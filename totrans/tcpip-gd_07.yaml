- en: Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分-4. 互联网协议版本 6 (IPV6)
- en: '[Chapter 24](ch24.html "Chapter 24. IPV6 OVERVIEW, CHANGES, AND TRANSITION")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 24 章](ch24.html "第 24 章. IPV6 概述、变更和过渡")'
- en: '[Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 25 章](ch25.html "第 25 章. IPV6 地址")'
- en: '[Chapter 26](ch26.html "Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 26 章](ch26.html "第 26 章. IPV6 数据报封装和格式")'
- en: '[Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY,
    AND ROUTING")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 27 章](ch27.html "第 27 章. IPV6 数据报大小、分片、重组和路由")'
- en: Since 1981, TCP/IP has been built on version 4 of the Internet Protocol (IPv4),
    discussed at length in the preceding part. IPv4 was created when the giant, worldwide
    Internet we take for granted today was just a small, experimental network. Considering
    how much the Internet has grown and changed over the course of two decades, IPv4
    has done its job admirably. At the same time, it has been apparent for many years
    that certain limitations in this venerable protocol would hold back the future
    growth of the Internet if they were not addressed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1981 年以来，TCP/IP 一直建立在互联网协议 (IPv4) 的第 4 版上，在前一部分中进行了详细讨论。IPv4 是在如今我们视为理所当然的全球互联网只是一个小型实验性网络的时候被创建的。考虑到互联网在二十年的时间里经历了多大的增长和变化，IPv4
    已经出色地完成了它的任务。同时，多年来，很明显，如果不对这个受人尊敬的协议中的某些限制进行解决，它们将阻碍互联网未来的增长。
- en: Due to the key role that IP plays, changing it is no simple feat. It means a
    substantial modification to the way that nearly everything in TCP/IP operates.
    However, even though we find change difficult, most of us know that it is necessary.
    For the past several years, development of a new version of IP has been under
    way, officially called *Internet Protocol version 6 (IPv6)* and also sometimes
    referred to as *IP Next Generation* or *IPng*. IPv6 is poised to take over for
    IPv4, and it will be the basis for the Internet of the future.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IP 扮演着关键角色，改变它是项艰巨的任务。这意味着对 TCP/IP 中几乎所有操作方式的重大修改。然而，尽管我们发现改变很难，但我们大多数人知道这是必要的。在过去几年里，IP
    的新版本的开发一直在进行中，官方称为 *互联网协议版本 6 (IPv6)*，有时也称为 *IP 下一个世代* 或 *IPng*。IPv6 准备取代 IPv4，并将成为未来互联网的基础。
- en: 'In this part, I provide a detailed description of IPv6\. Since IPv6 is still
    IP, just like IPv4, it performs the same functions: addressing, encapsulation,
    fragmentation and reassembly, and datagram delivery and routing. For this reason,
    this discussion of IPv6 is patterned after the discussion of IPv4\. There are
    four chapters: The first covers IPv6 concepts and issues; the second discusses
    IPv6 addressing; the third discusses IPv6 encapsulation and formatting; and the
    fourth discusses IPv6 datagram fragmentation, reassembly, and routing.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我提供了 IPv6 的详细描述。由于 IPv6 仍然是 IP，就像 IPv4 一样，它执行相同的函数：寻址、封装、分片和重组，以及数据报交付和路由。因此，关于
    IPv6 的讨论模仿了关于 IPv4 的讨论。共有四章：第一章涵盖 IPv6 概念和问题；第二章讨论 IPv6 寻址；第三章讨论 IPv6 封装和格式；第四章讨论
    IPv6 数据报分片、重组和路由。
- en: Since IPv6 represents the evolution of IP, many of its concepts of operation
    are built on those introduced in IPv4\. To avoid unnecessary duplication in this
    part, I've assumed you are familiar with the operation of IPv4, especially addressing
    and how datagrams are packaged and delivered. If you have not read [Part II-3](pt06.html
    "Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)"), reviewing it first would
    be wise, because the description of IPv6 focuses on how it differs from the current
    IP version.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IPv6 代表了 IP 的演变，许多操作概念都是建立在 IPv4 中引入的概念之上的。为了避免在本部分中不必要的重复，我假设您熟悉 IPv4 的操作，特别是地址以及数据报是如何封装和交付的。如果您还没有阅读[第二部分-3](pt06.html
    "第二部分-3. 互联网协议版本 4 (IP/IPV4)"), 首先复习它将是明智的，因为 IPv6 的描述重点在于它如何与当前的 IP 版本不同。
- en: You may also wish to refer to the [Part II-6](pt09.html "Part II-6. IP SUPPORT
    PROTOCOLS"), which covers the Internet Control Message Protocol (ICMP), part of
    which is ICMP version 6—ICMP for IPv6, and the IPv6 Neighbor Discovery (ND) protocol,
    since these are companions to IPv6.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以参考[第二部分-6](pt09.html "第二部分-6. IP 支持协议"), 其中涵盖了互联网控制消息协议 (ICMP)，其中一部分是 ICMP
    版本 6——IPv6 的 ICMP，以及 IPv6 邻居发现 (ND) 协议，因为这些是 IPv6 的伴侣。
- en: Chapter 24. IPV6 OVERVIEW, CHANGES, AND TRANSITION
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 24 章. IPV6 概述、变更和过渡
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Internet Protocol version 6 (IPv6) is destined to be the future of IP, and due
    to IP's critical importance, it will form the basis for the future of TCP/IP and
    the Internet as well. In fact, it's been under development since the middle of
    the last decade, and a real IPv6 internetwork has been used for testing for a
    number of years as well. Despite this, many people don't know much about IPv6,
    other than the fact that it's a newer version of IP. Some have never even heard
    of it at all! I'm going to rectify that, of course—but before I delve into the
    important changes made in IPv6 addressing, packaging, fragmentation, and other
    functions, let's start with a bird's-eye view of IPv6.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议版本6（IPv6）注定将成为IP的未来，由于IP的关键重要性，它将构成TCP/IP和互联网未来的基础。事实上，它自上上个十年中期以来一直在开发中，并且已经使用了多年的真实IPv6互连网络进行测试。尽管如此，许多人对于IPv6的了解并不多，除了它是一个IP的新版本之外。有些人甚至从未听说过它！当然，我将纠正这一点——但在深入探讨IPv6地址、封装、分片和其他功能的重要变化之前，让我们先从IPv6的鸟瞰图开始。
- en: In this chapter, I provide a brief higher-level overview of IPv6, including
    a look at how it differs from IP version 4 (IPv4) in general terms. I begin with
    a brief overview of IPv6 and why it was created. I list the major changes made
    in IPv6 and the new additions to the protocol. I also explain some of the difficulties
    associated with transitioning the enormous global Internet from IPv4 to IPv6.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提供了一个关于IPv6的简要高级概述，包括从一般意义上看它与IP版本4（IPv4）的不同之处。我首先简要概述了IPv6及其创建的原因。我列出了IPv6中做出的主要更改和协议的新增内容。我还解释了一些与从IPv4过渡到IPv6相关的困难。
- en: IPv6 Motivation and Overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 动机和概述
- en: '"If it ain''t broke, don''t fix it." This is one of my favorite pieces of folk
    wisdom. I generally like to stick with what works, as do most people. And IPv4
    works pretty darned well. It''s been around for decades now and has survived the
    growth of the Internet from a small research network into a globe-spanning powerhouse.
    So, like a trusty older car that you''ve operated successfully for years, why
    should you replace it if it still gets the job done?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “如果它没有坏，就别修它。”这是我非常喜欢的一句民间智慧。我通常喜欢坚持使用有效的方法，大多数人也是如此。IPv4运行得相当不错。它已经存在了几十年，并且随着互联网从小型研究网络发展到全球性的强大力量而幸存下来。所以，就像一辆你成功驾驶多年的可靠老车一样，如果它还能完成任务，为什么还要更换它呢？
- en: 'Like that older car, you could continue to use IPv4 for the foreseeable future.
    The question is: at what cost? An older car can be kept in good working order
    if you are willing to devote the time and money it takes to maintain and service
    it. However, it will still be limited in some of its capabilities. Its reliability
    may be suspect. It won''t have the latest features. With the exception of those
    who like to work on cars as a hobby, it eventually stops making sense to keep
    fixing up an older vehicle.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那辆老车一样，你可以在可预见的未来继续使用IPv4。问题是：这要付出什么代价？如果你愿意投入时间和金钱来维护和保养它，一辆老车可以保持良好的工作状态。然而，它的一些功能将受到限制。它的可靠性可能会受到怀疑。它不会有最新的功能。除了那些喜欢把汽车修理作为爱好的人之外，最终继续修复一辆老车是没有意义的。
- en: In some ways, this isn't that great of an analogy. Our highways aren't all that
    much different than they were in the 1970s, and most other issues related to driving
    a car haven't changed all that much in the past 25 years either. The choice of
    updating a vehicle or not is based on practical considerations more than necessity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这并不是一个很好的类比。我们的高速公路与20世纪70年代相比并没有太大的不同，而且与驾驶汽车相关的其他大多数问题在过去25年里也没有发生太大的变化。是否更新车辆的选择更多是基于实际考虑而非必要性。
- en: In contrast, look at what has happened to the computer and networking worlds
    in the last 25 years! Today's handheld PCs can do more than the most powerful
    servers could back then. Networking technologies are 100 or even 1,000 times as
    fast. The number of people connecting to the global Internet has increased by
    an even larger factor. And the ways that computers communicate have, in many cases,
    changed dramatically.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，看看在过去25年里计算机和网络世界发生了什么！今天的便携式电脑的功能比当时最强大的服务器还要多。网络技术速度提高了100倍甚至1000倍。连接到全球互联网的人数增加了更大的倍数。在许多情况下，计算机的通信方式也发生了巨大的变化。
- en: IPv4 could be considered in some ways like an older car that has been meticulously
    maintained and repaired over time. It gets the job done, but its age is starting
    to show. The main problem with IPv4 is its relatively small address space, a legacy
    of the decision to use only 32 bits for the IP address. Under the original classful
    addressing allocation scheme, we would have probably already run out of IPv4 addresses
    by now. Moving to classless addressing has helped postpone this, as have technologies
    like IP Network Address Translation (NAT), which allows privately addressed hosts
    to access the Internet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，IPv4可以被认为是一辆经过精心维护和修复的老车。它完成了工作，但它的年龄开始显现。IPv4的主要问题是其相对较小的地址空间，这是仅使用32位IP地址的决定的遗留问题。在原始的类地址分配方案下，我们可能已经用完了IPv4地址。迁移到无类地址分配有助于推迟这个问题，像IP网络地址转换（NAT）这样的技术也起到了作用，它允许私有地址的主机访问互联网。
- en: In the end, however, these represent patch jobs and imperfect repairs applied
    to keep the aging IPv4 automobile on the road. The core problem, the 32-bit address
    space that is too small for the current and future size of the Internet, can be
    solved only by moving to a larger address space. This was the primary motivating
    factor in creating the next version of IP, *IPv6*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，这些只是修补工作和不完美的修复，目的是为了保持老化的IPv4汽车在路上行驶。核心问题，即32位地址空间对于当前和未来互联网规模来说太小，只能通过迁移到更大的地址空间来解决。这是创建下一个版本IP，即*IPv6*的主要推动因素。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The reason why the successor to IPv4 is version 6 and not version 5 is because
    version number 5 was used to refer to an experimental protocol called the Internet
    Stream Protocol, which was never widely deployed. See [Chapter 15](ch15.html "Chapter 15. INTERNET
    PROTOCOL VERSIONS, CONCEPTS, AND OVERVIEW") for a full discussion of IP history
    and versions*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4的继任者版本是6而不是5的原因是因为版本号5被用来指代一个名为互联网流协议的实验性协议，该协议从未被广泛部署。有关IP历史和版本的完整讨论，请参见[第15章](ch15.html
    "第15章. 互联网协议版本、概念和概述")*。'
- en: IPv6 Standards
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6标准
- en: 'IPv6 represents the first major change to IP since IPv4 was formalized in 1981\.
    For many years, its core operation was defined in a series of RFCs published in
    1998: RFCs 2460 through 2467\. The most notable of these are the main IPv6 standard,
    RFC 2460, "Internet Protocol, Version 6 (IPv6) Specification," and documents describing
    the two helper protocols for IPv6: RFC 2461, which describes the IPv6 Neighbor
    Discovery Protocol (ND), and RFC 2463, which describes Internet Control Message
    Protocol version 6 (ICMPv6) for IPv6.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6代表了自1981年IPv4正式化以来IP的第一个重大变化。多年来，其核心操作在1998年发布的一系列RFC中定义：RFC 2460至RFC 2467。其中最值得注意的是主要的IPv6标准RFC
    2460，“互联网协议，版本6（IPv6）规范”，以及描述IPv6的两个辅助协议的文档：RFC 2461，描述了IPv6邻居发现协议（ND），和RFC 2463，描述了IPv6的互联网控制消息协议版本（ICMPv6）。
- en: 'In addition to these, two documents were also written in 1998\. They discuss
    more about IP addressing: RFC 2373, "IP Version 6 Addressing Architecture," and
    RFC 2374, "An IPv6 Aggregatable Global Unicast Address Format." Due to changes
    in how IPv6 addressing was to be implemented, these were updated in 2003 by RFC
    3513, "Internet Protocol Version 6 (IPv6) Addressing Architecture," and RFC 3587,
    "IPv6 Global Unicast Address Format."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，1998年还编写了两份文档。它们讨论了更多关于IP地址的内容：RFC 2373，“IP版本6地址架构”和RFC 2374，“IPv6可聚合全局单播地址格式”。由于IPv6地址实现方式的变化，这些文档在2003年由RFC
    3513，“互联网协议版本6（IPv6）地址架构”和RFC 3587，“IPv6全局单播地址格式”进行了更新。
- en: Many other RFCs define more specifics of how IPv6 works, and many also describe
    IPv6-compatible versions of other TCP/IP protocols like the Domain Name System
    (DNS; see [Chapter 52](ch52.html "Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW,
    FUNCTIONS, AND CHARACTERISTICS")) and Dynamic Host Control Protocol (DHCP; see
    [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS")).
    IPv6 is still very much a work in progress, with new standards being proposed
    and adopted on a regular basis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他RFC定义了IPv6如何工作的更多具体细节，许多也描述了IPv6兼容的其他TCP/IP协议版本，如域名系统（DNS；见[第52章](ch52.html
    "第52章. 域名系统（DNS）概述、功能和特性"））和动态主机控制协议（DHCP；见[第61章](ch61.html "第61章. DHCP概述和地址分配概念"））。IPv6仍然是一个非常正在进行中的工作，新的标准正在定期提出并被采纳。
- en: 'Because IPv6 is the version of IP that''s designed for the next generation
    of the Internet, it is also sometimes called *IP Next Generation* or *IPng*. Personally,
    I don''t care for this name; it reminds me too much of *Star Trek: The Next Generation*.
    Regardless of its name, IPv6 or IPng was designed to take TCP/IP and the Internet
    "where none have gone before." (Sorry, I *had* to!)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IPv6是为下一代互联网设计的IP版本，因此有时也被称为**IP下一代**或**IPng**。我个人并不喜欢这个名字；它让我想起了太多的**星际迷航：下一代**。无论其名称如何，IPv6或IPng都是为了将TCP/IP和互联网带到“无人去过的地方”。（抱歉，我**不得不**这么说！）
- en: Design Goals of IPv6
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6的设计目标
- en: The problem of addressing was the main motivation for creating IPv6\. Unfortunately,
    this has caused many people to think that the address space expansion is the *only*
    change made in IP, which is definitely not the case. Since making a change to
    IP is such a big deal, it's something done rarely. It made sense to correct not
    just the addressing issue, but also to update the protocol in a number of other
    respects in order to ensure its viability. In fact, even the addressing changes
    in IPv6 go far beyond just adding more bits to IP address fields.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 地址问题成为创建IPv6的主要动机。不幸的是，这导致许多人认为地址空间扩展是IP中**唯一**的变更，这显然不是事实。由于对IP的任何变更都是一件大事，因此这种变更很少发生。纠正地址问题是有意义的，同时也要在许多其他方面更新协议，以确保其可行性。实际上，IPv6中的地址变更远远超出了仅仅增加IP地址字段中的位数。
- en: 'Some of the most important goals in designing IPv6 include the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计IPv6时，一些最重要的目标包括以下内容：
- en: '**Larger Address Space** IPv6 needed to provide more addresses for the growing
    Internet.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**更大的地址空间** IPv6需要为不断增长的互联网提供更多的地址。'
- en: '**Better Management of Address Space** Developers wanted IPv6 to include not
    only more addresses, but also a more capable way of dividing the address space
    and using the bits in each address.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的地址空间管理** 开发者希望IPv6不仅包含更多的地址，而且还要包含一种更强大的方式来划分地址空间和使用每个地址中的位。'
- en: '**Elimination of Addressing Kludges** Technologies like NAT are effectively
    kludges that make up for the lack of address space in IPv4\. IPv6 eliminates the
    need for NAT and similar work-arounds, allowing every TCP/IP device to have a
    public address.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**消除地址问题解决方案** 像NAT这样的技术实际上是弥补IPv4地址空间不足的权宜之计。IPv6消除了对NAT和类似解决方案的需求，使得每个TCP/IP设备都能拥有一个公网地址。'
- en: '**Easier TCP/IP Administration** The designers of IPv6 hoped to resolve some
    of the current labor-intensive requirements of IPv4, such as the need to configure
    IP addresses. Even though tools like DHCP eliminate the need to manually configure
    many hosts, it only partially solves the problem.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**简化TCP/IP管理** IPv6的设计者希望解决IPv4中一些当前劳动密集型要求，例如配置IP地址的需求。尽管像DHCP这样的工具消除了手动配置许多主机地址的需求，但它只部分解决了问题。'
- en: '**Modern Design for Routing** In contrast to IPv4, which was designed before
    anyone had an idea what the modern Internet would be like, IPv6 was created specifically
    for efficient routing in the current Internet, and with the flexibility for the
    future.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**现代路由设计** 与IPv4不同，IPv4是在没有人想到现代互联网会是什么样子的时候设计的，IPv6是为了在当前互联网中实现高效路由而专门创建的，并且具有对未来灵活性的考虑。'
- en: '**Better Support for Multicasting** Multicasting was an option in IPv4 from
    the start, but support for it has been slow in coming.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的多播支持** 多播在IPv4中从一开始就是一项选项，但对它的支持进展缓慢。'
- en: '**Better Support for Security** IPv4 was designed at a time when security wasn''t
    much of an issue because there were a relatively small number of networks on the
    Internet, and those networks'' administrators often knew each other. Today, security
    on the public Internet is a big issue, and the future success of the Internet
    requires that security concerns be resolved.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的安全性支持** IPv4是在网络安全不是一个大问题的时候设计的，因为互联网上的网络相对较少，而且那些网络的管理员通常互相认识。今天，公共互联网上的安全问题是一个大问题，而互联网未来的成功需要解决安全担忧。'
- en: '**Better Support for Mobility** When IPv4 was created, there really was no
    concept of mobile IP devices. The problems associated with computers that move
    between networks led to the need for Mobile IP. IPv6 builds on Mobile IP and provides
    mobility support within IP itself.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的移动性支持** 当IPv4被创建时，实际上并没有移动IP设备的概念。计算机在网络上移动所引起的问题导致了移动IP的需求。IPv6建立在移动IP的基础上，并在IP本身内提供了移动性支持。'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The new version of the IP is *Internet Protocol version 6 (IPv6)*.
    It was created to correct some of the significant problems of IPv4, especially
    the looming deficiency of the IPv4 address space, to improve the operation of
    the protocol as a whole, and to take TCP/IP into the future.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 新版本的IP是*互联网协议版本6 (IPv6)*。它是为了纠正IPv4的一些重大问题而创建的，特别是IPv4地址空间即将出现的不足，以提高整个协议的操作，并将TCP/IP带入未来。'
- en: At the same time that IPv6 was intended to address these and many other issues
    with traditional IP, its changes are nevertheless *evolutionary*, not *revolutionary*.
    During the many discussions in the Internet Engineering Task Force (IETF) in the
    1990s, there were some who said that while we were updating IP, perhaps we should
    make a complete, radical change to a new type of internetworking protocol completely.
    The end decision was not to do this, but to define a more capable version of the
    IP that we've been using all along.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6旨在解决这些问题以及许多其他传统IP问题的同时，其变化仍然是*渐进的*，而不是*革命性的*。在20世纪90年代互联网工程任务组（IETF）的许多讨论中，有些人说，当我们更新IP时，也许我们应该对一种全新的、未经证实的互联网互连协议进行彻底、根本的改变。最终的决定不是这样做，而是定义一个更强大的IP版本，这是我们一直在使用的。
- en: 'The reason for this is simple: IP, like our trusted older car, *works*. IPv6
    represents an update that strives to add to the best characteristics of IPv4,
    rather than making everyone start over from scratch with something new and unproven.
    This design ensures that whatever pain may result from the change from IPv4 to
    IPv6 can be managed, and hopefully, minimized.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：IP，就像我们信任的旧车一样，*工作得很好*。IPv6代表了一个更新，它努力增加IPv4的最佳特性，而不是让每个人都从头开始使用一些新事物。这种设计确保了从IPv4到IPv6的任何变化带来的痛苦都可以得到管理，并且希望最小化。
- en: Major Changes and Additions in IPv6
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6中的主要变化和新增功能
- en: In the preceding overview, I explained that the primary motivation for creating
    a new version of IP was to fix the problems with addressing under IPv4\. But as
    you also saw, numerous other design goals existed for the new protocol as well.
    Once the decision was made to take the significant step of creating a new version
    of a protocol as important as IP, it made sense to use the opportunity to make
    as many improvements as possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的概述中，我解释了创建新的IP版本的主要动机是为了解决IPv4地址分配中的问题。但正如您所看到的，新协议也存在许多其他设计目标。一旦决定采取创建一个像IP一样重要的协议新版本的这一重大步骤，就有必要利用这个机会尽可能地进行改进。
- en: 'Of course, there is still the problem of the pain of change to worry about,
    so each potential change or addition in IPv6 needed to have benefits that would
    outweigh its costs. The resulting design does a good job of providing useful advantages
    while maintaining most of the core of the original IP. The following are some
    of the most important changes between IPv4 and IPv6, and they demonstrate some
    of the ways that the IPv6 team met the design goals for the new protocol:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要担心改变带来的痛苦，因此IPv6中的每个潜在变化或新增功能都需要有超过其成本的益处。最终的设计在提供有用优势的同时，保持了原始IP的大部分核心。以下是IPv4和IPv6之间的一些最重要的变化，它们展示了IPv6团队如何满足新协议的设计目标：
- en: '**Larger Address Space** IPv6 addresses are 128 bits long instead of 32 bits.
    This expands the address space from around 4 billion addresses to, well, an astronomical
    number (over 300 trillion trillion trillion addresses).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**更大的地址空间** IPv6地址长度为128位，而不是32位。这把地址空间从大约40亿个地址扩展到了，嗯，天文数字（超过300万亿万亿万亿个地址）。'
- en: '**Hierarchical Address Space** One reason why the IPv6 address size was expanded
    so much was to allow it to be hierarchically divided to provide a large number
    of many classes of addresses.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**分层地址空间** IPv6地址大小之所以扩大这么多，一个原因是为了允许它进行分层划分，从而提供大量不同类别的地址。'
- en: '**Hierarchical Assignment of Unicast Addresses** A special global unicast address
    format was created to allow addresses to be easily allocated across the entire
    Internet. It allows for multiple levels of network and subnetwork hierarchies
    at both the Internet service provider (ISP) and the organizational level. It also
    permits the generation of IP addresses based on underlying hardware interface
    device IDs such as Ethernet MAC addresses.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**单播地址的分层分配** 创建了一种特殊的全局单播地址格式，以便在整个互联网上轻松分配地址。它允许在互联网服务提供商（ISP）和组织级别上实现多级网络和子网层次结构。它还允许根据底层硬件接口设备ID（如以太网MAC地址）生成IP地址。'
- en: '**Better Support for Nonunicast Addressing** Support for multicasting is improved,
    and support for a new type of addressing, *anycast* addressing, has been added.
    This new kind of addressing basically says, "Deliver this message to the easiest-to-reach
    member of this group," and potentially enables new types of messaging functionality.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**对非单播寻址的支持得到改善** 多播支持得到改进，并增加了对一种新型寻址方式的支持，即*任播*寻址。这种新型的寻址方式基本上意味着，“将此消息发送到这个群体中最容易到达的成员”，并可能启用新的消息功能。'
- en: '**Autoconfiguration and Renumbering** A provision is included to allow easier
    autoconfiguration of hosts and renumbering of the IP addresses in networks and
    subnetworks as needed. A technique also exists for renumbering router addresses.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动配置和重新编号** 包含了一项规定，允许在需要时更容易地自动配置主机以及重新编号网络和子网络中的IP地址。同时，也存在一种重新编号路由器地址的技术。'
- en: '**New Datagram Format** The IP datagram format has been redefined and given
    new capabilities. The main header of each IP datagram has been streamlined, and
    support has been added for the ability to easily extend the header for datagrams
    that require more control information.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**新的数据报格式** IP数据报格式已被重新定义并赋予了新的功能。每个IP数据报的主要头部已被简化，并增加了对数据报扩展头部的支持，以便于扩展需要更多控制信息的头部。'
- en: '**Support for Quality of Service (QoS)** IPv6 datagrams include QoS features
    that allow for better support for multimedia and other applications that require
    QoS.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**对服务质量（QoS）的支持** IPv6数据报包括QoS特性，这有助于更好地支持多媒体和其他需要QoS的应用。'
- en: '**Security Support** Security support is designed into IPv6 using the authentication
    and encryption extension headers and other features.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全支持** 在IPv6中，通过使用认证和加密扩展头以及其他特性，设计进了安全支持。'
- en: '**Updated Fragmentation and Reassembly Procedures** The way that the fragmentation
    and reassembly of datagrams works has been changed in IPv6\. The improved routing
    efficiency better reflects the realities of today''s networks.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新的分片和重组过程** 在IPv6中，数据报的分片和重组工作方式已经改变。改进的路由效率更好地反映了当今网络的实际情况。'
- en: '**Modernized Routing Support** IPv6 is designed to support modern routing systems
    and allow for expansion as the Internet grows.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**现代化的路由支持** IPv6被设计成支持现代化的路由系统，并允许随着互联网的增长而进行扩展。'
- en: '**Transition Capabilities** Since it was recognized from the start that going
    from IPv4 to IPv6 is a big move, support for the IPv4/IPv6 transition has been
    provided in numerous areas. This includes a plan for interoperating IPv4 and IPv6
    networks, for mapping between IPv4 and IPv6 addresses, and other transition support.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**过渡能力** 由于从一开始就认识到从IPv4过渡到IPv6是一个重大的转变，因此在多个领域提供了IPv4/IPv6过渡的支持。这包括IPv4和IPv6网络互操作的计划、IPv4和IPv6地址之间的映射以及其他过渡支持。'
- en: '**Changes to Other Protocols** With the introduction of IPv6, several other
    TCP/IP protocols that deal intimately with IP have also had to be updated. One
    of these is ICMP, the most important support protocol for IPv4, which has been
    revised through the creation of ICMPv6 for IPv6\. An addition to TCP/IP is the
    ND protocol, which performs several functions for IPv6 that were done by the Address
    Resolution Protocol (ARP) and ICMP in version 4.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**对其他协议的更改** 随着IPv6的引入，一些与IP密切相关的其他TCP/IP协议也必须进行更新。其中之一是ICMP，它是IPv4最重要的支持协议，通过创建ICMPv6来对IPv6进行修订。TCP/IP的补充是ND协议，它执行了IPv6中由版本4的地址解析协议（ARP）和ICMP执行的多个功能。'
- en: The following chapters on IPv6 provide much more detail on these changes and
    additions to IP. You'll notice that the majority of these are related to addressing,
    because that is where the greatest number of important changes were made in IPv6\.
    Of course, routing and addressing are closely related, and the changes to addressing
    have had a big impact on routing as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关于IPv6的章节提供了更多关于这些变化和IP新增功能的具体细节。你会注意到，其中大部分都与寻址相关，因为IPv6中最重要的变化就是在寻址方面。当然，路由和寻址是紧密相关的，寻址的变化也对路由产生了重大影响。
- en: Transition from IPv4 to IPv6
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从IPv4到IPv6的过渡
- en: IP is the foundation of the TCP/IP protocol suite and the Internet, and thus
    it's somewhat comparable to the foundation of a house in terms of its structural
    importance. Given this, changing IP is somewhat analogous to making a substantial
    modification to the foundation of your house. Since IP is used to connect together
    many devices, it is like changing not just your house, but every house in the
    world!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: IP是TCP/IP协议套件和互联网的基础，因此在结构重要性方面与房子的基础有些类似。鉴于这一点，改变IP就像对房子的基础进行重大修改一样。由于IP用于连接许多设备，这就意味着不仅仅是改变你的房子，而是改变世界上每一座房子！
- en: How do you change the foundation of a house? Very carefully. The same caution
    is required with the implementation of IPv6\. While most people think IPv6 is
    something new, the reality is that the planning and development of IPv6 has been
    underway for nearly a full decade, and if we were starting from scratch, the protocol
    would have been ready for action years ago. However, there is a truly enormous
    installed base of IPv4 hardware and software. This means the folks who develop
    TCP/IP could not just flip a switch and have everyone move over to using IPv6\.
    Instead, a *transition* from IPv4 to IPv6 had to be planned.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何改变房子的基础？非常小心。在实施IPv6时也需要同样的谨慎。虽然大多数人认为IPv6是件新鲜事，但实际情况是IPv6的计划和开发已经进行了近十年，如果我们从头开始，这个协议多年前就已经可以投入使用。然而，IPv4的硬件和软件安装基础非常庞大。这意味着开发TCP/IP的人们不能只是打开一个开关，让所有人都转向使用IPv6。相反，必须计划从IPv4向IPv6的过渡。
- en: The transition is already under way, though most people don't know about it.
    As I said, development of IPv6 itself is pretty much complete, though work continues
    on refining the protocol and also on the development of IPv6-compatible versions
    of other protocols. The implementation of IPv6 began with the creation of development
    networks to test IPv6's operation. These were connected together to form an experimental
    IPv6 internetwork called the *6BONE* (which is a contraction of the phrase *IPv6
    backbone*). This internetwork has been in operation for several years.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 转型已经开始，尽管大多数人还不知道这一点。正如我所说，IPv6本身的发展几乎已经完成，尽管仍在继续完善协议以及开发其他协议的IPv6兼容版本。IPv6的实施始于创建开发网络以测试IPv6的运行。这些网络相互连接，形成了一个名为*6BONE*（该名称是*IPv6骨干*的缩写）的实验性IPv6互联网。这个互联网已经运行了好几年。
- en: 'IPv4 to IPv6 Transition: Differences of Opinion'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv4到IPv6的过渡：意见分歧
- en: Experimental networks are well and good, but the big issue is transitioning
    the Internet to IPv6, and here, opinion diverges rather quickly. In one camp are
    the corporations, organizations, and individuals. All of these groups are quite
    eager to transition to IPv6 quickly in order to gain the many benefits it promises
    in the areas of addressing, routing, and security. Others are taking a much more
    cautious approach, noting that the dire predictions in the mid-1990s of IPv4's
    imminent doom have not come to pass, and arguing that we should take our time
    to make sure IPv6 is going to work on a large scale.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实验性网络是很好的，但大问题是将互联网过渡到IPv6，在这里，意见分歧相当快。一方面有公司、组织和个人。所有这些群体都迫切希望快速过渡到IPv6，以获得它在寻址、路由和安全领域承诺的许多好处。另一方面的人则采取了一种更加谨慎的方法，指出1990年代中期对IPv4即将灭亡的悲观预测并没有成真，并认为我们应该花时间确保IPv6能够在大规模上运行。
- en: These two groups will continue to play tug-of-war for the next few years, but
    it seems that the tide is now turning toward those who want to speed up the now-years-long
    transition. The move toward adoption of IPv6 as a *production* protocol is being
    spearheaded by a number of groups and organizations. IPv6 has a lot of support
    in areas outside the United States, many of which are running short of IPv4 addresses
    due to small allocations relative to their size. One such area is Asia, a region
    with billions of people, rapidly growing Internet use, and a shortage of IPv4
    addresses.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这两组人将在接下来的几年里继续进行拔河比赛，但看起来现在潮流正在转向那些希望加快现在已持续多年的过渡的人。将IPv6作为*生产*协议的采用正在由多个团体和组织领导。IPv6在除美国以外的许多地区都得到了很多支持，这些地区由于相对于其规模的小额分配而IPv4地址短缺。亚洲就是这样一片地区，拥有数十亿人口，互联网使用快速增长，IPv4地址短缺。
- en: Within the United States, which has the lion's share of IPv4 addresses (because
    the Internet was developed here), there seems to be a bit less enthusiasm for
    rapid IPv6 deployment. Even here, however, IPv6 got a major shot in the arm in
    July 2003 when the United States Department of Defense (DoD) announced that starting
    in October of that year, it would purchase only networking products that included
    compatibility with IPv6\. The DoD (which was responsible for the development of
    the Internet in the first place) hopes to be fully transitioned to IPv6 by 2008\.
    This will likely have a big impact on the plans of other governmental and private
    organizations in the United States.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国，由于互联网在这里开发，拥有大部分IPv4地址（因为互联网在这里开发），对于快速部署IPv6似乎有点不太热情。然而，即使在这里，IPv6在2003年7月也获得了重大推动，当时美国国防部（DoD）宣布，从那年10月开始，它将只购买包含IPv6兼容性的网络产品。DoD（最初负责互联网的发展）希望到2008年完全过渡到IPv6。这可能会对其他美国政府和私营组织的计划产生重大影响。
- en: The creators of IPv6 knew from the start that transition was going to be an
    important issue with the new protocol. IPv6 is not compatible with IPv4 because
    the addressing system and datagram format are different. Yet the IPv6 designers
    knew that since the transition would take many years, it was necessary that they
    provide a way for IPv4 and IPv6 hosts to interoperate. Consider that in any transition
    there are always stragglers. Like the old Windows 3.11 PC in the corner that you
    still need to use once in a while, some devices will remain on IPv4, even when
    most of the Internet is IPv6, because they were never upgraded.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6的创造者从一开始就知道，过渡将是新协议的一个重要问题。IPv6与IPv4不兼容，因为地址系统和数据报格式不同。然而，IPv6的设计者知道，由于过渡将需要很多年，他们必须提供一种方法，使IPv4和IPv6宿主机能够互操作。考虑到在任何过渡中，总会有一些落后者。就像角落里那个你偶尔还需要使用的旧Windows
    3.11 PC一样，一些设备将保持使用IPv4，即使大部分互联网都是IPv6，因为它们从未升级。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Due to the many differences between IPv4 and IPv6, and the
    fundamental importance of IP to TCP/IP, an orderly transition has been planned
    from IPv4 to IPv6 over a period of many years.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于IPv4和IPv6之间存在许多差异，以及IP对TCP/IP的基本重要性，因此已经计划在多年内从IPv4到IPv6进行有序过渡。'
- en: IPv4 to IPv6 Transition Methods
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv4到IPv6过渡方法
- en: 'The IETF has been working on specific provisions to allow a smooth transition
    from IPv4 to IPv6, and hardware and software interoperability solutions to let
    newer IPv6 devices access IPv4 hosts. A technique was included in IPv6 to allow
    administrators to embed IPv4 addresses within IPv6 addresses. Special methods
    are defined to handle interoperability, including the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: IETF一直在制定具体规定，以允许从IPv4到IPv6的平稳过渡，以及硬件和软件互操作性解决方案，以便新的IPv6设备能够访问IPv4宿主机。IPv6中包含了一种技术，允许管理员在IPv6地址中嵌入IPv4地址。定义了特殊方法来处理互操作性，包括以下内容：
- en: '**Dual-Stack Devices** Routers and some other devices may be programmed with
    both IPv4 and IPv6 implementations to allow them to communicate with both types
    of hosts.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**双栈设备** 路由器和其他一些设备可能被编程为同时支持IPv4和IPv6的实现，以便它们能够与这两种类型的宿主机进行通信。'
- en: '**IPv4/IPv6 Translation** Dual-stack devices may be designed to accept requests
    from IPv6 hosts, convert them to IPv4 datagrams, send the datagrams to the IPv4
    destination, and then process the return datagrams similarly.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPv4/IPv6转换** 双栈设备可能被设计为接受来自IPv6宿主机的请求，将它们转换为IPv4数据报，然后将数据报发送到IPv4目的地，并类似地处理返回的数据报。'
- en: '**IPv4 Tunneling of IPv6** IPv6 devices that don''t have a path between them
    consisting entirely of IPv6-capable routers may be able to communicate by encapsulating
    IPv6 datagrams within IPv4\. In essence, they would be using IPv6 on top of IPv4;
    that is, two network layers. The encapsulated IPv4 datagrams would travel across
    conventional IPv4 routers.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPv6的IPv4隧道** 没有完全由支持IPv6的路由器组成的路径的IPv6设备可能能够通过封装IPv6数据报在IPv4中来进行通信。本质上，它们将使用IPv6在IPv4之上；也就是说，两个网络层。封装的IPv4数据报将穿越传统的IPv4路由器。'
- en: Bear in mind that these solutions generally address only backward compatibility
    to allow IPv6 devices to talk to IPv4 hardware. Forward compatibility between
    IPv4 and IPv6 is not possible because IPv4 hosts cannot communicate with IPv6
    hosts; they lack the knowledge of how IPv6 works. It is possible that certain
    special adaptations might be created to allow IPv4 hosts to access IPv6 hosts.
    But eventually, all IPv4 devices of any importance will want to migrate to IPv6.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些解决方案通常仅解决向后兼容性问题，以允许 IPv6 设备与 IPv4 硬件通信。IPv4 和 IPv6 之间的向前兼容性是不可能的，因为 IPv4
    主机无法与 IPv6 主机通信；它们缺乏了解 IPv6 如何工作的知识。可能某些特殊的适应性可能会被创建，以允许 IPv4 主机访问 IPv6 主机。但最终，所有重要的
    IPv4 设备都将希望迁移到 IPv6。
- en: The IETF has done such a good job in the past with introducing new technologies,
    and so much effort has been put into the IPv6 transition, that I am quite confident
    that the transition to IPv6 will come off with few, if any, problems. One good
    thing about the transition is that IPv4 is, at the present time, still getting
    the job done, so there is no big hurry to make the move to IPv6\. While technologies
    such as CIDR and NAT are like Band-Aids on IPv4, they have been very successful
    ones in extending the useful life of the aging protocol.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网工程任务组 (IETF) 在过去在引入新技术方面做得很好，并且在 IPv6 转型方面投入了大量的努力，因此我对 IPv6 转型能够顺利实施，几乎没有问题，非常有信心。关于转型的一个好处是，IPv4
    在目前仍然能够完成任务，因此没有必要急于转向 IPv6。虽然像 CIDR 和 NAT 这样的技术就像是 IPv4 的创可贴，但它们在延长这个老协议的有效寿命方面非常成功。
- en: Chapter 25. IPV6 ADDRESSING
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 25 章。IPv6 寻址
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The primary motivation for creating Internet Protocol version 6 (IPv6) was to
    rectify the addressing problems in version 4 (IPv4). Along with acquiring more
    addresses, the IPv6 designers desired a way of interpreting, assigning, and using
    addresses in a way that was more consonant with modern internetworking. So, it's
    no surprise that many of the changes in IPv6 are associated with IP addressing.
    The IPv6 addressing scheme is similar in concept to IPv4 addressing, but has been
    completely overhauled to create an addressing system that's capable of supporting
    continued Internet expansion and new applications for the foreseeable future.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建互联网协议版本 6 (IPv6) 的主要动机是为了纠正版本 4 (IPv4) 中的寻址问题。除了获取更多地址外，IPv6 设计者还希望找到一种方式，以更符合现代互联网的方式解释、分配和使用地址。因此，IPv6
    中许多变化都与 IP 寻址相关。IPv6 寻址方案在概念上与 IPv4 寻址方案相似，但已经完全重新设计，以创建一个能够支持未来可预见的互联网扩展和新应用的寻址系统。
- en: This chapter describes the concepts and methods associated with addressing under
    IPv6\. I begin with a look at some addressing generalities in IPv6, including
    the addressing model, address types' size, and address space. I discuss the unique
    and sometimes confusing representations and notations used for IPv6 addresses
    and prefixes. Then I look at how addresses are arranged and allocated into types,
    beginning with an overall look at address space composition and then at the global
    unicast address format. I describe the new methods used for mapping IP addresses
    to underlying physical network addresses. I then describe special IPv6 addressing
    issues, including reserved and private addresses, IPv4 address embedding, anycast
    and multicast addresses, and autoconfiguration and renumbering of addresses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了与 IPv6 寻址相关的概念和方法。我首先回顾了 IPv6 中的一些寻址一般性内容，包括寻址模型、地址类型的大小和地址空间。我讨论了用于 IPv6
    地址和前缀的独特和有时令人困惑的表示法和符号。然后，我探讨了地址是如何安排和分配到不同类型的，从整体上查看地址空间组成开始，然后是全局单播地址格式。我描述了用于将
    IP 地址映射到底层物理网络地址的新方法。然后，我描述了特殊的 IPv6 寻址问题，包括保留地址和私有地址、IPv4 地址嵌入、任播和多播地址，以及地址的自动配置和重新编号。
- en: 'Addressing under IPv6 is outlined in the main IPv6 RFC, RFC 2460, "Internet
    Protocol, Version 6 (IPv6) Specification." However, most of the details of IPv6
    addressing are contained in two other standards: RFC 3513, "Internet Protocol
    Version 6 (IPv6) Addressing Architecture," and RFC 3587, "IPv6 Global Unicast
    Address Format." These replaced the 1998 standards RFC 2373, "IP Version 6 Addressing
    Architecture," and RFC 2374, "An IPv6 Aggregatable Global Unicast Address Format."'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址分配在主要的IPv6 RFC 2460中进行了概述，即“互联网协议，版本6（IPv6）规范”。然而，IPv6地址的大部分细节包含在其他两个标准中：RFC
    3513，“互联网协议版本6（IPv6）地址架构”和RFC 3587，“IPv6全局单播地址格式”。这些标准取代了1998年的RFC 2373，“IP版本6地址架构”和RFC
    2374，“IPv6可聚合全局单播地址格式”。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *As with the other IPv6 chapters in this book, my
    look at addressing is based somewhat on a contrast to how addressing is done in
    IPv4\. I strongly recommend a thorough understanding of IPv4 addressing, including
    classless addressing using Classless Inter-Domain Routing (CIDR), as presented
    in Chapters [Chapter 16](ch16.html "Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES")
    through [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING"), before
    proceeding here. As with the IPv4 addressing sections, familiarity with how binary
    numbers work, and conversion between binary and decimal numbers is also a good
    idea. [Chapter 4](ch04.html "Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE
    MATHEMATICS OF COMPUTING"), which provides some background on data representation
    and the mathematics of computing, may be of assistance in that respect*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *与其他本书中的IPv6章节一样，我对地址分配的探讨在一定程度上是基于与IPv4地址分配方式的对比。我强烈建议在继续阅读之前，对IPv4地址分配有一个全面的理解，包括使用无类域间路由（CIDR）的无类地址分配，如第[第16章](ch16.html
    "第16章. IPv4地址概念和问题")至[第23章](ch23.html "第23章. IP路由和多播")所述。与IPv4地址分配部分一样，了解二进制数的工作原理以及二进制与十进制数之间的转换也是很好的主意。[第4章](ch04.html
    "第4章. 数据表示和计算数学的回顾")提供了关于数据表示和计算数学的一些背景信息，可能在这方面有所帮助*。'
- en: 'IPv6 Addressing Overview: Addressing Model, Address Types, and Address Size'
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6地址概述：地址模型、地址类型和地址大小
- en: As you saw in the previous chapter, IPv6 represents a significant update to
    IP, but its modifications and additions are made without changing the core nature
    of how IP works. Addressing is the place where most of the differences between
    IPv4 and IPv6 are seen, but the changes are mostly in how addresses are implemented
    and used. The overall model used for IP addressing in IPv6 is pretty much the
    same as it was in IPv4; some aspects have not changed at all, while others have
    changed only slightly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，IPv6对IP协议进行了重大更新，但其修改和新增内容并未改变IP工作的核心本质。地址分配是IPv4和IPv6之间大部分差异体现的地方，但这些变化主要在于地址的实现和使用方式。IPv6中用于IP地址分配的整体模型与IPv4中的非常相似；一些方面完全没有变化，而其他方面则只有轻微的变化。
- en: IPv6 Addressing Model Characteristics
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6地址模型特性
- en: 'Here are some of the general characteristics of the IPv6 addressing model that
    are basically the same as in IPv4:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些IPv6地址模型的一般特性，这些特性基本上与IPv4相同：
- en: '**Core Functions of Addressing** The two main functions of addressing are still
    network interface identification and routing. Routing is facilitated through the
    structure of addresses on the internetwork.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址的核心功能** 地址的两个主要功能仍然是网络接口标识和路由。路由通过互联网上地址的结构来实现。'
- en: '**Network Layer Addressing** IPv6 addresses are still the ones associated with
    the network layer in TCP/IP networks and are distinct from data link layer (also
    sometimes called *physical*) addresses.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络层地址** IPv6地址仍然是与TCP/IP网络中的网络层相关联的地址，并且与数据链路层（有时也称为*物理层*）地址不同。'
- en: '**Number of IP Addresses per Device** Addresses are still assigned to network
    interfaces, so a regular host like a PC will usually have one (unicast) address,
    and routers will have more than one for each of the physical networks to which
    it connects.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**每台设备的IP地址数量** 地址仍然分配给网络接口，因此像PC这样的普通主机通常只有一个（单播）地址，而路由器将为其连接的每个物理网络分配多个地址。'
- en: '**Address Interpretation and Prefix Representation** IPv6 addresses are like
    classless IPv4 addresses in that they are interpreted as having a network identifier
    part and a host identifier part (a network ID and a host ID), but that the delineation
    is not encoded into the address itself. A prefix-length number, using CIDR-like
    notation, is used to indicate the length of the network ID (prefix length).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址解释和前缀表示** IPv6地址与无类IPv4地址类似，它们被解释为具有网络标识符部分和主机标识符部分（网络ID和主机ID），但这种划分并没有编码到地址本身中。使用类似CIDR的表示法，一个前缀长度数字用来指示网络ID的长度（前缀长度）。'
- en: '**Private and Public Addresses** Both types of addresses exist in IPv6, though
    they are defined and used somewhat differently.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有地址和公有地址** 在IPv6中，这两种类型的地址都存在，尽管它们的定义和使用方式有所不同。'
- en: IPv6 Supported Address Types
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6支持地址类型
- en: 'One important change in the addressing model of IPv6 is the *address types*
    supported. IPv4 supported three address types: unicast, multicast, and broadcast.
    Of these, the vast majority of actual traffic was unicast. IP multicast support
    was not widely deployed until many years after the Internet was established and
    it continues to be hampered by various issues. Use of broadcast in IP had to be
    severely restricted for performance reasons (we don''t want any device to be able
    to broadcast across the entire Internet!).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6寻址模型中的一个重要变化是支持的*地址类型*。IPv4支持三种地址类型：单播、多播和广播。在这些类型中，绝大多数实际流量是单播。IP多播支持直到互联网建立多年后才得到广泛部署，并且由于各种问题而继续受到阻碍。出于性能原因，IP中的广播使用必须受到严格限制（我们不希望任何设备能够在整个互联网上广播！）。
- en: 'IPv6 also supports three address types, but with the following changes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6也支持三种地址类型，但有以下变化：
- en: '**Unicast Addresses** These are standard unicast addresses as in IPv4, one
    per host interface.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**单播地址** 这些是IPv4中的标准单播地址，每个主机接口一个。'
- en: '**Multicast Addresses** These are addresses that represent various groups of
    IP devices. A message sent to a multicast address goes to all devices in the group.
    IPv6 includes much better multicast features and many more multicast addresses
    than IPv4\. Since multicast under IPv4 was hampered in large part due to lack
    of support of the feature by many hardware devices, support for multicasting is
    a required, not optional, part of IPv6.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播地址** 这些是代表各种IP设备组的地址。发送到多播地址的消息将发送到组中的所有设备。IPv6包括比IPv4更好的多播功能和更多的多播地址。由于IPv4下的多播在很大程度上受到许多硬件设备不支持该特性的阻碍，因此多播支持是IPv6的一个必需部分，而不是一个可选部分。'
- en: '**Anycast Addresses** Anycast addressing is used when a message must be sent
    to any member of a group, but does not need to be sent to all of them. Usually
    the member of the group that is easiest to reach will be sent the message. One
    common example of how anycast addressing could be used is in load sharing among
    a group of routers in an organization.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**任播地址** 任播寻址用于必须将消息发送到组中的任何一个成员，但不需要发送给所有成员的情况。通常，最容易到达的组成员将接收该消息。任播寻址的一个常见例子是在组织中的一组路由器之间进行负载均衡。'
- en: Broadcast addressing as a distinct addressing method is gone in IPv6\. Broadcast
    functionality is implemented using multicast addressing to groups of devices.
    A multicast group to which all nodes belong can be used for broadcasting in a
    network, for example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中，作为独立寻址方法的广播寻址已经消失。广播功能是通过多播寻址到设备组来实现的。例如，一个所有节点都属于的多播组可以用于网络中的广播。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** IPv6 has unicast and multicast addresses like IPv4\. There
    is, however, no distinct concept of a broadcast address in IPv6\. A new type of
    address, *the anycast* address, has been added to allow a message to be sent to
    any one member of a group of devices.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6像IPv4一样具有单播和多播地址。然而，IPv6中并没有广播地址的独立概念。为了允许消息发送到设备组中的任何一个成员，增加了一种新的地址类型，即*任播*地址。'
- en: An important implication of the creation of anycast addressing is removal of
    the strict uniqueness requirement for IP addresses. Anycast is accomplished by
    assigning the same IP address to more than one device. The devices must also be
    specifically told that they are sharing an anycast address, but the addresses
    themselves are structurally the same as unicast addresses.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 任播地址的创建的一个重要含义是消除了IP地址的严格唯一性要求。任播是通过将相同的IP地址分配给多个设备来实现的。这些设备还必须明确告知它们正在共享一个任播地址，但地址本身的结构与单播地址相同。
- en: The bulk of the remainder of this chapter focuses on unicast addressing, since
    it is by far the most important type. Multicast and anycast addressing are given
    special attention in a separate section later in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分主要关注单播地址，因为它是迄今为止最重要的类型。多播和任播地址将在本章后面的单独部分中给予特别关注。
- en: IPv6 Address Size and Address Space
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6地址大小和地址空间
- en: Of all the changes introduced in IPv6, easily the most celebrated is the increase
    in the size of IP addresses, which resulted in a corresponding massive increase
    in the size of the address space as well. It's not surprising that these sizes
    were increased compared to IPv4—everyone has known for years that the IPv4 address
    space was too small to support the future of the Internet. What's remarkable is
    the level of increase and the implications for how Internet addresses are used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6引入的所有变化中，最容易引起关注的是IP地址大小的增加，这导致了地址空间大小的相应大幅增加。与IPv4相比，这些大小增加并不令人惊讶——因为多年来我们都知道IPv4地址空间太小，无法支持互联网的未来。令人印象深刻的是增加的程度以及这对互联网地址使用的影响。
- en: In IPv4, IP addresses are 32 bits long; these are usually grouped into 4 octets
    of 8 bits each. The theoretical IPv4 address space is 2^(32), or 4,294,967,296
    addresses. To increase this address space, we simply increase the size of addresses;
    each extra bit we give to the address size doubles the address space. Based on
    this, some folks expected the IPv6 address size to increase from 32 to 48 bits,
    or perhaps 64 bits. Either of these numbers would have given a rather large number
    of addresses.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，IP地址长度为32位；这些地址通常被分为4个8位的八位字节。理论上的IPv4地址空间是2^(32)，即4,294,967,296个地址。为了增加这个地址空间，我们只需增加地址的大小；我们给地址大小增加的每一个额外位都会使地址空间翻倍。基于这一点，有些人预计IPv6地址大小将从32位增加到48位，或者可能是64位。这两个数字中的任何一个都会给出一个非常大的地址数量。
- en: However, IPv6 addressing doesn't use either of these figures. Instead, the IP
    address size jumps all the way to 128 bits, or 16 8-bit octets/bytes. The size
    of the IPv6 address space is, quite literally, astronomical. Like the numbers
    that describe the number of stars in a galaxy or the distance to the furthest
    pulsars, the number of addresses that can be supported in IPv6 is mind-boggling.
    See [Figure 25-1](ch25.html#a_poor_representation_of_relative_ipv4_a "Figure 25-1. A
    (poor) representation of relative IPv4 and IPv6 address space sizes I wanted to
    make a cool graphic to show the relative sizes of the IPv4 and IPv6 address spaces.
    You know, where I would show the IPv6 address space as a big box and the IPv4
    address space as a tiny one. The problem is that the IPv6 address space is so
    much larger than the IPv4 space that there is no way to show it to scale! To make
    this diagram to scale, imagine the IPv4 address space is the 1.6-inch square above.
    In that case, the IPv6 address space would be represented by a square the size
    of the solar system!") for an idea of what I mean by *astronomical*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IPv6地址使用的是这两个数字中的任何一个。相反，IP地址大小直接跳到128位，即16个8位的八位字节/字节。IPv6地址空间的大小实际上是天文数字。就像描述星系中星星数量或最远脉冲星距离的数字一样，IPv6可以支持的地址数量令人难以置信。参见[图25-1](ch25.html#a_poor_representation_of_relative_ipv4_a
    "图25-1. 一个（较差的）相对IPv4和IPv6地址空间大小的表示我想制作一个酷炫的图形来展示IPv4和IPv6地址空间的相对大小。你知道，我会展示IPv6地址空间作为一个大盒子，IPv4地址空间作为一个小盒子。问题是IPv6地址空间比IPv4空间大得多，以至于无法按比例展示！为了使这个图按比例展示，想象IPv4地址空间是上面1.6英寸的方形。在这种情况下，IPv6地址空间将表示为一个与太阳系大小相当的方形！")来了解我所说的“天文数字”是什么意思。
- en: 'Since IPv6 addresses are 128 bits long, the theoretical address space, if all
    addresses were used, is 2^(128) addresses. This number, when expanded out, is
    340,282,366,920,938,463,463,374,607,431,768,211,456, which is normally expressed
    in scientific notation as about 3.4*10^(38) addresses. Whoa! That''s about 340
    trillion, *trillion*, *trillion* addresses. As I said, it''s pretty hard to grasp
    just how large this number is. Consider these comparisons:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IPv6地址长度为128位，如果所有地址都被使用，理论上的地址空间是2^(128)个地址。这个数字展开后是340,282,366,920,938,463,463,374,607,431,768,211,456，通常用科学记数法表示为大约3.4*10^(38)个地址。哇！这大约是340万亿，*万亿*，*万亿*个地址。正如我所说，很难理解这个数字有多大。考虑以下比较：
- en: It's enough addresses for many trillions of addresses to be assigned to every
    human being on the planet.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些地址足够多，可以为地球上每一个人类分配数十亿个地址。
- en: The Earth is about 4.5 billion years old. If you had been assigning IPv6 addresses
    at a rate of 1 billion per second since the Earth was formed, you would have by
    now used up less than one trillionth of the address space.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地球大约有45亿年的历史。如果你从地球形成的那一刻起，以每秒10亿个地址的速度分配IPv6地址，到目前为止，你使用的地址空间还不到万亿分之一。
- en: The Earth's surface area is about 510 trillion square meters. If a typical computer
    has a footprint of about one-tenth of a square meter, you would have to stack
    computers 10 billion high—blanketing the entire surface of the Earth—to use up
    that same trillionth of the address space.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地球表面积大约为510万亿平方米。如果一台典型的计算机占地面积约为0.1平方米，你需要堆叠1000亿台计算机——覆盖整个地球表面——才能耗尽同样的万亿分之一地址空间。
- en: OK, I think you get the idea. It's clear that one goal of the decision to go
    to 128-bit addresses is to make sure that we will never run out of address space
    again, and it seems quite likely that this will be the case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想你已经明白了。很明显，决定使用128位地址的一个目标是为了确保我们永远不会再次耗尽地址空间，而且这似乎是非常可能的。
- en: '![A (poor) representation of relative IPv4 and IPv6 address space sizes I wanted
    to make a cool graphic to show the relative sizes of the IPv4 and IPv6 address
    spaces. You know, where I would show the IPv6 address space as a big box and the
    IPv4 address space as a tiny one. The problem is that the IPv6 address space is
    so much larger than the IPv4 space that there is no way to show it to scale! To
    make this diagram to scale, imagine the IPv4 address space is the 1.6-inch square
    above. In that case, the IPv6 address space would be represented by a square the
    size of the solar system!](httpatomoreillycomsourcenostarchimages287869.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![相对IPv4和IPv6地址空间大小的（较差）表示我想制作一个酷炫的图形来展示IPv4和IPv6地址空间的相对大小。你知道，我会把IPv6地址空间展示为一个大的盒子，而IPv4地址空间展示为一个小的盒子。问题是IPv6地址空间比IPv4空间大得多，以至于无法按比例展示！为了使这个图按比例展示，想象一下上面的1.6英寸平方是IPv4地址空间。在这种情况下，IPv6地址空间将用一个代表太阳系的平方来表示！](http://atomoreilly.com/source/nostarch/images/287869.png.jpg)'
- en: Figure 25-1. A (poor) representation of relative IPv4 and IPv6 address space
    sizes I wanted to make a cool graphic to show the relative sizes of the IPv4 and
    IPv6 address spaces. You know, where I would show the IPv6 address space as a
    big box and the IPv4 address space as a tiny one. The problem is that the IPv6
    address space is so much larger than the IPv4 space that there is no way to show
    it to scale! To make this diagram to scale, imagine the IPv4 address space is
    the 1.6-inch square above. In that case, the IPv6 address space would be represented
    by a square the size of the solar system!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-1. 相对IPv4和IPv6地址空间大小的（较差）表示我想制作一个酷炫的图形来展示IPv4和IPv6地址空间的相对大小。你知道，我会把IPv6地址空间展示为一个大的盒子，而IPv4地址空间展示为一个小的盒子。问题是IPv6地址空间比IPv4空间大得多，以至于无法按比例展示！为了使这个图按比例展示，想象一下上面的1.6英寸平方是IPv4地址空间。在这种情况下，IPv6地址空间将用一个代表太阳系的平方来表示！
- en: There are drawbacks to having such a huge address space, too. Consider that
    even with a 64-bit address, we would have a very large address space; 2^(64) equals
    18,446,744,073,709,551,616, or about 18 million trillion. These are still probably
    more addresses than the Internet will ever need. However, by going to 128 bits
    instead, this has made dealing with IP addresses unruly (as you'll see in the
    next section). This has also increased overhead, since every datagram header or
    other place where IP addresses are referenced must use 16 bytes for each address
    instead of the 4 bytes that were needed in IPv4, or the 8 bytes that might have
    been required with a 64-bit address.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有如此巨大的地址空间也有其缺点。考虑一下，即使使用64位地址，我们也会有一个非常大的地址空间；2^64等于18,446,744,073,709,551,616，或者说大约18亿万亿。这些地址可能仍然比互联网需要的地址多。然而，通过使用128位，这使得处理IP地址变得难以管理（你将在下一节中看到）。这也增加了开销，因为每个数据报头或其他引用IP地址的地方都必须使用16个字节来表示每个地址，而不是IPv4中所需的4个字节，或者64位地址可能需要的8个字节。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The IPv6 address space is really, *really* big!'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6地址空间真的非常大！'
- en: So why the overkill of going to 128 bits? The main reason is *flexibility*.
    Even though you can have a couple zillion addresses if we allocate them one at
    a time, this makes assignment difficult. The developers got rid of class-oriented
    addressing in IPv4 because it wasted address space. The reality, though, is that
    being able to waste address space is a useful luxury.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么需要过度到128位呢？主要原因在于*灵活性*。尽管如果我们逐个分配，我们可以拥有数亿个地址，但这使得分配变得困难。开发者移除了IPv4中的基于类别的地址分配，因为它浪费了地址空间。然而，现实是，能够浪费地址空间是一种有用的奢侈。
- en: 'Having 128 bits allows us to divide the address space and assign various purposes
    to different bit ranges, while still not having to worry about running out of
    space. Later in this chapter, in the section describing the IPv6 global unicast
    address format, you''ll see one way that those 128 bits are put to good use: They
    allow you to create a hierarchy of networks while still saving 64 bits for host
    IDs. This hierarchy has its own advantages.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用128位允许我们将地址空间分割，并为不同的位范围分配不同的用途，同时仍然不必担心空间不足。在本章的后续部分，在描述IPv6全局单播地址格式的部分，你会看到这些128位是如何得到良好应用的：它们允许你创建一个网络层次结构，同时仍然为主机ID保留64位。这种层次结构有其自身的优势。
- en: IPv6 Address and Address Notation and Prefix Representation
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6地址、地址表示法和前缀表示法
- en: Increasing the size of IP addresses from 32 bits to 128 bits expands the address
    space to a gargantuan size, thereby ensuring that we will never again run out
    of IP addresses, and thereby allowing flexibility in how they are assigned and
    used. Unfortunately, there are some drawbacks to this method, and one of them
    is that 128-bit numbers are very large. The size makes them awkward and difficult
    to use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将IP地址的大小从32位增加到128位，将地址空间扩展到一个巨大的规模，从而确保我们永远不会再次耗尽IP地址，并允许在分配和使用它们时具有灵活性。不幸的是，这种方法有一些缺点，其中之一是128位数字非常大。其大小使得它们使用起来很尴尬且困难。
- en: 'Computers work in binary, and they have no problem dealing with long strings
    of ones and zeros, but humans find them confusing. Even the 32-bit addresses of
    IPv4 are cumbersome for us to deal with, which is why we use dotted decimal notation
    for them unless we need to work in binary (as with subnetting). However, IPv6
    addresses are so much larger than IPv4 addresses that it becomes problematic to
    use dotted decimal notation. To use this notation, we would split the 128 bits
    into 16 octets and represent each with a decimal number from 0 to 255\. However,
    we would end up not with 4 of these numbers, but *16*. A typical IPv6 address
    in this notation would appear as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机以二进制方式工作，它们处理一长串的1和0没有问题，但人类发现它们很令人困惑。即使是IPv4的32位地址对我们来说也很繁琐，这就是为什么我们通常使用点分十进制表示法来表示它们，除非我们需要在二进制下工作（如子网划分）。然而，IPv6地址比IPv4地址大得多，使用点分十进制表示法会变得很成问题。为了使用这种表示法，我们需要将128位分成16个八位字节，并用0到255之间的十进制数来表示每个字节。然而，我们最终得到的不是4个这样的数字，而是*16*个。按照这种表示法，一个典型的IPv6地址可能如下所示：
- en: '| 128.91.45.157.220.40.0.0.0.0.252.87.212.200.31.255 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 128.91.45.157.220.40.0.0.0.0.252.87.212.200.31.255 |'
- en: The binary and dotted decimal representations of this address are shown near
    the top of [Figure 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses."). In either case, the
    word *elegant* doesn't exactly spring to mind.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该地址的二元和点分十进制表示法显示在[图25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "图25-2. IPv6地址的二元、十进制和十六进制表示法。前两行显示了IPv6地址的二元和点分十进制表示法；这两种表示法都不常用（除了计算机自身使用之外！）。下表的第一行显示了完整的十六进制表示法，接下来的两行说明了零抑制和压缩。最后一行显示了混合表示法，IPv6地址的最后32位以点分十进制表示法（212.200.31.255）显示。这最常用于嵌入式IPv4地址。")的顶部附近。在任何情况下，"优雅"这个词都不太可能立刻出现在你的脑海中。
- en: '![Binary, decimal, and hexadecimal representations of IPv6 addresses The top
    two rows show binary and dotted decimal representations of an IPv6 address; neither
    is commonly used (other than by computers themselves!). The top row of the lower
    table shows the full hexadecimal representation, while the next two rows illustrate
    zero suppression and compression. The last row shows mixed notation, with the
    final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses.](httpatomoreillycomsourcenostarchimages287871.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6 地址的二进制、十进制和十六进制表示。最上面两行显示了 IPv6 地址的二进制和点分十进制表示；这两种表示法都不常用（除了计算机本身之外！）。下表的最上面一行显示了完整的十六进制表示，而接下来的两行说明了零抑制和压缩。最后一行显示了混合表示法，其中
    IPv6 地址的最后 32 位以点分十进制表示（212.200.31.255）。这最常用于嵌入式 IPv4 地址。](httpatomoreillycomsourcenostarchimages287871.png.jpg)'
- en: Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-2. IPv6 地址的二进制、十进制和十六进制表示。最上面两行显示了 IPv6 地址的二进制和点分十进制表示；这两种表示法都不常用（除了计算机本身之外！）。下表的最上面一行显示了完整的十六进制表示，而接下来的两行说明了零抑制和压缩。最后一行显示了混合表示法，其中
    IPv6 地址的最后 32 位以点分十进制表示（212.200.31.255）。这最常用于嵌入式 IPv4 地址。
- en: IPv6 Address Hexadecimal Notation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 地址十六进制表示法
- en: To make addresses shorter, the decision was made in IPv6 to change the primary
    method of expressing addresses to use hexadecimal instead of decimal. The advantage
    of this is that it requires fewer characters to represent an address, and converting
    from hexadecimal to binary and back again is much easier than converting from
    binary to decimal or vice versa. The disadvantage is that many people find hexadecimal
    difficult to comprehend and work with, especially because the notion of 16 values
    in each digit is a bit strange.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使地址更短，IPv6 中决定将表示地址的主要方法从十进制改为十六进制。这样做的好处是表示地址所需的字符更少，而且从十六进制到二进制以及反过来转换比从二进制到十进制或反过来转换要容易得多。缺点是许多人发现十六进制难以理解和处理，尤其是由于每个数字中包含
    16 个值的概念有点奇怪。
- en: 'The hexadecimal notation used for IPv6 addresses is similar to the same method
    used for IEEE 802 MAC addresses, and for technologies like Ethernet. With these
    MAC addresses, 48 bits are represented by 6 octets, each octet being a hexadecimal
    number from 0 to FF, separated by a dash or colon, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 IPv6 地址的十六进制表示法与用于 IEEE 802 MAC 地址以及类似以太网等技术的相同方法相似。在这些 MAC 地址中，48 位由 6 个八位字节表示，每个八位字节是一个从
    0 到 FF 的十六进制数，由破折号或冒号分隔，如下所示：
- en: '| 0A-A7-94-07-CB-D0 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 0A-A7-94-07-CB-D0 |'
- en: 'Since IPv6 addresses are larger, they are instead grouped into eight 16-bit
    *words*, separated by colons, to create what is sometimes called *colon hexadecimal
    notation*, as shown in [Figure 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses."). So, the IPv6 address
    given in the previous example would be expressed as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IPv6 地址更大，它们被分成八个 16 位 *单词*，并用冒号分隔，从而形成了有时被称为 *冒号十六进制表示法* 的格式，如[图 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "图 25-2. IPv6 地址的二进制、十进制和十六进制表示。最上面两行显示了 IPv6 地址的二进制和点分十进制表示；这两种表示法都不常用（除了计算机本身之外！）。下表的最上面一行显示了完整的十六进制表示，而接下来的两行说明了零抑制和压缩。最后一行显示了混合表示法，其中
    IPv6 地址的最后 32 位以点分十进制表示（212.200.31.255）。这最常用于嵌入式 IPv4 地址。")所示。因此，前面例子中的 IPv6 地址可以这样表示：
- en: '| 805B:2D9D:DC28:0000:0000:FC57:D4C8:1FFF |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 805B:2D9D:DC28:0000:0000:FC57:D4C8:1FFF |'
- en: 'To keep the address size down, leading zeros can be suppressed in the notation
    so you can immediately reduce this to the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减小地址的大小，可以在表示法中省略前导零，这样你可以立即将其简化为以下形式：
- en: '| 805B:2D9D:DC28:0:0:FC57:D4C8:1FFF |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 805B:2D9D:DC28:0:0:FC57:D4C8:1FFF |'
- en: 'Well, it''s definitely shorter than dotted decimal, but still pretty long.
    When you are dealing with numbers this big, there''s only so much you can do.
    This is part of why the use of Domain Name System (DNS) names for hosts becomes
    much more important under IPv6 than it is in IPv4: Who could remember a hex address
    that long?'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这确实比点分十进制表示法短，但仍然相当长。当你处理这么大的数字时，你能做的只有这么多。这也是为什么在IPv6下使用域名系统（DNS）名称来表示主机比在IPv4下更为重要的部分：谁会记得那么长的十六进制地址呢？
- en: Zero Compression in IPv6 Addresses
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6地址中的零压缩
- en: 'Fortunately, there is a shortcut that can be applied to shorten some addresses
    even further. This technique is sometimes called *zero compression*. The method
    allows a single string of contiguous zeros in an IPv6 address to be replaced by
    double colons. So, for example, the previous address could be expressed as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种快捷方式可以进一步缩短某些地址。这种技术有时被称为*零压缩*。这种方法允许将IPv6地址中的一个连续的零字符串替换为双冒号。例如，前面的地址可以这样表示：
- en: '| 805B:2D9D:DC28::FC57:D4C8:1FFF |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 805B:2D9D:DC28::FC57:D4C8:1FFF |'
- en: 'You know how many zeros are replaced by the two colons (::) because you can
    see how many fully expressed (uncompressed) hexadecimal words are in the address.
    In this case, there are six, so the :: represents two zero words. To prevent ambiguity,
    the double colons can appear only once in any IP address, because if it appeared
    more than once, you could not tell how many zeros were replaced in each instance.
    So, if the example address were 805B:2D9D:DC28:0:0:FC57:0:0, you could replace
    either the first pair of zeros or the second, but not both.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道有多少零被两个冒号（::）替换，因为你可以看到地址中有多少完全表示（未压缩）的十六进制词。在这种情况下，有六个，所以::代表两个零词。为了避免歧义，双冒号在任何IP地址中只能出现一次，因为如果出现多次，你将无法确定每个实例中替换了多少零。所以，如果示例地址是805B:2D9D:DC28:0:0:FC57:0:0，你可以替换第一对零或第二对，但不能同时替换。
- en: 'Zero compression doesn''t make the example much shorter, but due to how IPv6
    addresses are structured, long strings of zeros are common. For example, consider
    this address:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 零压缩并没有使示例变得更短，但由于IPv6地址的结构，长串的零是常见的。例如，考虑以下地址：
- en: '| FF00:4501:0:0:0:0:0:32 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| FF00:4501:0:0:0:0:0:32 |'
- en: 'With compression, this could be shortened as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用压缩，它可以缩短为以下形式：
- en: '| FF00:4501::32 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| FF00:4501::32 |'
- en: 'The technique works even better on special addresses. The full IPv6 loopback
    address is written as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在特殊地址上效果更好。完整的IPv6回环地址写法如下：
- en: '| 0:0:0:0:0:0:0:1 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 0:0:0:0:0:0:0:1 |'
- en: 'With compression, the loopback address looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用压缩，回环地址看起来是这样的：
- en: '| ::1 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| ::1 |'
- en: 'For even more fun, consider the especially odd IPv6 unspecified address, as
    shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有趣，考虑特别奇怪的IPv6未指定地址，如下所示：
- en: '| 0:0:0:0:0:0:0:0 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 0:0:0:0:0:0:0:0 |'
- en: Apply zero compression to an address that is all zeros, and what do you get?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个全为零的地址应用零压缩，你会得到什么？
- en: '| :: |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| :: |'
- en: 'No numbers at all! Of course, thinking of :: as an address *does* take some
    getting used to.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何数字！当然，将::视为地址确实需要一些习惯。
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** For brevity, IPv6 addresses are represented using eight sets
    of four hexadecimal digits, a form called *colon hexadecimal notation*. Additional
    techniques, called *zero suppression* and *zero compression*, are used to reduce
    the size of displayed addresses further by removing unnecessary zeros from the
    presentation of the address.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了简洁起见，IPv6地址使用八组四位十六进制数字表示，这种形式称为*冒号十六进制表示法*。此外，还使用称为*零省略*和*零压缩*的技术，通过从地址的表示中删除不必要的零来进一步减小显示地址的大小。'
- en: IPv6 Mixed Notation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6混合表示法
- en: 'There is also an alternative notation used in some cases, especially for expressing
    IPv6 addresses that embed IPv4 addresses (discussed later in this chapter). For
    these, it is useful to show the IPv4 portion of the address in the older dotted
    decimal notation, since that''s what you use for IPv4\. Since embedding uses the
    last 32 bits for the IPv4 address, the notation has the first 96 bits in colon
    hexadecimal notation and the last 32 bits in dotted decimal. So, to take the earlier
    example again, in *mixed notation* it would be shown as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，也使用了一种替代表示法，特别是用于表示嵌入 IPv4 地址的 IPv6 地址（本章后面将讨论）。对于这些地址，显示地址的 IPv4 部分以较旧的点分十进制表示法是有用的，因为这是你用于
    IPv4 的表示法。由于嵌入使用最后 32 位作为 IPv4 地址，因此表示法具有以冒号十六进制表示法显示的前 96 位和以点分十进制显示的最后 32 位。因此，再次以先前的例子为例，在
    *混合表示法* 中，它将如下所示：
- en: '| 805B:2D9D:DC28::FC57:**212.200.31.255** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 805B:2D9D:DC28::FC57:**212.200.31.255** |'
- en: 'This isn''t really a great example of mixed notation, because embedding usually
    involves long strings of zeros followed by the IPv4 address. Thus, zero compression
    comes in very handy here. Instead of seeing something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是混合表示法的很好例子，因为嵌入通常涉及长串零后面跟着 IPv4 地址。因此，零压缩在这里非常有用。你不会看到如下这样的内容：
- en: '| 0:0:0:0:0:0:212.200.31.255 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 0:0:0:0:0:0:212.200.31.255 |'
- en: 'You will typically see this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会看到这样的：
- en: '| ::212.200.31.255 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| ::212.200.31.255 |'
- en: At first glance, this appears to be an IPv4 address. You must keep a close eye
    on those colons in IPv6!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是一个 IPv4 地址。你必须密切关注 IPv6 中的那些冒号！
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** A special mixed notation is defined for IPv6 addresses whose
    last 32 bits contain an embedded IPv4 address. In this notation, the first 96
    bits are displayed in regular colon hexadecimal notation, and the last 32 bits
    are displayed in IPv4-style dotted decimal.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 对于最后 32 位包含嵌入的 IPv4 地址的 IPv6 地址，定义了一种特殊的混合表示法。在这种表示法中，前 96 位以常规的冒号十六进制表示法显示，而最后
    32 位以 IPv4 风格的点分十进制表示法显示。'
- en: IPv6 Address Prefix Length Representation
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 地址前缀长度表示
- en: Like IPv4 classless addresses, IPv6 addresses are fundamentally divided into
    a number of network ID bits followed by a number of host ID bits. The network
    identifier is called the *prefix*, and the number of bits used is the *prefix
    length*. This prefix is represented by adding a slash after the address and then
    putting the prefix length after the slash. This is the same method used for classless
    IPv4 addressing with CIDR. For example, if the first 48 bits of the sample address
    were the network ID (prefix), then we would express this as 805B:2D9D:DC28::FC57:D4C8:1FFF/48.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IPv4 无类地址一样，IPv6 地址在本质上被分成若干个网络 ID 位，后面跟着若干个主机 ID 位。网络标识符被称为 *前缀*，使用的位数是 *前缀长度*。这个前缀通过在地址后添加斜杠，然后在斜杠后放置前缀长度来表示。这是用于
    CIDR 的无类 IPv4 地址的相同方法。例如，如果样本地址的前 48 位是网络 ID（前缀），那么我们将表示为 805B:2D9D:DC28::FC57:D4C8:1FFF/48。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** In IPv6, the size of an address''s prefix is indicated by the
    prefix length that follows the address, separated with a slash, just as it is
    done in IPv4 classless addressing.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在 IPv6 中，地址前缀的大小由跟在地址后面的前缀长度指示，用斜杠分隔，就像在 IPv4 无类地址中做的那样。'
- en: As in IPv4, specifiers for whole networks will typically end in long strings
    of zeros. These can be replaced by double colons (::) using zero compression.
    For example, the 48-bit network ID for the previous example is 805B:2D9D:DC28:0:0:0:0:0/48,
    or 805B:2D9D:DC28::/48\. You *must* include the "::" if replacing the trailing
    zeros.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IPv4 类似，整个网络的指定符通常以长串零结尾。这些可以用双冒号（::）替换，使用零压缩。例如，前一个示例的 48 位网络 ID 是 805B:2D9D:DC28:0:0:0:0:0/48，或
    805B:2D9D:DC28::/48。如果你替换了尾随的零，*必须* 包含 "::"。
- en: IPv6 Address Space Allocation
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 地址空间分配
- en: After dealing for so many years with the very small IPv4 address space, the
    enormous number of addresses in IPv6 must have made the Internet Engineering Task
    Force (IETF) engineers feel like kids in a candy shop. They were good kids, however,
    and didn't run wild, grabbing all the candy they could find and gobbling it up.
    They very carefully considered how to divide the address space for various uses.
    Of course, when you have this much candy, sharing becomes pretty easy.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年处理非常小的 IPv4 地址空间之后，IPv6 中巨大的地址数量一定让互联网工程任务组（IETF）的工程师们感觉像是在糖果店里的孩子。然而，他们都是好孩子，并没有乱跑，抓取他们能找到的所有糖果并吞下去。他们非常仔细地考虑了如何为各种用途划分地址空间。当然，当你有这么多糖果时，分享变得相当容易。
- en: As was the case with IPv4, the two primary concerns in deciding how to divide
    the IPv6 address space were address assignment and routing. The designers of IPv6
    wanted to structure the address space to make allocation of addresses to Internet
    service providers (ISPs), organizations, and individuals as easy as possible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与IPv4一样，在决定如何划分IPv6地址空间时，有两个主要问题：地址分配和路由。IPv6的设计者希望结构化地址空间，使得将地址分配给互联网服务提供商（ISP）、组织和个人尽可能容易。
- en: At first, perhaps ironically, this led the creators of IPv6 back full circle
    to the use of specific bit sequences to identify different types of addresses,
    just like the old classful addressing scheme. The address type was indicated by
    a set of bits at the start of the address, called the format prefix (FP). The
    format prefix was conceptually identical to the one to four bits used in IPv4
    classful addressing to denote address classes, but was variable in length, ranging
    from three to ten bits. Format prefixes were described in RFC 2373.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，也许具有讽刺意味的是，这使IPv6的创造者回到了使用特定比特序列来识别不同类型地址的老路，就像旧的类地址方案一样。地址类型由地址开头的一组比特表示，称为格式前缀（FP）。格式前缀在概念上与IPv4类地址中用于表示地址类的1到4比特相同，但长度是可变的，范围从3到10比特。格式前缀在RFC
    2373中进行了描述。
- en: In the years following the publication of RFC 2373, the gurus who run the Internet
    had a change of heart regarding how address blocks should be considered. They
    still wanted to divide the IPv6 address space into variably sized blocks for different
    purposes. However, they realized that many people were starting to consider the
    use of format prefixes to be equivalent to the old class-oriented IPv4 system.
    Their main concern was that implementers might program into IPv6 hardware logic
    to make routing decisions based only on the first few bits of the address. This
    was specifically *not* how IPv6 is supposed to work; for one thing, the allocations
    are subject to change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC 2373发布后的几年里，管理互联网的大师们对地址块应该如何考虑有了新的看法。他们仍然希望将IPv6地址空间划分为不同大小的块以供不同目的使用。然而，他们意识到许多人开始认为使用格式前缀与旧的基于类的IPv4系统相当。他们主要担心的是，实施者可能会在IPv6硬件逻辑中编程，仅根据地址的前几个比特进行路由决策。这**特别不是**IPv6应该工作的方式；一方面，分配是可能改变的。
- en: Thus, one of the modifications made in RFC 3513 was to change the language regarding
    IPv6 address allocations, and specifically, to remove the term *format prefix*
    from the standard. The allocation of different parts of the address space is still
    done based on particular patterns of the first three to ten bits of the address
    to allow certain categories to have more addresses than others. The elimination
    of the specific term denoting this is intended to convey that these bits should
    not be given special attention.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RFC 3513中做出的修改之一是改变有关IPv6地址分配的语言，特别是从标准中删除了术语*格式前缀*。地址空间的各个部分的分配仍然基于地址的前三到十个比特的特定模式，以便某些类别比其他类别拥有更多的地址。消除表示这一点的特定术语是为了传达这些比特不应给予特殊关注。
- en: '[Table 25-1](ch25s03.html#ipv_address_space_allocations "Table 25-1. IPv6 Address
    Space Allocations") shows the allocations of the IPv6 address space and what fraction
    of the total address space each represents.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[表25-1](ch25s03.html#ipv_address_space_allocations "表25-1. IPv6地址空间分配")显示了IPv6地址空间的分配以及每个分配占总地址空间的多少。'
- en: Table 25-1. IPv6 Address Space Allocations
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表25-1. IPv6地址空间分配
- en: '| Leading Bits | Fraction of Total IPv6 Address Space | Allocation |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 前导比特 | IPv6地址空间总量的比例 | 分配 |'
- en: '| --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0000 0000 | 1/256 | Unassigned (Includes special addresses such as the unspecified
    and loopback addresses) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 0000 0000 | 1/256 | 未分配（包括特殊地址，如未指定地址和环回地址） |'
- en: '| 0000 0001 | 1/256 | Unassigned |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 0000 0001 | 1/256 | 未分配 |'
- en: '| 0000 001 | 1/128 | Reserved for NSAP address allocation |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 0000 001 | 1/128 | 保留用于NSAP地址分配 |'
- en: '| 0000 01 | 1/64 | Unassigned |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 0000 01 | 1/64 | 未分配 |'
- en: '| 0000 1 | 1/32 | Unassigned |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 0000 1 | 1/32 | 未分配 |'
- en: '| 0001 | 1/16 | Unassigned |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1/16 | 未分配 |'
- en: '| 001 | 1/8 | Global unicast addresses |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 001 | 1/8 | 全球单播地址 |'
- en: '| 010 | 1/8 | Unassigned |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 010 | 1/8 | 未分配 |'
- en: '| 011 | 1/8 | Unassigned |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 011 | 1/8 | 未分配 |'
- en: '| 100 | 1/8 | Unassigned |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 1/8 | 未分配 |'
- en: '| 101 | 1/8 | Unassigned |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 1/8 | 未分配 |'
- en: '| 110 | 1/8 | Unassigned |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 1/8 | 未分配 |'
- en: '| 1110 | 1/16 | Unassigned |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | 1/16 | 未分配 |'
- en: '| 1111 0 | 1/32 | Unassigned |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 1111 0 | 1/32 | 未分配 |'
- en: '| 1111 10 | 1/64 | Unassigned |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 1111 10 | 1/64 | 未分配 |'
- en: '| 1111 110 | 1/128 | Unassigned |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 1111 110 | 1/128 | 未分配 |'
- en: '| 1111 1110 0 | 1/512 | Unassigned |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 1111 1110 0 | 1/512 | 未分配 |'
- en: '| 1111 1110 10 | 1/1024 | Link-local unicast addresses |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 1111 1110 10 | 1/1024 | 链路本地单播地址 |'
- en: '| 1111 1110 11 | 1/1024 | Site-local unicast addresses |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 1111 1110 11 | 1/1024 | 站点本地单播地址 |'
- en: '| 1111 1111 | 1/256 | Multicast addresses |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 1111 1111 | 1/256 | 组播地址 |'
- en: This is more complicated than the IPv4 classful scheme because there are so
    many more categories and they range greatly in size, even if most of them are
    currently unassigned.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这比IPv4的类地址方案更复杂，因为类别更多，大小差异很大，即使大多数目前尚未分配。
- en: An easier way to make sense of this table is to consider the division of the
    IPv6 address space into *eighths*. Of these eight groups, one (001) has been reserved
    for unicast addresses; a second (000) has been used to carve out smaller reserved
    blocks, and a third (111) has been used for sub-blocks for local and multicast
    addresses. Five are completely unassigned.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解这个表格，可以考虑将IPv6地址空间划分为*八分之一*。在这八个组中，一个（001）已被保留用于单播地址；第二个（000）被用来划分更小的保留块，第三个（111）被用来为本地和组播地址的子块。其余五个完全未分配。
- en: You can see that the IPv6 designers have taken great care to allocate only the
    portion of these "eighths" of the address space that they felt was needed for
    each type of address. For example, only a small portion of the part of the address
    space beginning 111 was used, with most of it left aside. In total, only 71/512ths
    of the address space is assigned right now, or about 14 percent. The other 86
    percent is unassigned and kept aside for future use. (Bear in mind that even 1/1024th
    of the IPv6 address space is gargantuan—it represents trillions of trillions of
    addresses.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，IPv6的设计者非常小心地只为每种地址类型分配了地址空间中他们认为需要的“八分之一”部分。例如，以111开头的地址空间部分只使用了很小的一部分，大部分留空。总的来说，目前只分配了地址空间的71/512，大约14%，其余的86%尚未分配，留作将来使用。（记住，即使是IPv6地址空间的1/1024也是巨大的——它代表了数万亿的地址。）
- en: Later sections in this chapter provide more information on several of these
    address blocks. Note that the 0000 0000 reserved block is used for several special
    address types, including the loopback address, the unspecified address, and IPv4
    address embedding. The 1111 1111 format prefix identifies multicast addresses;
    this string is FF in hexadecimal, so any address beginning with FF is a multicast
    address in IPv6.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面的部分提供了关于这些地址块中几个地址块更多的信息。请注意，0000 0000保留块用于几种特殊地址类型，包括环回地址、未指定地址和IPv4地址嵌入。1111
    1111格式前缀标识组播地址；这个字符串在十六进制中是FF，所以任何以FF开头的地址在IPv6中都是组播地址。
- en: IPv6 Global Unicast Address Format
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6全局单播地址格式
- en: 'It is anticipated that unicast addressing will be used for the vast majority
    of Internet traffic under IPv6, as is the case for IPv4\. It is for this reason
    that the largest of the assigned blocks of the IPv6 address space is dedicated
    to unicast addressing. A full one-eighth slice of the enormous IPv6 address "pie"
    is assigned to unicast addresses, which are indicated by a 001 in the first three
    bits of the address. The question is: How do we use the remaining 125 bits in
    the spacious IP addresses?'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 预计在IPv6下，单播地址将被用于绝大多数互联网流量，就像在IPv4中一样。正因为如此，分配给IPv6地址空间的最大块被用于单播地址。整个地址空间的八分之一被分配给单播地址，这由地址前三位中的001表示。问题是：我们如何使用宽敞的IP地址中剩余的125位？
- en: Rationale for a Structured Unicast Address Block
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化单播地址块的理由
- en: 'When IPv4 was first created, the Internet was rather small, and the model for
    allocating address blocks was based on a central coordinator: the Internet Assigned
    Numbers Authority (IANA). Everyone who wanted address blocks would go straight
    to the central authority. As the Internet grew, this model became impractical.
    Today, IPv4''s classless addressing scheme allows variable-length network IDs
    and hierarchical assignment of address blocks. Big ISPs get large blocks from
    the central authority, and then subdivide them and allocate them to their customers,
    and so on. This is managed by today''s ISPs, but there is nothing in the address
    space that helps manage the allocation process. In turn, each organization has
    the ability to further subdivide its address allocation to suit its internal requirements.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当IPv4最初被创建时，互联网相对较小，地址块的分配模式基于一个中央协调者：互联网数字分配机构（IANA）。任何想要地址块的人都会直接前往中央权威机构。随着互联网的发展，这种模式变得不切实际。如今，IPv4的无类别地址方案允许可变长度的网络ID和地址块的分层分配。大型ISP从中央权威机构获得大块地址，然后将其细分并分配给客户，等等。这由今天的ISP管理，但在地址空间中没有帮助管理分配过程的东西。反过来，每个组织都有能力进一步细分其地址分配，以满足其内部需求。
- en: 'The designers of IPv6 had the benefit of this experience and realized there
    would be tremendous advantages to designing the unicast address structure to reflect
    the overall topology of the Internet. These include the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6的设计者受益于这一经验，并意识到将单播地址结构设计成反映互联网整体拓扑结构将带来巨大的优势。以下是一些包括的内容：
- en: Easier allocation of address blocks at various levels of the Internet topological
    hierarchy.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在互联网拓扑层次结构的各个级别上更容易分配地址块。
- en: IP network addresses that automatically reflect the hierarchy by which routers
    move information across the Internet, thereby allowing routes to be easily aggregated
    for more efficient routing.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP网络地址能够自动反映路由器在互联网中传输信息时所采用的层次结构，从而使得路由可以轻松聚合，实现更有效的路由。
- en: Flexibility for organizations like ISPs to subdivide their address blocks for
    customers.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为像ISP这样的组织提供灵活性，以便将地址块细分以供客户使用。
- en: Flexibility for end-user organizations to subdivide their address blocks to
    match internal networks, much as subnetting did in IPv4.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为终端用户组织提供灵活性，以便将地址块细分以匹配内部网络，就像IPv4中的子网划分一样。
- en: Greater meaning to IP addresses. Instead of just being a string of 128 bits
    with no structure, it would become possible to look at an address and know certain
    things about it.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址具有更大的意义。不再是128位无结构的字符串，而是可以查看地址并了解其某些信息。
- en: Generic Division of the Unicast Address Space
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单播地址空间的通用划分
- en: The most generic way of dividing up the 128 bits of the unicast address space
    is into three sections, as shown in [Table 25-2](ch25s04.html#generic_ipv_global_unicast_address_forma
    "Table 25-2. Generic IPv6 Global Unicast Address Format").
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将单播地址空间的128位最通用地划分为三个部分，如图[表25-2](ch25s04.html#generic_ipv_global_unicast_address_forma
    "表25-2. 通用IPv6全局单播地址格式")所示。
- en: Table 25-2. Generic IPv6 Global Unicast Address Format
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表25-2. 通用IPv6全局单播地址格式
- en: '| Field Name | Size (Bits) | Description |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（位） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Prefix | *n* | Global Routing Prefix: The network ID or prefix of the address,
    used for routing. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | *n* | 全局路由前缀：地址的网络ID或前缀，用于路由。 |'
- en: '| Subnet ID | *m* | Subnet Identifier: A number that identifies a subnet within
    the site. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 子网ID | *m* | 子网标识符：一个数字，用于标识站点内的子网。 |'
- en: '| Interface ID | 128-*n-m* | Interface Identifier: The unique identifier for
    a particular interface (host or other device). It is unique within the specific
    prefix and subnet. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 接口ID | 128-*n-m* | 接口标识符：特定接口（主机或其他设备）的唯一标识符。它在特定的前缀和子网内是唯一的。 |'
- en: 'The *global routing prefix* and *subnet identifier* represent the two basic
    levels at which addresses need to be hierarchically constructed: that is, global
    and site-specific. The routing prefix consists of a number of bits that can be
    further subdivided according to the needs of Internet registries and ISPs. This
    subdivision reflects the topography of the Internet as a whole. The subnet ID
    gives a number of bits to site administrators for creating an internal network
    structure suiting each administrator''s needs.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局路由前缀*和*子网标识符*代表了地址需要按层次结构构建的两个基本级别：即全球和特定站点。路由前缀由一定数量的位组成，可以根据互联网注册机构和ISP的需求进一步细分。这种细分反映了整个互联网的地形。子网ID为站点管理员提供了一定数量的位，以便创建适合每个管理员需求的内部网络结构。'
- en: IPv6 Implementation of the Unicast Address Space
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6单播地址空间实现
- en: In theory, any size for *n* and *m* (see [Table 25-2](ch25s04.html#generic_ipv_global_unicast_address_forma
    "Table 25-2. Generic IPv6 Global Unicast Address Format")) could be used. The
    implementation chosen for IPv6, however, assigns 48 bits to the routing prefix
    and 16 bits to the subnet identifier. This means 64 bits are available for interface
    identifiers, which are constructed based on the IEEE EUI-64 format, as described
    in the next section. Thus, the overall IPv6 unicast address format is constructed
    as shown in [Table 25-3](ch25s04.html#ipv_global_unicast_address_format "Table 25-3. IPv6
    Global Unicast Address Format") and illustrated in [Figure 25-3](ch25s04.html#ipv6_global_unicast_address_format-id001
    "Figure 25-3. IPv6 global unicast address format").
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，可以使用任何大小的*n*和*m*（参见[表25-2](ch25s04.html#generic_ipv_global_unicast_address_forma
    "表25-2. 通用IPv6全局单播地址格式"））。然而，IPv6的实现选择了48位用于路由前缀和16位用于子网标识符。这意味着有64位可用于接口标识符，这些标识符基于IEEE
    EUI-64格式构建，如下一节所述。因此，IPv6单播地址的整体格式构建如[表25-3](ch25s04.html#ipv_global_unicast_address_format
    "表25-3. IPv6全局单播地址格式")所示，并在[图25-3](ch25s04.html#ipv6_global_unicast_address_format-id001
    "图25-3. IPv6全局单播地址格式")中说明。
- en: Table 25-3. IPv6 Global Unicast Address Format
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 表25-3. IPv6全局单播地址格式
- en: '| Field Name | Size (Bits) | Description |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（位） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Prefix | 48 | Global Routing Prefix: The network ID or prefix of the address
    that''s used for routing. The first three bits are 001 to indicate a unicast address.
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 48 | 全局路由前缀：用于路由的地址的网络ID或前缀。前三位是001，表示单播地址。'
- en: '| Subnet ID | 16 | Subnet Identifier: A number that identifies a subnet within
    the site. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 子网ID | 16 | 子网标识符：一个标识站点内子网的数字。|'
- en: '| Interface ID | 64 | Interface ID: The unique identifier for a particular
    interface (host or other device). It is unique within the specific prefix and
    subnet. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 接口ID | 64 | 接口ID：特定接口（主机或其他设备）的唯一标识符。它在特定的前缀和子网内是唯一的。|'
- en: '![IPv6 global unicast address format](httpatomoreillycomsourcenostarchimages287873.png.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6全局单播地址格式](httpatomoreillycomsourcenostarchimages287873.png.jpg)'
- en: Figure 25-3. IPv6 global unicast address format
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-3. IPv6全局单播地址格式
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The part of the IPv6 address space set aside for unicast addresses
    is structured into an address format that uses the first 48 bits for the *routing
    prefix* (like a network ID), the next 16 bits for a *subnet ID*, and the final
    64 bits for an *interface ID* (like a host ID).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6地址空间中为单播地址预留的部分被组织成一个地址格式，其中使用前48位作为*路由前缀*（类似于网络ID），接下来的16位作为*子网ID*，最后的64位作为*接口ID*（类似于主机ID）。'
- en: Due to this structure, most end sites (regular companies and organizations,
    as opposed to ISPs) will be assigned IPv6 networks with a 48-bit prefix. In common
    parlance, these network identifiers have now come to be called *48s* or */48s*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种结构，大多数终端站点（与ISP相比，是普通公司和组织）将被分配具有48位前缀的IPv6网络。在常见的说法中，这些网络标识符现在被称为*48s*或*/48s*。
- en: 'The 16 bits of subnet ID allow each site considerable flexibility in creating
    subnets that reflect the site''s network structure. Here are some example uses
    of the 16 bits:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 子网ID的16位允许每个站点在创建反映站点网络结构的子网时有相当大的灵活性。以下是一些16位的使用示例：
- en: A smaller organization can just set all the bits in the subnet ID to zero and
    have a flat internal structure.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较小的组织可以将子网ID中的所有位都设置为0，并拥有一个扁平的内部结构。
- en: A medium-sized organization could use all the bits in the subnet ID to perform
    the equivalent of straight subnetting under IPv4, thereby assigning a different
    subnet ID to each subnet. There are 16 bits here, and this allows a whopping 65,536
    subnets!
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个中等规模的组织可以使用子网ID中的所有位来执行IPv4下的直接子网划分，从而为每个子网分配不同的子网ID。这里有16位，这允许有65,536个子网！
- en: A larger organization can use the bits to create a multiple-level hierarchy
    of subnets, exactly like IPv4's Variable Length Subnet Masking (VLSM). For example,
    the company could use two bits to create four subnets. It could then take the
    next three bits to create eight sub-subnets in some or all of the four subnets.
    There would still be 11 more bits to create sub-sub-subnets, and so forth.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个较大的组织可以使用这些位来创建多个级别的子网层次结构，就像IPv4的可变长度子网掩码（VLSM）一样。例如，公司可以使用两个位来创建四个子网。然后，它可以使用接下来的三个位在四个子网中的某些或全部子网中创建八个子子网。还有11个位可以用来创建更下一级的子子子网，以此类推。
- en: 'Original Division of the Global Routing Prefix: Aggregators'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球路由前缀的原有划分：聚合器
- en: 'The global routing prefix is similarly divided into a hierarchy, but one that
    has been designed for the use of the entire Internet, like CIDR. There are 45
    bits available here (48 bits minus the first three that are fixed at 001). That
    is a lot. When the unicast address structure was first detailed in RFC 2374, that
    document described a specific division of the 45 bits based on a two-level hierarchical
    topology of Internet registries and providers. These organizations were described
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 全球路由前缀被类似地划分为一个层次结构，但这是一个为整个互联网使用而设计的层次结构，就像CIDR。这里有45位可用（48位减去固定的前三位001）。这相当多。当RFC
    2374首次详细说明单播地址结构时，该文件描述了基于互联网注册机构和提供商的两级层次拓扑结构的具体45位划分。这些组织被描述如下：
- en: '**Top-Level Aggregators (TLAs)** These refer to the largest Internet organizations,
    which were to be assigned large blocks of IPv6 addresses from registration authorities.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶级聚合器（TLAs）** 这些指的是最大的互联网组织，它们将从注册机构那里分配大量的IPv6地址。'
- en: '**Next-Level Aggregators (NLAs)** These organizations would get blocks of addresses
    from TLAs and divide them for end-user organizations (sites).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一级聚合器（NLAs）** 这些组织将从顶级聚合器（TLAs）那里获得地址块，并将它们分配给最终用户组织（站点）。'
- en: The 45 bits were split between these two uses, with a few bits reserved in the
    middle to allow expansion of either field if needed. Thus, the RFC 2374 structure
    for the 45 bits appeared as listed in [Table 25-4](ch25s04.html#historical_ipv_unicast_routing_prefix_st
    "Table 25-4. Historical IPv6 Unicast Routing Prefix Structure").
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 45位在这两个用途之间分配，中间保留了一些位，以便在需要时扩展任一字段。因此，RFC 2374结构中的45位看起来就像[表25-4](ch25s04.html#historical_ipv_unicast_routing_prefix_st
    "表25-4. 历史IPv6单播路由前缀结构")中列出的一样。
- en: Table 25-4. Historical IPv6 Unicast Routing Prefix Structure
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表25-4. 历史IPv6单播路由前缀结构
- en: '| Field Name | Size (Bits) | Description |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（位） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| TLA ID | 13 | Top-Level Aggregation (TLA) Identifier: A globally unique identifier
    for the top-level aggregator. There are 13 bits, so there were a maximum of 8,192
    TLAs allowed. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| TLA ID | 13 | 顶级聚合（TLA）标识符：顶级聚合器的全局唯一标识符。有13位，因此允许的最大TLA数量为8,192个。|'
- en: '| RES | 8 | Reserved: These 8 bits were reserved for future use and set to
    zero. By leaving these 8 bits between the TLA ID and NLA ID unused, they could
    later be used to expand either the TLA ID or NLA ID fields as needed. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| RES | 8 | 保留：这8位被保留供将来使用，并设置为0。通过在TLA ID和NLA ID之间留出这8位未使用，它们可以在需要时扩展TLA ID或NLA
    ID字段。|'
- en: '| NLA ID | 24 | Next-Level Aggregation (NLA) Identifier: Each TLA was given
    this 24-bit field to generate blocks of addresses for allocation to its customers.
    The NLA ID is unique for each TLA ID. The use of the 24 bits was left up to the
    TLA organization. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| NLA ID | 24 | 下一级聚合（NLA）标识符：每个TLA都被分配了这个24位字段，用于为其客户分配地址块。NLA ID对于每个TLA ID是唯一的。24位的使用由TLA组织自行决定。|'
- en: You'll notice my use of the past tense in the description of the TLA/NLA structure,
    and that table heading is a pretty big giveaway, too. In August 2003, RFC 3587
    was published, which in a nutshell says, "Uh, never mind about all that TLA/NLA
    stuff." The decision was made that having this structure hardwired into an Internet
    standard was inflexible, and it made more sense to let the regional Internet registries
    (APNIC, ARIN, LACNIC, and RIPE) decide for themselves how to use the 45 bits.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我在描述 TLA/NLA 结构时使用了过去时态，而且那个表头也是一个很大的提示。2003 年 8 月，RFC 3587 被发布，简而言之就是，“嗯，关于所有那些
    TLA/NLA 的事情就别管了。”决定将这种结构硬编码到互联网标准中是不灵活的，让区域互联网注册机构（APNIC、ARIN、LACNIC 和 RIPE）自己决定如何使用这
    45 位似乎更有意义。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The obsoleting of the TLA/NLA structure occurred after many years of people
    getting used to it, so for some time to come, you will still routinely see those
    terms mentioned in IPv6 descriptions. (This is why I included discussion of them
    here.)*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*TLA/NLA 结构的淘汰是在人们习惯了多年之后发生的，所以在未来一段时间内，你仍然会经常在 IPv6 描述中看到这些术语。这就是为什么我在这里讨论了它们。)*'
- en: A Sample Division of the Global Routing Prefix into Levels
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球路由前缀分层划分的示例
- en: There is no single structure for determining how the 48-bit routing prefix is
    divided in the global unicast hierarchy. As one example, it might be possible
    to divide it into three levels, as shown in [Table 25-5](ch25s04.html#example_ipv_unicast_routing_prefix_struc
    "Table 25-5. Example IPv6 Unicast Routing Prefix Structure") and illustrated in
    [Figure 25-4](ch25s04.html#example_of_ipv6_unicast_routing_prefix_s "Figure 25-4. Example
    of IPv6 unicast routing prefix structure The top row shows the global IPv6 unicast
    address format. The second shows one way to divide the global routing prefix into
    three levels using 10, 12, and 23 bits, respectively. The third row shows how
    the first 10 bits are used to create 210, or 1,024, different level 1 blocks.
    The next row illustrates that for each of these 13-bit prefixes, you could have
    212, or 4,096, level 2 blocks. Then, within each 25-bit level 2 ID, you have 23
    bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or /48 would be assigned
    to an individual organization.").
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在全球单播层次结构中，没有单一的结构来确定 48 位路由前缀如何划分。例如，它可能被划分为三个层次，如[表 25-5](ch25s04.html#example_ipv_unicast_routing_prefix_struc
    "表 25-5. 示例 IPv6 单播路由前缀结构")所示，并在[图 25-4](ch25s04.html#example_of_ipv6_unicast_routing_prefix_s
    "图 25-4. IPv6 单播路由前缀结构示例。最上面一行显示了全球 IPv6 单播地址格式。第二行显示了使用 10、12 和 23 位将全球路由前缀划分为三个层次的一种方法。第三行显示了如何使用前
    10 位来创建 210，即 1,024 个不同的第一层块。下一行说明了对于这些 13 位前缀中的每一个，你可以有 212，即 4,096 个第二层块。然后，在每个
    25 位的第二层 ID 中，你有 23 位，即 8,388,608 个第三层块。在最下面，一个第三层或 /48 将被分配给一个单独的组织。”）所示。
- en: Table 25-5. Example IPv6 Unicast Routing Prefix Structure
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-5. 示例 IPv6 单播路由前缀结构
- en: '| Field Name | Size (Bits) | Description |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（位） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| (Unicast Indicator) | 3 | Each unicast address starts with 001; there is
    no official name for this (it used to be called the *format prefix*). |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| （单播指示符） | 3 | 每个单播地址以 001 开头；这个没有官方名称（它过去被称为 *格式前缀*）。|'
- en: '| Level1 ID | 10 | Level 1 Identifier: The identifier of the highest level
    in the hierarchy. This would be used for assigning the largest blocks of addresses
    in the global hierarchy to the biggest Internet organizations. The number of level
    1 organizations would be 210, or 1,024. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 第一层 ID | 10 | 第一层标识符：层次结构中最高的标识符。这将用于将全球层次结构中最大的地址块分配给最大的互联网组织。第一层组织的数量将是
    210，即 1,024。|'
- en: '| Level2 ID | 12 | Level 2 Identifier: Each block assigned to a level 1 organization
    would use 12 bits to create 4,096 address blocks to divide among the lower-level
    organizations it serves. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 第二层 ID | 12 | 第二层标识符：分配给第一层组织的每个块将使用 12 位来创建 4,096 个地址块，以分配给其服务的低层组织。|'
- en: '| Level3 ID | 23 | Level 3 Identifier: Each level 2 organization has 23 bits
    to use to divide its level 2 address block. Thus, it could create over 8 million
    individual /48 address blocks to assign to end-user sites. Alternatively, the
    23 bits could be divided further into still lower levels to reflect the structure
    of the level 2 organization''s customers. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 第三层 ID | 23 | 第三层标识符：每个第二层组织有 23 位来用于划分其第二层地址块。因此，它可以创建超过 800 万个单独的 /48 地址块分配给终端用户站点。或者，这
    23 位可以进一步划分为更低的层次，以反映第二层组织客户的结构。|'
- en: '![Example of IPv6 unicast routing prefix structure The top row shows the global
    IPv6 unicast address format. The second shows one way to divide the global routing
    prefix into three levels using 10, 12, and 23 bits, respectively. The third row
    shows how the first 10 bits are used to create 210, or 1,024, different level
    1 blocks. The next row illustrates that for each of these 13-bit prefixes, you
    could have 212, or 4,096, level 2 blocks. Then, within each 25-bit level 2 ID,
    you have 23 bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or /48
    would be assigned to an individual organization.](httpatomoreillycomsourcenostarchimages287875.png.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6单播路由前缀结构示例。最上面一行显示了全局IPv6单播地址格式。第二行展示了将全局路由前缀分别使用10、12和23位划分为三个级别的示例。第三行展示了如何使用前10位来创建210，即1,024个不同级别的1号块。下一行说明了对于这些13位前缀中的每一个，你可以有212，即4,096个级别的2号块。然后，在每个25位的级别2
    ID中，你有23位，即8,388,608个级别的3号块。在最下面，一个级别3或/48将被分配给一个单独的组织。](http://atomoreilly.com/source/nostarch/images/287875.png.jpg)'
- en: Figure 25-4. Example of IPv6 unicast routing prefix structure The top row shows
    the global IPv6 unicast address format. The second shows one way to divide the
    global routing prefix into three levels using 10, 12, and 23 bits, respectively.
    The third row shows how the first 10 bits are used to create 210, or 1,024, different
    level 1 blocks. The next row illustrates that for each of these 13-bit prefixes,
    you could have 212, or 4,096, level 2 blocks. Then, within each 25-bit level 2
    ID, you have 23 bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or
    /48 would be assigned to an individual organization.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-4. IPv6单播路由前缀结构示例。最上面一行显示了全局IPv6单播地址格式。第二行展示了将全局路由前缀分别使用10、12和23位划分为三个级别的示例。第三行展示了如何使用前10位来创建210，即1,024个不同级别的1号块。下一行说明了对于这些13位前缀中的每一个，你可以有212，即4,096个级别的2号块。然后，在每个25位的级别2
    ID中，你有23位，即8,388,608个级别的3号块。在最下面，一个级别3或/48将被分配给一个单独的组织。
- en: This is just one possible theoretical way that the bits in a /48 network address
    could be assigned. As you can see, with so many bits, there is a lot of flexibility.
    In the previous scheme, you can have over four million level 2 organizations,
    each of which can assign eight million /48 addresses. And each of those is equivalent
    in size to an IPv4 Class B address (over 65,000 hosts)!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是/48网络地址中位分配的一种可能的理论方式。正如你所见，有这么多位，有很大的灵活性。在之前的方案中，你可以拥有超过四百万个级别2的组织，每个组织可以分配八百万个/48地址。而且每个组织的大小相当于一个IPv4类B地址（超过65,000个主机）！
- en: The removal of RFC 2374's fixed structure for the global routing prefix is consistent
    with the IPv6 development team's efforts to emphasize that bit fields and structures
    are used only for allocating addresses and not for routing purposes. The addresses
    themselves, once created, are not interpreted by hardware on an internetwork based
    on this format. To routers, the only structure that matters is the division between
    the network ID and host ID, given by the prefix length that trails the IP address,
    and this division can occur at any bit boundary. These hardware devices just see
    128 bits of an IP address and use it without any knowledge of hierarchical address
    divisions or levels.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 移除RFC 2374中全局路由前缀的固定结构与IPv6开发团队强调的位字段和结构仅用于地址分配而不用于路由目的的努力是一致的。一旦创建，地址本身不会根据这种格式在网络互连中的硬件上进行解释。对于路由器来说，唯一重要的是由IP地址后面的前缀长度给出的网络ID和主机ID之间的划分，这种划分可以在任何位边界发生。这些硬件设备只看到IP地址的128位，并使用它，而不了解层次地址划分或级别。
- en: Incidentally, the key to obtaining the allocation benefits of the aggregatable
    unicast address format is the abundance of bits available to us under IPv6\. The
    ability to have these hierarchical levels while still allowing 64 bits for the
    interface identifier is one of the main reasons why IPv6 designers went all the
    way from 32 bits to 128 bits for address size. By creating this structure, we
    maintain flexibility, while avoiding the potential chaos of trying to allocate
    many different network sizes within the 128 bits.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，获得可聚合单播地址格式分配好处的关键在于IPv6下我们可用的位非常多。在仍然允许64位用于接口标识符的同时拥有这些层次级别是IPv6设计者从32位到128位地址大小的主要原因之一。通过创建这种结构，我们保持了灵活性，同时避免了在128位内尝试分配许多不同网络大小的潜在混乱。
- en: Note that anycast addresses are structured in the same way as unicast addresses,
    so they are allocated according to this same model. (Multicast addresses are not.)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任播地址的结构与单播地址相同，因此它们根据相同的模型分配。（多播地址不是。）
- en: IPv6 Interface Identifiers and Physical Address Mapping
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6接口标识符和物理地址映射
- en: In IPv4, IP addresses have no relationship to the addresses used for underlying
    data link layer network technologies. A host that connects to a TCP/IP network
    using an Ethernet network interface card (NIC) has an Ethernet MAC address and
    an IP address, but the two numbers are distinct and unrelated in any way. IP addresses
    are assigned manually by administrators without any regard for the underlying
    physical address.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，IP地址与底层数据链路层网络技术使用的地址没有关系。一个使用以太网网络接口卡（NIC）连接到TCP/IP网络的宿主具有一个以太网MAC地址和一个IP地址，但这两个数字是不同的，并且以任何方式都不相关。IP地址是由管理员手动分配的，不考虑底层物理地址。
- en: With the overhaul of addressing in IPv6, an opportunity presented itself to
    create a better way of mapping IP unicast addresses and physical network addresses.
    Implementing this superior mapping technique was one of the reasons why IPv6 addresses
    were made so large. With 128 total bits, even with a full 45 bits reserved for
    the network prefix and 16 bits for the site subnet, we are still left with 64
    bits to use for the *interface identifier (interface ID)*, which is analogous
    to the host ID under IPv4.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 随着IPv6地址系统的全面更新，出现了一个机会，可以创建一种更好的方法来映射IP单播地址和物理网络地址。实施这种高级映射技术是IPv6地址被设计得如此大的原因之一。总共有128位，即使有45位被保留用于网络前缀和16位用于站点子网，我们仍然有64位可用于*接口标识符（接口ID）*，这在IPv4中类似于主机ID。
- en: 'Having so many bits at our disposal gives us great flexibility. Instead of
    using arbitrary, made-up identifiers for hosts, we can base the interface ID on
    the underlying data link layer hardware address, as long as that address is no
    greater than 64 bits in length. Since virtually all devices use layer 2 addresses
    of 64 bits or fewer, there is no problem in using those addresses for the interface
    ID in IP addresses. This provides an immediate benefit: It makes networks easier
    to administer, since we don''t need to record two arbitrary numbers for each host.
    The IP address can be derived from the MAC address and the network ID. It also
    means that we can tell the IP address from the MAC address and vice versa.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有如此多的位给我们带来了极大的灵活性。我们不再需要为宿主使用任意编造的标识符，只要底层数据链路层硬件地址的长度不超过64位，我们就可以基于该地址创建接口ID。由于几乎所有设备都使用64位或更短的第二层地址，因此将这些地址用于IP地址中的接口ID没有问题。这提供了一个直接的好处：它使得网络管理变得更加容易，因为我们不需要为每个宿主记录两个任意数字。IP地址可以从MAC地址和网络ID中推导出来。这也意味着我们可以从MAC地址和IP地址中区分开来，反之亦然。
- en: The actual mapping from data link layer addresses to IP interface IDs depends
    on the particular technology. It is essential that all devices on the same network
    use the same mapping technique, of course. By far, the most common type of layer
    2 addresses in networking are IEEE 802 MAC addresses, which are used by Ethernet
    and other IEEE 802 Project networking technologies. These addresses have 48 bits,
    arranged into two blocks of 24\. The upper 24 bits are arranged into a block called
    the *organizationally unique identifier (OUI)*, with different values assigned
    to individual organizations. The lower 24 bits are then used for an identifier
    for each specific device.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从数据链路层地址映射到IP接口ID取决于特定的技术。当然，同一网络上的所有设备使用相同的映射技术是至关重要的。到目前为止，网络中最常见的第二层地址是IEEE
    802 MAC地址，这些地址被以太网和其他IEEE 802项目网络技术所使用。这些地址有48位，分为两个24位的块。上面的24位被组织成一个称为*组织唯一标识符（OUI）*的块，不同的值分配给各个组织。下面的24位用于每个特定设备的标识符。
- en: The IEEE has also defined a format called the *64-bit extended unique identifier*,
    which is abbreviated *EUI-64*. It is similar to the 48-bit MAC format, except
    that while the OUI remains at 24 bits, the device identifier becomes 40 bits instead
    of 24\. This gives each manufacturer 65,536 times as many device addresses within
    its OUI.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE还定义了一种称为*64位扩展唯一标识符*的格式，简称*EUI-64*。它与48位的MAC格式相似，除了OUI保持为24位外，设备标识符变为40位而不是24位。这给每个制造商提供了65,536倍的设备地址空间在其OUI内。
- en: A form of this format, called *modified EUI-64*, has been adopted for IPv6 interface
    IDs. To get the modified EUI-64 interface ID for a device, you simply take the
    EUI-64 address and change the seventh bit from the left (the universal/local,
    or U/L, bit) from a 0 to a 1.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式的形式，称为*修改后的EUI-64*，已被采用作为IPv6接口ID。要获取设备的修改后的EUI-64接口ID，你只需将EUI-64地址并将第七位（通用/本地，或U/L，位）从0改为1。
- en: 'Of course, most devices still use the older 48-bit MAC address format. These
    can be converted to EUI-64 and then modified to EUI-64 form for creating an IPv6
    interface ID. The process is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数设备仍然使用旧的48位MAC地址格式。这些可以转换为EUI-64，然后修改为EUI-64形式以创建IPv6接口ID。过程如下：
- en: Take the 24-bit OUI portion, the leftmost 24 bits of the Ethernet address, and
    put them into the leftmost 24 bits of the interface ID. Take the 24-bit local
    portion (the rightmost 24 bits of the Ethernet address) and put it into the rightmost
    24 bits of the interface ID.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将24位的OUI部分，即以太网地址的最左边24位，放入接口ID的最左边24位。将24位的本地部分（以太网地址的最右边24位）放入接口ID的最右边24位。
- en: In the remaining 16 bits in the middle of the interface ID, put the value 11111111
    11111110, FFFE in hexadecimal.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接口ID中间的剩余16位中，放入值11111111 11111110，即十六进制的FF FE。
- en: The address is now in EUI-64 form. Change the universal/local bit (bit 7 from
    the left, shown in bold in [Figure 25-5](ch25s06.html#converting_ieee_802_mac_addresses_to_ipv
    "Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers"))
    from a 0 to a 1\. This gives the modified EUI-64 interface ID.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在地址处于EUI-64形式。将通用/本地位（从左数第七位，在[图25-5](ch25s06.html#converting_ieee_802_mac_addresses_to_ipv
    "图25-5. 将IEEE 802 MAC地址转换为IPv6修改后的EUI-64标识符")中用粗体表示）从0改为1。这给出了修改后的EUI-64接口ID。
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The last 64 bits of IPv6 unicast addresses are used for interface
    IDs, which are created in a special format called *modified EUI-64*. A simple
    process can be used to determine the interface ID from the 48-bit MAC address
    of a device like an Ethernet network interface card. This can then be combined
    with a network prefix (routing prefix and subnet ID) to determine a corresponding
    IPv6 address for the device.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6单播地址的最后64位用于接口ID，这些接口ID以称为*修改后的EUI-64*的特殊格式创建。可以使用一个简单的流程从类似以太网网络接口卡的48位MAC地址中确定接口ID。然后，可以将网络前缀（路由前缀和子网ID）与之结合，以确定设备的相应IPv6地址。'
- en: 'Let''s take as an example the Ethernet address of 39-A7-94-07-CB-D0\. Here
    are the steps for conversion (illustrated in [Figure 25-5](ch25s06.html#converting_ieee_802_mac_addresses_to_ipv
    "Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers")):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以39-A7-94-07-CB-D0的以太网地址为例。以下是转换步骤（在[图25-5](ch25s06.html#converting_ieee_802_mac_addresses_to_ipv
    "图25-5. 将IEEE 802 MAC地址转换为IPv6修改后的EUI-64标识符")中说明）：
- en: Take 39-A7-94, the first 24 bits of the identifier, and put it into the first
    (leftmost) 24 bits of the address. The local portion of 07-CB-D0 becomes the last
    24 bits of the identifier.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标识符的前24位39-A7-94放入地址的第一个（最左边的）24位。07-CB-D0的本地部分成为标识符的最后24位。
- en: The middle 16 bits are given the value FF-FE.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间的16位赋予值FF-FE。
- en: Change the seventh bit from 0 to 1, which changes the first octet from 39 to
    3B.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第七位从0改为1，这将第一个八位字节从39改为3B。
- en: The identifier thus becomes 3B-A7-94-FF-FE-07-CB-D0, or in IPv6 colon hexadecimal
    notation, 3BA7:94FF:FE07:CBD0\. The first 64 bits of the device's address are
    supplied using the global unicast address format.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，标识符变为3B-A7-94-FF-FE-07-CB-D0，或者用IPv6冒号十六进制表示法，3BA7:94FF:FE07:CBD0。设备地址的前64位使用全局单播地址格式提供。
- en: The only drawback of this technique is that if the physical hardware changes,
    so does the IPv6 address.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的唯一缺点是，如果物理硬件发生变化，IPv6地址也会发生变化。
- en: 'IPv6 Special Addresses: Reserved, Private, Unspecified, and Loopback'
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6特殊地址：保留、私有、未指定和环回
- en: Just as certain IPv4 address ranges are designated for reserved, private, and
    other unusual addresses, a small part of the monstrous IPv6 address space has
    been set aside for special addresses. The purpose of these addresses and address
    blocks is to provide addresses for special requirements and private use in IPv6
    networks. Since even relatively small pieces of IPv6 are still enormous, setting
    aside 0.1 percent of the address space for a particular use still generally yields
    more addresses than anyone will ever need.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如某些 IPv4 地址范围被指定用于保留、私有和其他不寻常的地址一样，IPv6 的巨大地址空间中的一部分也被预留用于特殊地址。这些地址和地址块的目的在于为
    IPv6 网络中的特殊需求和私有用途提供地址。由于即使是相对较小的 IPv6 地址空间也非常巨大，因此为特定用途预留地址空间的 0.1% 通常会产生比任何人需要的都多的地址。
- en: '![Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers](httpatomoreillycomsourcenostarchimages287877.png.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![将 IEEE 802 MAC 地址转换为 IPv6 修改后的 EUI-64 标识符](httpatomoreillycomsourcenostarchimages287877.png.jpg)'
- en: Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-5. 将 IEEE 802 MAC 地址转换为 IPv6 修改后的 EUI-64 标识符
- en: Special Address Types
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊地址类型
- en: 'There are four basic types of special IPv6 addresses:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 有四种基本类型的特殊地址：
- en: '**Reserved Addresses** A portion of the address space is set aside as reserved
    for various uses by the IETF, both present and future. Unlike IPv4, which has
    many small reserved blocks in various locations in the address space, the reserved
    block in IPv6 is at the "top" of the address space, beginning with 0000 0000 (or
    00 for the first hexadecimal octet). This represents 1/256th of the total address
    space. Some of the special addresses you''ll see shortly come from this block.
    IPv4 address embedding is also done within this reserved address area.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留地址** 地址空间的一部分被预留，供 IETF 现在和未来的各种用途使用。与地址空间中分散的多个小保留块不同，IPv6 中的保留块位于地址空间的“顶部”，从
    0000 0000（或第一个十六进制八位字节为 00）开始。这代表了总地址空间的 1/256。你很快就会看到的一些特殊地址就来自这个块。IPv4 地址嵌入也在此保留地址区域内进行。'
- en: Note
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Reserved addresses are not the same as unassigned addresses. The latter term
    just refers to blocks whose use has not yet been determined*.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*保留地址与未分配地址不同。后者仅指尚未确定用途的块*。'
- en: '**Private/Unregistered/Nonroutable Addresses** A block of addresses is set
    aside for private addresses, just as in IPv4, except that like everything in IPv6
    the private address block in IPv6 is much larger. These private addresses are
    local only to a particular link or site and, therefore, are never routed outside
    a particular company''s network. Private addresses are indicated by the address
    having "1111 1110 1" for the first nine bits. Thus, private addresses have a first
    octet value of FE in hexadecimal, with the next hexadecimal digit being from 8
    to F. These addresses are further divided into two types based on their scope:
    site-local and link-local, as discussed shortly.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有/未注册/不可路由地址** 与 IPv4 类似，预留了一块地址用于私有地址，但与 IPv6 中的所有事物一样，IPv6 中的私有地址块要大得多。这些私有地址仅限于特定的链路或站点本地，因此永远不会被路由到特定公司的网络之外。私有地址通过地址的前九位为“1111
    1110 1”来表示。因此，私有地址的十六进制第一个八位字节值为 FE，下一个十六进制数字为 8 到 F。这些地址根据它们的范围进一步分为两种类型：站点本地和链路本地，如稍后所述。'
- en: '**Loopback Address** Like IPv4, a provision has been made for a special loopback
    address for testing; datagrams sent to this address "loop back" to the sending
    device. However, in IPv6, there is just one address for this function, not a whole
    block (which was never needed in the first place). The loopback address is 0:0:0:0:0:0:0:1,
    which is normally expressed using zero compression as ::1.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**环回地址** 与 IPv4 类似，已经为测试目的预留了一个特殊的环回地址；发送到该地址的数据报文会“回环”到发送设备。然而，在 IPv6 中，只有一个这样的地址，而不是一个整个块（最初也从未需要过）。环回地址是
    0:0:0:0:0:0:0:1，通常使用零压缩表示为 ::1。'
- en: '**Unspecified Address** In IPv4, an IP address of all zeros has a special meaning:
    It refers to the host itself and is used when a device doesn''t know its own address.
    In IPv6, this concept has been formalized, and the all-zeros address (0:0:0:0:0:0:0:0)
    is named the *unspecified address*. It is typically used in the source field of
    a datagram sent by a device seeking to have its IP address configured. Zero compression
    can be applied to this address; since it is all zeros, the address becomes just
    ::. (I consider this confusing, myself. I think something like 0::0 is a lot clearer
    and short enough.)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**未指定地址** 在IPv4中，全零的IP地址具有特殊含义：它指的是主机本身，当设备不知道自己的地址时使用。在IPv6中，这个概念已经被正式化，全零地址（0:0:0:0:0:0:0:0）被称为*未指定地址*。它通常用于设备发送的报文源字段中，以配置其IP地址。可以对这个地址应用零压缩；由于它是全零，地址就变成了::。（我个人认为这很令人困惑。我认为像0::0这样的表示法既清晰又简洁。）'
- en: Tip
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**KEY CONCEPT** In IPv6, a special *loopback address*, 0:0:0:0:0:0:0:1 (::1
    in compressed form) is set aside for testing purposes. The *unspecified address*,
    0:0:0:0:0:0:0:0 (:: in compressed form) is used to indicate an unknown address.
    A block of *private* or *local* addresses is defined. This block is the set of
    all addresses beginning with 1111 1110 1 as the first nine bits.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在IPv6中，一个特殊的*环回地址*，0:0:0:0:0:0:0:1（压缩形式为::1）被预留用于测试目的。*未指定地址*，0:0:0:0:0:0:0:0（压缩形式为::）用于表示未知地址。定义了一个*私有*或*本地*地址块。这个块是所有以1111
    1110 1作为前九位开始的地址集合。'
- en: IPv6 Private Addresses Type Scopes
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**IPv6私有地址类型范围**'
- en: Now let's take a closer look at private addresses. In IPv6, these are called
    *local-use* addresses, with the name conveying clearly what they are for. They
    are also sometimes called *link-layer* addresses. You'll recall that IPv4 private
    addresses were commonly used when public addresses could not be obtained for all
    devices, sometimes in combination with technologies like Network Address Translation
    (NAT). In IPv6, trickery like NAT isn't required. Instead, local-use addresses
    are intended for communication that is inherently designed to be sent to local
    devices only. For example, neighbor discovery functions using the IPv6 Neighbor
    Discovery (ND) protocol employ local-use addresses.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来更详细地看看私有地址。在IPv6中，这些被称为*本地使用*地址，名称清楚地说明了它们的作用。它们有时也被称为*链路层*地址。你会记得，在无法为所有设备获取公共地址时，IPv4私有地址通常被使用，有时与网络地址转换（NAT）等技术结合使用。在IPv6中，不需要像NAT这样的技巧。相反，本地使用地址旨在用于仅设计为发送到本地设备的通信。例如，使用IPv6邻居发现（ND）协议的邻居发现功能采用本地使用地址。
- en: 'The *scope* of local addresses is obviously a local network, not the global
    scope of public Internet addresses. Local addresses in IPv6 are further divided
    into two types, reflecting a division of local scope:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本地地址的*范围*显然是本地网络，而不是公共互联网地址的全局范围。IPv6中的本地地址进一步分为两种类型，反映了本地范围的划分：
- en: '**Site-Local Addresses** These addresses have the scope of an entire site or
    organization. They allow addressing within an organization without having to use
    a public prefix. Routers will forward datagrams using site-local addresses within
    the site, but not addresses outside it to the public Internet. Site-local addresses
    are differentiated from link-local addresses by having a tenth bit of 1 following
    the nine starting address bits that are common to all private IPv6 addresses.
    Thus, they begin with 1111 1110 11\. In hexadecimal, site-local addresses begin
    with FE, and then C to F for the third digit. So, these addresses start with FEC,
    FED, FEE, or FEF.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**站点本地地址** 这些地址的范围是整个站点或组织。它们允许在组织内部进行寻址，而无需使用公共前缀。路由器将在站点内使用站点本地地址转发数据报，但不会将站点外的地址转发到公共互联网。站点本地地址通过在所有私有IPv6地址共有的九位起始地址之后有一个1位来与链路本地地址区分。因此，它们以1111
    1110 11开始。以十六进制表示，站点本地地址以FE开始，然后是第三位的C到F。因此，这些地址以FEC、FED、FEE或FEF开始。'
- en: '**Link-Local Addresses** These addresses have a smaller scope than site-local
    addresses; they refer only to a particular physical link (physical network). Routers
    will not forward datagrams using link-local addresses at all—not even within the
    organization. These addresses are only for local communication on a particular
    physical network segment. They can be used for address configuration or for ND
    functions such as address resolution and ND. Link-local addresses are differentiated
    from site-local addresses by having a tenth bit of 0 following the nine initial
    address bits common to all private IPv6 addresses: 1111 1110 1\. Thus, site-local
    addresses begin with FE, and then 8 to B for the third hexadecimal digit. So,
    these addresses start with FE8, FE9, FEA, or FEB.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**链路本地地址** 这些地址的范围比站点本地地址小；它们仅指特定的物理链路（物理网络）。路由器不会转发使用链路本地地址的数据报，甚至不在组织内部转发。这些地址仅用于特定物理网络段上的本地通信。它们可用于地址配置或用于ND功能，如地址解析和ND。链路本地地址通过在所有私有IPv6地址共有的前九位地址之后跟一个0位来区分站点本地地址：1111
    1110 1。因此，站点本地地址以FE开头，然后是第三十六进制位的8到B。因此，这些地址以FE8、FE9、FEA或FEB开头。'
- en: Tip
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** IPv6 site-local addresses allow data to be sent only to the
    devices within a site or organization. They begin with FEC, FED, FEE, or FEF in
    hexadecimal. IPv6 link-loca laddresses are used only on a particular local link
    (physical network), typically for special purposes such as address resolution
    or Neighbor Discovery (ND). They start with FE8, FE9, FEA, or FEB.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6站点本地地址只允许数据发送到站点或组织内的设备。它们以十六进制的FEC、FED、FEE或FEF开头。IPv6链路本地地址仅在特定的本地链路（物理网络）上使用，通常用于特殊目的，如地址解析或邻居发现（ND）。它们以FE8、FE9、FEA或FEB开头。'
- en: Note that site-local IPv6 addresses are the equivalent of IPv4 private addresses,
    since they are routed throughout the organization. The concept of link-local scope
    is new to IPv6.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，站点本地IPv6地址相当于IPv4私有地址，因为它们在整个组织中路由。链路本地范围的概念在IPv6中是新的。
- en: IPv6/IPv4 Address Embedding
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6/IPv4地址嵌入
- en: Due to the importance of IP and the significance of the changes made in IPv6,
    deployment of the newer version of the protocol will not occur all at once. A
    *transition* from IPv4 to IPv6 will be required. This transition requires careful
    planning. It is anticipated that the migration from IPv4 to IPv6 will take many
    years, as I mentioned earlier.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP的重要性以及IPv6中做出的变更的重要性，新版本的协议的部署不会一次性完成。需要从IPv4向IPv6的*过渡*。这次过渡需要周密的规划。正如我之前提到的，预计从IPv4到IPv6的迁移将需要很多年。
- en: IPv6 is backward-compatible with IPv4 provided that you use special techniques.
    For example, to enable communication between islands of IPv6 devices connected
    by IPv4 networks, you may need to employ tunneling. To support IPv4/IPv6 compatibility,
    a scheme was developed to allow IPv4 addresses to be *embedded* within the IPv6
    address structure. This method takes regular IPv4 addresses and puts them in a
    special IPv6 format, so that they are recognized as being IPv4 addresses by certain
    IPv6 devices.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用特殊技术，IPv6与IPv4向后兼容。例如，为了在通过IPv4网络连接的IPv6设备岛屿之间启用通信，您可能需要使用隧道。为了支持IPv4/IPv6兼容性，开发了一种方案，允许IPv4地址嵌入到IPv6地址结构中。这种方法将常规IPv4地址放入特殊的IPv6格式中，以便某些IPv6设备将其识别为IPv4地址。
- en: 'Since the IPv6 address space is so much bigger than the one in IPv4, embedding
    the latter within the former is easy—it''s like tucking a compact sedan into the
    hold of a cargo ship! The embedding address space is part of the reserved address
    block whose addresses begin with eight 0 bits, but it''s only a relatively small
    part. Two different embedding formats are used to indicate the capabilities of
    the device that''s using the embedded address:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IPv6地址空间比IPv4大得多，将后者嵌入前者很容易——就像将紧凑型轿车塞进货轮的货舱一样！嵌入地址空间是地址块的一部分，其地址以八个0位开始，但它只是相对较小的一部分。使用两种不同的嵌入格式来指示使用嵌入地址的设备的性能：
- en: '**IPv4-Compatible IPv6 Addresses** These are special addresses assigned to
    IPv6-capable devices, such as *dual-stack* devices that use both IPv4 and IPv6\.
    They have all zeros for the middle 16 bits; thus, they start off with a string
    of 96 zeros, followed by the IPv4 address. An example of such an address would
    be 0:0:0:0:0:0:101.45.75.219 in mixed notation, or more succinctly, ::101.45.75.219\.
    [Figure 25-6](ch25s07.html#ipv4-compatible_embedded_ipv6_address_re "Figure 25-6. IPv4-compatible
    embedded IPv6 address representation") illustrates IPv4-compatible IPv6 representation.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPv4兼容的IPv6地址** 这些是分配给IPv6兼容设备的特殊地址，例如同时使用IPv4和IPv6的 *双栈* 设备。它们中间的16位都是零；因此，它们以一串96个零位开始，后面跟着IPv4地址。这种地址的一个例子是混合表示法中的
    0:0:0:0:0:0:101.45.75.219，或者更简洁地，::101.45.75.219。[图25-6](ch25s07.html#ipv4-compatible_embedded_ipv6_address_re
    "图25-6. IPv4兼容的嵌入式IPv6地址表示") 展示了IPv4兼容的IPv6表示。'
- en: '**IPv4-Mapped IPv6 Addresses** These are regular IPv4 addresses that have been
    mapped into the IPv6 address space. They are used for devices that are IPv4-capable
    only. They have a set of 16 ones after the initial string of 80 zeros and then
    the IPv4 address. So if an IPv4 device has the address 222.1.41.90, such as the
    one shown in [Figure 25-7](ch25s07.html#ipv4-mapped_embedded_ipv6_address_repres
    "Figure 25-7. IPv4-mapped embedded IPv6 address representation"), it would be
    represented as 0:0:0:0:0:FFFF:222.1.41.90, or ::FFFF:222.1.41.90.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPv4映射IPv6地址** 这些是已映射到IPv6地址空间的常规IPv4地址。它们用于仅具有IPv4功能的设备。它们在初始的80个零位之后有一组16个一，然后是IPv4地址。所以如果一个IPv4设备具有地址
    222.1.41.90，例如[图25-7](ch25s07.html#ipv4-mapped_embedded_ipv6_address_repres "图25-7.
    IPv4映射的嵌入式IPv6地址表示") 中显示的设备，它将被表示为 0:0:0:0:0:FFFF:222.1.41.90，或者 ::FFFF:222.1.41.90。'
- en: '![IPv4-compatible embedded IPv6 address representation](httpatomoreillycomsourcenostarchimages287879.png.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4兼容的嵌入式IPv6地址表示](httpatomoreillycomsourcenostarchimages287879.png.jpg)'
- en: Figure 25-6. IPv4-compatible embedded IPv6 address representation
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-6. IPv4兼容的嵌入式IPv6地址表示
- en: The difference between these two is subtle but important. Both have zeros for
    the first 80 bits of the address and put the embedded IPv4 address into the last
    32 bits of the IPv6 address format. They differ in the value of the 16 remaining
    bits in between (bits 81 to 96, counting from the left). IPv4-compatible IPv6
    addresses are used only for devices that are actually IPv6-aware; the IPv4-compatible
    address is in addition to its conventional IPv6 address. In contrast, if the FFFF
    is seen for the 16 bits after the initial 80, this designates a conventional IPv4
    devices whose IPv4 address has been mapped into the IPv6 format. It is not an
    IPv6-capable device.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间的区别微妙但很重要。它们地址的前80位都是零，并将嵌入的IPv4地址放入IPv6地址格式的最后32位。它们在中间的16位（从左数第81位到第96位）的值不同。IPv4兼容的IPv6地址仅用于实际具有IPv6意识的设备；IPv4兼容的地址是其传统IPv6地址的补充。相比之下，如果在初始的80位之后看到FFFF，这表示一个传统的IPv4设备，其IPv4地址已被映射到IPv6格式。它不是一个具有IPv6功能的设备。
- en: '![IPv4-mapped embedded IPv6 address representation](httpatomoreillycomsourcenostarchimages287881.png.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4映射的嵌入式IPv6地址表示](httpatomoreillycomsourcenostarchimages287881.png.jpg)'
- en: Figure 25-7. IPv4-mapped embedded IPv6 address representation
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-7. IPv4映射的嵌入式IPv6地址表示
- en: Tip
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** *IPv4 address embedding* is used to create a relationship between
    an IPv4 address and an IPv6 address to help you transition from IPv4 to IPv6\.
    One type, the *IPv4-compatible IPv6 address*, is used for devices that are compatible
    with both IPv4 and IPv6; it begins with 96 zero bits. The other, the *IPv4-mapped
    address*, is used for mapping IPv4 devices that are not compatible with IPv6 into
    the IPv6 address space; it begins with 80 zeros followed by 16 ones.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *IPv4地址嵌入* 用于在IPv4地址和IPv6地址之间建立关系，以帮助您从IPv4过渡到IPv6。一种类型，即 *IPv4兼容的IPv6地址*，用于同时兼容IPv4和IPv6的设备；它以96个零位开始。另一种，即
    *IPv4映射地址*，用于将不兼容IPv6的IPv4设备映射到IPv6地址空间；它以80个零位开始，然后是16个一。'
- en: IPv6 Multicast and Anycast Addressing
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6多播和任播寻址
- en: One of the most significant modifications in the general addressing model in
    IPv6 was a change to the basic types of addresses and how they were used. Unicast
    addresses are still the choice for the vast majority of communications as in IPv4,
    but the "bulk" addressing methods are different in IPv6\. Broadcast as a specific
    addressing type has been eliminated. Instead, support for multicast addressing
    has been expanded and made a required part of the protocol, and a new type of
    addressing called *anycast* has been implemented.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6的通用寻址模型中，最显著的修改之一是对基本地址类型及其使用方式的改变。单播地址仍然像在IPv4中一样，是绝大多数通信的选择，但在IPv6中，“批量”寻址方法有所不同。作为特定寻址类型的广播已被消除。相反，对多播寻址的支持得到了扩展，并成为协议的必要部分，并实现了一种称为*任播*的新类型地址。
- en: IPv6 Multicast Addresses
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6多播地址
- en: Let's start by looking at multicast under IPv6\. Multicasting is used to allow
    a single device to send a datagram to a group of recipients. IPv4 supported multicast
    addressing using the Class D address block in the classful addressing scheme (see
    [Chapter 17](ch17.html "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING")). Under
    IPv6, multicast addresses are allocated from the multicast block. This is 1/256th
    of the address space, and it consists of all addresses that begin with 1111 1111\.
    Thus, any address starting with FF in colon hexadecimal notation is an IPv6 multicast
    address.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从IPv6下的多播开始看起。多播允许单个设备向一组接收者发送数据报。IPv4支持使用无类别寻址方案中的D类地址块进行多播寻址（见[第17章](ch17.html
    "第17章. 无类别（传统）寻址"））。在IPv6下，多播地址从多播块中分配。这是地址空间的1/256，它由所有以1111 1111开头的地址组成。因此，以冒号十六进制表示法以FF开头的任何地址都是IPv6多播地址。
- en: The remaining 120 bits of address space are enough to allow the definition of,
    well, a gazillion or three multicast addresses. (OK, it's officially about 1.3
    trillion trillion trillion addresses.) The allocation of unicast addresses was
    organized by using a special format to divide these many bits, and the same thing
    was done for multicast addresses. The format for multicast addresses is explained
    in [Table 25-6](ch25s08.html#ipv_multicast_address_format "Table 25-6. IPv6 Multicast
    Address Format") and illustrated in [Figure 25-8](ch25s08.html#ipv6_multicast_address_format
    "Figure 25-8. IPv6 multicast address format").
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的120位地址空间足以定义，嗯，数以亿计的多播地址。（好吧，官方数字大约是1.3万亿万亿万亿地址。）单播地址的分配是通过使用特殊格式来划分这些许多位来组织的，同样也用于多播地址。多播地址的格式在[表25-6](ch25s08.html#ipv_multicast_address_format
    "表25-6. IPv6多播地址格式")中解释，并在[图25-8](ch25s08.html#ipv6_multicast_address_format "图25-8. IPv6多播地址格式")中展示。
- en: '![IPv6 multicast address format](httpatomoreillycomsourcenostarchimages287883.png.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6多播地址格式](httpatomoreillycomsourcenostarchimages287883.png.jpg)'
- en: Figure 25-8. IPv6 multicast address format
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-8. IPv6多播地址格式
- en: Table 25-6. IPv6 Multicast Address Format
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 表25-6. IPv6多播地址格式
- en: '| Field Name | Size (Bits) | Description |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（位） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| (Indicator) | 8 | The first eight bits are always 1111 1111, which indicates
    a multicast address. This used to be called the *format prefix* before the term
    was dropped (as explained in the section about IPv6 address space allocation earlier
    in this chapter). The field now has no name. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| （指示符） | 8 | 前八位始终是1111 1111，这表示一个多播地址。在术语被取消之前，这被称为*格式前缀*（如本章前面关于IPv6地址空间分配的章节中所述）。该字段现在没有名称。|'
- en: '| Flags | 4 | Four bits are reserved for flags that can be used to indicate
    the nature of certain multicast addresses. Currently, the first three of these
    are unused and set to zero. The fourth is the T (Transient) flag. If left as zero,
    this marks the multicast address as a permanently assigned, well-known multicast
    address, as you will see shortly. If set to one, this means this is a *transient*
    multicast address, meaning that it is not permanently assigned. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 4 | 四位保留用于可以用来指示某些多播地址性质的标志。目前，这其中的前三个是未使用的，设置为0。第四个是T（瞬态）标志。如果保持为0，则将多播地址标记为永久分配的、众所周知的多播地址，正如你将很快看到的。如果设置为1，这意味着这是一个*瞬态*多播地址，意味着它不是永久分配的。|'
- en: '| Scope ID | 4 | These four bits are used to define the scope of the multicast
    address; 16 different values from 0 to 15 are possible. This field allows creation
    of multicast addresses that are global to the entire Internet, or restricted to
    smaller spheres of influence such as a specific organization, site, or link. The
    currently defined values (in decimal) are as follows:0 = Reserved1 = Node-Local
    Scope 2 = Link-Local Scope5 = Site-Local Scope8 = Organization-Local Scope14 =
    Global Scope15 = Reserved |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 范围ID | 4 | 这四个位用于定义多播地址的范围；从0到15的16个不同值是可能的。该字段允许创建全局多播地址，或限制在更小的范围，如特定组织、站点或链路。当前定义的值（十进制）如下：0
    = 保留1 = 节点本地范围 2 = 链路本地范围5 = 站点本地范围8 = 组织本地范围14 = 全局范围15 = 保留 |'
- en: '| Group ID | 112 | Defines a particular group within each scope level. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 群组ID | 112 | 定义每个范围级别内的特定组。 |'
- en: Multicast Scopes
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多播范围
- en: 'The notion of explicitly scoping multicast addresses is important. Globally
    scoped multicast addresses must be unique across the entire Internet, but locally
    scoped addresses are unique only within the organization. This provides tremendous
    flexibility, as every type of multicast address actually comes in several versions:
    one that multicasts only within a node, one that multicasts on the local link
    (local network), one that multicasts on the local site, and so on. The scope also
    allows routers to immediately determine how broadly they should propagate multicast
    datagrams in order to improve efficiency and eliminate problems with traffic being
    sent outside the are a for which it is intended. [Figure 25-9](ch25s08.html#ipv6_multicast_scope_this_diagram_shows_
    "Figure 25-9. IPv6 multicast scope This diagram shows how the notion of scope
    allows IPv6 multicasts to be limited to specific spheres of influence. The tightest
    scope is node-local scope, with a scope ID value of 1\. As the scope ID value
    increases, the scope expands to cover the local network, site, organization, and
    finally, entire Internet.") illustrates the notion of multicast scope graphically.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 显式定义多播地址的范围的概念非常重要。全局范围的多播地址在整个互联网中必须是唯一的，但本地范围地址仅在组织内部是唯一的。这提供了极大的灵活性，因为每种类型的多播地址实际上都有几个版本：一个只在节点内部多播的版本，一个在本地链路（本地网络）上多播的版本，一个在本地站点上多播的版本，等等。范围还允许路由器立即确定它们应该将多播数据报传播得多广，以提高效率并消除将流量发送到预期范围之外的问题。[图25-9](ch25s08.html#ipv6_multicast_scope_this_diagram_shows_
    "图25-9. IPv6多播范围 此图展示了范围的概念如何使IPv6多播限制在特定的影响范围内。最紧密的范围是节点本地范围，其范围ID值为1。随着范围ID值的增加，范围扩展以覆盖本地网络、站点、组织，最终涵盖整个互联网。")以图形方式说明了多播范围的概念。
- en: Tip
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Multicast addresses are used to send data to a number of devices
    on an internetwork simultaneously. In IPv6, each multicast address can be specified
    for a variety of different scopes, thereby allowing a transmission to be targeted
    to either a wide or a narrow audience of recipient devices.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 多播地址用于向互联网上的多个设备同时发送数据。在IPv6中，每个多播地址可以指定为各种不同的范围，从而允许将传输针对广泛的或狭窄的接收设备受众。'
- en: '![IPv6 multicast scope This diagram shows how the notion of scope allows IPv6
    multicasts to be limited to specific spheres of influence. The tightest scope
    is node-local scope, with a scope ID value of 1\. As the scope ID value increases,
    the scope expands to cover the local network, site, organization, and finally,
    entire Internet.](httpatomoreillycomsourcenostarchimages287885.png.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6多播范围 此图展示了范围的概念如何使IPv6多播限制在特定的影响范围内。最紧密的范围是节点本地范围，其范围ID值为1。随着范围ID值的增加，范围扩展以覆盖本地网络、站点、组织，最终涵盖整个互联网。](httpatomoreillycomsourcenostarchimages287885.png.jpg)'
- en: Figure 25-9. IPv6 multicast scope This diagram shows how the notion of scope
    allows IPv6 multicasts to be limited to specific spheres of influence. The tightest
    scope is node-local scope, with a scope ID value of 1\. As the scope ID value
    increases, the scope expands to cover the local network, site, organization, and
    finally, entire Internet.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-9. IPv6多播范围 此图展示了范围的概念如何使IPv6多播限制在特定的影响范围内。最紧密的范围是节点本地范围，其范围ID值为1。随着范围ID值的增加，范围扩展以覆盖本地网络、站点、组织，最终涵盖整个互联网。
- en: Well-Known Multicast Addresses
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见多播地址
- en: The Transient flag allows for the explicit determination of which multicast
    addresses are available for normal use compared to which ones are set aside as
    well known. Several well-known multicast addresses are defined by setting aside
    certain group IDs that are used for a number of different scope ID values. [Table 25-7](ch25s08.html#important_ipv_well-known_multicast_addre
    "Table 25-7. Important IPv6 Well-Known Multicast Addresses") shows these values;
    the *x* in the multicast address pattern is the hexadecimal digit corresponding
    to the four-bit scope ID field.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 临时标志允许显式确定哪些多播地址可用于正常使用，与哪些保留为已知地址。通过保留用于多个范围ID值的一定数量的组ID来定义几个已知的多播地址。 [表25-7](ch25s08.html#important_ipv_well-known_multicast_addre
    "表25-7. 重要IPv6已知多播地址")显示了这些值；多播地址模式中的*x*是多位范围ID字段对应的十六进制数字。|
- en: The all-nodes and all-routers multicast addresses enable the equivalent function
    of what broadcast used to perform in IPv4\. Again, the concept of scope is important
    in a multicast of this type, because we don't want to try to send a message to
    all nodes on the global Internet, for example. So when the all-routers address
    is used with a scope value of 2, it means "all routers on the local link." If
    it is used with a value of 5, it means "all routers in this site."
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点和所有路由器的多播地址实现了IPv4中广播所执行的功能的等效功能。同样，在这种类型的多播中，范围的概念非常重要，因为我们不希望尝试向全球互联网上的所有节点发送消息，例如。因此，当使用具有范围值2的全路由器地址时，意味着“本地链路上的所有路由器。”如果使用值为5，则意味着“本站点的所有路由器。”
- en: Solicited-Node Multicast Addresses
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求节点多播地址
- en: In addition to the regular multicast addresses, each unicast address has a special
    multicast address called its *solicited-node address*. This address is created
    through a special mapping from the device's unicast address. Solicited-node addresses
    are used by the IPv6 ND protocol (see [Chapter 36](ch36.html "Chapter 36. IPV6
    NEIGHBOR DISCOVERY (ND) PROTOCOL")) to provide more efficient address resolution
    than the Address Resolution Protocol (ARP; see [Chapter 13](ch13.html "Chapter 13. ADDRESS
    RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")) technique used
    in IPv4.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的多播地址外，每个单播地址还有一个特殊的多播地址，称为其请求节点地址。此地址通过从设备的单播地址进行特殊映射创建。请求节点地址由IPv6 ND协议（参见[第36章](ch36.html
    "第36章. IPv6邻居发现(ND)协议"））使用，以提供比IPv4中使用的地址解析协议（ARP；参见[第13章](ch13.html "第13章. 地址解析和TCP/IP地址解析协议(ARP)"））技术更有效的地址解析。
- en: Table 25-7. Important IPv6 Well-Known Multicast Addresses
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表25-7. 重要IPv6已知多播地址
- en: '| Multicast Address Pattern | Valid Scope Values (Decimal) | Designation |
    Description |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 多播地址模式 | 有效范围值（十进制） | 标识 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| FF0x:0:0:0:0:0:0 | 0 to 15 | Reserved | All multicast addresses where the
    112-bit group ID is zero are reserved. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| FF0x:0:0:0:0:0:0 | 0到15 | 保留 | 所有112位组ID为零的多播地址都是保留的。|'
- en: '| FF0x:0:0:0:0:0:1 | 1, 2 | All Nodes | When the group ID is equal to exactly
    1, this is a multicast to all nodes. Both node-local (FF01:0:0:0:0:0:1) and link-local
    (FF02:0:0:0:0:0:1) all-nodes multicast addresses are possible. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| FF0x:0:0:0:0:0:1 | 1, 2 | 所有节点 | 当组ID恰好等于1时，这表示向所有节点进行多播。既可以是节点本地（FF01:0:0:0:0:0:1）也可以是链路本地（FF02:0:0:0:0:0:1）的所有节点多播地址。|'
- en: '| FF0x:0:0:0:0:0:2 | 1, 2, 5 | All Routers | When the group ID is equal to
    exactly 2, this designates all routers within a specific scope as the recipients.
    Valid scope values are node-local, link-local, and site-local. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| FF0x:0:0:0:0:0:2 | 1, 2, 5 | 所有路由器 | 当组ID恰好等于2时，这指定了特定范围内的所有路由器作为接收者。有效的范围值包括节点本地、链路本地和站点本地。|'
- en: 'All solicited-node addresses have their T flag set to zero and a scope ID of
    2, so they start with FF02\. The 112-bit group ID is broken down as follows (see
    [Figure 25-10](ch25s08.html#ipv6_solicited-node_address_calculation_ "Figure 25-10. IPv6
    solicited-node address calculation The solicited-node multicast address is calculated
    from a unicast address by taking the last 24 bits of the address and prepending
    them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows the example address
    from Figure 25-2 converted to its solicited-node address, FF02::1:FFC8:1FFF.")):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求节点地址的T标志都设置为0，并且具有范围ID 2，因此它们以FF02开头。112位的组ID如下分解（参见[图25-10](ch25s08.html#ipv6_solicited-node_address_calculation_
    "图25-10. IPv6请求节点地址计算 请求节点多播地址是通过从地址的最后24位开始，并在IPv6部分地址FF02:0:0:0:0:0:1:FF之前添加它们来计算的。这显示了图25-2中的示例地址转换为它的请求节点地址，FF02::1:FFC8:1FFF。"）：
- en: Eighty bits consisting of 79 zeros followed by a single one. This means that
    the next five hexadecimal values are 0000:0000:0000:0000:0001 in colon hexadecimal
    notation, or more succinctly, 0:0:0:0:1.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由79个零和一个一组成的80位。这意味着接下来的五个十六进制值是 0000:0000:0000:0000:0001，用冒号十六进制表示法表示，或者更简洁地说，是
    0:0:0:0:1。
- en: 'Eight ones: FF.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个一：FF。
- en: Twenty-four bits taken from the bottom 24 bits of its unicast address.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其单播地址的最低24位中取出的24位。
- en: So, these addresses start with FF02:0:0:0:0:1:FF, followed by the bottom 24
    bits of the unicast address. Thus, the node with IP address 805B:2D9D:DC28:0:0:FC57:D4C8:1FFF
    would have a solicited-node address of FF02:0:0:0:0:1:FFC8:1FFF (or FF02::1:FFC8:1FFF).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些地址以 FF02:0:0:0:0:1:FF 开头，后面跟着单播地址的最低24位。因此，具有IP地址 805B:2D9D:DC28:0:0:FC57:D4C8:1FFF
    的节点将有一个 solicited-node 地址为 FF02:0:0:0:0:1:FFC8:1FFF（或 FF02::1:FFC8:1FFF）。
- en: '![IPv6 solicited-node address calculation The solicited-node multicast address
    is calculated from a unicast address by taking the last 24 bits of the address
    and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows
    the example address from converted to its solicited-node address, FF02::1:FFC8:1FFF.](httpatomoreillycomsourcenostarchimages287887.png.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6 solicited-node address calculation The solicited-node multicast address
    is calculated from a unicast address by taking the last 24 bits of the address
    and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows
    the example address from converted to its solicited-node address, FF02::1:FFC8:1FFF.](httpatomoreillycomsourcenostarchimages287887.png.jpg)'
- en: Figure 25-10. IPv6 solicited-node address calculation The solicited-node multicast
    address is calculated from a unicast address by taking the last 24 bits of the
    address and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This
    shows the example address from [Figure 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses.") converted to its solicited-node
    address, FF02::1:FFC8:1FFF.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-10. IPv6 solicited-node address calculation The solicited-node multicast
    address is calculated from a unicast address by taking the last 24 bits of the
    address and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This
    shows the example address from [Figure 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses.") 转换为其 solicited-node
    地址，FF02::1:FFC8:1FFF。
- en: Tip
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Each unicast address has an equivalent *solicited-node multicast
    address* that is created from the unicast address and used when other devices
    need to reach it on the local network.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个单播地址都有一个等效的 *solicited-node multicast address*，它是由单播地址创建的，并在其他设备需要在本地网络上访问它时使用。'
- en: IPv6 Anycast Addresses
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 Anycast Addresses
- en: Anycast addresses are a unique type of address that is new to IP in IPv6\. The
    IPv6 implementation is based on the material in RFC 1546, "Host Anycasting Service."
    Anycast addresses can be considered a conceptual cross between unicast and multicast
    addressing. Where unicast says, "Send this to one address," and multicast says,
    "Send this to every member of this group," anycast says, "Send this to any one
    member of this group." Naturally, in choosing which member to send to, we would,
    for efficiency, normally send to the closest one—that is, the closest in routing
    terms. So, we can normally also consider *anycast* to mean, "Send this to the
    closest member of this group."
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Anycast addresses are a unique type of address that is new to IP in IPv6\. The
    IPv6 implementation is based on the material in RFC 1546, "Host Anycasting Service."
    Anycast addresses can be considered a conceptual cross between unicast and multicast
    addressing. Where unicast says, "Send this to one address," and multicast says,
    "Send this to every member of this group," anycast says, "Send this to any one
    member of this group." Naturally, in choosing which member to send to, we would,
    for efficiency, normally send to the closest one—that is, the closest in routing
    terms. So, we can normally also consider *anycast* to mean, "Send this to the
    closest member of this group."
- en: The idea behind anycast is to enable functionality that was previously difficult
    to implement in TCP/IP. Anycast was specifically intended to provide flexibility
    in situations where we need a service that is provided by a number of different
    servers or routers but don't really care which one provides it. In routing, anycast
    allows datagrams to be sent to whichever router in a group of equivalent routers
    is closest, and to allow load sharing among routers and dynamic flexibility if
    certain routers go out of service. Datagrams sent to the anycast address will
    automatically be delivered to the device that is easiest to reach.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Anycast背后的想法是使TCP/IP中以前难以实现的功能成为可能。Anycast特别旨在在需要由多个不同服务器或路由器提供的服务的情况下提供灵活性，而我们并不关心哪个提供它。在路由方面，Anycast允许数据报被发送到一组等效路由器中最近的任何一个路由器，并允许在路由器之间进行负载均衡，如果某些路由器停止服务，还可以提供动态灵活性。发送到Anycast地址的数据报将自动交付到最易到达的设备。
- en: Perhaps surprisingly, there is no special anycast-addressing scheme. Anycast
    addresses are the same as unicast addresses. An anycast address is created automatically
    when a unicast address is assigned to more than one interface.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，没有特殊的Anycast寻址方案。Anycast地址与单播地址相同。当单播地址分配给多个接口时，Anycast地址会自动创建。
- en: Tip
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Anycast addresses are new in IPv6 and can be used to set up
    a group of devices, any one of which can respond to a request sent to a single
    IP address.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Anycast地址是IPv6中的新功能，可以用来设置一组设备，其中任何一个都可以对发送到单个IP地址的请求做出响应。'
- en: Like multicast, anycast creates more work for routers, because it is more complicated
    than unicast addressing. In particular, the further apart the devices that share
    the anycast address are, the more complexity. Anycasting across the global Internet
    would be potentially difficult to implement, and IPv6 anycasting was designed
    for devices that are proximate to each other, generally within the same network.
    Also, at present, due to the Internet community's relative inexperience with anycast,
    only routers, not individual hosts, use anycast addresses.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 与多播一样，Anycast为路由器增加了更多的工作量，因为它的复杂性比单播寻址更高。特别是，共享Anycast地址的设备距离越远，复杂性就越高。在全球互联网上进行Anycasting可能难以实现，IPv6
    Anycasting是为彼此靠近的设备设计的，通常在同一网络内。此外，目前由于互联网社区对Anycast的相对不熟悉，只有路由器，而不是单个主机，使用Anycast地址。
- en: IPv6 Autoconfiguration and Renumbering
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 自动配置和重新编号
- en: One of the most interesting and potentially valuable addressing features implemented
    in IPv6 is a facility that allows devices on an IPv6 network to actually configure
    themselves independently. In IPv4, hosts were originally configured manually.
    Later, host configuration protocols like the Dynamic Host Configuration Protocol
    (DHCP; see [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION
    CONCEPTS")) enabled servers to allocate IP addresses to hosts that joined the
    network. IPv6 takes this a step further by defining a method for some devices
    to automatically configure their IP address and other parameters without the need
    for a server. It also defines a method whereby the IP addresses on a network can
    be renumbered (changed en masse). These are the sorts of features that make TCP/IP
    network administrators drool.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中实现的最有趣和可能最有价值的寻址功能之一是允许IPv6网络上的设备独立配置自己的功能。在IPv4中，主机最初是手动配置的。后来，如动态主机配置协议（DHCP；见[第61章](ch61.html
    "第61章。DHCP概述和地址分配概念"））之类的主机配置协议使服务器能够将IP地址分配给加入网络的设备。IPv6通过定义一种方法，使某些设备能够自动配置其IP地址和其他参数，而无需服务器，从而更进一步。它还定义了一种方法，通过这种方法，网络上的IP地址可以被重新编号（批量更改）。这些就是让TCP/IP网络管理员垂涎三尺的功能。
- en: The IPv6 autoconfiguration and renumbering feature is defined in RFC 2462, "IPv6
    Stateless Address Autoconfiguration." The word *stateless* contrasts this method
    to the server-based method using something like DHCPv6, which is called *stateful*.
    (This word, like *classful*, makes me cringe.) This method is called stateless
    because it begins with no information (or *state*) at all for the host to work
    with. It has no need for a DHCP server.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 自动配置和重新编号功能在RFC 2462中定义，即“IPv6 无状态地址自动配置”。单词 *无状态* 与使用类似DHCPv6的服务器端方法形成对比，后者被称为
    *有状态*。（这个词，就像 *类属*，让我感到不舒服。）这种方法被称为无状态，因为它开始时对主机来说没有任何信息（或 *状态*）可以工作。它不需要DHCP服务器。
- en: IPv6 Stateless Autoconfiguration
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 无状态自动配置
- en: Stateless autoconfiguration exploits several other new features in IPv6, including
    link-local addresses, multicasting, the ND protocol, and the ability to generate
    the interface ID of an address from the underlying data link layer address. The
    general idea is to have a device generate a temporary address until it can determine
    the characteristics of the network it is on, and then create a permanent address
    it can use based on that information. In the case of multihomed devices, autoconfiguration
    is performed for each interface separately.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态自动配置利用IPv6中的几个其他新特性，包括链路本地地址、多播、ND协议以及从底层数据链路层地址生成地址接口ID的能力。一般想法是让设备生成一个临时地址，直到它可以确定它所在的网络特性，然后根据该信息创建一个可以使用的永久地址。在多宿主设备的情况下，为每个接口分别执行自动配置。
- en: 'The following is a summary of the steps a device takes when using stateless
    autoconfiguration:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设备在使用无状态自动配置时采取的步骤摘要：
- en: '**Link-Local Address Generation** The device generates a link-local address.
    You''ll recall that this is one of the two types of local-use IPv6 addresses.
    Link-local addresses have 1111 1110 10 for the first 10 bits. The generated address
    uses those 10 bits, followed by 54 zeros and then the 64-bit interface ID. Typically,
    this will be derived from the data link layer (MAC) address as explained in the
    "IPv6 Interface Identifiers and Physical Address Mapping" section earlier in this
    chapter, or it may be a "token" generated in some other manner.'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链路本地地址生成** 设备生成一个链路本地地址。你会记得这是两种本地使用IPv6地址之一。链路本地地址的前10位是1111 1110 10。生成的地址使用这10位，然后是54个零，接着是64位的接口ID。通常，这将从本章前面“IPv6接口标识符和物理地址映射”部分中解释的数据链路层（MAC）地址派生出来，或者它可能以某种其他方式生成一个“令牌”。'
- en: '**Link-Local Address Uniqueness Test** The node tests to ensure that the address
    it generated isn''t already in use on the local network. (This is very unlikely
    to be an issue if the link-local address came from a MAC address; it is more likely
    that the address is already in use if it was based on a generated token.) It sends
    a Neighbor Solicitation message using the ND protocol. In response, it listens
    for a Neighbor Advertisement, which indicates that another device is already using
    its link-local address. If so, either a new address must be generated or autoconfiguration
    fails, and another method must be employed.'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链路本地地址唯一性测试** 节点测试以确保它生成的地址在本地网络中尚未被使用。（如果链路本地地址来自MAC地址，这种情况很少会出现问题；如果它是基于生成的令牌，则地址已被使用的可能性更大。）它使用ND协议发送一个邻居请求消息。作为回应，它监听邻居通告，这表明另一个设备已经在使用它的链路本地地址。如果是这样，则必须生成一个新的地址或自动配置失败，并必须采用另一种方法。'
- en: '**Link-Local Address Assignment** Assuming the uniqueness test passes, the
    device assigns the link-local address to its IP interface. This address can be
    used for communication on the local network, but not on the wider Internet (since
    link-local addresses are not routed).'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链路本地地址分配** 假设唯一性测试通过，设备将链路本地地址分配给其IP接口。此地址可用于本地网络上的通信，但不能用于更广泛的互联网（因为链路本地地址不进行路由）。'
- en: '**Router Contact** The node next attempts to contact a local router for more
    information on continuing the configuration. This is done either by listening
    for Router Advertisement messages sent periodically by routers or by sending a
    specific Router Solicitation message to ask a router for information on what to
    do next. This process is described in the section on the IPv6 ND protocol, in
    [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL").'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路由器接触** 节点接下来尝试接触本地路由器以获取有关继续配置的更多信息。这是通过监听路由器定期发送的路由器通告消息或通过发送特定的路由器请求消息来询问路由器下一步要做什么来完成的。这个过程在IPv6
    ND协议的章节中描述，见[第36章](ch36.html "第36章。IPV6 邻居发现（ND）协议")。'
- en: '**Router Direction** The router provides direction to the node about how to
    proceed with the autoconfiguration. It may tell the node that on this network
    stateful autoconfiguration is in use, and it may give it the address of a DHCP
    server to use. Alternatively, it will tell the host how to determine its global
    Internet address.'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路由器方向** 路由器向节点提供有关如何进行自动配置的指示。它可能告诉节点在这个网络中正在使用有状态自动配置，并可能提供要使用的DHCP服务器的地址。或者，它将告诉主机如何确定其全球互联网地址。'
- en: '**Global Address Configuration** Assuming that stateless autoconfiguration
    is in use on the network, the host will configure itself with its globally unique
    Internet address. This address is generally formed from a network prefix provided
    to the host by the router. The prefix is combined with the device''s identifier,
    as generated in step 1.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全局地址配置** 假设网络中正在使用无状态自动配置，主机将使用其全局唯一的互联网地址进行配置。该地址通常由路由器提供给主机的网络前缀形成。前缀与设备标识符相结合，该标识符在第
    1 步中生成。'
- en: Clearly, this method has numerous advantages over both manual and server-based
    configuration. It is particularly helpful in supporting the mobility of IP devices,
    because they can move to new networks and get a valid address without any knowledge
    of local servers or network prefixes. At the same time, it still allows for the
    management of IP addresses using the (IPv6-compatible) version of DHCP, if that
    is desired. Routers on the local network will typically tell hosts which type
    of autoconfiguration is supported using special flags in Internet Control Message
    Protocol version 6 (ICMPv6) Router Advertisement messages (see [Chapter 35](ch35.html
    "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS")).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法在手动和基于服务器的配置方法之上具有许多优势。它在支持 IP 设备的移动性方面尤其有用，因为它们可以移动到新的网络并获得有效的地址，而无需了解本地服务器或网络前缀。同时，如果需要，它仍然允许使用（IPv6
    兼容的）DHCP 版本来管理 IP 地址。本地网络上的路由器通常会通过在 Internet 控制消息协议第 6 版（ICMPv6）路由器通告消息中的特殊标志来告诉主机支持哪种类型的自动配置（参见[第
    35 章](ch35.html "第 35 章。ICMPV6 信息消息类型和格式")）。
- en: Tip
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** IPv6 includes an interesting feature called *stateless address
    autoconfiguration*, which allows a host to actually determine its own IPv6 address
    from its layer 2 address by following a special procedure.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6 包含一个有趣的功能，称为“无状态地址自动配置”，它允许主机通过遵循一个特殊程序，从其第 2 层地址确定自己的 IPv6 地址。'
- en: IPv6 Device Renumbering
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 设备重编号
- en: The renumbering of devices is a method related to autoconfiguration. Like host
    configuration, it can be implemented using protocols like DHCP through the use
    of IP address leases that expire after a period of time. Under IPv6, networks
    can be renumbered by having routers specify an expiration interval for network
    prefixes when autoconfiguration is done. Later, they can send a new prefix to
    tell devices to regenerate their IP addresses. Devices can actually maintain the
    old deprecated address for a while, and then move over to the new address.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 设备重编号是与自动配置相关的方法。像主机配置一样，它可以通过使用像 DHCP 这样的协议，通过使用在一段时间后到期的 IP 地址租约来实现。在 IPv6
    中，网络可以通过在自动配置时让路由器指定网络前缀的过期间隔来重编号。稍后，它们可以发送一个新的前缀来告诉设备重新生成它们的 IP 地址。设备实际上可以保持旧的不推荐地址一段时间，然后迁移到新地址。
- en: RFC 2894 defined a similar technique for renumbering router addresses. It uses
    special ICMPv6 messages and is described in [Chapter 35](ch35.html "Chapter 35. ICMPV6
    INFORMATIONAL MESSAGE TYPES AND FORMATS").
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2894 定义了一种用于重编号路由器地址的类似技术。它使用特殊的 ICMPv6 消息，并在[第 35 章](ch35.html "第 35 章。ICMPV6
    信息消息类型和格式")中描述。
- en: Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 26 章。IPv6 数据报封装和格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Delivery of data over Internet Protocol version 6 (IPv6) internetworks is accomplished
    by encapsulating higher-layer data into IPv6 datagrams. These serve the same general
    purpose for IPv6 as IPv4 datagrams do in the older version of the protocol. However,
    they have been redesigned as part of the overall changes represented by IPv6\.
    IPv6 datagrams have a flexible structure, and their format better matches the
    needs of current IP networks.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Internet 协议版本 6（IPv6）互联网中传输数据是通过将高层数据封装到 IPv6 数据报中实现的。这些在 IPv6 中起到与 IPv4 数据报在旧版协议中相同的一般作用。然而，它们作为
    IPv6 所代表的整体变化的组成部分进行了重新设计。IPv6 数据报具有灵活的结构，其格式更好地满足当前 IP 网络的需求。
- en: In this chapter, I take a look at the format used for IPv6 datagrams. I begin
    with an overview of the general structure of IPv6 datagrams, describe the major
    changes, and show how main and extension headers are arranged in the datagram.
    I then describe the format of the main header, and define and describe the various
    extension header types. I conclude with a brief explanation of IPv6 options and
    how they are implemented.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将探讨 IPv6 数据报使用的格式。我首先概述 IPv6 数据报的一般结构，描述主要变更，并展示主头部和扩展头部在数据报中的排列方式。然后，我描述主头部的格式，定义并描述各种扩展头部类型。最后，我简要解释
    IPv6 选项及其实现方式。
- en: Tip
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**BACKGROUND INFORMATION** *This chapter assumes basic understanding of IPv6
    addressing concepts (see the previous chapter) and general familiarity with the
    IPv4 datagram format (described in [Chapter 21](ch21.html "Chapter 21. INTERNET
    PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING"))*.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *本章假设读者对 IPv6 地址概念有基本理解（参见上一章）并且对 IPv4 数据报格式有一般了解（在第 21 章中描述）*。'
- en: IPv6 Datagram Overview and General Structure
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 数据报概述和一般结构
- en: The method by which IPv6 encapsulates data received from higher-layer protocols
    for transmission across the internetwork is basically the same as the one used
    by IPv4\. The data received from the transport or higher layers is made the payload
    of an IPv6 datagram, which has one or more headers that control the delivery of
    the message. These headers provide information to routers in order to enable them
    to move the datagram across the network. They also provide information to hosts
    so they can tell which datagrams they are intended to receive.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 封装从高层协议接收的数据以在互联网中传输的方法基本上与 IPv4 使用的方法相同。从传输或更高层接收的数据被作为 IPv6 数据报的有效负载，该数据报有一个或多个头部，用于控制消息的传递。这些头部向路由器提供信息，以便它们能够将数据报移动到网络中。它们还向主机提供信息，以便它们可以知道哪些数据报是针对它们的。
- en: 'While the basic use of datagrams hasn''t changed since IPv4, many modifications
    were made to their structure and format when IPv6 was created. This was done partly
    out of necessity: IPv6 addresses are different from IPv4 addresses, and IP addresses
    go in the datagram header. The increase in the size of IP addresses from 32 bits
    to 128 bits adds a whopping extra 192 bits, or 24 bytes, of information to the
    header. This led to an effort to remove fields that weren''t strictly necessary
    in order to compensate for the necessary increase in size. However, changes were
    also made to IPv6 datagrams to add features to them and to make them better suit
    the needs of modern internetworking.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自 IPv4 以来数据报的基本使用没有改变，但在创建 IPv6 时对其结构和格式进行了许多修改。这主要是出于必要性：IPv6 地址与 IPv4 地址不同，IP
    地址位于数据报头部。IP 地址从 32 位增加到 128 位，在头部中增加了惊人的额外 192 位，即 24 字节的信息。这导致了一个努力，以移除那些并非绝对必要的字段，以补偿必要的尺寸增加。然而，对
    IPv6 数据报的变更也包括添加功能以及使它们更好地满足现代互联网的需求。
- en: 'The following is a list of the most significant overall changes to datagrams
    in IPv6:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 IPv6 中数据报最显著的总体变更列表：
- en: '**Multiple-Header Structure** Rather than a single header that contains all
    fields for the datagram (possibly including options), the IPv6 datagram supports
    a main header and then extension headers for additional information when needed.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重头部结构** 与包含所有字段（可能包括选项）的单个头部不同，IPv6 数据报支持一个主头部，并在需要时支持扩展头部以提供附加信息。'
- en: '**Streamlined Header Format** Several fields have been removed from the main
    header to reduce its size and increase efficiency. Only the fields that are truly
    required for pretty much *all* datagrams remain in the main header; others are
    put into extension headers and used as needed. Some were removed because they
    were no longer needed, such as the Internet Header Length field. The IPv6 header
    is of fixed length. I''ll examine this more thoroughly in a moment.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**精简头部格式** 已从主头部中删除了几个字段，以减小其大小并提高效率。只有真正对几乎所有数据报都必需的字段保留在主头部中；其他字段被放入扩展头部中，并在需要时使用。一些字段被删除，因为它们不再需要，例如互联网头部长度字段。IPv6
    头部长度是固定的。我将在稍后更详细地检查这一点。'
- en: '**Renamed Fields** Some fields have been renamed to better reflect their actual
    use in modern networks.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**重命名字段** 一些字段已被重命名，以更好地反映它们在现代网络中的实际用途。'
- en: '**Greater Flexibility** The extension headers allow for a great deal of extra
    information that will accompany datagrams when needed. Options are also supported
    in IPv6.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**更大的灵活性** 扩展头允许在需要时伴随数据报传输大量额外信息。IPv6 也支持选项。'
- en: '**Elimination of Checksum Calculation** In IPv6, a checksum is no longer computed
    on the header. This saves both the calculation time spent by every device that
    packages IP datagrams (hosts and routers) and the space the checksum field took
    up in the IPv4 header.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**消除校验和计算** 在 IPv6 中，不再在头部计算校验和。这节省了每个封装 IP 数据报的设备（主机和路由器）的计算时间，以及校验和字段在 IPv4
    头部所占用的空间。'
- en: '**Improved Quality of Service Support** A new field, the Flow Label, is defined
    to help support the prioritization of traffic.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**改进的服务质量支持** 定义了一个新的字段，即流标签，以帮助支持流量的优先级。'
- en: Tip
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** IPv6 datagrams use a general structure that begins with a mandatory
    main header that''s 40 bytes in length, followed by optional extension headers,
    and then a variable-length Data area. This structure was created to allow the
    main header to be streamlined, while allowing devices to add extra information
    to datagrams when needed.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6 数据报使用一种通用结构，它以一个长度为 40 字节的强制主头开始，后面跟着可选的扩展头，然后是可变长度的数据区域。这种结构是为了使主头更加精简，同时允许设备在需要时向数据报添加额外信息。'
- en: As I mentioned previously, IPv6 datagrams now include a main header format (which
    has no official name in the standards; it's just "the header") and zero or more
    extension headers. The overall structure of an IPv6 datagram is shown in [Table 26-1](ch26.html#ipv_general_datagram_structure
    "Table 26-1. IPv6 General Datagram Structure") and illustrated in [Figure 26-1](ch26.html#ipv6_general_datagram_structure
    "Figure 26-1. IPv6 general datagram structure").
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，IPv6 数据报现在包括一个主头部格式（在标准中没有官方名称；它只是“头部”）和零个或多个扩展头部。IPv6 数据报的整体结构在 [表 26-1](ch26.html#ipv_general_datagram_structure
    "表 26-1. IPv6 通用数据报结构") 中显示，并在 [图 26-1](ch26.html#ipv6_general_datagram_structure
    "图 26-1. IPv6 通用数据报结构") 中说明。
- en: Table 26-1. IPv6 General Datagram Structure
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 表 26-1. IPv6 通用数据报结构
- en: '| Component | Number of Components per Datagram | Size (Bytes) | Description
    |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 每个数据报的组件数量 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Main Header | 1 | 40 | Contains the source and destination addresses, and
    important information that''s required for every datagram. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 主头 | 1 | 40 | 包含源地址和目的地址，以及每个数据报所需的重要信息。 |'
- en: '| Extension Headers | 0 or more | Variable | Each contains one type of extra
    information that supports various features, including fragmentation, source routing,
    security, and options. |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 扩展头部 | 0 或更多 | 可变 | 每个头部包含一种支持各种功能（包括分片、源路由、安全和选项）的额外信息。 |'
- en: '| Data | 1 | Variable | The payload from the upper layer that will be transmitted
    in the datagram. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 1 | 变量 | 将在数据报中传输的上层有效载荷。 |'
- en: '![IPv6 general datagram structure](httpatomoreillycomsourcenostarchimages287889.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6 通用数据报结构](httpatomoreillycomsourcenostarchimages287889.png)'
- en: Figure 26-1. IPv6 general datagram structure
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26-1. IPv6 通用数据报结构
- en: Note that as with IPv4, large payloads may be fragmented prior to encapsulation
    in order to ensure that the total size of the datagram doesn't exceed the maximum
    size permitted on an underlying network. However, the details of fragmentation
    in IPv6 are different than in IPv4, as explained in [Chapter 27](ch27.html "Chapter 27. IPV6
    DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING").
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 IPv4 一样，在封装之前可能会对大型有效载荷进行分片，以确保数据报的总大小不超过底层网络允许的最大大小。然而，IPv6 中的分片细节与 IPv4
    不同，如第 27 章所述（[第 27 章](ch27.html "第 27 章. IPv6 数据报大小、分片、重组和路由")）。
- en: IPv6 Datagram Main Header Format
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 数据报主头部格式
- en: IPv6 datagrams use a structure that includes a regular header and, optionally,
    one or more extension headers. This regular header is like the header of IPv4
    datagrams, though it has a different format, as you will see shortly. The standards
    don't give this header a name; it is just "*the* IPv6 header." To differentiate
    it from IPv6 extension headers, I call it the *main header*.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 数据报使用一种包括常规头和可选的一个或多个扩展头的结构。这个常规头类似于 IPv4 数据报的头部，尽管它的格式不同，您将在下面看到。标准没有给这个头部命名；它只是“*IPv6
    头部*”。为了区分 IPv6 扩展头部，我称之为“*主头部*”。
- en: The IPv6 main header is required for every datagram. It contains addressing
    and control information that are used to manage the processing and routing of
    the datagram. The main header format of IPv6 datagrams is described in [Table 26-2](ch26s02.html#ipv_main_header_format
    "Table 26-2. IPv6 Main Header Format") and illustrated in [Figure 26-2](ch26s02.html#ipv6_main_header_format
    "Figure 26-2. IPv6 main header format").
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6的主要报头对于每个数据报都是必需的。它包含用于管理数据报处理和路由的地址和控制信息。IPv6数据报的主要报头格式在[表26-2](ch26s02.html#ipv_main_header_format
    "表26-2. IPv6主要报头格式")中描述，并在[图26-2](ch26s02.html#ipv6_main_header_format "图26-2.
    IPv6主要报头格式")中展示。
- en: Table 26-2. IPv6 Main Header Format
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 表26-2. IPv6主要报头格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Version | 1/2 (4 bits) | This identifies the version of IP that''s used to
    generate the datagram. This field is used the same way as in IPv4, except that
    it carries the value 6 (0110 binary). |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1/2 (4位) | 此字段标识用于生成数据报的IP版本。此字段的使用方式与IPv4相同，只是它携带的值是6（二进制0110）。|'
- en: '| Traffic Class | 1 | This field replaces the Type of Service (TOS) field in
    the IPv4 header. It is used not in the original way that the TOS field was defined
    (with Precedence, D, T, and R bits), but rather, using the new Differentiated
    Services (DS) method defined in RFC 2474\. That RFC actually specifies quality-of-service
    (QoS) techniques for both IPv4 and IPv6; see the IPv4 format description ([Chapter 21](ch21.html
    "Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING")) for a
    bit more information. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| 流类别 | 1 | 此字段替换了IPv4头中的服务类型（TOS）字段。它不是按照TOS字段最初定义的方式（使用优先级、D、T和R位）使用，而是使用RFC
    2474中定义的新区分服务（DS）方法。实际上，该RFC规定了IPv4和IPv6的质量服务（QoS）技术；有关更多信息，请参阅IPv4格式描述（[第21章](ch21.html
    "第21章. 互联网协议数据报封装和格式")）。|'
- en: '| Flow Label | 2 1/2 (20 bits) | This large field was created to provide additional
    support for real-time datagram delivery and QoS features. The concept of a flow
    is defined in RFC 2460 as a sequence of datagrams sent from a source device to
    one or more destination devices. A unique flow label is used to identify all the
    datagrams in a particular flow, so that routers between the source and destination
    all handle them the same way. This helps to ensure uniformity in how the datagrams
    in the flow are delivered. For example, if a video stream is being sent across
    an IP internetwork, the datagrams containing the stream could be identified with
    a flow label to ensure that they are delivered with minimal latency. Not all devices
    and routers may support flow label handling, and the use of the field by a source
    device is entirely optional. Also, the field is still somewhat experimental and
    may be refined over time. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 流标签 | 2 1/2 (20位) | 这个大字段是为了提供对实时数据报交付和QoS功能的额外支持而创建的。在RFC 2460中将流定义为从源设备发送到一个或多个目标设备的数据报序列。使用唯一的流标签来标识特定流中的所有数据报，以便源设备和目标设备之间的所有路由器都以相同的方式处理它们。这有助于确保流中数据报的交付一致性。例如，如果视频流正在通过IP互联网发送，包含流的那些数据报可以通过流标签来识别，以确保它们以最小的延迟交付。并非所有设备和路由器都支持流标签处理，并且源设备使用该字段完全是可选的。此外，该字段仍然有些实验性，并且可能随着时间的推移而改进。|'
- en: '| Payload Length | 2 | This field replaces the Total Length field from the
    IPv4 header, but it is used differently. Rather than measuring the length of the
    whole datagram, it contains only the number of bytes of the payload. However,
    if extension headers are included, their length is counted here as well. In simpler
    terms, this field measures the length of the datagram less the 40 bytes of the
    main header itself. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| 有效载荷长度 | 2 | 此字段替换了IPv4头中的总长度字段，但其使用方式不同。它不是测量整个数据报的长度，而是只包含有效载荷的字节数。然而，如果包含扩展头，它们的长度也在此处计算。简单来说，此字段测量数据报的长度，减去主要头本身的40个字节。|'
- en: '| Next Header | 1 | This field replaces the Protocol field and has two uses.
    When a datagram has extension headers, this field specifies the identity of the
    first extension header, which is the next header in the datagram. When a datagram
    has just this "main" header and no extension headers, it serves the same purpose
    as the old IPv4 Protocol field and has the same values, though new numbers are
    used for the IPv6 versions of common protocols. In this case the "next header"
    is the header of the upper layer message the IPv6 datagram is carrying. I''ll
    discuss this in more detail a bit later in this chapter. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 下一个头部 | 1 | 此字段代替了协议字段，有两个用途。当一个数据报有扩展头部时，此字段指定第一个扩展头部的标识符，它是数据报中的下一个头部。当一个数据报只有这个“主要”头部而没有扩展头部时，它具有与旧IPv4协议字段相同的作用，并且具有相同的值，尽管IPv6版本中常用协议使用的新数字。在这种情况下，“下一个头部”是IPv6数据报携带的更高层消息的头部。我将在本章稍后更详细地讨论这一点。|'
- en: '| Hop Limit | 1 | This replaces the Time to Live (TTL) field in the IPv4 header;
    its name better reflects the way that TTL is used in modern networks (because
    TTL is really used to count hops, not time). |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 跳数限制 | 1 | 这代替了IPv4头部中的生存时间（TTL）字段；其名称更好地反映了现代网络中TTL的使用方式（因为TTL实际上用于计算跳数，而不是时间）。|'
- en: '| Source Address | 16 | The 128-bit IP address of the originator of the datagram.
    As with IPv4, this is always the device that originally sent the datagram. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 源地址 | 16 | 数据报发送者的128位IP地址。与IPv4一样，这始终是最初发送数据报的设备。|'
- en: '| Destination Address | 16 | The 128-bit IP address of the intended recipient
    of the datagram: unicast, anycast, or multicast. Again, even though devices such
    as routers may be the intermediate targets of the datagram, this field is always
    for the ultimate destination. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 目标地址 | 16 | 数据报预期接收者的128位IP地址：单播、任播或多播。同样，尽管路由器等设备可能是数据报的中间目标，但此字段始终用于最终目的地。|'
- en: '![IPv6 main header format](httpatomoreillycomsourcenostarchimages287891.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6主要头部格式](httpatomoreillycomsourcenostarchimages287891.png)'
- en: Figure 26-2. IPv6 main header format
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-2. IPv6主要头部格式
- en: IPv6 Next Header Field
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6下一个头部字段
- en: The Next Header field is one of the most important additions to the IPv6 datagram
    format. When an IPv6 datagram uses extension headers, this field contains an identifier
    for the first extension header, which, in turn, uses its own Next Header field
    to point to the next header, and so on. The last extension header then references
    the encapsulated higher-layer protocol. Because the higher-layer protocol's header
    appears at the start of the IPv6 Data field, it is like the "next header" to the
    device receiving the datagram. For some folks, this is a bit tough to see conceptually;
    you can find more detail on how the field works (including a useful illustration,
    [Figure 26-3](ch26s03.html#ipv6_extension_header_linking_using_the_ "Figure 26-3. IPv6
    extension header linking using the Next Header field The Next Header field allows
    a device to more easily process the headers in a received IPv6 datagram. When
    a datagram has no extension headers, the "next header" is actually the header
    at the start of the IP Data field, which, in this case, is a TCP header with a
    value of 6\. This is the same way the Protocol field is used in IPv4\. When extension
    headers do appear, the Next Header value of each header contains a number indicating
    the type of the following header in the datagram, so they logically chain together
    the headers.")) in the "IPv6 Header Chaining Using the Next Header Field" section
    later in this chapter.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个头部字段是IPv6数据报格式中最重要的新增功能之一。当IPv6数据报使用扩展头部时，此字段包含第一个扩展头部的标识符，该标识符反过来使用自己的下一个头部字段来指向下一个头部，依此类推。最后一个扩展头部随后引用封装的更高层协议。因为更高层协议的头部出现在IPv6数据字段的开头，所以它就像是接收数据报的设备眼中的“下一个头部”。对于一些人来说，这在概念上可能有点难以理解；你可以在本章后面的“使用下一个头部字段进行IPv6头部链接”部分找到更多关于该字段如何工作的细节（包括一个有用的插图，[图26-3](ch26s03.html#ipv6_extension_header_linking_using_the_
    "图26-3. 使用下一个头部字段进行IPv6扩展头部链接。下一个头部字段允许设备更容易地处理接收到的IPv6数据报中的头部。当一个数据报没有扩展头部时，“下一个头部”实际上是IP数据字段开头的头部，在这种情况下，是一个值为6的TCP头部。这与IPv4中使用的协议字段相同。当出现扩展头部时，每个头部的下一个头部值包含一个指示数据报中下一个头部类型的数字，因此它们逻辑上链接在一起。"))。
- en: Some of the most common values for the Next Header field in IPv6 are shown in
    [Table 26-3](ch26s02.html#common_ipv_next_header_values "Table 26-3. Common IPv6
    Next Header Values").
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6中下一个头部字段的一些最常见值显示在[表26-3](ch26s02.html#common_ipv_next_header_values "表26-3.
    常见IPv6下一个头部值")中。
- en: Table 26-3. Common IPv6 Next Header Values
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 表26-3. 常见IPv6下一个头部值
- en: '| Value (Hexadecimal) | Value (Decimal) | Protocol/Extension Header |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| 值（十六进制） | 值（十进制） | 协议/扩展头部 |'
- en: '| --- | --- | --- |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 00 | 0 | Hop-By-Hop Options Extension Header (Note that this value was "Reserved"
    in IPv4) |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| 00 | 0 | 跳到跳选项扩展头部（请注意，在IPv4中此值是“保留”的） |'
- en: '| 01 | 1 | Internet Control Message Protocol version 4 (ICMPv4) |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| 01 | 1 | 互联网控制消息协议版本4（ICMPv4） |'
- en: '| 02 | 2 | Internet Group Management Protocol version 4 (IGMPv4) |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| 02 | 2 | 互联网组管理协议版本4（IGMPv4） |'
- en: '| 04 | 4 | IP-in-IP Encapsulation |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| 04 | 4 | IP-in-IP封装 |'
- en: '| 06 | 6 | Transmission Control Protocol (TCP) |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| 06 | 6 | 传输控制协议（TCP） |'
- en: '| 08 | 8 | Exterior Gateway Protocol (EGP) |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 08 | 8 | 外部网关协议（EGP） |'
- en: '| 11 | 17 | User Datagram Protocol (UDP) |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 17 | 用户数据报协议（UDP） |'
- en: '| 29 | 41 | IPv6 |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 29 | 41 | IPv6 |'
- en: '| 2B | 43 | Routing Extension Header |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| 2B | 43 | 路由扩展头部 |'
- en: '| 2C | 44 | Fragmentation Extension Header |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 2C | 44 | 分段扩展头部 |'
- en: '| 2E | 46 | Resource Reservation Protocol (RSVP) |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| 2E | 46 | 资源预留协议（RSVP） |'
- en: '| 32 | 50 | Encrypted Security Payload (ESP) Extension Header |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 50 | 加密安全有效载荷（ESP）扩展头部 |'
- en: '| 33 | 51 | Authentication Header (AH) Extension Header |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 33 | 51 | 认证头部（AH）扩展头部 |'
- en: '| 3A | 58 | ICMPv6 |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| 3A | 58 | ICMPv6 |'
- en: '| 3B | 59 | No Next Header |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| 3B | 59 | 无下一个头部 |'
- en: '| 3C | 60 | Destination Options Extension Header |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 3C | 60 | 目的选项扩展头部 |'
- en: The total length of the main IPv6 header format is 40 bytes. This is double
    the size of the IPv4 header without options, largely because of the extra 24 bytes
    needed for the monstrous IPv6 addresses. There are only 8 bytes of nonaddress
    header fields in the IPv6 main header, compared to 12 in the IPv4 header.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6主要头部格式的总长度为40字节。这是没有选项的IPv4头部大小的两倍，这主要是因为需要额外的24字节来容纳庞大的IPv6地址。IPv6主要头部中只有8字节的非地址头部字段，而IPv4头部中有12个。
- en: Key Changes to the Main Header Between IPv4 and IPv6
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv4和IPv6之间主要头部的关键变化
- en: 'To summarize, the IPv6 main header compares to the IPv4 header as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，IPv6的主要头部与IPv4头部相比如下：
- en: '**Unchanged Fields** Three fields are used the same way, and they retain the
    same name (though they have different content and/or size): Version, Source Address,
    and Destination Address.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**未更改字段** 三个字段以相同的方式使用，并且保留了相同的名称（尽管它们的内容和/或大小不同）：版本、源地址和目的地址。'
- en: '**Renamed Fields** Two fields are used the same way, but they are renamed:
    Traffic Class and Hop Limit.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**重命名字段** 两个字段以相同的方式使用，但被重新命名：流量类别和跳数限制。'
- en: '**Modified Fields** Two fields are used in a way similar way to their IPv4
    predecessors, but they are slightly different in meaning and also renamed: Payload
    Length and Next Header.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改字段** 两个字段以类似的方式使用，但它们的意义略有不同，并且也被重新命名：有效载荷长度和下一个头部。'
- en: '**Added Field** There is one new field: Flow Label.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**新增字段** 有一个新字段：流标签。'
- en: '**Removed Fields** To cut down on header length and unnecessary work, five
    IPv4 header fields are removed from the IPv6 header:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**移除字段** 为了减少头部长度和不需要的工作，从IPv6头部中移除了五个IPv4头部字段：'
- en: The *Internet Header Length* field is no longer needed, because the main IPv6
    header is fixed in length at 40 bytes.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*互联网头部长度*字段不再需要，因为IPv6的主要头部长度固定为40字节。'
- en: The *Identification, Flags*, and *Fragment Offset* fields are used for fragmentation,
    which is done less in IPv6 than IPv4, so these fields are now found only when
    needed in the Fragmentation extension header.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标识符、标志*和*分段偏移量*字段用于分段，在IPv6中比IPv4少用，因此这些字段现在仅在需要时出现在分段扩展头部中。'
- en: The *Header Checksum* field is no longer needed, because the decision was made
    to eliminate header checksum calculations in IPv6\. It was viewed as redundant
    with higher-layer error-checking and data link layer CRC calculations. This saves
    processing time for routers and 2 bytes in the datagram header.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头部校验和*字段不再需要，因为决定在IPv6中消除头部校验计算。这被视为与高层错误检查和数据链路层CRC计算冗余。这为路由器节省了处理时间，并在数据报头部中节省了2个字节。'
- en: In addition, while options were formerly considered part of the main header
    in IPv4, they are separate in IPv6.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然IPv4中选项曾经被认为是主要头部的一部分，但在IPv6中它们是分开的。
- en: IPv6 Datagram Extension Headers
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6数据报扩展头部
- en: After the mandatory main header in an IPv6 datagram, one or more extension headers
    may appear before the encapsulated payload. These headers were created in an attempt
    to provide both flexibility and efficiency in the creation of IPv6 datagrams.
    All the fields that are needed for only special purposes are put into extension
    headers and placed in the datagram when needed. This allows the size of the main
    datagram header to be made small and streamlined, containing only those fields
    that really must be present all the time.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6数据报的强制主标题之后，可能有一或多个扩展标题出现在封装的有效载荷之前。这些标题是在尝试提供在创建IPv6数据报时的灵活性和效率而创建的。所有仅用于特殊目的的字段都被放入扩展标题中，并在需要时放入数据报。这使得主数据报标题的大小可以做得小而紧凑，只包含那些确实必须始终存在的字段。
- en: There is often confusion regarding the role of extension headers, especially
    when compared to datagram options. The IPv4 datagram had only one header, but
    it included a provision for options, and IPv6 also has options, so why bother
    with extension headers?
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 关于扩展标题的作用经常存在混淆，尤其是在与数据报选项比较时。IPv4数据报只有一个标题，但它包括了一个选项的条款，IPv6也有选项，那么为什么还要麻烦扩展标题呢？
- en: It would have been possible to do everything using options. However, it was
    deemed a better design to employ extension headers for certain sets of information
    that are needed for common functions such as fragmenting. Options are indeed still
    supported in IPv6; they are used to supply even more flexibility by providing
    variable-length fields that can be used for any purpose. They are themselves defined
    using extension headers, as you will see shortly.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 本来可以使用选项完成所有事情。然而，被认为更好的设计是为某些需要用于常见功能（如分段）的信息集使用扩展标题。确实，IPv6仍然支持选项；它们通过提供可变长度的字段来提供更多的灵活性，这些字段可用于任何目的。它们本身是使用扩展标题定义的，正如你很快就会看到的。
- en: When extension headers are included in an IPv6 datagram, they appear one after
    the other following the main header. Each extension header type has its own internal
    structure of fields.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展标题包含在IPv6数据报中时，它们会依次出现在主标题之后。每种扩展标题类型都有自己的字段内部结构。
- en: IPv6 Header Chaining Using the Next Header Field
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用下一个标题字段进行IPv6标题链式连接
- en: 'The only field common to all extension header types is the Next Header field,
    which actually appears at the end of one header type, the ESP header. The 8-bit
    Next Header field is used to logically link all the headers in an IPv6 datagram,
    as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 所有扩展标题类型共有的唯一字段是下一个标题字段，它实际上出现在ESP标题类型的末尾。8位的下一个标题字段用于逻辑链接IPv6数据报中的所有标题，如下所示：
- en: The Next Header field in the main header contains a reference number for the
    first extension header type.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主标题中的下一个标题字段包含第一个扩展标题类型的参考编号。
- en: The Next Header field in the first extension header contains the number of the
    second extension header type, if there is a second one. If there's a third, the
    second header's Next Header points to it, and so on.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个扩展标题中的下一个标题字段包含第二个扩展标题类型的编号，如果有第二个的话。如果有第三个，第二个标题的下一个标题指向它，依此类推。
- en: The Next Header field of the last extension header contains the protocol number
    of the encapsulated higher-layer protocol. In essence, this field points to the
    "next header" within the payload itself.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个扩展标题的下一个标题字段包含封装的更高层协议的协议号。本质上，此字段指向有效载荷内的“下一个标题”。
- en: 'For example, suppose a datagram that encapsulates TCP has a Hop-By-Hop Options
    extension header and a Fragment extension header. Then, the Next Header fields
    of these headers would contain the following values:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个封装TCP的数据报有一个跳-跳选项扩展标题和一个分段扩展标题。那么，这些标题的下一个标题字段将包含以下值：
- en: The main header would have a Next Header value of 0, indicating the Hop-By-Hop
    Options header.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要标题的下一个标题值将是0，表示跳-跳选项标题。
- en: The Hop-By-Hop Options header would have a Next Header value of 44 (decimal),
    which is the value for the Fragment extension header.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳-跳选项标题的下一个标题值将是44（十进制），这是分段扩展标题的值。
- en: The Fragment header would have a Next Header value of 6.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分段标题的下一个标题值将是6。
- en: This is illustrated in [Figure 26-3](ch26s03.html#ipv6_extension_header_linking_using_the_
    "Figure 26-3. IPv6 extension header linking using the Next Header field The Next
    Header field allows a device to more easily process the headers in a received
    IPv6 datagram. When a datagram has no extension headers, the "next header" is
    actually the header at the start of the IP Data field, which, in this case, is
    a TCP header with a value of 6\. This is the same way the Protocol field is used
    in IPv4\. When extension headers do appear, the Next Header value of each header
    contains a number indicating the type of the following header in the datagram,
    so they logically chain together the headers.").
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 [图 26-3](ch26s03.html#ipv6_extension_header_linking_using_the_ "图 26-3. 使用下一个头部字段链接
    IPv6 扩展头部 IPv6 下一个头部字段允许设备更容易地处理接收到的 IPv6 数据报中的头部。当数据报没有扩展头部时，“下一个头部”实际上是 IP 数据字段开始的头部，在这种情况下，是一个值为
    6 的 TCP 头部。这与 IPv4 中使用协议字段的方式相同。当出现扩展头部时，每个头部的下一个头部值包含一个表示数据报中后续头部类型的数字，因此它们逻辑上链接在一起。")
    中进行了说明。
- en: '![IPv6 extension header linking using the Next Header field The Next Header
    field allows a device to more easily process the headers in a received IPv6 datagram.
    When a datagram has no extension headers, the "next header" is actually the header
    at the start of the IP Data field, which, in this case, is a TCP header with a
    value of 6\. This is the same way the Protocol field is used in IPv4\. When extension
    headers do appear, the Next Header value of each header contains a number indicating
    the type of the following header in the datagram, so they logically chain together
    the headers.](httpatomoreillycomsourcenostarchimages287893.png.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![使用下一个头部字段链接 IPv6 扩展头部 IPv6 下一个头部字段允许设备更容易地处理接收到的 IPv6 数据报中的头部。当数据报没有扩展头部时，“下一个头部”实际上是
    IP 数据字段开始的头部，在这种情况下，是一个值为 6 的 TCP 头部。这与 IPv4 中使用协议字段的方式相同。当出现扩展头部时，每个头部的下一个头部值包含一个表示数据报中后续头部类型的数字，因此它们逻辑上链接在一起。](httpatomoreillycomsourcenostarchimages287893.png.jpg)'
- en: Figure 26-3. IPv6 extension header linking using the Next Header field The Next
    Header field allows a device to more easily process the headers in a received
    IPv6 datagram. When a datagram has no extension headers, the "next header" is
    actually the header at the start of the IP Data field, which, in this case, is
    a TCP header with a value of 6\. This is the same way the Protocol field is used
    in IPv4\. When extension headers do appear, the Next Header value of each header
    contains a number indicating the type of the following header in the datagram,
    so they logically chain together the headers.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26-3. 使用下一个头部字段链接 IPv6 扩展头部 IPv6 下一个头部字段允许设备更容易地处理接收到的 IPv6 数据报中的头部。当数据报没有扩展头部时，“下一个头部”实际上是
    IP 数据字段开始的头部，在这种情况下，是一个值为 6 的 TCP 头部。这与 IPv4 中使用协议字段的方式相同。当出现扩展头部时，每个头部的下一个头部值包含一个表示数据报中后续头部类型的数字，因此它们逻辑上链接在一起。
- en: Tip
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The IPv6 Next Header field is used to chain together the headers
    in an IPv6 datagram. The Next Header field in the main header contains the number
    of the first extension header; its Next Header contains the number of the second,
    and so forth. The last header in the datagram contains the number of the encapsulated
    protocol that begins the Data field.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6 下一个头部字段用于将 IPv6 数据报中的头部链接在一起。主头部中的下一个头部字段包含第一个扩展头部的编号；其下一个头部包含第二个的编号，依此类推。数据报中的最后一个头部包含开始数据字段的封装协议的编号。'
- en: Summary of IPv6 Extension Headers
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 扩展头信息摘要
- en: '[Table 26-4](ch26s03.html#ipv_extension_headers "Table 26-4. IPv6 Extension
    Headers") lists the different extension headers, showing each one''s Next Header
    value, length, defining RFC, and a brief description of how it is used.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 26-4](ch26s03.html#ipv_extension_headers "表 26-4. IPv6 扩展头部") 列出了不同的扩展头部，显示了每个扩展头部的下一个头部值、长度、定义的
    RFC 以及其简要使用说明。'
- en: Table 26-4. IPv6 Extension Headers
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 表 26-4. IPv6 扩展头部
- en: '| Next Header Value (Decimal) | Extension Header Name | Length (Bytes) | Description
    | Defining RFC |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 下一个头部值（十进制） | 扩展头部名称 | 长度（字节） | 描述 | 定义 RFC |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | Hop-By-Hop Options | Variable | Defines an arbitrary set of options that
    are intended to be examined by all devices on the path from the source to destination
    device(s). This is one of two extension headers used to define variable-format
    options. | 2460 |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 跳到跳选项 | 可变 | 定义一组任意选项，这些选项旨在由从源设备到目的地设备（们）路径上的所有设备检查。这是用于定义可变格式选项的两个扩展头之一。
    | 2460 |'
- en: '| 43 | Routing | Variable | Defines a method for allowing a source device to
    specify the route for a datagram. This header type actually allows the definition
    of multiple routing types. The IPv6 standard defines the Type 0 Routing extension
    header, which is equivalent to the "loose" source routing option in IPv4\. It''s
    used in a similar way. See the "IPv6 Routing Extension Header" section in this
    chapter for the format of this extension header. | 2460 |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| 43 | 路由 | 可变 | 定义一种允许源设备指定数据报路由的方法。此头部类型实际上允许定义多种路由类型。IPv6标准定义了类型0路由扩展头，它等同于IPv4中的“宽松”源路由选项。它以类似的方式使用。请参阅本章的“IPv6路由扩展头”部分，了解此扩展头的格式。
    | 2460 |'
- en: '| 44 | Fragment | 8 | When a datagram contains only a fragment of the original
    message, contains the Fragment Offset, Identification, and More Fragment fields
    that were removed from the main header. See the "IPv6 Fragment Extension Header"
    section in this chapter for the format of this extension header, and the topic
    on fragmentation and reassembly ([Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM
    SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING")) for details on how the fields
    are used. | 2460 |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 分片 | 8 | 当数据报只包含原始消息的一部分时，包含从主头部移除的片段偏移量、标识符和更多片段字段。请参阅本章的“IPv6分片扩展头”部分，了解此扩展头的格式，以及关于分片和重组的专题（[第27章](ch27.html
    "第27章. IPV6数据报大小、分片、重组和路由")），了解字段的使用细节。 | 2460 |'
- en: '| 50 | Encapsulating Security Payload (ESP) | Variable | Carries encrypted
    data for secure communications. This header is described in detail in [Chapter 29](ch29.html
    "Chapter 29. IP SECURITY (IPSEC) PROTOCOLS"), which covers IPsec. | 2406 |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 封装安全载荷 (ESP) | 可变 | 用于承载加密数据以实现安全通信。此头部在[第29章](ch29.html "第29章. IP安全（IPSEC）协议")中有详细描述，该章节涵盖了IPsec。
    | 2406 |'
- en: '| 51 | Authentication Header (AH) | Variable | Contains information used to
    verify the authenticity of encrypted data. This header is described in detail
    in [Chapter 29](ch29.html "Chapter 29. IP SECURITY (IPSEC) PROTOCOLS"). | 2402
    |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 51 | 认证头 (AH) | 可变 | 包含用于验证加密数据真实性的信息。此头部在[第29章](ch29.html "第29章. IP安全（IPSEC）协议")中有详细描述。
    | 2402 |'
- en: '| 60 | Destination Options | Variable | Defines an arbitrary set of options
    that are intended to be examined only by the destination(s) of the datagram. This
    is one of two extension headers used to define variable-format options. | 2460
    |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 60 | 目的选项 | 可变 | 定义一组任意选项，这些选项仅由数据报的目的地（们）检查。这是用于定义可变格式选项的两个扩展头之一。 | 2460
    |'
- en: Note that the Next Header value of the IPv6 main header is 41; that of an IPv4
    header is 4 (its protocol number). There is also a "dummy" extension header called
    No Next Header that has a value of 59\. This is a placeholder that, when found
    in the Next Header field, indicates that there is nothing after that extension
    header.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IPv6主头部的下一个头部值为41；IPv4头部的值为4（其协议号）。还有一个名为“无下一个头部”的“虚拟”扩展头，其值为59。这是一个占位符，当在下一个头部字段中找到时，表示该扩展头部之后没有其他内容。
- en: 'As mentioned in [Table 26-4](ch26s03.html#ipv_extension_headers "Table 26-4. IPv6
    Extension Headers"), the formats for several of the headers are provided in other
    areas of this book. I will describe two of them here, however: the Routing extension
    header and the Fragment extension header.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表26-4](ch26s03.html#ipv_extension_headers "表26-4. IPv6扩展头")中所述，几个头部格式的提供在其他本书的部分。然而，我将在这里描述其中两个：路由扩展头和分片扩展头。
- en: IPv6 Routing Extension Header
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6路由扩展头
- en: The Routing extension header is used to perform source routing in IPv6\. It
    is described in [Table 26-5](ch26s03.html#ipv_routing_extension_header_format
    "Table 26-5. IPv6 Routing Extension Header Format") and illustrated in [Figure 26-4](ch26s03.html#ipv6_routing_extension_header_format
    "Figure 26-4. IPv6 Routing extension header format").
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 路由扩展头用于在IPv6中执行源路由。它在[表26-5](ch26s03.html#ipv_routing_extension_header_format
    "表26-5. IPv6路由扩展头格式")中描述，并在[图26-4](ch26s03.html#ipv6_routing_extension_header_format
    "图26-4. IPv6路由扩展头格式")中展示。
- en: Table 26-5. IPv6 Routing Extension Header Format
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 表26-5. IPv6路由扩展头格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述|'
- en: '| --- | --- | --- |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Next Header | 1 | Contains the protocol number of the next header after the
    Routing header. Used to link headers together, as described earlier in this chapter.
    |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| 下一个头部 | 1 | 包含路由头部之后下一个头部的协议号。用于将头部链接在一起，如本章前面所述。|'
- en: '| Hdr Ext Len | 1 | For Header Extension Length, specifies the length of the
    Routing header in 8-byte units, not including the first 8 bytes of the header.
    For a Routing Type field of 0, this value is thus two times the number addresses
    embedded in the header. |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| Hdr Ext Len | 1 | 用于头部扩展长度，指定路由头在8字节单位中的长度，不包括头部的前8字节。对于路由类型字段为0的情况，此值是头部中嵌入的地址数的两倍。|'
- en: '| Routing Type | 1 | Allows multiple routing types to be defined; at present,
    the only value used is 0. |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| 路由类型 | 1 | 允许多个路由类型被定义；目前，唯一使用的值是0。|'
- en: '| Segments Left | 1 | Specifies the number of explicitly named nodes remaining
    in the route until the destination. |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| Segments Left | 1 | 指定在到达目的地之前路由中剩余的显式命名的节点数。|'
- en: '| Reserved | 4 | Not used; set to zeros. |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4 | 未使用；设置为0。|'
- en: '| Address1…AddressN | Variable (Multiple of 16) | A set of IPv6 addresses that
    specify the route to be used. |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| Address1…AddressN | 可变（16的倍数） | 一组IPv6地址，指定要使用的路由。|'
- en: '![IPv6 Routing extension header format](httpatomoreillycomsourcenostarchimages287895.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6路由扩展头部格式](httpatomoreillycomsourcenostarchimages287895.png)'
- en: Figure 26-4. IPv6 Routing extension header format
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-4. IPv6路由扩展头部格式
- en: IPv6 Fragment Extension Header
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6分片扩展头部
- en: The Fragment extension header is included in fragmented datagrams to provide
    the information that's necessary to allow the fragments to be reassembled. It
    is described in [Table 26-6](ch26s03.html#ipv_fragment_extension_header_format
    "Table 26-6. IPv6 Fragment Extension Header Format") and illustrated in [Figure 26-5](ch26s03.html#ipv6_fragment_extension_header_format
    "Figure 26-5. IPv6 Fragment extension header format").
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 片扩展头部包含在分片数据报中，以提供允许分片重新组装所需的信息。它描述在[表26-6](ch26s03.html#ipv_fragment_extension_header_format
    "表26-6. IPv6分片扩展头部格式")中，并在[图26-5](ch26s03.html#ipv6_fragment_extension_header_format
    "图26-5. IPv6分片扩展头部格式")中展示。
- en: Table 26-6. IPv6 Fragment Extension Header Format
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 表26-6. IPv6分片扩展头部格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述|'
- en: '| --- | --- | --- |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Next Header | 1 | Contains the protocol number of the next header after the
    Fragment header. Used to link headers together, as described earlier in this chapter.
    |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| 下一个头部 | 1 | 包含分片头部之后下一个头部的协议号。用于将头部链接在一起，如本章前面所述。|'
- en: '| Reserved | 1 | Not used; set to zeros. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 1 | 未使用；设置为0。|'
- en: '| Fragment Offset | 13/8 (13 bits) | Specifies the offset, or position, in
    the overall message where the data in this fragment goes. It is specified in units
    of 8 bytes (64 bits) and used in a manner very similar to the field of the same
    name in the IPv4 header. |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| 分片偏移 | 13/8 (13位) | 指定此分片中的数据在整体消息中的偏移量或位置。它以8字节（64位）为单位指定，其使用方式与IPv4头部中同名字段非常相似。|'
- en: '| Res | 1/4 (2 bits) | Not used; set to zeros. |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| Res | 1/4 (2位) | 未使用；设置为0。|'
- en: '| M Flag | 1/8 (1 bit) | For More Fragments Flag, same as the flag of the same
    name in the IPv4 header. When set to 0, indicates the last fragment in a message;
    when set to 1, indicates that more fragments are yet to come in the fragmented
    message. |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| M标志 | 1/8 (1位) | 更多分片标志，与IPv4头部中同名标志相同。当设置为0时，表示消息中的最后一个分片；当设置为1时，表示在分片消息中还有更多分片尚未到来。|'
- en: '| Identification | 4 | Same as the field of the same name in the IPv4 header,
    but expanded to 32 bits. It contains a specific value that is common to each of
    the fragments belonging to a particular message. This ensures that pieces from
    different fragmented messages are not mixed together. |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 标识 | 4 | 与IPv4头部中同名字段相同，但扩展到32位。它包含一个特定值，该值属于特定消息的每个分片。这确保了来自不同分片消息的片段不会混合在一起。|'
- en: '![IPv6 Fragment extension header format](httpatomoreillycomsourcenostarchimages287897.png.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6分片扩展头部格式](httpatomoreillycomsourcenostarchimages287897.png.jpg)'
- en: Figure 26-5. IPv6 Fragment extension header format
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-5. IPv6分片扩展头部格式
- en: IPv6 Extension Header Order
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6扩展头部顺序
- en: Each extension header appears only once in any datagram (with one exception,
    as you'll see shortly). Also, only the final recipients of the datagram examine
    extension headers, not intermediate devices (again with one exception, which you
    will see momentarily).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扩展标题在任何数据报中只出现一次（有一个例外，你很快就会看到）。此外，只有数据报的最终接收者会检查扩展标题，而不是中间设备（也有一个例外，你马上就会看到）。
- en: 'RFC 2460 specifies that when multiple headers appear, they should be in the
    following order, after the main header and before the higher-layer encapsulated
    header in the IPv6 datagram payload:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2460 规定，当出现多个标题时，它们应该在 IPv6 数据报有效载荷中的主标题之后、高层封装标题之前按照以下顺序出现：
- en: Hop-By-Hop Options
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳-跳选项
- en: Destination Options (for options to be processed by the destination as well
    as devices specified in a Routing header)
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目的选项（用于由目的地以及路由标题中指定的设备处理的选项）
- en: Routing
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由
- en: Fragmentation
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分片
- en: Authentication Header
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证标题
- en: Encapsulating Security Payload
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装安全有效载荷
- en: Destination Options (for options processed only by the final destination)
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目的选项（仅由最终目的地处理的选项）
- en: Now let's look at those exceptions. The only header that can appear twice is
    Destination Options. Normally, it appears as the last header. However, the datagram
    may also have a Destination Options header that contains options that must be
    examined by a list of devices specified in a source route, in addition to the
    destination. In this case, the Destination Options header for these options is
    placed before the Routing header. A second such header containing options for
    only the final destination may also appear.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看那些例外情况。唯一可能出现两次的标题是“目的选项”。通常，它作为最后一个标题出现。然而，数据报也可能包含一个“目的选项”标题，其中包含必须由源路由中指定的一组设备检查的选项，除了目的地之外。在这种情况下，这些选项的“目的选项”标题被放置在“路由”标题之前。还可能有一个包含仅针对最终目的地的选项的第二个此类标题。
- en: Tip
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Each extension header may appear only once in an IPv6 datagram,
    and each one must appear in a fixed order. The exception is the Destination Options
    header, which may appear twice: near the start of the datagram for options to
    be processed by devices en route to the destination and at the end of the extension
    headers for options intended for only the final destination.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个扩展标题在 IPv6 数据报中只能出现一次，并且每个都必须按照固定顺序出现。例外的是“目的选项”标题，它可以出现两次：在数据报的开始处，用于处理前往目的地的设备的选项，以及在扩展标题的末尾，用于仅针对最终目的地的选项。'
- en: The only header normally examined by all intermediate devices is the Hop-By-Hop
    Options extension header. It is used specifically to convey management information
    to all routers in a route. The Hop-By-Hop Options extension header must appear
    as the first extension header if present. Since it is the only one that every
    router must read (and this represents a performance drain on routers), it is given
    top billing to make it easier and faster to find and process.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 通常所有中间设备都会检查的唯一标题是“跳-跳选项”扩展标题。它专门用于将管理信息传达给路由中的所有路由器。如果存在，则“跳-跳选项”扩展标题必须作为第一个扩展标题出现。由于它是每个路由器都必须读取的（这代表了路由器的性能损耗），因此它被赋予最高的优先级，以便更容易、更快地找到和处理。
- en: Finally, note that all extension headers must be a multiple of eight bytes in
    length for alignment purposes. Also, remember that the Next Header value for a
    particular extension header appears in the Next Header field of the preceding
    header, not the header itself.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，所有扩展标题的长度必须是八的倍数，以便对齐。此外，请记住，特定扩展标题的“下一个标题”值出现在前一个标题的“下一个标题”字段中，而不是标题本身。
- en: IPv6 Datagram Options
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 数据报选项
- en: In IPv4, all extra information required for various purposes is placed into
    the datagram in the form of options that appear in the IPv4 header. In IPv6, the
    new concept of extension headers is introduced, as you just saw. These headers
    take the place of many of the predefined IPv4 options. However, the concept of
    options is still maintained in IPv6 for a slightly different purpose.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPv4 中，为各种目的所需的所有额外信息都以选项的形式放入数据报中，这些选项出现在 IPv4 标题中。在 IPv6 中，引入了新的扩展标题概念，正如你刚才看到的。这些标题取代了许多预定义的
    IPv4 选项。然而，选项的概念在 IPv6 中仍然保持，但目的略有不同。
- en: Options allow the IPv6 datagram to be supplemented with arbitrary sets of information
    that aren't defined in the regular extension headers. They provide maximum flexibility,
    thereby allowing the basic IPv6 protocol to be extended in ways the designers
    never anticipated, with the goal of reducing the chance of the protocol becoming
    obsolete in the future.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 选项允许IPv6数据报补充任意集合的信息，这些信息在常规扩展头部中没有定义。它们提供了最大的灵活性，从而允许基本IPv6协议以设计者未曾预料的方式扩展，目的是减少协议在未来变得过时的可能性。
- en: I said that IPv6 options supplement extension headers; in fact, they are actually
    implemented as extension headers. There are two different ones used to encode
    options. These two headers differ only in terms of how devices will process the
    options they contain; otherwise, they are formatted the same and used in the same
    way.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我说IPv6选项补充扩展头部；实际上，它们实际上作为扩展头部实现。用于编码选项有两种不同的头部。这两个头部在处理它们包含的选项方面有所不同；否则，它们的格式相同，并且以相同的方式使用。
- en: 'The two extension header types are as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 两种扩展头部类型如下：
- en: '**Destination Options** Contains options that are intended only for the ultimate
    destination of the datagram (and perhaps a set of routers in a Routing header,
    if present).'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标选项** 包含仅针对数据报最终目的地（如果存在，还包括路由头中的一组路由器）的选项。'
- en: '**Hop-By-Hop Options** Contains options that carry information for every device
    (router) between the source and destination.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳-跳选项** 包含携带源和目的地之间每个设备（路由器）信息的选项。'
- en: Each of these header types has a one-byte Next Header field, and a one-byte
    Header Extension Length field that indicates the header's overall length. The
    rest of the header has one or more option fields.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头部类型每个都有一个一字节的下一个头部字段和一个一字节的头部扩展长度字段，用于指示头部的总长度。头部的其余部分有一个或多个选项字段。
- en: '[Figure 26-6](ch26s04.html#ipv6_hop-by-hop_options_and_destination_ "Figure 26-6. IPv6
    Hop-By-Hop Options and Destination Options header formats Each of these extension
    headers begins with two fixed fields, Next Header and Header Extension Length.
    The rest of the header consists of a sequence of variable-length options. Each
    option has a structure that consists of a type/length/value triplet, shown in
    Table 26-7.") illustrates the overall format of these two headers. The format
    of each option is similar to that of IPv4 options, as shown in Tables [Table 26-7](ch26s04.html#ipv_option_format-id001
    "Table 26-7. IPv6 Option Format") and [Table 26-8](ch26s04.html#ipv_option_type_subfields
    "Table 26-8. IPv6 Option Type Subfields").'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '[图26-6](ch26s04.html#ipv6_hop-by-hop_options_and_destination_ "图26-6. IPv6
    跳-跳选项和目标选项头格式。这些扩展头每个都以两个固定字段开始，即下一个头部和头部扩展长度。头部的其余部分由一系列可变长度的选项组成。每个选项都有一个由类型/长度/值三元组组成的结构，如图表26-7所示。")
    展示了这两个头部的整体格式。每个选项的格式与IPv4选项类似，如[表26-7](ch26s04.html#ipv_option_format-id001 "表26-7.
    IPv6 选项格式")和[表26-8](ch26s04.html#ipv_option_type_subfields "表26-8. IPv6 选项类型子字段")所示。'
- en: '![IPv6 Hop-By-Hop Options and Destination Options header formats Each of these
    extension headers begins with two fixed fields, Next Header and Header Extension
    Length. The rest of the header consists of a sequence of variable-length options.
    Each option has a structure that consists of a type/length/value triplet, shown
    in .](httpatomoreillycomsourcenostarchimages287899.png.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6 跳-跳选项和目标选项头格式](httpatomoreillycomsourcenostarchimages287899.png.jpg)
    这些扩展头每个都以两个固定字段开始，即下一个头部和头部扩展长度。头部的其余部分由一系列可变长度的选项组成。每个选项都有一个由类型/长度/值三元组组成的结构，如图所示。'
- en: Figure 26-6. IPv6 Hop-By-Hop Options and Destination Options header formats
    Each of these extension headers begins with two fixed fields, Next Header and
    Header Extension Length. The rest of the header consists of a sequence of variable-length
    options. Each option has a structure that consists of a type/length/value triplet,
    shown in [Table 26-7](ch26s04.html#ipv_option_format-id001 "Table 26-7. IPv6 Option
    Format").
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-6. IPv6 跳-跳选项和目标选项头格式。这些扩展头每个都以两个固定字段开始，即下一个头部和头部扩展长度。头部的其余部分由一系列可变长度的选项组成。每个选项都有一个由类型/长度/值三元组组成的结构，如图[表26-7](ch26s04.html#ipv_option_format-id001
    "表26-7. IPv6 选项格式")所示。
- en: Table 26-7. IPv6 Option Format
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 表26-7. IPv6 选项格式
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Option Type | 1 | This field indicates the type of option. The bits are interpreted
    according to the sub-subfield" structure, described in [Table 26-8](ch26s04.html#ipv_option_type_subfields
    "Table 26-8. IPv6 Option Type Subfields"). |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 选项类型 | 1 | 此字段指示选项的类型。位根据子子字段“结构”进行解释，如[表26-8](ch26s04.html#ipv_option_type_subfields
    "表26-8. IPv6选项类型子字段")中所述。 |'
- en: '| Opt Data Len | 1 | Specifies the length of the Option Data subfield. Note
    that this is a change in semantics from IPv4, where the Length field indicated
    the size of the entire option; in IPv6 the length of the Option Type and Option
    Data Length fields are not included. |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 选项数据长度 | 1 | 指定选项数据子字段长度。注意，这与IPv4中的语义不同，在IPv4中，长度字段指示整个选项的大小；在IPv6中，选项类型和选项数据长度字段的长度不包括在内。
    |'
- en: '| Option Data | Variable | The data to be sent as part of the option, which
    is specific to the option type. Also sometimes referred to as the Option Value.
    |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| 选项数据 | 可变 | 作为选项的一部分要发送的数据，这取决于选项类型。有时也称为选项值。 |'
- en: Table 26-8. IPv6 Option Type Subfields
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 表26-8. IPv6选项类型子字段
- en: '| Sub-Subfield Name | Size (Bytes) | Description |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| 子子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Unrecognized Option Action | 2/8 (2 bits) | The first two bits specify what
    action should be taken if the device processing the option doesn''t recognize
    the Option Type. The four values are as follows:00: Skip option; process rest
    of header.0: Discard datagram; do nothing else.10: Discard datagram and send an
    ICMP Parameter Problem message with code 2 back to the datagram source.11: Discard
    datagram and send the ICMP message as for value 10, only if destination was not
    a multicast address. |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 未知选项操作 | 2/8 (2位) | 这两个位指定如果处理选项的设备不识别选项类型时应该采取什么操作。四个值如下：00: 跳过选项；处理其余的头部。0:
    丢弃数据报；不做其他操作。10: 丢弃数据报并发送一个带有代码2的ICMP参数问题消息回数据报源。11: 丢弃数据报并发送与值10相同的ICMP消息，仅当目标不是多播地址时。
    |'
- en: '| Option Change Allowed Flag | 1/8 (1 bit) | Set to 1 if the Option Data can
    change while the datagram is en route, or left at 0 if it cannot. |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| 选项更改允许标志 | 1/8 (1位) | 如果选项数据在数据报传输过程中可以更改，则设置为1；如果不可更改，则保留为0。 |'
- en: '| Remainder of Option Type | 5/8 (5 bits) | Five remaining bits that allow
    the specification of 32 different combinations for each combination of the three
    preceding bits. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| 选项类型剩余部分 | 5/8 (5位) | 五个剩余的位允许为前三个位的每个组合指定32种不同的组合。 |'
- en: Note
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Option Type subfield is a bit strange in terms of how it is interpreted.
    Even though it has a substructure with three sub-subfields (as shown in [Table 26-8](ch26s04.html#ipv_option_type_subfields
    "Table 26-8. IPv6 Option Type Subfields"), that structure is informal—the eight
    bits of this field are taken as a single entity. Despite the special meaning of
    the three highest-order bits, the entire field is called the Option Type, not
    just the last five bits, and the whole is used as a single value from 0 to 255\.
    In fact, the sub-subfield names aren''t even specified in the standard; I made
    them up*.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '*在解释方式上，选项类型子字段有点奇怪。尽管它有一个包含三个子子字段的子结构（如[表26-8](ch26s04.html#ipv_option_type_subfields
    "表26-8. IPv6选项类型子字段")所示），但这个结构是非正式的——这个字段的8位被视为一个整体。尽管最高三位有特殊含义，但整个字段被称为选项类型，而不仅仅是最后五位，整个字段从0到255用作单个值。实际上，子子字段名称甚至没有在标准中指定；是我自己编造的*。
    |'
- en: Since each option has a subfield for type, length, and value (data), the options
    are sometimes said to be TLV-encoded. If there are multiple options, they are
    placed one after each other in the header. At the end of all the options, in a
    Hop-By-Hop Options or Destination Options extension header, a device may place
    padding to ensure that the header is a multiple of eight bytes in length.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个选项都有一个类型、长度和值（数据）的子字段，因此有时说选项是TLV编码的。如果有多个选项，它们将按顺序放置在头部中。在所有选项的末尾，在跳步选项或目标选项扩展头中，设备可以放置填充以确保头部长度是8的倍数。
    |
- en: Tip
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Two IPv6 extension header types, Hop-By-Hop Options and Destination
    Options, are used to carry arbitrary optional information in IPv6 datagrams. Each
    consists of a set of variable-length options that are defined using three subfields
    that indicate the option''s type, length, and value.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 两种IPv6扩展头类型，跳步选项和目标选项，用于在IPv6数据报中携带任意可选信息。每个都由一组使用三个子字段定义的可变长度选项组成，这些子字段指示选项的类型、长度和值。'
- en: Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第27章. IPv6数据报大小、分片、重组和路由
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Internet Protocol version 6 (IPv6) changes many of the operating details of
    IP, but most of the basics are the same. In particular, devices still need to
    deliver datagrams over an internetwork that may use different underlying network
    technologies. This means that we must be concerned here, as we were in IPv4, with
    the mechanics of datagram sizing, handling fragmentation and reassembly, and dealing
    with issues related to routing.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议版本6（IPv6）改变了IP的许多操作细节，但大多数基本原理是相同的。特别是，设备仍然需要在可能使用不同底层网络技术的互联网上传递数据报。这意味着我们必须关注这里，就像在IPv4中一样，数据报的大小、处理分片和重组以及处理与路由相关的问题的机制。
- en: In this chapter, I complete the discussion of IPv6 by examining these matters,
    with an eye toward contrasting how they work in IPv6\. This includes a look at
    IPv6 datagram sizing, changes to the maximum transmission unit (MTU), and fragmentation
    and reassembly. I also briefly discuss areas where IPv6 routing is performed in
    the same way as in IPv4, as well as where routing has changed.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我通过检查这些问题来完成IPv6的讨论，目的是对比它们在IPv6中的工作方式。这包括查看IPv6数据报的大小、最大传输单元（MTU）的变化以及分片和重组。我还简要讨论了IPv6路由与IPv4相同以及路由发生变化的地方。
- en: Overview of IPv6 Datagram Sizing and Fragmentation
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6数据报大小和分片概述
- en: The job of IP is to convey messages across an internetwork of connected networks.
    When datagrams are sent between hosts on distant networks, they are carried along
    their journey by routers, one hop at a time, over many physical network links.
    On each step of this journey, the datagram is encoded in a data link layer frame
    for transmission.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: IP的工作是在连接的网络之间传递消息。当在不同网络的主机之间发送数据报时，它们通过路由器逐跳传输，跨越许多物理网络链路。在旅途中每一步，数据报都会被编码在数据链路层帧中以便传输。
- en: In order for a datagram to be successfully carried along a route, its size must
    be small enough to fit within the lower-layer frame at each step of the way. The
    term *maximum transmission unit (MTU)* describes the size limit for any given
    physical network. If a datagram is too large for the MTU of a network, it must
    be broken into pieces—a process called *fragmentation*—and then the pieces are
    *reassembled* at the destination device. This has been a requirement since IPv4,
    and I explain the concepts and issues related to datagram size, MTUs, fragmentation,
    and reassembly in detail in the associated IPv4 discussion, in [Chapter 22](ch22.html
    "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY").
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据报能够成功沿路由传输，其大小必须足够小，以便在每一步都能适应低层帧。术语*最大传输单元（MTU）*描述了任何给定物理网络的大小限制。如果一个数据报太大，无法适应网络的MTU，它必须被分成几块——这个过程称为*分片*——然后这些块在目标设备上重新组装。这自从IPv4以来一直是必需的，我在相关的IPv4讨论中详细解释了与数据报大小、MTU、分片和重组相关的概念和问题，在[第22章](ch22.html
    "第22章。IP数据报大小、分片和重组")。
- en: 'All of these issues apply to sending datagrams in IPv6 as much as they did
    in IPv4\. However, as in other areas of the protocol, some important details of
    how fragmentation and reassembly are done have changed. These changes were made
    to improve the efficiency of the routing process and to reflect the realities
    of current networking technologies: Most can handle average IP datagrams without
    needing fragmentation.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题在发送IPv6数据报时与IPv4一样适用。然而，正如协议的其他领域一样，关于分片和重组的一些重要细节已经发生了变化。这些变化是为了提高路由过程的效率，并反映当前网络技术的现实：大多数可以处理平均IP数据报而不需要分片。
- en: 'The most important differences between IPv4 and IPv6 with respect to datagram
    size, MTU, and fragmentation and reassembly are as follows:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据报大小、MTU和分片与重组，IPv4和IPv6之间最重要的区别如下：
- en: '**Increased Default MTU** In IPv4, the minimum MTU that routers and physical
    links were required to handle was 576 bytes. In IPv6, all links must handle a
    datagram size of at least 1280 bytes. This more than doubling in size improves
    efficiency by increasing the ratio of maximum payload to header length and reduces
    the frequency with which fragmentation is required.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加默认MTU** 在IPv4中，路由器和物理链路必须处理的最低MTU是576字节。在IPv6中，所有链路都必须处理至少1280字节的数据报大小。这种大小的增加通过增加最大有效载荷与头部长度的比率来提高效率，并减少了需要分片的情况。'
- en: '**Elimination of en Route Fragmentation** In IPv4, datagrams may be fragmented
    by either the source device or by routers during delivery. In IPv6, only the source
    node can fragment; routers do not. The source must fragment to the size of the
    smallest MTU on the route before transmission. This has both advantages and disadvantages,
    as you will see. Reassembly is still done only by the destination, as in IPv4.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**消除途中分片** 在IPv4中，数据报可以在传输过程中由源设备或路由器进行分片。在IPv6中，只有源节点可以进行分片；路由器不行。在传输之前，源必须将分片的大小设置为路由上最小的MTU。这将带来优点和缺点，您将看到。重组仍然只由目的地执行，就像在IPv4中一样。'
- en: '**MTU Size Error Feedback** Since routers cannot fragment datagrams, they must
    drop them if they are forced to try to send a too-large datagram over a physical
    link. Using the Internet Control Message Protocol version 6 (ICMPv6; see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")), a feedback process has been
    defined that allows routers to tell source devices that they are using datagrams
    that are too large for the route.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**MTU大小错误反馈** 由于路由器不能分片数据报，如果它们被迫尝试在物理链路上发送过大的数据报，它们必须丢弃它们。使用互联网控制消息协议版本6（ICMPv6；见[第31章](ch31.html
    "第31章。ICMP概念和一般操作"))，已经定义了一个反馈过程，允许路由器告诉源设备它们正在使用对于路由来说太大的数据报。'
- en: '**Path MTU Discovery** Since source devices must decide on the correct size
    of fragments, it is helpful if they have a mechanism for determining what this
    should be. This capability is provided through a special technique called *Path
    MTU Discovery*, which was originally defined for IPv4 but has been refined for
    IPv6.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径MTU发现** 由于源设备必须决定分片的大小，如果它们有一个机制来确定这应该是什么，那就很有帮助。这种能力是通过一种称为**路径MTU发现**的特殊技术提供的，最初是为IPv4定义的，但后来为IPv6进行了改进。'
- en: '**Movement of Fragmentation Header Fields** To reflect the decreased importance
    of fragmentation in IPv4, the permanent fields related to the process that were
    in the IPv4 header have been farmed out to a Fragment extension header and are
    included only when needed.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**分片头字段移动** 为了反映IPv4中分片的重要性降低，与该过程相关的永久字段已经从IPv4头部分离出来，并仅在需要时包含在分片扩展头中。'
- en: Implications of IPv6's Source-Only Fragmentation Rule
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6仅源分片规则的影响
- en: I find the changes in the fragmentation and reassembly process interesting.
    While many other changes in IPv6 represent a shift in responsibility for functions
    from host devices to routers, this one is the opposite. In IPv4, a source node
    can send a datagram of any size that its local link can handle, and let the routers
    take care of fragmenting it as needed. This seems like a sensible model; nodes
    communicate on a large, virtual network, and the details of splitting messages
    as needed for physical links are handled invisibly.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现分片和重组过程中的变化很有趣。虽然IPv6中的许多其他变化代表了从主机设备到路由器的功能责任转移，但这一变化却是相反的。在IPv4中，源节点可以发送其本地链路可以处理的任何大小的数据报，并让路由器根据需要对其进行分片。这似乎是一个合理的模型；节点在一个大型、虚拟的网络中通信，而根据物理链路需要拆分消息的细节则被无形地处理。
- en: The problem with this is that it represents a performance drag on routing. It
    is much faster for a router to forward a datagram intact than to spend time fragmenting
    it. In some cases, fragmentation would need to occur multiple times during the
    transmission of a datagram, and remember that this must happen for every datagram
    on a route. It is a lot more efficient for the source to just send datagrams that
    are the right size in the first place.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的缺点是它代表了路由性能的拖累。路由器转发一个完整的数据报比花费时间对其进行分片要快得多。在某些情况下，分片可能需要在数据报传输过程中多次发生，而且记住，这必须发生在路由上的每个数据报上。源一开始就发送正确大小的数据报要高效得多。
- en: 'Of course, there''s a problem here: How does the source know what size to use?
    The source has no understanding of the physical networks used by the route datagrams
    will take to a destination; in fact, it doesn''t even know what the routes are!
    Thus, it has no idea of what MTU would be best. It has two choices:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里有一个问题：源如何知道应该使用什么大小？源对路由数据报将要使用的物理网络没有任何了解；实际上，它甚至不知道路由是什么！因此，它根本不知道MTU的最佳大小。它有两个选择：
- en: '**Use the Default MTU** The first option is simply to use the default MTU of
    1280 bytes, which all physical networks must be able to handle. This is a good
    choice, especially for short communications or for sending small amounts of data.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用默认MTU** 第一个选项是简单地使用默认的1280字节MTU，所有物理网络都必须能够处理这个大小。这是一个不错的选择，尤其是对于短通信或发送少量数据时。'
- en: '**Use Path MTU Discovery** The alternative is to make use of the Path MTU Discovery
    feature, as described later in the chapter. This feature, defined in RFC 1981,
    defines a method whereby a node sends messages over a route to determine what
    the overall minimum MTU for the path is. It''s a technique that''s very similar
    to the way it is done in IPv4, as discussed in [Chapter 22](ch22.html "Chapter 22. IP
    DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY").'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用路径MTU发现** 另一个选择是利用本章后面描述的路径MTU发现功能。该功能在RFC 1981中定义，定义了一种方法，即节点通过路由发送消息以确定路径的整体最小MTU。这是一种与IPv4中讨论的方法非常相似的技术。[第22章](ch22.html
    "第22章。IP数据报大小、分片和重组")。'
- en: Since routers can't fragment in IPv6, if a datagram is sent by a source that
    is too large for a router, it must drop the datagram. It will then send back to
    the source feedback about this occurrence, in the form of an ICMPv6 Packet Too
    Big message. This tells the source that its datagram was dropped and that it must
    fragment (or reduce the size of its fragments).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由器在IPv6中不能分片，如果一个源发送的数据报太大而无法通过路由器，它必须丢弃该数据报。然后，它将向源发送关于这一事件的反馈，形式为ICMPv6“数据包太大”消息。这告诉源它的数据报已被丢弃，并且它必须分片（或减小其分片的大小）。
- en: This feedback mechanism is also used in discovering path MTUs. The source node
    sends a datagram that has the MTU of its local physical link, since that represents
    an upper bound on the MTU of the path. If this goes through without any errors,
    it knows it can use that value for future datagrams to that destination. If it
    gets back any Packet Too Big messages, it tries again using a smaller datagram
    size. The advantage of this over the 1280 default is that it may allow a large
    communication to proceed with a higher MTU, which improves performance.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反馈机制也用于发现路径MTU。源节点发送一个包含其本地物理链路MTU的数据报，因为那代表了路径MTU的上限。如果这个数据报无错误地通过，它就知道可以使用这个值来发送未来的数据报。如果它收到任何“数据包太大”的消息，它将尝试使用更小的数据报大小。与默认的1280字节相比，这种方法的优点是它可能允许使用更高的MTU进行大量通信，从而提高性能。
- en: Tip
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In IPv6, fragmentation is performed only by the device that''s
    sending a datagram, not by routers. If a router encounters a datagram too large
    to send over a physical network with a small MTU, the router sends an ICMPv6 *Packet
    Too Big* message back to the source of the datagram. This can be used as part
    of a process called *Path MTU Discovery* to determine the minimum MTU of an entire
    route.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在IPv6中，分片仅由发送数据报的设备执行，而不是由路由器执行。如果一个路由器遇到一个太大而无法通过具有小MTU的物理网络发送的数据报，路由器将向数据报的源发送一个ICMPv6“数据包太大”消息。这可以作为称为“路径MTU发现”的过程的一部分来使用，以确定整个路由的最小MTU。'
- en: One drawback of the decision to only fragment at the source is that it introduces
    the potential for problems if there is more than one route between devices or
    if routes change. In IPv4, fragmentation is dynamic and automatic; it happens
    on its own and adjusts as routes change. Path MTU Discovery is a good feature,
    but it is static. It requires that hosts keep track of MTUs for different routes
    and update them regularly. IPv6 does this by redoing Path MTU Discovery if a node
    receives a Packet Too Big message on a route for which it has previously performed
    Path MTU Discovery. However, this takes time.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在源节点进行分片的决定有一个缺点，那就是如果设备之间存在多条路由或路由发生变化，可能会引入潜在的问题。在IPv4中，分片是动态和自动的；它自行发生，并随着路由的变化而调整。路径MTU发现是一个很好的特性，但它却是静态的。它要求主机跟踪不同路由的MTU并定期更新。IPv6通过在节点收到之前已执行路径MTU发现的路由上的“数据包太大”消息时重新执行路径MTU发现来实现这一点。然而，这需要时间。
- en: The IPv6 Fragmentation Process
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6分片过程
- en: 'The actual mechanics of fragmentation in IPv6 are similar to those in IPv4,
    with the added complication that extension headers must be handled carefully.
    For purposes of fragmentation, IPv6 datagrams are broken into the following two
    pieces:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6中分片的实际机制与IPv4中的类似，但增加了处理扩展头部的复杂性。为了分片，IPv6数据报被分成以下两个部分：
- en: '**Unfragmentable Part** This includes the main header of the original datagram,
    as well as any extension headers that need to be present in each fragment. This
    means the main header, and any of the following headers, if present: Hop-By-Hop
    Options, Destination Options (for those options to be processed by devices along
    a route), and Routing.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可分部分** 这包括原始数据报的主报头，以及任何需要存在于每个分片中的扩展报头。这意味着主报头，以及以下任何存在的报头：跳数选项、目的选项（对于需要在路由上的设备处理的选项），以及路由。'
- en: '**Fragmentable Part** This includes the data portion of the datagram, along
    with the other extension headers, if present—Authentication Header, Encapsulating
    Security Payload, and/or Destination Options (for options to be processed only
    by the final destination).'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**可分部分** 这包括数据报的数据部分，以及如果存在的话，其他扩展报头——认证报头、封装安全载荷和/或目的选项（对于仅由最终目的地处理的选项）。'
- en: 'The Unfragmentable Part must be present in each fragment, while the Fragmentable
    Part is split up among the fragments. So to fragment a datagram, a device creates
    a set of fragment datagrams, each of which contains the following, in order:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 不可分部分必须存在于每个分片中，而可分部分则在分片中分割。因此，为了分片一个数据报，设备会创建一组分片数据报，每个数据报按顺序包含以下内容：
- en: '**Unfragmentable Part** The full Unfragmentable Part of the original datagram,
    with its Payload Length changed to the length of the fragment datagram.'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不可分部分** 原始数据报的完整不可分部分，其有效载荷长度已更改为分片数据报的长度。'
- en: '**Fragment Header** A Fragment header with the Fragment Offset, Identification,
    and M flags set in the same way they are used in IPv4.'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分片报头** 一个分片报头，其中片段偏移、标识和M标志的设置方式与IPv4中使用的相同。'
- en: '**Fragment** A fragment of the Fragmentable Part of the original datagram.
    Note that each fragment must have a length that is a multiple of 8 bytes, because
    the value in the Fragment Offset field is specified in multiples of 8 bytes.'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分片** 原始数据报的可分部分的分片。请注意，每个分片必须具有长度为8字节的倍数，因为片段偏移字段中的值是以8字节为单位的倍数。'
- en: Tip
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Fragmentation is done in IPv6 in a manner similar to that of
    IPv4, except that extension headers must be handled specially. Certain extension
    headers are considered *unfragmentable* and appear in each fragment; others are
    fragmented along with the data.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在IPv6中，分片的方式与IPv4类似，但扩展报头必须特别处理。某些扩展报头被认为是*不可分片*的，并出现在每个分片中；其他则与数据一起分片。'
- en: 'Let''s use an example to illustrate how IPv6 fragmentation works. Suppose you
    have an IPv6 datagram exactly 320 bytes wide, consisting of a 40-byte IP header,
    four 30-byte extension headers, and 160 bytes of data. Two of the extension headers
    are unfragmentable, while two are fragmentable. (In practice you would never need
    to fragment such a small datagram, but I am trying to keep the numbers simple.)
    Suppose you need to send this over a link with an MTU of only 230 bytes. You would
    actually require three fragments, not the two you might expect, because of the
    need to put the two 30-byte unfragmentable extension headers in each fragment,
    and the requirement that each fragment be a length that is a multiple of 8\. Here
    is how the fragments would be structured (see [Figure 27-1](ch27s03.html#ipv6_datagram_fragmentation_in_this_illu
    "Figure 27-1. IPv6 datagram fragmentation In this illustration, a 320-byte IPv6
    datagram, containing four 30-byte extension headers, is broken into three fragments.
    The sizes of the fields are shown to scale. The Unfragmentable Part, shown in
    lighter shading on the left, begins each fragment, followed by the Fragment header.
    Then, portions of the Fragmentable Part are placed into each fragment in sequence.
    The Authentication and Destination Options extension headers are part of the Fragmentable
    Part, so that they appear as part of the first fragment.")):'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明IPv6分段是如何工作的。假设你有一个正好320字节的IPv6数据报，由一个40字节的IP头，四个30字节的扩展头和160字节的数据组成。其中两个扩展头是不可分的，而另外两个是可分的。（在实际中，你永远不会需要分段如此小的数据报，但我试图保持数字简单。）假设你需要通过一个只有230字节MTU的链路发送这个数据报。实际上你需要三个片段，而不是你可能预期的两个，因为需要将两个30字节的不可分扩展头放入每个片段中，并且每个片段的长度必须是8的倍数。以下是片段的结构（参见[图27-1](ch27s03.html#ipv6_datagram_fragmentation_in_this_illu
    "图27-1. IPv6数据报分段 在这个图中，一个320字节的IPv6数据报，包含四个30字节的扩展头，被分成三个片段。字段的大小按比例显示。不可分部分，在左侧以较浅的阴影显示，在每个片段的开始，随后是片段头。然后，可分部分的各个部分按顺序放入每个片段中。认证和目标选项扩展头是可分部分的一部分，因此它们看起来像是第一个片段的一部分。"))：
- en: '**First Fragment** The first fragment would consist of the 100-byte Unfragmentable
    Part, followed by a 30-byte Fragment header and the first 96 bytes of the Fragmentable
    Part of the original datagram. This would contain the two fragmentable extension
    headers and the first 36 bytes of data. This leaves 124 bytes of data to send.'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第一片段** 第一个片段将包括100字节的不可分部分，随后是一个30字节的片段头和原始数据报文可分部分的第一个96字节。这将包含两个可分扩展头和前36字节的数据。这将留下124字节的数据需要发送。'
- en: '**Second Fragment** This would also contain the 100-byte Unfragmentable Part,
    followed by a Fragment header, and 96 bytes of data (bytes 36 to 131). This would
    leave 28 bytes of data remaining.'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第二片段** 这将包含100字节的不可分部分，随后是一个片段头，以及96字节的数据（字节36到131）。这将留下28字节的数据未发送。'
- en: '**Third Fragment** The last fragment would contain the 100-byte Unfragmentable
    Part, a Fragment header, and the final 28 bytes of data.'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第三片段** 最后一个片段将包含100字节的不可分部分，一个片段头和最后的28字节数据。'
- en: '![IPv6 datagram fragmentation In this illustration, a 320-byte IPv6 datagram,
    containing four 30-byte extension headers, is broken into three fragments. The
    sizes of the fields are shown to scale. The Unfragmentable Part, shown in lighter
    shading on the left, begins each fragment, followed by the Fragment header. Then,
    portions of the Fragmentable Part are placed into each fragment in sequence. The
    Authentication and Destination Options extension headers are part of the Fragmentable
    Part, so that they appear as part of the first fragment.](httpatomoreillycomsourcenostarchimages287901.png.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![IPv6数据报分段 在这个图中，一个320字节的IPv6数据报，包含四个30字节的扩展头，被分成三个片段。字段的大小按比例显示。不可分部分，在左侧以较浅的阴影显示，在每个片段的开始，随后是片段头。然后，可分部分的各个部分按顺序放入每个片段中。认证和目标选项扩展头是可分部分的一部分，因此它们看起来像是第一个片段的一部分。](httpatomoreillycomsourcenostarchimages287901.png.jpg)'
- en: Figure 27-1. IPv6 datagram fragmentation In this illustration, a 320-byte IPv6
    datagram, containing four 30-byte extension headers, is broken into three fragments.
    The sizes of the fields are shown to scale. The Unfragmentable Part, shown in
    lighter shading on the left, begins each fragment, followed by the Fragment header.
    Then, portions of the Fragmentable Part are placed into each fragment in sequence.
    The Authentication and Destination Options extension headers are part of the Fragmentable
    Part, so that they appear as part of the first fragment.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 图27-1。IPv6数据报分片 在这个示例中，一个包含四个30字节扩展头的320字节IPv6数据报被分成三个分片。字段的大小按比例显示。不可分部分，在左侧以较浅的阴影显示，开始于每个分片，然后是分片头部。然后，将可分部分的各个部分按顺序放入每个分片中。认证和目标选项扩展头部是可分部分的一部分，因此它们看起来像是第一部分的一部分。
- en: The M (More Fragments) flag would be set to 1 in the first two fragments and
    0 in the third, and the Fragment Offset values would be set appropriately. See
    [Chapter 22](ch22.html "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY"),
    which covers IPv4 fragmentation, for more on how these fields are used.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个分片中，M（更多分片）标志会被设置为1，在第三个分片中设置为0，并且分片偏移值会被适当地设置。有关这些字段如何使用的更多信息，请参阅[第22章](ch22.html
    "第22章。IP数据报大小、分片和重组")，它涵盖了IPv4的分片。
- en: The receiving device reassembles by taking the Unfragmentable Part from the
    first fragment and then assembling the Fragment data from each fragment in sequence.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 接收设备通过从第一个分片获取不可分部分，然后按顺序组装每个分片的分片数据来重新组装。
- en: IPv6 Datagram Delivery and Routing
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6数据报交付和路由
- en: 'IP functions such as addressing, datagram encapsulation, and, if necessary,
    fragmentation and reassembly, all lead up to the ultimate objective of the protocol:
    the actual delivery of datagrams from a source device to one or more destination
    devices. Most of the concepts related to how datagram delivery is accomplished
    in IPv6 are the same as in IPv4:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: IP功能，如寻址、数据报封装，以及在必要时分片和重组，所有这些最终都指向协议的最终目标：将数据报从源设备实际交付到一台或多台目标设备。与IPv6中数据报交付相关的多数概念与IPv4中的相同：
- en: Datagrams are delivered directly when the source and destination nodes are on
    the same network. When they are on different networks, delivery is indirect, using
    routing to the destination's network, and then direct to the destination.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当源节点和目标节点位于同一网络时，数据报直接交付。当它们位于不同的网络时，交付是间接的，使用路由到目标网络的路径，然后直接到目标。
- en: Routers look at IP addresses and determine which portion is the network identifier
    (network ID) and which is the host identifier (host ID). IPv6 does this in the
    same basic way as in classless IPv4, despite the fact that IPv6 unicast addresses
    are assigned using a special hierarchical format.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器查看IP地址，并确定哪一部分是网络标识符（网络ID），哪一部分是主机标识符（主机ID）。IPv6以与无类IPv4相同的基本方式执行此操作，尽管IPv6单播地址是使用特殊分层格式分配的。
- en: Routing is still done on a next-hop basis, with sources generally not knowing
    how datagrams get from point A to point B.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由仍然基于下一跳进行，源通常不知道数据报是如何从A点到B点的。
- en: Routing is performed by devices called *routers*, which maintain tables of routes
    that tell them where to forward datagrams to reach different destination networks.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由是由称为*路由器*的设备执行的，这些设备维护着路由表，告诉它们将数据报转发到不同的目标网络。
- en: Routing protocols are used to allow routers to exchange information about routes
    and networks.
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由协议用于允许路由器交换有关路由和网络的信息。
- en: 'Most of the changes in routing in IPv6 are directly related to changes in other
    areas of the protocol, as discussed in the previous chapters. Some of the main
    issues of note related to routing and routers in IPv6 include the following:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6中路由的大部分变化都与协议其他领域的更改直接相关，如前几章所述。与IPv6中的路由和路由器相关的一些主要问题包括以下内容：
- en: '**Hierarchical Routing and Aggregation** One of the goals of the structure
    used for organizing unicast addresses was to improve routing. The unicast addressing
    format is designed to provide a better match between addresses and Internet topology
    and to facilitate route aggregation. Classless addressing using CIDR in IPv4 was
    an improvement but lacked any formal mechanism for creating a scalable hierarchy.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '**分层路由和聚合** 用于组织单播地址的结构的目标之一是改进路由。单播地址格式旨在提供更好的地址与互联网拓扑之间的匹配，并便于路由聚合。在IPv4中使用CIDR的无类地址是一种改进，但它缺乏创建可扩展层次结构的正式机制。'
- en: '**Scoped Local Addresses** Local-use addresses, including site-local and link-local
    addresses, are defined in IPv6, and routers must be able to recognize them. They
    must route them or *not* route them when appropriate. Multicast addresses also
    have various levels of scope.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域本地地址** IPv6中定义了本地使用地址，包括站点本地地址和链路本地地址，路由器必须能够识别它们。在适当的时候，它们必须路由这些地址或*不*路由这些地址。多播地址也有各种作用域级别。'
- en: '**Multicast and Anycast Routing** Multicast is standard in IPv6, not optional
    as in IPv4, so routers must support it. Anycast addressing is a new type of addressing
    in IPv6.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播和任播路由** 多播在IPv6中是标准配置，不是像IPv4那样的可选配置，因此路由器必须支持它。任播寻址是IPv6中的一种新型寻址方式。'
- en: '**More Support Functions** Capabilities must be added to routers to support
    new features in IPv6\. For example, routers play a key role in implementing autoconfiguration
    without the help of a server and Path MTU Discovery in the new IPv6 fragmentation
    scheme.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多支持功能** 路由器必须增加功能以支持IPv6中的新特性。例如，在新的IPv6分片方案中，路由器在无需服务器帮助的情况下实现自动配置和路径MTU发现中发挥着关键作用。'
- en: '**New Routing Protocols** Routing protocols such as RIP must be updated to
    support IPv6.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**新的路由协议** 路由协议，如RIP，必须更新以支持IPv6。'
- en: '**Transition Issues** Last, but certainly not least, routers play a major role
    in supporting the transition from IPv4 to IPv6\. They will be responsible for
    connecting together IPv6 "islands" and performing translation to allow IPv4 and
    IPv6 devices to communicate with each other during the multiyear migration to
    the new protocol.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**过渡问题** 最后，但同样重要的是，路由器在支持从IPv4到IPv6的过渡中扮演着重要角色。它们将负责连接IPv6“岛屿”并执行翻译，以便在多年向新协议迁移的过程中，IPv4和IPv6设备能够相互通信。'
