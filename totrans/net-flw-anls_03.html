<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;VIEWING FLOWS"><div class="titlepage"><div><div><h1 class="title"><a id="viewing_flows"/>Chapter 3. VIEWING FLOWS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2681"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages651574.png.jpg"/></div></div><p>You have sensors transmitting data, and your collector is writing that data to disk. Now what? Flow-tools provides several programs for viewing flow data, generating statistical analysis, and generating reports. You'll start by displaying the data in the flow files.<a class="indexterm" id="IDX-CHP-3-0001"/><a class="indexterm" id="IDX-CHP-3-0002"/><a class="indexterm" id="IDX-CHP-3-0003"/></p><div class="sect1" title="Using flow-print"><div class="titlepage"><div><div><h1 class="title"><a id="using_flow-print"/>Using flow-print</h1></div></div></div><p>Flow files contain tightly packed binary data, and viewing a flow file with <code class="literal">cat</code> or <code class="literal">more</code> will scramble your terminal. To view flow data, you should use <code class="literal">flow-print</code>.<a class="indexterm" id="IDX-CHP-3-0004"/></p><p>Each flow file contains header information that identifies the host that exported the data, the capture time, and so on. When you need to view multiple flow files, you should strip out these headers before feeding the data to <code class="literal">flow-print</code> so that they don't interfere with your viewing of the actual flow data. That's where <code class="literal">flow-cat</code> comes in. You'll use <code class="literal">flow-cat</code> to concatenate multiple flow files and present clean data to <code class="literal">flow-print</code>. Although using <code class="literal">flow-cat</code> is optional, I recommend that you always use it with <code class="literal">flow-print</code> unless you are specifically examining header data.<a class="indexterm" id="IDX-CHP-3-0005"/><a class="indexterm" id="IDX-CHP-3-0006"/><a class="indexterm" id="IDX-CHP-3-0007"/><a class="indexterm" id="IDX-CHP-3-0008"/></p><p>To examine a flow file, use <code class="literal">flow-cat</code> to feed the data to <code class="literal">flow-print</code>, and then pipe the result to a pager so that you can view all of the results, as shown in <a class="xref" href="ch03.html#sample_flow-print_output" title="Example 3-1. Sample flow-print output">Example 3-1</a>.</p><div class="example"><a id="sample_flow-print_output"/><p class="title">Example 3-1. Sample flow-print output</p><div class="example-contents"><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2009-12-01.171500-0500 | flow-print | less</code></strong>
srcIP            dstIP            prot  srcPort  dstPort  octets      packets
36.85.32.9       158.43.192.1     17    2325     53       59          1
158.43.192.1     36.85.32.9       17    53       2325     134         1
36.85.32.37      83.243.35.204    6     25       4115     1035        14
83.243.35.204    36.85.32.37      6     4115     25       1527        12
...</pre></div></div><p>Each line in <a class="xref" href="ch03.html#sample_flow-print_output" title="Example 3-1. Sample flow-print output">Example 3-1</a> represents one flow. The first column, <code class="literal">srcIP</code>, shows the source IP address of the flow, and the second (<code class="literal">dstIP</code>) shows the destination address.<a class="indexterm" id="IDX-CHP-3-0009"/></p><p>The <code class="literal">prot</code> column displays the protocol number for this flow. Protocol 17 is UDP, and protocol 6 is TCP. (<a class="xref" href="ch03.html#common_protocol_numbers" title="Table 3-1. Common Protocol Numbers">Table 3-1</a> in <a class="xref" href="ch03.html#common_protocol_and_port_number_assignme" title="Common Protocol and Port Number Assignments">Common Protocol and Port Number Assignments</a> describes the protocols most commonly seen on a network, and you'll find a mostly complete list of these protocols numbers in the <span class="emphasis"><em>/etc/protocols</em></span> file on your collector server.)</p><p>The <code class="literal">srcPort</code> column shows the source port of a TCP or UDP flow, and <code class="literal">dstPort</code> shows the destination port. Finally, the <code class="literal">octets</code> column shows the number of bytes in the flow, and <code class="literal">packets</code> shows the number of packets in the flow.</p><p>The first flow in <a class="xref" href="ch03.html#sample_flow-print_output" title="Example 3-1. Sample flow-print output">Example 3-1</a> comes from the address 36.85.32.9. This is an address on my network that's going to the IP 158.43.192.1. Off the top of my head, I haven't the foggiest idea what this address is or why I'm communicating with it, but I do know that protocol 17 is UDP, the source port is 2325, and the destination port is 53. Port 53 is the UDP port reserved for DNS transactions, so I know that this flow represents a DNS query, and I also know from the <code class="literal">octets</code> column that 59 bytes were sent in one packet.</p><p>Now look at the second flow in <a class="xref" href="ch03.html#sample_flow-print_output" title="Example 3-1. Sample flow-print output">Example 3-1</a>. Notice that the source and destination IP addresses are reversed from our first flow: The remote end sent data from port 53 to port 2325 on my end, which is the reverse of the first flow. The response, 134 bytes in one packet, is almost certainly a DNS response to the query sent in the first flow, but I'd need to view the timing information to be absolutely certain.<a class="indexterm" id="IDX-CHP-3-0010"/><a class="indexterm" id="IDX-CHP-3-0011"/></p><p>The third flow in <a class="xref" href="ch03.html#sample_flow-print_output" title="Example 3-1. Sample flow-print output">Example 3-1</a> originates from a different IP on my network and is going to a different remote IP than either of the IPs in the first two flows. This flow represents a TCP/IP transaction that is separate and different from the first two flows. This transaction runs over protocol 6 (or TCP) and has a source port of 25 and a destination port of 4115. That's odd. TCP port 25 is used for SMTP, or email. You would expect an email connection to be <span class="emphasis"><em>to</em></span> port 25, not <span class="emphasis"><em>from</em></span> port 25. Why would a network transaction have a <span class="emphasis"><em>source</em></span> port of 25? Remember, every network transaction includes two flows: one from the client to the server and another from the server to the client. This "source port 25" flow is the server's communication to the client.</p><p>Now look at the fourth and final flow. This flow is the reverse of the third flow and represents the other half of that SMTP transaction. The source port is 4115, and the destination is 25, which makes sense if someone is trying to send mail to the email server.<a class="indexterm" id="IDX-CHP-3-0012"/><a class="indexterm" id="IDX-CHP-3-0013"/><a class="indexterm" id="IDX-CHP-3-0014"/><a class="indexterm" id="IDX-CHP-3-0015"/><a class="indexterm" id="IDX-CHP-3-0016"/><a class="indexterm" id="IDX-CHP-3-0017"/></p><p>As these last two lines demonstrate, <code class="literal">flow-print</code> does not necessarily print flows in the order in which the traffic occurred. For example, if two hosts have very fast connectivity to each other, the flow record might show both the flow that initiates a connection and the flow that is the response to that connection request as starting simultaneously. In that case, <code class="literal">flow-print</code> displays the flows in the order in which they are recorded in the flow file. (We'll extract actual timing data from flow files later.)</p><div class="sidebar"><a id="bits_comma_bytes_comma_and_octets"/><p class="title">BITS, BYTES, AND OCTETS</p><p>Most network management systems offer information about traffic in some multiple of bits—kilobits, megabits, and so on, all in base 10. However, some flow analysis systems, such as flow-tools, offer traffic information in <span class="emphasis"><em>octets</em></span>, rather than bits or even bytes, because the byte is not always 8 bits.</p><p>Most computing professionals know a byte as 8 bits. But <span class="emphasis"><em>very</em></span> strictly speaking, most computer professionals are wrong. A byte is the smallest unit of memory addressing on a particular hardware platform. The Intel 8086 CPU and its descendants, today's most common machines, have an 8-bit byte, which many other platforms adopted as a convenient standard. Commercially available hardware exists with bytes anywhere from 5 to 12 bits, and experimental hardware can have bytes of just about any size.</p><p>An octet is always eight bits, the same size as the normal byte. If you have systems where a byte is not 8 bits, the word <span class="emphasis"><em>byte</em></span> is ambiguous. Some software, such as flow-tools, explicitly uses octets for disambiguation because almost all network administrators only have hardware with 8-bit bytes. (Most of us don't have odd hardware.) You just need to recognize octets when you see them and be grateful that some network administrators suffer from annoyances you'll never need to cope with.</p></div><div class="sect2" title="Printing Protocol and Port Names"><div class="titlepage"><div><div><h2 class="title"><a id="printing_protocol_and_port_names"/>Printing Protocol and Port Names</h2></div></div></div><p>You probably remember that port 53 is for the Domain Name System, and port 25 is for email's SMTP protocol, but most of us haven't memorized the purpose of every port number. Similarly, you might remember that protocol 6 is TCP and 17 is UDP, but you can't bother memorizing all the other protocol numbers. The files <span class="emphasis"><em>/etc/protocols</em></span> and <span class="emphasis"><em>/etc/services</em></span> list port numbers and their associated names. Use the <code class="literal">-n</code> flag to have <code class="literal">flow-print</code> display ports and protocols using these names, as shown here:</p><a id="I_programlisting3_d1e2920"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-01.171500-0500 | flow-print -n | less</code></strong>
srcIP            dstIP            prot  srcPort  dstPort  octets      packets
36.85.32.9       158.43.192.1     udp   2325     domain   59          1
158.43.192.1     36.85.32.9       udp   domain   2325     134         1
36.85.32.37      83.243.35.204    tcp   smtp     4115     1035        14
83.243.35.204    36.85.32.37      tcp   4115     smtp     1527        12
...</pre><p>These are the same results as in <a class="xref" href="ch03.html#sample_flow-print_output" title="Example 3-1. Sample flow-print output">Example 3-1</a>, except that in the <code class="literal">prot</code> column <code class="literal">tcp</code> replaces 6 and <code class="literal">udp</code> replaces 17. Similarly, the numbers in the <code class="literal">srcPort</code> and <code class="literal">dstPort</code> columns have been replaced with service names such as <code class="literal">domain</code> and <code class="literal">smtp</code>. While using names for port numbers is reasonable, using hostnames instead of IP addresses introduces a dependency on the network. Also, getting hostnames for hundreds or thousands of IP addresses can take a very long time.<a class="indexterm" id="IDX-CHP-3-0018"/><a class="indexterm" id="IDX-CHP-3-0019"/><a class="indexterm" id="IDX-CHP-3-0020"/><a class="indexterm" id="IDX-CHP-3-0021"/><a class="indexterm" id="IDX-CHP-3-0022"/><a class="indexterm" id="IDX-CHP-3-0023"/><a class="indexterm" id="IDX-CHP-3-0024"/><a class="indexterm" id="IDX-CHP-3-0025"/><a class="indexterm" id="IDX-CHP-3-0026"/><a class="indexterm" id="IDX-CHP-3-0027"/><a class="indexterm" id="IDX-CHP-3-0028"/><a class="indexterm" id="IDX-CHP-3-0029"/></p><p>Not all <code class="literal">flow-print</code> formats support output with names, however. In those output formats, <code class="literal">flow-print</code> ignores the <code class="literal">-n</code> flag.</p></div><div class="sect2" title="Common Protocol and Port Number Assignments"><div class="titlepage"><div><div><h2 class="title"><a id="common_protocol_and_port_number_assignme"/>Common Protocol and Port Number Assignments</h2></div></div></div><p>Once you've worked with flow information for a while, you'll begin to recognize port and protocol numbers automatically. <a class="xref" href="ch03.html#common_protocol_numbers" title="Table 3-1. Common Protocol Numbers">Table 3-1</a> lists some protocols you'll commonly see on the Internet.<a class="indexterm" id="IDX-CHP-3-0030"/></p><div class="table"><a id="common_protocol_numbers"/><p class="title">Table 3-1. Common Protocol Numbers</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common Protocol Numbers"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Number</p></th><th style="text-align: left" valign="bottom"><p>Protocol</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>Internet Control Message Protocol (ICMP)</p></td></tr><tr><td style="text-align: left" valign="top"><p>6</p></td><td style="text-align: left" valign="top"><p>Transmission Control Protocol (TCP)</p></td></tr><tr><td style="text-align: left" valign="top"><p>17</p></td><td style="text-align: left" valign="top"><p>User Datagram Protocol (UDP)</p></td></tr><tr><td style="text-align: left" valign="top"><p>47</p></td><td style="text-align: left" valign="top"><p>Generic Routing Encapsulation (GRE)<a class="indexterm" id="IDX-CHP-3-0031"/></p></td></tr><tr><td style="text-align: left" valign="top"><p>50</p></td><td style="text-align: left" valign="top"><p>Encapsulating Security Payload (ESP)<a class="indexterm" id="IDX-CHP-3-0032"/></p></td></tr><tr><td style="text-align: left" valign="top"><p>51</p></td><td style="text-align: left" valign="top"><p>Authentication Header (AH)<a class="indexterm" id="IDX-CHP-3-0033"/></p></td></tr></tbody></table></div></div><p>Similarly, <a class="xref" href="ch03.html#common_tcp_and_udp_port_assignments" title="Table 3-2. Common TCP and UDP Port Assignments">Table 3-2</a> lists a few of the commonly used TCP and UDP port assignments on internal and public networks. (For a more complete list, see <span class="emphasis"><em>/etc/services</em></span> on your collector host.)</p><div class="table"><a id="common_tcp_and_udp_port_assignments"/><p class="title">Table 3-2. Common TCP and UDP Port Assignments</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common TCP and UDP Port Assignments"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Number</p></th><th style="text-align: left" valign="bottom"><p>Service</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>20</p></td><td style="text-align: left" valign="top"><p>File Transfer Protocol (FTP) data channel</p></td></tr><tr><td style="text-align: left" valign="top"><p>21</p></td><td style="text-align: left" valign="top"><p>File Transfer Protocol (FTP) control channel</p></td></tr><tr><td style="text-align: left" valign="top"><p>22</p></td><td style="text-align: left" valign="top"><p>Secure Shell (SSH)</p></td></tr><tr><td style="text-align: left" valign="top"><p>23</p></td><td style="text-align: left" valign="top"><p>Telnet</p></td></tr><tr><td style="text-align: left" valign="top"><p>25</p></td><td style="text-align: left" valign="top"><p>Email (SMTP)</p></td></tr><tr><td style="text-align: left" valign="top"><p>53</p></td><td style="text-align: left" valign="top"><p>Domain Name Service (DNS)</p></td></tr><tr><td style="text-align: left" valign="top"><p>80</p></td><td style="text-align: left" valign="top"><p>Hypertext Transfer Protocol (HTTP, Web)</p></td></tr><tr><td style="text-align: left" valign="top"><p>137</p></td><td style="text-align: left" valign="top"><p>NetBIOS Naming Service (Windows file sharing)</p></td></tr><tr><td style="text-align: left" valign="top"><p>138</p></td><td style="text-align: left" valign="top"><p>NetBIOS Datagram Service (Windows file sharing)</p></td></tr><tr><td style="text-align: left" valign="top"><p>139</p></td><td style="text-align: left" valign="top"><p>NetBIOS Session Service (Windows file sharing)</p></td></tr><tr><td style="text-align: left" valign="top"><p>161</p></td><td style="text-align: left" valign="top"><p>Simple Network Management Protocol (SNMP)</p></td></tr><tr><td style="text-align: left" valign="top"><p>389</p></td><td style="text-align: left" valign="top"><p>Lightweight Directory Access Protocol (LDAP)</p></td></tr><tr><td style="text-align: left" valign="top"><p>443</p></td><td style="text-align: left" valign="top"><p>Secure HTTP (HTTPS)</p></td></tr><tr><td style="text-align: left" valign="top"><p>445</p></td><td style="text-align: left" valign="top"><p>SMB over TCP (Windows file sharing)</p></td></tr></tbody></table></div></div><p>You'll find many more ports than this in use, of course, and if you find that a port isn't in this list or in <span class="emphasis"><em>/etc/services</em></span>, an Internet search should identify it. Some ports will stubbornly resist identification from the network, though: Some program on the host is using that port, and you'll need to use that host's native tools to identify that program.<a class="indexterm" id="IDX-CHP-3-0034"/><a class="indexterm" id="IDX-CHP-3-0035"/><a class="indexterm" id="IDX-CHP-3-0036"/><a class="indexterm" id="IDX-CHP-3-0037"/><a class="indexterm" id="IDX-CHP-3-0038"/><a class="indexterm" id="IDX-CHP-3-0039"/><a class="indexterm" id="IDX-CHP-3-0040"/><a class="indexterm" id="IDX-CHP-3-0041"/></p><div class="sidebar"><a id="ports_vs._services"/><p class="title">PORTS VS. SERVICES</p><p>Always remember that a port assignment is not conclusive proof that a particular protocol is running over that port. A systems administrator can run any program on any port. For example, you can run a web server on port 25 (email) or an FTP server on port 443 (HTTPS). One of my servers runs SSH on ports 23, 25, 53, 80, 443, and more, which lets me evade most simple packet-filtering firewalls. If you discover suspicious traffic, such as very long TCP-based DNS requests, remember that users are tricky little buggers and will try just about anything to evade your access controls.<a class="indexterm" id="IDX-CHP-3-0042"/><a class="indexterm" id="IDX-CHP-3-0043"/></p></div></div><div class="sect2" title="Viewing Flow Record Header Information with -p"><div class="titlepage"><div><div><h2 class="title"><a id="viewing_flow_record_header_information_w"/>Viewing Flow Record Header Information with -p</h2></div></div></div><p>Each flow file includes header data that records the collector hostname, timing and compression information, and other capture data. The <code class="literal">-p</code> flag prints the header information from a flow file before any of the flows to make it easier for you to identify the sensor host, start and stop time of a flow, how long a flow ran, how many flows <code class="literal">flow-capture</code> believes were lost in transit, and so on. This flow data is not frequently useful, but you can see it if you think it might help.</p><p>Remember, <code class="literal">flow-cat</code> specifically strips out this header data to avoid confusing other flow tools, which means that you can only effectively examine the headers of one flow file at a time, and you cannot use <code class="literal">flow-cat</code>.</p><a id="I_programlisting3_d1e3277"/><pre class="programlisting"># <strong class="userinput"><code>flow-print -p &lt; ft-v05.2011-12-01.171500-0500 | less</code></strong></pre></div><div class="sect2" title="Printing to a Wide Terminal"><div class="titlepage"><div><div><h2 class="title"><a id="printing_to_a_wide_terminal"/>Printing to a Wide Terminal</h2></div></div></div><p>Many flow-print reports contain a lot of information and as such don't have very much whitespace between columns. The <code class="literal">-w</code> flag tells <code class="literal">flow-print</code> that you have a wide terminal, so it can add extra space between the columns to make the output easier to read. If you have a very wide terminal, however, I suggest you look at format 5 instead.</p><div class="sidebar"><a id="flags_and_control_bits"/><p class="title">FLAGS AND CONTROL BITS</p><p>The TCP protocol includes <span class="emphasis"><em>flags</em></span>, also known as <span class="emphasis"><em>control bits</em></span>. <code class="literal">flow-print</code> provides the flags field for TCP flows, but this field is meaningless for other protocols. I'll call TCP flags by the name <span class="emphasis"><em>control bits</em></span> to be consistent.</p></div></div></div></div>
<div class="sect1" title="Setting flow-print Formats with -f"><div class="titlepage"><div><div><h1 class="title"><a id="setting_flow-print_formats_with_-f"/>Setting flow-print Formats with -f</h1></div></div></div><p>Because the default <code class="literal">flow-print</code> output might not include all the information you're interested in (and it certainly doesn't include all the information included within a flow file), <code class="literal">flow-print</code> supports a wide variety of output formats. You set the <code class="literal">flow-print</code> format with the <code class="literal">-f</code> flag.<a class="indexterm" id="IDX-CHP-3-0044"/><a class="indexterm" id="IDX-CHP-3-0045"/><a class="indexterm" id="IDX-CHP-3-0046"/><a class="indexterm" id="IDX-CHP-3-0047"/><a class="indexterm" id="IDX-CHP-3-0048"/><a class="indexterm" id="IDX-CHP-3-0049"/><a class="indexterm" id="IDX-CHP-3-0050"/><a class="indexterm" id="IDX-CHP-3-0051"/><a class="indexterm" id="IDX-CHP-3-0052"/></p><p>Each format has a number. For example, format 3 is the default format most commonly used by <code class="literal">flow-print</code>. (If you are using NetFlow version 8, <code class="literal">flow-print</code> might choose a different default.) You can use these format options to present flow data in the manner that best suits you, as demonstrated in the following examples. I'll cover only the most useful ones, but you can learn about the other formats in the <code class="literal">flow-print</code> man page.</p><div class="sect2" title="Showing Interfaces and Ports in Hex with Format -f 0"><div class="titlepage"><div><div><h2 class="title"><a id="showing_interfaces_and_ports_in_hex_with"/>Showing Interfaces and Ports in Hex with Format -f 0</h2></div></div></div><p>If you want to view the router interfaces the flows passed through, use format 0, as shown here:</p><a id="I_programlisting3_d1e3382"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-01.171500-0500 | flow-print -f 0 | less</code></strong>
Sif  SrcIPaddress     Dif  DstIPaddress      Pr SrcP DstP  Pkts       Octets
0000 36.85.32.9       0000 158.43.192.1      11 915  35    1          59
0000 158.43.192.1     0000 36.85.32.9        11 35   915   1          134
0000 36.85.32.37      0000 83.243.35.204     06 19   1013  14         1035
0000 83.243.35.204    0000 36.85.32.37       06 1013 19    12         1527
...</pre><p>Much of this output looks the same as the default output, but notice the addition of the <code class="literal">Sif</code> and <code class="literal">Dif</code> columns. These represent the source (<code class="literal">Sif</code>) and destination (<code class="literal">Dif</code>) interfaces. Flow records include information on which interface a packet entered on and which interface the flow departed on. You can match these to router interfaces, as you'll see in <a class="xref" href="ch04.html" title="Chapter 4. FILTERING FLOWS">Chapter 4</a> (<a class="xref" href="ch04s02.html#identifying_interface_numbers_using_snmp" title="Identifying Interface Numbers Using SNMP">Identifying Interface Numbers Using SNMP</a> in <a class="xref" href="ch04s02.html#identifying_interface_numbers_using_snmp" title="Identifying Interface Numbers Using SNMP">Identifying Interface Numbers Using SNMP</a>).</p><p>However, software flow sensors do <span class="emphasis"><em>not</em></span> record interface information because they cannot access it. Software-based sensors listen to a monitor port on a switch, but they can't see interface information. The interface number is always 0 as far as they're concerned.</p><p>Format <code class="literal">0</code> adds interface numbers to the flow output by compressing some of the other columns. The protocol column is now <code class="literal">Pr</code>, for example. But take a look at the numbers. The first flow is protocol 11 (or Network Voice Protocol per <span class="emphasis"><em>/etc/protocols</em></span>), the source port is 915, and the destination port is 35. You're almost certainly not running NVP on your network! What's going on here?</p><p>What's happening is that this format creates space for interface numbers by printing port and protocol information in hexadecimal. For example, 11 is hex for 17, or UDP; 915 is hex for 2325; and 35 is hex for 53. As it turns out, all four of these flows are exactly the same flows shown in the earlier examples, just printed in hex and with the interface column added.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Printing the port numbers in hex is useful if you're looking at ICMP flows. If you're looking at TCP or UDP flows with ports and interfaces on something other than an old 80-column terminal, use the 132-column format instead.<a class="indexterm" id="IDX-CHP-3-0053"/><a class="indexterm" id="IDX-CHP-3-0054"/><a class="indexterm" id="IDX-CHP-3-0055"/><a class="indexterm" id="IDX-CHP-3-0056"/><a class="indexterm" id="IDX-CHP-3-0057"/></p></div></div><div class="sect2" title="Two Lines with Times, Flags, and Hex Ports Using -f 1"><div class="titlepage"><div><div><h2 class="title"><a id="two_lines_with_times_comma_flags_comma"/>Two Lines with Times, Flags, and Hex Ports Using -f 1</h2></div></div></div><p>There is a better way to show all the information for a flow on a standard-width screen: Split each flow across two lines. Use format <code class="literal">1</code> to see interface information and times as well.</p><a id="I_programlisting3_d1e3458"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-01.171500-0500 | flow-print -n -f 1 | less</code></strong>
 Sif  SrcIPaddress     DIf  DstIPaddress      Pr SrcP DstP  Pkts  Octets
   StartTime          EndTime             Active   B/Pk Ts Fl

 0000 36.85.32.9       0000 158.43.192.1      11 915  35    1          59
❶  1201.17:09:46.750  1201.17:09:46.869      0.119 59  00 00

 0000 158.43.192.1     0000 36.85.32.9        11 35   915   1          134
   1201.17:09:46.750  1201.17:09:46.869      0.119 134 00 00

 0000 36.85.32.37      0000 83.243.35.204     06 19   1013  14         1035
   1201.17:09:46.912  1201.17:09:51.890     4.978 ❷73  00 1b

 0000 83.243.35.204    0000 36.85.32.37       06 1013 19    12         1527
   1201.17:09:46.912  1201.17:09:51.890     4.978 ❸127 00 1b
 ...</pre><p>These are the same flows that have appeared in all preceding examples, but they look very different. Each flow is shown on two lines, with a blank line separating individual flows. In addition, the entries on each line are slightly offset. This two-line format can be confusing at first glance, especially because it doesn't have actual columns: The header shows where information appears within each flow's two-line entry. The first line of each flow shows the source interface, source IP address, destination interface, destination IP address, protocol, source and destination ports, number of packets, and number of octets in the flow. (You've seen all of these before.) Take a moment to see how these appear in each of the four sample flows, and then you can look at the new items in the second line of each flow.<a class="indexterm" id="IDX-CHP-3-0058"/></p><p>The <code class="literal">StartTime</code> and <code class="literal">EndTime</code> spaces give the time that a connection started and ended. Here, at ❶, <code class="literal">1201</code> represents the date, December 1. The next three values give the time in 24-hour-clock format: <code class="literal">17:09:46</code> is 5:09:46 <span class="keycap"><strong>pm</strong></span>. The last fraction is the millisecond the flow began, or <code class="literal">.750</code> seconds. (If you need more precision than this, you're probably trying to solve the wrong problem.)</p><p>The <code class="literal">Active</code> column gives the number of seconds the flow was active, saving you the trouble of subtracting the <code class="literal">StartTime</code> from the <code class="literal">EndTime</code> (which would be easy with the first two flows but slightly more difficult as the flows grow longer).</p><p>The <code class="literal">B/Pk</code> space gives the average number of bytes per packet. The first flow had 59 bytes in 1 packet, so the math is pretty easy, but it's more difficult in larger flows. The third flow at ❷ averaged 73 bytes per packet, while the fourth at ❸ averaged 127 bytes per packet.<a class="indexterm" id="IDX-CHP-3-0059"/><a class="indexterm" id="IDX-CHP-3-0060"/><a class="indexterm" id="IDX-CHP-3-0061"/><a class="indexterm" id="IDX-CHP-3-0062"/></p><p>The <code class="literal">Ts</code> space gives the Type of Service (ToS), which is almost always <code class="literal">00</code> because most TCP/IP networks do not have to respect the ToS flag. Generally, a ToS in a packet indicates either that you're on an experimental network, that you're using complicated services such as VoIP or MPLS, or that someone is playing silly twits.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-1" id="CHP-3-FN-1">4</a>]</sup></p><p>The <code class="literal">Fl</code> space gives the flow's flags, the TCP control bits. Non-TCP flows, such as the first two, always show flags of zero. The third and fourth examples are TCP flows, and the flags are shown as <code class="literal">1b</code> for both. See <a class="xref" href="ch03s03.html" title="TCP Control Bits and Flow Records">TCP Control Bits and Flow Records</a> in <a class="xref" href="ch03s03.html" title="TCP Control Bits and Flow Records">TCP Control Bits and Flow Records</a> to learn how to transform <code class="literal">1b</code> into a meaningful value.</p></div><div class="sect2" title="Printing BGP Information"><div class="titlepage"><div><div><h2 class="title"><a id="printing_bgp_information"/>Printing BGP Information</h2></div></div></div><p>Routers that speak Border Gateway Protocol (BGP) with multiple upstream ISPs transmit flow records that contain autonomous system numbers (ASNs). Format 4 prints this information instead of the port numbers. Otherwise, this format includes the usual source and destination addresses, protocol, octets, and packet information you've seen in other formats.<a class="indexterm" id="IDX-CHP-3-0063"/></p><p>These are the same four flows used in <a class="xref" href="ch03.html#sample_flow-print_output" title="Example 3-1. Sample flow-print output">Example 3-1</a>, displayed in format 4:</p><a id="I_programlisting3_d1e3569"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-01.171500-0500 | flow-print -n -f 4 | less</code></strong>
srcIP              dstIP              prot  srcAS  dstAS  octets      packets
36.85.32.9/0       158.43.192.1/0     udp   0      701    59          1
158.43.192.1/0     36.85.32.9/0       udp   701    0      134         1
36.85.32.37/0      83.243.35.204/0    tcp   0      4713   1035        14
83.243.35.204/0    36.85.32.37/0      tcp   4713   0      1527        12
...</pre><p>Note in the previous listing that either the source (<code class="literal">srcAS</code>) or destination AS (<code class="literal">dstAS</code>) for each flow is 0. These flows are sourced locally. Flow sensors don't track your local AS.</p><p>If you're not using BGP, this format is irrelevant to you.</p></div><div class="sect2" title="Wide-Screen Display"><div class="titlepage"><div><div><h2 class="title"><a id="wide-screen_display"/>Wide-Screen Display</h2></div></div></div><p>If you have a sufficiently wide monitor, working in 80 columns is an annoyance. Why not just have a single very wide format that can show the most useful stuff on a single line? While we're at it, let's get rid of that hexadecimal and print everything in decimal. That's what format 5 is for, the format I use most frequently when examining network problems.</p><p>Like a summer special-effects blockbuster film, this format works nicely on a wide-screen monitor but less well on the printed page. But rather than provide an actual printed sample that would run across two facing pages of the book or have to be printed sideways, let's just walk through the fields this format shows.<a class="indexterm" id="IDX-CHP-3-0064"/><a class="indexterm" id="IDX-CHP-3-0065"/><a class="indexterm" id="IDX-CHP-3-0066"/></p><a id="I_programlisting3_d1e3606"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-01.171500-0500 | flow-print -f 5 | less</code></strong></pre><p>Format 5 produces the columns <code class="literal">Start</code>, <code class="literal">End</code>, <code class="literal">Sif</code>, <code class="literal">SrcIPaddress</code>, <code class="literal">SrcP</code>, <code class="literal">DstIPaddress</code>, <code class="literal">DstP</code>, <code class="literal">P</code>, <code class="literal">Fl</code>, <code class="literal">Pkts</code>, and <code class="literal">Octets</code>.</p><p><code class="literal">Start</code> and <code class="literal">End</code> give the times the flow begins and ends in millisecond resolution, just like format 1.</p><p>Then there's <code class="literal">Sif</code> (source interface), <code class="literal">SrcIPaddress</code> (source IP address), and <code class="literal">SrcP</code> (source port), followed by <code class="literal">DIf</code> (destination interface), <code class="literal">DstIPAddress</code> (destination IP address), and <code class="literal">DstP</code> (destination port). You should have no trouble reading these after understanding the earlier reports.</p><p><code class="literal">P</code> is the protocol number.</p><p><code class="literal">Fl</code> gives the TCP control bits printed in decimal.</p><p>At the end, <code class="literal">Pkts</code> gives you the number of packets in the flow, and <code class="literal">Octets</code> gives the bytes.</p><div class="sidebar"><a id="times_vs._times"/><p class="title">TIMES VS. TIMES</p><p>Flow record files are named after the time they were collected on the server. The times shown when printing flows are the time on the flow sensor. If your collector's clock and your sensor's clock don't match, the times shown in your flow records won't match the time the records were collected. Synchronize your clocks!</p></div></div><div class="sect2" title="IP Accounting Format"><div class="titlepage"><div><div><h2 class="title"><a id="ip_accounting_format"/>IP Accounting Format</h2></div></div></div><p>Perhaps you have software that interprets Cisco IP accounting output or you've looked at the output for so long that you can process it without expending precious brainpower. Format 6, shown here, exists specifically to make you happy:</p><a id="I_programlisting3_d1e3700"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-01.171500-0500 | flow-print -f 6 | less</code></strong>
   Source           Destination              Packets               Bytes
 36.85.32.9       158.43.192.1                     1                  59
 158.43.192.1     36.85.32.9                       1                 134
 36.85.32.37      83.243.35.204                   14                1035
 83.243.35.204    36.85.32.37                     12                1527
...</pre><p>For example, here are the four sample flows in Cisco format. If you sort this output by the number of bytes, you should be able to easily identify the hosts exchanging the most traffic.</p><a id="I_programlisting3_d1e3707"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-12-01.171500-0500  | flow-print -f 6 | sort -rnk 4 | less</code></strong>
 36.85.32.36      64.18.6.14                ❶  12820         ❷  19216320
 36.85.32.36      64.18.6.13                   12820            19216320
 207.46.209.247   36.85.32.4                   10977            16458558
 84.96.92.121     36.85.32.37                   6904             9671951
...</pre><p>By sorting the flows into order by the number of octets sent, you've ranked the flows from largest to smallest. What filled up your circuit? Here's the quick answer: The first line shows that the host 36.85.32.36 sent 64.18.6.14 (❶) 12,820 packets containing (❷) 19,216,320 bytes. The same host 36.85.32.36 sent 64.18.6.13 the same amount of traffic. Further filtering and reporting can identify the type of traffic between these busiest hosts, as you'll see in the next two chapters.<a class="indexterm" id="IDX-CHP-3-0067"/><a class="indexterm" id="IDX-CHP-3-0068"/><a class="indexterm" id="IDX-CHP-3-0069"/><a class="indexterm" id="IDX-CHP-3-0070"/></p><p>Now that you can view the traffic any way you want, let's take a closer look at some intricacies of TCP and ICMP connections.</p><div class="sidebar"><a id="warning_colon_hexadecimal_math_ahead_exc"/><p class="title">WARNING: HEXADECIMAL MATH AHEAD!</p><p>The network is binary, and lots of it is in base 16. To understand TCP control bits and ICMP codes and types, you'll need to use basic hexadecimal math. Remember, a leading 0x indicates that a number is hexadecimal</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-1" id="ftn.CHP-3-FN-1">4</a>] </sup>Although Type of Service/Quality of Service are worthwhile topics and although flow-tools supports ToS/QoS, these topics are required by only a small fraction of networks. Including a proper discussion of them would make this book much longer. Once you understand how to search and report on flows based on ports and addresses, you won't have any trouble processing flows based on their ToS or QoS.</p></div></div></div>
<div class="sect1" title="TCP Control Bits and Flow Records"><div class="titlepage"><div><div><h1 class="title"><a id="tcp_control_bits_and_flow_records"/>TCP Control Bits and Flow Records</h1></div></div></div><p>Every TCP packet includes one or more control bits, which are on-off switches that tell the connection participants how to handle a particular packet. Flow records capture the control bits used by each TCP flow. These control bits are not terribly useful when a connection works correctly but are invaluable when identifying problems. If you're not familiar with TCP control bits, read a good TCP/IP primer such as Charles A. Kozierok's <span class="emphasis"><em>The TCP/IP Guide</em></span> (No Starch Press, 2005).</p><p>Control bits are given this name because TCP has six bits set aside just for them. These bits are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>The SYN (synchronize) bit</strong></span> indicates a connection synchronization request. It permits the sender and receiver to synchronize TCP sequence numbers, allocate consistent ports on each end, and so on. This bit is always set on the first packet in a flow.<a class="indexterm" id="IDX-CHP-3-0071"/></p></li><li class="listitem"><p><span class="strong"><strong>The ACK (acknowledge) bit</strong></span> indicates that a packet contains acknowledgments of receiving specific earlier packets.</p></li><li class="listitem"><p><span class="strong"><strong>The PSH (push) bit</strong></span> is set when the side transmitting data wants the client's network stack to immediately shove this data up the protocol stack. This bit requests that the client flush all hardware and kernel buffers and hand all data to the client.<a class="indexterm" id="IDX-CHP-3-0072"/></p></li><li class="listitem"><p><span class="strong"><strong>The URG (urgent) bit</strong></span> indicates that the URGENT pointer field contains data that needs to be interpreted. In everyday language, this means that this packet contains the glue that the receiver needs if it is to correctly process other packets in the flow.<a class="indexterm" id="IDX-CHP-3-0073"/><a class="indexterm" id="IDX-CHP-3-0074"/></p></li><li class="listitem"><p><span class="strong"><strong>RST (reset)</strong></span> immediately terminates the connection.</p></li><li class="listitem"><p>Finally, the <span class="strong"><strong>FIN (finish) bit</strong></span> announces that this host will send no more data, but it will continue to listen for data from the other end. A FIN signals that it's time to tear down the connection.<a class="indexterm" id="IDX-CHP-3-0075"/></p></li></ul></div><p>Each control bit is expressed as a hexadecimal number, as shown in <a class="xref" href="ch03s03.html#tcp_control_bit_hexadecimal_values" title="Table 3-3. TCP Control Bit Hexadecimal Values">Table 3-3</a>.</p><div class="table"><a id="tcp_control_bit_hexadecimal_values"/><p class="title">Table 3-3. TCP Control Bit Hexadecimal Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="TCP Control Bit Hexadecimal Values"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Flag</p></th><th style="text-align: left" valign="bottom"><p>Hexadecimal</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>FIN</p></td><td style="text-align: left" valign="top"><p>0x01</p></td></tr><tr><td style="text-align: left" valign="top"><p>SYN</p></td><td style="text-align: left" valign="top"><p>0x02</p></td></tr><tr><td style="text-align: left" valign="top"><p>RST</p></td><td style="text-align: left" valign="top"><p>0x04</p></td></tr><tr><td style="text-align: left" valign="top"><p>PSH</p></td><td style="text-align: left" valign="top"><p>0x08</p></td></tr><tr><td style="text-align: left" valign="top"><p>ACK</p></td><td style="text-align: left" valign="top"><p>0x10</p></td></tr><tr><td style="text-align: left" valign="top"><p>URG</p></td><td style="text-align: left" valign="top"><p>0x20</p></td></tr></tbody></table></div></div><p>Many people find this easier to understand as a diagram, such as <a class="xref" href="ch03s03.html#tcp_control_bits" title="Figure 3-1. TCP control bits">Figure 3-1</a>.</p><div class="figure"><a id="tcp_control_bits"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e3860"/><img alt="TCP control bits" src="httpatomoreillycomsourcenostarchimages651580.png.jpg"/></div></div><p class="title">Figure 3-1. TCP control bits</p></div><p>Any combination of control bits in a packet can be represented as a unique number. If a control bit is set, add that flag's number to the packet's total control bit number. If you say that a packet's control bits are set to 18, that indicates a precise set of control bits. Only one possible combination of control bits adds up to 18. (Go ahead, try it. I'll wait.)</p><p>For example, <a class="xref" href="ch03s03.html#tcp_control_bits_in_a_syn_solidus_ack_pa" title="Figure 3-2. TCP control bits in a SYN/ACK packet">Figure 3-2</a> shows how you would represent a typical SYN/ACK packet.</p><div class="figure"><a id="tcp_control_bits_in_a_syn_solidus_ack_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e3874"/><img alt="TCP control bits in a SYN/ACK packet" src="httpatomoreillycomsourcenostarchimages651582.png.jpg"/></div></div><p class="title">Figure 3-2. TCP control bits in a SYN/ACK packet</p></div><p>As you can see in <a class="xref" href="ch03s03.html#tcp_control_bits_in_a_syn_solidus_ack_pa" title="Figure 3-2. TCP control bits in a SYN/ACK packet">Figure 3-2</a>, this packet has the control bits SYN (0x2) and ACK (0x10) marked, and all other control bits are unmarked. Go ahead and add 0x2 and 0x10. Hexadecimal 10 plus hexadecimal 2 is hexadecimal 12; my calculator tells me that hexadecimal 12 is decimal 18.</p><p>The only way to get a packet with a control bits value of 18 is if SYN and ACK, and only these two control bits, are selected.<a class="indexterm" id="IDX-CHP-3-0076"/><a class="indexterm" id="IDX-CHP-3-0077"/><a class="indexterm" id="IDX-CHP-3-0078"/><a class="indexterm" id="IDX-CHP-3-0079"/><a class="indexterm" id="IDX-CHP-3-0080"/><a class="indexterm" id="IDX-CHP-3-0081"/></p><p>Flows don't track individual packets, so how can flow records sensibly track TCP control bits? The flow sensor tracks all control bits that appear in a single flow. For example, when a host that initiates a connection sends a SYN and an ACK during the connection, you'd reasonably expect to also see, say, a PSH and a FIN. When any of these flags appear in a flow, the flow sensor notes their appearance. <a class="xref" href="ch03s03.html#tcp_control_bits_in_a_flow_with_syn_comm" title="Figure 3-3. TCP control bits in a flow with SYN, ACK, PSH, and FIN">Figure 3-3</a> shows how this would look in a bitmap.</p><div class="figure"><a id="tcp_control_bits_in_a_flow_with_syn_comm"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e3913"/><img alt="TCP control bits in a flow with SYN, ACK, PSH, and FIN" src="httpatomoreillycomsourcenostarchimages651584.png.jpg"/></div></div><p class="title">Figure 3-3. TCP control bits in a flow with SYN, ACK, PSH, and FIN</p></div><p>So, we have 0x1 + 0x2 + 0x8 + 0x10 = 0x1b, or decimal 27.</p><p>Look back at the first view of TCP flags earlier this chapter (in <a class="xref" href="ch03s02.html#two_lines_with_times_comma_flags_comma" title="Two Lines with Times, Flags, and Hex Ports Using -f 1">Two Lines with Times, Flags, and Hex Ports Using -f 1</a> in <a class="xref" href="ch03s02.html#two_lines_with_times_comma_flags_comma" title="Two Lines with Times, Flags, and Hex Ports Using -f 1">Two Lines with Times, Flags, and Hex Ports Using -f 1</a>). The <code class="literal">Flags</code> field of the third and fourth sample flows equals <code class="literal">1b</code>, which tells you that this flow included all the TCP flags required for a normal connection (SYN, ACK, and FIN). It also tells you that this flow included a flag perfectly acceptable in a normal connection (PSH) and that it didn't include the flag that would indicate a problem (RST). This connection almost certainly worked. In <a class="xref" href="ch04.html" title="Chapter 4. FILTERING FLOWS">Chapter 4</a> you'll search for flows that have combinations of control bits that indicate problems (<a class="xref" href="ch04s02.html#tcp_control_bit_primitives" title="TCP Control Bit Primitives">TCP Control Bit Primitives</a> in <a class="xref" href="ch04s02.html#tcp_control_bit_primitives" title="TCP Control Bit Primitives">TCP Control Bit Primitives</a>).</p><div class="sidebar"><a id="converting_hex_to_decimal_and_binary"/><p class="title">CONVERTING HEX TO DECIMAL AND BINARY</p><p>The Calculator program in Windows can convert between the three bases. Open the Calculator, and select <span class="strong"><strong>View ▸ Scientific</strong></span>. You'll see buttons for Hex(adecimal), Dec(imal), Oct(al), and Bin(ary). Select the base you want to convert from. Type in the number in that base. Select the base you want to convert to, and the Calculator will convert for you. You can also use the Calculator if you don't do hexadecimal math often enough to learn it. Most Unix-like desktop environments also include a hexadecimal/decimal calculator.</p></div></div>
<div class="sect1" title="ICMP Types and Codes and Flow Records"><div class="titlepage"><div><div><h1 class="title"><a id="icmp_types_and_codes_and_flow_records"/>ICMP Types and Codes and Flow Records</h1></div></div></div><p>Flow records also record ICMP types and codes, displaying them as destination port numbers. I'll review ICMP types and codes first and then discuss how flow records portray them.</p><div class="sect2" title="Types and Codes in ICMP"><div class="titlepage"><div><div><h2 class="title"><a id="types_and_codes_in_icmp"/>Types and Codes in ICMP</h2></div></div></div><p>Many people mentally pour the different ICMP requests into one large bucket and get by on generalizations such as "ICMP is ping." Although this might be fine for average users, you're not an average user, and you need a deeper understanding of ICMP to manage a network.<a class="indexterm" id="IDX-CHP-3-0082"/></p><p>An ICMP <span class="emphasis"><em>type</em></span> is a general class of ICMP request, such as ping requests and ping replies. Other ICMP types include messages such as "host unreachable," routing advertisements, traceroute requests, routing redirects, and so on. Some ICMP types prompt a response from the recipient, while others are received without comment.</p><p>Some ICMP types also include an ICMP <span class="emphasis"><em>code</em></span> that allows an ICMP message to provide a more specific response. The meaning of each ICMP code varies with the message's ICMP type. For example, although ICMP types 3, 5, and 11 all offer an ICMP code of 1, that code has a completely different meaning with each type.</p><p>The Internet Assigned Numbers Authority (IANA) assigns ICMP types and codes and maintains a list of current assignments at <a class="ulink" href="http://www.iana.org/assignments/icmp-parameters/">http://www.iana.org/assignments/icmp-parameters/</a>. These assignments rarely change, so <a class="xref" href="ch03s04.html#common_icmp_types_and_associated_codes_i" title="Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal">Table 3-4</a> offers the most commonly seen ICMP types and codes. Although an explanation of the meanings of different ICMP messages is best left for a book on TCP/IP (such as <span class="emphasis"><em>The TCP/IP Guide</em></span>, mentioned earlier), this table provides an easy reference.<a class="indexterm" id="IDX-CHP-3-0083"/><a class="indexterm" id="IDX-CHP-3-0084"/></p><div class="table"><a id="common_icmp_types_and_associated_codes_i"/><p class="title">Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common ICMP Types and Associated Codes in Decimal and Hexadecimal"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Type</p></th><th style="text-align: left" valign="bottom"><p>Code</p></th><th style="text-align: left" valign="bottom"><p>Decimal</p></th><th style="text-align: left" valign="bottom"><p>Definition</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>Echo Reply</p></td></tr><tr><td style="text-align: left" valign="top"><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>Destination Unreachable</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>300</p></td><td style="text-align: left" valign="top"><p>Network Unreachable</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>301</p></td><td style="text-align: left" valign="top"><p>Host Unreachable</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>2</p></td><td style="text-align: left" valign="top"><p>302</p></td><td style="text-align: left" valign="top"><p>Protocol Unreachable</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>3</p></td><td style="text-align: left" valign="top"><p>303</p></td><td style="text-align: left" valign="top"><p>Port Unreachable</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>4</p></td><td style="text-align: left" valign="top"><p>304</p></td><td style="text-align: left" valign="top"><p>Fragmentation Needed, but Don't Fragment was Set</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>6</p></td><td style="text-align: left" valign="top"><p>306</p></td><td style="text-align: left" valign="top"><p>Destination Network Unknown</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>7</p></td><td style="text-align: left" valign="top"><p>307</p></td><td style="text-align: left" valign="top"><p>Destination Host Unknown</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>9</p></td><td style="text-align: left" valign="top"><p>309</p></td><td style="text-align: left" valign="top"><p>Communication with Destination Network Administratively Prohibited</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>10(a)</p></td><td style="text-align: left" valign="top"><p>310</p></td><td style="text-align: left" valign="top"><p>Communication with Destination Host Administratively Prohibited</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>13(d)</p></td><td style="text-align: left" valign="top"><p>313</p></td><td style="text-align: left" valign="top"><p>Communication Administratively Prohibited</p></td></tr><tr><td style="text-align: left" valign="top"><p>5<a class="indexterm" id="IDX-CHP-3-0085"/><a class="indexterm" id="IDX-CHP-3-0086"/><a class="indexterm" id="IDX-CHP-3-0087"/><a class="indexterm" id="IDX-CHP-3-0088"/></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>Redirect</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>500</p></td><td style="text-align: left" valign="top"><p>Redirect for Subnet</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>501</p></td><td style="text-align: left" valign="top"><p>Redirect for Host</p></td></tr><tr><td style="text-align: left" valign="top"><p>8</p></td><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>800</p></td><td style="text-align: left" valign="top"><p>Echo Request</p></td></tr><tr><td style="text-align: left" valign="top"><p>11(b)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>Time Exceeded</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>2816</p></td><td style="text-align: left" valign="top"><p>Time to Live exceeded in Transit</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>2817</p></td><td style="text-align: left" valign="top"><p>Fragment Reassembly Time Exceeded</p></td></tr><tr><td style="text-align: left" valign="top"><p>12(c)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>3072</p></td><td style="text-align: left" valign="top"><p>Parameter Problem</p></td></tr><tr><td style="text-align: left" valign="top"><p>13(d)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>3328</p></td><td style="text-align: left" valign="top"><p>Timestamp Request</p></td></tr><tr><td style="text-align: left" valign="top"><p>14(e)</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>3584</p></td><td style="text-align: left" valign="top"><p>Timestamp Reply</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Flows and ICMP Details"><div class="titlepage"><div><div><h2 class="title"><a id="flows_and_icmp_details"/>Flows and ICMP Details</h2></div></div></div><p>Flow sensors encode the ICMP type and code in the flow's destination port. Destination (and source) ports are two bytes. The first byte of the port gives the type, and the second byte gives the code. Because ICMP has no concept of an originating port, the source port is always zero. In the following example, I've selected a few ICMP flows out of my test data.</p><p>This example uses a print format that displays destination ports in hexadecimal. You can use a format that displays ports in decimal, but you must convert the destination port from decimal to hex to interpret it.</p><a id="I_programlisting3_d1e4274"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft* | flow-print -f 0 | less</code></strong>
Sif  SrcIPaddress     Dif  DstIPaddress      Pr SrcP DstP  Pkts       Octets
0000 80.95.220.173    0000 36.85.32.153      01 0    ❶800   2          122
0000 189.163.178.51   0000 36.85.32.130      01 0    ❷b00   1          56
0000 64.142.0.205     0000 36.85.32.5        01 0    ❸300   1          56
0000 201.144.13.170   0000 36.85.32.130      01 0    ❹303   1          144
0000 36.85.32.9       0000 194.125.246.213   01 0    ❺0     5          420
...</pre><p>The first flow comes from the address 80.95.220.173 to 36.85.32.153 and has a destination port of hexadecimal 800 (❶). Although <code class="literal">flow-print</code> doesn't print leading zeros, you could think of this as 0800, just as you could think of port 25 as port 025. In this example, the ICMP type is 8, and the code is 00. ICMP type 8 has no associated codes, so <code class="literal">flow-print</code> gives the ICMP code as 00.</p><p>A look at <a class="xref" href="ch03s04.html#common_icmp_types_and_associated_codes_i" title="Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal">Table 3-4</a> tells you that ICMP type 8 is an echo request, also known as a <span class="emphasis"><em>ping attempt</em></span>. The host 80.95.220.173 is trying to ping 36.85.32.153.</p><p>The second ICMP flow has a destination port of b00 (❷), or an ICMP type of b and an ICMP code of 00. ICMP type b is "time exceeded." Unlike ICMP type 8, this ICMP type has codes with it. Code 0 means "time to live exceeded in transit." In this case, the IP 189.163.178.51 is informing the IP 36.85.32.130 that it's taking too long to reach a particular address, which usually means that a client has been disconnected.</p><p>The third flow, from 64.142.0.205 to 36.85.32.5, has a destination port of 300 (❸). ICMP type 3 messages indicate that a destination is unreachable. ICMP type 3's code 0 means "network unreachable." In this case, host 36.85.32.5 attempted to reach another host, and a router on the Internet is returning a message indicating that the target network is not reachable.<a class="indexterm" id="IDX-CHP-3-0089"/><a class="indexterm" id="IDX-CHP-3-0090"/><a class="indexterm" id="IDX-CHP-3-0091"/></p><p>The fourth flow has a destination port of 303 (❹). ICMP type 3 indicates that a destination is unreachable, but code 03 means "port unreachable." When a client sends a UDP request to a server port that isn't open, the server returns this ICMP message. If you were to search these flow records, you would find a UDP request going in the other direction between these two hosts.</p><p>Our fifth flow has a destination port of 0 (❺). ICMP type 0 is an echo reply, or a response to a ping. If you search these flows, you'll find an echo request going in the other direction.</p><p>As you can see, ICMP messages are frequently responses to other types of network requests. They often show exactly what type of error occurred as a result of an attempted connection. Matching these messages to other flows frequently requires searching the flow records, which is best accomplished by filtering, as you'll see in <a class="xref" href="ch04.html" title="Chapter 4. FILTERING FLOWS">Chapter 4</a>.</p></div></div></body></html>