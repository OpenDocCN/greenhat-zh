<html><head></head><body><div class="part" title="Part&#xA0;II-5.&#xA0;IP-RELATED FEATURE PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="ip-related_feature_protocols"/>Part II-5. IP-RELATED FEATURE PROTOCOLS</h1></div></div></div><div class="partintro" id="id3236806" title="IP-RELATED FEATURE PROTOCOLS"><div/><p><a class="xref" href="ch28.html" title="Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL">Chapter 28</a></p><p><a class="xref" href="ch29.html" title="Chapter 29. IP SECURITY (IPSEC) PROTOCOLS">Chapter 29</a></p><p><a class="xref" href="ch30.html" title="Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)">Chapter 30</a></p><p>The previous two parts thoroughly explored versions 4 and 6 of the Internet Protocol (IP). IP is a very capable protocol that provides the functionality necessary to address, package, and deliver information on TCP/IP internetworks. However, IP was intentionally designed to be simple, without a lot of bells and whistles. To deal with special needs, a number of other protocols have been created to enhance or expand on IP's capabilities. I call these <span class="emphasis"><em>IP-related feature protocols</em></span>.</p><p>This part contains three chapters that provide complete explanations of three of the more important IP-related feature protocols. The first chapter describes <span class="emphasis"><em>IP Network Address Translation (IP NAT or NAT)</em></span>, which allows private networks to be accessed on the Internet and IP addresses to be shared. The second chapter explores <span class="emphasis"><em>IP Security (IPsec)</em></span>, a set of subprotocols that allows IP datagrams to be authenticated and/or encrypted. The third chapter covers the <span class="emphasis"><em>Mobile IP</em></span> protocol, which corrects some of the problems associated with using TCP/IP with mobile hosts.</p><p>This part assumes that you have a good understanding of the operation of IP, discussed in Parts II-3 and II-4.</p></div></div>
<div class="chapter" title="Chapter&#xA0;28.&#xA0;IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL"><div class="titlepage"><div><div><h1 class="title"><a id="ip_network_address_translation_nat_proto"/>Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e28326"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> To help extend the life of the Internet Protocol version 4 (IPv4) addressing scheme while the newer IPv6 protocol is developed and deployed, other technologies have been developed. One of the most important of these is <span class="emphasis"><em>IP Network Address Translation (NAT)</em></span>. This technology allows a small number of public IP addresses to be shared by a large number of hosts using private addresses. This essential work-around allows the global Internet to actually have far more hosts on it than its address space would normally support. At the same time, it provides some security benefits by making hosts more difficult to address directly by foreign machines on the public Internet.</p><p>In this chapter, I provide a description of the concepts behind IP NAT and an explanation of operation of IP NAT types. I begin with an overview of the protocol and discussion of its advantages and disadvantages. I describe the address terminology that you need to know in order to understand how NAT functions and the differences between various translation techniques. I explain the way that address mappings are performed and the difference between static and dynamic address mapping.</p><p>I then explain the operation of the four main types of NAT: unidirectional, bidirectional, port-based, and overlapping. I conclude with a bit more information on compatibility issues associated with NAT.</p><p>NAT was developed in large part to deal with the address shortage problem in IPv4, so it is associated and used with IPv4. It is possible to implement an IPv6-compatible version of NAT, but address translation isn't nearly as important in IPv6, which was designed to give every TCP/IP device its own unique address. For this reason, in this chapter, I focus in on the use of NAT with IPv4.</p><div class="note" title="Note"><h3 class="title"><a id="note-90"/>Note</h3><p><span class="emphasis"><em>Incidentally, most people just call this technology</em></span> Network Address Translation <span class="emphasis"><em>without the</em></span> IP. <span class="emphasis"><em>However, this sounds to me rather generic, and since the version I'm discussing here is specific to IP, I prefer to make it clear that this is an IP feature. That said, for simplicity I often just say "NAT," too, since that's shorter. I should also point out that there are quite a few people who don't consider NAT to be a protocol in the strictest sense of the word</em></span>.</p></div><div class="sect1" title="IP NAT Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_overview"/>IP NAT Overview</h1></div></div></div><p><a class="indexterm" id="idx-CHP-28-0964"/>The decision to make IP addresses only 32 bits long as part of the original design of IP led to a serious problem when the Internet exploded in popularity beyond anyone's expectations: the exhaustion of the address space. Classless addressing helped make better use of the address space, and IPv6 was created to ensure that we will never run out of addresses again. However, classless addressing has only slowed the consumption of the IPv4 address space, and IPv6 has taken years to develop and will require years more to deploy.</p><p>The shortage of IP addresses promised to grow critical by the end of the 1990s unless some sort of solution was implemented until the transition to IPv6 was completed. Creative engineers on the Internet Engineering Task Force (IETF) were up to the challenge. They created a technique that would not only forestall the depletion of the address space, but could also be used to address the following two other growing issues in the mid- to late 1990s:</p><p><span class="strong"><strong>Increasing Cost of IP Addresses</strong></span> As any resource grows scarce, it becomes more expensive. Even when IP addresses were available, it cost more to get a larger number from a service provider than a smaller number. It was desirable to conserve them not only for the sake of the Internet as a whole, but to save money.</p><p><span class="strong"><strong>Growing Concerns over Security</strong></span> As Internet use increased in the 1990s, more bad guys started using the network also. The more machines a company had directly connected to the Internet, the greater their potential exposure to security risks.</p><p>One solution to these problems was to set up a system whereby a company's network was not connected directly to the Internet, but rather <span class="emphasis"><em>indirectly</em></span>. Setting up a network this way is possible due to the following important characteristics of how most organizations use the Internet:</p><p><span class="strong"><strong>Most Hosts Are Client Devices</strong></span> The Internet is client/server based, and the majority of hosts are clients. Client devices generally don't need to be made publicly accessible. For example, when using your local PC to access the World Wide Web, you issue requests to servers and they respond back, but servers don't have any reason to try to initiate contact with you. Clients, not servers, begin most correspondence, by definition.</p><p><span class="strong"><strong>Few Hosts Access the Internet Simultaneously</strong></span> When you have a large number of hosts that are connected to the Internet on the same network, usually only a small number of those hosts are trying to access the Internet at any given time. It isn't necessary to assume they will all need to access servers at once. Even while you actively browse the Web, you pause for a number of seconds to read information from time to time; you are only accessing the web server for the time it takes to perform a transaction.</p><p><span class="strong"><strong>Internet Communications Are Routed</strong></span> Communications between an organization's network and the Internet go through a router, which acts as a control point for traffic flows.</p><p>The best way to explain why these attributes matter is to draw an analogy to how telephones are used an organization, because many of the same attributes apply there. Most of the telephones in a typical organization are used to let employees make calls out. Usually there is no need to have any way to call employees directly; instead, one system or person can handle all incoming calls. Only a few employees are ever making a call to the outside world at any given time. And all calls are routed through a central point that manages the telephone system.</p><p>For these reasons, to save money, organizations don't run separate public telephone lines to every employee's desk. Instead, they set up a telephone system whereby each employee gets an <span class="emphasis"><em>extension</em></span>, which is basically a local telephone number valid only within the organization. A small number of outside lines is made available in a pool for employees to share, and the telephone system matches the inside extensions to the outside lines as needed. A voice mail system and human receptionist handle the routing of calls into the organization. (Yes, of course some companies have a direct mapping between extension numbers and real telephone numbers.)</p><p>A very similar technique can be used for connecting an organization's computers to the Internet. In TCP/IP networks, this technology was first formalized in RFC 1631, "The IP Network Address Translator (NAT)," which was adopted in May 1994. The word <span class="emphasis"><em>translator</em></span> refers to the device (router) that implements NAT. More commonly, the technology as a whole is called <span class="emphasis"><em>IP Network Address Translation</em></span> (<span class="emphasis"><em>IP NAT</em></span> or <span class="emphasis"><em>NAT</em></span>).</p><div class="note" title="Note"><h3 class="title"><a id="note-91"/>Note</h3><p><span class="emphasis"><em>The document status of RFC 1631 is informational. This means that, technically, IP NAT is not an official Internet standard</em></span>.</p></div><p>A basic implementation of NAT involves setting up an organization's internal network using one of the private addressing ranges set aside for local IP networks. One or more public (Internet) addresses are also assigned to the organization as well, and one or more NAT-capable routers are installed between the local network and the public Internet. The public IP addresses are like outside lines in the telephone system, and the private addresses are like internal extensions.</p><p>The NAT router plays the role of telephone system computer and receptionist. It maps internal extensions to outside lines as needed, and also handles "incoming calls" when required. It does this by not just routing IP datagrams, but also by modifying them as needed, thereby translating addresses in datagrams from the private network into public addresses for transmission on the Internet, and back again.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-148"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>IP Network Address Translation</em></span> (<span class="emphasis"><em>IP NAT</em></span> or <span class="emphasis"><em>NAT</em></span>) is a technique that allows an organization to set up a network using private addresses, while still allowing for communication on the public Internet. A NAT-capable router translates private to public addresses and vice versa as needed. This allows a small number of public IP addresses to be shared among a large number of devices and provides other benefits as well, but it also has some drawbacks.</p></div><p>Over time, newer versions of NAT have also been created. They solve other problems or provide additional capabilities. <span class="emphasis"><em>Port-Based NAT</em></span> allows for the sharing of even more hosts on a limited number of IP addresses by letting two or more devices share one IP address at a time. So-called <span class="emphasis"><em>twice NAT</em></span> helps with the implementation of virtual private networks (VPNs) by translating both source and destination addresses in both incoming and outgoing datagrams.</p><div class="sect2" title="Advantages of IP NAT"><div class="titlepage"><div><div><h2 class="title"><a id="advantages_of_ip_nat_t"/>Advantages of IP NAT</h2></div></div></div><p><a class="indexterm" id="idx-CHP-28-0965"/>NAT is one of those technologies that has a long list of advantages and disadvantages. This means it can be extremely useful in a variety of scenarios, but also problematic in others. The main advantages are as follows:</p><p><span class="strong"><strong>Public IP Address Sharing</strong></span> A large number of hosts can share a small number of public IP addresses. This saves money and also conserves IP address space.</p><p><span class="strong"><strong>Easier Expansion</strong></span> Since local network devices are privately addressed and a public IP address isn't needed for each one, it is easy to add new clients to the local network.</p><p><span class="strong"><strong>Greater Local Control</strong></span> Administrators get all the benefits of control that come with a private network, but can still connect to the Internet.</p><p><span class="strong"><strong>Greater Flexibility in Internet Service Provider (ISP) Service</strong></span> Changing the organization's ISP is easier, because only the public addresses change. It isn't necessary to renumber all the client machines on the network.</p><p><span class="strong"><strong>Increased Security</strong></span> The NAT translation represents a level of indirection. Thus, it automatically creates a type of firewall between the organization's network and the public Internet. It is more difficult for any client devices to be accessed directly by someone malicious because the clients don't have publicly known IP addresses.</p><p><span class="strong"><strong>(Mostly) Transparent</strong></span> NAT implementation is mostly transparent, because the changes take place in one or perhaps a few routers. The dozens or hundreds of hosts themselves don't need to be changed.</p></div><div class="sect2" title="Disadvantages of IP NAT"><div class="titlepage"><div><div><h2 class="title"><a id="disadvantages_of_ip_nat"/>Disadvantages of IP NAT</h2></div></div></div><p>The previously listed advantages are all good reasons to use NAT, but there are drawbacks to the technique as well:</p><p><span class="strong"><strong>Complexity</strong></span> NAT represents one more complexity in terms of setting up and managing the network. It also makes troubleshooting more confusing due to address substitutions.</p><p><span class="strong"><strong>Problems Due to Lack of Public Addresses</strong></span> Certain functions won't work properly due to lack of a real IP address in the client host machines.</p><p><span class="strong"><strong>Compatibility Problems with Certain Applications</strong></span> I said earlier that NAT was only mostly transparent. There are, in fact, <a class="indexterm" id="idx-CHP-28-0966"/>compatibility issues with certain applications that arise because NAT tinkers with the IP header fields in datagrams but not in the application data. This means tools like the File Transfer Protocol (FTP; see <a class="xref" href="ch72.html" title="Chapter 72. FILE TRANSFER PROTOCOL (FTP)">Chapter 72</a>), which pass IP addresses and port numbers in commands, must be specially handled, and some applications may not work.</p><p><span class="strong"><strong>Problems with Security Protocols</strong></span> Protocols like IPsec are designed to detect modifications to headers and commonly balk at the changes that NAT makes, since they cannot differentiate those changes from malicious datagram hacking. It is still possible to combine NAT and IPsec, but this becomes more complicated.</p><p><span class="strong"><strong>Poor Support for Client Access</strong></span> The lack of a public IP address for each client is a double-edged sword; it protects against hackers trying to access a host, but it also makes it difficult for legitimate access to clients on the local network. Peer-to-peer applications are harder to set up, and something like an organizational website (accessed from the Internet as a whole) usually needs to be set up without NAT.</p><p><span class="strong"><strong>Performance Reduction</strong></span> Each time a datagram transitions between the private network and the Internet, an address translation is required. In addition, other work must be done as well, such as recalculating header checksums. Each individual translation takes little effort, but when you add it up, you are giving up some performance.</p><p>Some of these cancel out some of the benefits of certain items in the previous list. However, many organizations feel that the advantages outweigh the <a class="indexterm" id="idx-CHP-28-0967"/>disadvantages, especially if they use the Internet in primarily a client/server fashion, as most do. For this reason, NAT has become quite popular. However, bear in mind that the main problem that led to NAT is lack of address space. IPv6 fixes this problem, while NAT merely finds a clever work-around for it. For this reason, many people consider NAT a <a class="indexterm" id="idx-CHP-28-0968"/>kludge. Once IPv6 is deployed, it will no longer be needed, and some folks don't like it even for IPv4. On the other hand, some feel its other benefits make it worthy of consideration even in IPv6.</p><div class="note" title="Note"><h3 class="title"><a id="note-92"/>Note</h3><p><span class="emphasis"><em>A</em></span> kludge (<span class="emphasis"><em>or</em></span> kluge) <span class="emphasis"><em>is something that is used to address a problem in an inelegant way, like hammering a nail using the side of an adjustable wrench</em></span>.</p></div></div></div></div>
<div class="sect1" title="IP NAT Address Terminology"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_address_terminology"/>IP NAT Address Terminology</h1></div></div></div><p>As its name clearly indicates, IP NAT is all about the <span class="emphasis"><em>translation</em></span> of IP <a class="indexterm" id="idx-CHP-28-0969"/>addresses. When datagrams pass between the private network of an organization and the public Internet, the NAT router changes one or more of the addresses in these datagrams. This translation means that every transaction in a NAT environment involves not just a source address and a destination address, but also potentially multiple addresses for each of the source and destination.</p><p>In order to make clearer the explanation of how NAT operates, several special designations have been developed to refer to the different types of addresses that can be found in an IP datagram when NAT is used. Unfortunately, the terminology used for addressing in NAT can be confusing, because it's hard to visualize what the differences are between the (often similar-sounding) names. However, without knowing what these addresses mean, a proper understanding of NAT operation is impossible.</p><p>The first way that addresses are differentiated is based on where the device is in the network that the address is referring to, as follows:</p><p><span class="strong"><strong>Inside Address</strong></span> Any device on the organization's private network that is using NAT is said to be on the inside network. Thus, any address that refers to a device on the local network in any form is called an <span class="emphasis"><em>inside address</em></span>.</p><p><span class="strong"><strong>Outside Address</strong></span> The public Internet—that is, everything outside the local network—is considered the outside network. Any address that refers to a public Internet device is an <span class="emphasis"><em>outside address</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-149"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In NAT, the terms <span class="emphasis"><em>inside</em></span> and <span class="emphasis"><em>outside</em></span> are used to identify the location of devices. <span class="emphasis"><em>Inside addresses</em></span> refer to devices on the organization's private network. <span class="emphasis"><em>Outside addresses</em></span> refer to devices on the public Internet.</p></div><p>An inside device always has an inside address; an outside device always has an outside address. However, there are two different ways of addressing either an inside or an outside device, depending on the part of the network in which the address appears in a datagram:</p><p><span class="strong"><strong>Local Address</strong></span> This term describes an address that appears in a datagram on the inside network, <span class="emphasis"><em>whether it refers to an inside or outside address</em></span>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-28-0970"/>Global Address</strong></span> This term describes an address that appears in a datagram on the outside network, again <span class="emphasis"><em>whether it refers to an inside or outside address</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-150"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In NAT, the terms <span class="emphasis"><em>local</em></span> and <span class="emphasis"><em>global</em></span> are used to indicate in what network a particular address appears. <span class="emphasis"><em>Local addresses</em></span> are used on the organization's private network (whether to refer to an inside device or an outside device). <span class="emphasis"><em>Global addresses</em></span> are used on the public Internet (again, whether referring to an inside or outside device).</p></div><p>This is a bit confusing, so I will try to explain further. The NAT translating router has the job of interfacing the inside network to the outside network (the Internet). Inside devices need to be able to talk to outside devices and vice versa, but inside devices can use only addressing consistent with the local network-addressing scheme. Similarly, outside devices cannot use local addressing. Thus, both inside and outside devices can be referred to with local or global address versions. This yields four different specific address types:</p><p><span class="strong"><strong>Inside Local Address</strong></span> An address of a device on the local network, expressed using its normal local device representation. So, for example, if you had a client on a network using the 10.0.0.0 private address block and assigned it address 10.0.0.207, this would be its <span class="emphasis"><em>inside local</em></span> address.</p><p><span class="strong"><strong>Inside Global Address</strong></span> This is a global, publicly routable IP address that's used to represent an inside device to the outside world. In a NAT configuration, <span class="emphasis"><em>inside global</em></span> addresses are those real IP addresses assigned to an organization for use by the NAT router. Let's say that device 10.0.0.207 wants to send an HTTP request to an Internet server located at address 204.51.16.12. It forms the datagram using 10.0.0.207 as the source address. However, if this datagram is sent out to the Internet as is, the server cannot reply back because 10.0.0.207 is not a publicly routable IP address. So the NAT router will translate 10.0.0.207 in the datagram into one of the organization's registered IP addresses, let's say, 194.54.21.10. This is the <span class="emphasis"><em>inside global</em></span> address that corresponds to 10.0.0.207. It will be used as the destination when the server sends its HTTP response. Note that, in some situations, the inside local address and outside local address may be the same.</p><p><span class="strong"><strong>Outside Global Address</strong></span> An address of an external (public Internet) device as it is referred to on the global Internet. This is basically a regular, publicly registered address of a device on the Internet. In the previous example, 204.51.16.12 is an <span class="emphasis"><em>outside global</em></span> address of a public server.</p><p><span class="strong"><strong>Outside Local Address</strong></span> An address of an external device as it is referred to by devices on the local network. In some situations, this may be identical to the <span class="emphasis"><em>outside global</em></span> address of that outside device.</p><p>Phew, it's still confusing, isn't it? Let's try another way of looking at this. Of these four addresses, two types are the addresses as they are known natively by either an inside or outside device, while the other two are translated addresses. Here is a summary:</p><p><span class="strong"><strong>Inside Device Designations</strong></span> For an inside device, the <span class="emphasis"><em>inside local</em></span> address is its normal, or native, address. The <span class="emphasis"><em>inside global</em></span> address is a translated address used to represent the inside device on the outside network, when necessary.</p><p><span class="strong"><strong>Outside Device Designations</strong></span> For an outside device, the <span class="emphasis"><em>outside global</em></span> address is its normal, or native, address. The <span class="emphasis"><em>outside local</em></span> address is a translated address used to represent the outside device on the inside network, when necessary.</p><p>So what NAT does then is translate the identity of either inside or outside devices from local representations to global representations and vice versa. Which <a class="indexterm" id="idx-CHP-28-0971"/>addresses are changed and how will depend on the specific type of NAT employed. For example, in traditional NAT, inside devices refer to outside devices using their proper (global) representation, so the outside global and outside local addresses of these outside devices are the same.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-151"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A NAT router translates <span class="emphasis"><em>local</em></span> addresses to <span class="emphasis"><em>global</em></span> ones and vice versa. Thus, an <span class="emphasis"><em>inside local</em></span> address is translated to an <span class="emphasis"><em>inside global</em></span> address (and vice versa) and an <span class="emphasis"><em>outside local</em></span> address is translated to an <span class="emphasis"><em>outside global</em></span> address (and vice versa).</p></div><p>And after all that, it's still confusing! One of the big problems is that the words <span class="emphasis"><em>inside</em></span> and <span class="emphasis"><em>local</em></span> are somewhat synonymous, as are <span class="emphasis"><em>outside</em></span> and <span class="emphasis"><em>global</em></span>, yet they mean different things in NAT. And the typical paradox in trying to explain networking concepts rears its ugly head here again: I wanted to define these addresses to make describing NAT operation easier, but find myself wanting to use an example of NAT operation to clarify how the addresses are used.</p><p>Even after writing this material I find these terms confusing, so I created <a class="xref" href="ch28s02.html#ip_network_address_translation_nat_termi" title="Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this diagram will help you to better understand the whole &quot;inside/outside/local/global&quot; thing.">Figure 28-1</a>, which shows this same terminology in graphical form and may be of some help. That diagram is also used as a template for the illustrations of each of the different types of NAT in the rest of this chapter. As you read about NAT operation, look back here if you want to double-check the meaning of address types. Don't get discouraged if it takes a couple of times to get the addresses straight.</p><div class="figure"><a id="ip_network_address_translation_nat_termi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e28727"/><img alt="IP Network Address Translation (NAT) terminology Hopefully this diagram will help you to better understand the whole &quot;inside/outside/local/global&quot; thing." src="httpatomoreillycomsourcenostarchimages287903.png.jpg"/></div></div><p class="title">Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this diagram will help you to better understand the whole "inside/outside/local/global" thing.</p></div></div>
<div class="sect1" title="IP NAT Static and Dynamic Address Mappings"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_static_and_dynamic_address_mappin"/>IP NAT Static and Dynamic Address Mappings</h1></div></div></div><p>NAT allows you to connect a private (inside) network to a public (outside) network such as the Internet by using an <a class="indexterm" id="idx-CHP-28-0972"/>address translation algorithm implemented in a router that connects the two. Each time a NAT router encounters an IP datagram that crosses the boundary between the two networks, it must translate addresses as appropriate. But how does it know what to translate and what to use for the translated address?</p><p>The NAT software in the router must maintain a <span class="emphasis"><em>translation table</em></span> to tell it how to operate. The translation table contains information that maps the <span class="emphasis"><em>inside local</em></span> addresses of internal devices (their regular addresses) to <span class="emphasis"><em>inside global</em></span> address representations (the special public addresses used for external communication). It may also contain <a class="indexterm" id="idx-CHP-28-0973"/>mappings between <span class="emphasis"><em>outside global</em></span> addresses and <span class="emphasis"><em>outside local</em></span> addresses for inbound transactions, if appropriate.</p><p>There are two basic ways that entries can be added to the NAT translation table: statically or dynamically.</p><div class="sect2" title="Static Mappings"><div class="titlepage"><div><div><h2 class="title"><a id="static_mappings"/>Static Mappings</h2></div></div></div><p><a class="indexterm" id="idx-CHP-28-0974"/>A static mapping represents a permanent, fixed relationship defined between a <span class="emphasis"><em>global</em></span> and a <span class="emphasis"><em>local</em></span> representation of the address of either an <span class="emphasis"><em>inside</em></span> or an <span class="emphasis"><em>outside</em></span> device. For example, you can use a static translation if you want the internal device with an <span class="emphasis"><em>inside local</em></span> address of 10.0.0.207 to <span class="emphasis"><em>always</em></span> use the <span class="emphasis"><em>inside global</em></span> address of 194.54.21.10. Whenever 10.0.0.027 initiates a transaction with the Internet, the NAT router will replace that address with 194.54.21.10.</p></div><div class="sect2" title="Dynamic Mappings"><div class="titlepage"><div><div><h2 class="title"><a id="dynamic_mappings"/>Dynamic Mappings</h2></div></div></div><p><a class="indexterm" id="idx-CHP-28-0975"/>With dynamic mapping, <span class="emphasis"><em>global</em></span> and <span class="emphasis"><em>local</em></span> address representations are generated automatically by the NAT router, which is used as needed and then discarded. The most common way that this is employed is in allowing a <span class="emphasis"><em>pool</em></span> of <span class="emphasis"><em>inside global</em></span> addresses to be shared by a large number of <span class="emphasis"><em>inside</em></span> devices.</p><p>For example, say you were using dynamic mapping with a pool of <span class="emphasis"><em>inside global</em></span> addresses available from 194.54.21.1 through 194.54.21.20. When 10.0.0.207 sent a request to the Internet, it would not automatically have its source address replaced by 194.54.21.10. One of the 20 addresses in the pool would be chosen by the NAT router. The router would then watch for replies back using that address and translate them back to 10.0.0.207. When the session was completed, it would discard the entry to return the <span class="emphasis"><em>inside global</em></span> address to the pool.</p></div><div class="sect2" title="Choosing Between Static and Dynamic Mapping"><div class="titlepage"><div><div><h2 class="title"><a id="choosing_between_static_and_dynamic_mapp"/>Choosing Between Static and Dynamic Mapping</h2></div></div></div><p>The trade-offs between static and dynamic NAT mappings are pretty much the same as they always are when the choice is between static and dynamic. For example, the same issues arises in Address Resolution Protocol (ARP) caching; see <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>.</p><p><a class="indexterm" id="idx-CHP-28-0976"/>Static mappings are permanent and therefore ideal for devices that need to be always represented with the same public address on the outside network. They may also be used to allow inbound traffic to a particular device; that is, they can be used for transactions initiated on the public network that send to a special server on the inside network. However, they require manual setup and maintenance, and they don't allow IP sharing on the internal network.</p><p>Dynamic mapping is normally used for regular clients in order to facilitate public IP address sharing—a prime goal of most NAT implementations. It is more complicated than static mapping, but once you set it up, it's automatic.</p><p>It is possible to mix dynamic and static mapping on the same system, of course. You can designate certain devices that are statically mapped and let the rest use dynamic mapping. You just have to make sure that the static mappings don't overlap with the pool used for dynamic assignment.</p><p>Incidentally, another way you can perform dynamic mapping of global and local addressing is through domain name resolution using the Domain Name System (DNS; see <a class="xref" href="ch52.html" title="Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS">Chapter 52</a>). This is particularly common when external devices access internal hosts using bidirectional NAT (inbound transactions). Since hosts on the public Internet know nothing about the organization's private network, they issue a request for the DNS name of the device they want to access. This causes the generation of a NAT translation entry that maps the inside local public address of the host to an inside global address for use by those outside the network. See the description of bidirectional NAT later in this chapter for more details on how this works.</p></div></div>
<div class="sect1" title="IP NAT Unidirectional (Traditional/Outbound) Operation"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_unidirectional_traditionaloutboun"/>IP NAT Unidirectional (Traditional/Outbound) Operation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-28-0977"/><a class="indexterm" id="idx-CHP-28-0978"/><a class="indexterm" id="idx-CHP-28-0979"/>Now it's time to get down to the nitty gritty of how it works. There are many different flavors of NAT, and four common ones are covered in this chapter. It makes sense to start by looking at the original variety of NAT described in RFC 1631. This is the simplest NAT method, and therefore the easiest one to explain.</p><p>NAT was designed to allow hosts on a private network to share public IP addresses in accessing an Internet. Since most hosts are clients that initiate transactions, NAT was designed under the assumption that a client/server request/response communication would begin with a datagram sent from the <span class="emphasis"><em>inside</em></span> network to the <span class="emphasis"><em>outside</em></span>. For this reason, this first type of NAT is sometimes called <a class="indexterm" id="idx-CHP-28-0980"/><span class="emphasis"><em>unidirectional</em></span> or <a class="indexterm" id="idx-CHP-28-0981"/><span class="emphasis"><em>outbound</em></span> NAT. Since it is the oldest flavor, it is also now called <a class="indexterm" id="idx-CHP-28-0982"/><span class="emphasis"><em>traditional</em></span> NAT to differentiate it from newer varieties.</p><p>To show how unidirectional NAT works, I will use an example. Let's assume the inside network has 250 hosts that use private (inside local) addresses from the 10.0.0.0/8 address range (which I selected because it has small numbers!). These hosts use dynamic NAT sharing a pool of 20 inside global addresses from 194.54.21.1 through 194.54.21.20.</p><p>In this example, device 10.0.0.207 wants to access the World Wide Web server at public address 204.51.16.12. <a class="xref" href="ch28s04.html#operation_of_unidirectional_traditional_" title="Table 28-1. Operation of Unidirectional (Traditional/Outbound) NAT">Table 28-1</a> shows the four basic steps that are involved in this (simplified) transaction. I did this in table form so I could show you explicitly what happens to the addresses in both the request datagram (in steps 1 and 2) and the response datagram (steps 3 and 4). I have also highlighted the translated address values for clarity, and provided <a class="xref" href="ch28s04.html#operation_of_unidirectional_tradit-id001" title="Figure 28-2. Operation of unidirectional (traditional/outbound) NAT You can see the four steps in this process by following the steps in clockwise order. Translated addresses are shown in bold. Refer to Table 28-1 and Figure 28-1 for an explanation of the four address types.">Figure 28-2</a>, which shows the process graphically.</p><div class="table"><a id="operation_of_unidirectional_traditional_"/><p class="title">Table 28-1. Operation of Unidirectional (Traditional/Outbound) NAT</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operation of Unidirectional (Traditional/Outbound) NAT"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step #</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Type</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Source Address</p></th><th style="border-bottom: 0.5pt solid ; "><p>Datagram Destination Address</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Inside Client Generates Request and Sends to NAT Router</strong></span>: Device 10.0.0.207 generates an HTTP request that is eventually passed down to IP and encapsulated in an IP datagram. The source address is itself, 10.0.0.207, and the destination is 204.51.16.12. The datagram is sent to the NAT-capable router that connects the organization's internal network to the Internet.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request (from inside client to outside server)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10.0.0.207 (inside local)</p></td><td style="border-bottom: 0.5pt solid ; "><p>204.51.16.12 (outside local)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Source Address and Sends to Outside Server</strong></span>: The NAT router realizes that 10.0.0.207 is an <span class="emphasis"><em>inside local</em></span> address and knows it must substitute an <span class="emphasis"><em>inside global</em></span> address in order to let the public Internet destination respond. It consults its pool of addresses and sees the next available one is 194.54.21.11. It changes the source address in the datagram from 10.0.0.207 to 194.54.21.11. The destination address is not translated in <a class="indexterm" id="idx-CHP-28-0983"/>traditional NAT. In other words, the <span class="emphasis"><em>outside local</em></span> address and <span class="emphasis"><em>outside global</em></span> address are the same.</p>
<p>The NAT router puts the mapping from 10.0.0.207 to 194.54.21.11 into its translation table. It sends out the modified datagram, which is eventually routed to the server at 204.51.16.12.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>194.54.21.11 (inside global)</p></td><td style="border-bottom: 0.5pt solid ; "><p>204.51.16.12 (outside global)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Outside Server Generates Response and Sends Back to NAT Router</strong></span>: The server at 204.51.16.12 generates an HTTP response. It has no idea that NAT was involved; it sees 194.54.21.11 in the request sent to it, so that's where it sends back the response. It is then routed back to the original client's NAT router.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response (from outside server to inside client)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>204.51.16.12 (outside global)</p></td><td style="border-bottom: 0.5pt solid ; "><p>194.54.21.11 (inside global)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Destination Address and Delivers Datagram to Inside Client</strong></span>: The NAT router sees 194.54.21.11 in the response that arrived from the Internet. It consults its translation table and knows this datagram is intended for 10.0.0.207. This time, the destination address is changed but not the source. It then delivers the datagram back to the originating client.</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>204.51.16.12 (outside local)</p></td><td style=""><p>10.0.0.207 (inside local)</p></td></tr></tbody></table></div></div><div class="figure"><a id="operation_of_unidirectional_tradit-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e29032"/><img alt="Operation of unidirectional (traditional/outbound) NAT You can see the four steps in this process by following the steps in clockwise order. Translated addresses are shown in bold. Refer to and for an explanation of the four address types." src="httpatomoreillycomsourcenostarchimages287905.png.jpg"/></div></div><p class="title">Figure 28-2. Operation of unidirectional (traditional/outbound) NAT You can see the four steps in this process by following the steps in clockwise order. Translated addresses are shown in bold. Refer to <a class="xref" href="ch28s04.html#operation_of_unidirectional_traditional_" title="Table 28-1. Operation of Unidirectional (Traditional/Outbound) NAT">Table 28-1</a> and <a class="xref" href="ch28s02.html#ip_network_address_translation_nat_termi" title="Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this diagram will help you to better understand the whole &quot;inside/outside/local/global&quot; thing.">Figure 28-1</a> for an explanation of the four address types.</p></div><p><a class="indexterm" id="idx-CHP-28-0984"/><a class="indexterm" id="idx-CHP-28-0985"/><a class="indexterm" id="idx-CHP-28-0986"/><a class="indexterm" id="idx-CHP-28-0987"/>As you can see, this really isn't rocket science, and it's fairly easy to understand what is going on as soon as you get used to the terminology and concepts. In <a class="indexterm" id="idx-CHP-28-0988"/>unidirectional NAT, the source address is translated on outgoing datagrams and the destination address is translated on incoming ones. <a class="indexterm" id="idx-CHP-28-0989"/>Traditional NAT supports only this sort of <a class="indexterm" id="idx-CHP-28-0990"/>outbound transaction, which is started by a device on the inside network. It cannot handle a device that sends a request to a private address on the public Internet.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-152"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In <a class="indexterm" id="idx-CHP-28-0991"/><span class="emphasis"><em>unidirectional</em></span> (<a class="indexterm" id="idx-CHP-28-0992"/>traditional) NAT, the NAT router translates the source address of an outgoing request from inside local to inside global form. It then transforms the destination address of the response from inside global to inside local. The outside local and outside global addresses are the same in both request and reply.</p></div><p>Also note that even though I am focusing on the changes that the NAT router makes to addresses, it also must make other changes to the datagram. Changing any field in the IP header means that the IP Header Checksum field will need to be recalculated. User Datagram Protocol (UDP) and Transmission Control Protocol (TCP) checksums need to be recalculated, and depending on the nature of the data in the datagram, other changes may also be required. I discuss these issues in the section on NAT compatibility issues, at the end of this chapter.</p><p>Incidentally, this simplified example assumes the existence of just one router between the private and public networks. It is possible to have more than one router between these networks. If this configuration is used, however, it is essential that they both use the same translation table. Otherwise, if Router R1 processes the request, but Router R2 receives the response, Router R2 won't know how to translate back the <a class="indexterm" id="idx-CHP-28-0993"/>destination address on the incoming datagram. This makes dynamic mapping extremely difficult: Routers would have to coordinate their address mappings.</p></div>
<div class="sect1" title="IP NAT Bidirectional (Two-Way/Inbound) Operation"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_bidirectional_two-wayinbound_oper"/>IP NAT Bidirectional (Two-Way/Inbound) Operation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-28-0994"/><a class="indexterm" id="idx-CHP-28-0995"/><a class="indexterm" id="idx-CHP-28-0996"/>Traditional NAT is designed to handle only outbound transactions; clients on the local network initiate requests and devices on the Internet and send back responses. However, in some circumstances, we may want to go in the opposite direction. That is, we may want to have a device on the outside network initiate a transaction with one on the inside. To permit this, we need a more capable type of NAT than the traditional version. This enhancement goes by various names, most commonly <a class="indexterm" id="idx-CHP-28-0997"/>Bidirectional NAT, <a class="indexterm" id="idx-CHP-28-0998"/>Two-Way NAT, and <a class="indexterm" id="idx-CHP-28-0999"/>Inbound NAT. All of these convey the concept that this kind of NAT allows both the type of transaction you saw in the previous topic and also transactions initiated from the outside network.</p><p>Performing NAT on inbound transactions is more difficult than conventional outbound NAT. To understand why, remember that the network configuration when using NAT is inherently <span class="emphasis"><em>asymmetric</em></span>: The inside network generally knows the IP addresses of outside devices, since they are public, but the outside network doesn't know the private addresses of the inside network. Even if they did know them, they could never be specified as the target of an IP datagram initiated from outside since they are not routable—there would be no way to get them to the private network's local router.</p><p>Why does this matter? Well, consider the case of outbound NAT from Device A on the inside network to Device B on the outside. The local client, A, always starts the transaction, so Device A's NAT router is able to create a mapping between Device A's inside local and inside global address during the request. Device B is the recipient of the already-translated datagram, so the fact that Device A is using NAT is hidden. Device B responds back, and the NAT router does the reverse translation without Device B ever even knowing NAT was used for Device A.</p><p>Now let's look at the inbound case. Here, Device B is trying to send to Device A, which is using NAT. Device B can't send to Device A's private (inside local) address. It needs Device A's inside global address in order to start the ball rolling. However, Device A's NAT router isn't proximate to Device B. In fact, Device B probably doesn't even know the identity of Device A's NAT router!</p><p>This leaves only two methods. One is to use static mapping for devices like servers on the inside network that need to be accessed from the outside. When static mapping is employed, the global address of the device that is using the static mapping will be publicly known, which solves the "where do I send my request to" problem.</p><p>The other solution is to make use of DNS. As explained in detail in the section on DNS (see <a class="xref" href="pt12.html" title="Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION">Part III-1</a>), this protocol allows requests to be sent as names instead of IP addresses. The DNS server translates these names to their corresponding addresses. It is possible to integrate DNS and NAT so they work together. This process is described in RFC 2694, "DNS Extensions to Network Address Translators (DNS_ALG)."</p><p>In this technique, an outside device can make use of dynamic mapping. The basic process (highly simplified) is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The outside device sends a DNS request using the name of the device on the inside network it wishes to reach. For example, it might be <a class="ulink" href="http://www.ilikenat.com">www.ilikenat.com</a>.</p></li><li class="listitem"><p>The DNS server for the internal network resolves the <a class="ulink" href="http://www.ilikenat.com">www.ilikenat.com</a> name into an <span class="emphasis"><em>inside local</em></span> address for the device that corresponds to this DNS entry.</p></li><li class="listitem"><p>The <span class="emphasis"><em>inside local</em></span> address is passed to NAT and used to create a dynamic mapping between the <span class="emphasis"><em>inside local</em></span> address of the server being accessed from the outside, and an <span class="emphasis"><em>inside global</em></span> address. This mapping is put into the NAT router's translation table.</p></li><li class="listitem"><p>When the DNS server sends back the name resolution, it tells the outside device the <span class="emphasis"><em>inside global</em></span> (public) address mapped in the previous step, not the <span class="emphasis"><em>inside local</em></span> (private) address of the server being sought.</p></li></ol></div><p>Once the inside global address of the device on the inside network is known by the outside device, the transaction can begin. Let's use the same example as in the previous section, but let's reverse it so that the outside device 204.51.16.12 is initiating a request (and is thus now the <span class="emphasis"><em>client</em></span> ) to inside device 10.0.0.207 (which is the <span class="emphasis"><em>server</em></span> ). Let's say that either static mapping or DNS has been used so that the outside device knows the inside global address of 10.0.0.207 is actually 194.54.21.6. <a class="xref" href="ch28s05.html#operation_of_bidirectional_two-way-id001" title="Table 28-2. Operation of Bidirectional (Two-Way/Inbound) NAT">Table 28-2</a> describes the transaction in detail, and it is illustrated <a class="xref" href="ch28s05.html#operation_of_bidirectional_two-wayinboun" title="Figure 28-3. Operation of bidirectional (two-way/inbound) NAT This figure is very similar to Figure 28-2, except that the transaction is in reverse, so start at the upper right and go counterclockwise. Translated addresses are shown in bold. Table 28-2 contains a complete explanation of the four steps. Refer to Figure 28-1 for an explanation of address types.">Figure 28-3</a>.</p><div class="figure"><a id="operation_of_bidirectional_two-wayinboun"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e29203"/><img alt="Operation of bidirectional (two-way/inbound) NAT This figure is very similar to , except that the transaction is in reverse, so start at the upper right and go counterclockwise. Translated addresses are shown in bold. contains a complete explanation of the four steps. Refer to for an explanation of address types." src="httpatomoreillycomsourcenostarchimages287907.png.jpg"/></div></div><p class="title">Figure 28-3. Operation of bidirectional (two-way/inbound) NAT This figure is very similar to <a class="xref" href="ch28s04.html#operation_of_unidirectional_tradit-id001" title="Figure 28-2. Operation of unidirectional (traditional/outbound) NAT You can see the four steps in this process by following the steps in clockwise order. Translated addresses are shown in bold. Refer to Table 28-1 and Figure 28-1 for an explanation of the four address types.">Figure 28-2</a>, except that the transaction is in reverse, so start at the upper right and go counterclockwise. Translated addresses are shown in bold. <a class="xref" href="ch28s05.html#operation_of_bidirectional_two-way-id001" title="Table 28-2. Operation of Bidirectional (Two-Way/Inbound) NAT">Table 28-2</a> contains a complete explanation of the four steps. Refer to <a class="xref" href="ch28s02.html#ip_network_address_translation_nat_termi" title="Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this diagram will help you to better understand the whole &quot;inside/outside/local/global&quot; thing.">Figure 28-1</a> for an explanation of address types.</p></div><div class="table"><a id="operation_of_bidirectional_two-way-id001"/><p class="title">Table 28-2. Operation of Bidirectional (Two-Way/Inbound) NAT</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operation of Bidirectional (Two-Way/Inbound) NAT"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-28-1000"/><a class="indexterm" id="idx-CHP-28-1001"/><a class="indexterm" id="idx-CHP-28-1002"/><a class="indexterm" id="idx-CHP-28-1003"/><a class="indexterm" id="idx-CHP-28-1004"/><a class="indexterm" id="idx-CHP-28-1005"/>Step #</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Type</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Source Address</p></th><th style="border-bottom: 0.5pt solid ; "><p>Datagram Destination Address</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Outside Client Generates Request and Sends to NAT Router</strong></span>: Device 204.51.16.12 generates a request to the inside server. It uses the <span class="emphasis"><em>inside global</em></span> address 194.54.21.6 as the destination. The datagram will be routed to the address's local router, which is the NAT router that services the inside network where the server is located.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request (from outside client to inside server)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>204.51.16.12 (outside global)</p></td><td style="border-bottom: 0.5pt solid ; "><p>194.54.21.6 (inside global)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Destination Address and Sends to Inside Server</strong></span>: The NAT router already has a mapping from the <span class="emphasis"><em>inside global</em></span> address to the <span class="emphasis"><em>inside local</em></span> address of the server. It replaces the 194.54.21.6 destination address with 10.0.0.207, and performs checksum recalculations and other work as necessary. The source address is not translated. The router then delivers the modified datagram to the inside server at 10.0.0.207.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>204.51.16.12 (outside local)</p></td><td style="border-bottom: 0.5pt solid ; "><p>10.0.0.207 (inside local)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Inside Server Generates Response and Sends Back to NAT Router</strong></span>: The server at 10.0.0.207 generates a response, which it addresses to 204.51.16.12 since that was the source of the request to it. This is then routed to the server's NAT router.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response (from inside server to outside client)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10.0.0.207 (inside local)</p></td><td style="border-bottom: 0.5pt solid ; "><p>204.51.16.12 (outside local)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Source Address and Routes Datagram to Outside Client</strong></span>: The NAT router sees the private address 10.0.0.207 in the response and replaces it with 194.54.21.6. It then routes this back to the original client on the outside network.</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>194.54.21.6 (inside global)</p></td><td style=""><p>204.51.16.12 (outside global)</p></td></tr></tbody></table></div></div><p>As you can see, once the outside device knows the inside device's <span class="emphasis"><em>inside global</em></span> address, you'll find that <a class="indexterm" id="idx-CHP-28-1006"/>inbound NAT is very similar to outbound NAT. It just does the exact opposite translation. Instead of modifying the source address on the outbound request and the destination on the <a class="indexterm" id="idx-CHP-28-1007"/>inbound response, the router changes the destination on the inbound request and the source on the outbound reply.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-153"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In traditional NAT, a transaction must begin with a request from a client on the local network, but in <a class="indexterm" id="idx-CHP-28-1008"/><span class="emphasis"><em>bidirectional</em></span> (<a class="indexterm" id="idx-CHP-28-1009"/>two-way/inbound) NAT, it is possible for a device on the public Internet to access a local network server. This requires the use of either static mapping or DNS to provide to the outside client the address of the server on the inside network. Then the NAT transaction is pretty much the same as in the unidirectional case, except in reverse: The incoming request has its destination address changed from <span class="emphasis"><em>inside global</em></span> to <span class="emphasis"><em>inside local</em></span>; the response has its source changed from <span class="emphasis"><em>inside local</em></span> to <span class="emphasis"><em>inside global</em></span>.</p></div></div>
<div class="sect1" title="IP NAT Port-Based (Overloaded) Operation"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_port-based_overloaded_operation"/>IP NAT Port-Based (Overloaded) Operation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-28-1010"/><a class="indexterm" id="idx-CHP-28-1011"/>Both traditional NAT and <a class="indexterm" id="idx-CHP-28-1012"/>bidirectional NAT work by swapping inside network and outside network addresses as needed in order to allow a private network to access a public one. For each transaction, there is a one-to-one mapping between the <span class="emphasis"><em>inside local</em></span> address of a device on the private network and the <span class="emphasis"><em>inside global</em></span> address that represents it on the public network. We can use dynamic address assignment to allow a large number of private hosts to share a small number of registered public addresses.</p><p>However, there is a potential snag here. Consider the earlier NAT example, where 250 hosts share 20 inside global (public) addresses. If 20 hosts already have transactions in progress, what happens when the 21st tries to access the Internet? There aren't any <span class="emphasis"><em>inside global</em></span> addresses available for it to use, so it won't be able to.</p><p>Fortunately, there is a mechanism already built into TCP/IP that can help us alleviate this situation. The two TCP/IP transport layer protocols, TCP and UDP, both make use of additional addressing components called <span class="emphasis"><em>ports</em></span>. The port number in a TCP or UDP message helps identify individual connections between two addresses. It is used to allow many different applications on a TCP/IP client and server to talk to each simultaneously, without interference. For example, you use this capability when you open multiple browser windows to access more than one web page on the same site at the same time. This sharing of IP addresses among many connections is called <span class="emphasis"><em>multiplexing</em></span>. <a class="xref" href="ch43.html" title="Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS">Chapter 43</a>, which describes TCP and UDP ports, covers all of this in much more detail.</p><p>Now let's come back to NAT. We are already translating IP addresses as we send datagrams between the public and private portions of the internetwork. What if we could also translate port numbers? Well, we can! The combination of an address and port uniquely identifies a connection. As a datagram passes from the private network to the public one, we can change not just the IP address, but also the port number in the TCP or UDP header. The datagram will be sent out with a different source address and port. The response will come back to this same address and port combination (called a <span class="emphasis"><em>socket</em></span>) and can be translated back again.</p><p>This method goes by various names. Since it is a technique that can have multiple inside local addresses share a single inside global address, it is called <span class="emphasis"><em>overloading</em></span> of an <span class="emphasis"><em>inside global</em></span> address, or alternatively, just <span class="emphasis"><em>overloaded NAT</em></span>. More elegant names that better indicate how the technique works include <span class="emphasis"><em>Port-Based NAT, Network Address Port Translation (NAPT)</em></span>, and <span class="emphasis"><em>Port Address Translation (PAT)</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-154"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Port-Based</em></span> or overloaded NAT is an enhancement of regular NAT that allows a large number of devices on a private network to simultaneously share a single inside global address by changing the port numbers used in TCP and UDP messages.</p></div><p>Whatever its name, the use of ports in translation has tremendous advantages. It can allow all 250 hosts on the private network to use only 20 IP addresses—and potentially even fewer than that. In theory, you could even have all 250 share a single public IP address at once! You don't want to share so many local hosts that you run out of port numbers, but there are thousands of port numbers to choose from.</p><p>Port-Based NAT requires a router that is programmed to make the appropriate address and port mappings for datagrams as it transfers them between networks. The disadvantages of the method include this greater complexity, and also the potential for more compatibility issues (such as with applications like FTP), since you must now watch for port numbers at higher layers and not just IP addresses.</p><p>The operation of NAPT/<a class="indexterm" id="idx-CHP-28-1013"/>PAT is very similar to the way regular NAT works, except that port numbers are also translated. For a traditional outbound transaction, the source port number is changed on the request at the same time that the source address is modified; the destination port number is modified on the response with the destination address.</p><p>Let's consider again the example you looked at in the topic on traditional NAT, but this time in a PAT environment. Device 10.0.0.207 was one of 250 hosts on a private network accessing the World Wide Web server at 204.51.16.12. Let's say that because PAT is being used, in order to save money, all 250 hosts are sharing a single <span class="emphasis"><em>inside global</em></span> address, 194.54.21.7, instead of a pool of 20. The transaction would proceed as described in <a class="xref" href="ch28s06.html#operation_of_port-based_overloaded_nat" title="Table 28-3. Operation of Port-Based (Overloaded) NAT">Table 28-3</a> and illustrated in <a class="xref" href="ch28s06.html#operation_of_port-based_overloaded_nat" title="Table 28-3. Operation of Port-Based (Overloaded) NAT">Table 28-3</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-155"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In <a class="indexterm" id="idx-CHP-28-1014"/>Port-Based NAT, the NAT router translates the source address and port of an outgoing request from inside local to inside global form. It then transforms the destination address and port of the response from inside global to inside local. The outside local and outside global addresses are the same in both request and reply.</p></div><p>One other issue related to NAPT/PAT is worth mentioning: It assumes that all traffic uses either UDP or TCP at the transport layer. Although this is generally the case, it may not always be true. If there is no port number, port translation cannot be done and the method will not work.</p><div class="figure"><a id="operation_of_port-based_overloaded_nat_t"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e29493"/><img alt="Operation of Port-Based (overloaded) NAT This figure is very similar to , except that the source and destination port numbers have been shown, since they are used in this type of NAT. Translated addresses and ports are in bold. contains a complete explanation of the four steps in Port-Based NAT. Refer to for an explanation of address types." src="httpatomoreillycomsourcenostarchimages287909.png.jpg"/></div></div><p class="title">Figure 28-4. Operation of Port-Based (overloaded) NAT This figure is very similar to <a class="xref" href="ch28s06.html#operation_of_port-based_overloaded_nat" title="Table 28-3. Operation of Port-Based (Overloaded) NAT">Table 28-3</a>, except that the source and destination port numbers have been shown, since they are used in this type of NAT. Translated addresses and ports are in bold. <a class="xref" href="ch28s06.html#operation_of_port-based_overloaded_nat" title="Table 28-3. Operation of Port-Based (Overloaded) NAT">Table 28-3</a> contains a complete explanation of the four steps in Port-Based NAT. Refer to <a class="xref" href="ch28s02.html#ip_network_address_translation_nat_termi" title="Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this diagram will help you to better understand the whole &quot;inside/outside/local/global&quot; thing.">Figure 28-1</a> for an explanation of address types.</p></div><div class="table"><a id="operation_of_port-based_overloaded_nat"/><p class="title">Table 28-3. Operation of Port-Based (Overloaded) NAT</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operation of Port-Based (Overloaded) NAT"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-28-1015"/><a class="indexterm" id="idx-CHP-28-1016"/>Step #</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Type</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Source Address:Port</p></th><th style="border-bottom: 0.5pt solid ; "><p>Datagram Destination Address:Port</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Inside Client Generates Request and Sends to NAT Router</strong></span>: Device 10.0.0.207 generates an HTTP request to the server at 204.51.16.12. The standard server port for WWW is 80, so the destination port of the request is 80; let's say the source port on the client is 7000. The datagram is sent to the NAT-capable router that connects the organization's internal network to the Internet.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request (from inside client to outside server)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10.0.0.207:7000 (inside local)</p></td><td style="border-bottom: 0.5pt solid ; "><p>204.51.16.12:80 (outside local)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Source Address and Port and Sends to Outside Server</strong></span>: The NAT router realizes that 10.0.0.207 is an <span class="emphasis"><em>inside local</em></span> address and knows it must substitute an <span class="emphasis"><em>inside global</em></span> address. Here though, there are multiple hosts sharing the single <span class="emphasis"><em>inside global</em></span> address 194.54.21.7. Lets say that port 7000 is already in use for that address by another private host connection. The router substitutes the <span class="emphasis"><em>inside global</em></span> address and also chooses a new source port number, say 7224, for this request. The destination address and port are not changed.</p>
<p>The NAT router puts the address and port mapping into its translation table. It sends the modified datagram out, which arrives at the server at 204.51.16.12.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>194.54.21.7:7224 (inside global)</p></td><td style="border-bottom: 0.5pt solid ; "><p>204.51.16.12 (outside global)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Outside Server Generates Response and Sends Back to NAT Router</strong></span>: The server at 204.51.16.12 generates an HTTP response. It has no idea that NAT was involved; it sees an address of 194.54.21.7 and port of 7224 in the request sent to it, so it sends back to that address and port.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response (from outside server to inside client)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>204.51.16.12:80 (outside global)</p></td><td style="border-bottom: 0.5pt solid ; "><p>194.54.21.7:7224 (inside global)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Destination Address and Port and Delivers Datagram to Inside Client</strong></span>: The NAT router sees the address 94.54.21.7 and port 7224 in the response that arrived from the Internet. It consults its translation table and knows this datagram is intended for 10.0.0.207, port 7000. This time, the destination address and port are changed but not the source. The router then delivers the datagram back to the originating client.</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>204.51.16.12:80 (outside local)</p></td><td style=""><p>10.0.0.207:7000 (inside local)</p></td></tr></tbody></table></div></div></div>
<div class="sect1" title="IP NAT Overlapping/Twice NAT Operation"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_overlappingtwice_nat_operation"/>IP NAT Overlapping/Twice NAT Operation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-28-1017"/><a class="indexterm" id="idx-CHP-28-1018"/>All three of the versions of NAT discussed so far—traditional, bidirectional, and <a class="indexterm" id="idx-CHP-28-1019"/>Port-Based—are normally used to connect a network using private, nonroutable addresses to the public Internet, which uses unique, registered, routable addresses. With these kinds of NAT, there will normally be no overlap between the address spaces of the inside and outside network, since the former are private and the latter are public. This enables the NAT router to be able to immediately distinguish inside addresses from outside addresses just by looking at them.</p><p>In the examples you've seen so far, the inside addresses were all from the RFC 1918 block 10.0.0.0. These can't be public Internet addresses, so the NAT router knew any address referenced by a request from the inside network within this range was a local reference within the inside network. Similarly, any addresses outside this range are easy to identify as belonging to the outside world.</p><p>There are circumstances, however, in which there may indeed be an overlap between the addresses used for the inside network, and the addresses used for part of the outside network. Consider the following cases:</p><p><span class="strong"><strong>Private Network–to–Private Network Connections</strong></span> The example network using 10.0.0.0 block addresses might want to connect to another network using the same method. This situation might occur if two corporations merged and happened to be using the same addressing scheme (and there aren't that many private IP blocks, so this isn't that uncommon).</p><p><span class="strong"><strong>Invalid Assignment of Public Address Space to Private Network</strong></span> Some networks might have been set up, not by using a designated private address block, but rather by using a block containing valid Internet addresses. For example, suppose an administrator decided that the network he was setting up would never be connected to the Internet (ha!), and numbered the whole thing using 18.0.0.0 addresses, which belong to the <a class="indexterm" id="idx-CHP-28-1020"/>Massachusetts Institute of Technology (MIT). Then later, this administrator's shortsightedness would backfire when the network did indeed need to be connected to the Internet.</p><p><span class="strong"><strong>Stale Public Address Assignment</strong></span> Company A might have been using a particular address block for years that was reassigned or reallocated for whatever reason to Company B. Company A might not want to go through the hassle of renumbering its network, and would then keep its addresses, even while Company B started using them on the Internet.</p><p>What these situations all have in common is that the inside addresses used in the private network <span class="emphasis"><em>overlap</em></span> with addresses on the public network. When a datagram is sent from within the local network, the NAT router can't tell if the intended destination is within the inside network or the outside network. For example, if you want to connect host 10.0.0.207 in the private network to host 10.0.0.199 in a different network, and you put 10.0.0.199 in the destination of the datagram and send it, how does the router know if you mean 10.0.0.199 on your own local network or the remote one? For that matter, you might need to send a request to 10.0.0.207 in the other private network, your own address! Take the network that was numbered with <a class="indexterm" id="idx-CHP-28-1021"/>MIT's address block. How does the router know when a datagram is actually being sent to MIT as opposed to another device on the private network?</p><p>The solution to this dilemma is to use a more sophisticated form of NAT. The other versions you have seen so far always translate either the source address <span class="emphasis"><em>or</em></span> the destination address as a datagram passes from the inside network to the outside network or vice versa. To cope with overlapping addresses, we must translate both the source address <span class="emphasis"><em>and</em></span> the <a class="indexterm" id="idx-CHP-28-1022"/>destination address on each transition from the inside to the outside or the other direction. This technique is called <span class="emphasis"><em>overlapping NAT</em></span> in reference to the problem it solves, or <span class="emphasis"><em>Twice NAT</em></span> due to how it solves it. (Incidentally, despite the latter name, regular NAT is <span class="emphasis"><em>not</em></span> called Once NAT.)</p><p>Twice NAT functions by creating a set of mappings not only for the private network the NAT router serves, but also for the overlapping network (or networks) that conflict with the inside network's address space. In order for this to function, Twice NAT relies on the use of DNS, just as does bidirectional NAT. This lets the inside network send requests to the overlapping network in a way that can be uniquely identified. Otherwise, the router can't tell what overlapping network our inside network is trying to contact.</p><p>Let's try a new example. Suppose the network has been improperly numbered so that it is not in the 10.0.0.0 private block but in the 18.0.0.0 block used by MIT. A client on our private network, 18.0.0.18, wants to send a request to the server <a class="ulink" href="http://www.twicenat.mit.edu">www.twicenat.mit.edu</a>, which has the address 18.1.2.3 at MIT. The client can't just make a datagram with 18.1.2.3 as the destination and send out, as the router will think it's on the local network and not route it. Instead, 18.0.0.18 uses a combination of DNS and NAT to get the outside device address, as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The client on the local network (18.0.0.18) sends a DNS request to get the address of <a class="ulink" href="http://www.twicenat.mit.edu">www.twicenat.mit.edu</a>.</p></li><li class="listitem"><p>The (Twice-NAT compatible) NAT router serving the local network intercepts this DNS request. It then consults its tables to find a special mapping for this outside device. Let's say that it is programmed to translate <a class="ulink" href="http://www.twicenat.mit.edu">www.twicenat.mit.edu</a> into the address 172.16.44.55. This is a private, nonroutable RFC 1918 address.</p></li><li class="listitem"><p>The NAT router returns this value, 172.16.44.55, to the source client, which uses it for the destination.</p></li></ol></div><p>Once the client has the translated address, it initiates a transaction just as before. NAT will now perform translation of the inside devices and the outside devices as well. The outside device address must be translated because the inside device is using 172.16.44.55, which isn't a valid address for the server it is trying to reach. The inside device address must still be translated as in regular NAT because 18.0.0.18 is not a valid public address for you. It may refer to a real machine in MIT and you aren't supposed to be using it on the Internet!</p><p>Let's say that you are still using the pool of 20 inside global addresses from 194.54.21.1 through 194.54.21.20 for inside addresses, and let's further suppose that the NAT router chooses 194.54.21.12 for this particular exchange. The transaction sequence would be roughly as described in <a class="xref" href="ch28s07.html#operation_of_overlapping_nattwice_nat" title="Table 28-4. Operation of Overlapping NAT/Twice NAT">Table 28-4</a> and illustrated in <a class="xref" href="ch28s08.html#operation_of_overlapping_nattwice_nat_th" title="Figure 28-5. Operation of Overlapping NAT/Twice NAT This figure is very similar to Figure 28-2, except that as you can see, the NAT router translates both source and destination addresses each time (shown in bold). Table 28-4 contains a complete explanation of the four steps in overlapping NAT. Refer to Figure 28-1 for an explanation of address types.">Figure 28-5</a>.</p><p>Overlapping NAT is used in situations where both the source and destination addresses in a datagram are private addresses or otherwise cannot be used regularly on the public Internet. In this case, unlike with the other types of NAT, the NAT router translates both the source and destination addresses of incoming and outgoing datagrams. On outgoing messages, <span class="emphasis"><em>inside local</em></span> addresses are changed to <span class="emphasis"><em>inside global</em></span> and <span class="emphasis"><em>outside local</em></span> to <span class="emphasis"><em>outside global</em></span>; on incoming messages, <span class="emphasis"><em>inside global</em></span> addresses are changed to <span class="emphasis"><em>inside local</em></span> and <span class="emphasis"><em>outside global</em></span> addresses are changed to <span class="emphasis"><em>outside local</em></span>.</p><div class="table"><a id="operation_of_overlapping_nattwice_nat"/><p class="title">Table 28-4. Operation of Overlapping NAT/Twice NAT</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operation of Overlapping NAT/Twice NAT"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step #</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Type</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Datagram Source Address</p></th><th style="border-bottom: 0.5pt solid ; "><p>Datagram Destination Address</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Inside Client Generates Request and Sends to NAT Router</strong></span>: Device 18.0.0.18 generates a request using the destination 172.16.44.55, which it got from the (NAT-intercepted) DNS query for <a class="ulink" href="http://www.twicenat.mit.edu">www.twicenat.mit.edu</a>. The datagram is sent to the NAT router for the local network.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request (from inside client to outside server)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18.0.0.18 (inside local)</p></td><td style="border-bottom: 0.5pt solid ; "><p>172.16.44.55 (outside local)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Source Address and Destination Address and Sends to Outside Server</strong></span>: The NAT router makes two translations. First, it substitutes the 18.0.0.18 address with a publicly registered address, which is 194.54.21.12 for this example. It then translates the bogus 172.16.44.55 back to the real MIT address for <a class="ulink" href="http://www.twicenat.mit.edu">www.twicenat.mit.edu</a>. It routes the datagram to the outside server.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>194.54.21.12 (inside global)</p></td><td style="border-bottom: 0.5pt solid ; "><p>18.1.2.3 (outside global)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Outside Server Generates Response and Sends Back to NAT Router</strong></span>: The MIT server at 18.1.2.3 generates a response and sends it back to 194.54.21.12, which causes it to arrive back at the NAT router.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response (from outside server to inside client)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18.1.2.3 (outside global)</p></td><td style="border-bottom: 0.5pt solid ; "><p>194.54.21.12 (inside global)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>NAT Router Translates Source Address and Destination Address and Delivers Datagram to the Inside Client</strong></span>: The NAT router translates back the destination address to the actual address that's being used for the inside client, as in regular NAT. It also substitutes back in the 172.16.44.55 value it is using as a substitute for the real address of <a class="ulink" href="http://www.twicenat.mit.edu">www.twicenat.mit.edu</a>.</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>172.16.44.55 (outside local)</p></td><td style=""><p>18.0.0.18 (inside local)</p></td></tr></tbody></table></div></div><p>As you can see, in this example, the <span class="emphasis"><em>outside local</em></span> and <span class="emphasis"><em>outside global</em></span> addresses are different, unlike in the preceding NAT examples. <a class="indexterm" id="idx-CHP-28-1023"/>Twice NAT can also handle an inbound transaction by watching for datagrams coming in from the Internet that overlap with the addresses used on the local network and doing double substitutions as required.</p></div>
<div class="sect1" title="IP NAT Compatibility Issues and Special Handling Requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ip_nat_compatibility_issues_and_special_"/>IP NAT Compatibility Issues and Special Handling Requirements</h1></div></div></div><p><a class="indexterm" id="idx-CHP-28-1024"/>In a perfect world NAT could be made transparent to the devices using it. We would like to be able to have a NAT router change IP addresses in request datagrams as they leave the network and change them back in responses that come back, and have none of the hosts be any wiser. Unfortunately, this isn't a perfect world.</p><p/><div class="figure"><a id="operation_of_overlapping_nattwice_nat_th"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e29879"/><img alt="Operation of Overlapping NAT/Twice NAT This figure is very similar to , except that as you can see, the NAT router translates both source and destination addresses each time (shown in bold). contains a complete explanation of the four steps in overlapping NAT. Refer to for an explanation of address types." src="httpatomoreillycomsourcenostarchimages287911.png.jpg"/></div></div><p class="title">Figure 28-5. Operation of Overlapping NAT/Twice NAT This figure is very similar to <a class="xref" href="ch28s04.html#operation_of_unidirectional_tradit-id001" title="Figure 28-2. Operation of unidirectional (traditional/outbound) NAT You can see the four steps in this process by following the steps in clockwise order. Translated addresses are shown in bold. Refer to Table 28-1 and Figure 28-1 for an explanation of the four address types.">Figure 28-2</a>, except that as you can see, the NAT router translates both source and destination addresses each time (shown in bold). <a class="xref" href="ch28s07.html#operation_of_overlapping_nattwice_nat" title="Table 28-4. Operation of Overlapping NAT/Twice NAT">Table 28-4</a> contains a complete explanation of the four steps in overlapping NAT. Refer to <a class="xref" href="ch28s02.html#ip_network_address_translation_nat_termi" title="Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this diagram will help you to better understand the whole &quot;inside/outside/local/global&quot; thing.">Figure 28-1</a> for an explanation of address types.</p></div><p><a class="indexterm" id="idx-CHP-28-1025"/>It is not possible for <a class="indexterm" id="idx-CHP-28-1026"/>NAT to be completely transparent to the devices that use it. There are potential compatibility problems that arise if NAT doesn't perform certain functions. These functions go beyond simply swapping IP addresses and possibly port numbers in the IP header. The main problem is that even though IP addresses are supposedly the domain of IP, they are really used by other protocols as well, both at the network layer and in higher layers. When NAT changes the IP address in an IP datagram, it must often also change addresses in other places to make sure that the addresses in various headers and payloads still match.</p><p>These compatibility issues require that even though NAT should theoretically work only at the level of IP at the network layer, in practical terms, NAT routers must be aware of many more protocols and perform special operations as required. Some are required for all datagrams that are translated; others only apply to certain datagrams and not others. And even when these techniques are added to NAT routers, some things still may not work properly in a NAT environment.</p><p>Let's take a look at some of the main issues and requirements:</p><p><span class="strong"><strong>TCP and UDP <a class="indexterm" id="idx-CHP-28-1027"/>Checksum Recalculations</strong></span> Changing the IP addresses in the IP header means that the IP header checksum must be calculated. Since both UDP and TCP also have checksums, and these checksums are computed over a pseudo header that contains the IP source and destination address as well, they too, must be recalculated each time a translation is made.</p><p><span class="strong"><strong>ICMP Manipulations</strong></span> Since NAT works so intimately with IP headers, and since IP is closely related to its "assistant" protocol the Internet Control Management Protocol (ICMP; see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>), NAT must also look for certain ICMP messages and make changes to addresses contained within them. Many ICMP messages, such as Destination Unreachable and Parameter Problem, contain the original IP header of the datagram that lead to the ICMP message as data. Since NAT is translating addresses in IP headers, it must watch for these messages and translate addresses in included headers as required.</p><p><span class="strong"><strong>Applications That Embed IP Addresses</strong></span> A number of TCP/IP applications embed IP addresses within the actual application data payload. The most notorious example of this is FTP, which actually sends address and port assignments as text information in datagrams between devices during a connection. In order for NAT to support FTP, it must be specifically programmed with algorithms to look for this information and make changes as needed. The level of complication can go even beyond this. Consider what happens when an FTP message containing these text addresses or port numbers is <span class="emphasis"><em>fragmented</em></span>. Part of the address that will be translated may be in two different IP datagrams and may be hard to recognize!</p><p><span class="strong"><strong>Additional Issues with Port Translation</strong></span> When Port-Based NAT (PAT) is used, the previous issues that apply to addresses now apply to ports as well, making even more work for the router to perform.</p><p><span class="strong"><strong>Cascading Impact of Changes to Address or Port Numbers</strong></span> Take the example of an FTP datagram encoding an IP address that NAT must change. The address being substituted might require more characters than the original; in the first example, 10.0.0.207 (10 ASCII characters) is replaced by 194.54.21.11 (12 ASCII characters). Making this substitution changes the size of the payload! This means that TCP sequence numbers (see <a class="xref" href="ch46.html" title="Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION">Chapter 46</a>) also must be modified. In these situations, NAT itself is supposed to take care of any additional work that may be required.</p><p><span class="strong"><strong>Problems with IPsec</strong></span> When IPsec is used in transport mode, both the Authentication Header (AH) and Encapsulating Security Payload (ESP) protocols use an integrity check that is based on the value of the entire payload. When NAT tries to update the TCP or UDP checksum in the IP datagram, this changes the value of data that the receiving device uses in performing the AH or ESP integrity check. The check will fail. Thus, NAT can't be used in IPsec transport mode. It may still work in tunnel mode, but there can be complications here as well.</p><p>Most NAT implementations do take at least some of the previous issues into account. Certainly, common applications like FTP are widely supported by NAT routers, or no one would want to use NAT. That said, there might be some applications that will not work over NAT. The fact that NAT really isn't transparent and must do these extra sorts of "hacks" to other protocol headers and even payloads is a big part of the reason why many people refer to NAT as a kludge; elegant solutions don't have so many special cases that need special handling.</p></div>
<div class="chapter" title="Chapter&#xA0;29.&#xA0;IP SECURITY (IPSEC) PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="ip_security_ipsec_protocols"/>Chapter 29. IP SECURITY (IPSEC) PROTOCOLS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e29944"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> One of the weaknesses of the original Internet Protocol (IP) is that it lacks any sort of general-purpose mechanism for ensuring the authenticity and privacy of data as it is passed over the internetwork. Since IP datagrams must usually be routed between two devices over unknown networks, any information in them is subject to being intercepted and even possibly changed. With the increased use of the Internet for critical applications, security enhancements were needed for IP. To this end, a set of protocols called <span class="emphasis"><em>IP Security</em></span> or <a class="indexterm" id="idx-CHP-29-1028"/><span class="emphasis"><em>IPsec</em></span> was developed.</p><p>In this chapter, I provide a brief description of IPsec concepts and protocols. I begin with an overview of IPsec, including a discussion of the history of the technology and a definition of the standards. I describe the main components and protocols of the IPsec suite and its different architectures and methods for implementation. I then move to actually discussing how IPsec works, beginning with a description of the two IPsec modes (transport and tunnel) and how they differ. I describe security associations and related constructs such as the <a class="indexterm" id="idx-CHP-29-1029"/>Security Parameter Index (SPI). The last three topics cover the three main IPsec protocols: IPsec Authentication Header (AH), IPsec Encapsulating Security Payload (<a class="indexterm" id="idx-CHP-29-1030"/>ESP), and the IPsec Internet Key Exchange (IKE).</p><div class="note" title="Note"><h3 class="title"><a id="note-93"/>Note</h3><p><span class="emphasis"><em>IPsec was initially developed with IPv6 in mind, but has been engineered to provide security for both IPv4 and IPv6 networks, and operation in both versions is similar. There are some differences in the datagram formats used for AH and ESP. These differences depend on whether you use IPsec in IPv4 or IPv6, because the two versions have different datagram formats and addressing. I highlight these differences where appropriate.</em></span></p></div><div class="sect1" title="IPsec Overview, History, and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_overview_history_and_standards"/>IPsec Overview, History, and Standards</h1></div></div></div><p><a class="indexterm" id="idx-CHP-29-1031"/>The big problem with the original IP version (IPv4) is the pending exhaustion of its address space. This situation arose due to the rapid expansion of the Internet beyond anyone's expectations when IPv4 was developed. This same mismatch between how the Internet was when IPv4 was created and how it is now has led to another major problem with IP: the lack of a definitive means of ensuring security on IP internetworks.</p><p>The security problem arose because 25 years ago, the Internet was tiny and relatively private. Today it is enormous and truly public. As the Internet has grown, the need for security has grown with it. Consider that TCP/IP and the early Internet precursors were developed as very small networks used by government researchers at the United States Defense Advanced Research Projects Agency (<span class="emphasis"><em>DARPA</em></span> or <span class="emphasis"><em>ARPA</em></span>). People who were well known and would generally have had security clearance controlled all the hardware. In such a network, you don't need to build security in to the protocols—you build it into the building! It's easier to use locks and guards to ensure security than fancy encryption. The easiest way to keep someone from snooping or tampering with data on the network is simply to deny them access to the hosts that connect to the network.</p><p>This worked fine at first when there were only a few dozen machines on the Internet. And even when the Internet first started to grow, it was used pretty much only to connect together researchers and other networking professionals. New sites were added to the network slowly at first, and at least someone knew the identity of each new site added to the growing internetwork. However, as the Internet continued to increase in size and was eventually opened to the public, maintaining security of the network as a whole became impossible. Today, the "great unwashed masses" are on the Internet. Many routers—owned by "who knows" and administered by "who knows"—stand between you and most other devices you want to connect with. You cannot assume that the data you send or receive is secure.</p><p>A number of methods have evolved over the years to address the need for security. Most of these are focused at the higher layers of the OSI protocol stack in order to compensate for IP's lack of security. These solutions are valuable for certain situations, but they can't be generalized easily because they are particular to various applications. For example, we can use Secure Sockets Layer (SSL) for certain applications like World Wide Web access or File Transfer Protocol (FTP), but there are dozens of applications that this type of security was never intended to work with.</p><p>What was really needed was a solution to allow security at the IP level so all higher-layer protocols in TCP/IP could take advantage of it. When the decision was made to develop a new version of IP (IPv6), this was the golden opportunity to resolve not just the addressing problems in the older IPv4, but the lack of security as well. New security technology was developed with IPv6 in mind, but since IPv6 has taken years to develop and roll out, and the need for security is now, the solution was designed to be usable for both IPv4 and IPv6.</p><p>The technology that brings secure communications to the IP is called <span class="emphasis"><em>IP Security</em></span>, commonly abbreviated <span class="emphasis"><em>IPsec.</em></span> The capitalization of this abbreviation is variable, so you'll see IPSec and IPSEC.</p><div class="sect2" title="Overview of IPsec Services and Functions"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_ipsec_services_and_functions"/>Overview of IPsec Services and Functions</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1032"/>IPsec is not a single protocol, but rather a set of services and protocols that provide a complete security solution for an IP network. These services and protocols combine to provide various types of protection. Since IPsec works at the IP layer, it can provide these protections for any higher-layer TCP/IP application or protocol without the need for additional security methods, which is a major strength. Some of the kinds of protection services offered by IPsec include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Encryption of user data for privacy</p></li><li class="listitem"><p>Authentication of the integrity of a message to ensure that it is not changed en route</p></li><li class="listitem"><p>Protection against certain types of security attacks, such as replay attacks</p></li><li class="listitem"><p>The ability for devices to negotiate the security algorithms and keys required to meet their security needs</p></li><li class="listitem"><p>Two security modes, tunnel and transport, to meet different network needs</p></li></ul></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-156"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>IPsec</em></span> is a contraction of <span class="emphasis"><em>IP Security</em></span>, and it consists of a set of services and protocols that provide security to IP networks. It is defined by a sequence of several Internet <a class="indexterm" id="idx-CHP-29-1033"/>standards.</p></div></div><div class="sect2" title="IPsec Standards"><div class="titlepage"><div><div><h2 class="title"><a id="ipsec_standards"/>IPsec Standards</h2></div></div></div><p>Since IPsec is actually a collection of techniques and protocols, it is not defined in a single Internet standard. Instead, a collection of RFCs defines the architecture, services, and specific protocols used in IPsec. Some of the most important of these are shown in <a class="xref" href="ch29.html#important_ip_security_ipsec_standards" title="Table 29-1. Important IP Security (IPsec) Standards">Table 29-1</a>, all of which were published in November 1998.</p><div class="table"><a id="important_ip_security_ipsec_standards"/><p class="title">Table 29-1. Important IP Security (IPsec) Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Important IP Security (IPsec) Standards"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2401</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Security Architecture for the Internet Protocol</p></td><td style="border-bottom: 0.5pt solid ; "><p>The main IPsec document, describing the architecture and general operation of the technology, and showing how the different components fit together.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2402</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Authentication Header</p></td><td style="border-bottom: 0.5pt solid ; "><p>Defines the IPsec Authentication Header (AH) protocol, which is used for ensuring data integrity and origin verification.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2403</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The Use of HMAC-MD5-96 within ESP and AH</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes a particular encryption algorithm for use by the AH and Encapsulation Security Payload (ESP) protocols called Message Digest 5 (MD5), HMAC variant.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2404</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The Use of HMAC-SHA-1-96 within ESP and AH</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes a particular encryption algorithm for use by AH and ESP called Secure Hash Algorithm 1 (SHA-1), HMAC variant.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2406</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Encapsulating Security Payload (ESP)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes the IPsec ESP protocol, which provides data encryption for confidentiality.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2408</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Internet Security Association and Key Management Protocol (ISAKMP)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Defines methods for exchanging keys and negotiating security associations.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2409</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The Internet Key Exchange (IKE)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes the IKE protocol that's used to negotiate security associations and exchange keys between devices for secure communications. Based on ISAKMP and OAKLEY.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>2412</p></td><td style="border-right: 0.5pt solid ; "><p>The OAKLEY Key Determination Protocol</p></td><td style=""><p>Describes a generic protocol for key exchange.</p></td></tr></tbody></table></div></div><p>Deployment of IPsec has only really started to take off in the last few years. A major use of the technology is in implementing virtual private networks (VPNs). It appears that the future is bright for IPsec, as more and more individuals and companies decide that they need to take advantage of the power of the Internet, while also protecting the security of the data they transport over it.</p></div></div></div>
<div class="sect1" title="IPsec General Operation, Components, and Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_general_operation_components_and_p"/>IPsec General Operation, Components, and Protocols</h1></div></div></div><p><a class="indexterm" id="idx-CHP-29-1034"/><a class="indexterm" id="idx-CHP-29-1035"/>IPsec isn't the only difficult topic in this book, but it is definitely a subject that baffles many. Most discussions of it jump straight to describing the mechanisms and protocols, without providing a general description of what it does and how the pieces fit together. Well, I recognized that IPsec is important, and I don't shy away from a challenge. Thus, here's my attempt to provide a framework for understanding IPsec's various bits and pieces.</p><p>So what exactly does IPsec do, and how does it do it? In general terms, it provides security services at the IP layer for other TCP/IP protocols and applications to use. What this means is that IPsec provides the tools that devices on a TCP/IP network need in order to communicate securely. When two devices (either end-user hosts or intermediate devices such as routers or firewalls) want to engage in secure communications, they set up a <span class="emphasis"><em>secure path</em></span> between themselves that may traverse across many insecure intermediate systems. To accomplish this, they must perform (at least) the following tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They must agree on a set of security protocols to use so that each one sends data in a format the other can understand.</p></li><li class="listitem"><p>They must decide on a specific encryption algorithm to use in encoding data.</p></li><li class="listitem"><p>They must exchange keys that are used to "unlock" data that has been cryptographically encoded.</p></li><li class="listitem"><p>Once this background work is completed, each device must use the protocols, methods, and keys previously agreed upon to encode data and send it across the network.</p></li></ul></div><div class="sect2" title="IPsec Core Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="ipsec_core_protocols"/>IPsec Core Protocols</h2></div></div></div><p>To support these activities, a number of different components make up the total package known as IPsec, as shown in <a class="xref" href="ch29s02.html#overview_of_ipsec_protocols_and_componen" title="Figure 29-1. Overview of IPsec protocols and components IPsec consists of two core protocols, AH and ESP, and three supporting components.">Figure 29-1</a>. The two main pieces are a pair of technologies sometimes called the <a class="indexterm" id="idx-CHP-29-1036"/><span class="emphasis"><em>core protocols</em></span> of IPsec, which actually do the work of encoding information to ensure security:</p><p><span class="strong"><strong>IPsec Authentication Header (AH)</strong></span> This protocol provides authentication services for IPsec. It allows the recipient of a message to verify that the supposed originator of a message was actually fact the one that sent it. It also allows the recipient to verify that intermediate devices en route haven't changed any of the data in the datagram. It also provides protection against so-called <a class="indexterm" id="idx-CHP-29-1037"/><span class="emphasis"><em>replay attacks</em></span>, whereby a message is captured by an unauthorized user and resent.</p><p><span class="strong"><strong>Encapsulating Security Payload (ESP)</strong></span> AH ensures the integrity of the data in datagram, but not its privacy. When the information in a datagram is "for your eyes only," it can be further protected using ESP, which encrypts the payload of the IP datagram.</p><div class="figure"><a id="overview_of_ipsec_protocols_and_componen"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30223"/><img alt="Overview of IPsec protocols and components IPsec consists of two core protocols, AH and ESP, and three supporting components." src="httpatomoreillycomsourcenostarchimages287913.png.jpg"/></div></div><p class="title">Figure 29-1. Overview of IPsec protocols and components IPsec consists of two core protocols, AH and ESP, and three supporting components.</p></div></div><div class="sect2" title="IPsec Support Components"><div class="titlepage"><div><div><h2 class="title"><a id="ipsec_support_components"/>IPsec Support Components</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1038"/><a class="indexterm" id="idx-CHP-29-1039"/><a class="indexterm" id="idx-CHP-29-1040"/>AH and ESP are commonly called <span class="emphasis"><em>protocols</em></span>, though this is another case where the use of this term is debatable. They are not really distinct protocols but are implemented as headers that are inserted into IP datagrams, as you will see. They thus do the "grunt work" of IPsec, and can be used together to provide both authentication and privacy. However, they cannot operate on their own. To function properly, they need the support of several other protocols and services (see <a class="xref" href="ch29s02.html#overview_of_ipsec_protocols_and_componen" title="Figure 29-1. Overview of IPsec protocols and components IPsec consists of two core protocols, AH and ESP, and three supporting components.">Figure 29-1</a>). The most important of these include the following:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-29-1041"/>Encryption/Hashing <a class="indexterm" id="idx-CHP-29-1042"/>Algorithms</strong></span> AH and ESP are generic and do not specify the exact mechanism used for encryption. This gives them the flexibility to work with a variety of such <a class="indexterm" id="idx-CHP-29-1043"/>algorithms and to negotiate which one to use as needed. Two common ones used with IPsec are <a class="indexterm" id="idx-CHP-29-1044"/><span class="emphasis"><em>Message Digest 5 (MD5)</em></span><a class="indexterm" id="idx-CHP-29-1045"/> and <a class="indexterm" id="idx-CHP-29-1046"/><span class="emphasis"><em>Secure Hash Algorithm 1 (SHA-1)</em></span>. These are also called <span class="emphasis"><em>hashing</em></span> algorithms because they work by computing a formula called a <span class="emphasis"><em>hash</em></span> based on input data and a key.</p><p><span class="strong"><strong>Security Policies, Security Associations, and Management Methods</strong></span> Since IPsec provides flexibility in letting different devices decide how they want to implement security, they require some means to keep track of the security relationships between themselves. This is done in IPsec using constructs called <span class="emphasis"><em>security policies</em></span> and <span class="emphasis"><em>security associations</em></span>, and by providing ways to exchange security association information.</p><p><span class="strong"><strong>Key Exchange Framework and Mechanism</strong></span> For two devices to exchange encrypted information, they need to be able to share keys for unlocking the encryption. They also need a way to exchange security association information. In IPsec, a protocol called the <span class="emphasis"><em>Internet Key Exchange (IKE)</em></span> provides these capabilities.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-157"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IPsec consists of a number of different components that work together to provide security services. The two main ones are protocols called the <span class="emphasis"><em>Authentication Header (AH)</em></span> and <span class="emphasis"><em>Encapsulating Security Payload (ESP)</em></span>, which provide authenticity and privacy to IP data in the form of special headers added to IP datagrams.</p></div><p>Well, that's at least a start at providing a framework for understanding what IPsec is all about and how the pieces fit together. You'll examine these components and protocols in more detail as you proceed through this chapter.</p></div></div>
<div class="sect1" title="IPsec Architectures and Implementation Methods"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_architectures_and_implementation_m"/>IPsec Architectures and Implementation Methods</h1></div></div></div><p>The main reason that IPsec is so powerful is that it provides security to IP, which is the basis for all other TCP/IP protocols. In protecting IP, you are protecting pretty much everything else in TCP/IP as well. An important issue, then, is how exactly do you get IPsec into IP? There are several implementation methods for deploying IPsec. These represent different ways that IPsec may modify the overall layer architecture of TCP/IP.</p><p>Three different implementation architectures are defined for IPsec in RFC 2401. The one you use depends on various factors including the version of IP used (IPv4 or IPv6), the requirements of the application, and other factors. These, in turn, rest on a primary implementation decision: Should IPsec be programmed into all hosts on a network, or just into certain routers or other intermediate devices? This is a design decision that must be based on the requirements of the network:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-29-1047"/>End-Host Implementation</strong></span> Putting IPsec into all host devices provides the most flexibility and security. It enables end-to-end security between any two devices on the network. However, there are many hosts on a typical network, so this means far more work than just implementing IPsec in routers.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-29-1048"/>Router Implementation</strong></span> This option is much less work because it means you make changes to only a few routers instead of hundreds or thousands of clients. It provides protection only between pairs of routers that implement IPsec, but this may be sufficient for certain applications such as VPNs. The routers can be used to provide protection for just the portion of the route that datagrams take outside the organization, thereby leaving connections between routers and local hosts unsecured (or possibly, secured by other means).</p><p>Three different architectures are defined that describe methods for how to get IPsec into the TCP/IP protocol stack: <a class="indexterm" id="idx-CHP-29-1049"/>integrated, bump in the stack, and bump in the wire.</p><div class="sect2" title="Integrated Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="integrated_architecture"/>Integrated Architecture</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1050"/>Under ideal circumstances, we would integrate IPsec's protocols and capabilities directly into IP itself. This is the most elegant solution, because it allows all IPsec security modes and capabilities to be provided just as easily as regular IP. No extra hardware or architectural layers are needed.</p><p>IPv6 was designed to support IPsec. Thus, it's a viable option for hosts or routers. With IPv4, integration would require making changes to the IP implementation on each device, which is often impractical (to say the least!).</p></div><div class="sect2" title="Bump in the Stack (BITS) Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="bump_in_the_stack_bits_architecture"/>Bump in the Stack (BITS) Architecture</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1051"/>In the <a class="indexterm" id="idx-CHP-29-1052"/>bump in the stack (BITS) technique, IPsec is made a separate architectural layer between IP and the data link layer. The cute name refers to the fact that IPsec is an extra element in the networking protocol stack, as you can see in <a class="xref" href="ch29s03.html#ipsec_bump_in_the_stack_bits_architectur" title="Figure 29-2. IPsec bump in the stack (BITS) architecture In this type of IPsec implementation, IPsec becomes a separate layer in the TCP/IP stack. It is implemented as software that sits below IP and adds security protection to datagrams created by the IP layer.">Figure 29-2</a>. IPsec intercepts IP datagrams as they are passed down the protocol stack, provides security, and passes them to the data link layer.</p><div class="figure"><a id="ipsec_bump_in_the_stack_bits_architectur"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30382"/><img alt="IPsec bump in the stack (BITS) architecture In this type of IPsec implementation, IPsec becomes a separate layer in the TCP/IP stack. It is implemented as software that sits below IP and adds security protection to datagrams created by the IP layer." src="httpatomoreillycomsourcenostarchimages287915.png.jpg"/></div></div><p class="title">Figure 29-2. IPsec bump in the stack (BITS) architecture In this type of IPsec implementation, IPsec becomes a separate layer in the TCP/IP stack. It is implemented as software that sits below IP and adds security protection to datagrams created by the IP layer.</p></div><p><a class="indexterm" id="idx-CHP-29-1053"/>The advantage of this technique is that IPsec can be retrofitted to any IP device, since the IPsec functionality is separate from IP. The disadvantage is that there is a duplication of effort compared to the integrated architecture. BITS is generally used for IPv4 hosts.</p></div><div class="sect2" title="Bump in the Wire (BITW) Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="bump_in_the_wire_bitw_architecture"/>Bump in the Wire (BITW) Architecture</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1054"/>In the <a class="indexterm" id="idx-CHP-29-1055"/>bump in the wire (BITW) method, we add a hardware device that provides IPsec services. For example, suppose we have a company with two sites. Each has a network that connects to the Internet using a router that is not capable of IPsec functions. We can interpose a special IPsec device between the router and the Internet at both sites, as shown in <a class="xref" href="ch29s03.html#ipsec_bump_in_the_wire_bitw_architecture" title="Figure 29-3. IPsec bump in the wire (BITW) architecture In this IPsec architecture, IPsec is actually implemented in separate devices that sit between the devices that wish to communicate securely. These repackage insecure IP datagrams for transport over the public Internet.">Figure 29-3</a>. These devices will then intercept outgoing datagrams, add IPsec protection to them, and strip it off incoming datagrams.</p><div class="figure"><a id="ipsec_bump_in_the_wire_bitw_architecture"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30413"/><img alt="IPsec bump in the wire (BITW) architecture In this IPsec architecture, IPsec is actually implemented in separate devices that sit between the devices that wish to communicate securely. These repackage insecure IP datagrams for transport over the public Internet." src="httpatomoreillycomsourcenostarchimages287917.png.jpg"/></div></div><p class="title">Figure 29-3. IPsec bump in the wire (BITW) architecture In this IPsec architecture, IPsec is actually implemented in separate devices that sit between the devices that wish to communicate securely. These repackage insecure IP datagrams for transport over the public Internet.</p></div><p><a class="indexterm" id="idx-CHP-29-1056"/>Just as BITS lets you add IPsec to legacy hosts, BITW can retrofit non-IPsec routers to provide security benefits. The disadvantages are complexity and cost.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-158"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Three different architectures or implementation models are defined for IPsec. The best is integrated architecture, in which IPsec is built into the IP layer of devices directly. The other two are <span class="emphasis"><em>bump in the stack (BITS)</em></span> and <a class="indexterm" id="idx-CHP-29-1057"/><span class="emphasis"><em>bump in the wire (BITW)</em></span>, which are ways of layering IPsec underneath regular IP, using software and hardware solutions, respectively.</p></div><p>As you will see in the next section, the choice of architecture has an important impact on which of the two IPsec modes can be used. Incidentally, even though BITS and BITW seem quite different, they are actually do the same thing. In the case of BITS, we have an extra software layer that adds security to existing IP datagrams; in BITW, distinct hardware devices do this same job. In both cases, the result is the same, and the implications on the choice of IPsec mode is likewise the same.</p></div></div>
<div class="sect1" title="IPsec Modes: Transport and Tunnel"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_modes_transport_and_tunnel"/>IPsec Modes: Transport and Tunnel</h1></div></div></div><p>You just saw that three different basic implementation architectures could be used to provide IPsec facilities to TCP/IP networks. The choice of which implementation you use, as well as whether you implement in end hosts or routers, impacts the specific way that IPsec functions. Two specific <a class="indexterm" id="idx-CHP-29-1058"/>modes of operation that are related to these architectures are defined for IPsec. They are called <a class="indexterm" id="idx-CHP-29-1059"/><span class="emphasis"><em>transport mode</em></span> and <a class="indexterm" id="idx-CHP-29-1060"/><span class="emphasis"><em>tunnel mode</em></span>.</p><p>IPsec modes are closely related to the function of the two core protocols, AH and ESP. Both of these protocols provide protection by adding a header (and possibly other fields) containing security information to a datagram. The choice of mode does not affect the method by which each generates its header, but rather, changes what specific parts of the IP datagram are protected and how the headers are arranged to accomplish this. In essence, the mode really describes, not prescribes, how AH or ESP do their thing. It is used as the basis for defining other constructs, such as security associations (SAs).</p><div class="sect2" title="Transport Mode"><div class="titlepage"><div><div><h2 class="title"><a id="transport_mode"/>Transport Mode</h2></div></div></div><p>As its name suggests, in transport mode, the protocol protects the message passed down to IP from the transport layer. The message is processed by AH and/or ESP, and the appropriate header(s) are added in front of the transport (UDP or TCP) header. The IP header is then added in front of that by IP.</p><p>Another way of looking at this is as follows: Normally, the transport layer packages data for transmission and sends it to IP. From IP's perspective, this transport layer message is the payload of the IP datagram. When IPsec is used in transport mode, the IPsec header is applied only over this IP payload, not the IP header. The AH and ESP headers appear between the original, single IP header and the IP payload. This is illustrated in <a class="xref" href="ch29s04.html#ipsec_transport_mode_operation_when_ipse" title="Figure 29-4. IPsec transport mode operation When IPsec operates in transport mode, it is integrated with IP and used to transport the upper layer (TCP/UDP) message directly. After processing, the datagram has just one IP header that contains the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in Figure 29-5.">Figure 29-4</a>.</p></div><div class="sect2" title="Tunnel Mode"><div class="titlepage"><div><div><h2 class="title"><a id="tunnel_mode"/>Tunnel Mode</h2></div></div></div><p>In tunnel mode, IPsec is used to protect a completely encapsulated IP datagram after the IP header has already been applied to it. The IPsec headers appear in front of the original IP header, and then a new IP header is added in front of the IPsec header. That is to say, the entire original IP datagram is secured and then encapsulated within another IP datagram. This is shown in <a class="xref" href="ch29s04.html#ipsec_tunnel_mode_operation_ipsec_tunnel" title="Figure 29-5. IPsec tunnel mode operation IPsec tunnel mode is so named because it represents an encapsulation of a complete IP datagram, thereby forming a virtual tunnel between IPsec-capable devices. The IP datagram is passed to IPsec, where a new IP header is created with the AH and ESP IPsec headers added. Contrast this to transport mode, shown in Figure 29-4.">Figure 29-5</a>.</p></div><div class="sect2" title="Comparing Transport and Tunnel Modes"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_transport_and_tunnel_modes"/>Comparing Transport and Tunnel Modes</h2></div></div></div><p>The bottom line in understanding the difference between the two IPsec modes is this: Tunnel mode protects the original IP datagram as a whole, header and all, while transport mode does not. Thus, in general terms, the order of the headers is as follows:</p><p><span class="strong"><strong>Transport Mode</strong></span> IP header, IPsec headers (AH and/or ESP), IP payload (including transport header)</p><p><span class="strong"><strong>Tunnel Mode</strong></span> New IP header, IPsec headers (AH and/or ESP), old IP header, IP payload</p><div class="figure"><a id="ipsec_transport_mode_operation_when_ipse"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30506"/><img alt="IPsec transport mode operation When IPsec operates in transport mode, it is integrated with IP and used to transport the upper layer (TCP/UDP) message directly. After processing, the datagram has just one IP header that contains the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in ." src="httpatomoreillycomsourcenostarchimages287919.png.jpg"/></div></div><p class="title">Figure 29-4. IPsec transport mode operation When IPsec operates in transport mode, it is integrated with IP and used to transport the upper layer (TCP/UDP) message directly. After processing, the datagram has just one IP header that contains the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in <a class="xref" href="ch29s04.html#ipsec_tunnel_mode_operation_ipsec_tunnel" title="Figure 29-5. IPsec tunnel mode operation IPsec tunnel mode is so named because it represents an encapsulation of a complete IP datagram, thereby forming a virtual tunnel between IPsec-capable devices. The IP datagram is passed to IPsec, where a new IP header is created with the AH and ESP IPsec headers added. Contrast this to transport mode, shown in Figure 29-4.">Figure 29-5</a>.</p></div><p>Again, this is a simplified view of how IPsec datagrams are constructed; the reality is significantly more complex. The exact way that the headers are arranged in an IPsec datagram in both <a class="indexterm" id="idx-CHP-29-1061"/>transport and tunnel modes depends on which version of IP is being used. IPv6 uses extension headers that must be arranged in a particular way when IPsec is used. The header placement also depends on which IPsec protocol is being used, AH or ESP. Note that it is also possible to apply both AH and ESP to the same datagram; if so, the AH header always appears before the ESP header.</p><p>There are thus three variables and eight basic combinations of mode (tunnel or transport), IP version (IPv4 or IPv6) and protocol (AH or ESP). The coming discussions of AH and ESP describe the four format combinations of transport/tunnel mode and IPv4/IPv6 applicable to each protocol. Note that ESP also includes an ESP trailer that goes after the data protected.</p><p>You could probably tell by reading these descriptions how the two modes relate to the choice of IPsec architecture you looked at earlier. <a class="indexterm" id="idx-CHP-29-1062"/>Transport mode requires that IPsec be integrated into IP, because AH/ESP must be applied as the original IP packaging is performed on the transport layer message. This is often the choice for implementations requiring end-to-end security with hosts that run IPsec directly.</p><div class="figure"><a id="ipsec_tunnel_mode_operation_ipsec_tunnel"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30534"/><img alt="IPsec tunnel mode operation IPsec tunnel mode is so named because it represents an encapsulation of a complete IP datagram, thereby forming a virtual tunnel between IPsec-capable devices. The IP datagram is passed to IPsec, where a new IP header is created with the AH and ESP IPsec headers added. Contrast this to transport mode, shown in ." src="httpatomoreillycomsourcenostarchimages287921.png.jpg"/></div></div><p class="title">Figure 29-5. IPsec tunnel mode operation IPsec tunnel mode is so named because it represents an encapsulation of a complete IP datagram, thereby forming a virtual tunnel between IPsec-capable devices. The IP datagram is passed to IPsec, where a new IP header is created with the AH and ESP IPsec headers added. Contrast this to transport mode, shown in <a class="xref" href="ch29s04.html#ipsec_transport_mode_operation_when_ipse" title="Figure 29-4. IPsec transport mode operation When IPsec operates in transport mode, it is integrated with IP and used to transport the upper layer (TCP/UDP) message directly. After processing, the datagram has just one IP header that contains the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in Figure 29-5.">Figure 29-4</a>.</p></div><p><a class="indexterm" id="idx-CHP-29-1063"/><a class="indexterm" id="idx-CHP-29-1064"/>Tunnel mode represents an encapsulation of IP within the combination of IP plus IPsec. Thus, it corresponds with the BITS and BITW implementations, where IPsec is applied after IP has processed higher-layer messages and has already added its header. <a class="indexterm" id="idx-CHP-29-1065"/>Tunnel mode is a common choice for VPN implementations, which are based on the <a class="indexterm" id="idx-CHP-29-1066"/>tunneling of IP datagrams through an unsecured network such as the Internet.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-159"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IPsec has two basic modes of operation. In <span class="emphasis"><em>transport mode</em></span>, IPsec AH and ESP headers are added as the original IP datagram is created. Transport mode is associated with integrated IPsec architectures. In <span class="emphasis"><em>tunnel mode</em></span>, the original IP datagram is created normally, and then the entire datagram is encapsulated into a new IP datagram containing the AH/ESP IPsec headers. Tunnel mode is most commonly used with <span class="emphasis"><em>bump in the stack (BITS)</em></span> and <span class="emphasis"><em>bump in the wire (BITW)</em></span> implementations.</p></div></div></div>
<div class="sect1" title="IPsec Security Constructs"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_security_constructs"/>IPsec Security Constructs</h1></div></div></div><p>Important IPsec <a class="indexterm" id="idx-CHP-29-1067"/>security constructs include <a class="indexterm" id="idx-CHP-29-1068"/>security associations, the security association database, security policies, the security policy database, selectors, and the security parameter index. These items are all closely related and essential to understand before you begin looking at the core IPsec protocols. These constructs are used to guide the operation of IPsec in a general way and particularly to guide exchanges between devices. The constructs control how IPsec works and ensure that each datagram coming into or leaving an IPsec-capable device is treated properly.</p><div class="sect2" title="Security Policies, Security Associations, and Associated Databases"><div class="titlepage"><div><div><h2 class="title"><a id="security_policies_security_associations_"/>Security Policies, Security Associations, and Associated Databases</h2></div></div></div><p>Let's begin by considering the problem of how to apply security in a device that may be handling many different exchanges of datagrams with others. There is overhead involved in providing security, so you do not want to do it for every message that comes in or out. Some types of messages may need more security; others may need less. Also, exchanges with certain devices may require different processing than others.</p><p>To manage all of this complexity, IPsec is equipped with a flexible, powerful way of specifying how different types of datagrams should be handled. To understand how this works, you must first define the following two important logical concepts:</p><p><span class="strong"><strong>Security Policies and the Security Policy Database (<a class="indexterm" id="idx-CHP-29-1069"/>SPD)</strong></span> A <span class="emphasis"><em>security policy</em></span> is a rule that is programmed into the IPsec implementation. It tells the implementation how to process different datagrams received by the device. For example, security policies decide if a particular packet needs to be processed by IPsec or not. AH and ESP entirely bypass those that do not need processing. If security is required, the security policy provides general guidelines for how it should be provided, and if necessary, links to more specific detail. Security policies for a device are stored in the device's <span class="emphasis"><em>security policy database (SPD)</em></span>.</p><p><span class="strong"><strong>Security Associations (<a class="indexterm" id="idx-CHP-29-1070"/>SAs) and the Security Association Database (<a class="indexterm" id="idx-CHP-29-1071"/>SAD)</strong></span> A security association (SA) is a set of security information that describes a particular kind of secure connection between one device and another. You can consider it a contract, if you will, that specifies the particular security mechanisms that are used for secure communications between the two. A device's security associations are contained in its <span class="emphasis"><em>security association database (SAD)</em></span>.</p><p>It's often hard to distinguish between the SPD and the SAD, because they are similar in concept. The main difference between them is that security policies are general, while security associations are more specific. To determine what to do with a particular datagram, a device first checks the SPD. The security policies in the SPD may reference a particular SA in the SAD. If so, the device will look up that SA and use it for processing the datagram.</p></div><div class="sect2" title="Selectors"><div class="titlepage"><div><div><h2 class="title"><a id="selectors"/>Selectors</h2></div></div></div><p>One issue I haven't covered yet is how a device determines what security policies or SAs to use for a specific datagram. Again here, IPsec defines a very flexible system that lets each security association define a set of rules for choosing datagrams that the SA applies to. Each of these rule sets is called a <span class="emphasis"><em>selector</em></span>. For example, you might define a selector that says that a particular range of values in the Source Address of a datagram, combined with another value in the Destination Address, means that a specific SA must be used for the datagram.</p></div><div class="sect2" title="Security Association Triples and Security Parameter Index (SPI)"><div class="titlepage"><div><div><h2 class="title"><a id="security_association_triples_and_securit"/>Security Association Triples and Security Parameter Index (SPI)</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1072"/>Each secure communication that a device makes to another requires that an SA be established. SAs are unidirectional, so each one only handles either inbound or outbound traffic for a particular device. This allows the level of security for a flow from Device A to Device B to be different than the level for traffic coming from Device B to Device A. In a bidirectional communication of this sort, both Device A and Device B would have two SAs; Device A would have SAs that you could call SAdeviceBin and SAdeviceBout. Device B would have SAs SAdeviceAin and SAdeviceAout.</p><p>SAs don't actually have names, however. They are instead defined by a set of three parameters, called a <span class="emphasis"><em>triple</em></span>:</p><p><span class="strong"><strong>Security Parameter Index (<a class="indexterm" id="idx-CHP-29-1073"/>SPI)</strong></span> A 32-bit number that is chosen to uniquely identify a particular SA for any connected device. The SPI is placed in <a class="indexterm" id="idx-CHP-29-1074"/>AH or ESP datagrams and thus links each secure datagram to the security association. It is used by the recipient of a transmission so it knows what SA governs the datagram.</p><p><span class="strong"><strong>IP Destination Address</strong></span> The address of the device for which the SA is established.</p><p><span class="strong"><strong>Security Protocol Identifier</strong></span> Specifies whether this association is for AH or ESP. If both are in use with this device, they have separate SAs.</p><p>As you can see, the two security protocols AH and ESP are dependent on SAs, security policies, and the various databases that control the operation of those SAs and policies. Management of these databases is important, but it's another complex subject entirely. Generally, SAs can either be set up manually (which is of course extra work) or you can deploy an automated system using a protocol like IKE (discussed near the end of this chapter).</p><p>Confused? I don't blame you, despite my best efforts, and remember that this is all highly simplified. Welcome to the wonderful world of networking security. If you are ever besieged by insomnia, I highly recommend RFC 2401!</p></div></div>
<div class="sect1" title="IPsec Authentication Header (AH)"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_authentication_header_ah"/>IPsec Authentication Header (AH)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-29-1075"/>As I mentioned earlier in this chapter, AH is one of the two core security protocols in IPsec. This is another protocol whose name has been well chosen. It provides <span class="emphasis"><em>authentication</em></span> of either all or part of the contents of a datagram through the addition of a <span class="emphasis"><em>header</em></span> that is calculated based on the values in the datagram. The parts of the datagram that are used for the calculation, and the placement of the header, depend on the mode (tunnel or transport) and the version of IP (IPv4 or IPv6).</p><p>The operation of AH is surprisingly simple, especially for any protocol that has anything to do with network security. The simplicity is analogous to the algorithms used to calculate checksums or perform cyclic redundancy (CRC) checks for error detection. In those cases, the sender uses a standard algorithm to compute a checksum or CRC code based on the contents of a message. This computed result is transmitted along with the original data to the destination, which repeats the calculation and discards the message if any discrepancy is found between its calculation and the one done by the source.</p><p>This is the same idea behind AH, except that instead of using a simple algorithm known to everyone, it uses a special hashing algorithm and a specific key known only to the source and the destination. An SA between two devices specifies these particulars, so that the source and destination know how to perform the computation but nobody else can. On the source device, AH performs the computation and puts the result (called the <span class="emphasis"><em>integrity check value</em></span>, or <span class="emphasis"><em>ICV</em></span>) into a special header with other fields for transmission. The destination device does the same calculation using the key that the two devices share. This enables the device to see immediately if any of the fields in the original datagram were modified (due to either error or malice).</p><p>Just as a checksum doesn't change the original data, neither does the ICV calculation change the original data. The presence of the AH header allows us to verify the integrity of the message, but doesn't encrypt it. Thus, AH provides <span class="emphasis"><em>authentication</em></span> but not <span class="emphasis"><em>privacy</em></span> (that's what ESP is for).</p><div class="sect2" title="AH Datagram Placement and Linking"><div class="titlepage"><div><div><h2 class="title"><a id="ah_datagram_placement_and_linking"/>AH Datagram Placement and Linking</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1076"/>The calculation of AH is similar for both IPv4 and IPv6. One difference is in the exact mechanism used for placing the header into the datagram and for linking the headers together. I'll describe IPv6 first because it is simpler, and because AH was really designed to fit into its mechanism for this.</p><div class="sect3" title="IPv6 AH Placement and Linking"><div class="titlepage"><div><div><h3 class="title"><a id="ipv6_ah_placement_and_linking"/>IPv6 AH Placement and Linking</h3></div></div></div><p>In IPv6, the AH is inserted into the IP datagram as an extension header, following the normal IPv6 rules for extension header linking. It is linked by the previous header (extension or main), which puts the assigned value for the AH header (51) into its Next Header field. The AH header then links to the next extension header or the transport layer header using its Next Header field.</p><p>In transport mode, the AH is placed into the main IP header and appears before any Destination Options header that contains options intended for the final destination, and before an ESP header if present, but after any other extension headers. In tunnel mode, it appears as an extension header of the new IP datagram that encapsulates the original one being tunneled. This is shown graphically in <a class="xref" href="ch29s06.html#ipv6_datagram_format_with_ipsec_authenti" title="Figure 29-6. IPv6 datagram format with IPsec Authentication Header (AH) This is an example of an IPv6 datagram with two extension headers that are linked using the standard IPv6 mechanism (see Figure 26-3 in Chapter 26). When AH is applied in transport mode, it is simply added as a new extension header (as shown in dark shading) that goes between the Routing extension header and the Destination Options header. In tunnel mode, the entire original datagram is encapsulated into a new IPv6 datagram that contains the AH header. In both cases, the Next Header fields are used to link each header one to the next. Note the use of Next Header value 41 in tunnel mode, which is the value for the encapsulated IPv6 datagram.">Figure 29-6</a>.</p><div class="figure"><a id="ipv6_datagram_format_with_ipsec_authenti"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30736"/><img alt="IPv6 datagram format with IPsec Authentication Header (AH) This is an example of an IPv6 datagram with two extension headers that are linked using the standard IPv6 mechanism (see in ). When AH is applied in transport mode, it is simply added as a new extension header (as shown in dark shading) that goes between the Routing extension header and the Destination Options header. In tunnel mode, the entire original datagram is encapsulated into a new IPv6 datagram that contains the AH header. In both cases, the Next Header fields are used to link each header one to the next. Note the use of Next Header value 41 in tunnel mode, which is the value for the encapsulated IPv6 datagram." src="httpatomoreillycomsourcenostarchimages287923.png.jpg"/></div></div><p class="title">Figure 29-6. IPv6 datagram format with IPsec Authentication Header (AH) This is an example of an IPv6 datagram with two extension headers that are linked using the standard IPv6 mechanism (see <a class="xref" href="ch26s03.html#ipv6_extension_header_linking_using_the_" title="Figure 26-3. IPv6 extension header linking using the Next Header field The Next Header field allows a device to more easily process the headers in a received IPv6 datagram. When a datagram has no extension headers, the &quot;next header&quot; is actually the header at the start of the IP Data field, which, in this case, is a TCP header with a value of 6. This is the same way the Protocol field is used in IPv4. When extension headers do appear, the Next Header value of each header contains a number indicating the type of the following header in the datagram, so they logically chain together the headers.">Figure 26-3</a> in <a class="xref" href="ch26.html" title="Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 26</a>). When AH is applied in transport mode, it is simply added as a new extension header (as shown in dark shading) that goes between the Routing extension header and the Destination Options header. In tunnel mode, the entire original datagram is encapsulated into a new IPv6 datagram that contains the AH header. In both cases, the Next Header fields are used to link each header one to the next. Note the use of Next Header value 41 in tunnel mode, which is the value for the encapsulated IPv6 datagram.</p></div></div><div class="sect3" title="IPv4 AH Placement and Linking"><div class="titlepage"><div><div><h3 class="title"><a id="ipv4_ah_placement_and_linking"/>IPv4 AH Placement and Linking</h3></div></div></div><p>In IPv4, a method that is similar to the IPv6 header-linking technique is employed. In an IPv4 <a class="indexterm" id="idx-CHP-29-1077"/>datagram, the Protocol field indicates the identity of the higher-layer protocol (typically TCP or UDP) that's carried in the datagram. As such, this field points to the next header, which is at the front of the IP payload. AH takes this value and puts it into its Next Header field, and then places the protocol value for AH itself (51 in dotted decimal) into the IP Protocol field. This makes the IP header point to the AH, which then points to whatever the IP datagram pointed to before.</p><p>Again, in transport mode, the AH header is added after the main IP header of the original datagram; in tunnel mode it is added after the new IP header that encapsulates the original datagram that's being tunneled. This is shown in <a class="xref" href="ch29s06.html#ipv4_datagram_format_with_ipsec_ah_here_" title="Figure 29-7. IPv4 datagram format with IPsec AH Here is an example of an IPv4 datagram; it may or may not contain IPv4 options (which are not distinct entities as they are in IPv6). In transport mode, the AH header is added between the IP header and the IP data; the Protocol field of the IP header points to it, while its Next Header field contains the IP header's prior protocol value (in this case 6, for TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4 datagram that includes the AH header. Note that in tunnel mode, the AH header uses the value 4 (which means IPv4) in its Next Header field.">Figure 29-7</a>.</p><div class="figure"><a id="ipv4_datagram_format_with_ipsec_ah_here_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30761"/><img alt="IPv4 datagram format with IPsec AH Here is an example of an IPv4 datagram; it may or may not contain IPv4 options (which are not distinct entities as they are in IPv6). In transport mode, the AH header is added between the IP header and the IP data; the Protocol field of the IP header points to it, while its Next Header field contains the IP header's prior protocol value (in this case 6, for TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4 datagram that includes the AH header. Note that in tunnel mode, the AH header uses the value 4 (which means IPv4) in its Next Header field." src="httpatomoreillycomsourcenostarchimages287925.png"/></div></div><p class="title">Figure 29-7. IPv4 datagram format with IPsec AH Here is an example of an IPv4 datagram; it may or may not contain IPv4 options (which are not distinct entities as they are in IPv6). In transport mode, the AH header is added between the IP header and the IP data; the Protocol field of the IP header points to it, while its Next Header field contains the IP header's prior protocol value (in this case 6, for TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4 datagram that includes the AH header. Note that in tunnel mode, the AH header uses the value 4 (which means IPv4) in its Next Header field.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-160"/>Tip</h3><p><a class="indexterm" id="idx-CHP-29-1078"/><span class="strong"><strong>KEY CONCEPT</strong></span> The IPsec <span class="emphasis"><em>Authentication Header (AH)</em></span> protocol allows the recipient of a datagram to verify its authenticity. It is implemented as a header that's added to an IP datagram that contains an <span class="emphasis"><em>integrity check value (ICV)</em></span>, which is computed based on the values of the fields in the datagram. The recipient can use this value to ensure that the data has not been changed in transit. AH does not encrypt data and thus does not ensure the privacy of transmissions.</p></div></div></div><div class="sect2" title="AH Format"><div class="titlepage"><div><div><h2 class="title"><a id="ah_format"/>AH Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1079"/>The <a class="indexterm" id="idx-CHP-29-1080"/>format of AH is described in <a class="xref" href="ch29s06.html#ipsec_authentication_header_ah_format" title="Table 29-2. IPsec Authentication Header (AH) Format">Table 29-2</a> and illustrated in <a class="xref" href="ch29s06.html#ipsec_authentication_header_ah_for-id001" title="Figure 29-8. IPsec Authentication Header (AH) format">Figure 29-8</a>.</p><div class="table"><a id="ipsec_authentication_header_ah_format"/><p class="title">Table 29-2. IPsec Authentication Header (AH) Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPsec Authentication Header (AH) Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next Header</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains the protocol number of the next header after the AH. Used to link headers together.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Payload Len</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Despite its name, this field measures the length of the authentication header itself, not the payload. (I wonder what the history is behind that!) It is measured in 32-bit units, with 2 subtracted for consistency with how header lengths are normally calculated in IPv6.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SPI</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 32-bit value that, when combined with the destination address and security protocol type (which is obviously the one for AH here), identifies the security association (SA) that will be used for this datagram. (SAs are discussed earlier in this chapter.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>A counter field that is initialized to zero when an SA is formed between two devices, and then incremented for each datagram sent using that SA. This uniquely identifies each datagram on an SA and is used to provide protection against replay attacks by preventing the retransmission of captured datagrams.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Authentication Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Contains the result of the hashing algorithm, called the integrity check value (ICV), performed by the AH protocol.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ipsec_authentication_header_ah_for-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e30890"/><img alt="IPsec Authentication Header (AH) format" src="httpatomoreillycomsourcenostarchimages287927.png"/></div></div><p class="title">Figure 29-8. IPsec Authentication Header (AH) format</p></div><p>The size of the <a class="indexterm" id="idx-CHP-29-1081"/>Authentication Data field is variable to support different datagram lengths and hashing algorithms. Its total length must be a multiple of 32 bits. Also, the entire <a class="indexterm" id="idx-CHP-29-1082"/>header must be a multiple of either 32 bits (for IPv4) or 64 bits (for IPv6), so additional padding may be added to the Authentication Data field if necessary.</p><p>You may also notice that no IP addresses appear in the header, which is a prerequisite for it being the same for both IPv4 and IPv6.</p></div></div>
<div class="sect1" title="IPsec Encapsulating Security Payload (ESP)"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_encapsulating_security_payload_esp"/>IPsec Encapsulating Security Payload (ESP)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-29-1083"/>The IPsec AH provides integrity authentication services to IPsec-capable devices so that they can verify that messages are received intact from other devices. For many applications, however, this is only one piece of the puzzle. We want to not only protect against intermediate devices changing the datagrams, but also to protect against them examining their contents as well. For this level of private communication, AH is not enough; we need to use the ESP protocol.</p><p>The main job of ESP is to provide the privacy we seek for IP datagrams by encrypting them. An encryption algorithm combines the data in the datagram with a key to transform it into an encrypted form. This is then repackaged using a special format that you will see shortly, and then transmitted to the destination, which decrypts it using the same algorithm. ESP also sports its own authentication scheme like the one used in AH, or it can be used in conjunction with AH.</p><div class="sect2" title="ESP Fields"><div class="titlepage"><div><div><h2 class="title"><a id="esp_fields"/>ESP Fields</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1084"/>ESP has several fields that are the same as those used in AH, but it packages its fields in a very different way. Instead of having just a header, it divides its fields into three components:</p><p><span class="strong"><strong>ESP Header</strong></span> This contains two fields, SPI and Sequence Number, and comes before the encrypted data. Its placement depends on whether ESP is used in transport mode or tunnel mode, as explained earlier in this chapter.</p><p><span class="strong"><strong>ESP <a class="indexterm" id="idx-CHP-29-1085"/>Trailer</strong></span> This section is placed after the encrypted data. It contains padding that is used to align the encrypted data through a Padding and Pad Length field. Interestingly, it also contains the Next Header field for ESP.</p><p><span class="strong"><strong>ESP Authentication Data</strong></span> This field contains an ICV that's computed in a manner that's similar to how the AH protocol works. The field is used when ESP's optional authentication feature is employed.</p><p>There are two reasons why these fields are broken into pieces like this. The first is that some encryption algorithms require the data to be encrypted to have a certain block size, and so padding must appear after the data and not before it. That's why padding appears in the ESP <a class="indexterm" id="idx-CHP-29-1086"/>Trailer field. The second is that the ESP Authentication Data appears separately because it is used to authenticate the rest of the encrypted datagram after encryption. This means that it cannot appear in the ESP Header or ESP Trailer.</p></div><div class="sect2" title="ESP Operations and Field Use"><div class="titlepage"><div><div><h2 class="title"><a id="esp_operations_and_field_use"/>ESP Operations and Field Use</h2></div></div></div><p>This is still a bit boggling so I'm going to try to explain this procedurally by considering three basic steps performed by ESP: calculating the header, then the <a class="indexterm" id="idx-CHP-29-1087"/>trailer, and then the Authentication field.</p><div class="sect3" title="Header Calculation and Placement"><div class="titlepage"><div><div><h3 class="title"><a id="header_calculation_and_placement"/>Header Calculation and Placement</h3></div></div></div><p><a class="indexterm" id="idx-CHP-29-1088"/>The first thing to consider is how the ESP header is placed. This is similar to how AH works and depends on the IP version, as follows:</p><p><span class="strong"><strong>IPv6</strong></span> The ESP Header field is inserted into the IP datagram as an extension header, following the normal IPv6 rules for extension-header linking. In transport mode, it appears before a Destination Options header that contains options intended for the final destination, but after any other extension headers, if present. In tunnel mode, it appears as an extension header of the new IP datagram that encapsulates the original one being tunneled. This is shown in <a class="xref" href="ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here" title="Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of an IPv6 datagram with two extension headers that you saw in Figure 29-6. When ESP is applied in transport mode, the ESP Header field is added to the existing datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the entire encapsulated IPv6 datagram. Note the encryption and authentication coverage in each case, and also how the Next Header field points back into the datagram since it appears in the ESP Trailer.">Figure 29-9</a>.</p><p><span class="strong"><strong>IPv4</strong></span> As with AH, the ESP Header field is placed after the normal IPv4 header. In transport mode, it appears after the IP header of the original datagram; in tunnel mode, it appears after the IP header of the new IP datagram that's encapsulating the original one. You can see this in <a class="xref" href="ch29s07.html#ipv4_datagram_format_with_ipsec_esp_here" title="Figure 29-10. IPv4 datagram format with IPsec ESP Here is the same sample IPv4 datagram that you saw in Figure 29-7. When ESP processes this datagram in transport mode, the ESP Header field is placed between the IPv4 header and data, with the ESP Trailer and ESP Authentication Data fields following. In tunnel mode, the entire original IPv4 datagram is surrounded by these ESP components, rather than just the IPv4 data. Again, as in Figure 29-9, note the encryption and authentication coverage, and how the Next Header field points back to specify the identity of the encrypted data or datagram.">Figure 29-10</a>.</p></div><div class="sect3" title="Trailer Calculation and Placement"><div class="titlepage"><div><div><h3 class="title"><a id="trailer_calculation_and_placement"/>Trailer Calculation and Placement</h3></div></div></div><p>The ESP Trailer field is appended to the data that will be encrypted. ESP then performs the encryption. The payload (TCP/UDP message or encapsulated IP datagram) and the ESP trailer are both encrypted, but the ESP header is not. Note again that any other IP headers that appear between the ESP header and the payload are also encrypted. In IPv6, this can include a Destination Options extension header.</p><p>Normally, the Next Header field would appear in the ESP Header and would be used to link the ESP Header to the header that comes after it. However, the Next Header field in ESP appears in the trailer and not the header, which makes the linking seem a bit strange in ESP. The method is basically the same as what's used in AH and in IPv6 in general, with the Next Header and Protocol fields being used to tie everything together. However, in ESP the Next Header field appears <span class="emphasis"><em>after</em></span> the encrypted data, and so it points back to one of the following: a Destination Options extension header (if present), a TCP/UDP header (in transport mode), or an IPv4/IPv6 header (in tunnel mode). This is also shown in Figures <a class="xref" href="ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here" title="Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of an IPv6 datagram with two extension headers that you saw in Figure 29-6. When ESP is applied in transport mode, the ESP Header field is added to the existing datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the entire encapsulated IPv6 datagram. Note the encryption and authentication coverage in each case, and also how the Next Header field points back into the datagram since it appears in the ESP Trailer.">Figure 29-9</a> and <a class="xref" href="ch29s07.html#ipv4_datagram_format_with_ipsec_esp_here" title="Figure 29-10. IPv4 datagram format with IPsec ESP Here is the same sample IPv4 datagram that you saw in Figure 29-7. When ESP processes this datagram in transport mode, the ESP Header field is placed between the IPv4 header and data, with the ESP Trailer and ESP Authentication Data fields following. In tunnel mode, the entire original IPv4 datagram is surrounded by these ESP components, rather than just the IPv4 data. Again, as in Figure 29-9, note the encryption and authentication coverage, and how the Next Header field points back to specify the identity of the encrypted data or datagram.">Figure 29-10</a>.</p></div><div class="sect3" title="ESP Authentication Field Calculation and Placement"><div class="titlepage"><div><div><h3 class="title"><a id="esp_authentication_field_calculation_and"/>ESP Authentication Field Calculation and Placement</h3></div></div></div><p><a class="indexterm" id="idx-CHP-29-1089"/>If the optional ESP authentication feature is being used, it is computed over the entire ESP datagram (except the Authentication Data field itself, of course). This includes the ESP header, payload, and trailer.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-161"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The IPsec ESP protocol allows the contents of a datagram to be encrypted, which ensures that only the intended recipient is able to see the data. ESP is implemented using three components: an <span class="emphasis"><em>ESP Header</em></span> that's added to the front of a protected datagram, an <span class="emphasis"><em>ESP Trailer</em></span> that follows the protected data, and an optional <span class="emphasis"><em>ESP Authentication</em></span> Data field that provides authentication services similar to those provided by AH.</p></div><div class="figure"><a id="ipv6_datagram_format_with_ipsec_esp_here"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e31045"/><img alt="IPv6 datagram format with IPsec ESP Here is the same example of an IPv6 datagram with two extension headers that you saw in . When ESP is applied in transport mode, the ESP Header field is added to the existing datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the entire encapsulated IPv6 datagram. Note the encryption and authentication coverage in each case, and also how the Next Header field points back into the datagram since it appears in the ESP Trailer." src="httpatomoreillycomsourcenostarchimages287929.png.jpg"/></div></div><p class="title">Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of an IPv6 datagram with two extension headers that you saw in <a class="xref" href="ch29s06.html#ipv6_datagram_format_with_ipsec_authenti" title="Figure 29-6. IPv6 datagram format with IPsec Authentication Header (AH) This is an example of an IPv6 datagram with two extension headers that are linked using the standard IPv6 mechanism (see Figure 26-3 in Chapter 26). When AH is applied in transport mode, it is simply added as a new extension header (as shown in dark shading) that goes between the Routing extension header and the Destination Options header. In tunnel mode, the entire original datagram is encapsulated into a new IPv6 datagram that contains the AH header. In both cases, the Next Header fields are used to link each header one to the next. Note the use of Next Header value 41 in tunnel mode, which is the value for the encapsulated IPv6 datagram.">Figure 29-6</a>. When ESP is applied in transport mode, the ESP Header field is added to the existing datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the entire encapsulated IPv6 datagram. Note the encryption and authentication coverage in each case, and also how the Next Header field points back into the datagram since it appears in the ESP Trailer.</p></div><div class="figure"><a id="ipv4_datagram_format_with_ipsec_esp_here"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e31057"/><img alt="IPv4 datagram format with IPsec ESP Here is the same sample IPv4 datagram that you saw in . When ESP processes this datagram in transport mode, the ESP Header field is placed between the IPv4 header and data, with the ESP Trailer and ESP Authentication Data fields following. In tunnel mode, the entire original IPv4 datagram is surrounded by these ESP components, rather than just the IPv4 data. Again, as in , note the encryption and authentication coverage, and how the Next Header field points back to specify the identity of the encrypted data or datagram." src="httpatomoreillycomsourcenostarchimages287931.png.jpg"/></div></div><p class="title">Figure 29-10. IPv4 datagram format with IPsec ESP Here is the same sample IPv4 datagram that you saw in <a class="xref" href="ch29s06.html#ipv4_datagram_format_with_ipsec_ah_here_" title="Figure 29-7. IPv4 datagram format with IPsec AH Here is an example of an IPv4 datagram; it may or may not contain IPv4 options (which are not distinct entities as they are in IPv6). In transport mode, the AH header is added between the IP header and the IP data; the Protocol field of the IP header points to it, while its Next Header field contains the IP header's prior protocol value (in this case 6, for TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4 datagram that includes the AH header. Note that in tunnel mode, the AH header uses the value 4 (which means IPv4) in its Next Header field.">Figure 29-7</a>. When ESP processes this datagram in transport mode, the ESP Header field is placed between the IPv4 header and data, with the ESP Trailer and ESP Authentication Data fields following. In tunnel mode, the entire original IPv4 datagram is surrounded by these ESP components, rather than just the IPv4 data. Again, as in <a class="xref" href="ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here" title="Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of an IPv6 datagram with two extension headers that you saw in Figure 29-6. When ESP is applied in transport mode, the ESP Header field is added to the existing datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the entire encapsulated IPv6 datagram. Note the encryption and authentication coverage in each case, and also how the Next Header field points back into the datagram since it appears in the ESP Trailer.">Figure 29-9</a>, note the encryption and authentication coverage, and how the Next Header field points back to specify the identity of the encrypted data or datagram.</p></div></div></div><div class="sect2" title="ESP Format"><div class="titlepage"><div><div><h2 class="title"><a id="esp_format"/>ESP Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-29-1090"/><a class="indexterm" id="idx-CHP-29-1091"/>The <a class="indexterm" id="idx-CHP-29-1092"/>format of the ESP sections and fields is described in <a class="xref" href="ch29s07.html#ipsec_encapsulating_security_paylo-id001" title="Table 29-3. IPsec Encapsulating Security Payload (ESP) Format">Table 29-3</a> and illustrated in <a class="xref" href="ch29s07.html#ipsec_esp_format_note_that_most_of_the_f" title="Figure 29-11. IPsec ESP format Note that most of the fields and sections in this format are variable length. The exceptions are the SPI and Sequence Number fields, which are four bytes long, and the Pad Length and Next Header fields, which are one byte each.">Figure 29-11</a>. In both the figure and the table, I have shown the encryption and authentication coverage of the fields explicitly, to clarify how it all works.</p><div class="table"><a id="ipsec_encapsulating_security_paylo-id001"/><p class="title">Table 29-3. IPsec Encapsulating Security Payload (ESP) Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPsec Encapsulating Security Payload (ESP) Format"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-29-1093"/>Section</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Encryption Coverage</p></th><th style="border-bottom: 0.5pt solid ; "><p>Authentication Coverage</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ESP Header</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SPI</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A 32-bit value that is combined with the destination address and security protocol type to identify the SA that will be used for this datagram. (SAs are discussed earlier in this chapter.)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "><p/><span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e31147"/><img alt="" src="httpatomoreillycomsourcenostarchimages287933.png.jpg"/></span></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A counter field initialized to zero when an SA is formed between two devices, and then incremented for each datagram that's sent using that SA. This is used to provide protection against replay attacks.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td class="auto-generated" style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Payload</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Payload Data</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The encrypted payload data, which consists of a higher-layer message or encapsulated IP datagram. It may also include support information such as an initialization vector that's required by certain encryption methods.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e31179"/><img alt="" src="httpatomoreillycomsourcenostarchimages287935.png.jpg"/></span></p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ESP Trailer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Padding</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable (0 to 255)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Additional padding bytes are included as needed for encryption or for alignment.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pad Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The number of bytes in the preceding Padding field.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next Header</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Contains the protocol number of the next header in the datagram. Used to chain together headers.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; "><p>ESP Authentication Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; "><p>Contains the ICV resulting from the application of the optional ESP authentication algorithm.</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td class="auto-generated" style=""> </td></tr></tbody></table></div></div><div class="figure"><a id="ipsec_esp_format_note_that_most_of_the_f"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e31241"/><img alt="IPsec ESP format Note that most of the fields and sections in this format are variable length. The exceptions are the SPI and Sequence Number fields, which are four bytes long, and the Pad Length and Next Header fields, which are one byte each." src="httpatomoreillycomsourcenostarchimages287937.png.jpg"/></div></div><p class="title">Figure 29-11. IPsec ESP format Note that most of the fields and sections in this format are variable length. The exceptions are the SPI and Sequence Number fields, which are four bytes long, and the Pad Length and Next Header fields, which are one byte each.</p></div><p>The Padding field is used when encryption algorithms require it. Padding is also used to make sure that the ESP Trailer field ends on a 32-bit boundary. That is, the size of the ESP Header field plus the Payload field, plus the ESP Trailer field must be a multiple of 32 bits. The ESP Authentication Data field must also be a multiple of 32 bits.</p></div></div>
<div class="sect1" title="IPsec Internet Key Exchange (IKE)"><div class="titlepage"><div><div><h1 class="title"><a id="ipsec_internet_key_exchange_ike"/>IPsec Internet Key Exchange (IKE)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-29-1094"/>IPsec, <a class="indexterm" id="idx-CHP-29-1095"/>like many secure networking protocol sets, is based on the concept of a shared secret. Two devices that want to send <a class="indexterm" id="idx-CHP-29-1096"/>information securely encode and decode it using a piece of information that only the devices know. Anyone who isn't in on the secret is able to intercept the information but is prevented either from reading it (if ESP is used to encrypt the payload) or from tampering with it undetected (if AH is used). Before either AH or ESP can be used, however, it is necessary for the two devices to exchange the secret that the security protocols themselves will use. The primary support protocol used for this purpose in IPsec is called <span class="emphasis"><em>Internet Key Exchange (IKE)</em></span>.</p><p>IKE is defined in RFC 2409, and it is one of the more complicated of the IPsec protocols to comprehend. In fact, it is simply impossible to truly understand more than a real simplification of its operation without significant background in cryptography. I don't have a background in cryptography, and I must assume that you, my reader, do not either. So rather than fill this topic with baffling acronyms and unexplained concepts, I will just provide a brief outline of IKE and how it is used.</p><div class="sect2" title="IKE Overview"><div class="titlepage"><div><div><h2 class="title"><a id="ike_overview"/>IKE Overview</h2></div></div></div><p>The purpose of IKE is to allow devices to exchange information that's required for secure communication. As the title suggests, this includes cryptographic keys that are used for encoding authentication information and performing payload encryption. IKE works by allowing IPsec-capable devices to exchange SAs, which populate their SADs. These SADs are then used for the actual exchange of secured datagrams with the AH and ESP protocols.</p><p>IKE is considered a hybrid protocol because it combines (and supplements) the functions of three other protocols. The first of these is the <a class="indexterm" id="idx-CHP-29-1097"/><span class="emphasis"><em>Internet Security Association and Key Management Protocol (ISAKMP)</em></span>. This protocol provides a framework for exchanging encryption keys and security association information. It operates by allowing security associations to be negotiated through a series of phases.</p><p><a class="indexterm" id="idx-CHP-29-1098"/>ISAKMP is a generic protocol that supports many different key exchange methods. In IKE, the ISAKMP framework is used as the basis for a specific key exchange method that combines features from two key exchange protocols:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-29-1099"/>OAKLEY</strong></span> Describes a specific mechanism for exchanging keys through the definition of various key exchange modes. Most of the IKE key exchange process is based on OAKLEY.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-29-1100"/>SKEME</strong></span> Describes a different key exchange mechanism than OAKLEY. IKE uses some features from SKEME, including its method of public key encryption and its fast rekeying feature.</p></div><div class="sect2" title="IKE Operation"><div class="titlepage"><div><div><h2 class="title"><a id="ike_operation"/>IKE Operation</h2></div></div></div><p>IKE doesn't strictly implement either OAKLEY or SKEME but takes bits of each to form its own method of using ISAKMP. Clear as mud, I know. Because IKE functions within the framework of ISAKMP, its operation is based on the ISAKMP phased-negotiation process. There are two phases, as follows:</p><p><span class="strong"><strong>ISAKMP Phase 1</strong></span> The first phase is a setup stage where two devices agree on how to exchange further information securely. This negotiation between the two units creates an SA for ISAKMP itself: an <span class="emphasis"><em>ISAKMP SA</em></span>. This security association is then used for securely exchanging more detailed information in Phase 2.</p><p><span class="strong"><strong>ISAKMP Phase 2</strong></span> In this phase, the ISAKMP SA established in Phase 1 is used to create SAs for other security protocols. Normally, this is where the parameters for the "real" SAs for the AH and ESP protocols would be negotiated.</p><p>An obvious question is why IKE bothers with this two-phased approach. Why not just negotiate the SA for AH or ESP in the first place? Well, even though the extra phase adds overhead, multiple Phase 2 negotiations can be conducted after one Phase 1, which amortizes the extra cost of the two-phase approach. It is also possible to use a simpler exchange method for Phase 2 once the ISAKMP SA has been established in Phase 1.</p><p>The ISAKMP SA negotiated during Phase 1 includes the negotiation of the following attributes used for subsequent negotiations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An encryption algorithm, such as the <span class="emphasis"><em>Data Encryption Standard (DES)</em></span></p></li><li class="listitem"><p>A hash algorithm (MD5 or SHA, as used by AH or ESP)</p></li><li class="listitem"><p>An authentication method, such as authentication using previously shared keys</p></li><li class="listitem"><p>A <span class="emphasis"><em>Diffie-Hellman</em></span> group</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="note-94"/>Note</h3><p><span class="emphasis"><em>Diffie and Hellman were two pioneers in the industry who invented public-key cryptography. In this method, instead of encrypting and decrypting with the same key, data is encrypted using a public key that anyone can know, and decrypted using a private key that is kept secret. A Diffie-Hellman group defines the attributes of how to perform this type of cryptography. Four predefined groups derived from OAKLEY are specified in IKE, and provision is allowed for defining new groups as well</em></span>.</p></div><p>Note that even though SAs in general are unidirectional, the ISAKMP SA is established bidirectionally. Once Phase 1 is complete, either device can set up a subsequent SA for AH or ESP using the ISAKMP SA.</p></div></div>
<div class="chapter" title="Chapter&#xA0;30.&#xA0;INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)"><div class="titlepage"><div><div><h1 class="title"><a id="internet_protocol_mobility_support_mobil"/>Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e31358"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The Internet Protocol (IP) is the most successful network layer protocol in computing due to its many strengths, but it also has some weaknesses, most of which have become more important as networks has evolved over time. Technologies like classless addressing and Network Address Translation (NAT) combat the exhaustion of the IP version 4 (IPv4) address space, while IPsec provides it with the secure communications it lacks. Another weakness of IP is that it was not designed with <a class="indexterm" id="idx-CHP-30-1101"/>mobile computers in mind.</p><p>While mobile devices can certainly use IP, the way that devices are addressed and datagrams routed causes a problem when they are moved from one network to another. At the time IP was developed, computers were large and rarely moved. Today, we have millions of notebook computers and smaller devices, some of which even use wireless networking to connect to the wired network. The importance of providing full IP capabilities for these mobile devices has grown dramatically. To support IP in a mobile environment, a new protocol called <span class="emphasis"><em>IP Mobility Support</em></span>, or more simply, <a class="indexterm" id="idx-CHP-30-1102"/><span class="emphasis"><em>Mobile IP</em></span>, was developed.</p><p>In this chapter, I describe the special protocol that was developed to overcome the problems with mobile computers attaching to IP internetworks. I begin with an overview of Mobile IP and a more detailed description of why it was created. I discuss important concepts that define Mobile IP and its general mode of operation. I then move on to some of the specifics of how Mobile IP works. This includes a description of the special Mobile IP addressing scheme, an explanation of how agents are discovered by mobile devices, a discussion of the process of registration with the device's home agent, and finally, an explanation of how data is encapsulated and routed. I discuss the impact that Mobile IP has on the operation of the TCP/IP Address Resolution Protocol (ARP). I end the chapter by examining some of the efficiency and security issues that come into play when Mobile IP is used.</p><div class="note" title="Note"><h3 class="title"><a id="note-95"/>Note</h3><p><span class="emphasis"><em>This section specifically describes how IP mobility support is provided for IPv4 networks. It does not deal with the more specific details for how mobility is implemented in IPv6</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-162"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>If you are not familiar with the basics of IP addressing and routing, I strongly suggest reading at least Chapters <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a> and <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a> before reading about Mobile IP</em></span>.</p></div><div class="sect1" title="Mobile IP Overview, History, and Motivation"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_overview_history_and_motivatio"/>Mobile IP Overview, History, and Motivation</h1></div></div></div><p>Mobile computing has greatly increased in popularity over the past several years, largely due to advances in miniaturization. Today, we can get the power that once required a hulking behemoth of a machine in a notebook PC or even a handheld computer. We also have wireless LAN (WLAN) technologies that easily let a device move from place to place and retain networking connectivity at the data link layer. Unfortunately, IP was developed back in the era of the behemoths, and it isn't designed to deal gracefully with computers that move around. To understand why IP doesn't work well in a mobile environment, you must take a look back at how IP addressing and routing work.</p><div class="sect2" title="The Problem with Mobile Nodes in TCP/IP"><div class="titlepage"><div><div><h2 class="title"><a id="the_problem_with_mobile_nodes_in_tcpip"/>The Problem with Mobile Nodes in TCP/IP</h2></div></div></div><p>If you've read any of the materials in this book on IP addressing—and I certainly hope that you have—you know that IP addresses are fundamentally divided into two portions: a network identifier (network ID) and a host identifier (host ID). The network ID specifies which network a host is on, and the host ID uniquely specifies hosts within a network. This structure is fundamental to datagram routing, because devices use the network ID portion of the destination address of a datagram to determine if the recipient is on a local network or a remote one, and routers use it to determine how to route the datagram.</p><p>This is a great system, but it has one critical flaw: The IP address is tied tightly to the network where the device is located. Most devices never (or at least rarely) change their attachment point to the network, so this is not a problem for them, but it is certainly an issue for a mobile device. When the mobile device travels away from its home location, the system of routing based on IP address breaks. This is illustrated in <a class="xref" href="ch30.html#the_main_problem_with_mobile_devices_on_" title="Figure 30-1. The main problem with mobile devices on IP internetworks In this example, a mobile device (the notebook PC) has been moved from its home network in London to another network in Tokyo. A remote client (upper left) decides to send a datagram to the mobile device. However, it has no idea the device has moved. Since it sends by using the mobile node's home address, 71.13.204.20, its request is routed to the router responsible for that network, which is in London. The mobile device isn't there, so the router can't deliver it. Mobile IP solves this problem by giving mobile devices and routers the capability to forward datagrams from one location to another.">Figure 30-1</a>.</p><p>The tight binding of network ID and host IP address means that there are only two real options under conventional IP when a mobile device moves from one network to another:</p><p><span class="strong"><strong>Change IP Address</strong></span> We can change the IP address of the host to a new address that includes the network ID of the network to which it is moving.</p><p><span class="strong"><strong>Decouple IP Routing from Address</strong></span> We can change the way routing is done for the device, so that instead of routers sending datagrams to a device based on its network ID, they route based on its entire address.</p><div class="figure"><a id="the_main_problem_with_mobile_devices_on_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e31425"/><img alt="The main problem with mobile devices on IP internetworks In this example, a mobile device (the notebook PC) has been moved from its home network in London to another network in Tokyo. A remote client (upper left) decides to send a datagram to the mobile device. However, it has no idea the device has moved. Since it sends by using the mobile node's home address, 71.13.204.20, its request is routed to the router responsible for that network, which is in London. The mobile device isn't there, so the router can't deliver it. Mobile IP solves this problem by giving mobile devices and routers the capability to forward datagrams from one location to another." src="httpatomoreillycomsourcenostarchimages287939.png.jpg"/></div></div><p class="title">Figure 30-1. The main problem with mobile devices on IP internetworks In this example, a mobile device (the notebook PC) has been moved from its home network in London to another network in Tokyo. A remote client (upper left) decides to send a datagram to the mobile device. However, it has no idea the device has moved. Since it sends by using the mobile node's home address, 71.13.204.20, its request is routed to the router responsible for that network, which is in London. The mobile device isn't there, so the router can't deliver it. Mobile IP solves this problem by giving mobile devices and routers the capability to forward datagrams from one location to another.</p></div><p>These both seem like viable options at first glance, and if only a few devices tried them, they might work. Unfortunately, they are both inefficient, often impractical, and neither is scalable (practical when thousands or millions of devices try them) for these reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Changing the IP address each time a device moves is time-consuming and normally requires manual intervention. In addition, the entire TCP/IP stack would need to be restarted, thereby breaking any existing connections.</p></li><li class="listitem"><p>If we change the mobile device's IP address, how do we communicate the change of address to other devices on the Internet? These devices will only have the mobile node's original home address, which means they won't be able to find it, even if we give it a new address matching its new location.</p></li><li class="listitem"><p>Routing based on the entire address of a host would mean the entire Internet would be flooded with routing information for each and every mobile computer. Considering how much trouble has gone into developing technologies like classless addressing to reduce routing table entries, it's obvious this is a Pandora's box no one wants to touch.</p></li></ul></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-163"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The basic problem with supporting mobile devices in IP internetworks is that routing is performed using the IP address. This means the IP address of a device is tied to the network where that the device is located. If a device changes networks, data sent to its old address cannot be delivered by conventional means. Traditional work-arounds, such as routing by the full IP address or changing IP addresses manually, often create more problems.</p></div></div><div class="sect2" title="The Solution: Mobile IP"><div class="titlepage"><div><div><h2 class="title"><a id="the_solution_mobile_ip"/>The Solution: Mobile IP</h2></div></div></div><p>The solution to these difficulties was to define a new protocol especially to support mobile devices, which adds to the original IP. This protocol, called <span class="emphasis"><em>IP Mobility Support for IPv4</em></span>, was first defined in RFC 2002, was updated in RFC 3220, and is now described in RFC 3344. The formal name given in that document title is rather long; the technology is more commonly called <span class="emphasis"><em>Mobile IP</em></span>, both in the RFC itself and by networking professionals.</p><p>To ensure its success, Mobile IP's designers had to meet a number of important goals. The resulting protocol has these key attributes and features:</p><p><span class="strong"><strong>Seamless Device Mobility Using Existing Device Address</strong></span> Mobile devices can change their physical network attachment method and location while continuing to use their existing IP address.</p><p><span class="strong"><strong>No New Addressing or Routing Requirements</strong></span> The overall scheme for addressing and routing as in regular IP is maintained. IP addresses are still assigned in the conventional way by the owner of each device. No new routing requirements are placed on the internetwork, such as host-specific routes.</p><p><span class="strong"><strong>Interoperability</strong></span> Mobile IP devices can still send to and receive from existing IP devices that do not know how Mobile IP works, and vice versa.</p><p><span class="strong"><strong>Layer Transparency</strong></span> The changes made by Mobile IP are confined to the network layer. Transport layer and higher-layer protocols and applications are able to function as in regular IPv4, and existing connections can even be maintained across a move.</p><p><span class="strong"><strong>Limited Hardware Changes</strong></span> Changes are required to the mobile device's software as well as to routers used directly by the mobile device. Other devices, however, do not need changes, including routers between the ones on the home and visited networks.</p><p><span class="strong"><strong>Scalability</strong></span> Mobile IP allows a device to change from any network to any other, and supports this for an arbitrary number of devices. The scope of the connection change can be global; you could detach a notebook from an office in London and move it to Australia or Brazil, for example, and it will work the same as if you took it to the office next door.</p><p><span class="strong"><strong>Security</strong></span> Mobile IP works by redirecting messages, and includes authentication procedures to prevent an unauthorized device from causing problems.</p><p>Mobile IP accomplishes these goals by implementing a <span class="emphasis"><em>forwarding system</em></span> for mobile devices. When a mobile unit is on its home network, it functions normally. When it moves to a different network, datagrams are sent from its home network to its new location. This allows normal hosts and routers that don't know about Mobile IP to continue to operate as if the mobile device had not moved. Special support services are required to implement Mobile IP; these services allow activities such as letting a mobile device determine where it is, telling the home network where to forward messages, and more.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-164"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Mobile IP</em></span> solves the problems associated with devices that change network locations by setting up a system whereby datagrams sent to the mobile node's home location are forwarded to it wherever it may be located. It is particularly useful for wireless devices, but can be used for any device that moves between networks periodically.</p></div><p>Mobile IP is often associated with wireless networks, since devices using WLAN technology can move so easily from one network to another. However, it wasn't designed specifically for wireless. It can be equally useful for moving from an Ethernet network in one building to a network in another building, city, or country. Mobile IP can be of great benefit in numerous applications for traveling salespeople, consultants who visit client sites, administrators who walk around a campus troubleshooting problems, and many more.</p></div><div class="sect2" title="Limitations of Mobile IP"><div class="titlepage"><div><div><h2 class="title"><a id="limitations_of_mobile_ip"/>Limitations of Mobile IP</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1103"/>It's important to realize that Mobile IP has certain limitations in its usefulness in a wireless environment. It was designed to handle the mobility of devices, but only relatively infrequent mobility. This is due to the work involved with each change. This overhead isn't a big deal when you move a computer once a week, once a day, or even once an hour. It can be an issue for "real-time" mobility, such as roaming in a wireless network, where handoff functions operating at the data link layer may be more suitable. Mobile IP was designed under the specific assumption that the attachment point would not change more than once per second.</p><p>Mobile IP is intended to be used with devices that maintain a static IP configuration. Since the device needs to be able to always know the identity of its home network and normal IP address, it is much more difficult to use it with a device that obtains an IP address dynamically, using something like the Dynamic Host Configuration Protocol (DHCP).</p></div></div></div>
<div class="sect1" title="Mobile IP Concepts and General Operation"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_concepts_and_general_operation"/>Mobile IP Concepts and General Operation</h1></div></div></div><p>I like analogies because they provide a way of explaining often dry technical concepts in terms that you can relate to. The problem of mobile devices in an IP internetwork can easily be compared to a real-life mobility and information transmission problem: mail delivery for those who travel.</p><p>Suppose you are a consultant working for a large corporation with many offices. Your home office is in London, England, and you spend about half your time there. The rest of the time is split between other offices in, say, Rome, Tokyo, New York City, and Toronto. You also occasionally visit client sites that can be just about anywhere in the world. You may be at these remote locations for weeks at a time.</p><p>The problem is how do you arrange things so that you can receive your mail regardless of your location? You have the same problem that regular IP has with a mobile device, and without taking special steps, you have the same two unsatisfactory options for resolving it: address changing or decoupling routing from your address. You can't change your address each time you move because you would be modifying it constantly; by the time you told everyone about your new address, it would change again. And you certainly can't "decouple" the routing of mail from your address, unless you want to set up your own postal system!</p><p>The solution to this dilemma is <span class="emphasis"><em>mail forwarding</em></span>. Let's say that you leave London for Tokyo for a couple of months. You tell the London post office (PO) that you will be in Tokyo. They intercept mail headed for your normal London address, relabel it, and forward it to Tokyo. Depending on where you are staying, this mail might be redirected either straight to a new address in Tokyo or to a Tokyo PO where you can pick it up. If you leave Tokyo to go to another city, you just call the London PO and tell them your new location. When you come home, you cancel the forwarding and get your mail as always. (Yes, I'm assuming London and Tokyo each have only one PO.)</p><p>The advantages of this system are many. It is relatively simple to understand and implement. It is also transparent to everyone who sends you mail; they still send to you in London and it gets wherever it needs to go. And handling of the forwarding mechanism is done only by the London PO and possibly the PO where you are presently located; the rest of the postal system doesn't even know anything out of the ordinary is going on.</p><p>There are some disadvantages, too. The London PO may allow occasional forwarding for free, but would probably charge you if you did this on a regular basis. You might also need a special arrangement in the city you travel to. You need to keep communicating with your home PO each time you move. And every piece of mail must be sent through the system twice—first to London and then to wherever you are located—which is inefficient.</p><p><a class="indexterm" id="idx-CHP-30-1104"/>Mobile IP works in a manner very similar to the mail-forwarding system I just described. The traveling consultant is the device that goes from network to network. Each network can be considered like a different city, and the internetwork of routers is like the postal system. The router that connects any network to the Internet is like that network's post office, from an IP perspective.</p><p>The mobile node is normally resident on its home network, which is the one that is indicated by the network ID in its IP address. <a class="indexterm" id="idx-CHP-30-1105"/>Devices on the internetwork always route using this address, so the pieces of "mail" (datagrams) always arrive at a router at the device's "home." When the device travels to another network, the home router ("post office") intercepts these datagrams and forwards them to the device's current address. It may send them straight to the device using a new, temporary address, or it may send them to a router on the device's current network (the "other post office" or Tokyo in our analogy) for final delivery. You can see an overview of <a class="indexterm" id="idx-CHP-30-1106"/>Mobile IP <a class="indexterm" id="idx-CHP-30-1107"/>operation in <a class="xref" href="ch30s02.html#general_operation_of_mobile_ip_this_diag" title="Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1, except that it shows Mobile IP implemented. The mobile node's home router serves as home agent, and the router in Tokyo serves as the foreign agent. The mobile has been assigned a temporary &quot;care-of&quot; address to use while in Tokyo (which in this case is a co-located care-of address, meaning that it is assigned directly to the mobile node. Figure 30-3 shows the same example using the other type of care-of address). In step 1, the remote client sends a datagram to the mobile using its home address, as in normal TCP/IP. It arrives in London as usual. In step 2, the home agent encapsulates that datagram in a new one and sends it to the mobile node in Tokyo.">Figure 30-2</a>.</p><div class="figure"><a id="general_operation_of_mobile_ip_this_diag"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e31566"/><img alt="General operation of Mobile IP This diagram is similar to , except that it shows Mobile IP implemented. The mobile node's home router serves as home agent, and the router in Tokyo serves as the foreign agent. The mobile has been assigned a temporary &quot;care-of&quot; address to use while in Tokyo (which in this case is a co-located care-of address, meaning that it is assigned directly to the mobile node. shows the same example using the other type of care-of address). In step 1, the remote client sends a datagram to the mobile using its home address, as in normal TCP/IP. It arrives in London as usual. In step 2, the home agent encapsulates that datagram in a new one and sends it to the mobile node in Tokyo." src="httpatomoreillycomsourcenostarchimages287941.png.jpg"/></div></div><p class="title">Figure 30-2. General operation of Mobile IP This diagram is similar to <a class="xref" href="ch30.html#the_main_problem_with_mobile_devices_on_" title="Figure 30-1. The main problem with mobile devices on IP internetworks In this example, a mobile device (the notebook PC) has been moved from its home network in London to another network in Tokyo. A remote client (upper left) decides to send a datagram to the mobile device. However, it has no idea the device has moved. Since it sends by using the mobile node's home address, 71.13.204.20, its request is routed to the router responsible for that network, which is in London. The mobile device isn't there, so the router can't deliver it. Mobile IP solves this problem by giving mobile devices and routers the capability to forward datagrams from one location to another.">Figure 30-1</a>, except that it shows Mobile IP implemented. The mobile node's home router serves as home agent, and the router in Tokyo serves as the foreign agent. The mobile has been assigned a temporary "care-of" address to use while in Tokyo (which in this case is a co-located care-of address, meaning that it is assigned directly to the mobile node. <a class="xref" href="ch30s03.html#mobile_ip_operation_with_a_foreign_agent" title="Figure 30-3. Mobile IP operation with a foreign agent care-of address This diagram is similar to Figure 30-2, except that instead of the mobile node having a co-located (distinct) IP address, here the mobile node is using a foreign agent care-of address. This means that the node's care-of address is actually that of the foreign agent itself. Step 1 is the same as in Figure 30-2, but in step 2, the home agent forwards not to the mobile node directly, but to the foreign agent (since that router is the one whose IP address the mobile is using). In step 3, the foreign agent strips off the home agent's packaging and delivers the original datagram to the mobile node. This is typically done using whatever layer 2 (LAN or WLAN) technology connects the mobile node and foreign agent.">Figure 30-3</a> shows the same example using the other type of care-of address). In step 1, the remote client sends a datagram to the mobile using its home address, as in normal TCP/IP. It arrives in London as usual. In step 2, the home agent encapsulates that datagram in a new one and sends it to the mobile node in Tokyo.</p></div><div class="sect2" title="Mobile IP Device Roles"><div class="titlepage"><div><div><h2 class="title"><a id="mobile_ip_device_roles"/>Mobile IP Device Roles</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1108"/><a class="indexterm" id="idx-CHP-30-1109"/>As you can see, just as mail forwarding requires support from one or more POs, Mobile IP requires the help of two routers. The following special names are given to the three main players that implement the protocol (also shown in <a class="xref" href="ch30s02.html#general_operation_of_mobile_ip_this_diag" title="Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1, except that it shows Mobile IP implemented. The mobile node's home router serves as home agent, and the router in Tokyo serves as the foreign agent. The mobile has been assigned a temporary &quot;care-of&quot; address to use while in Tokyo (which in this case is a co-located care-of address, meaning that it is assigned directly to the mobile node. Figure 30-3 shows the same example using the other type of care-of address). In step 1, the remote client sends a datagram to the mobile using its home address, as in normal TCP/IP. It arrives in London as usual. In step 2, the home agent encapsulates that datagram in a new one and sends it to the mobile node in Tokyo.">Figure 30-2</a>):</p><p><span class="strong"><strong>Mobile Node</strong></span> This is the mobile device, the one moving around the internetwork.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1110"/>Home Agent</strong></span> This is a router on the home network that is responsible for catching datagrams intended for the mobile node and forwarding them to it when it is traveling. It also implements other support <a class="indexterm" id="idx-CHP-30-1111"/>functions that are necessary to run the protocol.</p><p><span class="strong"><strong>Foreign Agent</strong></span> This is a router on the network to which the mobile node is currently attached. It serves as a "home away from home" for the mobile node, and normally acts as its default router and implements Mobile IP functions. Depending on the mode of operation, it may receive forwarded datagrams from the home agent and forward them to the mobile node. It also supports the sharing of mobility information to make Mobile IP operate. The foreign agent may not be required in some Mobile IP implementations but is usually considered part of how the protocol operates.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-165"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Mobile IP operates by setting up the TCP/IP equivalent of a mail-forwarding system. A router on a <span class="emphasis"><em>mobile node</em></span>'s home network serves as the mobile device's <span class="emphasis"><em>home agent</em></span>, and one on its current network acts as the <span class="emphasis"><em>foreign agent</em></span>. The home agent receives datagrams destined for the mobile's normal IP address and forwards them to the mobile node's current location, either directly or by sending the datagrams to the foreign agent. The home agent and foreign agent are also responsible for various communication and setup activities that are required for Mobile IP to work.</p></div></div><div class="sect2" title="Mobile IP Functions"><div class="titlepage"><div><div><h2 class="title"><a id="mobile_ip_functions"/>Mobile IP Functions</h2></div></div></div><p>An important difference between Mobile IP and this mail-forwarding example is one that represents the classic distinction between people and computers: People are smart, and computers are not. When the consultant is traveling in Tokyo, he always knows he's in Tokyo and that his mail is being forwarded. He knows that he must deal with the Tokyo PO to get his mail. The PO in London knows what forwarding is all about and how to do it. The traveler and the POs can communicate easily using the telephone.</p><p>In contrast, in the computer world, when a device travels using Mobile IP, things are more complicated. Let's suppose the consultant flies to Tokyo, turns on his notebook, and plugs it in to the network. When the notebook is first turned on, it has no clue what is going on. The notebook has to figure out that it is in Tokyo. It needs to find a foreign agent in Tokyo. It needs to know what address to use while in Tokyo. It needs to communicate with its home agent back in London to tell it that it is in Tokyo and that the agent should start forwarding datagrams. Furthermore, it must accomplish its communication without any telephone.</p><p>To this end, Mobile IP includes a host of special functions that are used to set up and manage datagram forwarding. To see how these support functions work, let's look at the general operation of Mobile IP as a simplified series of steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Agent Communication</strong></span> The mobile node finds an agent on its local network by engaging in the <span class="emphasis"><em>Agent Discovery</em></span> process. It listens for Agent Advertisement messages that are sent out by agents, and from this it can determine where it is located. If it doesn't hear these messages it can ask for one using an Agent Solicitation message.</p></li><li class="listitem"><p><span class="strong"><strong>Network Location Determination</strong></span> The mobile node determines whether it is on its home network or on a foreign one by looking at the information in the Agent Advertisement message.</p></li></ol></div><p>If it is on its home network, it functions using regular IP. To show how the rest of the process works, let's say the device sees that it just moved to a foreign network. The remaining steps are as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Care-Of <a class="indexterm" id="idx-CHP-30-1112"/>Address Acquisition</strong></span> The device obtains a temporary address called a <span class="emphasis"><em>care-of address</em></span>. This either comes from the Agent Advertisement message from the foreign agent or through some other means. This address is used only as the destination point for forwarding datagrams, and for no other purpose.</p></li><li class="listitem"><p><span class="strong"><strong>Agent Registration</strong></span> The mobile node informs the home agent on its home network of its presence on the foreign network and enables datagram forwarding by <span class="emphasis"><em>registering</em></span> with the home agent. This may be done either directly between the node and the home agent or indirectly using the foreign agent as a conduit.</p></li><li class="listitem"><p><span class="strong"><strong>Datagram Forwarding</strong></span> The home agent captures datagrams intended for the mobile node and forwards them. It may send them either directly to the node or indirectly to the foreign agent for delivery, depending on the type of care-of address in use.</p></li></ol></div><p>Datagram forwarding continues until the current agent registration expires. The device can then renew it. If it moves again, it repeats the process to get a new care-of address and then registers its new location with the home agent. When the mobile node returns to its home network, it <span class="emphasis"><em>deregisters</em></span> to cancel datagram forwarding and resumes normal IP operation.</p><p>The following sections look in more detail at the functions summarized in each of the previous steps.</p></div></div>
<div class="sect1" title="Mobile IP Addressing: Home and Care-Of Addresses"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_addressing_home_and_care-of_ad"/>Mobile IP Addressing: Home and Care-Of Addresses</h1></div></div></div><p><a class="indexterm" id="idx-CHP-30-1113"/>Just as most of us have only a single address used for mail, most IP devices have only a single address. Our traveling consultant, however, needs to have two addresses; a normal one and one that is used while he is away. Continuing the earlier analogy, the Mobile IP–equipped notebook the consultant carries needs to have two addresses:</p><p><span class="strong"><strong>Home Address</strong></span> The normal, permanent IP address assigned to the mobile node. This is the address used by the device on its home network, and the one to which datagrams intended for the mobile node are always sent.</p><p><span class="strong"><strong>Care-Of Address</strong></span> A secondary, temporary address used by a mobile node while it is traveling away from its home network. It is a normal 32-bit IP address in most respects, but is used only by Mobile IP for forwarding IP datagrams and for administrative functions. Higher layers never use it, nor do regular IP devices when creating datagrams.</p><p>The care-of address is a slightly tricky concept. There are two different types, which correspond to two distinctly different methods of forwarding datagrams from the home agent router.</p><div class="sect2" title="Foreign Agent Care-Of Address"><div class="titlepage"><div><div><h2 class="title"><a id="foreign_agent_care-of_address"/>Foreign Agent Care-Of Address</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1114"/>The care-of address is provided by a foreign agent in its <span class="emphasis"><em>Agent Advertisement</em></span> message. It is, in fact, the IP address of the foreign agent itself. When this type of care-of address is used, all datagrams captured by the home agent are not relayed directly to the mobile node, but indirectly to the foreign agent, which is responsible for final delivery. In this arrangement, the mobile node has no distinct IP address valid on the foreign network, so this is typically done using a layer 2 technology. This arrangement is illustrated in <a class="xref" href="ch30s03.html#mobile_ip_operation_with_a_foreign_agent" title="Figure 30-3. Mobile IP operation with a foreign agent care-of address This diagram is similar to Figure 30-2, except that instead of the mobile node having a co-located (distinct) IP address, here the mobile node is using a foreign agent care-of address. This means that the node's care-of address is actually that of the foreign agent itself. Step 1 is the same as in Figure 30-2, but in step 2, the home agent forwards not to the mobile node directly, but to the foreign agent (since that router is the one whose IP address the mobile is using). In step 3, the foreign agent strips off the home agent's packaging and delivers the original datagram to the mobile node. This is typically done using whatever layer 2 (LAN or WLAN) technology connects the mobile node and foreign agent.">Figure 30-3</a>.</p><div class="figure"><a id="mobile_ip_operation_with_a_foreign_agent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e31724"/><img alt="Mobile IP operation with a foreign agent care-of address This diagram is similar to , except that instead of the mobile node having a co-located (distinct) IP address, here the mobile node is using a foreign agent care-of address. This means that the node's care-of address is actually that of the foreign agent itself. Step 1 is the same as in , but in step 2, the home agent forwards not to the mobile node directly, but to the foreign agent (since that router is the one whose IP address the mobile is using). In step 3, the foreign agent strips off the home agent's packaging and delivers the original datagram to the mobile node. This is typically done using whatever layer 2 (LAN or WLAN) technology connects the mobile node and foreign agent." src="httpatomoreillycomsourcenostarchimages287943.png.jpg"/></div></div><p class="title">Figure 30-3. Mobile IP operation with a foreign agent care-of address This diagram is similar to <a class="xref" href="ch30s02.html#general_operation_of_mobile_ip_this_diag" title="Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1, except that it shows Mobile IP implemented. The mobile node's home router serves as home agent, and the router in Tokyo serves as the foreign agent. The mobile has been assigned a temporary &quot;care-of&quot; address to use while in Tokyo (which in this case is a co-located care-of address, meaning that it is assigned directly to the mobile node. Figure 30-3 shows the same example using the other type of care-of address). In step 1, the remote client sends a datagram to the mobile using its home address, as in normal TCP/IP. It arrives in London as usual. In step 2, the home agent encapsulates that datagram in a new one and sends it to the mobile node in Tokyo.">Figure 30-2</a>, except that instead of the mobile node having a co-located (distinct) IP address, here the mobile node is using a foreign agent care-of address. This means that the node's care-of address is actually that of the foreign agent itself. Step 1 is the same as in <a class="xref" href="ch30s02.html#general_operation_of_mobile_ip_this_diag" title="Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1, except that it shows Mobile IP implemented. The mobile node's home router serves as home agent, and the router in Tokyo serves as the foreign agent. The mobile has been assigned a temporary &quot;care-of&quot; address to use while in Tokyo (which in this case is a co-located care-of address, meaning that it is assigned directly to the mobile node. Figure 30-3 shows the same example using the other type of care-of address). In step 1, the remote client sends a datagram to the mobile using its home address, as in normal TCP/IP. It arrives in London as usual. In step 2, the home agent encapsulates that datagram in a new one and sends it to the mobile node in Tokyo.">Figure 30-2</a>, but in step 2, the home agent forwards not to the mobile node directly, but to the foreign agent (since that router is the one whose IP address the mobile is using). In step 3, the foreign agent strips off the home agent's packaging and delivers the original datagram to the mobile node. This is typically done using whatever layer 2 (LAN or WLAN) technology connects the mobile node and foreign agent.</p></div><p><a class="indexterm" id="idx-CHP-30-1115"/><a class="indexterm" id="idx-CHP-30-1116"/>In the consultant analogy, this type of care-of address is like forwarding from the London PO to the Tokyo PO. The London personnel would take a letter for John Smith sent to his London address, and repackage it for delivery to John Smith, care of the Tokyo post office. The Tokyo PO (or John Smith himself) would need to worry about the last leg of the delivery.</p></div><div class="sect2" title="Co-Located Care-Of Address"><div class="titlepage"><div><div><h2 class="title"><a id="co-located_care-of_address"/>Co-Located Care-Of Address</h2></div></div></div><p>The <a class="indexterm" id="idx-CHP-30-1117"/>co-located care-of address is assigned directly to the mobile node using some means that is external to Mobile IP. For example, it may be assigned on the foreign network manually, or it may be assigned automatically using DHCP. In this situation, the care-of address is used to forward traffic from the home agent directly to the mobile node. This was the type of address shown earlier in <a class="xref" href="ch30s02.html#general_operation_of_mobile_ip_this_diag" title="Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1, except that it shows Mobile IP implemented. The mobile node's home router serves as home agent, and the router in Tokyo serves as the foreign agent. The mobile has been assigned a temporary &quot;care-of&quot; address to use while in Tokyo (which in this case is a co-located care-of address, meaning that it is assigned directly to the mobile node. Figure 30-3 shows the same example using the other type of care-of address). In step 1, the remote client sends a datagram to the mobile using its home address, as in normal TCP/IP. It arrives in London as usual. In step 2, the home agent encapsulates that datagram in a new one and sends it to the mobile node in Tokyo.">Figure 30-2</a>.</p><p>In the consultant analogy, this is like John Smith obtaining a temporary address for his use while in Tokyo. The London PO would forward directly to his Tokyo address. They would not specifically send it to the Tokyo PO (although that PO would handle the mail at some point).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-166"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In Mobile IP, each mobile device uses a temporary care-of address while on a foreign network. A <a class="indexterm" id="idx-CHP-30-1118"/>co-located care-of address is one that is assigned directly to the mobile node and enables direct delivery of datagrams to the node. The alternative is to use a foreign agent care-of address. In this situation, the mobile node actually uses the IP address of the foreign agent. Datagrams are sent to the foreign agent, which delivers them to the mobile node.</p></div></div><div class="sect2" title="Advantages and Disadvantages of the Care-Of Address Types"><div class="titlepage"><div><div><h2 class="title"><a id="advantages_and_disadvantages_of_the_care"/>Advantages and Disadvantages of the Care-Of Address Types</h2></div></div></div><p>The foreign agent care-of address is considered the type used in classic Mobile IP, where there is both a home agent and a foreign agent. While it seems less efficient than the co-located address method, it offers some important advantages, a key one being that the same foreign agent care-of address can be used for all mobile nodes visiting that network. Datagrams for all mobile nodes on that network are sent to the foreign agent, which completes the delivery to the individual nodes. Since the mobile nodes use the foreign agent's address, no extra addresses or extra work is required for each mobile node.</p><p>The co-located care-of address has the advantage that traffic can be forwarded directly from the home agent to the mobile node. In this type of arrangement, it is possible for a Mobile IP device to travel to a foreign network where there is no Mobile IP–aware router to act as a foreign agent. This does mean, however, that the Mobile IP implementation must include all the functions of communicating with the home agent that the foreign agent normally performs.</p><p>When co-located care-of addresses are used, an issue is how the temporary address is obtained. In many foreign networks, automatic assignment of an IP address using something like DHCP may be possible, but if not, a temporary IP address would need to be assigned. Either way, some of the foreign network's limited IP address space would need to be set aside for mobile nodes, each of which would use an address while present on the network. In some cases, this could lead to an address depletion issue.</p><p>Foreign agent care-of addressing is usually preferred due to its more automatic nature, when a foreign agent is present on the visited network. Considering that all datagrams will need to go through some router on the foreign network to reach the mobile node anyway, we might as well save the extra IP addresses. Co-located care-of addresses would be used when there is no foreign agent, or might be practical for long-term connections even when a foreign agent is present.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-167"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In Mobile IP, <span class="emphasis"><em>co-located care-of addresses</em></span> have the advantage of flexibility, but require each device to have a unique IP address on the remote network. Foreign agent care-of addresses have the chief advantage of allowing many mobile devices on a foreign network without each requiring a distinct IP address.</p></div><p>Remember that the care-of address represents only the destination to which mobile node datagrams are forwarded. Foreign agents provide services other than forwarding, so it is possible for a mobile node to use a co-located care-of address even when a foreign agent is present, while continuing to take advantage of the other foreign agent services.</p><p>For more information on how datagrams are forwarded between the home agent and the mobile node's care-of address, <a class="indexterm" id="idx-CHP-30-1119"/>see the section on Mobile IP encapsulation and tunneling, later in this chapter.</p></div></div>
<div class="sect1" title="Mobile IP Agent Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_agent_discovery"/>Mobile IP Agent Discovery</h1></div></div></div><p><a class="indexterm" id="idx-CHP-30-1120"/>When a mobile node is first turned on, it cannot assume that it is still at home, the way normal IP devices do. It must first determine where it is, and if it is not at home, begin the process of setting up datagram forwarding from its home network. This process is accomplished by communicating with a local router that's serving as an agent through the process called <span class="emphasis"><em>Agent Discovery</em></span>.</p><div class="sect2" title="Agent Discovery Process"><div class="titlepage"><div><div><h2 class="title"><a id="agent_discovery_process"/>Agent Discovery Process</h2></div></div></div><p>Agent discovery encompasses the first three steps in the simplified five-step Mobile IP operational summary I gave earlier in discussing general Mobile IP operation. The main goals of Agent Discovery include the following:</p><p><span class="strong"><strong>Agent/Node Communication</strong></span> Agent Discovery is the method by which a mobile node first establishes contact with an agent on the local network to which it is attached. Messages containing important information about the agent are sent from the agent to the node. A message can also be sent from the node to the agent asking for this information to be sent.</p><p><span class="strong"><strong>Orientation</strong></span> The node uses the Agent Discovery process to determine where it is. Specifically, it learns whether it is on its home network or a foreign network by identifying the agent that sends it messages.</p><p><span class="strong"><strong>Care-Of Address Assignment</strong></span> The Agent Discovery process is the method used to tell a mobile node the care-of address it should use, when foreign agent care-of addressing is used.</p><p>Mobile IP agents are routers that have been given additional programming to make them Mobile IP-aware. The communication between a mobile node and the agent on its local network is basically the same as the normal communication required between a device on an IP network and its local router, except more information needs to be sent when the router is an agent.</p></div><div class="sect2" title="Agent Advertisement and Agent Solicitation Messages"><div class="titlepage"><div><div><h2 class="title"><a id="agent_advertisement_and_agent_solicitati"/>Agent Advertisement and Agent Solicitation Messages</h2></div></div></div><p>Provision already exists for exchanges of data between a router and a node in the form of Internet Control Message Protocol (ICMP) messages that are used for the regular IP <span class="emphasis"><em>Router Discovery</em></span> process. Two messages are used for this purpose: Router Advertisement messages that let routers tell local nodes that they exist and describe their capabilities, and Router Solicitation messages that let a node prompt a router to send an advertisement. These are described in <a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a>.</p><p>Given the similarity to normal Router Discovery, it made sense to implement Agent Discovery as a modification to the existing process rather than set up a whole new system. The messages used in the Agent Discovery process are as follows:</p><p><span class="strong"><strong>Agent Advertisement</strong></span> This is a message transmitted regularly by a router acting as a Mobile IP agent. It consists of a regular Router Advertisement message that has one or more <span class="emphasis"><em>extensions</em></span> added that contain Mobile IP–specific information for mobile nodes.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1121"/>Agent Solicitation</strong></span> This message can be sent by a Mobile IP device to nudge a local agent to send an Agent Advertisement message.</p><p>The use of these messages is described in the Mobile IP standard in detail, and unsurprisingly, is very similar to how regular Router Advertisement and Router Solicitation messages are employed. Agents are normally configured to send out Agent Advertisements on a regular basis, with the rate set to ensure reasonably fast contact with mobile nodes without consuming excessive network bandwidth. They are required to respond to any Agent Solicitation messages they receive by sending an Advertisement. It is possible that some agents may be configured to send Advertisements only upon receipt of a Solicitation.</p><p>Mobile nodes are required to accept and process Agent Advertisements. They distinguish these from regular Router Advertisements by looking at the size of the message. They then parse the extension(s) to learn the capabilities of the local agent. They determine whether they are on their home network or a foreign network, and in the case of a foreign agent, how the agent should be used. Mobile nodes are required to use Agent Advertisements to detect when they have moved, using one of two algorithms defined in the standard. Mobile nodes are also required to detect when they have returned to their home network after they have been traveling. Finally, they are also required to be able to send Agent Solicitation messages if they don't receive an Agent Advertisement after a certain period of time. They are restricted to sending these only infrequently, however, in order to keep traffic manageable.</p><p>Now let's look at the formats of the two message types.</p><div class="sect3" title="Agent Solicitation Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="agent_solicitation_message_format"/>Agent Solicitation Message Format</h3></div></div></div><p>The Agent Solicitation message is simple. In fact, there is no new message format defined for this at all; it is identical to the format of a Router Solicitation message (see <a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a>).</p><p>The reason no new message type is required here is that a solicitation is an extremely simple message: "Hey, if there are any routers out there, please tell me who you are and what you can do." No extra <a class="indexterm" id="idx-CHP-30-1122"/>Mobile IP information needs to be sent. When a regular IP router receives a Router Solicitation, it will send a Router Advertisement, but a Mobile IP router automatically sends the longer <a class="indexterm" id="idx-CHP-30-1123"/>Agent Advertisement instead when prompted by any solicitation, whether it comes from a Mobile IP node or a regular IP device.</p></div><div class="sect3" title="Agent Advertisement Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="agent_advertisement_message_format"/>Agent Advertisement Message Format</h3></div></div></div><p>The Agent Advertisement begins with the normal fields of an ICMP Router Advertisement message (see <a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a>). The destination of the message is either the "all devices" multicast address (224.0.0.1) if multicast is supported on the local network, or the broadcast address (255.255.255.255) otherwise. The <span class="emphasis"><em>Router Address</em></span> fields are filled in with the address(es) of the agent.</p><div class="note" title="Note"><h3 class="title"><a id="note-96"/>Note</h3><p><span class="emphasis"><em>It is possible that a device may wish to advertise its ability to handle Mobile IP messages, but not act as a regular router. In this case it changes the normal Code field in the header of the Router Advertisement message from 0 to 16</em></span>.</p></div><p>Following the regular fields, one or more extensions are added:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1124"/>Mobility Agent Advertisement Extension</strong></span> This is the main extension used to convey Mobile IP capabilities of the agent to mobile nodes on the local network. This field is described in Tables <a class="xref" href="ch30s04.html#mobile_ip_mobility_agent_advertise-id001" title="Table 30-1. Mobile IP Mobility Agent Advertisement Extension Format">Table 30-1</a> and <a class="xref" href="ch30s04.html#mobile_ip_mobility_agent_advertise-id002" title="Table 30-2. Mobile IP Mobility Agent Advertisement Extension Flags">Table 30-2</a> and illustrated in <a class="xref" href="ch30s04.html#mobile_ip_mobility_agent_advertisement_e" title="Figure 30-4. Mobile IP Mobility Agent Advertisement Extension format This extension appears after the normal fields of a Router Advertisement message, as shown in Chapter 33.">Figure 30-4</a>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1125"/>Prefix-Lengths Extension</strong></span> This is an optional extension that tells a mobile node the prefix length(s) of the router address(es) contained in the regular portion of the Agent Advertisement message; that is, the Router Address field in the regular Router Advertisement part of the message. The prefix length is another term for the number of bits of a network ID in an address, so this specifies the network ID in the router addresses. This field is described in <a class="xref" href="ch30s04.html#mobile_ip_prefix-lengths_extension_forma" title="Table 30-3. Mobile IP Prefix-Lengths Extension Format">Table 30-3</a> and illustrated in <a class="xref" href="ch30s04.html#mobile_ip_prefix-lengths_extension-id001" title="Figure 30-5. Mobile IP Prefix-Lengths Extension format This extension appears after the normal fields of a Router Advertisement message, as shown in Chapter 33.">Figure 30-5</a>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1126"/>One-Byte Padding Extension</strong></span> Some implementations require ICMP messages to be an even number of bytes, so a byte of padding is needed. This field is just a single byte of all zeros.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-168"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Mobile IP <span class="emphasis"><em>Agent Discovery</em></span> is the process by which a mobile node determines where it is located and establishes contact with a home or foreign agent. To indicate their capabilities, routers that can function as agents regularly send <span class="emphasis"><em>Agent Advertisement</em></span> messages, which are modified versions of regular <span class="emphasis"><em>Router Advertisements</em></span>. To request the sending of an <span class="emphasis"><em>Advertisement</em></span>, a mobile node can also send an <span class="emphasis"><em>Agent Solicitation</em></span>, which is the same as a regular <span class="emphasis"><em>Router Solicitation</em></span>.</p></div><p>I should point out that Mobile IP does not include any provisions for the authentication of <span class="emphasis"><em>Agent Advertisement</em></span> and <span class="emphasis"><em>Agent Solicitation</em></span> messages. They may be authenticated using IPsec, if that has been implemented.</p><div class="figure"><a id="mobile_ip_mobility_agent_advertisement_e"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e31974"/><img alt="Mobile IP Mobility Agent Advertisement Extension format This extension appears after the normal fields of a Router Advertisement message, as shown in ." src="httpatomoreillycomsourcenostarchimages287945.png.jpg"/></div></div><p class="title">Figure 30-4. Mobile IP Mobility Agent Advertisement Extension format This extension appears after the normal fields of a Router Advertisement message, as shown in <a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a>.</p></div><div class="table"><a id="mobile_ip_mobility_agent_advertise-id001"/><p class="title">Table 30-1. Mobile IP Mobility Agent Advertisement Extension Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Mobile IP Mobility Agent Advertisement Extension Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the <a class="indexterm" id="idx-CHP-30-1127"/>Agent Advertisement extension type. For the <a class="indexterm" id="idx-CHP-30-1128"/>Mobility Agent Advertisement Extension, it is set to 16.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Length of the extension in bytes, excluding the Type and Length fields. Thus, it is equal to 6 plus 4 for each care-of address in the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A sequential counter is set to zero when the router initializes and then incremented for each advertisement sent out.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Registration Lifetime</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The maximum length of time, in seconds, that the agent is willing to accept for registration requests. A value of 65,535 (all ones) means infinite. Note that this field is for registration only and has no relation to the regular Lifetime field in the regular Router Advertisement part of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>A one-byte field containing several informational flags that convey specific information about the agent's capabilities and status. There are seven one-bit flags, which, when set, convey the meanings shown in <a class="xref" href="ch30s04.html#mobile_ip_mobility_agent_advertise-id002" title="Table 30-2. Mobile IP Mobility Agent Advertisement Extension Flags">Table 30-2</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent as zero and ignored by recipient.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Care-Of Addresses</p></td><td style="border-right: 0.5pt solid ; "><p>Variable (4 per address)</p></td><td style=""><p>Zero or more addresses provided by a foreign agent for a mobile node to use as a foreign agent care-of address. A foreign agent must always provide at least one address in its advertisement. A router that cannot act as a foreign agent will typically omit this field.</p></td></tr></tbody></table></div></div><div class="table"><a id="mobile_ip_mobility_agent_advertise-id002"/><p class="title">Table 30-2. Mobile IP Mobility Agent Advertisement Extension Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Mobile IP Mobility Agent Advertisement Extension Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-30-1129"/>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration Required: The mobile node must register through the foreign agent, even when using a co-located care-of address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Busy: The agent is currently too busy to accept further registrations from mobile nodes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>H</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Home Agent: The agent is willing to function as a home agent on this link (it will forward datagrams, and so on). Note that a device can offer services as both a home agent and a foreign agent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>F</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Foreign Agent: The agent is willing to function as a foreign agent. Again, a device can act as both a home agent and a foreign agent simultaneously.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Minimal Encapsulation: The agent can receive tunneled datagrams using minimal encapsulation.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>G</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>GRE Encapsulation: The agent can receive tunneled datagrams using GRE encapsulation.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>r</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved: Not used; sent as zero.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>T</p></td><td style="border-right: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style=""><p>Reverse Tunneling: The agent supports reverse tunneling.</p></td></tr></tbody></table></div></div><div class="table"><a id="mobile_ip_prefix-lengths_extension_forma"/><p class="title">Table 30-3. Mobile IP Prefix-Lengths Extension Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Mobile IP Prefix-Lengths Extension Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-30-1130"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the <a class="indexterm" id="idx-CHP-30-1131"/>Agent Advertisement extension type. For the <a class="indexterm" id="idx-CHP-30-1132"/>Prefix-Lengths Extension, it is set to 19.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Length of the extension in bytes, excluding the Type and Length fields. Thus, it is equal to the number of prefix lengths (since each takes 1 byte).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Prefix Lengths</p></td><td style="border-right: 0.5pt solid ; "><p>Variable (1 per length)</p></td><td style=""><p>One prefix length number for each router address in the regular, Router Advertisement portion of the <a class="indexterm" id="idx-CHP-30-1133"/>Agent Advertisement.</p></td></tr></tbody></table></div></div><div class="figure"><a id="mobile_ip_prefix-lengths_extension-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e32262"/><img alt="Mobile IP Prefix-Lengths Extension format This extension appears after the normal fields of a Router Advertisement message, as shown in ." src="httpatomoreillycomsourcenostarchimages287947.png.jpg"/></div></div><p class="title">Figure 30-5. Mobile IP Prefix-Lengths Extension format This extension appears after the normal fields of a Router Advertisement message, as shown in <a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a>.</p></div><p>See the section on Mobile IP encapsulation later in this chapter for details on minimal and Generic Routing Encapsulation (GRE) encapsulation and reverse tunneling.</p></div></div></div>
<div class="sect1" title="Mobile IP Home Agent Registration and Registration Messages"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_home_agent_registration_and_re"/>Mobile IP Home Agent Registration and Registration Messages</h1></div></div></div><p>Once a mobile node has completed Agent Discovery, it knows whether it is on its home network or a foreign network. If it's on its home network, it communicates as a regular IP device, but if it's on a foreign network, it must activate Mobile IP. This requires that it communicate with its home agent so that information and instructions can be exchanged between the two. This process is called <span class="emphasis"><em>home agent registration</em></span>, or more simply, just <span class="emphasis"><em>registration</em></span>.</p><p>The main purpose of registration is to actually start Mobile IP working. The mobile node must contact the home agent and tell it that it is on a foreign network and request that datagram forwarding be turned on. It also must let the home agent know its care-of address so the home agent knows where to send the forwarded datagrams. The home agent needs to communicate various types of information back to the mobile node when registration is performed. Note that the foreign agent is not really involved in registration, except perhaps to relay messages.</p><div class="sect2" title="Mobile Node Registration Events"><div class="titlepage"><div><div><h2 class="title"><a id="mobile_node_registration_events"/>Mobile Node Registration Events</h2></div></div></div><p>Successful registration establishes what is called in the standard a <span class="emphasis"><em>mobility binding</em></span> between a home agent and a mobile node. For the duration of the registration, the mobile node's regular home address is tied to its current care-of address, and the home agent will encapsulate and forward datagrams addressed to the home address over to the care-of address. The mobile node is supposed to manage its registration and handle various events using the following actions:</p><p><span class="strong"><strong>Registration</strong></span> The mobile node initiates a <span class="emphasis"><em>registration</em></span> when it first detects it has moved from its home network to a foreign network.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1134"/>Deregistration</strong></span> When the mobile node returns home, it should tell the home agent to cancel forwarding—a process called <span class="emphasis"><em>deregistration</em></span>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1135"/>Reregistration</strong></span> If the mobile node moves from one foreign network to another, or if its care-of address changes, it must update its registration with the home agent. It also must do so if its current registration is about to expire, even if it remains stationary on one foreign network.</p><p>Each registration is established only for a specific length of time, which is why regular reregistration is required whether or not the device moves. Registrations are time-limited to ensure that they do not become stale. If, for example, a node forgets to deregister when it returns home, the datagram forwarding will eventually stop when the registration expires.</p></div><div class="sect2" title="Registration Request and Registration Reply Messages"><div class="titlepage"><div><div><h2 class="title"><a id="registration_request_and_registration_re"/>Registration Request and Registration Reply Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1136"/><a class="indexterm" id="idx-CHP-30-1137"/>To perform registration, two new message types have been defined in Mobile IP: the <span class="emphasis"><em>Registration Request</em></span> and the <span class="emphasis"><em>Registration Reply</em></span>. Each of these does what you would expect from its name. Interestingly, these are not ICMP messages like the ones used in Agent Discovery; they are User Datagram Protocol (UDP) messages. Thus, technically speaking, <a class="indexterm" id="idx-CHP-30-1138"/>registration is performed at a higher layer than the rest of <a class="indexterm" id="idx-CHP-30-1139"/>Mobile IP communication. Agents listen for <a class="indexterm" id="idx-CHP-30-1140"/>Registration Requests on well-known UDP port 434, and respond back to mobile nodes using whatever ephemeral port the node used to send the message.</p></div><div class="sect2" title="Registration Process"><div class="titlepage"><div><div><h2 class="title"><a id="registration_process"/>Registration Process</h2></div></div></div><p>There are two different procedures defined for registration, depending on the type of care-of address used by the mobile node, and other specifics that I will get into shortly. The first is the direct registration method, which has only two steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The mobile node sends a Registration Request to the home agent.</p></li><li class="listitem"><p>The home agent sends a Registration Reply back to the mobile node.</p></li></ol></div><p>In some cases, however, a slightly more complex process is required, whereby the foreign agent conveys messages between the home agent and the mobile node. In this situation, the process has four steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The mobile node sends a Registration Request to the foreign agent.</p></li><li class="listitem"><p>The foreign agent processes a Registration Request and forwards it to the home agent.</p></li><li class="listitem"><p>The home agent sends a Registration Reply to a foreign agent.</p></li><li class="listitem"><p>The foreign agent processes a Registration Reply and sends back to the mobile node.</p></li></ol></div><p>The first, simpler method is normally used when a mobile node is using a co-located care-of address. In that situation, the node can easily communicate directly with the home agent, and the mobile node is also set up to directly receive information and datagrams from the home agent. When there is no foreign agent, this is obviously the only method available. It is also obviously the only method when a mobile node is deregistering with its home agent after it arrives back on the home network.</p><p>The second method is required when a mobile node is using a foreign care-of address. You'll recall that in this situation, the mobile node doesn't have its own unique IP address at all; it is using a shared address that was given to it by the foreign agent, which precludes direct communication between the node and the home agent. Also, if a mobile node receives an Agent Advertisement with the R flag set, it also should go through the foreign agent, even if it has a co-located care-of address.</p><p>Note that the foreign agent really is just a middleman; the exchange is still really between the home agent and the mobile node. However, the foreign agent can deny registration if the request violates whatever rules are in place for using the foreign network. It is for this reason that some foreign agents may require that they be the conduits for registrations even if the mobile node has a co-located care-of address. Of course, if the foreign agent can't contact the home agent the registration will not be able to proceed.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-169"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Mobile IP <span class="emphasis"><em>home agent registration</em></span> is the process by which a <span class="emphasis"><em>mobility binding</em></span> is created between a home agent and a traveling mobile node to enable datagram forwarding to be performed. The mobile node that sends a <a class="indexterm" id="idx-CHP-30-1141"/>Registration Request message performs registration, and the home agent returns a Registration Reply. The foreign agent may be required to act as a middleman in order to facilitate the transaction, but is otherwise not involved.</p></div><p>The previous description is really a highly simplified explanation of the basics of registration. The Mobile IP standard specifies many more details on exactly how agents and nodes perform registration, including particulars on when requests and replies are sent, how to handle various special conditions such as invalid requests, rules for how home agents maintain a table of mobility bindings, and much more. The standard covers the definition of extensions to the regular registration messages that support authentication, which is required for secure communications (see the section on security issues later in this chapter for more details). It also includes the ability to have a mobile node that maintains more than one concurrent binding, when needed.</p></div><div class="sect2" title="Registration Request Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="registration_request_message_format"/>Registration Request Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1142"/><a class="indexterm" id="idx-CHP-30-1143"/>Registration Request messages have the format shown in Tables <a class="xref" href="ch30s05.html#mobile_ip_registration_request_message_f" title="Table 30-4. Mobile IP Registration Request Message Format">Table 30-4</a> and <a class="xref" href="ch30s05.html#registration_request_flags" title="Table 30-5. Registration Request Flags">Table 30-5</a> and illustrated in <a class="xref" href="ch30s05.html#mobile_ip_registration_request_mes-id001" title="Figure 30-6. Mobile IP Registration Request message format This message is carried in the payload of a User Datagram Protocol (UDP) message, the headers of which are not shown.">Figure 30-6</a>. See the section on Mobile IP encapsulation later in this chapter for details on minimal and GRE encapsulation and reverse tunneling.</p><div class="table"><a id="mobile_ip_registration_request_message_f"/><p class="title">Table 30-4. Mobile IP Registration Request Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Mobile IP Registration Request Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the registration message type. For a request, this field is 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>A one-byte field containing several informational flags that convey specific requests that are being made by the mobile node to the home agent. When set, the flags conveys the meanings shown in <a class="xref" href="ch30s05.html#registration_request_flags" title="Table 30-5. Registration Request Flags">Table 30-5</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lifetime</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Length of time, in seconds, that the mobile node requests from the home agent for this registration.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Home Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The home (normal) IP address of the mobile node when on its home network. Uniquely identifies the device regardless of how the request is conveyed to the home agent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Home Agent</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The IP address of the device acting as the mobile node's home agent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Care-Of Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The IP address being used by the mobile node as its care-of address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identification</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 64-bit number that uniquely identifies the <span class="emphasis"><em>Registration Request</em></span> and is used to match requests to replies. It also provides protection against replay attacks; see the section on Mobile IP security issues later in this chapter for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Extensions</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Extension fields are included here for authentication of the request. Other extensions may also be included.</p></td></tr></tbody></table></div></div><div class="table"><a id="registration_request_flags"/><p class="title">Table 30-5. Registration Request Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Registration Request Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>S</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Simultaneous Bindings: Mobile node requests that prior mobility bindings be retained in addition to the one in the current request.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Broadcast Datagrams: Mobile node requests that broadcasts on the home network be forwarded to it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Decapsulation by Mobile Node: Mobile node is telling the home agent that it will itself decapsulate encapsulated datagrams, as opposed to a foreign agent. In other words, when this is one, the mobile node is using a co-located care-of address; when zero, it is using a foreign agent care-of address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Minimal Encapsulation: Mobile node requests that home agent use minimal encapsulation for forwarded datagrams.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>G</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>GRE Encapsulation: Mobile node requests that home agent use GRE encapsulation for forwarded datagrams.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>r</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved: Not used; sent as zero.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>T</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reverse Tunneling: Mobile node requests that reverse tunneling be used by the home agent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>x</p></td><td style="border-right: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style=""><p>Reserved: Not used; sent as zero.</p></td></tr></tbody></table></div></div><div class="figure"><a id="mobile_ip_registration_request_mes-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e32635"/><img alt="Mobile IP Registration Request message format This message is carried in the payload of a User Datagram Protocol (UDP) message, the headers of which are not shown." src="httpatomoreillycomsourcenostarchimages287949.png.jpg"/></div></div><p class="title">Figure 30-6. Mobile IP Registration Request message format This message is carried in the payload of a User Datagram Protocol (UDP) message, the headers of which are not shown.</p></div></div><div class="sect2" title="Registration Reply Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="registration_reply_message_format"/>Registration Reply Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1144"/><a class="indexterm" id="idx-CHP-30-1145"/>Registration Reply messages are formatted as shown in <a class="xref" href="ch30s05.html#mobile_ip_registration_reply_message_for" title="Table 30-6. Mobile IP Registration Reply Message Format">Table 30-6</a> and illustrated in <a class="xref" href="ch30s05.html#mobile_ip_registration_reply_messa-id001" title="Figure 30-7. Mobile IP Registration Reply Message format This message is carried in the payload of a UDP message, the headers of which are not shown.">Figure 30-7</a>.</p><div class="table"><a id="mobile_ip_registration_reply_message_for"/><p class="title">Table 30-6. Mobile IP Registration Reply Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Mobile IP Registration Reply Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-30-1146"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the registration message type. For a reply, this field is 3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the result of the registration request. This field is set to 0 if the registration was accepted, 1 if it was accepted but simultaneous bindings were requested and are not supported. If the registration was denied, a different reason code is provided that indicates the reason for the rejection, as well as whether it was the home agent or foreign agent that denied it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lifetime</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>If the registration was accepted, this represents the length of time in seconds until the registration expires. This may be a different value than the mobile node requested.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Home Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The home (normal) IP address of the mobile node when it's on its home network. Uniquely identifies the device regardless of how the request is conveyed to the home agent so that the message can be delivered to it if the same foreign agent serves multiple mobile nodes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Home Agent</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The IP address of the device acting as the mobile node's home agent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identification</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 64-bit number that uniquely identifies the <span class="emphasis"><em>Registration Reply</em></span> and is matched to the Identification field of the request that precipitated it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Extensions</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Extension fields are included here for the authentication of the reply. Other extensions may also be included.</p></td></tr></tbody></table></div></div><div class="figure"><a id="mobile_ip_registration_reply_messa-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e32757"/><img alt="Mobile IP Registration Reply Message format This message is carried in the payload of a UDP message, the headers of which are not shown." src="httpatomoreillycomsourcenostarchimages287951.png"/></div></div><p class="title">Figure 30-7. Mobile IP Registration Reply Message format This message is carried in the payload of a UDP message, the headers of which are not shown.</p></div></div></div>
<div class="sect1" title="Mobile IP Data Encapsulation and Tunneling"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_data_encapsulation_and_tunneli"/>Mobile IP Data Encapsulation and Tunneling</h1></div></div></div><p><a class="indexterm" id="idx-CHP-30-1147"/>Once a mobile node on a foreign network has completed a successful registration with its home agent, the Mobile IP datagram forwarding process described earlier in this chapter will be fully "activated." The home agent will intercept datagrams intended for the mobile node as they are routed to its home network, and forward them to the mobile node. Encapsulating the datagrams, and then sending them to the node's care-of address, does this.</p><p>Encapsulation is required because each datagram that you intercept and forward needs to be resent over the network to the device's care-of address. In theory, the designers might conceivably have done this by just having the home agent change the destination address and stick it back out on the network, but there are various complications that make this unwise. It makes more sense to take the entire datagram and wrap it in a new set of headers before retransmitting. In my mail-forwarding analogy, this is comparable to taking a letter received for the traveling consultant and putting it into a fresh envelope for forwarding, as opposed to just crossing off the original address and putting a new one on.</p><p>The default encapsulation process used in Mobile <a class="indexterm" id="idx-CHP-30-1148"/>IP is called <a class="indexterm" id="idx-CHP-30-1149"/><span class="emphasis"><em>IP Encapsulation within IP</em></span>, which is as it's defined in RFC 2003. It's commonly abbreviated <span class="emphasis"><em>IP-in-IP</em></span>. It is a relatively simple method that describes how to take an IP datagram and make it the payload of another IP datagram. In Mobile IP, the new headers specify how to send the encapsulated datagram to the mobile node's care-of address.</p><p>In addition to IP-in-IP, the following two encapsulation methods may be optionally used: <a class="indexterm" id="idx-CHP-30-1150"/><span class="emphasis"><em>Minimal Encapsulation within IP</em></span>, which is defined in RFC 2004, and <a class="indexterm" id="idx-CHP-30-1151"/><span class="emphasis"><em>Generic Routing Encapsulation (GRE)</em></span><a class="indexterm" id="idx-CHP-30-1152"/>, which is defined in RFC 1701. To use either of these, the mobile node must request the appropriate method in its Registration Request, and the home agent must agree to use it. If foreign agent care-of addressing is used, the foreign agent also must support the method desired.</p><div class="sect2" title="Mobile IP Conventional Tunneling"><div class="titlepage"><div><div><h2 class="title"><a id="mobile_ip_conventional_tunneling"/>Mobile IP Conventional Tunneling</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1153"/>The encapsulation process creates a logical construct called a <span class="emphasis"><em>tunnel</em></span> between the device that encapsulates and the one that decapsulates. This is the same idea of a tunnel used in discussions of <a class="indexterm" id="idx-CHP-30-1154"/>virtual private networks (<a class="indexterm" id="idx-CHP-30-1155"/>VPNs), IPsec tunnel mode, or the various other <a class="indexterm" id="idx-CHP-30-1156"/>tunneling protocols used for security. The tunnel represents a conduit over which datagrams are forwarded across an arbitrary internetwork, with the details of the encapsulated datagram (meaning the original IP headers) temporarily hidden.</p><p>In Mobile IP, the start of the tunnel is the home agent, which does the encapsulation. The end of the tunnel depends on which of the two types of care-of address is being used:</p><p><span class="strong"><strong>Foreign Agent Care-Of Address</strong></span> The foreign agent is the end of the tunnel. It receives encapsulated messages from the home agent, strips off the outer IP header, and then delivers the datagram to the mobile node. This is generally done using layer 2, because the mobile node and foreign agent are on the same local network, and the mobile node does not have its own IP address on that network, because it is using the foreign agent's address.</p><p><span class="strong"><strong>Co-Located Care-Of Address</strong></span> The mobile node itself is the end of the tunnel and strips off the outer header.</p><p>Normally, the tunnel described previously is used only for datagrams that have been sent to the mobile node and captured by the home agent. When the mobile node wants to send a datagram, it doesn't tunnel it back to the home agent; this would be needlessly inefficient. Instead, it just sends out the datagram directly using whatever router it can find on its current network, which may or may not be a foreign agent. When it does this, it uses its own home address as the source address for any requests it sends. As a result, any response to those requests will go back to the home network. This sets up a triangle of three <a class="indexterm" id="idx-CHP-30-1157"/>transmissions for these kinds of transactions (illustrated in <a class="xref" href="ch30s06.html#mobile_ip_encapsulation_and_tunneling_th" title="Figure 30-8. Mobile IP encapsulation and tunneling This example illustrates how a typical request/reply message exchange in Mobile IP results in a triangle of communication. In step 1, the mobile node sends a request to a remote server somewhere on the Internet. It uses its own home address as the source for this request, so in step 2, the reply goes back to the home agent. Step 3 consists of the home agent tunneling the reply back to the mobile node.">Figure 30-8</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The mobile node sends a request from the foreign network to some third-party device somewhere on the internetwork.</p></li><li class="listitem"><p>The third-party device responds back to the mobile node. However, this sends the reply back to the model node's home address on its home network.</p></li><li class="listitem"><p>The home agent intercepts the response on the home network and tunnels it back to the mobile node.</p></li></ol></div><div class="figure"><a id="mobile_ip_encapsulation_and_tunneling_th"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e32865"/><img alt="Mobile IP encapsulation and tunneling This example illustrates how a typical request/reply message exchange in Mobile IP results in a triangle of communication. In step 1, the mobile node sends a request to a remote server somewhere on the Internet. It uses its own home address as the source for this request, so in step 2, the reply goes back to the home agent. Step 3 consists of the home agent tunneling the reply back to the mobile node." src="httpatomoreillycomsourcenostarchimages287953.png.jpg"/></div></div><p class="title">Figure 30-8. Mobile IP encapsulation and tunneling This example illustrates how a typical request/reply message exchange in Mobile IP results in a triangle of communication. In step 1, the mobile node sends a request to a remote server somewhere on the Internet. It uses its own home address as the source for this request, so in step 2, the reply goes back to the home agent. Step 3 consists of the home agent tunneling the reply back to the mobile node.</p></div><p><a class="indexterm" id="idx-CHP-30-1158"/><a class="indexterm" id="idx-CHP-30-1159"/> The reverse transaction would be pretty much the same, except in the reverse order. In that case, the third-party (Internet) device would send a request to mobile node, which would be received and forwarded by the home agent. The mobile node would reply back directly to the Internet host.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-170"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Once <a class="indexterm" id="idx-CHP-30-1160"/>Mobile IP is set up and operational, it works by having the home agent <span class="emphasis"><em>encapsulate</em></span> and <span class="emphasis"><em>tunnel</em></span> received datagrams to the mobile node. The mobile device normally sends datagrams directly to Internet hosts, which respond back to the mobile's home agent, which forwards those datagrams to the mobile node. This means a request/reply communication takes three transmissions.</p></div></div><div class="sect2" title="Mobile IP Reverse Tunneling"><div class="titlepage"><div><div><h2 class="title"><a id="mobile_ip_reverse_tunneling"/>Mobile IP Reverse Tunneling</h2></div></div></div><p><a class="indexterm" id="idx-CHP-30-1161"/>There may be situations where it is not feasible or desired to have the mobile node send datagrams directly to the internetwork using a router on the foreign network, as you just saw. In this case, an optional feature called <a class="indexterm" id="idx-CHP-30-1162"/><span class="emphasis"><em>reverse tunneling</em></span> may be deployed if it is supported by the mobile node, the home agent, and, if relevant, the foreign agent. When this is done, a reverse tunnel that complements the normal one is set up between the mobile node and the home agent, or between the foreign agent and the home agent, depending on the care-of address type. All transmissions from the mobile node are tunneled back to the home network where the home agent transmits them over the internetwork, thereby resulting in a more symmetric operation as opposed to the triangle just described. This is basically what I described earlier as being needlessly inefficient, because it means each communication requires four steps. Thus, it is used only when necessary.</p><p>One situation for which reverse tunneling may be required is if the network where the mobile node is located has implemented certain security measures that prohibit the node from sending datagrams using its normal IP address. In particular, a network may be set up to disallow outgoing datagrams with a source address that doesn't match its network prefix. This is often done to prevent <span class="emphasis"><em>spoofing</em></span> (impersonating another's IP address).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-171"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> An optional feature called <span class="emphasis"><em>reverse tunneling</em></span> may be used in certain cases, such as when a network does not allow outgoing datagrams with a foreign source IP address. When enabled, rather than sending datagrams directly, the mobile node tunnels all transmissions back to the home agent, which sends them on the Internet.</p></div><p>Note that everything I've just discussed is applicable to normal—meaning unicast—datagrams that are sent to and from the mobile node. Broadcast datagrams on the home network, which would normally be intended for the mobile node if it were at home, are not forwarded unless the node specifically asks for this service during registration. Multicast operation on the foreign network is also supported, but extra work is required by the mobile node to set it up.</p></div></div>
<div class="sect1" title="Mobile IP and TCP/IP Address Resolution Protocol (ARP) Operation"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_and_tcpip_address_resolution_p"/>Mobile IP and TCP/IP Address Resolution Protocol (ARP) Operation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-30-1163"/>Mobile IP is a protocol that does a good job of implementing a difficult function: It transparently allows an IP device to travel to a different network. Unfortunately, a problem with any protocol that tries to change how IP works is dealing with special cases. Having a home agent intercept datagrams and tunnel them to the mobile node works well in general terms, but there are some instances in which extra work is required. One of these is the use of ARP, which breaks under <a class="indexterm" id="idx-CHP-30-1164"/>Mobile IP unless we take special steps.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-172"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>Some understanding of how ARP works in general terms is assumed in this topic. This includes ARP proxying, which is described in <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a></em></span>.</p></div><p>To understand what the problem is with ARP, consider a mobile node that is on a foreign network and has successfully registered with its home agent. The home agent will intercept all datagrams that come onto the home network, particularly the ones intended for the mobile node, and then encapsulate and forward them. For this to happen, though, the home agent (home router) must see the datagram. This normally occurs only when a datagram comes onto the home network from the outside and is processed by the router.</p><p>What happens when a local device on the home network itself wants to transmit to a mobile node that has traveled elsewhere? Remember that this device may not be mobile itself and probably knows nothing about Mobile IP. It will follow the standard process for deciding what to do with a datagram that it needs to send, as explained in <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a>. It will compare its network ID to that of the mobile node and realize that it doesn't need to route its datagram; it can send it directly to the mobile node.</p><p>The local host will attempt to use ARP to find the data link layer address of the mobile node so that it can send the datagram to it directly. The host will start by looking in its ARP cache, and if it finds the node's data link layer address there, it will use it to send at layer 2. The mobile node is no longer on the local network segment, so the message will never be received. If there is no ARP cache entry, the host on the home network will attempt to send an ARP Request to the mobile node to determine its layer 2 address. Again, the mobile node has traveled away, so this request will go unanswered.</p><p>Solving this problem requires the intervention of, you guessed it, the home agent. It must perform two tasks to enable local hosts to send to the mobile node:</p><p><span class="strong"><strong>ARP Proxying</strong></span> The home agent must listen for any ARP Requests that are sent by nodes on the same network as any of the mobile nodes that are currently registered to it. When it hears one, it replies in the mobile node's stead, and specifies its own data link layer address as the binding for the mobile node's IP address. This will cause hosts on the home network to send any datagrams that are intended for the mobile node to the home agent where they can be forwarded. This process is illustrated in <a class="xref" href="ch30s07.html#arp_proxying_by_mobile_ip_home_agent_the" title="Figure 30-9. ARP proxying by Mobile IP home agent The home agent must take special steps to deal with transmissions from devices on the local network to the mobile node. In this example (using short hardware addresses for simplicity), the hardware address of the mobile node is 48 and the home agent is 63. A local client on the home network with hardware address 97 sends an ARP Request to find out the hardware address of the mobile node. The home agent responds on the mobile's behalf, specifying not hardware address 48 but rather its own address: 63. The client will thus send to the home agent, which can then forward the data to the mobile node on the foreign network.">Figure 30-9</a>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-30-1165"/>Gratuitous ARP</strong></span> Proxying helps with ARP Requests, but what about devices that already have cache entries for the mobile node? As soon as the mobile node leaves the network, these become automatically stale. To correct them, the home agent sends what is called a <a class="indexterm" id="idx-CHP-30-1166"/><span class="emphasis"><em>gratuitous</em></span> ARP message, which tells devices on the local network to associate the mobile node's IP address with the home agent's data link layer address. The term <span class="emphasis"><em>gratuitous</em></span> refers to the fact that the device isn't sending the message in order to perform an actual address resolution, but merely to cause caches to be updated. It may be sent more than once to ensure that every device gets the message.</p><div class="figure"><a id="arp_proxying_by_mobile_ip_home_agent_the"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e32992"/><img alt="ARP proxying by Mobile IP home agent The home agent must take special steps to deal with transmissions from devices on the local network to the mobile node. In this example (using short hardware addresses for simplicity), the hardware address of the mobile node is 48 and the home agent is 63. A local client on the home network with hardware address 97 sends an ARP Request to find out the hardware address of the mobile node. The home agent responds on the mobile's behalf, specifying not hardware address 48 but rather its own address: 63. The client will thus send to the home agent, which can then forward the data to the mobile node on the foreign network." src="httpatomoreillycomsourcenostarchimages287955.png.jpg"/></div></div><p class="title">Figure 30-9. ARP proxying by Mobile IP home agent The home agent must take special steps to deal with transmissions from devices on the local network to the mobile node. In this example (using short hardware addresses for simplicity), the hardware address of the mobile node is 48 and the home agent is 63. A local client on the home network with hardware address 97 sends an ARP Request to find out the hardware address of the mobile node. The home agent responds on the mobile's behalf, specifying not hardware address 48 but rather its own address: 63. The client will thus send to the home agent, which can then forward the data to the mobile node on the foreign network.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-173"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In theory, problems can occur with hosts on the mobile node's home network that are trying to send datagrams to the host at layer 2. To address these issues, the home agent is required to use proxy ARP to direct such devices to send to the home agent so they can be forwarded. It must also use <span class="emphasis"><em>gratuitous</em></span> ARP to update any existing ARP caches to that effect.</p></div><p>Once these steps are taken, ARP should function normally on the home link. When the mobile device returns back to the home network, the process must be reversed. Upon deregistration with the home agent, the mobile device will stop <a class="indexterm" id="idx-CHP-30-1167"/>proxying for the mobile node. Both the mobile node and the home agent will also send gratuitous ARP broadcasts that update local device caches. These will again associate the mobile node's IP address with its own layer 2 address, instead of the layer 2 address of the home agent.</p></div>
<div class="sect1" title="Mobile IP Efficiency Issues"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_efficiency_issues"/>Mobile IP Efficiency Issues</h1></div></div></div><p><a class="indexterm" id="idx-CHP-30-1168"/><a class="indexterm" id="idx-CHP-30-1169"/>Having the home agent forward all datagrams to the mobile node wherever it may be is a convenient solution to mobility, but it's also a rather inefficient one. Since the device must send every datagram first to the home network and then forward it to the mobile node, the datagrams are going to travel over some part of the internetwork twice. The degree of inefficiency represented by forwarding can be significant and may lead to problems with certain applications.</p><p>To see what the problem is, let's consider a traveling mobile Node M and a regular device that wants to send to it, Device A. The degree of the inefficiency of Mobile IP is a function of the internetwork distance between Device A and Node M's home network, compared to the internetwork distance between Device A and Node M's current network. By <span class="emphasis"><em>distance</em></span>, I mean the term as it is used in determining routes on an internetwork. Two devices are closer when it takes less time and fewer hops to communicate between them, and they are farther when more hops are required. (I use geography in the following examples to represent this notion of distance, but remember that geographical distance is only one factor in internetwork distance.)</p><p>Let's consider the case in which mobile Node M is on a foreign network that's quite far from home, and Device A wants to send a datagram using Node M's home IP address. Suppose the home network is in London and the device is again in Tokyo. Let's look at the inefficiency factor of Mobile IP, compared to the alternative of having the mobile node just get a new temporary IP address on the foreign network and not use Mobile IP. The following examples are arranged in order of increasing inefficiency:</p><p><span class="strong"><strong>Sending Device on Home Network</strong></span> In this situation, Device A will send a datagram that is immediately intercepted by the home agent on the home network and forwarded to the mobile node. There is really no inefficiency here at all (except for overhead for encapsulation and such), because even if Device A did send the datagram directly to the mobile node with a new foreign address, the datagram would probably be routed through the home agent router anyway.</p><p><span class="strong"><strong>Sending Device on Network Close to Home Network</strong></span> Let's say a device in Paris wants to send to the mobile node. The datagram goes from Paris to London and then to Tokyo. That's not too bad.</p><p><span class="strong"><strong>Sending Device on Network Close to Foreign Network</strong></span> Now suppose the sending device is in Taipei, Taiwan. In this situation, Mobile IP becomes quite inefficient. The datagram must be sent from Taipei all the way to London, and then all the way back to Tokyo.</p><p><span class="strong"><strong>Sending Device on Foreign Network</strong></span> The greatest inefficiency occurs when the sending device is actually on the foreign network that the mobile node is visiting. If Device A is on the mobile node's current network in Tokyo, it must send all the way to London, and then have the result forwarded all the way back again to Tokyo. Without Mobile IP, all you would need to do is use ARP and then deliver directly at layer 2 without needing routing at all! This scenario is illustrated in <a class="xref" href="ch30s08.html#a_mobile_ip_inefficiency_worst-case_scen" title="Figure 30-10. A Mobile IP inefficiency worst-case scenario This diagram shows the worst possible case of Mobile IP inefficiency. When a device on the foreign network where the mobile is located tries to send data to the mobile device. The sender here, 210.4.79.11, uses the mobile node's home address so that the transmission must be routed all the way back to London, and then forwarded back to Tokyo, even though the two devices might be sitting on the same desk!">Figure 30-10</a>.</p><p>Unfortunately, the worst-case scenario of the sending device on a foreign network is one that occurs quite often. It's common for a mobile device to connect with a foreign network in order for it to communicate specifically with the hosts on that network.</p><div class="figure"><a id="a_mobile_ip_inefficiency_worst-case_scen"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e33063"/><img alt="A Mobile IP inefficiency worst-case scenario This diagram shows the worst possible case of Mobile IP inefficiency. When a device on the foreign network where the mobile is located tries to send data to the mobile device. The sender here, 210.4.79.11, uses the mobile node's home address so that the transmission must be routed all the way back to London, and then forwarded back to Tokyo, even though the two devices might be sitting on the same desk!" src="httpatomoreillycomsourcenostarchimages287957.png.jpg"/></div></div><p class="title">Figure 30-10. A Mobile IP inefficiency worst-case scenario This diagram shows the worst possible case of Mobile IP inefficiency. When a device on the foreign network where the mobile is located tries to send data to the mobile device. The sender here, 210.4.79.11, uses the mobile node's home address so that the transmission must be routed all the way back to London, and then forwarded back to Tokyo, even though the two devices might be sitting on the same desk!</p></div><p>To make matters worse, consider what happens if reverse tunneling is used! Here, tunneling is done not just for datagrams sent to the mobile node, but for datagrams sent from the device as well. In the worst-case example, a request/reply pair from the mobile node to another device on the foreign network requires <span class="emphasis"><em>two</em></span> complete round-trips from Tokyo to London and back. Clearly, this is far from ideal.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-174"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since datagrams are sent to a Mobile IP at its home address, each datagram sent to the mobile device must first go back to its home network and then be forwarded to its current location. The level of <a class="indexterm" id="idx-CHP-30-1170"/>inefficiency that results depends on how far the sender is from the mobile's home network. The worst case actually occurs if the sender and mobile are on the same foreign network, in which case each transmission must make a round-trip to the mobile's home network and then back again.</p></div><p>There really isn't any solution to this problem within Mobile IP itself; it's just a natural consequence of how the protocol works. The only way to really improve things is to "hack in" a solution that ultimately boils down to one of the two options we always have in IP without mobility support: Either give the mobile device a temporary real IP address on the foreign network, or use a host-specific route for the mobile device while it's on the foreign network.</p><p>You've already seen that these both have problems, which is why Mobile IP was created in the first place. There may be situations, however, in which efficiency is more important than the transparent portability that Mobile IP provides. For a long-term deployment on a foreign network far from the home network, or for applications where efficiency is paramount, it may make sense to employ one of these techniques. For example, a corporation that has a small number of offices in different cities that are connected using the Internet might set up special routing. This would let mobile devices visiting from other cities talk directly to nodes that are local to the foreign part of the network without being routed across the Internet.</p></div>
<div class="sect1" title="Mobile IP Security Considerations"><div class="titlepage"><div><div><h1 class="title"><a id="mobile_ip_security_considerations"/>Mobile IP Security Considerations</h1></div></div></div><p><a class="indexterm" id="idx-CHP-30-1171"/><a class="indexterm" id="idx-CHP-30-1172"/>Security is always a concern in any internetworking environment these days, but is especially important with Mobile IP. There are a number of reasons for this. The reasons are related to both how the protocol is used and the specific mechanisms by which it is implemented.</p><p>In terms of use, security was kept in mind during Mobile IP's development because mobile devices often use wireless networking technologies. Wireless communication is inherently less secure than wired communication, because transmissions are sent out in the open, where they can be intercepted. It's also easier for malicious users to disrupt the operation of wireless devices.</p><p>In terms of operation, Mobile IP has a number of risks due to the fact that it uses a registration system and then forwards datagrams across an unsecured internetwork. A malicious device could interfere with registration process, thereby causing the datagrams intended for a mobile device to be diverted. A bad guy might also interfere with the data forwarding process itself by encapsulating a bogus datagram to trick a mobile node into thinking it was sent something that it never was.</p><p>For these reasons, the Mobile IP standard includes a limited number of explicit provisions to safeguard against various security risks. One security measure was considered sufficiently important that it was built into the Mobile IP standard directly: the authentication of Registration Request and Registration Reply messages. This authentication process is accomplished in a manner that's somewhat similar to how the IPsec Authentication Header (AH) operates, as described in <a class="xref" href="ch29.html" title="Chapter 29. IP SECURITY (IPSEC) PROTOCOLS">Chapter 29</a>. Its goal is to prevent unauthorized devices from intercepting traffic by tricking an agent into setting up, renewing, or canceling a registration improperly.</p><p>All Mobile IP devices are required to support authentication. Nodes must use it for requests, and agents must use it for replies. Keys must be assigned manually because there is no automated system for secure key distribution. The default authentication method uses <a class="indexterm" id="idx-CHP-30-1173"/><span class="emphasis"><em>HMAC-MD5</em></span> (specified in RFC 2403), which is one of two hashing algorithms used by IPsec.</p><p>Another concern is a security problem called a <a class="indexterm" id="idx-CHP-30-1174"/><span class="emphasis"><em>replay attack</em></span>. In this type of attack, a third party intercepts a datagram, holds on to it, and then resends it later on. This seems fairly harmless, but consider the importance of timing. Imagine a mobile node that registers with its home agent, and then later returns home and deregisters. If a malicious device captures a copy of the original Registration Request and resends it, the home agent might be fooled into thinking the node has traveled away from home when it has not. It could then intercept the forwarded datagrams.</p><p>The Identification field used in Registration Request and Registration Reply messages is designed to prevent replay attacks. Since each request has a different Identification number, nodes and agents can match up requests with replies and reject any datagrams they receive that are repeats of ones they have seen already. The Mobile IP standard also specifies alternative methods for protecting against replays.</p><p>While Mobile IP includes authentication measures for registration messages, it does not for other types of messages. It also doesn't specify authentication of encapsulated datagrams being forwarded from the home agent to the mobile node. Encryption is also not provided to safeguard the privacy of either control messages or forwarded datagrams. The obvious solution when stronger assurances of privacy or authenticity are required is to make use of the IPsec AH and/or Encapsulating Security Payload (ESP) protocols (described in <a class="xref" href="ch29.html" title="Chapter 29. IP SECURITY (IPSEC) PROTOCOLS">Chapter 29</a>).</p></div></body></html>