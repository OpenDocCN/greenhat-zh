- en: Chapter 13. Building Your Own Module
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章. 构建自己的模块
- en: Building your own Metasploit module is relatively simple, as long as you have
    some programming experience and an idea of what you want to build. Because Metasploit
    is primarily Ruby-based, we’ll be working in the Ruby programming language in
    this chapter. If you aren’t a Ruby ninja yet, but you have some exposure to the
    language, don’t fret; continue to practice and learn. It’s fairly easy to learn
    Ruby as you go. If you find yourself struggling with the concepts in this chapter,
    skip it for now, try to build up your Ruby knowledge, and revisit the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自己的Metasploit模块相对简单，只要你有一些编程经验，并且知道你想要构建什么。因为Metasploit主要是基于Ruby的，所以在本章中我们将使用Ruby编程语言。如果你还不是Ruby忍者，但已经接触过这门语言，不要担心；继续练习和学习。随着你的学习，Ruby相对容易掌握。如果你发现自己在本章的概念上遇到困难，可以先跳过，尝试积累Ruby知识，然后再回过头来学习这一章。
- en: In this chapter, we’ll write a module called *mssql_powershell* to harness a
    technique released at the Defcon 18 Hacking Conference by Josh Kelley (winfang)
    and David Kennedy. This module targets Windows platforms with Microsoft’s PowerShell
    installed (the default on Windows 7).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个名为*mssql_powershell*的模块，利用在Defcon 18黑客大会上由Josh Kelley（winfang）和David
    Kennedy发布的技术。此模块针对已安装Microsoft PowerShell的Windows平台（Windows 7的默认设置）。
- en: This module converts a standard MSF binary payload to a *hex-blob* (a hexadecimal
    representation of binary data) that can be transmitted to a target system through
    Microsoft SQL commands. Once this payload is on the target system, a PowerShell
    script is used to convert the hexadecimal data back to a binary executable, execute
    it, and deliver a shell to the attacker. This module is already in Metasploit
    and was developed by one of the authors of this book; it’s a great lesson on how
    to build your own modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块将标准的MSF二进制有效载荷转换为*hex-blob*（二进制数据的十六进制表示），可以通过Microsoft SQL命令传输到目标系统。一旦此有效载荷在目标系统上，就使用PowerShell脚本来将十六进制数据转换回二进制可执行文件，执行它，并将shell提供给攻击者。此模块已在Metasploit中，并由本书的作者之一开发；它是如何构建自己的模块的一个很好的例子。
- en: The ability to convert a binary to hexadecimal, transmit it via MS SQL, and
    convert it back to binary is an excellent example of how powerful the Metasploit
    Framework can be. As you’re performing penetration tests, you will encounter many
    unfamiliar scenarios or situations; your ability to create or modify modules and
    exploits on the fly will give you that needed edge. As you begin to understand
    the Framework, you’ll be able to write these types of modules in a relatively
    short amount of time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制转换为十六进制，通过MS SQL传输，并将其转换回二进制的能力是Metasploit框架强大功能的一个极好例子。在你进行渗透测试时，你将遇到许多不熟悉的场景或情况；你创建或即时修改模块和攻击的能力将为你提供所需的竞争优势。随着你开始理解框架，你将能够在相对较短的时间内编写这些类型的模块。
- en: Getting Command Execution on Microsoft SQL
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Microsoft SQL上获取命令执行
- en: As mentioned in [Chapter 6](part0010.html#meterpreter), most system administrators
    set the *sa* (system administrator) account password to something weak, not realizing
    the impact of this simple mistake. The *sa* account is installed by default with
    the SQL role of *sysadmin*, and when you’re performing penetration tests, you
    can almost guarantee that a weak or blank *sa* account will exist on Microsoft
    SQL Server instances. We will use the MS SQL instance that you built in [Appendix A](part0022.html#configuring_your_target_machines)
    to exploit a situation with our module. As discussed in [Chapter 6](part0010.html#meterpreter),
    you initially scan the system with the Metasploit auxiliary modules and brute
    force the weak *sa* account.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](part0010.html#meterpreter)所述，大多数系统管理员将*sa*（系统管理员）账户密码设置为弱密码，没有意识到这个简单错误的影响。*sa*账户默认安装了SQL角色的*sysadmin*，在进行渗透测试时，你几乎可以保证在Microsoft
    SQL Server实例上存在一个弱密码或空密码的*sa*账户。我们将使用[附录A](part0022.html#configuring_your_target_machines)中构建的MS
    SQL实例来利用我们的模块。如[第6章](part0010.html#meterpreter)所述，你最初使用Metasploit辅助模块扫描系统，并暴力破解弱密码的*sa*账户。
- en: Once you have brute forced the *sa* account, you can insert, drop, create, and
    perform most other tasks you would normally use in MS SQL. This includes calling
    an extended administrative-level stored procedure called `xp_cmdshell`, as discussed
    in [Chapter 6](part0010.html#meterpreter). This stored procedure lets you execute
    underlying operating system commands under the same security context used by the
    SQL Server service (for example, Local System).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你破解了 *sa* 账户，你就可以在 MS SQL 中插入、删除、创建，并执行大多数其他你通常会用到的任务。这包括调用一个扩展的行政级别存储过程 `xp_cmdshell`，如第
    6 章所述。[第 6 章](part0010.html#meterpreter)。此存储过程允许你在与 SQL Server 服务（例如，本地系统）相同的上下文中执行底层操作系统命令。
- en: '* * *'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MS SQL installs with this stored procedure disabled in SQL Server 2005 and 2008,
    but you can re-enable it using SQL commands if you have the *sysadmin* role within
    MS SQL. For example, you could use `SELECT loginname FROM master..syslogins WHERE
    sysadmin=1` to view all users with this level of access and then become one of
    those users. If you have the sysadmin role, you’re almost guaranteed a full-system
    compromise.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MS SQL 在 SQL Server 2005 和 2008 中安装时，此存储过程是禁用的，但如果你在 MS SQL 中拥有 *sysadmin* 角色，你可以使用
    SQL 命令重新启用它。例如，你可以使用 `SELECT loginname FROM master..syslogins WHERE sysadmin=1`
    来查看所有具有此级别访问权限的用户，然后成为其中之一。如果你拥有 sysadmin 角色，你几乎可以保证完全系统妥协。
- en: '* * *'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'The following listing demonstrates how to run basic commands through Metasploit’s
    MS SQL modules:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何通过 Metasploit 的 MS SQL 模块运行基本命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we first select the *mssql_exec* auxiliary module at ![](../images/00002.gif),
    which calls the `xp_cmdshell` stored procedure to execute commands. Next, we view
    the module’s options at ![](../images/00004.gif) and set our target at ![](../images/00005.gif)
    and the command to execute on the target at ![](../images/00006.gif). Finally,
    we run the exploit with `exploit`, and you can see at ![](../images/00007.gif)
    that the exploit is successful. We’ve added a user to the system using the `xp_cmdshell`
    stored procedure. (At this point we could enter `net localgroup administrators
    metasploit /ADD` to add the user to the local administrators group on the compromised
    system.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先在 ![](../images/00002.gif) 选择 *mssql_exec* 辅助模块，它调用 `xp_cmdshell`
    存储过程来执行命令。接下来，我们在 ![](../images/00004.gif) 查看模块的选项，并将目标设置为 ![](../images/00005.gif)，以及在目标上执行的命令为
    ![](../images/00006.gif)。最后，我们使用 `exploit` 运行攻击，你可以在 ![](../images/00007.gif)
    看到攻击是成功的。我们已经使用 `xp_cmdshell` 存储过程向系统中添加了一个用户。（在这个时候，我们可以输入 `net localgroup administrators
    metasploit /ADD` 将用户添加到受侵害系统上的本地管理员组。）
- en: You can think of the *mssql_exec* module as a command prompt accessible via
    MS SQL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 *mssql_exec* 模块视为通过 MS SQL 可访问的命令提示符。
- en: Exploring an Existing Metasploit Module
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索现有的 Metasploit 模块
- en: 'Now we’ll examine what is actually occurring “under the hood” of the module
    we just worked with, *mssql_exec*. This allows us to get a feel for how existing
    code is operating before we write our own. Let’s open the module with a text editor
    to see how it operates:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查我们刚刚使用的模块 *mssql_exec* 的实际“内部”操作。这让我们在编写自己的代码之前，能够了解现有代码是如何运行的。让我们用文本编辑器打开模块，看看它是如何操作的：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following lines excerpted from the module yield a few important things
    worthy of note:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从模块中摘录的以下行包含一些值得注意的重要事项：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line at ![](../images/00002.gif) tells us that this module will include
    all functionality from Metasploit’s core libraries. Next the class is set at ![](../images/00004.gif)
    with code that defines this as an auxiliary module that inherits certain characteristics
    of, for example, scanners, denial-of-service vectors, data retrieval, brute force
    attacks, and reconnaissance attempts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](../images/00002.gif) 的第一行告诉我们，此模块将包含来自 Metasploit 核心库的所有功能。接下来，在 ![](../images/00004.gif)
    设置类，使用代码将其定义为继承某些特性的辅助模块，例如扫描器、拒绝服务向量、数据检索、暴力攻击和侦察尝试。
- en: The `include` statement at ![](../images/00005.gif) is probably one of the most
    important lines, because it pulls in the MS SQL module from the core Metasploit
    libraries. Essentially, the MS SQL module handles all MS SQL–based communications
    and anything related to MS SQL. Finally, at ![](../images/00006.gif) it pulls
    a specific command from the Metasploit datastore.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](../images/00005.gif) 的 `include` 语句可能是最重要的一行，因为它从核心 Metasploit 库中引入了 MS
    SQL 模块。本质上，MS SQL 模块处理所有基于 MS SQL 的通信以及与 MS SQL 相关的一切。最后，在 ![](../images/00006.gif)
    它从 Metasploit 数据存储中提取了一个特定的命令。
- en: 'Let’s examine the MS SQL function in the Metasploit core libraries to get a
    better understanding of its power. First, open *mssql.rb* and then *mssql_commands.rb*
    with the following commands, each in a different window:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 Metasploit 核心库中的 MS SQL 函数，以更好地理解其功能。首先，使用以下命令在不同的窗口中打开 *mssql.rb* 和 *mssql_commands.rb*：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Press ctrl-W in Nano to search for `mssql_xpcmdshell` in *mssql.rb*, and you
    should find the definition that tells Metasploit how to use the `xp_cmdshell`
    procedure, as shown next:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Nano 中按 Ctrl-W 搜索 *mssql.rb* 中的 `mssql_xpcmdshell`，您应该找到定义 Metasploit 如何使用
    `xp_cmdshell` 过程的说明，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This listing defines the SQL query to be run against the server as a call to
    the `xp_cmdshell` stored procedure at ![](../images/00002.gif) and a variable
    that will be replaced with the command line the user requests to be executed at
    ![](../images/00004.gif). For instance, an attempt to add a user to the system
    would execute within MS SQL as `EXEC master..xp_cmdshell 'net user metasploit
    p@55w0rd! /ADD'` by setting the `cmd` variable to `'net user metasploit p@55w0rd!
    /ADD'`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表定义了针对服务器运行的 SQL 查询，作为对 `xp_cmdshell` 存储过程的调用，在 ![图片](../images/00002.gif)
    以及一个将被替换为用户请求执行的命令行的变量，在 ![图片](../images/00004.gif)。例如，尝试将用户添加到系统中的操作将在 MS SQL
    中执行 `EXEC master..xp_cmdshell 'net user metasploit p@55w0rd! /ADD'`，通过将 `cmd`
    变量设置为 `'net user metasploit p@55w0rd! /ADD'`。
- en: 'Now turn your attention to the *mssql_commands.rb*, where the commands to enable
    the `xp_cmdshell` procedure live:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将您的注意力转向 *mssql_commands.rb*，其中包含启用 `xp_cmdshell` 过程的命令：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here you can see the sequence of commands ![](../images/00002.gif) issued to
    re-enable the `xp_cmdshell` stored procedure in MS SQL Server 2005 and 2008.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到用于在 MS SQL Server 2005 和 2008 中重新启用 `xp_cmdshell` 存储过程的命令序列 ![图片](../images/00002.gif)。
- en: Now that you understand the functions we will be using in creating our own module,
    let’s get started.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了我们将要使用的函数，让我们开始创建自己的模块。
- en: Creating a New Module
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新模块
- en: Suppose you’re working on a penetration test and you encounter a system running
    SQL Server 2008 and Microsoft Server 2008 R2\. Because Microsoft removed *debug.exe*
    on Windows 7 x64 and Windows Server 2008, these systems won’t allow you to convert
    executables in a traditional way as defined in [Chapter 11](part0015.html#fast-track).
    That means you need to create a new module that will allow you to attack a Microsoft
    Server 2008 and SQL Server 2008 instance successfully.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在进行渗透测试，并且遇到了运行 SQL Server 2008 和 Microsoft Server 2008 R2 的系统。由于 Microsoft
    在 Windows 7 x64 和 Windows Server 2008 中移除了 *debug.exe*，这些系统不会允许您以 [第 11 章](part0015.html#fast-track)
    中定义的传统方式转换可执行文件。这意味着您需要创建一个新的模块，以便成功攻击 Microsoft Server 2008 和 SQL Server 2008
    实例。
- en: We’ll make certain assumptions for purposes of this scenario. First, you’ve
    already guessed that the SQL Server password is blank, and you have gained access
    to the `xp_cmdshell` stored procedure. You need to deliver a Meterpreter payload
    onto the system, but all ports other than 1433 are closed. You don’t know whether
    a physical firewall is in place or if the Windows-based firewall is in use, but
    you don’t want to modify the port list or turn off the firewall because that might
    raise suspicion.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们将做出一些假设。首先，您已经猜到 SQL Server 密码为空，并且您已经获得了对 `xp_cmdshell` 存储过程的访问权限。您需要将
    Meterpreter 有效载荷传输到系统上，但除了 1433 端口之外的所有端口都已被关闭。您不知道是否设置了物理防火墙，或者是否正在使用基于 Windows
    的防火墙，但您不想修改端口列表或关闭防火墙，因为这可能会引起怀疑。
- en: PowerShell
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell
- en: Windows PowerShell is our only viable option here. PowerShell is a comprehensive
    Windows scripting language that allows you to access the full Microsoft .NET Framework
    from the command line. PowerShell’s active community works at extending the tool,
    making it a valuable tool for security professionals because of its versatility
    and compatibility with .NET. We aren’t specifically going to dive into how PowerShell
    works and its functions, but you should know that it is a full-fledged programmatic
    language available to you on newer operating systems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Windows PowerShell 是我们唯一可行的选择。PowerShell 是一种全面的 Windows 脚本语言，允许您从命令行访问完整的 Microsoft
    .NET Framework。PowerShell 的活跃社区致力于扩展工具，这使得它成为安全专业人士的有价值工具，因为它具有多功能性和与 .NET 的兼容性。我们不会具体深入探讨
    PowerShell 的工作原理及其功能，但您应该知道它是一种全新的程序性语言，可在较新的操作系统上使用。
- en: We’ll create a new module that will use Metasploit to convert the binary code
    to hexadecimal (or Base64 if desired), and then echo it onto the underlying operating
    system. Then we’ll use PowerShell to convert the executable back to a binary that
    you can execute.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的模块，该模块将使用Metasploit将二进制代码转换为十六进制（或根据需要转换为Base64），然后将其输出到底层操作系统。然后我们将使用PowerShell将可执行文件转换回可执行的二进制文件。
- en: 'To begin, we create a boilerplate by copying the *mssql_payload* exploit as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过以下方式复制 *mssql_payload* 漏洞来创建一个模板：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we open the *mssql_powershell.rb* file we just created and modify its
    code so that it looks just like the following. This is an exploit base shell.
    Take some time to review the various parameters and remember the topics covered
    in the previous chapters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打开我们刚刚创建的 *mssql_powershell.rb* 文件，并修改其代码，使其看起来如下。这是一个漏洞基础shell。花些时间来回顾各种参数，并记住前几章中涵盖的主题。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before this exploit will work properly, you’ll need to define some basic settings.
    Notice that the name, description, licensing, and references are defined at ![](../images/00002.gif).
    We also define a platform at ![](../images/00004.gif) (Windows) and a target at
    ![](../images/00005.gif) (all operating systems). We also define a new parameter
    called `UsePowerShell` at ![](../images/00006.gif) for use in the body of the
    exploit. Lastly, a handler is specified at ![](../images/00007.gif) to handle
    the connections between the attacker and the exploited target.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个漏洞能够正常工作之前，你需要定义一些基本设置。注意，名称、描述、许可和参考在 ![](../images/00002.gif) 中定义。我们还定义了一个平台在
    ![](../images/00004.gif)（Windows）和一个目标在 ![](../images/00005.gif)（所有操作系统）。我们还定义了一个名为
    `UsePowerShell` 的新参数，在 ![](../images/00006.gif) 中用于漏洞体中。最后，在 ![](../images/00007.gif)
    中指定了一个处理器来处理攻击者和被利用目标之间的连接。
- en: Running the Shell Exploit
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行Shell Exploit
- en: 'With the skeleton of the exploit built, we run it through *msfconsole* to see
    what options are available:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了漏洞利用的框架之后，我们通过 *msfconsole* 运行它，以查看可用的选项：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recall from [Chapter 5](part0009.html#the_joy_of_exploitation) that the `show
    options` command will display any new options that have been added to an exploit.
    After we set these options, they will be stored within Metasploit as valid options.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第5章](part0009.html#the_joy_of_exploitation) 中的 `show options` 命令将显示已添加到漏洞中的任何新选项。在我们设置这些选项后，它们将作为有效选项存储在Metasploit中。
- en: Now we’ll finalize the *mssql_powershell.rb* file, which we have been editing
    since the beginning of this chapter, before we edit *mssql.rb* (which will be
    explained shortly).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们编辑 *mssql.rb*（稍后将解释）之前，我们将最终确定我们自本章开始以来一直在编辑的 *mssql_powershell.rb* 文件。
- en: 'When you examine the exploits in the *modules* directory inside Metasploit
    (*modules/exploits*, *modules/auxiliary/*, and so on), you’ll notice that most
    of them have the same overall structure (`def` exploit as an example). Remember
    always to comment your code to give other developers an idea of what it’s doing!
    In the following listing, we first introduce our `def exploit` line, which defines
    what we’ll be doing in our exploit. We’ll frame our exploit the same way as the
    other modules and add a few new sections, as explained next:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查Metasploit中 *modules* 目录内的漏洞（*modules/exploits*，*modules/auxiliary* 等）时，你会注意到它们大多数都有相同的整体结构（以
    `def` exploit 为例）。记住始终为你的代码添加注释，以便其他开发者了解它在做什么！在下面的列表中，我们首先介绍我们的 `def exploit`
    行，它定义了我们将在漏洞利用中执行的操作。我们将以与其他模块相同的方式构建我们的漏洞利用，并添加一些新的部分，如下所述：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The module first checks to see if we are logged in at ![](../images/00002.gif).
    If we aren’t logged in, the error message `"Invalid SQL Server Credentials"` ![](../images/00004.gif)
    is displayed. The `UsePowerShell` method at ![](../images/00005.gif) is used to
    call the function `powershell_upload_exec` ![](../images/00006.gif), which will
    automatically create a Metasploit-based payload that we specify during our exploit.
    After we finally run the exploit, when we specify our payload in *msfconsole*,
    it will automatically generate it for us based on the `Msf::Util::EXE.to_win32pe(framework,payload.encoded)`
    option.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 模块首先检查我们是否在 ![](../images/00002.gif) 登录。如果没有登录，将显示错误消息 `"Invalid SQL Server
    Credentials"` ![](../images/00004.gif)。在 ![](../images/00005.gif) 中使用 `UsePowerShell`
    方法来调用 `powershell_upload_exec` 函数 ![](../images/00006.gif)，该函数将自动创建一个基于Metasploit的负载，我们在漏洞利用期间指定。在我们最终运行漏洞利用后，当我们指定
    *msfconsole* 中的负载时，它将根据 `Msf::Util::EXE.to_win32pe(framework,payload.encoded)`
    选项自动为我们生成。
- en: Creating powershell_upload_exec
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 powershell_upload_exec
- en: Now we’ll open the *mssql.rb* file that we opened earlier, in preparation for
    editing. We need to find space for the `powershell_upload_exec` function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将打开之前打开的 *mssql.rb* 文件，为编辑做准备。我们需要找到 `powershell_upload_exec` 函数的空间。
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In your version of Metasploit, you can do a search for PowerShell, and you should
    see the referenced code that follows in the *mssql.rb* file. Feel free to delete
    this code from the file and start from scratch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Metasploit 版本中，您可以搜索 PowerShell，应该会在 *mssql.rb* 文件中看到以下引用代码。您可以自由地从文件中删除此代码，从头开始。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At ![](../images/00002.gif) you see that our definition includes the commands
    `exe` and `debug` parameters that are added to the `def powershell_upload_exec`
    function. The `exe` command is the executable we will be sending from our original
    code `Msf::Util::EXE.to_win32pe(framework,payload.encoded)`, as mentioned previously.
    The `debug` command is set to `false`, which means we will not see debug information.
    Generally this would be set to `true` if you wanted to see additional information
    for troubleshooting.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![图片](../images/00002.gif) 处，您可以看到我们的定义包括添加到 `def powershell_upload_exec`
    函数中的 `exe` 和 `debug` 参数。`exe` 命令是我们将从原始代码 `Msf::Util::EXE.to_win32pe(framework,payload.encoded)`
    发送的可执行文件，如前所述。`debug` 命令设置为 `false`，这意味着我们将不会看到调试信息。通常，如果您想看到用于故障排除的附加信息，此设置会设置为
    `true`。
- en: Next, at ![](../images/00004.gif) we convert the entire encoded executable to
    raw hexadecimal format. The `H` in this line simply means “open the file as a
    binary and place it in a hexadecimal representation.”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 ![图片](../images/00004.gif) 处，我们将整个编码的可执行文件转换为原始十六进制格式。此行中的 `H` 简单地意味着“以二进制形式打开文件并将其放置在十六进制表示中。”
- en: At ![](../images/00005.gif) we create a random, alphabetical, eight-character
    filename. It’s usually best to randomize this name to throw off antivirus software.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![图片](../images/00005.gif) 处，我们创建了一个随机的、字母的、八字符的文件名。通常，最好随机化此名称以迷惑防病毒软件。
- en: And finally, at ![](../images/00006.gif) we tell the attacker that our payload
    will remain on the operating system, in the SQL Server */Temp* directory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 ![图片](../images/00006.gif) 处，我们告知攻击者，我们的负载将保留在操作系统的 SQL Server */Temp*
    目录中。
- en: Conversion from Hex to Binary
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 十六进制到二进制的转换
- en: The following listing shows the conversion from hexadecimal back to binary,
    written in PowerShell. The code is defined as a string to be called later and
    uploaded to the target machine.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了使用 PowerShell 将十六进制数转换回二进制的示例。该代码被定义为字符串，以便稍后调用并上传到目标机器。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At ![](../images/00002.gif) we create the hex-to-binary (`h2b`) conversion method
    through PowerShell. This code essentially creates a byte array that will write
    out the hex-based Metasploit payload as a binary file. (The `{var_payload}` is
    a random name specified through Metasploit.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![图片](../images/00002.gif) 处，我们通过 PowerShell 创建了十六进制转二进制 (`h2b`) 的转换方法。此代码本质上创建了一个字节数组，它将基于十六进制的
    Metasploit 负载作为二进制文件写入。（`{var_payload}` 是通过 Metasploit 指定的一个随机名称。）
- en: Because MS SQL has character limit restrictions, we need to break our hexadecimal
    payload into 500-byte chunks that separate the payload into multiple requests.
    But one side effect of this splitting is that carriage returns and line feeds
    (CRLF) are added to the file on the target, and these need to be stripped out.
    At ![](../images/00004.gif) we add better handling of CRLFs by stripping them
    out properly. If we didn’t do this, our binary would be corrupt and would not
    execute properly. Notice that we are simply redesignating the `$s` variable to
    replace `` `r `` and `` `n `` with `''` (nothing). This effectively removes CRLFs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MS SQL 有字符限制，我们需要将我们的十六进制负载分成 500 字节的块，将负载分成多个请求。但这种分割的一个副作用是在目标文件中添加了回车符和换行符（CRLF），这些需要被移除。在
    ![图片](../images/00004.gif) 处，我们通过正确移除它们来添加更好的 CRLF 处理。如果我们不这样做，我们的二进制文件将会损坏，并且无法正确执行。请注意，我们只是重新指定了
    `$s` 变量，用 `''`（空字符串）替换 `r` 和 `n`。这实际上移除了 CRLF。
- en: Once the CRLFs are stripped out, `Convert::ToByte` is invoked in the hex-based
    Metasploit payload. We tell PowerShell that the file’s format is base 16 (hexadecimal
    format) and to write it out to a file called *#{var_payload}.exe* (our random
    payload name). After the payload has been written, we can run a method for executing
    PowerShell commands in an encoded format that is supported by the PowerShell programming
    language. These encoded commands allow us to execute lengthy and large amounts
    of code on one line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦去除了 CRLFs，就会在基于十六进制的 Metasploit 有效载荷中调用 `Convert::ToByte`。我们告诉 PowerShell
    文件的格式是基 16（十六进制格式），并将其写入名为 *#{var_payload}.exe* 的文件（我们的随机有效载荷名称）。在有效载荷被写入后，我们可以运行一个方法来执行
    PowerShell 编码格式的命令，这种格式是 PowerShell 编程语言所支持的。这些编码命令允许我们在一行中执行大量和长代码。
- en: By first converting the `h2b` string at ![](../images/00005.gif) to Unicode
    and then Base64 encoding the resultant string at ![](../images/00006.gif), we
    can pass the `-EncodedCommand` flag through PowerShell to bypass execution restrictions
    that would normally exist. The execution restriction policies do not allow untrusted
    scripts to be executed. (These restrictions are an important way to protect users
    from executing just any script they download on the Internet.) If we didn’t encode
    these commands, we wouldn’t be able to execute our PowerShell code and ultimately
    wouldn’t be able to compromise the target system. Encoding the commands allow
    us to add lots of code to one command without worrying about execution restriction
    policies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先将 ![](../images/00005.gif) 处的 `h2b` 字符串转换为 Unicode，然后将结果字符串在 ![](../images/00006.gif)
    处进行 Base64 编码，我们可以通过 PowerShell 传递 `-EncodedCommand` 标志来绕过通常存在的执行限制。执行限制策略不允许执行不受信任的脚本。（这些限制是保护用户免受在互联网上下载的任何脚本执行的重要方式。）如果我们不编码这些命令，我们就无法执行我们的
    PowerShell 代码，最终也无法破坏目标系统。编码命令允许我们在不担心执行限制策略的情况下，将大量代码添加到一条命令中。
- en: After we specified the `h2b` string and encoded command flags, we get the PowerShell
    commands in the correct encoded format so that we can execute our PowerShell code
    in an unrestricted format.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们指定了 `h2b` 字符串和编码命令标志之后，我们得到了正确的编码格式的 PowerShell 命令，这样我们就可以在不受限制的格式下执行我们的
    PowerShell 代码。
- en: At ![](../images/00005.gif), the string was converted to Unicode; this is a
    requirement to have the arguments and information passed to PowerShell. The `h2b_encoded
    = Rex::Text.encoded_base64(h2b_unicode)` is then passed to convert it to a Base64-encoded
    string to be passed through MS SQL. Base64 is the encoding required to leverage
    the `-EncodedCommand` flag. We first converted our string to Unicode, and then
    to Base64, which is the format we need for all of our PowerShell commands. Finally,
    at ![](../images/00007.gif) a message stating that we are in the process of uploading
    the payload is printed to the console.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](../images/00005.gif)，字符串被转换为 Unicode；这是将参数和信息传递给 PowerShell 的要求。然后 `h2b_encoded
    = Rex::Text.encoded_base64(h2b_unicode)` 被传递以将其转换为 Base64 编码的字符串，以便通过 MS SQL 传递。Base64
    是利用 `-EncodedCommand` 标志所需的编码。我们首先将我们的字符串转换为 Unicode，然后转换为 Base64，这是我们所有 PowerShell
    命令所需的格式。最后，在 ![](../images/00007.gif) 处，打印了一条消息到控制台，表明我们正在上传有效载荷的过程中。
- en: Counters
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器
- en: Counters help you track your location in a file or keep track of how much data
    the program has read in. In the next example, a base counter called `idx` starts
    at `0`. The counter is used to identify the end of the file and move up 500 bytes
    at a time when the hexadecimal-based binary is being sent to the operating system.
    Essentially, the counter is saying, “Read 500 bytes, and then send. Read another
    500 bytes, and then send,” until it reaches the end of the file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器可以帮助你在文件中跟踪你的位置，或者跟踪程序读取了多少数据。在下一个示例中，一个名为 `idx` 的基本计数器从 `0` 开始。计数器用于识别文件的结尾，并在将基于十六进制的二进制数据发送到操作系统时，每次向上移动
    500 字节。本质上，计数器是在说，“读取 500 字节，然后发送。再读取 500 字节，然后发送，”直到达到文件的结尾。
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Recall that to deliver the payload to the target operating system, we need to
    split it into 500-byte chunks. We use the counters `idx` ![](../images/00002.gif)
    and `cnt` ![](../images/00004.gif) to track how the payload is being split up.
    The counter `idx` will gradually increase by 500, and we set the other counter
    `cnt` to 500 (we need to read in 500 bytes at a time). After the first 500 bytes
    have been read from the Metasploit payload at ![](../images/00005.gif), the 500
    hexadecimal characters will be sent to the target machine. The 500-byte chunks
    continue to be added until the `idx` counter reaches the same length as the payload,
    which equals the end of the file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，为了将payload发送到目标操作系统，我们需要将其分成500字节的块。我们使用计数器`idx`![../images/00002.gif]和`cnt`![../images/00004.gif]来跟踪payload是如何被分割的。计数器`idx`将逐渐增加500，我们将另一个计数器`cnt`设置为500（我们需要一次读取500字节）。在从Metasploit
    payload的![../images/00005.gif]处读取了前500字节之后，这500个十六进制字符将被发送到目标机器。500字节的块会继续添加，直到`idx`计数器的长度与payload相同，这等于文件的结尾。
- en: At ![](../images/00006.gif) we see a message that the payload is being converted
    and sent to the target using the `-EncodedCommand` PowerShell command, which is
    where the conversion is occurring from the normal PowerShell command to a Base64
    encoded format (mentioned earlier).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在![../images/00006.gif]处，我们看到一条消息表明payload正在被转换并通过`-EncodedCommand` PowerShell命令发送到目标，这是转换从正常的PowerShell命令到前面提到的Base64编码格式的位置。
- en: 'The line `"powershell -EncodedCommand #{h2b_encoded}"` tells us that the payload
    has executed. The PowerShell commands that we converted to Base64 will convert
    the hexadecimal-based payload back to binary after it is executed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '这行代码`"powershell -EncodedCommand #{h2b_encoded}"`告诉我们payload已经执行。我们将PowerShell命令转换为Base64后，会在执行后将基于十六进制的payload转换回二进制。'
- en: 'The following shows the entire *mssql.rb* file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了整个*mssql.rb*文件：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running the Exploit
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行漏洞利用
- en: 'With our work on *mssql_powershell.rb* and *mssql.rb* complete, we can run
    the exploit through Metasploit and *msfconsole*. But before we do, we need to
    make sure that PowerShell is installed. Then we can run the following commands
    to execute our newly created exploit:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了对*mssql_powershell.rb*和*mssql.rb*的工作，现在我们可以通过Metasploit和*msfconsole*运行这个漏洞利用。但在我们这样做之前，我们需要确保PowerShell已经安装。然后我们可以运行以下命令来执行我们新创建的漏洞利用：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Power of Code Reuse
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码复用的力量
- en: This process of leveraging existing code, tweaking it, and adding in some original
    code is one of the most powerful things we can do with Metasploit. You have no
    reason to start from scratch in most situations after you have a feel for the
    Framework and you take a look at how existing code works. Because this module
    was essentially built for you, you can get more practice by going through other
    Metasploit modules and seeing what they are doing and how they work. You’ll start
    to learn the basics of buffer overflows and how they are created. Notice how the
    code is structured and how it works, and then create your own exploits from scratch.
    If you’re not familiar with the Ruby programming language or if this chapter was
    a bit over your head, pick up a book and read and learn. The best way to learn
    how to create these types of module development is through trial and error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 利用现有代码，对其进行调整，并添加一些原创代码，这是我们可以在Metasploit中做到的最强大的一件事之一。在熟悉了框架并了解了现有代码的工作方式之后，在大多数情况下，你无需从头开始。因为这个模块基本上是为你构建的，你可以通过查看其他Metasploit模块以及它们的功能和工作方式来获得更多实践。你将开始学习缓冲区溢出的基础知识以及它们的创建方式。注意代码的结构和它的工作方式，然后从头开始创建自己的漏洞利用。如果你不熟悉Ruby编程语言或者这一章对你来说有点难以理解，找一本书来阅读和学习。学习如何创建这类模块开发的最佳方式是通过试错。
