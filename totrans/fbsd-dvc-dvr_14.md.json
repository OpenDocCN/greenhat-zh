["```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/selinfo.h>\n  #include <sys/bus.h>\n  #include <sys/conf.h>\n  #include <sys/bio.h>\n  #include <sys/malloc.h>\n  #include <sys/uio.h>\n\n  #include <cam/cam.h>\n  #include <cam/cam_ccb.h>\n  #include <cam/cam_debug.h>\n  #include <cam/cam_sim.h>\n  #include <cam/cam_xpt_sim.h>\n  #include <cam/scsi/scsi_all.h>\n\n  #include <machine/md_var.h>\n  #include <machine/bus.h>\n  #include <sys/rman.h>\n\n  #include <dev/mfi/mfireg.h>\n  #include <dev/mfi/mfi_ioctl.h>\n  #include <dev/mfi/mfivar.h>\n\n  #define ccb_mfip_ptr            sim_priv.entries[0].ptr\n\n  struct mfip {\n          device_t                dev;\n          struct mfi_softc        *mfi;\n          struct cam_devq         *devq;\n          struct cam_sim          *sim;\n          struct cam_path         *path;\n  };\n\n  static devclass_t               mfip_devclass;\n\n  static void                     mfip_action(struct cam_sim *, union ccb *);\n  static void                     mfip_poll(struct cam_sim *);\n  static struct mfi_command *     mfip_start(void *);\n  static void                     mfip_done(struct mfi_command *);\n\n  static int\n mfip_probe(device_t dev)\n  {\n          device_set_desc(dev, \"SCSI pass-through bus\");\n          return (BUS_PROBE_SPECIFIC);\n  }\n\n  static int\n  mfip_attach(device_t dev)\n  {\n          struct mfip *sc;\n          struct mfi_softc *mfi;\n\n          sc = device_get_softc(dev);\n          if (sc == NULL)\n                  return (EINVAL);\n\n          mfi = device_get_softc(device_get_parent(dev));\n          sc->dev = dev;\n          sc->mfi = mfi;\n          mfi->mfi_cam_start = mfip_start;\n\n          if ((sc->devq = cam_simq_alloc(MFI_SCSI_MAX_CMDS)) == NULL)\n                  return (ENOMEM);\n\n          sc->sim = cam_sim_alloc(mfip_action, mfip_poll, \"mfi\", sc,\n              device_get_unit(dev), &mfi->mfi_io_lock, 1, MFI_SCSI_MAX_CMDS,\n              sc->devq);\n          if (sc->sim == NULL) {\n                  cam_simq_free(sc->devq);\n                  device_printf(dev, \"cannot allocate CAM SIM\\n\");\n                  return (EINVAL);\n          }\n\n          mtx_lock(&mfi->mfi_io_lock);\n          if (xpt_bus_register(sc->sim, dev, 0) != 0) {\n                  device_printf(dev,\n                      \"cannot register SCSI pass-through bus\\n\");\n                  cam_sim_free(sc->sim, FALSE);\n                  cam_simq_free(sc->devq);\n                  mtx_unlock(&mfi->mfi_io_lock);\n                  return (EINVAL);\n          }\n          mtx_unlock(&mfi->mfi_io_lock);\n\n          return (0);\n  }\n\n  static int\n  mfip_detach(device_t dev)\n  {\n          struct mfip *sc;\n\n          sc = device_get_softc(dev);\n          if (sc == NULL)\n                  return (EINVAL);\n\n          if (sc->sim != NULL) {\n                  mtx_lock(&sc->mfi->mfi_io_lock);\n                  xpt_bus_deregister(cam_sim_path(sc->sim));\n                  cam_sim_free(sc->sim, FALSE);\n                  mtx_unlock(&sc->mfi->mfi_io_lock);\n          }\n\n          if (sc->devq != NULL)\n                  cam_simq_free(sc->devq);\n\n          return (0);\n  }\n\n  static void\n  mfip_action(struct cam_sim *sim, union ccb *ccb)\n  {\n          struct mfip *sc;\n          struct mfi_softc *mfi;\n\n          sc = cam_sim_softc(sim);\n          mfi = sc->mfi;\n          mtx_assert(&mfi->mfi_io_lock, MA_OWNED);\n\n          switch (ccb->ccb_h.func_code) {\n          case XPT_PATH_INQ:\n          {\n                  struct ccb_pathinq *cpi;\n\n                  cpi = &ccb->cpi;\n                  cpi->version_num = 1;\n                  cpi->hba_inquiry = PI_SDTR_ABLE | PI_TAG_ABLE | PI_WIDE_16;\n                  cpi->target_sprt = 0;\n                  cpi->hba_misc = PIM_NOBUSRESET | PIM_SEQSCAN;\n                  cpi->hba_eng_cnt = 0;\n                  cpi->max_target = MFI_SCSI_MAX_TARGETS;\n                  cpi->max_lun = MFI_SCSI_MAX_LUNS;\n                  cpi->initiator_id = MFI_SCSI_INITIATOR_ID;\n                  strncpy(cpi->sim_vid, \"FreeBSD\", SIM_IDLEN);\n                  strncpy(cpi->hba_vid, \"LSI\", HBA_IDLEN);\n                  strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);\n                  cpi->unit_number = cam_sim_unit(sim);\n                  cpi->bus_id = cam_sim_bus(sim);\n                  cpi->base_transfer_speed = 150000;\n                  cpi->protocol = PROTO_SCSI;\n                  cpi->protocol_version = SCSI_REV_2;\n                  cpi->transport = XPORT_SAS;\n                  cpi->transport_version = 0;\n\n                  cpi->ccb_h.status = CAM_REQ_CMP;\n                  break;\n          }\n          case XPT_RESET_BUS:\n                  ccb->ccb_h.status = CAM_REQ_CMP;\n                  break;\n          case XPT_RESET_DEV:\n                  ccb->ccb_h.status = CAM_REQ_CMP;\n                  break;\n          case XPT_GET_TRAN_SETTINGS:\n          {\n                  struct ccb_trans_settings_sas *sas;\n\n                  ccb->cts.protocol = PROTO_SCSI;\n                  ccb->cts.protocol_version = SCSI_REV_2;\n                  ccb->cts.transport = XPORT_SAS;\n                  ccb->cts.transport_version = 0;\n                  sas = &ccb->cts.xport_specific.sas;\n                  sas->valid &= ˜CTS_SAS_VALID_SPEED;\n                  sas->bitrate = 150000;\n\n                  ccb->ccb_h.status = CAM_REQ_CMP;\n                  break;\n          }\n          case XPT_SET_TRAN_SETTINGS:\n                  ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n                  break;\n          case XPT_SCSI_IO:\n          {\n                  struct ccb_hdr *ccb_h = &ccb->ccb_h;\n                  struct ccb_scsiio *csio = &ccb->csio;\n\n                  ccb_h->status = CAM_REQ_INPROG;\n                  if (csio->cdb_len > MFI_SCSI_MAX_CDB_LEN) {\n                          ccb_h->status = CAM_REQ_INVALID;\n                          break;\n                  }\n                  if ((ccb_h->flags & CAM_DIR_MASK) != CAM_DIR_NONE) {\n                          if (ccb_h->flags & CAM_DATA_PHYS) {\n                                  ccb_h->status = CAM_REQ_INVALID;\n                                  break;\n                          }\n                          if (ccb_h->flags & CAM_SCATTER_VALID) {\n                                  ccb_h->status = CAM_REQ_INVALID;\n                                  break;\n                          }\n                  }\n\n                  ccb_h->ccb_mfip_ptr = sc;\n                  TAILQ_INSERT_TAIL(&mfi->mfi_cam_ccbq, ccb_h, sim_links.tqe);\n                  mfi_startio(mfi);\n\n                  return;\n          }\n          default:\n                  ccb->ccb_h.status = CAM_REQ_INVALID;\n                  break;\n          }\n\n          xpt_done(ccb);\n          return;\n  }\n\n  static void\n  mfip_poll(struct cam_sim *sim)\n  {\n          return;\n  }\n\n  static struct mfi_command *\n  mfip_start(void *data)\n  {\n          union ccb *ccb = data;\n          struct ccb_hdr *ccb_h = &ccb->ccb_h;\n          struct ccb_scsiio *csio = &ccb->csio;\n          struct mfip *sc;\n          struct mfi_command *cm;\n          struct mfi_pass_frame *pt;\n\n          sc = ccb_h->ccb_mfip_ptr;\n\n          if ((cm = mfi_dequeue_free(sc->mfi)) == NULL)\n                  return (NULL);\n\n          pt = &cm->cm_frame->pass;\n          pt->header.cmd = MFI_CMD_PD_SCSI_IO;\n          pt->header.cmd_status = 0;\n          pt->header.scsi_status = 0;\n          pt->header.target_id = ccb_h->target_id;\n          pt->header.lun_id = ccb_h->target_lun;\n          pt->header.flags = 0;\n          pt->header.timeout = 0;\n          pt->header.data_len = csio->dxfer_len;\n          pt->header.sense_len = MFI_SENSE_LEN;\n          pt->header.cdb_len = csio->cdb_len;\n          pt->sense_addr_lo = cm->cm_sense_busaddr;\n          pt->sense_addr_hi = 0;\n          if (ccb_h->flags & CAM_CDB_POINTER)\n                  bcopy(csio->cdb_io.cdb_ptr, &pt->cdb[0], csio->cdb_len);\n          else\n                  bcopy(csio->cdb_io.cdb_bytes, &pt->cdb[0], csio->cdb_len);\n\n          cm->cm_complete = mfip_done;\n          cm->cm_private = ccb;\n          cm->cm_sg = &pt->sgl;\n          cm->cm_total_frame_size = MFI_PASS_FRAME_SIZE;\n          cm->cm_data = csio->data_ptr;\n          cm->cm_len = csio->dxfer_len;\n          switch (ccb_h->flags & CAM_DIR_MASK) {\n          case CAM_DIR_IN:\n                  cm->cm_flags = MFI_CMD_DATAIN;\n                  break;\n          case CAM_DIR_OUT:\n                  cm->cm_flags = MFI_CMD_DATAOUT;\n                  break;\n          case CAM_DIR_NONE:\n          default:\n                  cm->cm_data = NULL;\n                  cm->cm_len = 0;\n                  cm->cm_flags = 0;\n                  break;\n          }\n\n          TAILQ_REMOVE(&sc->mfi->mfi_cam_ccbq, ccb_h, sim_links.tqe);\n          return (cm);\n  }\n\n  static void\n  mfip_done(struct mfi_command *cm)\n  {\n          union ccb *ccb = cm->cm_private;\n          struct ccb_hdr *ccb_h = &ccb->ccb_h;\n          struct ccb_scsiio *csio = &ccb->csio;\n          struct mfip *sc;\n          struct mfi_pass_frame *pt;\n\n          sc = ccb_h->ccb_mfip_ptr;\n          pt = &cm->cm_frame->pass;\n\n          switch (pt->header.cmd_status) {\n          case MFI_STAT_OK:\n          {\n                  uint8_t command, device;\n\n                  ccb_h->status = CAM_REQ_CMP;\n                  csio->scsi_status = pt->header.scsi_status;\n\n                  if (ccb_h->flags & CAM_CDB_POINTER)\n                          command = ccb->csio.cdb_io.cdb_ptr[0];\n                  else\n                          command = ccb->csio.cdb_io.cdb_bytes[0];\n\n                  if (command == INQUIRY) {\n                          device = ccb->csio.data_ptr[0] & 0x1f;\n                          if ((device == T_DIRECT) || (device == T_PROCESSOR))\n                                  csio->data_ptr[0] =\n                                      (device & 0xe0) | T_NODEVICE;\n                  }\n\n                  break;\n          }\n          case MFI_STAT_SCSI_DONE_WITH_ERROR:\n          {\n                  int sense_len;\n\n                  ccb_h->status = CAM_SCSI_STATUS_ERROR | CAM_AUTOSNS_VALID;\n                  csio->scsi_status = pt->header.scsi_status;\n\n                  sense_len = min(pt->header.sense_len,\n                      sizeof(struct scsi_sense_data));\n                  bzero(&csio->sense_data, sizeof(struct scsi_sense_data));\n                  bcopy(&cm->cm_sense->data[0], &csio->sense_data, sense_len);\n                  break;\n          }\n          case MFI_STAT_DEVICE_NOT_FOUND:\n                  ccb_h->status = CAM_SEL_TIMEOUT;\n                  break;\n          case MFI_STAT_SCSI_IO_FAILED:\n                  ccb_h->status = CAM_REQ_CMP_ERR;\n                  csio->scsi_status = pt->header.scsi_status;\n                  break;\n          default:\n                  ccb_h->status = CAM_REQ_CMP_ERR;\n                  csio->scsi_status = pt->header.scsi_status;\n                  break;\n          }\n\n          mfi_release_command(cm);\n          xpt_done(ccb);\n  }\n\n  static device_method_t mfip_methods[] = {\n          /* Device interface. */\n          DEVMETHOD(device_probe,         mfip_probe),\n          DEVMETHOD(device_attach,        mfip_attach),\n          DEVMETHOD(device_detach,        mfip_detach),\n          { 0, 0 }\n  };\n\n  static driver_t mfip_driver = {\n          \"mfip\",\n          mfip_methods,\n          sizeof(struct mfip)\n  };\n\n  DRIVER_MODULE(mfip, mfi, mfip_driver, mfip_devclass, 0, 0);\n  MODULE_DEPEND(mfip, cam, 1, 1, 1);\n  MODULE_DEPEND(mfip, mfi, 1, 1, 1);\n```", "```\nstatic int\nmfip_attach(device_t dev)\n{\n        struct mfip *sc;\n        struct mfi_softc *mfi;\n\n        sc = device_get_softc(dev);\n        if (sc == NULL)\n                return (EINVAL);\n\n        mfi = device_get_softc(device_get_parent(dev));\n        sc->dev = dev;\n        sc->mfi = mfi;\n        mfi->mfi_cam_start = mfip_start;\n\n        if ((sc->devq = cam_simq_alloc(MFI_SCSI_MAX_CMDS)) == NULL)\n                return (ENOMEM);\n\n        sc->sim = cam_sim_alloc(mfip_action, mfip_poll, \"mfi\", sc,\n            device_get_unit(dev), &mfi->mfi_io_lock, 1, MFI_SCSI_MAX_CMDS,\n            sc->devq);\n        if (sc->sim == NULL) {\n                cam_simq_free(sc->devq);\n                device_printf(dev, \"cannot allocate CAM SIM\\n\");\n                return (EINVAL);\n        }\n\n        mtx_lock(&mfi->mfi_io_lock);\n        if (xpt_bus_register(sc->sim, dev, 0) != 0) {\n                device_printf(dev,\n                    \"cannot register SCSI pass-through bus\\n\");\n                cam_sim_free(sc->sim, FALSE);\n                cam_simq_free(sc->devq);\n                mtx_unlock(&mfi->mfi_io_lock);\n                return (EINVAL);\n        }\n        mtx_unlock(&mfi->mfi_io_lock);\n\n        return (0);\n}\n```", "```\nstatic int\nmfip_detach(device_t dev)\n{\n        struct mfip *sc;\n\n        sc = device_get_softc(dev);\n        if (sc == NULL)\n                return (EINVAL);\n\n        if (sc->sim != NULL) {\n                mtx_lock(&sc->mfi->mfi_io_lock);\n              xpt_bus_deregister(cam_sim_path(sc->sim));\n              cam_sim_free(sc->sim, FALSE);\n                mtx_unlock(&sc->mfi->mfi_io_lock);\n        }\n\n        if (sc->devq != NULL)\n              cam_simq_free(sc->devq);\n\n        return (0);\n}\n```", "```\nstatic void\nmfip_action(struct cam_sim *sim, union ccb *ccb)\n{\n        struct mfip *sc;\n        struct mfi_softc *mfi;\n\n        sc = cam_sim_softc(sim);\n        mfi = sc->mfi;\n        mtx_assert(&mfi->mfi_io_lock, MA_OWNED);\n\n      switch (ccb->ccb_h.func_code) {\n      case XPT_PATH_INQ:\n        {\n                struct ccb_pathinq *cpi;\n\n                cpi = &ccb->cpi;\n                cpi->version_num = 1;\n                cpi->hba_inquiry = PI_SDTR_ABLE | PI_TAG_ABLE | PI_WIDE_16;\n                cpi->target_sprt = 0;\n                cpi->hba_misc = PIM_NOBUSRESET | PIM_SEQSCAN;\n                cpi->hba_eng_cnt = 0;\n                cpi->max_target = MFI_SCSI_MAX_TARGETS;\n                cpi->max_lun = MFI_SCSI_MAX_LUNS;\n                cpi->initiator_id = MFI_SCSI_INITIATOR_ID;\n                strncpy(cpi->sim_vid, \"FreeBSD\", SIM_IDLEN);\n                strncpy(cpi->hba_vid, \"LSI\", HBA_IDLEN);\n                strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);\n                cpi->unit_number = cam_sim_unit(sim);\n                cpi->bus_id = cam_sim_bus(sim);\n                cpi->base_transfer_speed = 150000;\n                cpi->protocol = PROTO_SCSI;\n                cpi->protocol_version = SCSI_REV_2;\n                cpi->transport = XPORT_SAS;\n                cpi->transport_version = 0;\n\n                cpi->ccb_h.status = CAM_REQ_CMP;\n                break;\n        }\n      case XPT_RESET_BUS:\n                ccb->ccb_h.status = CAM_REQ_CMP;\n                break;\n      case XPT_RESET_DEV:\n                ccb->ccb_h.status = CAM_REQ_CMP;\n                break;\n      case XPT_GET_TRAN_SETTINGS:\n        {\n                struct ccb_trans_settings_sas *sas;\n\n                ccb->cts.protocol = PROTO_SCSI;\n                ccb->cts.protocol_version = SCSI_REV_2;\n                ccb->cts.transport = XPORT_SAS;\n                ccb->cts.transport_version = 0;\n                sas = &ccb->cts.xport_specific.sas;\n                sas->valid &= ˜CTS_SAS_VALID_SPEED;\n                sas->bitrate = 150000;\n\n                ccb->ccb_h.status = CAM_REQ_CMP;\n                break;\n        }\n      case XPT_SET_TRAN_SETTINGS:\n                ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n                break;\n      case XPT_SCSI_IO:\n        {\n                struct ccb_hdr *ccb_h = &ccb->ccb_h;\n                struct ccb_scsiio *csio = &ccb->csio;\n\n                ccb_h->status = CAM_REQ_INPROG;\n                if (csio->cdb_len > MFI_SCSI_MAX_CDB_LEN) {\n                        ccb_h->status = CAM_REQ_INVALID;\n                        break;\n                }\n                if ((ccb_h->flags & CAM_DIR_MASK) != CAM_DIR_NONE) {\n                        if (ccb_h->flags & CAM_DATA_PHYS) {\n                                ccb_h->status = CAM_REQ_INVALID;\n                                break;\n                        }\n                        if (ccb_h->flags & CAM_SCATTER_VALID) {\n                                ccb_h->status = CAM_REQ_INVALID;\n                                break;\n                        }\n                }\n\n                ccb_h->ccb_mfip_ptr = sc;\n                TAILQ_INSERT_TAIL(&mfi->mfi_cam_ccbq, ccb_h, sim_links.tqe);\n                mfi_startio(mfi);\n\n                return;\n        }\n        default:\n                ccb->ccb_h.status = CAM_REQ_INVALID;\n                break;\n        }\n\n        xpt_done(ccb);\n        return;\n}\n```", "```\nstatic void\nmfip_poll(struct cam_sim *sim)\n{\n        return;\n}\n```", "```\nstatic struct mfi_command *\nmfip_start(void *data)\n{\n        union ccb *ccb = data;\n        struct ccb_hdr *ccb_h = &ccb->ccb_h;\n        struct ccb_scsiio *csio = &ccb->csio;\n        struct mfip *sc;\n        struct mfi_command *cm;\n        struct mfi_pass_frame *pt;\n\n        sc = ccb_h->ccb_mfip_ptr;\n\n        if ((cm = mfi_dequeue_free(sc->mfi)) == NULL)\n                return (NULL);\n\n        pt = &cm->cm_frame->pass;\n        pt->header.cmd = MFI_CMD_PD_SCSI_IO;\n        pt->header.cmd_status = 0;\n        pt->header.scsi_status = 0;\n        pt->header.target_id = ccb_h->target_id;\n        pt->header.lun_id = ccb_h->target_lun;\n        pt->header.flags = 0;\n        pt->header.timeout = 0;\n        pt->header.data_len = csio->dxfer_len;\n        pt->header.sense_len = MFI_SENSE_LEN;\n        pt->header.cdb_len = csio->cdb_len;\n        pt->sense_addr_lo = cm->cm_sense_busaddr;\n        pt->sense_addr_hi = 0;\n        if (ccb_h->flags & CAM_CDB_POINTER)\n                bcopy(csio->cdb_io.cdb_ptr, &pt->cdb[0], csio->cdb_len);\n        else\n                bcopy(csio->cdb_io.cdb_bytes, &pt->cdb[0], csio->cdb_len);\n\n        cm->cm_complete = mfip_done;\n        cm->cm_private = ccb;\n        cm->cm_sg = &pt->sgl;\n        cm->cm_total_frame_size = MFI_PASS_FRAME_SIZE;\n        cm->cm_data = csio->data_ptr;\n        cm->cm_len = csio->dxfer_len;\n        switch (ccb_h->flags & CAM_DIR_MASK) {\n        case CAM_DIR_IN:\n                cm->cm_flags = MFI_CMD_DATAIN;\n                break;\n        case CAM_DIR_OUT:\n                cm->cm_flags = MFI_CMD_DATAOUT;\n                break;\n        case CAM_DIR_NONE:\n        default:\n                cm->cm_data = NULL;\n                cm->cm_len = 0;\n                cm->cm_flags = 0;\n                break;\n        }\n\n        TAILQ_REMOVE(&sc->mfi->mfi_cam_ccbq, ccb_h, sim_links.tqe);\n        return (cm);\n}\n```", "```\nstatic void\nmfip_done(struct mfi_command *cm)\n{\n        union ccb *ccb = cm->cm_private;\n        struct ccb_hdr *ccb_h = &ccb->ccb_h;\n        struct ccb_scsiio *csio = &ccb->csio;\n        struct mfip *sc;\n        struct mfi_pass_frame *pt;\n\n        sc = ccb_h->ccb_mfip_ptr;\n        pt = &cm->cm_frame->pass;\n\n        switch (pt->header.cmd_status) {\n        case MFI_STAT_OK:\n        {\n                uint8_t command, device;\n\n              ccb_h->status = CAM_REQ_CMP;\n                csio->scsi_status = pt->header.scsi_status;\n\n                if (ccb_h->flags & CAM_CDB_POINTER)\n                        command = ccb->csio.cdb_io.cdb_ptr[0];\n                else\n                        command = ccb->csio.cdb_io.cdb_bytes[0];\n\n                if (command == INQUIRY) {\n                        device = ccb->csio.data_ptr[0] & 0x1f;\n                        if ((device == T_DIRECT) || (device == T_PROCESSOR))\n                                csio->data_ptr[0] =\n                                    (device & 0xe0) | T_NODEVICE;\n                }\n\n                break;\n        }\n        case MFI_STAT_SCSI_DONE_WITH_ERROR:\n        {\n                int sense_len;\n\n              ccb_h->status = CAM_SCSI_STATUS_ERROR | CAM_AUTOSNS_VALID;\n                csio->scsi_status = pt->header.scsi_status;\n\n                sense_len = min(pt->header.sense_len,\n                    sizeof(struct scsi_sense_data));\n                bzero(&csio->sense_data, sizeof(struct scsi_sense_data));\n                bcopy(&cm->cm_sense->data[0], &csio->sense_data, sense_len);\n                break;\n        }\n        case MFI_STAT_DEVICE_NOT_FOUND:\n              ccb_h->status = CAM_SEL_TIMEOUT;\n                break;\n        case MFI_STAT_SCSI_IO_FAILED:\n              ccb_h->status = CAM_REQ_CMP_ERR;\n                csio->scsi_status = pt->header.scsi_status;\n                break;\n        default:\n              ccb_h->status = CAM_REQ_CMP_ERR;\n                csio->scsi_status = pt->header.scsi_status;\n                break;\n        }\n\n        mfi_release_command(cm);\n      xpt_done(ccb);\n}\n```", "```\n#include <cam/cam_sim.h>\n#include <cam/cam_queue.h>\n\nstruct cam_devq *\ncam_simq_alloc(u_int32_t max_sim_transactions);\n```", "```\nmax_sim_transactions = number_of_supported_devices *\n    number_of_commands_that_can_be_concurrently_processed_per_device;\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n\n#include <cam/cam_sim.h>\n#include <cam/cam_queue.h>\n\nstruct cam_sim *\ncam_sim_alloc(sim_action_func sim_action, sim_poll_func sim_poll,\n    const char *sim_name, void *softc, u_int32_t unit, struct mtx *mtx,\n    int max_dev_transactions, int max_tagged_dev_transactions,\n    struct cam_devq *queue);\n```", "```\n#include <cam/cam_sim.h>\n#include <cam/cam_xpt_sim.h>\n\nint32_t\nxpt_bus_register(struct cam_sim *sim, device_t parent, u_int32_t bus)\n```", "```\ntypedef void (*sim_action_func)(struct cam_sim *sim, union ccb *ccb);\n```", "```\nstruct ccb_pathinq {\n        struct ccb_hdr ccb_h;           /* Header information fields.   */\n        u_int8_t    version_num;        /* Version number.              */\n        u_int8_t    hba_inquiry;        /* Imitate INQ byte 7\\.          */\n        u_int8_t    target_sprt;        /* Target mode support flags.   */\n        u_int8_t    hba_misc;           /* Miscellaneous HBA features.  */\n        u_int16_t   hba_eng_cnt;        /* HBA engine count.            */\n\n        u_int8_t vuhba_flags[VUHBALEN]; /* Vendor unique capabilities.  */\n        u_int32_t   max_target;         /* Maximum supported targets.   */\n        u_int32_t   max_lun;            /* Maximum supported LUN.       */\n        u_int32_t   async_flags;        /* Asynchronous handler flags.  */\n        path_id_t   hpath_id;      /* Highest path ID in the subsystem. */\n        target_id_t initiator_id;       /* HBA ID on the bus.           */\n\n        char sim_vid[SIM_IDLEN];        /* SIM vendor ID.               */\n        char hba_vid[HBA_IDLEN];        /* HBA vendor ID.               */\n        char dev_name[DEV_IDLEN];       /* SIM device name.             */\n\n        u_int32_t   unit_number;        /* SIM unit number.             */\n        u_int32_t   bus_id;             /* SIM bus ID.                  */\n        u_int32_t base_transfer_speed;  /* Base bus speed in KB/sec.    */\n\n        cam_proto   protocol;           /* CAM protocol.                */\n        u_int       protocol_version;   /* CAM protocol version.        */\n        cam_xport   transport;          /* Transport (e.g., FC, USB).   */\n        u_int       transport_version;  /* Transport version.           */\n        union {\n                struct ccb_pathinq_settings_spi spi;\n                struct ccb_pathinq_settings_fc fc;\n                struct ccb_pathinq_settings_sas sas;\n                char ccb_pathinq_settings_opaque[PATHINQ_SETTINGS_SIZE];\n        } xport_specific;\n\n        u_int maxio;    /* Maximum supported I/O size (in bytes).       */\n};\n```", "```\nstatic void\nmfip_action(struct cam_sim *sim, union ccb *ccb)\n{\n        struct mfip *sc;\n        struct mfi_softc *mfi;\n\n        sc = cam_sim_softc(sim);\n        mfi = sc->mfi;\n        mtx_assert(&mfi->mfi_io_lock, MA_OWNED);\n\n        switch (ccb->ccb_h.func_code) {\n        case XPT_PATH_INQ:\n        {\n                struct ccb_pathinq *cpi;\n\n                cpi = &ccb->cpi;\n                cpi->version_num = 1;\n                cpi->hba_inquiry = PI_SDTR_ABLE | PI_TAG_ABLE | PI_WIDE_16;\n                cpi->target_sprt = 0;\n                cpi->hba_misc = PIM_NOBUSRESET | PIM_SEQSCAN;\n                cpi->hba_eng_cnt = 0;\n                cpi->max_target = MFI_SCSI_MAX_TARGETS;\n                cpi->max_lun = MFI_SCSI_MAX_LUNS;\n                cpi->initiator_id = MFI_SCSI_INITIATOR_ID;\n                strncpy(cpi->sim_vid, \"FreeBSD\", SIM_IDLEN);\n                strncpy(cpi->hba_vid, \"LSI\", HBA_IDLEN);\n                strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);\n                cpi->unit_number = cam_sim_unit(sim);\n                cpi->bus_id = cam_sim_bus(sim);\n                cpi->base_transfer_speed = 150000;\n                cpi->protocol = PROTO_SCSI;\n                cpi->protocol_version = SCSI_REV_2;\n                cpi->transport = XPORT_SAS;\n                cpi->transport_version = 0;\n\n              cpi->ccb_h.status = CAM_REQ_CMP;\n                break;\n        }\n...\n        default:\n              ccb->ccb_h.status = CAM_REQ_INVALID;\n                break;\n        }\n\n        xpt_done(ccb);\n        return;\n}\n```", "```\nstatic void\nmfip_action(struct cam_sim *sim, union ccb *ccb)\n{\n        struct mfip *sc;\n        struct mfi_softc *mfi;\n\n        sc = cam_sim_softc(sim);\n        mfi = sc->mfi;\n        mtx_assert(&mfi->mfi_io_lock, MA_OWNED);\n\n        switch (ccb->ccb_h.func_code) {\n...\n        case XPT_RESET_BUS:\n                ccb->ccb_h.status = CAM_REQ_CMP;\n                break;\n...\n        default:\n                ccb->ccb_h.status = CAM_REQ_INVALID;\n                break;\n        }\n\n        xpt_done(ccb);\n        return;\n}\n```", "```\ntypedef enum {\n        CTS_TYPE_CURRENT_SETTINGS,      /* Current transfer settings.   */\n        CTS_TYPE_USER_SETTINGS          /* User-defined upper limits.   */\n} cts_type;\n\nstruct ccb_trans_settings {\n        struct ccb_hdr ccb_h;           /* Header information fields.   */\n        cts_type  type;                 /* Current or user settings?    */\n        cam_proto protocol;             /* CAM protocol.                */\n        u_int     protocol_version;     /* CAM protocol version.        */\n        cam_xport transport;            /* Transport (e.g., FC, USB).   */\n        u_int     transport_version;    /* Transport version.           */\n\n      union {\n                u_int valid;            /* Which field(s) to honor.     */\n                struct ccb_trans_settings_scsi scsi;\n        } proto_specific;\n\n      union {\n                u_int valid;            /* Which field(s) to honor.     */\n                struct ccb_trans_settings_spi spi;\n                struct ccb_trans_settings_fc fc;\n                struct ccb_trans_settings_sas sas;\n                struct ccb_trans_settings_ata ata;\n                struct ccb_trans_settings_sata sata;\n        } xport_specific;\n};\n```", "```\nstruct ccb_trans_settings_scsi {\n        u_int           valid;          /* Which field(s) to honor.     */\n#define CTS_SCSI_VALID_TQ               0x01\n        u_int           flags;\n#define CTS_SCSI_FLAGS_TAG_ENB          0x01\n};\n\nstruct ccb_trans_settings_spi {\n        u_int           valid;          /* Which field(s) to honor.     */\n#define CTS_SPI_VALID_SYNC_RATE         0x01\n#define CTS_SPI_VALID_SYNC_OFFSET       0x02\n#define CTS_SPI_VALID_BUS_WIDTH         0x04\n#define CTS_SPI_VALID_DISC              0x08\n#define CTS_SPI_VALID_PPR_OPTIONS       0x10\n        u_int           flags;\n#define CTS_SPI_FLAGS_DISC_ENB          0x01\n        u_int           sync_period;    /* Sync period.                 */\n        u_int           sync_offset;    /* Sync offset.                 */\n        u_int           bus_width;      /* Bus width.                   */\n        u_int           ppr_options;    /* Parallel protocol request.   */\n};\n\nstruct ccb_trans_settings_fc {\n        u_int           valid;          /* Which field(s) to honor.     */\n#define CTS_FC_VALID_WWNN               0x8000\n#define CTS_FC_VALID_WWPN               0x4000\n#define CTS_FC_VALID_PORT               0x2000\n#define CTS_FC_VALID_SPEED              0x1000\n        u_int64_t       wwnn;           /* World wide node name.        */\n        u_int64_t       wwpn;           /* World wide port name.        */\n        u_int32_t       port;           /* 24-bit port ID (if known).   */\n        u_int32_t       bitrate;        /* Mbps.                        */\n};\n\nstruct ccb_trans_settings_sas {\n        u_int           valid;          /* Which field(s) to honor.     */\n#define CTS_SAS_VALID_SPEED             0x1000\n        u_int32_t       bitrate;        /* Mbps.                        */\n};\n\nstruct ccb_trans_settings_ata {\n        u_int           valid;          /* Which field(s) to honor.     */\n#define CTS_ATA_VALID_MODE              0x01\n#define CTS_ATA_VALID_BYTECOUNT         0x02\n#define CTS_ATA_VALID_ATAPI             0x20\n        int             mode;           /* Mode.                        */\n        u_int           bytecount;      /* PIO transaction length.      */\n        u_int           atapi;          /* ATAPI CDB length.            */\n};\n\nstruct ccb_trans_settings_sata {\n        u_int           valid;          /* Which field(s) to honor.     */\n#define CTS_SATA_VALID_MODE             0x01\n#define CTS_SATA_VALID_BYTECOUNT        0x02\n#define CTS_SATA_VALID_REVISION         0x04\n#define CTS_SATA_VALID_PM               0x08\n#define CTS_SATA_VALID_TAGS             0x10\n#define CTS_SATA_VALID_ATAPI            0x20\n#define CTS_SATA_VALID_CAPS             0x40\n        int             mode;           /* Legacy PATA mode.            */\n        u_int           bytecount;      /* PIO transaction length.      */\n        int             revision;       /* SATA revision.               */\n        u_int           pm_present;     /* PM is present (XPT->SIM).    */\n        u_int           tags;           /* Number of allowed tags.      */\n        u_int           atapi;          /* ATAPI CDB length.            */\n        u_int           caps;           /* Host and device SATA caps.   */\n#define CTS_SATA_CAPS_H                 0x0000ffff\n#define CTS_SATA_CAPS_H_PMREQ           0x00000001\n#define CTS_SATA_CAPS_H_APST            0x00000002\n#define CTS_SATA_CAPS_H_DMAAA           0x00000010\n#define CTS_SATA_CAPS_D                 0xffff0000\n#define CTS_SATA_CAPS_D_PMREQ           0x00010000\n#define CTS_SATA_CAPS_D_APST            0x00020000\n};\n```", "```\nstatic void\nmfip_action(struct cam_sim *sim, union ccb *ccb)\n{\n        struct mfip *sc;\n        struct mfi_softc *mfi;\n\n        sc = cam_sim_softc(sim);\n        mfi = sc->mfi;\n        mtx_assert(&mfi->mfi_io_lock, MA_OWNED);\n\n        switch (ccb->ccb_h.func_code) {\n...\n        case XPT_GET_TRAN_SETTINGS:\n        {\n                struct ccb_trans_settings_sas *sas;\n\n              ccb->cts.protocol = PROTO_SCSI;\n                ccb->cts.protocol_version = SCSI_REV_2;\n                ccb->cts.transport = XPORT_SAS;\n                ccb->cts.transport_version = 0;\n                sas = &ccb->cts.xport_specific.sas;\n                sas->valid &= ˜CTS_SAS_VALID_SPEED;\n                sas->bitrate = 150000;\n\n                ccb->ccb_h.status = CAM_REQ_CMP;\n                break;\n        }\n...\n        default:\n                ccb->ccb_h.status = CAM_REQ_INVALID;\n                break;\n        }\n\n        xpt_done(ccb);\n        return;\n}\n```", "```\nstatic void\nmfip_action(struct cam_sim *sim, union ccb *ccb)\n{\n        struct mfip *sc;\n        struct mfi_softc *mfi;\n\n        sc = cam_sim_softc(sim);\n        mfi = sc->mfi;\n        mtx_assert(&mfi->mfi_io_lock, MA_OWNED);\n\n        switch (ccb->ccb_h.func_code) {\n...\n        case XPT_SET_TRAN_SETTINGS:\n                ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n                break;\n...\n        default:\n                ccb->ccb_h.status = CAM_REQ_INVALID;\n                break;\n        }\n\n        xpt_done(ccb);\n        return;\n}\n```", "```\nstruct ccb_scsiio {\n        struct ccb_hdr ccb_h;           /* Header information fields.   */\n        union ccb *next_ccb;            /* Next CCB to process.         */\n        u_int8_t  *req_map;             /* Mapping information.         */\n        u_int8_t  *data_ptr;            /* Data buffer or S/G list.     */\n        u_int32_t  dxfer_len;           /* Length of data to transfer.  */\n\n        /* Sense information (used if the command returns an error).    */\n        struct scsi_sense_data sense_data;\n\n        u_int8_t   sense_len;           /* Sense information length.    */\n        u_int8_t   cdb_len;             /* SCSI command length.         */\n        u_int16_t  sglist_cnt;          /* Number of S/G segments.      */\n        u_int8_t   scsi_status; /* SCSI status (returned by device).    */\n        u_int8_t   sense_resid; /* Residual sense information length.   */\n        u_int32_t  resid;               /* Residual data length.        */\n        cdb_t      cdb_io;              /* SCSI command.                */\n        u_int8_t  *msg_ptr;             /* Message.                     */\n        u_int16_t  msg_len;             /* Message length.              */\n        u_int8_t   tag_action;          /* Tag action?                  */\n        /*\n         * tag_action should be the constant below to send a non-tagged\n         * transaction or one of the constants in scsi_message.h.\n         */\n#define CAM_TAG_ACTION_NONE             0x00\n        u_int      tag_id;              /* Tag ID (from initiator).     */\n        u_int      init_id;             /* Initiator ID.                */\n};\n```", "```\nstruct ccb_hdr {\n        cam_pinfo       pinfo;          /* Priority scheduling.         */\n        camq_entry      xpt_links;      /* Transport layer links.       */\n        camq_entry      sim_links;      /* SIM layer links.             */\n        camq_entry      periph_links;   /* Peripheral layer links.      */\n        u_int32_t       retry_count;    /* Retry count.                 */\n\n        /* Pointer to peripheral module done routine.                   */\n        void (*cbfcnp)(struct cam_periph *, union ccb *);\n\n        xpt_opcode      func_code;      /* I/O operation to perform.    */\n        u_int32_t     status;         /* Completion status.           */\n        struct cam_path *path;          /* Path for this CCB.           */\n        path_id_t       path_id;        /* Path ID for the request.     */\n        target_id_t     target_id;      /* Target device ID.            */\n        lun_id_t        target_lun;     /* Target logical unit number.  */\n        u_int32_t       flags;          /* CCB flags.                   */\n        ccb_ppriv_area  periph_priv;    /* Private use by peripheral.   */\n        ccb_spriv_area  sim_priv;       /* Private use by SIM.          */\n        u_int32_t       timeout;        /* Timeout value.               */\n\n        /* Deprecated. Don't use!                                       */\n        struct callout_handle timeout_ch;\n};\n```", "```\n#define ccb_mfip_ptr            sim_priv.entries[0].ptr\n...\nstatic void\nmfip_action(struct cam_sim *sim, union ccb *ccb)\n{\n        struct mfip *sc;\n        struct mfi_softc *mfi;\n\n        sc = cam_sim_softc(sim);\n        mfi = sc->mfi;\n        mtx_assert(&mfi->mfi_io_lock, MA_OWNED);\n\n        switch (ccb->ccb_h.func_code) {\n...\n        case XPT_SCSI_IO:\n        {\n                struct ccb_hdr *ccb_h = &ccb->ccb_h;\n                struct ccb_scsiio *csio = &ccb->csio;\n\n                ccb_h->status = CAM_REQ_INPROG;\n              if (csio->cdb_len > MFI_SCSI_MAX_CDB_LEN) {\n                        ccb_h->status = CAM_REQ_INVALID;\n                        break;\n                }\n              if ((ccb_h->flags & CAM_DIR_MASK) != CAM_DIR_NONE) {\n                      if (ccb_h->flags & CAM_DATA_PHYS) {\n                                ccb_h->status = CAM_REQ_INVALID;\n                              break;\n                        }\n                      if (ccb_h->flags & CAM_SCATTER_VALID) {\n                                ccb_h->status = CAM_REQ_INVALID;\n                              break;\n                        }\n                }\n\n              ccb_h->ccb_mfip_ptr = sc;\n                TAILQ_INSERT_TAIL(&mfi->mfi_cam_ccbq, ccb_h, sim_links.tqe);\n              mfi_startio(mfi);\n\n                return;\n        }\n        default:\n                ccb->ccb_h.status = CAM_REQ_INVALID;\n                break;\n        }\n\n        xpt_done(ccb);\n        return;\n}\n```", "```\nstatic struct mfi_command *\nmfip_start(void *data)\n{\n        union ccb *ccb = data;\n        struct ccb_hdr *ccb_h = &ccb->ccb_h;\n        struct ccb_scsiio *csio = &ccb->csio;\n        struct mfip *sc;\n        struct mfi_command *cm;\n        struct mfi_pass_frame *pt;\n\n        sc = ccb_h->ccb_mfip_ptr;\n\n        if ((cm = mfi_dequeue_free(sc->mfi)) == NULL)\n                return (NULL);\n\n        pt = &cm->cm_frame->pass;\n        pt->header.cmd = MFI_CMD_PD_SCSI_IO;\n        pt->header.cmd_status = 0;\n        pt->header.scsi_status = 0;\n        pt->header.target_id = ccb_h->target_id;\n        pt->header.lun_id = ccb_h->target_lun;\n        pt->header.flags = 0;\n        pt->header.timeout = 0;\n        pt->header.data_len = csio->dxfer_len;\n        pt->header.sense_len = MFI_SENSE_LEN;\n        pt->header.cdb_len = csio->cdb_len;\n        pt->sense_addr_lo = cm->cm_sense_busaddr;\n        pt->sense_addr_hi = 0;\n        if (ccb_h->flags & CAM_CDB_POINTER)\n                bcopy(csio->cdb_io.cdb_ptr, &pt->cdb[0],\n csio->cdb_len);\n        else\n                bcopy(csio->cdb_io.cdb_bytes, &pt->cdb[0], csio->cdb_len);\n\n        cm->cm_complete = mfip_done;\n        cm->cm_private = ccb;\n        cm->cm_sg = &pt->sgl;\n        cm->cm_total_frame_size = MFI_PASS_FRAME_SIZE;\n        cm->cm_data = csio->data_ptr;\n        cm->cm_len = csio->dxfer_len;\n        switch (ccb_h->flags & CAM_DIR_MASK) {\n      case CAM_DIR_IN:\n                cm->cm_flags = MFI_CMD_DATAIN;\n                break;\n      case CAM_DIR_OUT:\n                cm->cm_flags = MFI_CMD_DATAOUT;\n                break;\n      case CAM_DIR_NONE:\n        default:\n                cm->cm_data = NULL;\n                cm->cm_len = 0;\n                cm->cm_flags = 0;\n                break;\n        }\n\n        TAILQ_REMOVE(&sc->mfi->mfi_cam_ccbq, ccb_h, sim_links.tqe);\n        return (cm);\n}\n```", "```\nstatic void\nmfip_done(struct mfi_command *cm)\n{\n        union ccb *ccb = cm->cm_private;\n        struct ccb_hdr *ccb_h = &ccb->ccb_h;\n        struct ccb_scsiio *csio = &ccb->csio;\n        struct mfip *sc;\n        struct mfi_pass_frame *pt;\n\n        sc = ccb_h->ccb_mfip_ptr;\n        pt = &cm->cm_frame->pass;\n\n        switch (pt->header.cmd_status) {\n        case MFI_STAT_OK:\n        {\n                uint8_t command, device;\n\n                ccb_h->status = CAM_REQ_CMP;\n                csio->scsi_status = pt->header.scsi_status;\n\n                if (ccb_h->flags & CAM_CDB_POINTER)\n                        command = ccb->csio.cdb_io.cdb_ptr[0];\n                else\n                        command = ccb->csio.cdb_io.cdb_bytes[0];\n\n                if (command == INQUIRY) {\n                        device = ccb->csio.data_ptr[0] & 0x1f;\n                        if ((device == T_DIRECT) || (device == T_PROCESSOR))\n                                csio->data_ptr[0] =\n                                    (device & 0xe0) | T_NODEVICE;\n                }\n\n                break;\n        }\n      case MFI_STAT_SCSI_DONE_WITH_ERROR:\n        {\n                int sense_len;\n\n                ccb_h->status = CAM_SCSI_STATUS_ERROR | CAM_AUTOSNS_VALID;\n                csio->scsi_status = pt->header.scsi_status;\n\n                sense_len = min(pt->header.sense_len,\n                    sizeof(struct scsi_sense_data));\n                bzero(&csio->sense_data, sizeof(struct scsi_sense_data));\n              bcopy(&cm->cm_sense->data[0], &csio->sense_data,\n                    sense_len);\n                break;\n        }\n        case MFI_STAT_DEVICE_NOT_FOUND:\n                ccb_h->status = CAM_SEL_TIMEOUT;\n                break;\n        case MFI_STAT_SCSI_IO_FAILED:\n                ccb_h->status = CAM_REQ_CMP_ERR;\n                csio->scsi_status = pt->header.scsi_status;\n                break;\n        default:\n                ccb_h->status = CAM_REQ_CMP_ERR;\n                csio->scsi_status = pt->header.scsi_status;\n                break;\n        }\n\n        mfi_release_command(cm);\n        xpt_done(ccb);\n}\n```", "```\nstatic void\nbtaction(struct cam_sim *sim, union ccb *ccb)\n{\n        struct bt_softc *bt;\n\n        bt = (struct bt_softc *)cam_sim_softc(sim);\n\n        switch (ccb->ccb_h.func_code) {\n        case XPT_RESET_DEV:\n                /* FALLTHROUGH */\n        case XPT_SCSI_IO:\n        {\n...\n```"]