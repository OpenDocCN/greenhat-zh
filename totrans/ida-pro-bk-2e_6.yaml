- en: Part VI. The IDA Debugger
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六部分。IDA调试器
- en: Chapter 24. The IDA Debugger
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第24章。IDA调试器
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: IDA is most widely known as a disassembler, and it is clearly one of the finest
    tools available for performing static analysis of binaries. Given the sophistication
    of modern anti–static analysis techniques, it is not uncommon to combine static
    analysis tools and techniques with dynamic analysis tools and techniques in order
    to take advantage of the best of both worlds. Ideally, all of these tools would
    be integrated into a single package. Hex-Rays made that move when it introduced
    a debugger in version 4.5 of IDA and solidified IDA’s role as a general-purpose
    reverse engineering tool. With each successive version of IDA, its debugging capabilities
    have been improved. In its latest version, IDA is capable of local and remote
    debugging on a number of different platforms and supports a number of different
    processors. IDA may also be configured to act as a frontend to Microsoft’s WinDbg
    debugger, making it possible to perform Windows kernel debugging.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: IDA最广为人知的是反汇编器，它显然是用于对二进制文件进行静态分析的最佳工具之一。鉴于现代反静态分析技术的复杂性，将静态分析工具和技术与动态分析工具和技术相结合以利用两者的优点并不罕见。理想情况下，所有这些工具都应集成在一个单一包中。当Hex-Rays在IDA
    4.5版本中引入调试器时，它实现了这一举措，并巩固了IDA作为通用逆向工程工具的角色。随着IDA每个后续版本的发布，其调试功能得到了改进。在其最新版本中，IDA能够对多种不同平台上的本地和远程调试进行操作，并支持多种不同的处理器。IDA还可以配置为充当Microsoft的WinDbg调试器的前端，从而实现Windows内核调试。
- en: Over the course of the next few chapters, we will cover the basic features of
    IDA’s debugger, using the debugger to assist with obfuscated code analysis and
    remote debugging of Windows, Linux, or OS X binaries. While we assume that the
    reader possesses some familiarity with the use of debuggers, we will review many
    of the basic capabilities of debuggers in general as we progress through the features
    of IDA’s debugger.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将介绍IDA调试器的基本功能，使用调试器协助进行代码混淆分析以及远程调试Windows、Linux或OS X二进制文件。虽然我们假设读者对调试器的使用有一定了解，但我们将在介绍IDA调试器功能的过程中回顾调试器的一般基本功能。
- en: Launching the Debugger
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动调试器
- en: 'Debuggers are typically used to perform one of two tasks: examining memory
    images (core dumps) associated with crashed processes and executing processes
    in a very controlled manner. A typical debugging session begins with the selection
    of a process to debug. There are two ways this is generally accomplished. First,
    most debuggers are capable of *attaching* to a running process (assuming the user
    has permission to do so). Depending on the debugger being used, the debugger itself
    may be able to present a list of available processes to choose from. Lacking such
    capability, the user must determine the ID of the process to which he wishes to
    attach and then command the debugger to attach to the specified process. The precise
    manner by which a debugger attaches to a process varies from one operating system
    to another and is beyond the scope of this book. When attaching to an existing
    process, it is not possible to monitor or control the process’s initial start-up
    sequence, because all of the startup and initialization code will already have
    completed before you have a chance to attach to the process.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器通常用于执行以下两项任务之一：检查与崩溃进程相关的内存映像（核心转储）以及在非常受控的方式下执行进程。典型的调试会话从选择要调试的进程开始。这通常有两种方法。首先，大多数调试器能够*附加*到正在运行的进程（假设用户有权限这样做）。根据所使用的调试器，调试器本身可能能够显示一个可供选择的过程列表。如果没有这种能力，用户必须确定他希望附加的进程的ID，然后命令调试器附加到指定的进程。调试器附加到进程的确切方式因操作系统而异，超出了本书的范围。当附加到现有进程时，无法监控或控制进程的初始启动序列，因为所有启动和初始化代码在您有机会附加到进程之前就已经完成。
- en: The manner by which you attach to a process with the IDA debugger depends on
    whether a database is currently open or not. When no database is open, the Debugger
    ▸ Attach menu is available, as shown in [Figure 24-1](ch24.html#attaching_to_an_arbitrary_process
    "Figure 24-1. Attaching to an arbitrary process").
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IDA调试器附加到进程的方式取决于是否打开了数据库。当没有打开数据库时，调试器▸附加菜单是可用的，如图[图24-1](ch24.html#attaching_to_an_arbitrary_process
    "图24-1. 附加到任意进程")所示。
- en: '![Attaching to an arbitrary process](httpatomoreillycomsourcenostarchimages854356.png.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![连接到任意进程](httpatomoreillycomsourcenostarchimages854356.png.jpg)'
- en: Figure 24-1. Attaching to an arbitrary process
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-1. 连接到任意进程
- en: Available options allow selection of different IDA debuggers (remote debugging
    is covered in [Chapter 26](ch26.html "Chapter 26. Additional Debugger Features")).
    Options vary depending on the platform on which you are running IDA. Selecting
    a local debugger causes IDA to display a list of running processes to which you
    may attach. [Figure 24-2](ch24.html#debugger_process-selection_dialog "Figure 24-2. Debugger
    process-selection dialog") shows an example of such a list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的选项允许选择不同的IDA调试器（远程调试在[第26章](ch26.html "第26章. 其他调试器功能")中介绍）。选项取决于您在哪个平台上运行IDA。选择本地调试器会导致IDA显示一个可以附加的运行进程列表。[图24-2](ch24.html#debugger_process-selection_dialog
    "图24-2. 调试器进程选择对话框")显示了此类列表的一个示例。
- en: '![Debugger process-selection dialog](httpatomoreillycomsourcenostarchimages854359.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![调试器进程选择对话框](httpatomoreillycomsourcenostarchimages854359.png.jpg)'
- en: Figure 24-2. Debugger process-selection dialog
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-2. 调试器进程选择对话框
- en: Once a process has been selected, the debugger creates a temporary database
    by taking a memory snapshot of the running process. In addition to the memory
    image of the running process, the temporary database contains sections for all
    shared libraries loaded by the process, resulting in a substantially larger and
    more cluttered database than you may be accustomed to. One drawback to attaching
    to a process in this manner is that IDA has less information available to disassemble
    the process because IDA’s loader never processes the corresponding executable
    file image and an automated analysis of the binary is never performed. In fact,
    once the debugger has attached to the process, the only instructions that will
    be disassembled in the binary are the instruction referenced by the instruction
    pointer and those that flow from it. Attaching to a process immediately pauses
    the process, allowing you the opportunity to set breakpoints prior to resuming
    execution of the process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了进程，调试器将通过获取运行进程的内存快照来创建一个临时数据库。除了运行进程的内存映像外，临时数据库还包含由进程加载的所有共享库的部分，这导致数据库比您可能习惯的要大得多且更杂乱。以这种方式连接到进程的一个缺点是，IDA由于加载器从未处理相应的可执行文件映像，并且从未执行过二进制的自动分析，因此对进程的解汇编信息较少。实际上，一旦调试器连接到进程，二进制中将被解汇编的唯一指令是指令指针引用的指令以及从它流出的指令。连接到进程会立即暂停进程，让您有机会在恢复进程执行之前设置断点。
- en: An alternate way to attach to a running process is to open the associated executable
    in IDA before attempting to attach to the running process. With a database open,
    the Debugger menu takes on an entirely different form, as shown in [Figure 24-3](ch24.html#debugger_menu_with_a_database_open
    "Figure 24-3. Debugger menu with a database open").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种连接到正在运行的进程的方法是在尝试连接到正在运行的进程之前，在IDA中打开相关的可执行文件。在打开数据库的情况下，调试器菜单将呈现出完全不同的形式，如[图24-3](ch24.html#debugger_menu_with_a_database_open
    "图24-3. 打开数据库时的调试器菜单")所示。
- en: '![Debugger menu with a database open](httpatomoreillycomsourcenostarchimages854362.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![打开数据库时的调试器菜单](httpatomoreillycomsourcenostarchimages854362.png.jpg)'
- en: Figure 24-3. Debugger menu with a database open
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-3. 打开数据库时的调试器菜单
- en: If you are not presented with this menu (or one very like it), then you probably
    have not yet specified a debugger to use for the currently open file type. In
    such cases, Debugger ▸ Select Debugger will present a list of suitable debuggers
    given the current file type. [Figure 24-4](ch24.html#debugger_selection_dialog
    "Figure 24-4. Debugger selection dialog") shows a typical debugger selection dialog.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到这个菜单（或者一个非常相似的菜单），那么您可能还没有指定用于当前打开文件类型的调试器。在这种情况下，选择“调试器 ▸ 选择调试器”将根据当前文件类型显示一个合适的调试器列表。[图24-4](ch24.html#debugger_selection_dialog
    "图24-4. 调试器选择对话框")显示了典型的调试器选择对话框。
- en: '![Debugger selection dialog](httpatomoreillycomsourcenostarchimages854365.png.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![调试器选择对话框](httpatomoreillycomsourcenostarchimages854365.png.jpg)'
- en: Figure 24-4. Debugger selection dialog
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-4. 调试器选择对话框
- en: You may make your selection the default debugger for the current file type by
    checking the box at the bottom of the dialog. The current default debugger, if
    any, is noted just above the checkbox. Once you have selected a debugger, you
    may change debuggers at any time via the Debug ▸ Switch Debugger menu.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过勾选对话框底部的复选框来将你的选择设置为当前文件类型的默认调试器。当前的默认调试器（如果有），会在复选框上方注明。一旦你选择了调试器，你可以在任何时间通过“调试”▸“切换调试器”菜单来更改调试器。
- en: When Debugger ▸ Attach to Process is selected, IDA’s behavior will vary depending
    on the type of file opened in the active database. If the file is an executable
    file, IDA will display a list of all processes that have the same name as the
    file opened in the database. If IDA can find no process with a matching name,
    IDA will display a list of every running process and leave it to you to choose
    the correct process to attach to. In any case, you may attach to any of the displayed
    processes, but IDA has no way to guarantee that the process was started with same
    binary image that is loaded in the open IDA database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择“调试器”▸“附加到进程”时，IDA的行为将根据在活动数据库中打开的文件类型而有所不同。如果文件是可执行文件，IDA将显示与数据库中打开的文件同名的所有进程列表。如果IDA找不到具有匹配名称的进程，它将显示所有正在运行的进程列表，并留给你选择要附加的正确进程。在任何情况下，你可以附加到显示的任何进程，但IDA无法保证该进程是以与打开的IDA数据库中加载的相同二进制映像启动的。
- en: IDA behaves differently if the currently open database is a shared library.
    On Windows systems, IDA will filter the displayed process list to just those processes
    that have the corresponding *.dll* file loaded. For example, if you are currently
    analyzing *wininet.dll* in IDA, then when you select Debugger ▸ Attach to Process,
    you will see only those processes that currently have *wininet.dll* loaded. On
    Linux and OS X systems, IDA does not have this filtering ability and displays
    every process to which you have the rights to attach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前打开的数据库是一个共享库时，IDA的行为会有所不同。在Windows系统上，IDA会过滤显示的进程列表，只显示那些加载了相应*.dll*文件的进程。例如，如果你目前在IDA中分析*wininet.dll*，那么当你选择“调试器”▸“附加到进程”时，你将只会看到那些当前已加载*wininet.dll*的进程。在Linux和OS
    X系统上，IDA没有这种过滤能力，会显示你可以附加权限的每一个进程。
- en: As an alternative to attaching to an existing process, you may opt to launch
    a new process under debugger control. With no database open, a new process can
    be launched via Debugger ▸ Run. When a database is open, a new process can be
    launched via Debugger ▸ Start Process or Debugger ▸ Run to Cursor. Using the former
    causes the new process to execute until it hits a breakpoint (which you need to
    have set prior to choosing Debugger ▸ Start Process) or until you elect to pause
    the process using Debugger ▸ Pause Process. Using Debugger ▸ Run to Cursor automatically
    sets a breakpoint at the current cursor location prior to starting the new process.
    In this case, the new process will execute until the current cursor location is
    reached or until an earlier breakpoint is hit. If execution never reaches the
    current cursor location (or any other breakpoint), the process will continue to
    run until it is forcibly paused or terminated (Debugger ▸ Terminate Process).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加到现有进程的替代方案，你可以选择在调试器控制下启动一个新的进程。在没有打开数据库的情况下，可以通过“调试器”▸“运行”来启动一个新的进程。当打开数据库时，可以通过“调试器”▸“启动进程”或“调试器”▸“运行到光标”来启动一个新的进程。使用前者会导致新进程执行，直到它遇到断点（你需要在选择“调试器”▸“启动进程”之前设置）或直到你选择使用“调试器”▸“暂停进程”来暂停进程。使用“调试器”▸“运行到光标”会自动在启动新进程之前在当前光标位置设置断点。在这种情况下，新进程将执行，直到当前光标位置被达到或直到遇到更早的断点。如果执行永远不会达到当前光标位置（或任何其他断点），进程将继续运行，直到被强制暂停或终止（“调试器”▸“终止进程”）。
- en: Launching a process under debugger control (as opposed to attaching to an existing
    process) is the only way to monitor every action the process takes. With breakpoints
    set prior to process initiation, it becomes possible to closely monitor a process’s
    entire startup sequence. Controlling startup sequences is particularly important
    in the case of programs that have been obfuscated, because you will often want
    to pause the process immediately after the de-obfuscation routines complete and
    before the process begins its normal operations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器控制下启动进程（而不是附加到现有进程），是唯一一种监控进程所采取的每一个动作的方法。在进程启动前设置断点，可以让你密切监控进程的整个启动序列。控制启动序列对于被混淆的程序尤为重要，因为你在反混淆例程完成后，进程开始正常操作之前，通常会希望立即暂停进程。
- en: Another advantage to launching a process from an open IDA database is that IDA
    performs its initial autoanalysis on the process image before launching the process.
    This results in significantly better disassembly quality over that attained when
    attaching the debugger to an existing process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从打开的 IDA 数据库启动进程的另一个优点是，IDA 在启动进程之前会对进程映像进行初始的自动分析。这导致与将调试器附加到现有进程时获得的反汇编质量显著提高。
- en: IDA’s debugger is capable of both local and remote debugging. For local debugging,
    you can only debug binaries that will run on your platform. There is no emulation
    layer that allows binaries from alternate platforms or CPU types to be executed
    within IDA’s local debugger. For remote debugging, IDA ships with a number of
    debugging servers including implementations for Windows 32/64, Windows CE/ARM,
    Mac OS X 32/64, Linux 32/64/ARM, and Android. The debugging servers are intended
    to execute alongside the binary that you intend to debug. Once you have a remote
    debugging server running, IDA can communicate with the server to launch or attach
    to a target process on the remote machine. For Windows CE ARM devices, IDA communicates
    with the remote device using ActiveSync and installs the debugging server remotely.
    IDA is also capable of communicating with the `gdbserver`^([[216](#ftn.CHP-24-FN-1)])
    component of the GNU Debugger^([[217](#ftn.CHP-24-FN-2)]) (gdb) or with programs
    that are linked with a suitable gdb remote stub.^([[218](#ftn.CHP-24-FN-3)]) Finally,
    for remote debugging on Symbian devices, you must install and configure Metrowerk’s
    App TRK^([[219](#ftn.CHP-24-FN-4)]) in order for IDA to communicate with the device
    over a serial port. In any case, IDA is capable of acting as a debugger frontend
    only for processing running on x86, x64, MIPS, ARM, and PPC processors. Remote
    debugging is discussed in [Chapter 26](ch26.html "Chapter 26. Additional Debugger
    Features").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的调试器能够进行本地和远程调试。对于本地调试，你只能调试将在你的平台上运行的二进制文件。IDA 的本地调试器没有仿真层，无法执行来自其他平台或
    CPU 类型的二进制文件。对于远程调试，IDA 随带了一些调试服务器，包括 Windows 32/64、Windows CE/ARM、Mac OS X 32/64、Linux
    32/64/ARM 和 Android 的实现。调试服务器旨在与你要调试的二进制文件一起执行。一旦你启动了远程调试服务器，IDA 就可以与服务器通信，在远程机器上启动或附加到目标进程。对于
    Windows CE ARM 设备，IDA 通过 ActiveSync 与远程设备通信，并在远程安装调试服务器。IDA 还能够与 GNU 调试器（gdb）的
    `gdbserver` 组件（^[[216](#ftn.CHP-24-FN-1)）或与链接了合适的 gdb 远程桩的程序通信（^[[218](#ftn.CHP-24-FN-3)）。最后，对于
    Symbian 设备的远程调试，你必须安装和配置 Metrowerk 的 App TRK（^[[219](#ftn.CHP-24-FN-4)），以便 IDA
    能够通过串行端口与设备通信。在任何情况下，IDA 只能作为 x86、x64、MIPS、ARM 和 PPC 处理器上运行的调试器前端。远程调试在[第 26 章](ch26.html
    "第 26 章。额外的调试器功能")中讨论。
- en: 'As with any other debugger, if you intend to use IDA’s debugger to launch new
    processes, the original executable file is required to be present on the debugging
    host, and the original binary will be executed with the full privileges of the
    user running IDA. In other words, it is not sufficient to have only an IDA database
    loaded with the binary you wish to debug. This is extremely important to understand
    if you intend to use the IDA debugger for malware analysis. You can easily infect
    the debugging target machine if you fail to properly control the malware sample.
    IDA attempts to warn you of this possibility anytime you select Debugger ▸ Start
    Process (or Debugger ▸ Attach to process with an open database) by displaying
    a debugger warning message stating the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他调试器一样，如果你打算使用 IDA 的调试器来启动新进程，原始的可执行文件必须存在于调试主机上，并且原始的二进制文件将以运行 IDA 的用户的完整权限执行。换句话说，仅仅加载了你希望调试的二进制文件的
    IDA 数据库是不够的。如果你打算使用 IDA 调试器进行恶意软件分析，这一点非常重要。如果你未能正确控制恶意软件样本，你很容易感染调试目标机器。IDA 会在你选择“调试器”▸“启动进程”（或“调试器”▸“使用打开的数据库附加到进程”）时尝试提醒你这种可能性，它会显示一个调试器警告消息，内容如下：
- en: You are going to launch the debugger. Debugging a program means that its code
    will be executed on your system.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你将启动调试器。调试程序意味着其代码将在你的系统上执行。
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be careful with malicious programs, viruses and trojans!
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小心恶意程序、病毒和木马！
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'REMARK: if you select ‘No’, the debugger will be automatically disabled.'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注：如果你选择“否”，调试器将被自动禁用。
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you sure you want to continue?
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你确定要继续吗？
- en: Selecting No in response to this warning causes the Debugger menu to be removed
    from the IDA menu bar. The Debugger menu will not be restored until you close
    the active database.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在此警告下选择“否”会导致调试器菜单从IDA菜单栏中移除。只有当你关闭活动数据库时，调试器菜单才会被恢复。
- en: It is highly recommended that you perform any debugging of malicious software
    within a sandbox environment. In contrast, the x86 emulator plug-in discussed
    in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis") neither requires
    that the original binary be present nor executes any of the binary’s instructions
    on the machine performing the emulation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你在沙盒环境中进行任何恶意软件的调试。相比之下，第21章中讨论的x86模拟器插件既不需要原始的二进制文件存在，也不会在执行模拟的机器上执行二进制文件的任何指令。
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[216](#CHP-24-FN-1)]) See [http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server](http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[216](#CHP-24-FN-1)]) 请参阅 [http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server](http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server)。
- en: ^([[217](#CHP-24-FN-2)]) See [http://www.gnu.org/software/gdb/](http://www.gnu.org/software/gdb/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[217](#CHP-24-FN-2)]) 请参阅 [http://www.gnu.org/software/gdb/](http://www.gnu.org/software/gdb/)。
- en: ^([[218](#CHP-24-FN-3)]) See [http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub](http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[218](#CHP-24-FN-3)]) 请参阅 [http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub](http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub)。
- en: ^([[219](#CHP-24-FN-4)]) See [http://www.tools.ext.nokia.com/agents/index.htm](http://www.tools.ext.nokia.com/agents/index.htm).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[219](#CHP-24-FN-4)]) 请参阅 [http://www.tools.ext.nokia.com/agents/index.htm](http://www.tools.ext.nokia.com/agents/index.htm)。
- en: Basic Debugger Displays
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本调试器显示
- en: Regardless of how you happen to launch the debugger, once your process of interest
    has been paused under debugger control, IDA enters its debugger mode (as opposed
    to normal disassembly mode), and you are presented with several default displays.
    The default debugger display is shown in [Figure 24-5](ch24s02.html#ida_debugger_display
    "Figure 24-5. IDA debugger display").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何启动调试器，一旦你的目标进程在调试器控制下暂停，IDA就会进入调试模式（与正常反汇编模式相反），你将看到几个默认的显示。默认的调试器显示在[图24-5](ch24s02.html#ida_debugger_display
    "图24-5. IDA调试器显示")中。
- en: '![IDA debugger display](httpatomoreillycomsourcenostarchimages854367.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![IDA调试器显示](httpatomoreillycomsourcenostarchimages854367.png.jpg)'
- en: Figure 24-5. IDA debugger display
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-5. IDA调试器显示
- en: If you are accustomed to using other Windows debuggers such as OllyDbg^([[220](#ftn.CHP-24-FN-5)])
    or Immunity Debugger,^([[221](#ftn.CHP-24-FN-6)]) one of your first thoughts might
    be that not much information is displayed on the screen. This is primarily a result
    of the fact that IDA defaults to a font size that is actually readable. If you
    find yourself missing the micro fonts used in other debuggers, you can easily
    change things via the Options ▸ Font menu. You may also wish to make use of saved
    IDA desktops (Windows ▸ Save Desktop) if you develop a fondness for a specific
    layout of your debugger windows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用其他Windows调试器，如OllyDbg^([[220](#ftn.CHP-24-FN-5)])或Immunity Debugger^([[221](#ftn.CHP-24-FN-6)]),你第一个可能的想法可能是屏幕上显示的信息不多。这主要是由于IDA默认的字体大小实际上是可读的。如果你发现自己怀念其他调试器中使用的微字体，你可以通过选项
    ▸ 字体菜单轻松更改这些设置。如果你对调试器窗口的特定布局情有独钟，你也可以使用保存的IDA桌面（Windows ▸ 保存桌面）。
- en: As shown in the [Figure 24-5](ch24s02.html#ida_debugger_display "Figure 24-5. IDA
    debugger display"), the debugger toolbar ![](httpatomoreillycomsourcenostarchimages854061.png)
    replaces the disassembly toolbar. A number of standard (from a debugging standpoint)
    tools are present, including process control tools and breakpoint manipulation
    tools.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图24-5](ch24s02.html#ida_debugger_display "图24-5. IDA调试器显示")所示，调试器工具栏![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)取代了反汇编工具栏。其中包含了许多标准（从调试的角度来看）的工具，包括进程控制工具和断点操作工具。
- en: The IDA View-EIP ![](httpatomoreillycomsourcenostarchimages854063.png) disassembly
    window is a default disassembly listing window when the debugger is active. It
    also happens to be synchronized with the current value of the instruction pointer
    register. If IDA detects that a register points to a memory location within the
    disassembly window, the name of that register is displayed in the left margin,
    opposite the address to which the register points. In [Figure 24-5](ch24s02.html#ida_debugger_display
    "Figure 24-5. IDA debugger display"), the location to which EIP points is flagged
    in IDA View-EIP (note that EDX also points to the same location in this example).
    By default, IDA highlights breakpoints in red and the next instruction to be executed
    (the one to which the instruction pointer points) in blue. Debugger-related disassemblies
    are generated via the same disassembly process used in standard disassembly mode.
    Thus, IDA’s debugger offers perhaps the best disassembly capability to be found
    in a debugger. Additionally, if you launched the debugger from an open IDA database,
    IDA is able to characterize all of the executable content based on analysis performed
    prior to launching the debugger. IDA’s ability to disassemble any library code
    that has been loaded by the process will be somewhat more limited because IDA
    has not had a chance to analyze the associated *.dll* file prior to launching
    the debugger.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: IDA View-EIP ![IDA View-EIP](http://atomoreilly.com/source/nostarch/images/854063.png)
    反汇编窗口是调试器激活时的默认反汇编列表窗口。它还恰好与指令指针寄存器的当前值同步。如果 IDA 检测到一个寄存器指向反汇编窗口内的内存位置，则在该寄存器的名称显示在左侧边缘，与寄存器指向的地址相对。在
    [图 24-5](ch24s02.html#ida_debugger_display "图 24-5. IDA 调试器显示") 中，EIP 指向的位置在 IDA
    View-EIP 中被标记出来（注意，在本例中 EDX 也指向相同的位置）。默认情况下，IDA 用红色突出显示断点，用蓝色突出显示将要执行的下一个指令（指令指针指向的指令）。与调试器相关的反汇编是通过与标准反汇编模式中使用的相同反汇编过程生成的。因此，IDA
    的调试器可能提供了在调试器中可以找到的最好的反汇编功能。此外，如果您从打开的 IDA 数据库启动调试器，IDA 能够根据启动调试器之前进行的分析来描述所有可执行内容。由于
    IDA 在启动调试器之前没有机会分析相关的 *.dll* 文件，因此 IDA 能够反汇编进程加载的任何库代码的能力将受到一定程度的限制。
- en: The Stack View ![](httpatomoreillycomsourcenostarchimages854093.png) window
    is another standard disassembly view primarily used to display the data contents
    of the process’s runtime stack. All registers that point to stack locations are
    noted as such in the General Registers ![](httpatomoreillycomsourcenostarchimages854095.png)
    view (such as EBP in this case). Through the use of comments, IDA makes every
    attempt to provide context information for each data item on the stack. When the
    stack item is a memory address, IDA attempts to resolve the address to a function
    location (this helps highlight the location from which a function was called).
    When the stack item is a data pointer, a reference to the associated data item
    is displayed. The remaining default displays include the Hex view ![](httpatomoreillycomsourcenostarchimages854099.png),
    which offers a standard hex dump of memory, the Modules ![](httpatomoreillycomsourcenostarchimages854101.png)
    view, which displays a list of modules currently loaded in the process image,
    and the Threads ![](httpatomoreillycomsourcenostarchimages854103.png) view, which
    displays a list of threads in the current process. Double-clicking any listed
    thread causes the IDA View-EIP disassembly window to jump to the current instruction
    within the selected thread and updates the General Registers view to reflect the
    current values for registers within the selected thread.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Stack View ![Stack View](http://atomoreilly.com/source/nostarch/images/854093.png)
    窗口是另一种标准反汇编视图，主要用于显示进程运行时栈的数据内容。所有指向栈位置的寄存器在通用寄存器 ![通用寄存器](http://atomoreilly.com/source/nostarch/images/854095.png)
    视图中都会被标记出来（例如，在本例中为 EBP）。通过使用注释，IDA 尽力为栈上的每个数据项提供上下文信息。当栈项是一个内存地址时，IDA 会尝试将该地址解析为函数位置（这有助于突出显示函数被调用的位置）。当栈项是一个数据指针时，会显示关联数据项的引用。其他默认显示包括十六进制视图
    ![十六进制视图](http://atomoreilly.com/source/nostarch/images/854099.png)，它提供标准的内存十六进制转储，模块
    ![模块](http://atomoreilly.com/source/nostarch/images/854101.png) 视图，显示当前进程图像中加载的模块列表，以及线程
    ![线程](http://atomoreilly.com/source/nostarch/images/854103.png) 视图，显示当前进程中的线程列表。双击任何列出的线程会导致
    IDA View-EIP 反汇编窗口跳转到所选线程中的当前指令，并更新通用寄存器视图以反映所选线程中寄存器的当前值。
- en: The General Registers window (also shown in [Figure 24-6](ch24s02.html#the_general_registers_display
    "Figure 24-6. The General Registers display")) displays the current contents of
    the CPU’s general-purpose registers. Additional windows for displaying the contents
    of the CPU’s segment, floating-point, or MMX registers may be opened from the
    Debugger menu.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “通用寄存器”窗口（如图24-6所示）显示CPU通用寄存器的当前内容。可以从调试器菜单打开显示CPU段、浮点或MMX寄存器内容的额外窗口。
- en: '![The General Registers display](httpatomoreillycomsourcenostarchimages854370.png.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![通用寄存器显示](httpatomoreillycomsourcenostarchimages854370.png.jpg)'
- en: Figure 24-6. The General Registers display
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-6. 通用寄存器显示
- en: Within the General Registers window, register contents are displayed to the
    right of the associated register name followed by a description of each register’s
    content. The CPU flag bits are displayed down the rightmost column. Right-clicking
    a register value or flag bit provides access to a Modify menu item, which allows
    you to change the contents of any register or CPU flag. Menu options offer quick
    access to zero a value, toggle a value, increment a value, or decrement a value.
    Toggling values is particularly useful for changing CPU flag bits. Right-clicking
    any register value also provides access to the Open Register Window menu item.
    Selecting Open Register Window causes IDA to open a new disassembly window centered
    at the memory location held in the selected register. If you ever find that you
    have inadvertently closed either IDA View-EIP or IDA View-ESP, use the Open Register
    Window command on the appropriate register to reopen the lost window. If a register
    appears to point to a valid memory location, then the right-angle arrow control
    to the right of that register’s value will be active and highlighted in black.
    Clicking an active arrow opens a new disassembly view centered on the corresponding
    memory location.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在“通用寄存器”窗口中，寄存器内容显示在相关寄存器名称的右侧，随后是每个寄存器内容的描述。CPU标志位显示在最右侧的列中。右键单击寄存器值或标志位可以访问“修改”菜单项，允许您更改任何寄存器或CPU标志的内容。菜单选项提供快速访问将值置零、切换值、增加值或减少值的功能。切换值对于更改CPU标志位特别有用。右键单击任何寄存器值还可以提供访问“打开寄存器窗口”菜单项。选择“打开寄存器窗口”会导致IDA在所选寄存器所持有的内存位置打开一个新的反汇编窗口。如果您意外关闭了IDA
    View-EIP或IDA View-ESP，请使用适当寄存器上的“打开寄存器窗口”命令重新打开丢失的窗口。如果寄存器看起来指向一个有效的内存位置，那么该寄存器值右侧的直角箭头控制将处于活动状态，并以黑色突出显示。单击活动箭头将打开一个以相应内存位置为中心的新反汇编视图。
- en: The Modules window displays a list of all executable files and shared libraries
    loaded into the process memory space. Double-clicking any module named in the
    list opens a list of symbols exported by that module. [Figure 24-7](ch24s02.html#the_modules_window_with_associated_modul
    "Figure 24-7. The Modules window with associated module contents") shows an example
    of the contents of *kernel32.dll*. The symbol list provides an easy way to track
    down functions within loaded libraries if you wish to set breakpoints on entry
    to those functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “模块”窗口显示所有加载到进程内存空间中的可执行文件和共享库的列表。双击列表中的任何模块将打开该模块导出的符号列表。[图24-7](ch24s02.html#the_modules_window_with_associated_modul
    "图24-7. 模块窗口及其相关模块内容")显示了*kernel32.dll*的内容示例。符号列表提供了一个轻松追踪加载库中函数的方法，如果您想在那些函数的入口处设置断点。
- en: '![The Modules window with associated module contents](httpatomoreillycomsourcenostarchimages854373.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![模块窗口及其相关模块内容](httpatomoreillycomsourcenostarchimages854373.png)'
- en: Figure 24-7. The Modules window with associated module contents
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-7. 模块窗口及其相关模块内容
- en: Additional debugger displays are accessible using various debugger menu selections.
    Displays pertaining to debugger operations will be discussed in the following
    section, “Process Control.” Along with the debugger-specific displays, all traditional
    IDA subviews, such as Functions and Segments, remain available via the Views ▸
    Open Subviews command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用各种调试器菜单选择来访问额外的调试器显示。有关调试器操作的显示将在下一节“进程控制”中讨论。除了调试器特定的显示外，所有传统的IDA子视图，如函数和段，都可以通过“视图”▸“打开子视图”命令访问。
- en: '* * *'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[220](#CHP-24-FN-5)]) See [http://www.ollydbg.de/](http://www.ollydbg.de/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[220](#CHP-24-FN-5)]) 查看 [http://www.ollydbg.de/](http://www.ollydbg.de/).
- en: ^([[221](#CHP-24-FN-6)]) See [http://www.immunityinc.com/products-immdbg.shtml](http://www.immunityinc.com/products-immdbg.shtml).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[221](#CHP-24-FN-6)]) 查看 [http://www.immunityinc.com/products-immdbg.shtml](http://www.immunityinc.com/products-immdbg.shtml)。
- en: Process Control
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程控制
- en: Perhaps the most important feature of any debugger is the ability to closely
    control—and modify, if desired—the behavior of the process being debugged. To
    that end, most debuggers offer commands that allow one or more instructions to
    be executed before returning control to the debugger. Such commands are often
    used in conjunction with breakpoints that allow the user to specify that execution
    should be interrupted when a designated instruction is reached or when a specific
    condition is met.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任何调试器最重要的特性可能是能够紧密控制——如果需要的话，还可以修改——正在调试的进程的行为。为此，大多数调试器提供了一些命令，允许在将控制权返回给调试器之前执行一个或多个指令。这些命令通常与断点一起使用，允许用户指定在到达指定的指令或满足特定条件时中断执行。
- en: Basic execution of a process under debugger control is accomplished through
    the use of various Step, Continue, and Run commands. Because they are used so
    frequently, it is helpful to become familiar with the toolbar buttons and hotkey
    sequences associated with these commands. [Figure 24-8](ch24s03.html#debugger_process_control_tools
    "Figure 24-8. Debugger process control tools") shows the toolbar buttons associated
    with execution of a process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器控制下基本执行进程是通过使用各种单步、继续和运行命令来完成的。由于它们使用频率很高，因此熟悉与这些命令相关的工具栏按钮和快捷键序列是有帮助的。[图24-8](ch24s03.html#debugger_process_control_tools
    "图24-8. 调试器进程控制工具")显示了与进程执行相关的工具栏按钮。
- en: '![Debugger process control tools](httpatomoreillycomsourcenostarchimages854376.png.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![调试器进程控制工具](httpatomoreillycomsourcenostarchimages854376.png.jpg)'
- en: Figure 24-8. Debugger process control tools
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-8. 调试器进程控制工具
- en: 'The behavior of each of these commands is described in the following list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表描述了这些命令的行为：
- en: '| **Continue** Resumes execution of a paused process. Execution continues until
    a breakpoint is hit, the user pauses or terminates execution, or the process terminates
    on its own. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **继续** 继续执行暂停的进程。执行将继续，直到遇到断点、用户暂停或终止执行，或者进程自行终止。|'
- en: '| **Pause** Pauses a running process. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **暂停** 暂停正在运行的过程。|'
- en: '| **Terminate** Terminates a running process. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **终止** 终止正在运行的过程。|'
- en: '| **Step Into** Executes the next instruction only. If the next instruction
    is a function call, breaks on the first instruction of the target function. Hence
    the name *Step Into*, since execution steps into any function being called. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **进入** 仅执行下一个指令。如果下一个指令是函数调用，则在目标函数的第一个指令处中断。因此得名“进入”，因为执行会进入被调用的任何函数。|'
- en: '| **Step Over** Executes the next instruction only. If the next instruction
    is a function call, treats the call as a single instruction, breaking once the
    function returns. Hence the name *Step Over*, since stepping proceeds over functions
    rather than through them as with Step Into. Execution may be interrupted prior
    to completion of the function call if a breakpoint is encountered. Step Over is
    very useful as a time-saver when the behavior of a function is well known and
    uninteresting. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **单步执行** 仅执行下一个指令。如果下一个指令是函数调用，则将调用视为单个指令，在函数返回时中断。因此得名“单步执行”，因为执行是跨过函数而不是像进入那样通过函数。如果在函数调用之前遇到断点，则执行可能会在函数调用完成之前中断。当函数的行为已知且不感兴趣时，单步执行非常有用，可以节省时间。|'
- en: '| **Run Until Return** Resumes execution of the current function and does not
    stop until that function returns (or a breakpoint is encountered). This operation
    is useful when you have seen enough of a function and you wish to get out of it
    or when you inadvertently step into a function that you meant to step over. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **运行到返回** 继续执行当前函数，直到该函数返回（或遇到断点）才停止。当您已经看到了足够多的函数内容，希望从中退出，或者不慎进入了一个本想跳过的函数时，此操作非常有用。|'
- en: '| **Run to Cursor** Resumes execution of the process and stops when execution
    reaches the current cursor location (or a breakpoint is hit). This feature is
    useful for running through large blocks of code without the need to set a permanent
    breakpoint at each location where you wish to pause. Beware that the program may
    not pause if the cursor location is bypassed or otherwise never reached. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **运行到光标处**会在执行达到当前光标位置（或遇到断点）时停止进程的执行。此功能在无需在每个希望暂停的位置设置永久断点的情况下运行大块代码时非常有用。请注意，如果光标位置被绕过或根本无法到达，程序可能不会暂停。'
- en: In addition to toolbar and hotkey access, all of the execution control commands
    are accessible via the Debugger menu. Regardless of whether a process pauses after
    a single step or hitting a breakpoint, each time the process pauses, all debugger-related
    displays are updated to reflect the state of the process (CPU registers, flags,
    memory contents) at the time the process was paused.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了工具栏和快捷键访问外，所有执行控制命令都可以通过调试器菜单访问。无论进程在单步执行后或遇到断点后是否暂停，每次进程暂停时，所有与调试器相关的显示都会更新，以反映进程暂停时的状态（CPU寄存器、标志、内存内容）。
- en: Breakpoints
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: '*Breakpoints* are a debugger feature that goes hand in hand with process execution
    and interruption (pausing). Breakpoints are set as a means of interrupting program
    execution at very specific locations within the program. In a sense a breakpoint
    is a more permanent extension of the Run to Cursor concept in that once a breakpoint
    is set at a given address, execution will always be interrupted when execution
    reaches that location, regardless of whether the cursor remains positioned on
    that location or not. However, while there is only one cursor to which execution
    can run, it is possible to set many breakpoints all over a program, the arrival
    at any one of which will interrupt execution of the program. Breakpoints are set
    in IDA by navigating to the location at which you want execution to pause and
    using the F2 hotkey (or right-clicking and selecting Add Breakpoint). Addresses
    at which breakpoints have been set are highlighted with a red (by default) band
    across the entire disassembly line. A breakpoint may be removed by pressing F2
    a second time to toggle the breakpoint off. A complete list of breakpoints currently
    set within a program may be viewed via Debugger ▸ Breakpoints ▸ Breakpoint List.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*断点*是调试器与进程执行和中断（暂停）紧密相关的功能。断点被设置为在程序中非常具体的地点中断程序执行。从某种意义上说，断点是对“运行到光标处”概念的更永久扩展，一旦在给定地址设置断点，执行到达该位置时，无论光标是否保持在那个位置，都会中断执行。然而，虽然只有一个执行可以运行的光标，但可以在程序的所有地方设置许多断点，到达任何一个都会中断程序的执行。在IDA中设置断点是通过导航到希望执行暂停的位置并使用F2快捷键（或右键单击并选择添加断点）来实现的。设置断点的地址会用红色（默认情况下）的带状区域突出显示在整个反汇编行上。可以通过按两次F2来切换断点，以关闭断点。可以通过“调试器”▸“断点”▸“断点列表”查看程序中当前设置的断点的完整列表。'
- en: By default, IDA utilizes *software breakpoints*, which are implemented by replacing
    the opcode byte at the breakpoint address with a software breakpoint instruction.
    For x86 binaries, this is the `int 3` instruction, which uses opcode value `0xCC`.
    Under normal circumstances, when a software breakpoint instruction is executed,
    the operating system transfers control to any debugger that may be monitoring
    the interrupted process. As discussed in [Chapter 21](ch21.html "Chapter 21. Obfuscated
    Code Analysis"), obfuscated code may take advantage of the behavior of software
    breakpoints in an attempt to hinder normal operation of any attached debugger.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，IDA使用*软件断点*，这是通过将断点地址处的操作码字节替换为软件断点指令来实现的。对于x86二进制文件，这是`int 3`指令，它使用操作码值`0xCC`。在正常情况下，当执行软件断点指令时，操作系统会将控制权传递给任何可能正在监控中断进程的调试器。如[第21章](ch21.html
    "第21章。混淆代码分析")中所述，混淆代码可能会利用软件断点的行为，试图阻碍任何附加调试器的正常操作。
- en: As an alternative to software breakpoints, some CPUs (such as the x86, actually
    386, and later) offer support for *hardware-assisted breakpoints*. Hardware breakpoints
    are typically configured through the use of dedicated CPU registers. For x86 CPUs,
    these registers are called DR0–7 (debug registers 0 through 7). A maximum of four
    hardware breakpoints can be specified using x86 registers DR0–3\. The remaining
    x86 debug registers are used to specify additional constraints on each breakpoint.
    When a hardware breakpoint is enabled, there is no need to substitute a special
    instruction into the program being debugged. Instead, the CPU itself decides whether
    execution should be interrupted or not based on values contained within the debug
    registers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件断点的替代，一些CPU（例如x86，实际上是386及其后续版本）提供了对*硬件辅助断点*的支持。硬件断点通常通过使用专用CPU寄存器来配置。对于x86
    CPU，这些寄存器被称为DR0–7（调试寄存器0到7）。可以使用x86寄存器DR0–3指定最多四个硬件断点。剩余的x86调试寄存器用于为每个断点指定额外的约束。当硬件断点启用时，不需要在调试的程序中替换特殊指令。相反，CPU本身会根据调试寄存器中的值决定是否中断执行。
- en: Once a breakpoint has been set, it is possible to modify various aspects of
    its behavior. Beyond simply interrupting the process, debuggers often support
    the concept of *conditional breakpoints*, which allow users to specify a condition
    that must be satisfied before the breakpoint is actually honored. When such a
    breakpoint is reached and the associated condition is not satisfied, the debugger
    automatically resumes execution of the program. The general idea is that the condition
    is expected to be satisfied at some point in the future, resulting in interruption
    of the program only when the condition you are interested in has been satisfied.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了断点，就可以修改其行为的各个方面。除了简单地中断进程之外，调试器通常还支持*条件断点*的概念，允许用户指定在断点实际被认可之前必须满足的条件。当达到这样的断点并且关联的条件未满足时，调试器会自动恢复程序的执行。一般想法是，预期条件将在未来的某个时刻得到满足，只有在感兴趣的条件下得到满足时，程序才会被中断。
- en: The IDA debugger supports both conditional and hardware breakpoints. In order
    to modify the default (unconditional, software-based) behavior of a breakpoint,
    you must edit a breakpoint after it has been set. In order to access the breakpoint-editing
    dialog, you must right-click an existing breakpoint and select Edit Breakpoint.
    [Figure 24-9](ch24s03.html#the_breakpoint_settings_dialog "Figure 24-9. The Breakpoint
    Settings dialog") shows the resulting Breakpoint Settings dialog.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: IDA调试器支持条件断点和硬件断点。为了修改断点的默认（无条件、基于软件）行为，你必须在设置断点之后编辑它。为了访问断点编辑对话框，你必须右键单击现有的断点并选择编辑断点。[图24-9](ch24s03.html#the_breakpoint_settings_dialog
    "图24-9. 断点设置对话框")显示了结果断点设置对话框。
- en: '![The Breakpoint Settings dialog](httpatomoreillycomsourcenostarchimages854379.png.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![断点设置对话框](httpatomoreillycomsourcenostarchimages854379.png.jpg)'
- en: Figure 24-9. The Breakpoint Settings dialog
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-9. 断点设置对话框
- en: The Location box indicates the address of the breakpoint being edited, while
    the Enabled checkbox indicates whether the breakpoint is currently active or not.
    A breakpoint that is disabled is not honored regardless of any condition that
    may be associated with the breakpoint. The Hardware checkbox is used to request
    that the breakpoint be implemented in hardware rather than software.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 位置框指示正在编辑的断点地址，而启用复选框指示断点当前是否处于活动状态。一个被禁用的断点无论与断点关联的条件如何，都不会被认可。硬件复选框用于请求将断点在硬件而不是软件中实现。
- en: Warning
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: 'A word of caution concerning hardware breakpoints: Though the x86 only supports
    four hardware breakpoints at any given time, as of this writing (IDA version 6.1),
    IDA will happily allow you to designate more than four hardware breakpoints. However,
    only four of them will be honored. Any additional hardware breakpoints will be
    ignored.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于硬件断点的注意事项：尽管x86架构在任何给定时间只支持四个硬件断点，但截至本文撰写时（IDA版本6.1），IDA仍然会愉快地允许你指定超过四个硬件断点。然而，只有其中四个会被认可。任何额外的硬件断点都将被忽略。
- en: When specifying a hardware breakpoint, you must use the Hardware breakpoint
    mode radio buttons to specify whether the breakpoint behavior is to break on execute,
    break on write, or break on read/write. The latter two categories (break on write
    and break on read/write) allow you to create breakpoints that trigger when a specific
    memory location (usually a data location) is accessed, regardless of what instruction
    happens to be executing at the time the access takes place. This is very useful
    if you are more interested in when your program accesses a piece of data than
    where the data is accessed from.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定硬件断点时，您必须使用硬件断点模式单选按钮来指定断点行为是在执行时中断、在写入时中断，还是在读取/写入时中断。后两种类别（在写入时中断和在读取/写入时中断）允许您创建在访问特定内存位置（通常是数据位置）时触发的断点，无论访问发生时正在执行什么指令。如果您更关注程序访问数据的时间，而不是数据访问的来源，这非常有用。
- en: 'In addition to specifying a mode for your hardware breakpoint, you must specify
    a size. For execute breakpoints the size must be 1 byte. For write or read/write
    breakpoints, the size may be set to 1, 2, or 4 bytes. When the size is set to
    2 bytes, the breakpoint’s address must be word aligned (a multiple of 2 bytes).
    Similarly, for 4-byte breakpoints, the breakpoint address must be double-word
    aligned (a multiple of 4 bytes). A hardware breakpoint’s size is combined with
    its address to form a range of bytes over which the breakpoint may be triggered.
    An example may help to explain. Consider a 4-byte write breakpoint set at address
    `0804C834h`. This breakpoint will be triggered by a 1-byte write to `0804C837h`,
    a 2-byte write to `0804C836h`, and a 4-byte write to `0804C832h`, among others.
    In each of these cases, at least 1 byte in the range `0804C834h0804C837h` is written.
    More information on the behavior of x86 hardware breakpoints can be found in the
    *Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B: System
    Programming Guide, Part 2*.^([[222](#ftn.CHP-24-FN-7)])'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为您的硬件断点指定模式外，您还必须指定大小。对于执行断点，大小必须是1字节。对于写入或读取/写入断点，大小可以设置为1、2或4字节。当大小设置为2字节时，断点的地址必须是字对齐的（2字节的倍数）。同样，对于4字节断点，断点地址必须是双字对齐的（4字节的倍数）。硬件断点的大小与其地址结合，形成一个字节范围，在此范围内断点可能被触发。以下是一个示例来帮助解释。考虑在地址`0804C834h`设置的4字节写入断点。这个断点将由对`0804C837h`的1字节写入、对`0804C836h`的2字节写入和对`0804C832h`的4字节写入触发，以及其他情况。在这些情况下，`0804C834h`到`0804C837h`范围内的至少1个字节被写入。有关x86硬件断点行为的更多信息，请参阅*英特尔64和IA-32架构软件开发者手册，第3B卷：系统编程指南，第2部分*。[^[[222](#ftn.CHP-24-FN-7)])
- en: Conditional breakpoints are created by providing an expression in the Breakpoint
    Settings dialog’s Condition field. Conditional breakpoints are a debugger feature,
    not an instruction set or CPU feature. When a breakpoint is triggered, it is the
    debugger’s job to evaluate any associated conditional expression and determine
    whether the program should be paused (the condition is met) or whether execution
    should simply continue (the condition is not met). Therefore, conditions may be
    specified for both software and hardware breakpoints.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在断点设置对话框的条件字段中提供表达式来创建条件断点。条件断点是调试器的功能，而不是指令集或CPU功能。当断点被触发时，调试器的任务是评估任何相关的条件表达式，并确定程序是否应该暂停（条件满足）或者执行应该简单地继续（条件不满足）。因此，可以为软件断点和硬件断点指定条件。
- en: IDA breakpoint conditions are specified using IDC (not Python) expressions.
    Expressions that evaluate to non-zero are considered true, satisfying the breakpoint
    condition and triggering the breakpoint. Expressions that evaluate to zero are
    considered false, failing to satisfy the breakpoint condition and failing to trigger
    the associated breakpoint. In order to assist in the creation of breakpoint expressions,
    IDA makes special register variables available within IDC (again, not Python)
    to provide direct access to register contents in breakpoint expressions. These
    variables are named after the registers themselves and include `EAX`, `EBX`, `ECX`,
    `EDX`, `ESI`, `EDI`, `EBP`, `ESP`, `EFL`, `AX`, `BX`, `CX`, `DX`, `SI`, `DI`,
    `BP`, `SP`, `AL`, `AH`, `BL`, `BH`, `CL`, `CH`, `DL`, and `DH`. These register
    variables are accessible only when the debugger is active.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: IDA断点条件使用IDC（而不是Python）表达式指定。计算结果非零的表达式被认为是真的，满足断点条件并触发断点。计算结果为零的表达式被认为是假的，未能满足断点条件，并且不会触发相关的断点。为了帮助创建断点表达式，IDA在IDC（再次，不是Python）中提供了特殊的寄存器变量，以便在断点表达式中直接访问寄存器内容。这些变量以寄存器本身命名，包括`EAX`、`EBX`、`ECX`、`EDX`、`ESI`、`EDI`、`EBP`、`ESP`、`EFL`、`AX`、`BX`、`CX`、`DX`、`SI`、`DI`、`BP`、`SP`、`AL`、`AH`、`BL`、`BH`、`CL`、`CH`、`DL`和`DH`。这些寄存器变量仅在调试器活动时才可访问。
- en: 'Unfortunately, no variables exist that allow direct access to the processor
    flag bits. In order to access individual CPU flags, you need to call the `GetRegValue`
    function to obtain the value of the desired flag bit, such as `CF`. If you need
    a reminder regarding valid register and flag names, refer to the labels along
    the left and right edges of the General Registers window. A few example breakpoint
    expressions are shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，没有变量可以直接访问处理器标志位。为了访问单个CPU标志，你需要调用`GetRegValue`函数来获取所需标志位的值，例如`CF`。如果你需要有关有效寄存器和标志名称的提醒，请参考“常规寄存器”窗口的左侧和右侧的标签。这里显示了几个示例断点表达式：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Two things to note about breakpoint expressions are the fact that IDC functions
    may be called to access process information (as long as the function returns a
    value) and the fact that assignment can be used as a means of modifying register
    values at specific locations during process execution. Ilfak himself demonstrated
    this technique as an example of overriding a function return value.^([[223](#ftn.CHP-24-FN-8)])
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于断点表达式需要注意的两点是：IDC函数可以被调用以访问进程信息（只要函数返回一个值），以及赋值可以用作在进程执行过程中特定位置修改寄存器值的一种手段。Ilfak
    本身就演示了这种技术，作为覆盖函数返回值的例子。[^([[223](#ftn.CHP-24-FN-8))]
- en: The last breakpoint options that can be configured in the Breakpoint Settings
    dialog are grouped into the Actions box on the right side of the dialog. The Break
    checkbox specifies whether program execution should actually be paused (assuming
    any associated condition is true) when the break-point is reached. It may seem
    unusual to create a breakpoint that doesn’t break, but this is actually a useful
    feature if all you want to do is modify a specific memory or register value each
    time an instruction is reached without requiring the program to be paused at the
    same time. Selecting the Trace checkbox causes a trace event to be logged each
    time the breakpoint is hit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在“断点设置”对话框中可以配置的最后断点选项被分组到对话框右侧的“操作”框中。断点复选框指定当达到断点时程序执行是否实际上应该暂停（假设任何相关条件为真）。创建一个不会中断的断点可能看起来有些不寻常，但如果你只想在每次到达指令时修改特定的内存或寄存器值而不需要同时暂停程序，这实际上是一个有用的功能。选择“跟踪”复选框会在每次断点被触发时记录一个跟踪事件。
- en: Tracing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪
- en: 'Tracing offers a means of logging specific events that occur while a process
    is executing. Trace events are logged to a fixed-size trace buffer and may optionally
    be logged to a trace file. Two styles of tracing are available: instruction tracing
    and function tracing. When *instruction tracing* is enabled (Debugger ▸ Tracing
    ▸ Instruction Tracing), IDA records the address, the instruction, and the values
    of any registers (other than EIP) that were changed by the instruction. Instruction
    tracing can slow down a debugged process considerably, because the debugger must
    single-step the process in order to monitor and record all register values. *Function
    tracing* (Debugger ▸ Tracing ▸ Function Tracing) is a subset of instruction tracing
    in which only function calls (and optionally returns) are logged. No register
    values are logged for function trace events.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪提供了一种记录在进程执行期间发生的特定事件的方法。跟踪事件记录到固定大小的跟踪缓冲区，并且可以选择记录到跟踪文件。有两种跟踪风格：指令跟踪和函数跟踪。当启用*指令跟踪*（调试器
    ▸ 跟踪 ▸ 指令跟踪）时，IDA记录由指令更改的地址、指令以及任何寄存器（除了EIP）的值（其他寄存器）。指令跟踪可能会显著减慢调试过程，因为调试器必须单步执行进程以监控和记录所有寄存器的值。"函数跟踪"（调试器
    ▸ 跟踪 ▸ 函数跟踪）是指令跟踪的一个子集，其中仅记录函数调用（以及可选的返回）。函数跟踪事件不记录任何寄存器值。
- en: 'Three types of individual trace events are also available: write traces, read/write
    traces, and execution traces. As their names imply, each allows logging of a trace
    event when a specific action occurs at a designated address. Each of these individual
    traces is implemented using nonbreaking breakpoints with the `trace` option set.
    Write and read/write traces are implemented using hardware breakpoints and thus
    fall under the same restrictions mentioned previously for hardware breakpoints,
    the most significant being that no more than four hardware-assisted breakpoints
    or traces may be active at any given time. By default, execution traces are implemented
    using software breakpoints, and thus there is no limit on the number of execution
    traces that can be set within a program.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 三种个人跟踪事件类型也可用：写入跟踪、读写跟踪和执行跟踪。正如其名称所暗示的，每个都允许在指定地址发生特定操作时记录跟踪事件。这些个人跟踪均使用非破坏性断点，并将`trace`选项设置为。写入和读写跟踪使用硬件断点实现，因此受到之前提到的硬件断点相同限制的影响，其中最重要的是在任何给定时间点不能超过四个硬件辅助断点或跟踪。默认情况下，执行跟踪使用软件断点实现，因此程序内可以设置的执行跟踪数量没有限制。
- en: '[Figure 24-10](ch24s03.html#the_tracing_options_dialog "Figure 24-10. The Tracing
    Options dialog") shows the Tracing Options (Debugger ▸ Tracing ▸ Tracing Options)
    dialog used to configure the debugger’s tracing operations.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图24-10](ch24s03.html#the_tracing_options_dialog "图24-10. 跟踪选项对话框")显示了用于配置调试器跟踪操作的跟踪选项（调试器
    ▸ 跟踪 ▸ 跟踪选项）对话框。'
- en: Options specified here apply to function and instruction tracing only. These
    options have no effect on individual trace events. The Trace buffer size option
    specifies the maximum number of trace events that may be displayed at any given
    time. For a given buffer size *n*, only the *n* most recent trace events are displayed.
    Naming a log file causes all trace events to be appended to the named file. A
    file dialog is not offered when specifying a log file, so you must specify the
    complete path to the log file yourself. An IDC expression may be entered as a
    stop condition. The condition is evaluated prior to tracing through each instruction.
    If the condition evaluates to true, execution is immediately paused. The effect
    of this expression is to act as a conditional breakpoint that is not tied to any
    specific location.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处指定的选项仅适用于函数和指令跟踪。这些选项对单个跟踪事件没有影响。跟踪缓冲区大小选项指定了任何给定时间可以显示的最大跟踪事件数。对于给定的缓冲区大小*n*，仅显示最近的*n*个跟踪事件。命名日志文件会导致所有跟踪事件附加到该命名文件。指定日志文件时不会提供文件对话框，因此您必须自己指定日志文件的完整路径。可以输入IDC表达式作为停止条件。该条件在通过每个指令进行跟踪之前进行评估。如果条件评估为真，则立即暂停执行。此表达式的效果是作为一个条件断点，它不依赖于任何特定位置。
- en: '![The Tracing Options dialog](httpatomoreillycomsourcenostarchimages854383.png.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪选项对话框](httpatomoreillycomsourcenostarchimages854383.png.jpg)'
- en: Figure 24-10. The Tracing Options dialog
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-10. 跟踪选项对话框
- en: 'The Mark consecutive traced events with same IP option, when checked, causes
    consecutive trace events originating from the same instruction (*IP* here means
    *Instruction Pointer*) to be flagged with an equal sign. An example in which consecutive
    events can originate at the same instruction address occurs when the `REP`^([[224](#ftn.CHP-24-FN-9)])
    prefix is used in `x86` programs. In order for an instruction trace to show each
    repetition at the same instruction address, the Log if same IP option must also
    be selected. Without this option selected, an instruction prefixed with `REP`
    is listed only once each time it is encountered. The following listing shows a
    partial instruction trace using the default trace settings:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当勾选“标记具有相同IP的连续跟踪事件”选项时，来自同一指令的连续跟踪事件会被标记为等号。当在`x86`程序中使用`REP`^([[224](#ftn.CHP-24-FN-9)])前缀时，可能会出现连续事件来自同一指令地址的例子。为了使指令跟踪显示每个重复的指令地址，必须也选择“如果IP相同则记录”选项。如果没有选择此选项，带有`REP`前缀的指令每次遇到时只列一次。以下列表显示了使用默认跟踪设置的部分指令跟踪：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the `movsb` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    is listed only once.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`movsb`指令![httpatomoreillycomsourcenostarchimages854061.png]只列了一次。
- en: 'In the following listing, Log if same IP has been selected, resulting in each
    iteration of the `rep` loop being logged:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，已选择“如果IP相同则记录”，导致`rep`循环的每次迭代都被记录：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, in the following listing, the Mark consecutive traced events with
    same IP option has been enabled, resulting in special markings that highlight
    the fact that the instruction pointer has not changed from one instruction to
    the next:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在以下列表中，已启用“标记具有相同IP的连续跟踪事件”选项，导致特殊的标记突出显示指令指针在连续的指令之间没有改变：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last two options we will mention concerning tracing are Trace over debugger
    segments and Trace over library functions. When Trace over debugger segments is
    selected, instruction and function call tracing is temporarily disabled anytime
    execution proceeds to a program segment outside any of the file segments originally
    loaded into IDA. The most common example of this is a call to a shared library
    function. Selecting Trace over library functions temporarily disables function
    and instruction tracing anytime execution enters a function that IDA has identified
    as a library function (perhaps via FLIRT signature matching). Library functions
    linked into a binary should not be confused with library functions that a binary
    accesses via a shared library file such as a DLL. Both of these options are enabled
    by default, resulting in better performance while tracing (because the debugger
    does not need to step into library code) as well as a substantial reduction in
    the number of trace events generated, since instruction traces through library
    code can rapidly fill the trace buffer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要提到的关于跟踪的最后两个选项是“在调试器段上跟踪”和“在库函数上跟踪”。当选择“在调试器段上跟踪”时，只要执行流程转到IDA最初加载的任何文件段之外的程序段，指令和函数调用跟踪就会被临时禁用。最常见的例子是调用共享库函数。选择“在库函数上跟踪”会临时禁用在IDA被识别为库函数的函数（可能通过FLIRT签名匹配）中的函数和指令跟踪。链接到二进制文件中的库函数不应与通过共享库文件（如DLL）访问的库函数混淆。这两个选项默认都是启用的，这有助于在跟踪时提高性能（因为调试器不需要进入库代码），同时显著减少生成的跟踪事件数量，因为指令通过库代码的跟踪可以迅速填满跟踪缓冲区。
- en: Stack Traces
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: A *stack trace* is a display of the current call stack, or sequence of function
    calls that have been made in order for execution to reach a particular location
    within a binary. [Figure 24-11](ch24s03.html#a_sample_stack_trace "Figure 24-11. A
    sample stack trace") shows a sample stack trace generated using the Debugger ▸
    Stack Trace command.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈跟踪*是当前调用栈的显示，或者说是为了执行到达二进制文件中的特定位置而执行的函数调用序列。[图24-11](ch24s03.html#a_sample_stack_trace
    "图24-11. 一个示例堆栈跟踪")显示了使用“调试器”>“堆栈跟踪”命令生成的示例堆栈跟踪。'
- en: '![A sample stack trace](httpatomoreillycomsourcenostarchimages854386.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例堆栈跟踪](httpatomoreillycomsourcenostarchimages854386.png)'
- en: Figure 24-11. A sample stack trace
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-11. 一个示例堆栈跟踪
- en: The top line in a stack trace lists the name of the function currently executing.
    The second line indicates the function that called the current function and the
    address from which that call was made. Successive lines indicate the point from
    which each function was called. A debugger is able to create a stack trace display
    by walking the stack and parsing each stack frame that it encounters, and it typically
    relies on the contents of the frame pointer register (EBP for x86) to locate the
    base of each stack frame. When a stack frame is located, the debugger can extract
    a pointer to the next stack frame (the saved frame pointer) as well as the saved
    return address, which is used to locate the call instruction used to invoke the
    current function. IDA’s debugger cannot trace through stack frames that do not
    utilize EBP as a frame pointer. At the function (rather than individual instruction)
    level, stack traces are useful for answering the question, “How did I get here?”
    or, more correctly, “What sequence of function calls led to this particular location?”
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 栈跟踪的最上面一行列出了当前正在执行的函数的名称。第二行指示调用了当前函数的函数及其调用地址。后续的行指示每个函数被调用的点。调试器能够通过遍历栈并解析它遇到的每个栈帧来创建栈跟踪显示，它通常依赖于帧指针寄存器（x86中的EBP）的内容来定位每个栈帧的基址。当找到栈帧时，调试器可以提取指向下一个栈帧（保存的帧指针）以及保存的返回地址的指针，这些返回地址用于定位用于调用当前函数的调用指令。IDA的调试器不能跟踪不使用EBP作为帧指针的栈帧。在函数（而不是单个指令）级别上，栈跟踪对于回答“我是如何到达这里的？”或更准确地说，“什么函数调用序列导致了这个特定的位置？”这样的问题是有用的。
- en: Watches
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手表
- en: While debugging a process, you may wish to constantly monitor the value contained
    in one or more variables. Rather than requiring you to navigate to the desired
    memory locations each time the process is paused, many debuggers allow you to
    specify lists of memory locations whose values should be displayed each time the
    process is stopped in the debugger. Such lists are called *watch lists*, because
    they allow you to watch as the contents of designated memory locations change
    during program execution. Watch lists are simply a navigational convenience; they
    do not cause execution to pause like a breakpoint.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试一个进程时，你可能希望持续监控一个或多个变量中的值。而不是要求你在每次进程暂停时都导航到所需的内存位置，许多调试器允许你指定应显示其值的内存位置列表。这样的列表被称为*监视列表*，因为它们允许你在程序执行期间监视指定内存位置的内容变化。监视列表仅仅是一种导航便利；它们不会像断点一样导致执行暂停。
- en: Because they are focused on data, watch points (addresses designated to be watched)
    are most commonly set in the stack, heap, or data sections of a binary. Watches
    are set in the IDA debugger by right-clicking a memory item of interest and selecting
    Add Watch. Determining exactly which address to set a watch on may require some
    thought. Determining the address of a global variable is somewhat less challenging
    than determining the address of a local variable because global variables are
    allocated and assigned fixed addresses at compile time. Local variables, on the
    other hand, don’t exist until runtime, and even then they exist only once the
    function in which they are declared has been called. With the debugger active,
    once you have stepped into a function, IDA is capable of reporting the addresses
    of local variables within that function. [Figure 24-12](ch24s03.html#debugger_resolution_of_a_local_variable
    "Figure 24-12. Debugger resolution of a local variable address") shows the result
    of mousing over a local variable named `arg_0` (actually a parameter passed into
    the function).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们关注数据，监视点（被指定为要监视的地址）通常设置在二进制的栈、堆或数据部分。在IDA调试器中设置监视点是通过右键单击感兴趣的内存项并选择添加监视来完成的。确定确切要设置监视的地址可能需要一些思考。确定全局变量的地址比确定局部变量的地址要容易一些，因为全局变量在编译时被分配并分配了固定的地址。另一方面，局部变量在运行时才存在，即使如此，它们也只有在它们声明的函数被调用之后才存在。当调试器处于活动状态时，一旦你进入了一个函数，IDA就能够报告该函数内局部变量的地址。[图24-12](ch24s03.html#debugger_resolution_of_a_local_variable
    "图24-12. 调试器解析局部变量地址")显示了将鼠标悬停在名为`arg_0`的局部变量（实际上是一个传递给函数的参数）上的结果。
- en: '![Debugger resolution of a local variable address](httpatomoreillycomsourcenostarchimages854389.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![调试器解析局部变量地址](httpatomoreillycomsourcenostarchimages854389.png)'
- en: Figure 24-12. Debugger resolution of a local variable address
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图24-12. 调试器解析局部变量地址
- en: Double-clicking a local variable within an active function causes IDA to jump
    the main IDA View window to the address of that local variable. Having arrived
    at the variable’s address, you may then add a watch on that address using the
    Add Watch context-sensitive menu option, though you will need to manually enter
    the address into the Watch Address dialog. If, instead, you take the time to name
    the memory location, IDA will automatically add a watch if you apply the same
    menu option to the name rather than the address.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 双击活动函数内的局部变量会导致IDA将主IDA视图窗口跳转到该局部变量的地址。到达变量的地址后，您可以使用“添加监视”的上下文菜单选项在该地址上添加监视，尽管您需要手动将该地址输入到监视地址对话框中。如果您花时间命名内存位置，当您将相同的菜单选项应用于名称而不是地址时，IDA将自动添加监视。
- en: You can access a list of all watches currently in effect via Debugger ▸ Watches
    ▸ Watch List. You can delete individual watches by highlighting the desired watch
    in the watch list and pressing DELETE.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过“调试器” ▸ “监视” ▸ “监视列表”访问当前所有有效的监视列表。您可以通过在监视列表中突出显示所需的监视并按DELETE键来删除单个监视。
- en: '* * *'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[222](#CHP-24-FN-7)]) See [http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[222](#CHP-24-FN-7)]) 请参阅 [http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/)。
- en: ^([[223](#CHP-24-FN-8)]) See [http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html](http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html)
    and [http://www.hexblog.com/2005/11/stealth_plugin_1.html](http://www.hexblog.com/2005/11/stealth_plugin_1.html).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[223](#CHP-24-FN-8)]) 请参阅 [http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html](http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html)
    和 [http://www.hexblog.com/2005/11/stealth_plugin_1.html](http://www.hexblog.com/2005/11/stealth_plugin_1.html).
- en: ^([[224](#CHP-24-FN-9)]) The `REP` prefix is an instruction modifier that causes
    certain x86 string instructions such as `movs` and `scas` to be repeated based
    on a count contained in the ECX register.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[224](#CHP-24-FN-9)]) `REP` 前缀是一个指令修饰符，它会导致某些x86字符串指令（如 `movs` 和 `scas`）根据ECX寄存器中的计数重复执行。
- en: Automating Debugger Tasks
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化调试任务
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") through [Chapter 19](ch19.html
    "Chapter 19. IDA Processor Modules"), we covered the basics of IDA scripting and
    the IDA SDK and demonstrated the usefulness of these capabilities during static
    analysis of binaries. Launching a process and working in the more dynamic environment
    of a debugger doesn’t make scripting and plug-ins any less useful. Interesting
    uses for the automation provided by scripts and plug-ins include analyzing runtime
    data available while a process is being debugged, implementing complex breakpoint
    conditions, and implementing measures to subvert anti-debugging techniques.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第15章](ch15.html "第15章。IDA脚本") 到 [第19章](ch19.html "第19章。IDA处理器模块") 中，我们介绍了IDA脚本和IDA
    SDK的基础知识，并在二进制文件的静态分析中展示了这些功能的有用性。在调试器中启动进程并在更动态的调试环境中工作并不会使脚本和插件变得不那么有用。脚本和插件提供的自动化功能的一些有趣用途包括分析调试过程中可用的运行时数据、实现复杂的断点条件以及实施绕过反调试技术的措施。
- en: Scripting Debugger Actions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本化调试操作
- en: All of the IDA scripting capabilities discussed in [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting") continue to be accessible when you are using the IDA debugger. Scripts
    may be launched from the File menu, associated with hotkeys, and invoked from
    the IDA scripting command line. In addition, user-created IDC functions may be
    referenced from breakpoint conditions and tracing termination expressions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用IDA调试器时，[第15章](ch15.html "第15章。IDA脚本") 中讨论的所有IDA脚本功能仍然可以访问。可以从文件菜单启动脚本，将其与热键关联，并从IDA脚本命令行调用。此外，用户创建的IDC函数可以从断点条件和跟踪终止表达式中引用。
- en: Basic scripting functions offer the capability to set, modify, and enumerate
    breakpoints and the ability to read and write register and memory values. Memory
    access is provided by the `DbgByte`, `PatchDbgByte`, `DbgWord`, `PatchDbgWord`,
    `DbgDword`, and `PatchDbgDword` functions (analogous to the `Byte`, `Word`, `Dword`,
    and `Patch`*`XXX`* functions described in [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting")). Register and breakpoint manipulation is made possible by the following
    functions (please see the IDA help file for a complete list).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基本脚本函数提供了设置、修改和枚举断点的功能，以及读取和写入寄存器和内存值的能力。内存访问由 `DbgByte`、`PatchDbgByte`、`DbgWord`、`PatchDbgWord`、`DbgDword`
    和 `PatchDbgDword` 函数提供（类似于第 15 章中描述的 `Byte`、`Word`、`Dword` 和 `Patch`*`XXX`* 函数）。通过以下函数可以实现寄存器和断点的操作（请参阅
    IDA 帮助文件以获取完整列表）。
- en: '**`long GetRegValue(string reg)`**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetRegValue(string reg)`**'
- en: Returns the value of the named register, such as EAX, as discussed previously.
    In IDC only, register values may also be easily accessed by using the desired
    register’s name as a variable within an IDC expression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 返回之前讨论过的指定寄存器（如 EAX）的值。在 IDC 中，也可以通过在 IDC 表达式中使用所需的寄存器名称作为变量来轻松访问寄存器值。
- en: '**`bool SetRegValue(number val, string name)`**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool SetRegValue(number val, string name)`**'
- en: Sets the value of the named register, such as EAX. If you are using IDC, register
    values may also be modified directly by using the desired register name on the
    left side of an assignment statement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 设置指定名称的寄存器值，例如 EAX。如果你使用 IDC，也可以通过在赋值语句的左侧使用所需的寄存器名称直接修改寄存器值。
- en: '**`bool AddBpt(long addr)`**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool AddBpt(long addr)`**'
- en: Adds a software breakpoint at the indicated address.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定的地址添加软件断点。
- en: '**`bool AddBptEx(long addr, long size, long type)`**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool AddBptEx(long addr, long size, long type)`**'
- en: Adds a breakpoint of the specified size and type at the indicated address. Type
    should be one of the `BPT_`*`xxx`* constants described in *idc.idc* or the IDA
    help file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定的地址添加指定大小和类型的断点。类型应该是 *idc.idc* 或 IDA 帮助文件中描述的 `BPT_`*`xxx`* 常量之一。
- en: '**`bool DelBpt(long addr)`**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool DelBpt(long addr)`**'
- en: Deletes a breakpoint at the specified address.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 删除指定地址处的断点。
- en: '**`long GetBptQty()`**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetBptQty()`**'
- en: Returns the number of breakpoints set within a program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中设置的断点数量。
- en: '**`long GetBptEA(long bpt_num)`**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetBptEA(long bpt_num)`**'
- en: Returns the address at which the indicated breakpoint is set.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指示断点设置的地址。
- en: '**`long/string GetBptAttr(long addr, number attr)`**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long/string GetBptAttr(long addr, number attr)`**'
- en: Returns an attribute associated with the breakpoint at the indicated address.
    The return value may be a number or a string depending on which attribute value
    has been requested. Attributes are specified using one of the `BPTATTR_`*`xxx`*
    values described in *idc.idc* or the IDA help file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与指定地址处的断点相关联的属性。返回值可能是一个数字或一个字符串，具体取决于请求的属性值。属性使用 *idc.idc* 或 IDA 帮助文件中描述的
    `BPTATTR_`*`xxx`* 值之一指定。
- en: '**`bool SetBptAttr(long addr, number attr, long value)`**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool SetBptAttr(long addr, number attr, long value)`**'
- en: Sets the specified attribute of the specified breakpoint to the specified value.
    Do not use this function to set breakpoint condition expressions (use `SetBptCnd`
    instead).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定断点的指定属性设置为指定的值。不要使用此函数设置断点条件表达式（请使用 `SetBptCnd`）。
- en: '**`bool SetBptCnd(long addr, string cond)`**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool SetBptCnd(long addr, string cond)`**'
- en: Sets the breakpoint condition to the provided conditional expression, which
    must be a valid IDC expression.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将断点条件设置为提供的条件表达式，该表达式必须是一个有效的 IDC 表达式。
- en: '**`long CheckBpt(long addr)`**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long CheckBpt(long addr)`**'
- en: Gets the breakpoint status at the specified address. Return values indicate
    whether there is no breakpoint, the breakpoint is disabled, the breakpoint is
    enabled, or the breakpoint is active. An active breakpoint is a breakpoint that
    is enabled while the debugger is also active.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 获取指定地址的断点状态。返回值表示是否存在断点、断点是否禁用、断点是否启用或断点是否激活。一个激活的断点是在调试器也激活时启用的断点。
- en: 'The following script demonstrates how to install a custom IDC breakpoint-handling
    function at the current cursor location:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本演示了如何在当前光标位置安装自定义的 IDC 断点处理函数：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The complexity of `my_breakpoint_condition` is entirely up to you. In this example,
    each time the breakpoint is hit, a dialog will be displayed asking the user if
    she would like to continue execution of the process or pause at the current location.
    The value returned by `my_breakpoint_condition` is used by the debugger to determine
    whether the breakpoint should be honored or ignored.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_breakpoint_condition` 的复杂度完全由您决定。在这个例子中，每次遇到断点时，都会弹出一个对话框询问用户是否希望继续执行过程或暂停在当前位置。`my_breakpoint_condition`
    返回的值被调试器用来确定是否应该尊重或忽略断点。'
- en: 'Programmatic control of the debugger is possible from both the SDK and through
    the use of scripts. Within the SDK, IDA utilizes an event-driven model and provides
    callback notifications to plug-ins when specific debugger events occur. Unfortunately,
    IDA’s scripting capabilities don’t facilitate the use of an event-driven paradigm
    within scripts. As a result, Hex-Rays introduced a number of scripting functions
    that allow for synchronous control of the debugger from within scripts. The basic
    approach required to drive the debugger using a script is to initiate a debugger
    action and then wait for the corresponding debugger event code. Keep in mind that
    a call to a synchronous debugger function (which is all you can do in a script)
    blocks all other IDA operations until the call completes. The following list details
    several of the debugging extensions available for scripts:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SDK 和通过使用脚本都可以对调试器进行程序控制。在 SDK 中，IDA 使用事件驱动模型，并在特定调试事件发生时向插件提供回调通知。不幸的是，IDA
    的脚本功能并不便于在脚本中使用事件驱动范式。因此，Hex-Rays 引入了一系列脚本函数，允许在脚本中对调试器进行同步控制。使用脚本驱动调试器的基本方法是在脚本中启动调试器操作，然后等待相应的调试器事件代码。请注意，对同步调试器函数的调用（在脚本中您能做的所有事情）会阻塞所有其他
    IDA 操作，直到调用完成。以下列表详细说明了可用于脚本的几个调试扩展：
- en: '**`long GetDebuggerEvent(long wait_evt, long timeout)`**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetDebuggerEvent(long wait_evt, long timeout)`**'
- en: Waits for a debugger event (as specified by `wait_evt`) to take place within
    the specified number of seconds (−1 waits forever). Returns an event type code
    that indicates the type of event that was received. Specify `wait_evt` using a
    combination of one or more `WFNE_`*`xxx`* (WFNE stands for Wait For Next Event)
    flags. Possible return values are documented in the IDA help file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 等待在指定秒数内（-1 表示无限期等待）发生调试器事件（由 `wait_evt` 指定）。返回一个事件类型代码，指示接收到的事件类型。使用 `WFNE_`*`xxx`*（WFNE
    表示等待下一个事件）标志的组合来指定 `wait_evt`。可能的返回值在 IDA 帮助文件中有文档说明。
- en: '**b****`ool RunTo(long addr)`**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**b****`ool RunTo(long addr)`**'
- en: Runs the process until the specified location is reached or until a breakpoint
    is hit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行过程直到达到指定的位置或遇到断点。
- en: '**`bool StepInto()`**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool StepInto()`**'
- en: Steps the process one instruction, stepping into any function calls.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 单步执行过程，进入任何函数调用。
- en: '**`bool StepOver()`**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool StepOver()`**'
- en: Steps the process one instruction, stepping over any function calls. This call
    may terminate early if a breakpoint is hit.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单步执行过程，跳过任何函数调用。如果遇到断点，此调用可能提前终止。
- en: '**`bool StepUntilRet()`**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool StepUntilRet()`**'
- en: Runs until the current function call returns or until a breakpoint is hit.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行直到当前函数调用返回或遇到断点。
- en: '**`bool EnableTracing(long trace_level, long enable)`**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool EnableTracing(long trace_level, long enable)`**'
- en: Enables (or disables) the generation of trace events. The `trace_level` parameter
    should be set to one of the `TRACE_`*`xxx`* constants defined in *idc.idc*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 启用（或禁用）生成跟踪事件。`trace_level` 参数应设置为在 *idc.idc* 中定义的 `TRACE_`*`xxx`* 常量之一。
- en: '**`long GetEvent`***`XXX`***`()`**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetEvent`***`XXX`***`()`**'
- en: A number of functions are available for retrieving information related to the
    current debug event. Some of these functions are valid only for specific event
    types. You should test the return value of `GetDebuggerEvent` in order to make
    sure that a particular `GetEvent`*`XXX`* function is valid.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多函数可用于检索与当前调试事件相关的信息。其中一些函数仅适用于特定的事件类型。您应该测试 `GetDebuggerEvent` 的返回值，以确保特定的
    `GetEvent`*`XXX`* 函数是有效的。
- en: '`GetDebuggerEvent` must be called after each function that causes the process
    to execute in order to retrieve the debugger’s event code. Failure to do so may
    prevent follow-up attempts to step or run the process. For example, the following
    code fragment will step the debugger only one time because `GetDebuggerEvent`
    does not get called to clear the last event type in between invocations of `StepOver`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在导致进程执行的每个函数之后必须调用 `GetDebuggerEvent`，以便检索调试器的事件代码。如果不这样做，可能会阻止后续尝试单步执行或运行进程。例如，以下代码片段将只单步执行调试器一次，因为
    `GetDebuggerEvent` 没有在 `StepOver` 调用之间被调用以清除最后的事件类型。
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The proper way to perform an execution action is to follow up each call with
    a call to `GetDebuggerEvent`, as shown in the following example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 执行操作的正确方式是在每个调用之后跟随一个对 `GetDebuggerEvent` 的调用，如下例所示：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The calls to `GetDebuggerEvent` allow execution to continue even if you choose
    to ignore the return value from `GetDebuggerEvent`. The event type `WFNE_SUSP`
    indicates that we wish to wait for an event that results in suspension of the
    debugged process, such as an exception or a breakpoint. You may have noticed that
    there is no function that simply resumes execution of a suspended process.^([[225](#ftn.CHP-24-FN-10)])
    However, it is possible to achieve the same effect by using the `WFNE_CONT` flag
    in a call to `GetDebuggerEvent`, as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `GetDebuggerEvent` 的调用允许即使在选择忽略 `GetDebuggerEvent` 的返回值的情况下，执行也能继续。事件类型 `WFNE_SUSP`
    表示我们希望等待导致被调试进程挂起的事件，例如异常或断点。你可能已经注意到没有函数可以简单地恢复挂起进程的执行。^([[225](#ftn.CHP-24-FN-10)])
    然而，通过在 `GetDebuggerEvent` 的调用中使用 `WFNE_CONT` 标志，可以实现相同的效果，如下所示：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This particular call waits for the next available suspend event after first
    resuming execution by continuing the process from the current instruction.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的调用在首先通过从当前指令继续执行来恢复执行后，等待下一个可用的挂起事件。
- en: Additional functions are provided for automatically launching the debugger and
    attaching to running processes. See IDA’s help file for more information on these
    functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了额外的函数来自动启动调试器和附加到正在运行的进程。有关这些函数的更多信息，请参阅 IDA 的帮助文件。
- en: 'An example of a simple debugger script for collecting statistics on the addresses
    of each executed instruction (provided the debugger is enabled) is shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了用于收集每个执行指令地址的统计信息的简单调试器脚本的示例（假设调试器已启用）：
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The script begins ![](httpatomoreillycomsourcenostarchimages854061.png) by
    testing for the presence of a global array named `stats`. If one is found, the
    array is removed and re-created so that we can start with an empty array. Next
    ![](httpatomoreillycomsourcenostarchimages854063.png), single-step tracing is
    enabled before entering a loop ![](httpatomoreillycomsourcenostarchimages854093.png)
    to drive the single-stepping process. Each time a debug event is generated, the
    address of the associated event is retrieved ![](httpatomoreillycomsourcenostarchimages854095.png),
    the current count for the associated address is retrieved from the global array
    and incremented ![](httpatomoreillycomsourcenostarchimages854099.png), and the
    array is updated with the new count ![](httpatomoreillycomsourcenostarchimages854101.png).
    Note that the instruction pointer is used as the index into the sparse global
    array, which saves time looking up the address in some other form of data structure.
    Once the process completes, a second loop ![](httpatomoreillycomsourcenostarchimages854103.png)
    is used to retrieve and print all values from array locations that have valid
    values. In this case, the only array indexes that will have valid values represent
    addresses from which instructions were fetched. The script finishes off ![](httpatomoreillycomsourcenostarchimages854133.png)
    by deleting the global array that was used to gather the statistics. Example output
    from this script is shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本开始时！[](httpatomoreillycomsourcenostarchimages854061.png)会检查是否存在名为`stats`的全局数组。如果找到，则删除该数组并重新创建，以便我们可以从一个空数组开始。接下来！[](httpatomoreillycomsourcenostarchimages854063.png)，在进入循环！[](httpatomoreillycomsourcenostarchimages854093.png)以驱动单步执行过程之前，启用单步跟踪。每次生成调试事件时，都会检索相关事件的地址！[](httpatomoreillycomsourcenostarchimages854095.png)，从全局数组中检索与该地址关联的当前计数并增加！[](httpatomoreillycomsourcenostarchimages854099.png)，并用新的计数更新数组！[](httpatomoreillycomsourcenostarchimages854101.png)。请注意，指令指针用作稀疏全局数组的索引，这可以节省在某种其他数据结构中查找地址的时间。一旦过程完成，就会使用第二个循环！[](httpatomoreillycomsourcenostarchimages854103.png)来检索并打印所有具有有效值的数组位置的值。在这种情况下，只有那些从其中检索指令的地址的数组索引才会具有有效值。脚本通过删除用于收集统计信息的全局数组来完成！[](httpatomoreillycomsourcenostarchimages854133.png)。
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A slight alteration of the preceding example can be used to gather statistics
    on what types of instructions are executed during the lifetime of a process. The
    following example shows the modifications required in the first loop to gather
    instruction-type data rather than address data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对前面的示例进行轻微修改，可以收集有关在进程生命周期内执行了哪些类型指令的统计信息。以下示例显示了在第一个循环中所需的修改，以收集指令类型数据而不是地址数据：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rather than attempting to classify individual opcodes, we choose to group instructions
    by mnemonics ![](httpatomoreillycomsourcenostarchimages854061.png). Because mnemonics
    are strings, we make use of the hash-table feature of global arrays to retrieve
    the current count associated with a given mnemonic ![](httpatomoreillycomsourcenostarchimages854063.png)
    and save the updated count ![](httpatomoreillycomsourcenostarchimages854093.png)
    back into the correct hash table entry. Sample output from this modified script
    is shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是尝试对单个操作码进行分类，我们选择按助记符！[](httpatomoreillycomsourcenostarchimages854061.png)分组指令。因为助记符是字符串，我们利用全局数组的哈希表功能来检索与给定助记符关联的当前计数！[](httpatomoreillycomsourcenostarchimages854063.png)，并将更新的计数！[](httpatomoreillycomsourcenostarchimages854093.png)保存回正确的哈希表条目。此修改后的脚本的示例输出如下：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger Integration") we
    will revisit the use of debugger-interaction capabilities as a means to assist
    in de-obfuscating binaries.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第25章](ch25.html "第25章。反汇编器/调试器集成")中，我们将重新探讨使用调试器交互功能作为辅助去混淆二进制文件的手段。
- en: Automating Debugger Actions with IDA Plug-ins
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IDA 插件自动化调试器操作
- en: In [Chapter 16](ch16.html "Chapter 16. The IDA Software Development Kit") you
    learned that IDA’s SDK offers significant power for developing a variety of compiled
    extensions that can be integrated into IDA and that have complete access to the
    IDA API. The IDA API offers a superset of all the capabilities available in IDC,
    and the debugging extensions are no exception. Debugger extensions to the API
    are declared in *<SDKDIR>/dbg.hpp* and include C++ counterparts to all of the
    IDC functions discussed thus far, along with a complete asynchronous debugger
    interface capability.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](ch16.html "第16章。IDA软件开发工具包")中，你了解到IDA的SDK为开发各种可集成到IDA并完全访问IDA API的编译扩展提供了强大的功能。IDA
    API提供了IDC中所有可用功能的超集，调试扩展也不例外。API的调试扩展在`<SDKDIR>/dbg.hpp`中声明，包括迄今为止讨论的所有IDC函数的C++对应版本，以及完整的异步调试器接口功能。
- en: For asynchronous interaction, plug-ins gain access to debugger notifications
    by hooking the `HT_DBG` notification type (see *loader.hpp*). Debugger notifications
    are declared in the `dbg_notification_t` enum found in *dbg.hpp*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步交互，插件通过挂钩`HT_DBG`通知类型（见*loader.hpp*）来获取调试器通知。调试器通知在`dbg.hpp`中找到的`dbg_notification_t`枚举中声明。
- en: Within the debugger API, commands for interacting with the debugger are typically
    defined in pairs, with one function used for synchronous interaction (as with
    scripts) and the second function used for asynchronous interaction. Generically,
    the synchronous form of a function is named `COMMAND()`, and its asynchronous
    counterpart is named `request_COMMAND()`. The `request_`*`XXX`* versions are used
    to queue debugger actions for later processing. Once you finish queuing asynchronous
    requests, you must invoke the `run_requests` function to initiate processing of
    your request queue. As your requests are processed, debugger notifications will
    be delivered to any callback functions that you may have registered via `hook_to_notification_point`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器API中，与调试器交互的命令通常以成对定义，一个函数用于同步交互（如脚本），另一个函数用于异步交互。一般而言，函数的同步形式命名为`COMMAND()`，其异步对应版本命名为`request_COMMAND()`。`request_`*`XXX`*版本用于将调试器操作排队以供后续处理。一旦你完成异步请求的排队，你必须调用`run_requests`函数来启动请求队列的处理。随着你的请求被处理，调试器通知将被发送到任何通过`hook_to_notification_point`注册的回调函数。
- en: 'Using asynchronous notifications, we can develop an asynchronous version of
    the address-counting script from the previous section. The first task is to make
    sure that we hook and unhook debugger notifications. We will do this in the plug-in’s
    `init` and `term` methods, as shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步通知，我们可以开发一个来自上一节的地址计数脚本的异步版本。第一个任务是确保我们挂钩和取消挂钩调试器通知。我们将在插件的`init`和`term`方法中这样做，如下所示：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that we have also elected to declare a global netnode ![](httpatomoreillycomsourcenostarchimages854061.png),
    which we will use to collect statistics. Next we consider what we want the plug-in
    to do when it is activated via its assigned hotkey. Our example plug-in `run`
    function is shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还选择声明了一个全局netnode ![链接](httpatomoreillycomsourcenostarchimages854061.png)，我们将用它来收集统计数据。接下来，我们考虑当插件通过其分配的热键激活时，我们希望插件执行什么操作。我们的示例插件`run`函数如下所示：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since we are using asynchronous techniques in this example, we must first submit
    a request to enable step tracing ![](httpatomoreillycomsourcenostarchimages854061.png)
    and then submit a request to resume execution of the process being debugged. For
    the sake of simplicity, we will gather statistics on the current function only,
    so we will issue a request to run until the current function returns ![](httpatomoreillycomsourcenostarchimages854063.png).
    With our requests properly queued, we kick things off by invoking `run_requests`
    to process the current request queue ![](httpatomoreillycomsourcenostarchimages854093.png).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本例中使用异步技术，我们必须首先提交一个请求来启用步骤跟踪 ![链接](httpatomoreillycomsourcenostarchimages854061.png)，然后提交一个请求来恢复调试的进程的执行。为了简化，我们将只对当前函数收集统计数据，因此我们将发出一个请求，直到当前函数返回
    ![链接](httpatomoreillycomsourcenostarchimages854063.png)。在我们的请求正确排队后，我们将通过调用`run_requests`来启动当前请求队列的处理
    ![链接](httpatomoreillycomsourcenostarchimages854093.png)。
- en: 'All that remains is to process the notifications that we expect to receive
    by creating our `HT_DBG` callback function. A simple callback that processes only
    two messages is shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是通过创建我们的`HT_DBG`回调函数来处理我们期望接收的通知。这里展示了一个只处理两个消息的简单回调：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `dbg_trace` notification ![](httpatomoreillycomsourcenostarchimages854061.png)
    will be received for each instruction that executes until we turn tracing off.
    When a trace notification is received, the address of the trace point is retrieved
    from the args list ![](httpatomoreillycomsourcenostarchimages854063.png) and then
    used to update the appropriate netnode array index ![](httpatomoreillycomsourcenostarchimages854093.png).
    The `dbg_step_until_ret` notification ![](httpatomoreillycomsourcenostarchimages854095.png)
    is sent once the process hits the `return` statement to leave the function in
    which we started. This notification is our signal that we should stop tracing
    and print any statistics we have gathered. A loop is used ![](httpatomoreillycomsourcenostarchimages854099.png)
    to iterate through all valid index values of the `stats` netnode before destroying
    the netnode ![](httpatomoreillycomsourcenostarchimages854101.png) and requesting
    that step tracing be disabled ![](httpatomoreillycomsourcenostarchimages854103.png).
    Since this example uses asynchronous commands, the request to disable tracing
    is added to the queue, which means we have to issue `run_requests` ![](httpatomoreillycomsourcenostarchimages854133.png)
    in order for the queue to be processed. An important warning about synchronous
    versus asynchronous interaction with the debugger is that you should never call
    the synchronous version of a function while actively processing an asynchronous
    notification message.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条执行的指令，我们直到关闭跟踪之前都会接收到 `dbg_trace` 通知 ![图片](httpatomoreillycomsourcenostarchimages854061.png)。当接收到跟踪通知时，从
    args 列表 ![图片](httpatomoreillycomsourcenostarchimages854063.png) 中检索跟踪点的地址，然后用于更新适当的
    netnode 数组索引 ![图片](httpatomoreillycomsourcenostarchimages854093.png)。当进程遇到 `return`
    语句并离开我们开始的函数时，会发送 `dbg_step_until_ret` 通知 ![图片](httpatomoreillycomsourcenostarchimages854095.png)。这个通知是我们的信号，表明我们应该停止跟踪并打印我们收集到的任何统计信息。在销毁
    netnode ![图片](httpatomoreillycomsourcenostarchimages854101.png) 并请求禁用跟踪 ![图片](httpatomoreillycomsourcenostarchimages854103.png)
    之前，使用循环 ![图片](httpatomoreillycomsourcenostarchimages854099.png) 遍历 `stats` netnode
    的所有有效索引值。由于此示例使用异步命令，禁用跟踪的请求被添加到队列中，这意味着我们必须发出 `run_requests` ![图片](httpatomoreillycomsourcenostarchimages854133.png)
    以处理队列。关于与调试器同步交互与异步交互的重要警告是，在处理异步通知消息时，您绝对不应该调用函数的同步版本。
- en: Synchronous interaction with the debugger using the SDK is done in a manner
    very similar to scripting the debugger. As with many of the SDK functions we have
    seen in previous chapters, the names of debugger-related functions typically do
    not match the names of related scripting functions, so you may need to spend some
    time combing through *dbg.hpp* in order to find the functions you are looking
    for. The biggest disparity in names between scripting and the SDK is the SDK’s
    version of `GetDebuggerEvent`, which is called `wait_for_next_event` in the SDK.
    The other major difference between script functions and the SDK is that variables
    corresponding to the CPU registers are not automatically declared for you within
    the SDK. In order to access the values of CPU registers from the SDK, you must
    use the `get_reg_val` and `set_reg_val` functions to read and write registers,
    respectively.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SDK 与调试器的同步交互方式与脚本调试器非常相似。与我们在前几章中看到的许多 SDK 函数一样，调试器相关函数的名称通常与相关脚本函数的名称不匹配，因此您可能需要花费一些时间在
    *dbg.hpp* 中查找所需的函数。脚本和 SDK 之间名称差异最大的是 SDK 的 `GetDebuggerEvent` 版本，在 SDK 中称为 `wait_for_next_event`。脚本函数和
    SDK 之间的另一个主要区别是，SDK 中不会自动为您声明对应于 CPU 寄存器的变量。要从 SDK 访问 CPU 寄存器的值，您必须使用 `get_reg_val`
    和 `set_reg_val` 函数分别读取和写入寄存器。
- en: '* * *'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[225](#CHP-24-FN-10)]) In reality, there is a macro named `ResumeProcess`
    that is defined as `GetDebuggerEvent(WFNE_CONT|WFNE_NOWAIT, 0)`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[225](#CHP-24-FN-10)]) 实际上，有一个名为 `ResumeProcess` 的宏，定义为 `GetDebuggerEvent(WFNE_CONT|WFNE_NOWAIT,
    0)`。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: IDA may not have the largest share of the debugger market, but its debugger
    is powerful and integrates seamlessly with the disassembly side of IDA. While
    the debugger’s user interface, like that of any debugger, requires some initial
    getting used to, it offers all of the fundamental features that users require
    in a basic debugger. Strong points include scripting and plug-in capabilities
    along with the familiar user interface of IDA’s disassembly displays and the power
    of its analysis capabilities. Together the unified disassembler/debugger combination
    provides a solid tool for performing static analysis, dynamic analysis, or a combination
    of both.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: IDA可能不是调试器市场的最大份额，但它的调试器功能强大，并且与IDA的反汇编功能无缝集成。尽管调试器的用户界面，就像任何调试器一样，需要一些初始的适应，但它提供了用户在基本调试器中所需的所有基本功能。其优点包括脚本和插件功能，以及IDA反汇编显示的熟悉用户界面和其分析能力的强大。统一的反汇编器/调试器组合为执行静态分析、动态分析或两者的组合提供了一个坚实的工具。
- en: Chapter 25. Disassembler/Debugger Integration
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第25章。反汇编器/调试器集成
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: An integrated disassembler/debugger combination such as IDA should be a pretty
    powerful tool for manipulating binaries and seamlessly applying static and dynamic
    techniques as part of the reverse engineering process. This turns out to be true
    if you understand the capabilities and limitations of each tool individually and
    in combination.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 像IDA这样的集成反汇编器/调试器组合应该是一个强大的工具，用于操作二进制文件，并在逆向工程过程中无缝地应用静态和动态技术。如果你理解每个工具的特性和局限性，以及它们组合时的表现，这一点是成立的。
- en: In this chapter we will discuss some important points concerning the manner
    in which the static side of IDA interacts with its dynamic side, and we will take
    a look at techniques that can be employed with IDA’s debugger in order to defeat
    certain anti-debugging (and anti-disassembly) techniques in the context of malware
    analysis. In that regard, it is important to remember that the goal in malware
    analysis is usually not to run the malware but to obtain a disassembly of sufficient
    quality to allow static analysis tools to take over. Recall from [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis") that there are many techniques designed
    specifically to prevent disassemblers from performing properly. In the face of
    such anti-disassembly techniques, the debugger is simply one means to an end.
    By running an obfuscated program under debugger control, we will attempt to obtain
    a de-obfuscated version of the program, which we then prefer to analyze using
    the disassembler.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些关于IDA静态方面与其动态方面交互的重要观点，并探讨可以使用IDA调试器来克服恶意分析中某些反调试（和反反汇编）技术的技术。在这方面，重要的是要记住，在恶意分析中，通常的目标不是运行恶意软件，而是获得足够质量的反汇编，以便静态分析工具可以接管。回想一下[第21章](ch21.html
    "第21章。混淆代码分析")中提到的，有许多专门设计来防止反汇编器正确执行的技术。面对这些反反汇编技术，调试器只是达到目的的一种手段。通过在调试器控制下运行混淆程序，我们将尝试获得一个去混淆的程序版本，然后我们更喜欢使用反汇编器来分析它。
- en: Background
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: Some background on debugger-assisted de-obfuscation may be useful before proceeding.
    It is well known that an obfuscated program must de-obfuscate itself before it
    can get down to its intended business. The following steps provide a basic and
    somewhat simplistic guide for dynamic de-obfuscation of binaries.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，了解一些关于调试器辅助去混淆的背景信息可能是有用的。众所周知，一个混淆程序必须在开始其预期业务之前先去混淆自己。以下步骤提供了一个基本且有些简化的指南，用于二进制文件的动态去混淆。
- en: Open an obfuscated program with a debugger.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试器打开一个混淆程序。
- en: Search for and set a breakpoint on the end of the de-obfuscation routine.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在去混淆例程的末尾搜索并设置一个断点。
- en: Launch the program from the debugger and wait for your breakpoint to trigger.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调试器启动程序，等待断点触发。
- en: Utilize the debugger’s memory-dumping features to capture the current state
    of the process to a file.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用调试器的内存转储功能将进程的当前状态捕获到文件中。
- en: Terminate the process before it can do anything malicious.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进程执行任何恶意操作之前终止它。
- en: Perform static analysis on the captured process image.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对捕获到的进程图像进行静态分析。
- en: Most modern debuggers contain enough features to perform the tasks just mentioned.
    OllyDbg^([[226](#ftn.CHP-25-FN-1)]) is a very popular Windows-only debugger often
    used for such work. Step 2 is not always as straightforward as it may sound. It
    may take a combination of tools, including spending some amount of time in a disassembler
    such as IDA, or a lot of single stepping before the end of the de-obfuscation
    algorithm can be properly identified. In many cases, the end of de-obfuscation
    is marked by a behavior rather than a specific instruction. One such behavior
    might be a large change in the instruction pointer value, indicating a jump to
    a location far from the de-obfuscation code. In the case of `UPX`-packed binaries,
    for example, all you need to do is observe that the instruction pointer holds
    a value that is less than the program’s entry point address to know that de-obfuscation
    is complete and the program has jumped to the newly de-obfuscated code. In generic
    terms, this process is called *original entry point (OEP) recognition*, the OEP
    being the address at which the program would have begun execution had it not been
    obfuscated.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代调试器都包含足够的功能来执行上述任务。OllyDbg^([[226](#ftn.CHP-25-FN-1)]) 是一个非常流行的仅适用于 Windows
    的调试器，常用于此类工作。步骤 2 并不一定像听起来那么简单。可能需要结合多种工具，包括在反汇编器（如 IDA）中花费一些时间，或者在去混淆算法结束前进行大量的单步执行，才能正确地识别去混淆算法的结束。在许多情况下，去混淆的结束是由一种行为而不是特定的指令标记的。这种行为可能是一个指令指针值的巨大变化，表明跳转到了去混淆代码之外的某个位置。例如，在
    `UPX` 打包的二进制文件的情况下，你只需要观察指令指针的值小于程序入口点地址，就可以知道去混淆已经完成，程序已经跳转到了新去混淆的代码。用通用术语来说，这个过程被称为
    *原始入口点（OEP）识别*，OEP 是程序在没有被混淆的情况下开始执行时的地址。
- en: Complicating matters, some modern obfuscators are capable of transforming an
    input executable into an equivalent byte code program, which is then executed
    on a custom virtual machine generated by the obfuscator.^([[227](#ftn.CHP-25-FN-2)])
    Executables protected with such virtualizing obfuscators cannot be analyzed with
    the traditional expectation of recovering the original binary or locating the
    original entry point. This is a result of the fact that the original x86 (or other
    processor) instructions are not embedded in the obfuscated binary and are therefore
    unavailable for recovery.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更为复杂的是，一些现代混淆器能够将输入的可执行文件转换成等效的字节码程序，然后由混淆器生成的自定义虚拟机执行.^([[227](#ftn.CHP-25-FN-2)])
    使用此类虚拟化混淆器保护的可执行文件不能按照传统的期望来分析，即恢复原始二进制文件或定位原始入口点。这是由于原始的 x86（或其他处理器）指令没有嵌入到混淆的二进制文件中，因此无法恢复。
- en: If you are not careful, step 3 can be a dangerous one. In any case, you should
    always think twice before you allow a piece of malware to run unhindered in the
    hope that you have set your breakpoints or breakpoint conditions properly. If
    the program manages to bypass your breakpoint(s), it may well proceed to execute
    malicious code before you know what has happened. For this reason, attempts to
    de-obfuscate malware under debugger control should always be conducted in a sandbox
    environment that you are not afraid to wipe clean in the event things go wrong.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不够小心，步骤 3 可能会变得很危险。无论如何，在允许恶意软件无阻碍地运行之前，你应该总是三思而后行，希望你已经正确设置了断点或断点条件。如果程序成功绕过你的断点（s），它可能会在你意识到发生了什么之前执行恶意代码。因此，在调试器控制下尝试去混淆恶意软件时，应该始终在一个你不怕出错的沙盒环境中进行。
- en: Step 4 may require some level of effort, because memory dumping is usually supported
    in debuggers, while entire-process image dumping may not be. The OllyDump^([[228](#ftn.CHP-25-FN-3)])
    plug-in, by Gigapede, adds process-dumping capabilities to OllyDbg. Keep in mind
    that the image that gets dumped from memory contains content from a running process
    and does not necessarily reflect the original state of the binary at rest in a
    disk file. In malware analysis, however, the goal is generally to create not a
    working de-obfuscated executable file, but rather an image file that is correctly
    structured so that it can be loaded into a disassembler for further analysis.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4 可能需要一些努力，因为内存转储通常在调试器中受支持，而整个进程图像转储可能不受支持。Gigapede 的 OllyDump^([[228](#ftn.CHP-25-FN-3)])
    插件为 OllyDbg 添加了进程转储功能。请记住，从内存中转储的图像包含运行进程的内容，并不一定反映磁盘文件中静态二进制文件的原始状态。然而，在恶意软件分析中，目标通常是创建一个正确结构的图像文件，以便将其加载到反汇编器中进行进一步分析。
- en: One of the trickiest parts of reconstructing a binary image from an obfuscated
    process is restoration of the program’s imported function table. As part of the
    obfuscation process, a program’s import table is often obfuscated as well. As
    a result, the de-obfuscation process must also take care of linking the newly
    de-obfuscated process to all of the shared libraries and functions the process
    requires in order to execute properly. The only trace of this process is usually
    a table of imported function addresses somewhere within the process’s memory image.
    When dumping a de-obfuscated process image to a file, steps are often taken to
    attempt to reconstruct a valid import table in the dumped process image. In order
    to do this, the headers of the dumped image need to be modified to point to a
    new import table structure that must properly reflect all of the shared library
    dependencies of the original de-obfuscated program. A popular tool for automating
    this process is the ImpREC^([[229](#ftn.CHP-25-FN-4)]) (Import REConstruction)
    utility by MackT. As with process dumping, keep in mind that extracting a standalone
    executable may not be your primary goal in malware analysis, in which case reconstructing
    valid headers and a working import table is less important than knowing which
    functions have been resolved and where the addresses of those functions have been
    stored.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从混淆进程重构二进制图像的复杂部分之一是恢复程序的导入函数表。作为混淆过程的一部分，程序的导入表通常也会被混淆。因此，去混淆过程还必须注意将新去混淆的进程链接到所有必要的共享库和函数，以便正确执行。通常，这个过程留下的唯一痕迹是在进程内存图像中的某个位置的导入函数地址表。在将去混淆的进程图像导出到文件时，通常会采取步骤尝试在导出的进程图像中重建一个有效的导入表。为了做到这一点，导出图像的头部需要被修改，以指向一个新的导入表结构，该结构必须正确反映原始去混淆程序的所有共享库依赖关系。自动化此过程的流行工具是
    MackT 开发的 ImpREC^([[229](#ftn.CHP-25-FN-4)])（导入重建）实用程序。与进程导出一样，请记住，在恶意软件分析中，提取独立的可执行文件可能不是你的主要目标，在这种情况下，重建有效的头部和导入表的重要性不如知道哪些函数已被解析以及这些函数的地址存储在哪里。
- en: '* * *'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[226](#CHP-25-FN-1)]) See [http://www.ollydbg.de/](http://www.ollydbg.de/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[226](#CHP-25-FN-1)]) 请参阅 [http://www.ollydbg.de/](http://www.ollydbg.de/).
- en: ^([[227](#CHP-25-FN-2)]) For a discussion of one such obfuscator, VMProtect,
    see “Unpacking Virtualization Obfuscators” by Rolf Rooles at [http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf](http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[227](#CHP-25-FN-2)]) 关于此类混淆器之一 VMProtect 的讨论，请参阅 Rolf Rooles 在 [http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf](http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf)
    发表的“解包虚拟化混淆器”。
- en: ^([[228](#CHP-25-FN-3)]) See [http://www.woodmann.com/collaborative/tools/index.php/OllyDump](http://www.woodmann.com/collaborative/tools/index.php/OllyDump).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[228](#CHP-25-FN-3)]) 请参阅 [http://www.woodmann.com/collaborative/tools/index.php/OllyDump](http://www.woodmann.com/collaborative/tools/index.php/OllyDump).
- en: ^([[229](#CHP-25-FN-4)]) See [http://www.woodmann.com/collaborative/tools/index.php/ImpREC](http://www.woodmann.com/collaborative/tools/index.php/ImpREC).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[229](#CHP-25-FN-4)]) 请参阅 [http://www.woodmann.com/collaborative/tools/index.php/ImpREC](http://www.woodmann.com/collaborative/tools/index.php/ImpREC).
- en: IDA Databases and the IDA Debugger
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA 数据库和 IDA 调试器
- en: It is important that we begin with an understanding of how the debugger treats
    your database when you initiate (and terminate) a debugging session. A debugger
    needs a process image to work with. Debuggers obtain process images either by
    attaching to existing processes or by creating new processes from executable files.
    An IDA database does not contain a valid process image, nor in most cases can
    a valid process image be reconstructed from a database (if one could, then File
    ▸ Produce File ▸ Create EXE File might be simple to implement). When you launch
    a debugger session from IDA, the disassembler side informs the debugger side of
    the name of the original input file, which the debugger uses to create and attach
    to a new process. Information provided to the debugger includes disassembly formatting,
    symbol names, data formatting, and any comments that you have entered into the
    database. An important point to understand is that any patches (changes in byte
    content) you have applied to your database will not be reflected in the process
    being debugged. In other words, it is not possible to patch changes into the database
    and expect to observe the effect of those changes when you launch the debugger.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先理解，当你开始（和结束）调试会话时，调试器是如何处理你的数据库的。调试器需要一个进程映像来工作。调试器通过附加到现有进程或从可执行文件创建新进程来获取进程映像。IDA数据库不包含有效的进程映像，在大多数情况下，也无法从数据库中重建有效的进程映像（如果可以的话，那么“文件
    ▸ 生成文件 ▸ 创建EXE文件”可能就简单实现了）。当你从IDA启动调试器会话时，反汇编器端会通知调试器端原始输入文件的名称，调试器使用该名称来创建并附加到新进程。提供给调试器的信息包括反汇编格式、符号名称、数据格式以及你输入到数据库中的任何注释。一个需要理解的重要点是，你应用到数据库中的任何补丁（字节内容的变化）都不会反映在正在调试的进程中。换句话说，不可能将更改补丁应用到数据库中，并期望在启动调试器时观察到这些更改的效果。
- en: The opposite holds true as well. When you have finished debugging a process
    and you return to disassembly mode, by default the only changes that will be reflected
    in the database are cosmetic in nature (such as renamed variables or functions).
    Any memory changes, such as self-modified code, are not pulled back into the database
    for you to analyze. If you wish to migrate any content, such as newly de-obfuscated
    code, from the debugger back to your disassembly database, IDA will allow you
    to do so via the Debugger ▸ Take Memory Snapshot command. The resulting confirmation
    dialog is shown in [Figure 25-1](ch25s02.html#memory_snapshot_confirmation_dialog
    "Figure 25-1. Memory snapshot confirmation dialog").
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，情况也相反。当你完成一个过程的调试并返回到反汇编模式时，默认情况下，数据库中反映的唯一变化将是外观上的（例如重命名的变量或函数）。任何内存变化，如自我修改的代码，都不会被拉回到数据库供你分析。如果你希望将任何内容，如新解密的代码，从调试器迁移回你的反汇编数据库，IDA将允许你通过“调试器
    ▸ 捕获内存快照”命令来完成。结果确认对话框如图25-1所示。
- en: '![Memory snapshot confirmation dialog](httpatomoreillycomsourcenostarchimages854392.png.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![内存快照确认对话框](httpatomoreillycomsourcenostarchimages854392.png.jpg)'
- en: Figure 25-1. Memory snapshot confirmation dialog
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-1. 内存快照确认对话框
- en: The default option is to copy loader segments from the running process to the
    database. *Loader segments* are those segments that were loaded into the database
    by the IDA loader module used to create the current database. In the case of an
    obfuscated program, one or more of these segments probably contain data that has
    been obfuscated and are therefore nearly impossible to analyze in the disassembler.
    These are precisely the segments that you will want to copy back from the running
    process image in order to take advantage of the de-obfuscation work performed
    by the process running under debugger control.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选项是将运行进程的加载器段复制到数据库中。“加载器段”是指由创建当前数据库时使用的IDA加载器模块加载到数据库中的段。在加密程序的情况下，这些段中可能包含被加密的数据，因此在反汇编器中几乎不可能分析。这些正是你希望从运行进程映像中复制回以利用在调试器控制下运行的进程执行的解密工作的段。
- en: Selecting All segments causes all segments created by the debugger to be copied
    back to the database. These segments include the contents of all shared libraries
    loaded in support of the process as well as additional process-related segments,
    such as the stack and heap contents.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“所有段”会导致所有由调试器创建的段被复制回数据库。这些段包括为支持该过程而加载的所有共享库的内容，以及与过程相关的其他段，如栈和堆的内容。
- en: When the debugger is used to attach to an existing process with no associated
    database, none of the debugger segments will be flagged as loader segments because
    the file was not loaded by one of IDA’s loaders. In such cases, you may elect
    to capture all available segments into a new database. Alternatively, you may
    elect to edit segment attributes and designate one or more segments as loader
    segments. Segment attributes may be edited by first opening the Segments window
    (View ▸ Open Subviews ▸ Segments). Any segment marked as a loader segment will
    contain an *L* in the L column of the Program Segmentation window. Right-clicking
    a segment of interest and selecting Edit Segment opens the segment attributes
    dialog shown in [Figure 25-2](ch25s02.html#segment_editing_dialog_with_the_loader_s
    "Figure 25-2. Segment editing dialog with the Loader segment checkbox").
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器用于连接到一个没有关联数据库的现有进程时，由于文件不是由IDA的加载器加载的，因此没有调试器段会被标记为加载器段。在这种情况下，您可以选择将所有可用的段捕获到一个新的数据库中。或者，您可以选择编辑段属性，将一个或多个段指定为加载器段。可以通过首先打开段窗口（视图
    ▸ 打开子视图 ▸ 段）来编辑段属性。任何标记为加载器段的段将在程序分段窗口的L列中包含一个*L*。右键单击感兴趣的段并选择编辑段将打开[图25-2](ch25s02.html#segment_editing_dialog_with_the_loader_s
    "图25-2。带有加载器段复选框的段编辑对话框")中显示的段属性对话框。
- en: '![Segment editing dialog with the Loader segment checkbox](httpatomoreillycomsourcenostarchimages854395.png.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![带有加载器段复选框的段编辑对话框](httpatomoreillycomsourcenostarchimages854395.png.jpg)'
- en: Figure 25-2. Segment editing dialog with the Loader segment checkbox
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-2. 带有加载器段复选框的段编辑对话框
- en: Selecting the Loader segment checkbox marks the segment as a loader segment
    and allows it to be copied into the database along with all other loader segments.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 选择加载器段复选框将段标记为加载器段，并允许它与其他所有加载器段一起复制到数据库中。
- en: The segment attributes dialog is also useful when you have created a process
    from an open database and wish to add additional loader segments before taking
    a memory snapshot. For example, if an obfuscated process extracts the original
    code into a block of memory allocated in the heap (or a memory-mapped block),
    you will want to mark that memory block as a loader segment before you snapshot
    memory; otherwise, the de-obfuscated code will not be copied back into your database.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从打开的数据库创建一个进程，并在进行内存快照之前添加额外的加载器段时，段属性对话框也非常有用。例如，如果一个混淆进程将原始代码提取到堆（或内存映射块）中分配的内存块，您将希望在快照内存之前将该内存块标记为加载器段；否则，去混淆代码将不会复制回您的数据库。
- en: Debugging Obfuscated Code
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试混淆代码
- en: We have mentioned a number of times that loading an obfuscated program in a
    debugger, allowing it to run until the de-obfuscation is complete, and then taking
    a memory snapshot of the program in its de-obfuscated state seems like a good
    strategy for obtaining a de-obfuscated version of a program. Controlled execution
    is probably a better way of thinking about this process than debugging, because
    all we are really doing is observing the code in operation and then taking a memory
    snapshot at the appropriate moment. A debugger simply happens to be the tool that
    allows us to accomplish this task. At least that is what we are hoping for. In
    [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis") we discussed several
    anti-disassembly and anti-debugging techniques that obfuscators utilize in an
    attempt to prevent us from obtaining a clear picture of a program. It is time
    to see how IDA’s debugger can help us bypass some of these techniques.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次提到，在调试器中加载一个混淆程序，让它运行直到混淆过程完成，然后对程序在去混淆状态下的内存进行快照，这似乎是获取程序去混淆版本的一个好策略。相对于调试，控制执行可能是更恰当的思考方式，因为我们实际上只是在观察代码运行状态，并在适当的时候进行内存快照。调试器只是恰好是我们完成这项任务的工具。至少这是我们希望的情况。在[第21章](ch21.html
    "第21章。混淆代码分析")中，我们讨论了几种混淆器用来防止我们获得程序清晰视图的反反汇编和反调试技术。现在是时候看看IDA的调试器如何帮助我们绕过这些技术了。
- en: 'For this chapter we will assume that the obfuscated programs we are dealing
    with employ some form of encryption or compression on the interesting portions
    of the binary. The level of difficulty in obtaining a clear picture of that code
    depends entirely on the sophistication of any anti-analysis techniques used in
    the obfuscation process and the measures that can be developed to circumvent these
    techniques. Before we get started, however, here are a few rules to live by when
    working with malware in a debugging environment:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将假设我们处理的混淆程序在二进制文件的有兴趣部分使用了某种形式的加密或压缩。获取该代码清晰图像的难度完全取决于在混淆过程中使用的任何反分析技术的复杂性以及可以开发的绕过这些技术的措施。然而，在我们开始之前，这里有一些在调试环境中处理恶意软件时应遵守的规则：
- en: Protect your network and host environments. Always work in a sandbox environment.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护你的网络和主机环境。始终在沙盒环境中工作。
- en: On initial analysis, use single stepping when possible. It may be tedious, but
    it is your best defense against a program escaping your control.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初步分析时，尽可能使用单步执行。这可能很繁琐，但这是你防止程序逃离控制的最佳防御手段。
- en: Always think twice before executing a debugger command that will allow more
    than a single instruction to execute. If you have not planned properly, the program
    you are debugging may run into a malicious portion of the code.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行任何允许执行多个指令的调试器命令之前，始终三思而后行。如果你没有妥善计划，你正在调试的程序可能会遇到恶意代码部分。
- en: When possible, use hardware breakpoints. It is difficult to set software breakpoints
    in obfuscated code, because de-obfuscation algorithms may modify the breakpoint
    instructions that you have inserted or compute checksums over regions of code.^([[230](#ftn.CHP-25-FN-5)])
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当可能时，使用硬件断点。在混淆代码中设置软件断点很困难，因为解混淆算法可能会修改你插入的断点指令或对代码区域计算校验和。[^[[230](#ftn.CHP-25-FN-5])]
- en: When examining a program for the first time, it is best to allow the debugger
    to handle all exceptions generated by the program so that you can make informed
    decisions about which exceptions to pass to the program and which exceptions the
    debugger should continue to catch.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在首次检查程序时，最好让调试器处理程序生成的所有异常，这样你可以做出明智的决定，决定哪些异常传递给程序，哪些异常由调试器继续捕获。
- en: Be prepared to restart debugging often, because one wrong step can lead you
    down a road to failure (for example, if you allow the process to detect the debugger).
    Keep detailed notes regarding addresses that are safe to run to so that you can
    rapidly recover when you restart the process.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好经常重新启动调试，因为一个错误的步骤可能会让你走向失败的道路（例如，如果你允许进程检测到调试器）。详细记录安全运行的地址，以便你在重新启动进程时可以快速恢复。
- en: In general, you should always take a very cautious approach the first time you
    start to work with a particular obfuscated program. In most cases your primary
    goal should be to obtain a de-obfuscated version of the program. Speeding up the
    de-obfuscation process by learning exactly how far you can go before you need
    to set a breakpoint should be a secondary goal, and it is probably best saved
    for a follow-on exercise once you have managed to successfully de-obfuscate a
    program for the first time.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你第一次开始处理一个特定的混淆程序时，你应该始终采取非常谨慎的态度。在大多数情况下，你的主要目标应该是获取程序的解混淆版本。通过学习在需要设置断点之前你能走多远来加快解混淆过程应该是次要目标，而且这最好是在你第一次成功解混淆一个程序之后作为后续练习来保存。
- en: Launching the Process
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动进程
- en: Whether you have spent minutes or hours studying a malicious executable with
    IDA, you will probably want to gain control of it at the earliest opportunity
    the first time you launch it in the debugger. One of the easiest ways to gain
    control over a process is to set a breakpoint at the process entry point, the
    first instruction executed once the operation has finished creating the process’s
    memory image. In most cases this will be the symbol labeled `start`; however,
    in some cases it won’t. The PE file format, for example, allows for the designation
    TLS^([[231](#ftn.CHP-25-FN-6)]) callback functions designed to perform initialization
    and destruction tasks for data that is local to each thread, and these TLS callback
    functions are invoked before control is ever transferred to `start`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用 IDA 研究恶意可执行文件花费了分钟还是数小时，你可能会希望在第一次在调试器中启动它时尽快控制它。控制进程的最简单方法之一是在进程的入口点设置断点，这是在操作完成创建进程内存映像后执行的第一条指令。在大多数情况下，这将是由标签
    `start` 标记的符号；然而，在某些情况下则不是。例如，PE 文件格式允许指定 TLS^([[231](#ftn.CHP-25-FN-6)]) 回调函数，这些函数旨在为每个线程本地的数据进行初始化和销毁任务，并且这些
    TLS 回调函数在控制权传递到 `start` 之前就会被调用。
- en: Malware authors are well aware of TLS callback functions and have made use of
    these functions to have code executed before a program’s main entry point code
    gets a chance to run. The hope is that anyone analyzing the malware will fail
    to notice the presence of the TLS callback, with a resulting failure to understand
    the true behavior of the program being analyzed. IDA properly parses PE file headers
    and recognizes the presence of any TLS callbacks contained within a PE file, adding
    any such functions to the binary’s list of entry points in the Exports window.
    [Figure 25-3](ch25s03.html#exports_window_showing_a_tls_callback_fu "Figure 25-3. Exports
    window showing a TLS callback function") shows the Exports window for an executable
    that contains a TLS callback.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者对 TLS 回调函数非常了解，并已利用这些函数在程序的主入口点代码有机会运行之前执行代码。希望任何分析恶意软件的人都会忽略 TLS 回调的存在，从而导致无法理解正在分析的程序的真正行为。IDA
    正确解析 PE 文件头，并识别出 PE 文件中包含的任何 TLS 回调，将这些函数添加到二进制文件的入口点列表中。图 25-3 显示了包含 TLS 回调的可执行文件的
    Exports 窗口。[图 25-3](ch25s03.html#exports_window_showing_a_tls_callback_fu "图 25-3.
    显示 TLS 回调函数的 Exports 窗口")。
- en: '![Exports window showing a TLS callback function](httpatomoreillycomsourcenostarchimages854398.png.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![显示 TLS 回调函数的 Exports 窗口](httpatomoreillycomsourcenostarchimages854398.png.jpg)'
- en: Figure 25-3. Exports window showing a TLS callback function
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-3. 显示 TLS 回调函数的 Exports 窗口
- en: The bottom line when it comes to TLS callbacks is to recognize their presence
    and then set breakpoints at the beginning of each TLS callback function to ensure
    that you gain control of the process before it is too late.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 TLS 回调的底线是识别它们的存在，然后在每个 TLS 回调函数的开始处设置断点，以确保你在为时已晚之前控制住进程。
- en: Many debuggers offer options to specify when (if at all) the debugger should
    pause following initial process creation, and IDA is no exception. [Figure 25-4](ch25s03.html#debugger_pausing_events
    "Figure 25-4. Debugger pausing events") shows a portion of IDA’s Debugger Setup
    dialog (Debugger ▸ Debugger Options).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 许多调试器提供选项来指定（如果有的话）在初始进程创建后何时（如果有的话）暂停调试器，IDA 也不例外。[图 25-4](ch25s03.html#debugger_pausing_events
    "图 25-4. 调试器暂停事件") 显示了 IDA 的调试器设置对话框（调试器 ▸ 调试器选项）的一部分。
- en: '![Debugger pausing events](httpatomoreillycomsourcenostarchimages854401.png.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![调试器暂停事件](httpatomoreillycomsourcenostarchimages854401.png.jpg)'
- en: Figure 25-4. Debugger pausing events
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-4. 调试器暂停事件
- en: 'Each of the available options offers the opportunity to automatically pause
    the process being debugged when specific events occur. Each of these events is
    summarized in the following list:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可用的选项都提供了在特定事件发生时自动暂停正在调试的进程的机会。以下列表总结了这些事件：
- en: '| **Stop on debugging start** This option offers the earliest opportunity to
    pause the debugger following process creation. For example, on Windows 7, this
    will pause the process at the beginning of the `RtlUserThread-Star``t` function
    within *ntdll.dll*. This will pause execution before any program code, including
    TLS callback functions, is executed. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **在调试开始时停止** 此选项提供了在进程创建后暂停调试器的最早机会。例如，在 Windows 7 上，这将在 `ntdll.dll` 中的 `RtlUserThread-Star``t`
    函数的开始处暂停进程。这将暂停执行，在包括 TLS 回调函数在内的任何程序代码执行之前。'
- en: '| **Stop on process entry point** Causes the debugger to pause execution once
    the program entry point is reached. This typically coincides with the symbol named
    `start` (or its equivalent) in your IDA database. Any TLS callback functions will
    already have executed before this event takes place. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **在进程入口点停止** 当程序入口点被达到时，会使调试器暂停执行。这通常与你在 IDA 数据库中名为 `start`（或其等效名称）的符号相对应。在此事件发生之前，任何
    TLS 回调函数都已经执行完毕。|'
- en: '| **Stop on thread start/exit** Pauses the debugger each time a new thread
    starts or an existing thread terminates. On a Windows system, when this event
    fires, the debugger will pause somewhere within *kernel32.dll*. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **在线程开始/退出时停止** 每当新线程开始或现有线程终止时，都会暂停调试器。在 Windows 系统中，当此事件触发时，调试器将在 *kernel32.dll*
    中某个位置暂停。|'
- en: '| **Stop on library load/unload** Pauses the debugger each time a new library
    is loaded or an existing library is unloaded. On a Windows system, when this event
    fires, the debugger will pause somewhere within *kernel32.dll*. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **在库加载/卸载时停止** 每当加载新库或卸载现有库时，都会暂停调试器。在 Windows 系统中，当此事件触发时，调试器将在 *kernel32.dll*
    中某个位置暂停。|'
- en: '| **Stop on debugging message** Pauses execution each time the process outputs
    a message using the debug print facility. On Windows systems, this corresponds
    to a call to `OutputDebugString`, and execution is paused within *kernel32.dll*.
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **在调试消息停止** 每当进程使用调试打印功能输出消息时，都会暂停执行。在 Windows 系统中，这对应于对 `OutputDebugString`
    的调用，并且执行将在 *kernel32.dll* 中暂停。|'
- en: Understanding where the process is likely to be paused for each of these debugger
    events is important in order to keep the process you are debugging from executing
    further than you intend it to. Once you are certain that you will gain control
    of the process in a predictable manner, you can move on to getting some work done
    with the debugger.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在每个调试器事件中进程可能暂停的位置对于防止你正在调试的进程执行超出你的预期非常重要。一旦你确定你将以可预测的方式控制进程，你就可以继续使用调试器进行一些工作了。
- en: Simple Decryption and Decompression Loops
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单解密和解压缩循环
- en: When we say *simple decryption and decompression loops*, we mean loops that
    employ no nested obfuscation techniques and for which you can identify, with certainty,
    all possible exit points. When you encounter such loops, the easiest way to get
    through them is to set a breakpoint at all possible exit points and then allow
    the loop to execute. Consider single stepping through such loops one or two times
    in order to get a feel for them; then set breakpoints accordingly. When setting
    a breakpoint immediately following a loop, you should make sure that the bytes
    at the address at which you are setting the breakpoint will not be changed during
    the course of the loop; otherwise, a software breakpoint may fail to trigger.
    When in doubt, use a hardware breakpoint.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 *简单的解密和解压缩循环* 时，我们指的是没有使用嵌套混淆技术，并且你可以确定所有可能的退出点的循环。当你遇到这样的循环时，通过在所有可能的退出点设置断点并允许循环执行来通过它们是最简单的方法。考虑单步执行这样的循环一两次，以便了解它们；然后相应地设置断点。在循环之后立即设置断点时，你应该确保你设置断点的地址处的字节在循环过程中不会改变；否则，软件断点可能无法触发。如有疑问，请使用硬件断点。
- en: 'If your goal is to develop a fully automated de-obfuscation process, you will
    need to develop an algorithm for recognizing when the de-obfuscation process has
    completed. When this condition is satisfied, your automated solution can pause
    the process, at which point you can acquire a memory snapshot. For simple de-obfuscation
    routines, recognizing the end of the de-obfuscation stage may be as simple as
    noting a large change in the value of the instruction pointer or the execution
    of a specific instruction. For example, the beginning and end of the `UPX` decompression
    routine for an obfuscated Windows executable are shown in the following listing:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是开发一个完全自动化的去混淆过程，你需要开发一个算法来识别去混淆过程何时完成。当满足此条件时，你的自动化解决方案可以暂停进程，此时你可以获取内存快照。对于简单的去混淆例程，识别去混淆阶段的结束可能就像注意指令指针或执行特定指令的值发生的大变化一样简单。例如，以下列表显示了混淆的
    Windows 可执行文件的 `UPX` 解压缩例程的开始和结束：
- en: '[PRE15]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Several characteristics of this routine can be used to automatically recognize
    its completion. First, the routine begins by pushing all registers onto the stack
    at the program entry point ![](httpatomoreillycomsourcenostarchimages854061.png).
    The complementary operation of popping all registers occurs near the end of the
    routine ![](httpatomoreillycomsourcenostarchimages854063.png) after the program
    has been decompressed. Finally, control is transferred ![](httpatomoreillycomsourcenostarchimages854093.png)
    to the newly unpacked program. Thus, one strategy for automating decompression
    would be to step trace the program until the current instruction is a `popa`.
    Because step tracing is slow, the IDC script shown in [Example 25-1](ch25s03.html#simple_upx_unpacker_script
    "Example 25-1. Simple UPX unpacker script") takes the slightly different approach
    of scanning for the `popa` instruction and then running the program to the address
    of the `popa`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程的几个特征可以用来自动识别其完成。首先，例程从程序入口点开始，将所有寄存器推入堆栈 ![http://atomoreilly.com/source/no_starch_images/854061.png]。在程序解压缩后，例程的末尾发生弹出所有寄存器的互补操作
    ![http://atomoreilly.com/source/no_starch_images/854063.png]。最后，控制权转移到新解包的程序 ![http://atomoreilly.com/source/no_starch_images/854093.png]。因此，自动化解压缩的一种策略是逐步跟踪程序，直到当前指令是
    `popa`。因为逐步跟踪很慢，所以[示例 25-1](ch25s03.html#simple_upx_unpacker_script "示例 25-1.
    简单 UPX 解包脚本")中显示的 IDC 脚本采取了稍微不同的方法：扫描 `popa` 指令，然后运行程序到 `popa` 的地址：
- en: Example 25-1. Simple UPX unpacker script
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 25-1. 简单 UPX 解包脚本
- en: '[PRE16]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The script in [Example 25-1](ch25s03.html#simple_upx_unpacker_script "Example 25-1. Simple
    UPX unpacker script") is designed to be launched within an IDA database, prior
    to launching the debugger, and assumes that you have previously selected a debugger
    using Debugger ▸ Select debugger. The script takes care of the details of launching
    the debugger and gaining control of the newly created process. This script relies
    on some very specific features of UPX and is therefore not a good candidate for
    use as a generic de-obfuscation script. It does, however, demonstrate some concepts
    that might be used in later efforts. The script depends on the fact that the decompression
    routine resides at the end of one of the program segments (typically named `UPX1`)
    and that `UPX` does not make use of any desynchronization techniques to prevent
    proper disassembly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 25-1](ch25s03.html#simple_upx_unpacker_script "示例 25-1. 简单 UPX 解包脚本")中的脚本设计为在
    IDA 数据库中启动，在启动调试器之前，并假设您之前已使用“调试器”>>“选择调试器”选择了一个调试器。该脚本负责启动调试器和获取新创建进程的控制权。这个脚本依赖于
    UPX 的一些非常特定的功能，因此不适合用作通用去混淆脚本。然而，它确实演示了一些可能在后续工作中使用到的概念。该脚本依赖于解压缩例程位于程序段末尾的事实（通常命名为
    `UPX1`），以及 `UPX` 没有使用任何反汇编同步技术的事实。'
- en: OBFUSCATING OBFUSCATORS
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆混淆器
- en: UPX is one of the more popular obfuscation utilities in use today (perhaps because
    it is free). Its popularity does not make it a particularly effective tool, however.
    One of the principal drawbacks to its effectiveness is the fact that UPX itself
    offers a command-line option to restore a UPX-packed binary to its original form.
    Consequently, a cottage industry has evolved for developing tools to prevent UPX
    from unpacking itself. Because UPX performs some integrity checks on a compressed
    binary before it will unpack that binary, simple changes that cause the integrity
    checks to fail without affecting the operation of the compressed binary render
    UPX’s own unpacking feature inoperative. One such technique involves changing
    the default UPX section names to anything other than UPX0, UPX1, and UPX2\. For
    this reason, it is useful to avoid hardcoding these segment names into any scripts
    that you develop for unpacking UPX.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: UPX 是目前使用中较受欢迎的混淆工具之一（可能是因为它是免费的）。然而，它的流行并不使其成为一个特别有效的工具。其有效性的主要缺点之一是 UPX 本身提供了一个命令行选项，可以将
    UPX 打包的二进制文件恢复到其原始形式。因此，一个 cottage industry 已经发展起来，开发防止 UPX 自解包的工具。因为 UPX 在解包二进制文件之前会对压缩的二进制文件进行一些完整性检查，所以简单的更改会导致完整性检查失败，而不会影响压缩二进制文件的操作，这使得
    UPX 的自解包功能失效。一种这样的技术涉及将默认 UPX 段名称更改为除 UPX0、UPX1 和 UPX2 之外的其他名称。因此，在您开发的任何解包脚本中避免将这些段名称硬编码进去是有用的。
- en: The script relies on these facts in order to scan forward, one instruction at
    a time ![](httpatomoreillycomsourcenostarchimages854061.png), from the program
    entry point, as long as the next instruction lies within the same program segment
    ![](httpatomoreillycomsourcenostarchimages854063.png) and until the current instruction
    is a `popa` ![](httpatomoreillycomsourcenostarchimages854093.png). Once the `popa`
    instruction is located, the debugger is invoked ![](httpatomoreillycomsourcenostarchimages854095.png)
    to execute the process up to the address of the `popa` instruction, at which point
    the program has been decompressed. The last step is to take a memory snapshot
    ![](httpatomoreillycomsourcenostarchimages854099.png) to pull the de-obfuscated
    program bytes back into our database for further analysis.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本依赖于这些事实来逐条指令向前扫描，每次一个指令 ![http://atomoreilly.com/source/nostarch/images/854061.png]，从程序入口点开始，只要下一个指令位于相同的程序段内
    ![http://atomoreilly.com/source/nostarch/images/854063.png]，并且直到当前指令是 `popa` ![http://atomoreilly.com/source/nostarch/images/854093.png]。一旦找到
    `popa` 指令，调试器就会被调用 ![http://atomoreilly.com/source/nostarch/images/854095.png]
    来执行直到 `popa` 指令地址的过程，此时程序已经被解压缩。最后一步是获取内存快照 ![http://atomoreilly.com/source/nostarch/images/854099.png]，将解混淆后的程序字节拉回到我们的数据库以进行进一步分析。
- en: 'An even more general-purpose solution for automated unpacking is to exploit
    the fact that many de-obfuscation routines are appended to the end of a binary
    and perform a jump to the original entry point, which occurs much earlier in the
    binary, once de-obfuscation is complete. In some cases, the original entry point
    may lie in an entirely different program segment, while in other cases, the original
    entry point simply precedes any address used by the de-obfuscation code. The Python
    script in [Example 25-2](ch25s03.html#generic_attempt_to_run_until_oep_is_hit
    "Example 25-2. Generic attempt to run until OEP is hit") offers a more basic means
    of running a simple de-obfuscation algorithm until it jumps to the program’s original
    entry point:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动化解包，一个更通用的解决方案是利用这样一个事实：许多解混淆例程被附加到二进制文件的末尾，并在解混淆完成后跳转到原始入口点，该入口点在二进制文件中发生得要早得多。在某些情况下，原始入口点可能位于完全不同的程序段中，而在其他情况下，原始入口点简单地位于解混淆代码使用的任何地址之前。Python
    脚本 [示例 25-2](ch25s03.html#generic_attempt_to_run_until_oep_is_hit "示例 25-2. 通用尝试运行直到遇到
    OEP") 提供了一种更基本的方法来运行一个简单的解混淆算法，直到它跳转到程序的原始入口点：
- en: Example 25-2. Generic attempt to run until OEP is hit
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 25-2. 通用尝试运行直到遇到 OEP
- en: '[PRE17]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to the script in [Example 25-1](ch25s03.html#simple_upx_unpacker_script
    "Example 25-1. Simple UPX unpacker script"), this script should be launched from
    the disassembler rather than the debugger and again assumes that a debugger has
    been selected. The script handles the details of launching the debugger and gaining
    the necessary control of the newly created process. This particular script makes
    two assumptions: that all code prior to the entry point is obfuscated and that
    nothing malicious takes place prior to transferring control to an address that
    precedes the entry point. The script begins by launching the debugger and pausing
    at the program entry point ![](httpatomoreillycomsourcenostarchimages854061.png).
    Next, the program enables step tracing ![](httpatomoreillycomsourcenostarchimages854063.png)
    and loops to test the address of each generated event ![](httpatomoreillycomsourcenostarchimages854093.png).
    Once the event address precedes the program entry point address, de-obfuscation
    is assumed to be complete, and the process is paused ![](httpatomoreillycomsourcenostarchimages854095.png)
    and step tracing disabled ![](httpatomoreillycomsourcenostarchimages854099.png).
    Finally, for good measure, the script ensures that the bytes at the current instruction
    pointer location are formatted as code ![](httpatomoreillycomsourcenostarchimages854101.png).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [示例 25-1](ch25s03.html#simple_upx_unpacker_script "示例 25-1. 简单 UPX 解包脚本")
    中的脚本类似，这个脚本应该从反汇编器而不是调试器启动，并且再次假设已经选择了调试器。脚本处理启动调试器和获取新创建进程所需控制权的细节。这个特定的脚本有两个假设：即入口点之前的所有代码都是混淆的，并且在将控制权转移到入口点之前的地址之前没有发生恶意行为。脚本首先启动调试器，并在程序入口点暂停
    ![http://atomoreilly.com/source/nostarch/images/854061.png]。接下来，程序启用单步跟踪 ![http://atomoreilly.com/source/nostarch/images/854063.png]
    并循环测试每个生成事件的地址 ![http://atomoreilly.com/source/nostarch/images/854093.png]。一旦事件地址在程序入口点地址之前，就假设解混淆已完成，进程被暂停
    ![http://atomoreilly.com/source/nostarch/images/854095.png] 并且单步跟踪被禁用 ![http://atomoreilly.com/source/nostarch/images/854099.png]。最后，为了保险起见，脚本确保当前指令指针位置的字节格式化为代码
    ![http://atomoreilly.com/source/nostarch/images/854101.png]。
- en: When stepping your way through obfuscated code, it is not uncommon to encounter
    the warning shown in [Figure 25-5](ch25s03.html#debugger_instruction_pointer_warning
    "Figure 25-5. Debugger instruction pointer warning").
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过去混淆代码进行单步调试时，遇到[图 25-5](ch25s03.html#debugger_instruction_pointer_warning
    "图 25-5. 调试器指令指针警告")中显示的警告并不罕见。
- en: '![Debugger instruction pointer warning](httpatomoreillycomsourcenostarchimages854405.png.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![调试器指令指针警告](httpatomoreillycomsourcenostarchimages854405.png.jpg)'
- en: Figure 25-5. Debugger instruction pointer warning
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-5. 调试器指令指针警告
- en: This warning indicates that the instruction pointer is pointing into an item
    that IDA believed was data or that the instruction pointer is pointing into the
    middle of a previously disassembled instruction. This warning is frequently encountered
    when single stepping through code that utilizes disassembly desynchronization
    techniques. It is also often encountered when a program jumps to a region that
    was once data and is now code, as happens following the de-obfuscation of a program.
    Answering yes to the question causes IDA to reformat the bytes in question as
    code, which should be the proper thing to do since the instruction pointer indicates
    that this is the next item to be fetched for execution.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告表明指令指针指向了 IDA 认为是数据的项目，或者指令指针指向了之前已反汇编指令的中间部分。当单步执行使用反汇编不同步技术的代码时，经常会遇到这种警告。它也经常在程序跳转到曾经是数据现在是代码的区域时遇到，例如在程序去混淆之后。回答“是”会导致
    IDA 重新格式化相关字节作为代码，这应该是正确的做法，因为指令指针表明这是下一个要取来执行的项目。
- en: Note that because of its use of step tracing, the script in [Example 25-2](ch25s03.html#generic_attempt_to_run_until_oep_is_hit
    "Example 25-2. Generic attempt to run until OEP is hit") will be substantially
    slower than the script in [Example 25-1](ch25s03.html#simple_upx_unpacker_script
    "Example 25-1. Simple UPX unpacker script"). However, for the price of slower
    execution, we gain a couple of advantages. First, we are able to specify a termination
    condition that is not tied to any one address. This is not possible when using
    breakpoints alone. Second, this script is immune to any attempts to desynchronize
    the disassembler because instruction boundaries are determined purely based on
    runtime values of the instruction pointer rather than static disassembly analysis.
    In its announcement introducing scripted debugging features,^([[232](#ftn.CHP-25-FN-7)])
    Hex-Rays presents a far more robust script for performing the tasks of a *universal
    unpacker*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于使用了步骤跟踪，[示例 25-2](ch25s03.html#generic_attempt_to_run_until_oep_is_hit
    "示例 25-2. 通用运行直到遇到 OEP 的尝试") 中的脚本将比 [示例 25-1](ch25s03.html#simple_upx_unpacker_script
    "示例 25-1. 简单 UPX 解包脚本") 中的脚本慢得多。然而，以牺牲执行速度为代价，我们获得了一些优势。首先，我们能够指定一个与任何特定地址无关的终止条件。单独使用断点时这是不可能的。其次，这个脚本对任何试图使反汇编器不同步的尝试都具有免疫力，因为指令边界完全是基于指令指针的运行时值而不是静态反汇编分析来确定的。在介绍脚本调试功能的公告中^([[232](#ftn.CHP-25-FN-7)])，Hex-Rays
    展示了一个执行通用解包器任务的脚本，其鲁棒性要高得多。
- en: Import Table Reconstruction
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入表重建
- en: Once a binary has been de-obfuscated, analysis of that binary can begin. While
    we may never intend to execute the de-obfuscated program (in fact, we cannot execute
    that program if a snapshot was pulled directly into an IDA database), a program’s
    import table is almost always a valuable resource for developing an understanding
    of the program’s behavior.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦二进制文件被去混淆，就可以开始对该二进制文件进行分析。虽然我们可能永远不会意图执行去混淆的程序（实际上，如果直接将快照拉入 IDA 数据库，我们无法执行该程序），但一个程序的导入表通常是了解程序行为的一个宝贵资源。
- en: Under normal circumstances, IDA is able to parse a program’s import table as
    part of the file-loading process upon initial database creation. Unfortunately,
    in obfuscated programs, the only import table that IDA sees at load time belongs
    to the de-obfuscation component of the program. This import table typically contains
    a bare minimum of functions required to complete the de-obfuscation process. The
    most sophisticated obfuscators may generate empty import tables, in which case
    the de-obfuscation component must contain all of the code necessary to load libraries
    and resolve necessary functions on its own.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，IDA能够在创建初始数据库时，作为文件加载过程的一部分解析程序的导入表。不幸的是，在混淆程序中，IDA在加载时看到的唯一导入表属于程序的解混淆组件。这个导入表通常只包含完成解混淆过程所需的最基本的函数。最复杂的混淆器可能会生成空的导入表，在这种情况下，解混淆组件必须包含加载库和自行解析所需函数的所有必要代码。
- en: As for the binary that has been obfuscated, in most cases its import table has
    been obfuscated as well and is reconstructed, in some form, as part of the de-obfuscation
    process. The reconstruction process typically relies on newly de-obfuscated data
    in order to perform its own library loading and function address resolution. For
    Windows programs, this nearly always involves calls to the `LoadLibrary` function
    combined with repeated calls to `GetProcAddress` to resolve required function
    addresses.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 至于被混淆的二进制文件，在大多数情况下，其导入表也被混淆，并在解混淆过程中以某种形式重建。重建过程通常依赖于新解混淆的数据来执行自己的库加载和函数地址解析。对于Windows程序，这几乎总是涉及到对`LoadLibrary`函数的调用，以及重复调用`GetProcAddress`来解析所需的函数地址。
- en: More sophisticated import table reconstruction routines may utilize custom lookup
    functions in place of `GetProcAddress` in order to avoid triggering any breakpoints
    set on `GetProcAddress` itself. Such routines may also substitute the use of hash
    values in place of strings for identifying which function’s address is being requested.
    In rare cases, import table reconstructors may go so far as to bypass `LoadLibrary`
    as well, in which case the reconstruction routine must implement its own custom
    version of that function.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的导入表重建例程可能会使用自定义查找函数代替`GetProcAddress`，以避免触发对`GetProcAddress`本身的任何断点设置。这些例程还可能用哈希值代替字符串来识别请求的是哪个函数的地址。在罕见的情况下，导入表重建器甚至可能绕过`LoadLibrary`，在这种情况下，重建例程必须实现该函数的自己的自定义版本。
- en: 'The net result of the import table reconstruction process is usually a table
    of function addresses, none of which have much meaning in a static analysis context.
    If we take a memory snapshot of a process, the best we are likely to come up with
    is something like the following partial listing:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 导入表重建过程的净结果是通常是一个函数地址表，在静态分析环境中，这些地址几乎都没有什么意义。如果我们对某个进程进行内存快照，我们可能得到的最好结果就像以下部分列表：
- en: '[PRE18]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This block of data depicts a number of 4-byte values, all in close proximity
    to one another and referenced from various locations with the program. The problem
    is that these values, such as `7C812F1Dh`, represent addresses of library functions
    as they were mapped in the process we were debugging. Within the code section
    of the program itself, we would see function calls similar to the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这块数据表示了一组紧密相邻的4字节值，这些值在程序中的多个位置被引用。问题是这些值，例如 `7C812F1Dh`，代表了在调试过程中映射的库函数的地址。在程序本身的代码部分，我们会看到类似以下的函数调用：
- en: '[PRE19]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that two of the function calls, ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) refer to the contents
    of the reconstructed import table, while a third function call ![](httpatomoreillycomsourcenostarchimages854093.png)
    refers to a function whose body is present in the database. In an ideal world,
    each entry in the reconstructed import table would be named after the function
    whose address it contains.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其中两个函数调用（![](httpatomoreillycomsourcenostarchimages854061.png) 和 ![](httpatomoreillycomsourcenostarchimages854063.png)）指的是重建的导入表的内容，而第三个函数调用
    ![](httpatomoreillycomsourcenostarchimages854093.png) 指的是数据库中存在的函数体。在理想的世界里，重建的导入表中的每一项都应该以包含其地址的函数命名。
- en: This problem is best addressed before taking a memory snapshot of the de-obfuscated
    process. As shown in the next listing, if we view the same memory range from within
    the debugger, we get an entirely different picture. Since the debugger has access
    to the memory regions in which each referenced function lies, the debugger is
    able to display addresses (such as `7C812F1Dh`) as their corresponding symbolic
    names (in this case `kernel32_GetCommandLineA`).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在对去混淆过程进行内存快照之前，最好解决此问题。如图所示，如果我们从调试器内部查看相同的内存范围，我们会得到一个完全不同的画面。由于调试器可以访问每个引用函数所在的内存区域，因此调试器能够显示地址（例如
    `7C812F1Dh`）及其对应的符号名称（在这种情况下为 `kernel32_GetCommandLineA`）。
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is worth noting at this point that the debugger adopts a slightly different
    naming scheme than we are accustomed to. The debugger prefixes all functions exported
    from shared libraries with the name of the associated library followed by an underscore.
    For example, the function `GetCommandLineA` in *kernel32.dll* is assigned the
    name `kernel32_GetCommandLineA`. This ensures that unique names are generated
    should two libraries export the same name.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，此时调试器采用的命名方案与我们习惯的略有不同。调试器将所有从共享库导出的函数名称前缀为关联库的名称，后跟一个下划线。例如，*kernel32.dll*
    中的函数 `GetCommandLineA` 被分配名称 `kernel32_GetCommandLineA`。这确保了如果两个库导出相同的名称，将生成唯一的名称。
- en: 'We need to overcome two problems with the import table shown in the preceding
    listing. First, in order for function calls to become more readable, we need to
    name each entry in the import table according to the function it references. If
    the entries are named properly, IDA will automatically display function signatures
    from its type libraries. Naming each import table entry is a relatively easy task
    as long as we have a name to assign. This leads to the second problem: obtaining
    the proper name. One approach is to parse the debugger-generated name, strip off
    the library name, and assign the remaining text as the name of the import table
    entry. The only problem with this approach is the fact that library names and
    function names may both contain underscore characters, making it difficult in
    some cases to determine the exact length of a function’s name within a longer
    name string. Recognizing this difficulty, this is nonetheless the approach taken
    by the *renimp.idc* import table–renaming script that ships with IDA (found in
    *<IDADIR>/idc*).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要克服前面列表中导入表的两个问题。首先，为了使函数调用更易于阅读，我们需要根据引用的函数为导入表中的每个条目命名。如果条目被正确命名，IDA 将自动从其类型库中显示函数签名。只要我们有名字可以分配，命名每个导入表条目相对容易。这导致第二个问题：获取正确的名称。一种方法是从调试器生成的名称中解析，去掉库名称，并将剩余的文本作为导入表条目的名称。这种方法唯一的问题是库名称和函数名称都可能包含下划线字符，这使在某些情况下难以确定较长名称字符串中函数名称的确切长度。认识到这个困难，尽管如此，这种方法仍然是随
    IDA 一起提供的 *renimp.idc* 导入表重命名脚本（位于 *<IDADIR>/idc*）所采用的方法。
- en: In order for this script to execute properly, it must be run while the debugger
    is active (so that it has access to loaded library names), and we must be able
    to locate the reconstructed import table within the de-obfuscated binary. One
    strategy for determining where the reconstructed import table will lie is to track
    calls to `GetProcAddress` and note where the results are stored into memory. [Example 25-3](ch25s03.html#upx_code_to_resolve_and_store_imported_f
    "Example 25-3. UPX code to resolve and store imported function addresses") shows
    the code used by UPX to call `GetProcAddress` and store the result.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此脚本正确执行，必须在调试器活动时运行它（以便它能够访问已加载的库名称），并且我们必须能够定位去混淆二进制文件中的重建导入表。确定重建导入表将位于何处的一种策略是跟踪对
    `GetProcAddress` 的调用，并注意结果存储到内存中的位置。[示例 25-3](ch25s03.html#upx_code_to_resolve_and_store_imported_f
    "示例 25-3. UPX 代码用于解析和存储导入函数地址") 展示了 UPX 用于调用 `GetProcAddress` 并存储结果的代码。
- en: Example 25-3. UPX code to resolve and store imported function addresses
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 25-3. UPX 代码用于解析和存储导入函数地址
- en: '[PRE21]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The call to `GetProcAddress` takes place at ![](httpatomoreillycomsourcenostarchimages854061.png),
    with the result being stored into memory at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Making note of the value held in the `ebx` register at ![](httpatomoreillycomsourcenostarchimages854063.png)
    will tell us where the import table is located. The `ebx` register is advanced
    by four bytes at ![](httpatomoreillycomsourcenostarchimages854093.png) to prepare
    it for the next iteration of the function resolution loop.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在![图片链接](http://atomoreilly.com/source/nostarch/images/854061.png)处发生对`GetProcAddress`的调用，结果存储在![图片链接](http://atomoreilly.com/source/nostarch/images/854063.png)处的内存中。在![图片链接](http://atomoreilly.com/source/nostarch/images/854063.png)处记录`ebx`寄存器中的值将告诉我们导入表的位置。在![图片链接](http://atomoreilly.com/source/nostarch/images/854093.png)处，`ebx`寄存器向前推进四个字节，为函数解析循环的下一迭代做准备。
- en: 'Once we have located the reconstructed import table, *renimp.idc* requires
    that we highlight the contents of the table using a click-and-drag operation from
    the beginning to the end of the table. The *renimp.idc* script iterates across
    the selection, obtains the name of the referenced function, strips the library
    name prefix, and names the import table entry accordingly. Following execution
    of this script, the import table shown previously is transformed into the import
    table shown here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了重建的导入表，*renimp.idc*要求我们通过从表头到表尾的点击和拖动操作突出显示表的内容。*renimp.idc*脚本遍历选择区域，获取引用函数的名称，移除库名称前缀，并相应地命名导入表条目。执行此脚本后，之前显示的导入表转换为以下导入表：
- en: '[PRE22]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We see that the script has done the work of renaming each import table entry,
    but IDA has added function prototypes for each function whose type information
    IDA is aware of. Note that no type information would be visible if the library
    name prefix had not been stripped from each function name. The *renimp.idc* script
    can fail to properly extract an imported function name when the name of the module
    in which the function resides contains an underscore. The ws2_32 networking library
    is a well-known example of a module whose name happens to contain an underscore.
    Special handling of ws2_32 takes place within *renimp.idc*; however, any other
    module whose name contains an underscore will cause *renimp.idc* to parse function
    names incorrectly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到脚本已经完成了每个导入表条目的重命名工作，但IDA为IDA所知的每个函数类型添加了函数原型。请注意，如果从每个函数名称中移除了库名称前缀，则不会显示任何类型信息。当函数所在的模块名称包含下划线时，`*renimp.idc*`脚本可能无法正确提取导入函数名称。`ws2_32`网络库是一个著名的例子，其名称恰好包含下划线。在`*renimp.idc*`中，对`ws2_32`的特殊处理发生；然而，任何名称包含下划线的其他模块都可能导致`*renimp.idc*`错误地解析函数名称。
- en: 'An alternative approach to renaming import table entries may be employed when
    a single instruction is responsible for storing all resolved function addresses
    as UPX does in [Example 25-3](ch25s03.html#upx_code_to_resolve_and_store_imported_f
    "Example 25-3. UPX code to resolve and store imported function addresses"). If
    such an instruction can be identified, such as the instruction at ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the listing, then we can take advantage of the fact that breakpoint conditions
    in IDA are specified using IDC statements. In this case we might set a conditional
    breakpoint at address `004088A1` and make the conditional expression invoke a
    function that we define. Here we name the function `createImportLabel` and define
    it as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个指令负责存储所有解析的函数地址时，例如[示例25-3](ch25s03.html#upx_code_to_resolve_and_store_imported_f
    "示例25-3. UPX代码解析和存储导入函数地址")中UPX所做的那样，可以采用重命名导入表条目的另一种方法。如果可以识别出这样的指令，例如列表中的![图片链接](http://atomoreilly.com/source/nostarch/images/854063.png)处的指令，那么我们可以利用IDA中断点条件使用IDC语句指定的这一事实。在这种情况下，我们可以在地址`004088A1`处设置一个条件断点，并使条件表达式调用我们定义的函数。在这里，我们命名该函数为`createImportLabel`，并定义如下：
- en: '[PRE23]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function begins by querying for the name referenced by EAX. Recall that
    EAX contains the result of the call to `GetProcAddress` and thus should refer
    to a function within some DLL. Next, the function loops to truncate the name to
    just that portion following the last underscore found in the original name. Finally,
    a series of function calls is made to properly format the target location (referenced
    by EBX) as a 4-byte data item, and apply a name to that location. By returning
    zero, the function informs IDA that the breakpoint should not be honored, with
    the result that execution continues without pausing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先查询由EAX引用的名称。回想一下，EAX包含对`GetProcAddress`的调用结果，因此应该指向某个DLL中的函数。接下来，函数循环以截断名称，只保留原始名称中找到的最后一个下划线之后的那个部分。最后，通过一系列函数调用，将目标位置（由EBX引用）正确格式化为一个4字节数据项，并给该位置应用一个名称。通过返回零，函数通知IDA该断点不应被尊重，结果是执行继续而不会暂停。
- en: 'In [Chapter 24](ch24.html "Chapter 24. The IDA Debugger"), we discussed how
    to specify breakpoint conditions in IDA’s debugger. Installing a user-defined
    function as a breakpoint handler is not quite as straightforward as setting and
    editing a breakpoint and entering `createImportLabel()` as the breakpoint condition.
    While this is exactly the condition that we wish to enter in this case, the problem
    is that, from IDA’s perspective, `createImportLabel` is an undefined function.
    The workaround for this is to create a script file (IDC by definition) containing
    our function along with a simple `main` function that looks something like the
    following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第24章](ch24.html "第24章。IDA调试器")中，我们讨论了如何在IDA的调试器中指定断点条件。将用户定义的函数作为断点处理程序安装并不像设置和编辑断点以及将`createImportLabel()`作为断点条件那样简单直接。虽然这正是我们希望在此情况下输入的条件，但问题是，从IDA的角度来看，`createImportLabel`是一个未定义的函数。解决这个问题的方法是创建一个包含我们的函数以及一个简单的`main`函数的脚本文件（IDC按定义），该`main`函数看起来如下所示：
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Placing the cursor on the instruction that you wish to set the breakpoint on
    and then running this script (File ▸ Script File) results in a conditional breakpoint
    that calls `createImportLabel` each time it is hit. The `AddBpt` function ![](httpatomoreillycomsourcenostarchimages854061.png)
    adds a breakpoint at the specified location (the cursor location in this case),
    and the `SetBptCnd` function ![](httpatomoreillycomsourcenostarchimages854063.png)
    adds a condition to an existing breakpoint. The condition is specified as a string
    containing the IDC statement to evaluate each time the breakpoint is hit. With
    this breakpoint in place, once the de-obfuscation has completed, we will have
    a labeled import table without having to go through the trouble of locating the
    table within the process’s memory space.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将光标放在你想要设置断点的指令上，然后运行此脚本（文件 ▸ 脚本文件），结果是在每次命中时调用`createImportLabel`的条件断点。`AddBpt`函数
    ![](httpatomoreillycomsourcenostarchimages854061.png) 在指定位置（在这种情况下是光标位置）添加一个断点，而`SetBptCnd`函数
    ![](httpatomoreillycomsourcenostarchimages854063.png) 向现有的断点添加一个条件。条件被指定为一个字符串，包含每次断点命中时评估的IDC语句。有了这个断点，一旦反混淆完成，我们就不必费心在进程的内存空间中定位表，就可以拥有一个带有标签的导入表。
- en: Yet another approach for deriving name information involves searching memory
    for the file headers associated with a function address and then parsing the export
    table described in those headers to locate the name of the function being referenced.
    This is essentially a reverse lookup of a function name given the function’s address.
    Scripts (*RebuildImports.idc/RebuildImports.py*) based on this concept are available
    on the book’s website. Either of these scripts may be executed in lieu of *renimp.idc*
    with nearly identical results. The problems faced by *renimp.idc* when dealing
    with modules whose names contain an underscore character are avoided because function
    names are extracted directly from export tables present in the process address
    space.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取名称信息的方法是搜索与函数地址关联的文件头，然后解析这些头文件中描述的导出表以找到引用的函数名称。这本质上是在给定函数地址的情况下对函数名称的反向查找。基于这个概念编写的脚本（*RebuildImports.idc/RebuildImports.py*）可在本书的网站上找到。这两个脚本中的任何一个都可以替代*renimp.idc*执行，几乎得到相同的结果。*renimp.idc*在处理包含下划线字符的模块名称时遇到的问题被避免了，因为函数名称是直接从进程地址空间中存在的导出表中提取的。
- en: 'The effect of naming each import table entry properly carries through to the
    disassembly itself, as shown in the following automatically updated disassembly
    listing:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 正确命名每个导入表条目的效果会传递到反汇编本身，如下面的自动更新的反汇编列表所示：
- en: '[PRE25]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The name of each renamed import table entry is propagated to all locations from
    which imported functions are called, making the disassembly far more readable.
    It is worth noting that any formatting changes that you make while you’re working
    within the debugger are automatically applied to the database view as well. In
    other words, there is no need to take a memory snapshot simply to capture formatting
    changes that you have made. The purpose of a memory snapshot is to migrate memory
    content (code and data) from a processes address space back into an IDA database.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 每个重命名导入表条目的名称都会传播到所有调用导入函数的位置，这使得反汇编代码更加易于阅读。值得注意的是，你在调试器内进行的工作中的任何格式更改都会自动应用到数据库视图中。换句话说，你不需要仅仅为了捕获所做的格式更改而采取内存快照。内存快照的目的是将进程地址空间中的内存内容（代码和数据）迁移回IDA数据库。
- en: Hiding the Debugger
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏调试器
- en: A popular method of preventing the use of debuggers as de-obfuscation tools
    is *debugger detection*. The authors of obfuscation tools understand just as well
    as you do that debuggers are useful for undoing their handiwork. In response,
    they often take measures to prevent their tools from running if the tools detect
    the presence of a debugger. We discussed a few debugger-detection methods in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis"). As mentioned in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis"), Nicolas Falliere’s article “Windows Anti-Debug
    Reference”^([[233](#ftn.CHP-25-FN-8)]) contains an excellent summary of a number
    of Windows-specific techniques for detecting the presence of a debugger. You can
    counter several of these detection techniques by using a simple script to start
    your debugger session and automatically configure some breakpoints. While it is
    possible to use Python to counter some of these techniques, we will ultimately
    be using conditional breakpoints, which we can only specify using IDC. For this
    reason the sample code that follows is all written in IDC.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 防止使用调试器作为去混淆工具的一种流行方法是*调试器检测*。混淆工具的作者就像你一样明白调试器对于撤销他们的工作是有用的。作为回应，他们通常会采取措施防止他们的工具在检测到调试器的情况下运行。我们在[第21章](ch21.html
    "第21章。混淆代码分析")中讨论了几种调试器检测方法。正如[第21章](ch21.html "第21章。混淆代码分析")中提到的，Nicolas Falliere的文章“Windows
    Anti-Debug Reference”^([[233](#ftn.CHP-25-FN-8)])对许多针对Windows的检测调试器存在的技术进行了很好的总结。你可以通过使用一个简单的脚本来启动你的调试器会话并自动配置一些断点来对抗这些检测技术。虽然可以使用Python来对抗这些技术中的一些，但我们将最终使用条件断点，这只能使用IDC来指定。因此，以下示例代码都是用IDC编写的。
- en: 'In order to launch a debugging session from a script, we begin with the following
    code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从脚本中启动调试会话，我们首先编写以下代码：
- en: '[PRE26]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These statements check for the presence of a TLS callback function, set a breakpoint
    if one is found, and then launch the debugger, requesting to break on the entry
    point address before waiting for the operation to complete (strictly speaking,
    we should test the return value of `GetDebuggerEvent` as well). Once our script
    regains control, we have an active debugger session, and the process we wish to
    debug is mapped into memory along with all libraries on which it depends.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句检查TLS回调函数的存在，如果找到则设置断点，然后启动调试器，在等待操作完成之前请求在入口点地址处中断（严格来说，我们还应该测试`GetDebuggerEvent`的返回值）。一旦我们的脚本恢复控制，我们就有一个活动的调试器会话，我们想要调试的进程及其依赖的所有库都会映射到内存中。
- en: 'The first debugger detection we will bypass is the `IsDebugged` field of the
    process environment block (PEB). This is a 1-byte field that is set to the value
    1 if the process is being debugged and 0 otherwise. The field lies 2 bytes into
    the PEB, so all we need to do is find the PEB and patch the proper byte to the
    value 0\. This also happens to be the field tested by the Windows API function
    `IsDebuggerPresent`, so we manage to kill two birds with one stone in this case.
    If we know that we have stopped at the program entry point as opposed to a TLS
    callback, then locating the PEB turns out to be rather simple, because the EBX
    register contains a pointer to the PEB upon entry to the process. If instead the
    process has stopped at a TLS callback function, then we need a more general-purpose
    means of finding the PEB. We will take an approach similar to that often used
    in shellcode and obfuscators. The basic idea is to locate the current *thread
    information block (TIB)*^([[234](#ftn.CHP-25-FN-9)]) and follow an embedded pointer
    to find the PEB. The following code locates the PEB and makes the appropriate
    patch:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绕过的第一个调试器检测是进程环境块（PEB）中的 `IsDebugged` 字段。这是一个1字节字段，如果进程正在被调试，则设置为值1，否则为0。该字段位于PEB的2字节处，因此我们只需要找到PEB并修补适当的字节为值0。这也恰好是Windows
    API函数 `IsDebuggerPresent` 测试的字段，因此在这种情况下我们一石二鸟。如果我们知道我们已经停止在程序入口点而不是TLS回调中，那么定位PEB就变得相当简单，因为EBX寄存器在进程进入时包含对PEB的指针。如果进程停止在TLS回调函数中，那么我们需要一种更通用的方法来找到PEB。我们将采取类似于在shellcode和混淆器中经常使用的方法。基本思想是定位当前的
    *线程信息块（TIB）*^([[234](#ftn.CHP-25-FN-9)]) 并跟随一个嵌入的指针找到PEB。以下代码定位PEB并执行适当的修补：
- en: '[PRE27]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the `PatchDbgByte` function was not introduced until IDA 5.5\. When
    used with versions prior to IDA 5.5, `PatchByte` will work but will also modify
    (patch) the database if the address specified is present in the database.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PatchDbgByte` 函数是在 IDA 5.5 版本中引入的。当与 IDA 5.5 之前的版本一起使用时，`PatchByte` 将会工作，但如果指定的地址存在于数据库中，它也会修改（修补）数据库。
- en: Another anti-debugging technique mentioned in Falliere’s article involves testing
    several bits in another field of the PEB named `NtGlobalFlags`. The bits relate
    to the operation of a process’s heap and are set to 1 when a process is being
    debugged. Assuming variable `peb` remains set from the previous example, the following
    code retrieves the `NtGlobalFlags` field from the PEB, resets the offending bits,
    and stores the flags back into the PEB.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Falliere 文章中提到的另一种反调试技术涉及测试PEB中名为 `NtGlobalFlags` 的另一个字段中的几个位。这些位与进程堆的运行相关，当进程正在被调试时设置为1。假设变量
    `peb` 从上一个示例中保持设置，以下代码从PEB中检索 `NtGlobalFlags` 字段，重置有问题的位，并将标志存储回PEB。
- en: '[PRE28]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Several techniques in Falliere’s article rely on differences in information
    returned by system functions when a process is being debugged as opposed to when
    a process is not being debugged. The first function mentioned in the article is
    `NtQueryInformationProcess`, found in *ntdll.dll*. Using this function, a process
    may request information regarding its *ProcessDebugPort*. If the process is being
    debugged, the result is non-zero; if it is not being debugged, the result should
    be zero. One way to avoid detection in this manner is to set a breakpoint on `NtQueryInformationProcess`
    and then specify a breakpoint condition function to filter out `ProcessDebugPort`
    requests. In order to automatically locate this instruction, we take the following
    steps:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Falliere 文章中提到的几种技术依赖于系统函数在调试进程时返回的信息差异，与未调试进程时返回的信息差异。文章中提到的第一个函数是 `NtQueryInformationProcess`，位于
    `ntdll.dll` 中。使用此函数，进程可以请求有关其 `ProcessDebugPort` 的信息。如果进程正在被调试，则结果非零；如果未调试，则结果应为零。避免以这种方式检测的一种方法是在
    `NtQueryInformationProcess` 上设置断点，然后指定一个断点条件函数来过滤掉 `ProcessDebugPort` 请求。为了自动定位此指令，我们采取以下步骤：
- en: Look up the address of `NtQueryInformationProcess`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `NtQueryInformationProcess` 的地址。
- en: Set a breakpoint on `NtQueryInformationProcess`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NtQueryInformationProcess` 上设置断点。
- en: Add a breakpoint condition to call a function we will name `bpt_NtQueryInformationProcess`,
    which will be executed each time `NtQuery-InformationProcess` gets called.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个断点条件来调用我们将命名的函数 `bpt_NtQueryInformationProcess`，该函数将在每次调用 `NtQuery-InformationProcess`
    时执行。
- en: 'In order to find the address of `NtQueryInformationProcess`, we need to remember
    that the function will be named `ntdll_NtQueryInformationProcess` in the debugger.
    The code to configure the necessary breakpoint appears here:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到`NtQueryInformationProcess`的地址，我们需要记住在调试器中该函数将被命名为`ntdll_NtQueryInformationProcess`。配置必要的断点的代码如下：
- en: '[PRE29]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What remains is for us to implement the breakpoint function that will keep
    the debugger hidden from an inquiring process. The prototype for `NtQueryInformationProcess`
    is shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是为我们实现一个断点函数，该函数将使调试器对询问进程保持隐藏。`NtQueryInformationProcess`的原型如下所示：
- en: '[PRE30]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Information about a process is requested by providing an integer query identifier
    in the `ProcessInformationClass` parameter ![](httpatomoreillycomsourcenostarchimages854061.png).
    Information is returned via the user-supplied buffer pointed to by the `ProcessInformation`
    parameter ![](httpatomoreillycomsourcenostarchimages854063.png). A caller may
    pass the enumerated constant `ProcessDebugPort` (value 7) in order to query the
    debugging status of a given process. If a process is being debugged by a user-space
    debugger, the return value passed via the supplied pointer will be non-zero. If
    the process is not being debugged, the return value will be zero. A breakpoint
    function that always sets the `ProcessDebugPort` return value to zero is shown
    here:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`ProcessInformationClass`参数中提供一个整数查询标识符来请求进程信息 ![图片链接](httpatomoreillycomsourcenostarchimages854061.png)。信息通过由`ProcessInformation`参数指向的用户提供的缓冲区返回
    ![图片链接](httpatomoreillycomsourcenostarchimages854063.png)。调用者可以通过传递枚举常量`ProcessDebugPort`（值为7）来查询给定进程的调试状态。如果进程正在由用户空间调试器调试，则通过提供的指针传递的返回值将非零。如果进程没有被调试，则返回值将为零。以下是一个始终将`ProcessDebugPort`返回值设置为零的断点函数示例：
- en: '[PRE31]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Recall that this function is invoked each time `NtQueryInformationProcess` is
    called. On entry, the stack pointer is pointing to the saved return address, which
    lies on top of the five arguments to `NtQueryInformationProcess`. The breakpoint
    function begins by examining the value of the `ProcessInformation-Class` to determine
    whether the caller is requesting `ProcessDebugPort` information ![](httpatomoreillycomsourcenostarchimages854061.png).
    If the caller is requesting `ProcessDebugPort`, the function continues by retrieving
    the return value pointer ![](httpatomoreillycomsourcenostarchimages854063.png),
    testing that it is non-null ![](httpatomoreillycomsourcenostarchimages854093.png),
    and finally storing a return value of zero ![](httpatomoreillycomsourcenostarchimages854095.png)
    to make it appear that no debugger is attached. In order to skip the remainder
    of the function, EIP is then modified by reading the saved return address ![](httpatomoreillycomsourcenostarchimages854099.png),
    after which ESP is adjusted to simulate a `stdcall` return ![](httpatomoreillycomsourcenostarchimages854101.png).
    `NtQueryInformationProcess` returns an NTSTATUS code, which is set to 0 (success)
    at ![](httpatomoreillycomsourcenostarchimages854103.png) before returning.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每次调用`NtQueryInformationProcess`时都会调用此函数。进入时，栈指针指向保存的返回地址，该地址位于`NtQueryInformationProcess`的五个参数之上。断点函数首先检查`ProcessInformation-Class`的值以确定调用者是否请求`ProcessDebugPort`信息
    ![图片链接](httpatomoreillycomsourcenostarchimages854061.png)。如果调用者请求`ProcessDebugPort`，函数将继续通过检索返回值指针
    ![图片链接](httpatomoreillycomsourcenostarchimages854063.png)，检查它是否非空 ![图片链接](httpatomoreillycomsourcenostarchimages854093.png)，并最终将返回值存储为零
    ![图片链接](httpatomoreillycomsourcenostarchimages854095.png)，使其看起来没有调试器附加。为了跳过函数的其余部分，然后通过读取保存的返回地址
    ![图片链接](httpatomoreillycomsourcenostarchimages854099.png) 修改EIP，之后调整ESP以模拟`stdcall`返回
    ![图片链接](httpatomoreillycomsourcenostarchimages854101.png)。"NtQueryInformationProcess"返回一个NTSTATUS代码，在返回之前将其设置为0（成功）![图片链接](httpatomoreillycomsourcenostarchimages854103.png)。
- en: 'Another function mentioned in Falliere’s article is `NtSetInformation-Thread`,
    which is also found in *ntdll.dll*. The prototype for this function is shown here:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Falliere文章中提到的另一个函数是`NtSetInformation-Thread`，它也位于`ntdll.dll`中。此函数的原型如下所示：
- en: '[PRE32]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The anti-debugging technique involves passing the value `ThreadHideFromDebugger`
    in the `ThreadInformationClass` parameter, which causes a thread to be detached
    from a debugger. Bypassing this technique involves the same basic setup as the
    previous example. The resulting setup code is shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试技术涉及在`ThreadInformationClass`参数中传递`ThreadHideFromDebugger`的值，这将导致线程从调试器中分离。绕过此技术涉及与上一个示例相同的基本设置。结果设置代码如下：
- en: '[PRE33]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The associated breakpoint function is shown here:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的断点函数如下所示：
- en: '[PRE34]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On entry we test the value of the `ThreadInformationClass` parameter ![](httpatomoreillycomsourcenostarchimages854061.png)
    and bypass the function body if the user has specified `ThreadHideFromDebugger`.
    Bypassing the function body is accomplished by setting our desired return value
    ![](httpatomoreillycomsourcenostarchimages854063.png) and modifying the instruction
    pointer by reading the saved return address out of the stack ![](httpatomoreillycomsourcenostarchimages854093.png).
    We simulate the `stdcall` return by making a 20-byte adjustment to ESP ![](httpatomoreillycomsourcenostarchimages854095.png).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入时，我们测试`ThreadInformationClass`参数的值 ![图片链接](http://atomoreilly.com/source/nostarch/images/854061.png)，如果用户指定了`ThreadHideFromDebugger`，则绕过函数体。绕过函数体是通过设置我们期望的返回值
    ![图片链接](http://atomoreilly.com/source/nostarch/images/854063.png) 并通过从堆栈中读取保存的返回地址来修改指令指针
    ![图片链接](http://atomoreilly.com/source/nostarch/images/854093.png)。我们通过调整ESP 20个字节来模拟`stdcall`返回
    ![图片链接](http://atomoreilly.com/source/nostarch/images/854095.png)。
- en: 'The last function that we will discuss, whose use as an anti-debugging technique
    is also discussed in Falliere’s article, is `OutputDebugStringA` from *kernel32.dll*.
    The prototype of this function is shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个函数，其作为反调试技术的使用也在Falliere的文章中讨论过，是来自`kernel32.dll`的`OutputDebugStringA`。此函数的原型如下所示：
- en: '[PRE35]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, `WINAPI` is a synonym for `_stdcall` and is used to specify
    the calling convention employed by `OutputDebugStringA`. Strictly speaking, this
    function has no return value, as specified by the `void` return type in its prototype;
    however, according to the article, this function “returns” 1 when no debugger
    is attached to the calling process, and it “returns” the address of the string
    passed as a parameter if it is called while a debugger is attached to the calling
    process. Under normal circumstances, `_stdcall` functions that do return a value
    return that value in the EAX register. Since EAX must hold some value when `OutputDebugStringA`
    returns, it can be argued that this is the return value of the function; however,
    since the official return type is `void`, there is no documentation or guarantee
    as to what value EAX may actually hold in this case. This particular anti-debugging
    technique simply relies on the observed behavior of the function. One solution
    to the observed change in return values is to ensure that EAX contains 1 whenever
    `OutputDebugStringA` returns. The following IDC code implements this technique:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`WINAPI`是`_stdcall`的同义词，用于指定`OutputDebugStringA`使用的调用约定。严格来说，此函数没有返回值，如其原型中指定的`void`返回类型；然而，根据文章，当没有调试器附加到调用进程时，此函数“返回”1，如果调用进程附加了调试器，则“返回”作为参数传递的字符串的地址。在正常情况下，返回值的`_stdcall`函数将返回值放在EAX寄存器中。由于`OutputDebugStringA`返回时EAX必须持有某个值，因此可以认为这是函数的返回值；然而，由于官方返回类型是`void`，没有文档或保证说明在这种情况下EAX可能实际持有的值。这种特定的反调试技术仅依赖于函数观察到的行为。解决观察到的返回值变化的一种方法是确保在`OutputDebugStringA`返回时EAX包含1。以下IDC代码实现了这种技术：
- en: '[PRE36]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example uses the same technique for automatically locating the end of the
    `OutputDebugStringA` function that we used in the preceding examples. However,
    in contrast to the preceding example, the work that needs to be done when the
    breakpoint is hit is simple enough to be specified in an IDC expression ![](httpatomoreillycomsourcenostarchimages854061.png)
    (rather than requiring a dedicated function). In this case, the breakpoint expression
    modifies (note this is assignment rather than comparison) the EAX register to
    ensure that it contains 1 when the function returns and also adjusts EIP and ESP
    to bypass the function. The breakpoint condition is negated to cause the breakpoint
    to be skipped in all cases, because the result of the Boolean *and* expression
    is always expected to be nonzero.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用与前面示例相同的技巧来自动定位`OutputDebugStringA`函数的结尾。然而，与前面的示例相比，当遇到断点时需要完成的工作足够简单，可以指定在IDC表达式中
    ![图片链接](http://atomoreilly.com/source/nostarch/images/854061.png)（而不是需要一个专用函数）。在这种情况下，断点表达式修改（注意这是赋值而不是比较）EAX寄存器，以确保函数返回时它包含1，并调整EIP和ESP以绕过函数。断点条件被否定，以导致在所有情况下跳过断点，因为布尔*与*表达式的结果始终预期不为零。
- en: A script (*HideDebugger.idc*) that combines all of the elements presented in
    this section into a useful tool for simultaneously initiating debugging sessions
    and implementing measures to combat anti-debugging attempts is available on the
    book’s website. For more information on hiding the presence of the debugger, please
    see Ilfak’s blog, where he presents several hiding techniques.^([[235](#ftn.CHP-25-FN-10)])
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一段脚本(*HideDebugger.idc*)，它将本节中展示的所有元素组合成一个有用的工具，可以同时启动调试会话并实施对抗反调试尝试的措施，可在本书的网站上找到。有关隐藏调试器存在的信息，请参阅Ilfak的博客，他在博客中介绍了几种隐藏技术.^([[235](#ftn.CHP-25-FN-10)])
- en: '* * *'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[230](#CHP-25-FN-5)]) Keep in mind that the software breakpoint instruction
    inserted by the debugger will cause the checksum computation to yield a result
    other than the expected result.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[230](#CHP-25-FN-5)]) 请记住，调试器插入的软件断点指令会导致校验和计算的结果不是预期的结果。
- en: ^([[231](#CHP-25-FN-6)]) For more information on Thread Local Storage (TLS)
    callback functions, please refer to the PE file format specification [http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx](http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[231](#CHP-25-FN-6)]) 有关线程局部存储 (TLS) 回调函数的更多信息，请参阅PE文件格式规范[http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx](http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx)。
- en: ^([[232](#CHP-25-FN-7)]) See [http://www.hex-rays.com/idapro/scriptable.htm](http://www.hex-rays.com/idapro/scriptable.htm).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[232](#CHP-25-FN-7)]) 请参阅[http://www.hex-rays.com/idapro/scriptable.htm](http://www.hex-rays.com/idapro/scriptable.htm)。
- en: ^([[233](#CHP-25-FN-8)]) See [http://www.symantec.com/connect/articles/windows-anti-debug-reference/](http://www.symantec.com/connect/articles/windows-anti-debug-reference/).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[233](#CHP-25-FN-8)]) 请参阅[http://www.symantec.com/connect/articles/windows-anti-debug-reference/](http://www.symantec.com/connect/articles/windows-anti-debug-reference/)。
- en: ^([[234](#CHP-25-FN-9)]) This is also known as a *thread environment block (TEB)*.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[234](#CHP-25-FN-9)]) 这也被称为*线程环境块 (TEB)*。
- en: ^([[235](#CHP-25-FN-10)]) See [http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html](http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html),
    [http://www.hexblog.com/2005/11/stealth_plugin_1.html](http://www.hexblog.com/2005/11/stealth_plugin_1.html),
    and [http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html](http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[235](#CHP-25-FN-10)]) 请参阅[http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html](http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html)、[http://www.hexblog.com/2005/11/stealth_plugin_1.html](http://www.hexblog.com/2005/11/stealth_plugin_1.html)和[http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html](http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html)。
- en: IdaStealth
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IdaStealth
- en: While the *HideDebugger* script discussed in the previous section is useful
    for demonstrating some basic programmatic interaction with the debugger and some
    basics of library function hooking, the total number of known anti-debugging techniques
    and the complexity of those techniques argue for more robust anti-anti-debugging
    than can be provided by a simple script. Fortunately, the IdaStealth plug-in is
    designed to meet our needs for a power debugger-hiding capability. Written by
    Jan Newger, IdaStealth was the winner of Hex-Rays’s 2009 plug-in writing contest.
    The plug-in is written in C++ and is available in both source and binary form.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一节中讨论的*HideDebugger*脚本对于演示与调试器的某些基本程序性交互和库函数钩子的一些基础知识很有用，但已知反调试技术的总数和这些技术的复杂性表明，需要比简单脚本提供的更强大的反反调试功能。幸运的是，IdaStealth插件旨在满足我们对强大调试器隐藏功能的需求。由Jan
    Newger编写的IdaStealth是Hex-Rays 2009插件编写大赛的获奖作品。该插件是用C++编写的，并提供源代码和二进制形式。
- en: '| **Name** | IDAStealth |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | IDAStealth |'
- en: '| **Author** | Jan Newger |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Jan Newger |'
- en: '| **Distribution** | C++Source and binary |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | C++源代码和二进制 |'
- en: '| **Price** | Free |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | Windows debugger-hiding plug-in |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | Windows调试器隐藏插件 |'
- en: '| **Information** | [http://www.newgre.net/idastealth/](http://www.newgre.net/idastealth/)
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://www.newgre.net/idastealth/](http://www.newgre.net/idastealth/)
    |'
- en: The binary components of IDAStealth consist of a plug-in and a helper library,
    both of which need to be installed to *<IDADIR>/plugins*. Upon initial activation,
    IDAStealth presents the configuration dialog shown in [Figure 25-6](ch25s04.html#idastealth_configuration_dialog
    "Figure 25-6. IDAStealth configuration dialog").
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: IDAStealth的二进制组件包括一个插件和一个辅助库，这两个组件都需要安装到*<IDADIR>/plugins*目录下。在首次激活时，IDAStealth会显示如图[图25-6](ch25s04.html#idastealth_configuration_dialog
    "图25-6. IDAStealth配置对话框")所示的配置对话框。
- en: '![IDAStealth configuration dialog](httpatomoreillycomsourcenostarchimages854408.png.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![IDAStealth配置对话框](httpatomoreillycomsourcenostarchimages854408.png.jpg)'
- en: Figure 25-6. IDAStealth configuration dialog
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-6. IDAStealth配置对话框
- en: Several tabs full of options allow you to decide which anti-anti-debugging techniques
    you wish to employ. Once activated, IDAStealth implements evasion techniques for
    virtually every known debugger-detection technique, including those discussed
    in the Falliere article and those addressed by the *HideDebugger.idc* script developed
    earlier.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 几个选项卡充满了选项，允许你决定你想采用哪些反反调试技术。一旦激活，IDAStealth将实现几乎所有已知的调试器检测技术的规避技术，包括在Falliere文章中讨论的以及由之前开发的*HideDebugger.idc*脚本解决的问题。
- en: Dealing with Exceptions
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: Occasionally, programs expect to handle any exceptions generated during their
    execution. As we saw in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis"),
    obfuscated programs often go so far as to intentionally generate exceptions as
    both an anti–control flow technique and an anti-debugging technique. Unfortunately,
    exceptions are often indicative of a problem, and the purpose of debuggers is
    to assist us in localizing problems. Therefore, debuggers typically want to handle
    all exceptions that occur when a program is running in order to help us find bugs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序期望处理在执行过程中产生的任何异常。正如我们在[第21章](ch21.html "第21章. 代码混淆分析")中看到的，混淆程序往往会故意生成异常，作为反控制流技术和反调试技术的手段。不幸的是，异常通常表明存在问题，而调试器的目的是帮助我们定位问题。因此，调试器通常希望处理程序运行时发生的所有异常，以帮助我们找到错误。
- en: When a program expects to handle its own exceptions, we need to prevent the
    debugger from intercepting such exceptions, or, at a minimum, once an exception
    is intercepted, we need a means to have the debugger forward the exception to
    the process at our discretion. Fortunately, IDA’s debugger has the capability
    to pass along individual exceptions as they occur or to automatically pass along
    all exceptions of a specified type.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序期望处理自己的异常时，我们需要防止调试器拦截这些异常，或者至少，一旦异常被拦截，我们需要一种方法让调试器能够根据我们的意愿将异常转发给进程。幸运的是，IDA的调试器具有在异常发生时传递单个异常或自动传递指定类型所有异常的能力。
- en: Automated exception processing is configured via the Debugger ▸ Debugger Options
    command; the resulting dialog is shown in [Figure 25-7](ch25s05.html#the_debugger_setup_dialog
    "Figure 25-7. The Debugger Setup dialog").
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 自动异常处理通过“调试器”>>“调试器选项”命令进行配置；生成的对话框如图[图25-7](ch25s05.html#the_debugger_setup_dialog
    "图25-7. 调试器设置对话框")所示。
- en: '![The Debugger Setup dialog](httpatomoreillycomsourcenostarchimages854411.png.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![调试器设置对话框](httpatomoreillycomsourcenostarchimages854411.png.jpg)'
- en: Figure 25-7. The Debugger Setup dialog
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-7. 调试器设置对话框
- en: In addition to allowing several events to be configured to automatically stop
    the debugger and a number of events to be automatically logged to IDA’s message
    window, the Debugger Setup dialog is used to configure the debugger’s exception-handling
    behavior. The Edit Exceptions button opens the Exceptions configuration dialog
    shown in [Figure 25-8](ch25s05.html#the_exceptions_configuration_dialog "Figure 25-8. The
    Exceptions configuration dialog").
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许配置多个事件以自动停止调试器以及将多个事件自动记录到IDA的消息窗口外，调试器设置对话框还用于配置调试器的异常处理行为。点击“编辑异常”按钮将打开如图[图25-8](ch25s05.html#the_exceptions_configuration_dialog
    "图25-8. 异常配置对话框")所示的异常配置对话框。
- en: '![The Exceptions configuration dialog](httpatomoreillycomsourcenostarchimages854414.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![异常配置对话框](httpatomoreillycomsourcenostarchimages854414.png)'
- en: Figure 25-8. The Exceptions configuration dialog
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-8. 异常配置对话框
- en: For each exception type known to the debugger, the dialog lists an operating
    system–specific exception code, the name of the exception, whether the debugger
    will stop the process or not (`Stop/No`), and whether the debugger will handle
    the exception or automatically pass the exception to the application (`Debugger/Application`).
    A master list of exceptions and default settings for handling each exception is
    contained in *<IDADIR>/cfg/exceptions.cfg*. In addition, the configuration file
    contains messages to be displayed whenever an exception of a given type occurs
    while the debugger is executing a process. Changes to the debugger’s default exception-handling
    behavior may be made by editing *exceptions.cfg* with a text editor. In *exceptions.cfg*,
    the values `stop` and `nostop` are used to indicate whether the debugger should
    suspend the process or not when a given exception occurs.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试器所知的每种异常类型，对话框列出了操作系统特定的异常代码、异常的名称、调试器是否会停止进程（`停止/否`），以及调试器是否会处理异常或自动将异常传递给应用程序（`调试器/应用程序`）。异常的主列表和每种异常的处理默认设置包含在`*<IDADIR>/cfg/exceptions.cfg*`中。此外，配置文件还包含在调试器执行进程时发生特定类型异常时要显示的消息。可以通过使用文本编辑器编辑`exceptions.cfg`来更改调试器的默认异常处理行为。在`exceptions.cfg`中，`stop`和`nostop`值用于指示当发生特定异常时，调试器是否应该挂起进程。
- en: Exception handling may also be configured on a persession (that is, while you
    have a particular database open) basis by editing individual exceptions via the
    Exceptions configuration dialog. To modify the debugger’s behavior for a given
    exception type, right-click the desired exception in the Exceptions configuration
    dialog and select **Edit**. [Figure 25-9](ch25s05.html#the_exception_editing_dialog
    "Figure 25-9. The Exception editing dialog") shows the resulting Exception editing
    dialog.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理也可以通过编辑异常配置对话框中的单个异常来在会话级别（即，当你打开特定数据库时）进行配置。要修改调试器对特定异常类型的处理行为，请在异常配置对话框中右键单击所需的异常，然后选择**编辑**。[图25-9](ch25s05.html#the_exception_editing_dialog
    "图25-9. 异常编辑对话框")显示了生成的异常编辑对话框。
- en: '![The Exception editing dialog](httpatomoreillycomsourcenostarchimages854417.png.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![异常编辑对话框](httpatomoreillycomsourcenostarchimages854417.png.jpg)'
- en: Figure 25-9. The Exception editing dialog
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-9. 异常编辑对话框
- en: 'Two options, corresponding to the two configurable options in *exceptions.cfg*,
    may be configured for any exception. First, it is possible to specify whether
    the debugger should stop the process when an exception of the specified type occurs
    or whether execution should continue. Beware: Allowing the process to continue
    may result in an infinite exception-generation loop if you also elect to have
    the debugger handle the exception.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选项，对应于`*exceptions.cfg*`中的两个可配置选项，可以为任何异常进行配置。首先，可以指定当发生指定类型的异常时，调试器是否应该停止进程，或者是否应该继续执行。请注意：如果同时选择让调试器处理异常，允许进程继续可能会导致无限循环的异常生成。
- en: The second configuration option allows you to decide whether a given exception
    type should be passed to the application being debugged so the application can
    have a chance to process the exception using its own exception handlers. When
    the proper operation of an application depends on such exception handlers being
    executed, you should choose to pass the associated exception types to the application.
    This may be required when analyzing obfuscated code such as that generated by
    the tElock utility (which registers its own exception handlers) described in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis").
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个配置选项允许你决定是否应该将给定的异常类型传递给正在调试的应用程序，以便应用程序有机会使用自己的异常处理器来处理异常。当应用程序的正确操作依赖于执行这些异常处理器时，你应该选择将相关的异常类型传递给应用程序。这在分析如tElock实用程序（该实用程序注册了自己的异常处理器）生成的混淆代码时可能需要（如第21章[混淆代码分析](ch21.html
    "第21章. 混淆代码分析")中所述）。
- en: Unless you have configured IDA to continue execution and to pass a specific
    exception type to the application, IDA will pause execution and report exceptions
    to you as they occur. If you elect to continue execution of the program, IDA will
    then display the Exception Handling dialog shown in [Figure 25-10](ch25s05.html#the_exception_handling_dialog
    "Figure 25-10. The Exception Handling dialog").
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你已配置IDA继续执行并将特定异常类型传递给应用程序，否则IDA将在异常发生时暂停执行并向你报告。如果你选择继续程序的执行，IDA将显示如图[图25-10](ch25s05.html#the_exception_handling_dialog
    "图25-10. 异常处理对话框")所示的异常处理对话框。
- en: '![The Exception Handling dialog](httpatomoreillycomsourcenostarchimages854420.png.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![异常处理对话框](httpatomoreillycomsourcenostarchimages854420.png.jpg)'
- en: Figure 25-10. The Exception Handling dialog
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-10. 异常处理对话框
- en: At this point you have the option of changing the manner in which IDA handles
    the given exception type (Change exception definition), passing the exception
    on to the application (Yes), or allowing IDA to eat the exception (No). Passing
    the exception to the application allows the application to handle the exception
    using any configured exception handlers. If you choose No, IDA attempts to continue
    execution, which is likely to fail unless you have corrected the condition that
    was responsible for causing the exception.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，你可以选择更改 IDA 处理给定异常类型的方式（更改异常定义），将异常传递给应用程序（是），或者允许 IDA 消耗异常（否）。将异常传递给应用程序允许应用程序使用任何配置的异常处理程序来处理异常。如果你选择否，IDA
    将尝试继续执行，除非你已纠正导致异常的条件，否则这很可能会失败。
- en: A special circumstance arises when you are single stepping through code and
    IDA determines that the instruction you are about to execute will generate an
    exception, as is the case with an `int 3`, an `icebp`, or a `popf` that will set
    the trace flag; IDA displays the dialog shown in [Figure 25-11](ch25s05.html#the_exception_confirmation_dialog
    "Figure 25-11. The exception confirmation dialog").
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在单步执行代码时，如果 IDA 判断你即将执行的指令将产生异常，例如 `int 3`、`icebp` 或 `popf` 指令将设置跟踪标志，就会出现特殊情况。在这种情况下，IDA
    会显示如图 [图 25-11](ch25s05.html#the_exception_confirmation_dialog "图 25-11. 异常确认对话框")
    所示的对话框。
- en: '![The exception confirmation dialog](httpatomoreillycomsourcenostarchimages854423.png.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![异常确认对话框](httpatomoreillycomsourcenostarchimages854423.png.jpg)'
- en: Figure 25-11. The exception confirmation dialog
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-11. 异常确认对话框
- en: In most cases, the Run option is the most suitable choice and results in the
    application seeing the behavior that it expects when a debugger is not attached
    (as noted in the dialog). In working through this dialog, you are simply acknowledging
    that an exception is about to be generated. If you choose Run, in short order
    you will then be notified that an exception has occurred, and when you continue
    execution, you will be presented with the Exception Handling dialog of [Figure 25-10](ch25s05.html#the_exception_handling_dialog
    "Figure 25-10. The Exception Handling dialog") to decide how the exception should
    be dealt with.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，运行选项是最合适的选择，它会导致应用程序在调试器未附加时看到它期望的行为（如对话框中所述）。在处理此对话框时，你只是在确认即将生成异常。如果你选择运行，很快你就会收到异常已发生的通知，当你继续执行时，你将看到如图
    [图 25-10](ch25s05.html#the_exception_handling_dialog "图 25-10. 异常处理对话框") 所示的异常处理对话框，以决定如何处理异常。
- en: Determining how an application will handle an exception requires that we know
    how to trace exception handlers, which in turn requires that we know how to locate
    exception handlers. Ilfak discusses tracing Windows SEH handlers in a blog post
    titled “Tracing exception handlers.”^([[236](#ftn.CHP-25-FN-11)]) The basic idea
    is to locate any interesting exception handlers by walking the application’s list
    of installed exception handlers. For Windows SEH exceptions, a pointer to the
    head of this list may be found as the first dword in the thread environment block
    (TEB). The list of exception handlers is a standard linked-list data structure
    that contains a pointer to the next exception handler in the chain and a pointer
    to the function that should be called to handle any exception that is generated.
    Exceptions are passed down the list from one handler to another until a handler
    chooses to handle the exception and notify the operating system that the process
    may resume normal execution. If none of the installed exception handlers choose
    to handle the current exception, the operating system terminates the process or,
    when the process is being debugged, notifies the debugger that an exception has
    occurred within the debugged process.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 确定应用程序如何处理异常需要我们知道如何跟踪异常处理程序，而这又需要我们知道如何定位异常处理程序。Ilfak在一篇题为“跟踪异常处理程序”的博客文章中讨论了跟踪Windows
    SEH处理程序。[236](#ftn.CHP-25-FN-11)] 基本思想是通过遍历应用程序已安装的异常处理程序列表来定位任何有趣的异常处理程序。对于Windows
    SEH异常，这个列表的头部指针可能作为线程环境块（TEB）中的第一个dword找到。异常处理程序列表是一个标准的链表数据结构，它包含指向链中下一个异常处理程序的指针以及指向应该被调用来处理任何生成的异常的函数的指针。异常从列表中的一个处理程序传递到另一个处理程序，直到一个处理程序选择处理异常并通知操作系统进程可以继续正常执行。如果安装的任何异常处理程序都不选择处理当前的异常，操作系统将终止进程，或者当进程正在调试时，通知调试器在调试的进程中发生了异常。
- en: 'Under the IDA debugger, TEBs are mapped to an IDA database section named `TIB[`*`NNNNNNNN`*`]`,
    where *`NNNNNNNN`* is the eight-digit hexadecimal representation of the thread’s
    identification number. The following listing shows an example of the first dword
    in one such section:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA调试器下，TEB（线程环境块）被映射到名为`TIB[`*`NNNNNNNN`*`]`的IDA数据库部分，其中*`NNNNNNNN`*是线程识别号的八位十六进制表示。以下列表显示了此类部分中第一个dword的一个示例：
- en: '[PRE37]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The first three lines show summary information about the segment, while the
    fourth line ![](httpatomoreillycomsourcenostarchimages854061.png) contains the
    first dword of the section, indicating that the first exception handler record
    may be found at address `22FFE0h` (`off-set dword_22FFE0`). If no exception handlers
    were installed for this particular thread, the first dword in the TEB would contain
    the value `0FFFFFFFFh`, indicating that the end of the exception handler chain
    had been reached. In this example, examining two dwords at address `22FFE0h` shows
    the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行显示了关于段的摘要信息，而第四行![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)包含了该部分的第一个dword，表明第一个异常处理程序记录可能在地址`22FFE0h`（`off-set
    dword_22FFE0`）找到。如果没有为这个特定的线程安装任何异常处理程序，TEB中的第一个dword将包含值`0FFFFFFFFh`，表示已达到异常处理程序链的末尾。在这个例子中，检查地址`22FFE0h`处的两个dword显示以下内容：
- en: '[PRE38]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first dword ![](httpatomoreillycomsourcenostarchimages854061.png) contains
    the value `0FFFFFFFFh`, indicating that this is the last exception handler record
    in the chain. The second dword ![](httpatomoreillycomsourcenostarchimages854063.png)
    contains the address `7C839AA8h` (`offset loc_7C839AA8`), indicating that the
    function at `loc_7C839AA8` should be called to process any exceptions that may
    arise during the execution of the process. If we were interested in tracing the
    handling of any exceptions in this process, we might begin by setting a breakpoint
    at address `7C839AA8h`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个dword![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)包含值`0FFFFFFFFh`，表示这是链中的最后一个异常处理程序记录。第二个dword![httpatomoreillycomsourcenostarchimages854063.png](httpatomoreillycomsourcenostarchimages854063.png)包含地址`7C839AA8h`（`offset
    loc_7C839AA8`），表示应该调用`loc_7C839AA8`处的函数来处理在进程执行过程中可能出现的任何异常。如果我们对跟踪此进程中的任何异常处理感兴趣，我们可能从在地址`7C839AA8h`处设置断点开始。
- en: Because it is a relatively simple task to walk the SEH chain, a useful feature
    for the debugger to implement would be a display of the chain of SEH handlers
    that are installed for the current thread. Given such a display, it should be
    easy to navigate to each SEH handler, at which point you may decide whether you
    want to insert a breakpoint within the handler or not. Unfortunately, this is
    another feature available in OllyDbg that is not available in IDA’s debugger.
    To address this shortcoming, we have developed an SEH Chain plug-in, which, when
    invoked from within the debugger, will display the list of exception handlers
    that are installed for the current thread. An example of this display is shown
    in [Figure 25-12](ch25s05.html#the_seh_chain_display "Figure 25-12. The SEH Chain
    display").
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 因为遍历SEH链相对简单，对于调试器来说，一个有用的特性就是显示当前线程安装的SEH处理器的链。有了这样的显示，应该可以轻松地导航到每个SEH处理器，此时你可以决定是否在处理器中插入一个断点。不幸的是，这是OllyDbg中可用但IDA调试器中不可用的另一个特性。为了解决这个不足，我们开发了一个SEH
    Chain插件，当从调试器内部调用时，将显示为当前线程安装的异常处理器的列表。这个显示的例子在[图25-12](ch25s05.html#the_seh_chain_display
    "图25-12. SEH链显示")中展示。
- en: '![The SEH Chain display](httpatomoreillycomsourcenostarchimages854427.png.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![SEH链显示](httpatomoreillycomsourcenostarchimages854427.png.jpg)'
- en: Figure 25-12. The SEH Chain display
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图25-12. SEH链显示
- en: This plug-in utilizes the SDK’s `choose2` function to display a nonmodal dialog
    that lists the current exception-handler chain. For each installed exception handler,
    the address of the exception-handler record (the two-dword list record) and the
    address of the corresponding exception handler are displayed. Double-clicking
    an exception handler jumps the active disassembly view (either IDA View-EIP or
    IDA View-ESP) to the address of the SEH handler function. The entire purpose of
    this plug-in is to simplify the process of locating exception handlers. The source
    code for the SEH Chain plug-in may be found on the website for this book.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件使用SDK的`choose2`函数显示一个非模态对话框，列出当前的异常处理器链。对于每个安装的异常处理器，显示异常处理器记录的地址（两个双字列表记录）和相应异常处理器的地址。双击一个异常处理器会将活动反汇编视图（IDA
    View-EIP或IDA View-ESP）跳转到SEH处理器函数的地址。此插件的全部目的就是简化定位异常处理器的过程。SEH Chain插件的源代码可以在本书的网站上找到。
- en: The flip side of the exception-handling process is the manner in which an exception
    handler returns control (if it chooses to do so) to the application in which the
    exception occurred. When an exception-handler function is called by the operating
    system, the function is granted access to all of the CPU register’s contents as
    they were set at the moment the exception took place. In the process of handling
    the exception, the function may elect to modify one or more CPU register values
    prior to returning control to the application. The intent of this process is for
    an exception handler to be given the opportunity to repair the state of the process
    sufficiently so that the process may resume normal execution. If the exception
    handler determines that the process should be allowed to continue, the operating
    system is notified, and the process’s register values are restored, using any
    modifications made by the exception handler. As discussed in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis"), some anti–reverse engineering utilities
    make use of exception handlers to alter a process’s flow of execution by modifying
    the saved value of the instruction pointer during the exception-handling phase.
    When the operating system returns control to the affected process, execution resumes
    at the address specified by the modified instruction pointer.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理过程的另一方面是异常处理器如何将控制权（如果它选择这样做）返回到发生异常的应用程序。当操作系统调用异常处理器函数时，该函数被授予访问在异常发生时设置的CPU寄存器内容的权限。在处理异常的过程中，该函数可以选择在将控制权返回给应用程序之前修改一个或多个CPU寄存器的值。这个过程的目的是为异常处理器提供足够的机会修复进程的状态，以便进程可以继续正常执行。如果异常处理器确定进程应该继续执行，操作系统会收到通知，并且进程的寄存器值会通过异常处理器所做的任何修改来恢复。如[第21章](ch21.html
    "第21章. 混淆代码分析")中所述，一些反逆向工程工具利用异常处理器通过修改异常处理阶段中保存的指令指针的值来改变进程的执行流程。当操作系统将控制权返回给受影响的过程时，执行从修改后的指令指针指定的地址继续。
- en: 'In his blog post on tracing exceptions, Ilfak discusses the fact that Windows
    SEH exception handlers return control to the affected process via the *ntdll.dll*
    function `NtContinue` (also known as `ZwContinue`). Since `NtContinue` has access
    to all of the process’s saved register values (via one of its arguments), it is
    possible to determine exactly where the process will resume execution by examining
    the value contained in the saved instruction pointer from within `NtContinue`.
    Once we know where the process is set to resume execution, we can set a breakpoint
    in order to avoid stepping through operating system code and to stop the process
    at the earliest opportunity once it resumes execution. The following steps outline
    the process we need to follow:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在他关于跟踪异常的博客文章中，Ilfak 讨论了这样一个事实：Windows SEH 异常处理程序通过 `ntdll.dll` 函数 `NtContinue`（也称为
    `ZwContinue`）将控制权返回给受影响的过程。由于 `NtContinue` 可以访问进程的所有保存寄存器值（通过其参数之一），因此可以通过检查 `NtContinue`
    内部的保存指令指针值来确定进程将确切地在哪里恢复执行。一旦我们知道进程将恢复执行的位置，我们就可以设置一个断点，以避免执行操作系统代码，并在进程恢复执行时尽早停止它。以下步骤概述了我们需要遵循的过程：
- en: Locate `NtContinue` and set a nonstopping breakpoint on its first instruction.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位 `NtContinue` 并在其第一条指令上设置一个非停止断点。
- en: Add a breakpoint condition to this breakpoint.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此断点添加一个断点条件。
- en: When the breakpoint is hit, obtain the address of the saved registers by reading
    the `CONTEXT` pointer from the stack.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当断点被触发时，通过从堆栈中读取 `CONTEXT` 指针来获取保存寄存器的地址。
- en: Retrieve the process’s saved instruction pointer value from the `CONTEXT` record.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `CONTEXT` 记录中检索进程的保存指令指针值。
- en: Set a breakpoint on the retrieved address and allow execution to continue.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检索到的地址上设置断点，并允许执行继续。
- en: 'Using a process similar to the debugger-hiding script, we can automate all
    of these tasks and associate them with the initiation of a debugging session.
    The following code demonstrates launching a process in the debugger and setting
    a breakpoint on `NtContinue`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与调试器隐藏脚本类似的过程，我们可以自动化所有这些任务，并将它们与调试会话的启动相关联。以下代码演示了在调试器中启动进程并在 `NtContinue`
    上设置断点：
- en: '[PRE39]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The purpose of this code is simply to set a conditional breakpoint on the entry
    of `NtContinue`. The behavior of the breakpoint is implemented by the IDC function
    `bpt_NtContinue`, which is shown here:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是简单地设置一个在 `NtContinue` 入口处的条件断点。断点的行为是通过 IDC 函数 `bpt_NtContinue` 实现的，如下所示：
- en: '[PRE40]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function locates the pointer to the process’s saved register context information
    ![](httpatomoreillycomsourcenostarchimages854061.png), retrieves the saved instruction
    pointer value from offset `0xB8` within the `CONTEXT` structure ![](httpatomoreillycomsourcenostarchimages854063.png),
    and sets a breakpoint on this address ![](httpatomoreillycomsourcenostarchimages854093.png).
    In order to make it clear to the user why execution has stopped, a breakpoint
    condition (which is always true) is added to display a message to the user ![](httpatomoreillycomsourcenostarchimages854095.png).
    We choose to do this because the breakpoint was not set explicitly by the user,
    and the user may not correlate the event to the return from an exception handler.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数定位进程的保存寄存器上下文信息指针 ![](httpatomoreillycomsourcenostarchimages854061.png)，从
    `CONTEXT` 结构的偏移 `0xB8` 处检索保存的指令指针值 ![](httpatomoreillycomsourcenostarchimages854063.png)，并在该地址上设置断点
    ![](httpatomoreillycomsourcenostarchimages854093.png)。为了使用户清楚地知道执行为什么停止，添加了一个始终为真的断点条件来向用户显示消息
    ![](httpatomoreillycomsourcenostarchimages854095.png)。我们选择这样做是因为断点不是由用户明确设置的，用户可能不会将事件与异常处理程序的返回相关联。
- en: This example represents a simple means of handling exception returns. Much more
    sophisticated logic could be added to the breakpoint function `bpt_NtContinue`.
    For example, if you suspect that an exception handler is manipulating the contents
    of debug registers, perhaps to prevent you from setting hardware breakpoints,
    you might opt to restore the values of the debug registers to known good values
    prior to returning control to the process being debugged.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子代表了一种处理异常返回的简单方法。可以在断点函数 `bpt_NtContinue` 中添加更复杂的逻辑。例如，如果你怀疑异常处理程序正在操作调试寄存器的内容，可能是为了防止你设置硬件断点，你可能选择在将控制权返回给被调试的进程之前，将调试寄存器的值恢复到已知的好值。
- en: '* * *'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[236](#CHP-25-FN-11)]) See [http://www.hexblog.com/2005/12/tracing_exception_handlers.html](http://www.hexblog.com/2005/12/tracing_exception_handlers.html).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[236](#CHP-25-FN-11)]) 查看 [http://www.hexblog.com/2005/12/tracing_exception_handlers.html](http://www.hexblog.com/2005/12/tracing_exception_handlers.html)。
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In addition to their obvious uses in tracking down bugs in software, debuggers
    may also be used as effective reverse engineering tools. For malware and obfuscated
    code analysis, the ability to utilize a single application for both static and
    dynamic analysis can save valuable time and the effort required to generate data
    with one tool that can be analyzed with a second tool. Given the wide variety
    of debuggers available today, IDA’s debugger may not be the ideal choice for tracking
    down runtime problems in your applications. However, if you anticipate the need
    to conduct any reverse engineering of an application or if you simply desire a
    high-quality disassembly to refer to during the debugging process, IDA’s debugger
    may serve your needs well. In [Chapter 26](ch26.html "Chapter 26. Additional Debugger
    Features"), we conclude the book by covering more advanced features of IDA’s debugger,
    including remote debugging and debugging on Linux and OS X.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在追踪软件中的错误方面的明显用途外，调试器还可以作为有效的逆向工程工具。对于恶意软件和混淆代码分析，能够利用单个应用程序进行静态和动态分析的能力可以节省宝贵的时间和生成数据所需的努力，这些数据可以用第二个工具进行分析。鉴于今天可用的调试器种类繁多，IDA
    的调试器可能不是追踪应用程序运行时问题的理想选择。然而，如果您预计需要对应用程序进行任何逆向工程，或者您只是希望在调试过程中参考高质量的反汇编代码，IDA
    的调试器可能很好地满足您的需求。在 [第 26 章](ch26.html "第 26 章. 其他调试器功能") 中，我们通过介绍 IDA 调试器的更多高级功能来结束本书，包括远程调试和
    Linux 以及 OS X 上的调试。
- en: Chapter 26. Additional Debugger Features
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 26 章. 其他调试器功能
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: Over the last two chapters, we have covered the majority of the debugger’s basic
    features including scripting debugger actions, as well as its usefulness in de-obfuscating
    code. In this chapter, we round out our discussion of the debugger by looking
    at remote debugging with IDA, the use of the Bochs x86 emulator^([[237](#ftn.CHP-26-FN-1)])
    as a debugging platform, and the Appcall^([[238](#ftn.CHP-26-FN-2)]) feature that
    effectively extends IDA’s scripting capabilities to include any function defined
    with a process and its associated libraries.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们已经介绍了调试器的大部分基本功能，包括脚本调试器操作，以及其在去混淆代码中的实用性。在本章中，我们通过探讨使用 IDA 进行远程调试、使用
    Bochs x86 模拟器^([[237](#ftn.CHP-26-FN-1)]) 作为调试平台，以及 Appcall^([[238](#ftn.CHP-26-FN-2)])
    功能来扩展 IDA 脚本功能，包括任何使用进程及其相关库定义的函数，来完善我们对调试器的讨论。
- en: Remote Debugging with IDA
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IDA 进行远程调试
- en: All versions of IDA ship with server components designed to facilitate remote
    debugging sessions. In addition, IDA is capable of interfacing with remote gdb
    sessions that make use of `gdb_server` or built-in gdb stubs. One of the principal
    advantages of remote debugging is the ability to use the GUI debugger interface
    as a frontend for any debugging session. For the most part, other than initial
    setup and establishing the connection to the remote debugging server, remote debugging
    sessions differ little from local debugging sessions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的所有版本都配备了旨在方便远程调试会话的服务器组件。此外，IDA 能够与使用 `gdb_server` 或内置 gdb 检测棒的远程 gdb 会话进行接口。远程调试的主要优势之一是能够将
    GUI 调试器界面用作任何调试会话的前端。在大多数情况下，除了初始设置和建立与远程调试服务器的连接之外，远程调试会话与本地调试会话几乎没有区别。
- en: Using a Hex-Rays Debugging Server
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hex-Rays 调试服务器
- en: 'Remote debugging begins by launching an appropriate debugging server component
    on the computer on which a process is to be debugged. IDA ships with the following
    server components:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调试首先在将要调试进程的计算机上启动适当的调试服务器组件。IDA 提供以下服务器组件：
- en: '| **`win32_remote.exe`** Server component executed on Windows computers for
    the purpose of debugging 32-bit Windows applications |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| **`win32_remote.exe`** 服务器组件在 Windows 计算机上执行，用于调试 32 位 Windows 应用程序|'
- en: '| **`win64_remotex64.exe`** Server component executed on 64-bit Windows computers
    for the purpose of debugging 64-bit Windows applications (IDA Advanced only) |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| **`win64_remotex64.exe`** 服务器组件在 64 位 Windows 计算机上执行，用于调试 64 位 Windows 应用程序（仅限
    IDA Advanced）|'
- en: '| **`wince_remote_arm.dll`** Server component uploaded to Windows CE devices
    (via ActiveSync) |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| **`wince_remote_arm.dll`** 服务器组件上传到 Windows CE 设备（通过 ActiveSync）|'
- en: '| **`mac_server`** Server component executed on OS X computers for the purpose
    of debugging 32-bit OS X applications |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| **`mac_server`** 在OS X计算机上执行的服务器组件，用于调试32位OS X应用程序 |'
- en: '| **`mac_serverx64`** Server component executed on 64-bit OS X computers for
    the purpose of debugging 64-bit OS X applications (IDA Advanced only) |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| **`mac_serverx64`** 在64位OS X计算机上执行的服务器组件，用于调试64位OS X应用程序（仅IDA高级版） |'
- en: '| **`linux_server`** Server component executed on Linux computers for the purpose
    of debugging 32-bit Linux applications |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| **`linux_server`** 在Linux计算机上执行的服务器组件，用于调试32位Linux应用程序 |'
- en: '| **`linux_serverx64`** Server component executed on 64-bit Linux computers
    for the purpose of debugging 64-bit Linux applications (IDA Advanced only) |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| **`linux_serverx64`** 在64位Linux计算机上执行的服务器组件，用于调试64位Linux应用程序（仅IDA高级版） |'
- en: '| **`armlinux_server`** Server component executed on ARM-based computers for
    the purpose of debugging ARM applications |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| **`armlinux_server`** 基于ARM计算机执行的服务器组件，用于调试ARM应用程序 |'
- en: '| **`android_server`** Server component executed on Android devices for the
    purpose of debugging Android applications |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| **`android_server`** 在Android设备上执行的服务器组件，用于调试Android应用程序 |'
- en: In order to perform remote debugging on any platform, the only component you
    are required to execute on that platform is the appropriate server component.
    It is not necessary to install a full version of IDA on the remote platform. In
    other words, if you intend to use a Windows version of IDA as your debugging client,
    and you wish to remotely debug Linux applications, the only file, other than the
    binary that is being debugged, that you need to copy to and execute on the Linux
    system is *linux_server*.^([[239](#ftn.CHP-26-FN-3)])
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在任何平台上执行远程调试，您需要在该平台上执行适当的服务器组件。不需要在远程平台上安装IDA的完整版本。换句话说，如果您打算使用IDA的Windows版本作为您的调试客户端，并且您希望远程调试Linux应用程序，除了正在调试的二进制文件外，您还需要复制并执行到Linux系统上的唯一文件是
    *linux_server*^([[239](#ftn.CHP-26-FN-3)])
- en: 'Regardless of the platform you intend to run the server on, the server components
    accept three command-line options, as listed here:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您打算在哪个平台上运行服务器，服务器组件接受三个命令行选项，如下所示：
- en: '| **`-p<`****``*`port number`*``****`>`** is used to specify an alternate TCP
    port for the server to listen on. The default port is 23946\. Note that no space
    should be entered between the `-p` and the port number. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| **`-p<`****``*`端口号`*``****`>`** 用于指定服务器监听的备用TCP端口。默认端口是23946。请注意，在 `-p` 和端口号之间不应输入空格。
    |'
- en: '| **`-P<`****``*`password`*``****`>`** is used to specify a password that must
    be supplied in order for a client to connect to the debug server. Note that no
    space should be entered between the `-P` and the provided password. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| **`-P<`****``*`password`*``****`>`** 用于指定客户端连接到调试服务器时必须提供的密码。请注意，在 `-P` 和提供的密码之间不应输入空格。
    |'
- en: '| **`-v`** places the server in verbose mode. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| **`-v`** 将服务器置于详细模式。 |'
- en: There is no option to restrict the IP address on which the server listens. If
    you wish to restrict incoming connections, you may do so using host-based firewall
    rules as applicable to your debugging platform. Once a server has been launched,
    IDA may be executed from any supported operating system and used to provide a
    client interface to the debug server; however, a server can handle only one active
    debugging session at any given time. If you wish to maintain several simultaneous
    debugging sessions, you must launch several instances of the debugging server
    on several different TCP ports.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 没有选项可以限制服务器监听的IP地址。如果您希望限制传入的连接，您可以使用适用于您的调试平台的主机防火墙规则来实现。一旦启动了服务器，IDA可以从任何支持的操作系统执行，并用作向调试服务器提供客户端界面的工具；然而，服务器在任何给定时间只能处理一个活动的调试会话。如果您希望维护多个同时进行的调试会话，您必须在多个不同的TCP端口上启动多个调试服务器实例。
- en: From the client perspective, remote debugging is initiated by specifying a server
    hostname and ports via the Debugger ▸ Process Options command, as shown in [Figure 26-1](ch26.html#the_debugger_process_options_dialog
    "Figure 26-1. The debugger process options dialog"). This action must be performed
    prior to starting or attaching to the process you intend to debug.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，远程调试是通过在“调试器”▸“进程选项”命令中指定服务器主机名和端口来启动的，如图26-1所示。此操作必须在启动或附加到您打算调试的进程之前执行。
- en: '![The debugger process options dialog](httpatomoreillycomsourcenostarchimages854430.png.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![调试器进程选项对话框](httpatomoreillycomsourcenostarchimages854430.png.jpg)'
- en: Figure 26-1. The debugger process options dialog
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-1. 调试器进程选项对话框
- en: The first four fields in this dialog apply to both local and remote debugging
    sessions, while the Hostname, Port, and Password fields apply only to remote debugging
    sessions. The fields of this dialog are summarized here.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框中的前四个字段适用于本地和远程调试会话，而主机名、端口和密码字段仅适用于远程调试会话。此对话框的字段总结如下。
- en: '| **Application** The full path to the application binary that you wish to
    debug. For local debugging sessions, this is a path in the local filesystem. For
    a remote debugging session, this is the path on the debugging server. If you choose
    not to use a full path, the remote server will search its current working directory.
    |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| **应用程序** 您希望调试的应用程序二进制文件的完整路径。对于本地调试会话，这是一个本地文件系统中的路径。对于远程调试会话，这是调试服务器上的路径。如果您选择不使用完整路径，远程服务器将搜索其当前工作目录。|'
- en: '| **Input file** The full path to the file that was used to create the IDA
    database. For local debugging sessions, this is a path in the local filesystem.
    For a remote debugging session, this is the path on the debugging server. If you
    choose not to use a full path, the remote server will search its current working
    directory. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| **输入文件** 用于创建IDA数据库的文件的完整路径。对于本地调试会话，这是一个本地文件系统中的路径。对于远程调试会话，这是调试服务器上的路径。如果您选择不使用完整路径，远程服务器将搜索其当前工作目录。|'
- en: '| **Directory** The working directory in which the process should be launched.
    For local debugging, this directory must exist in the local file-system. For remote
    debugging, this is a directory on the debugging server. |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| **目录** 进程应启动的工作目录。对于本地调试，此目录必须在本地文件系统中存在。对于远程调试，这是一个调试服务器上的目录。|'
- en: '| **Parameters** Used to specify any command-line parameters to be passed to
    the process when it is started. Note that shell metacharacters (such as `<`, `>`,
    and `&#124;`) are not honored here. Any such characters will be passed to the
    process as command-line arguments. Thus it is not possible to launch a process
    under the debugger and have that process perform any sort of input or output redirection.
    For remote debugging sessions, process output is displayed in the console that
    was used to launch the debugging server. |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| **参数** 用于指定在启动进程时传递给进程的任何命令行参数。请注意，此处不尊重shell元字符（如`<`, `>`, 和 `&#124;`）。任何此类字符都将作为命令行参数传递给进程。因此，无法在调试器下启动进程，并让该进程执行任何类型的输入或输出重定向。对于远程调试会话，进程输出显示在启动调试服务器的控制台。|'
- en: '| **Hostname** The hostname or IP address of the remote debugging server. Leave
    this field blank for local debugging sessions. |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| **主机名** 远程调试服务器的计算机名或IP地址。对于本地调试会话，请留空此字段。|'
- en: '| **Port** The TCP port number on which the remote debugging server is listening.
    |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| **端口** 远程调试服务器监听的TCP端口号。|'
- en: '| **Password** The password expected by the remote debugging server. Note that
    the data entered into this field is not masked, making it possible for the password
    to be viewed by anyone who can observe your display. Further, this password is
    transmitted to the remote server as plain text, making it observable by anyone
    who can intercept your network packets. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| **密码** 远程调试服务器期望的密码。请注意，输入到此字段的数据不会被屏蔽，使得任何可以观察您显示的人都可以查看密码。此外，此密码以纯文本形式传输到远程服务器，使得任何可以拦截您的网络数据包的人都可以观察到。|'
- en: At first glance, the Application and Input File fields in [Figure 26-1](ch26.html#the_debugger_process_options_dialog
    "Figure 26-1. The debugger process options dialog") may seem to be identical.
    When the file opened in your IDA database is the same as the executable file that
    you wish to run on the remote computer, these two fields will hold the same value.
    However, in some cases, you may wish to debug a library file (such as a DLL) that
    you are analyzing in an IDA database. It is not possible to debug a library file
    directly because library files are not standalone executables. In such cases,
    you will set the Input File field to the path of the library file. The Application
    field must be set to the name of an application that makes use of the library
    file that you wish to debug.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，[图26-1](ch26.html#the_debugger_process_options_dialog "图26-1. 调试器进程选项对话框")中的“应用程序”和“输入文件”字段似乎相同。当你打开在IDA数据库中的文件与你在远程计算机上希望运行的可执行文件相同时，这两个字段将持有相同的值。然而，在某些情况下，你可能希望调试一个在IDA数据库中分析库文件（如DLL）。由于库文件不是独立的可执行文件，因此无法直接调试库文件。在这种情况下，你需要将“输入文件”字段设置为库文件的路径。而“应用程序”字段必须设置为使用你希望调试的库文件的应用程序名称。
- en: The procedures for connecting to a remote gdb server are nearly identical to
    the procedures for attaching to a remote IDA debugging server with two minor exceptions.
    First, no password is required to connect to a `gdb_server`, and second, IDA allows
    specification of gdb-specific behaviors via the Set specific options button within
    the debugger setup dialog. [Figure 26-2](ch26.html#gdb_configuration_dialog "Figure 26-2. GDB
    Configuration dialog") shows the GDB Configuration dialog.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到远程gdb服务器的步骤几乎与附加到远程IDA调试服务器的步骤相同，只有两个小的例外。首先，连接到`gdb_server`不需要密码，其次，IDA允许通过调试器设置对话框中的“设置特定选项”按钮指定gdb特定的行为。[图26-2](ch26.html#gdb_configuration_dialog
    "图26-2. GDB配置对话框")显示了GDB配置对话框。
- en: '![GDB Configuration dialog](httpatomoreillycomsourcenostarchimages854433.png.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![GDB配置对话框](httpatomoreillycomsourcenostarchimages854433.png.jpg)'
- en: Figure 26-2. GDB Configuration dialog
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-2. GDB配置对话框
- en: Of note is the fact that IDA has no way of knowing the architecture of the computer
    on which the `gdb_server` is running and that you are obligated to specify a processor
    type (which defaults to Intel x86) and potentially the endian-ness of that processor.
    IDA is currently capable of providing a debugging interface for x86, ARM, PowerPC,
    and MIPS processors.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，IDA无法知道`gdb_server`运行的计算机的架构，并且你有义务指定一个处理器类型（默认为Intel x86）以及该处理器的字节序。目前IDA能够为x86、ARM、PowerPC和MIPS处理器提供调试接口。
- en: Attaching to a Remote Process
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加到远程进程
- en: A number of different scenarios exist if you intend to attach to a running process
    on your remote debugging server. First, if you have no database open in IDA, you
    may select Debugger ▸ Attach and choose from IDA’s list of available debuggers.
    If you choose one of IDA’s remote debuggers, you are presented with the configuration
    dialog shown in [Figure 26-3](ch26.html#remote_debugger_configuration "Figure 26-3. Remote
    debugger configuration").
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算连接到远程调试服务器上的运行进程，存在多种不同的场景。首先，如果你在IDA中没有打开数据库，你可以选择“调试器”▸“附加”并从IDA的可用调试器列表中选择。如果你选择IDA的远程调试器之一，你会看到一个配置对话框，如图26-3所示。
- en: '![Remote debugger configuration](httpatomoreillycomsourcenostarchimages854436.png.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![远程调试器配置](httpatomoreillycomsourcenostarchimages854436.png.jpg)'
- en: Figure 26-3. Remote debugger configuration
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-3. 远程调试器配置
- en: Once you provide the appropriate connection parameters and click OK, IDA obtains
    and displays a process list from the remote debugging server, allowing you to
    select and attach to a specific process.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你提供了适当的连接参数并点击“确定”，IDA将从远程调试服务器获取并显示进程列表，允许你选择并附加到特定的进程。
- en: In the second scenario, you might already have a binary open in IDA and wish
    to attach to a remote process. In this case you may need to select a debugger
    (if none has been previously specified for the open file type) or switch your
    debugger type (if a remote debugger is not currently selected). Once a debugger
    has been selected, you must provide hostname and password information for the
    remote debugger server, as shown in [Figure 26-1](ch26.html#the_debugger_process_options_dialog
    "Figure 26-1. The debugger process options dialog"), at which point you may attach
    to a remote process using Debugger ▸ Attach to Process.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，你可能已经在 IDA 中打开了一个二进制文件，并希望将其附加到远程进程。在这种情况下，你可能需要选择一个调试器（如果之前没有为打开的文件类型指定调试器）或切换调试器类型（如果当前未选择远程调试器）。一旦选择了调试器，你必须提供远程调试器服务器的主机名和密码信息，如图
    [图 26-1](ch26.html#the_debugger_process_options_dialog "图 26-1. 调试器进程选项对话框") 所示，此时你可以使用调试器
    ▸ 附加到进程来附加到远程进程。
- en: Exception Handling During Remote Debugging
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程调试期间的异常处理
- en: In [Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger Integration") we
    discussed the IDA debugger’s handling of exceptions and how to modify the debugger’s
    exception-handling behavior. During remote debugging sessions, the debugger’s
    default exception-handling behavior is dictated by the *exceptions.cfg* file,
    which resides on the client machine (the machine on which you are actually running
    IDA). This allows you to modify *exceptions.cfg* and reload the changes via the
    Debugger Setup dialog (see [Figure 25-4](ch25s03.html#debugger_pausing_events
    "Figure 25-4. Debugger pausing events")) without the need to access the remote
    server.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 25 章](ch25.html "第 25 章. 反汇编器/调试器集成") 中，我们讨论了 IDA 调试器对异常的处理以及如何修改调试器的异常处理行为。在远程调试会话期间，调试器的默认异常处理行为由客户端机器上的
    *exceptions.cfg* 文件决定（即你实际运行 IDA 的机器）。这允许你通过调试器设置对话框（见图 25-4）（见 [图 25-4](ch25s03.html#debugger_pausing_events
    "图 25-4. 调试器暂停事件")）修改 *exceptions.cfg* 并重新加载更改，而无需访问远程服务器。
- en: Using Scripts and Plug-ins During Remote Debugging
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在远程调试期间使用脚本和插件
- en: During a remote debugging session, it remains possible to utilize scripts and
    plug-ins to automate debugging tasks. Any scripts or plug-ins that you choose
    to execute will run within IDA on the client machine. IDA will in turn handle
    any actions that are required to interact with the remote process, such as setting
    breakpoints, querying state, modifying memory, or resuming execution. From the
    script’s perspective, all behaviors will appear just as if the debugging session
    was taking place locally. The only thing to remember is to make sure that your
    scripts and plug-ins are tailored to the architecture on which the target process
    is running and not the architecture on which the IDA client is running (unless
    they happen to be the same). In other words, if you are running the Windows version
    of IDA as a client for remote debugging on Linux, do not expect your Windows debugger-hiding
    script to do you any good.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程调试会话期间，仍然可以使用脚本和插件来自动化调试任务。你选择的任何脚本或插件都将运行在客户端机器上的 IDA 中。然后 IDA 将处理与远程进程交互所需的任何操作，例如设置断点、查询状态、修改内存或恢复执行。从脚本的角度来看，所有行为都将与本地调试会话一样。唯一需要注意的是确保你的脚本和插件针对的是目标进程运行的架构，而不是
    IDA 客户端运行的架构（除非它们恰好相同）。换句话说，如果你在 Linux 上以远程调试客户端的身份运行 IDA 的 Windows 版本，不要期望你的
    Windows 调试器隐藏脚本能对你有所帮助。
- en: '* * *'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[237](#CHP-26-FN-1)]) See [http://bochs.sourceforge.net/](http://bochs.sourceforge.net/).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[237](#CHP-26-FN-1)]) 查看 [http://bochs.sourceforge.net/](http://bochs.sourceforge.net/)。
- en: ^([[238](#CHP-26-FN-2)]) See [http://www.hexblog.com/?p=112](http://www.hexblog.com/?p=112).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[238](#CHP-26-FN-2)]) 查看 [http://www.hexblog.com/?p=112](http://www.hexblog.com/?p=112)。
- en: ^([[239](#CHP-26-FN-3)]) Note that the **_server* binaries distributed with
    IDA depend on a number of shared libraries. You can use `ldd` (or `otool -L` on
    OS X) to list these dependencies.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[239](#CHP-26-FN-3)]) 注意，与 IDA 一起分发的 **_server* 二进制文件依赖于多个共享库。你可以使用 `ldd`（或在
    OS X 上使用 `otool -L`）来列出这些依赖项。
- en: Debugging with Bochs
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bochs 进行调试
- en: Bochs is an open source x86 emulation environment. Bochs is capable of full-system
    emulation of x86 computer systems and includes emulation for common I/O devices
    and a custom BIOS. Bochs provides an emulation-based alternative to virtualization
    software such as VMware Workstation. Elias Bachaalany of the Hex-Rays development
    team has taken the lead on integrating Bochs with IDA to provide an emulation-based
    alternative to traditional debugging.^([[240](#ftn.CHP-26-FN-4)]) Windows versions
    of IDA ship with and install a compatible version of Bochs, while non-Windows
    users wishing to make use of Bochs must make sure that version 2.4.2 or later
    is installed on their system.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Bochs是一个开源的x86模拟环境。Bochs能够全系统模拟x86计算机系统，包括对常见I/O设备和自定义BIOS的模拟。Bochs提供了基于模拟的虚拟化软件（如VMware
    Workstation）的替代方案。Hex-Rays开发团队的Elias Bachaalany负责将Bochs与IDA集成，以提供基于模拟的传统调试的替代方案.^([[240](#ftn.CHP-26-FN-4)])
    Windows版本的IDA附带并安装了兼容的Bochs版本，而希望使用Bochs的非Windows用户必须确保他们的系统上安装了2.4.2或更高版本的Bochs。
- en: 'With Bochs installed, IDA offers a Local Bochs debugger choice whenever you
    have an x86 binary open in IDA. The availability of Bochs offers the opportunity
    to perform local debugging of Windows applications on non-Windows systems, because
    the application will be emulated rather than executed as a native process. Because
    it’s an emulator, Bochs configuration options differ somewhat from those available
    with more traditional debuggers. One of the most important things to understand
    about Bochs is that it can operate in three distinct modes: disk image mode, IDB
    mode, and PE mode. The choice of mode is made using the Bochs specific debugger
    configuration dialog shown in [Figure 26-4](ch26s02.html#bochs_debugger_options_dialog
    "Figure 26-4. Bochs debugger options dialog").'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Bochs后，IDA在打开IDA中的x86二进制文件时，会提供本地Bochs调试器的选择。Bochs的可用性为在非Windows系统上对Windows应用程序进行本地调试提供了机会，因为应用程序将被模拟而不是作为本地进程执行。由于它是一个模拟器，Bochs的配置选项与更传统的调试器有所不同。关于Bochs，最重要的理解之一是它可以以三种不同的模式运行：磁盘镜像模式、IDB模式和PE模式。模式的选取是通过Bochs特定的调试器配置对话框来完成的，如图[图26-4](ch26s02.html#bochs_debugger_options_dialog
    "图26-4. Bochs调试器选项对话框")所示。
- en: '![Bochs debugger options dialog](httpatomoreillycomsourcenostarchimages854439.png.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![Bochs调试器选项对话框](httpatomoreillycomsourcenostarchimages854439.png.jpg)'
- en: Figure 26-4. Bochs debugger options dialog
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-4. Bochs调试器选项对话框
- en: Each of the available modes offers a drastically different degree of fidelity
    in terms of the quality and type of emulation being performed.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 每种可用的模式在执行模拟的质量和类型方面提供了截然不同的保真度。
- en: Bochs IDB Mode
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bochs IDB模式
- en: Working from the ground up, IDB is the most basic Bochs mode. In IDB mode, the
    only code that Bochs is aware of is the code contained in your database. Memory
    regions are mapped into Bochs and populated by copying bytes from the database.
    A configurable amount of stack space is provided based on settings in the Bochs
    options dialog, and IDA will make its own decision as to where the stack will
    be allocated. Emulated execution begins (meaning the instruction pointer is initially
    positioned) at the database symbol named `ENTRY` if one has been defined. If an
    `ENTRY` symbol is not present, IDA tests to see if a range of locations is currently
    selected in the open database and uses the beginning of the range as the debugger
    entry point. If no selection exists, then the current cursor location is taken
    as the initial instruction pointer value. When running in IDB mode, keep in mind
    that Bochs has no notion of any operating system support such as shared libraries
    or the location of any well-known structures within a typical process address
    space. It is equally possible to step through a PE file, an ELF file, a Mach-O
    file, or a raw blob of machine code such as an exploit payload as long as the
    code makes no reference to anything that might reside outside the database. One
    way that IDB might be used is for executing a single function in an effort to
    understand its behavior without the requirement to craft a complete process or
    disk image to do so.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 从底层开始工作，IDB是Bochs最基本的一种模式。在IDB模式下，Bochs所知晓的唯一代码就是包含在您的数据库中的代码。内存区域被映射到Bochs中，并通过从数据库复制字节来填充。根据Bochs选项对话框中的设置，提供可配置的堆栈空间，IDA将自行决定堆栈的分配位置。如果定义了名为`ENTRY`的数据库符号，则模拟执行开始（意味着指令指针最初定位）在该符号处。如果没有`ENTRY`符号，IDA会检查是否在打开的数据库中当前选定了某个地址范围，并使用该范围的起始点作为调试器的入口点。如果没有选择，则将当前光标位置作为初始指令指针值。在IDB模式下运行时，请记住，Bochs没有关于任何操作系统支持的概念，例如共享库或典型进程地址空间内任何知名结构的定位。只要代码不引用可能存在于数据库之外的内容，就可以逐步执行PE文件、ELF文件、Mach-O文件或原始机器代码块（如漏洞载荷）。IDB可能的一种用途是执行单个函数，以了解其行为，而不需要构建完整的进程或磁盘镜像。
- en: Bochs PE Mode
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bochs PE模式
- en: PE mode offers the opportunity to debug at something approaching the process
    level. When PE mode is selected and activated, IDA’s Bochs control module (an
    IDA plug-in) takes over and behaves much like the Windows process loader would
    if you were actually launching a native Windows process. A PE mode process receives
    process (PEB) and thread (TEB) environment blocks, along with a stack that mimics
    those that would be created in an actual process.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: PE模式提供了在接近进程级别进行调试的机会。当选择并激活PE模式时，IDA的Bochs控制模块（一个IDA插件）接管并表现得就像您实际启动一个本机Windows进程时的Windows进程加载器一样。PE模式进程接收进程（PEB）和线程（TEB）环境块，以及模拟实际进程中创建的堆栈。
- en: The Bochs plug-in also loads (without executing any code) a number of common
    Windows libraries into the emulated process address space in order to properly
    handle any library calls made by the process. The exact set of libraries that
    Bochs loads on debugger start is configurable and is specified in *<IDADIR>/plugins/bochs/startup.idc*.
    Any library may be loaded as is or may be designated to be stubbed out. If a library
    is marked to be stubbed, then the Bochs plug-in will automatically hook every
    function exported by that library and redirect execution to a Bochs interception
    function (refer to *startup.idc* and the IDA help system for more details). This
    stubbing technique provides an extensible means for users to define custom behaviors
    for any library function. For any library that is stubbed by IDA, it is possible
    to define a corresponding script file in which you may define your custom behaviors.
    For any library, *foolib.dll* for example, the Bochs plug-in scans for a related
    script named *api_foolib.idc* or *api_foolib.py* within the *<IDADIR>/plugins/bochs*
    directory. IDA ships with *<IDADIR>/plugins/bochs/api_kernel32.idc*, which provides
    a good example of the structure of such a file and the implementation of custom
    behaviors for a number of functions.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Bochs 插件还会将（不执行任何代码）许多常见的 Windows 库加载到模拟进程的地址空间中，以便正确处理进程所做的任何库调用。Bochs 在调试器启动时加载的确切库集合是可配置的，并在
    *<IDADIR>/plugins/bochs/startup.idc* 中指定。任何库都可以直接加载，或者指定为要模拟的。如果一个库被标记为要模拟，那么
    Bochs 插件将自动挂钩该库导出的每个函数，并将执行重定向到 Bochs 拦截函数（有关更多详细信息，请参阅 *startup.idc* 和 IDA 帮助系统）。这种模拟技术为用户提供了一种可扩展的方式来定义任何库函数的自定义行为。对于任何由
    IDA 模拟的库，你可以在其中定义自定义行为的相应脚本文件。对于任何库，例如 *foolib.dll*，Bochs 插件会在 *<IDADIR>/plugins/bochs*
    目录中搜索一个相关的脚本，名为 *api_foolib.idc* 或 *api_foolib.py*。IDA 随带 *<IDADIR>/plugins/bochs/api_kernel32.idc*，它提供了一个此类文件结构的良好示例以及为许多函数实现自定义行为的示例。
- en: The ability to hook library functions and define custom implementations is important
    in PE mode because there is no operating system layer to perform all of the heavy
    lifting needed by the shared libraries. For example, by providing an alternate,
    script-based behavior for a function such as `VirtualAlloc`, which would fail
    if it could not communicate with the operating system, it is possible to convince
    (to some degree) the emulated process that it is running as an actual process.
    The goal when creating such script-based behaviors is to provide the emulated
    process with the responses it would expect to see if were communicating with the
    actual library functions, which in turn were communicating with the actual operating
    system.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PE 模式下，能够挂钩库函数和定义自定义实现非常重要，因为共享库需要执行的所有繁重工作都没有操作系统层来处理。例如，通过为像 `VirtualAlloc`
    这样的函数提供一个基于脚本的替代行为，如果无法与操作系统通信则该函数会失败，可以（在一定程度上）让被模拟的过程相信它作为一个实际进程在运行。创建此类基于脚本的行为的目标是向被模拟的进程提供它在与实际库函数通信时预期会看到的响应，而这些库函数反过来又与实际操作系统通信。
- en: If you use IDA on a non-Windows platform, you may take full advantage of Bochs
    PE mode by copying any required libraries (as specified in *startup.idc*) from
    a Windows system onto your IDA system and editing *startup.idc* to point at the
    directory containing all of the copied libraries. The following listing shows
    an example of the required changes.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个非 Windows 平台上使用 IDA，你可以通过将所需的库（如 *startup.idc* 中指定的）从 Windows 系统复制到你的
    IDA 系统上，并编辑 *startup.idc* 以指向包含所有复制库的目录，充分利用 Bochs 的 PE 模式。以下列表显示了一个示例所需的更改。
- en: '[PRE41]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When using PE mode, one difference you will note when launching a process under
    Bochs is that IDA does not open a warning dialog to remind you of the danger of
    launching a potentially malicious process under debugger control. This is because
    the only process that gets created is the Bochs emulator process, and all of the
    code that you are debugging is viewed by the Bochs emulator as data that happens
    to represent code for it to emulate. No native process is ever created from the
    binary that you are debugging.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Bochs 下启动一个进程时，如果你使用 PE 模式，你会注意到的一个区别是 IDA 不会打开一个警告对话框来提醒你，在调试器控制下启动可能恶意的过程的风险。这是因为唯一创建的进程是
    Bochs 模拟器进程，而你正在调试的所有代码都被 Bochs 模拟器视为代表它要模拟的代码的数据。从你正在调试的二进制文件中永远不会创建任何本地进程。
- en: Bochs Disk Image Mode
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bochs 磁盘镜像模式
- en: The third mode of operation for the Bochs debugger is called disk image mode.
    Aside from IDA’s ability to make use of Bochs, Bochs is a full-blown x86 system
    emulator on its own. It is quite possible to create hard drive images, using the
    `bximage` tool supplied with Bochs; install an operating system on the disk image,
    using Bochs and any required installation medium for the desired operating system;
    and ultimately use Bochs to run your guest operating system within an emulated
    environment.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Bochs调试器的第三种操作模式被称为磁盘镜像模式。除了IDA能够利用Bochs之外，Bochs本身也是一个完整的x86系统仿真器。使用Bochs提供的`bximage`工具创建硬盘镜像是完全可能的；使用Bochs和所需的操作系统安装介质在磁盘镜像上安装操作系统；最终使用Bochs在仿真环境中运行你的客户操作系统。
- en: If your primary goal in using IDA/Bochs is to understand the behavior of a single
    process, then disk image mode may not be for you. Isolating and observing a single
    process executing within a fully emulated operating system is not an easy task
    and requires a detailed understanding of the operating system and how it manages
    processes and memory. Where you may find IDA/Bochs useful is in analyzing system
    BIOS and boot code, which can be followed relatively easily before the operating
    system code takes over.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用IDA/Bochs的主要目标是理解单个进程的行为，那么磁盘镜像模式可能不适合你。在完全仿真的操作系统中隔离和观察单个进程的执行并不是一件容易的事情，需要详细理解操作系统以及它是如何管理和处理进程与内存的。你可能发现IDA/Bochs在分析系统BIOS和引导代码时很有用，这些代码在操作系统代码接管之前相对容易追踪。
- en: In disk image mode, you have no executable file image to load into IDA. Instead,
    IDA ships with a loader that recognizes Bochs configuration (*boch-src*) files.^([[241](#ftn.CHP-26-FN-5)])
    A *bochsrc* file is used to describe the hardware execution environment when Bochs
    is used as a full system emulator. IDA’s default *bochsrc* file is located at
    *<IDADIR>/cfg/bochsrc.cfg*. Among other things, a *bochsrc* file is used to specify
    the locations of the system BIOS, video ROM, and disk image files. IDA’s *bochsrc*
    loader offers minimal loading services, doing nothing more than reading the first
    sector of the first disk image file specified in the Bochs configuration file
    being loaded and then selecting the Bochs debugger for use with the new database.
    The use of IDA/Bochs in a master boot record development scenario is discussed
    on the Hex-Rays blog.^([[242](#ftn.CHP-26-FN-6)])
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘镜像模式下，你无法将可执行文件镜像加载到IDA中。相反，IDA附带了一个识别Bochs配置（*boch-src*）文件的加载器.^([[241](#ftn.CHP-26-FN-5)）*bochsrc*文件用于描述当Bochs作为全系统仿真器使用时的硬件执行环境。IDA的默认*bochsrc*文件位于*<IDADIR>/cfg/bochsrc.cfg*。除了其他用途外，*bochsrc*文件用于指定系统BIOS、视频ROM和磁盘镜像文件的位置。IDA的*bochsrc*加载器提供最基础的加载服务，仅读取正在加载的Bochs配置文件中指定的第一个磁盘镜像文件的第一扇区，然后选择Bochs调试器用于新数据库。关于在主引导记录开发场景中使用IDA/Bochs的讨论可以在Hex-Rays博客上找到.^([[242](#ftn.CHP-26-FN-6)））
- en: '* * *'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[240](#CHP-26-FN-4)]) See “Designing a minimal operating system to emulate
    32/64bits x86 code snippets, shellcode or malware in Bochs” from Recon 2011 ([http://www.recon.cx/](http://www.recon.cx/)).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[240](#CHP-26-FN-4))]) 请参阅Recon 2011中的“设计一个最小的操作系统以在Bochs中仿真32/64位x86代码片段、shellcode或恶意软件”([http://www.recon.cx/](http://www.recon.cx/))。
- en: ^([[241](#CHP-26-FN-5)]) See [http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html](http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html)
    for information on the `bochsrc` file format.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[241](#CHP-26-FN-5))]) 请参阅 [http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html](http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html)
    了解`bochsrc`文件格式的信息。
- en: ^([[242](#CHP-26-FN-6)]) See [http://www.hexblog.com/?p=103](http://www.hexblog.com/?p=103).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[242](#CHP-26-FN-6)]) 请参阅 [http://www.hexblog.com/?p=103](http://www.hexblog.com/?p=103)。
- en: Appcall
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Appcall
- en: The debugger’s Appcall feature effectively extends the capabilities of IDC or
    IDAPython to make any function in the active process callable from a script. There
    are an infinite number of uses for such a capability, including mapping additional
    memory into the process address space (by calling `VirtualAlloc` or similar) and
    injecting new libraries into the process being debugged (by calling `LoadLibrary`
    or by calling functions within the process to perform tasks you would rather perform
    manually, such as decoding blocks of data or computing hash values).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器的Appcall功能有效地扩展了IDC或IDAPython的能力，使得活动进程中的任何函数都可以从脚本中调用。这种功能有无限多的用途，包括将额外的内存映射到进程地址空间（通过调用`VirtualAlloc`或类似函数）以及将新的库注入正在调试的进程（通过调用`LoadLibrary`或调用进程内的函数以执行你更愿意手动执行的任务，例如解码数据块或计算哈希值）。
- en: In order to make use of Appcall, the function you wish to invoke must be loaded
    in the address space of the process being debugged, and IDA must know or be informed
    of the function’s prototype so that parameters may be marshaled and unmarshaled
    properly. Any Appcall that you do make will be made in the context of the current
    debugger thread after first saving the thread’s state (essentially all registers
    associated with the thread). Once the Appcall completes, IDA restores the thread
    state, and the debugger is ready to resume execution as if no Appcall had ever
    taken place.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Appcall，你希望调用的函数必须加载到正在调试的进程地址空间中，并且 IDA 必须知道或被告知函数的原型，以便正确地打包和拆包参数。你做出的任何
    Appcall 都将在保存线程状态（基本上是与线程相关的所有寄存器）的上下文中进行。一旦 Appcall 完成，IDA 将恢复线程状态，调试器准备像没有发生
    Appcall 一样继续执行。
- en: 'Let’s look at an example in which Appcall is used to allocate a 4096-byte block
    of memory into the current (Windows) process address space. In this case, the
    Windows API function that we wish to invoke is named `VirtualAlloc` and its prototype
    is shown here:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用 Appcall 在当前（Windows）进程地址空间中分配 4096 字节内存块的示例。在这种情况下，我们希望调用的 Windows
    API 函数名为 `VirtualAlloc`，其原型如下所示：
- en: '[PRE42]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The call that we wish to make using Appcall might look something like the following
    if we were to write it in C:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用 C 语言编写，使用 Appcall 的调用可能看起来像以下这样：
- en: '[PRE43]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This function call ultimately translates into the following once all of the
    constants are resolved:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有常量都得到解决，这个函数调用最终将转换为以下形式：
- en: '[PRE44]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Recall that while a Windows process is being debugged, IDA prefixes the name
    of every library function with the name of the library to which the function belongs.
    Thus, `VirtualAlloc` will be named `kernel32_VirtualAlloc` when the debugger is
    active, as shown is the following listing:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当 Windows 进程正在调试时，IDA 会将每个库函数的名称前缀为所属库的名称。因此，当调试器处于活动状态时，`VirtualAlloc`
    将被命名为 `kernel32_VirtualAlloc`，如下所示：
- en: '[PRE45]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'No type information is displayed because IDA’s type libraries know nothing
    about a function named `kernel32_VirtualAlloc`. Since Appcall requires knowledge
    of a function’s type signature, we must add the information into the database
    ourselves using the `Set Function Type` command. An exact type signature is not
    required as long as the signature we specify allows IDA to properly transfer our
    parameters to the function we are invoking. In this case, we supply the following
    signature:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IDA 的类型库对名为 `kernel32_VirtualAlloc` 的函数一无所知，因此不会显示类型信息。由于 Appcall 需要知道函数的类型签名，我们必须使用
    `Set Function Type` 命令将信息添加到数据库中。只要我们指定的签名允许 IDA 正确地将我们的参数传递给要调用的函数，就不需要精确的类型签名。在这种情况下，我们提供以下签名：
- en: '[PRE46]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point we are ready to use Appcall to have more memory allocated into
    our process. Using IDC, this is extremely easy because all we need to do is invoke
    the function just as if it was an IDC function. Entering the function call at
    the IDA command line and using the `Message` function to display the results yields
    the following output:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好使用 Appcall 为我们的进程分配更多内存。使用 IDC，这非常简单，因为我们只需要像调用 IDC 函数一样调用该函数。在
    IDA 命令行中输入函数调用并使用 `Message` 函数显示结果，将得到以下输出：
- en: '[PRE47]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result in this case is a new 4096-byte block allocated to the process at
    address `0x3c0000`. In order to make the new memory block show up in IDA, we must
    use the Debugger ▸ Refresh memory command or wait for IDA to perform a refresh
    in conjunction with other debugger operations.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果是地址 `0x3c0000` 处为进程分配了一个新的 4096 字节块。为了使新的内存块在 IDA 中显示，我们必须使用“调试器”▸“刷新内存”命令或等待
    IDA 在与其他调试器操作结合时执行刷新。
- en: 'The syntax for performing an Appcall in Python is slightly different, making
    use of the `Appcall` variable defined in the `idaapi` module. However, the requirements
    to have a named function with an assigned type signature remain. When performed
    in Python, the same Appcall to `VirtualAlloc` would be done as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中执行 Appcall 的语法略有不同，它使用了在 `idaapi` 模块中定义的 `Appcall` 变量。然而，需要有一个具有指定类型签名的命名函数的要求仍然存在。在
    Python 中执行时，对 `VirtualAlloc` 的相同 Appcall 将如下所示：
- en: '[PRE48]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Additional information and examples related to Appcall and its uses may be found
    on the Hex-Rays blog.^([[243](#ftn.CHP-26-FN-7)])
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Appcall 及其使用的更多信息示例，可以在 Hex-Rays 博客上找到.^([[243](#ftn.CHP-26-FN-7)])
- en: '* * *'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[243](#CHP-26-FN-7)]) See [http://www.hexblog.com/?p=113](http://www.hexblog.com/?p=113).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[243](#CHP-26-FN-7)]) 查看 [http://www.hexblog.com/?p=113](http://www.hexblog.com/?p=113).
- en: Summary
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Whether through the efforts of the Hex-Rays development team or through user
    contributions, IDA’s debugger is continually evolving. The best place to keep
    up with all of these changes is the Hex-Rays blog ([http://www.hexblog.com/](http://www.hexblog.com/)),
    where the Hex-Rays developers frequently preview features that will appear in
    upcoming versions of IDA. Keeping up with user-contributed extensions requires
    a little more effort. Occasionally, interesting IDA extensions are announced in
    the IDA support forums, but you are just as likely to see them announced in various
    reverse engineering forums (such as [http://www.openrce.org/](http://www.openrce.org/)),
    see them entered into Hex-Rays’s annual plug-in writing contest, or simply stumble
    across them while performing an Internet search.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是通过 Hex-Rays 开发团队的努力还是通过用户贡献，IDA 的调试器持续发展。跟踪所有这些变化的最佳地点是 Hex-Rays 博客 ([http://www.hexblog.com/](http://www.hexblog.com/))，Hex-Rays
    开发者经常预览即将出现在 IDA 未来版本中的新功能。跟踪用户贡献的扩展需要更多的努力。偶尔，有趣的 IDA 扩展会在 IDA 支持论坛中宣布，但你同样有可能在各个逆向工程论坛（如
    [http://www.openrce.org/](http://www.openrce.org/)）中看到它们，或者它们被提交到 Hex-Rays 的年度插件编写大赛中，或者在执行网络搜索时偶然发现。
- en: IDA’s debugger is both full featured and extensible. With both local and remote
    capabilities, as well as the ability to act as a frontend to a number of popular
    debuggers such as gdb and WinDbg, IDA offers a consistent debugging interface
    across a large number of popular platforms. Given the ability to script extensions
    or build compiled debugger plug-ins, the limits of the debugger’s capabilities
    are constantly being extended. Among current debuggers, IDA’s debugger enjoys
    perhaps the most active development and benefits from the fact that all of its
    core developers are themselves accomplished reverse engineers who share a personal
    as well as professional interest in making the debugger a powerful and useful
    tool.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的调试器功能全面且可扩展。它具备本地和远程功能，同时还能作为多个流行调试器（如 gdb 和 WinDbg）的前端，IDA 为众多流行平台提供了一个一致的调试接口。鉴于可以编写扩展脚本或构建编译后的调试器插件，调试器的功能极限不断被扩展。在当前的调试器中，IDA
    的调试器可能拥有最活跃的开发活动，并得益于其所有核心开发者都是自身成就卓著的反汇编工程师这一事实，他们既在个人层面也在职业层面都对使调试器成为一个强大且实用的工具有着浓厚的兴趣。
