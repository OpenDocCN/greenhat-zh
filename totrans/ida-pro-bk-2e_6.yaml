- en: Part VI. The IDA Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 24. The IDA Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: IDA is most widely known as a disassembler, and it is clearly one of the finest
    tools available for performing static analysis of binaries. Given the sophistication
    of modern anti–static analysis techniques, it is not uncommon to combine static
    analysis tools and techniques with dynamic analysis tools and techniques in order
    to take advantage of the best of both worlds. Ideally, all of these tools would
    be integrated into a single package. Hex-Rays made that move when it introduced
    a debugger in version 4.5 of IDA and solidified IDA’s role as a general-purpose
    reverse engineering tool. With each successive version of IDA, its debugging capabilities
    have been improved. In its latest version, IDA is capable of local and remote
    debugging on a number of different platforms and supports a number of different
    processors. IDA may also be configured to act as a frontend to Microsoft’s WinDbg
    debugger, making it possible to perform Windows kernel debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of the next few chapters, we will cover the basic features of
    IDA’s debugger, using the debugger to assist with obfuscated code analysis and
    remote debugging of Windows, Linux, or OS X binaries. While we assume that the
    reader possesses some familiarity with the use of debuggers, we will review many
    of the basic capabilities of debuggers in general as we progress through the features
    of IDA’s debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debuggers are typically used to perform one of two tasks: examining memory
    images (core dumps) associated with crashed processes and executing processes
    in a very controlled manner. A typical debugging session begins with the selection
    of a process to debug. There are two ways this is generally accomplished. First,
    most debuggers are capable of *attaching* to a running process (assuming the user
    has permission to do so). Depending on the debugger being used, the debugger itself
    may be able to present a list of available processes to choose from. Lacking such
    capability, the user must determine the ID of the process to which he wishes to
    attach and then command the debugger to attach to the specified process. The precise
    manner by which a debugger attaches to a process varies from one operating system
    to another and is beyond the scope of this book. When attaching to an existing
    process, it is not possible to monitor or control the process’s initial start-up
    sequence, because all of the startup and initialization code will already have
    completed before you have a chance to attach to the process.'
  prefs: []
  type: TYPE_NORMAL
- en: The manner by which you attach to a process with the IDA debugger depends on
    whether a database is currently open or not. When no database is open, the Debugger
    ▸ Attach menu is available, as shown in [Figure 24-1](ch24.html#attaching_to_an_arbitrary_process
    "Figure 24-1. Attaching to an arbitrary process").
  prefs: []
  type: TYPE_NORMAL
- en: '![Attaching to an arbitrary process](httpatomoreillycomsourcenostarchimages854356.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-1. Attaching to an arbitrary process
  prefs: []
  type: TYPE_NORMAL
- en: Available options allow selection of different IDA debuggers (remote debugging
    is covered in [Chapter 26](ch26.html "Chapter 26. Additional Debugger Features")).
    Options vary depending on the platform on which you are running IDA. Selecting
    a local debugger causes IDA to display a list of running processes to which you
    may attach. [Figure 24-2](ch24.html#debugger_process-selection_dialog "Figure 24-2. Debugger
    process-selection dialog") shows an example of such a list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger process-selection dialog](httpatomoreillycomsourcenostarchimages854359.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-2. Debugger process-selection dialog
  prefs: []
  type: TYPE_NORMAL
- en: Once a process has been selected, the debugger creates a temporary database
    by taking a memory snapshot of the running process. In addition to the memory
    image of the running process, the temporary database contains sections for all
    shared libraries loaded by the process, resulting in a substantially larger and
    more cluttered database than you may be accustomed to. One drawback to attaching
    to a process in this manner is that IDA has less information available to disassemble
    the process because IDA’s loader never processes the corresponding executable
    file image and an automated analysis of the binary is never performed. In fact,
    once the debugger has attached to the process, the only instructions that will
    be disassembled in the binary are the instruction referenced by the instruction
    pointer and those that flow from it. Attaching to a process immediately pauses
    the process, allowing you the opportunity to set breakpoints prior to resuming
    execution of the process.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate way to attach to a running process is to open the associated executable
    in IDA before attempting to attach to the running process. With a database open,
    the Debugger menu takes on an entirely different form, as shown in [Figure 24-3](ch24.html#debugger_menu_with_a_database_open
    "Figure 24-3. Debugger menu with a database open").
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger menu with a database open](httpatomoreillycomsourcenostarchimages854362.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-3. Debugger menu with a database open
  prefs: []
  type: TYPE_NORMAL
- en: If you are not presented with this menu (or one very like it), then you probably
    have not yet specified a debugger to use for the currently open file type. In
    such cases, Debugger ▸ Select Debugger will present a list of suitable debuggers
    given the current file type. [Figure 24-4](ch24.html#debugger_selection_dialog
    "Figure 24-4. Debugger selection dialog") shows a typical debugger selection dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger selection dialog](httpatomoreillycomsourcenostarchimages854365.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-4. Debugger selection dialog
  prefs: []
  type: TYPE_NORMAL
- en: You may make your selection the default debugger for the current file type by
    checking the box at the bottom of the dialog. The current default debugger, if
    any, is noted just above the checkbox. Once you have selected a debugger, you
    may change debuggers at any time via the Debug ▸ Switch Debugger menu.
  prefs: []
  type: TYPE_NORMAL
- en: When Debugger ▸ Attach to Process is selected, IDA’s behavior will vary depending
    on the type of file opened in the active database. If the file is an executable
    file, IDA will display a list of all processes that have the same name as the
    file opened in the database. If IDA can find no process with a matching name,
    IDA will display a list of every running process and leave it to you to choose
    the correct process to attach to. In any case, you may attach to any of the displayed
    processes, but IDA has no way to guarantee that the process was started with same
    binary image that is loaded in the open IDA database.
  prefs: []
  type: TYPE_NORMAL
- en: IDA behaves differently if the currently open database is a shared library.
    On Windows systems, IDA will filter the displayed process list to just those processes
    that have the corresponding *.dll* file loaded. For example, if you are currently
    analyzing *wininet.dll* in IDA, then when you select Debugger ▸ Attach to Process,
    you will see only those processes that currently have *wininet.dll* loaded. On
    Linux and OS X systems, IDA does not have this filtering ability and displays
    every process to which you have the rights to attach.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to attaching to an existing process, you may opt to launch
    a new process under debugger control. With no database open, a new process can
    be launched via Debugger ▸ Run. When a database is open, a new process can be
    launched via Debugger ▸ Start Process or Debugger ▸ Run to Cursor. Using the former
    causes the new process to execute until it hits a breakpoint (which you need to
    have set prior to choosing Debugger ▸ Start Process) or until you elect to pause
    the process using Debugger ▸ Pause Process. Using Debugger ▸ Run to Cursor automatically
    sets a breakpoint at the current cursor location prior to starting the new process.
    In this case, the new process will execute until the current cursor location is
    reached or until an earlier breakpoint is hit. If execution never reaches the
    current cursor location (or any other breakpoint), the process will continue to
    run until it is forcibly paused or terminated (Debugger ▸ Terminate Process).
  prefs: []
  type: TYPE_NORMAL
- en: Launching a process under debugger control (as opposed to attaching to an existing
    process) is the only way to monitor every action the process takes. With breakpoints
    set prior to process initiation, it becomes possible to closely monitor a process’s
    entire startup sequence. Controlling startup sequences is particularly important
    in the case of programs that have been obfuscated, because you will often want
    to pause the process immediately after the de-obfuscation routines complete and
    before the process begins its normal operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage to launching a process from an open IDA database is that IDA
    performs its initial autoanalysis on the process image before launching the process.
    This results in significantly better disassembly quality over that attained when
    attaching the debugger to an existing process.
  prefs: []
  type: TYPE_NORMAL
- en: IDA’s debugger is capable of both local and remote debugging. For local debugging,
    you can only debug binaries that will run on your platform. There is no emulation
    layer that allows binaries from alternate platforms or CPU types to be executed
    within IDA’s local debugger. For remote debugging, IDA ships with a number of
    debugging servers including implementations for Windows 32/64, Windows CE/ARM,
    Mac OS X 32/64, Linux 32/64/ARM, and Android. The debugging servers are intended
    to execute alongside the binary that you intend to debug. Once you have a remote
    debugging server running, IDA can communicate with the server to launch or attach
    to a target process on the remote machine. For Windows CE ARM devices, IDA communicates
    with the remote device using ActiveSync and installs the debugging server remotely.
    IDA is also capable of communicating with the `gdbserver`^([[216](#ftn.CHP-24-FN-1)])
    component of the GNU Debugger^([[217](#ftn.CHP-24-FN-2)]) (gdb) or with programs
    that are linked with a suitable gdb remote stub.^([[218](#ftn.CHP-24-FN-3)]) Finally,
    for remote debugging on Symbian devices, you must install and configure Metrowerk’s
    App TRK^([[219](#ftn.CHP-24-FN-4)]) in order for IDA to communicate with the device
    over a serial port. In any case, IDA is capable of acting as a debugger frontend
    only for processing running on x86, x64, MIPS, ARM, and PPC processors. Remote
    debugging is discussed in [Chapter 26](ch26.html "Chapter 26. Additional Debugger
    Features").
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any other debugger, if you intend to use IDA’s debugger to launch new
    processes, the original executable file is required to be present on the debugging
    host, and the original binary will be executed with the full privileges of the
    user running IDA. In other words, it is not sufficient to have only an IDA database
    loaded with the binary you wish to debug. This is extremely important to understand
    if you intend to use the IDA debugger for malware analysis. You can easily infect
    the debugging target machine if you fail to properly control the malware sample.
    IDA attempts to warn you of this possibility anytime you select Debugger ▸ Start
    Process (or Debugger ▸ Attach to process with an open database) by displaying
    a debugger warning message stating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You are going to launch the debugger. Debugging a program means that its code
    will be executed on your system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be careful with malicious programs, viruses and trojans!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'REMARK: if you select ‘No’, the debugger will be automatically disabled.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you sure you want to continue?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Selecting No in response to this warning causes the Debugger menu to be removed
    from the IDA menu bar. The Debugger menu will not be restored until you close
    the active database.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that you perform any debugging of malicious software
    within a sandbox environment. In contrast, the x86 emulator plug-in discussed
    in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis") neither requires
    that the original binary be present nor executes any of the binary’s instructions
    on the machine performing the emulation.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[216](#CHP-24-FN-1)]) See [http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server](http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[217](#CHP-24-FN-2)]) See [http://www.gnu.org/software/gdb/](http://www.gnu.org/software/gdb/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[218](#CHP-24-FN-3)]) See [http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub](http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[219](#CHP-24-FN-4)]) See [http://www.tools.ext.nokia.com/agents/index.htm](http://www.tools.ext.nokia.com/agents/index.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Basic Debugger Displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of how you happen to launch the debugger, once your process of interest
    has been paused under debugger control, IDA enters its debugger mode (as opposed
    to normal disassembly mode), and you are presented with several default displays.
    The default debugger display is shown in [Figure 24-5](ch24s02.html#ida_debugger_display
    "Figure 24-5. IDA debugger display").
  prefs: []
  type: TYPE_NORMAL
- en: '![IDA debugger display](httpatomoreillycomsourcenostarchimages854367.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-5. IDA debugger display
  prefs: []
  type: TYPE_NORMAL
- en: If you are accustomed to using other Windows debuggers such as OllyDbg^([[220](#ftn.CHP-24-FN-5)])
    or Immunity Debugger,^([[221](#ftn.CHP-24-FN-6)]) one of your first thoughts might
    be that not much information is displayed on the screen. This is primarily a result
    of the fact that IDA defaults to a font size that is actually readable. If you
    find yourself missing the micro fonts used in other debuggers, you can easily
    change things via the Options ▸ Font menu. You may also wish to make use of saved
    IDA desktops (Windows ▸ Save Desktop) if you develop a fondness for a specific
    layout of your debugger windows.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the [Figure 24-5](ch24s02.html#ida_debugger_display "Figure 24-5. IDA
    debugger display"), the debugger toolbar ![](httpatomoreillycomsourcenostarchimages854061.png)
    replaces the disassembly toolbar. A number of standard (from a debugging standpoint)
    tools are present, including process control tools and breakpoint manipulation
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: The IDA View-EIP ![](httpatomoreillycomsourcenostarchimages854063.png) disassembly
    window is a default disassembly listing window when the debugger is active. It
    also happens to be synchronized with the current value of the instruction pointer
    register. If IDA detects that a register points to a memory location within the
    disassembly window, the name of that register is displayed in the left margin,
    opposite the address to which the register points. In [Figure 24-5](ch24s02.html#ida_debugger_display
    "Figure 24-5. IDA debugger display"), the location to which EIP points is flagged
    in IDA View-EIP (note that EDX also points to the same location in this example).
    By default, IDA highlights breakpoints in red and the next instruction to be executed
    (the one to which the instruction pointer points) in blue. Debugger-related disassemblies
    are generated via the same disassembly process used in standard disassembly mode.
    Thus, IDA’s debugger offers perhaps the best disassembly capability to be found
    in a debugger. Additionally, if you launched the debugger from an open IDA database,
    IDA is able to characterize all of the executable content based on analysis performed
    prior to launching the debugger. IDA’s ability to disassemble any library code
    that has been loaded by the process will be somewhat more limited because IDA
    has not had a chance to analyze the associated *.dll* file prior to launching
    the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack View ![](httpatomoreillycomsourcenostarchimages854093.png) window
    is another standard disassembly view primarily used to display the data contents
    of the process’s runtime stack. All registers that point to stack locations are
    noted as such in the General Registers ![](httpatomoreillycomsourcenostarchimages854095.png)
    view (such as EBP in this case). Through the use of comments, IDA makes every
    attempt to provide context information for each data item on the stack. When the
    stack item is a memory address, IDA attempts to resolve the address to a function
    location (this helps highlight the location from which a function was called).
    When the stack item is a data pointer, a reference to the associated data item
    is displayed. The remaining default displays include the Hex view ![](httpatomoreillycomsourcenostarchimages854099.png),
    which offers a standard hex dump of memory, the Modules ![](httpatomoreillycomsourcenostarchimages854101.png)
    view, which displays a list of modules currently loaded in the process image,
    and the Threads ![](httpatomoreillycomsourcenostarchimages854103.png) view, which
    displays a list of threads in the current process. Double-clicking any listed
    thread causes the IDA View-EIP disassembly window to jump to the current instruction
    within the selected thread and updates the General Registers view to reflect the
    current values for registers within the selected thread.
  prefs: []
  type: TYPE_NORMAL
- en: The General Registers window (also shown in [Figure 24-6](ch24s02.html#the_general_registers_display
    "Figure 24-6. The General Registers display")) displays the current contents of
    the CPU’s general-purpose registers. Additional windows for displaying the contents
    of the CPU’s segment, floating-point, or MMX registers may be opened from the
    Debugger menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![The General Registers display](httpatomoreillycomsourcenostarchimages854370.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-6. The General Registers display
  prefs: []
  type: TYPE_NORMAL
- en: Within the General Registers window, register contents are displayed to the
    right of the associated register name followed by a description of each register’s
    content. The CPU flag bits are displayed down the rightmost column. Right-clicking
    a register value or flag bit provides access to a Modify menu item, which allows
    you to change the contents of any register or CPU flag. Menu options offer quick
    access to zero a value, toggle a value, increment a value, or decrement a value.
    Toggling values is particularly useful for changing CPU flag bits. Right-clicking
    any register value also provides access to the Open Register Window menu item.
    Selecting Open Register Window causes IDA to open a new disassembly window centered
    at the memory location held in the selected register. If you ever find that you
    have inadvertently closed either IDA View-EIP or IDA View-ESP, use the Open Register
    Window command on the appropriate register to reopen the lost window. If a register
    appears to point to a valid memory location, then the right-angle arrow control
    to the right of that register’s value will be active and highlighted in black.
    Clicking an active arrow opens a new disassembly view centered on the corresponding
    memory location.
  prefs: []
  type: TYPE_NORMAL
- en: The Modules window displays a list of all executable files and shared libraries
    loaded into the process memory space. Double-clicking any module named in the
    list opens a list of symbols exported by that module. [Figure 24-7](ch24s02.html#the_modules_window_with_associated_modul
    "Figure 24-7. The Modules window with associated module contents") shows an example
    of the contents of *kernel32.dll*. The symbol list provides an easy way to track
    down functions within loaded libraries if you wish to set breakpoints on entry
    to those functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Modules window with associated module contents](httpatomoreillycomsourcenostarchimages854373.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-7. The Modules window with associated module contents
  prefs: []
  type: TYPE_NORMAL
- en: Additional debugger displays are accessible using various debugger menu selections.
    Displays pertaining to debugger operations will be discussed in the following
    section, “Process Control.” Along with the debugger-specific displays, all traditional
    IDA subviews, such as Functions and Segments, remain available via the Views ▸
    Open Subviews command.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[220](#CHP-24-FN-5)]) See [http://www.ollydbg.de/](http://www.ollydbg.de/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[221](#CHP-24-FN-6)]) See [http://www.immunityinc.com/products-immdbg.shtml](http://www.immunityinc.com/products-immdbg.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: Process Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most important feature of any debugger is the ability to closely
    control—and modify, if desired—the behavior of the process being debugged. To
    that end, most debuggers offer commands that allow one or more instructions to
    be executed before returning control to the debugger. Such commands are often
    used in conjunction with breakpoints that allow the user to specify that execution
    should be interrupted when a designated instruction is reached or when a specific
    condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: Basic execution of a process under debugger control is accomplished through
    the use of various Step, Continue, and Run commands. Because they are used so
    frequently, it is helpful to become familiar with the toolbar buttons and hotkey
    sequences associated with these commands. [Figure 24-8](ch24s03.html#debugger_process_control_tools
    "Figure 24-8. Debugger process control tools") shows the toolbar buttons associated
    with execution of a process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger process control tools](httpatomoreillycomsourcenostarchimages854376.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-8. Debugger process control tools
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of each of these commands is described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Continue** Resumes execution of a paused process. Execution continues until
    a breakpoint is hit, the user pauses or terminates execution, or the process terminates
    on its own. |'
  prefs: []
  type: TYPE_TB
- en: '| **Pause** Pauses a running process. |'
  prefs: []
  type: TYPE_TB
- en: '| **Terminate** Terminates a running process. |'
  prefs: []
  type: TYPE_TB
- en: '| **Step Into** Executes the next instruction only. If the next instruction
    is a function call, breaks on the first instruction of the target function. Hence
    the name *Step Into*, since execution steps into any function being called. |'
  prefs: []
  type: TYPE_TB
- en: '| **Step Over** Executes the next instruction only. If the next instruction
    is a function call, treats the call as a single instruction, breaking once the
    function returns. Hence the name *Step Over*, since stepping proceeds over functions
    rather than through them as with Step Into. Execution may be interrupted prior
    to completion of the function call if a breakpoint is encountered. Step Over is
    very useful as a time-saver when the behavior of a function is well known and
    uninteresting. |'
  prefs: []
  type: TYPE_TB
- en: '| **Run Until Return** Resumes execution of the current function and does not
    stop until that function returns (or a breakpoint is encountered). This operation
    is useful when you have seen enough of a function and you wish to get out of it
    or when you inadvertently step into a function that you meant to step over. |'
  prefs: []
  type: TYPE_TB
- en: '| **Run to Cursor** Resumes execution of the process and stops when execution
    reaches the current cursor location (or a breakpoint is hit). This feature is
    useful for running through large blocks of code without the need to set a permanent
    breakpoint at each location where you wish to pause. Beware that the program may
    not pause if the cursor location is bypassed or otherwise never reached. |'
  prefs: []
  type: TYPE_TB
- en: In addition to toolbar and hotkey access, all of the execution control commands
    are accessible via the Debugger menu. Regardless of whether a process pauses after
    a single step or hitting a breakpoint, each time the process pauses, all debugger-related
    displays are updated to reflect the state of the process (CPU registers, flags,
    memory contents) at the time the process was paused.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Breakpoints* are a debugger feature that goes hand in hand with process execution
    and interruption (pausing). Breakpoints are set as a means of interrupting program
    execution at very specific locations within the program. In a sense a breakpoint
    is a more permanent extension of the Run to Cursor concept in that once a breakpoint
    is set at a given address, execution will always be interrupted when execution
    reaches that location, regardless of whether the cursor remains positioned on
    that location or not. However, while there is only one cursor to which execution
    can run, it is possible to set many breakpoints all over a program, the arrival
    at any one of which will interrupt execution of the program. Breakpoints are set
    in IDA by navigating to the location at which you want execution to pause and
    using the F2 hotkey (or right-clicking and selecting Add Breakpoint). Addresses
    at which breakpoints have been set are highlighted with a red (by default) band
    across the entire disassembly line. A breakpoint may be removed by pressing F2
    a second time to toggle the breakpoint off. A complete list of breakpoints currently
    set within a program may be viewed via Debugger ▸ Breakpoints ▸ Breakpoint List.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, IDA utilizes *software breakpoints*, which are implemented by replacing
    the opcode byte at the breakpoint address with a software breakpoint instruction.
    For x86 binaries, this is the `int 3` instruction, which uses opcode value `0xCC`.
    Under normal circumstances, when a software breakpoint instruction is executed,
    the operating system transfers control to any debugger that may be monitoring
    the interrupted process. As discussed in [Chapter 21](ch21.html "Chapter 21. Obfuscated
    Code Analysis"), obfuscated code may take advantage of the behavior of software
    breakpoints in an attempt to hinder normal operation of any attached debugger.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to software breakpoints, some CPUs (such as the x86, actually
    386, and later) offer support for *hardware-assisted breakpoints*. Hardware breakpoints
    are typically configured through the use of dedicated CPU registers. For x86 CPUs,
    these registers are called DR0–7 (debug registers 0 through 7). A maximum of four
    hardware breakpoints can be specified using x86 registers DR0–3\. The remaining
    x86 debug registers are used to specify additional constraints on each breakpoint.
    When a hardware breakpoint is enabled, there is no need to substitute a special
    instruction into the program being debugged. Instead, the CPU itself decides whether
    execution should be interrupted or not based on values contained within the debug
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: Once a breakpoint has been set, it is possible to modify various aspects of
    its behavior. Beyond simply interrupting the process, debuggers often support
    the concept of *conditional breakpoints*, which allow users to specify a condition
    that must be satisfied before the breakpoint is actually honored. When such a
    breakpoint is reached and the associated condition is not satisfied, the debugger
    automatically resumes execution of the program. The general idea is that the condition
    is expected to be satisfied at some point in the future, resulting in interruption
    of the program only when the condition you are interested in has been satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: The IDA debugger supports both conditional and hardware breakpoints. In order
    to modify the default (unconditional, software-based) behavior of a breakpoint,
    you must edit a breakpoint after it has been set. In order to access the breakpoint-editing
    dialog, you must right-click an existing breakpoint and select Edit Breakpoint.
    [Figure 24-9](ch24s03.html#the_breakpoint_settings_dialog "Figure 24-9. The Breakpoint
    Settings dialog") shows the resulting Breakpoint Settings dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Breakpoint Settings dialog](httpatomoreillycomsourcenostarchimages854379.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-9. The Breakpoint Settings dialog
  prefs: []
  type: TYPE_NORMAL
- en: The Location box indicates the address of the breakpoint being edited, while
    the Enabled checkbox indicates whether the breakpoint is currently active or not.
    A breakpoint that is disabled is not honored regardless of any condition that
    may be associated with the breakpoint. The Hardware checkbox is used to request
    that the breakpoint be implemented in hardware rather than software.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A word of caution concerning hardware breakpoints: Though the x86 only supports
    four hardware breakpoints at any given time, as of this writing (IDA version 6.1),
    IDA will happily allow you to designate more than four hardware breakpoints. However,
    only four of them will be honored. Any additional hardware breakpoints will be
    ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: When specifying a hardware breakpoint, you must use the Hardware breakpoint
    mode radio buttons to specify whether the breakpoint behavior is to break on execute,
    break on write, or break on read/write. The latter two categories (break on write
    and break on read/write) allow you to create breakpoints that trigger when a specific
    memory location (usually a data location) is accessed, regardless of what instruction
    happens to be executing at the time the access takes place. This is very useful
    if you are more interested in when your program accesses a piece of data than
    where the data is accessed from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to specifying a mode for your hardware breakpoint, you must specify
    a size. For execute breakpoints the size must be 1 byte. For write or read/write
    breakpoints, the size may be set to 1, 2, or 4 bytes. When the size is set to
    2 bytes, the breakpoint’s address must be word aligned (a multiple of 2 bytes).
    Similarly, for 4-byte breakpoints, the breakpoint address must be double-word
    aligned (a multiple of 4 bytes). A hardware breakpoint’s size is combined with
    its address to form a range of bytes over which the breakpoint may be triggered.
    An example may help to explain. Consider a 4-byte write breakpoint set at address
    `0804C834h`. This breakpoint will be triggered by a 1-byte write to `0804C837h`,
    a 2-byte write to `0804C836h`, and a 4-byte write to `0804C832h`, among others.
    In each of these cases, at least 1 byte in the range `0804C834h0804C837h` is written.
    More information on the behavior of x86 hardware breakpoints can be found in the
    *Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B: System
    Programming Guide, Part 2*.^([[222](#ftn.CHP-24-FN-7)])'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional breakpoints are created by providing an expression in the Breakpoint
    Settings dialog’s Condition field. Conditional breakpoints are a debugger feature,
    not an instruction set or CPU feature. When a breakpoint is triggered, it is the
    debugger’s job to evaluate any associated conditional expression and determine
    whether the program should be paused (the condition is met) or whether execution
    should simply continue (the condition is not met). Therefore, conditions may be
    specified for both software and hardware breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: IDA breakpoint conditions are specified using IDC (not Python) expressions.
    Expressions that evaluate to non-zero are considered true, satisfying the breakpoint
    condition and triggering the breakpoint. Expressions that evaluate to zero are
    considered false, failing to satisfy the breakpoint condition and failing to trigger
    the associated breakpoint. In order to assist in the creation of breakpoint expressions,
    IDA makes special register variables available within IDC (again, not Python)
    to provide direct access to register contents in breakpoint expressions. These
    variables are named after the registers themselves and include `EAX`, `EBX`, `ECX`,
    `EDX`, `ESI`, `EDI`, `EBP`, `ESP`, `EFL`, `AX`, `BX`, `CX`, `DX`, `SI`, `DI`,
    `BP`, `SP`, `AL`, `AH`, `BL`, `BH`, `CL`, `CH`, `DL`, and `DH`. These register
    variables are accessible only when the debugger is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, no variables exist that allow direct access to the processor
    flag bits. In order to access individual CPU flags, you need to call the `GetRegValue`
    function to obtain the value of the desired flag bit, such as `CF`. If you need
    a reminder regarding valid register and flag names, refer to the labels along
    the left and right edges of the General Registers window. A few example breakpoint
    expressions are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Two things to note about breakpoint expressions are the fact that IDC functions
    may be called to access process information (as long as the function returns a
    value) and the fact that assignment can be used as a means of modifying register
    values at specific locations during process execution. Ilfak himself demonstrated
    this technique as an example of overriding a function return value.^([[223](#ftn.CHP-24-FN-8)])
  prefs: []
  type: TYPE_NORMAL
- en: The last breakpoint options that can be configured in the Breakpoint Settings
    dialog are grouped into the Actions box on the right side of the dialog. The Break
    checkbox specifies whether program execution should actually be paused (assuming
    any associated condition is true) when the break-point is reached. It may seem
    unusual to create a breakpoint that doesn’t break, but this is actually a useful
    feature if all you want to do is modify a specific memory or register value each
    time an instruction is reached without requiring the program to be paused at the
    same time. Selecting the Trace checkbox causes a trace event to be logged each
    time the breakpoint is hit.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tracing offers a means of logging specific events that occur while a process
    is executing. Trace events are logged to a fixed-size trace buffer and may optionally
    be logged to a trace file. Two styles of tracing are available: instruction tracing
    and function tracing. When *instruction tracing* is enabled (Debugger ▸ Tracing
    ▸ Instruction Tracing), IDA records the address, the instruction, and the values
    of any registers (other than EIP) that were changed by the instruction. Instruction
    tracing can slow down a debugged process considerably, because the debugger must
    single-step the process in order to monitor and record all register values. *Function
    tracing* (Debugger ▸ Tracing ▸ Function Tracing) is a subset of instruction tracing
    in which only function calls (and optionally returns) are logged. No register
    values are logged for function trace events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three types of individual trace events are also available: write traces, read/write
    traces, and execution traces. As their names imply, each allows logging of a trace
    event when a specific action occurs at a designated address. Each of these individual
    traces is implemented using nonbreaking breakpoints with the `trace` option set.
    Write and read/write traces are implemented using hardware breakpoints and thus
    fall under the same restrictions mentioned previously for hardware breakpoints,
    the most significant being that no more than four hardware-assisted breakpoints
    or traces may be active at any given time. By default, execution traces are implemented
    using software breakpoints, and thus there is no limit on the number of execution
    traces that can be set within a program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 24-10](ch24s03.html#the_tracing_options_dialog "Figure 24-10. The Tracing
    Options dialog") shows the Tracing Options (Debugger ▸ Tracing ▸ Tracing Options)
    dialog used to configure the debugger’s tracing operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Options specified here apply to function and instruction tracing only. These
    options have no effect on individual trace events. The Trace buffer size option
    specifies the maximum number of trace events that may be displayed at any given
    time. For a given buffer size *n*, only the *n* most recent trace events are displayed.
    Naming a log file causes all trace events to be appended to the named file. A
    file dialog is not offered when specifying a log file, so you must specify the
    complete path to the log file yourself. An IDC expression may be entered as a
    stop condition. The condition is evaluated prior to tracing through each instruction.
    If the condition evaluates to true, execution is immediately paused. The effect
    of this expression is to act as a conditional breakpoint that is not tied to any
    specific location.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Tracing Options dialog](httpatomoreillycomsourcenostarchimages854383.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-10. The Tracing Options dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'The Mark consecutive traced events with same IP option, when checked, causes
    consecutive trace events originating from the same instruction (*IP* here means
    *Instruction Pointer*) to be flagged with an equal sign. An example in which consecutive
    events can originate at the same instruction address occurs when the `REP`^([[224](#ftn.CHP-24-FN-9)])
    prefix is used in `x86` programs. In order for an instruction trace to show each
    repetition at the same instruction address, the Log if same IP option must also
    be selected. Without this option selected, an instruction prefixed with `REP`
    is listed only once each time it is encountered. The following listing shows a
    partial instruction trace using the default trace settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `movsb` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    is listed only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following listing, Log if same IP has been selected, resulting in each
    iteration of the `rep` loop being logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the following listing, the Mark consecutive traced events with
    same IP option has been enabled, resulting in special markings that highlight
    the fact that the instruction pointer has not changed from one instruction to
    the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last two options we will mention concerning tracing are Trace over debugger
    segments and Trace over library functions. When Trace over debugger segments is
    selected, instruction and function call tracing is temporarily disabled anytime
    execution proceeds to a program segment outside any of the file segments originally
    loaded into IDA. The most common example of this is a call to a shared library
    function. Selecting Trace over library functions temporarily disables function
    and instruction tracing anytime execution enters a function that IDA has identified
    as a library function (perhaps via FLIRT signature matching). Library functions
    linked into a binary should not be confused with library functions that a binary
    accesses via a shared library file such as a DLL. Both of these options are enabled
    by default, resulting in better performance while tracing (because the debugger
    does not need to step into library code) as well as a substantial reduction in
    the number of trace events generated, since instruction traces through library
    code can rapidly fill the trace buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Traces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *stack trace* is a display of the current call stack, or sequence of function
    calls that have been made in order for execution to reach a particular location
    within a binary. [Figure 24-11](ch24s03.html#a_sample_stack_trace "Figure 24-11. A
    sample stack trace") shows a sample stack trace generated using the Debugger ▸
    Stack Trace command.
  prefs: []
  type: TYPE_NORMAL
- en: '![A sample stack trace](httpatomoreillycomsourcenostarchimages854386.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-11. A sample stack trace
  prefs: []
  type: TYPE_NORMAL
- en: The top line in a stack trace lists the name of the function currently executing.
    The second line indicates the function that called the current function and the
    address from which that call was made. Successive lines indicate the point from
    which each function was called. A debugger is able to create a stack trace display
    by walking the stack and parsing each stack frame that it encounters, and it typically
    relies on the contents of the frame pointer register (EBP for x86) to locate the
    base of each stack frame. When a stack frame is located, the debugger can extract
    a pointer to the next stack frame (the saved frame pointer) as well as the saved
    return address, which is used to locate the call instruction used to invoke the
    current function. IDA’s debugger cannot trace through stack frames that do not
    utilize EBP as a frame pointer. At the function (rather than individual instruction)
    level, stack traces are useful for answering the question, “How did I get here?”
    or, more correctly, “What sequence of function calls led to this particular location?”
  prefs: []
  type: TYPE_NORMAL
- en: Watches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While debugging a process, you may wish to constantly monitor the value contained
    in one or more variables. Rather than requiring you to navigate to the desired
    memory locations each time the process is paused, many debuggers allow you to
    specify lists of memory locations whose values should be displayed each time the
    process is stopped in the debugger. Such lists are called *watch lists*, because
    they allow you to watch as the contents of designated memory locations change
    during program execution. Watch lists are simply a navigational convenience; they
    do not cause execution to pause like a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Because they are focused on data, watch points (addresses designated to be watched)
    are most commonly set in the stack, heap, or data sections of a binary. Watches
    are set in the IDA debugger by right-clicking a memory item of interest and selecting
    Add Watch. Determining exactly which address to set a watch on may require some
    thought. Determining the address of a global variable is somewhat less challenging
    than determining the address of a local variable because global variables are
    allocated and assigned fixed addresses at compile time. Local variables, on the
    other hand, don’t exist until runtime, and even then they exist only once the
    function in which they are declared has been called. With the debugger active,
    once you have stepped into a function, IDA is capable of reporting the addresses
    of local variables within that function. [Figure 24-12](ch24s03.html#debugger_resolution_of_a_local_variable
    "Figure 24-12. Debugger resolution of a local variable address") shows the result
    of mousing over a local variable named `arg_0` (actually a parameter passed into
    the function).
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger resolution of a local variable address](httpatomoreillycomsourcenostarchimages854389.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-12. Debugger resolution of a local variable address
  prefs: []
  type: TYPE_NORMAL
- en: Double-clicking a local variable within an active function causes IDA to jump
    the main IDA View window to the address of that local variable. Having arrived
    at the variable’s address, you may then add a watch on that address using the
    Add Watch context-sensitive menu option, though you will need to manually enter
    the address into the Watch Address dialog. If, instead, you take the time to name
    the memory location, IDA will automatically add a watch if you apply the same
    menu option to the name rather than the address.
  prefs: []
  type: TYPE_NORMAL
- en: You can access a list of all watches currently in effect via Debugger ▸ Watches
    ▸ Watch List. You can delete individual watches by highlighting the desired watch
    in the watch list and pressing DELETE.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[222](#CHP-24-FN-7)]) See [http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[223](#CHP-24-FN-8)]) See [http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html](http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html)
    and [http://www.hexblog.com/2005/11/stealth_plugin_1.html](http://www.hexblog.com/2005/11/stealth_plugin_1.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[224](#CHP-24-FN-9)]) The `REP` prefix is an instruction modifier that causes
    certain x86 string instructions such as `movs` and `scas` to be repeated based
    on a count contained in the ECX register.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Debugger Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") through [Chapter 19](ch19.html
    "Chapter 19. IDA Processor Modules"), we covered the basics of IDA scripting and
    the IDA SDK and demonstrated the usefulness of these capabilities during static
    analysis of binaries. Launching a process and working in the more dynamic environment
    of a debugger doesn’t make scripting and plug-ins any less useful. Interesting
    uses for the automation provided by scripts and plug-ins include analyzing runtime
    data available while a process is being debugged, implementing complex breakpoint
    conditions, and implementing measures to subvert anti-debugging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting Debugger Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the IDA scripting capabilities discussed in [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting") continue to be accessible when you are using the IDA debugger. Scripts
    may be launched from the File menu, associated with hotkeys, and invoked from
    the IDA scripting command line. In addition, user-created IDC functions may be
    referenced from breakpoint conditions and tracing termination expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Basic scripting functions offer the capability to set, modify, and enumerate
    breakpoints and the ability to read and write register and memory values. Memory
    access is provided by the `DbgByte`, `PatchDbgByte`, `DbgWord`, `PatchDbgWord`,
    `DbgDword`, and `PatchDbgDword` functions (analogous to the `Byte`, `Word`, `Dword`,
    and `Patch`*`XXX`* functions described in [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting")). Register and breakpoint manipulation is made possible by the following
    functions (please see the IDA help file for a complete list).
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetRegValue(string reg)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the value of the named register, such as EAX, as discussed previously.
    In IDC only, register values may also be easily accessed by using the desired
    register’s name as a variable within an IDC expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool SetRegValue(number val, string name)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the value of the named register, such as EAX. If you are using IDC, register
    values may also be modified directly by using the desired register name on the
    left side of an assignment statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool AddBpt(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a software breakpoint at the indicated address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool AddBptEx(long addr, long size, long type)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a breakpoint of the specified size and type at the indicated address. Type
    should be one of the `BPT_`*`xxx`* constants described in *idc.idc* or the IDA
    help file.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool DelBpt(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes a breakpoint at the specified address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetBptQty()`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of breakpoints set within a program.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetBptEA(long bpt_num)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the address at which the indicated breakpoint is set.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long/string GetBptAttr(long addr, number attr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an attribute associated with the breakpoint at the indicated address.
    The return value may be a number or a string depending on which attribute value
    has been requested. Attributes are specified using one of the `BPTATTR_`*`xxx`*
    values described in *idc.idc* or the IDA help file.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool SetBptAttr(long addr, number attr, long value)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the specified attribute of the specified breakpoint to the specified value.
    Do not use this function to set breakpoint condition expressions (use `SetBptCnd`
    instead).
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool SetBptCnd(long addr, string cond)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the breakpoint condition to the provided conditional expression, which
    must be a valid IDC expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long CheckBpt(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the breakpoint status at the specified address. Return values indicate
    whether there is no breakpoint, the breakpoint is disabled, the breakpoint is
    enabled, or the breakpoint is active. An active breakpoint is a breakpoint that
    is enabled while the debugger is also active.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script demonstrates how to install a custom IDC breakpoint-handling
    function at the current cursor location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The complexity of `my_breakpoint_condition` is entirely up to you. In this example,
    each time the breakpoint is hit, a dialog will be displayed asking the user if
    she would like to continue execution of the process or pause at the current location.
    The value returned by `my_breakpoint_condition` is used by the debugger to determine
    whether the breakpoint should be honored or ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatic control of the debugger is possible from both the SDK and through
    the use of scripts. Within the SDK, IDA utilizes an event-driven model and provides
    callback notifications to plug-ins when specific debugger events occur. Unfortunately,
    IDA’s scripting capabilities don’t facilitate the use of an event-driven paradigm
    within scripts. As a result, Hex-Rays introduced a number of scripting functions
    that allow for synchronous control of the debugger from within scripts. The basic
    approach required to drive the debugger using a script is to initiate a debugger
    action and then wait for the corresponding debugger event code. Keep in mind that
    a call to a synchronous debugger function (which is all you can do in a script)
    blocks all other IDA operations until the call completes. The following list details
    several of the debugging extensions available for scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetDebuggerEvent(long wait_evt, long timeout)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Waits for a debugger event (as specified by `wait_evt`) to take place within
    the specified number of seconds (−1 waits forever). Returns an event type code
    that indicates the type of event that was received. Specify `wait_evt` using a
    combination of one or more `WFNE_`*`xxx`* (WFNE stands for Wait For Next Event)
    flags. Possible return values are documented in the IDA help file.
  prefs: []
  type: TYPE_NORMAL
- en: '**b****`ool RunTo(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Runs the process until the specified location is reached or until a breakpoint
    is hit.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool StepInto()`**'
  prefs: []
  type: TYPE_NORMAL
- en: Steps the process one instruction, stepping into any function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool StepOver()`**'
  prefs: []
  type: TYPE_NORMAL
- en: Steps the process one instruction, stepping over any function calls. This call
    may terminate early if a breakpoint is hit.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool StepUntilRet()`**'
  prefs: []
  type: TYPE_NORMAL
- en: Runs until the current function call returns or until a breakpoint is hit.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool EnableTracing(long trace_level, long enable)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Enables (or disables) the generation of trace events. The `trace_level` parameter
    should be set to one of the `TRACE_`*`xxx`* constants defined in *idc.idc*.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetEvent`***`XXX`***`()`**'
  prefs: []
  type: TYPE_NORMAL
- en: A number of functions are available for retrieving information related to the
    current debug event. Some of these functions are valid only for specific event
    types. You should test the return value of `GetDebuggerEvent` in order to make
    sure that a particular `GetEvent`*`XXX`* function is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetDebuggerEvent` must be called after each function that causes the process
    to execute in order to retrieve the debugger’s event code. Failure to do so may
    prevent follow-up attempts to step or run the process. For example, the following
    code fragment will step the debugger only one time because `GetDebuggerEvent`
    does not get called to clear the last event type in between invocations of `StepOver`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The proper way to perform an execution action is to follow up each call with
    a call to `GetDebuggerEvent`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The calls to `GetDebuggerEvent` allow execution to continue even if you choose
    to ignore the return value from `GetDebuggerEvent`. The event type `WFNE_SUSP`
    indicates that we wish to wait for an event that results in suspension of the
    debugged process, such as an exception or a breakpoint. You may have noticed that
    there is no function that simply resumes execution of a suspended process.^([[225](#ftn.CHP-24-FN-10)])
    However, it is possible to achieve the same effect by using the `WFNE_CONT` flag
    in a call to `GetDebuggerEvent`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This particular call waits for the next available suspend event after first
    resuming execution by continuing the process from the current instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Additional functions are provided for automatically launching the debugger and
    attaching to running processes. See IDA’s help file for more information on these
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a simple debugger script for collecting statistics on the addresses
    of each executed instruction (provided the debugger is enabled) is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The script begins ![](httpatomoreillycomsourcenostarchimages854061.png) by
    testing for the presence of a global array named `stats`. If one is found, the
    array is removed and re-created so that we can start with an empty array. Next
    ![](httpatomoreillycomsourcenostarchimages854063.png), single-step tracing is
    enabled before entering a loop ![](httpatomoreillycomsourcenostarchimages854093.png)
    to drive the single-stepping process. Each time a debug event is generated, the
    address of the associated event is retrieved ![](httpatomoreillycomsourcenostarchimages854095.png),
    the current count for the associated address is retrieved from the global array
    and incremented ![](httpatomoreillycomsourcenostarchimages854099.png), and the
    array is updated with the new count ![](httpatomoreillycomsourcenostarchimages854101.png).
    Note that the instruction pointer is used as the index into the sparse global
    array, which saves time looking up the address in some other form of data structure.
    Once the process completes, a second loop ![](httpatomoreillycomsourcenostarchimages854103.png)
    is used to retrieve and print all values from array locations that have valid
    values. In this case, the only array indexes that will have valid values represent
    addresses from which instructions were fetched. The script finishes off ![](httpatomoreillycomsourcenostarchimages854133.png)
    by deleting the global array that was used to gather the statistics. Example output
    from this script is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A slight alteration of the preceding example can be used to gather statistics
    on what types of instructions are executed during the lifetime of a process. The
    following example shows the modifications required in the first loop to gather
    instruction-type data rather than address data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than attempting to classify individual opcodes, we choose to group instructions
    by mnemonics ![](httpatomoreillycomsourcenostarchimages854061.png). Because mnemonics
    are strings, we make use of the hash-table feature of global arrays to retrieve
    the current count associated with a given mnemonic ![](httpatomoreillycomsourcenostarchimages854063.png)
    and save the updated count ![](httpatomoreillycomsourcenostarchimages854093.png)
    back into the correct hash table entry. Sample output from this modified script
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger Integration") we
    will revisit the use of debugger-interaction capabilities as a means to assist
    in de-obfuscating binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Debugger Actions with IDA Plug-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 16](ch16.html "Chapter 16. The IDA Software Development Kit") you
    learned that IDA’s SDK offers significant power for developing a variety of compiled
    extensions that can be integrated into IDA and that have complete access to the
    IDA API. The IDA API offers a superset of all the capabilities available in IDC,
    and the debugging extensions are no exception. Debugger extensions to the API
    are declared in *<SDKDIR>/dbg.hpp* and include C++ counterparts to all of the
    IDC functions discussed thus far, along with a complete asynchronous debugger
    interface capability.
  prefs: []
  type: TYPE_NORMAL
- en: For asynchronous interaction, plug-ins gain access to debugger notifications
    by hooking the `HT_DBG` notification type (see *loader.hpp*). Debugger notifications
    are declared in the `dbg_notification_t` enum found in *dbg.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: Within the debugger API, commands for interacting with the debugger are typically
    defined in pairs, with one function used for synchronous interaction (as with
    scripts) and the second function used for asynchronous interaction. Generically,
    the synchronous form of a function is named `COMMAND()`, and its asynchronous
    counterpart is named `request_COMMAND()`. The `request_`*`XXX`* versions are used
    to queue debugger actions for later processing. Once you finish queuing asynchronous
    requests, you must invoke the `run_requests` function to initiate processing of
    your request queue. As your requests are processed, debugger notifications will
    be delivered to any callback functions that you may have registered via `hook_to_notification_point`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using asynchronous notifications, we can develop an asynchronous version of
    the address-counting script from the previous section. The first task is to make
    sure that we hook and unhook debugger notifications. We will do this in the plug-in’s
    `init` and `term` methods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have also elected to declare a global netnode ![](httpatomoreillycomsourcenostarchimages854061.png),
    which we will use to collect statistics. Next we consider what we want the plug-in
    to do when it is activated via its assigned hotkey. Our example plug-in `run`
    function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using asynchronous techniques in this example, we must first submit
    a request to enable step tracing ![](httpatomoreillycomsourcenostarchimages854061.png)
    and then submit a request to resume execution of the process being debugged. For
    the sake of simplicity, we will gather statistics on the current function only,
    so we will issue a request to run until the current function returns ![](httpatomoreillycomsourcenostarchimages854063.png).
    With our requests properly queued, we kick things off by invoking `run_requests`
    to process the current request queue ![](httpatomoreillycomsourcenostarchimages854093.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains is to process the notifications that we expect to receive
    by creating our `HT_DBG` callback function. A simple callback that processes only
    two messages is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `dbg_trace` notification ![](httpatomoreillycomsourcenostarchimages854061.png)
    will be received for each instruction that executes until we turn tracing off.
    When a trace notification is received, the address of the trace point is retrieved
    from the args list ![](httpatomoreillycomsourcenostarchimages854063.png) and then
    used to update the appropriate netnode array index ![](httpatomoreillycomsourcenostarchimages854093.png).
    The `dbg_step_until_ret` notification ![](httpatomoreillycomsourcenostarchimages854095.png)
    is sent once the process hits the `return` statement to leave the function in
    which we started. This notification is our signal that we should stop tracing
    and print any statistics we have gathered. A loop is used ![](httpatomoreillycomsourcenostarchimages854099.png)
    to iterate through all valid index values of the `stats` netnode before destroying
    the netnode ![](httpatomoreillycomsourcenostarchimages854101.png) and requesting
    that step tracing be disabled ![](httpatomoreillycomsourcenostarchimages854103.png).
    Since this example uses asynchronous commands, the request to disable tracing
    is added to the queue, which means we have to issue `run_requests` ![](httpatomoreillycomsourcenostarchimages854133.png)
    in order for the queue to be processed. An important warning about synchronous
    versus asynchronous interaction with the debugger is that you should never call
    the synchronous version of a function while actively processing an asynchronous
    notification message.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous interaction with the debugger using the SDK is done in a manner
    very similar to scripting the debugger. As with many of the SDK functions we have
    seen in previous chapters, the names of debugger-related functions typically do
    not match the names of related scripting functions, so you may need to spend some
    time combing through *dbg.hpp* in order to find the functions you are looking
    for. The biggest disparity in names between scripting and the SDK is the SDK’s
    version of `GetDebuggerEvent`, which is called `wait_for_next_event` in the SDK.
    The other major difference between script functions and the SDK is that variables
    corresponding to the CPU registers are not automatically declared for you within
    the SDK. In order to access the values of CPU registers from the SDK, you must
    use the `get_reg_val` and `set_reg_val` functions to read and write registers,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[225](#CHP-24-FN-10)]) In reality, there is a macro named `ResumeProcess`
    that is defined as `GetDebuggerEvent(WFNE_CONT|WFNE_NOWAIT, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA may not have the largest share of the debugger market, but its debugger
    is powerful and integrates seamlessly with the disassembly side of IDA. While
    the debugger’s user interface, like that of any debugger, requires some initial
    getting used to, it offers all of the fundamental features that users require
    in a basic debugger. Strong points include scripting and plug-in capabilities
    along with the familiar user interface of IDA’s disassembly displays and the power
    of its analysis capabilities. Together the unified disassembler/debugger combination
    provides a solid tool for performing static analysis, dynamic analysis, or a combination
    of both.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 25. Disassembler/Debugger Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An integrated disassembler/debugger combination such as IDA should be a pretty
    powerful tool for manipulating binaries and seamlessly applying static and dynamic
    techniques as part of the reverse engineering process. This turns out to be true
    if you understand the capabilities and limitations of each tool individually and
    in combination.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will discuss some important points concerning the manner
    in which the static side of IDA interacts with its dynamic side, and we will take
    a look at techniques that can be employed with IDA’s debugger in order to defeat
    certain anti-debugging (and anti-disassembly) techniques in the context of malware
    analysis. In that regard, it is important to remember that the goal in malware
    analysis is usually not to run the malware but to obtain a disassembly of sufficient
    quality to allow static analysis tools to take over. Recall from [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis") that there are many techniques designed
    specifically to prevent disassemblers from performing properly. In the face of
    such anti-disassembly techniques, the debugger is simply one means to an end.
    By running an obfuscated program under debugger control, we will attempt to obtain
    a de-obfuscated version of the program, which we then prefer to analyze using
    the disassembler.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some background on debugger-assisted de-obfuscation may be useful before proceeding.
    It is well known that an obfuscated program must de-obfuscate itself before it
    can get down to its intended business. The following steps provide a basic and
    somewhat simplistic guide for dynamic de-obfuscation of binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Open an obfuscated program with a debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for and set a breakpoint on the end of the de-obfuscation routine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the program from the debugger and wait for your breakpoint to trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Utilize the debugger’s memory-dumping features to capture the current state
    of the process to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Terminate the process before it can do anything malicious.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform static analysis on the captured process image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most modern debuggers contain enough features to perform the tasks just mentioned.
    OllyDbg^([[226](#ftn.CHP-25-FN-1)]) is a very popular Windows-only debugger often
    used for such work. Step 2 is not always as straightforward as it may sound. It
    may take a combination of tools, including spending some amount of time in a disassembler
    such as IDA, or a lot of single stepping before the end of the de-obfuscation
    algorithm can be properly identified. In many cases, the end of de-obfuscation
    is marked by a behavior rather than a specific instruction. One such behavior
    might be a large change in the instruction pointer value, indicating a jump to
    a location far from the de-obfuscation code. In the case of `UPX`-packed binaries,
    for example, all you need to do is observe that the instruction pointer holds
    a value that is less than the program’s entry point address to know that de-obfuscation
    is complete and the program has jumped to the newly de-obfuscated code. In generic
    terms, this process is called *original entry point (OEP) recognition*, the OEP
    being the address at which the program would have begun execution had it not been
    obfuscated.
  prefs: []
  type: TYPE_NORMAL
- en: Complicating matters, some modern obfuscators are capable of transforming an
    input executable into an equivalent byte code program, which is then executed
    on a custom virtual machine generated by the obfuscator.^([[227](#ftn.CHP-25-FN-2)])
    Executables protected with such virtualizing obfuscators cannot be analyzed with
    the traditional expectation of recovering the original binary or locating the
    original entry point. This is a result of the fact that the original x86 (or other
    processor) instructions are not embedded in the obfuscated binary and are therefore
    unavailable for recovery.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not careful, step 3 can be a dangerous one. In any case, you should
    always think twice before you allow a piece of malware to run unhindered in the
    hope that you have set your breakpoints or breakpoint conditions properly. If
    the program manages to bypass your breakpoint(s), it may well proceed to execute
    malicious code before you know what has happened. For this reason, attempts to
    de-obfuscate malware under debugger control should always be conducted in a sandbox
    environment that you are not afraid to wipe clean in the event things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 may require some level of effort, because memory dumping is usually supported
    in debuggers, while entire-process image dumping may not be. The OllyDump^([[228](#ftn.CHP-25-FN-3)])
    plug-in, by Gigapede, adds process-dumping capabilities to OllyDbg. Keep in mind
    that the image that gets dumped from memory contains content from a running process
    and does not necessarily reflect the original state of the binary at rest in a
    disk file. In malware analysis, however, the goal is generally to create not a
    working de-obfuscated executable file, but rather an image file that is correctly
    structured so that it can be loaded into a disassembler for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: One of the trickiest parts of reconstructing a binary image from an obfuscated
    process is restoration of the program’s imported function table. As part of the
    obfuscation process, a program’s import table is often obfuscated as well. As
    a result, the de-obfuscation process must also take care of linking the newly
    de-obfuscated process to all of the shared libraries and functions the process
    requires in order to execute properly. The only trace of this process is usually
    a table of imported function addresses somewhere within the process’s memory image.
    When dumping a de-obfuscated process image to a file, steps are often taken to
    attempt to reconstruct a valid import table in the dumped process image. In order
    to do this, the headers of the dumped image need to be modified to point to a
    new import table structure that must properly reflect all of the shared library
    dependencies of the original de-obfuscated program. A popular tool for automating
    this process is the ImpREC^([[229](#ftn.CHP-25-FN-4)]) (Import REConstruction)
    utility by MackT. As with process dumping, keep in mind that extracting a standalone
    executable may not be your primary goal in malware analysis, in which case reconstructing
    valid headers and a working import table is less important than knowing which
    functions have been resolved and where the addresses of those functions have been
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[226](#CHP-25-FN-1)]) See [http://www.ollydbg.de/](http://www.ollydbg.de/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[227](#CHP-25-FN-2)]) For a discussion of one such obfuscator, VMProtect,
    see “Unpacking Virtualization Obfuscators” by Rolf Rooles at [http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf](http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[228](#CHP-25-FN-3)]) See [http://www.woodmann.com/collaborative/tools/index.php/OllyDump](http://www.woodmann.com/collaborative/tools/index.php/OllyDump).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[229](#CHP-25-FN-4)]) See [http://www.woodmann.com/collaborative/tools/index.php/ImpREC](http://www.woodmann.com/collaborative/tools/index.php/ImpREC).
  prefs: []
  type: TYPE_NORMAL
- en: IDA Databases and the IDA Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important that we begin with an understanding of how the debugger treats
    your database when you initiate (and terminate) a debugging session. A debugger
    needs a process image to work with. Debuggers obtain process images either by
    attaching to existing processes or by creating new processes from executable files.
    An IDA database does not contain a valid process image, nor in most cases can
    a valid process image be reconstructed from a database (if one could, then File
    ▸ Produce File ▸ Create EXE File might be simple to implement). When you launch
    a debugger session from IDA, the disassembler side informs the debugger side of
    the name of the original input file, which the debugger uses to create and attach
    to a new process. Information provided to the debugger includes disassembly formatting,
    symbol names, data formatting, and any comments that you have entered into the
    database. An important point to understand is that any patches (changes in byte
    content) you have applied to your database will not be reflected in the process
    being debugged. In other words, it is not possible to patch changes into the database
    and expect to observe the effect of those changes when you launch the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite holds true as well. When you have finished debugging a process
    and you return to disassembly mode, by default the only changes that will be reflected
    in the database are cosmetic in nature (such as renamed variables or functions).
    Any memory changes, such as self-modified code, are not pulled back into the database
    for you to analyze. If you wish to migrate any content, such as newly de-obfuscated
    code, from the debugger back to your disassembly database, IDA will allow you
    to do so via the Debugger ▸ Take Memory Snapshot command. The resulting confirmation
    dialog is shown in [Figure 25-1](ch25s02.html#memory_snapshot_confirmation_dialog
    "Figure 25-1. Memory snapshot confirmation dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory snapshot confirmation dialog](httpatomoreillycomsourcenostarchimages854392.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-1. Memory snapshot confirmation dialog
  prefs: []
  type: TYPE_NORMAL
- en: The default option is to copy loader segments from the running process to the
    database. *Loader segments* are those segments that were loaded into the database
    by the IDA loader module used to create the current database. In the case of an
    obfuscated program, one or more of these segments probably contain data that has
    been obfuscated and are therefore nearly impossible to analyze in the disassembler.
    These are precisely the segments that you will want to copy back from the running
    process image in order to take advantage of the de-obfuscation work performed
    by the process running under debugger control.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting All segments causes all segments created by the debugger to be copied
    back to the database. These segments include the contents of all shared libraries
    loaded in support of the process as well as additional process-related segments,
    such as the stack and heap contents.
  prefs: []
  type: TYPE_NORMAL
- en: When the debugger is used to attach to an existing process with no associated
    database, none of the debugger segments will be flagged as loader segments because
    the file was not loaded by one of IDA’s loaders. In such cases, you may elect
    to capture all available segments into a new database. Alternatively, you may
    elect to edit segment attributes and designate one or more segments as loader
    segments. Segment attributes may be edited by first opening the Segments window
    (View ▸ Open Subviews ▸ Segments). Any segment marked as a loader segment will
    contain an *L* in the L column of the Program Segmentation window. Right-clicking
    a segment of interest and selecting Edit Segment opens the segment attributes
    dialog shown in [Figure 25-2](ch25s02.html#segment_editing_dialog_with_the_loader_s
    "Figure 25-2. Segment editing dialog with the Loader segment checkbox").
  prefs: []
  type: TYPE_NORMAL
- en: '![Segment editing dialog with the Loader segment checkbox](httpatomoreillycomsourcenostarchimages854395.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-2. Segment editing dialog with the Loader segment checkbox
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the Loader segment checkbox marks the segment as a loader segment
    and allows it to be copied into the database along with all other loader segments.
  prefs: []
  type: TYPE_NORMAL
- en: The segment attributes dialog is also useful when you have created a process
    from an open database and wish to add additional loader segments before taking
    a memory snapshot. For example, if an obfuscated process extracts the original
    code into a block of memory allocated in the heap (or a memory-mapped block),
    you will want to mark that memory block as a loader segment before you snapshot
    memory; otherwise, the de-obfuscated code will not be copied back into your database.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Obfuscated Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned a number of times that loading an obfuscated program in a
    debugger, allowing it to run until the de-obfuscation is complete, and then taking
    a memory snapshot of the program in its de-obfuscated state seems like a good
    strategy for obtaining a de-obfuscated version of a program. Controlled execution
    is probably a better way of thinking about this process than debugging, because
    all we are really doing is observing the code in operation and then taking a memory
    snapshot at the appropriate moment. A debugger simply happens to be the tool that
    allows us to accomplish this task. At least that is what we are hoping for. In
    [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis") we discussed several
    anti-disassembly and anti-debugging techniques that obfuscators utilize in an
    attempt to prevent us from obtaining a clear picture of a program. It is time
    to see how IDA’s debugger can help us bypass some of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter we will assume that the obfuscated programs we are dealing
    with employ some form of encryption or compression on the interesting portions
    of the binary. The level of difficulty in obtaining a clear picture of that code
    depends entirely on the sophistication of any anti-analysis techniques used in
    the obfuscation process and the measures that can be developed to circumvent these
    techniques. Before we get started, however, here are a few rules to live by when
    working with malware in a debugging environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Protect your network and host environments. Always work in a sandbox environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On initial analysis, use single stepping when possible. It may be tedious, but
    it is your best defense against a program escaping your control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always think twice before executing a debugger command that will allow more
    than a single instruction to execute. If you have not planned properly, the program
    you are debugging may run into a malicious portion of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When possible, use hardware breakpoints. It is difficult to set software breakpoints
    in obfuscated code, because de-obfuscation algorithms may modify the breakpoint
    instructions that you have inserted or compute checksums over regions of code.^([[230](#ftn.CHP-25-FN-5)])
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When examining a program for the first time, it is best to allow the debugger
    to handle all exceptions generated by the program so that you can make informed
    decisions about which exceptions to pass to the program and which exceptions the
    debugger should continue to catch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be prepared to restart debugging often, because one wrong step can lead you
    down a road to failure (for example, if you allow the process to detect the debugger).
    Keep detailed notes regarding addresses that are safe to run to so that you can
    rapidly recover when you restart the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In general, you should always take a very cautious approach the first time you
    start to work with a particular obfuscated program. In most cases your primary
    goal should be to obtain a de-obfuscated version of the program. Speeding up the
    de-obfuscation process by learning exactly how far you can go before you need
    to set a breakpoint should be a secondary goal, and it is probably best saved
    for a follow-on exercise once you have managed to successfully de-obfuscate a
    program for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you have spent minutes or hours studying a malicious executable with
    IDA, you will probably want to gain control of it at the earliest opportunity
    the first time you launch it in the debugger. One of the easiest ways to gain
    control over a process is to set a breakpoint at the process entry point, the
    first instruction executed once the operation has finished creating the process’s
    memory image. In most cases this will be the symbol labeled `start`; however,
    in some cases it won’t. The PE file format, for example, allows for the designation
    TLS^([[231](#ftn.CHP-25-FN-6)]) callback functions designed to perform initialization
    and destruction tasks for data that is local to each thread, and these TLS callback
    functions are invoked before control is ever transferred to `start`.
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors are well aware of TLS callback functions and have made use of
    these functions to have code executed before a program’s main entry point code
    gets a chance to run. The hope is that anyone analyzing the malware will fail
    to notice the presence of the TLS callback, with a resulting failure to understand
    the true behavior of the program being analyzed. IDA properly parses PE file headers
    and recognizes the presence of any TLS callbacks contained within a PE file, adding
    any such functions to the binary’s list of entry points in the Exports window.
    [Figure 25-3](ch25s03.html#exports_window_showing_a_tls_callback_fu "Figure 25-3. Exports
    window showing a TLS callback function") shows the Exports window for an executable
    that contains a TLS callback.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exports window showing a TLS callback function](httpatomoreillycomsourcenostarchimages854398.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-3. Exports window showing a TLS callback function
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line when it comes to TLS callbacks is to recognize their presence
    and then set breakpoints at the beginning of each TLS callback function to ensure
    that you gain control of the process before it is too late.
  prefs: []
  type: TYPE_NORMAL
- en: Many debuggers offer options to specify when (if at all) the debugger should
    pause following initial process creation, and IDA is no exception. [Figure 25-4](ch25s03.html#debugger_pausing_events
    "Figure 25-4. Debugger pausing events") shows a portion of IDA’s Debugger Setup
    dialog (Debugger ▸ Debugger Options).
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger pausing events](httpatomoreillycomsourcenostarchimages854401.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-4. Debugger pausing events
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the available options offers the opportunity to automatically pause
    the process being debugged when specific events occur. Each of these events is
    summarized in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stop on debugging start** This option offers the earliest opportunity to
    pause the debugger following process creation. For example, on Windows 7, this
    will pause the process at the beginning of the `RtlUserThread-Star``t` function
    within *ntdll.dll*. This will pause execution before any program code, including
    TLS callback functions, is executed. |'
  prefs: []
  type: TYPE_TB
- en: '| **Stop on process entry point** Causes the debugger to pause execution once
    the program entry point is reached. This typically coincides with the symbol named
    `start` (or its equivalent) in your IDA database. Any TLS callback functions will
    already have executed before this event takes place. |'
  prefs: []
  type: TYPE_TB
- en: '| **Stop on thread start/exit** Pauses the debugger each time a new thread
    starts or an existing thread terminates. On a Windows system, when this event
    fires, the debugger will pause somewhere within *kernel32.dll*. |'
  prefs: []
  type: TYPE_TB
- en: '| **Stop on library load/unload** Pauses the debugger each time a new library
    is loaded or an existing library is unloaded. On a Windows system, when this event
    fires, the debugger will pause somewhere within *kernel32.dll*. |'
  prefs: []
  type: TYPE_TB
- en: '| **Stop on debugging message** Pauses execution each time the process outputs
    a message using the debug print facility. On Windows systems, this corresponds
    to a call to `OutputDebugString`, and execution is paused within *kernel32.dll*.
    |'
  prefs: []
  type: TYPE_TB
- en: Understanding where the process is likely to be paused for each of these debugger
    events is important in order to keep the process you are debugging from executing
    further than you intend it to. Once you are certain that you will gain control
    of the process in a predictable manner, you can move on to getting some work done
    with the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Decryption and Decompression Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we say *simple decryption and decompression loops*, we mean loops that
    employ no nested obfuscation techniques and for which you can identify, with certainty,
    all possible exit points. When you encounter such loops, the easiest way to get
    through them is to set a breakpoint at all possible exit points and then allow
    the loop to execute. Consider single stepping through such loops one or two times
    in order to get a feel for them; then set breakpoints accordingly. When setting
    a breakpoint immediately following a loop, you should make sure that the bytes
    at the address at which you are setting the breakpoint will not be changed during
    the course of the loop; otherwise, a software breakpoint may fail to trigger.
    When in doubt, use a hardware breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your goal is to develop a fully automated de-obfuscation process, you will
    need to develop an algorithm for recognizing when the de-obfuscation process has
    completed. When this condition is satisfied, your automated solution can pause
    the process, at which point you can acquire a memory snapshot. For simple de-obfuscation
    routines, recognizing the end of the de-obfuscation stage may be as simple as
    noting a large change in the value of the instruction pointer or the execution
    of a specific instruction. For example, the beginning and end of the `UPX` decompression
    routine for an obfuscated Windows executable are shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Several characteristics of this routine can be used to automatically recognize
    its completion. First, the routine begins by pushing all registers onto the stack
    at the program entry point ![](httpatomoreillycomsourcenostarchimages854061.png).
    The complementary operation of popping all registers occurs near the end of the
    routine ![](httpatomoreillycomsourcenostarchimages854063.png) after the program
    has been decompressed. Finally, control is transferred ![](httpatomoreillycomsourcenostarchimages854093.png)
    to the newly unpacked program. Thus, one strategy for automating decompression
    would be to step trace the program until the current instruction is a `popa`.
    Because step tracing is slow, the IDC script shown in [Example 25-1](ch25s03.html#simple_upx_unpacker_script
    "Example 25-1. Simple UPX unpacker script") takes the slightly different approach
    of scanning for the `popa` instruction and then running the program to the address
    of the `popa`:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-1. Simple UPX unpacker script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The script in [Example 25-1](ch25s03.html#simple_upx_unpacker_script "Example 25-1. Simple
    UPX unpacker script") is designed to be launched within an IDA database, prior
    to launching the debugger, and assumes that you have previously selected a debugger
    using Debugger ▸ Select debugger. The script takes care of the details of launching
    the debugger and gaining control of the newly created process. This script relies
    on some very specific features of UPX and is therefore not a good candidate for
    use as a generic de-obfuscation script. It does, however, demonstrate some concepts
    that might be used in later efforts. The script depends on the fact that the decompression
    routine resides at the end of one of the program segments (typically named `UPX1`)
    and that `UPX` does not make use of any desynchronization techniques to prevent
    proper disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: OBFUSCATING OBFUSCATORS
  prefs: []
  type: TYPE_NORMAL
- en: UPX is one of the more popular obfuscation utilities in use today (perhaps because
    it is free). Its popularity does not make it a particularly effective tool, however.
    One of the principal drawbacks to its effectiveness is the fact that UPX itself
    offers a command-line option to restore a UPX-packed binary to its original form.
    Consequently, a cottage industry has evolved for developing tools to prevent UPX
    from unpacking itself. Because UPX performs some integrity checks on a compressed
    binary before it will unpack that binary, simple changes that cause the integrity
    checks to fail without affecting the operation of the compressed binary render
    UPX’s own unpacking feature inoperative. One such technique involves changing
    the default UPX section names to anything other than UPX0, UPX1, and UPX2\. For
    this reason, it is useful to avoid hardcoding these segment names into any scripts
    that you develop for unpacking UPX.
  prefs: []
  type: TYPE_NORMAL
- en: The script relies on these facts in order to scan forward, one instruction at
    a time ![](httpatomoreillycomsourcenostarchimages854061.png), from the program
    entry point, as long as the next instruction lies within the same program segment
    ![](httpatomoreillycomsourcenostarchimages854063.png) and until the current instruction
    is a `popa` ![](httpatomoreillycomsourcenostarchimages854093.png). Once the `popa`
    instruction is located, the debugger is invoked ![](httpatomoreillycomsourcenostarchimages854095.png)
    to execute the process up to the address of the `popa` instruction, at which point
    the program has been decompressed. The last step is to take a memory snapshot
    ![](httpatomoreillycomsourcenostarchimages854099.png) to pull the de-obfuscated
    program bytes back into our database for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'An even more general-purpose solution for automated unpacking is to exploit
    the fact that many de-obfuscation routines are appended to the end of a binary
    and perform a jump to the original entry point, which occurs much earlier in the
    binary, once de-obfuscation is complete. In some cases, the original entry point
    may lie in an entirely different program segment, while in other cases, the original
    entry point simply precedes any address used by the de-obfuscation code. The Python
    script in [Example 25-2](ch25s03.html#generic_attempt_to_run_until_oep_is_hit
    "Example 25-2. Generic attempt to run until OEP is hit") offers a more basic means
    of running a simple de-obfuscation algorithm until it jumps to the program’s original
    entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-2. Generic attempt to run until OEP is hit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the script in [Example 25-1](ch25s03.html#simple_upx_unpacker_script
    "Example 25-1. Simple UPX unpacker script"), this script should be launched from
    the disassembler rather than the debugger and again assumes that a debugger has
    been selected. The script handles the details of launching the debugger and gaining
    the necessary control of the newly created process. This particular script makes
    two assumptions: that all code prior to the entry point is obfuscated and that
    nothing malicious takes place prior to transferring control to an address that
    precedes the entry point. The script begins by launching the debugger and pausing
    at the program entry point ![](httpatomoreillycomsourcenostarchimages854061.png).
    Next, the program enables step tracing ![](httpatomoreillycomsourcenostarchimages854063.png)
    and loops to test the address of each generated event ![](httpatomoreillycomsourcenostarchimages854093.png).
    Once the event address precedes the program entry point address, de-obfuscation
    is assumed to be complete, and the process is paused ![](httpatomoreillycomsourcenostarchimages854095.png)
    and step tracing disabled ![](httpatomoreillycomsourcenostarchimages854099.png).
    Finally, for good measure, the script ensures that the bytes at the current instruction
    pointer location are formatted as code ![](httpatomoreillycomsourcenostarchimages854101.png).'
  prefs: []
  type: TYPE_NORMAL
- en: When stepping your way through obfuscated code, it is not uncommon to encounter
    the warning shown in [Figure 25-5](ch25s03.html#debugger_instruction_pointer_warning
    "Figure 25-5. Debugger instruction pointer warning").
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger instruction pointer warning](httpatomoreillycomsourcenostarchimages854405.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-5. Debugger instruction pointer warning
  prefs: []
  type: TYPE_NORMAL
- en: This warning indicates that the instruction pointer is pointing into an item
    that IDA believed was data or that the instruction pointer is pointing into the
    middle of a previously disassembled instruction. This warning is frequently encountered
    when single stepping through code that utilizes disassembly desynchronization
    techniques. It is also often encountered when a program jumps to a region that
    was once data and is now code, as happens following the de-obfuscation of a program.
    Answering yes to the question causes IDA to reformat the bytes in question as
    code, which should be the proper thing to do since the instruction pointer indicates
    that this is the next item to be fetched for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note that because of its use of step tracing, the script in [Example 25-2](ch25s03.html#generic_attempt_to_run_until_oep_is_hit
    "Example 25-2. Generic attempt to run until OEP is hit") will be substantially
    slower than the script in [Example 25-1](ch25s03.html#simple_upx_unpacker_script
    "Example 25-1. Simple UPX unpacker script"). However, for the price of slower
    execution, we gain a couple of advantages. First, we are able to specify a termination
    condition that is not tied to any one address. This is not possible when using
    breakpoints alone. Second, this script is immune to any attempts to desynchronize
    the disassembler because instruction boundaries are determined purely based on
    runtime values of the instruction pointer rather than static disassembly analysis.
    In its announcement introducing scripted debugging features,^([[232](#ftn.CHP-25-FN-7)])
    Hex-Rays presents a far more robust script for performing the tasks of a *universal
    unpacker*.
  prefs: []
  type: TYPE_NORMAL
- en: Import Table Reconstruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a binary has been de-obfuscated, analysis of that binary can begin. While
    we may never intend to execute the de-obfuscated program (in fact, we cannot execute
    that program if a snapshot was pulled directly into an IDA database), a program’s
    import table is almost always a valuable resource for developing an understanding
    of the program’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Under normal circumstances, IDA is able to parse a program’s import table as
    part of the file-loading process upon initial database creation. Unfortunately,
    in obfuscated programs, the only import table that IDA sees at load time belongs
    to the de-obfuscation component of the program. This import table typically contains
    a bare minimum of functions required to complete the de-obfuscation process. The
    most sophisticated obfuscators may generate empty import tables, in which case
    the de-obfuscation component must contain all of the code necessary to load libraries
    and resolve necessary functions on its own.
  prefs: []
  type: TYPE_NORMAL
- en: As for the binary that has been obfuscated, in most cases its import table has
    been obfuscated as well and is reconstructed, in some form, as part of the de-obfuscation
    process. The reconstruction process typically relies on newly de-obfuscated data
    in order to perform its own library loading and function address resolution. For
    Windows programs, this nearly always involves calls to the `LoadLibrary` function
    combined with repeated calls to `GetProcAddress` to resolve required function
    addresses.
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated import table reconstruction routines may utilize custom lookup
    functions in place of `GetProcAddress` in order to avoid triggering any breakpoints
    set on `GetProcAddress` itself. Such routines may also substitute the use of hash
    values in place of strings for identifying which function’s address is being requested.
    In rare cases, import table reconstructors may go so far as to bypass `LoadLibrary`
    as well, in which case the reconstruction routine must implement its own custom
    version of that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The net result of the import table reconstruction process is usually a table
    of function addresses, none of which have much meaning in a static analysis context.
    If we take a memory snapshot of a process, the best we are likely to come up with
    is something like the following partial listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This block of data depicts a number of 4-byte values, all in close proximity
    to one another and referenced from various locations with the program. The problem
    is that these values, such as `7C812F1Dh`, represent addresses of library functions
    as they were mapped in the process we were debugging. Within the code section
    of the program itself, we would see function calls similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that two of the function calls, ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) refer to the contents
    of the reconstructed import table, while a third function call ![](httpatomoreillycomsourcenostarchimages854093.png)
    refers to a function whose body is present in the database. In an ideal world,
    each entry in the reconstructed import table would be named after the function
    whose address it contains.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is best addressed before taking a memory snapshot of the de-obfuscated
    process. As shown in the next listing, if we view the same memory range from within
    the debugger, we get an entirely different picture. Since the debugger has access
    to the memory regions in which each referenced function lies, the debugger is
    able to display addresses (such as `7C812F1Dh`) as their corresponding symbolic
    names (in this case `kernel32_GetCommandLineA`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting at this point that the debugger adopts a slightly different
    naming scheme than we are accustomed to. The debugger prefixes all functions exported
    from shared libraries with the name of the associated library followed by an underscore.
    For example, the function `GetCommandLineA` in *kernel32.dll* is assigned the
    name `kernel32_GetCommandLineA`. This ensures that unique names are generated
    should two libraries export the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to overcome two problems with the import table shown in the preceding
    listing. First, in order for function calls to become more readable, we need to
    name each entry in the import table according to the function it references. If
    the entries are named properly, IDA will automatically display function signatures
    from its type libraries. Naming each import table entry is a relatively easy task
    as long as we have a name to assign. This leads to the second problem: obtaining
    the proper name. One approach is to parse the debugger-generated name, strip off
    the library name, and assign the remaining text as the name of the import table
    entry. The only problem with this approach is the fact that library names and
    function names may both contain underscore characters, making it difficult in
    some cases to determine the exact length of a function’s name within a longer
    name string. Recognizing this difficulty, this is nonetheless the approach taken
    by the *renimp.idc* import table–renaming script that ships with IDA (found in
    *<IDADIR>/idc*).'
  prefs: []
  type: TYPE_NORMAL
- en: In order for this script to execute properly, it must be run while the debugger
    is active (so that it has access to loaded library names), and we must be able
    to locate the reconstructed import table within the de-obfuscated binary. One
    strategy for determining where the reconstructed import table will lie is to track
    calls to `GetProcAddress` and note where the results are stored into memory. [Example 25-3](ch25s03.html#upx_code_to_resolve_and_store_imported_f
    "Example 25-3. UPX code to resolve and store imported function addresses") shows
    the code used by UPX to call `GetProcAddress` and store the result.
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-3. UPX code to resolve and store imported function addresses
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The call to `GetProcAddress` takes place at ![](httpatomoreillycomsourcenostarchimages854061.png),
    with the result being stored into memory at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Making note of the value held in the `ebx` register at ![](httpatomoreillycomsourcenostarchimages854063.png)
    will tell us where the import table is located. The `ebx` register is advanced
    by four bytes at ![](httpatomoreillycomsourcenostarchimages854093.png) to prepare
    it for the next iteration of the function resolution loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have located the reconstructed import table, *renimp.idc* requires
    that we highlight the contents of the table using a click-and-drag operation from
    the beginning to the end of the table. The *renimp.idc* script iterates across
    the selection, obtains the name of the referenced function, strips the library
    name prefix, and names the import table entry accordingly. Following execution
    of this script, the import table shown previously is transformed into the import
    table shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We see that the script has done the work of renaming each import table entry,
    but IDA has added function prototypes for each function whose type information
    IDA is aware of. Note that no type information would be visible if the library
    name prefix had not been stripped from each function name. The *renimp.idc* script
    can fail to properly extract an imported function name when the name of the module
    in which the function resides contains an underscore. The ws2_32 networking library
    is a well-known example of a module whose name happens to contain an underscore.
    Special handling of ws2_32 takes place within *renimp.idc*; however, any other
    module whose name contains an underscore will cause *renimp.idc* to parse function
    names incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach to renaming import table entries may be employed when
    a single instruction is responsible for storing all resolved function addresses
    as UPX does in [Example 25-3](ch25s03.html#upx_code_to_resolve_and_store_imported_f
    "Example 25-3. UPX code to resolve and store imported function addresses"). If
    such an instruction can be identified, such as the instruction at ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the listing, then we can take advantage of the fact that breakpoint conditions
    in IDA are specified using IDC statements. In this case we might set a conditional
    breakpoint at address `004088A1` and make the conditional expression invoke a
    function that we define. Here we name the function `createImportLabel` and define
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function begins by querying for the name referenced by EAX. Recall that
    EAX contains the result of the call to `GetProcAddress` and thus should refer
    to a function within some DLL. Next, the function loops to truncate the name to
    just that portion following the last underscore found in the original name. Finally,
    a series of function calls is made to properly format the target location (referenced
    by EBX) as a 4-byte data item, and apply a name to that location. By returning
    zero, the function informs IDA that the breakpoint should not be honored, with
    the result that execution continues without pausing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 24](ch24.html "Chapter 24. The IDA Debugger"), we discussed how
    to specify breakpoint conditions in IDA’s debugger. Installing a user-defined
    function as a breakpoint handler is not quite as straightforward as setting and
    editing a breakpoint and entering `createImportLabel()` as the breakpoint condition.
    While this is exactly the condition that we wish to enter in this case, the problem
    is that, from IDA’s perspective, `createImportLabel` is an undefined function.
    The workaround for this is to create a script file (IDC by definition) containing
    our function along with a simple `main` function that looks something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Placing the cursor on the instruction that you wish to set the breakpoint on
    and then running this script (File ▸ Script File) results in a conditional breakpoint
    that calls `createImportLabel` each time it is hit. The `AddBpt` function ![](httpatomoreillycomsourcenostarchimages854061.png)
    adds a breakpoint at the specified location (the cursor location in this case),
    and the `SetBptCnd` function ![](httpatomoreillycomsourcenostarchimages854063.png)
    adds a condition to an existing breakpoint. The condition is specified as a string
    containing the IDC statement to evaluate each time the breakpoint is hit. With
    this breakpoint in place, once the de-obfuscation has completed, we will have
    a labeled import table without having to go through the trouble of locating the
    table within the process’s memory space.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another approach for deriving name information involves searching memory
    for the file headers associated with a function address and then parsing the export
    table described in those headers to locate the name of the function being referenced.
    This is essentially a reverse lookup of a function name given the function’s address.
    Scripts (*RebuildImports.idc/RebuildImports.py*) based on this concept are available
    on the book’s website. Either of these scripts may be executed in lieu of *renimp.idc*
    with nearly identical results. The problems faced by *renimp.idc* when dealing
    with modules whose names contain an underscore character are avoided because function
    names are extracted directly from export tables present in the process address
    space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of naming each import table entry properly carries through to the
    disassembly itself, as shown in the following automatically updated disassembly
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The name of each renamed import table entry is propagated to all locations from
    which imported functions are called, making the disassembly far more readable.
    It is worth noting that any formatting changes that you make while you’re working
    within the debugger are automatically applied to the database view as well. In
    other words, there is no need to take a memory snapshot simply to capture formatting
    changes that you have made. The purpose of a memory snapshot is to migrate memory
    content (code and data) from a processes address space back into an IDA database.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A popular method of preventing the use of debuggers as de-obfuscation tools
    is *debugger detection*. The authors of obfuscation tools understand just as well
    as you do that debuggers are useful for undoing their handiwork. In response,
    they often take measures to prevent their tools from running if the tools detect
    the presence of a debugger. We discussed a few debugger-detection methods in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis"). As mentioned in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis"), Nicolas Falliere’s article “Windows Anti-Debug
    Reference”^([[233](#ftn.CHP-25-FN-8)]) contains an excellent summary of a number
    of Windows-specific techniques for detecting the presence of a debugger. You can
    counter several of these detection techniques by using a simple script to start
    your debugger session and automatically configure some breakpoints. While it is
    possible to use Python to counter some of these techniques, we will ultimately
    be using conditional breakpoints, which we can only specify using IDC. For this
    reason the sample code that follows is all written in IDC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to launch a debugging session from a script, we begin with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These statements check for the presence of a TLS callback function, set a breakpoint
    if one is found, and then launch the debugger, requesting to break on the entry
    point address before waiting for the operation to complete (strictly speaking,
    we should test the return value of `GetDebuggerEvent` as well). Once our script
    regains control, we have an active debugger session, and the process we wish to
    debug is mapped into memory along with all libraries on which it depends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first debugger detection we will bypass is the `IsDebugged` field of the
    process environment block (PEB). This is a 1-byte field that is set to the value
    1 if the process is being debugged and 0 otherwise. The field lies 2 bytes into
    the PEB, so all we need to do is find the PEB and patch the proper byte to the
    value 0\. This also happens to be the field tested by the Windows API function
    `IsDebuggerPresent`, so we manage to kill two birds with one stone in this case.
    If we know that we have stopped at the program entry point as opposed to a TLS
    callback, then locating the PEB turns out to be rather simple, because the EBX
    register contains a pointer to the PEB upon entry to the process. If instead the
    process has stopped at a TLS callback function, then we need a more general-purpose
    means of finding the PEB. We will take an approach similar to that often used
    in shellcode and obfuscators. The basic idea is to locate the current *thread
    information block (TIB)*^([[234](#ftn.CHP-25-FN-9)]) and follow an embedded pointer
    to find the PEB. The following code locates the PEB and makes the appropriate
    patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `PatchDbgByte` function was not introduced until IDA 5.5\. When
    used with versions prior to IDA 5.5, `PatchByte` will work but will also modify
    (patch) the database if the address specified is present in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Another anti-debugging technique mentioned in Falliere’s article involves testing
    several bits in another field of the PEB named `NtGlobalFlags`. The bits relate
    to the operation of a process’s heap and are set to 1 when a process is being
    debugged. Assuming variable `peb` remains set from the previous example, the following
    code retrieves the `NtGlobalFlags` field from the PEB, resets the offending bits,
    and stores the flags back into the PEB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Several techniques in Falliere’s article rely on differences in information
    returned by system functions when a process is being debugged as opposed to when
    a process is not being debugged. The first function mentioned in the article is
    `NtQueryInformationProcess`, found in *ntdll.dll*. Using this function, a process
    may request information regarding its *ProcessDebugPort*. If the process is being
    debugged, the result is non-zero; if it is not being debugged, the result should
    be zero. One way to avoid detection in this manner is to set a breakpoint on `NtQueryInformationProcess`
    and then specify a breakpoint condition function to filter out `ProcessDebugPort`
    requests. In order to automatically locate this instruction, we take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Look up the address of `NtQueryInformationProcess`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a breakpoint on `NtQueryInformationProcess`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a breakpoint condition to call a function we will name `bpt_NtQueryInformationProcess`,
    which will be executed each time `NtQuery-InformationProcess` gets called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to find the address of `NtQueryInformationProcess`, we need to remember
    that the function will be named `ntdll_NtQueryInformationProcess` in the debugger.
    The code to configure the necessary breakpoint appears here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What remains is for us to implement the breakpoint function that will keep
    the debugger hidden from an inquiring process. The prototype for `NtQueryInformationProcess`
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Information about a process is requested by providing an integer query identifier
    in the `ProcessInformationClass` parameter ![](httpatomoreillycomsourcenostarchimages854061.png).
    Information is returned via the user-supplied buffer pointed to by the `ProcessInformation`
    parameter ![](httpatomoreillycomsourcenostarchimages854063.png). A caller may
    pass the enumerated constant `ProcessDebugPort` (value 7) in order to query the
    debugging status of a given process. If a process is being debugged by a user-space
    debugger, the return value passed via the supplied pointer will be non-zero. If
    the process is not being debugged, the return value will be zero. A breakpoint
    function that always sets the `ProcessDebugPort` return value to zero is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Recall that this function is invoked each time `NtQueryInformationProcess` is
    called. On entry, the stack pointer is pointing to the saved return address, which
    lies on top of the five arguments to `NtQueryInformationProcess`. The breakpoint
    function begins by examining the value of the `ProcessInformation-Class` to determine
    whether the caller is requesting `ProcessDebugPort` information ![](httpatomoreillycomsourcenostarchimages854061.png).
    If the caller is requesting `ProcessDebugPort`, the function continues by retrieving
    the return value pointer ![](httpatomoreillycomsourcenostarchimages854063.png),
    testing that it is non-null ![](httpatomoreillycomsourcenostarchimages854093.png),
    and finally storing a return value of zero ![](httpatomoreillycomsourcenostarchimages854095.png)
    to make it appear that no debugger is attached. In order to skip the remainder
    of the function, EIP is then modified by reading the saved return address ![](httpatomoreillycomsourcenostarchimages854099.png),
    after which ESP is adjusted to simulate a `stdcall` return ![](httpatomoreillycomsourcenostarchimages854101.png).
    `NtQueryInformationProcess` returns an NTSTATUS code, which is set to 0 (success)
    at ![](httpatomoreillycomsourcenostarchimages854103.png) before returning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another function mentioned in Falliere’s article is `NtSetInformation-Thread`,
    which is also found in *ntdll.dll*. The prototype for this function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The anti-debugging technique involves passing the value `ThreadHideFromDebugger`
    in the `ThreadInformationClass` parameter, which causes a thread to be detached
    from a debugger. Bypassing this technique involves the same basic setup as the
    previous example. The resulting setup code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated breakpoint function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: On entry we test the value of the `ThreadInformationClass` parameter ![](httpatomoreillycomsourcenostarchimages854061.png)
    and bypass the function body if the user has specified `ThreadHideFromDebugger`.
    Bypassing the function body is accomplished by setting our desired return value
    ![](httpatomoreillycomsourcenostarchimages854063.png) and modifying the instruction
    pointer by reading the saved return address out of the stack ![](httpatomoreillycomsourcenostarchimages854093.png).
    We simulate the `stdcall` return by making a 20-byte adjustment to ESP ![](httpatomoreillycomsourcenostarchimages854095.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function that we will discuss, whose use as an anti-debugging technique
    is also discussed in Falliere’s article, is `OutputDebugStringA` from *kernel32.dll*.
    The prototype of this function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `WINAPI` is a synonym for `_stdcall` and is used to specify
    the calling convention employed by `OutputDebugStringA`. Strictly speaking, this
    function has no return value, as specified by the `void` return type in its prototype;
    however, according to the article, this function “returns” 1 when no debugger
    is attached to the calling process, and it “returns” the address of the string
    passed as a parameter if it is called while a debugger is attached to the calling
    process. Under normal circumstances, `_stdcall` functions that do return a value
    return that value in the EAX register. Since EAX must hold some value when `OutputDebugStringA`
    returns, it can be argued that this is the return value of the function; however,
    since the official return type is `void`, there is no documentation or guarantee
    as to what value EAX may actually hold in this case. This particular anti-debugging
    technique simply relies on the observed behavior of the function. One solution
    to the observed change in return values is to ensure that EAX contains 1 whenever
    `OutputDebugStringA` returns. The following IDC code implements this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This example uses the same technique for automatically locating the end of the
    `OutputDebugStringA` function that we used in the preceding examples. However,
    in contrast to the preceding example, the work that needs to be done when the
    breakpoint is hit is simple enough to be specified in an IDC expression ![](httpatomoreillycomsourcenostarchimages854061.png)
    (rather than requiring a dedicated function). In this case, the breakpoint expression
    modifies (note this is assignment rather than comparison) the EAX register to
    ensure that it contains 1 when the function returns and also adjusts EIP and ESP
    to bypass the function. The breakpoint condition is negated to cause the breakpoint
    to be skipped in all cases, because the result of the Boolean *and* expression
    is always expected to be nonzero.
  prefs: []
  type: TYPE_NORMAL
- en: A script (*HideDebugger.idc*) that combines all of the elements presented in
    this section into a useful tool for simultaneously initiating debugging sessions
    and implementing measures to combat anti-debugging attempts is available on the
    book’s website. For more information on hiding the presence of the debugger, please
    see Ilfak’s blog, where he presents several hiding techniques.^([[235](#ftn.CHP-25-FN-10)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[230](#CHP-25-FN-5)]) Keep in mind that the software breakpoint instruction
    inserted by the debugger will cause the checksum computation to yield a result
    other than the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[231](#CHP-25-FN-6)]) For more information on Thread Local Storage (TLS)
    callback functions, please refer to the PE file format specification [http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx](http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[232](#CHP-25-FN-7)]) See [http://www.hex-rays.com/idapro/scriptable.htm](http://www.hex-rays.com/idapro/scriptable.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[233](#CHP-25-FN-8)]) See [http://www.symantec.com/connect/articles/windows-anti-debug-reference/](http://www.symantec.com/connect/articles/windows-anti-debug-reference/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[234](#CHP-25-FN-9)]) This is also known as a *thread environment block (TEB)*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[235](#CHP-25-FN-10)]) See [http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html](http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html),
    [http://www.hexblog.com/2005/11/stealth_plugin_1.html](http://www.hexblog.com/2005/11/stealth_plugin_1.html),
    and [http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html](http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html).
  prefs: []
  type: TYPE_NORMAL
- en: IdaStealth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the *HideDebugger* script discussed in the previous section is useful
    for demonstrating some basic programmatic interaction with the debugger and some
    basics of library function hooking, the total number of known anti-debugging techniques
    and the complexity of those techniques argue for more robust anti-anti-debugging
    than can be provided by a simple script. Fortunately, the IdaStealth plug-in is
    designed to meet our needs for a power debugger-hiding capability. Written by
    Jan Newger, IdaStealth was the winner of Hex-Rays’s 2009 plug-in writing contest.
    The plug-in is written in C++ and is available in both source and binary form.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | IDAStealth |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Jan Newger |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | C++Source and binary |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Windows debugger-hiding plug-in |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://www.newgre.net/idastealth/](http://www.newgre.net/idastealth/)
    |'
  prefs: []
  type: TYPE_TB
- en: The binary components of IDAStealth consist of a plug-in and a helper library,
    both of which need to be installed to *<IDADIR>/plugins*. Upon initial activation,
    IDAStealth presents the configuration dialog shown in [Figure 25-6](ch25s04.html#idastealth_configuration_dialog
    "Figure 25-6. IDAStealth configuration dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![IDAStealth configuration dialog](httpatomoreillycomsourcenostarchimages854408.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-6. IDAStealth configuration dialog
  prefs: []
  type: TYPE_NORMAL
- en: Several tabs full of options allow you to decide which anti-anti-debugging techniques
    you wish to employ. Once activated, IDAStealth implements evasion techniques for
    virtually every known debugger-detection technique, including those discussed
    in the Falliere article and those addressed by the *HideDebugger.idc* script developed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, programs expect to handle any exceptions generated during their
    execution. As we saw in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis"),
    obfuscated programs often go so far as to intentionally generate exceptions as
    both an anti–control flow technique and an anti-debugging technique. Unfortunately,
    exceptions are often indicative of a problem, and the purpose of debuggers is
    to assist us in localizing problems. Therefore, debuggers typically want to handle
    all exceptions that occur when a program is running in order to help us find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: When a program expects to handle its own exceptions, we need to prevent the
    debugger from intercepting such exceptions, or, at a minimum, once an exception
    is intercepted, we need a means to have the debugger forward the exception to
    the process at our discretion. Fortunately, IDA’s debugger has the capability
    to pass along individual exceptions as they occur or to automatically pass along
    all exceptions of a specified type.
  prefs: []
  type: TYPE_NORMAL
- en: Automated exception processing is configured via the Debugger ▸ Debugger Options
    command; the resulting dialog is shown in [Figure 25-7](ch25s05.html#the_debugger_setup_dialog
    "Figure 25-7. The Debugger Setup dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Debugger Setup dialog](httpatomoreillycomsourcenostarchimages854411.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-7. The Debugger Setup dialog
  prefs: []
  type: TYPE_NORMAL
- en: In addition to allowing several events to be configured to automatically stop
    the debugger and a number of events to be automatically logged to IDA’s message
    window, the Debugger Setup dialog is used to configure the debugger’s exception-handling
    behavior. The Edit Exceptions button opens the Exceptions configuration dialog
    shown in [Figure 25-8](ch25s05.html#the_exceptions_configuration_dialog "Figure 25-8. The
    Exceptions configuration dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Exceptions configuration dialog](httpatomoreillycomsourcenostarchimages854414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-8. The Exceptions configuration dialog
  prefs: []
  type: TYPE_NORMAL
- en: For each exception type known to the debugger, the dialog lists an operating
    system–specific exception code, the name of the exception, whether the debugger
    will stop the process or not (`Stop/No`), and whether the debugger will handle
    the exception or automatically pass the exception to the application (`Debugger/Application`).
    A master list of exceptions and default settings for handling each exception is
    contained in *<IDADIR>/cfg/exceptions.cfg*. In addition, the configuration file
    contains messages to be displayed whenever an exception of a given type occurs
    while the debugger is executing a process. Changes to the debugger’s default exception-handling
    behavior may be made by editing *exceptions.cfg* with a text editor. In *exceptions.cfg*,
    the values `stop` and `nostop` are used to indicate whether the debugger should
    suspend the process or not when a given exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling may also be configured on a persession (that is, while you
    have a particular database open) basis by editing individual exceptions via the
    Exceptions configuration dialog. To modify the debugger’s behavior for a given
    exception type, right-click the desired exception in the Exceptions configuration
    dialog and select **Edit**. [Figure 25-9](ch25s05.html#the_exception_editing_dialog
    "Figure 25-9. The Exception editing dialog") shows the resulting Exception editing
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Exception editing dialog](httpatomoreillycomsourcenostarchimages854417.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-9. The Exception editing dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Two options, corresponding to the two configurable options in *exceptions.cfg*,
    may be configured for any exception. First, it is possible to specify whether
    the debugger should stop the process when an exception of the specified type occurs
    or whether execution should continue. Beware: Allowing the process to continue
    may result in an infinite exception-generation loop if you also elect to have
    the debugger handle the exception.'
  prefs: []
  type: TYPE_NORMAL
- en: The second configuration option allows you to decide whether a given exception
    type should be passed to the application being debugged so the application can
    have a chance to process the exception using its own exception handlers. When
    the proper operation of an application depends on such exception handlers being
    executed, you should choose to pass the associated exception types to the application.
    This may be required when analyzing obfuscated code such as that generated by
    the tElock utility (which registers its own exception handlers) described in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis").
  prefs: []
  type: TYPE_NORMAL
- en: Unless you have configured IDA to continue execution and to pass a specific
    exception type to the application, IDA will pause execution and report exceptions
    to you as they occur. If you elect to continue execution of the program, IDA will
    then display the Exception Handling dialog shown in [Figure 25-10](ch25s05.html#the_exception_handling_dialog
    "Figure 25-10. The Exception Handling dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Exception Handling dialog](httpatomoreillycomsourcenostarchimages854420.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-10. The Exception Handling dialog
  prefs: []
  type: TYPE_NORMAL
- en: At this point you have the option of changing the manner in which IDA handles
    the given exception type (Change exception definition), passing the exception
    on to the application (Yes), or allowing IDA to eat the exception (No). Passing
    the exception to the application allows the application to handle the exception
    using any configured exception handlers. If you choose No, IDA attempts to continue
    execution, which is likely to fail unless you have corrected the condition that
    was responsible for causing the exception.
  prefs: []
  type: TYPE_NORMAL
- en: A special circumstance arises when you are single stepping through code and
    IDA determines that the instruction you are about to execute will generate an
    exception, as is the case with an `int 3`, an `icebp`, or a `popf` that will set
    the trace flag; IDA displays the dialog shown in [Figure 25-11](ch25s05.html#the_exception_confirmation_dialog
    "Figure 25-11. The exception confirmation dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The exception confirmation dialog](httpatomoreillycomsourcenostarchimages854423.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-11. The exception confirmation dialog
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the Run option is the most suitable choice and results in the
    application seeing the behavior that it expects when a debugger is not attached
    (as noted in the dialog). In working through this dialog, you are simply acknowledging
    that an exception is about to be generated. If you choose Run, in short order
    you will then be notified that an exception has occurred, and when you continue
    execution, you will be presented with the Exception Handling dialog of [Figure 25-10](ch25s05.html#the_exception_handling_dialog
    "Figure 25-10. The Exception Handling dialog") to decide how the exception should
    be dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: Determining how an application will handle an exception requires that we know
    how to trace exception handlers, which in turn requires that we know how to locate
    exception handlers. Ilfak discusses tracing Windows SEH handlers in a blog post
    titled “Tracing exception handlers.”^([[236](#ftn.CHP-25-FN-11)]) The basic idea
    is to locate any interesting exception handlers by walking the application’s list
    of installed exception handlers. For Windows SEH exceptions, a pointer to the
    head of this list may be found as the first dword in the thread environment block
    (TEB). The list of exception handlers is a standard linked-list data structure
    that contains a pointer to the next exception handler in the chain and a pointer
    to the function that should be called to handle any exception that is generated.
    Exceptions are passed down the list from one handler to another until a handler
    chooses to handle the exception and notify the operating system that the process
    may resume normal execution. If none of the installed exception handlers choose
    to handle the current exception, the operating system terminates the process or,
    when the process is being debugged, notifies the debugger that an exception has
    occurred within the debugged process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the IDA debugger, TEBs are mapped to an IDA database section named `TIB[`*`NNNNNNNN`*`]`,
    where *`NNNNNNNN`* is the eight-digit hexadecimal representation of the thread’s
    identification number. The following listing shows an example of the first dword
    in one such section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three lines show summary information about the segment, while the
    fourth line ![](httpatomoreillycomsourcenostarchimages854061.png) contains the
    first dword of the section, indicating that the first exception handler record
    may be found at address `22FFE0h` (`off-set dword_22FFE0`). If no exception handlers
    were installed for this particular thread, the first dword in the TEB would contain
    the value `0FFFFFFFFh`, indicating that the end of the exception handler chain
    had been reached. In this example, examining two dwords at address `22FFE0h` shows
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first dword ![](httpatomoreillycomsourcenostarchimages854061.png) contains
    the value `0FFFFFFFFh`, indicating that this is the last exception handler record
    in the chain. The second dword ![](httpatomoreillycomsourcenostarchimages854063.png)
    contains the address `7C839AA8h` (`offset loc_7C839AA8`), indicating that the
    function at `loc_7C839AA8` should be called to process any exceptions that may
    arise during the execution of the process. If we were interested in tracing the
    handling of any exceptions in this process, we might begin by setting a breakpoint
    at address `7C839AA8h`.
  prefs: []
  type: TYPE_NORMAL
- en: Because it is a relatively simple task to walk the SEH chain, a useful feature
    for the debugger to implement would be a display of the chain of SEH handlers
    that are installed for the current thread. Given such a display, it should be
    easy to navigate to each SEH handler, at which point you may decide whether you
    want to insert a breakpoint within the handler or not. Unfortunately, this is
    another feature available in OllyDbg that is not available in IDA’s debugger.
    To address this shortcoming, we have developed an SEH Chain plug-in, which, when
    invoked from within the debugger, will display the list of exception handlers
    that are installed for the current thread. An example of this display is shown
    in [Figure 25-12](ch25s05.html#the_seh_chain_display "Figure 25-12. The SEH Chain
    display").
  prefs: []
  type: TYPE_NORMAL
- en: '![The SEH Chain display](httpatomoreillycomsourcenostarchimages854427.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-12. The SEH Chain display
  prefs: []
  type: TYPE_NORMAL
- en: This plug-in utilizes the SDK’s `choose2` function to display a nonmodal dialog
    that lists the current exception-handler chain. For each installed exception handler,
    the address of the exception-handler record (the two-dword list record) and the
    address of the corresponding exception handler are displayed. Double-clicking
    an exception handler jumps the active disassembly view (either IDA View-EIP or
    IDA View-ESP) to the address of the SEH handler function. The entire purpose of
    this plug-in is to simplify the process of locating exception handlers. The source
    code for the SEH Chain plug-in may be found on the website for this book.
  prefs: []
  type: TYPE_NORMAL
- en: The flip side of the exception-handling process is the manner in which an exception
    handler returns control (if it chooses to do so) to the application in which the
    exception occurred. When an exception-handler function is called by the operating
    system, the function is granted access to all of the CPU register’s contents as
    they were set at the moment the exception took place. In the process of handling
    the exception, the function may elect to modify one or more CPU register values
    prior to returning control to the application. The intent of this process is for
    an exception handler to be given the opportunity to repair the state of the process
    sufficiently so that the process may resume normal execution. If the exception
    handler determines that the process should be allowed to continue, the operating
    system is notified, and the process’s register values are restored, using any
    modifications made by the exception handler. As discussed in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis"), some anti–reverse engineering utilities
    make use of exception handlers to alter a process’s flow of execution by modifying
    the saved value of the instruction pointer during the exception-handling phase.
    When the operating system returns control to the affected process, execution resumes
    at the address specified by the modified instruction pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his blog post on tracing exceptions, Ilfak discusses the fact that Windows
    SEH exception handlers return control to the affected process via the *ntdll.dll*
    function `NtContinue` (also known as `ZwContinue`). Since `NtContinue` has access
    to all of the process’s saved register values (via one of its arguments), it is
    possible to determine exactly where the process will resume execution by examining
    the value contained in the saved instruction pointer from within `NtContinue`.
    Once we know where the process is set to resume execution, we can set a breakpoint
    in order to avoid stepping through operating system code and to stop the process
    at the earliest opportunity once it resumes execution. The following steps outline
    the process we need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate `NtContinue` and set a nonstopping breakpoint on its first instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a breakpoint condition to this breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the breakpoint is hit, obtain the address of the saved registers by reading
    the `CONTEXT` pointer from the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the process’s saved instruction pointer value from the `CONTEXT` record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a breakpoint on the retrieved address and allow execution to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using a process similar to the debugger-hiding script, we can automate all
    of these tasks and associate them with the initiation of a debugging session.
    The following code demonstrates launching a process in the debugger and setting
    a breakpoint on `NtContinue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of this code is simply to set a conditional breakpoint on the entry
    of `NtContinue`. The behavior of the breakpoint is implemented by the IDC function
    `bpt_NtContinue`, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function locates the pointer to the process’s saved register context information
    ![](httpatomoreillycomsourcenostarchimages854061.png), retrieves the saved instruction
    pointer value from offset `0xB8` within the `CONTEXT` structure ![](httpatomoreillycomsourcenostarchimages854063.png),
    and sets a breakpoint on this address ![](httpatomoreillycomsourcenostarchimages854093.png).
    In order to make it clear to the user why execution has stopped, a breakpoint
    condition (which is always true) is added to display a message to the user ![](httpatomoreillycomsourcenostarchimages854095.png).
    We choose to do this because the breakpoint was not set explicitly by the user,
    and the user may not correlate the event to the return from an exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: This example represents a simple means of handling exception returns. Much more
    sophisticated logic could be added to the breakpoint function `bpt_NtContinue`.
    For example, if you suspect that an exception handler is manipulating the contents
    of debug registers, perhaps to prevent you from setting hardware breakpoints,
    you might opt to restore the values of the debug registers to known good values
    prior to returning control to the process being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[236](#CHP-25-FN-11)]) See [http://www.hexblog.com/2005/12/tracing_exception_handlers.html](http://www.hexblog.com/2005/12/tracing_exception_handlers.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to their obvious uses in tracking down bugs in software, debuggers
    may also be used as effective reverse engineering tools. For malware and obfuscated
    code analysis, the ability to utilize a single application for both static and
    dynamic analysis can save valuable time and the effort required to generate data
    with one tool that can be analyzed with a second tool. Given the wide variety
    of debuggers available today, IDA’s debugger may not be the ideal choice for tracking
    down runtime problems in your applications. However, if you anticipate the need
    to conduct any reverse engineering of an application or if you simply desire a
    high-quality disassembly to refer to during the debugging process, IDA’s debugger
    may serve your needs well. In [Chapter 26](ch26.html "Chapter 26. Additional Debugger
    Features"), we conclude the book by covering more advanced features of IDA’s debugger,
    including remote debugging and debugging on Linux and OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 26. Additional Debugger Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Over the last two chapters, we have covered the majority of the debugger’s basic
    features including scripting debugger actions, as well as its usefulness in de-obfuscating
    code. In this chapter, we round out our discussion of the debugger by looking
    at remote debugging with IDA, the use of the Bochs x86 emulator^([[237](#ftn.CHP-26-FN-1)])
    as a debugging platform, and the Appcall^([[238](#ftn.CHP-26-FN-2)]) feature that
    effectively extends IDA’s scripting capabilities to include any function defined
    with a process and its associated libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Remote Debugging with IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All versions of IDA ship with server components designed to facilitate remote
    debugging sessions. In addition, IDA is capable of interfacing with remote gdb
    sessions that make use of `gdb_server` or built-in gdb stubs. One of the principal
    advantages of remote debugging is the ability to use the GUI debugger interface
    as a frontend for any debugging session. For the most part, other than initial
    setup and establishing the connection to the remote debugging server, remote debugging
    sessions differ little from local debugging sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Hex-Rays Debugging Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remote debugging begins by launching an appropriate debugging server component
    on the computer on which a process is to be debugged. IDA ships with the following
    server components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`win32_remote.exe`** Server component executed on Windows computers for
    the purpose of debugging 32-bit Windows applications |'
  prefs: []
  type: TYPE_TB
- en: '| **`win64_remotex64.exe`** Server component executed on 64-bit Windows computers
    for the purpose of debugging 64-bit Windows applications (IDA Advanced only) |'
  prefs: []
  type: TYPE_TB
- en: '| **`wince_remote_arm.dll`** Server component uploaded to Windows CE devices
    (via ActiveSync) |'
  prefs: []
  type: TYPE_TB
- en: '| **`mac_server`** Server component executed on OS X computers for the purpose
    of debugging 32-bit OS X applications |'
  prefs: []
  type: TYPE_TB
- en: '| **`mac_serverx64`** Server component executed on 64-bit OS X computers for
    the purpose of debugging 64-bit OS X applications (IDA Advanced only) |'
  prefs: []
  type: TYPE_TB
- en: '| **`linux_server`** Server component executed on Linux computers for the purpose
    of debugging 32-bit Linux applications |'
  prefs: []
  type: TYPE_TB
- en: '| **`linux_serverx64`** Server component executed on 64-bit Linux computers
    for the purpose of debugging 64-bit Linux applications (IDA Advanced only) |'
  prefs: []
  type: TYPE_TB
- en: '| **`armlinux_server`** Server component executed on ARM-based computers for
    the purpose of debugging ARM applications |'
  prefs: []
  type: TYPE_TB
- en: '| **`android_server`** Server component executed on Android devices for the
    purpose of debugging Android applications |'
  prefs: []
  type: TYPE_TB
- en: In order to perform remote debugging on any platform, the only component you
    are required to execute on that platform is the appropriate server component.
    It is not necessary to install a full version of IDA on the remote platform. In
    other words, if you intend to use a Windows version of IDA as your debugging client,
    and you wish to remotely debug Linux applications, the only file, other than the
    binary that is being debugged, that you need to copy to and execute on the Linux
    system is *linux_server*.^([[239](#ftn.CHP-26-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the platform you intend to run the server on, the server components
    accept three command-line options, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`-p<`****``*`port number`*``****`>`** is used to specify an alternate TCP
    port for the server to listen on. The default port is 23946\. Note that no space
    should be entered between the `-p` and the port number. |'
  prefs: []
  type: TYPE_TB
- en: '| **`-P<`****``*`password`*``****`>`** is used to specify a password that must
    be supplied in order for a client to connect to the debug server. Note that no
    space should be entered between the `-P` and the provided password. |'
  prefs: []
  type: TYPE_TB
- en: '| **`-v`** places the server in verbose mode. |'
  prefs: []
  type: TYPE_TB
- en: There is no option to restrict the IP address on which the server listens. If
    you wish to restrict incoming connections, you may do so using host-based firewall
    rules as applicable to your debugging platform. Once a server has been launched,
    IDA may be executed from any supported operating system and used to provide a
    client interface to the debug server; however, a server can handle only one active
    debugging session at any given time. If you wish to maintain several simultaneous
    debugging sessions, you must launch several instances of the debugging server
    on several different TCP ports.
  prefs: []
  type: TYPE_NORMAL
- en: From the client perspective, remote debugging is initiated by specifying a server
    hostname and ports via the Debugger ▸ Process Options command, as shown in [Figure 26-1](ch26.html#the_debugger_process_options_dialog
    "Figure 26-1. The debugger process options dialog"). This action must be performed
    prior to starting or attaching to the process you intend to debug.
  prefs: []
  type: TYPE_NORMAL
- en: '![The debugger process options dialog](httpatomoreillycomsourcenostarchimages854430.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-1. The debugger process options dialog
  prefs: []
  type: TYPE_NORMAL
- en: The first four fields in this dialog apply to both local and remote debugging
    sessions, while the Hostname, Port, and Password fields apply only to remote debugging
    sessions. The fields of this dialog are summarized here.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Application** The full path to the application binary that you wish to
    debug. For local debugging sessions, this is a path in the local filesystem. For
    a remote debugging session, this is the path on the debugging server. If you choose
    not to use a full path, the remote server will search its current working directory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Input file** The full path to the file that was used to create the IDA
    database. For local debugging sessions, this is a path in the local filesystem.
    For a remote debugging session, this is the path on the debugging server. If you
    choose not to use a full path, the remote server will search its current working
    directory. |'
  prefs: []
  type: TYPE_TB
- en: '| **Directory** The working directory in which the process should be launched.
    For local debugging, this directory must exist in the local file-system. For remote
    debugging, this is a directory on the debugging server. |'
  prefs: []
  type: TYPE_TB
- en: '| **Parameters** Used to specify any command-line parameters to be passed to
    the process when it is started. Note that shell metacharacters (such as `<`, `>`,
    and `&#124;`) are not honored here. Any such characters will be passed to the
    process as command-line arguments. Thus it is not possible to launch a process
    under the debugger and have that process perform any sort of input or output redirection.
    For remote debugging sessions, process output is displayed in the console that
    was used to launch the debugging server. |'
  prefs: []
  type: TYPE_TB
- en: '| **Hostname** The hostname or IP address of the remote debugging server. Leave
    this field blank for local debugging sessions. |'
  prefs: []
  type: TYPE_TB
- en: '| **Port** The TCP port number on which the remote debugging server is listening.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Password** The password expected by the remote debugging server. Note that
    the data entered into this field is not masked, making it possible for the password
    to be viewed by anyone who can observe your display. Further, this password is
    transmitted to the remote server as plain text, making it observable by anyone
    who can intercept your network packets. |'
  prefs: []
  type: TYPE_TB
- en: At first glance, the Application and Input File fields in [Figure 26-1](ch26.html#the_debugger_process_options_dialog
    "Figure 26-1. The debugger process options dialog") may seem to be identical.
    When the file opened in your IDA database is the same as the executable file that
    you wish to run on the remote computer, these two fields will hold the same value.
    However, in some cases, you may wish to debug a library file (such as a DLL) that
    you are analyzing in an IDA database. It is not possible to debug a library file
    directly because library files are not standalone executables. In such cases,
    you will set the Input File field to the path of the library file. The Application
    field must be set to the name of an application that makes use of the library
    file that you wish to debug.
  prefs: []
  type: TYPE_NORMAL
- en: The procedures for connecting to a remote gdb server are nearly identical to
    the procedures for attaching to a remote IDA debugging server with two minor exceptions.
    First, no password is required to connect to a `gdb_server`, and second, IDA allows
    specification of gdb-specific behaviors via the Set specific options button within
    the debugger setup dialog. [Figure 26-2](ch26.html#gdb_configuration_dialog "Figure 26-2. GDB
    Configuration dialog") shows the GDB Configuration dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![GDB Configuration dialog](httpatomoreillycomsourcenostarchimages854433.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-2. GDB Configuration dialog
  prefs: []
  type: TYPE_NORMAL
- en: Of note is the fact that IDA has no way of knowing the architecture of the computer
    on which the `gdb_server` is running and that you are obligated to specify a processor
    type (which defaults to Intel x86) and potentially the endian-ness of that processor.
    IDA is currently capable of providing a debugging interface for x86, ARM, PowerPC,
    and MIPS processors.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to a Remote Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of different scenarios exist if you intend to attach to a running process
    on your remote debugging server. First, if you have no database open in IDA, you
    may select Debugger ▸ Attach and choose from IDA’s list of available debuggers.
    If you choose one of IDA’s remote debuggers, you are presented with the configuration
    dialog shown in [Figure 26-3](ch26.html#remote_debugger_configuration "Figure 26-3. Remote
    debugger configuration").
  prefs: []
  type: TYPE_NORMAL
- en: '![Remote debugger configuration](httpatomoreillycomsourcenostarchimages854436.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-3. Remote debugger configuration
  prefs: []
  type: TYPE_NORMAL
- en: Once you provide the appropriate connection parameters and click OK, IDA obtains
    and displays a process list from the remote debugging server, allowing you to
    select and attach to a specific process.
  prefs: []
  type: TYPE_NORMAL
- en: In the second scenario, you might already have a binary open in IDA and wish
    to attach to a remote process. In this case you may need to select a debugger
    (if none has been previously specified for the open file type) or switch your
    debugger type (if a remote debugger is not currently selected). Once a debugger
    has been selected, you must provide hostname and password information for the
    remote debugger server, as shown in [Figure 26-1](ch26.html#the_debugger_process_options_dialog
    "Figure 26-1. The debugger process options dialog"), at which point you may attach
    to a remote process using Debugger ▸ Attach to Process.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Handling During Remote Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger Integration") we
    discussed the IDA debugger’s handling of exceptions and how to modify the debugger’s
    exception-handling behavior. During remote debugging sessions, the debugger’s
    default exception-handling behavior is dictated by the *exceptions.cfg* file,
    which resides on the client machine (the machine on which you are actually running
    IDA). This allows you to modify *exceptions.cfg* and reload the changes via the
    Debugger Setup dialog (see [Figure 25-4](ch25s03.html#debugger_pausing_events
    "Figure 25-4. Debugger pausing events")) without the need to access the remote
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Using Scripts and Plug-ins During Remote Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During a remote debugging session, it remains possible to utilize scripts and
    plug-ins to automate debugging tasks. Any scripts or plug-ins that you choose
    to execute will run within IDA on the client machine. IDA will in turn handle
    any actions that are required to interact with the remote process, such as setting
    breakpoints, querying state, modifying memory, or resuming execution. From the
    script’s perspective, all behaviors will appear just as if the debugging session
    was taking place locally. The only thing to remember is to make sure that your
    scripts and plug-ins are tailored to the architecture on which the target process
    is running and not the architecture on which the IDA client is running (unless
    they happen to be the same). In other words, if you are running the Windows version
    of IDA as a client for remote debugging on Linux, do not expect your Windows debugger-hiding
    script to do you any good.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[237](#CHP-26-FN-1)]) See [http://bochs.sourceforge.net/](http://bochs.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[238](#CHP-26-FN-2)]) See [http://www.hexblog.com/?p=112](http://www.hexblog.com/?p=112).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[239](#CHP-26-FN-3)]) Note that the **_server* binaries distributed with
    IDA depend on a number of shared libraries. You can use `ldd` (or `otool -L` on
    OS X) to list these dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Bochs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bochs is an open source x86 emulation environment. Bochs is capable of full-system
    emulation of x86 computer systems and includes emulation for common I/O devices
    and a custom BIOS. Bochs provides an emulation-based alternative to virtualization
    software such as VMware Workstation. Elias Bachaalany of the Hex-Rays development
    team has taken the lead on integrating Bochs with IDA to provide an emulation-based
    alternative to traditional debugging.^([[240](#ftn.CHP-26-FN-4)]) Windows versions
    of IDA ship with and install a compatible version of Bochs, while non-Windows
    users wishing to make use of Bochs must make sure that version 2.4.2 or later
    is installed on their system.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Bochs installed, IDA offers a Local Bochs debugger choice whenever you
    have an x86 binary open in IDA. The availability of Bochs offers the opportunity
    to perform local debugging of Windows applications on non-Windows systems, because
    the application will be emulated rather than executed as a native process. Because
    it’s an emulator, Bochs configuration options differ somewhat from those available
    with more traditional debuggers. One of the most important things to understand
    about Bochs is that it can operate in three distinct modes: disk image mode, IDB
    mode, and PE mode. The choice of mode is made using the Bochs specific debugger
    configuration dialog shown in [Figure 26-4](ch26s02.html#bochs_debugger_options_dialog
    "Figure 26-4. Bochs debugger options dialog").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bochs debugger options dialog](httpatomoreillycomsourcenostarchimages854439.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-4. Bochs debugger options dialog
  prefs: []
  type: TYPE_NORMAL
- en: Each of the available modes offers a drastically different degree of fidelity
    in terms of the quality and type of emulation being performed.
  prefs: []
  type: TYPE_NORMAL
- en: Bochs IDB Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working from the ground up, IDB is the most basic Bochs mode. In IDB mode, the
    only code that Bochs is aware of is the code contained in your database. Memory
    regions are mapped into Bochs and populated by copying bytes from the database.
    A configurable amount of stack space is provided based on settings in the Bochs
    options dialog, and IDA will make its own decision as to where the stack will
    be allocated. Emulated execution begins (meaning the instruction pointer is initially
    positioned) at the database symbol named `ENTRY` if one has been defined. If an
    `ENTRY` symbol is not present, IDA tests to see if a range of locations is currently
    selected in the open database and uses the beginning of the range as the debugger
    entry point. If no selection exists, then the current cursor location is taken
    as the initial instruction pointer value. When running in IDB mode, keep in mind
    that Bochs has no notion of any operating system support such as shared libraries
    or the location of any well-known structures within a typical process address
    space. It is equally possible to step through a PE file, an ELF file, a Mach-O
    file, or a raw blob of machine code such as an exploit payload as long as the
    code makes no reference to anything that might reside outside the database. One
    way that IDB might be used is for executing a single function in an effort to
    understand its behavior without the requirement to craft a complete process or
    disk image to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Bochs PE Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PE mode offers the opportunity to debug at something approaching the process
    level. When PE mode is selected and activated, IDA’s Bochs control module (an
    IDA plug-in) takes over and behaves much like the Windows process loader would
    if you were actually launching a native Windows process. A PE mode process receives
    process (PEB) and thread (TEB) environment blocks, along with a stack that mimics
    those that would be created in an actual process.
  prefs: []
  type: TYPE_NORMAL
- en: The Bochs plug-in also loads (without executing any code) a number of common
    Windows libraries into the emulated process address space in order to properly
    handle any library calls made by the process. The exact set of libraries that
    Bochs loads on debugger start is configurable and is specified in *<IDADIR>/plugins/bochs/startup.idc*.
    Any library may be loaded as is or may be designated to be stubbed out. If a library
    is marked to be stubbed, then the Bochs plug-in will automatically hook every
    function exported by that library and redirect execution to a Bochs interception
    function (refer to *startup.idc* and the IDA help system for more details). This
    stubbing technique provides an extensible means for users to define custom behaviors
    for any library function. For any library that is stubbed by IDA, it is possible
    to define a corresponding script file in which you may define your custom behaviors.
    For any library, *foolib.dll* for example, the Bochs plug-in scans for a related
    script named *api_foolib.idc* or *api_foolib.py* within the *<IDADIR>/plugins/bochs*
    directory. IDA ships with *<IDADIR>/plugins/bochs/api_kernel32.idc*, which provides
    a good example of the structure of such a file and the implementation of custom
    behaviors for a number of functions.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to hook library functions and define custom implementations is important
    in PE mode because there is no operating system layer to perform all of the heavy
    lifting needed by the shared libraries. For example, by providing an alternate,
    script-based behavior for a function such as `VirtualAlloc`, which would fail
    if it could not communicate with the operating system, it is possible to convince
    (to some degree) the emulated process that it is running as an actual process.
    The goal when creating such script-based behaviors is to provide the emulated
    process with the responses it would expect to see if were communicating with the
    actual library functions, which in turn were communicating with the actual operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: If you use IDA on a non-Windows platform, you may take full advantage of Bochs
    PE mode by copying any required libraries (as specified in *startup.idc*) from
    a Windows system onto your IDA system and editing *startup.idc* to point at the
    directory containing all of the copied libraries. The following listing shows
    an example of the required changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When using PE mode, one difference you will note when launching a process under
    Bochs is that IDA does not open a warning dialog to remind you of the danger of
    launching a potentially malicious process under debugger control. This is because
    the only process that gets created is the Bochs emulator process, and all of the
    code that you are debugging is viewed by the Bochs emulator as data that happens
    to represent code for it to emulate. No native process is ever created from the
    binary that you are debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Bochs Disk Image Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third mode of operation for the Bochs debugger is called disk image mode.
    Aside from IDA’s ability to make use of Bochs, Bochs is a full-blown x86 system
    emulator on its own. It is quite possible to create hard drive images, using the
    `bximage` tool supplied with Bochs; install an operating system on the disk image,
    using Bochs and any required installation medium for the desired operating system;
    and ultimately use Bochs to run your guest operating system within an emulated
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: If your primary goal in using IDA/Bochs is to understand the behavior of a single
    process, then disk image mode may not be for you. Isolating and observing a single
    process executing within a fully emulated operating system is not an easy task
    and requires a detailed understanding of the operating system and how it manages
    processes and memory. Where you may find IDA/Bochs useful is in analyzing system
    BIOS and boot code, which can be followed relatively easily before the operating
    system code takes over.
  prefs: []
  type: TYPE_NORMAL
- en: In disk image mode, you have no executable file image to load into IDA. Instead,
    IDA ships with a loader that recognizes Bochs configuration (*boch-src*) files.^([[241](#ftn.CHP-26-FN-5)])
    A *bochsrc* file is used to describe the hardware execution environment when Bochs
    is used as a full system emulator. IDA’s default *bochsrc* file is located at
    *<IDADIR>/cfg/bochsrc.cfg*. Among other things, a *bochsrc* file is used to specify
    the locations of the system BIOS, video ROM, and disk image files. IDA’s *bochsrc*
    loader offers minimal loading services, doing nothing more than reading the first
    sector of the first disk image file specified in the Bochs configuration file
    being loaded and then selecting the Bochs debugger for use with the new database.
    The use of IDA/Bochs in a master boot record development scenario is discussed
    on the Hex-Rays blog.^([[242](#ftn.CHP-26-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[240](#CHP-26-FN-4)]) See “Designing a minimal operating system to emulate
    32/64bits x86 code snippets, shellcode or malware in Bochs” from Recon 2011 ([http://www.recon.cx/](http://www.recon.cx/)).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[241](#CHP-26-FN-5)]) See [http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html](http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html)
    for information on the `bochsrc` file format.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[242](#CHP-26-FN-6)]) See [http://www.hexblog.com/?p=103](http://www.hexblog.com/?p=103).
  prefs: []
  type: TYPE_NORMAL
- en: Appcall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debugger’s Appcall feature effectively extends the capabilities of IDC or
    IDAPython to make any function in the active process callable from a script. There
    are an infinite number of uses for such a capability, including mapping additional
    memory into the process address space (by calling `VirtualAlloc` or similar) and
    injecting new libraries into the process being debugged (by calling `LoadLibrary`
    or by calling functions within the process to perform tasks you would rather perform
    manually, such as decoding blocks of data or computing hash values).
  prefs: []
  type: TYPE_NORMAL
- en: In order to make use of Appcall, the function you wish to invoke must be loaded
    in the address space of the process being debugged, and IDA must know or be informed
    of the function’s prototype so that parameters may be marshaled and unmarshaled
    properly. Any Appcall that you do make will be made in the context of the current
    debugger thread after first saving the thread’s state (essentially all registers
    associated with the thread). Once the Appcall completes, IDA restores the thread
    state, and the debugger is ready to resume execution as if no Appcall had ever
    taken place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in which Appcall is used to allocate a 4096-byte block
    of memory into the current (Windows) process address space. In this case, the
    Windows API function that we wish to invoke is named `VirtualAlloc` and its prototype
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The call that we wish to make using Appcall might look something like the following
    if we were to write it in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This function call ultimately translates into the following once all of the
    constants are resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that while a Windows process is being debugged, IDA prefixes the name
    of every library function with the name of the library to which the function belongs.
    Thus, `VirtualAlloc` will be named `kernel32_VirtualAlloc` when the debugger is
    active, as shown is the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'No type information is displayed because IDA’s type libraries know nothing
    about a function named `kernel32_VirtualAlloc`. Since Appcall requires knowledge
    of a function’s type signature, we must add the information into the database
    ourselves using the `Set Function Type` command. An exact type signature is not
    required as long as the signature we specify allows IDA to properly transfer our
    parameters to the function we are invoking. In this case, we supply the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we are ready to use Appcall to have more memory allocated into
    our process. Using IDC, this is extremely easy because all we need to do is invoke
    the function just as if it was an IDC function. Entering the function call at
    the IDA command line and using the `Message` function to display the results yields
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The result in this case is a new 4096-byte block allocated to the process at
    address `0x3c0000`. In order to make the new memory block show up in IDA, we must
    use the Debugger ▸ Refresh memory command or wait for IDA to perform a refresh
    in conjunction with other debugger operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for performing an Appcall in Python is slightly different, making
    use of the `Appcall` variable defined in the `idaapi` module. However, the requirements
    to have a named function with an assigned type signature remain. When performed
    in Python, the same Appcall to `VirtualAlloc` would be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Additional information and examples related to Appcall and its uses may be found
    on the Hex-Rays blog.^([[243](#ftn.CHP-26-FN-7)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[243](#CHP-26-FN-7)]) See [http://www.hexblog.com/?p=113](http://www.hexblog.com/?p=113).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether through the efforts of the Hex-Rays development team or through user
    contributions, IDA’s debugger is continually evolving. The best place to keep
    up with all of these changes is the Hex-Rays blog ([http://www.hexblog.com/](http://www.hexblog.com/)),
    where the Hex-Rays developers frequently preview features that will appear in
    upcoming versions of IDA. Keeping up with user-contributed extensions requires
    a little more effort. Occasionally, interesting IDA extensions are announced in
    the IDA support forums, but you are just as likely to see them announced in various
    reverse engineering forums (such as [http://www.openrce.org/](http://www.openrce.org/)),
    see them entered into Hex-Rays’s annual plug-in writing contest, or simply stumble
    across them while performing an Internet search.
  prefs: []
  type: TYPE_NORMAL
- en: IDA’s debugger is both full featured and extensible. With both local and remote
    capabilities, as well as the ability to act as a frontend to a number of popular
    debuggers such as gdb and WinDbg, IDA offers a consistent debugging interface
    across a large number of popular platforms. Given the ability to script extensions
    or build compiled debugger plug-ins, the limits of the debugger’s capabilities
    are constantly being extended. Among current debuggers, IDA’s debugger enjoys
    perhaps the most active development and benefits from the fact that all of its
    core developers are themselves accomplished reverse engineers who share a personal
    as well as professional interest in making the debugger a powerful and useful
    tool.
  prefs: []
  type: TYPE_NORMAL
