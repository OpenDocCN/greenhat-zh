- en: Chapter 2. Class Hierarchies, Attributes, and Class Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We ended the previous chapter by creating two new classes: a Thing and a Treasure.
    Despite the fact that these two classes shared some features (notably both had
    a “name”), there was no connection between them.'
  prefs: []
  type: TYPE_NORMAL
- en: These two classes are so trivial that this tiny bit of repetition doesn’t really
    matter much. However, when you start writing real programs of some complexity,
    your classes will frequently contain numerous variables and methods, and you really
    don’t want to keep coding the same things over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to create a class hierarchy in which one class may be a “special
    type” of some other (ancestor) class, in which case it will automatically inherit
    the features of its ancestor. In our simple adventure game, for instance, a Treasure
    is a special type of Thing, so the Treasure class should inherit the features
    of the Thing class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, I will often talk about descendant classes inheriting features
    from their ancestor classes. These terms deliberately suggest a kind a family
    relationship between “related” classes. Each class in Ruby has only one parent.
    It may, however, descend from a long and distinguished family tree with many generations
    of parents, grandparents, great-grandparents, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of Things in general will be coded in the Thing class. The Treasure
    class will automatically “inherit” all the features of the Thing class, so we
    won’t need to code them all over again; it will then add some additional features,
    specific to Treasures.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, when creating a class hierarchy, the classes with the most
    generalized behavior are higher up the hierarchy than classes with more specialist
    behavior. So, a Thing class with just a name and a description would be the ancestor
    of a Treasure class that has a name, a description, and, additionally, a value;
    the Thing class might also be the ancestor of some other specialist class such
    as a Room that has a name, a description, and exits . . . and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One Parent, Many Children
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860142.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram shows a Thing class that has a *name* and a *description* (in a
    Ruby program, these might be internal variables such as `@name` and `@description`
    plus some methods to access them). The Treasure and Room classes both descend
    from the Thing class, so they automatically “inherit” a *name* and a *description*.
    The Treasure class adds one new item, *value*, so it now has *name*, *description*,
    and *value*. The Room class adds *exits*—so it has *name*, *description*, and
    *exits*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to create a descendant class in Ruby. Load the *1adventure.rb*
    program. This starts simply enough with the definition of a Thing class, which
    has two instance variables, `@name` and `@description`.
  prefs: []
  type: TYPE_NORMAL
- en: '*1adventure.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `@name` and `@description` variables are assigned values in the `initialize`
    method when a new Thing object is created. Instance variables generally cannot
    (and should not) be directly accessed from the world outside the class itself,
    because of the principle of encapsulation (as explained in the previous chapter).
    To obtain the value of each variable, you need a *get* accessor method such as
    `get_name`; in order to assign a new value, you need a *set* accessor method such
    as `set_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Superclasses and Subclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now look at the Treasure class, which is also defined in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1adventure.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the Treasure class is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The left angle bracket (`<`) indicates that Treasure is a *subclass*, or descendant,
    of Thing, and therefore it inherits the data (variables) and behavior (methods)
    from the Thing class. Since the methods `get_name`, `set_name`, `get_description`,
    and `set_description` already exist in the ancestor class (Thing), these methods
    don’t need to be recoded in the descendant class (Treasure).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Treasure class has one additional piece of data, its value (`@value`),
    and I have written *get* and *set* accessors for this. When a new Treasure object
    is created, its `initialize` method is automatically called. A Treasure has three
    variables to initialize (`@name`, `@description`, and `@value`), so its `initialize`
    method takes three arguments. The first two arguments are passed, using the `super`
    keyword, to the `initialize` method of the superclass (Thing) so that the Thing
    class’s `initialize` method can deal with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When used inside a method, the `super` keyword calls a method with the same
    name as the current method in the ancestor or *super*class. If the `super` keyword
    is used on its own, without any arguments being specified, all the arguments sent
    to the current method are passed to the ancestor method. If, as in the present
    case, a specific list of arguments (here `aName` and `aDescription`) is supplied,
    then only these are passed to the method of the ancestor class.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Arguments to the Superclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parentheses matter when calling the superclass! If the argument list is empty
    and no parentheses are used, *all* arguments are passed to the superclass. But
    if the argument list is empty and parentheses are used, *no* arguments are passed
    to the superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '*super_args.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To gain a better understanding of the use of `super`, see [Digging Deeper](ch02s06.html#digging_deeper-id1
    "Digging Deeper") in [Digging Deeper](ch02s06.html#digging_deeper-id1 "Digging
    Deeper").
  prefs: []
  type: TYPE_NORMAL
- en: Accessor Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the classes in this would-be adventure game work well enough, they
    are still fairly verbose because of all those *get* and *set* accessors. Let’s
    see what you can do to remedy this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of accessing the value of the `@description` instance variable with
    two different methods, `get_description` and `set_description`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'it would be so much nicer to retrieve and assign values just as you would retrieve
    and assign values to and from a simple variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to do this, you need to modify the Treasure class definition. One
    way of accomplishing this would be to rewrite the accessor methods for `@description`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*accessors1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'I have added accessors similar to these in the *accessors1.rb* program. Here,
    the *get* accessor is called `description`, and the *set* accessor is called `description=`
    (that is, it appends an equals sign to the method name used by the corresponding
    *get* accessor). It is now possible to assign a new string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can retrieve the value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when you write a *set* accessor in this way, you must append the
    `=` character to the method name, not merely place it somewhere between the method
    name and the arguments. In other words, this is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'but this results in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Attribute Readers and Writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In fact, there is a simpler and shorter way of creating a pair of *get* and
    *set* accessors simultaneously. All you have to do is use two special methods,
    `attr_reader` and `attr_writer`, followed by a *symbol* (a name preceded by a
    colon):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should add this code inside your class definition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Calling `attr_reader` with a symbol has the effect of creating a *get* accessor
    (here named `description`) for an instance variable (`@description`) with a name
    matching the symbol (`:description`).
  prefs: []
  type: TYPE_NORMAL
- en: Calling `attr_writer` similarly creates a *set* accessor for an instance variable.
    Instance variables are considered to be the “attributes” of an object, which is
    why the `attr_reader` and `attr_writer` methods are so named.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Symbol?
  prefs: []
  type: TYPE_NORMAL
- en: In Ruby, a *symbol* is a name preceded by a colon (for example, `:description`).
    The Symbol class is defined in the Ruby class library to represent names inside
    the Ruby interpreter. When you pass one or more symbols as arguments to `attr_reader`
    (which is a method of the Module class), Ruby creates an instance variable and
    a *get* accessor method. This accessor method returns the value of the corresponding
    variable; both the instance variable and the accessor method will take the name
    that was specified by the symbol. So, `attr_reader( :description )` creates an
    instance variable with the name, `@description`, and an accessor method named
    `description()`. Symbols are discussed in detail in [Chapter 11](ch11.html "Chapter 11. Symbols").
  prefs: []
  type: TYPE_NORMAL
- en: 'The *accessors2.rb* program contains some examples of attribute readers and
    writers in action. This is its version of the Thing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*accessors2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here the Thing class explicitly defines a *get* method accessor for the `@name`
    attribute. The advantage of writing a complete method like this is that it gives
    you the opportunity to do some extra processing rather than simply reading and
    writing an attribute value. The *get* accessor, `name` ![](httpatomoreillycomsourcenostarchimages860154.png),
    uses the `String.capitalize` method to return the string value of `@name` with
    its initial letter in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: When assigning a value to the `@name` attribute, I don’t need to do any special
    processing, so I have given it an attribute writer instead of a `set` accessor
    method ![](httpatomoreillycomsourcenostarchimages860150.png).
  prefs: []
  type: TYPE_NORMAL
- en: The `@description` attribute needs no special processing at all, so I use `attr_reader`
    and `attr_writer` instead of accessor methods in order to get and set the value
    of the `@description` variable ![](httpatomoreillycomsourcenostarchimages860146.png).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Are they attributes or properties? Don’t be confused by the terminology. In
    Ruby, an *attribute* is the equivalent of what many programming languages call
    a *property*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want both to read and to write a variable, the `attr_accessor` method
    provides a shorter alternative than using both `attr_reader` and `attr_writer`.
    I have used this to access the value attribute in the Treasure class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Earlier I said that calling `attr_reader` with a symbol actually creates a variable
    with the same name as the symbol. The `attr_accessor` method also does this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code for the Thing class, this behavior is not obvious since the class
    has an `initialize` method that explicitly creates the variables. The Treasure
    class, however, makes no reference to the `@value` variable in its `initialize`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The only indication that `@value` exists at all is this accessor definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'My code at the bottom of the *accessors2.rb* source file sets the value of
    each Treasure object as a separate operation, following the creation of the object
    itself, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though it has never been formally declared, the `@value` variable really
    does exist, and you are able to retrieve its numerical value using the *get* accessor:
    `t1.value`. To be absolutely certain that the attribute accessor really has created
    `@value`, you can always look inside the object using the `inspect` method. I
    have done so in the final two code lines in this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the data inside the t1 and t2 objects, including the `@value`
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Attribute accessors can initialize more than one attribute at a time if you
    send them a list of symbols separated by commas, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*accessors3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As always, parentheses around the arguments are optional but, in my view (for
    reasons of clarity), are to be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how to put attribute readers and writers to use in my adventure
    game. Load the *2adventure.rb* program. You will see that I have created two readable
    attributes in the Thing class: `name` and `description`. I have also made `description`
    writeable; however, because I don’t plan to change the names of any Thing objects,
    the `name` attribute is not writeable:'
  prefs: []
  type: TYPE_NORMAL
- en: '*2adventure.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: I have created a method called `to_s`, which returns a string describing the
    Treasure object. Recall that all Ruby classes have a `to_s` method as standard.
    The `Thing.to_s` method overrides (and replaces) the default one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can override existing methods when you want to implement new behavior appropriate
    to the specific class type.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Methods of a Superclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game in *2adventure.rb* will have two classes descending from Thing: the
    Treasure class and the Room class. The Treasure class adds a `value` attribute,
    which can be both read and written. Note that its `initialize` method calls its
    superclass in order to initialize the `name` and `description` attributes before
    initializing the new `@value` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, if I had omitted the call to the superclass, the `name` and `description`
    attributes would never be initialized. This is because `Treasure.initialize` overrides
    `Thing.initialize`, so when a Treasure object is created, the code in `Thing.initialize`
    will *not* automatically be executed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the Room class, which also descends from Thing, currently
    has no `initialize` method, so when a new Room object is created, Ruby goes scrambling
    back up the class hierarchy in search of one. The first `initialize` method it
    finds is in Thing, so a Room object’s `name` and `description` attributes are
    initialized there.
  prefs: []
  type: TYPE_NORMAL
- en: Class Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few other interesting things are going on in this program. Right at the top
    of the Thing class you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The two `@` characters at the start of this variable name, `@@num_things`, define
    this to be a *class variable*. The variables we’ve used inside classes up to now
    have been instance variables, preceded by a single `@`, like `@name`. Whereas
    each new object (or instance) of a class assigns its own values to its own instance
    variables, all objects derived from a specific class share the same class variables.
    I have assigned 0 to the `@@num_things` variable to ensure that it has a meaningful
    value at the outset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `@@num_things` class variable is used to keep a running total of
    the number of Thing objects in the game. It does this simply by incrementing the
    class variable (by adding 1 to it: `+= 1`) in its `initialize` method every time
    a new object is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you look later in the code, you will see that I have created a Map class
    to contain an array of rooms. This includes a version of the `to_s` method that
    prints information on each room in the array. Don’t worry about the implementation
    of the Map class right now; we’ll be looking at arrays and their methods in [Chapter 4](ch04.html
    "Chapter 4. Arrays and Hashes").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Scroll to the code at the bottom of the file, and run the program to see how
    I have created and initialized all the objects and used the class variable, `@@num_things`,
    to keep a tally of all the Thing objects that have been created.
  prefs: []
  type: TYPE_NORMAL
- en: Class Variables and Instance Variables
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860158.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram shows a Thing class (the rectangle) that contains a class variable,
    `@@num_things`, and an instance variable, `@name`. The three oval shapes represent
    “Thing objects”—that is, instances of the Thing class. When one of these objects
    assigns a value to its instance variable, `@name`, that value affects only the
    `@name` variable in the object itself. So here, each object has a different value
    for `@name`. But when an object assigns a value to the class variable, `@@num_things`,
    that value “lives inside” the Thing class and is shared by all instances of that
    class. Here `@@num_things` equals 3, and that is true for all the Thing objects.
  prefs: []
  type: TYPE_NORMAL
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: Every class you create will descend from one or more other classes. Here I explain
    the fundamentals of the Ruby class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Superclasses
  prefs: []
  type: TYPE_NORMAL
- en: To understand how the `super` keyword works, take a look at the sample program
    *super.rb*. This contains five related classes. The Thing class is the ancestor
    of all the others, and from Thing descends Thing2, from Thing2 descends Thing3,
    from Thing3 descends Thing4, and from Thing4 descends Thing5.
  prefs: []
  type: TYPE_NORMAL
- en: '*super.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the first three classes in this hierarchy: The
    Thing class has two instance variables, `@name` and `@description`. Thing2 also
    defines `@fulldescription` (a string that contains `@name` and `@description`);
    Thing3 adds yet another variable, `@value`.'
  prefs: []
  type: TYPE_NORMAL
- en: These three classes each contain an `initialize` method that sets the values
    of the variables when a new object is created; they also each have a method named,
    rather inventively, `aMethod`, which changes the value of one or more variables.
    The descendant classes, Thing2 and Thing3, both use the `super` keyword in their
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of this code unit I’ve written a “main” loop that executes when
    you run the program. Don’t worry about the syntax of this; you’ll be learning
    about loops in [Chapter 5](ch05.html "Chapter 5. Loops and Iterators"). I’ve added
    this loop so that you can easily run the different bits of code contained in the
    methods, `test1` to `test5`. You can run the program in a command window and enter
    a number, 1 to 5, when prompted, or Q to quit. When you run it for the first time,
    type **`1`** at the prompt and press the enter key. This will run the `test1`
    method containing these two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line here creates and initializes a Thing object, and the second
    line calls its `aMethod` method. Because the Thing class doesn’t descend from
    anything special, nothing very new or interesting happens here. In fact, as with
    all Ruby classes, Thing descends from the Object class, which is the ancestor
    of all other classes (with the sole exception of the BasicObject class in Ruby
    1.9, as explained later in this chapter). The output uses the `inspect` method
    to display the internal structure of the object when the `Thing.initialize` and
    `Thing.aMethod` methods are called. This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `inspect` method can be used with all objects and is an invaluable debugging
    aid. Here, it shows a hexadecimal number, which identifies this specific object
    followed by the string values of the `@name` and `@description` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now enter **`2`** at the prompt to run `test2`, which contains the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This creates a Thing2 object, t2, and calls `t2.aMethod`. Look carefully at
    the output. You will see that even though t2 is a Thing2 object, it is the Thing
    class’s `initialize` method that is called first. And only then is the Thing2
    class’s `initialize` called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand why this is so, look at the code of the Thing2 class’s `initialize`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `super` keyword to call the `initialize` method of Thing2’s ancestor,
    or *superclass*. The superclass of Thing2 is Thing, as you can see from its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ruby, when the `super` keyword is used on its own (that is, without any
    arguments), it passes all the arguments from the current method (here `Thing2.initialize`)
    to a method with the same name in its superclass (here `Thing.initialize`). Alternatively,
    you can explicitly specify a list of arguments following `super`. So, in this
    case, the following code would have the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it is permissible to use the `super` keyword all on its own, it is
    often preferable to explicitly specify the list of arguments to be passed to the
    superclass, for the sake of clarity. If you want to pass only a limited number
    of the arguments sent to the current method, an explicit argument list is necessary.
    Thing2’s `aMethod`, for example, passes only the `aName` argument to the `initialize`
    method of its superclass, Thing1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This explains why the `@description` variable is not changed when `Thing2.aMethod`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you look at Thing3, you will see that this adds one more variable, `@value`.
    In its implementation of `initialize`, it passes the two arguments, `aName` and
    `aDescription`, to its superclass, Thing2\. In its turn, as you’ve already seen,
    Thing2’s `initialize` method passes these same arguments to the `initialize` method
    of its superclass, Thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the program running, enter **`3`** at the prompt to view the output. The
    following code will execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note how the flow of execution goes right up the hierarchy so that code in the
    `initialize` and `aMethod` methods of Thing execute before code in the matching
    methods of Thing2 and Thing3.
  prefs: []
  type: TYPE_NORMAL
- en: It is not obligatory to override a superclass’s methods as I have done in the
    examples so far. This is required only when you want to add some new behavior.
    Thing4 omits the `initialize` method but implements the `aMethod` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter **`4`** at the prompt to execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run it, notice that the first available `initialize` method is called
    when a Thing4 object is created. This happens to be `Thing3.initialize`, which,
    once again, also calls the `initialize` methods of its ancestor classes, Thing2
    and Thing. However, the `aMethod` method implemented by Thing4 contains no call
    to its superclasses, so this executes right away, and the code in any other `aMethod`
    methods in the ancestor classes is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Thing5 inherits from Thing4 and doesn’t introduce any new data or
    methods. Enter **`5`** at the prompt to execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This time, you will see that the call to `new` causes Ruby to backtrack through
    the class hierarchy until it finds the first `initialize` method. This happens
    to belong to Thing3 (which also calls the `initialize` methods of Thing2 and Thing).
    The first implementation of `aMethod`, however, occurs in Thing4, and there are
    no calls to `super`, so that’s where the trail ends.
  prefs: []
  type: TYPE_NORMAL
- en: The Root of All Classes
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, all our Ruby classes will ultimately descend from the
    Object class. You may think of Object as the “root” or “base” class of the Ruby
    hierarchy. In Ruby 1.8 this is literally true—there are no classes from which
    Object itself descends. In Ruby 1.9, however, Object is derived from a new class
    called BasicObject. This new class was created to provide programmers with a very
    lightweight class—one that supplies only the bare minimum of methods for creating
    objects, testing equality, and manipulating special methods called *singletons*.
    (I’ll talk more about singletons in [Chapter 7](ch07.html "Chapter 7. Methods").)
  prefs: []
  type: TYPE_NORMAL
- en: The Ruby 1.9 Object class inherits the methods from BasicObject and adds a number
    of new methods of its own. BasicObject does not exist in Ruby 1.8, and the Object
    class supplies all the methods provided by the combination of BasicObject and
    Object in Ruby 1.9\. Since all normal Ruby classes—both Ruby 1.8 and Ruby 1.9—descend
    from Object, you may generally think of Object as being the “root” of all other
    classes. Just bear in mind that in Ruby 1.9, the ultimate ancestor of all classes
    is BasicObject.
  prefs: []
  type: TYPE_NORMAL
- en: The root class itself has no superclass, and any attempt to locate its superclass
    will return `nil`. You can see this for yourself by running *superclasses.rb*.
    This calls the `superclass` method to climb up the class hierarchy from the Three
    class to the Object or BasicObject class. At each turn through the loop, the variable
    `x` is assigned the class of `x`’s immediate parent until `x` equals `nil`. Here
    `class` and `superclass` are methods that return references to Ruby classes rather
    than to objects created from those classes. The `begin..until` block is one of
    Ruby’s looping constructs, which you’ll look at in more detail in [Chapter 5](ch05.html
    "Chapter 5. Loops and Iterators").
  prefs: []
  type: TYPE_NORMAL
- en: '*superclasses.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code displays the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Constants Inside Classes
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be times when you need to access constants (identifiers beginning
    with a capital letter, which are used to store nonchanging values) declared inside
    a class. Let’s assume you have this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*classconsts.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the constant `A`, you would need to use the special scope resolution
    operator `::` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Class names are constants, so this same operator gives you access to classes
    inside other classes. This makes it possible to create objects from “nested” classes
    such as class `Y` inside class `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Partial Classes
  prefs: []
  type: TYPE_NORMAL
- en: In Ruby it is not obligatory to define a class all in one place. If you want,
    you can define a single class in separate parts of your program. When a class
    descends from a specific superclass, each subsequent partial (or *open*) class
    definition may optionally repeat the superclass in its definition using the `<`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I create one class, A, and another that descends from it, B:'
  prefs: []
  type: TYPE_NORMAL
- en: '*partial_classes.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if I create a B object, all the methods of both A and B are available
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use partial class definitions to add features to Ruby’s standard
    classes such as Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds the `gribbit` method to the Array class so that the following code
    can now be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
