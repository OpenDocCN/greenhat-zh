- en: Part III-5. TCP/IP APPLICATION LAYER ADDRESSING AND APPLICATION CATEGORIES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM
    RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 71](ch71.html "Chapter 71. FILE AND MESSAGE TRANSFER OVERVIEW AND
    APPLICATION CATEGORIES")'
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP protocol suite is the foundation of modern internetworking, and for
    this reason, has been used as the primary platform for the development and implementation
    of networking applications. Over the past few decades, as the global TCP/IP Internet
    has grown, hundreds of new applications have been created. These programs support
    a myriad of different tasks and functions, ranging from implementing essential
    business tasks to providing pure entertainment. Users may be in the same room
    or on different continents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the many TCP/IP applications, a small number are widely considered to be
    key applications of TCP/IP. Most have been around for a very long time—in some
    cases, longer than even the modern Internet Protocol (IP) itself. Many of these
    protocols deal specifically with the sending of information that has been arranged
    into discrete units called *files* or *messages*. For this reason, one of the
    most important groups of TCP/IP applications is the one that describes the basic
    mechanisms for moving these files between internetworked devices: *file and message
    transfer applications*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this book deals with the most common definitive TCP/IP applications
    and application layer protocols. Before describing the applications themselves,
    however, I need to lay some groundwork related to application protocols as a whole.
    To that end, this part contains two chapters. In the first, I explain the universal
    system set up for TCP/IP applications to use for addressing Internet resources:
    Uniform Resource Identifiers (URIs), which include Uniform Resource Locators (URLs)
    and Uniform Resource Names (URNs). In the second chapter, I provide an overview
    of file and message transfer applications, including a description of the differences
    between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS,
    LOCATORS, AND NAMES (URIS, URLS, AND URNS)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Internet consists of millions of interconnected servers, each of which is
    capable of providing useful information to Internet users who request it. The
    more information a network has, the richer it is, but the more difficult it becomes
    to locate. In order to use information, we need to be able to find it, and that
    requires, at a minimum, that we employ some means for labeling each file or object.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, TCP/IP has defined a system of Uniform Resource Identifiers
    (URIs) that can be used both on the Internet and on private TCP/IP networks. Each
    URI uniquely specifies how a client can locate a particular resource and access
    it so it can be used. URIs are subdivided into Uniform Resource Locators (URLs)
    and Uniform Resource Names (URNs), which serve a similar purpose but work in different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe the system of addressing used on the Internet to
    identify files, objects, and resources. I begin with an overview, which introduces
    the concept of URIs and explains the differences between URIs, URLs, and URNs.
    I then provide a detailed explanation of URLs and how they are used. This includes
    an overview of the general syntax used for URLs, a description of the URL schemes
    used for the most common applications, a discussion of relative URLs and how they
    work, and a comprehensive look at real-world issues associated with URLs, including
    the intentional obfuscation games being played by some unscrupulous people. Finally,
    I discuss URNs, including how they solve a major problem with URLs and the impediments
    to their use.
  prefs: []
  type: TYPE_NORMAL
- en: URI Overview and Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve been working your way up the OSI Reference Model layers in reading
    this book, you might have expected that you would be done with addressing by this
    point. After all, we have already discussed MAC addresses at layer 2, IP addresses
    at layer 3, and mechanisms for converting between them (see Chapters [Chapter 13](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")
    and [Chapter 14](ch14.html "Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP
    REVERSE ADDRESS RESOLUTION PROTOCOL (RARP)")). We even have ports and sockets
    that provide transport layer addressing capabilities to let each device run multiple
    software applications (see [Chapter 43](ch43.html "Chapter 43. TCP AND UDP ADDRESSING:
    PORTS AND SOCKETS")). Given all this, the idea of application layer addressing
    may seem a bit strange, and I am aware that using the term to refer to the subject
    of this chapter may be a bit unorthodox.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept isn't really as odd as it might seem at first, however. It's true
    that with an IP address and a port number, we can theoretically access any resource
    on a TCP/IP internetwork; the problem is finding it.
  prefs: []
  type: TYPE_NORMAL
- en: Application layer addressing is not something that is required by the computer
    software. It is something that makes it easier for humans to identify and locate
    resources. This is very much the same rationale that is used to justify the creation
    of name systems, such as the Domain Name System (DNS; see [Part III-1](pt12.html
    "Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION")).
    DNS is a form of high-level addressing that allows names to be used instead of
    IP addresses. It is helpful to people, who find it easier to understand www.intel.com
    than 198.175.96.33.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind a comprehensive application layer addressing scheme is to extend
    to the next level what DNS has already accomplished. DNS names provide essential
    high-level abstract addressing, but only of whole devices (whether real or virtual).
    These names can be used as the basis for a more complete labeling scheme that
    points not just to a site or device, but to a specific file, object, or other
    resource. In TCP/IP, these labels are called Uniform Resource Identifiers (URIs).
  prefs: []
  type: TYPE_NORMAL
- en: URIs were one of the key technologies developed as part of the World Wide Web
    (WWW), and they are still most often associated with the Web and the protocol
    that implements it, the Hypertext Transfer Protocol (HTTP; see [Part III-8](pt19.html
    "Part III-8. TCP/IP WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)")).
    You have likely used URIs thousands of times in the past; whenever you enter something
    like `http://www.myfavoritewebsite.com` into a web browser, you are using a URI.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why URIs are so important to the Web is that they combine into one
    string all of the information necessary to refer to a resource. This compactness
    of expression is essential to the entire concept of hypertext resource linking.
    If we want to be able to have an object in one document point to another, we need
    to have a simple way of describing that object without requiring a whole set of
    instructions. URIs allow us to do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, URIs are so associated with the Web that they are usually described
    as being part of Web technology specifically. They are not, however, unique to
    the Web, which is why this chapter is separate from the discussion of WWW and
    HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'URI Categories: URLs and URNs'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'URIs are a general-purpose method for referring to many kinds of TCP/IP resources.
    They are currently divided into two primary categories based on how they describe
    a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform Resource Locators (URLs)** A URL is a URI that refers to a resource
    through the combination of a protocol or access mechanism and a specific resource
    location. A URL begins with the name of the protocol to be used for accessing
    the resource, and then contains sufficient information to point to how it can
    be obtained.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform Resource Names (URNs)** A URN is a URI that provides a way of uniquely
    naming a resource without specifying an access protocol or mechanism, and without
    specifying a particular location.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a URL and a URN is that the former is much more specific
    and oriented around how to access a resource, while the latter is more abstract
    and designed more to identify what the resource is than describe how to get it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Giving someone a URL is like giving them directions to find a book, as follows:
    "Take the train to Albuquerque, then Bus #11 to 41 Albert Street, a red brick
    house owned by Joanne Johnson. The book you want is the third from the right on
    the bottom of the bookshelf on the second floor."'
  prefs: []
  type: TYPE_NORMAL
- en: A URN is more like referring to a book using its International Standard Book
    Number (ISBN); it uniquely identifies the book, regardless of where the book may
    be located, and doesn't tell you how to access it. (In fact, ISBNs are one of
    the identification systems used with URNs, as you will see in the section about
    URNs at the end of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: While URLs and URNs are theoretical peers, in practice, URLs are used far more
    often than URNs. In fact, URLs are so dominant that most people have never even
    heard of URIs or URNs. The reason is that even though the example of how to find
    a book suggests that URNs are more natural than URLs, URLs are easier to use in
    practice. URLs provide the information needed to access a resource, and without
    being able to access a resource, simply knowing how to identify it is of limited
    value.
  prefs: []
  type: TYPE_NORMAL
- en: URNs are an attractive concept because they identify a resource without tying
    it to a specific access mechanism or location. However, the implementation of
    URNs requires some means of tying the permanent identifier of a resource to where
    it is at any given moment, which is not a simple task. For this reason, URNs and
    the methods for using them have been in development for a number of years, while
    URLs have been in active use all that time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Some sort of mechanism is needed on any internetwork to allow
    resources such as files, directories, and programs to be identified and accessed.
    In TCP/IP, Uniform Resource Identifiers (URIs) are used for this sort of "application
    layer addressing." The two types of URIs are Uniform Resource Locators (URLs),
    which specify how to access an object using a combination of an access method
    and location, and Uniform Resource Names (URNs), which identify an object by name
    but do not indicate how to access it.'
  prefs: []
  type: TYPE_NORMAL
- en: While URLs began with the Web and most URLs are still used with HTTP, they can
    and do refer to resources that are accessed using many other protocols, such as
    the File Transfer Protocol (FTP) and Telnet. The compactness of URIs makes them
    very powerful for such uses. With a URL, we can use one string to tell a program
    to retrieve a file using FTP. This replaces the complete FTP process of starting
    an FTP client, establishing a session, logging in, and issuing commands.
  prefs: []
  type: TYPE_NORMAL
- en: URI Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of Internet standards published in the 1990s describe the syntax and
    basic use of URIs, URLs, and URNs. The first was RFC 1630, "Universal Resource
    Identifiers in WWW," which was published in 1994 and is still a good overview
    of the topic. In December 1994, a pair of documents, RFCs 1737 and 1738, provided
    more specific information about URNs and URLs, respectively. RFC 1808 describes
    how to define and use relative URLs. RFC 2141 provides more information about
    the URN syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 2396, "Uniform Resource Identifiers (URI): Generic Syntax," was published
    in August 1998 to revise and replace some of the information in many of the previous
    RFCs just mentioned. It is probably the definitive standard on URIs at the present
    time, although RFCs continue to be published discussing issues related to URIs.
    This is especially true of URNs, which as I noted earlier, are still in active
    development.'
  prefs: []
  type: TYPE_NORMAL
- en: The base documents such as RFC 2396 describe how URLs can be specified for a
    number of common protocols (called *schemes* in URL-speak, as we will see when
    we look at URLs more closely). To provide flexibility, a mechanism was also defined
    to allow new URL schemes to be registered. This is described in RFC 2717, "Registration
    Procedures for URL Scheme Names," and RFC 2718, "Guidelines for new URL Schemes."
    There are also a few RFCs that describe specific URL schemes for different protocols,
    including RFCs 2192 (IMAP), 2224 (NFS), 2368 (email), and 2384 (POP).
  prefs: []
  type: TYPE_NORMAL
- en: URL General Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URLs are text strings that allow a resource such as a file or other object to
    be labeled based on its location on an internetwork and the primary method or
    protocol by which it may be accessed. URLs have become the most common type of
    URI used for application layer addressing in TCP/IP because of their simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'URLs consist of two components that identify how to access a resource on a
    TCP/IP internetwork: the location of the resource and the method to be used to
    access it. These two pieces of information, taken together, allow a user with
    the appropriate software to obtain, read, or otherwise work with many different
    kinds of resources, such as files, objects, programs, and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most general form of syntax for a URL contains only two elements, which
    correspond to the two pieces of information just described: `<scheme>:<scheme-specific-part>`.
    The term *scheme* refers to a type of access method, which describes the way that
    the resource is to be used. It usually refers to either an application protocol,
    such as `http` or `ftp`, or a resource type, such as `file`. A scheme name must
    contain only letters, plus signs (+), periods (.), and hyphens (-). In practice,
    scheme names usually contain only letters. Schemes are case-insensitive but usually
    expressed in lowercase.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the URL after the scheme (and the required colon separator) is scheme-specific.
    This is necessary because various protocols and access methods require different
    types and quantities of information to identify a particular resource. When a
    URL is read, the scheme name tells the program parsing it how to interpret the
    syntax of the rest of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Common Internet Scheme Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In theory, each scheme may use a completely different syntax for the `<scheme-specific-part>`
    of a URL. However, many of these schemes share a common syntax for this part,
    by virtue of the similarities in how they refer to internetwork devices and resources
    on those devices. For example, both HTTP and FTP are used to point to specific
    TCP/IP devices using a DNS name or IP address, and then access resources stored
    in a hierarchical directory structure. It makes sense that their URLs would be
    at least somewhat similar.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** URLs are the most widely used type of URI. In its most basic
    form, a URL consists of two elements: a scheme that defines the protocol or other
    mechanism for accessing the resource, and a scheme-specific part that contains
    information that identifies the specific resource and indicates how it should
    be used. Some schemes use a common syntax for their scheme-specific parts; others
    use a syntax unique to the scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most general form of this common Internet scheme syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<scheme>`** The URL scheme, which refers to a type of access method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<user>`** **and** **`<password>`** Authentication information for schemes
    requiring a login, in the form of a user name and password.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<host>`** An Internet host, usually specified either as a fully qualified
    DNS domain name or an IP address in dotted decimal notation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<port>`** A Transmission Control Protocol (TCP) or User Datagram Protocol
    (UDP) port number to use when invoking the protocol appropriate to the scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<url-path>`** A resource location path. This is usually a full directory
    path expressing the sequence of directories to be traversed from the root directory
    to the place where the resource is located, and then the resource''s name. For
    example, if on a device there is a directory called project1 and within it a subdirectory
    called memos containing a text file called June11th-minutes.txt, the URL path
    `project1/memos/June11th-minutes.txt` would refer to that resource. Note that
    the slash before the `<url-path>` is required, and while it is technically not
    considered part of the path, it serves the purpose of acting like the slash denoting
    the root directory in many file systems. Also, the `<url-path>` may end in a slash,
    which means that the path refers specifically to a directory. However, this is
    often not required, as the server will treat the URL as a directory reference
    by context when needed. A path may also refer to a virtual file, program, or another
    type of resource.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<params>`** Scheme-specific parameters included to control how the scheme
    is used to access the resource. Each parameter is generally of the form `<parameter>=<value>`,
    with each parameter specification separated from the next using a semicolon.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<query>`** An optional query or other information to be passed to the server
    when the resource is accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<fragment>`** Identifies a particular place within a resource that the user
    of the URL is interested in.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 70-1](ch70s02.html#example_of_a_uniform_resource_locator_ur "Figure 70-1. Example
    of a Uniform Resource Locator (URL) This diagram shows a sample URL that includes
    almost all of the possible elements in the general scheme syntax, each of them
    highlighted using shaded boxes. This URL identifies a Web (HTTP) resource that
    must be accessed using a particular password at the site www.mysite.org using
    port 8080\. The resource in this case is a PHP program in the site''s cgi-bin
    directory that causes a particular page of photographs to be displayed. The <fragment>
    specifier will cause the picture Reception07 on the retrieved page of wedding
    photos to be displayed to the user.") illustrates this common syntax and its elements
    using an example of an HTTP URL.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a Uniform Resource Locator (URL) This diagram shows a sample URL
    that includes almost all of the possible elements in the general scheme syntax,
    each of them highlighted using shaded boxes. This URL identifies a Web (HTTP)
    resource that must be accessed using a particular password at the site www.mysite.org
    using port 8080\. The resource in this case is a PHP program in the site''s cgi-bin
    directory that causes a particular page of photographs to be displayed. The <fragment>
    specifier will cause the picture Reception07 on the retrieved page of wedding
    photos to be displayed to the user.](httpatomoreillycomsourcenostarchimages288259.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 70-1. Example of a Uniform Resource Locator (URL) This diagram shows
    a sample URL that includes almost all of the possible elements in the general
    scheme syntax, each of them highlighted using shaded boxes. This URL identifies
    a Web (HTTP) resource that must be accessed using a particular password at the
    site www.mysite.org using port 8080\. The resource in this case is a PHP program
    in the site's cgi-bin directory that causes a particular page of photographs to
    be displayed. The `<fragment>` specifier will cause the picture Reception07 on
    the retrieved page of wedding photos to be displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Omission of URL Syntax Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The full URL syntax may seem very complicated, but bear in mind that this is
    a formal definition and shows all of the possible elements in a URL at once. Most
    schemes do not use every one of these elements, and furthermore, many of them
    are optional, even when they are valid in a particular scheme. For example, the
    `<login>` and `<password>` elements are officially supported for HTTP URLs, but
    they are very rarely used. Similarly, port numbers are often omitted, telling
    the client software to just use the default port number for the scheme. The "URL
    Schemes and Scheme-Specific Syntaxes" section of this chapter describes some of
    the most common URL schemes and the specific syntaxes used for them, including
    how and when these elements are employed.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the richness of the URL syntax isn't often needed, it can be useful
    for supplying a wide variety of information in special cases. URLs are also very
    flexible in terms of how they may be expressed. For example, while a `<host>`
    element is usually a DNS name, it can also be an IP address expressed in many
    forms, including dotted decimal, regular decimal, hexadecimal, octal, and even
    a combination of these. Unfortunately, the lack of familiarity that most people
    have with some of these refinements has led to URLs being abused through deliberate
    obscuration, to get people to visit "resources" they would normally want to avoid.
    We'll explore this later in this chapter, in the "URL Obscuration, Obfuscation,
    and General Trickery" section.
  prefs: []
  type: TYPE_NORMAL
- en: URL Fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's worth noting that, technically, a `<fragment>` element is not considered
    a formal part of the URL by the standards that describe resource naming. The reason
    is that it identifies only a portion of a resource, and it is not part of the
    information required to identify the resource itself. It is not sent to the server
    but retained by the client software, to guide it in how to display or use the
    resource. Some would make a valid argument, however, that this distinction is
    somewhat arbitrary. Consider, for example, that the scheme itself is also used
    only by the client, as is the host itself.
  prefs: []
  type: TYPE_NORMAL
- en: The most common example of a URL fragment is specifying a particular bookmark
    to scroll to in displaying a web page. In practice, a fragment identifier is often
    treated as if it were part of a URL, since it is part of the string that specifies
    a URL.
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe Characters and Special Encodings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: URLs are normally expressed in the standard US ASCII character set, which is
    the default used by most TCP/IP application protocols. Certain characters in the
    set are called unsafe, because they have special meaning in different contexts,
    and including them in a URL would lead to ambiguity or problems in of how they
    should be interpreted. The space character is the classic unsafe character, because
    spaces are normally used to separate URLs, so including one in a URL would break
    the URL into pieces. Other characters are unsafe because they have special significance
    in a URL, such as the colon (:).
  prefs: []
  type: TYPE_NORMAL
- en: 'The safe characters in a URL are alphanumerics (*A* to *Z*, *a* to *z*, and
    0 to 9) and the following special characters: the dollar sign ($), hyphen (-),
    underscore (_), period (.), plus sign (+), exclamation point (!), asterisk (*),
    apostrophe (''), left parenthesis ((), and right parenthesis ()). All other unsafe
    characters can be represented in a URL using an encoding scheme consisting of
    a percent sign (%) followed by the hexadecimal ASCII value of the character. The
    most common examples are given in [Table 70-1](ch70s02.html#url_special_character_encodings
    "Table 70-1. URL Special Character Encodings").'
  prefs: []
  type: TYPE_NORMAL
- en: Table 70-1. URL Special Character Encodings
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Encoding | Character | Encoding | Character | Encoding |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **<space>** | %20 | < | %3C | > | %3E |'
  prefs: []
  type: TYPE_TB
- en: '| **#** | %23 | % | %25 | { | %7B |'
  prefs: []
  type: TYPE_TB
- en: '| **}** | %7D | &#124; | %7C | \ | %5C |'
  prefs: []
  type: TYPE_TB
- en: '| **^** | %5E | ~ | %7E | [ | %5B |'
  prefs: []
  type: TYPE_TB
- en: '| **]** | %5D |  | `%60 | ; | %3B |'
  prefs: []
  type: TYPE_TB
- en: '| **/** | %2F | ? | %3F | : | %3A |'
  prefs: []
  type: TYPE_TB
- en: '| **@** | %40 | = | %3D | % | %26 |'
  prefs: []
  type: TYPE_TB
- en: When these sequences are encountered, they are interpreted as the literal character
    they represent, without any significance. So, the URL `http://www.myfavesite.com/are%20you%20there%3F`
    points to a file called "are you there?" on [www.myfavesite.com](http://www.myfavesite.com).
    The `%20` codes prevent the spaces from breaking up the URL, and the `3F` prevents
    the question mark in the filename from being interpreted as a special URL character.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Since the percent sign is used for this encoding mechanism, it itself is special.
    When it is encountered, the next values are interpreted as character encodings.
    So, to embed a literal percent sign, it must be encoded as `%25`*.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, these encodings are sometimes abused for nefarious purposes, unfortunately,
    such as using them for regular ASCII characters to obscure URLs.
  prefs: []
  type: TYPE_NORMAL
- en: URL Schemes and Scheme-Specific Syntaxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As explained in the previous sections, URLs use a general syntax that describes
    the location and method for accessing a TCP/IP resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each access method, called a *scheme*, has its own specific URL syntax, including
    the various pieces of information required by the method to identify a resource.
    RFC 1738 includes a description of the specific syntaxes used by several popular
    URL schemes. Others have been defined in subsequent RFCs using the procedure established
    for URL scheme registration.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the URL schemes use the common Internet pattern shown in [Figure 70-1](ch70s02.html#example_of_a_uniform_resource_locator_ur
    "Figure 70-1. Example of a Uniform Resource Locator (URL) This diagram shows a
    sample URL that includes almost all of the possible elements in the general scheme
    syntax, each of them highlighted using shaded boxes. This URL identifies a Web
    (HTTP) resource that must be accessed using a particular password at the site
    www.mysite.org using port 8080\. The resource in this case is a PHP program in
    the site's cgi-bin directory that causes a particular page of photographs to be
    displayed. The <fragment> specifier will cause the picture Reception07 on the
    retrieved page of wedding photos to be displayed to the user.") earlier in the
    chapter. Other schemes use entirely different (usually simpler) structures based
    on their needs.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe the most common URL schemes and the scheme-specific
    syntaxes they use.
  prefs: []
  type: TYPE_NORMAL
- en: World Wide Web/Hypertext Transfer Protocol Syntax (http)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Web potentially uses most of the elements of the common Internet scheme
    syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in the overview of resource identifiers, the Web is the primary
    application using URLs today. A URL can theoretically contain most of the common
    URL syntax elements, but in practice, most are omitted. Most URLs contain only
    a host and a path to a resource. The port number is usually omitted, implying
    that the default value of 80 should be used. The `<query>` construct is often
    used to pass arguments or information from the client to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: I have provided full details on how Web URLs are used in [Chapter 79](ch79.html
    "Chapter 79. WORLD WIDE WEB AND HYPERTEXT OVERVIEW AND CONCEPTS").
  prefs: []
  type: TYPE_NORMAL
- en: File Transfer Protocol Syntax (ftp)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for FTP URLs is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: FTP (see [Chapter 72](ch72.html "Chapter 72. FILE TRANSFER PROTOCOL (FTP)"))
    is an interactive command-based protocol, so it may seem odd to use a URL for
    FTP. However, one of the most common uses of FTP is to access and read a single
    file, and this is what an FTP URL allows a client to do, quickly and easily. The
    `<user>` and `<password>` elements are used for login and may be omitted for anonymous
    FTP access. The port number is usually omitted and defaults to the standard FTP
    control channel port, 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<url-path>` is interpreted as a directory structure and filename. The
    appropriate CWD (change working directory) commands are issued to go to the specified
    directory, and then a RETR (retrieve) command is issued for the named file. The
    optional `type` parameter can be used to indicate the file type: `a` to specify
    an ASCII file retrieval or `i` for an image (binary) file. The `type` parameter
    is often omitted from the URL, with the correct mode being set automatically by
    the client based on the name of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to starting an FTP client, making an anonymous FTP connection
    to [ftp.hardwarecompanyx.com](http://ftp.hardwarecompanyx.com), then changing
    to the drivers directory and retrieving the file widgetdriver.zip. The client
    will retrieve the file in binary mode because it is a compressed ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use an FTP URL to get a listing of the files within a
    particular directory. This allows users to navigate an FTP server's directory
    structure using URL links to find the file they want, and then retrieve it. This
    is done by specifying a directory name for the `<url-path>` and using the `type`
    parameter with a `<typecode>` of `d` to request a directory listing. Again, the
    `type` parameter is usually omitted, and the software figures out to send a LIST
    command to the server when a directory name is given in a URL.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic Mail Syntax (mailto)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A special syntax is defined to allow a URL to represent the command to send
    mail to a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The email address (see [Chapter 75](ch75.html "Chapter 75. TCP/IP ELECTRONIC
    MAIL ADDRESSES AND ADDRESSING")) is in standard Internet form: *<username>@<domainname>*.
    This is really an unusual type of URL because it does not really represent an
    object at all, though a person can be considered a type of resource. Note that
    optional parameters, such as the subject of the email, can also be included in
    a `mailto` URL. This facility is not often used, however.'
  prefs: []
  type: TYPE_NORMAL
- en: Gopher Protocol Syntax (gopher)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for the Gopher protocol is similar to that of HTTP and FTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See [Chapter 86](ch86.html "Chapter 86. GOPHER PROTOCOL (GOPHER)") for more
    information about the Gopher protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Network News/Usenet Syntax (news)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two syntaxes are defined for Usenet newsgroup access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both of these URLs are used to access a Usenet newsgroup (see [Chapter 85](ch85.html
    "Chapter 85. USENET (NETWORK NEWS) AND THE TCP/IP NETWORK NEWS TRANSFER PROTOCOL
    (NNTP)")) or a specific message, referenced by message ID. Like the `mailto` scheme,
    this is a special type of URL because it defines an access method but does not
    provide the detailed information to describe how to locate a newsgroup or message.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, the first form of this URL is interpreted as being local. So,
    for example, `news://alt.food.sushi` means, "Access the newsgroup alt.food.sushi
    on the local news server, using the default news protocol." The default news protocol
    is normally the Network News Transfer Protocol (NNTP). The second URL form is
    global, because message IDs are unique on Usenet (or at least, they are supposed
    to be!).
  prefs: []
  type: TYPE_NORMAL
- en: Network News Transfer Protocol Syntax (nttp)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nntp` form is a different URL type for news access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `news`, this URL form specifically requests the use of NNTP (see [Chapter 85](ch85.html
    "Chapter 85. USENET (NETWORK NEWS) AND THE TCP/IP NETWORK NEWS TRANSFER PROTOCOL
    (NNTP)")) and identifies a particular NNTP server. Then it tells the server which
    newsgroup to access and which article number within that newsgroup. Note that
    articles are numbered using a different sequence by each server, so this is still
    a local form of news addressing. The port number defaults to 119.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the `nntp` form seems to provide a more complete resource specification,
    the `news` URL is more often used, because it is simpler. It's easier just to
    set up the appropriate NNTP server in the client software once than to specify
    it each time, since clients usually use only one NNTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet Syntax (telnet)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This syntax is used to open a Telnet connection to a server (see [Chapter 87](ch87.html
    "Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In practice, the user name and password are often omitted, which causes the
    Telnet server to prompt for this information. Alternatively, the `<user>` can
    be supplied and the password left out (to prevent it being seen), and the server
    will prompt for just the password. The port number defaults to the standard port
    for Telnet, 23, and is also often omitted.
  prefs: []
  type: TYPE_NORMAL
- en: This type of URL is interesting in that it identifies a resource that is not
    an object but rather a service.
  prefs: []
  type: TYPE_NORMAL
- en: Local File Syntax (file)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A special URL type is used for referring to files on a particular host computer.
    The standard syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This type of URL is also somewhat interesting, in that it describes the location
    of an object but not an access method. It is not sufficiently general to allow
    access to a file anywhere on an internetwork, but is often used for referencing
    files on computers on a local area network (LAN) where names have been assigned
    to different devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special syntax is also defined to refer specifically to files on the local
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the entire `//<host>:` element has been replaced by a set of three slashes,
    meaning to look on the local host.
  prefs: []
  type: TYPE_NORMAL
- en: Special Syntax Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Additional syntax rules are often used by browsers to support the quirks of
    Microsoft operating systems, especially for the file scheme. First, the backslashes
    used by Microsoft Windows are expressed as forward slashes as required by TCP/IP.
    Second, since colons are used in drive letters specifications in Microsoft operating
    systems, these are replaced by the vertical pipe character (|).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to refer to the file C:\WINDOWS\SYSTEM32\DRIVERS\ETC\HOSTS, the following
    URL could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that some browsers actually do allow the colon in the drive specification.
  prefs: []
  type: TYPE_NORMAL
- en: URL Relative Syntax and Base URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The URL syntax described so far is sometimes said to specify an *absolute URL*.
    This is because the information in the URL is sufficient to completely identify
    the resource. Absolute URLs thus have the property of being context-independent,
    meaning that users can access and retrieve the resource using the URL without
    any additional information required.
  prefs: []
  type: TYPE_NORMAL
- en: Since the entire point of a URL is to provide the information needed to locate
    and access a resource, it makes sense that we would want them to be absolute in
    definition most of the time. The problem with absolute URLs is that they can be
    long and cumbersome. There are cases where many different resources need to be
    identified that have a relationship to each other; the URLs for these resources
    often have many common elements. Using absolute URLs in such situations leads
    to a lot of excess and redundant verbiage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the overview of URIs at the beginning of this chapter, I gave a real-world
    analogy to a URL in the form of a description of an access method and location
    for a person retrieving a book: "Take the train to Albuquerque, then Bus #11 to
    41 Albert Street, a red brick house owned by Joanne Johnson. The book you want
    is the third from the right on the bottom of the bookshelf on the second floor."'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if I also wanted the same person to get a second book located in the same
    house on the ground floor after getting the first one? Should I start by saying
    again, "Take the train to Albuquerque, then Bus #11 to 41 Albert Street, a red
    brick house owned by Joanne Johnson?" Why bother, when they are already there
    at that house? No, I would give a second instruction in relative terms: "Go downstairs,
    and also get the blue book on the wood table." This instruction only makes sense
    in the context of the original one.'
  prefs: []
  type: TYPE_NORMAL
- en: The same need arises in URLs. Consider a web page located at `http://www.longdomainnamesareirritating.com/index.htm`
    that has 37 embedded graphic images in it. The poor guy stuck with maintaining
    this site doesn't want to have to put `http://www.longdomainnamesareirritating.com/`
    in front of the URL of every image.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if we have just taken a directory listing at `ftp://ftp.somesitesomewhere.org/very/deep/directory/structures/also/stink/`,
    and we want to explore the parent directory, we would like to just say "go up
    one level," without having to say `ftp://ftp.somesitesomewhere.org/very/deep/directory/structures/also/`.
  prefs: []
  type: TYPE_NORMAL
- en: It is for these reasons that URL syntax was extended to include a relative form.
    In simplest terms, a relative URL is the same as an absolute URL, but with pieces
    of information omitted that are implied by context. Like our "Go downstairs" instruction,
    a relative URL does not by itself contain enough information to specify a resource.
    A relative URL must be interpreted within a context that provides the missing
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation Rules for Relative URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The context needed to find a resource from a relative URL is provided in the
    form of a base URL that provides the missing information. A base URL must be either
    a specific absolute URL or itself a relative URL that refers to some other absolute
    base. The base URL may be either explicitly stated or may be inferred from use.
    The RFCs dealing with URLs define the following three methods for determining
    the base URL, in the precedence in which they are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base URL Within Document** Some documents allow the base URL to be explicitly
    stated. If present, this specification is used for any relative URLs in the document.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base URL from Encapsulating Entity** In cases where no explicit base URL
    is specified in a document, but the document is part of a higher-level entity
    enclosing it, the base URL is the URL of the parent document. For example, a document
    within a body part of a MIME multipart message (see [Chapter 76](ch76.html "Chapter 76. TCP/IP
    ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME")) can
    use the URL of the message as a whole as the base URL for relative references.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base URL from Retrieval URL** If neither of those two methods are feasible,
    the base URL is inferred from the URL used to retrieve the document containing
    the relative URL.'
  prefs: []
  type: TYPE_NORMAL
- en: Of these three methods, the first and third are the most common. HTML, the language
    used for the Web, allows a base URL to be explicitly stated, which removes any
    doubt about how relative URLs are to be interpreted. Failing this, the third method
    is commonly used for images and other links in HTML documents that are specified
    in relative terms.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Regular URLs are absolute, meaning that they include all of
    the information needed to fully specify how to access a resource. In situations
    where many resources need to be accessed that are approximately in the same place
    or are related in some way, completely specifying a URL can be inefficient. Instead,
    relative URLs can be used, which specify how to access a resource relative to
    the location of another one. A relative URL can be interpreted only within the
    context of a base URL that provides any information missing from the relative
    reference.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's go back to the poor slob maintaining `http://www.longdomainnamesareirritating.com/index.htm`.
    By default, any images referenced from that index.htm HTML document can use relative
    URLs—the base URL will be assumed from the name of the document itself. So he
    can just say `companylogo.gif` instead of `http://www.longdomainnamesareirritating.com/companylogo.gif`,
    as long as that file is in the same directory on the same server as index.htm.
  prefs: []
  type: TYPE_NORMAL
- en: If all three of these methods fail for whatever reason, then no base URL can
    be determined. Relative URLs in such a document will be interpreted as absolute
    URLs, and since they do not contain complete information, they will not work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Practical Interpretation of Relative URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This probably seems confusing, but relative URLs are actually fairly easy to
    understand, because they are interpreted in a rather common-sense way. You simply
    take the base URL and the relative URL, and you substitute whatever information
    is in the relative URL for the appropriate information in the base URL to get
    the resulting equivalent absolute reference. In so doing, you must drop any elements
    that are more specific than the ones being replaced.
  prefs: []
  type: TYPE_NORMAL
- en: What do I mean by "more specific?" Well, most URLs can be considered to move
    from most general to most specific in terms of the location they specify. As you
    go from left to right, you go through the host name, then high-level directories,
    subdirectories, the filename, and optionally, the parameters, query, and fragment
    applied to the filename. If a relative URL specifies a new file name, it replaces
    the file name in the base URL, and any parameters, query, and fragment elements
    are dropped, as they no longer have meaning given that the file name has changed.
    If the relative URL changes the host name, the entire directory structure, filename,
    and everything else to the right of the host name goes away, replaced with any
    that might have been included in the new host name specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is hard to explain in words but easy to understand with a few examples.
    Let''s assume we start with the following explicit base URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 70-2](ch70s04.html#relative_url_specifications_and_absolute "Table 70-2. Relative
    URL Specifications and Absolute Equivalents") shows some examples of relative
    URLs and how they would be interpreted.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 70-2. Relative URL Specifications and Absolute Equivalents
  prefs: []
  type: TYPE_NORMAL
- en: '| Relative URL | Equivalent Absolute URL | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| #bookmark2 | http://site.net/dir1/subdir1/file1?query1#bookmark2 | The URL
    is the same as the base URL, except that the bookmark is different. This can be
    used to reference different places in the same document in HTML. Technically,
    the URL has not changed here, since the fragment (bookmark) is not part of the
    actual URL. A web browser given a new bookmark name will usually not try to reaccess
    the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| ?query2 | http://site.net/dir1/subdir1/file1?query2 | The same file as given
    by the base URL, but with a different query string. Note that the bookmark reference
    from the base URL is stripped off. |'
  prefs: []
  type: TYPE_TB
- en: '| file2 | http://site.net/dir1/subdir1/file2 | This refers to a file using
    the name file2, which replaces file1 in the base URL. Here, both the query and
    bookmark are removed. |'
  prefs: []
  type: TYPE_TB
- en: '| /file2 | http://site.net/file2 | Since a single slash was included, this
    means file2 is in the root directory. This relative URL replaces the entire `<url-path>`
    of the base URL. |'
  prefs: []
  type: TYPE_TB
- en: '| .. | http://site.net/dir1/ | The pair of dots refers to the parent directory
    of the one in the base URL. Since the directory in the base URL is dir1/subdir1\.
    This refers to dir1/. |'
  prefs: []
  type: TYPE_TB
- en: '| ../file2 | http://site.net/dir1/file2 | This specifies that we should go
    up to the parent directory to find the file file2 in dir1. |'
  prefs: []
  type: TYPE_TB
- en: '| ../subdir2/file2 | http://site.net/dir1/subdir2/file2 | This says go up one
    directory with .., then enter the subdirectory subdir2 to find file2. |'
  prefs: []
  type: TYPE_TB
- en: '| ../../dir2/subdir2/file2 | http://site.net/dir2/subdir2/file2 | This is the
    same as the previous example, but going up two directory levels, then down through
    dir2 and subdir2 to find file2. |'
  prefs: []
  type: TYPE_TB
- en: '| //file2 | http://file2 | Two slashes means that file2 replaces the host name,
    causing everything to the right of the host name to be stripped. This is probably
    not what was intended, and it shows how important it is to watch those slashes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| //www.newsite.net/otherfile.htm | http://www.newsite.net/otherfile.htm |
    In this example, everything but the scheme has been replaced. In practice, this
    form of relative URL is not that common—the scheme is usually included if the
    site name is specified, for completeness. |'
  prefs: []
  type: TYPE_TB
- en: '| file2?query2#bookmark2 | http://site.net/dir1/subdir1/file2?query2#bookmark2
    | This replaces the filename, query name, and bookmark name. |'
  prefs: []
  type: TYPE_TB
- en: '| ftp://differentsite.net/whatever | ftp://differentsite.net/whatever | Using
    a new scheme forces the URL to be interpreted as absolute. |'
  prefs: []
  type: TYPE_TB
- en: Relative URLs have meaning only for certain URL schemes. For others, they make
    no sense and cannot be used. In particular, relative URLs are never used for the
    `telnet`, `mailto`, and `news` schemes. They are very commonly used for HTTP documents,
    and may also be used for FTP and file URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Incidentally, there is one other very important benefit of using relative URLs:
    Avoiding absolute URLs in a document allows it to be more portable by eliminating
    hard-coded references to names that might change. Going back to our previous example,
    if the guy maintaining the site `http://www.longdomainnamesareirritating.com`
    uses only relative links to refer to graphics and other embedded objects, then
    if the site is migrated to [www.muchshortername.com](http://www.muchshortername.com),
    he will not need to edit all of his links to the new name. The significance of
    this in Web URLs is explored further in the detailed discussion of HTTP URLs in
    [Chapter 79](ch79.html "Chapter 79. WORLD WIDE WEB AND HYPERTEXT OVERVIEW AND
    CONCEPTS").'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In addition to being more efficient than absolute URLs, relative
    URLs have the advantage that they allow a resource designer to avoid the specific
    mention of names. This increases the portability of documents between locations
    within a site or between sites.'
  prefs: []
  type: TYPE_NORMAL
- en: URL Length and Complexity Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'URLs are the most ubiquitous form of resource addressing for some very good
    reasons: They represent a simple, convenient, and easy-to-understand way of finding
    documents. Popularized by their use on the Web, URLs can now be seen in everything
    from electronic document lists to television commercials—a testament to their
    universality and ease of use.'
  prefs: []
  type: TYPE_NORMAL
- en: At least, this is true most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: When URLs work, they work very well. Unfortunately, there are also some concerns
    that arise with respect to how URLs are used. Both accidental and intentional
    misuse of URLs occurs on a regular basis. Part of why I have devoted so much effort
    to describing URLs is that most people don't really understand how they work,
    and this is part of why problems occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the issues with URLs are directly due to the related matters of length
    and complexity. URLs work best when they are short and simple, so it is clear
    what they are about and so they are easy to manipulate. For example, `http://www.ibm.com`
    is recognizable to almost everyone as the website of the International Business
    Machines Corporation (IBM). Similarly, you can probably figure out what this URL
    does without any explanation: `ftp://www.somecomputercompany.com/drivers/videodrivers.zip`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, as you have seen earlier in this chapter, URLs can be much more complex.
    In particular, the common Internet syntax used by protocols such as HTTP and FTP
    is extremely flexible, containing a large number of optional elements that can
    be used when required to provide the information necessary for a particular resource
    access.
  prefs: []
  type: TYPE_NORMAL
- en: The point that many elements in URL syntax are optional is important. The majority
    of the time, most of these optional parts are omitted, which makes URLs much simpler
    in practical use than they are in their descriptions. For example, even though
    an HTTP URL theoretically contains a user name, password, host, port, path, query,
    and bookmark, most URLs use only a host name and a path. This is what helps keep
    URLs short and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite this, you will still find some rather long URLs used on the Internet,
    for a variety of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long DNS Domain and Host Names** Some people don''t realize that long host
    names are hard to remember. If you run the Super Auto Body Shop & Pizza Parlor,
    having a website called www.superauto.com will make it easier for your customers
    to find you than trying to register www.superautobodyshopandpizza.com. Yet DNS
    names of 15, 20, or even more characters are surprisingly common.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long Document or Directory Names** Similarly, short filenames are better
    than long ones, and again, many people don''t think about this before putting
    files on the Internet, which makes things more difficult for those who must access
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use of Unsafe Characters** As discussed saw earlier in this chapter, URLs
    have a mechanism for dealing with unsafe characters, but it makes them longer
    and harder to decipher. If you have a file called "{ABC Corp} budget; draft #3;
    third quarter 2004.htm," the URL for it will have to be `%7BABC%20Corp%7D%20budget%3B%20draft%20%233%3B%20third%20quarter%202004.htm`.
    The original long filename was readable, but the URL is a mess. Naming the file
    "ABC budget draft 3, 3Q2004.htm" would be a better choice, and still includes
    enough information to be understandable. Even better, you could replace the spaces
    with underscores, to avoid the need for the `%20` encoding entirely: "ABC_budget_draft
    3,_3Q2004.htm."'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameter Strings** In HTTP URLs, the syntax for specifying a query (following
    a question mark character) is often used to allow a web browser to send various
    types of information to a web server, especially parameters for interactive queries.
    These parameter strings can get quite lengthy. For example, I typed in a query
    to the great web search engine Google to find recipes for potato salad. This is
    what the URL for one of the recipe files looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Almost all of that consists of parameters that tell the Google server exactly
    what document I want based on my query. It is necessary, but still cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: URL Wrapping and Delimiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For humans, long and complex URLs are hard to remember and use. In addition
    to the sheer difficulty of remembering all those characters, there is the issue
    of URL wrapping, which occurs when they are presented in certain forms. Most programs
    can display only 78 or 80 characters in a single line. If a URL is longer than
    this, the characters of the URL will wrap onto multiple lines; when you read that
    Google example of parameter strings, you probably noticed that.
  prefs: []
  type: TYPE_NORMAL
- en: URL wrapping can lead to mistakes when copying a URL from one form to another,
    such as if you copied it from this document into your web browser. If a URL is
    81 characters long, and 80 are on the first line and the last character is on
    the second line, many users may not realize that the URL has wrapped. I have seen
    URLs that are hundreds of characters long, requiring several manual copy-and-paste
    operations to get the URL to work.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps surprisingly, some software may not handle this wrapping properly either.
    While this is not a problem when a hyperlink is used in something like an HTML
    document, it can be troublesome when links are included in an email message or
    Usenet article.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is delimiting where a URL starts and ends when it appears. A URL
    begins with a scheme name that could, in theory, be used in other contexts that
    are not URLs. Without a clear way of labeling a URL as being a URL, a software
    program might not recognize it. Consider discussion of a URL in a document like
    this one. If I say, "Please visit [http://www.thissite.com](http://www.thissite.com);
    you will see the information you need there," we all know the semicolon is part
    of the sentence and not part of the URL, but a computer program might not be so
    sure. And again, this problem is worse when a URL is long and complex, and wraps
    on to multiple lines of text. How does the program recognize the end of the URL?
  prefs: []
  type: TYPE_NORMAL
- en: Explicit URL Delimiting and Redirectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To resolve both the wrapping and delimiting problems, a special URL super-syntax
    is sometimes employed, especially when URLs are used in other text. This is done
    by surrounding the URL in angle brackets, possibly including the label `URL:`.
    before the scheme name. For example, all of the following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The angle brackets indicate clearly where the URL begins and ends, making it
    easier for both programs and humans to deal with long URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution sometimes used for long URLs are redirection services, provided
    by many websites. For example, [http://www.tinyurl.com](http://www.tinyurl.com)
    is a free service that allows someone to create a short URL that automatically
    loads a resource at a much longer URL.
  prefs: []
  type: TYPE_NORMAL
- en: URL Abbreviation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One final issue I want to discuss isn''t related directly to long or complex
    URLs, but is related indirectly to the matter of length: URL abbreviation. Many
    people use URLs so often that they become lazy when it comes to specifying URLs.
    They tend to leave off portions of the full URL syntax to save time and energy.
    I don''t mean by this that they specify relative URLs, but rather, they specify
    absolute URLs with missing pieces.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than type `http://www.sitename.com`, they might type `http:www.sitename.com`,
    leaving off the two slashes. More commonly, people omit the scheme name entirely,
    just entering `www.sitename.com`. Technically, this is not a URL—it is just a
    domain name. However, most web browsers can handle this, assuming by default that
    the scheme is `http://` if none is provided.
  prefs: []
  type: TYPE_NORMAL
- en: URL Obscuration, Obfuscation, and General Trickery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, the owner of a resource wants the URL that refers to the resource
    to be short, simple and easily understood. Thus, long and complex URLs are usually
    the result of necessity, accident, or ignorance. Some resources need to have long
    names for a specific reason, such as the use of the long query string in the Google
    example earlier; other times, URLs are made long because the owner of the resource
    doesn't realize that using a long DNS host name or file name will make for a long
    and unwieldy URL.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever the reasons for these situations, they are not deliberate. Recent years,
    however, have seen a dramatic rise in the use of intentionally long, complex,
    confusing and deliberately deceptive URLs. These URLs are either structured so
    that it is impossible to tell what they are, or worse, they are made to appear
    as if they point to one resource when they really go to another.
  prefs: []
  type: TYPE_NORMAL
- en: Why would people do this? Because they do not want to be open and honest about
    their "resources." And who would these people be? Why, they would be the spammers
    and con artists who overload our Internet email boxes with offers of every sort
    imaginable, from making you rich beyond your wildest dreams to inflating the dimensions
    of certain body parts to unnatural sizes.
  prefs: []
  type: TYPE_NORMAL
- en: They are afraid that if the URL indicated clearly what the "resource" was, you
    might not click the link, or that if you identify them as spammers you might filter
    out their email. They also figure that if they can make the URL appear to be something
    interesting, you'll load it. Even if it turns out to be something you didn't expect,
    maybe you'll pay attention anyway.
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking that you are too smart to be tricked into buying a product
    through a deceptive URL. And you would never support a spammer anyway. What a
    coincidence—same with me! Yet the spam keeps coming. It must work, or they wouldn't
    keep doing it … would they?
  prefs: []
  type: TYPE_NORMAL
- en: It is a cruel irony that the complex syntax that was built into URLs to allow
    them to be so flexible has been subject to exploitation. Tricksters know that
    most people are used to seeing simple URLs like `http://www.myfavoritesite.com`
    and do not realize that the full URL syntax allows the same resource to be specified
    in literally millions of different ways. So, desperate for hits to their websites
    at any cost, they keep coming up with new tricks for manipulating URLs. These
    are focused on HTTP scheme URLs, though in theory, the tricks can be applied to
    several other types as well (though they won't work with some schemes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the more common gimmicks that have been used (note that if
    you are trying these out as you read, some examples may not work on certain browsers):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excessive Length** In some cases, a URL is just made really long by the addition
    of a lot of gibberish as a query string, so that the user''s eyes glaze over just
    looking at it. This is a relatively unsophisticated technique, however, since
    you can easily tell what the real host name is by looking at the start of the
    URL. Most of the better scammers have moved beyond such simple tricks today.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular IP Address Hosts** Internet users are so accustomed to using DNS
    names that they don''t realize that you can access a URL using an IP address.
    So most people don''t realize that The PC Guide can be accessed as easily using
    `<http://209.68.14.80>` as `<http://www.PCGuide.com>`. (Note that this is not
    true of all Internet hosts; those that use virtual names cannot be accessed using
    just an IP address.) This is not really trickery per se. It is quite legitimate,
    and in some ways, even necessary; for example, for accessing a site that is having
    DNS problems. The problem here is that usually you cannot tell what a site is
    from the IP address alone, and many people will just click an IP address link
    without bothering to find out what it is.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numeric Domain Names** It is possible to register a DNS domain name consisting
    of just a single number. For example, one could register 114.com. And then you
    could create subdomains within it such as 42.12.205.114.com. At first glance,
    this appears to be an IP address specification, so someone might think it would
    resolve to the address 42.12.205.114, but it''s actually some other address. I
    believe that DNS name registrars have been cracking down on this sort of trickery,
    so it may not be as prevalent now as it once was.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bogus Authentication Information** HTTP URLs theoretically support the inclusion
    of authentication information, by including `<user>:<password>@` before the host
    in the URL. Yet the vast majority of websites are open, and neither require nor
    use this type of information. If you specify an authentication string and it is
    not needed, it is ignored. One way to abuse this is by including "authentication
    information" that looks like a benign host, to make the user think the URL is
    for that host. For example, if I wanted to trick you into visiting The PC Guide,
    I might use this URL to make it look like clicking it would go to CNN: `<http://www.cnn.com@www.PCGuide.com>`.
    This is still too obvious, however, so this method is often combined with some
    of the following techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deceptive Character Encoding** The use of the percent sign to encode special
    characters such as spaces and punctuation can also be abused to obscure the name
    of a domain. For example, the following is another way of expressing the DNS name
    for The PC Guide: `<http://%57%57%57.%50%43%47%55%49%44%45.%43%4F%4D>`. Try it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP Address Math Trickery** Okay, this is where things get really bizarre.
    Most of the time, we express an IP address as a dotted decimal number. Remember,
    however, that to computers, the IP address is just a 32-bit binary number. Most
    browsers support a rather shocking number of methods for expressing these numbers.
    This is unfortunate, because this flexibility is really not needed and almost
    never used for legitimate purposes. It can lead to some really bizarre URLs that
    are unrecognizable or that look like regular IP addresses but are not. Here are
    some examples, all of which are the same as the IP address form of The PC Guide
    (`<http://209.68.14.80>`):'
  prefs: []
  type: TYPE_NORMAL
- en: An IP address in dotted octal uses a leading zero to signify where each byte
    is in octal, as in `<http://0321.0104.016.0120>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IP address in dotted hexadecimal uses a leading zero followed by an *x* to
    signify where each byte is in hexadecimal, as in `<http://0xD1.0x44.0x0E.0x50>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can even take the entire 32-bit number and express it as a single number,
    and that will work too. In decimal, this would look like `<http://3510898256/>`;
    in octal, `<http://032121007120/>`; and in hexadecimal, `<http://0xd1440e50/>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As if these tricks weren''t bad enough taken individually, we can have some
    real fun by combining them! For example, start with the regular PC Guide URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And convert it to IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add some bogus authentication gibberish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And convert the real URL into a single number, so it looks like a document
    on the CNN website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the octal form, and even include a lot of extra leading
    zeros just for fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Believe it or not, this is just the tip of the iceberg. In some browsers, even
    the IP address numbers can be expressed using percent sign ASCII encoding!
  prefs: []
  type: TYPE_NORMAL
- en: While quite irritating, I must give these people points for creativity at least—some
    of the tricks are quite ingenious. At the same time, their inventiveness is potentially
    hazardous. While these false URLs are usually more a waste of time than anything
    harmful, there are sometimes good reasons a person would go to great lengths to
    hide the identity of a resource. Deceptive URLs are just one more danger that
    network administrators must deal with today.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The syntax of Internet URLs includes many elements that provide
    great flexibility in how URLs can be constructed. Unfortunately, these capabilities
    of expression are now often abused by people who create intentionally obfuscated
    URLs to trick users into accessing their websites and other resources. Some of
    these can be potentially hazardous, which means that care is required before clicking
    unknown links or accessing strange URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: URNs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"HTTP 404 - NOT FOUND"'
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever tried to access a website or other Internet resource, only to
    see those dreaded words appear? You probably have, and in seeing them, you have
    experienced firsthand one of the most common problems with URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'URLs specify a resource using two key pieces of information: the resource''s
    location and a method by which the resource may be accessed or retrieved. This
    focus on the means of access for the resource makes URLs very practical, in that
    the URL usually contains all the data we need to use the resource. This is why
    URLs are so widely used today. However, this access orientation also means that
    URLs have a number of serious limitations.'
  prefs: []
  type: TYPE_NORMAL
- en: The Problem with URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main difficulty with URLs is that since they describe a resource based on
    its location, they tie the resource and its location together inextricably. While
    this may not seem to be a big deal, it is actually a fairly serious matter in
    a number of ways, because a resource and its location are not the same thing.
    It is only because most Internet resources rarely change location that we don't
    notice this issue more often with URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that your name is Joe Xavier Zachariah and you live at 44 Glendale Crescent
    in Sydney, Australia. If someone asked you who you were, would you say, "Joe Xavier
    Zachariah," or "the man living at 44 Glendale Crescent in Sydney, Australia"?
    Almost certainly, you would supply the former answer. But a URL would be like
    describing yourself as a "resource" using the latter description.
  prefs: []
  type: TYPE_NORMAL
- en: Since we realize that Mr. Zachariah is obviously not always going to be at 44
    Glendale Crescent, we know that describing him using just a location is not sufficient.
    The same thing occurs with Internet resources when they are identified using only
    location.
  prefs: []
  type: TYPE_NORMAL
- en: However, the problem with Internet resources and URLs goes beyond just the matter
    of movement. Consider a situation where a particular resource is very popular
    and we want to duplicate the same resource in multiple locations. Using URLs,
    we would need a different identifier for each copy of the resource, even though
    each copy is the same. Again, the problem is that we are not identifying the resource
    itself, but rather the place where it can be found.
  prefs: []
  type: TYPE_NORMAL
- en: In recognition of this issue with URLs, an alternative identification mechanism
    for Internet resources was developed, called *Uniform Resource Names (URNs)*.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of URNs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic standard describing URNs is RFC 1737, "Functional Requirements for
    Uniform Resource Names," which was published in 1994\. In 1997, RFC 2141 was published,
    which specifies the syntax of URNs.
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably tell from that term, a URN is intended to label a resource
    based on its actual identity, rather than where it can be found. So, where a URL
    is like Joe Zachariah's address, a URN would be his name. Or, as I gave as an
    example in the overview of URIs at the beginning of this chapter, a URN would
    be identifying a book based on its ISBN number rather than specifying which bookshelf
    it is on in a building.
  prefs: []
  type: TYPE_NORMAL
- en: To be useful in identifying a particular resource, it is necessary that a URN
    be globally unique, and that's not always as simple as it may at first appear.
    Consider human names, for example. Even though there is probably only one Charles
    Marlin Kozierok in the entire world, if your name is John Paul Smith or José Garcia,
    you likely share that name with thousands of others. This means using common names
    may not be sufficient for identifying human "resources," and some other method
    might need to be devised.
  prefs: []
  type: TYPE_NORMAL
- en: URN Namespaces and Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many types of resources that URNs are intended to identify on the
    Internet, each of which may require a different form of naming. To allow URNs
    to represent many kinds of resources, numerous *URN namespaces* are defined.
  prefs: []
  type: TYPE_NORMAL
- en: A namespace is referenced using a unique string that tells the person or computer
    interpreting the URN what type of resource the URN identifies. The namespace also
    ensures the uniqueness of URNs, when a particular identifier might exist in more
    than one context. For example, both North American telephone numbers and ISBN
    numbers consist of ten digits, so a particular number such as 4167819249 could
    represent both a telephone number and a book number. The namespace identifier
    tells us what the number means when it is encountered in a URN.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of a URN is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For example, a book with the ISBN number 0-679-73669-7 could be represented
    as `URN:isbn:0-679-73669-7`. This string identifies that particular book uniquely,
    wherever it might happen to be in the world. Many other namespaces have also been
    defined to specify the URNs for other types of resources, such as documents on
    the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Where URLs specify a resource based on an access method and
    location, Uniform Resource Names (URNs) identify a resource by name. A URN consists
    of a namespace identifier that indicates what type of name it contains, and a
    resource identifier that specifies the individual resource within the context
    of that namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: URN Resolution and Implementation Difficulties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'URNs are a more natural way of identifying resources, which gives them intuitive
    appeal. Despite this, URNs are still not widely used, even though they have been
    in development for more than a decade. The main reason for this is somewhat ironic:
    It is because URNs are independent of location! The very characteristic that provides
    URNs with identification advantages over URLs also makes URNs much harder to use
    practically, which has led to long delays in workable URN systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the problem, consider the example `URN:isbn:0-679-73669-7`. This
    uniquely identifies a particular book, and will always refer to it no matter where
    the book may be, unlike a URL. The problem is that while the URL equivalent tells
    us how to actually find this book, the URN does not. The same thing goes for our
    previous human example: Identifying Joe Xavier Zachariah by his name is more sensible
    than identifying him as the man living at 44 Glendale Crescent in Sydney, Australia,
    but at least with the latter, we know where Joe is!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for URNs to be useful on an internetwork, they require an additional
    mechanism for translating a simple URN identification string into a particular
    location and/or access method. In other words, we need to be able to change a
    URN into the equivalent of a URL, so that the resource can be found. This requirement
    is analogous to the problem of resolving Internet DNS domain names into IP addresses,
    and the same term is used to describe it: *URN resolution*.'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we want to be able to use some sort of technique where we specify the
    name Joe Xavier Zachariah, and we are told where Joe is so we can find him. Or,
    we provide the string `URN:isbn:0-679-73669-7`, and we are provided with a list
    of libraries or other places where the book can be found. The power of URNs can
    also be taken advantage of in such a system, by having the resolution system specify
    the location of a copy of the resource that is closest (in terms of network distance,
    cost, or other measurements) to the entity making the request.
  prefs: []
  type: TYPE_NORMAL
- en: However, setting up URN resolution mechanisms is a nontrivial task. The matter
    of URN resolution has been the subject of much of the work on URNs over the past
    decade. RFC 2483, "URI Resolution Services Necessary for URN Resolution," was
    published in 1999 and discusses some of the important issues in URN resolution.
    In October 2002, a series of RFCs, 3401 to 3405, defined a new system called the
    *Dynamic Delegation Discovery System (DDDS)* that was designed not just to resolve
    URNs, but to handle the entire class of resolution problems where an identifier
    is given and the output is information about where to get more information about
    that identifier. RFC 3406 was published at the same time, providing more information
    about URN namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Since URNs identify resources by name rather than location,
    they are a more natural way of identifying resources than using URLs. Unfortunately,
    this advantage is also a disadvantage, since URNs don''t, by themselves, provide
    a user with the necessary information to find the resource so it can be used.
    A process of URN resolution must be performed to transform the URN into a set
    of information that allows the resource to be accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: Although progress on URNs has been slow, it has been steady. While it may yet
    be a few years before URNs are widely used, I believe it is likely that they will
    play an increasingly prominent role in identifying resources on the Internet in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 71. FILE AND MESSAGE TRANSFER OVERVIEW AND APPLICATION CATEGORIES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The purpose of networking applications is to allow different types of information
    to be sent between networked devices. In the world of computers, information is
    most often arranged into discrete units called *files*. When those files are created
    specifically for the purpose of communication, they are often called *messages*.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files and messages between networked computers is the most basic
    type of network communication. For this reason, it would not be an exaggeration
    to say that *file and message transfer applications* may be the most important
    class of internetworking applications. Some of the members of this group are so
    common that many people use them every day without even thinking about it.
  prefs: []
  type: TYPE_NORMAL
- en: In this brief introductory chapter, I take a general look at the concepts behind
    file and message transfer, and how different applications treat them. I begin
    with a discussion of the general concept behind files, then discuss the categories
    of applications that use them, contrasting message transfer with file transfer.
  prefs: []
  type: TYPE_NORMAL
- en: File Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the file and message transfer applications, let's first take a
    quick step back to look at the fundamental concept of a *file*. Simply put, a
    file is just a collection of information that is treated as a single unit by a
    computer system.
  prefs: []
  type: TYPE_NORMAL
- en: Files are stored in directories or folders in a *file system*. In modern computers,
    files are normally expressed as a sequence of bytes or characters, and each file
    is read, written, copied, or otherwise manipulated as an independent object. In
    addition to the data it contains, each file has associated with it file *attributes*
    that describe it.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, the critical characteristic of a file is that it is a self-contained
    object carrying arbitrary information. Since files are the building blocks of
    information in computer systems, it's no surprise that the transfer of information
    in networking was originally defined in terms of the movement of files. Some of
    the protocols describing how to transfer files predate all of the modern protocols
    in the lower levels of TCP/IP, including Internet Protocol version 4 (IPv4), the
    Transmission Control Protocol (TCP), and the User Datagram Protocol (UDP). It's
    not the case that file transfer was an early application of internetworking, but
    that internetworking was invented in large part to permit file transfer!
  prefs: []
  type: TYPE_NORMAL
- en: Application Categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Files in modern computing systems are inherently designed to be generic; they
    can contain any type of information. The significance of the contents of a file
    depends entirely on the user or software program that examines it. The TCP/IP
    file and message transfer protocols have in common the notion of moving files
    from one computer to another. Where they differ is in how the files are handled
    and processed. There are two basic approaches: file transfer and message transfer.'
  prefs: []
  type: TYPE_NORMAL
- en: General File Transfer Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: General transfer applications normally treat files as a "black box," moving
    them from place to place and paying little or no attention to what the files contain.
    The TCP/IP File Transfer Protocol (FTP) and Trivial File Transfer Protocol (TFTP)
    fall into this category. FTP has been around in one form or another for more than
    30 years now and is still widely used.
  prefs: []
  type: TYPE_NORMAL
- en: Message Transfer Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other TCP/IP applications work with particular types of files, processing and
    interpreting them in various ways. These files are usually designed for the specific
    purpose of communication, and are thus called *messages*; these applications allow
    users to construct, send, and receive messages that fit a particular message format.
    There are several prominent TCP/IP messaging applications we'll examine in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic Mail (Email)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Email is a system that allows users to exchange "letters" (in fact, any type
    of document) in a manner equivalent to the conventional postal system, but with
    the advantages of great speed and simplicity. Email has not replaced regular mail
    entirely, but many people now use it for the vast majority of their correspondence.
  prefs: []
  type: TYPE_NORMAL
- en: Network News (Usenet)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usenet is an application that is like email in that it allows users to send
    messages. However, while email is normally used to allow a message to be sent
    to one user or a small number of recipients, network news is a way for thousands
    of users to share messages on various topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any user can contribute a message that can be seen by others, any of whom can
    respond. Unlike the case with email, recipients do not need to be explicitly identified,
    which makes network news far more suitable to communication among large groups
    of people who may not even know each other. This was one of the first TCP/IP applications
    to create something like an electronic bulletin board: an online community.'
  prefs: []
  type: TYPE_NORMAL
- en: Hypertext (World Wide Web)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You probably don't even need me to explain what the World Wide Web is, such
    is its great significance in modern internetworking. Hypertext moves the idea
    of messaging beyond the simple exchange of text messages or plain files to the
    notion of rich messages that can contain a variety of types of information. This
    includes text, graphics, multimedia, and embedded files.
  prefs: []
  type: TYPE_NORMAL
- en: Most important, hypertext allows one document to be linked to another, forming
    the web of related documents that led to the name World Wide Web. The Web is almost
    certainly the single most important TCP/IP application, used daily by millions
    of people.
  prefs: []
  type: TYPE_NORMAL
- en: The Merging of File and Message Transfer Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, a number of developments have caused the lines between applications
    that transfer files and applications that transfer messages to become greatly
    blurred. Email is no longer limited to simple text messages; it can now be used
    to carry general files by encoding them into text form using special methods,
    and even to carry hypertext documents. World Wide Web clients (browsers) continue
    to be enhanced to let them access other types of servers and files, and can also
    be used for general file transfer.
  prefs: []
  type: TYPE_NORMAL
- en: These developments mean even more functionality and flexibility for the TCP/IP
    user—and a bit more care required on the part of you, the TCP/IP learner.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the most important groups of TCP/IP applications is
    the one that enables files to be moved between devices on an internetwork: file
    and message transfer applications. This group contains many of the common applications
    that TCP/IP users employ every day to communicate. It can be broken into two main
    categories: general file transfer applications that are used to move any type
    of file between devices, and message transfer applications, which allow different
    types of communication using special file types, such as electronic-mail messages
    or hypertext files.'
  prefs: []
  type: TYPE_NORMAL
