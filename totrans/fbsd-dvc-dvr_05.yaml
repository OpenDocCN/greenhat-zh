- en: Chapter 5. Delaying Execution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。延迟执行
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: Often, drivers need to delay their execution in order to give their device(s),
    the kernel, or a user the time to accomplish some task. In this chapter, I’ll
    detail the different functions available for achieving these delays. In the process,
    I’ll also describe asynchronous code execution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，驱动程序需要延迟它们的执行，以便给它们的设备、内核或用户提供时间来完成某些任务。在本章中，我将详细介绍可用于实现这些延迟的不同函数。在这个过程中，我还会描述异步代码执行。
- en: Voluntary Context Switching, or Sleeping
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自愿上下文切换，或休眠
- en: '*Voluntary context switching*, or *sleeping*, is done when a driver thread
    must await the availability of a resource or the arrival of an event; for example,
    a driver thread should sleep after it requests data from an input device, such
    as a terminal (McKusick and Neville-Neil, 2005). A driver thread sleeps by calling
    a `*sleep` function.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*自愿上下文切换*，或*休眠*，发生在驱动线程必须等待资源可用或事件到达时；例如，驱动线程在从输入设备（如终端）请求数据后应该休眠（McKusick
    和 Neville-Neil，2005）。驱动线程通过调用 `*sleep` 函数来休眠。'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A thread voluntarily context switches (or sleeps) by calling `tsleep`. The arguments
    for `tsleep` are common to the other `*sleep` functions and are described in the
    next few paragraphs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `tsleep`，线程可以自愿地进行上下文切换（或休眠）。`tsleep` 的参数与其他 `*sleep` 函数的参数相同，将在接下来的几段中描述。
- en: The `chan` argument is the channel (that is to say, an arbitrary address) that
    uniquely identifies the event that the thread is waiting for.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`chan` 参数是通道（即，一个任意地址），它唯一标识线程正在等待的事件。'
- en: The `priority` argument is the priority for the thread when it resumes. If `priority`
    is `0`, the current thread priority is used. If `PCATCH` is `OR`’ed into `priority`,
    signals are checked before and after sleeping.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`priority` 参数是线程恢复时的优先级。如果 `priority` 为 `0`，则使用当前线程的优先级。如果 `PCATCH` 与 `priority`
    进行 `OR` 操作，则在睡眠前后检查信号。'
- en: The `wmesg` argument expects a concise description of the sleeping thread. This
    description is displayed by user-mode utilities, such as `ps(1)`, and has no real
    impact on performance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`wmesg` 参数期望对休眠线程的简洁描述。此描述将由用户模式实用程序（如 `ps(1)`）显示，并且对性能没有实际影响。'
- en: The `timo` argument specifies the sleep timeout. If `timo` is nonzero, the thread
    will sleep for at most `timo` / `hz` seconds. Afterward, `tsleep` returns the
    error code `EWOULDBLOCK`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`timo` 参数指定睡眠超时。如果 `timo` 不为零，则线程将休眠最多 `timo` / `hz` 秒。之后，`tsleep` 返回错误代码 `EWOULDBLOCK`。'
- en: The `wakeup` function wakes up every thread asleep on the channel `chan`. Generally
    speaking, threads woken from sleep should re-evaluate the conditions they slept
    on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`wakeup` 函数唤醒通道 `chan` 上所有休眠的线程。一般来说，从睡眠中唤醒的线程应该重新评估它们睡眠的条件。'
- en: The `wakeup_one` function is a variant of `wakeup` that only gets up the first
    thread that it finds asleep on chan. The assumption is that when the awakened
    thread is done, it calls `wakeup_one` to wake up another thread that’s asleep
    on `chan`; this succession of `wakeup_one` calls continues until every thread
    asleep on `chan` has been awakened (McKusick and Neville-Neil, 2005). This reduces
    the load in cases when numerous threads are asleep on `chan`, but only one thread
    can do anything meaningful when made runnable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`wakeup_one` 函数是 `wakeup` 的一个变体，它只唤醒在通道上找到的第一个休眠线程。假设当唤醒的线程完成时，它调用 `wakeup_one`
    来唤醒另一个在 `chan` 上休眠的线程；这种 `wakeup_one` 调用的连续发生，直到 `chan` 上所有休眠的线程都被唤醒（McKusick
    和 Neville-Neil，2005）。这减少了在 `chan` 上有多个线程休眠但只有一个线程可以执行有意义操作的情况下的负载。'
- en: The `pause` function puts the calling thread to sleep for `timo` / `hz` seconds.
    This thread cannot be awoken by `wakeup`, `wakeup_one`, or signals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause` 函数使调用线程休眠 `timo` / `hz` 秒。此线程不能被 `wakeup`、`wakeup_one` 或信号唤醒。'
- en: The remaining `*sleep` functions—`mtx_sleep`, `msleep_spin`, `sx_sleep`, and
    `rw_`sleep—are variants of tsleep that take a particular lock. This lock is dropped
    before the thread sleeps and is reacquired before the thread awakes; if `PDROP`
    is `OR`’ed into `priority`, this lock is not reacquired.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的 `*sleep` 函数——`mtx_sleep`、`msleep_spin`、`sx_sleep` 和 `rw_`sleep——是 `tsleep`
    的变体，它们接受特定的锁。在线程休眠之前释放此锁，在线程唤醒之前重新获取此锁；如果 `PDROP` 与 `priority` 进行 `OR` 操作，则不会重新获取此锁。
- en: Note that the `msleep_spin` function does not have a `priority` argument. Consequently,
    it cannot assign a new thread priority, catch signals via `PCATCH`, or drop its
    spin mutex via `PDROP`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`msleep_spin` 函数没有 `priority` 参数。因此，它不能分配新的线程优先级，通过 `PCATCH` 捕获信号，或通过 `PDROP`
    释放自旋互斥锁。
- en: Implementing Sleeps and Condition Variables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现睡眠和条件变量
- en: '[Example 5-1](ch05s02.html#sleep.c "Example 5-1. sleep.c") (which is based
    on code written by John Baldwin) is a KLD designed to demonstrate sleeps and condition
    variables. It works by obtaining “events” from a sysctl; each event is then passed
    to a thread, which performs a specific task based on the event it received.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](ch05s02.html#sleep.c "示例 5-1. sleep.c")（基于 John Baldwin 编写的代码）是一个用于演示睡眠和条件变量的
    KLD。它通过从 sysctl 获取“事件”来工作；然后，每个事件都被传递给一个线程，该线程根据接收到的事件执行特定的任务。'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take a quick look at this code and try to discern some of its structure. If
    you don’t understand all of it, don’t worry; an explanation follows.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览一下这段代码，并尝试理解其结构。如果你不理解所有内容，不要担心；解释将随后提供。
- en: Example 5-1. sleep.c
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1. sleep.c
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Near the beginning of [Example 5-1](ch05s02.html#sleep.c "Example 5-1. sleep.c"),
    a constant named ![](httpatomoreillycomsourcenostarchimages1137499.png) `MAX_EVENT`
    is defined as `1`, and a `struct proc` pointer named ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `kthread` is declared. For now, ignore these two objects; I’ll discuss them later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 5-1](ch05s02.html#sleep.c "示例 5-1. sleep.c") 的开头附近，定义了一个名为 ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `MAX_EVENT` 的常量，其值为 `1`，并声明了一个名为 ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `kthread` 的 `struct proc` 指针。现在，忽略这两个对象；我稍后会讨论它们。
- en: 'Next, there are two variable declarations: an integer named ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `event` and a condition variable named ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `event_cv`. These variables are used to synchronize [Example 5-1](ch05s02.html#sleep.c
    "Example 5-1. sleep.c")’s threads. Obviously, the ![](httpatomoreillycomsourcenostarchimages1137507.png)
    `event_mtx` mutex is used to protect even`t`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有两个变量声明：一个名为 ![](httpatomoreillycomsourcenostarchimages1137503.png) `event`
    的整数和一个名为 ![](httpatomoreillycomsourcenostarchimages1137505.png) `event_cv` 的条件变量。这些变量用于同步
    [示例 5-1](ch05s02.html#sleep.c "示例 5-1. sleep.c") 的线程。显然，![](httpatomoreillycomsourcenostarchimages1137507.png)
    `event_mtx` 互斥锁用于保护 `event`。
- en: The remaining parts—![](httpatomoreillycomsourcenostarchimages1137509.png) `sleep_thread`,
    ![](httpatomoreillycomsourcenostarchimages1137511.png) `sysctl_debug_sleep_test`,
    ![](httpatomoreillycomsourcenostarchimages1137513.png) `load`, ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `unload`, and ![](httpatomoreillycomsourcenostarchimages1137517.png) `sleep_modevent`—require
    a more in-depth explanation and are therefore described in their own sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的部分——![](httpatomoreillycomsourcenostarchimages1137509.png) `sleep_thread`,
    ![](httpatomoreillycomsourcenostarchimages1137511.png) `sysctl_debug_sleep_test`,
    ![](httpatomoreillycomsourcenostarchimages1137513.png) `load`, ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `unload`, 和 ![](httpatomoreillycomsourcenostarchimages1137517.png) `sleep_modevent`——需要更深入的说明，因此它们将在各自的章节中描述。
- en: To make things easier to follow, I’ll describe the abovementioned parts in the
    order they execute, rather than in the order they appear. Thus, I’ll begin with
    [Example 5-1](ch05s02.html#sleep.c "Example 5-1. sleep.c")’s module event handler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更容易理解，我将按照它们执行的顺序而不是它们出现的顺序来描述上述部分。因此，我将从 [示例 5-1](ch05s02.html#sleep.c
    "示例 5-1. sleep.c") 的模块事件处理器开始。
- en: sleep_modevent Function
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sleep_modevent 函数
- en: 'The `sleep_modevent` function is the module event handler for [Example 5-1](ch05s02.html#sleep.c
    "Example 5-1. sleep.c"). Here is its function definition (again):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_modevent` 函数是 [示例 5-1](ch05s02.html#sleep.c "示例 5-1. sleep.c") 的模块事件处理器。以下是它的函数定义（再次）：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On module load, this function simply calls the ![](httpatomoreillycomsourcenostarchimages1137499.png)
    load function. On module unload, it calls the ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `unload` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块加载时，此函数简单地调用 ![](httpatomoreillycomsourcenostarchimages1137499.png) 加载函数。在模块卸载时，它调用
    ![](httpatomoreillycomsourcenostarchimages1137501.png) `unload` 函数。
- en: load Function
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载函数
- en: 'The `load` function initializes this KLD. Here is its function definition (again):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 函数初始化这个 KLD。以下是它的函数定义（再次）：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function can be split into four parts. The first ![](httpatomoreillycomsourcenostarchimages1137499.png)
    creates a kernel process to execute the function ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `sleep_thread`. A handle to this process is saved in ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `p`. The constant ![](httpatomoreillycomsourcenostarchimages1137505.png) `RFSTOPPED`
    puts the process in the stopped state. The second part initializes the ![](httpatomoreillycomsourcenostarchimages1137507.png)
    `event`, ![](httpatomoreillycomsourcenostarchimages1137509.png) `event_mtx`, and
    ![](httpatomoreillycomsourcenostarchimages1137511.png) `event_cv` variables. The
    third part ![](httpatomoreillycomsourcenostarchimages1137513.png) schedules the
    new process to execute `sleep_thread`. It also saves the process handle in ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `kthread`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以分为四个部分。第一部分 ![创建一个内核进程来执行 `sleep_thread` 函数](httpatomoreillycomsourcenostarchimages1137499.png)。这个进程的句柄被保存在
    ![`p` 中](httpatomoreillycomsourcenostarchimages1137503.png)。常量 ![`RFSTOPPED`](httpatomoreillycomsourcenostarchimages1137505.png)
    将进程置于停止状态。第二部分初始化 ![`event`、`event_mtx` 和 `event_cv` 变量](httpatomoreillycomsourcenostarchimages1137507.png)。第三部分
    ![安排新进程执行 `sleep_thread`](httpatomoreillycomsourcenostarchimages1137513.png)。它还将在
    ![`kthread` 中保存进程句柄](httpatomoreillycomsourcenostarchimages1137515.png)。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Processes are executed at thread granularity, which is why this code is thread
    centric.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 进程在线程粒度上执行，这就是为什么这段代码以线程为中心。
- en: The fourth part creates a sysctl named debug.sleep.test, which uses a handler
    function named ![](httpatomoreillycomsourcenostarchimages1137517.png) `sysctl_debug_sleep_test`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分创建一个名为 debug.sleep.test 的 sysctl，它使用名为 ![`sysctl_debug_sleep_test` 的处理函数](httpatomoreillycomsourcenostarchimages1137517.png)。
- en: sleep_thread Function
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sleep_thread 函数
- en: 'The `sleep_thread` function receives events from the `sysctl_debug_sleep_test`
    function. It then performs a specific task based on the event received. Here is
    its function definition (again):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_thread` 函数从 `sysctl_debug_sleep_test` 函数接收事件。然后，它根据接收到的事件执行特定的任务。以下是它的函数定义（再次）：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the execution of `sleep_thread` is contained within a ![](httpatomoreillycomsourcenostarchimages1137499.png)
    forever loop. This loop begins by ![](httpatomoreillycomsourcenostarchimages1137501.png)
    acquiring `event_mtx`. Next, the value of `event` is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    saved in `ev`. If `event` is equal to `0`, `sleep_thread` ![](httpatomoreillycomsourcenostarchimages1137505.png)
    waits on `event_cv`. See, `event` is only `0` if `sleep_thread` has yet to receive
    an event. If an event has been received, `sleep_thread` ![](httpatomoreillycomsourcenostarchimages1137507.png)
    sets event to 0 to prevent reprocessing it. Next, `event_mtx` is ![](httpatomoreillycomsourcenostarchimages1137509.png)
    released. Finally, the received event is processed by a ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `switch` statement. Note that if the received event is ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `−1, sleep_thread` ![](httpatomoreillycomsourcenostarchimages1137515.png) self-terminates
    via `kproc_exit`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`sleep_thread` 的执行被包含在一个 ![永远循环](httpatomoreillycomsourcenostarchimages1137499.png)
    中。这个循环首先 ![获取 `event_mtx`](httpatomoreillycomsourcenostarchimages1137501.png)。接下来，将
    `event` 的值 ![保存到 `ev` 中](httpatomoreillycomsourcenostarchimages1137503.png)。如果
    `event` 等于 `0`，`sleep_thread` ![在 `event_cv` 上等待](httpatomoreillycomsourcenostarchimages1137505.png)。注意，只有当
    `sleep_thread` 尚未收到事件时，`event` 才是 `0`。如果已收到事件，`sleep_thread` ![将事件设置为 0 以防止重新处理它](httpatomoreillycomsourcenostarchimages1137507.png)。接下来，`event_mtx`
    被释放。最后，接收到的事件通过一个 ![`switch` 语句](httpatomoreillycomsourcenostarchimages1137511.png)
    进行处理。注意，如果接收到的事件是 ![`−1`](httpatomoreillycomsourcenostarchimages1137513.png)，`sleep_thread`
    ![通过 `kproc_exit` 自终止](httpatomoreillycomsourcenostarchimages1137515.png)。
- en: sysctl_debug_sleep_test Function
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sysctl_debug_sleep_test 函数
- en: The `sysctl_debug_sleep_test` function obtains events from the sysctl `debug.sleep.test`.
    It then passes those events to the `sleep_thread` function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysctl_debug_sleep_test` 函数从 sysctl `debug.sleep.test` 获取事件。然后，它将这些事件传递给 `sleep_thread`
    函数。'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    obtaining an event from `debug.sleep.test` and ![](httpatomoreillycomsourcenostarchimages1137501.png)
    storing it in `i`. The following ![](httpatomoreillycomsourcenostarchimages1137503.png)
    if statement ensures that the event was obtained successfully. Next, a ![](httpatomoreillycomsourcenostarchimages1137505.png)
    range check is performed on `i`. If `i` is in the allowable range, `event_mtx`
    is ![](httpatomoreillycomsourcenostarchimages1137507.png) acquired and `event`
    is ![](httpatomoreillycomsourcenostarchimages1137509.png) queried to ensure that
    it equals 0.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先通过 ![](httpatomoreillycomsourcenostarchimages1137499.png) 从 `debug.sleep.test`
    获取一个事件并将其存储在 `i` 中。接下来的 ![](httpatomoreillycomsourcenostarchimages1137501.png)
    if 语句确保事件已成功获取。接下来，对 `i` 执行 ![](httpatomoreillycomsourcenostarchimages1137503.png)
    范围检查。如果 `i` 在允许的范围内，则获取 `event_mtx` 并查询 `event` 以确保它等于 0。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If `event` does not equal `0`, something has gone horribly wrong. And if `INVARIANTS`
    is enabled, the kernel panics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `event` 不等于 `0`，则表示出了严重错误。如果启用了 `INVARIANTS`，则内核会崩溃。
- en: Finally, `event` is ![](httpatomoreillycomsourcenostarchimages1137511.png) set
    to `i` and `sleep_thread` is ![](httpatomoreillycomsourcenostarchimages1137513.png)
    unblocked to process it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`event` 被设置为 `i`，`sleep_thread` 被解除阻塞以处理它。
- en: unload Function
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载函数
- en: 'The `unload` function shuts down this KLD. Here is its function definition
    (again):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`unload` 函数关闭这个 KLD。以下是它的函数定义（再次）：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    tearing down the sysctl `debug.sleep.test`. Afterward, `event` is ![](httpatomoreillycomsourcenostarchimages1137501.png)
    set to -`1` and `sleep_thread` is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    unblocked to process it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先通过 ![](httpatomoreillycomsourcenostarchimages1137499.png) 拆除 sysctl `debug.sleep.test`。之后，`event`
    被设置为 -`1`，`sleep_thread` 被解除阻塞以处理它。
- en: Recall that if event is `−1`, `sleep_thread` self-terminates via `kproc_exit`.
    Note that `kproc_exit` executes `wakeup` on its caller’s process handle before
    returning. This is why `unload` ![](httpatomoreillycomsourcenostarchimages1137505.png)
    sleeps on the channel ![](httpatomoreillycomsourcenostarchimages1137507.png) `kthread`,
    because it contains `sleep_thread`’s process handle.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，如果事件是 `-1`，则 `sleep_thread` 通过 `kproc_exit` 自行终止。注意，`kproc_exit` 在返回之前在其调用者的进程句柄上执行
    `wakeup`。这就是为什么 `unload` ![](httpatomoreillycomsourcenostarchimages1137505.png)
    在 `kthread` 通道上睡眠的原因，因为它包含 `sleep_thread` 的进程句柄。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Recall that `load` saved `sleep_thread`’s process handle in `kthread`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`load` 在 `kthread` 中保存了 `sleep_thread` 的进程句柄。
- en: As `unload` sleeps (at ![](httpatomoreillycomsourcenostarchimages1137505.png))
    until `sleep_thread` exits, it cannot destroy ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `event_mtx` and ![](httpatomoreillycomsourcenostarchimages1137511.png) `event_cv`
    while they’re still in use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `unload` 在 (at ![](httpatomoreillycomsourcenostarchimages1137505.png)) 睡觉直到
    `sleep_thread` 退出，它不能在它们仍在使用时销毁 ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `event_mtx` 和 ![](httpatomoreillycomsourcenostarchimages1137511.png) `event_cv`。
- en: Don’t Panic
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要慌张
- en: 'Here are the results from loading and unloading [Example 5-1](ch05s02.html#sleep.c
    "Example 5-1. sleep.c"):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是加载和卸载 [示例 5-1](ch05s02.html#sleep.c "示例 5-1. sleep.c") 的结果：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Naturally, it works. Now, let’s look at some other ways to delay execution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，它工作得很好。现在，让我们看看其他延迟执行的方法。
- en: Kernel Event Handlers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核事件处理器
- en: '*Event handlers* allow drivers to register one or more functions to be called
    when an event occurs. As an example, before halting the system, every function
    that is registered with the event handler `shutdown_final` is called. [Table 5-1](ch05s03.html#kernel_event_handlers-id1
    "Table 5-1. Kernel Event Handlers") describes every event handler that is available.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件处理器* 允许驱动程序注册一个或多个函数，当事件发生时调用这些函数。例如，在停止系统之前，所有注册到事件处理器 `shutdown_final`
    的函数都会被调用。[表 5-1](ch05s03.html#kernel_event_handlers-id1 "表 5-1. 内核事件处理器") 描述了所有可用的事件处理器。'
- en: Table 5-1. Kernel Event Handlers
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1. 内核事件处理器
- en: '| Event Handler | Description |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 事件处理器 | 描述 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `acpi_sleep_event` | Registered functions are called when the system is sent
    to sleep. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `acpi_sleep_event` | 当系统被发送到睡眠状态时调用已注册的函数。|'
- en: '| `acpi_wakeup_event` | Registered functions are called when the system is
    woken up. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `acpi_wakeup_event` | 当系统唤醒时调用已注册的函数。|'
- en: '| `dev_clone` | Registered functions are called when a solicited item under
    */dev* does not exist; in other words, these functions create device nodes on
    demand. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `dev_clone` | 当在 `/dev` 下的请求项不存在时，注册的函数将被调用；换句话说，这些函数将在需要时创建设备节点。 |'
- en: '| `ifaddr_event` | Registered functions are called when an address is set up
    on a network interface. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `ifaddr_event` | 当在网络上设置地址时，注册的函数将被调用。 |'
- en: '| `if_clone_event` | Registered functions are called when a network interface
    is cloned. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `if_clone_event` | 当网络接口被克隆时，注册的函数将被调用。 |'
- en: '| `ifnet_arrival_event` | Registered functions are called when a new network
    interface appears. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `ifnet_arrival_event` | 当出现新的网络接口时，注册的函数将被调用。 |'
- en: '| `ifnet_departure_event` | Registered functions are called when a network
    interface is taken down. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `ifnet_departure_event` | 当网络接口被移除时，注册的函数将被调用。 |'
- en: '| `power_profile_change` | Registered functions are called when the system’s
    power profile changes. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `power_profile_change` | 当系统电源配置文件更改时，注册的函数将被调用。 |'
- en: '| `process_exec` | Registered functions are called when a process issues an
    `exec` operation. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `process_exec` | 当进程执行 `exec` 操作时，注册的函数将被调用。 |'
- en: '| `process_exit` | Registered functions are called when a process exits. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `process_exit` | 当进程退出时，注册的函数将被调用。 |'
- en: '| `process_fork` | Registered functions are called when a process forks. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `process_fork` | 当进程进行分叉时，注册的函数将被调用。 |'
- en: '| `shutdown_pre_sync` | Registered functions are called when the system is
    shut down before any filesystems are synchronized. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `shutdown_pre_sync` | 在任何文件系统同步之前，系统关闭时，注册的函数将被调用。 |'
- en: '| `shutdown_post_sync` | Registered functions are called when the system is
    shut down after every filesystem is synchronized. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `shutdown_post_sync` | 在所有文件系统同步后，系统关闭时，注册的函数将被调用。 |'
- en: '| `shutdown_final` | Registered functions are called before halting the system.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `shutdown_final` | 在系统停止之前，注册的函数将被调用。 |'
- en: '| `vm_lowmem` | Registered functions are called when virtual memory is low.
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `vm_lowmem` | 当虚拟内存不足时，注册的函数将被调用。 |'
- en: '| `watchdog_list` | Registered functions are called when the watchdog timer
    is reinitialized. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `watchdog_list` | 当看门狗定时器被重新初始化时，注册的函数将被调用。 |'
- en: 'The FreeBSD kernel provides the following three macros for working with event
    handlers:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 内核提供了以下三个宏来处理事件处理器：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `EVENTHANDLER_REGISTER` macro registers the function ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `func` with the event handler ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `name`. If successful, an ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `eventhandler_tag` is returned. When `func` is called, ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `arg` will be its first argument. Functions registered with `name` are called
    in order of ![](httpatomoreillycomsourcenostarchimages1137507.png) `priority`.
    `priority` can be 0 (which is the highest priority) to `20000` (which is the lowest
    priority).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`EVENTHANDLER_REGISTER` 宏将函数 `func` 与事件处理器 `name` 注册。如果成功，将返回一个 `eventhandler_tag`。当
    `func` 被调用时，`arg` 将是其第一个参数。使用 `name` 注册的函数将按照 `priority` 的顺序被调用。`priority` 的值可以从
    0（最高优先级）到 `20000`（最低优先级）。'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generally, I use the constant `EVENTHANDLER_PRI_ANY`, which equals `10000`,
    for `priority`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我使用常量 `EVENTHANDLER_PRI_ANY`，其值为 `10000`，作为 `priority`。
- en: The `EVENTHANDLER_DEREGISTER` macro deletes the function associated with ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `tag` from the event handler ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `name` (where `tag` is an ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `eventhandler_tag`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`EVENTHANDLER_DEREGISTER` 宏用于从事件处理器 `name` 中删除与 `tag` 相关的函数（其中 `tag` 是一个 `eventhandler_tag`）。'
- en: The `EVENTHANDLER_INVOKE` macro executes every function registered with the
    event handler ![](httpatomoreillycomsourcenostarchimages1137513.png) `name`. Note
    that you’ll never call `EVENTHANDLER_INVOKE`, because each event handler has threads
    dedicated to do just that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`EVENTHANDLER_INVOKE` 宏执行与事件处理器 `name` 注册的所有函数。请注意，您永远不会调用 `EVENTHANDLER_INVOKE`，因为每个事件处理器都有专门的线程来执行这项任务。'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We’ll walk through an example that uses event handlers in [Chapter 6](ch06.html
    "Chapter 6. Case Study: Virtual Null Modem").'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 6 章](ch06.html "第 6 章。案例研究：虚拟空调制解调器") 中通过一个示例来讲解如何使用事件处理器。
- en: Callouts
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旁注
- en: '*Callouts* allow drivers to asynchronously execute a function after a specified
    amount of time (or at regular intervals). These functions are known as *callout
    functions*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用* 允许驱动程序在指定的时间（或定期间隔）后异步执行一个函数。这些函数被称为 *调用函数*。'
- en: 'The FreeBSD kernel provides the following seven functions for working with
    callouts:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 内核提供了以下七个函数用于处理调用：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `callout_init` function initializes the `callout` structure ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `c`. The ![](httpatomoreillycomsourcenostarchimages1137501.png) `mpsafe` argument
    denotes whether the callout function is “multiprocessor safe.” Valid values for
    this argument are shown in [Table 5-2](ch05s04.html#callout_underscore_init_symbolic_constan
    "Table 5-2. callout_init Symbolic Constants").
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_init` 函数初始化 `callout` 结构 ![图片](httpatomoreillycomsourcenostarchimages1137499.png)
    `c`。![图片](httpatomoreillycomsourcenostarchimages1137501.png) `mpsafe` 参数表示调用函数是否是“多处理器安全的”。此参数的有效值显示在
    [表 5-2](ch05s04.html#callout_underscore_init_symbolic_constan "表 5-2. callout_init
    符号常量") 中。'
- en: Table 5-2. callout_init Symbolic Constants
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2. callout_init 符号常量
- en: '| Constant | Description |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` | The callout function is *not* multiprocessor safe; the `Giant` mutex
    is acquired before executing the callout function, and it’s dropped after the
    callout function returns. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 调用函数不是 *多处理器安全的*；在执行调用函数之前获取 `Giant` 锁，在调用函数返回后释放。 |'
- en: '| `CALLOUT_MPSAFE` | The callout function is multiprocessor safe; in other
    words, race conditions are dealt with by the callout function itself. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `CALLOUT_MPSAFE` | 调用函数是多处理器安全的；换句话说，竞态条件由调用函数本身处理。 |'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, `Giant` is acquired and dropped by the callout subsystem. `Giant` primarily
    protects legacy code and should not be used by contemporary code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Giant` 由调用子系统获取和释放。`Giant` 主要保护旧代码，不应由现代代码使用。
- en: The `callout_init_mtx` function is an alternative to `callout_init`. The mutex
    ![](httpatomoreillycomsourcenostarchimages1137503.png) `mtx` is acquired before
    executing the callout function and it’s dropped after the callout function returns
    (`mtx` is acquired and dropped by the callout subsystem). After `callout_init_mtx`
    returns, `mtx` is associated with the `callout` structure `c` and its callout
    function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_init_mtx` 函数是 `callout_init` 的替代方案。在执行调用函数之前，会获取 mutex ![图片](httpatomoreillycomsourcenostarchimages1137503.png)
    `mtx`，并在调用函数返回后释放它（`mtx` 由调用子系统获取和释放）。在 `callout_init_mtx` 返回后，`mtx` 与 `callout`
    结构 `c` 及其调用函数相关联。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137505.png) `flags` argument
    modifies `callout_init_mtx’s` behavior. [Table 5-3](ch05s04.html#callout_underscore_init_underscore_mtx_s
    "Table 5-3. callout_init_mtx Symbolic Constants") displays its only valid value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](httpatomoreillycomsourcenostarchimages1137505.png) `flags` 参数修改 `callout_init_mtx`
    的行为。[表 5-3](ch05s04.html#callout_underscore_init_underscore_mtx_s "表 5-3. callout_init_mtx
    符号常量") 显示了其唯一的有效值。'
- en: Table 5-3. callout_init_mtx Symbolic Constants
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-3. callout_init_mtx 符号常量
- en: '| Constant | Description |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CALLOUT_RETURNUNLOCKED` | Indicates that the callout function will drop
    mtx itself; in other words, `mtx` is not dropped after the callout function returns,
    but during. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `CALLOUT_RETURNUNLOCKED` | 表示调用函数将自行释放 mtx；换句话说，在调用函数返回后不会释放 mtx，而是在函数执行期间释放。
    |'
- en: The `callout_init_rw` function is an alternative to `callout_init`. The rw lock
    ![](httpatomoreillycomsourcenostarchimages1137507.png) `rw` is acquired, as a
    writer, before executing the callout function and it’s dropped after the callout
    function returns (`rw` is acquired and dropped by the callout subsystem). After
    `callout_init_rw` returns, `rw` is associated with the `callout` structure `c`
    and its callout function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_init_rw` 函数是 `callout_init` 的替代方案。在执行调用函数之前，作为写者，会获取 rw 锁 ![图片](httpatomoreillycomsourcenostarchimages1137507.png)
    `rw`，并在调用函数返回后释放它（`rw` 由调用子系统获取和释放）。在 `callout_init_rw` 返回后，`rw` 与 `callout` 结构
    `c` 及其调用函数相关联。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137509.png) `flags` argument
    modifies `callout_init_rw`’s behavior. [Table 5-4](ch05s04.html#callout_underscore_init_underscore_rw_sy
    "Table 5-4. callout_init_rw Symbolic Constants") displays its only valid value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](httpatomoreillycomsourcenostarchimages1137509.png) `flags` 参数修改 `callout_init_rw`
    的行为。[表 5-4](ch05s04.html#callout_underscore_init_underscore_rw_sy "表 5-4. callout_init_rw
    符号常量") 显示了其唯一的有效值。'
- en: Table 5-4. callout_init_rw Symbolic Constants
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-4. callout_init_rw 符号常量
- en: '| Constant | Description |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CALLOUT_SHAREDLOCK` | Causes `rw` to be acquired as a reader |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `CALLOUT_SHAREDLOCK` | 导致 `rw` 以读取者的身份获取 |'
- en: The `callout_stop` function cancels a callout function that’s currently pending.
    If successful, a nonzero value is returned. If 0 is returned, the callout function
    is either currently executing or it has already finished executing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_stop` 函数取消当前挂起的调用函数。如果成功，返回非零值。如果返回 0，则调用函数目前正在执行或已经完成执行。'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must exclusively hold the lock associated with the callout function that
    you’re trying to stop before calling `callout_stop`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `callout_stop` 之前，你必须独占持有你试图停止的调用函数相关的锁。
- en: The `callout_drain` function is identical to `callout_stop` except that if the
    callout function is currently executing, it waits for the callout function to
    finish before returning. If the callout function that you’re trying to stop requires
    a lock and you’re exclusively holding that lock while calling `callout_drain`,
    deadlock will result.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_drain` 函数与 `callout_stop` 相同，除了如果调用函数目前正在执行，它将等待调用函数完成后再返回。如果你试图停止的调用函数需要一个锁，并且你在调用
    `callout_drain` 时独占持有该锁，则会导致死锁。'
- en: The `callout_reset` function schedules the function ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `func` to be executed, one time, after ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `ticks` / `hz` seconds; negative values for `ticks` are converted to `1`. When
    func is called, ![](httpatomoreillycomsourcenostarchimages1137517.png) `arg` will
    be its first and only argument. After `callout_reset` returns, `func` is the callout
    function for the callout structure ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `c`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_reset` 函数安排函数 ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `func` 在 ![](httpatomoreillycomsourcenostarchimages1137513.png) `ticks` / `hz`
    秒后执行一次；对于 `ticks` 的负值转换为 `1`。当 `func` 被调用时，![](httpatomoreillycomsourcenostarchimages1137517.png)
    `arg` 将是其第一个也是唯一的参数。在 `callout_reset` 返回后，`func` 是调用结构 ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `c` 的调用函数。'
- en: The `callout_reset` function can also reschedule a pending callout function
    to execute at a new time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_reset` 函数也可以将挂起的调用函数重新安排在新的时间执行。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must exclusively hold the lock associated with the callout or callout function
    that you’re trying to establish or reschedule before calling `callout_reset`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `callout_reset` 之前，你必须独占持有你试图建立或重新安排的调用或调用函数相关的锁。
- en: The `callout_schedule` function reschedules a pending callout function to execute
    at a new time. This function is simply a convenience wrapper for `callout_reset`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`callout_schedule` 函数将挂起的调用函数重新安排在新的时间执行。这个函数仅仅是 `callout_reset` 的便利包装器。'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must exclusively hold the lock associated with the callout function that
    you’re trying to reschedule before calling `callout_schedule`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `callout_schedule` 之前，你必须独占持有你试图重新安排的调用函数相关的锁。
- en: Callouts and Race Conditions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用和竞争条件
- en: 'Because callout functions execute asynchronously, it’s possible for a callout
    function to be called while another thread attempts to stop or reschedule it;
    thus creating a race condition. Fortunately, there are two simple solutions available
    for solving this problem:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为调用函数是异步执行的，所以有可能在另一个线程尝试停止或重新安排它时调用调用函数；从而创建竞争条件。幸运的是，有两个简单的解决方案可以解决这个问题：
- en: '**Use** **`callout_init_mtx`**, **`callout_init_rw`**, **or** **`callout_init(foo,
    0)`**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用** **`callout_init_mtx`**、**`callout_init_rw`**、**或** **`callout_init(foo,
    0)`**'
- en: Callout functions associated with a lock are exempt from the race condition
    described above—as long as the associated lock is held before calling the callout
    management functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与锁关联的调用函数免于上述提到的竞争条件——只要在调用调用管理函数之前持有相关的锁。
- en: '**Use** **`callout_drain`** **to permanently cancel a callout function**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用** **`callout_drain`** **永久取消调用函数**'
- en: Use `callout_drain` instead of `callout_stop` to permanently cancel a callout
    function. See, by waiting for the callout function to finish, you can’t destroy
    any objects that it might need.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `callout_drain` 而不是 `callout_stop` 来永久取消调用函数。注意，通过等待调用函数完成，你无法销毁它可能需要的任何对象。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We’ll walk through an example that uses callouts in [Chapter 6](ch06.html "Chapter 6. Case
    Study: Virtual Null Modem").'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](ch06.html "第6章. 案例研究：虚拟空调制解调器")中通过一个使用调用的示例来讲解。
- en: Taskqueues
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务队列
- en: '*Taskqueues* allow drivers to schedule the asynchronous execution of one or
    more functions at a later time. These functions are known as *tasks*. Taskqueues
    are primarily used for deferred work.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务队列* 允许驱动程序在稍后时间异步执行一个或多个函数。这些函数被称为 *任务*。任务队列主要用于延迟工作。'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Taskqueues are like callouts except that you can’t specify the time to execute
    your functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 任务队列类似于回调，但你不能指定执行函数的时间。
- en: Taskqueues work by having tasks queued on them. Intermittently, these tasks
    get executed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 任务队列通过将任务排队在其上工作。这些任务会间歇性地执行。
- en: Global Taskqueues
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局任务队列
- en: 'FreeBSD runs and maintains four global taskqueues:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 运行并维护四个全局任务队列：
- en: '**`taskqueue_swi`**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**`taskqueue_swi`**'
- en: The `taskqueue_swi` taskqueue executes its tasks in the context of an interrupt.
    Interrupt handlers typically defer their computationally expensive work to this
    taskqueue. This taskqueue lets interrupt handlers finish sooner, thereby reducing
    the amount of time spent with interrupts disabled. Interrupt handlers are discussed
    in detail in [Chapter 8](ch08.html "Chapter 8. Interrupt Handling").
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskqueue_swi` 任务队列在中断上下文中执行其任务。中断处理程序通常将计算密集型工作推迟到这个任务队列。这个任务队列让中断处理程序更快完成，从而减少了中断禁用的时间。中断处理程序在[第
    8 章](ch08.html "第 8 章。中断处理")中详细讨论。'
- en: '**`taskqueue_swi_giant`**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**`taskqueue_swi_giant`**'
- en: The `taskqueue_swi_giant` taskqueue is identical to `taskqueue_swi` except that
    it acquires the `Giant` mutex before executing its tasks. Contemporary code should
    avoid this taskqueue.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskqueue_swi_giant` 任务队列与 `taskqueue_swi` 相同，只是在执行任务之前会获取 `Giant` 锁。现代代码应避免使用此任务队列。'
- en: '**`taskqueue_thread`**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**`taskqueue_thread`**'
- en: The `taskqueue_thread` taskqueue is the general-purpose taskqueue. It executes
    its tasks in the context of a kernel thread (which is the same context that drivers
    execute in). You can use this taskqueue when you have code that executes without
    a thread context (such as an interrupt handler) that needs to execute code that
    requires a thread context.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskqueue_thread` 任务队列是通用任务队列。它在内核线程的上下文中执行其任务（与驱动程序执行的上下文相同）。当你有代码需要在没有线程上下文的情况下执行（例如中断处理程序）且需要执行需要线程上下文的代码时，可以使用此任务队列。'
- en: '**`taskqueue_fast`**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**`taskqueue_fast`**'
- en: The `taskqueue_fast` taskqueue is identical to `taskqueue_thread` except that
    it acquires a spin mutex before executing its tasks. Use this taskqueue when your
    tasks cannot sleep.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskqueue_fast` 任务队列与 `taskqueue_thread` 相同，只是在执行任务之前会获取自旋锁。当你的任务不能睡眠时，使用此任务队列。'
- en: Taskqueue Management Routines
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务队列管理例程
- en: 'The FreeBSD kernel provides the following macro and functions for working with
    taskqueues:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 内核提供了以下宏和函数来处理任务队列：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `TASK_INIT` macro initializes the `task` structure ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `task`. The ![](httpatomoreillycomsourcenostarchimages1137503.png) `priority`
    argument is `task`’s position on a taskqueue. The ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `func` argument is the function to be executed (one time). When `func` is called,
    ![](httpatomoreillycomsourcenostarchimages1137507.png) `context` will be its first
    argument and the value of ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `ta_pending` will be its second.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`TASK_INIT` 宏初始化 `task` 结构！[](http://atomoreilly.com/source/no_starch_images/1137501.png)`task`。`priority`
    参数是 `task` 在任务队列中的位置。`func` 参数是要执行的函数（一次）。当 `func` 被调用时，`context` 将是其第一个参数，而 `ta_pending`
    的值将是其第二个。'
- en: The `taskqueue_enqueue` function puts ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `task` on the taskqueue ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `queue` right before the first `task` structure that has a lower `priority` value.
    If `taskqueue_enqueue` gets called to put `task` on `queue` again, `task`’s `ta_pending`
    value is incremented—another copy of `task` is *not* put on `queue`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskqueue_enqueue` 函数将！[](http://atomoreilly.com/source/no_starch_images/1137511.png)`task`
    放在任务队列！[](http://atomoreilly.com/source/no_starch_images/1137509.png)`queue` 中，位于具有较低
    `priority` 值的第一个 `task` 结构之前。如果 `taskqueue_enqueue` 被调用再次将 `task` 放在 `queue` 上，`task`
    的 `ta_pending` 值会增加——不会在 `queue` 上放置 `task` 的另一个副本。'
- en: The `taskqueue_run` function executes every task on the taskqueue ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `queue` in the order of the task’s `priority` value. After each task finishes,
    its `task` structure is removed from `queue`. Then its `ta_pending` value is zeroed
    and `wakeup` is called on its `task` structure. Note that you’ll never call `taskqueue_run`,
    because each taskqueue has threads dedicated to do just that.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskqueue_run` 函数按照任务的 `优先级` 值的顺序执行任务队列 ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `队列` 中的每个任务。每个任务完成后，其 `task` 结构从 `队列` 中移除。然后将其 `ta_pending` 值置零，并在其 `task` 结构上调用
    `wakeup`。请注意，你永远不会调用 `taskqueue_run`，因为每个任务队列都有线程专门用于执行这项任务。'
- en: The `taskqueue_drain` function waits for ![](httpatomoreillycomsourcenostarchimages1137517.png)
    task, which is on ![](httpatomoreillycomsourcenostarchimages1137515.png) `queue`,
    to finish executing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskqueue_drain` 函数等待 ![](httpatomoreillycomsourcenostarchimages1137517.png)
    任务完成，该任务位于 ![](httpatomoreillycomsourcenostarchimages1137515.png) `队列` 中。'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We’ll walk through an example that uses taskqueues in [Chapter 6](ch06.html
    "Chapter 6. Case Study: Virtual Null Modem").'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](ch06.html "第6章。案例研究：虚拟空调制解调器")中通过一个使用任务队列的示例进行说明。
- en: Conclusion
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'This chapter covered the four different methods for delaying execution:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了四种不同的延迟执行方法：
- en: '| **Sleeping** Sleeping is done when you must wait for something to occur before
    you can proceed. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **休眠** 当你必须等待某些事情发生才能继续时，会进行休眠。|'
- en: '| **Event Handlers** Event handlers let you register one or more functions
    to be executed when an event occurs. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **事件处理器** 事件处理器允许你注册一个或多个函数，以便在事件发生时执行。|'
- en: '| **Callouts** Callouts let you perform asyn chronous code execution. Callouts
    are used to execute your functions at a specific time. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **调用** 调用允许你执行异步代码执行。调用用于在特定时间执行你的函数。|'
- en: '| **Taskqueues** Taskqueues also let you perform asynchronous code execution.
    Taskqueues are used for deferred work. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **任务队列** 任务队列也允许你执行异步代码。任务队列用于延迟工作。|'
