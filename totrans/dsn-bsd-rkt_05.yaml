- en: Chapter 5. RUN-TIME KERNEL MEMORY PATCHING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters we looked at the classic method of introducing code
    into a running kernel: through a loadable kernel module. In this chapter we''ll
    look at how to patch and augment a running kernel with userland code. This is
    accomplished by interacting with the /dev/kmem device, which allows us to read
    from and write to kernel virtual memory. In other words, /dev/kmem allows us to
    patch the various code bytes (loaded in executable memory space) that control
    the logic of the kernel. This is commonly referred to as *run-time kernel memory
    patching*.'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Data Access Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kernel Data Access Library (libkvm) provides a uniform interface for accessing
    kernel virtual memory through the /dev/kmem device. The following six functions
    from libkvm form the basis of run-time kernel memory patching.
  prefs: []
  type: TYPE_NORMAL
- en: The kvm_openfiles Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access to kernel virtual memory is initialized by calling the `kvm_openfiles`
    function. If `kvm_openfiles` is successful, a descriptor is returned to be used
    in all subsequent libkvm calls. If an error is encountered, `NULL` is returned
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function prototype for `kvm_openfiles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The following is a brief description of each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**`execfile`**'
  prefs: []
  type: TYPE_NORMAL
- en: This specifies the kernel image to be examined, which must contain a symbol
    table. If this parameter is set to `NULL`, the currently running kernel image
    is examined.
  prefs: []
  type: TYPE_NORMAL
- en: '**`corefile`**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the kernel memory device file; it must be set to either /dev/mem or
    a crash dump core generated by `savecore(8)`. If this parameter is set to `NULL`,
    /dev/mem is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**`swapfile`**'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter is currently unused; thus, it's always set to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`flags`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This parameter indicates the read/write access permissions for the core file.
    It must be set to one of the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`O_RDONLY`**'
  prefs: []
  type: TYPE_NORMAL
- en: Open for reading only.
  prefs: []
  type: TYPE_NORMAL
- en: '**`O_WRONLY`**'
  prefs: []
  type: TYPE_NORMAL
- en: Open for writing only.
  prefs: []
  type: TYPE_NORMAL
- en: '**`O_RDWR`**'
  prefs: []
  type: TYPE_NORMAL
- en: Open for reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: '**`errbuf`**'
  prefs: []
  type: TYPE_NORMAL
- en: If `kvm_openfiles` encounters an error, an error message is written into this
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The kvm_nlist Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `kvm_nlist` function retrieves the symbol table entries from a kernel image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `nl` is a null-terminated array of `nlist` structures. To make proper
    use of `kvm_nlist`, you'll need to know two fields in `struct nlist`, specifically
    `n_name`, which is the name of a symbol loaded in memory, and `n_value`, which
    is the address of the symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The `kvm_nlist` function iterates through `nl`, looking up each symbol in turn
    through the `n_name` field; if found, `n_value` is filled out appropriately. Otherwise,
    it is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The kvm_geterr Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `kvm_geterr` function returns a string describing the most recent error
    condition on a kernel virtual memory descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The results are undefined if the most recent libkvm call did not produce an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The kvm_read Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data is read from kernel virtual memory with the `kvm_read` function. If the
    read is successful, the number of bytes transferred is returned. Otherwise, `−1`
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `nbytes` indicates the number of bytes to be read from the kernel space
    address `addr` to the buffer `buf`.
  prefs: []
  type: TYPE_NORMAL
- en: The kvm_write Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data is written to kernel virtual memory with the `kvm_write` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The return value is usually equal to the `nbytes` argument, unless an error
    has occurred, in which case `−1` is returned instead. In this definition, `nbytes`
    indicates the number of bytes to be written to `addr` from `buf`.
  prefs: []
  type: TYPE_NORMAL
- en: The kvm_close Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An open kernel virtual memory descriptor is closed by calling the `kvm_close`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If `kvm_close` is successful, `0` is returned. Otherwise, `−1` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Patching Code Bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, equipped with the functions from the previous section, let's patch some
    kernel virtual memory. I'll start with a very basic example. Listing 5-1 is a
    system call module that acts like an over-caffeinated "Hello, world!" function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: hello.c*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if we execute this system call, we'll get some very annoying
    output. To make this system call less annoying, we can patch out ❶ the `for` loop,
    which will remove the nine additional calls to `printf`. However, before we can
    do that, we'll need to know what this system call looks like when it's loaded
    in main memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary *`hello.ko`* was compiled explicitly without the *`-funroll-loops`*
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the instruction at address 49d, which causes the instruction pointer
    to jump back to address 490 if the sign flag is not set. This instruction is,
    more or less, the `for` loop in hello.c. Therefore, if we `nop` it out, we can
    make the `hello` system call somewhat bearable. The program in Listing 5-2 does
    just that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-2: fix_hello.c*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how ❶ I search through the first 48 bytes of `hello`, looking for the
    `jns` instruction, instead of using a hard-coded offset. Depending on your compiler
    version, compiler flags, base system, and so on, it is entirely possible for hello.c
    to compile differently. Therefore, it's useless to determine the location of `jns`
    ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it's possible that when compiled, hello.c will not even include a `jns`
    instruction, as there are multiple ways to represent a `for` loop in machine code.
    Furthermore, recall that the disassembly of `hello.ko` identified two instructions
    that require dynamic relocation. This means that the first 0×79 byte encountered
    may be part of those instructions, and not the actual `jns` instruction. That's
    why this is an example and not a real program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get around these problems, use longer and/or more search signatures. You
    could also use hard-coded offsets, but your code would break on some systems.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting detail worth mentioning is that when I patch `hello` with
    `kvm_write`, I ❷ pass `sizeof(nop_code) - 1`, not `sizeof(nop_code)`, as the `nbytes`
    argument. In C, character arrays are null terminated; therefore, `sizeof(nop_code)`
    returns three. However, I only want to write two `nop`s, not two `nop`s and a
    `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the results of executing `hello` before and after
    running `fix_hello` on ttyv0 (i.e., the system console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Success! Now let's try something a little more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding *x*86 Call Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *x*86 assembly the `call` statement is a control transfer instruction used
    to call a function or procedure. There are two types of `call` statements: `near`
    and `far`. For our purposes, we only need to understand `near call` statements.
    The following (contrived) code segment illustrates the details of a `near call`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the above code snippet, when the instruction pointer reaches address 205—the
    `call` statement—it will jump to address 300\. The hexadecimal representation
    for a `call` statement is `e8`. However, `f6 00 00 00` is obviously not `300`.
    At first glance, it appears that the machine code and assembly code don't match,
    but in fact, they do. In a `near call`, the address of the instruction after the
    `call` statement is saved on the stack, so that the called procedure knows where
    to return to. Thus, the machine code operand for a `call` statement is the address
    of the called procedure, minus the address of the instruction following the `call`
    statement (`0×300` – `0×20a` = `0xf6`). This explains why the machine code operand
    for `call` is `f6 00 00 00` in this example, not `00 03 00 00`. This is an important
    point that will come into play shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Patching Call Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going back to Listing 5-1, let's say that when we `nop` out the `for` loop,
    we also want `hello` to call `uprintf` instead of `printf`. The program in Listing
    5-3 patches `hello` to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-3: fix_hello_improved.c*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how `hello` is patched to invoke `uprintf` instead of `printf`. First,
    the addresses of `hello` and `uprintf` are ❶ stored in `nl[0].n_value` and `nl[1].n_value`,
    respectively. Next, the relative address of `call` within `hello` is ❷ stored
    in `call_offset`. Then, a new `call` statement operand is calculated by subtracting
    ❹ the address of the instruction following `call` from ❸ the address of `uprintf`.
    This value is stored in `call_operand[]`. Finally, the old `call` statement operand
    is ❺ overwritten with `call_operand[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the results of executing `hello`, before and after
    running `fix_hello_improved` on ttyv1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Success! At this point, you should have no trouble patching any kernel code
    byte. However, what happens when the patch you want to apply is too big and will
    overwrite nearby instructions that you require? The answer is . . .
  prefs: []
  type: TYPE_NORMAL
- en: Allocating Kernel Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section I'll describe a set of core functions and macros used to allocate
    and deallocate kernel memory. We'll put these functions to use later on, when
    we explicitly solve the problem outlined above.
  prefs: []
  type: TYPE_NORMAL
- en: The malloc Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `malloc` function allocates a specified number of bytes of memory in kernel
    space. If successful, a kernel virtual address (that is suitably aligned for storage
    of any data object) is returned. If an error is encountered, `NULL` is returned
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function prototype for `malloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following is a brief description of each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`size`'
  prefs: []
  type: TYPE_NORMAL
- en: This specifies the amount of uninitialized kernel memory to allocate.
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter is used to perform statistics on memory usage and for basic sanity
    checks. (Memory statistics can be viewed by running the command `vmstat -m`.)
    Typically, I'll set this parameter to `M_TEMP`, which is the `malloc_type` for
    miscellaneous temporary data buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more on *`struct malloc_type`*, see the malloc(9) manual page.
  prefs: []
  type: TYPE_NORMAL
- en: '**`flags`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This parameter further qualifies `malloc`''s operational characteristics. It
    can be set to any of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`M_ZERO`**'
  prefs: []
  type: TYPE_NORMAL
- en: This causes the allocated memory to be set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**`M_NOWAIT`**'
  prefs: []
  type: TYPE_NORMAL
- en: This causes `malloc` to return `NULL` if the allocation request cannot be fulfilled
    immediately. This flag should be set when calling `malloc` in an interrupt context.
  prefs: []
  type: TYPE_NORMAL
- en: '**`M_WAITOK`**'
  prefs: []
  type: TYPE_NORMAL
- en: This causes `malloc` to sleep and wait for resources if the allocation request
    cannot be fulfilled immediately. If this flag is set, `malloc` cannot return `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Either `M_NOWAIT` or `M_WAITOK` must be specified.
  prefs: []
  type: TYPE_NORMAL
- en: The MALLOC Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For compatibility with legacy code, the `malloc` function is called with the
    `MALLOC` macro, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro is functionally equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The free Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deallocate kernel memory that was previously allocated by `malloc`, call
    the `free` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `addr` is the memory address returned by a previous `malloc` call, and
    `type` is its associated `malloc_type`.
  prefs: []
  type: TYPE_NORMAL
- en: The FREE Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For compatibility with legacy code, the `free` function is called with the
    `FREE` macro, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro is functionally equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At some point in 4BSD's history, part of its *`malloc`* algorithm was inline
    in a macro, which is why there is a *`MALLOC`* macro in addition to a function
    call.^([[1](#ftn.CHP-5-FN-1)]) However, FreeBSD's *`malloc`* algorithm is just
    a function call. Thus, unless you are writing legacy-compatible code, the use
    of the *`MALLOC`* and *`FREE`* macros is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing 5-4 shows a system call module designed to allocate kernel memory.
    The system call is invoked with two arguments: a long integer containing the amount
    of memory to allocate and a long integer pointer to store the returned address.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-4: kmalloc.c*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this code simply ❶ calls the `MALLOC` macro to allocate `uap->size`
    amount of kernel memory, and then ❷ copies out the returned address to user space.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-5 is the user space program designed to execute the system call above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-5: interface.c*'
  prefs: []
  type: TYPE_NORMAL
- en: This program uses the `modstat`/`modfind` approach (described in [Chapter 1](ch01.html
    "Chapter 1. LOADABLE KERNEL MODULES")) to pass the first command-line argument
    to `kmalloc`; this argument should contain the amount of kernel memory to allocate.
    It then outputs the kernel virtual address where the recently allocated memory
    is located.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-5-FN-1)]) ¹ John Baldwin, personal communication, 2006–2007.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating Kernel Memory from User Space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you''ve seen how to "properly" allocate kernel memory using module
    code, let''s do it using run-time kernel memory patching. Here is the algorithm
    (Cesare, 1998, as cited in sd and devik, 2001) we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the in-memory address of the `mkdir` system call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save `sizeof(kmalloc)` bytes of `mkdir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite `mkdir` with `kmalloc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `mkdir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restore `mkdir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this algorithm, you are basically patching a system call with your own
    code, issuing the system call (which will execute your code instead), and then
    restoring the system call. This algorithm can be used to execute any piece of
    code in kernel space without a KLD.
  prefs: []
  type: TYPE_NORMAL
- en: However, keep in mind that when you overwrite a system call, any process that
    issues or is currently executing the system call will break, resulting in a kernel
    panic. In other words, inherent to this algorithm is a race condition or concurrency
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing 5-6 shows a user space program designed to allocate kernel memory.
    This program is invoked with one command-line argument: an integer containing
    the number of bytes to allocate.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-6: kmalloc_reloaded.c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, the ❶ `kmalloc` function code was generated by disassembling
    the `kmalloc` system call from Listing 5-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `objdump(1)` reports three instructions that require dynamic relocation.
    The first, at offset 10, is ❶ for the address of `M_TEMP`. The second, at offset
    34, is ❷ for the `malloc` call statement operand. And the third, at offset 64,
    is ❸ for the `copyout` call statement operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In kmalloc_reloaded.c, we account for this in our `kmalloc` function code with
    the following five lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `kmalloc` is patched at offset 10 with ❶ the address of `M_TEMP`.
    It is also patched at offsets 34 and 64 with ❷ the address of `malloc` minus ❸
    the address of the instruction following the `malloc` call, and ❹ the address
    of `copyout` minus ❺ the address of the instruction following the `copyout` call,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows `kmalloc_reloaded` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the kernel memory allocation, you can use a kernel-mode debugger
    like `ddb(4)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Inline Function Hooking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall the problem posed at the end of [Patching Call Statements](ch05s03.html#patching_call_statements
    "Patching Call Statements"): What do you do when you want to patch some kernel
    code, but your patch is too big and will overwrite nearby instructions that you
    require? The answer is: You use an inline function hook.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, an inline function hook places an unconditional jump within the
    body of a function to a region of memory under your control. This memory will
    contain the "new" code you want the function to execute, the code bytes that were
    overwritten by the unconditional jump, and an unconditional jump back to the original
    function. This will extend functionality while preserving original behavior. Of
    course, you don't have to preserve the original behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we'll patch the `mkdir` system call with an inline function
    hook so that it will output the phrase "Hello, world!\n" each time it creates
    a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the disassembly of `mkdir` to see where we should
    place the jump, which bytes we need to preserve, and where we should jump back
    to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Because I want to extend the functionality of `mkdir`, rather than change it,
    the best place for the unconditional jump is at the beginning. An unconditional
    jump requires seven bytes. If you overwrite the first seven bytes of `mkdir`,
    the first three instructions will be eliminated, and the fourth instruction (which
    starts at offset six) will be mangled. Therefore, we'll need to save the first
    four instructions (i.e., the first nine bytes) in order to preserve `mkdir`'s
    functionality; this also means that you should jump back to offset nine to resume
    execution from the fifth instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Before committing to this plan, however, let's look at the disassembly of `mkdir`
    on a different machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the two disassemblies are quite different. In fact, this time around
    the fifth instruction starts at offset eight, not nine. If the code were to jump
    back to offset nine, it would most definitely crash this system. What this boils
    down to is that when writing an inline function hook, in general, you'll have
    to avoid using hard-coded offsets if you want to apply the hook to a wide range
    of systems.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the two disassemblies, notice how `mkdir` calls `kern_mkdir`
    every time. Therefore, we can jump back to that (i.e., 0xe8). In order to preserve
    `mkdir`'s functionality, we'll now have to save every byte up to, but not including,
    0xe8.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-7 shows my `mkdir` inline function hook.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To save space, the `kmalloc` function code is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-7: mkdir_patch.c*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, employing an inline function hook is relatively straightforward
    (although it's somewhat lengthy). In fact, the only piece of code you haven't
    seen before is ❶ the `"Hello, world!\n"` function code. It is rather simplistic,
    but there are two important points about it.
  prefs: []
  type: TYPE_NORMAL
- en: First, notice how the first 15 bytes of `hello` are actually data; to be exact,
    these bytes make up the string `Hello, world!\n`. The actual assembly language
    instructions don't start until offset 15\. This is why the unconditional jump
    code, which overwrites `mkdir`, is ❷ set to `addr + 0x0f`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, note `hello`'s final three instructions. The first zeros out the `%eax`
    register, the second cleans up the stack, and the last restores the `%ebp` register.
    This is done so that when `mkdir` actually begins executing, it's as if the hook
    never happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows `mkdir_patch` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because mkdir_patch.c is a simple example, it fails to reveal some typical gotchas
    associated with inline function hooking.
  prefs: []
  type: TYPE_NORMAL
- en: First, by placing an unconditional jump within the body of a function, whose
    behavior you intend to preserve, there is a good chance that you'll cause a kernel
    panic. This is because the unconditional jump code requires the use of a general-purpose
    register; however, it is likely that within the body of a function, all the general-purpose
    registers will already be in use. To get around this, push the register you are
    going to use onto the stack before jumping, and then pop it off after.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if you copy a `call` or jump statement and place it into a different
    region of memory, you can't execute it as is; you have to adjust its operand first.
    This is because a `call` or jump statement's machine code operand is a relative
    address.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's possible for your code to be preempted while patching, and during
    that time, your target function may execute in its incomplete state. Therefore,
    if possible, you should avoid patching with multiple writes.
  prefs: []
  type: TYPE_NORMAL
- en: Cloaking System Call Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before concluding this chapter, let''s take a brief look at a nontrivial application
    for run-time kernel memory patching: cloaking system call hooks. That is, implementing
    a system call hook without patching the system call table or any system call function.
    This is achieved by patching the system call dispatcher with an inline function
    hook so it references a Trojan system call table instead of the original. This
    renders the original table functionless, but maintains its integrity, enabling
    the Trojan table to direct system call requests to any handler you like.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the code to do this is rather lengthy (it's longer than mkdir_patch.c),
    I'll simply explain how it's done and leave the actual code to you.
  prefs: []
  type: TYPE_NORMAL
- en: The system call dispatcher in FreeBSD is `syscall`, which is implemented in
    the file /sys/i386/i386/trap.c as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the interest of saving space, any code irrelevant to this discussion is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In `syscall`, line ❶ references the system call table and stores the address
    of the system call to be dispatched into `callp`. Here is what this line looks
    like disassembled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction loads `curthread`, the currently running thread (i.e.,
    the `%fs` segment register), into `%eax`. The first field in a `thread` structure
    is a pointer to its associated `proc` structure; hence, the second instruction
    loads the current process into `%eax`. The next instruction loads `p_sysent` into
    `%eax`. This can be verified, as the `p_sysent` field (which is a `sysentvec`
    pointer) is located at an offset of 0x1a0 within a `proc` structure. The last
    instruction loads the system call table into `%eax`. This can be verified, as
    the `sv_table` field is located at an offset of 0x4 within a `sysentvec` structure.
    This last line is the one you'll need to scan for and patch. However, be aware
    that, depending on the system, the system call table can be loaded into a different
    general-purpose register.
  prefs: []
  type: TYPE_NORMAL
- en: Also, after Trojaning the system call table, any system call modules that are
    loaded won't work. However, since you now control the system calls responsible
    for loading a module, this can be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: That's about it! All you really need to do is patch one spot. Of course, the
    devil is in the details. (In fact, all the gotchas I listed in [Gotchas](ch05s06.html#gotchas
    "Gotchas") are a direct result of trying to patch that one spot.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you Trojan your own system call table, you'll null the effects of traditional
    system call hooking. In other words, this technique of cloaking system calls can
    be applied defensively.
  prefs: []
  type: TYPE_NORMAL
- en: Concluding Remarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run-time kernel memory patching is one of the strongest techniques for modifying
    software logic. Theoretically, you can use it to rewrite the entire operating
    system on the fly. Furthermore, it's somewhat difficult to detect, depending on
    where you place your patches and whether or not you use inline function hooks.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, a technique to cloak run-time kernel memory patching
    has been published. See "Raising The Bar For Windows Rootkit Detection" by Jamie
    Butler and Sherri Sparks, published in *Phrack* magazine, issue 63\. Although
    this article is written from a Windows perspective, the theory can be applied
    to any *x*86 operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, like most rootkit techniques, run-time kernel memory patching has legitimate
    uses. For example, Microsoft calls it *hot patching* and uses it to patch systems
    without requiring a reboot.
  prefs: []
  type: TYPE_NORMAL
