<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Functionally Solving Problems"><div class="titlepage"><div><div><h1 class="title"><a id="functionally_solving_problems"/>Chapter 10. Functionally Solving Problems</h1></div></div></div><p>In this chapter, we’ll look at a couple of interesting problems, and we’ll think about how to solve them as elegantly as possible using functional programming techniques. This will give you the opportunity to flex your newly acquired Haskell muscles and practice your coding skills.<a id="IDX-CHP-10-0001" class="indexterm"/><a id="IDX-CHP-10-0002" class="indexterm"/><a id="IDX-CHP-10-0003" class="indexterm"/></p><div class="sect1" title="Reverse Polish Notation Calculator"><div class="titlepage"><div><div><h1 class="title"><a id="reverse_polish_notation_calculator"/>Reverse Polish Notation Calculator</h1></div></div></div><p>Usually, when we work with algebraic expressions in school, we write them in an infix manner. For instance, we write <code class="literal">10 - (4 + 3) * 2</code>. Addition (<code class="literal">+</code>), multiplication (<code class="literal">*</code>), and subtraction (<code class="literal">-</code>) are infix operators, just like the infix functions in Haskell (<code class="literal">+ `elem`</code>, and so on). As humans, we can parse this form easily in our minds. The downside is that we need to use parentheses to denote precedence.</p><p>Another way to write algebraic expressions is to use <span class="emphasis"><em>reverse polish notation</em></span>, or <span class="emphasis"><em>RPN</em></span>. In RPN, the operator comes after the numbers, rather than being sandwiched between them. So, instead of writing <code class="literal">4 + 3</code>, we write <code class="literal">4 3 +</code>. But how do we write expressions that contain several operators? For example, how would we write an expression that adds <code class="literal">4</code> and <code class="literal">3</code> and then multiplies that by <code class="literal">10</code>? It’s simple: <code class="literal">4 3 + 10 *</code>. Because <code class="literal">4 3 +</code> is equivalent to <code class="literal">7</code>, that whole expression is the same as <code class="literal">7 10 *</code>.<a id="IDX-CHP-10-0004" class="indexterm"/></p><div class="sect2" title="Calculating RPN Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="calculating_rpn_expressions"/>Calculating RPN Expressions</h2></div></div></div><p>To get a feel for how to calculate RPN expressions, think of a stack of numbers. We go over the expression from left to right. Every time a number is encountered, put it on top of the stack (<span class="emphasis"><em>push</em></span> it onto the stack). When we encounter an operator, we take the two numbers that are on top of the stack (<span class="emphasis"><em>pop</em></span> them), use the operator with those two, and then push the resulting number back onto the stack. When we reach the end of the expression, we should be left with a single number that represents the result (assuming the expression was well formed).</p><p>Let’s see how we would calculate the RPN expression <code class="literal">10 4 3 + 2 * -</code>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>We push <code class="literal">10</code> onto the stack, so the stack consists of <code class="literal">10</code>.</p></li><li class="listitem"><p>The next item is <code class="literal">4</code>, so we push it onto the stack as well. The stack is now <code class="literal">10, 4</code>.</p></li><li class="listitem"><p>We do the same with <code class="literal">3</code>, and the stack is now <code class="literal">10, 4, 3</code>.</p></li><li class="listitem"><p>We encounter an operator: <code class="literal">+</code>. We pop the two top numbers from the stack (so now the stack is just <code class="literal">10</code>), add those numbers together, and push that result to the stack. The stack is now <code class="literal">10, 7</code>.</p></li><li class="listitem"><p>We push <code class="literal">2</code> to the stack, and the stack becomes <code class="literal">10, 7, 2</code>.</p></li><li class="listitem"><p>We encounter another operator. We pop <code class="literal">7</code> and <code class="literal">2</code> off the stack, multiply them, and push that result to the stack. Multiplying <code class="literal">7</code> and <code class="literal">2</code> produces <code class="literal">14</code>, so the stack is now <code class="literal">10, 14</code>.</p></li><li class="listitem"><p>Finally, there’s a <code class="literal">-</code>. We pop <code class="literal">10</code> and <code class="literal">14</code> from the stack, subtract <code class="literal">14</code> from <code class="literal">10</code>, and push that back.</p></li><li class="listitem"><p>The number on the stack is now <code class="literal">-4</code>. Because there are no more numbers or operators in our expression, that’s our result!</p></li></ol></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject10_d1e17709"/><img src="httpatomoreillycomsourcenostarchimages802634.png.jpg" alt="image with no caption"/></div></div><p>So, that’s how to calculate an RPN expression by hand. Now let’s think about how to make a Haskell function to do the same thing.</p></div><div class="sect2" title="Writing an RPN Function"><div class="titlepage"><div><div><h2 class="title"><a id="writing_an_rpn_function"/>Writing an RPN Function</h2></div></div></div><p>Our function will take a string that contains an RPN expression as its parameter (like <code class="literal">"10 4 3 + 2 * -"</code>) and give us back that expression’s result.<a id="IDX-CHP-10-0005" class="indexterm"/><a id="IDX-CHP-10-0006" class="indexterm"/><a id="IDX-CHP-10-0007" class="indexterm"/><a id="IDX-CHP-10-0008" class="indexterm"/><a id="IDX-CHP-10-0009" class="indexterm"/><a id="IDX-CHP-10-0010" class="indexterm"/><a id="IDX-CHP-10-0011" class="indexterm"/><a id="IDX-CHP-10-0012" class="indexterm"/><a id="IDX-CHP-10-0013" class="indexterm"/><a id="IDX-CHP-10-0014" class="indexterm"/></p><p>What would the type of that function be? We want it to take a string as a parameter and produce a number as its result. Let’s say that we want the result to be a floating-point number of double precision, because we want to include division as well. So its type will probably be something like this:</p><a id="I_programlisting10_d1e17769"/><pre class="programlisting">solveRPN :: String -&gt; Double</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>It really helps to first think what the type declaration of a function should be before dealing with the implementation. In Haskell, a function’s type declaration tells you a whole lot about the function, due to the very strong type system.</p></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject10_d1e17775"/><img src="httpatomoreillycomsourcenostarchimages802636.png.jpg" alt="image with no caption"/></div></div><p>When implementing a solution to a problem in Haskell, it can be helpful to consider how you did it by hand. For our RPN expression calculation, we treated every number or operator that was separated by a space as a single item. So it might help us if we start by breaking a string like <code class="literal">"10 4 3 + 2 * -"</code> into a list of items, like this:</p><a id="I_programlisting10_d1e17785"/><pre class="programlisting">["10","4","3","+","2","*","-"].</pre><p>Next up, what did we do with that list of items in our head? We went over it from left to right and kept a stack as we did that. Does that process remind you of anything? In <a class="xref" href="ch05s05.html" title="I Fold You So">I Fold You So</a> in <a class="xref" href="ch05s05.html" title="I Fold You So">I Fold You So</a>, you saw that pretty much any function where you traverse a list element by element, and build up (<span class="emphasis"><em>accumulate</em></span>) some result—whether it’s a number, a list, a stack, or something else—can be implemented with a fold.</p><p>In this case, we’re going to use a left fold, because we go over the list from left to right. The accumulator value will be our stack, so the result from the fold will also be a stack (though as we’ve seen, it will contain only one item).</p><p>One more thing to think about is how we will represent the stack. Let’s use a list and keep the top of our stack at the head of the list. Adding to the head (beginning) of a list is much faster than adding to the end of it. So if we have a stack of, say, <code class="literal">10, 4, 3</code>, we’ll represent that as the list <code class="literal">[3,4,10]</code>.</p><p>Now we have enough information to roughly sketch our function. It’s going to take a string like <code class="literal">"10 4 3 + 2 * -"</code> and break it down into a list of items by using <code class="literal">words</code>. Next, we’ll do a left fold over that list and end up with a stack that has a single item (in this example, <code class="literal">[-4]</code>). We take that single item out of the list, and that’s our final result!</p><p>Here’s a sketch of that function:<a id="IDX-CHP-10-0015" class="indexterm"/><a id="IDX-CHP-10-0016" class="indexterm"/><a id="IDX-CHP-10-0017" class="indexterm"/></p><a id="I_programlisting10_d1e17835"/><pre class="programlisting">solveRPN :: String -&gt; Double
solveRPN expression = head (foldl foldingFunction [] (words expression))
    where  foldingFunction stack item = ...</pre><p>We take the expression and turn it into a list of items. Then we fold over that list of items with the folding function. Notice the <code class="literal">[]</code>, which represents the starting accumulator. The accumulator is our stack, so <code class="literal">[]</code> represents an empty stack, which is what we start with. After getting the final stack with a single item, we apply <code class="literal">head</code> to that list to get the item out.</p><p>All that’s left now is to implement a folding function that will take a stack, like <code class="literal">[4,10]</code>, and an item, like <code class="literal">"3"</code>, and return a new stack <code class="literal">[3,4,10]</code>. If the stack is <code class="literal">[4,10]</code> and the item is <code class="literal">"*"</code>, then the function will need to return <code class="literal">[40]</code>.</p><p>Before we write the folding function, let’s turn our function into point-free style, because it has a lot of parentheses that are kind of freaking me out:<a id="IDX-CHP-10-0018" class="indexterm"/></p><a id="I_programlisting10_d1e17874"/><pre class="programlisting">solveRPN :: String -&gt; Double
solveRPN = head . foldl foldingFunction [] . words
    where  foldingFunction stack item = ...</pre><p>That’s much better.</p><p>The folding function will take a stack and an item and return a new stack. We’ll use pattern matching to get the top items of a stack and to pattern match against operators like <code class="literal">"*"</code> and <code class="literal">"-"</code>. Here it is with the folding function implemented:</p><a id="I_programlisting10_d1e17886"/><pre class="programlisting">solveRPN :: String -&gt; Double
solveRPN = head . foldl foldingFunction [] . words
    where  foldingFunction (x:y:ys) "*" = (y * x):ys
           foldingFunction (x:y:ys) "+" = (y + x):ys
           foldingFunction (x:y:ys) "-" = (y - x):ys
           foldingFunction xs numberString = read numberString:xs</pre><p>We laid this out as four patterns. The patterns will be tried from top to bottom. First, the folding function will see if the current item is <code class="literal">"*"</code>. If it is, then it will take a list like <code class="literal">[3,4,9,3]</code> and name its first two elements <code class="literal">x</code> and <code class="literal">y</code>, respectively. So in this case, <code class="literal">x</code> would be <code class="literal">3</code>, and <code class="literal">y</code> would be <code class="literal">4</code>. <code class="literal">ys</code> would be <code class="literal">[9,3]</code>. It will return a list that’s just like <code class="literal">ys</code>, but with <code class="literal">x</code> and <code class="literal">y</code> multiplied as its head. With this, we pop the two topmost numbers off the stack, multiply them, and push the result back onto the stack. If the item is not <code class="literal">"*"</code>, the pattern matching will fall through, <code class="literal">"+"</code> will be checked, and so on.</p><p>If the item is none of the operators, we assume it’s a string that represents a number. If it’s a number, we just apply <code class="literal">read</code> to that string to get a number from it and return the previous stack but with that number pushed to the top.</p><p>For the list of items <code class="literal">["2","3","+"]</code>, our function will start folding from the left. The initial stack will be <code class="literal">[]</code>. It will call the folding function with <code class="literal">[]</code> as the stack (accumulator) and <code class="literal">"2"</code> as the item. Because that item is not an operator, it will be read and then added to the beginning of <code class="literal">[]</code>. So the new stack is now <code class="literal">[2]</code>. The folding function will be called with <code class="literal">[2]</code> as the stack and <code class="literal">"3"</code> as the item, producing a new stack of <code class="literal">[3,2]</code>. Then it’s called for the third time with <code class="literal">[3,2]</code> as the stack and <code class="literal">"+"</code> as the item. This causes these two numbers to be popped off the stack, added together, and pushed back. The final stack is <code class="literal">[5]</code>, which is the number that we return.<a id="IDX-CHP-10-0019" class="indexterm"/><a id="IDX-CHP-10-0020" class="indexterm"/><a id="IDX-CHP-10-0021" class="indexterm"/><a id="IDX-CHP-10-0022" class="indexterm"/><a id="IDX-CHP-10-0023" class="indexterm"/></p><p>Let’s play around with our function:</p><a id="I_programlisting10_d1e18000"/><pre class="programlisting">ghci&gt; solveRPN "10 4 3 + 2 * -"
-4.0
ghci&gt; solveRPN "2 3.5 +"
5.5
ghci&gt; solveRPN "90 34 12 33 55 66 + * - +"
-3947.0
ghci&gt; solveRPN "90 34 12 33 55 66 + * - + -"
4037.0
ghci&gt; solveRPN "90 3.8 -"
86.2</pre><p>Cool, it works!</p></div><div class="sect2" title="Adding More Operators"><div class="titlepage"><div><div><h2 class="title"><a id="adding_more_operators"/>Adding More Operators</h2></div></div></div><p>One nice thing about this solution is that it can be easily modified to support various other operators. They don’t even need to be binary operators. For instance, we can make an operator <code class="literal">"log"</code> that just pops one number off the stack and pushes back its logarithm. We can also make operators that operate on several numbers, like <code class="literal">"sum"</code>, which pops off all the numbers and pushes back their sum.</p><p>Let’s modify our function to accept a few more operators.</p><a id="I_programlisting10_d1e18017"/><pre class="programlisting">solveRPN :: String -&gt; Double
solveRPN = head . foldl foldingFunction [] . words
    where  foldingFunction (x:y:ys) "*" = (y * x):ys
           foldingFunction (x:y:ys) "+" = (y + x):ys
           foldingFunction (x:y:ys) "-" = (y - x):ys
           foldingFunction (x:y:ys) "/" = (y / x):ys
           foldingFunction (x:y:ys) "^" = (y ** x):ys
           foldingFunction (x:xs) "ln" = log x:xs
           foldingFunction xs "sum" = [sum xs]
           foldingFunction xs numberString = read numberString:xs</pre><p>The <code class="literal">/</code> is division, of course, and <code class="literal">**</code> is exponentiation. With the logarithm operator, we just pattern match against a single element and the rest of the stack, because we need only one element to perform its natural logarithm. With the sum operator, we return a stack that has only one element, which is the sum of the stack so far.</p><a id="I_programlisting10_d1e18027"/><pre class="programlisting">ghci&gt; solveRPN "2.7 ln"
0.9932517730102834
ghci&gt; solveRPN "10 10 10 10 sum 4 /"
10.0
ghci&gt; solveRPN "10 10 10 10 10 sum 4 /"
12.5
ghci&gt; solveRPN "10 2 ^"
100.0</pre><p>I think that making a function that can calculate arbitrary floating-point RPN expressions and has the option to be easily extended in 10 lines is pretty awesome.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>This RPN calculation solution is not really fault tolerant. When given input that doesn’t make sense, it might result in a runtime error. But don’t worry, you’ll learn how to make this function more robust in <a class="xref" href="ch14.html" title="Chapter 14. For a Few Monads More">Chapter 14</a>.</p></div></div></div></div>
<div class="sect1" title="Heathrow to London"><div class="titlepage"><div><div><h1 class="title"><a id="heathrow_to_london"/>Heathrow to London</h1></div></div></div><p>Suppose that we’re on a business trip. Our plane has just landed in England, and we rent a car. We have a meeting really soon, and we need to get from Heathrow Airport to London as fast as we can (but safely!).</p><p>There are two main roads going from Heathrow to London, and a number of regional roads cross them. It takes a fixed amount of time to travel from one crossroad to another. It’s up to us to find the optimal path to take so that we get to our meeting in London on time. We start on the left side and can either cross to the other main road or go forward.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject10_d1e18044"/><img src="httpatomoreillycomsourcenostarchimages802638.png.jpg" alt="image with no caption"/></div></div><p>As you can see in the picture, the quickest path from Heathrow to London in this case is to start on main road B, cross over, go forward on A, cross over again, and then go forward twice on B. If we take this path, it takes us 75 minutes. Had we chosen any other path, it would take longer.</p><p>Our job is to make a program that takes input that represents a road system and prints out the quickest path across it. Here’s what the input would look like for this case:<a id="IDX-CHP-10-0024" class="indexterm"/></p><a id="I_programlisting10_d1e18058"/><pre class="programlisting">50
10
30
5
90
20
40
2
25
10
8
0</pre><p>To mentally parse the input file, read it in threes and mentally split the road system into sections. Each section is composed of road <code class="literal">A</code>, road <code class="literal">B</code>, and a crossing road. To have it neatly fit into threes, we say that there’s a last crossing section that takes 0 minutes to drive over. That’s because we don’t care where we arrive in London, as long as we’re in London, mate!</p><p>Just as we did when considering the RPN calculator problem, we’ll solve this problem in three steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Forget Haskell for a minute and think about how to solve the problem by hand. In the RPN calculator section, we first figured out that when calculating an expression by hand, we keep a sort of stack in our minds and then go over the expression one item at a time..</p></li><li class="listitem"><p>Think about how we’re going to represent our data in Haskell. For our RPN calculator, we decided to use a list of strings to represent our expression..</p></li><li class="listitem"><p>Figure out how to operate on that data in Haskell so that we produce a solution. For the calculator, we used a left fold to walk over the list of strings, while keeping a stack to produce a solution.</p></li></ol></div><div class="sect2" title="Calculating the Quickest Path"><div class="titlepage"><div><div><h2 class="title"><a id="calculating_the_quickest_path"/>Calculating the Quickest Path</h2></div></div></div><p>So how do we figure out the quickest path from Heathrow to London by hand? Well, we can just look at the whole picture and try to guess what the quickest path is and hope our guess is correct. That solution works for very small inputs, but what if we have a road that has 10,000 sections? Yikes! We also won’t be able to say for certain that our solution is the optimal one; we can just say that we’re pretty sure. So, that’s not a good solution.</p><p>Here’s a simplified picture of our road system:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject10_d1e18088"/><img src="httpatomoreillycomsourcenostarchimages802640.png.jpg" alt="image with no caption"/></div></div><p>Can we figure out the quickest path to the first crossroads (the first dot on <code class="literal">A</code>, marked <code class="literal">A1</code>) on road <code class="literal">A</code>? That’s pretty trivial. We just see if it’s faster to go directly forward on <code class="literal">A</code> or to go forward on <code class="literal">B</code> and then cross over. Obviously, it’s faster to go forward via <code class="literal">B</code> and then cross over, because that takes 40 minutes, whereas going directly via <code class="literal">A</code> takes 50 minutes. What about crossroads <code class="literal">B1</code>? We see that it’s a lot faster to just go directly via <code class="literal">B</code> (incurring a cost of 10 minutes), because going via <code class="literal">A</code> and then crossing over would take us 80 minutes!</p><p>Now we know the quickest path to <code class="literal">A1</code>: Go via <code class="literal">B</code> and then cross over. We’ll say that’s path <code class="literal">B, C</code> with a cost of 40 minutes. We also know the quickest path to <code class="literal">B1</code>: Go directly via <code class="literal">B</code>. So that’s a path consisting just of <code class="literal">B</code> for 10 minutes. Does this knowledge help us at all if we want to know the quickest path to the next crossroads on both main roads? Gee golly, it sure does!</p><p>Let’s see what the quickest path to <code class="literal">A2</code> would be. To get to <code class="literal">A2</code>, we’ll either go directly to <code class="literal">A2</code> from <code class="literal">A1</code> or we’ll go forward from <code class="literal">B1</code> and then cross over (remember that we can only move forward or cross to the other side). And because we know the cost to <code class="literal">A1</code> and <code class="literal">B1</code>, we can easily figure out the best path to <code class="literal">A2</code>. It takes us 40 minutes to get to <code class="literal">A1</code> and then 5 minutes to get from <code class="literal">A1</code> to <code class="literal">A2</code>, so that’s path <code class="literal">B, C, A</code>, for a cost of 45. It takes us only 10 minutes to get to <code class="literal">B1</code>, but then it would take an additional 110 minutes to go to <code class="literal">B2</code> and then cross over! So obviously, the quickest path to <code class="literal">A2</code> is <code class="literal">B, C, A</code>. In the same way, the quickest way to <code class="literal">B2</code> is to go forward from <code class="literal">A1</code> and then cross over.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Maybe you’re asking yourself, “But what about getting to <code class="literal">A2</code> by first crossing over at <code class="literal">B1</code> and then going forward?” Well, we already covered crossing from <code class="literal">B1</code> to <code class="literal">A1</code> when we were looking for the best way to <code class="literal">A1</code>, so we don’t need to take that into account in the next step as well.</p></div><p>Now that we have the best path to <code class="literal">A2</code> and <code class="literal">B2</code>, we can repeat this until we reach the end. Once we have calculated the best paths for <code class="literal">A4</code> and <code class="literal">B4</code>, the one that takes less time is the optimal path.</p><p>So in essence, for the second section, we just repeat the step we did at first, but we take into account the previous best paths on <code class="literal">A</code> and <code class="literal">B</code>. We could say that we also took into account the best paths on <code class="literal">A</code> and on <code class="literal">B</code> in the first step—they were both empty paths with a cost of 0 minutes.</p><p>In summary, to get the best path from Heathrow to London, we do this:<a id="IDX-CHP-10-0025" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>We see what the best path to the next crossroads on main road <code class="literal">A</code> is. The two options are going directly forward or starting at the opposite road, going forward and then crossing over. We remember the cost and the path.</p></li><li class="listitem"><p>We use the same method to find the best path to the next crossroads on main road <code class="literal">B</code> and remember that.</p></li><li class="listitem"><p>We see if the path to the next crossroads on <code class="literal">A</code> takes less time if we go from the previous <code class="literal">A</code> crossroads or if we go from the previous <code class="literal">B</code> crossroads and then cross over. We remember the quicker path. We do the same for the crossroads opposite of it.</p></li><li class="listitem"><p>We do this for every section until we reach the end.</p></li><li class="listitem"><p>Once we’ve reached the end, the quicker of the two paths that we have is our optimal path.</p></li></ol></div><p>So, in essence, we keep one quickest path on the <code class="literal">A</code> road and one quickest path on the <code class="literal">B</code> road. When we reach the end, the quicker of those two is our path.</p><p>We now know how to figure out the quickest path by hand. If you had enough time, paper, and pencils, you could figure out the quickest path through a road system with any number of sections.<a id="IDX-CHP-10-0026" class="indexterm"/></p></div><div class="sect2" title="Representing the Road System in Haskell"><div class="titlepage"><div><div><h2 class="title"><a id="representing_the_road_system_in_haskell"/>Representing the Road System in Haskell</h2></div></div></div><p>How do we represent this road system with Haskell’s data types?</p><p>Thinking back to our solution by hand, we checked the durations of three road parts at once: the road part on the <code class="literal">A</code> road, its opposite part on the <code class="literal">B</code> road, and part <code class="literal">C</code>, which touches those two parts and connects them. When we were looking for the quickest path to <code class="literal">A1</code> and <code class="literal">B1</code>, we dealt with the durations of only the first three parts, which were 50, 10, and 30. We’ll call that one section. So the road system that we use for this example can be easily represented as four sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">50, 10, 30</code></p></li><li class="listitem"><p><code class="literal">5, 90, 20</code></p></li><li class="listitem"><p><code class="literal">40, 2, 25</code></p></li><li class="listitem"><p><code class="literal">10, 8, 0</code></p></li></ul></div><p>It’s always good to keep our data types as simple as possible (although not any simpler!). Here’s the data type for our road system:</p><a id="I_programlisting10_d1e18348"/><pre class="programlisting">data Section = Section { getA :: Int, getB :: Int, getC :: Int }
    deriving (Show)

type RoadSystem = [Section]</pre><p>This is as simple as it gets, and I have a feeling it will work perfectly for implementing our solution.<a id="IDX-CHP-10-0027" class="indexterm"/><a id="IDX-CHP-10-0028" class="indexterm"/><a id="IDX-CHP-10-0029" class="indexterm"/><a id="IDX-CHP-10-0030" class="indexterm"/><a id="IDX-CHP-10-0031" class="indexterm"/></p><p><code class="literal">Section</code> is a simple algebraic data type that holds three integers for the durations of its three road parts. We introduce a type synonym as well, saying that <code class="literal">RoadSystem</code> is a list of sections.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We could also use a triple of <code class="literal">(Int, Int, Int)</code> to represent a road section. Using tuples instead of making your own algebraic data types is good for some small, localized stuff, but it’s usually better to make a new type for more complex representations. It gives the type system more information about what’s what. We can use <code class="literal">(Int, Int, Int)</code> to represent a road section or a vector in 3D space, and we can operate on those two, but that allows us to mix them up. If we use <code class="literal">Section</code> and <code class="literal">Vector</code> data types, then we can’t accidentally add a vector to a section of a road system.</p></div><p>Our road system from Heathrow to London can now be represented like this:</p><a id="I_programlisting10_d1e18399"/><pre class="programlisting">heathrowToLondon :: RoadSystem
heathrowToLondon = [ Section 50 10 30
                   , Section 5 90 20
                   , Section 40 2 25
                   , Section 10 8 0
                   ]</pre><p>All we need to do now is implement the solution in Haskell.</p></div><div class="sect2" title="Writing the Optimal Path Function"><div class="titlepage"><div><div><h2 class="title"><a id="writing_the_optimal_path_function"/>Writing the Optimal Path Function</h2></div></div></div><p>What should the type declaration for a function that calculates the quickest path for any given road system be? It should take a road system as a parameter and return a path. We’ll represent a path as a list as well.</p><p>Let’s introduce a <code class="literal">Label</code> type that’s just an enumeration of <code class="literal">A</code>, <code class="literal">B</code>, or <code class="literal">C</code>. We’ll also make a type synonym called <code class="literal">Path</code>.</p><a id="I_programlisting10_d1e18426"/><pre class="programlisting">data Label = A | B | C deriving (Show)
type Path = [(Label, Int)]</pre><p>Our function, which we’ll call <code class="literal">optimalPath</code>, should have the following type:</p><a id="I_programlisting10_d1e18433"/><pre class="programlisting">optimalPath :: RoadSystem -&gt; Path</pre><p>If called with the road system <code class="literal">heathrowToLondon</code>, it should return the following path:</p><a id="I_programlisting10_d1e18440"/><pre class="programlisting">[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8)]</pre><p>We’re going to need to walk over the list with the sections from left to right and keep the optimal path on <code class="literal">A</code> and optimal path on <code class="literal">B</code> as we go along. We’ll accumulate the best path as we walk over the list, left to right. What does that sound like? Ding, ding, ding! That’s right, a <span class="emphasis"><em>left fold</em></span>!<a id="IDX-CHP-10-0032" class="indexterm"/></p><p>When doing the solution by hand, there was a step that we repeated over and over. It involved checking the optimal paths on <code class="literal">A</code> and <code class="literal">B</code> so far and the current section to produce the new optimal paths on <code class="literal">A</code> and <code class="literal">B</code>. For instance, at the beginning, the optimal paths were <code class="literal">[]</code> and <code class="literal">[]</code> for <code class="literal">A</code> and <code class="literal">B</code>, respectively. We examined the section <code class="literal">Section 50 10 30</code> and concluded that the new optimal path to <code class="literal">A1</code> was <code class="literal">[(B,10),(C,30)]</code> and the optimal path to <code class="literal">B1</code> was <code class="literal">[(B,10)]</code>. If you look at this step as a function, it takes a pair of paths and a section and produces a new pair of paths. So its type is this:</p><a id="I_programlisting10_d1e18501"/><pre class="programlisting">roadStep :: (Path, Path) -&gt; Section -&gt; (Path, Path)</pre><p>Let’s implement this function, because it’s bound to be useful:</p><a id="I_programlisting10_d1e18506"/><pre class="programlisting">roadStep :: (Path, Path) -&gt; Section -&gt; (Path, Path)
roadStep (pathA, pathB) (Section a b c) =
    let timeA = sum (map snd pathA)
        timeB = sum (map snd pathB)
        forwardTimeToA = timeA + a
        crossTimeToA = timeB + b + c
        forwardTimeToB = timeB + b
        crossTimeToB = timeA + a + c
        newPathToA = if forwardTimeToA &lt;= crossTimeToA
                        then (A, a):pathA
                        else (C, c):(B, b):pathB
        newPathToB = if forwardTimeToB &lt;= crossTimeToB
                        then (B, b):pathB
                        else (C, c):(A, a):pathA
    in  (newPathToA, newPathToB)</pre><p>What’s going on here? First, we calculate the optimal time on road A based on the best so far on <code class="literal">A</code>, and we do the same for <code class="literal">B</code>. We do <code class="literal">sum (map snd pathA)</code>, so if <code class="literal">pathA</code> is something like <code class="literal">[(A,100),(C,20)]</code>, <code class="literal">timeA</code> becomes <code class="literal">120</code>.</p><p><code class="literal">forwardTimeToA</code> is the time that it would take to get to the next crossroads on <code class="literal">A</code> if we went there directly from the previous crossroads on <code class="literal">A</code>. It equals the best time to our previous <code class="literal">A</code> plus the duration of the <code class="literal">A</code> part of the current section.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject10_d1e18549"/><img src="httpatomoreillycomsourcenostarchimages802642.png.jpg" alt="image with no caption"/></div></div><p><code class="literal">crossTimeToA</code> is the time that it would take if we went to the next <code class="literal">A</code> by going forward from the previous <code class="literal">B</code> and then crossing over. It’s the best time to the previous <code class="literal">B</code> so far plus the <code class="literal">B</code> duration of the section plus the <code class="literal">C</code> duration of the section.</p><p>We determine <code class="literal">forwardTimeToB</code> and <code class="literal">crossTimeToB</code> in the same manner.</p><p>Now that we know the best way to <code class="literal">A</code> and <code class="literal">B</code>, we just need to make the new paths to <code class="literal">A</code> and <code class="literal">B</code> based on that. If it’s quicker to go to <code class="literal">A</code> by just going forward, we set <code class="literal">newPathToA</code> to be <code class="literal">(A, a):pathA</code>. Basically, we prepend the <code class="literal">Label A</code> and the section duration <code class="literal">a</code> to the optimal path on <code class="literal">A</code> so far. We say that the best path to the next <code class="literal">A</code> crossroads is the path to the previous <code class="literal">A</code> crossroads and then one section forward via <code class="literal">A</code>. Remember that <code class="literal">A</code> is just a label, whereas <code class="literal">a</code> has a type of <code class="literal">Int</code>.</p><p>Why do we prepend instead of doing <code class="literal">pathA ++ [(A, a)]</code>? Well, adding an element to the beginning of a list is much faster than adding it to the end. This means that the path will be the wrong way around once we fold over a list with this function, but it’s easy to reverse the list later.</p><p>If it’s quicker to get to the next <code class="literal">A</code> crossroads by going forward from road <code class="literal">B</code> and then crossing over, <code class="literal">newPathToA</code> is the old path to <code class="literal">B</code> that then goes forward and crosses to <code class="literal">A</code>. We do the same thing for <code class="literal">newPathToB</code>, except that everything is mirrored.</p><p>Finally, we return <code class="literal">newPathToA</code> and <code class="literal">newPathToB</code> in a pair.</p><p>Let’s run this function on the first section of <code class="literal">heathrowToLondon</code>. Because it’s the first section, the best paths on <code class="literal">A</code> and <code class="literal">B</code> parameter will be a pair of empty lists.</p><a id="I_programlisting10_d1e18679"/><pre class="programlisting">ghci&gt; roadStep ([], []) (head heathrowToLondon)
([(C,30),(B,10)],[(B,10)])</pre><p>Remember that the paths are reversed, so read them from right to left. From this, we can read that the best path to the next <code class="literal">A</code> is to start on <code class="literal">B</code> and then cross over to <code class="literal">A</code>. The best path to the next <code class="literal">B</code> is to just go directly forward from the starting point at <code class="literal">B</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When we do <code class="literal">timeA = sum (map snd pathA)</code>, we’re calculating the time from the path on every step. We wouldn’t need to do that if we implemented <code class="literal">roadStep</code> to take and return the best times on <code class="literal">A</code> and <code class="literal">B</code>, along with the paths themselves.</p></div><p>Now that we have a function that takes a pair of paths and a section, and produces a new optimal path, we can easily do a left fold over a list of sections. <code class="literal">roadStep</code> is called with <code class="literal">([], [])</code> and the first section, and returns a pair of optimal paths to that section. Then it’s called with that pair of paths and the next section, and so on. When we’ve walked over all the sections, we’re left with a pair of optimal paths, and the shorter of them is our answer. With this in mind, we can implement <code class="literal">optimalPath</code>:</p><a id="I_programlisting10_d1e18724"/><pre class="programlisting">optimalPath :: RoadSystem -&gt; Path
optimalPath roadSystem =
    let (bestAPath, bestBPath) = foldl roadStep ([], []) roadSystem
    in  if sum (map snd bestAPath) &lt;= sum (map snd bestBPath)
            then reverse bestAPath
            else reverse bestBPath</pre><p>We left fold over <code class="literal">roadSystem</code> (remember that it’s a list of sections) with the starting accumulator being a pair of empty paths. The result of that fold is a pair of paths, so we pattern match on the pair to get the paths themselves. Then we check which one of these was quicker and return it. Before returning it, we also reverse it, because the optimal paths so far were reversed due to us choosing prepending over appending.<a id="IDX-CHP-10-0033" class="indexterm"/><a id="IDX-CHP-10-0034" class="indexterm"/><a id="IDX-CHP-10-0035" class="indexterm"/><a id="IDX-CHP-10-0036" class="indexterm"/></p><p>Let’s test this!</p><a id="I_programlisting10_d1e18751"/><pre class="programlisting">ghci&gt; optimalPath heathrowToLondon
[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8),(C,0)]</pre><p>This is the result that we were supposed to get! It differs from our expected result a bit, because there’s a step <code class="literal">(C,0)</code> at the end, which means that we cross over to the other road once we’re in London. But because that crossing doesn’t take any time, this is still the correct result.</p></div><div class="sect2" title="Getting a Road System from the Input"><div class="titlepage"><div><div><h2 class="title"><a id="getting_a_road_system_from_the_input"/>Getting a Road System from the Input</h2></div></div></div><p>We have the function that finds an optimal path, so now we just need to read a textual representation of a road system from the standard input, convert it into a type of <code class="literal">RoadSystem</code>, run that through our <code class="literal">optimalPath</code> function, and print the resulting path.</p><p>First, let’s make a function that takes a list and splits it into groups of the same size. We’ll call it <code class="literal">groupsOf</code>:</p><a id="I_programlisting10_d1e18774"/><pre class="programlisting">groupsOf :: Int -&gt; [a] -&gt; [[a]]
groupsOf 0 _ = undefined
groupsOf _ [] = []
groupsOf n xs = take n xs : groupsOf n (drop n xs)</pre><p>For a parameter of <code class="literal">[1..10]</code>, <code class="literal">groupsOf 3</code> should result in the following:</p><a id="I_programlisting10_d1e18784"/><pre class="programlisting">[[1,2,3],[4,5,6],[7,8,9],[10]]</pre><p>As you can see, it’s a standard recursive function. Doing <code class="literal">groupsOf 3 [1..10]</code> equals the following:</p><a id="I_programlisting10_d1e18791"/><pre class="programlisting">[1,2,3] : groupsOf 3 [4,5,6,7,8,9,10]</pre><p>When the recursion is done, we get our list in groups of three. And here’s our main function, which reads from the standard input, makes a <code class="literal">RoadSystem</code> out of it, and prints out the shortest path:</p><a id="I_programlisting10_d1e18798"/><pre class="programlisting">import Data.List

main = do
    contents &lt;- getContents
    let threes = groupsOf 3 (map read $ lines contents)
        roadSystem = map (\[a,b,c] -&gt; Section a b c) threes
        path = optimalPath roadSystem
        pathString = concat $ map (show . fst) path
        pathTime = sum $ map snd path
    putStrLn $ "The best path to take is: " ++ pathString
    putStrLn $ "Time taken: " ++ show pathTime</pre><p>First, we get all the contents from the standard input. Then we apply <code class="literal">lines</code> to our contents to convert something like <code class="literal">"50\n10\n30\n ...</code> to something cleaner, like <code class="literal">["50","10","30" ...</code>. We then map <code class="literal">read</code> over that to convert it to a list of numbers. We apply <code class="literal">groupsOf 3</code> to it so that we turn it to a list of lists of length 3. We map the lambda <code class="literal">(\[a,b,c] -&gt; Section a b c)</code> over that list of lists.<a id="IDX-CHP-10-0037" class="indexterm"/><a id="IDX-CHP-10-0038" class="indexterm"/><a id="IDX-CHP-10-0039" class="indexterm"/><a id="IDX-CHP-10-0040" class="indexterm"/></p><p>As you can see, the lambda just takes a list of length 3 and turns it into a section. So <code class="literal">roadSystem</code> is now our system of roads, and it even has the correct type: <code class="literal">RoadSystem</code> (or <code class="literal">[Section]</code>). We apply <code class="literal">optimalPath</code> to that, get the path and the total time in a nice textual representation, and print it out.</p><p>We save the following text in a file called <span class="emphasis"><em>paths.txt</em></span>:</p><a id="I_programlisting10_d1e18857"/><pre class="programlisting">50
10
30
5
90
20
40
2
25
10
8
0</pre><p>Then we feed it to our program like so:</p><a id="I_programlisting10_d1e18861"/><pre class="programlisting">$ runhaskell heathrow.hs &lt; paths.txt
The best path to take is: BCACBBC
Time taken: 75</pre><p>Works like a charm!</p><p>You can use your knowledge of the <code class="literal">Data.Random</code> module to generate a much longer system of roads, which you can then feed to the code we just wrote. If you get stack overflows, you can change <code class="literal">foldl</code> to <code class="literal">foldl'</code> and <code class="literal">sum</code> to <code class="literal">foldl' (+) 0</code>. Alternatively, try compiling it like this before running it:</p><a id="I_programlisting10_d1e18882"/><pre class="programlisting">$ ghc --make -O heathrow.hs</pre><p>Including the <code class="literal">O</code> flag turns on optimizations that help prevent functions such as <code class="literal">foldl</code> and <code class="literal">sum</code> from causing stack overflows.</p></div></div></body></html>