["```\nmovl   count,%eax       # Move the value of count into a register (eax).\naddl   $0x1,%eax        # Add 1 to the value in the register.\nmovl   %eax,count       # Move the value of the register into count.\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/conf.h>\n  #include <sys/uio.h>\n  #include <sys/malloc.h>\n  #include <sys/ioccom.h>\n  #include <sys/queue.h>\n  #include \"race_ioctl.h\"\n\n  MALLOC_DEFINE(M_RACE, \"race\", \"race object\");\n\n  struct race_softc {\n         LIST_ENTRY(race_softc) list;\n         int unit;\n  };\n\n  static LIST_HEAD(, race_softc) race_list =\n      LIST_HEAD_INITIALIZER(&race_list);\n\n  static struct race_softc *      race_new(void);\n  static struct race_softc *      race_find(int unit);\n  static void                     race_destroy(struct race_softc *sc);\n  static d_ioctl_t                race_ioctl;\n\n static struct cdevsw race_cdevsw = {\n          .d_version =    D_VERSION,\n          .d_ioctl =      race_ioctl,\n          .d_name =     RACE_NAME\n  };\n\n  static struct cdev *race_dev;\n\n  static int\n race_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n      struct thread *td)\n  {\n          struct race_softc *sc;\n          int error = 0;\n\n          switch (cmd) {\n          case RACE_IOC_ATTACH:\n                  sc = race_new();\n                  *(int *)data = sc->unit;\n                  break;\n          case RACE_IOC_DETACH:\n                  sc = race_find(*(int *)data);\n                  if (sc == NULL)\n                          return (ENOENT);\n                  race_destroy(sc);\n                  break;\n          case RACE_IOC_QUERY:\n                  sc = race_find(*(int *)data);\n                  if (sc == NULL)\n                          return (ENOENT);\n                  break;\n          case RACE_IOC_LIST:\n                  uprintf(\"  UNIT\\n\");\n                  LIST_FOREACH(sc, &race_list, list)\n                          uprintf(\"  %d\\n\", sc->unit);\n                  break;\n          default:\n                  error = ENOTTY;\n                  break;\n          }\n\n          return (error);\n  }\n\n  static struct race_softc *\n  race_new(void)\n  {\n          struct race_softc *sc;\n          int unit, max = −1;\n\n          LIST_FOREACH(sc, &race_list, list) {\n                  if (sc->unit > max)\n                          max = sc->unit;\n          }\n          unit = max + 1;\n\n          sc = (struct race_softc *)malloc(sizeof(struct race_softc), M_RACE,\n              M_WAITOK | M_ZERO);\n          sc->unit = unit;\n          LIST_INSERT_HEAD(&race_list, sc, list);\n\n          return (sc);\n  }\n\n  static struct race_softc *\n  race_find(int unit)\n  {\n          struct race_softc *sc;\n\n          LIST_FOREACH(sc, &race_list, list) {\n                  if (sc->unit == unit)\n                          break;\n          }\n\n          return (sc);\n  }\n\n  static void\n  race_destroy(struct race_softc *sc)\n  {\n          LIST_REMOVE(sc, list);\n          free(sc, M_RACE);\n  }\n\n  static int\n  race_modevent(module_t mod __unused, int event, void *arg __unused)\n  {\n          int error = 0;\n\n          switch (event) {\n          case MOD_LOAD:\n                  race_dev = make_dev(&race_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                      0600, RACE_NAME);\n                  uprintf(\"Race driver loaded.\\n\");\n                  break;\n          case MOD_UNLOAD:\n                  destroy_dev(race_dev);\n                  uprintf(\"Race driver unloaded.\\n\");\n                  break;\n          case MOD_QUIESCE:\n                  if (!LIST_EMPTY(&race_list))\n                          error = EBUSY;\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n  DEV_MODULE(race, race_modevent, NULL);\n```", "```\n#define RACE_NAME               \"race\"\n```", "```\nint\nnullop(void)\n{\n\n        return (0);\n}\n```", "```\nstatic struct race_softc *\nrace_new(void)\n{\n        struct race_softc *sc;\n        int unit, max = −1;\n\n       LIST_FOREACH(sc, &race_list, list) {\n                if (sc->unit > max)\n                       max = sc->unit;\n        }\n        unit = max + 1;\n\n        sc = (struct race_softc *)malloc(sizeof(struct race_softc), M_RACE,\n            M_WAITOK | M_ZERO);\n        sc->unit = unit;\n       LIST_INSERT_HEAD(&race_list, sc, list);\n\n       return (sc);\n}\n```", "```\nstatic struct race_softc *\nrace_find(int unit)\n{\n        struct race_softc *sc;\n\n        LIST_FOREACH(sc, &race_list, list) {\n                if (sc->unit == unit)\n                        break;\n        }\n\n        return (sc);\n}\n```", "```\nstatic void\nrace_destroy(struct race_softc *sc)\n{\n       LIST_REMOVE(sc, list);\n       free(sc, M_RACE);\n}\n```", "```\n#define RACE_IOC_ATTACH         _IOR('R', 0, int)\n#define RACE_IOC_DETACH         _IOW('R', 1, int)\n#define RACE_IOC_QUERY          _IOW('R', 2, int)\n#define RACE_IOC_LIST           _IO('R', 3)\n```", "```\nstatic int\nrace_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n    struct thread *td)\n{\n        struct race_softc *sc;\n        int error = 0;\n\n        switch (cmd) {\n      case RACE_IOC_ATTACH:\n                sc = race_new();\n              *(int *)data = sc->unit;\n                break;\n      case RACE_IOC_DETACH:\n                sc = race_find(*(int *)data);\n                if (sc == NULL)\n                        return (ENOENT);\n                race_destroy(sc);\n                break;\n      case RACE_IOC_QUERY:\n                sc = race_find(*(int *)data);\n                if (sc == NULL)\n                        return (ENOENT);\n                break;\n      case RACE_IOC_LIST:\n                uprintf(\"  UNIT\\n\");\n                LIST_FOREACH(sc, &race_list, list)\n                        uprintf(\"  %d\\n\", sc->unit);\n                break;\n        default:\n                error = ENOTTY;\n                break;\n        }\n\n        return (error);\n}\n```", "```\nstatic int\nrace_modevent(module_t mod __unused, int event, void *arg __unused)\n{\n        int error = 0;\n\n        switch (event) {\n        case MOD_LOAD:\n                race_dev = make_dev(&race_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                    0600, RACE_NAME);\n                uprintf(\"Race driver loaded.\\n\");\n                break;\n        case MOD_UNLOAD:\n                destroy_dev(race_dev);\n                uprintf(\"Race driver unloaded.\\n\");\n                break;\n      case MOD_QUIESCE:\n              if (!LIST_EMPTY(&race_list))\n                        error = EBUSY;\n                break;\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return (error);\n}\n```", "```\n#include <sys/types.h>\n#include <sys/ioctl.h>\n\n#include <err.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"../race/race_ioctl.h\"\n\nstatic enum {UNSET, ATTACH, DETACH, QUERY, LIST} action = UNSET;\n\n/*\n * The usage statement: race_config -a | -d unit | -q unit | -l\n */\n\nstatic void\nusage()\n{\n        /*\n         * Arguments for this program are \"either-or.\" For example,\n         * 'race_config -a' or 'race_config -d unit' are valid; however,\n         * 'race_config -a -d unit' is invalid.\n         */\n\n        fprintf(stderr, \"usage: race_config -a | -d unit | -q unit | -l\\n\");\n        exit(1);\n}\n\n/*\n * This program manages the doubly linked list found in /dev/race. It\n * allows you to add or remove an item, query the existence of an item,\n * or print every item on the list.\n */\n\nint\nmain(int argc, char *argv[])\n{\n        int ch, fd, i, unit;\n        char *p;\n\n        /*\n         * Parse the command line argument list to determine\n         * the correct course of action.\n         *\n         *    -a:      add an item.\n         *    -d unit: detach an item.\n         *    -q unit: query the existence of an item.\n         *    -l:      list every item.\n         */\n\n        while ((ch = getopt(argc, argv, \"ad:q:l\")) != −1)\n                switch (ch) {\n                case 'a':\n                        if (action != UNSET)\n                                usage();\n                        action = ATTACH;\n                        break;\n                case 'd':\n                        if (action != UNSET)\n                                usage();\n                        action = DETACH;\n                        unit = (int)strtol(optarg, &p, 10);\n                        if (*p)\n                                errx(1, \"illegal unit -- %s\", optarg);\n                        break;\n                case 'q':\n                        if (action != UNSET)\n                                usage();\n                        action = QUERY;\n                        unit = (int)strtol(optarg, &p, 10);\n                        if (*p)\n                                errx(1, \"illegal unit -- %s\", optarg);\n                        break;\n                case 'l':\n                        if (action != UNSET)\n                                usage();\n                        action = LIST;\n                        break;\n                default:\n                        usage();\n                }\n\n        /*\n         * Perform the chosen action.\n         */\n\n        if (action == ATTACH) {\n                fd = open(\"/dev/\" RACE_NAME, O_RDWR);\n                if (fd < 0)\n                        err(1, \"open(/dev/%s)\", RACE_NAME);\n\n                i = ioctl(fd, RACE_IOC_ATTACH, &unit);\n                if (i < 0)\n                        err(1, \"ioctl(/dev/%s)\", RACE_NAME);\n                printf(\"unit: %d\\n\", unit);\n\n                close (fd);\n        } else if (action == DETACH) {\n                fd = open(\"/dev/\" RACE_NAME, O_RDWR);\n                if (fd < 0)\n                        err(1, \"open(/dev/%s)\", RACE_NAME);\n\n                i = ioctl(fd, RACE_IOC_DETACH, &unit);\n                if (i < 0)\n                        err(1, \"ioctl(/dev/%s)\", RACE_NAME);\n\n                close (fd);\n        } else if (action == QUERY) {\n                fd = open(\"/dev/\" RACE_NAME, O_RDWR);\n                if (fd < 0)\n                        err(1, \"open(/dev/%s)\", RACE_NAME);\n\n                i = ioctl(fd, RACE_IOC_QUERY, &unit);\n                if (i < 0)\n                        err(1, \"ioctl(/dev/%s)\", RACE_NAME);\n\n                close (fd);\n        } else if (action == LIST) {\n                fd = open(\"/dev/\" RACE_NAME, O_RDWR);\n                if (fd < 0)\n                        err(1, \"open(/dev/%s)\", RACE_NAME);\n\n                i = ioctl(fd, RACE_IOC_LIST, NULL);\n                if (i < 0)\n                        err(1, \"ioctl(/dev/%s)\", RACE_NAME);\n\n                close (fd);\n        } else\n                usage();\n\n        return (0);\n}\n```", "```\n$ `sudo kldload ./race.ko`\nRace driver loaded.\n$ `sudo ./race_config -a & sudo ./race_config -a &`\n[1] 2378\n[2] 2379\n$ unit: 0\nunit: 0\n```", "```\n$ `sudo kldload ./race.ko`\nRace driver loaded.\n$ `sudo ./race_config -a & sudo kldunload race.ko &`\n[1] 2648\n[2] 2649\n$ unit: 0\nRace driver unloaded.\n\n[1]-  Done                    sudo ./race_config -a\n[2]+  Done                    sudo kldunload race.ko\n$ `dmesg | tail -n 1`\nWarning: memory type race leaked memory on destroy (1 allocations, 16 bytes\nleaked).\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n\nvoid\nmtx_init(struct mtx mutex, const char name, const char type,\n    int opts);\n\nvoid\nmtx_lock(struct mtx mutex);\n\nvoid\nmtx_lock_spin(struct mtx mutex);\n\nint\nmtx_trylock(struct mtx mutex);\n\nvoid\nmtx_unlock(struct mtx mutex);\n\nvoid\nmtx_unlock_spin(struct mtx mutex);\n\nvoid\nmtx_destroy(struct mtx *mutex);\n```", "```\nstatic void\nfoo()\n{\n...\n        mtx_lock(&mutex);\n...\n        foo();\n...\n        mtx_unlock(&mutex);\n...\n}\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/conf.h>\n  #include <sys/uio.h>\n  #include <sys/malloc.h>\n  #include <sys/ioccom.h>\n  #include <sys/queue.h>\n  #include <sys/lock.h>\n  #include <sys/mutex.h>\n  #include \"race_ioctl.h\"\n\n  MALLOC_DEFINE(M_RACE, \"race\", \"race object\");\n\n  struct race_softc {\n          LIST_ENTRY(race_softc) list;\n          int unit;\n  };\n\n  static LIST_HEAD(, race_softc) race_list = LIST_HEAD_INITIALIZER(&race_list);\n static struct mtx race_mtx;\n\n  static struct race_softc *      race_new(void);\n  static struct race_softc *      race_find(int unit);\n  static void                     race_destroy(struct race_softc *sc);\n  static d_ioctl_t                race_ioctl_mtx;\n  static d_ioctl_t                race_ioctl;\n\n  static struct cdevsw race_cdevsw = {\n          .d_version =    D_VERSION,\n        .d_ioctl =      race_ioctl_mtx,\n          .d_name =       RACE_NAME\n  };\n\n  static struct cdev *race_dev;\n\n  static int\n race_ioctl_mtx(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n      struct thread *td)\n  {\n          int error;\n\n        mtx_lock(&race_mtx);\n          error = race_ioctl(dev, cmd, data, fflag, td);\n        mtx_unlock(&race_mtx);\n\n          return (error);\n  }\n\n  static int\n  race_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n      struct thread *td)\n  {\n  ...\n  }\n\n  static struct race_softc *\n  race_new(void)\n  {\n  ...\n  }\n\n  static struct race_softc *\n  race_find(int unit)\n  {\n  ...\n  }\n\n  static void\n  race_destroy(struct race_softc *sc)\n  {\n  ...\n  }\n\n  static int\n  race_modevent(module_t mod __unused, int event, void *arg __unused)\n  {\n          int error = 0;\n          struct race_softc *sc, *sc_temp;\n\n          switch (event) {\n          case MOD_LOAD:\n                  mtx_init(&race_mtx, \"race config lock\", NULL, MTX_DEF);\n                  race_dev = make_dev(&race_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                      0600, RACE_NAME);\n                  uprintf(\"Race driver loaded.\\n\");\n                  break;\n          case MOD_UNLOAD:\n                  destroy_dev(race_dev);\n                  mtx_lock(&race_mtx);\n                  if (!LIST_EMPTY(&race_list)) {\n                          LIST_FOREACH_SAFE(sc, &race_list, list, sc_temp) {\n                                  LIST_REMOVE(sc, list);\n                                  free(sc, M_RACE);\n                          }\n                  }\n\n                  mtx_unlock(&race_mtx);\n                  mtx_destroy(&race_mtx);\n                  uprintf(\"Race driver unloaded.\\n\");\n                  break;\n          case MOD_QUIESCE:\n                  mtx_lock(&race_mtx);\n                  if (!LIST_EMPTY(&race_list))\n                          error = EBUSY;\n                  mtx_unlock(&race_mtx);\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n  DEV_MODULE(race, race_modevent, NULL);\n```", "```\nstatic int\nrace_modevent(module_t mod __unused, int event, void *arg __unused)\n{\n        int error = 0;\n        struct race_softc *sc, *sc_temp;\n\n        switch (event) {\n        case MOD_LOAD:\n              mtx_init(&race_mtx, \"race config lock\", NULL, MTX_DEF);\n                race_dev = make_dev(&race_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                    0600, RACE_NAME);\n                uprintf(\"Race driver loaded.\\n\");\n                break;\n        case MOD_UNLOAD:\n              destroy_dev(race_dev);\n                mtx_lock(&race_mtx);\n              if (!LIST_EMPTY(&race_list)) {\n                        LIST_FOREACH_SAFE(sc, &race_list, list, sc_temp) {\n                                LIST_REMOVE(sc, list);\n                              free(sc, M_RACE);\n                        }\n                }\n                mtx_unlock(&race_mtx);\n              mtx_destroy(&race_mtx);\n                uprintf(\"Race driver unloaded.\\n\");\n                break;\n        case MOD_QUIESCE:\n              mtx_lock(&race_mtx);\n              if (!LIST_EMPTY(&race_list))\n                        error = EBUSY;\n              mtx_unlock(&race_mtx);\n                break;\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return (error);\n}\n```", "```\n$ `sudo kldload ./race_mtx.ko`\nRace driver loaded.\n$ `sudo ./race_config -a & sudo ./race_config -a &`\n[1] 923\n[2] 924\n$ unit: 0\nunit: 1\n\n...\n\n$ `sudo kldload ./race_mtx.ko`\nRace driver loaded.\n$ `sudo ./race_config -a & sudo kldunload race_mtx.ko &`\n[1] 933\n[2] 934\n$ Race driver unloaded.\nrace_config: open(/dev/race): No such file or directory\n\n[1]-  Exit 1                  sudo ./race_config -a\n[2]+  Done                    sudo kldunload race_mtx.ko\n```", "```\nsc = (struct race_softc *)malloc(sizeof(struct race_softc), M_RACE,\n           M_WAITOK | M_ZERO);\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/sx.h>\n\nvoid\nsx_init(struct sx sx, const char description);\n\nvoid\nsx_init_flags(struct sx sx, const char description, int opts);\n\nvoid\nsx_slock(struct sx sx);\n\nvoid\nsx_xlock(struct sx sx);\n\nint\nsx_slock_sig(struct sx sx);\n\nint\nsx_xlock_sig(struct sx sx);\n\nint\nsx_try_slock(struct sx sx);\n\nint\nsx_try_xlock(struct sx sx);\n\nvoid\nsx_sunlock(struct sx sx);\n\nvoid\nsx_xunlock(struct sx sx);\n\nvoid\nsx_unlock(struct sx sx);\n\nint\nsx_try_upgrade(struct sx sx);\n\nvoid\nsx_downgrade(struct sx sx);\n\nvoid\nsx_destroy(struct sx sx);\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/conf.h>\n  #include <sys/uio.h>\n  #include <sys/malloc.h>\n  #include <sys/ioccom.h>\n  #include <sys/queue.h>\n  #include <sys/lock.h>\n #include <sys/sx.h>\n  #include \"race_ioctl.h\"\n\n  MALLOC_DEFINE(M_RACE, \"race\", \"race object\");\n\n  struct race_softc {\n          LIST_ENTRY(race_softc) list;\n          int unit;\n  };\n\n  static LIST_HEAD(, race_softc) race_list = LIST_HEAD_INITIALIZER(&race_list);\n static struct sx race_sx;\n\n  static struct race_softc *      race_new(void);\n  static struct race_softc *      race_find(int unit);\n  static void                     race_destroy(struct race_softc *sc);\n  static d_ioctl_t                race_ioctl_sx;\n  static d_ioctl_t                race_ioctl;\n\n  static struct cdevsw race_cdevsw = {\n          .d_version =    D_VERSION,\n          .d_ioctl =      race_ioctl_sx,\n          .d_name =       RACE_NAME\n  };\n\n    static struct cdev *race_dev;\n\n  static int\n  race_ioctl_sx(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n      struct thread *td)\n  {\n          int error;\n\n        sx_xlock(&race_sx);\n          error = race_ioctl(dev, cmd, data, fflag, td);\n        sx_xunlock(&race_sx);\n\n          return (error);\n  }\n\n  static int\n  race_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n      struct thread *td)\n  {\n  ...\n  }\n\n  static struct race_softc *\n  race_new(void)\n  {\n  ...\n  }\n\n  static struct race_softc *\n  race_find(int unit)\n  {\n  ...\n  }\n\n  static void\n  race_destroy(struct race_softc *sc)\n  {\n  ...\n  }\n\n  static int\n  race_modevent(module_t mod __unused, int event, void *arg __unused)\n  {\n          int error = 0;\n          struct race_softc *sc, *sc_temp;\n\n          switch (event) {\n          case MOD_LOAD:\n                sx_init(&race_sx, \"race config lock\");\n                  race_dev = make_dev(&race_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                      0600, RACE_NAME);\n                  uprintf(\"Race driver loaded.\\n\");\n                  break;\n            case MOD_UNLOAD:\n                  destroy_dev(race_dev);\n                sx_xlock(&race_sx);\n                  if (!LIST_EMPTY(&race_list)) {\n                          LIST_FOREACH_SAFE(sc, &race_list, list, sc_temp) {\n                                  LIST_REMOVE(sc, list);\n                                  free(sc, M_RACE);\n                          }\n                  }\n\n                sx_xunlock(&race_sx);\n                sx_destroy(&race_sx);\n                  uprintf(\"Race driver unloaded.\\n\");\n                  break;\n          case MOD_QUIESCE:\n                sx_xlock(&race_sx);\n                  if (!LIST_EMPTY(&race_list))\n                          error = EBUSY;\n                sx_xunlock(&race_sx);\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n  DEV_MODULE(race, race_modevent, NULL);\n```", "```\n$ `sudo kldload ./race_sx.ko`\nRace driver loaded.\n$ `sudo ./race_config -a & sudo ./race_config -a &`\n[1] 800\n[2] 801\n$ unit: 0\nunit: 1\n\n...\n\n$ `sudo kldload ./race_sx.ko`\nRace driver loaded.\n$ `sudo ./race_config -a & sudo kldunload race_sx.ko &`\n[1] 811\n[2] 812\n$ unit: 0\nkldunload: can't unload file: Device busy\n\n[1]-  Done                    sudo ./race_config -a\n[2]+  Exit 1                  sudo kldunload race_sx.ko\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/rwlock.h>\n\nvoid\nrw_init(struct rwlock *rw, const char *name);\n\nvoid\nrw_init_flags(struct rwlock *rw, const char *name, int opts);\n\nvoid\nrw_rlock(struct rwlock *rw);\n\nvoid\nrw_wlock(struct rwlock *rw);\n\nint\nrw_try_rlock(struct rwlock *rw);\n\nint\nrw_try_wlock(struct rwlock *rw);\n\nvoid\nrw_runlock(struct rwlock *rw);\n\nvoid\nrw_wunlock(struct rwlock *rw);\n\nint\nrw_try_upgrade(struct rwlock *rw);\n\nvoid\nrw_downgrade(struct rwlock *rw);\n\nvoid\nrw_destroy(struct rwlock *rw);\n```", "```\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/condvar.h>\n\nvoid\ncv_init(struct cv *cvp, const char *d);\n\nconst char *\ncv_wmesg(struct cv *cvp);\n\nvoid\ncv_wait(struct cv *cvp, lock);\n\nvoid\ncv_wait_unlock(struct cv *cvp, lock);\n\nint\ncv_wait_sig(struct cv *cvp, lock);\n\nint\ncv_timedwait(struct cv *cvp, lock, int timo);\n\nint\ncv_timedwait_sig(struct cv *cvp, lock, int timo);\n\nvoid\ncv_signal(struct cv *cvp);\n\nvoid\ncv_broadcast(struct cv *cvp);\n\nvoid\ncv_broadcastpri(struct cv *cvp, int pri);\n\nvoid\ncv_destroy(struct cv *cvp);\n```"]