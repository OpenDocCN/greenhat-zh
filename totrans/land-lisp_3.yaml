- en: Part III. Lisp is Hacking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分。Lisp 是黑客
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779893.png)![image
    with no caption](httpatomoreillycomsourcenostarchimages779921.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779893.png)![无标题图片](httpatomoreillycomsourcenostarchimages779921.png.jpg)'
- en: 'loop and format: The Seedy Underbelly of Lisp'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: loop 和 format：Lisp 的阴暗面
- en: Previously, we looked at the core of the Common Lisp language and admired its
    succinctness and elegance. However, there are also some darker, seedier parts
    of Lisp built around this core that have a certain charm of their own. They may
    lack the beauty of the Lisp core, but they easily make up for it with their power.
    These parts of the language are a real delight for any budding Lisp hacker.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们探讨了 Common Lisp 语言的精髓，并对其简洁和优雅表示钦佩。然而，围绕这个核心，Lisp 还有一些不那么光鲜、有些阴暗的部分，它们本身也具有一定的魅力。它们可能缺乏
    Lisp 核心的美感，但它们以强大的功能来弥补这一点。对于任何初学的 Lisp 程序员来说，这些语言的部分真是令人愉悦。
- en: The extensions we’ll cover in this section, `loop` and `format`, place a strong
    emphasis on power over mathematical elegance. This has led to occasional controversy
    among Lisp programmers, some of whom question whether the power provided by these
    commands is worth the trade-off in elegance. These programmers believe that `loop`
    and `format` should be avoided when writing any serious code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中将要介绍的扩展，`loop` 和 `format`，非常强调功能强大而非数学上的优雅。这导致 Lisp 程序员之间偶尔出现争议，有些人质疑这些命令提供的强大功能是否值得在优雅性上的妥协。这些程序员认为，在编写任何严肃的代码时都应该避免使用
    `loop` 和 `format`。
- en: 'But there is one great reason to learn and use these commands: They embody
    the flexibility and extensibility of Lisp. Since Lisp is (arguably) the most flexible
    programming language available, hackers have been extending it with thousands
    of their own hacks for decades. `loop` and `format`, which are among the most
    successful of these extensions, had to be really spectacular to survive in the
    Darwinian battlefield.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但学习和使用这些命令有一个很好的理由：它们体现了 Lisp 的灵活性和可扩展性。由于 Lisp（有争议地）是可用的最灵活的编程语言，黑客们已经通过数十年的数千个自己的黑客技巧来扩展它。`loop`
    和 `format` 作为这些扩展中最成功的一些，必须非常出色才能在达尔文式的战场上生存下来。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780016.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780016.png.jpg)'
- en: Chapter 10. Looping with the loop Command
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。使用 loop 命令进行循环
- en: The `loop` and `format` commands are powerful and hacker-friendly. Though most
    of the functionality they offer is available elsewhere in the Lisp language, these
    highly specialized commands are worth learning if you like terse code. We’ll look
    at `loop` in this chapter. The next chapter covers `format`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop` 和 `format` 命令功能强大且对黑客友好。尽管它们提供的许多功能在 Lisp 语言的其他地方也有提供，但这些高度专业化的命令如果喜欢简洁的代码，学习它们是值得的。我们将在本章中探讨
    `loop`。下一章将介绍 `format`。'
- en: The loop Macro
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环宏
- en: 'Any type of looping you would ever want to do inside a computer program can
    be accomplished with the `loop` macro. Here’s a simple example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序内部进行的任何类型的循环都可以通过 `loop` 宏来完成。以下是一个简单的示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code adds together the natural numbers below 5, like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 5 以下的自然数相加，如下所示：
- en: '| 0 + 1 + 2 + 3 + 4 = 10 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 0 + 1 + 2 + 3 + 4 = 10 |'
- en: You can see that this `loop` command doesn’t work in the way a proper Lisp command
    should. First of all, it’s parenthetically challenged. Never before have we had
    seven tokens in a row without parentheses!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个 `loop` 命令并不像一个合适的 Lisp 命令那样工作。首先，它在括号方面存在挑战。在此之前，我们从未有过七个连续的标记而没有括号！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779821.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779821.png.jpg)'
- en: 'What makes it even less Lispy is that some of these extra tokens (`for`, `below`,
    and `sum`) appear to have special meanings. Recall from [Chapter 3](ch03.html
    "Chapter 3. Exploring the Syntax of Lisp Code") that the first token in a form
    (the one immediately after the opening parenthesis) is typically what decides
    the basic behavior of the code, while the rest of the form contains parameters.
    Within the `loop` macro, several of these “magic tokens” fundamentally affect
    the `loop`’s behavior. Here’s what they mean:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使其更加不符合 Lisp 特性的还有，其中一些额外的标记（`for`、`below` 和 `sum`）似乎具有特殊的意义。回想一下 [第 3 章](ch03.html
    "第 3 章。探索 Lisp 代码的语法")，形式（括号之后）的第一个标记通常是决定代码基本行为的东西，而形式的其他部分包含参数。在 `loop` 宏中，这些“魔法标记”中的几个从根本上影响了
    `loop` 的行为。它们的意义如下：
- en: '`for` allows you to declare a variable (in this case, named `i`) that iterates
    through a range of values. By default, it will count through the integers starting
    at zero.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 允许你声明一个变量（在这种情况下，命名为 `i`），该变量遍历一系列值。默认情况下，它将从零开始计数整数。'
- en: '`below` tells the `for` construct to halt when it reaches the specified value
    (in this case, `5`), excluding the value itself.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`below` 告诉 `for` 构造在达到指定值（在这种情况下，为 `5`）时停止，不包括该值本身。'
- en: '`sum` adds together all values of a given expression (in this case, the expression
    is just `i`) and makes the `loop` return that number.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum` 将给定表达式的所有值（在这种情况下，表达式只是 `i`）相加，并使 `loop` 返回该数字。'
- en: Some loop Tricks
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些循环技巧
- en: The `loop` macro has a veritable cornucopia of special tokens that make just
    about any kind of behavior possible. Let’s look at some of the possibilities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop` 宏拥有丰富的特殊令牌，几乎可以实现任何行为。让我们看看一些可能性。'
- en: Counting from a Starting Point to an Ending Point
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一个起始点计数到结束点
- en: 'By using `from` and `to` clauses, you can make the `for` construct count through
    any specific range of integers:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `from` 和 `to` 子句，你可以使 `for` 构造遍历任何特定的整数范围：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Iterating Through Values in a List
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历列表中的值
- en: 'In the following example, we iterate through values in a list using the `in`
    token:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用 `in` 令牌遍历列表中的值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: doing Stuff in a Loop
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在循环中执行操作
- en: 'The `do` token takes an arbitrary expression and executes it inside the `loop`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 令牌接受任意表达式并在 `loop` 中执行它：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Doing Stuff Under Certain Conditions
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在特定条件下执行操作
- en: 'The `when` token lets you run the following part of the `loop` only as needed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 令牌允许你根据需要运行 `loop` 的以下部分：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that only the sum of the odd numbers is returned.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有奇数的和被返回。
- en: Breaking out of a Loop Early
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提前退出循环
- en: 'The following `loop` uses several new tricks:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `loop` 使用了几个新技巧：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782608.png.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782608.png.jpg)'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that there’s nothing in the `for` part of the `loop` that tells it to
    stop counting numbers—it goes from zero off to infinity. However, once we reach
    `5`, the `when` clause triggers the loop to immediately return the value `'falafel`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `loop` 的 `for` 部分中没有告诉它停止计数的任何内容——它从零开始一直计数到无穷大。然而，一旦我们达到 `5`，`when` 子句就会触发循环立即返回值
    `'falafel'`。
- en: Collecting a List of Values
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集一系列值
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780290.png.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780290.png.jpg)'
- en: 'The `collect` clause lets you return more than one item from the `loop`, in
    the form of a list. This command is useful when you need to modify each item in
    a list, as in the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect` 子句允许你从 `loop` 中返回多个项目，形式为一个列表。当需要修改列表中的每个项目时，此命令非常有用，如下例所示：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using Multiple for Clauses
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个 `for` 子句
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782304.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782304.png)'
- en: 'It’s possible for a `loop` macro to have more than one `for` clause. Consider
    the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `loop` 宏可以有多个 `for` 子句。考虑以下示例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'How many numbers do you think will be returned as a result? There are two possibilities:
    Either it increments `x` and `y` at the same time and returns a list of 10 items,
    or it iterates `x` and `y` in a nested fashion and returns 100 numbers. The answer
    is the former:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为会有多少数字作为结果返回？有两种可能性：要么同时递增 `x` 和 `y` 并返回一个包含 10 个项目的列表，要么以嵌套方式迭代 `x` 和 `y`
    并返回 100 个数字。答案是前者：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, both numbers incremented at the same time between 0 and 9.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，两个数字在 0 到 9 之间同时递增。
- en: If there are multiple `for` clauses in a Common Lisp `loop`, each one will be
    checked, and the `loop` will stop when any one of the clauses runs out of values.
    This means that `for` clauses *do not* `loop` independently across multiple looping
    variables, so if you `loop` on two ranges of 10 values each, it will still just
    `loop` 10 times.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Common Lisp 的 `loop` 中有多个 `for` 子句，每个子句都会被检查，并且当任何一个子句的值用尽时，`loop` 会停止。这意味着
    `for` 子句不会在多个循环变量之间独立 `loop`，所以如果你在两个各有 10 个值的范围内 `loop`，它仍然只会 `loop` 10 次。
- en: 'However, sometimes you want to generate the *Cartesian product* between multiple
    ranges. In other words, you want a `loop` to run once for every possible combination
    of two or more ranges. To accomplish this, you need to use nested loops for `x`
    and `y`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你想要生成多个范围之间的笛卡尔积。换句话说，你想要一个循环为两个或更多范围的每一种可能的组合运行一次。为了实现这一点，你需要使用嵌套循环来处理`x`和`y`：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, we’ve created 10 lists of 10 items each, `loop`ing for a total
    of 100 items.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了10个包含10个项目的列表，总共循环了100个项目。
- en: 'Also, notice that using a `for` variable starting at zero, such as the `i`
    variable in the following example, provides a clean way to track the index number
    of items in a list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，使用从零开始的`for`变量，例如以下示例中的`i`变量，提供了一种跟踪列表中项目索引数字的干净方式：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You might think we’ve covered every conceivable variation of looping at this
    point. If so, you are gravely mistaken. Behold! The Periodic Table of the Loop
    Macro!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为我们到现在已经涵盖了所有可能的循环变体。如果是这样，你大错特错了。看吧！循环宏的周期表！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781219.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781278.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781219.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781278.png.jpg)'
- en: Everything You Ever Wanted to Know About loop
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你想知道关于循环的一切
- en: The individual examples we’ve discussed so far give only the briefest hint of
    the full capabilities of `loop`. But fear not! You now have the world’s first
    and only Periodic Table of the Loop Macro. Just tape it to your monitor, glue
    it to your wallet, or laser-etch it directly into your retina, and you’ll be guaranteed
    to reach `loop` proficiency in no time!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止讨论的个别示例只是对`loop`完整功能的简要提示。但别担心！你现在拥有了世界上第一个也是唯一的循环宏周期表。只需将它贴在你的显示器上，粘在你的钱包上，或者直接激光雕刻到你的视网膜上，你就能保证迅速达到`loop`熟练水平！
- en: Almost every legal command that can be used in a `loop` macro is covered by
    the periodic table. It shows how to manipulate hash tables and arrays, and perform
    special looping operations. Each square in the periodic table contains an example.
    If you run the example, you should be able to figure out the behavior of the given
    command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有可以在循环宏中使用的合法命令都在周期表中得到了涵盖。它展示了如何操作散列表和数组，以及执行特殊的循环操作。周期表中的每个方格都包含一个示例。如果你运行这个示例，你应该能够弄清楚给定命令的行为。
- en: Using loop to Evolve!
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环进化！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782680.png.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782680.png.jpg)'
- en: Let’s create another game, making full use of `loop`. But this won’t be a game
    that we play. Instead, it will be a game world that evolves as we watch it! We’re
    going to create an environment of steppes and jungles, filled with animals running
    around, foraging, eating, and reproducing. And after a few million units of time,
    we’ll see that they’ve evolved into different species!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个游戏，充分利用`loop`。但这不会是我们玩的游戏。相反，它将是一个随着我们观看而演化的游戏世界！我们将创建一个由草原和热带雨林组成的环境，里面充满了四处奔跑、觅食、进食和繁殖的动物。经过几百万个时间单位后，我们将看到它们已经进化成不同的物种！
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This example is adapted from A.K. Dewdney’s article “Simulated evolution: wherein
    bugs learn to hunt bacteria,” in the “Computer Recreations” column of *Scientific
    American* (May 1989: 138-141).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例改编自A.K. Dewdney的文章“模拟进化：虫子学会捕食细菌”，发表在《科学美国人》的“计算机娱乐”专栏（1989年5月：138-141）。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782162.png.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782162.png.jpg)'
- en: Our game world is extremely simple. It consists of a simple rectangular plane,
    with edges that wrap around to the opposite side. (Mathematically speaking, it
    has a toroidal topology.) Most of this world is covered in steppes, meaning that
    very few plants grow for the animals to eat. In the center of the world is a small
    jungle, where plants grow much faster. Our animals, who are herbivores, will forage
    this world in search for food.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏世界极其简单。它由一个简单的矩形平面组成，边缘环绕到对面。从数学上讲，它具有环面拓扑结构。这个世界的绝大部分都是草原，这意味着几乎没有植物生长供动物食用。在世界的中心是一个小型的热带雨林，那里的植物生长得更快。我们的动物是食草动物，它们将在这个世界中觅食以寻找食物。
- en: 'Let’s create some variables describing the extent of our world:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些描述我们世界范围的变量：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’re giving the world a width of 100 units and a height of 30 units. Using
    these dimensions should make it easy to display the world in our Lisp REPL. The
    `*jungle*` list defines the rectangle in the world map that contains the jungle.
    The first two numbers in the list are the x- and y-coordinates of the jungle’s
    top-left corner, and the last two numbers are its width and height. Finally, we
    give the amount of energy contained in each plant, which is set to 80\. This means
    that if an animal finds a plant, it will gain 80 days’ worth of food by eating
    it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给世界设定了100个单位的宽度和30个单位的长度。使用这些尺寸应该可以在我们的Lisp REPL中轻松显示世界。`*jungle*`列表定义了包含丛林的世界地图中的矩形。列表中的前两个数字是丛林左上角的x和y坐标，最后两个数字是其宽度和高度。最后，我们给出每个植物所含的能量量，设置为80。这意味着如果动物找到植物，它通过吃它将获得80天的食物。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your terminal window isn’t large enough to display the entire world, change
    the values of the `*width*` and `*height*` variables. Set the `*width*` variable
    to the width of your terminal window minus two, and the `*height*` variable to
    the height of your terminal window minus one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的终端窗口不够大，无法显示整个世界，请更改`*width*`和`*height*`变量的值。将`*width*`变量设置为终端窗口宽度减去二，将`*height*`变量设置为终端窗口高度减去一。
- en: Growing Plants in Our World
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的世界中种植植物
- en: As you might imagine, simulating evolution on a computer is a slow process.
    In order to see the creatures evolve, we need to simulate large stretches of time,
    which means we’ll want our code for this project to be very efficient. As animals
    wander around our world, they will need to be able to check if there is a plant
    at a given x,y location. The most efficient way to enable this is to store all
    of our plants in a hash table, indexed based on each plant’s x- and y-coordinates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，在计算机上模拟进化是一个缓慢的过程。为了看到生物进化，我们需要模拟大量时间，这意味着我们希望这个项目的代码非常高效。当动物在我们的世界中游荡时，它们需要能够检查给定x,y位置是否有植物。实现这一点最有效的方法是将所有植物存储在基于每个植物x和y坐标的哈希表中。
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By default, a Common Lisp hash table uses `eq` when testing for the equality
    of keys. For this hash table, however, we’re defining `:test` to use `equal` instead
    of `eq`, which will let us use cons pairs of x- and y-coordinates as keys. If
    you remember our rule of thumb for checking equality, cons pairs should be compared
    using `equal`. If we didn’t make this change, every check for a key would fail,
    since two different cons cells, even with the same contents, test as being different
    when using `eq`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Common Lisp哈希表在测试键的相等性时使用`eq`。然而，对于这个哈希表，我们定义`:test`使用`equal`而不是`eq`，这将允许我们使用x和y坐标对的cons对作为键。如果你还记得我们检查相等性的经验法则，cons对应该使用`equal`进行比较。如果我们没有进行这个更改，每次检查键都会失败，因为即使两个不同的cons单元具有相同的内容，使用`eq`测试时也会被视为不同。
- en: 'Plants will grow randomly across the world, though a higher concentration of
    plants will grow in the jungle area than in the steppes. Let’s write some functions
    to grow new plants:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 植物将在全球范围内随机生长，尽管在丛林地区的植物密度将高于草原地区。让我们编写一些函数来种植新的植物：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `random-plant` function creates a new plant within a specified region of
    the world. It uses the `random` function to construct a random location and stores
    it in the local variable `pos` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it uses `setf` to indicate the existence of the plant within the hash table
    ![](httpatomoreillycomsourcenostarchimages783562.png). The only item actually
    stored in the hash table is `t`. For this `*plants*` table, the keys of the table
    (the x,y position of each plant) are actually more than the values stored in the
    table.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`random-plant`函数在世界的指定区域内创建一个新的植物。它使用`random`函数构建一个随机位置，并将其存储在局部变量`pos`中 ![http://atomoreilly.com/source/nostarch/images/783564.png]。然后它使用`setf`来指示哈希表中植物的存在
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。哈希表中实际存储的唯一项是`t`。对于这个`*plants*`表，表的键（每个植物的x,y位置）实际上比表中存储的值要多。'
- en: It may seem a bit weird to go through the trouble of creating a hash table to
    do nothing more than store `t` in every slot. However, Common Lisp does not, by
    default, have a data structure designed for holding mathematical sets. In our
    game, we want to keep track of the set of all world positions that have a plant
    in them. It turns out that hash tables are a perfectly acceptable way of expressing
    this. You simply use each set item as a key and store `t` as the value. Indeed,
    doing this is a bit of a hack, but it is a reasonably simple and efficient hack.
    (Other Lisp dialects, such as Clojure, have a set data structure built right into
    them, making this hack unnecessary.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有点奇怪，要费这么大的劲创建一个散列表，只是为了在每个槽位中存储`t`。然而，Common Lisp默认并没有为持有数学集合而设计的结构。在我们的游戏中，我们想要追踪所有包含植物的全球位置集合。结果证明，散列表是表达这种方式的完美选择。你只需使用每个集合项作为键，并将`t`作为值存储。实际上，这样做确实是一种折衷方案，但它是一种相对简单且高效的折衷方案。（其他Lisp方言，如Clojure，直接内置了集合数据结构，使得这种折衷方案变得不必要。）
- en: 'Every day our simulation runs, the `add-plants` function will create two new
    plants: one in the jungle ![](httpatomoreillycomsourcenostarchimages783560.png)
    and one in the rest of the map ![](httpatomoreillycomsourcenostarchimages783554.png).
    Because the jungle is so small, it will have dense vegetation compared to the
    rest of the world.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每天我们的模拟运行时，`add-plants`函数将创建两种新的植物：一个在丛林中 ![丛林](httpatomoreillycomsourcenostarchimages783560.png)
    和一个在地图的其余部分 ![地图其余部分](httpatomoreillycomsourcenostarchimages783554.png)。由于丛林很小，与世界的其余部分相比，它将有更茂密的植被。
- en: Creating Animals
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动物
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782474.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782474.png)'
- en: 'The plants in our world are very simple, but the animals are a bit more complicated.
    Because of this, we’ll need to define a structure that stores the properties of
    each animal in our game:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们世界中的植物非常简单，但动物要复杂一些。因此，我们需要定义一个结构来存储我们游戏中每个动物的属性：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s take a look at each of these fields in detail.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些字段中的每一个。
- en: Anatomy of an Animal
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动物的解剖结构
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781054.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781054.png.jpg)'
- en: We need to track several properties for each animal. First, we need to know
    its x- and y-coordinates. This indicates where the animal is located on the world
    map.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要追踪每个动物的一些属性。首先，我们需要知道它的x和y坐标。这表明动物在世界地图上的位置。
- en: Next, we need to know how much `energy` an animal has. This is a Darwinian game
    of survival, so if an animal can’t forage enough food, it will starve and die.
    The energy field tracks how many days of energy an animal has remaining. It is
    crucial that an animal find more food before its energy supply is exhausted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道动物有多少`能量`。这是一个达尔文式的生存游戏，所以如果动物不能觅食足够的食物，它就会饿死。能量字段追踪动物剩余的能量天数。动物在能量供应耗尽之前找到更多的食物至关重要。
- en: 'We also need to track which direction the animal is facing. This is important
    because an animal will walk to a neighboring square in the world map each day.
    The `dir` field will specify the direction of the animal’s next x,y position as
    a number from 0 to 7:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要追踪动物面向的方向。这很重要，因为动物每天都会在世界地图上的相邻方块中移动。`dir`字段将指定动物下一个x,y位置的方位，为一个从0到7的数字：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782494.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782494.png)'
- en: For example, an orientation of 0 would cause the animal to move up and to the
    left by the next day.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，方位0将导致动物在第二天向上并向左移动。
- en: 'Finally, we need to track the animal’s `genes`. Each animal has exactly eight
    genes, consisting of positive integers. These integers represent eight “slots,”
    which encircle the animal as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要追踪动物的`基因`。每种动物恰好有八个基因，由正整数组成。这些整数代表八个“槽位”，如下环绕着动物：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781962.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781962.png)'
- en: Every day, an animal will decide whether to continue facing the same direction
    as the day before or to turn and face a new direction. It will do this by consulting
    these eight slots and randomly choosing a new direction. The chance of a gene
    being chosen will be proportional to the number stored in the gene slot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每天早上，动物将决定是否继续面向前一天的方向，或者转向面向新的方向。它将通过咨询这八个槽位并随机选择一个新的方向来完成这项工作。基因被选择的概率将与存储在基因槽中的数字成正比。
- en: 'For example, an animal might have the following genes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个动物可能具有以下基因：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s represent these genes as a table, showing each slot number and how large
    of a value is stored in it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用表格表示这些基因，显示每个槽位编号及其存储的值的大小：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781380.png.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781380.png.jpg)'
- en: In this example, an animal has a large number (10) stored in slot 2\. Looking
    at our picture of the eight slots around the animal, you can see that slot 2 points
    to the right. Therefore, this animal will make a lot of right-hand turns and run
    in a circle. Of course, since the other slots still contain values larger than
    zero, the animal will occasionally move in another direction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个动物在2号槽中存储了一个大数（10）。查看我们围绕动物的八个槽位的图片，你可以看到2号槽指向右边。因此，这个动物将会进行很多右转，并形成一个圆圈。当然，由于其他槽位仍然包含大于零的值，动物偶尔也会移动到其他方向。
- en: Let’s create an `*animals*` variable, populated with a single starting animal.
    You can think of this animal as “Adam” (or “Eve”, depending on what gender you
    prefer for our asexual animals).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`*animals*`变量，用单个起始动物填充。你可以把这个动物看作是“亚当”（或者“夏娃”，取决于你更喜欢我们的无性动物是男性还是女性）。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We make the animal’s starting point the center of the world by setting the `x`
    and `y` positions to half of the map’s width and height, respectively. We set
    its initial energy to `1000`, since it hasn’t evolved much yet and we want it
    to have a fighting chance at survival. It starts off facing the upper left, with
    its `dir` field set to `0`. For its genes, we just use random numbers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将动物起点设置为世界的中心，将`x`和`y`位置分别设置为地图宽度和高度的一半。我们将它的初始能量设置为`1000`，因为它还没有进化很多，我们希望它在生存上有一定的机会。它一开始面向上左，其`dir`字段设置为`0`。对于其基因，我们只使用随机数。
- en: Note that unlike the `*plants*` structure, which was a hash table, the `*animals*`
    structure is just a plain list (currently containing only a single member). This
    is because, for the core of our simulation, we never need to search our list of
    animals. Instead, we’ll just be traversing `*animals*` once every simulated day,
    to let our critters do their daily activities. Lists already support efficient
    linear traversals, so using another, more complex data structure (such as a table)
    would have no significant effect on the performance of our simulation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`*plants*`结构不同，后者是一个哈希表，`*animals*`结构只是一个普通的列表（目前只包含一个成员）。这是因为，对于我们模拟的核心，我们从未需要搜索我们的动物列表。相反，我们只需在模拟的每一天遍历一次`*animals*`，让我们的生物体进行日常活动。列表已经支持高效的线性遍历，因此使用另一个更复杂的数据结构（如表）对我们的模拟性能不会有显著影响。
- en: Handling Animal Motion
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理动物运动
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780460.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages780460.png.jpg)'
- en: 'The `move` function accepts an animal as an argument and moves it, orthogonally
    or diagonally, based on the direction grid we have described:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`函数接受一个动物作为参数，并根据我们描述的方向网格将其移动，可以是正交或对角移动：'
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `move` function modifies the `x` and `y` fields, using the `animal-x` and
    `animal-y` accessors. As we’ve discussed, these are automatically generated through
    the `defstruct` macro, based on the field names. At the top of this function,
    we use the accessors to retrieve the x- and y-coordinates for the animal ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we use the same accessors to set the same values, with the aid of `setf`
    ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`函数修改`x`和`y`字段，使用`animal-x`和`animal-y`访问器。正如我们讨论的那样，这些是通过`defstruct`宏自动生成的，基于字段名称。在这个函数的顶部，我们使用访问器检索动物的x和y坐标
    ![image with no caption](httpatomoreillycomsourcenostarchimages783564.png) ![image
    with no caption](httpatomoreillycomsourcenostarchimages783562.png)。然后我们使用相同的访问器设置相同的值，借助`setf`
    ![image with no caption](httpatomoreillycomsourcenostarchimages783560.png) ![image
    with no caption](httpatomoreillycomsourcenostarchimages783556.png)。'
- en: To calculate the new x-coordinate, we use a `cond` command to first check if
    the direction is 2, 3, or 4 ![](httpatomoreillycomsourcenostarchimages783554.png).
    These are the directions the animal may face that point east in the world, so
    we want to add one to the x-coordinate. If the direction instead is 1 or 5, it
    means the animal is facing directly north or south ![](httpatomoreillycomsourcenostarchimages783510.png).
    In those cases, the x-coordinate shouldn’t be changed. In all other cases, the
    animal is facing west and we need to subtract one ![](httpatomoreillycomsourcenostarchimages783544.png).
    The y-coordinate is adjusted in an analogous way ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算新的 x 坐标，我们使用 `cond` 命令首先检查方向是否为 2、3 或 4 ![图片](httpatomoreillycomsourcenostarchimages783554.png)。这些是动物可能面对且指向世界东部的方向，因此我们希望将
    x 坐标加一。如果方向是 1 或 5，则意味着动物正直接面向北或南 ![图片](httpatomoreillycomsourcenostarchimages783510.png)。在这些情况下，x
    坐标不应改变。在所有其他情况下，动物面向西，我们需要减一 ![图片](httpatomoreillycomsourcenostarchimages783544.png)。y
    坐标以类似的方式调整 ![图片](httpatomoreillycomsourcenostarchimages783556.png)。
- en: Since the world needs to wrap around at the edges, we do some extra math using
    the `mod` (remainder) function to calculate the modulus of the coordinates and
    enable wrapping across the map ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783556.png).
    If an animal would have ended up with an x-coordinate of `*width*`, the `mod`
    function puts it back to zero, and it does the same for the y-coordinate and `*height*`.
    So, for example, if our function makes the animal move east until `x` equals 100,
    this will mean that (`mod 100 *width*`) equals zero, and the animal will have
    wrapped around back to the far west side of the game world.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于世界需要在边缘处绕回，我们使用 `mod` （余数）函数进行一些额外的数学计算来计算坐标的模数，并允许在地图上绕回 ![图片](httpatomoreillycomsourcenostarchimages783560.png)
    ![图片](httpatomoreillycomsourcenostarchimages783556.png)。如果一个动物的 x 坐标会变成 `*width*`，则
    `mod` 函数将其放回零，对 y 坐标和 `*height*` 也做同样的处理。例如，如果我们的函数使动物向东移动直到 `x` 等于 100，这意味着 (`mod
    100 *width*`) 等于零，动物将绕回到游戏世界的远西边。
- en: The final thing the `move` function needs to do is decrease the amount of energy
    the animal possesses by one. Motion, after all, requires energy.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 函数需要做的最后一件事是减少动物拥有的能量量一个单位。毕竟，运动需要能量。'
- en: Handling Animal Turning
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理动物转向
- en: Next, we’ll write the `turn` function. This function will use the animal’s genes
    to decide if and how much it will turn on a given day.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写 `turn` 函数。此函数将使用动物的基因来决定在给定的一天中它是否以及如何转向。
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function needs to make sure that the amount the animal turns is proportional
    to the gene number in the given slot. It does this by first summing the amount
    of all genes, and then picking a random number within that sum ![](httpatomoreillycomsourcenostarchimages783564.png).
    After that, it uses a recursive function named `angle` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which traverses the genes and finds the gene that corresponds to the chosen number,
    based on the respective contributions of each gene to the sum. It subtracts the
    running count in the argument `x` from the number stored at the current gene ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the running count has hit or exceeded zero, the function has reached the chosen
    number and stops recursing ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, it adds the amount of turning to the current direction and, if needed,
    wraps the number around back to zero, once again by using `mod` ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能需要确保动物转向的量与给定槽位中的基因数量成比例。它是通过首先计算所有基因的总和，然后在那个总和内选择一个随机数来实现的 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。之后，它使用一个名为
    `angle` 的递归函数 ![图片](httpatomoreillycomsourcenostarchimages783562.png)，该函数遍历基因，并根据每个基因对总和的贡献找到对应的数字。它从参数
    `x` 中的运行计数中减去当前基因存储的数字 ![图片](httpatomoreillycomsourcenostarchimages783562.png)。如果运行计数达到或超过零，则函数已达到所选数字并停止递归
    ![图片](httpatomoreillycomsourcenostarchimages783560.png)。最后，它将转向量加到当前方向上，并在需要时，通过使用
    `mod` ![图片](httpatomoreillycomsourcenostarchimages783554.png) 将数字绕回零。
- en: Handling Animal Eating
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理动物进食
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780304.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780304.png)'
- en: 'Eating is a simple process. We just need to check if there’s a plant at the
    animal’s current location, and if there is, consume it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 进食是一个简单的过程。我们只需检查动物当前位置是否有植物，如果有，就消耗它：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The animal’s energy is increased by the amount of energy that was being stored
    by the plant. We then remove the plant from the world using the `remhash` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 动物的能量通过植物储存的能量量来增加。然后我们使用`remhash`函数从世界中移除植物。
- en: Handling Animal Reproduction
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理动物繁殖
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782918.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782918.png.jpg)'
- en: Reproduction is usually the most interesting part in any animal simulation.
    We’ll keep things simple by having our animals reproduce asexually, but it should
    still be interesting, because errors will creep into their genes as they get copied,
    causing mutations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何动物模拟中，繁殖通常是最有趣的部分。我们将通过让我们的动物进行无性繁殖来简化问题，但这仍然应该是有趣的，因为当它们的基因被复制时，错误会逐渐进入，导致突变。
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It takes a healthy parent to produce healthy offspring, so our animals will
    reproduce only if they have at least 200 days’ worth of energy ![](httpatomoreillycomsourcenostarchimages783564.png).
    We use the global constant `*reproduction-energy*` to decide what this cutoff
    number should be. If the animal decides to reproduce, it will lose half its energy
    to its child ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要产生健康的后代，需要一个健康的父母，因此我们的动物只有在拥有至少200天的能量时才会繁殖！[](httpatomoreillycomsourcenostarchimages783564.png)。我们使用全局常量`*reproduction-energy*`来决定这个截止数字应该是多少。如果动物决定繁殖，它将失去一半的能量给它的子女！[](httpatomoreillycomsourcenostarchimages783562.png)。
- en: To create the new animal, we simply copy the structure of the parent with the
    `copy-structure` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    We need to be careful though, since `copy-structure` performs only a *shallow
    copy* of a structure. This means that if there are any fields in the structure
    that contain values that are more complicated than just numbers or symbols, the
    values in those fields will be shared with the parent. An animal’s genes, which
    are stored in a list, represent the only such complex value in our animal structures.
    If we aren’t careful, mutations in the genes of an animal would simultaneously
    affect all its parents and children. In order to avoid this, we need to create
    an explicit copy of our gene list using the `copy-list` function ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的动物，我们只需使用`copy-structure`函数复制父母的结构！[](httpatomoreillycomsourcenostarchimages783560.png)。但是，我们需要小心，因为`copy-structure`只执行结构的浅拷贝。这意味着如果结构中包含比数字或符号更复杂的值的字段，这些字段中的值将与父母共享。动物的基因，存储在列表中，是我们动物结构中唯一的这种复杂值。如果我们不小心，动物基因的突变将同时影响所有父母和子女。为了避免这种情况，我们需要使用`copy-list`函数创建基因列表的显式副本！[](httpatomoreillycomsourcenostarchimages783554.png)。
- en: 'Here is an example that shows what horrible things could happen if we just
    relied on the shallow copy from the `copy-structure` function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，展示了如果我们仅仅依赖于`copy-structure`函数的浅拷贝，可能会发生多么糟糕的事情：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we’ve created a parent animal with all its genes set to `1` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we use `copy-structure` to create a child ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we set the third (second counting from zero) gene equal to `10` ![](httpatomoreillycomsourcenostarchimages783560.png).
    Our parent now looks correct ![](httpatomoreillycomsourcenostarchimages783554.png).
    Unfortunately, since we neglected to use `copy-list` to create a separate list
    of genes for the child, the child genes were also changed ![](httpatomoreillycomsourcenostarchimages783510.png)
    when the parent mutated. Any time you have data structures that go beyond simple
    atomic symbols or numbers, you need to be very careful when using `setf` so that
    these kinds of bugs don’t creep into your code. In future chapters (especially
    [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with Functional Programming")),
    you’ll learn how to avoid these issues by not using functions that mutate data
    directly, in the manner that `setf` does.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个所有基因都设置为`1`的父代动物 ![图片](http://atomoreilly.com/source/nostarch/images/783564.png)。接下来，我们使用`copy-structure`创建一个子代
    ![图片](http://atomoreilly.com/source/nostarch/images/783562.png)。然后我们将第三个（从零开始计数）基因设置为`10`
    ![图片](http://atomoreilly.com/source/nostarch/images/783560.png)。现在我们的父代看起来是正确的
    ![图片](http://atomoreilly.com/source/nostarch/images/783554.png)。不幸的是，由于我们忘记使用`copy-list`为子代创建一个单独的基因列表，当父代发生变异时，子代的基因也被改变了
    ![图片](http://atomoreilly.com/source/nostarch/images/783510.png)。任何当你有超出简单原子符号或数字的数据结构时，在使用`setf`时都需要非常小心，以免这类错误悄悄进入你的代码。在未来的章节（特别是[第14章](ch16.html
    "第14章。用函数式编程提升Lisp的层次"))中，你将学习如何通过不使用像`setf`那样直接修改数据的函数来避免这些问题。
- en: 'To mutate an animal in our `reproduce` function, we randomly pick one of its
    eight genes and place it in the `mutation` variable. Then we use `setf` to twiddle
    that value a bit, again using a random number. We did this twiddling on the following
    line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的`reproduce`函数中变异一个动物，我们随机选择它的八个基因中的一个，并将其放入`mutation`变量中。然后我们使用`setf`对这个值进行一点调整，再次使用一个随机数。我们在以下这一行做了这个调整：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this line, we’re slightly changing a random slot in the gene list. The number
    of the slot is stored in the local variable `mutation`. We add a random number
    less than three to the value in this slot, and then subtract one from the total.
    This means the gene value will change plus or minus one, or stay the same. Since
    we don’t want a gene value to be smaller than one, we use the `max` function to
    make sure it is at least one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们稍微改变了一下基因列表中的一个随机槽位。这个槽位的数字存储在局部变量`mutation`中。我们给这个槽位中的值加上一个小于三的随机数，然后从总数中减去一。这意味着基因值将改变一正一负，或者保持不变。由于我们不希望基因值小于一，我们使用`max`函数确保它至少是一。
- en: We then use `push` to insert this new critter into our global `*animal*` list,
    which adds it to the simulation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`push`将这个新生物插入到我们的全局`*animal*`列表中，这样它就被添加到了模拟中。
- en: Simulating a Day in Our World
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟我们世界的一天
- en: Now that we have functions that handle every detail of an animal’s routine,
    let’s write one that simulates a day in our world.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了处理动物日常细节的函数，让我们写一个模拟我们世界一天的函数。
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First, this function removes all dead animals from the world ![](httpatomoreillycomsourcenostarchimages783564.png).
    (An animal is dead if its energy is less than or equal to zero.) Next, it maps
    across the list, handling each of the animal’s possible daily activities: turning,
    moving, eating, and reproducing ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since all these functions have side effects (they modify the individual animal
    structures directly, using `setf`), we use the `mapc` function, which does not
    waste time generating a result list from the mapping process.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数会从世界中移除所有死亡的动物 ![图片](http://atomoreilly.com/source/nostarch/images/783564.png)。（如果一个动物的能量小于或等于零，它就是死亡的。）接下来，它映射到列表上，处理每个动物可能的日常活动：转身、移动、进食和繁殖
    ![图片](http://atomoreilly.com/source/nostarch/images/783562.png)。由于所有这些函数都有副作用（它们直接使用`setf`修改单个动物结构），我们使用`mapc`函数，它不会浪费时间从映射过程中生成结果列表。
- en: Finally, we call the `add-plants` function ![](httpatomoreillycomsourcenostarchimages783560.png),
    which adds two new plants to the world every day (one in the jungle and one in
    the steppe). Since there are always new plants growing on the landscape, our simulated
    world should eventually reach an equilibrium, allowing a reasonably large population
    of animals to survive throughout the spans of time we simulate.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `add-plants` 函数！[](httpatomoreillycomsourcenostarchimages783560.png)，该函数每天向世界添加两种新的植物（一个在丛林中，一个在草原上）。由于景观上总是有新的植物在生长，我们的模拟世界最终应该达到平衡，允许在模拟的时间跨度内生存一个相当大的动物群体。
- en: Drawing Our World
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制我们的世界
- en: A simulated world isn’t any fun unless we can actually see our critters running
    around, searching for food, reproducing, and dying. The `draw-world` function
    handles this by using the `*animals*` and `*plants*` data structures to draw a
    snapshot of the current world to the REPL.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模拟的世界如果没有我们能看到我们的生物四处奔跑、寻找食物、繁殖和死亡，那就没有多少乐趣。`draw-world` 函数通过使用 `*animals*`
    和 `*plants*` 数据结构来绘制当前世界的快照到交互式命令行环境（REPL）中。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, the function uses a `loop` to iterate through each of the world’s rows
    ![](httpatomoreillycomsourcenostarchimages783564.png). Every row starts with a
    new line (created with `fresh-line`) followed by a vertical bar, which shows us
    where the left edge of the world is. Next, we iterate across the columns of the
    current row ![](httpatomoreillycomsourcenostarchimages783562.png), checking for
    an animal at every location. We perform this check using the `some` function ![](httpatomoreillycomsourcenostarchimages783560.png),
    which lets us determine if at least one item in a list obeys a certain condition.
    In this case, the condition we’re checking is whether there’s an animal at the
    current x- and y-coordinates. If so, we draw the letter `M` at that spot ![](httpatomoreillycomsourcenostarchimages783554.png).
    (The capital letter `M` looks a little like an animal, if you use your imagination.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该函数使用一个 `loop` 来遍历世界的每一行！[](httpatomoreillycomsourcenostarchimages783564.png)。每一行都以一个新行（使用
    `fresh-line` 创建）开始，后面跟着一个垂直线，这显示了世界的左边缘。接下来，我们遍历当前行的列！[](httpatomoreillycomsourcenostarchimages783562.png)，检查每个位置是否有动物。我们使用
    `some` 函数！[](httpatomoreillycomsourcenostarchimages783560.png) 来执行此检查，该函数允许我们确定列表中是否至少有一个项目满足某个条件。在这种情况下，我们检查的条件是当前
    x 和 y 坐标处是否有动物。如果有，我们在该位置绘制字母 `M`！[](httpatomoreillycomsourcenostarchimages783554.png)。（如果你发挥想象力，大写字母
    `M` 看起来有点像动物。）
- en: Otherwise, we check for a plant, which we’ll indicate with an asterisk (`*`)
    character ![](httpatomoreillycomsourcenostarchimages783510.png). And if there
    isn’t a plant or an animal, we draw a space character ![](httpatomoreillycomsourcenostarchimages783544.png).
    Lastly, we draw another vertical bar to cap off the end of each line ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们检查是否存在植物，我们将用星号（`*`）字符来表示！[](httpatomoreillycomsourcenostarchimages783510.png)。如果没有植物或动物，我们绘制一个空格字符！[](httpatomoreillycomsourcenostarchimages783544.png)。最后，我们再画一条垂直线来结束每一行的绘制！[](httpatomoreillycomsourcenostarchimages783556.png)。
- en: Notice that in this function, we need to search through our entire `*animals*`
    list, which will cause a performance penalty. However, `draw-world` is not a core
    routine in our simulation. As you’ll see shortly, the user interface for our game
    will allow us to run thousands of days of the simulation at a time, without drawing
    the world to the screen until the end. Since there’s no need to draw the screen
    on every single day when we do this, the performance of `draw-world` has no impact
    on the overall performance of the simulation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个函数中，我们需要搜索整个 `*animals*` 列表，这将会造成性能损失。然而，`draw-world` 并不是我们模拟的核心程序。正如你很快就会看到的，我们游戏的用户界面将允许我们一次运行数千天的模拟，直到最后才将世界绘制到屏幕上。由于在这种情况下我们不需要每天都在屏幕上绘制屏幕，所以
    `draw-world` 的性能对模拟的整体性能没有影响。
- en: Creating a User Interface
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Finally, we’ll create a user interface function for our simulation, called `evolution`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为我们的模拟创建一个用户界面函数，称为 `evolution`。
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, this function draws the world in the REPL ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it waits for the user to enter a command at the REPL using `read-line` ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the user enters `quit`, the simulation ends ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, it will attempt to parse the user’s command using `parse-integer` ![](httpatomoreillycomsourcenostarchimages783554.png).
    We set `:junk-allowed` to `true` for `parse-integer`, which lets the interface
    accept a string even if it isn’t a valid integer.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数在 REPL 中绘制世界 ![绘制世界](httpatomoreillycomsourcenostarchimages783564.png)。然后它等待用户在
    REPL 中使用 `read-line` ![read-line](httpatomoreillycomsourcenostarchimages783562.png)
    输入命令。如果用户输入 `quit`，模拟结束 ![结束模拟](httpatomoreillycomsourcenostarchimages783560.png)。否则，它将尝试使用
    `parse-integer` 解析用户的命令 ![parse-integer](httpatomoreillycomsourcenostarchimages783554.png)。我们为
    `parse-integer` 设置了 `:junk-allowed` 为 `true`，这使得界面可以接受一个字符串，即使它不是一个有效的整数。
- en: If the user enters a valid integer *n*, the program will run the simulation
    for *n* simulated days, using a loop ![](httpatomoreillycomsourcenostarchimages783510.png).
    It will also print a dot to the screen for every 1000 days, so the user can see
    that the computer hasn’t frozen while running the simulation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入一个有效的整数 *n*，程序将运行 *n* 模拟天，使用循环 ![循环](httpatomoreillycomsourcenostarchimages783510.png)。它还会在每
    1000 天打印一个点，以便用户可以看到计算机在运行模拟时没有冻结。
- en: If the input isn’t a valid integer, we run `update-world` to simulate one more
    day. Since `read-line` allows for an empty value, the user can just tap the enter
    key and watch the animals move around their world.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的不是有效的整数，我们将运行 `update-world` 来模拟额外的一天。由于 `read-line` 允许空值，用户只需按下回车键，就可以看到动物在其世界中四处移动。
- en: Finally, the `evolution` function recursively calls itself to redraw the world
    and await more user input ![](httpatomoreillycomsourcenostarchimages783544.png).
    Our simulation is now complete.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`evolution` 函数递归地调用自身来重新绘制世界并等待更多用户输入 ![更多](httpatomoreillycomsourcenostarchimages783544.png)。我们的模拟现在完成了。
- en: Let's Watch Some Evolution!
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们观看一些进化吧！
- en: 'To start the simulation, execute `evolution` as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始模拟，按照以下方式执行 `evolution`：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our world is currently empty, except for the Adam/Eve animal in the center.
    Hit enter a few times to cycle through a few days:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的世界是空的，除了中心的亚当/夏娃动物。按回车键几次，可以循环显示几天：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our under-evolved animal is stumbling around randomly, and a few plants are
    starting to grow.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们未充分进化的动物正在随机乱走，一些植物开始生长。
- en: 'Next, enter **`100`** to see what the world looks like after 100 days:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入 **`100`** 来看看 100 天后世界是什么样子：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our animal has already multiplied quite a bit, although this has less to do
    with the amount of food it has eaten than with the large amount of “starter energy”
    we gave it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动物已经繁殖了很多，但这与它吃过的食物量没有太大关系，而是与我们给予它的“启动能量”大量有关。
- en: Now let’s go all out and run the simulation for five million days! Since we’re
    using CLISP, this will be kind of slow, and you may want to start it up in the
    evening and let it run overnight. With a higher-performance Lisp, such as SBCL,
    it could take only a couple of minutes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们全力以赴，运行五百万天的模拟！由于我们使用的是 CLISP，这可能会比较慢，你可能想在晚上启动它，让它整夜运行。使用性能更高的 Lisp，如
    SBCL，可能只需几分钟。
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our world doesn’t look much different after five million days than it did after
    a hundred days. Of course, there are more animals, both traveling across the steppes
    and enjoying the lush vegetation of the jungle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 五百万天后，我们的世界看起来与一百天后并没有太大的不同。当然，动物更多了，既有穿越草原的，也有享受丛林茂密植被的。
- en: 'But appearances are deceptive. These animals are distinctly different from
    their early ancestors. If you observe them closely (by tapping enter), you’ll
    see that some of the creatures move in straight lines and others just jitter around
    in a small area, never taking more than a single step in any direction. (As an
    exercise, you could tweak the code to use different letters for each animal, in
    order to make their motion even easier to observe.) You can see this contrast
    even more clearly by typing `quit` to exit the simulation, then checking the contents
    of the `*animals*` variable at the REPL:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但外表是欺骗性的。这些动物与它们的早期祖先明显不同。如果你仔细观察（通过按回车键），你会看到一些生物直线移动，而另一些生物只是在小范围内跳跃，在任何方向上都不会走超过一步。（作为一个练习，你可以调整代码，为每种动物使用不同的字母，以便更容易观察它们的运动。）你可以通过输入
    `quit` 退出模拟，然后检查 REPL 中的 `*animals*` 变量内容来更清楚地看到这种对比：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you look closely at all the animals in the list, you’ll notice that they
    have two distinct types of genomes. One group of animals has a high number toward
    the front of the list, which causes them to move mostly in a straight line. The
    other group has a large number toward the back of the list, which causes them
    to jitter about within a small area. There are no animals with a genome between
    those two extremes. Have we evolved two different species?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察列表中的所有动物，你会注意到它们有两种不同的基因组。一组动物在列表的前面有较高的数字，这导致它们主要直线移动。另一组动物在列表的后面有较大的数字，这导致它们在较小的区域内跳跃。没有动物在两种极端之间。我们进化出两种不同的物种了吗？
- en: 'If you were to create a function that measured how far these evolved animals
    travel in a fixed amount of time, the histogram of the distance would appear as
    follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个函数来衡量这些进化动物在固定时间内行进的距离，距离的直方图将如下所示：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783464.png.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783464.png.jpg)'
- en: This is a clear bimodal distribution, showing that the behavior of these animals
    appears to fall into two populations. Think about the environment these animals
    live in, and try to reason why this bimodal distribution would evolve. We will
    discuss the solution to this conundrum next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个清晰的二模态分布，表明这些动物的行为似乎分为两个群体。想想这些动物生活的环境，并尝试推理为什么这种二模态分布会进化。我们将在下一节讨论这个难题的解决方案。
- en: Explaining the Evolution
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释进化
- en: 'The solution to the evolution puzzle is pretty straightforward. There are two
    possible survival strategies an animal can adopt in this imaginary world:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 进化难题的解决方案相当直接。在这个虚构的世界里，动物可以采取两种可能的生存策略：
- en: Focus on the rich food supply in the jungle. Any animal adopting this strategy
    needs to be conservative in its motion. It can’t stray too far over time, or it
    might fall out of the jungle. Of course, these types of animals *do* need to evolve
    at least a bit of jittery motion, or they will never find any food at all. Let’s
    call these conservative, jittery, jungle-dwelling animals the *elephant species*.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注丛林中丰富的食物供应。采用这种策略的任何动物都需要在运动上保守。它不能随着时间的推移走得太远，否则可能会掉出丛林。当然，这类动物*确实*需要至少进化一点跳跃运动，否则它们将永远找不到任何食物。让我们称这些保守的、跳跃的、生活在丛林中的动物为*象种*。
- en: Forage the sparse vegetation of the steppes. Here, the most critical trait for
    survival is to cover large distances. Such an animal needs to be open-minded,
    and must constantly migrate to new areas of the map to find food. (It can’t travel
    in *too* straight a line however, or it may end up competing for resources with
    its own offspring.) This strategy requires a bit of naïve optimism, and can at
    times lead to doom. Let’s call these liberally minded, risk-taking animals the
    *donkey species*.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在草原上觅食稀疏的植被。在这里，生存的最关键特征是覆盖大距离。这类动物需要思想开放，并且必须不断迁移到地图上的新区域以寻找食物。（然而，它不能直线旅行得太直，否则可能会与自己的后代竞争资源。）这种策略需要一点天真的乐观，有时可能会导致灾难。让我们称这些思想开放、敢于冒险的动物为*马种*。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781764.png.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781764.png.jpg)'
- en: Expanding the simulation to evolve the three branches of government is left
    as an exercise to the reader.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将模拟扩展到进化三个政府分支的任务留给读者作为练习。
- en: What You've Learned
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we discussed the `loop` command in detail. Along the way,
    you learned the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了`loop`命令。在这个过程中，你学习了以下内容：
- en: The `loop` command is a one-stop looping shop—it can do anything you need a
    `loop` to do.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`命令是一个一站式循环商店——它可以完成你需要`loop`完成的任何事情。'
- en: To count through numbers in a loop, use the `for` phrase.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在循环中计数数字，请使用`for`短语。
- en: To count through items in a list within a loop, use the `for in` phrase.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在循环中计数列表中的项目，请使用`for in`短语。
- en: You can collect items inside a list and return them as a list with the `collect`
    phrase.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`collect`短语在列表内收集项目，并将它们作为一个列表返回。
- en: Use the Periodic Table of the Loop Macro to find other useful phrases supported
    by `loop`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环宏周期表来找到`loop`支持的其他有用短语。
- en: Chapter 11. Printing Text with the format Function
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 使用格式函数打印文本
- en: Even in this modern era of programming, it’s extremely important to be able
    to manipulate text, and Common Lisp has some of the fanciest text-printing functions
    available. Whether you need to manipulate XML, HTML, Linux configuration files,
    or any other data in a textual format, Lisp will make your work easy.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在现代编程时代，能够操纵文本仍然非常重要，而Common Lisp拥有一些最花哨的文本打印函数。无论你需要操纵XML、HTML、Linux配置文件，还是任何其他文本格式的数据，Lisp都能使你的工作变得简单。
- en: The most important advanced text printing function in Common Lisp is the `format`
    function, which is the subject of this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Common Lisp中，最重要的高级文本打印函数是`format`函数，这是本章的主题。
- en: Anatomy of the format Function
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`format`函数的解剖结构'
- en: 'Here is an example of the `format` function in use:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`format`函数使用的一个示例：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s take a look at what each part of this function means.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个函数的每个部分代表什么。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780524.png.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages780524.png.jpg)'
- en: The Destination Parameter
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标参数
- en: 'The first parameter to the `format` function is the *destination* parameter,
    which tells `format` where to send the text it generates. Here are its possible
    values:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`函数的第一个参数是*目标*参数，它告诉`format`将生成的文本发送到何处。以下是它的可能值：'
- en: '**`nil`**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**`nil`**'
- en: Don’t print anything; just return the value as a string.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不打印任何内容；只需返回值作为字符串。
- en: '**`t`**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**`t`**'
- en: Print the value to the console. In this case, the function just returns nil
    as a value (as in our example).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将值打印到控制台。在这种情况下，函数只是返回nil作为值（如我们的示例所示）。
- en: '**`stream`**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**`stream`**'
- en: Write the data to an output stream (covered in [Chapter 12](ch13.html "Chapter 12. Working
    with Streams")).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据写入输出流（在第12章中介绍）。
- en: 'In the following example, we set the first parameter to `nil` so it simply
    returns the value as a string:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将第一个参数设置为`nil`，因此它简单地以字符串形式返回值：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The resulting string value (`"Add onion rings for only 1.50 dollars more!"`)
    is passed to the `reverse` function, and then that reversed string is printed
    to the screen with the `princ` command ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串值（`"Add onion rings for only 1.50 dollars more!"`）传递给`reverse`函数，然后使用`princ`命令将反转后的字符串打印到屏幕上![image
    with no caption](httpatomoreillycomsourcenostarchimages783564.png)。
- en: In this example, the REPL will also print the value of the entered expression,
    along with the information output by the `princ` command. This is why you see
    the value displayed a second time ![](httpatomoreillycomsourcenostarchimages783562.png).
    For the remainder of this chapter, the examples will omit these values printed
    by the REPL, and show only the information explicitly printed by our code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，REPL也会打印输入表达式的值，以及`princ`命令输出的信息。这就是为什么你会看到值被显示两次![image with no caption](httpatomoreillycomsourcenostarchimages783562.png)。在本章的其余部分，示例将省略REPL打印的这些值，只显示我们代码显式打印的信息。
- en: The Control String Parameter
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制字符串参数
- en: The second parameter to the `format` function is a `control string`, which controls
    the text formatting. The `format` function’s power lies in the control string.
    In our current example, the control string is `"Add onion rings for only ˜$ dollars
    more!"`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`函数的第二个参数是一个`控制字符串`，它控制文本格式。`format`函数的力量在于控制字符串。在我们的当前示例中，控制字符串是`"Add
    onion rings for only ˜$ dollars more!"`。'
- en: By default, the text in this string is simply printed as output. However, you
    can place *control sequences* into this string to affect the format of the output,
    as described in the remainder of this chapter. Our current example contains the
    control sequence `˜$`, which indicates a *monetary floating-point* value. Every
    control sequence recognized by the `format` function begins with the tilde (`˜`)
    character.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此字符串中的文本将简单地作为输出打印。然而，你可以在字符串中放置*控制序列*来影响输出的格式，正如本章剩余部分所描述的。我们当前的示例包含控制序列`˜$`，表示*货币浮点值*。`format`函数识别的每个控制序列都以波浪号（`˜`）字符开头。
- en: Value Parameters
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值参数
- en: The `format` parameters following the control string contain values, or the
    actual data to be displayed and formatted. As you’ll see, the control string interacts
    with these parameters and controls their formatting.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 控制字符串后面的`format`参数包含值，或实际要显示和格式化的数据。正如你所看到的，控制字符串与这些参数交互并控制它们的格式。
- en: Control Sequences for Printing Lisp Values
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印Lisp值的控制序列
- en: 'Any Lisp value can be printed with the `print` or `prin1` command. To print
    a value for humans, without any delimiters, we can use the `princ` command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Lisp值都可以使用`print`或`prin1`命令打印。要打印供人类阅读的值，不使用任何分隔符，我们可以使用`princ`命令：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use the `˜s` and `˜a` control sequences with `format` to produce the
    same behavior as `prin1` and `princ`. When used with `format`, the `˜s` control
    sequence includes appropriate delimiters. The `˜a` shows the value, without delimiters,
    for humans to read:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`˜s`和`˜a`控制序列与`format`一起产生与`prin1`和`princ`相同的行为。当与`format`一起使用时，`˜s`控制序列包含适当的分隔符。`˜a`显示没有分隔符的值，以便人类阅读：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can adjust the behavior of these control sequences even further by entering
    parameters within the control sequence. For instance, we can place a number *n*
    in front of the `a` or `s` to indicate that the value should be *padded* with
    blank spaces on the right. The `format` command will then add spaces until the
    total width of the value is *n*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在控制序列内输入参数来进一步调整这些控制序列的行为。例如，我们可以在`a`或`s`前放置一个数字*n*，以指示值应该用空格在右侧*填充*。然后`format`命令将添加空格，直到值的总宽度达到*n*。
- en: 'For example, by writing `˜10a` in the following example, we add seven spaces
    to the right of `foo`, making the total width of the formatted value 10 characters:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下示例中，通过写入`˜10a`，我们在`foo`的右侧添加了七个空格，使得格式化值的总宽度为10个字符：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also add spaces on the left side of the value by adding the @ symbol,
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过添加@符号在值的左侧添加空格，如下所示：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, the total width of the added spaces along with the value `foo`
    equals 10 characters.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，添加的空格总数加上值`foo`等于10个字符。
- en: 'Control sequences can accept more than just one parameter. In the preceding
    examples, we set only the first parameter, which controls the final width of the
    final formatted string. Let’s look at an example that sets the second parameter
    of the `˜a` control sequence as well:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 控制序列可以接受不止一个参数。在先前的例子中，我们只设置了第一个参数，它控制最终格式化字符串的宽度。让我们看看一个同时设置`˜a`控制序列第二个参数的例子：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, additional parameters to a control sequence are separated with
    a comma. In this case, the second parameter is set to `3`, which tells the `format`
    command to add spaces in groups of three (instead of just one at a time) until
    the goal width of 10 is reached. In this example, a total of nine spaces are added
    to the formatted value. This means it overshot our goal width of 10 (by design),
    leading instead to a total width of 12 (nine spaces plus the letters `foo`). Padding
    strings in multiples like this is not a commonly needed feature, so the second
    parameter to the `˜a` control sequence is rarely used.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，控制序列的附加参数用逗号分隔。在这种情况下，第二个参数设置为`3`，这告诉`format`命令以三组（而不是一次一个）添加空格，直到达到目标宽度10。在这个例子中，总共添加了九个空格到格式化值中。这意味着它超出了我们的目标宽度10（按设计），反而导致总宽度为12（九个空格加上字母`foo`）。以这种方式以倍数填充字符串不是常用的功能，所以`˜a`控制序列的第二个参数很少使用。
- en: 'Sometimes we need to control the exact number of spaces to add to our string,
    regardless of the length of the final value. We can do this by setting the third
    parameter in the `˜a` control sequence. For example, suppose we want to print
    exactly four spaces after the final formatted value. To set the third control
    sequence parameter equal to four, we place two commas in front of the parameter
    to indicate that the first two parameters are blank, then follow this with a `4`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要控制添加到字符串中的确切空格数，而不管最终值的长度。我们可以通过在`˜a`控制序列中设置第三个参数来实现这一点。例如，假设我们想在最终格式化值后打印出恰好四个空格。要将第三个控制序列参数设置为四，我们在参数前放置两个逗号来表示前两个参数为空，然后跟一个`4`：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that there are exactly four extra spaces inserted in the results. Since
    the first and second parameters were not specified before the commas, their default
    values will be used.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到结果中恰好插入了四个额外的空格。由于在逗号之前没有指定第一个和第二个参数，将使用它们的默认值。
- en: 'The fourth control sequence parameter specifies which character will be used
    for padding. For example, in the following listing, we pad the printed value with
    four exclamation points:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个控制序列参数指定了用于填充的字符。例如，在以下列表中，我们用四个感叹号填充打印的值：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'These control sequence parameters can also be combined. For example, we can
    add the `@` symbol to our code to indicate that the exclamation marks should appear
    in front of the value, like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制序列参数也可以组合使用。例如，我们可以在代码中添加 `@` 符号来表示感叹号应该出现在值的前面，如下所示：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that you have an overview of `format` command control sequences, let’s look
    at how to use them for formatting, beginning with numbers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `format` 命令的控制序列概述，让我们看看如何使用它们进行格式化，从数字开始。
- en: Control Sequences for Formatting Numbers
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字格式化控制序列
- en: The `format` command has many options designed specifically for controlling
    the appearance of numbers. Let’s look at some of the more useful ones.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 命令有许多专门设计用于控制数字外观的选项。让我们看看其中一些更有用的选项。'
- en: Control Sequences for Formatting Integers
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数格式化控制序列
- en: 'First, we can use `format` to display a number using a different base. For
    instance, we can display a number in hexadecimal (base-16) with the `˜x` control
    sequence:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 `format` 来使用不同的基数显示一个数字。例如，我们可以使用 `˜x` 控制序列以十六进制（基数-16）显示一个数字：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, we can display a number in binary (base-2) using the `˜b` control
    sequence:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用 `˜b` 控制序列以二进制（基数-2）显示一个数字：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can even explicitly declare that a value will be displayed as a decimal
    (base-10) number, using the `˜d` control sequence:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以显式声明一个值将以十进制（基数-10）数字的形式显示，使用 `˜d` 控制序列：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this case, we would have gotten the same result if we had just used the
    more generic `˜a` control sequence. The difference is that `˜d` supports special
    parameters and flags that are specific to printing decimal numbers. For example,
    we can place a colon inside the control sequence to enable commas as digit group
    separators:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们只是使用了更通用的 `˜a` 控制序列，我们也会得到相同的结果。区别在于 `˜d` 支持特定于打印十进制数字的特殊参数和标志。例如，我们可以在控制序列内部放置冒号以启用逗号作为数字分组分隔符：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To control the width of the number, we can set the padding parameter, just
    as we did with the `˜a` and `˜s` control sequences:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制数字的宽度，我们可以设置填充参数，就像我们在 `˜a` 和 `˜s` 控制序列中所做的那样：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To change the character used for padding, pass in the desired character (in
    this case, the *x* character) as the second parameter:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改用于填充的字符，请传入所需的字符（在这种情况下，是 *x* 字符）作为第二个参数：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Control Sequences for Formatting Floating-Point Numbers
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数格式化控制序列
- en: 'Floating-point values are handled with the `˜f` control sequence. As with all
    of the previously discussed control sequences, we can change the value’s display
    width by changing the first parameter. When used with floating-point numbers,
    the `format` command will automatically round the value to fit within the requested
    number of characters (including the decimal point):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值使用 `˜f` 控制序列处理。与之前讨论的所有控制序列一样，我们可以通过更改第一个参数来更改值的显示宽度。当与浮点数一起使用时，`format`
    命令将自动将值四舍五入以适应请求的字符数（包括小数点）：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, the final width of `3.14` is four characters wide, as specified
    by the control sequence.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`3.14` 的最终宽度是四个字符宽，正如控制序列所指定的。
- en: 'The second parameter of the `˜f` control sequence controls the number of digits
    displayed after the decimal point. For example, if we pass `4` as the second parameter
    in the preceding example, we get the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`˜f` 控制序列的第二个参数控制小数点后显示的数字位数。例如，如果我们将在前面的示例中传递 `4` 作为第二个参数，我们得到以下输出：'
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that Common Lisp actually includes the constant `pi` as part of the standard,
    so you could also rewrite the command like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Common Lisp 实际上在标准中包含了常数 `pi`，因此你也可以这样重写命令：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The third parameter of the `˜f` control sequence causes the number to be scaled
    by factors of ten. For example, we can pass `2` as the third parameter, which
    we can use to multiply a fraction by 10² to turn it into a percentage:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`˜f` 控制序列的第三个参数会导致数字按十的因子缩放。例如，我们可以将 `2` 作为第三个参数传递，我们可以用它将分数乘以 10²，将其转换为百分比：'
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In addition to `˜f`, we can use the control sequence `˜$`, which is used for
    formatting currencies:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `˜f`，我们还可以使用控制序列 `˜$`，它用于货币格式化：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You saw an example that used `˜$` at the beginning of this chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章的开头看到了一个使用 `˜$` 的示例。
- en: Printing Multiple Lines of Output
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印多行输出
- en: 'Common Lisp has two different commands for starting a new line during printing.
    The first, `terpri`, simply tells Lisp to terminate the current line and start
    a new one for printing subsequent output. For example, we can print two numbers
    on different lines like so:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 在打印时开始新行有两个不同的命令。第一个，`terpri`，只是告诉 Lisp 终止当前行并开始一个新行以打印后续输出。例如，我们可以这样在不同的行上打印两个数字：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can also start a new line with `fresh-line`. This command will start a new
    line, but only if the cursor position in the REPL isn’t already at the very front
    of a line. Let’s look at some examples:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `fresh-line` 来开始新行。此命令将开始新行，但前提是 REPL 中的光标位置不在行的最前面。让我们看看一些示例：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, placing two `fresh-line` statements between the two `princ`
    calls resulted in Lisp printing only one line between the outputted numbers. The
    first `fresh-line` starts a new line; the second `fresh-line` is simply ignored.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在两个 `princ` 调用之间放置两个 `fresh-line` 语句导致 Lisp 在输出数字之间只打印了一行。第一个 `fresh-line`
    开始新行；第二个 `fresh-line` 被简单地忽略。
- en: Essentially, the `terpri` command says “start a new line,” whereas the `fresh-line`
    command says “start a new line, *if needed*.” Any code using the `terpri` command
    needs to “know” what was printed before. Otherwise, unsightly empty lines may
    result. Since it’s always better if different parts of a program know as little
    about each other as possible, most Lispers prefer using `fresh-line` over `terpri`,
    because it allows them to decouple the printing of one piece of data from the
    next.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`terpri` 命令表示“开始新行”，而 `fresh-line` 命令表示“如果需要，开始新行”。任何使用 `terpri` 命令的代码都需要“知道”之前打印了什么。否则，可能会出现难看的空白行。由于程序的不同部分最好尽可能少地了解彼此，大多数
    Lisp 程序员更喜欢使用 `fresh-line` 而不是 `terpri`，因为它允许他们将一条数据的打印与下一条数据的打印解耦。
- en: 'The `format` command has two control sequences that are analogous to `terpri`
    and `fresh-line`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 命令有两个与 `terpri` 和 `fresh-line` 类似的控制序列：'
- en: '**`˜%`**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**`˜%`**'
- en: causes a new line to be created in all cases (like `terpri`)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下都会创建新行（类似于 `terpri`）
- en: '**`˜&`**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**`˜&`**'
- en: creates new lines only as needed (like `fresh-line`).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 只在需要时创建新行（类似于 `fresh-line`）。
- en: 'These examples illustrate this difference:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例说明了这种差异：
- en: '[PRE54]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, using an extra `˜%` prints an unsightly empty line ![](httpatomoreillycomsourcenostarchimages783564.png),
    and using `˜&` in the same places does not.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用额外的 `˜%` 会打印出难看的空白行 ![image with no caption](httpatomoreillycomsourcenostarchimages782580.png.jpg)，而在相同的位置使用
    `˜&` 则不会。
- en: 'These two line-termination sequences can also have an additional parameter
    in front of them to indicate the number of new lines to be created. This is useful
    in cases where we want to use empty lines to space out our output. For example,
    the addition of `5` in the following example adds five empty lines to our output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个行终止序列也可以在它们前面有一个额外的参数，以指示要创建的新行数。这在我们需要使用空行来分隔输出时很有用。例如，以下示例中添加的 `5` 在输出中添加了五行空行：
- en: '[PRE55]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Justifying Output
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出对齐
- en: The `format` command also gives us a lot of control over text justification.
    Control sequences allow us to format tables, center text, and perform other useful
    justification feats.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 命令也让我们对文本对齐有了很多控制。控制序列允许我们格式化表格、居中文本以及执行其他有用的对齐技巧。'
- en: 'To help you understand the various justification rules, we’ll create a simple
    function that returns different animal names with varying character lengths:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解各种对齐规则，我们将创建一个简单的函数，该函数返回具有不同字符长度的不同动物名称：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now suppose we want to display a bunch of random animals in a table. We can
    do this by using the `˜t` control sequence. `˜t` can take a parameter that specifies
    the column position at which the formatted value should appear. For example, to
    have our table of animals appear in three columns at the fifth, fifteenth, and
    twenty-fifth character positions, we could create this table:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想在表格中显示一些随机的动物。我们可以通过使用 `˜t` 控制序列来实现这一点。`˜t` 可以接受一个参数，指定格式化值应出现的列位置。例如，为了使我们的动物表格出现在第五、第十五和第二十五个字符位置的三列中，我们可以创建如下表格：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Remember that a `loop` command with a `repeat 10` clause executes the body of
    the loop 10 times. As you can see, use of the `˜t` control sequence caused the
    animals to be laid out in a neatly formatted table.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，带有 `repeat 10` 子句的 `loop` 命令会执行循环体 10 次。正如您所看到的，使用 `˜t` 控制序列导致动物被整齐地排列在表格中。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782580.png.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages782580.png.jpg)'
- en: 'Now suppose we want all the animals be spaced equally apart on a single line.
    To do so, we can use the `˜<` and `˜>` control sequences, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要所有动物在单行上均匀分布。为了做到这一点，我们可以使用 `˜<` 和 `˜>` 控制序列，如下所示：
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s deconstruct this control string to understand how it works:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个控制字符串来了解它是如何工作的：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780168.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780168.png)'
- en: First, the `˜30<` tells the function that we’re initiating a block of justified
    text. The parameter `30` indicates that the block should be 30 characters wide.
    Next, we have three `˜a` control sequences in a row, one for each animal. Each
    `˜a` is separated by `;`, which tells `format` that we’re starting a new value
    to be justified by `˜<`. (The `˜;` sequences indicate where extra spaces should
    be inserted to justify the values.) We then end the justified section with the
    `˜>` command sequence.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`˜30<` 告诉函数我们正在启动一个对齐文本块。参数 `30` 表示该块应该有 30 个字符宽。接下来，我们有一行三个 `˜a` 控制序列，每个动物一个。每个
    `˜a` 都由 `;` 分隔，这告诉 `format` 我们正在开始一个新的值，该值将由 `˜<` 对齐。（`˜;` 序列表示应在何处插入额外空格以对齐值。）然后我们使用
    `˜>` 命令序列结束对齐部分。
- en: 'Because the equal spacing of the animals in each line doesn’t guarantee that
    the columns created by printing multiple lines will be properly aligned, we add
    the `:@` flag to our justification `˜<` command sequence. For example, we can
    create a single, neatly centered column as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每行动物之间的等距分布并不能保证通过打印多行创建的列能够正确对齐，我们在对齐命令序列 `˜<` 中添加了 `:@` 标志。例如，我们可以创建一个整齐居中的单列，如下所示：
- en: '[PRE59]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the same way, we can use `:@` with multiple justified values, centering
    them on the line with additional space at their left and right ends:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `:@` 与多个对齐值一起使用，在行的左右两端添加额外的空间来居中对齐：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This step brings us closer to having three neatly centered columns, but our
    columns are still a bit wavy because we’re aligning the values within a single
    line, without telling `format` to arrange the values using three centered columns.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步让我们更接近于拥有三个整齐居中的列，但我们的列仍然有点波浪状，因为我们是在单行内对齐值，而没有告诉 `format` 使用三个居中对齐的列来排列值。
- en: 'To produce neat columns, we’ll still use the `:@` flag, but we’ll describe
    our rows using three separate 10-character justification sections:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生整齐的列，我们仍然会使用 `:@` 标志，但我们将使用三个独立的 10 个字符对齐部分来描述我们的行：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: At last, we have the nicely centered random animal columns of our dreams!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们拥有了梦想中完美居中的随机动物列！
- en: As you can see, the layout options for `format` are quite flexible. Since we
    often need to create complex lists and tables of data when debugging applications,
    these tricks are very helpful when you need to get a handle on your data, even
    with more complex programs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`format` 的布局选项非常灵活。由于我们在调试应用程序时经常需要创建复杂的数据列表和表格，这些技巧在您需要掌握数据时非常有用，即使是在更复杂的程序中也是如此。
- en: Iterating Through Lists Using Control Sequences
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制序列遍历列表
- en: The `format` function with its many control sequences is practically a programming
    language in its own right. (In fact, many Lispers would call it a *domain-specific
    language*, a concept we will revisit in [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages").) And, like most programming languages, `format` can loop through
    data. It does this using the `˜{` and `˜}` control sequences.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 带有众多控制序列的 `format` 函数实际上是一种编程语言。（事实上，许多 Lisp 程序员会称其为**领域特定语言**，这个概念我们将在第 17
    章（[Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages")）中再次探讨。）而且，像大多数编程语言一样，`format`
    可以遍历数据。它是通过使用 `˜{` 和 `˜}` 控制序列来实现的。
- en: To achieve this looping, pass the `format` function a control string containing
    `˜{` and `˜}`, and a list to iterate through. The part of the control string between
    the `˜{` and `˜}` sequences is treated almost like the body of a loop. It will
    be executed a number of times, depending on the length of the list that follows
    it. The `format` function will iterate through this list, applying each of its
    items to the specified section of the control string.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种循环，请将包含 `˜{` 和 `˜}` 的控制字符串和要迭代的列表传递给 `format` 函数。控制字符串中 `˜{` 和 `˜}` 序列之间的部分几乎像循环的主体。它将被执行多次，具体取决于其后列表的长度。`format`
    函数将遍历这个列表，将每个项目应用于指定的控制字符串部分。
- en: 'For example, let’s create a list of animals that we can use for testing:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个动物列表，我们可以用它来测试：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now we use the `˜{ ˜}` control sequences to to loop through this list:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `˜{ ˜}` 控制序列来遍历这个列表：
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To produce this loop, we simply pass the single variable `*animals*`, a list
    of items, to the `format` function. The control string iterates through the list,
    constructing the sentence `"I see a ˜a"` for each member of `*animals*`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成这个循环，我们只需将单个变量 `*animals*`，一个项目列表，传递给 `format` 函数。控制字符串会遍历列表，为 `*animals*`
    的每个成员构造句子 `"我看到一个 ˜a"`。
- en: 'A single iteration construct can also grab more than one item from the list,
    as in this example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 单个迭代结构也可以从列表中获取多个项目，如下例所示：
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we have two `˜a` control sequences within a single looping construct.
    Each `˜a` pulls a single animal from the list, so two animals print for every
    iteration of the loop.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个单独的循环结构中包含两个 `˜a` 控制序列。每个 `˜a` 从列表中拉取一个动物，因此每次循环迭代都会打印出两个动物。
- en: A Crazy Formatting Trick for Creating Pretty Tables of Data
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建漂亮数据表的疯狂格式化技巧
- en: Let’s look at one last `format` example that uses some of the control sequences
    you’ve already seen, as well as some new ones. This example will illustrate how
    the varied control sequences can be combined for complex behavior.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最后一个 `format` 示例，它使用了一些你已经见过的控制序列，以及一些新的控制序列。这个例子将说明如何将不同的控制序列组合起来以实现复杂的行为。
- en: '[PRE65]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To create this nicely formatted table of numbers, we first use the looping control
    sequences `˜{ ˜}` to iterate through a list of numbers created by the `loop` command.
    Within the iteration, we place justification control sequences `˜< ˜>`, which
    we’ve used earlier. In this case, we don’t use them to justify our text, but instead
    use them to divide the resulting text into pieces. This is how we break our 100
    numbers into nice clean rows of 10\. We place the `˜:;` control sequence inside
    our justification control sequences `˜< ˜>`, which causes text to be broken into
    pieces of equal length.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个格式良好的数字表，我们首先使用循环控制序列 `˜{ ˜}` 通过 `loop` 命令创建的数字列表进行迭代。在迭代过程中，我们放置了之前使用过的对齐控制序列
    `˜< ˜>`。在这种情况下，我们不是用它们来对齐文本，而是用它们来将生成的文本分成几部分。这就是我们将100个数字分成10行整洁的行的方法。我们在对齐控制序列
    `˜< ˜>` 内放置了 `˜:;` 控制序列，这将导致文本被分成等长的片段。
- en: When used inside a justification, the control string preceding this sequence
    `˜:;` (which in this case happens to be `|˜%|`) will be triggered only if the
    current cursor position is beyond a certain point, as specified by the second
    parameter, `33`. In other words, we’re telling the format function “Hey, once
    you have 33 characters’ worth of text, start a fresh line.”
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当在对齐中使用时，此序列之前的控制字符串 `˜:;`（在这种情况下恰好是 `|˜%|`）只有在当前光标位置超过由第二个参数指定的某个点时才会触发，即 `33`。换句话说，我们是在告诉格式化函数：“嘿，一旦你有33个字符的文本，就开启一个新行。”
- en: The `|˜%|` control string causes the line break and vertical bars to be printed.
    The number to be displayed is formatted using `˜2d`, which prints a left-justified
    number, two characters wide.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`|˜%|` 控制字符串会导致换行并打印垂直线。要显示的数字使用 `˜2d` 格式化，这将打印一个左对齐的数字，宽度为两个字符。'
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For full details on every single control sequence, see the *Common Lisp HyperSpec*
    at [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解每个控制序列的详细信息，请参阅 *Common Lisp HyperSpec* 在 [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm)。
- en: Attack of the Robots!
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人攻击！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780825.png.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780825.png.jpg)'
- en: 'Here, we look at a game so horrifying that it’s sure to give you nightmares:
    Attack of the Robots! In this game, robots have taken over the world, and it’s
    your job to destroy them. Though the plot may sound scary, the part of this game
    that will *really* give a Lisp programmer nightmares is the way it abuses the
    `loop` and `format` commands in order to squeeze a fully functional robot-fighting
    game into a *single page of code!* (This program uses the “crazy formatting trick”
    discussed in the previous section.)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看看一个如此恐怖的游戏，它肯定会让你做噩梦：机器人攻击！在这个游戏中，机器人已经占领了世界，你的任务是摧毁它们。尽管情节可能听起来很可怕，但这个游戏真正会给
    Lisp 程序员带来噩梦的部分是它滥用 `loop` 和 `format` 命令，以便将一个功能齐全的机器人战斗游戏压缩到 *单页代码* 中！（此程序使用了上一节中讨论的“疯狂格式化技巧”）
- en: I have annotated the code with some basic explanations. If you want to understand
    how the game works in detail, you’ll need to review most of the information from
    the previous couple of chapters. Also, you can visit [http://landoflisp.com/](http://landoflisp.com/)
    to download the source code for the game and read a more thorough explanation
    of the code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经用一些基本解释注释了代码。如果你想详细了解游戏是如何工作的，你需要回顾前几章的大部分信息。此外，你可以访问[http://landoflisp.com/](http://landoflisp.com/)下载游戏的源代码，并阅读代码的更详细解释。
- en: To win the game, you need to strategically walk around the field to cause all
    robots to collide with each other. The movement keys are QWE/ASD/ZXC. These characters
    form a grid on the left side of your keyboard, letting you move up, down, left,
    right, as well as diagonally. You can also teleport with the T key.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要赢得游戏，你需要策略性地在场上移动，以使所有机器人相互碰撞。移动键是 QWE/ASD/ZXC。这些字符在你的键盘左侧形成一个网格，让你可以向上、向下、向左、向右移动，也可以斜向移动。你还可以使用
    T 键进行传送。
- en: Enjoy!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 享受吧！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783256.png.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783256.png.jpg)'
- en: What You've Learned
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'This chapter didn’t really even come close to covering all of the features
    of the `format` function. However, it did provide an introduction, in which you
    learned the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并没有真正涵盖 `format` 函数的所有功能。然而，它确实提供了一个介绍，其中你学习了以下内容：
- en: The first parameter of the `format` command determines whether the output is
    sent to the REPL, a stream, or returned as a string.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 命令的第一个参数决定了输出是发送到 REPL、流还是作为字符串返回。'
- en: The second parameter of the `format` command is a *control string* that lets
    you change the way your data is printed. The control string has a sophisticated
    syntax, acting almost like a programming language in its own right.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 命令的第二个参数是一个 *控制字符串*，它允许你改变数据打印的方式。控制字符串具有复杂的语法，几乎可以像一门编程语言一样独立存在。'
- en: The remaining `format` parameters are values that can be referenced from the
    control string to embed values into the formatted output.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 命令剩余的参数是可以从控制字符串中引用的值，用于将值嵌入到格式化输出中。'
- en: To embed a Lisp value into a formatted string, use the `˜s` or `˜a` control
    sequences.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将 Lisp 值嵌入到格式化字符串中，请使用 `˜s` 或 `˜a` 控制序列。
- en: Many control sequences are available for printing and customizing the appearance
    of numbers.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多控制序列可用于打印和自定义数字的显示外观。
- en: The `format` command also has complex looping abilities that can be used, for
    example, to format tables laid out in many different styles.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 命令还具有复杂的循环能力，可以用于格式化以多种不同风格排列的表格。'
- en: Chapter 12. Working with Streams
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。处理流
- en: Nearly every computer program you write will need to interact with the outside
    world at some point. Perhaps your program just needs to communicate with the user
    through the REPL, printing out information and capturing the user’s input from
    the keyboard. Other programs you write may need to read or write files on a hard
    drive. Additionally, you may want to write programs that interact with other computers,
    either over a local network or the Internet. In Common Lisp, these kinds of interactions
    happen through streams.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎你编写的每个计算机程序都需要在某个时候与外部世界交互。也许你的程序只需要通过 REPL 与用户通信，打印信息并从键盘捕获用户的输入。你编写的其他程序可能需要读取或写入硬盘上的文件。此外，你可能想编写与其他计算机交互的程序，无论是通过本地网络还是互联网。在
    Common Lisp 中，这类交互通过流来实现。
- en: '*Streams* are data types in Common Lisp that allow you to take some external
    resource and make it look like just another simple piece of data you can manipulate
    with your code. The external resource could be a variety of things: a file on
    a disk, another computer on a network, or text in a console window on the screen.
    As you’ll learn in this chapter, through the use of a stream, a Lisp program can
    interact with this outside resource just as easily as it might interact with a
    list or a hash table.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*流* 是 Common Lisp 中的数据类型，它允许你将一些外部资源看作是你可以用代码操作的数据。外部资源可以是各种东西：磁盘上的文件、网络上的另一台计算机，或者是屏幕上控制台窗口中的文本。正如你将在本章中学到的，通过使用流，Lisp
    程序可以像与列表或哈希表交互一样容易地与外部资源交互。'
- en: Types of Streams
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流的类型
- en: When we communicate with an external resource from a Common Lisp program, we
    do so by using a stream. Different types of streams are available for different
    types of resources. Another factor is the direction of the stream—sometimes you
    will want to write data to a resource, and sometimes you will want to read data
    from a resource.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 Common Lisp 程序与外部资源通信时，我们通过使用流来完成。不同类型的资源有不同的流类型可用。另一个因素是流的流向——有时你可能想向资源写入数据，有时你可能想从资源读取数据。
- en: Streams by Type of Resource
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按资源类型分类的流
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780982.png.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780982.png.jpg)'
- en: 'When organized by the type of resource on which they operate, the following
    are the most commonly used stream types:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当按它们操作的资源类型组织时，以下是最常用的流类型：
- en: '**Console streams**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台流**'
- en: What we’ve been using so far when communicating with the REPL.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止与 REPL 通信时使用的内容。
- en: '**File streams**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件流**'
- en: Let us read and write to files on our hard drive.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在硬盘上的文件中读取和写入。
- en: '**Socket streams**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**套接字流**'
- en: Let us communicate with other computers on a network.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过网络与其他计算机进行通信。
- en: '**String streams**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串流**'
- en: Let us send and receive text from a Lisp string.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Lisp 字符串发送和接收文本。
- en: Of these stream types, string streams are the black sheep of the family. Rather
    than letting you communicate with the outside world, string streams allow you
    to manipulate strings in new and interesting ways.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些流类型中，字符串流是这个家族中的“黑羊”。字符串流不仅让你与外界通信，还允许你以新的和有趣的方式操作字符串。
- en: Streams by Direction
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按方向分类的流
- en: When you write data to a resource, you use *output streams*. For reading data
    from a resource, you use *input streams*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向资源写入数据时，你使用 *输出流*。对于从资源读取数据，你使用 *输入流*。
- en: Output Streams
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出流
- en: 'Output streams are used for tasks such as writing to the REPL, writing to a
    file, or sending information over a socket. At the most primitive level, you can
    do two things with an output stream:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 输出流用于诸如写入 REPL、写入文件或通过套接字发送信息等任务。在最基本层面上，你可以对输出流做两件事：
- en: Check whether the stream is valid.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查流是否有效。
- en: Push a new item onto the stream.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新项目推入流。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780652.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780652.png)'
- en: As you can see, a stream is more restrictive than a true data structure in Lisp.
    For instance, a list supports all of the same features as a stream (we can push
    a new item onto a list with `push` and check if a list is valid with `listp`),
    and we also can do certain tasks with a list that we can’t do with an output stream
    (such as changing items in the list with `setf`). But this limited functionality
    of streams actually makes them useful in many cases.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，流在 Lisp 中比真正的数据结构更受限制。例如，列表支持与流相同的所有功能（我们可以使用 `push` 将新项目推入列表，并使用 `listp`
    检查列表是否有效），我们还可以使用列表执行某些任务，这些任务我们无法使用输出流执行（例如，使用 `setf` 改变列表中的项）。但流这种有限的功能实际上使它们在许多情况下非常有用。
- en: 'To see if we have a valid output stream, we can use the `output-stream-p` function.
    For example, the REPL has an output stream associated with it called `*standard-output*`.
    We can see if this is a valid output stream with the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否有有效的输出流，我们可以使用 `output-stream-p` 函数。例如，REPL 有一个与之关联的输出流，称为 `*standard-output*`。我们可以使用以下代码来检查这是否是一个有效的输出流：
- en: '[PRE66]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A Lisp character is one item that can be pushed onto an output stream using
    the basic command `write-char`. For example, to write the character `#\x` to the
    `*standard-output*` stream, we can run the following command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 字符是一个可以使用基本命令 `write-char` 推入输出流的项目。例如，要将字符 `#\x` 写入 `*standard-output*`
    流，我们可以运行以下命令：
- en: '[PRE67]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code prints an *x* to the standard output (which, in this case, is the
    same as the REPL). Note that this function also returns `nil`, causing the *x*
    and the return value to be printed on the same line. As you saw in [Chapter 6](ch06.html
    "Chapter 6. Interacting with the World: Reading and Printing in Lisp"), this extra
    `nil` is just a side effect of running the code in the REPL. If we ran this command
    as part of a larger program, only the *x* would have printed out.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将一个 *x* 打印到标准输出（在这种情况下，它与 REPL 相同）。请注意，此函数还返回 `nil`，导致 *x* 和返回值在同一行上打印。正如你在
    [第 6 章](ch06.html "第 6 章。与世界交互：在 Lisp 中读取和打印") 中看到的，这个额外的 `nil` 只是代码在 REPL 中运行时的副作用。如果我们把这个命令作为更大程序的一部分运行，只有
    *x* 会被打印出来。
- en: Note
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we’ll discuss only streams based on text characters. In Common
    Lisp, you can also create streams based on other data types. For instance, if
    you’re working with binary data, you may want to send or receive raw bytes instead
    of characters. But for our purposes, manipulating textual data (and hence using
    streams that work with text characters) is the most convenient.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅讨论基于文本字符的流。在Common Lisp中，您还可以创建基于其他数据类型的流。例如，如果您正在处理二进制数据，您可能希望发送或接收原始字节而不是字符。但就我们的目的而言，操作文本数据（因此使用与文本字符一起工作的流）是最方便的。
- en: Input Streams
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入流
- en: 'Input streams are used for reading data. As with output streams, the actions
    that you can perform with an input stream are limited. At the most primitive level,
    you can do two things with an input stream:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 输入流用于读取数据。与输出流一样，您可以使用输入流执行的操作有限。在最基本层面上，您可以使用输入流做两件事：
- en: Check whether the stream is valid.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查流是否有效。
- en: Pop an item off of the stream.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从流中弹出项目。
- en: 'We can see if we have a valid stream with the `input-stream-p` command. For
    instance, as with standard output, the REPL has an associated input stream called
    `*standard-input*`, which we can validate as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`input-stream-p`命令来检查我们是否有有效的流。例如，与标准输出一样，REPL有一个相关的输入流，称为`*standard-input*`，我们可以如下验证：
- en: '[PRE68]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781986.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781986.png)'
- en: 'We can pop an item off the stream with the `read-char` command. Since we’re
    reading from the REPL, we need to type some characters and press enter to send
    the data into the standard input stream:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`read-char`命令从流中弹出项目。由于我们从REPL中读取，我们需要输入一些字符并按回车键将数据发送到标准输入流：
- en: '[PRE69]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you can see, the 1 at the front of the stream was popped off and returned
    by `read-char`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，流前面的1被`read-char`弹出并返回。
- en: USING OTHER COMMANDS TO INTERACT WITH STREAMS
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他命令与流交互
- en: 'In addition to `write-char` and `read-char`, Common Lisp has many other commands
    for interacting with streams. In fact, all the commands for printing and reading
    introduced in [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading
    and Printing in Lisp") can accept a stream as an extra parameter, which lets us
    use Lisp''s powerful input/output abilities with any stream. For instance, we
    can explicitly tell the `print` command to print to `*standard-output*`, as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`write-char`和`read-char`之外，Common Lisp还有许多其他命令用于与流交互。事实上，在[第6章](ch06.html
    "第6章。与世界交互：在Lisp中进行读取和打印")中引入的所有打印和读取命令都可以接受一个流作为额外参数，这使得我们可以使用Lisp强大的输入/输出能力与任何流一起使用。例如，我们可以明确告诉`print`命令将输出打印到`*standard-output*`，如下所示：
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This can be useful when working with streams other than `*standard-output*`,
    as you'll see shortly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这在处理除`*standard-output*`之外的流时可能很有用，您很快就会看到。
- en: Working with Files
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: In addition to using streams to write to and read from the REPL, we can also
    use streams to write to and read from files.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用流在REPL中写入和读取外，我们还可以使用流将数据写入和读取到文件中。
- en: 'You can create a file stream in Common Lisp in several ways. The best way is
    to use the `with-open-file` command. As you’ll see shortly, this command contains
    special bug-prevention features that make it safer to use than other available
    file commands. The following example uses `with-open-file` to write the string
    `"my data"` to a file named `data.txt`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用多种方式在Common Lisp中创建文件流。最好的方法是使用`with-open-file`命令。如您很快就会看到的，此命令包含特殊的错误预防功能，使其比其他可用的文件命令更安全。以下示例使用`with-open-file`将字符串`"my
    data"`写入名为`data.txt`的文件：
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this example, the `with-open-file` command binds the output stream to the
    name `my-stream` ![](httpatomoreillycomsourcenostarchimages783564.png). This causes
    a file output stream to be created with the name `my-stream`. This stream will
    be available within the body of the `with-open-file` command (until the final
    closing bracket ![](httpatomoreillycomsourcenostarchimages783562.png)), and any
    data we send to this stream will end up in the file named `data.txt` on the disk.
    The `print` command references `my-stream` as the destination for its output ![](httpatomoreillycomsourcenostarchimages783562.png).
    Therefore, after running this example, you should find a new file named `data.txt`
    in the folder from which you launched CLISP. This file has the text "`my data`"
    as its content.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`with-open-file` 命令将输出流绑定到名称 `my-stream` ![图片](httpatomoreillycomsourcenostarchimages783564.png)。这将在名为
    `my-stream` 的文件中创建一个文件输出流。这个流将在 `with-open-file` 命令的体内部可用（直到最后的闭合括号 ![图片](httpatomoreillycomsourcenostarchimages783562.png)），并且我们发送到这个流中的任何数据都将最终存储在磁盘上的名为
    `data.txt` 的文件中。`print` 命令将 `my-stream` 作为其输出的目标 ![图片](httpatomoreillycomsourcenostarchimages783562.png)。因此，运行此示例后，你应该在启动
    CLISP 的文件夹中找到一个名为 `data.txt` 的新文件。该文件的内容是文本 "`my data`"。
- en: 'Specifying `:output` as the direction for `with-open-file` creates an output
    stream. To make this an input stream instead, we could change the direction to
    `:input`, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `:output` 作为 `with-open-file` 的方向指定将创建一个输出流。要将其改为输入流，我们可以将方向更改为 `:input`，如下所示：
- en: '[PRE72]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, this causes the data—the same data written to the file in the
    previous example—to be read in from the file.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这导致数据——与上一个示例中写入文件中的相同数据——从文件中读取。
- en: 'As you learned in [Chapter 6](ch06.html "Chapter 6. Interacting with the World:
    Reading and Printing in Lisp"), the `print` and `read` commands can print and
    read any of the basic Common Lisp data types. This functionality makes it easy
    to use streams to store data from your programs to the hard drive. Here is a more
    complicated example that writes an association list (alist) to a file:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [第 6 章](ch06.html "第 6 章。与世界交互：在 Lisp 中读取和打印") 中所学，`print` 和 `read` 命令可以打印和读取任何基本
    Common Lisp 数据类型。这种功能使得使用流将程序数据存储到硬盘驱动器变得容易。以下是一个更复杂的示例，它将关联列表（alist）写入文件：
- en: '[PRE73]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, we’re creating an association table of animals and the sounds
    they make. We create a new alist named `animal-noises` ![](httpatomoreillycomsourcenostarchimages783564.png).
    We put keys for `dog` and `cat` into this list. Now we can write this alist to
    a new file called `animal-noises.txt` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Later, we can easily reconstitute this alist from the file ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在创建一个动物及其发出的声音的关联表。我们创建了一个名为 `animal-noises` 的新 alist ![图片](httpatomoreillycomsourcenostarchimages783564.png)。我们将
    `dog` 和 `cat` 的键放入这个列表中。现在我们可以将这个 alist 写入一个名为 `animal-noises.txt` 的新文件 ![图片](httpatomoreillycomsourcenostarchimages783562.png)。稍后，我们可以轻松地从文件中重新构建这个
    alist ![图片](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'The `with-open-file` command can take keyword parameters that modify its behavior.
    For instance, you can tell the command what to do if a file with the given name
    already exists. In the following example, we’ll display an error message using
    the `:if-exists` keyword parameter:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-open-file` 命令可以接受修改其行为的关键字参数。例如，你可以告诉命令如果存在具有给定名称的文件时应该做什么。在以下示例中，我们将使用
    `:if-exists` 关键字参数显示错误信息：'
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Alternatively, you may simply want the existing file to be overwritten. In
    that case, set the `:if-exists` keyword parameter to `:supersede`, as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能只想覆盖现有的文件。在这种情况下，将 `:if-exists` 关键字参数设置为 `:supersede`，如下所示：
- en: '[PRE75]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `with-open-file` command gives you a very succinct way to work with files.
    Unlike most programming languages, when using this command, you don’t need to
    open and close files manually, and you don’t need to worry about potentially messing
    up your files by failing to properly close them. (Actually, Common Lisp has lower-level
    commands for opening and closing files as well, but `with-open-file` packages
    them in a clean way that hides all the ugly details.)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-open-file` 命令为你提供了一个非常简洁的方式来处理文件。与大多数编程语言不同，当使用此命令时，你不需要手动打开和关闭文件，也不需要担心由于未能正确关闭文件而可能损坏文件。（实际上，Common
    Lisp 也有用于打开和关闭文件的低级命令，但 `with-open-file` 以一种干净的方式将它们打包起来，隐藏了所有丑陋的细节。）'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782374.png.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782374.png.jpg)'
- en: The main purpose of `with-open-file` is to acquire a file resource. It takes
    command of the file and assumes the responsibility of closing it. In fact, even
    if the code inside the `with-open-file` throws an ugly error that stops the program
    dead, `with-open-file` will still close the file properly to make sure this resource
    stays intact.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-open-file`的主要目的是获取文件资源。它控制文件并承担关闭文件的责任。实际上，即使`with-open-file`内部的代码抛出一个丑陋的错误，停止程序运行，`with-open-file`仍然会正确关闭文件，以确保该资源保持完整。'
- en: Note
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Common Lisp has many commands that begin with `with-` that will safely allocate
    resources in this way. These `with-` commands, available in the core Lisp libraries,
    are built with Lisp’s awesome macro system. You’ll learn more about Lisp macros,
    and how to create your own `with-` commands, in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp有许多以`with-`开头的命令，可以安全地以这种方式分配资源。这些`with-`命令，可在核心Lisp库中找到，是用Lisp的强大宏系统构建的。你将在[第16章](ch18.html
    "第16章。Lisp宏的魔力")中了解更多关于Lisp宏的知识，以及如何创建自己的`with-`命令。
- en: Working with Sockets
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与套接字一起工作
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779968.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779968.png)'
- en: Now that we’ve used streams to communicate with the REPL and with files, let’s
    see how we can use them to communicate with another computer.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用流与REPL和文件进行通信，让我们看看我们如何使用它们与另一台计算机进行通信。
- en: If you want to write a program that can communicate with another computer elsewhere
    on a standard network (almost all networks nowadays use the TCP/IP protocol),
    you’ll first need to create a socket. A *socket* is a mechanism for routing data
    over a computer network between programs running on different computers on that
    network.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要编写一个可以与标准网络（几乎所有网络现在都使用TCP/IP协议）上其他地方的计算机进行通信的程序，你首先需要创建一个套接字。*套接字*是在计算机网络上在运行在不同计算机上的程序之间路由数据的机制。
- en: Unfortunately, sockets didn’t make it into the ANSI Common Lisp standard, which
    means there’s no standard way of interacting with sockets at this time. However,
    every version of Common Lisp supports sockets, even if it doesn’t follow any standard.
    Since we’ve been using CLISP as our Lisp of choice in this book, we’ll consider
    only CLISP’s socket commands.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，套接字没有进入ANSI Common Lisp标准，这意味着目前没有标准的方式来与套接字交互。然而，每个版本的Common Lisp都支持套接字，即使它不遵循任何标准。由于我们在这本书中选择了CLISP作为我们的Lisp，我们将只考虑CLISP的套接字命令。
- en: Note
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: cl-sockets *(*[http://common-lisp.net/project/cl-sockets/](http://common-lisp.net/project/cl-sockets/)*)*
    and usocket *(*[http://common-lisp.net/project/usocket/](http://common-lisp.net/project/usocket/)*)*
    are two attempts at adding a standard socket library to Common Lisp.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: cl-sockets *(*[http://common-lisp.net/project/cl-sockets/](http://common-lisp.net/project/cl-sockets/)*)*
    和 usocket *(*[http://common-lisp.net/project/usocket/](http://common-lisp.net/project/usocket/)*)*
    是将标准套接字库添加到Common Lisp的两种尝试。
- en: Socket Addresses
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字地址
- en: 'Every socket within a network must have a *socket address*. This socket address
    has two components:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的每个套接字都必须有一个*套接字地址*。这个套接字地址有两个组成部分：
- en: '**IP address**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP地址**'
- en: A number that uniquely identifies a computer on the network (typically shown
    as 4 bytes delimited by periods, such as 192.168.33.22).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一个唯一标识网络中计算机的数字（通常以点分隔的4个字节表示，例如192.168.33.22）。
- en: '**Port number**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口号**'
- en: Any programs that want to use the network must choose a unique port number that
    no other program on the same computer is already using.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 任何想要使用网络的程序都必须选择一个唯一的端口号，这个端口号在该计算机上的其他程序尚未使用。
- en: The IP address and the port number combine to make up the socket address. Since
    the IP address is unique on a network and the port number is unique for a given
    computer, every socket address on a network is unique to a specific program running
    on a specific computer. Any messages running over the network (through chunks
    of data called *TCP packets*) will be labeled with a socket address to indicate
    their destination.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址和端口号组合起来构成套接字地址。由于IP地址在网络中是唯一的，端口号对于给定的计算机是唯一的，因此网络上的每个套接字地址都是特定计算机上运行的特定程序的唯一标识。通过网络（通过称为*TCP数据包*的数据块）传输的任何消息都将带有套接字地址，以指示其目的地。
- en: Once a computer receives a packet labeled with its IP address, the operating
    system will look at the port number in the socket address of the message to figure
    out which program should receive the message.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算机收到标记有其IP地址的数据包，操作系统将查看消息的套接字地址中的端口号，以确定哪个程序应该接收该消息。
- en: And how does the operating system know which program receives messages for a
    given port? It knows this because a program first must create a socket for that
    port in order to use it. In other words, a socket is simply a way for a computer
    program to tell the operating system, “Hey, if you get any messages on port 251,
    send them my way!”
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统是如何知道哪个程序接收指定端口的消息的呢？因为它知道，一个程序必须首先为该端口创建一个套接字才能使用它。换句话说，套接字就是计算机程序告诉操作系统的一种方式：“嘿，如果你收到端口251上的任何消息，请将它们发送给我！”
- en: Socket Connections
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字连接
- en: In order to actually send a message over a socket between two programs, we first
    need to follow some steps to initialize a *socket connection*. The first step
    in creating such a connection is to have one of the programs create a socket that
    starts in a listening state, waiting to see if other programs on the network want
    to start a communication. The computer with the socket in a listening state is
    called the *server*. Then the other program, called a *client*, creates a socket
    on its end and uses it to establish a connection with the server. If all goes
    well, these two programs can now transmit messages across the socket connection
    running between them.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在两个程序之间通过套接字发送消息，我们首先需要遵循一些步骤来初始化一个 *套接字连接*。创建此类连接的第一步是让其中一个程序创建一个处于监听状态的套接字，等待查看网络上是否有其他程序想要开始通信。拥有处于监听状态套接字的计算机被称为
    *服务器*。然后，另一个程序（称为 *客户端*）在其端创建一个套接字，并使用它来与服务器建立连接。如果一切顺利，这两个程序现在可以通过它们之间运行的套接字连接传输消息。
- en: But enough talk. Let’s try connecting two programs right now to see the magic
    happen for ourselves!
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 但说得够多了。让我们现在尝试连接两个程序，亲自看看魔法是如何发生的！
- en: Sending a Message over a Socket
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过套接字发送消息
- en: First, open two copies of CLISP in two different console windows on your computer.
    We’ll call one the client and one the server. (Or, if you have two computers on
    a network and know their IP addresses, you can create the two consoles on two
    separate machines, for the full network experience.)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的计算机上打开两个CLISP副本，分别在两个不同的控制台窗口中。我们将一个称为客户端，另一个称为服务器。（或者，如果你在一个网络上有两台计算机并且知道它们的IP地址，你可以在两个不同的机器上创建两个控制台，以获得完整的网络体验。）
- en: Note
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You *must* use CLISP to get the socket code shown in this chapter to run.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你 *必须* 使用CLISP来运行本章中显示的套接字代码。
- en: 'On the server, take control of a port by calling `socket-server`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，通过调用 `socket-server` 来控制一个端口：
- en: '[PRE76]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This command acquires port 4321 and binds a socket to it using the operating
    system. The socket is bound to the `my-socket` variable so that we can interact
    with it.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令获取端口4321并将套接字绑定到它，使用操作系统。套接字绑定到 `my-socket` 变量，这样我们就可以与之交互。
- en: This command is somewhat dangerous, because the operating system is expecting
    us to give up the socket once we’re finished with it. If we don’t, no one will
    be able to use this socket anymore. In fact, if you make any mistakes during this
    socket exercise, you could mess up the socket at port 4321, and then you would
    need to switch to another port number until you restart your computer. (In the
    next chapter, you’ll learn how to use the exception handling system in Common
    Lisp to work around these ugly problems.)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令有些危险，因为操作系统期望我们在完成套接字后放弃它。如果我们不这样做，就没有人能够再使用这个套接字了。实际上，如果你在套接字练习中犯了任何错误，你可能会弄乱端口4321上的套接字，然后你需要切换到另一个端口号，直到你重新启动计算机。（在下一章中，你将学习如何使用Common
    Lisp的异常处理系统来绕过这些丑陋的问题。）
- en: 'Next, let’s make a stream from this socket (still on the server) that handles
    a connection from a single client:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从这个套接字（仍然在服务器上）创建一个流，该流处理来自单个客户端的连接：
- en: '[PRE77]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: After running this command, the server will seem to lock up, and you won’t be
    returned to the REPL prompt. Don’t be alarmed—the `socket-accept` command is a
    *blocking operation*, which means the function won’t exit until a client has connected.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，服务器似乎会锁定，并且你不会返回到REPL提示符。不要惊慌——`socket-accept` 命令是一个 *阻塞操作*，这意味着函数不会退出，直到客户端已连接。
- en: 'Now switch over to your client CLISP and use the `socket-connect` command to
    connect to that socket on the server:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到你的客户端CLISP，并使用 `socket-connect` 命令连接到服务器上的那个套接字：
- en: '[PRE78]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The IP address 127.0.0.1 is a special address that always points to the computer
    from which it’s called. If you are using two different computers for this exercise,
    you should enter the actual IP address of your server.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址127.0.0.1是一个特殊的地址，它始终指向调用它的计算机。如果你为这个练习使用了两台不同的计算机，你应该输入服务器的实际IP地址。
- en: After running this command, the server will unlock, and the value of the `my-stream`
    variable will be set. We now have a stream open in both copies of CLISP, and we
    can use it to communicate between them!
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，服务器将解锁，`my-stream` 变量的值将被设置。我们现在在 CLISP 的两个副本中都有一个打开的流，我们可以用它来在它们之间进行通信！
- en: The stream CLISP has created here is called a *bidirectional* stream. This means
    it can act both as an input stream and an output stream, and we can use either
    set of commands on it to communicate in both directions. Let’s send a cordial
    greeting between the client and the server.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: CLISP 在这里创建的流被称为 *双向* 流。这意味着它可以作为输入流和输出流，我们可以使用任何一组命令与之通信，以双向进行通信。让我们在客户端和服务器之间发送一个友好的问候。
- en: 'Enter the following on the client:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端输入以下内容：
- en: '[PRE79]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And enter the following on the server:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上输入以下内容：
- en: '[PRE80]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, still on the server, enter this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，仍然在服务器上，输入以下内容：
- en: '[PRE81]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Back on the client, run this command:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 回到客户端，运行以下命令：
- en: '[PRE82]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here’s what your two CLISP windows should look like when you’re finished:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的两个 CLISP 窗口应该看起来像这样：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780950.png.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780950.png.jpg)'
- en: The message we sent across the socket was a Lisp string, but because of Lisp’s
    elegant stream-handling capabilities, we could send almost any standard Lisp data
    structure in the same way, without any extra effort!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过套接字发送的消息是一个 Lisp 字符串，但由于 Lisp 优雅的流处理能力，我们可以以相同的方式发送几乎任何标准的 Lisp 数据结构，而无需任何额外的工作！
- en: Tidying Up After Ourselves
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整理我们的工作
- en: 'It’s crucial that we free up the resources we’ve created during this exercise.
    First, run the following command on *both* the client and the server to close
    the stream on both ends:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建的资源释放至关重要。首先，在客户端和服务器上运行以下命令来关闭两端的流：
- en: '[PRE83]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Next, run `socket-server-close` on the server to free up the port and disconnect
    the socket from it. If you don’t, port 4321 will be unusable until you reboot.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在服务器上运行 `socket-server-close` 命令来释放端口，并断开与该端口的套接字连接。如果不这样做，端口 4321 将无法使用，直到你重新启动。
- en: '[PRE84]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'String Streams: The Oddball Type'
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串流：怪异类型
- en: Streams are usually used for communicating with the outside world from within
    a Lisp program. One exception to this is the string stream, which simply makes
    a string look like a stream. In the same way you can read or write to external
    resources with other types of streams, a string stream will let you read or write
    to a string.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 流通常用于从 Lisp 程序内部与外部世界通信。一个例外是字符串流，它只是让字符串看起来像流。就像你可以使用其他类型的流读取或写入外部资源一样，字符串流将允许你读取或写入字符串。
- en: 'You can create string streams with the `make-string-output-stream` and `make-string-input-stream`
    commands. Following is an example that uses `make-string-output-stream`:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `make-string-output-stream` 和 `make-string-input-stream` 命令创建字符串流。以下是一个使用
    `make-string-output-stream` 的示例：
- en: '[PRE85]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You may be wondering why anyone would want to do this, since we can already
    directly manipulate strings in Lisp, without using streams. Actually, there are
    several good reasons for using string streams in this way. They are useful for
    debugging, as well as for creating complex strings efficiently.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么有人会想要做这件事，因为我们已经可以直接在 Lisp 中操作字符串，而不需要使用流。实际上，使用字符串流这种方式有几个很好的理由。它们在调试时很有用，而且可以有效地创建复杂的字符串。
- en: Sending Streams to Functions
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将流发送到函数
- en: Using string streams allows us to use functions that require streams as parameters.
    This is great for debugging code that works with files or sockets, using only
    strings for the input and output of data.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串流允许我们使用需要流作为参数的函数。这对于仅使用字符串作为数据输入和输出的文件或套接字代码的调试来说非常棒。
- en: For example, suppose we have a function `write-to-log` that writes log information
    to a stream. Usually, we would want to send the log information to a file stream,
    so it can be written to a file for safekeeping. However, if we want to debug the
    function, we may want to send it a string stream instead, so we can take a look
    at the data it writes and make sure it’s correct. If we had hard-coded the `write-to-log`
    function to only write to a file, we wouldn’t have this flexibility. This is why
    it makes sense to write functions to use the abstract concept of a stream whenever
    possible, instead of using other methods to access external resources.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个`write-to-log`函数，它将日志信息写入流。通常，我们希望将日志信息发送到文件流，以便将其写入文件以进行安全存储。然而，如果我们想调试该函数，我们可能希望将其发送到字符串流，这样我们就可以查看它写入的数据并确保其正确性。如果我们将`write-to-log`函数硬编码为仅写入文件，我们就不会有这种灵活性。这就是为什么在可能的情况下，编写使用流这一抽象概念的功能函数而不是使用其他方法访问外部资源是有意义的。
- en: Working with Long Strings
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理长字符串
- en: String streams can lead to better-performing code when dealing with very long
    strings. For instance, concatenating two strings together can be a costly operation—first,
    it requires a new block of memory to be allocated to hold both strings, and then
    the strings need to be copied into this new location. Because of this bottleneck,
    many programming languages use devices called *string builders* to avoid this
    overhead. In Lisp, we can get similar performance benefits by using string streams.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理非常长的字符串时，字符串流可以使代码的性能更好。例如，将两个字符串连接起来可能是一个昂贵的操作——首先，它需要一个新块内存来存储两个字符串，然后字符串需要被复制到这个新位置。由于这个瓶颈，许多编程语言使用称为*字符串构建器*的设备来避免这种开销。在Lisp中，我们可以通过使用字符串流获得类似性能的好处。
- en: Reading and Debugging
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读和调试
- en: Another reason for using string streams is that they can make our code easier
    to read and debug, especially when we use the `with-output-to-string` macro.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串流的另一个原因是它们可以使我们的代码更容易阅读和调试，尤其是在我们使用`with-output-to-string`宏时。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781306.png.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781306.png.jpg)'
- en: 'Here’s an example of this command being used:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用此命令的例子：
- en: '[PRE86]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `with-output-to-string` macro ![](httpatomoreillycomsourcenostarchimages783564.png)
    will intercept any text that would otherwise be output to the console, REPL, or
    other output stream, and capture it as a string. In the preceding example, the
    output created by the `princ` functions ![](httpatomoreillycomsourcenostarchimages783562.png)
    within the body of the `with-output-to-string` call is redirected automatically
    into a string stream. Once the body of the `with-output-to-string` command has
    completed, the entire printed output that was put into the stream is returned
    as a result ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-output-to-string`宏![图片](httpatomoreillycomsourcenostarchimages783564.png)将拦截任何本应输出到控制台、REPL或其他输出流的文本，并将其捕获为字符串。在前面的例子中，`with-output-to-string`调用体内的`princ`函数![图片](httpatomoreillycomsourcenostarchimages783562.png)创建的输出被自动重定向到字符串流中。一旦`with-output-to-string`命令的主体完成，整个放入流中的打印输出将作为结果返回![图片](httpatomoreillycomsourcenostarchimages783560.png)。'
- en: You can also use the `with-output-to-string` macro to easily construct complex
    strings by “printing” each part, and then capturing the result as a string. This
    tends to be much more elegant and efficient than using the `concatenate` command.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`with-output-to-string`宏通过“打印”每个部分来轻松构建复杂的字符串，然后将结果捕获为字符串。这通常比使用`concatenate`命令更加优雅和高效。
- en: Note
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `with-output-to-string` runs counter to the tenets of functional programming
    (discussed in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with
    Functional Programming")). Some Lispers consider this function (and similar functions
    that intercept input or output intended for other destinations) to be an ugly
    hack. You’ll see some disagreement in the Lisp community about whether the use
    of `with-output-to-string` is elegant or ugly.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with-output-to-string`与函数式编程的原则（在第14章中讨论）相悖。一些Lisper认为这个函数（以及拦截输入或输出到其他目的地的类似函数）是一种丑陋的修补。你会在Lisp社区中看到一些关于`with-output-to-string`的使用是优雅的还是丑陋的争议。
- en: What You've Learned
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'This chapter described how to use streams to let your Lisp programs interact
    with outside resources. You learned the following:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用流使您的Lisp程序与外部资源交互。你学习了以下内容：
- en: Different types of streams interact with different types of resources. These
    include *console streams*, *file streams*, *socket streams*, and *string streams*.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的流与不同类型的资源交互。这些包括*控制台流*、*文件流*、*套接字流*和*字符串流*。
- en: Streams can be categorized based on their direction. *Output streams* let us
    write to a resource. *Input streams* let us read from a resource.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流可以根据其方向进行分类。*输出流*让我们可以向资源写入。*输入流*让我们可以从资源读取。
- en: Socket streams allow computer programs to communicate over a network. To establish
    a socket stream, we must first open sockets on both ends and open a socket connection
    between the programs.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字流允许计算机程序通过网络进行通信。为了建立套接字流，我们首先需要在两端打开套接字，并在程序之间建立一个套接字连接。
- en: String streams allow us to use functions that require streams without linking
    to an outside resource, for debugging purposes. They also are useful for constructing
    complex strings efficiently and elegantly through the use of `with-output-to-string`.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串流允许我们在调试时使用需要流的功能，而不需要链接到外部资源。它们也通过使用 `with-output-to-string` 来有效地构建复杂字符串，并且优雅。
- en: Chapter 13. Let's Create a Web Server!
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。让我们创建一个 Web 服务器！
- en: 'In [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and
    Printing in Lisp"), you learned how to interact with a user by sending text to
    and from the REPL. However, when people talk about “interacting with a user” these
    days, they’re usually referring to a user on the Web. In this chapter, you’re
    going to learn how to interact with users on the Web by building a web server
    from scratch. Since communications over a network are error prone by their nature,
    you’ll first learn how errors are handled in Lisp.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](ch06.html "第 6 章。与世界交互：在 Lisp 中读取和打印")中，你学习了如何通过向 REPL 发送和接收文本与用户交互。然而，当人们现在谈论“与用户交互”时，他们通常指的是
    Web 上的用户。在本章中，你将学习如何通过从头开始构建 Web 服务器来与 Web 用户交互。由于网络通信本质上容易出错，你将首先学习 Lisp 中如何处理错误。
- en: Error Handling in Common Lisp
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Common Lisp 中的错误处理
- en: Any time you’re interacting with the outside world, as our web server will,
    unexpected things can happen. No matter how smart a modern computer network may
    be, it can never anticipate every possible exceptional situation. After all, even
    the smartest network can’t recover from some fool tripping over the wrong cable.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候你与外界交互，就像我们的 Web 服务器将要做的那样，都可能发生意外的事情。无论现代计算机网络多么聪明，它都无法预见到每一个可能出现的异常情况。毕竟，即使是最聪明的网络也无法从某个笨蛋绊倒在错误电缆上而恢复过来。
- en: Common Lisp has a very extensive set of features for dealing with unexpected
    exceptional situations in your code. This exception handling system is very flexible,
    and it can be used to do things that are impossible with exception systems in
    most other languages.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 提供了一套非常广泛的功能来处理代码中意外异常情况。这个异常处理系统非常灵活，它可以用来做其他大多数语言中异常系统不可能做到的事情。
- en: Signaling a Condition
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发出条件信号
- en: If you’re writing a function and something goes horribly wrong, a Lisp function
    can notify the Lisp environment that a problem has been encountered. This is done
    by *signaling a condition*. What sort of things could go wrong? Maybe a function
    tried to divide by zero. Or maybe a library function received a parameter of the
    wrong type. Or maybe a socket communication was interrupted because you tripped
    over your network cable.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个函数，并且出了严重的错误，Lisp 函数可以通知 Lisp 环境，已经遇到了问题。这是通过*发出一个条件信号*来完成的。可能会发生什么问题呢？也许一个函数尝试除以零。或者也许库函数接收到了错误类型的参数。或者也许是因为你绊倒了网络电缆，套接字通信被中断了。
- en: 'If you want to signal a condition directly, you can do so with the `error`
    command. You would do this if a function you wrote detected a problem on its own—a
    problem so serious the program just could not continue normally. Using the `error`
    command will interrupt your running Lisp program, unless you intercept the error
    elsewhere to prevent an interruption. Let’s signal a condition and print the message
    “foo” to describe the error:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接发出一个条件信号，你可以使用 `error` 命令。如果你写的函数自己检测到问题——一个严重到程序无法正常继续的问题，你会这样做。使用 `error`
    命令将中断你的运行中的 Lisp 程序，除非你在其他地方拦截错误以防止中断。让我们发出一个条件信号，并打印消息“foo”来描述错误：
- en: '[PRE87]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you can see, signaling this condition causes Lisp to interrupt our program,
    print the message “foo,” and show an error prompt at the REPL. (In CLISP, you
    can type **`:a`** at this point to abort the program and return to the normal
    REPL.)
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，发出这个条件会导致 Lisp 中断我们的程序，打印消息“foo”，并在 REPL 中显示错误提示。（在 CLISP 中，您可以在此时输入 **`:a`**
    来终止程序并返回到正常的 REPL。）
- en: Most of the time your program signals a condition, it will probably not be because
    you called `error` yourself. Instead, it will be because your program has a bug,
    or because you called a library function, and that function signals a condition.
    However, any time something prevents normal execution in your program, leading
    to a condition, your program will stop and show an error prompt such as in the
    preceding example.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当您的程序发出条件时，这很可能不是因为您自己调用了 `error`。相反，这可能是由于您的程序有错误，或者您调用了库函数，而这个函数发出了一个条件。然而，任何阻止程序正常执行并导致条件的事情，您的程序都会停止并显示一个类似于前面示例的错误提示。
- en: Creating Custom Conditions
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义条件
- en: In our first example, we passed a string describing the condition to the `error`
    command. However, this text string just customizes the error message and doesn’t
    lead to a different “type” of condition. Common Lisp also allows you to have various
    types of conditions that can be handled in different ways.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们将描述条件的字符串传递给了 `error` 命令。然而，这个文本字符串只是自定义了错误信息，并不会导致不同“类型”的条件。Common
    Lisp 也允许你拥有各种类型的条件，这些条件可以用不同的方式处理。
- en: 'A more sophisticated way to signal conditions is to first define a custom condition
    using `define-condition`, as in the following example:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 信号条件的一种更复杂的方式是首先使用 `define-condition` 定义一个自定义条件，如下面的示例所示：
- en: '[PRE88]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is a typical example of creating a new type of condition, which we’ve named
    `foo` ![](httpatomoreillycomsourcenostarchimages783564.png). When this condition
    is signaled, we can supply a custom function that will be called to report the
    error. Here, we declare a lambda function for this purpose ![](httpatomoreillycomsourcenostarchimages783562.png).
    Within the lambda function, we print a custom message to report the error ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建新类型条件的典型例子，我们将其命名为 `foo`！[](httpatomoreillycomsourcenostarchimages783564.png)。当这个条件被发出时，我们可以提供一个自定义函数，该函数将被调用以报告错误。在这里，我们声明了一个
    lambda 函数来完成这个目的！[](httpatomoreillycomsourcenostarchimages783562.png)。在 lambda
    函数内部，我们打印一个自定义消息来报告错误！[](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'Let’s see what happens when we trigger this new condition:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看触发这个新条件会发生什么：
- en: '[PRE89]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As you can see, our custom message was printed. This technique allows the programmer
    to get a more meaningful error report, customized for the specific condition that
    was triggered.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的自定义消息已被打印出来。这种技术允许程序员获得一个更有意义的错误报告，该报告针对触发特定条件的具体情况进行了定制。
- en: Intercepting Conditions
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拦截条件
- en: 'When we create a condition with `define-condition`, it’s given a name (such
    as `foo`). This name can be used by the higher-level parts of our program to intercept
    and handle that condition, so it won’t stop the program’s execution. We can do
    this with the `handler-case` command, as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `define-condition` 创建一个条件时，它会赋予一个名称（例如 `foo`）。这个名称可以被程序的高级部分用来拦截和处理该条件，这样就不会停止程序的执行。我们可以通过
    `handler-case` 命令来实现，如下所示：
- en: '[PRE90]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The first thing we put inside a `handler-case` command is the piece of code
    that may signal conditions that we want to handle ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handler-case` 命令中，我们首先放入的是可能会发出我们想要处理的条件的代码片段！[](httpatomoreillycomsourcenostarchimages783564.png)。
- en: In this example, the code we’re watching is a call to `bad-function`. The rest
    of `handler-case` lets us specify actions to perform if a particular condition
    occurs ![](httpatomoreillycomsourcenostarchimages783562.png). When this code is
    run, `bad-function` signals the `foo` condition by calling `(error 'foo)`. Usually,
    this would cause our program to be interrupted and lead to a error prompt at the
    REPL. However, our `handler-case` command intercepts the `foo` condition ![](httpatomoreillycomsourcenostarchimages783562.png).
    This means that the program can keep running without interruption, with the `handler-case`
    evaluating as “somebody signaled foo!” ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在观察的代码是对 `bad-function` 的调用。`handler-case` 的其余部分允许我们指定在特定条件发生时要执行的操作
    ![http://atomoreilly.com/source/no_starch_images/783562.png]。当这段代码运行时，`bad-function`
    通过调用 `(error 'foo)` 触发 `foo` 条件。通常，这会导致我们的程序中断，并在 REPL 中出现错误提示。然而，我们的 `handler-case`
    命令拦截了 `foo` 条件 ![http://atomoreilly.com/source/no_starch_images/783562.png]。这意味着程序可以继续运行而不会中断，`handler-case`
    评估为“有人发出了 foo 信号！” ![http://atomoreilly.com/source/no_starch_images/783560.png]。
- en: Protecting Resources Against Unexpected Conditions
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止资源受到意外条件的影响
- en: When an unexpected exception happens in a program, there is always a risk that
    it could bring down your program, or even cause damage to resources outside your
    program. Exceptions interrupt the regular flow of your code, and they may stop
    your code dead in its tracks, even while it’s in the middle of a sensitive operation.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中发生意外异常时，总有可能导致程序崩溃，甚至可能对程序外的资源造成损害。异常会中断代码的正常流程，并且它们可能会在代码进行敏感操作时立即停止。
- en: For instance, your program may be writing to a file or to a socket stream when
    an unexpected exception happens. In this case, it is critically important that
    your program has an opportunity to close the file/socket stream and free the file
    handle or socket; otherwise, that resource may become locked indefinitely. If
    such resources aren’t cleaned up properly, the users may need to reboot their
    computer first before the resource becomes available again.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当程序遇到意外异常时，它可能正在向文件或套接字流写入数据。在这种情况下，程序有机会关闭文件/套接字流并释放文件句柄或套接字至关重要；否则，该资源可能会无限期地锁定。如果这些资源没有得到适当的清理，用户可能需要首先重新启动计算机，资源才能再次可用。
- en: 'The `unwind-protect` command can help us to avoid these problems. With this
    command, we can tell the Lisp compiler, “This piece of code must run no matter
    what happens.” Consider the following example:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`unwind-protect` 命令可以帮助我们避免这些问题。使用这个命令，我们可以告诉 Lisp 编译器，“无论发生什么，这段代码都必须运行。”考虑以下示例：'
- en: '[PRE91]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Within the `unwind-protect`, we divide by 0, which signals a condition ![](httpatomoreillycomsourcenostarchimages783564.png).
    But even after we tell CLISP to abort, the program still prints its crucial message
    ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `unwind-protect` 中，我们进行除以 0 的操作，这会触发一个条件 ![http://atomoreilly.com/source/no_starch_images/783564.png]。即使我们告诉
    CLISP 终止程序，程序仍然会打印出其关键信息 ![http://atomoreilly.com/source/no_starch_images/783562.png]。
- en: We can usually avoid calling `unwind-protect` directly by relying on Common
    Lisp’s “`with-`” macros; many of these call `unwind-protect` themselves, under
    the hood. In [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros"), we’ll
    create our own macros to see how this is possible.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以通过依赖 Common Lisp 的“`with-`”宏来避免直接调用 `unwind-protect`；其中许多宏在底层会自己调用 `unwind-protect`。在[第
    16 章](ch18.html "第 16 章。Lisp 宏的魔法")中，我们将创建自己的宏来了解这是如何实现的。
- en: Note
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the comic book epilogue at the end of the book, you’ll learn about an additional
    feature of the Common Lisp signaling system called *restarts*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的漫画书尾声中，你将了解 Common Lisp 信号系统的一个附加功能，称为 *restarts*。
- en: Writing a Web Server from Scratch
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始编写 Web 服务器
- en: Now that you have a basic understanding of sockets (covered in [Chapter 12](ch13.html
    "Chapter 12. Working with Streams")) and error handling, you know enough to make
    a web server that can serve dynamic web pages written in Lisp. After all, why
    should Apache (the world’s most popular web server) have all the fun?
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对套接字（在第 12 章[Working with Streams]中介绍）和错误处理有了基本的了解，你已经有足够的知识来创建一个能够服务用
    Lisp 编写的动态网页的 Web 服务器。毕竟，为什么 Apache（世界上最受欢迎的 Web 服务器）要独占所有乐趣呢？
- en: How a Web Server Works
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 服务器是如何工作的
- en: Hypertext Transfer Protocol, or HTTP, is the Internet protocol used for transferring
    web pages. It adds a layer on top of TCP/IP for requesting pages once a socket
    connection has been established. When a program running on a client computer (usually
    a web browser) sends a properly encoded request, the server will retrieve the
    requested page and send it over the socket stream in response.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本传输协议，或 HTTP，是用于传输网页的互联网协议。它在一旦建立了套接字连接后，在 TCP/IP 之上添加了一层，用于请求页面。当运行在客户端计算机上的程序（通常是网络浏览器）发送一个正确编码的请求时，服务器将检索请求的页面并通过套接字流发送它作为响应。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781432.png.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781432.png.jpg)'
- en: Note
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This web server is adapted from *http.lisp*, created by Ron Garret.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络服务器是从由 Ron Garret 创建的 *http.lisp* 中改编而来的。
- en: 'For example, suppose the client is the Firefox web browser, and it asks for
    the page *lolcats.html*. The client’s request might look like this:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设客户端是 Firefox 网络浏览器，并且请求 *lolcats.html* 页面。客户端的请求可能看起来像这样：
- en: '[PRE92]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: For our web server, the most important part of this request is the first line.
    There we can see the type of request made (a `GET` request, which means we just
    want to look at a page without modifying it), and the name of the page requested
    (*lolcats.html*). This data sent to the server is called the *request header*.
    You’ll see later that additional information can be sent to the server below the
    request header, in a *request body*.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络服务器来说，这个请求最重要的部分是第一行。在那里我们可以看到所进行的请求类型（一个 `GET` 请求，这意味着我们只想查看页面而不修改它），以及请求的页面名称
    (*lolcats.html*)。发送到服务器的这些数据被称为 *请求头*。你将在稍后看到，可以在请求头下方发送更多信息到服务器，在 *请求体* 中。
- en: Note
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To readers from the distant future, *lolcats* was a viral Internet phenomenon
    from early in the third millennium. It involved pictures of cats with funny captions.
    If people of your time are no longer familiar with lolcats, it is of no great
    loss.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自遥远未来的读者，*lolcats* 是第三千年早期的一个病毒式互联网现象。它涉及带有有趣标题的猫的图片。如果你们那个时代的人们不再熟悉 lolcats，这并不会造成太大的损失。
- en: 'In response, the server will send an HTML document that represents the web
    page over the socket stream. This is called the *response body*. Here is what
    a response body might look like:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 作为响应，服务器将通过套接字流发送一个表示网页的 HTML 文档。这被称为 *响应体*。以下是一个响应体的示例：
- en: '[PRE93]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: An HTML document is wrapped in `html` opening ![](httpatomoreillycomsourcenostarchimages783564.png)
    and closing tags ![](httpatomoreillycomsourcenostarchimages783554.png). Within
    these tags, you can declare a body section ![](httpatomoreillycomsourcenostarchimages783562.png).
    In the body section, you can write a text message that will be displayed in the
    web browser as the body of the web page![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文档被包裹在 `html` 开头 ![](httpatomoreillycomsourcenostarchimages783564.png)
    和结尾标签 ![](httpatomoreillycomsourcenostarchimages783554.png) 之间。在这些标签内，你可以声明一个主体部分
    ![](httpatomoreillycomsourcenostarchimages783562.png)。在主体部分，你可以写入将在网络浏览器中作为网页主体的文本消息！[](httpatomoreillycomsourcenostarchimages783560.png)。
- en: For a fully HTML-compliant web page, other items must exist in the document,
    such as a DOCTYPE declaration. However, our example will work just fine, and we
    can ignore these technical details for our simple demonstration.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个完全符合 HTML 规范的网页，文档中必须存在其他项目，例如 DOCTYPE 声明。然而，我们的示例将正常工作，并且我们可以忽略这些技术细节以进行简单的演示。
- en: A web server will typically also generate a *response header*. This header can
    give a web browser additional information about the document it has just received,
    such as whether it is in HTML or another format. However, the simplified web server
    we’re going to create does not generate such a header and instead simply returns
    a body.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器通常还会生成一个 *响应头*。这个头可以给网络浏览器提供有关它刚刚接收到的文档的额外信息，例如它是否是 HTML 或其他格式。然而，我们将要创建的简化版网络服务器不会生成这样的头，而是简单地返回一个主体。
- en: Note
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since we’re using CLISP-specific socket commands, you must be running CLISP
    for the sample web server presented in this chapter to work.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 CLISP 特定的套接字命令，你必须运行 CLISP 才能使本章中提供的示例网络服务器正常工作。
- en: Request Parameters
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求参数
- en: Web forms are an essential element in powering websites. For instance, suppose
    we create a simple login form for a website.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 网络表单是使网站运行的基本元素。例如，假设我们为网站创建一个简单的登录表单。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781624.png)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781624.png)'
- en: After the visitor to our website hits the Submit button on this page, it will
    send a `POST` request back to the website. A `POST` request looks very similar
    to the `GET` request in the preceding example. However, a `POST` request usually
    carries the expectation that it may alter data on the server.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当网站访客点击此页面的提交按钮后，它将向网站发送一个`POST`请求。`POST`请求看起来与前面示例中的`GET`请求非常相似。然而，`POST`请求通常意味着它可能会更改服务器上的数据。
- en: In our sample login form, we need to tell the server the user ID and password
    that the visitor to our site had entered into the text fields on this form. The
    values of these fields that are sent to the server as part of the `POST` request
    are called *request parameters*. They are sent within the `POST` request by appending
    them below the request header, in the area that makes up the request body.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例登录表单中，我们需要告诉服务器用户ID和密码，这是访客在此表单的文本字段中输入的。作为`POST`请求一部分发送到服务器的这些字段的值被称为*请求参数*。它们通过在请求头下方附加到请求体中发送。
- en: 'This is what the `POST` request might look like for our login example:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的登录示例中可能出现的`POST`请求：
- en: '[PRE94]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The extra parameter in the header of this `POST` request, `Content-Length`,
    indicates the length of the parameter data at the bottom of the request. Specifically,
    `Content-Length: 39` tells the server that the text containing the request parameters
    ![](httpatomoreillycomsourcenostarchimages783564.png) is 39 characters long.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '这个`POST`请求头部的额外参数`Content-Length`表示请求底部参数数据的长度。具体来说，`Content-Length: 39`告诉服务器包含请求参数的文本（如![http://www.example.com/source/nostarch/images/783564.png]所示）是39个字符长。'
- en: Request Parameters for GET Requests
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`GET`请求的请求参数'
- en: As we’ve discussed, the typical purpose of request parameters is to send web
    form data back to the server during a `POST` request. However, `GET` requests
    may also contain request parameters. Usually, with a `GET` request, we want to
    see what the parameters are in the URL of the request, whereas with a `POST` request,
    the parameters are hidden in the body of the request.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，请求参数的典型用途是在`POST`请求期间将网页表单数据发送回服务器。然而，`GET`请求也可能包含请求参数。通常，在`GET`请求中，我们希望查看请求URL中的参数，而在`POST`请求中，参数则隐藏在请求体中。
- en: For instance, suppose you go to Google and search for “dogs.” In this case,
    the follow-up page will have a URL that reads something like [http://www.google.com/search?q=dogs&hl=en&safe=off&](http://www.google.com/search?q=dogs&hl=en&safe=off&)....
    These values in the URL (such as the one stating that the [q]uery=“dogs”) are
    also request parameters.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你访问Google并搜索“dogs”。在这种情况下，后续页面将有一个类似[http://www.google.com/search?q=dogs&hl=en&safe=off&](http://www.google.com/search?q=dogs&hl=en&safe=off&)的URL。URL中的这些值（如表示[q]uery=“dogs”的那个）也是请求参数。
- en: 'The web server we’re creating will need to give the server code access to both
    types of request parameters: the ones in the body of the request (as is common
    with `POST` requests) as well as the ones that appear in the URL (as is common
    with `GET` requests.)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的Web服务器需要允许服务器代码访问这两种类型的请求参数：请求体中的那些（这在`POST`请求中很常见）以及出现在URL中的那些（这在`GET`请求中很常见。）
- en: Decoding the Values of Request Parameters
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析请求参数的值
- en: 'HTTP has a special way to represent the nonalphanumeric characters that a user
    might enter into a form, using *HTTP escape codes*. These escape codes let you
    have characters in the values of a request parameter that would not otherwise
    be available in the HTTP format. For instance, if a user enters **`"foo?"`**,
    it will appear in the request as `"foo%3F"`, since the question mark is represented
    with an escape code. Our web server will need to decode these escape characters,
    so the first function we’ll write is `decode-param`:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP使用一种特殊的方式来表示用户可能输入到表单中的非字母数字字符，即使用*HTTP转义码*。这些转义码允许你在请求参数的值中使用那些在HTTP格式中通常不可用的字符。例如，如果用户输入**`"foo?"`**，它将在请求中显示为`"foo%3F"`，因为问号是用转义码表示的。我们的Web服务器需要解码这些转义字符，因此我们将编写的第一个函数是`decode-param`：
- en: '[PRE95]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Note
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The HTTP escape codes we are discussing here are unrelated to the escape characters
    in Lisp strings we’ve discussed in other parts of this book.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的HTTP转义码与我们在这本书的其他部分讨论的Lisp字符串中的转义字符无关。
- en: First, this function defines a local function named `f` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which we’ll use to recursively process the characters. To make this recursion
    work, we need to use `coerce` to turn the string into a list of characters ![](httpatomoreillycomsourcenostarchimages783544.png),
    and then pass this list to `f`.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数定义了一个名为`f`的局部函数！![更多](httpatomoreillycomsourcenostarchimages783560.png)，我们将使用它来递归处理字符。为了使这个递归工作，我们需要使用`coerce`将字符串转换为字符列表！![更多](httpatomoreillycomsourcenostarchimages783544.png)，然后将这个列表传递给`f`。
- en: The `f` function checks the first character in the list to see if it’s a percent
    sign (`%`) or a plus sign (`+`). If it’s a percent sign, we know that the next
    value in the list is an ASCII code, represented as a hexadecimal number. (ASCII
    codes are a standard set of numbers that correspond to text characters, shared
    among many computer systems and applications.)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`函数检查列表中的第一个字符，看它是否是一个百分号（`%`）或一个加号（`+`）。如果是百分号，我们知道列表中的下一个值是一个ASCII码，表示为十六进制数。（ASCII码是一组标准数字，对应于文本字符，在许多计算机系统和应用程序中共享。） '
- en: To decode this ASCII code, we’ve created a function named `http-char` ![](httpatomoreillycomsourcenostarchimages783564.png).
    In this function, we use the `parse-integer` function to convert this string to
    an integer ![](httpatomoreillycomsourcenostarchimages783562.png). In this case,
    we’re using some keyword parameters on `parse-integer:` the `:radix` parameter,
    which tells the function to parse a hexadecimal number, and the `:junk-allowed`
    parameter, which tells it to just return nil when an invalid number is given,
    rather than signaling an error.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解码这个ASCII码，我们创建了一个名为`http-char`的函数！![更多](httpatomoreillycomsourcenostarchimages783564.png)。在这个函数中，我们使用`parse-integer`函数将这个字符串转换为整数！![更多](httpatomoreillycomsourcenostarchimages783562.png)。在这种情况下，我们在`parse-integer:`上使用了一些关键字参数：`:radix`参数告诉函数解析一个十六进制数，而`:junk-allowed`参数告诉它在给出无效数字时只返回nil，而不是发出错误信号。
- en: We then use the `code-char` function to convert this integer (which holds an
    ASCII code) into the actual character that the user entered.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`code-char`函数将这个整数（它包含ASCII码）转换为用户实际输入的实际字符。
- en: As per the rules of HTTP encoding, if a value in a request parameter contains
    a plus sign, it should be translated into a space character. We make this conversion
    here ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 根据HTTP编码的规则，如果请求参数中的值包含一个加号，它应该被转换为空格字符。我们在这里进行这个转换！![更多](httpatomoreillycomsourcenostarchimages783554.png)。
- en: Any other character passes through the `f` function unchanged. However, we still
    need to call `f` on the remainder of the list until all the characters have been
    processed ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他字符都会通过`f`函数保持不变。然而，我们仍然需要调用`f`函数处理列表的其余部分，直到所有字符都被处理！![更多](httpatomoreillycomsourcenostarchimages783510.png)。
- en: 'Here are some examples of `decode-param` in action:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些`decode-param`函数的示例：
- en: '[PRE96]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Decoding Lists of Request Parameters
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解码请求参数列表
- en: 'The next thing our server needs to do is to decode a list of parameters, which
    will be given as name/value pairs in a string such as `"name=bob&age=25&gender=male"`.
    As we’ve discussed, URLs for web pages often contain such name/value pairs at
    the end. As you can see, this string says that the person we’re looking for on
    the web page has a name of bob, an age of 25, and a gender of male. These name/value
    pairs are separated by an ampersand (`&`). The structure of these strings is equivalent
    to that of an association list (alist), so we’ll store these parameters as an
    alist using the following function:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接下来需要做的事情是解码一系列参数，这些参数将以字符串形式给出，例如 `"name=bob&age=25&gender=male"`。正如我们之前讨论的，网页的URL通常在末尾包含这样的名称/值对。正如你所看到的，这个字符串表明我们在网页上寻找的人的名字是bob，年龄是25岁，性别是男性。这些名称/值对由一个和号（`&`）分隔。这些字符串的结构与关联列表（alist）的结构相当，因此我们将使用以下函数将这些参数存储为一个alist：
- en: '[PRE97]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `parse-params` function finds the first occurrence of an ampersand (`&`)
    and equal sign (=) in the string, using the `position` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    If a name/value pair is found (we know this is true if an equal sign was found
    in the string and is stored in `i1`), we use the `intern` function to convert
    the name into a Lisp symbol ![](httpatomoreillycomsourcenostarchimages783562.png).
    We `cons` this name to the value of the parameter, which we decode with our `decode-param`
    function ![](httpatomoreillycomsourcenostarchimages783560.png). Finally, we recursively
    call `parse-params` on the remainder of the string ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse-params` 函数通过使用 `position` 函数找到字符串中第一个出现的 `&` 和 `=` 符号 ![位置图](httpatomoreillycomsourcenostarchimages783564.png)。如果找到一个名称/值对（如果字符串中找到了等号并且存储在
    `i1` 中，我们知道这是真的），我们使用 `intern` 函数将名称转换为 Lisp 符号 ![符号图](httpatomoreillycomsourcenostarchimages783562.png)。然后我们使用
    `cons` 函数将这个名称连接到参数的值上，我们使用我们的 `decode-param` 函数来解码这个值 ![解码图](httpatomoreillycomsourcenostarchimages783560.png)。最后，我们递归地调用
    `parse-params` 函数处理字符串的剩余部分 ![剩余部分图](httpatomoreillycomsourcenostarchimages783554.png)。'
- en: 'Let’s give our new `parse-params` function a try:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的新 `parse-params` 函数：
- en: '[PRE98]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Putting this data into an alist will allow our code to easily reference a specific
    variable whenever that’s necessary.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数据放入 alist 中将允许我们的代码在需要时轻松引用特定的变量。
- en: Note
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both `decode-param` and `parse-params` could achieve higher performance if they
    were written using a tail call, as we’ll discuss in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming").
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`decode-param` 和 `parse-params` 如果使用尾调用编写，可能会实现更高的性能，我们将在第 14 章（[第 14 章. 使用函数式编程提升
    Lisp 的层次](ch16.html "第 14 章. 使用函数式编程提升 Lisp 的层次")）中讨论。'
- en: Parsing the Request Header
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析请求头
- en: Next, we’ll write a function to process the first line of the request header.
    (This is the line that will look something like `GET /lolcats.html HTTP/1.1`).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个函数来处理请求头的第一行。（这将是看起来像 `GET /lolcats.html HTTP/1.1` 这样的行）。
- en: 'The following `parse-url` function will process these strings:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `parse-url` 函数将处理这些字符串：
- en: '[PRE99]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This function first uses the string’s delimiting spaces to find and extract
    the URL ![](httpatomoreillycomsourcenostarchimages783564.png). It then checks
    this URL for a question mark, which may indicate that there are request parameters
    that need to be handled ![](httpatomoreillycomsourcenostarchimages783562.png).
    For instance, if the URL is *lolcats.html?extra-funny=yes*, then the question
    mark lets us know that there is a parameter named *extra-funny* in the URL. If
    such parameters exist, we’ll need to extract them, and then parse them using our
    `parse-params` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    If there aren’t any request parameters, we just return the URL ![](httpatomoreillycomsourcenostarchimages783554.png).
    Note that this function skips over the request method (most often `GET` or `POST`).
    A fancier web server would extract this data point as well.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先使用字符串的分隔空格来找到并提取 URL ![URL图](httpatomoreillycomsourcenostarchimages783564.png)。然后它检查这个
    URL 是否包含问号，这可能表明需要处理请求参数 ![参数图](httpatomoreillycomsourcenostarchimages783562.png)。例如，如果
    URL 是 `*lolcats.html?extra-funny=yes*`，那么问号让我们知道在 URL 中有一个名为 `*extra-funny*` 的参数。如果存在这样的参数，我们需要提取它们，然后使用我们的
    `parse-params` 函数来解析它们 ![解析图](httpatomoreillycomsourcenostarchimages783560.png)。如果没有请求参数，我们只需返回
    URL ![返回图](httpatomoreillycomsourcenostarchimages783554.png)。注意，这个函数会跳过请求方法（通常是
    `GET` 或 `POST`）。更高级的 Web 服务器会提取这个数据点。
- en: 'Let’s try out our new URL extractor:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的新 URL 提取器：
- en: '[PRE100]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now that we can read the first line, we’ll process the rest of the request.
    The following `get-header` function will convert the remaining lines of the request
    into a nice alist:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够读取第一行，我们将处理请求的其余部分。以下 `get-header` 函数将把请求的剩余行转换为漂亮的 alist：
- en: '[PRE101]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This function reads in a line from the stream ![](httpatomoreillycomsourcenostarchimages783564.png),
    converts it to a key/value pair based on the location of a colon ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then recurses to convert additional lines in the header ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it encounters a line that doesn’t conform to a header line, it means we’ve
    reached the blank line at the end of the header and are finished. In this case,
    both `i` and `h` will be `nil`, and the function terminates.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从流 ![](httpatomoreillycomsourcenostarchimages783564.png) 中读取一行，根据冒号 ![](httpatomoreillycomsourcenostarchimages783562.png)
    的位置将其转换为键/值对，然后递归地转换头部中的附加行 ![](httpatomoreillycomsourcenostarchimages783560.png)。如果它遇到不符合头部行的行，这意味着我们已经到达了头部的空行，并且完成了。在这种情况下，`i`
    和 `h` 都将是 `nil`，函数终止。
- en: The `intern` command used when generating the key above is a simple function
    that converts a string into a symbol. We could, instead, have used the `read`
    command for this purpose, as we have previously in this book. But remember that
    the flexibility of the `read` command also makes it a great target for hackers,
    who might try creating malformed headers to crack your web server. That’s why
    it’s wise to use the more limited, specific `intern` function to process this
    data sent over the Internet to our web server.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成上述键时使用的 `intern` 命令是一个简单的函数，它将字符串转换为符号。我们也可以使用 `read` 命令来完成这个目的，就像我们在本书中之前做的那样。但请记住，`read`
    命令的灵活性也使其成为黑客攻击的绝佳目标，他们可能会尝试创建格式不正确的头部来破解你的网络服务器。这就是为什么使用更有限、更具体的 `intern` 函数来处理发送到我们网络服务器的互联网数据是明智的。
- en: Testing get-header with a String Stream
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串流测试 get-header
- en: 'Since the `get-header` function pulls its data directly from a socket stream,
    you might think we can’t test it directly through the REPL. However, as you saw
    in the previous chapter, there are actually several different types of resources
    besides sockets that can be accessed through the stream interface in Common Lisp.
    Because of the common interface among streams, we can test our `get-header` function
    by passing it a string stream instead of a socket stream:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `get-header` 函数直接从套接字流中获取其数据，你可能会认为我们无法直接通过 REPL 测试它。然而，正如你在上一章中看到的，除了套接字之外，还有几种不同类型的资源可以通过
    Common Lisp 的流接口访问。由于流之间的通用接口，我们可以通过传递字符串流而不是套接字流来测试我们的 `get-header` 函数：
- en: '[PRE102]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Using the `make-string-input-stream` function, we can create an input stream
    from a literal string. In this example, we’re taking a string defining two keys
    (`foo` and `bar`) and ending it with an empty line, just like a typical HTTP header.
    Note that we have a single literal string from ![](httpatomoreillycomsourcenostarchimages783564.png)
    to ![](httpatomoreillycomsourcenostarchimages783562.png). Such strings are permitted
    in Common Lisp. As you can see, the `get-header` function appropriately pulled
    the two keys and their values out of this stream, in the same way it would pull
    these values out of a socket stream.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `make-string-input-stream` 函数，我们可以从字面字符串创建一个输入流。在这个例子中，我们取一个定义了两个键（`foo`
    和 `bar`）并以其一个空行结束的字符串，就像一个典型的 HTTP 头部。注意，我们有一个从 ![](httpatomoreillycomsourcenostarchimages783564.png)
    到 ![](httpatomoreillycomsourcenostarchimages783562.png) 的单个字面字符串。这样的字符串在 Common
    Lisp 中是允许的。正如你所见，`get-header` 函数适当地从这个流中提取了两个键及其值，就像它会从套接字流中提取这些值一样。
- en: Using this trick, you can test functions that manipulate streams directly from
    the REPL. To do this, simply substitute string streams for other, more complicated
    stream types.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个技巧，你可以直接从 REPL 测试操作流的函数。要做到这一点，只需用字符串流替换其他更复杂的流类型。
- en: Parsing the Request Body
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析请求体
- en: 'In a POST request, there will usually be parameters stored beneath the header,
    in an area known as the *request body* or *request content*. The following `get-content-params`
    function extracts these parameters:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POST 请求中，通常会在头部下方存储参数，在称为 *请求体* 或 *请求内容* 的区域。以下 `get-content-params` 函数提取这些参数：
- en: '[PRE103]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: First, this function searches the header for a value called `content-length`
    ![](httpatomoreillycomsourcenostarchimages783564.png), which tells us the length
    of the string that contains these content parameters. If `content-length` exists,
    then we know there are parameters to parse ![](httpatomoreillycomsourcenostarchimages783562.png).
    The function will then create a string with the given length using `make-string`
    ![](httpatomoreillycomsourcenostarchimages783560.png), and use `read-sequence`
    to fill that string with characters from the stream ![](httpatomoreillycomsourcenostarchimages783554.png).
    It then runs the result through our `parse-params` function to translate the parameters
    into our cleaned-up alist format ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数在头部搜索一个名为`content-length`的值 ![content-length](httpatomoreillycomsourcenostarchimages783564.png)，它告诉我们包含这些内容参数的字符串的长度。如果存在`content-length`，那么我们知道有参数需要解析
    ![parse-params](httpatomoreillycomsourcenostarchimages783562.png)。然后，该函数将使用`make-string`
    ![make-string](httpatomoreillycomsourcenostarchimages783560.png)创建一个给定长度的字符串，并使用`read-sequence`
    ![read-sequence](httpatomoreillycomsourcenostarchimages783554.png)将流中的字符填充到该字符串中。然后，它将结果通过我们的`parse-params`函数运行，将参数转换为我们的清理后的alist格式
    ![parse-params](httpatomoreillycomsourcenostarchimages783510.png)。
- en: 'Our Grand Finale: The serve Function!'
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的大结局：服务函数！
- en: 'Now all the pieces are in place to write the heart of our web server: the `serve`
    function. Here it is in all its glory:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的部件都已经就位，我们可以编写我们网络服务器的心脏部分：`serve`函数。以下是它的全部辉煌：
- en: '[PRE104]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `serve` function takes a single parameter: `request-handler` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which is supplied by the creator of a website that wants to use this web server.
    When the server receives a request over the network, it parses the request into
    clean Lisp data structures (using the functions we’ve discussed throughout this
    chapter), and then passes this request information to `request-handler`. The `request-handler`
    then displays the correct HTML.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`serve`函数接受一个单一参数：`request-handler` ![request-handler](httpatomoreillycomsourcenostarchimages783564.png)，这是想要使用这个网络服务器的网站创建者提供的。当服务器通过网络接收到请求时，它会将请求解析成干净的Lisp数据结构（使用我们在本章中讨论过的函数），然后将这个请求信息传递给`request-handler`。然后`request-handler`显示正确的HTML。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783506.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783506.png)'
- en: Let’s look at our `serve` function in detail to see how it accomplishes this.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看我们的`serve`函数，看看它是如何完成这个任务的。
- en: First, `serve` creates a socket bound to port 8080 ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is one of several ports that is commonly used for serving web pages, especially
    when a site is still under development. (Port 80 is usually used for a production
    website/web server.) We then call `unwind-protect` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which ensures that no matter what happens as the server runs, `socket-server-close`
    will be called at some point to free the socket.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`serve`创建一个绑定到8080端口的套接字 ![socket-server-close](httpatomoreillycomsourcenostarchimages783562.png)。这是几个常用端口之一，用于提供网页服务，尤其是在网站仍在开发阶段时。
    (80端口通常用于生产网站/服务器。)然后我们调用`unwind-protect` ![unwind-protect](httpatomoreillycomsourcenostarchimages783560.png)，这确保无论服务器运行过程中发生什么，`socket-server-close`都会在某个时刻被调用以释放套接字。
- en: Next, we start the main web-serving loop. Within this loop, we open a stream
    for any client that accesses our server ![](httpatomoreillycomsourcenostarchimages783554.png).
    We then use the `with-open-stream` macro to guarantee that, no matter what, that
    stream will be properly closed. Now we’re ready to read and parse the website
    request that the client has made to our server, using all of the reading and parsing
    functions we created ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动主要的网络服务循环。在这个循环中，我们为访问我们服务器的任何客户端打开一个流 ![read-sequence](httpatomoreillycomsourcenostarchimages783554.png)。然后我们使用`with-open-stream`宏来保证，无论发生什么，那个流都将被正确关闭。现在我们准备好读取和解析客户端对我们服务器提出的网站请求，使用我们创建的所有读取和解析函数
    ![parse-params](httpatomoreillycomsourcenostarchimages783510.png)。
- en: Finally, we call the `request-handler` function, passing in the request details
    ![](httpatomoreillycomsourcenostarchimages783544.png). Note how we redefine the
    `*standard-output*` dynamic variable beforehand. This means that the request handler
    can just write to standard output, and all the printed data will be redirected
    to the client stream automatically. As you learned in [Chapter 12](ch13.html "Chapter 12. Working
    with Streams"), capturing data from standard output allows us to minimize string
    concatenation. Also, it will make our `request-handler` function easier to debug,
    as you’ll see shortly.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`request-handler`函数，传入请求详情 ![图片链接](http://atomoreilly.com/source/nostarch/images/783544.png)。注意我们事先重新定义了`*standard-output*`动态变量。这意味着请求处理器可以直接写入标准输出，所有打印的数据将自动重定向到客户端流。正如你在[第12章](ch13.html
    "第12章。与流一起工作")中学到的，从标准输出捕获数据可以让我们最小化字符串连接。此外，它还将使我们的`request-handler`函数更容易调试，正如你很快就会看到的。
- en: Note
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing we did not do with our web server is prevent the web server from crashing
    if the `request-handler` triggers an exception. Instead, we simply guarantee that
    no resources are mangled in the case of an exception. We could easily add extra
    exception handling to keep the server ticking even if horrible exceptions occur.
    However, since our goal is to learn Lisp and develop games in a browser, it’s
    better for us to know right away about any exceptions, even if that brings down
    our server.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在我们的Web服务器中做的一件事是防止`request-handler`触发异常时Web服务器崩溃。相反，我们只是保证在异常情况下不会损坏任何资源。我们很容易添加额外的异常处理来确保即使在发生可怕的异常的情况下，服务器也能继续运行。然而，由于我们的目标是学习Lisp并在浏览器中开发游戏，最好是立即了解任何异常，即使那会导致我们的服务器崩溃。
- en: Building a Dynamic Website
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建动态网站
- en: 'To try out our shiny new web server, let’s build a simple site that greets
    a visitor, using the dirt-simple function `hello-request-handler`:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试我们闪亮的新Web服务器，让我们构建一个简单的网站，该网站使用简单的函数`hello-request-handler`来问候访客：
- en: '[PRE105]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This `hello-request-handler` function supports only a single web page, called
    `greeting`. The first step in serving up this `greeting` page is to see if this
    page is indeed what the client requested ![](httpatomoreillycomsourcenostarchimages783564.png).
    If not, we print an apology to the user for not finding the specified page ![](httpatomoreillycomsourcenostarchimages783510.png).
    Otherwise, we check the request parameters to see if we know the user’s name![](httpatomoreillycomsourcenostarchimages783562.png).
    If not, we ask the user to enter a username using a web form ![](httpatomoreillycomsourcenostarchimages783560.png).
    If we *do* know the user’s name, we greet the visitor enthusiastically![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`hello-request-handler`函数只支持一个网页，称为`greeting`。提供这个`greeting`页面的第一步是查看这个页面是否确实是客户端请求的
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)。如果不是，我们向用户打印一个道歉，因为我们没有找到指定的页面
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783510.png)。否则，我们检查请求参数，看我们是否知道用户的姓名
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)。如果不知道，我们要求用户使用网页表单输入用户名
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)。如果我们确实知道用户的姓名，我们将热情地问候访客
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)。
- en: Note
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We’re taking a ton of shortcuts with our web server and this primitive website.
    For instance, any HTML sent to a client should be wrapped in a proper HTML skeleton,
    such as `<html><body>...</body></html>`. However, even then our page wouldn’t
    be fully compliant with modern HTML standards. In addition, when a client requests
    a nonexistent page, the appropriate response is to display a 404 error page, not
    just print a polite apology. Luckily, web browsers are very forgiving about such
    shortcuts, and they will display our simplified responses anyway.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建我们的Web服务器和这个原始网站时采用了许多捷径。例如，发送给客户端的任何HTML都应该包裹在一个合适的HTML骨架中，例如`<html><body>...</body></html>`。然而，即使如此，我们的页面也不会完全符合现代HTML标准。此外，当客户端请求一个不存在的页面时，适当的响应是显示404错误页面，而不仅仅是打印一个礼貌的道歉。幸运的是，网络浏览器对这样的捷径非常宽容，它们仍然会显示我们的简化响应。
- en: Testing the Request Handler
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试请求处理器
- en: 'Before we launch our new website, let’s test our `hello-request-handler` in
    the REPL by first viewing a page about lolcats:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动新网站之前，让我们通过首先查看有关lolcats的页面来在REPL中测试我们的`hello-request-handler`：
- en: '[PRE106]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Perfect. As you can see, when we ask our request handler for a page other than
    the `greeting` page, it just prints an apology. Now let’s try viewing the correct
    `greeting` page:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。正如你所看到的，当我们向请求处理器请求除`greeting`页面之外的页面时，它只是打印出一个道歉。现在让我们尝试查看正确的`greeting`页面：
- en: '[PRE107]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Excellent! Our request handler has generated an HTML form asking the user for
    a username. Now let’s pass in a parameter for the user’s name, as if the form
    had been processed and sent to the server:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的请求处理器已生成一个HTML表单，要求用户输入用户名。现在让我们为用户名传递一个参数，就像表单已被处理并发送到服务器一样：
- en: '[PRE108]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Because of the way we designed our web server, it’s very simple to debug a request
    handler independently in the REPL. We were able to see that `hello-request-handler`
    generates the correct responses without actually firing up a web browser.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设计Web服务器的方式，在REPL中独立调试请求处理器非常简单。我们能够看到`hello-request-handler`生成了正确的响应，而无需实际启动Web浏览器。
- en: Launching the Website
  id: totrans-607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动网站
- en: Now that we know that our new website is functioning, let’s launch it! But first,
    we need to make sure that all of the functions discussed in this chapter have
    been defined in an instance of CLISP. If you haven’t been entering these functions
    into the REPL as you’ve been reading, you can just save them all into a file called
    *webserver.lisp*, and then load them with `(load "webserve'")`.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们的新网站正在运行，让我们启动它！但首先，我们需要确保本章讨论的所有函数都已在一个CLISP实例中定义。如果您在阅读时没有将这些函数输入到REPL中，您可以将它们全部保存到一个名为*webserver.lisp*的文件中，然后使用`(load
    "webserver")`来加载它们。
- en: 'Once you’ve defined your functions in the CLISP, start the server by entering
    the following into the REPL:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在CLISP中定义了你的函数，通过在REPL中输入以下内容来启动服务器：
- en: '[PRE109]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'That’s it! Now you should be able to visit the site in a web browser:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在你应该能够通过Web浏览器访问该网站：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783558.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782976.png.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783558.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782976.png.jpg)'
- en: As you can see, when you visit our `greeting` page from a browser (using 127.0.0.1:8080,
    which will point to port 8080 on the same machine the web browser is running on),
    you are asked for your name. The server then shows a follow-up page, which greets
    you by name. This shows that our web server was able to parse out the name from
    the request parameters, and was able to pass the name to our `hello-request-handler`
    function.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当您从浏览器（使用127.0.0.1:8080，这将指向运行Web浏览器的同一台机器上的8080端口）访问我们的`greeting`页面时，您会被要求输入您的名字。然后服务器会显示一个后续页面，通过名字问候您。这表明我们的Web服务器能够从请求参数中解析出名字，并将名字传递给我们的`hello-request-handler`函数。
- en: We now have a fully functioning web server and request handling infrastructure.
    In future chapters, we’ll use these tools to create an awesome, graphical, web-based
    game.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了一个完全功能的Web服务器和请求处理基础设施。在未来的章节中，我们将使用这些工具来创建一个令人惊叹的、图形化的、基于Web的游戏。
- en: What You've Learned
  id: totrans-615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, you created a web server using Common Lisp, and learned the
    following along the way:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您使用Common Lisp创建了一个Web服务器，并在过程中学习了以下内容：
- en: You can signal conditions in Common Lisp with the `error` function. You can
    catch such errors with the `handle-case` command. If some code absolutely, positively
    needs to be called no matter what errors occur, you can place this code inside
    the `unwind-protect` command.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`error`函数在Common Lisp中发出条件。您可以使用`handle-case`命令捕获此类错误。如果某些代码绝对、肯定需要在发生任何错误的情况下调用，您可以将此代码放在`unwind-protect`命令内部。
- en: A web server processes HTTP requests. The most common type of request is the
    `GET` request, used for viewing information. Another common type is a `POST` request,
    which is used when submitting web forms, for instance. You can tell the type of
    request, which page was requested, as well as other information, by looking at
    the *request header*. Both `GET` and `POST` requests may have request parameters,
    which can appear either at the end of the requested URL or at the bottom of the
    request in the *request body*.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器处理HTTP请求。最常见的一种请求是`GET`请求，用于查看信息。另一种常见类型是`POST`请求，用于提交Web表单，例如。您可以通过查看*请求头*来告诉请求的类型、请求的页面以及其他信息。`GET`和`POST`请求都可能包含请求参数，这些参数可以出现在请求URL的末尾或在*请求体*的底部。
- en: Chapter 13.5. Functional Programming Is Beautiful
  id: totrans-619
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13.5章. 函数式编程很美
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783152.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782536.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781954.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781992.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781350.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781394.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780708.png)![image with
    no caption](httpatomoreillycomsourcenostarchimages780140.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages780194.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages779934.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages783136.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages783170.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages782562.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages782606.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages782016.png)![image with no caption](httpatomoreillycomsourcenostarchimages781376.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781416.png)![image with
    no caption](httpatomoreillycomsourcenostarchimages780728.png)![image with no caption](httpatomoreillycomsourcenostarchimages780772.png.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783152.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782536.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781954.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781992.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781350.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781394.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages780708.png)![无标题图片](httpatomoreillycomsourcenostarchimages780140.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages780194.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages779934.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages783136.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages783170.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782562.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782606.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782016.png)![无标题图片](httpatomoreillycomsourcenostarchimages781376.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781416.png)![无标题图片](httpatomoreillycomsourcenostarchimages780728.png)![无标题图片](httpatomoreillycomsourcenostarchimages780772.png.jpg)'
