- en: Part III. Lisp is Hacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779893.png)![image
    with no caption](httpatomoreillycomsourcenostarchimages779921.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'loop and format: The Seedy Underbelly of Lisp'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we looked at the core of the Common Lisp language and admired its
    succinctness and elegance. However, there are also some darker, seedier parts
    of Lisp built around this core that have a certain charm of their own. They may
    lack the beauty of the Lisp core, but they easily make up for it with their power.
    These parts of the language are a real delight for any budding Lisp hacker.
  prefs: []
  type: TYPE_NORMAL
- en: The extensions we’ll cover in this section, `loop` and `format`, place a strong
    emphasis on power over mathematical elegance. This has led to occasional controversy
    among Lisp programmers, some of whom question whether the power provided by these
    commands is worth the trade-off in elegance. These programmers believe that `loop`
    and `format` should be avoided when writing any serious code.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is one great reason to learn and use these commands: They embody
    the flexibility and extensibility of Lisp. Since Lisp is (arguably) the most flexible
    programming language available, hackers have been extending it with thousands
    of their own hacks for decades. `loop` and `format`, which are among the most
    successful of these extensions, had to be really spectacular to survive in the
    Darwinian battlefield.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780016.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 10. Looping with the loop Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `loop` and `format` commands are powerful and hacker-friendly. Though most
    of the functionality they offer is available elsewhere in the Lisp language, these
    highly specialized commands are worth learning if you like terse code. We’ll look
    at `loop` in this chapter. The next chapter covers `format`.
  prefs: []
  type: TYPE_NORMAL
- en: The loop Macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any type of looping you would ever want to do inside a computer program can
    be accomplished with the `loop` macro. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code adds together the natural numbers below 5, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 + 1 + 2 + 3 + 4 = 10 |'
  prefs: []
  type: TYPE_TB
- en: You can see that this `loop` command doesn’t work in the way a proper Lisp command
    should. First of all, it’s parenthetically challenged. Never before have we had
    seven tokens in a row without parentheses!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779821.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What makes it even less Lispy is that some of these extra tokens (`for`, `below`,
    and `sum`) appear to have special meanings. Recall from [Chapter 3](ch03.html
    "Chapter 3. Exploring the Syntax of Lisp Code") that the first token in a form
    (the one immediately after the opening parenthesis) is typically what decides
    the basic behavior of the code, while the rest of the form contains parameters.
    Within the `loop` macro, several of these “magic tokens” fundamentally affect
    the `loop`’s behavior. Here’s what they mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` allows you to declare a variable (in this case, named `i`) that iterates
    through a range of values. By default, it will count through the integers starting
    at zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`below` tells the `for` construct to halt when it reaches the specified value
    (in this case, `5`), excluding the value itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sum` adds together all values of a given expression (in this case, the expression
    is just `i`) and makes the `loop` return that number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some loop Tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `loop` macro has a veritable cornucopia of special tokens that make just
    about any kind of behavior possible. Let’s look at some of the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Counting from a Starting Point to an Ending Point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using `from` and `to` clauses, you can make the `for` construct count through
    any specific range of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Iterating Through Values in a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following example, we iterate through values in a list using the `in`
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: doing Stuff in a Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `do` token takes an arbitrary expression and executes it inside the `loop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Doing Stuff Under Certain Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `when` token lets you run the following part of the `loop` only as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that only the sum of the odd numbers is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking out of a Loop Early
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following `loop` uses several new tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782608.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there’s nothing in the `for` part of the `loop` that tells it to
    stop counting numbers—it goes from zero off to infinity. However, once we reach
    `5`, the `when` clause triggers the loop to immediately return the value `'falafel`.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting a List of Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780290.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `collect` clause lets you return more than one item from the `loop`, in
    the form of a list. This command is useful when you need to modify each item in
    a list, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using Multiple for Clauses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782304.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It’s possible for a `loop` macro to have more than one `for` clause. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'How many numbers do you think will be returned as a result? There are two possibilities:
    Either it increments `x` and `y` at the same time and returns a list of 10 items,
    or it iterates `x` and `y` in a nested fashion and returns 100 numbers. The answer
    is the former:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both numbers incremented at the same time between 0 and 9.
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple `for` clauses in a Common Lisp `loop`, each one will be
    checked, and the `loop` will stop when any one of the clauses runs out of values.
    This means that `for` clauses *do not* `loop` independently across multiple looping
    variables, so if you `loop` on two ranges of 10 values each, it will still just
    `loop` 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes you want to generate the *Cartesian product* between multiple
    ranges. In other words, you want a `loop` to run once for every possible combination
    of two or more ranges. To accomplish this, you need to use nested loops for `x`
    and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’ve created 10 lists of 10 items each, `loop`ing for a total
    of 100 items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that using a `for` variable starting at zero, such as the `i`
    variable in the following example, provides a clean way to track the index number
    of items in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You might think we’ve covered every conceivable variation of looping at this
    point. If so, you are gravely mistaken. Behold! The Periodic Table of the Loop
    Macro!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781219.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781278.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Everything You Ever Wanted to Know About loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The individual examples we’ve discussed so far give only the briefest hint of
    the full capabilities of `loop`. But fear not! You now have the world’s first
    and only Periodic Table of the Loop Macro. Just tape it to your monitor, glue
    it to your wallet, or laser-etch it directly into your retina, and you’ll be guaranteed
    to reach `loop` proficiency in no time!
  prefs: []
  type: TYPE_NORMAL
- en: Almost every legal command that can be used in a `loop` macro is covered by
    the periodic table. It shows how to manipulate hash tables and arrays, and perform
    special looping operations. Each square in the periodic table contains an example.
    If you run the example, you should be able to figure out the behavior of the given
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Using loop to Evolve!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782680.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s create another game, making full use of `loop`. But this won’t be a game
    that we play. Instead, it will be a game world that evolves as we watch it! We’re
    going to create an environment of steppes and jungles, filled with animals running
    around, foraging, eating, and reproducing. And after a few million units of time,
    we’ll see that they’ve evolved into different species!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example is adapted from A.K. Dewdney’s article “Simulated evolution: wherein
    bugs learn to hunt bacteria,” in the “Computer Recreations” column of *Scientific
    American* (May 1989: 138-141).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782162.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our game world is extremely simple. It consists of a simple rectangular plane,
    with edges that wrap around to the opposite side. (Mathematically speaking, it
    has a toroidal topology.) Most of this world is covered in steppes, meaning that
    very few plants grow for the animals to eat. In the center of the world is a small
    jungle, where plants grow much faster. Our animals, who are herbivores, will forage
    this world in search for food.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create some variables describing the extent of our world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’re giving the world a width of 100 units and a height of 30 units. Using
    these dimensions should make it easy to display the world in our Lisp REPL. The
    `*jungle*` list defines the rectangle in the world map that contains the jungle.
    The first two numbers in the list are the x- and y-coordinates of the jungle’s
    top-left corner, and the last two numbers are its width and height. Finally, we
    give the amount of energy contained in each plant, which is set to 80\. This means
    that if an animal finds a plant, it will gain 80 days’ worth of food by eating
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your terminal window isn’t large enough to display the entire world, change
    the values of the `*width*` and `*height*` variables. Set the `*width*` variable
    to the width of your terminal window minus two, and the `*height*` variable to
    the height of your terminal window minus one.
  prefs: []
  type: TYPE_NORMAL
- en: Growing Plants in Our World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might imagine, simulating evolution on a computer is a slow process.
    In order to see the creatures evolve, we need to simulate large stretches of time,
    which means we’ll want our code for this project to be very efficient. As animals
    wander around our world, they will need to be able to check if there is a plant
    at a given x,y location. The most efficient way to enable this is to store all
    of our plants in a hash table, indexed based on each plant’s x- and y-coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By default, a Common Lisp hash table uses `eq` when testing for the equality
    of keys. For this hash table, however, we’re defining `:test` to use `equal` instead
    of `eq`, which will let us use cons pairs of x- and y-coordinates as keys. If
    you remember our rule of thumb for checking equality, cons pairs should be compared
    using `equal`. If we didn’t make this change, every check for a key would fail,
    since two different cons cells, even with the same contents, test as being different
    when using `eq`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plants will grow randomly across the world, though a higher concentration of
    plants will grow in the jungle area than in the steppes. Let’s write some functions
    to grow new plants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `random-plant` function creates a new plant within a specified region of
    the world. It uses the `random` function to construct a random location and stores
    it in the local variable `pos` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it uses `setf` to indicate the existence of the plant within the hash table
    ![](httpatomoreillycomsourcenostarchimages783562.png). The only item actually
    stored in the hash table is `t`. For this `*plants*` table, the keys of the table
    (the x,y position of each plant) are actually more than the values stored in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem a bit weird to go through the trouble of creating a hash table to
    do nothing more than store `t` in every slot. However, Common Lisp does not, by
    default, have a data structure designed for holding mathematical sets. In our
    game, we want to keep track of the set of all world positions that have a plant
    in them. It turns out that hash tables are a perfectly acceptable way of expressing
    this. You simply use each set item as a key and store `t` as the value. Indeed,
    doing this is a bit of a hack, but it is a reasonably simple and efficient hack.
    (Other Lisp dialects, such as Clojure, have a set data structure built right into
    them, making this hack unnecessary.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Every day our simulation runs, the `add-plants` function will create two new
    plants: one in the jungle ![](httpatomoreillycomsourcenostarchimages783560.png)
    and one in the rest of the map ![](httpatomoreillycomsourcenostarchimages783554.png).
    Because the jungle is so small, it will have dense vegetation compared to the
    rest of the world.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Animals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782474.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The plants in our world are very simple, but the animals are a bit more complicated.
    Because of this, we’ll need to define a structure that stores the properties of
    each animal in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at each of these fields in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an Animal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781054.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We need to track several properties for each animal. First, we need to know
    its x- and y-coordinates. This indicates where the animal is located on the world
    map.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to know how much `energy` an animal has. This is a Darwinian game
    of survival, so if an animal can’t forage enough food, it will starve and die.
    The energy field tracks how many days of energy an animal has remaining. It is
    crucial that an animal find more food before its energy supply is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to track which direction the animal is facing. This is important
    because an animal will walk to a neighboring square in the world map each day.
    The `dir` field will specify the direction of the animal’s next x,y position as
    a number from 0 to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782494.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, an orientation of 0 would cause the animal to move up and to the
    left by the next day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to track the animal’s `genes`. Each animal has exactly eight
    genes, consisting of positive integers. These integers represent eight “slots,”
    which encircle the animal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781962.png)'
  prefs: []
  type: TYPE_IMG
- en: Every day, an animal will decide whether to continue facing the same direction
    as the day before or to turn and face a new direction. It will do this by consulting
    these eight slots and randomly choosing a new direction. The chance of a gene
    being chosen will be proportional to the number stored in the gene slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an animal might have the following genes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s represent these genes as a table, showing each slot number and how large
    of a value is stored in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781380.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, an animal has a large number (10) stored in slot 2\. Looking
    at our picture of the eight slots around the animal, you can see that slot 2 points
    to the right. Therefore, this animal will make a lot of right-hand turns and run
    in a circle. Of course, since the other slots still contain values larger than
    zero, the animal will occasionally move in another direction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an `*animals*` variable, populated with a single starting animal.
    You can think of this animal as “Adam” (or “Eve”, depending on what gender you
    prefer for our asexual animals).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We make the animal’s starting point the center of the world by setting the `x`
    and `y` positions to half of the map’s width and height, respectively. We set
    its initial energy to `1000`, since it hasn’t evolved much yet and we want it
    to have a fighting chance at survival. It starts off facing the upper left, with
    its `dir` field set to `0`. For its genes, we just use random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note that unlike the `*plants*` structure, which was a hash table, the `*animals*`
    structure is just a plain list (currently containing only a single member). This
    is because, for the core of our simulation, we never need to search our list of
    animals. Instead, we’ll just be traversing `*animals*` once every simulated day,
    to let our critters do their daily activities. Lists already support efficient
    linear traversals, so using another, more complex data structure (such as a table)
    would have no significant effect on the performance of our simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Animal Motion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780460.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `move` function accepts an animal as an argument and moves it, orthogonally
    or diagonally, based on the direction grid we have described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `move` function modifies the `x` and `y` fields, using the `animal-x` and
    `animal-y` accessors. As we’ve discussed, these are automatically generated through
    the `defstruct` macro, based on the field names. At the top of this function,
    we use the accessors to retrieve the x- and y-coordinates for the animal ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we use the same accessors to set the same values, with the aid of `setf`
    ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the new x-coordinate, we use a `cond` command to first check if
    the direction is 2, 3, or 4 ![](httpatomoreillycomsourcenostarchimages783554.png).
    These are the directions the animal may face that point east in the world, so
    we want to add one to the x-coordinate. If the direction instead is 1 or 5, it
    means the animal is facing directly north or south ![](httpatomoreillycomsourcenostarchimages783510.png).
    In those cases, the x-coordinate shouldn’t be changed. In all other cases, the
    animal is facing west and we need to subtract one ![](httpatomoreillycomsourcenostarchimages783544.png).
    The y-coordinate is adjusted in an analogous way ![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: Since the world needs to wrap around at the edges, we do some extra math using
    the `mod` (remainder) function to calculate the modulus of the coordinates and
    enable wrapping across the map ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783556.png).
    If an animal would have ended up with an x-coordinate of `*width*`, the `mod`
    function puts it back to zero, and it does the same for the y-coordinate and `*height*`.
    So, for example, if our function makes the animal move east until `x` equals 100,
    this will mean that (`mod 100 *width*`) equals zero, and the animal will have
    wrapped around back to the far west side of the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing the `move` function needs to do is decrease the amount of energy
    the animal possesses by one. Motion, after all, requires energy.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Animal Turning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll write the `turn` function. This function will use the animal’s genes
    to decide if and how much it will turn on a given day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function needs to make sure that the amount the animal turns is proportional
    to the gene number in the given slot. It does this by first summing the amount
    of all genes, and then picking a random number within that sum ![](httpatomoreillycomsourcenostarchimages783564.png).
    After that, it uses a recursive function named `angle` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which traverses the genes and finds the gene that corresponds to the chosen number,
    based on the respective contributions of each gene to the sum. It subtracts the
    running count in the argument `x` from the number stored at the current gene ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the running count has hit or exceeded zero, the function has reached the chosen
    number and stops recursing ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, it adds the amount of turning to the current direction and, if needed,
    wraps the number around back to zero, once again by using `mod` ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Handling Animal Eating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780304.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Eating is a simple process. We just need to check if there’s a plant at the
    animal’s current location, and if there is, consume it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The animal’s energy is increased by the amount of energy that was being stored
    by the plant. We then remove the plant from the world using the `remhash` function.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Animal Reproduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782918.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reproduction is usually the most interesting part in any animal simulation.
    We’ll keep things simple by having our animals reproduce asexually, but it should
    still be interesting, because errors will creep into their genes as they get copied,
    causing mutations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It takes a healthy parent to produce healthy offspring, so our animals will
    reproduce only if they have at least 200 days’ worth of energy ![](httpatomoreillycomsourcenostarchimages783564.png).
    We use the global constant `*reproduction-energy*` to decide what this cutoff
    number should be. If the animal decides to reproduce, it will lose half its energy
    to its child ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: To create the new animal, we simply copy the structure of the parent with the
    `copy-structure` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    We need to be careful though, since `copy-structure` performs only a *shallow
    copy* of a structure. This means that if there are any fields in the structure
    that contain values that are more complicated than just numbers or symbols, the
    values in those fields will be shared with the parent. An animal’s genes, which
    are stored in a list, represent the only such complex value in our animal structures.
    If we aren’t careful, mutations in the genes of an animal would simultaneously
    affect all its parents and children. In order to avoid this, we need to create
    an explicit copy of our gene list using the `copy-list` function ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows what horrible things could happen if we just
    relied on the shallow copy from the `copy-structure` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve created a parent animal with all its genes set to `1` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we use `copy-structure` to create a child ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we set the third (second counting from zero) gene equal to `10` ![](httpatomoreillycomsourcenostarchimages783560.png).
    Our parent now looks correct ![](httpatomoreillycomsourcenostarchimages783554.png).
    Unfortunately, since we neglected to use `copy-list` to create a separate list
    of genes for the child, the child genes were also changed ![](httpatomoreillycomsourcenostarchimages783510.png)
    when the parent mutated. Any time you have data structures that go beyond simple
    atomic symbols or numbers, you need to be very careful when using `setf` so that
    these kinds of bugs don’t creep into your code. In future chapters (especially
    [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with Functional Programming")),
    you’ll learn how to avoid these issues by not using functions that mutate data
    directly, in the manner that `setf` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mutate an animal in our `reproduce` function, we randomly pick one of its
    eight genes and place it in the `mutation` variable. Then we use `setf` to twiddle
    that value a bit, again using a random number. We did this twiddling on the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we’re slightly changing a random slot in the gene list. The number
    of the slot is stored in the local variable `mutation`. We add a random number
    less than three to the value in this slot, and then subtract one from the total.
    This means the gene value will change plus or minus one, or stay the same. Since
    we don’t want a gene value to be smaller than one, we use the `max` function to
    make sure it is at least one.
  prefs: []
  type: TYPE_NORMAL
- en: We then use `push` to insert this new critter into our global `*animal*` list,
    which adds it to the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a Day in Our World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have functions that handle every detail of an animal’s routine,
    let’s write one that simulates a day in our world.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'First, this function removes all dead animals from the world ![](httpatomoreillycomsourcenostarchimages783564.png).
    (An animal is dead if its energy is less than or equal to zero.) Next, it maps
    across the list, handling each of the animal’s possible daily activities: turning,
    moving, eating, and reproducing ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since all these functions have side effects (they modify the individual animal
    structures directly, using `setf`), we use the `mapc` function, which does not
    waste time generating a result list from the mapping process.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `add-plants` function ![](httpatomoreillycomsourcenostarchimages783560.png),
    which adds two new plants to the world every day (one in the jungle and one in
    the steppe). Since there are always new plants growing on the landscape, our simulated
    world should eventually reach an equilibrium, allowing a reasonably large population
    of animals to survive throughout the spans of time we simulate.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Our World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simulated world isn’t any fun unless we can actually see our critters running
    around, searching for food, reproducing, and dying. The `draw-world` function
    handles this by using the `*animals*` and `*plants*` data structures to draw a
    snapshot of the current world to the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First, the function uses a `loop` to iterate through each of the world’s rows
    ![](httpatomoreillycomsourcenostarchimages783564.png). Every row starts with a
    new line (created with `fresh-line`) followed by a vertical bar, which shows us
    where the left edge of the world is. Next, we iterate across the columns of the
    current row ![](httpatomoreillycomsourcenostarchimages783562.png), checking for
    an animal at every location. We perform this check using the `some` function ![](httpatomoreillycomsourcenostarchimages783560.png),
    which lets us determine if at least one item in a list obeys a certain condition.
    In this case, the condition we’re checking is whether there’s an animal at the
    current x- and y-coordinates. If so, we draw the letter `M` at that spot ![](httpatomoreillycomsourcenostarchimages783554.png).
    (The capital letter `M` looks a little like an animal, if you use your imagination.)
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we check for a plant, which we’ll indicate with an asterisk (`*`)
    character ![](httpatomoreillycomsourcenostarchimages783510.png). And if there
    isn’t a plant or an animal, we draw a space character ![](httpatomoreillycomsourcenostarchimages783544.png).
    Lastly, we draw another vertical bar to cap off the end of each line ![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in this function, we need to search through our entire `*animals*`
    list, which will cause a performance penalty. However, `draw-world` is not a core
    routine in our simulation. As you’ll see shortly, the user interface for our game
    will allow us to run thousands of days of the simulation at a time, without drawing
    the world to the screen until the end. Since there’s no need to draw the screen
    on every single day when we do this, the performance of `draw-world` has no impact
    on the overall performance of the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a User Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we’ll create a user interface function for our simulation, called `evolution`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, this function draws the world in the REPL ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it waits for the user to enter a command at the REPL using `read-line` ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the user enters `quit`, the simulation ends ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, it will attempt to parse the user’s command using `parse-integer` ![](httpatomoreillycomsourcenostarchimages783554.png).
    We set `:junk-allowed` to `true` for `parse-integer`, which lets the interface
    accept a string even if it isn’t a valid integer.
  prefs: []
  type: TYPE_NORMAL
- en: If the user enters a valid integer *n*, the program will run the simulation
    for *n* simulated days, using a loop ![](httpatomoreillycomsourcenostarchimages783510.png).
    It will also print a dot to the screen for every 1000 days, so the user can see
    that the computer hasn’t frozen while running the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: If the input isn’t a valid integer, we run `update-world` to simulate one more
    day. Since `read-line` allows for an empty value, the user can just tap the enter
    key and watch the animals move around their world.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `evolution` function recursively calls itself to redraw the world
    and await more user input ![](httpatomoreillycomsourcenostarchimages783544.png).
    Our simulation is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Let's Watch Some Evolution!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the simulation, execute `evolution` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our world is currently empty, except for the Adam/Eve animal in the center.
    Hit enter a few times to cycle through a few days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our under-evolved animal is stumbling around randomly, and a few plants are
    starting to grow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter **`100`** to see what the world looks like after 100 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our animal has already multiplied quite a bit, although this has less to do
    with the amount of food it has eaten than with the large amount of “starter energy”
    we gave it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s go all out and run the simulation for five million days! Since we’re
    using CLISP, this will be kind of slow, and you may want to start it up in the
    evening and let it run overnight. With a higher-performance Lisp, such as SBCL,
    it could take only a couple of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our world doesn’t look much different after five million days than it did after
    a hundred days. Of course, there are more animals, both traveling across the steppes
    and enjoying the lush vegetation of the jungle.
  prefs: []
  type: TYPE_NORMAL
- en: 'But appearances are deceptive. These animals are distinctly different from
    their early ancestors. If you observe them closely (by tapping enter), you’ll
    see that some of the creatures move in straight lines and others just jitter around
    in a small area, never taking more than a single step in any direction. (As an
    exercise, you could tweak the code to use different letters for each animal, in
    order to make their motion even easier to observe.) You can see this contrast
    even more clearly by typing `quit` to exit the simulation, then checking the contents
    of the `*animals*` variable at the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely at all the animals in the list, you’ll notice that they
    have two distinct types of genomes. One group of animals has a high number toward
    the front of the list, which causes them to move mostly in a straight line. The
    other group has a large number toward the back of the list, which causes them
    to jitter about within a small area. There are no animals with a genome between
    those two extremes. Have we evolved two different species?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to create a function that measured how far these evolved animals
    travel in a fixed amount of time, the histogram of the distance would appear as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783464.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a clear bimodal distribution, showing that the behavior of these animals
    appears to fall into two populations. Think about the environment these animals
    live in, and try to reason why this bimodal distribution would evolve. We will
    discuss the solution to this conundrum next.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Evolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution to the evolution puzzle is pretty straightforward. There are two
    possible survival strategies an animal can adopt in this imaginary world:'
  prefs: []
  type: TYPE_NORMAL
- en: Focus on the rich food supply in the jungle. Any animal adopting this strategy
    needs to be conservative in its motion. It can’t stray too far over time, or it
    might fall out of the jungle. Of course, these types of animals *do* need to evolve
    at least a bit of jittery motion, or they will never find any food at all. Let’s
    call these conservative, jittery, jungle-dwelling animals the *elephant species*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forage the sparse vegetation of the steppes. Here, the most critical trait for
    survival is to cover large distances. Such an animal needs to be open-minded,
    and must constantly migrate to new areas of the map to find food. (It can’t travel
    in *too* straight a line however, or it may end up competing for resources with
    its own offspring.) This strategy requires a bit of naïve optimism, and can at
    times lead to doom. Let’s call these liberally minded, risk-taking animals the
    *donkey species*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781764.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanding the simulation to evolve the three branches of government is left
    as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the `loop` command in detail. Along the way,
    you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `loop` command is a one-stop looping shop—it can do anything you need a
    `loop` to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To count through numbers in a loop, use the `for` phrase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To count through items in a list within a loop, use the `for in` phrase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can collect items inside a list and return them as a list with the `collect`
    phrase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Periodic Table of the Loop Macro to find other useful phrases supported
    by `loop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 11. Printing Text with the format Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even in this modern era of programming, it’s extremely important to be able
    to manipulate text, and Common Lisp has some of the fanciest text-printing functions
    available. Whether you need to manipulate XML, HTML, Linux configuration files,
    or any other data in a textual format, Lisp will make your work easy.
  prefs: []
  type: TYPE_NORMAL
- en: The most important advanced text printing function in Common Lisp is the `format`
    function, which is the subject of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of the format Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of the `format` function in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at what each part of this function means.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780524.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Destination Parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first parameter to the `format` function is the *destination* parameter,
    which tells `format` where to send the text it generates. Here are its possible
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`nil`**'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t print anything; just return the value as a string.
  prefs: []
  type: TYPE_NORMAL
- en: '**`t`**'
  prefs: []
  type: TYPE_NORMAL
- en: Print the value to the console. In this case, the function just returns nil
    as a value (as in our example).
  prefs: []
  type: TYPE_NORMAL
- en: '**`stream`**'
  prefs: []
  type: TYPE_NORMAL
- en: Write the data to an output stream (covered in [Chapter 12](ch13.html "Chapter 12. Working
    with Streams")).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we set the first parameter to `nil` so it simply
    returns the value as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The resulting string value (`"Add onion rings for only 1.50 dollars more!"`)
    is passed to the `reverse` function, and then that reversed string is printed
    to the screen with the `princ` command ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the REPL will also print the value of the entered expression,
    along with the information output by the `princ` command. This is why you see
    the value displayed a second time ![](httpatomoreillycomsourcenostarchimages783562.png).
    For the remainder of this chapter, the examples will omit these values printed
    by the REPL, and show only the information explicitly printed by our code.
  prefs: []
  type: TYPE_NORMAL
- en: The Control String Parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second parameter to the `format` function is a `control string`, which controls
    the text formatting. The `format` function’s power lies in the control string.
    In our current example, the control string is `"Add onion rings for only ˜$ dollars
    more!"`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the text in this string is simply printed as output. However, you
    can place *control sequences* into this string to affect the format of the output,
    as described in the remainder of this chapter. Our current example contains the
    control sequence `˜$`, which indicates a *monetary floating-point* value. Every
    control sequence recognized by the `format` function begins with the tilde (`˜`)
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Value Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `format` parameters following the control string contain values, or the
    actual data to be displayed and formatted. As you’ll see, the control string interacts
    with these parameters and controls their formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Control Sequences for Printing Lisp Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any Lisp value can be printed with the `print` or `prin1` command. To print
    a value for humans, without any delimiters, we can use the `princ` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `˜s` and `˜a` control sequences with `format` to produce the
    same behavior as `prin1` and `princ`. When used with `format`, the `˜s` control
    sequence includes appropriate delimiters. The `˜a` shows the value, without delimiters,
    for humans to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can adjust the behavior of these control sequences even further by entering
    parameters within the control sequence. For instance, we can place a number *n*
    in front of the `a` or `s` to indicate that the value should be *padded* with
    blank spaces on the right. The `format` command will then add spaces until the
    total width of the value is *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, by writing `˜10a` in the following example, we add seven spaces
    to the right of `foo`, making the total width of the formatted value 10 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add spaces on the left side of the value by adding the @ symbol,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the total width of the added spaces along with the value `foo`
    equals 10 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Control sequences can accept more than just one parameter. In the preceding
    examples, we set only the first parameter, which controls the final width of the
    final formatted string. Let’s look at an example that sets the second parameter
    of the `˜a` control sequence as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, additional parameters to a control sequence are separated with
    a comma. In this case, the second parameter is set to `3`, which tells the `format`
    command to add spaces in groups of three (instead of just one at a time) until
    the goal width of 10 is reached. In this example, a total of nine spaces are added
    to the formatted value. This means it overshot our goal width of 10 (by design),
    leading instead to a total width of 12 (nine spaces plus the letters `foo`). Padding
    strings in multiples like this is not a commonly needed feature, so the second
    parameter to the `˜a` control sequence is rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we need to control the exact number of spaces to add to our string,
    regardless of the length of the final value. We can do this by setting the third
    parameter in the `˜a` control sequence. For example, suppose we want to print
    exactly four spaces after the final formatted value. To set the third control
    sequence parameter equal to four, we place two commas in front of the parameter
    to indicate that the first two parameters are blank, then follow this with a `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there are exactly four extra spaces inserted in the results. Since
    the first and second parameters were not specified before the commas, their default
    values will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth control sequence parameter specifies which character will be used
    for padding. For example, in the following listing, we pad the printed value with
    four exclamation points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'These control sequence parameters can also be combined. For example, we can
    add the `@` symbol to our code to indicate that the exclamation marks should appear
    in front of the value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an overview of `format` command control sequences, let’s look
    at how to use them for formatting, beginning with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Control Sequences for Formatting Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `format` command has many options designed specifically for controlling
    the appearance of numbers. Let’s look at some of the more useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: Control Sequences for Formatting Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we can use `format` to display a number using a different base. For
    instance, we can display a number in hexadecimal (base-16) with the `˜x` control
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can display a number in binary (base-2) using the `˜b` control
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even explicitly declare that a value will be displayed as a decimal
    (base-10) number, using the `˜d` control sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we would have gotten the same result if we had just used the
    more generic `˜a` control sequence. The difference is that `˜d` supports special
    parameters and flags that are specific to printing decimal numbers. For example,
    we can place a colon inside the control sequence to enable commas as digit group
    separators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the width of the number, we can set the padding parameter, just
    as we did with the `˜a` and `˜s` control sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the character used for padding, pass in the desired character (in
    this case, the *x* character) as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Control Sequences for Formatting Floating-Point Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Floating-point values are handled with the `˜f` control sequence. As with all
    of the previously discussed control sequences, we can change the value’s display
    width by changing the first parameter. When used with floating-point numbers,
    the `format` command will automatically round the value to fit within the requested
    number of characters (including the decimal point):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the final width of `3.14` is four characters wide, as specified
    by the control sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter of the `˜f` control sequence controls the number of digits
    displayed after the decimal point. For example, if we pass `4` as the second parameter
    in the preceding example, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that Common Lisp actually includes the constant `pi` as part of the standard,
    so you could also rewrite the command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The third parameter of the `˜f` control sequence causes the number to be scaled
    by factors of ten. For example, we can pass `2` as the third parameter, which
    we can use to multiply a fraction by 10² to turn it into a percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to `˜f`, we can use the control sequence `˜$`, which is used for
    formatting currencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You saw an example that used `˜$` at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Printing Multiple Lines of Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Common Lisp has two different commands for starting a new line during printing.
    The first, `terpri`, simply tells Lisp to terminate the current line and start
    a new one for printing subsequent output. For example, we can print two numbers
    on different lines like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also start a new line with `fresh-line`. This command will start a new
    line, but only if the cursor position in the REPL isn’t already at the very front
    of a line. Let’s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, placing two `fresh-line` statements between the two `princ`
    calls resulted in Lisp printing only one line between the outputted numbers. The
    first `fresh-line` starts a new line; the second `fresh-line` is simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the `terpri` command says “start a new line,” whereas the `fresh-line`
    command says “start a new line, *if needed*.” Any code using the `terpri` command
    needs to “know” what was printed before. Otherwise, unsightly empty lines may
    result. Since it’s always better if different parts of a program know as little
    about each other as possible, most Lispers prefer using `fresh-line` over `terpri`,
    because it allows them to decouple the printing of one piece of data from the
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format` command has two control sequences that are analogous to `terpri`
    and `fresh-line`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`˜%`**'
  prefs: []
  type: TYPE_NORMAL
- en: causes a new line to be created in all cases (like `terpri`)
  prefs: []
  type: TYPE_NORMAL
- en: '**`˜&`**'
  prefs: []
  type: TYPE_NORMAL
- en: creates new lines only as needed (like `fresh-line`).
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples illustrate this difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using an extra `˜%` prints an unsightly empty line ![](httpatomoreillycomsourcenostarchimages783564.png),
    and using `˜&` in the same places does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two line-termination sequences can also have an additional parameter
    in front of them to indicate the number of new lines to be created. This is useful
    in cases where we want to use empty lines to space out our output. For example,
    the addition of `5` in the following example adds five empty lines to our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Justifying Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `format` command also gives us a lot of control over text justification.
    Control sequences allow us to format tables, center text, and perform other useful
    justification feats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you understand the various justification rules, we’ll create a simple
    function that returns different animal names with varying character lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose we want to display a bunch of random animals in a table. We can
    do this by using the `˜t` control sequence. `˜t` can take a parameter that specifies
    the column position at which the formatted value should appear. For example, to
    have our table of animals appear in three columns at the fifth, fifteenth, and
    twenty-fifth character positions, we could create this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Remember that a `loop` command with a `repeat 10` clause executes the body of
    the loop 10 times. As you can see, use of the `˜t` control sequence caused the
    animals to be laid out in a neatly formatted table.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782580.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now suppose we want all the animals be spaced equally apart on a single line.
    To do so, we can use the `˜<` and `˜>` control sequences, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s deconstruct this control string to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780168.png)'
  prefs: []
  type: TYPE_IMG
- en: First, the `˜30<` tells the function that we’re initiating a block of justified
    text. The parameter `30` indicates that the block should be 30 characters wide.
    Next, we have three `˜a` control sequences in a row, one for each animal. Each
    `˜a` is separated by `;`, which tells `format` that we’re starting a new value
    to be justified by `˜<`. (The `˜;` sequences indicate where extra spaces should
    be inserted to justify the values.) We then end the justified section with the
    `˜>` command sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the equal spacing of the animals in each line doesn’t guarantee that
    the columns created by printing multiple lines will be properly aligned, we add
    the `:@` flag to our justification `˜<` command sequence. For example, we can
    create a single, neatly centered column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we can use `:@` with multiple justified values, centering
    them on the line with additional space at their left and right ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This step brings us closer to having three neatly centered columns, but our
    columns are still a bit wavy because we’re aligning the values within a single
    line, without telling `format` to arrange the values using three centered columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce neat columns, we’ll still use the `:@` flag, but we’ll describe
    our rows using three separate 10-character justification sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: At last, we have the nicely centered random animal columns of our dreams!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the layout options for `format` are quite flexible. Since we
    often need to create complex lists and tables of data when debugging applications,
    these tricks are very helpful when you need to get a handle on your data, even
    with more complex programs.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Through Lists Using Control Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `format` function with its many control sequences is practically a programming
    language in its own right. (In fact, many Lispers would call it a *domain-specific
    language*, a concept we will revisit in [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages").) And, like most programming languages, `format` can loop through
    data. It does this using the `˜{` and `˜}` control sequences.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this looping, pass the `format` function a control string containing
    `˜{` and `˜}`, and a list to iterate through. The part of the control string between
    the `˜{` and `˜}` sequences is treated almost like the body of a loop. It will
    be executed a number of times, depending on the length of the list that follows
    it. The `format` function will iterate through this list, applying each of its
    items to the specified section of the control string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s create a list of animals that we can use for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we use the `˜{ ˜}` control sequences to to loop through this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To produce this loop, we simply pass the single variable `*animals*`, a list
    of items, to the `format` function. The control string iterates through the list,
    constructing the sentence `"I see a ˜a"` for each member of `*animals*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single iteration construct can also grab more than one item from the list,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two `˜a` control sequences within a single looping construct.
    Each `˜a` pulls a single animal from the list, so two animals print for every
    iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: A Crazy Formatting Trick for Creating Pretty Tables of Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at one last `format` example that uses some of the control sequences
    you’ve already seen, as well as some new ones. This example will illustrate how
    the varied control sequences can be combined for complex behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To create this nicely formatted table of numbers, we first use the looping control
    sequences `˜{ ˜}` to iterate through a list of numbers created by the `loop` command.
    Within the iteration, we place justification control sequences `˜< ˜>`, which
    we’ve used earlier. In this case, we don’t use them to justify our text, but instead
    use them to divide the resulting text into pieces. This is how we break our 100
    numbers into nice clean rows of 10\. We place the `˜:;` control sequence inside
    our justification control sequences `˜< ˜>`, which causes text to be broken into
    pieces of equal length.
  prefs: []
  type: TYPE_NORMAL
- en: When used inside a justification, the control string preceding this sequence
    `˜:;` (which in this case happens to be `|˜%|`) will be triggered only if the
    current cursor position is beyond a certain point, as specified by the second
    parameter, `33`. In other words, we’re telling the format function “Hey, once
    you have 33 characters’ worth of text, start a fresh line.”
  prefs: []
  type: TYPE_NORMAL
- en: The `|˜%|` control string causes the line break and vertical bars to be printed.
    The number to be displayed is formatted using `˜2d`, which prints a left-justified
    number, two characters wide.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For full details on every single control sequence, see the *Common Lisp HyperSpec*
    at [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Attack of the Robots!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780825.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we look at a game so horrifying that it’s sure to give you nightmares:
    Attack of the Robots! In this game, robots have taken over the world, and it’s
    your job to destroy them. Though the plot may sound scary, the part of this game
    that will *really* give a Lisp programmer nightmares is the way it abuses the
    `loop` and `format` commands in order to squeeze a fully functional robot-fighting
    game into a *single page of code!* (This program uses the “crazy formatting trick”
    discussed in the previous section.)'
  prefs: []
  type: TYPE_NORMAL
- en: I have annotated the code with some basic explanations. If you want to understand
    how the game works in detail, you’ll need to review most of the information from
    the previous couple of chapters. Also, you can visit [http://landoflisp.com/](http://landoflisp.com/)
    to download the source code for the game and read a more thorough explanation
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: To win the game, you need to strategically walk around the field to cause all
    robots to collide with each other. The movement keys are QWE/ASD/ZXC. These characters
    form a grid on the left side of your keyboard, letting you move up, down, left,
    right, as well as diagonally. You can also teleport with the T key.
  prefs: []
  type: TYPE_NORMAL
- en: Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783256.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter didn’t really even come close to covering all of the features
    of the `format` function. However, it did provide an introduction, in which you
    learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the `format` command determines whether the output is
    sent to the REPL, a stream, or returned as a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter of the `format` command is a *control string* that lets
    you change the way your data is printed. The control string has a sophisticated
    syntax, acting almost like a programming language in its own right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining `format` parameters are values that can be referenced from the
    control string to embed values into the formatted output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To embed a Lisp value into a formatted string, use the `˜s` or `˜a` control
    sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many control sequences are available for printing and customizing the appearance
    of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format` command also has complex looping abilities that can be used, for
    example, to format tables laid out in many different styles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 12. Working with Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every computer program you write will need to interact with the outside
    world at some point. Perhaps your program just needs to communicate with the user
    through the REPL, printing out information and capturing the user’s input from
    the keyboard. Other programs you write may need to read or write files on a hard
    drive. Additionally, you may want to write programs that interact with other computers,
    either over a local network or the Internet. In Common Lisp, these kinds of interactions
    happen through streams.
  prefs: []
  type: TYPE_NORMAL
- en: '*Streams* are data types in Common Lisp that allow you to take some external
    resource and make it look like just another simple piece of data you can manipulate
    with your code. The external resource could be a variety of things: a file on
    a disk, another computer on a network, or text in a console window on the screen.
    As you’ll learn in this chapter, through the use of a stream, a Lisp program can
    interact with this outside resource just as easily as it might interact with a
    list or a hash table.'
  prefs: []
  type: TYPE_NORMAL
- en: Types of Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we communicate with an external resource from a Common Lisp program, we
    do so by using a stream. Different types of streams are available for different
    types of resources. Another factor is the direction of the stream—sometimes you
    will want to write data to a resource, and sometimes you will want to read data
    from a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Streams by Type of Resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780982.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When organized by the type of resource on which they operate, the following
    are the most commonly used stream types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Console streams**'
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve been using so far when communicating with the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: '**File streams**'
  prefs: []
  type: TYPE_NORMAL
- en: Let us read and write to files on our hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket streams**'
  prefs: []
  type: TYPE_NORMAL
- en: Let us communicate with other computers on a network.
  prefs: []
  type: TYPE_NORMAL
- en: '**String streams**'
  prefs: []
  type: TYPE_NORMAL
- en: Let us send and receive text from a Lisp string.
  prefs: []
  type: TYPE_NORMAL
- en: Of these stream types, string streams are the black sheep of the family. Rather
    than letting you communicate with the outside world, string streams allow you
    to manipulate strings in new and interesting ways.
  prefs: []
  type: TYPE_NORMAL
- en: Streams by Direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write data to a resource, you use *output streams*. For reading data
    from a resource, you use *input streams*.
  prefs: []
  type: TYPE_NORMAL
- en: Output Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Output streams are used for tasks such as writing to the REPL, writing to a
    file, or sending information over a socket. At the most primitive level, you can
    do two things with an output stream:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the stream is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push a new item onto the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780652.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a stream is more restrictive than a true data structure in Lisp.
    For instance, a list supports all of the same features as a stream (we can push
    a new item onto a list with `push` and check if a list is valid with `listp`),
    and we also can do certain tasks with a list that we can’t do with an output stream
    (such as changing items in the list with `setf`). But this limited functionality
    of streams actually makes them useful in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see if we have a valid output stream, we can use the `output-stream-p` function.
    For example, the REPL has an output stream associated with it called `*standard-output*`.
    We can see if this is a valid output stream with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A Lisp character is one item that can be pushed onto an output stream using
    the basic command `write-char`. For example, to write the character `#\x` to the
    `*standard-output*` stream, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This code prints an *x* to the standard output (which, in this case, is the
    same as the REPL). Note that this function also returns `nil`, causing the *x*
    and the return value to be printed on the same line. As you saw in [Chapter 6](ch06.html
    "Chapter 6. Interacting with the World: Reading and Printing in Lisp"), this extra
    `nil` is just a side effect of running the code in the REPL. If we ran this command
    as part of a larger program, only the *x* would have printed out.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss only streams based on text characters. In Common
    Lisp, you can also create streams based on other data types. For instance, if
    you’re working with binary data, you may want to send or receive raw bytes instead
    of characters. But for our purposes, manipulating textual data (and hence using
    streams that work with text characters) is the most convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Input Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Input streams are used for reading data. As with output streams, the actions
    that you can perform with an input stream are limited. At the most primitive level,
    you can do two things with an input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the stream is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pop an item off of the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see if we have a valid stream with the `input-stream-p` command. For
    instance, as with standard output, the REPL has an associated input stream called
    `*standard-input*`, which we can validate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781986.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can pop an item off the stream with the `read-char` command. Since we’re
    reading from the REPL, we need to type some characters and press enter to send
    the data into the standard input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the 1 at the front of the stream was popped off and returned
    by `read-char`.
  prefs: []
  type: TYPE_NORMAL
- en: USING OTHER COMMANDS TO INTERACT WITH STREAMS
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `write-char` and `read-char`, Common Lisp has many other commands
    for interacting with streams. In fact, all the commands for printing and reading
    introduced in [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading
    and Printing in Lisp") can accept a stream as an extra parameter, which lets us
    use Lisp''s powerful input/output abilities with any stream. For instance, we
    can explicitly tell the `print` command to print to `*standard-output*`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful when working with streams other than `*standard-output*`,
    as you'll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to using streams to write to and read from the REPL, we can also
    use streams to write to and read from files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a file stream in Common Lisp in several ways. The best way is
    to use the `with-open-file` command. As you’ll see shortly, this command contains
    special bug-prevention features that make it safer to use than other available
    file commands. The following example uses `with-open-file` to write the string
    `"my data"` to a file named `data.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `with-open-file` command binds the output stream to the
    name `my-stream` ![](httpatomoreillycomsourcenostarchimages783564.png). This causes
    a file output stream to be created with the name `my-stream`. This stream will
    be available within the body of the `with-open-file` command (until the final
    closing bracket ![](httpatomoreillycomsourcenostarchimages783562.png)), and any
    data we send to this stream will end up in the file named `data.txt` on the disk.
    The `print` command references `my-stream` as the destination for its output ![](httpatomoreillycomsourcenostarchimages783562.png).
    Therefore, after running this example, you should find a new file named `data.txt`
    in the folder from which you launched CLISP. This file has the text "`my data`"
    as its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying `:output` as the direction for `with-open-file` creates an output
    stream. To make this an input stream instead, we could change the direction to
    `:input`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this causes the data—the same data written to the file in the
    previous example—to be read in from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you learned in [Chapter 6](ch06.html "Chapter 6. Interacting with the World:
    Reading and Printing in Lisp"), the `print` and `read` commands can print and
    read any of the basic Common Lisp data types. This functionality makes it easy
    to use streams to store data from your programs to the hard drive. Here is a more
    complicated example that writes an association list (alist) to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re creating an association table of animals and the sounds
    they make. We create a new alist named `animal-noises` ![](httpatomoreillycomsourcenostarchimages783564.png).
    We put keys for `dog` and `cat` into this list. Now we can write this alist to
    a new file called `animal-noises.txt` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Later, we can easily reconstitute this alist from the file ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `with-open-file` command can take keyword parameters that modify its behavior.
    For instance, you can tell the command what to do if a file with the given name
    already exists. In the following example, we’ll display an error message using
    the `:if-exists` keyword parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you may simply want the existing file to be overwritten. In
    that case, set the `:if-exists` keyword parameter to `:supersede`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `with-open-file` command gives you a very succinct way to work with files.
    Unlike most programming languages, when using this command, you don’t need to
    open and close files manually, and you don’t need to worry about potentially messing
    up your files by failing to properly close them. (Actually, Common Lisp has lower-level
    commands for opening and closing files as well, but `with-open-file` packages
    them in a clean way that hides all the ugly details.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782374.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main purpose of `with-open-file` is to acquire a file resource. It takes
    command of the file and assumes the responsibility of closing it. In fact, even
    if the code inside the `with-open-file` throws an ugly error that stops the program
    dead, `with-open-file` will still close the file properly to make sure this resource
    stays intact.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common Lisp has many commands that begin with `with-` that will safely allocate
    resources in this way. These `with-` commands, available in the core Lisp libraries,
    are built with Lisp’s awesome macro system. You’ll learn more about Lisp macros,
    and how to create your own `with-` commands, in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").
  prefs: []
  type: TYPE_NORMAL
- en: Working with Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779968.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve used streams to communicate with the REPL and with files, let’s
    see how we can use them to communicate with another computer.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to write a program that can communicate with another computer elsewhere
    on a standard network (almost all networks nowadays use the TCP/IP protocol),
    you’ll first need to create a socket. A *socket* is a mechanism for routing data
    over a computer network between programs running on different computers on that
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, sockets didn’t make it into the ANSI Common Lisp standard, which
    means there’s no standard way of interacting with sockets at this time. However,
    every version of Common Lisp supports sockets, even if it doesn’t follow any standard.
    Since we’ve been using CLISP as our Lisp of choice in this book, we’ll consider
    only CLISP’s socket commands.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: cl-sockets *(*[http://common-lisp.net/project/cl-sockets/](http://common-lisp.net/project/cl-sockets/)*)*
    and usocket *(*[http://common-lisp.net/project/usocket/](http://common-lisp.net/project/usocket/)*)*
    are two attempts at adding a standard socket library to Common Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: Socket Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every socket within a network must have a *socket address*. This socket address
    has two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP address**'
  prefs: []
  type: TYPE_NORMAL
- en: A number that uniquely identifies a computer on the network (typically shown
    as 4 bytes delimited by periods, such as 192.168.33.22).
  prefs: []
  type: TYPE_NORMAL
- en: '**Port number**'
  prefs: []
  type: TYPE_NORMAL
- en: Any programs that want to use the network must choose a unique port number that
    no other program on the same computer is already using.
  prefs: []
  type: TYPE_NORMAL
- en: The IP address and the port number combine to make up the socket address. Since
    the IP address is unique on a network and the port number is unique for a given
    computer, every socket address on a network is unique to a specific program running
    on a specific computer. Any messages running over the network (through chunks
    of data called *TCP packets*) will be labeled with a socket address to indicate
    their destination.
  prefs: []
  type: TYPE_NORMAL
- en: Once a computer receives a packet labeled with its IP address, the operating
    system will look at the port number in the socket address of the message to figure
    out which program should receive the message.
  prefs: []
  type: TYPE_NORMAL
- en: And how does the operating system know which program receives messages for a
    given port? It knows this because a program first must create a socket for that
    port in order to use it. In other words, a socket is simply a way for a computer
    program to tell the operating system, “Hey, if you get any messages on port 251,
    send them my way!”
  prefs: []
  type: TYPE_NORMAL
- en: Socket Connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to actually send a message over a socket between two programs, we first
    need to follow some steps to initialize a *socket connection*. The first step
    in creating such a connection is to have one of the programs create a socket that
    starts in a listening state, waiting to see if other programs on the network want
    to start a communication. The computer with the socket in a listening state is
    called the *server*. Then the other program, called a *client*, creates a socket
    on its end and uses it to establish a connection with the server. If all goes
    well, these two programs can now transmit messages across the socket connection
    running between them.
  prefs: []
  type: TYPE_NORMAL
- en: But enough talk. Let’s try connecting two programs right now to see the magic
    happen for ourselves!
  prefs: []
  type: TYPE_NORMAL
- en: Sending a Message over a Socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, open two copies of CLISP in two different console windows on your computer.
    We’ll call one the client and one the server. (Or, if you have two computers on
    a network and know their IP addresses, you can create the two consoles on two
    separate machines, for the full network experience.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You *must* use CLISP to get the socket code shown in this chapter to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server, take control of a port by calling `socket-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This command acquires port 4321 and binds a socket to it using the operating
    system. The socket is bound to the `my-socket` variable so that we can interact
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: This command is somewhat dangerous, because the operating system is expecting
    us to give up the socket once we’re finished with it. If we don’t, no one will
    be able to use this socket anymore. In fact, if you make any mistakes during this
    socket exercise, you could mess up the socket at port 4321, and then you would
    need to switch to another port number until you restart your computer. (In the
    next chapter, you’ll learn how to use the exception handling system in Common
    Lisp to work around these ugly problems.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s make a stream from this socket (still on the server) that handles
    a connection from a single client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, the server will seem to lock up, and you won’t be
    returned to the REPL prompt. Don’t be alarmed—the `socket-accept` command is a
    *blocking operation*, which means the function won’t exit until a client has connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now switch over to your client CLISP and use the `socket-connect` command to
    connect to that socket on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The IP address 127.0.0.1 is a special address that always points to the computer
    from which it’s called. If you are using two different computers for this exercise,
    you should enter the actual IP address of your server.
  prefs: []
  type: TYPE_NORMAL
- en: After running this command, the server will unlock, and the value of the `my-stream`
    variable will be set. We now have a stream open in both copies of CLISP, and we
    can use it to communicate between them!
  prefs: []
  type: TYPE_NORMAL
- en: The stream CLISP has created here is called a *bidirectional* stream. This means
    it can act both as an input stream and an output stream, and we can use either
    set of commands on it to communicate in both directions. Let’s send a cordial
    greeting between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'And enter the following on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, still on the server, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Back on the client, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what your two CLISP windows should look like when you’re finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780950.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The message we sent across the socket was a Lisp string, but because of Lisp’s
    elegant stream-handling capabilities, we could send almost any standard Lisp data
    structure in the same way, without any extra effort!
  prefs: []
  type: TYPE_NORMAL
- en: Tidying Up After Ourselves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s crucial that we free up the resources we’ve created during this exercise.
    First, run the following command on *both* the client and the server to close
    the stream on both ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Next, run `socket-server-close` on the server to free up the port and disconnect
    the socket from it. If you don’t, port 4321 will be unusable until you reboot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'String Streams: The Oddball Type'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams are usually used for communicating with the outside world from within
    a Lisp program. One exception to this is the string stream, which simply makes
    a string look like a stream. In the same way you can read or write to external
    resources with other types of streams, a string stream will let you read or write
    to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create string streams with the `make-string-output-stream` and `make-string-input-stream`
    commands. Following is an example that uses `make-string-output-stream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why anyone would want to do this, since we can already
    directly manipulate strings in Lisp, without using streams. Actually, there are
    several good reasons for using string streams in this way. They are useful for
    debugging, as well as for creating complex strings efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Streams to Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using string streams allows us to use functions that require streams as parameters.
    This is great for debugging code that works with files or sockets, using only
    strings for the input and output of data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we have a function `write-to-log` that writes log information
    to a stream. Usually, we would want to send the log information to a file stream,
    so it can be written to a file for safekeeping. However, if we want to debug the
    function, we may want to send it a string stream instead, so we can take a look
    at the data it writes and make sure it’s correct. If we had hard-coded the `write-to-log`
    function to only write to a file, we wouldn’t have this flexibility. This is why
    it makes sense to write functions to use the abstract concept of a stream whenever
    possible, instead of using other methods to access external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Long Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String streams can lead to better-performing code when dealing with very long
    strings. For instance, concatenating two strings together can be a costly operation—first,
    it requires a new block of memory to be allocated to hold both strings, and then
    the strings need to be copied into this new location. Because of this bottleneck,
    many programming languages use devices called *string builders* to avoid this
    overhead. In Lisp, we can get similar performance benefits by using string streams.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another reason for using string streams is that they can make our code easier
    to read and debug, especially when we use the `with-output-to-string` macro.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781306.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s an example of this command being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `with-output-to-string` macro ![](httpatomoreillycomsourcenostarchimages783564.png)
    will intercept any text that would otherwise be output to the console, REPL, or
    other output stream, and capture it as a string. In the preceding example, the
    output created by the `princ` functions ![](httpatomoreillycomsourcenostarchimages783562.png)
    within the body of the `with-output-to-string` call is redirected automatically
    into a string stream. Once the body of the `with-output-to-string` command has
    completed, the entire printed output that was put into the stream is returned
    as a result ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `with-output-to-string` macro to easily construct complex
    strings by “printing” each part, and then capturing the result as a string. This
    tends to be much more elegant and efficient than using the `concatenate` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `with-output-to-string` runs counter to the tenets of functional programming
    (discussed in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with
    Functional Programming")). Some Lispers consider this function (and similar functions
    that intercept input or output intended for other destinations) to be an ugly
    hack. You’ll see some disagreement in the Lisp community about whether the use
    of `with-output-to-string` is elegant or ugly.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter described how to use streams to let your Lisp programs interact
    with outside resources. You learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Different types of streams interact with different types of resources. These
    include *console streams*, *file streams*, *socket streams*, and *string streams*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams can be categorized based on their direction. *Output streams* let us
    write to a resource. *Input streams* let us read from a resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket streams allow computer programs to communicate over a network. To establish
    a socket stream, we must first open sockets on both ends and open a socket connection
    between the programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String streams allow us to use functions that require streams without linking
    to an outside resource, for debugging purposes. They also are useful for constructing
    complex strings efficiently and elegantly through the use of `with-output-to-string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 13. Let's Create a Web Server!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and
    Printing in Lisp"), you learned how to interact with a user by sending text to
    and from the REPL. However, when people talk about “interacting with a user” these
    days, they’re usually referring to a user on the Web. In this chapter, you’re
    going to learn how to interact with users on the Web by building a web server
    from scratch. Since communications over a network are error prone by their nature,
    you’ll first learn how errors are handled in Lisp.'
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling in Common Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any time you’re interacting with the outside world, as our web server will,
    unexpected things can happen. No matter how smart a modern computer network may
    be, it can never anticipate every possible exceptional situation. After all, even
    the smartest network can’t recover from some fool tripping over the wrong cable.
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp has a very extensive set of features for dealing with unexpected
    exceptional situations in your code. This exception handling system is very flexible,
    and it can be used to do things that are impossible with exception systems in
    most other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Signaling a Condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re writing a function and something goes horribly wrong, a Lisp function
    can notify the Lisp environment that a problem has been encountered. This is done
    by *signaling a condition*. What sort of things could go wrong? Maybe a function
    tried to divide by zero. Or maybe a library function received a parameter of the
    wrong type. Or maybe a socket communication was interrupted because you tripped
    over your network cable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to signal a condition directly, you can do so with the `error`
    command. You would do this if a function you wrote detected a problem on its own—a
    problem so serious the program just could not continue normally. Using the `error`
    command will interrupt your running Lisp program, unless you intercept the error
    elsewhere to prevent an interruption. Let’s signal a condition and print the message
    “foo” to describe the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, signaling this condition causes Lisp to interrupt our program,
    print the message “foo,” and show an error prompt at the REPL. (In CLISP, you
    can type **`:a`** at this point to abort the program and return to the normal
    REPL.)
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time your program signals a condition, it will probably not be because
    you called `error` yourself. Instead, it will be because your program has a bug,
    or because you called a library function, and that function signals a condition.
    However, any time something prevents normal execution in your program, leading
    to a condition, your program will stop and show an error prompt such as in the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our first example, we passed a string describing the condition to the `error`
    command. However, this text string just customizes the error message and doesn’t
    lead to a different “type” of condition. Common Lisp also allows you to have various
    types of conditions that can be handled in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more sophisticated way to signal conditions is to first define a custom condition
    using `define-condition`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This is a typical example of creating a new type of condition, which we’ve named
    `foo` ![](httpatomoreillycomsourcenostarchimages783564.png). When this condition
    is signaled, we can supply a custom function that will be called to report the
    error. Here, we declare a lambda function for this purpose ![](httpatomoreillycomsourcenostarchimages783562.png).
    Within the lambda function, we print a custom message to report the error ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens when we trigger this new condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our custom message was printed. This technique allows the programmer
    to get a more meaningful error report, customized for the specific condition that
    was triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we create a condition with `define-condition`, it’s given a name (such
    as `foo`). This name can be used by the higher-level parts of our program to intercept
    and handle that condition, so it won’t stop the program’s execution. We can do
    this with the `handler-case` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we put inside a `handler-case` command is the piece of code
    that may signal conditions that we want to handle ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the code we’re watching is a call to `bad-function`. The rest
    of `handler-case` lets us specify actions to perform if a particular condition
    occurs ![](httpatomoreillycomsourcenostarchimages783562.png). When this code is
    run, `bad-function` signals the `foo` condition by calling `(error 'foo)`. Usually,
    this would cause our program to be interrupted and lead to a error prompt at the
    REPL. However, our `handler-case` command intercepts the `foo` condition ![](httpatomoreillycomsourcenostarchimages783562.png).
    This means that the program can keep running without interruption, with the `handler-case`
    evaluating as “somebody signaled foo!” ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Resources Against Unexpected Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an unexpected exception happens in a program, there is always a risk that
    it could bring down your program, or even cause damage to resources outside your
    program. Exceptions interrupt the regular flow of your code, and they may stop
    your code dead in its tracks, even while it’s in the middle of a sensitive operation.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, your program may be writing to a file or to a socket stream when
    an unexpected exception happens. In this case, it is critically important that
    your program has an opportunity to close the file/socket stream and free the file
    handle or socket; otherwise, that resource may become locked indefinitely. If
    such resources aren’t cleaned up properly, the users may need to reboot their
    computer first before the resource becomes available again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unwind-protect` command can help us to avoid these problems. With this
    command, we can tell the Lisp compiler, “This piece of code must run no matter
    what happens.” Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Within the `unwind-protect`, we divide by 0, which signals a condition ![](httpatomoreillycomsourcenostarchimages783564.png).
    But even after we tell CLISP to abort, the program still prints its crucial message
    ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: We can usually avoid calling `unwind-protect` directly by relying on Common
    Lisp’s “`with-`” macros; many of these call `unwind-protect` themselves, under
    the hood. In [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros"), we’ll
    create our own macros to see how this is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the comic book epilogue at the end of the book, you’ll learn about an additional
    feature of the Common Lisp signaling system called *restarts*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Web Server from Scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of sockets (covered in [Chapter 12](ch13.html
    "Chapter 12. Working with Streams")) and error handling, you know enough to make
    a web server that can serve dynamic web pages written in Lisp. After all, why
    should Apache (the world’s most popular web server) have all the fun?
  prefs: []
  type: TYPE_NORMAL
- en: How a Web Server Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hypertext Transfer Protocol, or HTTP, is the Internet protocol used for transferring
    web pages. It adds a layer on top of TCP/IP for requesting pages once a socket
    connection has been established. When a program running on a client computer (usually
    a web browser) sends a properly encoded request, the server will retrieve the
    requested page and send it over the socket stream in response.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781432.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This web server is adapted from *http.lisp*, created by Ron Garret.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose the client is the Firefox web browser, and it asks for
    the page *lolcats.html*. The client’s request might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: For our web server, the most important part of this request is the first line.
    There we can see the type of request made (a `GET` request, which means we just
    want to look at a page without modifying it), and the name of the page requested
    (*lolcats.html*). This data sent to the server is called the *request header*.
    You’ll see later that additional information can be sent to the server below the
    request header, in a *request body*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To readers from the distant future, *lolcats* was a viral Internet phenomenon
    from early in the third millennium. It involved pictures of cats with funny captions.
    If people of your time are no longer familiar with lolcats, it is of no great
    loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'In response, the server will send an HTML document that represents the web
    page over the socket stream. This is called the *response body*. Here is what
    a response body might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: An HTML document is wrapped in `html` opening ![](httpatomoreillycomsourcenostarchimages783564.png)
    and closing tags ![](httpatomoreillycomsourcenostarchimages783554.png). Within
    these tags, you can declare a body section ![](httpatomoreillycomsourcenostarchimages783562.png).
    In the body section, you can write a text message that will be displayed in the
    web browser as the body of the web page![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: For a fully HTML-compliant web page, other items must exist in the document,
    such as a DOCTYPE declaration. However, our example will work just fine, and we
    can ignore these technical details for our simple demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: A web server will typically also generate a *response header*. This header can
    give a web browser additional information about the document it has just received,
    such as whether it is in HTML or another format. However, the simplified web server
    we’re going to create does not generate such a header and instead simply returns
    a body.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we’re using CLISP-specific socket commands, you must be running CLISP
    for the sample web server presented in this chapter to work.
  prefs: []
  type: TYPE_NORMAL
- en: Request Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web forms are an essential element in powering websites. For instance, suppose
    we create a simple login form for a website.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781624.png)'
  prefs: []
  type: TYPE_IMG
- en: After the visitor to our website hits the Submit button on this page, it will
    send a `POST` request back to the website. A `POST` request looks very similar
    to the `GET` request in the preceding example. However, a `POST` request usually
    carries the expectation that it may alter data on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample login form, we need to tell the server the user ID and password
    that the visitor to our site had entered into the text fields on this form. The
    values of these fields that are sent to the server as part of the `POST` request
    are called *request parameters*. They are sent within the `POST` request by appending
    them below the request header, in the area that makes up the request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `POST` request might look like for our login example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The extra parameter in the header of this `POST` request, `Content-Length`,
    indicates the length of the parameter data at the bottom of the request. Specifically,
    `Content-Length: 39` tells the server that the text containing the request parameters
    ![](httpatomoreillycomsourcenostarchimages783564.png) is 39 characters long.'
  prefs: []
  type: TYPE_NORMAL
- en: Request Parameters for GET Requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we’ve discussed, the typical purpose of request parameters is to send web
    form data back to the server during a `POST` request. However, `GET` requests
    may also contain request parameters. Usually, with a `GET` request, we want to
    see what the parameters are in the URL of the request, whereas with a `POST` request,
    the parameters are hidden in the body of the request.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, suppose you go to Google and search for “dogs.” In this case,
    the follow-up page will have a URL that reads something like [http://www.google.com/search?q=dogs&hl=en&safe=off&](http://www.google.com/search?q=dogs&hl=en&safe=off&)....
    These values in the URL (such as the one stating that the [q]uery=“dogs”) are
    also request parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web server we’re creating will need to give the server code access to both
    types of request parameters: the ones in the body of the request (as is common
    with `POST` requests) as well as the ones that appear in the URL (as is common
    with `GET` requests.)'
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the Values of Request Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTTP has a special way to represent the nonalphanumeric characters that a user
    might enter into a form, using *HTTP escape codes*. These escape codes let you
    have characters in the values of a request parameter that would not otherwise
    be available in the HTTP format. For instance, if a user enters **`"foo?"`**,
    it will appear in the request as `"foo%3F"`, since the question mark is represented
    with an escape code. Our web server will need to decode these escape characters,
    so the first function we’ll write is `decode-param`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTTP escape codes we are discussing here are unrelated to the escape characters
    in Lisp strings we’ve discussed in other parts of this book.
  prefs: []
  type: TYPE_NORMAL
- en: First, this function defines a local function named `f` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which we’ll use to recursively process the characters. To make this recursion
    work, we need to use `coerce` to turn the string into a list of characters ![](httpatomoreillycomsourcenostarchimages783544.png),
    and then pass this list to `f`.
  prefs: []
  type: TYPE_NORMAL
- en: The `f` function checks the first character in the list to see if it’s a percent
    sign (`%`) or a plus sign (`+`). If it’s a percent sign, we know that the next
    value in the list is an ASCII code, represented as a hexadecimal number. (ASCII
    codes are a standard set of numbers that correspond to text characters, shared
    among many computer systems and applications.)
  prefs: []
  type: TYPE_NORMAL
- en: To decode this ASCII code, we’ve created a function named `http-char` ![](httpatomoreillycomsourcenostarchimages783564.png).
    In this function, we use the `parse-integer` function to convert this string to
    an integer ![](httpatomoreillycomsourcenostarchimages783562.png). In this case,
    we’re using some keyword parameters on `parse-integer:` the `:radix` parameter,
    which tells the function to parse a hexadecimal number, and the `:junk-allowed`
    parameter, which tells it to just return nil when an invalid number is given,
    rather than signaling an error.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `code-char` function to convert this integer (which holds an
    ASCII code) into the actual character that the user entered.
  prefs: []
  type: TYPE_NORMAL
- en: As per the rules of HTTP encoding, if a value in a request parameter contains
    a plus sign, it should be translated into a space character. We make this conversion
    here ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Any other character passes through the `f` function unchanged. However, we still
    need to call `f` on the remainder of the list until all the characters have been
    processed ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of `decode-param` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Decoding Lists of Request Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next thing our server needs to do is to decode a list of parameters, which
    will be given as name/value pairs in a string such as `"name=bob&age=25&gender=male"`.
    As we’ve discussed, URLs for web pages often contain such name/value pairs at
    the end. As you can see, this string says that the person we’re looking for on
    the web page has a name of bob, an age of 25, and a gender of male. These name/value
    pairs are separated by an ampersand (`&`). The structure of these strings is equivalent
    to that of an association list (alist), so we’ll store these parameters as an
    alist using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `parse-params` function finds the first occurrence of an ampersand (`&`)
    and equal sign (=) in the string, using the `position` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    If a name/value pair is found (we know this is true if an equal sign was found
    in the string and is stored in `i1`), we use the `intern` function to convert
    the name into a Lisp symbol ![](httpatomoreillycomsourcenostarchimages783562.png).
    We `cons` this name to the value of the parameter, which we decode with our `decode-param`
    function ![](httpatomoreillycomsourcenostarchimages783560.png). Finally, we recursively
    call `parse-params` on the remainder of the string ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give our new `parse-params` function a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Putting this data into an alist will allow our code to easily reference a specific
    variable whenever that’s necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both `decode-param` and `parse-params` could achieve higher performance if they
    were written using a tail call, as we’ll discuss in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming").
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the Request Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll write a function to process the first line of the request header.
    (This is the line that will look something like `GET /lolcats.html HTTP/1.1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `parse-url` function will process these strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This function first uses the string’s delimiting spaces to find and extract
    the URL ![](httpatomoreillycomsourcenostarchimages783564.png). It then checks
    this URL for a question mark, which may indicate that there are request parameters
    that need to be handled ![](httpatomoreillycomsourcenostarchimages783562.png).
    For instance, if the URL is *lolcats.html?extra-funny=yes*, then the question
    mark lets us know that there is a parameter named *extra-funny* in the URL. If
    such parameters exist, we’ll need to extract them, and then parse them using our
    `parse-params` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    If there aren’t any request parameters, we just return the URL ![](httpatomoreillycomsourcenostarchimages783554.png).
    Note that this function skips over the request method (most often `GET` or `POST`).
    A fancier web server would extract this data point as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our new URL extractor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can read the first line, we’ll process the rest of the request.
    The following `get-header` function will convert the remaining lines of the request
    into a nice alist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This function reads in a line from the stream ![](httpatomoreillycomsourcenostarchimages783564.png),
    converts it to a key/value pair based on the location of a colon ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then recurses to convert additional lines in the header ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it encounters a line that doesn’t conform to a header line, it means we’ve
    reached the blank line at the end of the header and are finished. In this case,
    both `i` and `h` will be `nil`, and the function terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The `intern` command used when generating the key above is a simple function
    that converts a string into a symbol. We could, instead, have used the `read`
    command for this purpose, as we have previously in this book. But remember that
    the flexibility of the `read` command also makes it a great target for hackers,
    who might try creating malformed headers to crack your web server. That’s why
    it’s wise to use the more limited, specific `intern` function to process this
    data sent over the Internet to our web server.
  prefs: []
  type: TYPE_NORMAL
- en: Testing get-header with a String Stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the `get-header` function pulls its data directly from a socket stream,
    you might think we can’t test it directly through the REPL. However, as you saw
    in the previous chapter, there are actually several different types of resources
    besides sockets that can be accessed through the stream interface in Common Lisp.
    Because of the common interface among streams, we can test our `get-header` function
    by passing it a string stream instead of a socket stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Using the `make-string-input-stream` function, we can create an input stream
    from a literal string. In this example, we’re taking a string defining two keys
    (`foo` and `bar`) and ending it with an empty line, just like a typical HTTP header.
    Note that we have a single literal string from ![](httpatomoreillycomsourcenostarchimages783564.png)
    to ![](httpatomoreillycomsourcenostarchimages783562.png). Such strings are permitted
    in Common Lisp. As you can see, the `get-header` function appropriately pulled
    the two keys and their values out of this stream, in the same way it would pull
    these values out of a socket stream.
  prefs: []
  type: TYPE_NORMAL
- en: Using this trick, you can test functions that manipulate streams directly from
    the REPL. To do this, simply substitute string streams for other, more complicated
    stream types.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the Request Body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a POST request, there will usually be parameters stored beneath the header,
    in an area known as the *request body* or *request content*. The following `get-content-params`
    function extracts these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: First, this function searches the header for a value called `content-length`
    ![](httpatomoreillycomsourcenostarchimages783564.png), which tells us the length
    of the string that contains these content parameters. If `content-length` exists,
    then we know there are parameters to parse ![](httpatomoreillycomsourcenostarchimages783562.png).
    The function will then create a string with the given length using `make-string`
    ![](httpatomoreillycomsourcenostarchimages783560.png), and use `read-sequence`
    to fill that string with characters from the stream ![](httpatomoreillycomsourcenostarchimages783554.png).
    It then runs the result through our `parse-params` function to translate the parameters
    into our cleaned-up alist format ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Grand Finale: The serve Function!'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now all the pieces are in place to write the heart of our web server: the `serve`
    function. Here it is in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `serve` function takes a single parameter: `request-handler` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which is supplied by the creator of a website that wants to use this web server.
    When the server receives a request over the network, it parses the request into
    clean Lisp data structures (using the functions we’ve discussed throughout this
    chapter), and then passes this request information to `request-handler`. The `request-handler`
    then displays the correct HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783506.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s look at our `serve` function in detail to see how it accomplishes this.
  prefs: []
  type: TYPE_NORMAL
- en: First, `serve` creates a socket bound to port 8080 ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is one of several ports that is commonly used for serving web pages, especially
    when a site is still under development. (Port 80 is usually used for a production
    website/web server.) We then call `unwind-protect` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which ensures that no matter what happens as the server runs, `socket-server-close`
    will be called at some point to free the socket.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start the main web-serving loop. Within this loop, we open a stream
    for any client that accesses our server ![](httpatomoreillycomsourcenostarchimages783554.png).
    We then use the `with-open-stream` macro to guarantee that, no matter what, that
    stream will be properly closed. Now we’re ready to read and parse the website
    request that the client has made to our server, using all of the reading and parsing
    functions we created ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `request-handler` function, passing in the request details
    ![](httpatomoreillycomsourcenostarchimages783544.png). Note how we redefine the
    `*standard-output*` dynamic variable beforehand. This means that the request handler
    can just write to standard output, and all the printed data will be redirected
    to the client stream automatically. As you learned in [Chapter 12](ch13.html "Chapter 12. Working
    with Streams"), capturing data from standard output allows us to minimize string
    concatenation. Also, it will make our `request-handler` function easier to debug,
    as you’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing we did not do with our web server is prevent the web server from crashing
    if the `request-handler` triggers an exception. Instead, we simply guarantee that
    no resources are mangled in the case of an exception. We could easily add extra
    exception handling to keep the server ticking even if horrible exceptions occur.
    However, since our goal is to learn Lisp and develop games in a browser, it’s
    better for us to know right away about any exceptions, even if that brings down
    our server.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Dynamic Website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try out our shiny new web server, let’s build a simple site that greets
    a visitor, using the dirt-simple function `hello-request-handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This `hello-request-handler` function supports only a single web page, called
    `greeting`. The first step in serving up this `greeting` page is to see if this
    page is indeed what the client requested ![](httpatomoreillycomsourcenostarchimages783564.png).
    If not, we print an apology to the user for not finding the specified page ![](httpatomoreillycomsourcenostarchimages783510.png).
    Otherwise, we check the request parameters to see if we know the user’s name![](httpatomoreillycomsourcenostarchimages783562.png).
    If not, we ask the user to enter a username using a web form ![](httpatomoreillycomsourcenostarchimages783560.png).
    If we *do* know the user’s name, we greet the visitor enthusiastically![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re taking a ton of shortcuts with our web server and this primitive website.
    For instance, any HTML sent to a client should be wrapped in a proper HTML skeleton,
    such as `<html><body>...</body></html>`. However, even then our page wouldn’t
    be fully compliant with modern HTML standards. In addition, when a client requests
    a nonexistent page, the appropriate response is to display a 404 error page, not
    just print a polite apology. Luckily, web browsers are very forgiving about such
    shortcuts, and they will display our simplified responses anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Request Handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we launch our new website, let’s test our `hello-request-handler` in
    the REPL by first viewing a page about lolcats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect. As you can see, when we ask our request handler for a page other than
    the `greeting` page, it just prints an apology. Now let’s try viewing the correct
    `greeting` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Our request handler has generated an HTML form asking the user for
    a username. Now let’s pass in a parameter for the user’s name, as if the form
    had been processed and sent to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Because of the way we designed our web server, it’s very simple to debug a request
    handler independently in the REPL. We were able to see that `hello-request-handler`
    generates the correct responses without actually firing up a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know that our new website is functioning, let’s launch it! But first,
    we need to make sure that all of the functions discussed in this chapter have
    been defined in an instance of CLISP. If you haven’t been entering these functions
    into the REPL as you’ve been reading, you can just save them all into a file called
    *webserver.lisp*, and then load them with `(load "webserve'")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve defined your functions in the CLISP, start the server by entering
    the following into the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! Now you should be able to visit the site in a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783558.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782976.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when you visit our `greeting` page from a browser (using 127.0.0.1:8080,
    which will point to port 8080 on the same machine the web browser is running on),
    you are asked for your name. The server then shows a follow-up page, which greets
    you by name. This shows that our web server was able to parse out the name from
    the request parameters, and was able to pass the name to our `hello-request-handler`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a fully functioning web server and request handling infrastructure.
    In future chapters, we’ll use these tools to create an awesome, graphical, web-based
    game.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you created a web server using Common Lisp, and learned the
    following along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: You can signal conditions in Common Lisp with the `error` function. You can
    catch such errors with the `handle-case` command. If some code absolutely, positively
    needs to be called no matter what errors occur, you can place this code inside
    the `unwind-protect` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web server processes HTTP requests. The most common type of request is the
    `GET` request, used for viewing information. Another common type is a `POST` request,
    which is used when submitting web forms, for instance. You can tell the type of
    request, which page was requested, as well as other information, by looking at
    the *request header*. Both `GET` and `POST` requests may have request parameters,
    which can appear either at the end of the requested URL or at the bottom of the
    request in the *request body*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 13.5. Functional Programming Is Beautiful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783152.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782536.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781954.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781992.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781350.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781394.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780708.png)![image with
    no caption](httpatomoreillycomsourcenostarchimages780140.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages780194.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages779934.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages783136.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages783170.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages782562.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages782606.png.jpg)![image with
    no caption](httpatomoreillycomsourcenostarchimages782016.png)![image with no caption](httpatomoreillycomsourcenostarchimages781376.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781416.png)![image with
    no caption](httpatomoreillycomsourcenostarchimages780728.png)![image with no caption](httpatomoreillycomsourcenostarchimages780772.png.jpg)'
  prefs: []
  type: TYPE_IMG
