<html><head></head><body><div class="part" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="view_from_the_top"/>Part VI. VIEW FROM THE TOP</h1></div></div></div><div class="partintro" xml:lang="en"><div/><p>The air's getting thinner, but the view's getting better. Several hundred pages ago we started our journey at the lowest level, grubbing around the seedy underbelly of source code construction. In this last section we complete our journey by climbing to the very top of the software development mountain and surveying the territory below. I hope you're not afraid of heights.</p><p>Here we'll look at how the final parts of the jigsaw fit together.</p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch22.html" title="Chapter 22. RECIPE FOR A PROGRAM">Chapter 22</a></span></dt><dd><p>The code cookbook: how we actually write software in our development teams. This chapter describes both software development methodologies and software development processes. It shows how we manage to produce programs in a predictable, timely manner (or, at least, attempt to).</p></dd><dt><span class="term"><a class="xref" href="ch23.html" title="Chapter 23. THE OUTER LIMITS">Chapter 23</a></span></dt><dd><p>A look at the different code-writing disciplines out there: applications programming, games programming, distributed programming, and more. Each of these branches of programming has its own special problems and important skills. Understanding these will equip you to write the most suitable code for each occasion.</p></dd><dt><span class="term"><a class="xref" href="ch24.html" title="Chapter 24. WHERE NEXT?">Chapter 24</a></span></dt><dd><p>The end is in sight. . . . This is the final, tearful farewell. We look at where to go next in your continuing study of code craft. This book is just the beginning.</p></dd></dl></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="recipe_for_a_program"/>Chapter 22. RECIPE FOR A PROGRAM</h1></div><div><h3 class="subtitle"><i>Code Development Methodologies and Processes</i></h3></div></div></div><div class="epigraph"><p>They always say time changes things, but you actually have to change them yourself.</p><div class="attribution"><span>--<span class="attribution">Andy Warhol</span></span></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Ingredients</strong></span></span></dt><dd><p>1 bunch programmers (preferably fresh)</p><p>1-2 tsp language</p><p>1 target platform</p><p>1 project manager</p><p>1 pinch luck</p><p>1 sachet dehydrated training</p><p>Various industry buzzwords</p></dd><dt><span class="term"><span class="strong"><strong>Instructions</strong></span></span></dt><dd><p>Marinade programmers in training. Add language, target platform, and season with project manager. Stir briskly until well mixed. Add buzzwords to taste. Sprinkle evenly with luck and leave to cook in a hot software oven until deadline. Remove, tip onto wire rack, and allow to cool before handing on to customer.</p></dd></dl></div><p>I know at least four recipes for sponge cake. They vary depending on whether you want a fat-free or an egg-free cake and also on the method you want to prepare with. Writing software is like that. There is no one recipe or magic formula; the same system could be built in many different ways, with no one necessarily better than any other. There are different ingredients that you may choose to feed the development process and different methods to follow. Likely as not, they will each produce a slightly different cake; different in terms of features, structure, stability, extensibility, maintainability, and more. These recipes describe the <span class="emphasis"><em>software life cycle</em></span>: the phases of development ranging from the very beginning (conceptualizing the software) to its very end (decommissioning it).<a class="indexterm" id="IDX-CHP-22-1695"/><a class="indexterm" id="IDX-CHP-22-1696"/></p><p>As software engineers, we should be able to predictably (and to some extent reproducibly) create software by following a defined procedure. As software craftsmen, we should be able to harness a particular development procedure as a tool to help fashion the best software possible. In this chapter, we'll investigate some of the recipes for creating software; we'll compare, contrast, criticize, and see how they affect the way we code.</p><p>We programmed a ZX spectrum differently from a modern palmtop PDA, and that differently from a mainframe stock control system with a high-capacity web interface. We program differently alone than we would working in a pair, and differently than we would in a 200-strong worldwide project team. Differences in the target platform and development team (and their levels of experience) will shape the choice of recipe. The art of programming is much more than just edit, compile, link, and run.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Good programmers are aware of</em></span> how <span class="emphasis"><em>they program—the methods and practices that shape their work</em></span>.</p></dd></dl></div><p>What are these programming recipes?</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="programming_styles"/>Programming Styles</h1></div></div></div><p>A programming style describes how a software problem is mapped out and how its solution is decomposed and then modeled by the target language. We have to <span class="emphasis"><em>model</em></span> a solution, since useful systems can't be entirely held in the mind of a single developer. The programming style shapes how we split a project up into manageable pieces; it is the design paradigm used to express your code's intent.<a class="indexterm" id="IDX-CHP-22-1697"/><a class="indexterm" id="IDX-CHP-22-1698"/><a class="indexterm" id="IDX-CHP-22-1699"/><a class="indexterm" id="IDX-CHP-22-1700"/><a class="indexterm" id="IDX-CHP-22-1701"/><a class="indexterm" id="IDX-CHP-22-1702"/><a class="indexterm" id="IDX-CHP-22-1703"/><a class="indexterm" id="IDX-CHP-22-1704"/><a class="indexterm" id="IDX-CHP-22-1705"/></p><p>Different programming languages support different programming styles. Some are tailored to a specific one; some cater for a number of them. The programming styles fall into two main camps: <span class="emphasis"><em>imperative</em></span> and <span class="emphasis"><em>declarative</em></span>.<a class="indexterm" id="IDX-CHP-22-1706"/><a class="indexterm" id="IDX-CHP-22-1707"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Imperative (or procedural ) languages allow you to specify the explicit sequence of steps to follow to produce the program's output. It's what most programmers are used to.<a class="indexterm" id="IDX-CHP-22-1708"/></p></li><li class="listitem"><p>Declarative languages describe relationships between variables in terms of inference rules (or functions), and the language executor applies some fixed algorithm to these rules to produce the result. (This description might turn into understandable English once when we take a look at functional and logic programming.)</p></li></ul></div><p>The programming language you choose will go some way to determine the style you design with. (However, it would be better to select a language that supports the style you want to use.) The programming language is not the ultimate determinant, though. It is perfectly possible to build structured code in an object-oriented language, in the same way that it is possible to write hateful code in any language. The next few sections describe the popular programming styles.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="structured_programming"/>Structured Programming</h2></div></div></div><p>This common imperative design method applies <span class="emphasis"><em>algorithmic decomposition</em></span>—a process of breaking a system into parts, each of which represents a small step in the larger process. Design decisions focus on the flow of control and create a hierarchy of functional structure. As Dijkstra observed, "Hierarchical systems seem to have a property that something considered as an undivided entity on one level is considered as a composite object on the next lowest level of greater detail: as a result, the natural grain of space or time that is applicable at each level decreases by an order of magnitude when we shift our attention from one level to the next lower one. We understand walls in terms of bricks, bricks in terms of crystals, crystals in terms of molecules, etc." Indeed, it was Dijkstra's seminal paper "Go To Statement Considered Harmful" that popularized structured programming. (Dijkstra 68)<a class="indexterm" id="IDX-CHP-22-1713"/><a class="indexterm" id="IDX-CHP-22-1714"/><a class="indexterm" id="IDX-CHP-22-1709"/><a class="indexterm" id="IDX-CHP-22-1710"/><a class="indexterm" id="IDX-CHP-22-1711"/><a class="indexterm" id="IDX-CHP-22-1712"/><a class="indexterm" id="IDX-CHP-22-1715"/><a class="indexterm" id="IDX-CHP-22-1716"/><a class="indexterm" id="IDX-CHP-22-1717"/><a class="indexterm" id="IDX-CHP-22-1718"/></p><p>Structured programming is a control-centered model and follows a top-down design technique. You start with the whole program in mind (e.g., <code class="literal">do_shopping</code>). Then you decompose it into sequential sub-blocks (e.g., <code class="literal">get_shopping_list</code>, <code class="literal">leave_house</code>, <code class="literal">walk_to_shop</code>, <code class="literal">collect_items</code>, <code class="literal">pay_at_checkout</code>, <code class="literal">return_to_house</code>, <code class="literal">put_shopping_away</code>). In turn, each sub-block is decomposed until it is at a level that can be easily implemented in code. The blocks are assembled into a whole, and the design is complete.<a class="indexterm" id="IDX-CHP-22-1719"/></p><p>The implications of a structured approach are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Each step of the decomposition should be within the programmer's intellectual understanding. (Dijkstra said, "I now suggest that we confine ourselves to the design and implementation of intellectually manageable programs.")</p></li><li class="listitem"><p>Control flow should be carefully managed: Avoid the dreaded <code class="literal">goto</code> statement (an unstructured jump in the code to some arbitrary place), and instead prefer functions to have a single entry and single exit point (this is known as <span class="emphasis"><em>SESE code</em></span>).</p></li><li class="listitem"><p>Looping constructs and conditional statements are used within functional blocks to provide code structure. Short-circuit jumping out of the middle of a loop or from within a nested block of code is held in similar disdain to <code class="literal">goto</code>.</p></li></ul></div><p>Common structured programming languages are C, Pascal, BASIC, and more venerable languages like Fortran and COBOL. Most other imperative languages can be easily used to write structured code, although it's not their design specialism; structured programmers often adopt new fashionable languages without adopting new idioms.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-1" id="CHP-22-FN-1">1</a>]</sup></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="object-oriented_programming"/>Object-Oriented Programming</h2></div></div></div><p>Booch describes OO programming as "A method of implementation in which programs are organized as co-operative collections of objects, each of which represents an instance of some class, and whose classes are all members of a hierarchy of classes united via inheritance relationships." (Booch 94) It is another imperative style, but one that allows us to more naturally model the world in our code designs; we focus on the interacting entities being modeled rather than on the notion of a particular flow of execution.<a class="indexterm" id="IDX-CHP-22-1725"/><a class="indexterm" id="IDX-CHP-22-1726"/><a class="indexterm" id="IDX-CHP-22-1727"/><a class="indexterm" id="IDX-CHP-22-1728"/><a class="indexterm" id="IDX-CHP-22-1729"/><a class="indexterm" id="IDX-CHP-22-1730"/><a class="indexterm" id="IDX-CHP-22-1731"/><a class="indexterm" id="IDX-CHP-22-1732"/><a class="indexterm" id="IDX-CHP-22-1733"/></p><p>This is very much a data-centred model (as opposed to structured programming's process-centric view). We think about the life of our data and how it moves about, rather than the sequence of steps that need to be taken to get the job done. Objects (the data) have behavior (they do things) and states (which change when they do things). This is implemented at language level by <span class="emphasis"><em>methods</em></span> on <span class="emphasis"><em>classes</em></span> of <span class="emphasis"><em>objects</em></span>. We think of OO programs as sets of collaborating software components, rather than as monolithic lists of CPU instructions. OO design has allowed us to effectively model larger systems.<a class="indexterm" id="IDX-CHP-22-1734"/><a class="indexterm" id="IDX-CHP-22-1735"/></p><p>Object-oriented programming exploits the following computer science concepts:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Abstraction</strong></span></span></dt><dd><p>The art of selective ignorance—abstraction allows us to design code so that the higher levels of control can ignore gory implementation details below. Who cares whether <code class="literal">get_next_item</code> does a binary search in a list, indexes an array, or makes a phone call to Frankfurt? It returns the next item (whatever that is), and that's all the calling code has to care about.<a class="indexterm" id="IDX-CHP-22-1736"/></p><p>Dijkstra's earlier exposition of hierarchy—go back and read it again—revealed a form of abstraction.</p></dd><dt><span class="term"><span class="strong"><strong>Encapsulation</strong></span></span></dt><dd><p>Encapsulation is the placing of cohesive units of execution into one tightly bound package that can only be accessed through a well-defined API: a code capsule. Users of that capsule can only call the defined API and cannot tinker directly with internal state. This provides a clear separation of concerns, helps us to reason about metaphysical questions like <span class="emphasis"><em>What is an object?</em></span> and provides some assurance that no evil programmer can tinker with your innards when you're not looking.</p></dd><dt><span class="term"><span class="strong"><strong>Inheritance</strong></span></span></dt><dd><p>A mechanism to create an object type that is a specialized version of a parent object. Consider a parent type called <code class="literal">Shape</code>, with inherited child types <code class="literal">Square</code>, <code class="literal">Circle</code>, and <code class="literal">Triangle</code>. The inherited types provide more detail, specializing behavior (for example, knowing the exact number of sides the shape has). Like any other programming concept, inheritance can be abused to create unfathomable, surprising programs or leveraged to create logically sound, elegant code. Good OO programmers know how to create appropriate inheritance hierarchies.<a class="indexterm" id="IDX-CHP-22-1737"/><a class="indexterm" id="IDX-CHP-22-1738"/><a class="indexterm" id="IDX-CHP-22-1739"/><a class="indexterm" id="IDX-CHP-22-1740"/></p></dd><dt><span class="term"><span class="strong"><strong>Polymorphism</strong></span></span></dt><dd><p>This allows the same code to use different underlying data types (what most OO programming languages call <span class="emphasis"><em>classes</em></span>) depending on the context in which it runs. This technique emphasizes programming to explicitly defined interfaces, not to an implicit implementation—polymorphism provides a clear separation of concerns as you write code. There are two types of polymorphism, <span class="emphasis"><em>dynamic</em></span> and <span class="emphasis"><em>static</em></span>.<a class="indexterm" id="IDX-CHP-22-1741"/><a class="indexterm" id="IDX-CHP-22-1742"/><a class="indexterm" id="IDX-CHP-22-1743"/></p><p>Dynamic polymorphism, as the name suggests, determines the actual operation to be performed at run time, based on the type of an operand or target object. This often exploits inheritance hierarchies: a client that deals with <code class="literal">Shape</code> types might currently be using a <code class="literal">Square</code> or a <code class="literal">Triangle</code> object—which one is figured out at run time.</p><p>Static polymorphism determines the exact code to be run at compile time. Language features that provide static polymorphism include: <span class="emphasis"><em>function overloading</em></span> (functions with the same name accept different parameter lists—the compiler deduces the correct function to invoke from the arguments supplied), <span class="emphasis"><em>operator overloading</em></span> (where you can define certain operations on types—including +, !=, &lt;, and &amp;—these functions are called when the types of operands match), and <span class="emphasis"><em>generic programming facilities</em></span> like C++'s <span class="emphasis"><em>template specialism</em></span> (where you can overload a template based on the template parameter type).<a class="indexterm" id="IDX-CHP-22-1744"/><a class="indexterm" id="IDX-CHP-22-1745"/></p></dd></dl></div><p>These facilities are all possible to use in non-OO languages, using non-OO practices. However, OO languages express them directly and OO designs exploit them to create a cohesive system.</p><p>Object-oriented programming started with Simula around 1970 and has been recently popularized by C++ and Java. One of the few pure OO programming languages is Smalltalk. These days, OO is en vogue, and there are many OO languages; a number are structured languages with fashionable OO bolt-ons.<a class="indexterm" id="IDX-CHP-22-1746"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="functional_programming"/>Functional Programming</h2></div></div></div><p>This is a declarative programming style based on typed <span class="emphasis"><em>lambda calculus</em></span>, a more mathematical model of programming. You work with values, functions, and functional forms. Functional programs are generally compact and elegant, although seldom compiled. They are therefore reliant on a language executor. The program's performance is governed by these executors—they can be quite slow and memory hungry.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-2" id="CHP-22-FN-2">2</a>]</sup></p><p>The structured and OO styles are far more popular in mainstream use than any declarative languages, although that doesn't diminish the usefulness of this breed of programming. They have different strong points and uses. Functional programs require a totally different approach to code design from the procedural methods.</p><p>Common functional programming languages are Lisp (although it does contain nonfunctional elements), Scheme, ML, and Haskell.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="logic_programming"/>Logic Programming</h2></div></div></div><p>This is another declarative style, in which you provide the executor with a set of axioms (rules) and a goal statement. A set of built-in inference rules (over which the programmer has no control) are applied to determine whether the axioms are sufficient to ensure the truth of the goal statement. Program execution is essentially the proof of the goal statement.<a class="indexterm" id="IDX-CHP-22-1752"/><a class="indexterm" id="IDX-CHP-22-1753"/></p><p>Interest in artificial intelligence was a huge boost to the development of logic programming languages. They are widely used for automatic theorem proving and in <span class="emphasis"><em>expert systems</em></span> (which model large problem domains and generate specific answers based on the amassed body of knowledge).<a class="indexterm" id="IDX-CHP-22-1754"/><a class="indexterm" id="IDX-CHP-22-1755"/></p><p>The best known logic programming language is Prolog.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-1" id="ftn.CHP-22-FN-1">1</a>] </sup>This is not necessarily a Bad Thing, unless the programmer believes that he's moved beyond structured coding without changing the way he designs code.<a class="indexterm" id="IDX-CHP-22-1720"/><a class="indexterm" id="IDX-CHP-22-1721"/><a class="indexterm" id="IDX-CHP-22-1722"/><a class="indexterm" id="IDX-CHP-22-1723"/><a class="indexterm" id="IDX-CHP-22-1724"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-2" id="ftn.CHP-22-FN-2">2</a>] </sup>This is not a problem solely encountered by declarative languages (for example Java has an executor, the JVM). However, comparatively less optimization effort has gone into the declarative breed of language executors—they're more often backed by academic institutions than wealthy corporations.<a class="indexterm" id="IDX-CHP-22-1747"/><a class="indexterm" id="IDX-CHP-22-1748"/><a class="indexterm" id="IDX-CHP-22-1749"/><a class="indexterm" id="IDX-CHP-22-1750"/><a class="indexterm" id="IDX-CHP-22-1751"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="recipes_colon_the_how_and_the_what"/>Recipes: The How and the What</h1></div></div></div><p>There are two different aspects we'll investigate. Software "recipes" employ a <span class="emphasis"><em>development process</em></span> and also a <span class="emphasis"><em>programming style</em></span>. The two are separate and connected:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The process is the larger picture: It describes the steps taken to construct software. This encompasses the <span class="emphasis"><em>entire</em></span> development organization, not just the programmers. Most software construction is not a one-person job; the process explains how to get a number of people to build a coherent whole. Or at least, it should attempt to.</p></li><li class="listitem"><p>The programming style is the smaller picture: It is an underlying approach for dissecting, building, and gluing software components together. It will quite likely be influenced by the choice of development process, but doesn't have to be.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-3" id="CHP-22-FN-3">3</a>]</sup> It's more likely to be influenced by a target language or the designer's prior experience.</p></li></ul></div><p>You'll see both of these construction aspects called methodologies, so it's easy to get them confused.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-4" id="CHP-22-FN-4">4</a>]</sup> We'll look in turn at styles and then development processes. It's important to have a grasp of the different development methods out there, to give you a better programming worldview and to help you choose a process, should you ever have the opportunity.<a class="indexterm" id="IDX-CHP-22-1756"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Our software development efforts are molded by the</em></span> styles <span class="emphasis"><em>and</em></span> processes <span class="emphasis"><em>we employ. These have an inevitable effect on the shape and quality of our code</em></span>.</p></dd></dl></div><p>The following sections do not provide a textbook description of these topics; they provide a suitably hand-wavy overview to help us compare and contrast. If you want or need more detail, you can easily find a hard-core software engineering textbook.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-3" id="ftn.CHP-22-FN-3">3</a>] </sup>For example, OO styles are often picked in "iterative and incremental" processes; this is mostly by convention. (If you don't know what this means, <span class="emphasis"><em>don't panic</em></span>! It will all be explained in "<a class="xref" href="ch22s03.html#iterative_and_incremental_development" title="Iterative and Incremental Development">Iterative and Incremental Development</a>" on page 432.)</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-4" id="ftn.CHP-22-FN-4">4</a>] </sup>If you want to make a distinction, then what I call programming styles are often called methodologies (with a lowercase m). Development processes are often called Methodologies (with an uppercase M ); a kind of high-church/low-church classification. That's far too subtle. In this chapter I'll stick to styles and processes.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="development_processes"/>Development Processes</h1></div></div></div><p>There are as many development processes as there are people who feel like inventing them. Many are slight evolutions of one or two basic development models. We'll look here at those basic variants. Some of them are closely related, as you will see.<a class="indexterm" id="IDX-CHP-22-1757"/><a class="indexterm" id="IDX-CHP-22-1758"/></p><p>Your choice of development processes determines how projects are planned, how work flows between phases, and how the project team interacts. Processes vary along a number of axes:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Thick/thin</strong></span></span></dt><dd><p>A <span class="emphasis"><em>thick development process</em></span> is heavyweight and bureaucratic. It generates a lot of paperwork, regiments developer behavior, and presumes a certain team structure. It's characterized by the ISO 9000 organizational model, where every work procedure is slavishly written down in great detail, without regard for whether the process is flawed or appropriate.<a class="indexterm" id="IDX-CHP-22-1759"/><a class="indexterm" id="IDX-CHP-22-1760"/></p><p>At the other end of the process spectrum, <span class="emphasis"><em>thin development processes</em></span> eschew unnecessary bureaucracy, favoring leaner, people-centric principles. Agile processes, described in "<a class="xref" href="ch22s03.html#agile_methodologies" title="Agile Methodologies">Agile Methodologies</a>" on page 433, are built around thin practices.<a class="indexterm" id="IDX-CHP-22-1761"/></p></dd><dt><span class="term"><span class="strong"><strong>Sequencing</strong></span></span></dt><dd><p>Some development processes sensibly recognize that the world is not a predictable place and attempt to model and plan for this by running a number of iterations around a process loop. This provides an opportunity for the developers to incorporate feedback from one iteration into the work of the next. They can adapt to the natural changes that occur as software develops (changing customer requirements, unexpected problems encountered, etc.).</p><p>Other processes are more regimented and linear—predicting a formal progression of development from one phase to the next. They involve heavy up-front planning efforts and try to foresee the future in great detail. These predictions make it hard to change direction late in development.<a class="indexterm" id="IDX-CHP-22-1762"/></p></dd><dt><span class="term"><span class="strong"><strong>Design direction</strong></span></span></dt><dd><p>A <span class="emphasis"><em>top-down design</em></span> creates the system from an initial undetailed overview. Each top-level package is refined and split into subcomponents. This process iterates until the software is specified sufficiently to begin work. Top-down design emphasizes planning and a good understanding of the final system, and presumes that few requirements change en route.<a class="indexterm" id="IDX-CHP-22-1764"/><a class="indexterm" id="IDX-CHP-22-1763"/></p><p>The opposite, <span class="emphasis"><em>bottom-up design</em></span>, specifies individual parts of the system in detail and then determines how best to connect them to form a cohesive whole. This helps us to leverage existing software components in a new design. Modern processes tend to blend these two polar opposites—some idea of the entire system is required to begin initial planning, then the design progresses by identifying and coding low-level components and objects.<a class="indexterm" id="IDX-CHP-22-1765"/><a class="indexterm" id="IDX-CHP-22-1766"/></p></dd></dl></div><p>No one style of development process is better than any other. Extreme religious views are held about the correct position on any one of these axes. The correct methodology for any project is determined by a number of factors, including the development culture of the organization, the type of product being developed, and the experience of the development team.<a class="indexterm" id="IDX-CHP-22-1767"/></p><p>Now please buckle your seat belts for our roller coaster ride through the range of software development processes. Hold on tight.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ad_hoc"/>Ad Hoc</h2></div></div></div><p>This is a starting point, but it's really an anti-process. Here there is no process, or else it is undocumented. Everybody works to his or her own agenda, no one knows what anyone else is doing, and hopefully something useful will drop out at the end. Perhaps your team works like <a class="xref" href="ch22s03.html#engineering_a_release" title="Figure 22-1. Engineering a release">Figure 22-1</a>?<a class="indexterm" id="IDX-CHP-22-1768"/><a class="indexterm" id="IDX-CHP-22-1769"/></p><p>If an organization doesn't know how it builds software, then it's in an unforgivable state, even if it's a small outfit and it doesn't think it needs a process. In this state, there is no guarantee that the software will be delivered on time, since there's no accountability. Who can guarantee that all the features will be implemented?<a class="indexterm" id="IDX-CHP-22-1770"/></p><p>A lot of open source software is created using this chaotic method.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-5" id="CHP-22-FN-5">5</a>]</sup> If you have an infinite number of monkeys and an infinite number of computers, you might eventually get a program out—however it isn't feasible to wait the requisite infinite amount of time. Even back-of-napkin designs are a step toward a more formal, predictable development process.<a class="indexterm" id="IDX-CHP-22-1772"/><a class="indexterm" id="IDX-CHP-22-1771"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Without a development process, your team is in a state of anarchy. Your software will be produced by luck, not on purpose</em></span>.<a class="indexterm" id="IDX-CHP-22-1773"/></p></dd></dl></div><p>This case is development anarchy. Individual programmers may work hard, and their heroic efforts might eventually produce something of value. Such an outcome cannot be seriously relied upon, though. The team is likely to be very inefficient and will probably never deliver anything of value.</p><div class="figure"><a id="engineering_a_release"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e30446"/><img alt="Engineering a release" src="tagoreillycom20080909nostarchimages207578.png.jpg"/></div></div><p class="title"><b>Figure 22-1. Engineering a release</b></p></div><br class="figure-break"/></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="waterfall_model"/>Waterfall Model</h2></div></div></div><p>The <span class="emphasis"><em>waterfall model</em></span> is the classic software development life cycle model. It has been much criticized for its simplicity (even for being old fashioned). However practically every other development process is in some way based on it. It has numerous flaws, and yet it is still an instructional starting point in process study. It's modeled after a more conventional engineering life cycle and was described by W.W. Royce in 1970. (Royce 70) It's the most predictive of the development processes.<a class="indexterm" id="IDX-CHP-22-1779"/><a class="indexterm" id="IDX-CHP-22-1774"/><a class="indexterm" id="IDX-CHP-22-1775"/><a class="indexterm" id="IDX-CHP-22-1776"/><a class="indexterm" id="IDX-CHP-22-1777"/><a class="indexterm" id="IDX-CHP-22-1778"/></p><div class="sidebar"><a id="stages_of_development"/><p class="title"><b>STAGES OF DEVELOPMENT</b></p><p>The waterfall model describes five stages in the life of a software development process.<a class="indexterm" id="IDX-CHP-22-1780"/></p><p>Many other processes identify the same phases but order them differently or change their relative emphasis.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Requirements analysis</strong></span></span></dt><dd><p>First, the requirements for the software project are established. This scopes its goals, the services it will provide, and what constraints it needs to work within. This step is often preceded by a feasibility study to kick the project off, or feasibility is done at the same time. The feasibility study asks questions like: <span class="emphasis"><em>Will this project work? Should we develop this software? What are the alternatives?</em></span><a class="indexterm" id="IDX-CHP-22-1781"/><a class="indexterm" id="IDX-CHP-22-1782"/></p></dd><dt><span class="term"><span class="strong"><strong>Design and specification</strong></span></span></dt><dd><p>The established requirements flowing from the first stage are converted into software or hardware requirements. The software requirements are then transformed into a form that can be readily implemented in a computer program, perhaps by splitting into separately developed components.</p></dd><dt><span class="term"><span class="strong"><strong>Implementation</strong></span></span></dt><dd><p>This is where the programs are created. Each program or subcomponent is a unit, and is unit tested. The unit test ensures that each unit meets its specification as defined in the previous step.<a class="indexterm" id="IDX-CHP-22-1783"/></p></dd><dt><span class="term"><span class="strong"><strong>Integration and testing</strong></span></span></dt><dd><p>All units are combined and the whole system is tested. We test that the code integrates correctly, that the entire system behaves as it should, and that it implements all system requirements. When successfully tested, the software is considered complete.</p></dd><dt><span class="term"><span class="strong"><strong>Maintenance</strong></span></span></dt><dd><p>Finally, the product is delivered. We should never presume software is finished when it ships; it is naïve to do so. The largest phase of the software lifecycle is <span class="emphasis"><em>maintenance</em></span> (see "<a class="xref" href="ch15s05.html#maintenance_of_existing_code" title="Maintenance of Existing Code">Maintenance of Existing Code</a>" on page 288). There will be bugs to fix, unnoticed requirements to accommodate, evolution of the original requirements, and other product support work for software deployed in the field.<a class="indexterm" id="IDX-CHP-22-1784"/></p></dd></dl></div></div><p>It is a simple idea; the development process is broken up into a number of stages, which run one after the other. This is likened to a waterfall because of the steady, irreversible flow from one stage to another. Just as water always flows downward toward the river, the development always flows downward through each stage toward release.</p><p>The traditional waterfall model is shown in <a class="xref" href="ch22s03.html#the_traditional_waterfall_model" title="Figure 22-2. The traditional waterfall model">Figure 22-2</a>.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-6" id="CHP-22-FN-6">6</a>]</sup> You can see the five standard stages; these are described in the "<a class="xref" href="ch22s03.html#stages_of_development" title="STAGES OF DEVELOPMENT">STAGES OF DEVELOPMENT</a>" text box. Once a stage is successfully completed, progression is made via some <span class="emphasis"><em>gating process</em></span> (usually a review meeting) to the next stage. The output of most stages is a document; a requirements specification, a design specification, or something similar. If the review finds an error or problem, it is fed back upstream, setting that stage back again.<a class="indexterm" id="IDX-CHP-22-1785"/></p><p>Following this model, you can't easily backtrack to make changes; it's like a salmon expending massive amounts of time and energy swimming back upstream. While salmon are genetically programmed to do this, programmers aren't. This means that the process is not helpful when changes are made late in the development process. The requirements must be fixed before system design, and it is difficult to accommodate too many alterations after the process is underway. Generally, problems at the design stage are not discovered until system testing.<a class="indexterm" id="IDX-CHP-22-1786"/></p><p>In its defense, though, it is simple to manage—at least conceptually—and is the basis for most other development models. The waterfall doesn't scale well to very large projects; it works fine for a two-week project. Other development models exploit this by running many, smaller, waterfalls over the life of a large project.</p><div class="figure"><a id="the_traditional_waterfall_model"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e30583"/><img alt="The traditional waterfall model" src="tagoreillycom20080909nostarchimages207580.png"/></div></div><p class="title"><b>Figure 22-2. The traditional waterfall model</b></p></div><br class="figure-break"/></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ssadm_and_prince"/>SSADM and PRINCE</h2></div></div></div><p>Although <span class="emphasis"><em>SSADM</em></span> sounds like development only partaken by consenting adults, it actually stands for <span class="emphasis"><em>Structured Systems Analysis and Design Methodology</em></span>. It is a structured and rigorous method following the waterfall approach, perhaps the most regimented waterfall variant you'll encounter.<a class="indexterm" id="IDX-CHP-22-1787"/><a class="indexterm" id="IDX-CHP-22-1788"/><a class="indexterm" id="IDX-CHP-22-1789"/><a class="indexterm" id="IDX-CHP-22-1790"/><a class="indexterm" id="IDX-CHP-22-1791"/></p><p>It covers analysis and design, not implementation and testing, and is a well-defined open standard, heavily used in UK government organizations. SSADM consists of five main steps (each subdivided into many other procedures), which for our purposes are self-descriptive:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Feasibility study</p></li><li class="listitem"><p>Requirements analysis</p></li><li class="listitem"><p>Requirements specification</p></li><li class="listitem"><p>Logical system specification</p></li><li class="listitem"><p>Physical design</p></li></ul></div><p><span class="emphasis"><em>Projects In a Controlled Environment (PRINCE)</em></span> and its imaginatively named successor, <span class="emphasis"><em>PRINCE2</em></span>, were created in 1989 and 1996 to supercede SSADM. Like SSADM, they define a heavyweight, document-centric model. They list regimented steps (this time in eight separate phases) that can be followed to produce a product, aiming to meet identified requirements and quality standards.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="v_model"/>V Model</h2></div></div></div><p>This process model derives from the classic waterfall and was developed to regulate the software development process within German administration and military. It shares much in common with the waterfall model (including a propensity to attract criticism) but rather than model the processes as a cascade, it is visualized as a <span class="emphasis"><em>V</em></span>, as shown in <a class="xref" href="ch22s03.html#the_v_model" title="Figure 22-3. The V model">Figure 22-3</a>.<a class="indexterm" id="IDX-CHP-22-1792"/><a class="indexterm" id="IDX-CHP-22-1793"/><a class="indexterm" id="IDX-CHP-22-1794"/></p><div class="figure"><a id="the_v_model"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e30667"/><img alt="The V model" src="tagoreillycom20080909nostarchimages207582.png"/></div></div><p class="title"><b>Figure 22-3. The V model</b></p></div><br class="figure-break"/><p>On the left, we see the development phases leading up to software construction: the planning, design, and implementation work. The right-hand stream governs testing and approval.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-7" id="CHP-22-FN-7">7</a>]</sup> Each level of test work is measured against the specification generated from the corresponding left-hand phase.</p><p>The V model's difference from the waterfall is more than the orientation of a diagram. The testing phases (in the right branch) can begin in parallel to the development work (the left branch), and are given an equal importance. This is good because:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Traditionally, testing is squeezed out during the dying stages of a slipping project. This is dangerous. Emphasizing testing as a keystone of the development process highlights this fact and helps to ensure product quality.</p></li><li class="listitem"><p>We should always test more than the final software: reviewing and validating at <span class="emphasis"><em>all</em></span> stages of development work, from the requirements specification through to the completed software. The V model highlights this.</p></li><li class="listitem"><p>In the Real World, testing and bug fixing often take up more than half of a project's total time. The waterfall model doesn't accurately reflect this.</p></li><li class="listitem"><p>This model can shave time from the entire development process, since the test plans can be drawn up as soon as each development phase is complete. This streamlined, parallelized work will bring forward the project's end date because we don't need to wait for the waterfall's implementation phase to end before beginning test activity.</p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="prototyping"/>Prototyping</h2></div></div></div><p>Despite our many years of research and experience in software development processes, the waterfall is still a standard reference model since it has a clear logic to it—you obviously can't perform useful implementation before requirements analysis or any design work. However, the waterfall makes it hard to evaluate a software system until development is complete. It is also hard to demonstrate the software to your customer until the integration phase has completed and the system is ready to alpha test.<a class="indexterm" id="IDX-CHP-22-1796"/><a class="indexterm" id="IDX-CHP-22-1797"/><a class="indexterm" id="IDX-CHP-22-1798"/><a class="indexterm" id="IDX-CHP-22-1799"/></p><p>The <span class="emphasis"><em>prototyping approach</em></span> attempts to work around this limitation. It helps to explore and evaluate implementation as development progresses and to refine unknown or ambiguous requirements (users never know what they <span class="emphasis"><em>really</em></span> want).</p><p>The essence of the prototyping process is to create a number of throw-away prototypes of the software system. Each prototype is evaluated, shown to the customer, and customer feedback is used to shape the next prototype. This continues until enough is known to develop and deploy the real product.</p><p>We see an analogy with other industries here. If you were developing a new car, you'd create many prototypes until you hit on exactly the right design. We aim to do the same with our software. However, there is an important difference that must be observed. When building a car, the major cost is in the manufacturing, not the development. It works the other way around with software. You can make multiple copies of the code for free; the development is the costly part. For this reason, the prototyping cycle needs to be controlled; it can't be repeated an unlimited number of times.</p><div class="sidebar"><a id="prototype_blues"/><p class="title"><b>PROTOTYPE BLUES</b></p><p>Releasing prototypes can cause severe maintenance problems.</p><p>I did some work for a company that had a policy of only using one GUI library for its Java front ends. But in practice, it had some systems that used the library and some that didn't. Whenever a bug cropped up, the maintenance programmers had to jump through hoops to work out what the front end code was doing. They didn't understand the other GUI libraries, and often their fixes introduced yet more problems. The more this happened, the less respected the company's products became.</p><p>It didn't take much software archeology to discover the cause of this problem: The front ends that didn't use the correct GUI library had been prototypes that "accidentally" became products. A little time spent releasing correct code would have saved months of work later on and wouldn't have destroyed the company's reputation.</p></div><p>The prototypes are developed quickly in very high-level languages. Sometimes they are simply drawn: The use of automated tool support<sup>[<a class="footnote" href="#ftn.CHP-22-FN-8" id="CHP-22-FN-8">8</a>]</sup> can speed prototype production immensely. The prototypes are proofs-of-concept, so efficiency, stability, or a complete feature set are not primary concerns. For this reason, prototyping works best for systems with an emphasis on the user interface.</p><p>Prototypes help us to manage risk. We can use them to ensure that customers really do want what they <span class="emphasis"><em>say</em></span> they want. We can also use prototypes to explore the use of a new technology or to check that our design decisions will stand up to real use.</p><p>The danger with prototyping is the temptation to continue developing the inefficient, quickly produced, not fully thought-out prototype code into a real release. This is especially true when a project is running out of time and the real development might not fit the schedule. Without education, customers will confuse the prototype with the finished product and be surprised that it takes a lot longer to receive their completed software. It needs very careful management to work. The best way to avoid this problem is to leave your prototypes deliberately rough around the edges, and to never get them near a releasable state. A prototype that has too much functionality is not a prototype!</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="iterative_and_incremental_development"/>Iterative and Incremental Development</h2></div></div></div><p>All the recent advances on the waterfall approach are basically variations on a theme. The major improvement is performing development in an <span class="emphasis"><em>iterative and incremental manner</em></span>. That is, many trips (iterations) around a small development life cycle run back to back (incrementally), with each cycle adding more and more functionality to the system until it is complete. Each single run of a mini lifecycle tends to follow the waterfall model and may last a number of weeks or months (depending on the scale of the project). Each phase of the waterfall therefore gets executed more than once. At each iteration end is a software release.<a class="indexterm" id="IDX-CHP-22-1802"/><a class="indexterm" id="IDX-CHP-22-1800"/><a class="indexterm" id="IDX-CHP-22-1801"/></p><p>Incremental development is neither a top-down nor a bottom-up approach. A complete version of the code is created for each code release, with all requisite high- and low-level components. During each iteration, the system grows, and subsequent design work can be done based on the existing design and implementation. There is a parallel to prototyping here, but we're not so focused on quick demonstrative hacks. With this approach each stage is less complex and easier to manage—and process progress is more easily monitored; you know how much of the system is built and integrated.</p><p>This kind of process works well for projects whose requirements are less understood at the start. Let's face it: That encompasses most projects in the Real World. It is more resilient to change, and it saves the lengthy redesign and reimplementation of the entire system that you'd encounter in the waterfall approach. Iterative and incremental development works well because it fits the fundamental nature of software development, it consequently helps us to better control the inherent chaos. Because iterative cycles are much shorter, there is greater opportunity for feedback and correction; you don't have to wait until the end of your project to find out that it's failing.<a class="indexterm" id="IDX-CHP-22-1803"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="spiral_model"/>Spiral Model</h2></div></div></div><p>The <span class="emphasis"><em>spiral model</em></span>, proposed by Barry Boehm in 1988 (Boehm 88), is a good example of the iterative and incremental approach.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-9" id="CHP-22-FN-9">9</a>]</sup> The development process is modeled as a spiral, like <a class="xref" href="ch22s03.html#the_spiral_model" title="Figure 22-4. The spiral model">Figure 22-4</a>. It starts in the center and fans outward toward the later stages of the process. We start working on a very rough notion of the system, becoming more detailed over time, as we enter later stages of the spiral. Each 360-degree turn of the spiral sees us go through a single waterfall, and each iteration typically lasts six months to two years.</p><p>Features are defined and implemented in order of decreasing priority; the most important facilities are created as soon as possible. This is a way of managing risk; it's safer because as you inch toward the ship date, you can be sure that the majority of the system is complete. In fact, it is very pragmatic approach; the programmers will not be spending 80 percent of their time on the trifling (but fun) 20 percent of the system.</p><div class="figure"><a id="the_spiral_model"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e30808"/><img alt="The spiral model" src="tagoreillycom20080909nostarchimages207584.png"/></div></div><p class="title"><b>Figure 22-4. The spiral model</b></p></div><br class="figure-break"/><p>Boehm splits the spiral into four quadrants or four distinct phases:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Objective setting</strong></span></span></dt><dd><p>Specific objectives for this phase are identified.</p></dd><dt><span class="term"><span class="strong"><strong>Risk assessment and reduction</strong></span></span></dt><dd><p>The key risks are identified and analyzed, and information is sought to reduce these risks.</p></dd><dt><span class="term"><span class="strong"><strong>Development and validation</strong></span></span></dt><dd><p>An appropriate model is chosen for next phase of development.</p></dd><dt><span class="term"><span class="strong"><strong>Planning</strong></span></span></dt><dd><p>The project is reviewed, and plans are drawn up for the next round of the spiral.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="agile_methodologies"/>Agile Methodologies</h2></div></div></div><p>These were developed as a backlash against the bureaucratic and heavyweight methodologies that tried to straitjacket the software development process. Agile practitioners observed that software development cannot easily be made a predictable process; they claim that it is <span class="emphasis"><em>very</em></span> different from the established engineering procedures, like constructing a bridge.<sup>[<a class="footnote" href="#ftn.CHP-22-FN-10" id="CHP-22-FN-10">10</a>]</sup> The old-fashioned, monumental methodologies only serve to get in the way of people trying to write good software, and so they should be thrown away.</p><p><span class="emphasis"><em>Agile methodology</em></span> is an umbrella term that describes a number of development processes, including the much-hyped Extreme Programming, as well as Crystal Clear and Scrum. Agile processes focus on nimbleness and risk reduction rather than on long-term planning or forcing (pretending to have) predictability.<a class="indexterm" id="IDX-CHP-22-1807"/><a class="indexterm" id="IDX-CHP-22-1808"/><a class="indexterm" id="IDX-CHP-22-1809"/></p><p>Agile processes share these central tenets:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Minimize risk by performing many small iterative development cycles. The software and all process artifacts are complete, consistent, and of releasable quality at the end of each cycle. Although the software seldom <span class="emphasis"><em>is</em></span> released, it can be passed on to the customer to review and to comment on. This gives the customer reassurance of the team's progress.</p><p>Agile process iterations tend to be much smaller than iterative and incremental process loops (typically lasting a number of weeks, rather than months).</p></li><li class="listitem"><p>Minimize risk by placing far more emphasis on a suite of automated regression tests that are run continually, rather than on a lengthy test cycle at the end of development.<a class="indexterm" id="IDX-CHP-22-1810"/></p></li><li class="listitem"><p>Reduce the documentation that plagues heavyweight processes. Agile processes view the code itself as the design and as the implementation documentation. Good code stands on its own and doesn't need to be lumbered with bureaucratic documentation processes.<a class="indexterm" id="IDX-CHP-22-1811"/></p></li><li class="listitem"><p>Emphasize people and aim to facilitate communication, preferably face-to-face rather than through documents. This keeps the customer (or a customer representative) as close to the development team as possible, to take part in implementation and prioritization decisions.<a class="indexterm" id="IDX-CHP-22-1812"/></p></li><li class="listitem"><p>Consider <span class="emphasis"><em>working software</em></span> as the measure of progress and performance, not specification writing or a manager's opinion of the team's position in a fictitious development cycle. The developers meet problems and respond to changes by modifying the code as development progresses.</p></li></ul></div><p>The agile approach is not always appropriate. It tends to work best on smaller projects, with teams of less than 10 high-quality programmers who are geographically co-located. Agile processes excel in domains with a high degree of requirements change. They are hard to run in companies with a heavy process culture.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="other_development_processes"/>Other Development Processes</h2></div></div></div><p>There are many other development processes: variations on these themes, each with its own distinct features. There are modified waterfall processes that overlap certain phases or contain subprojects, managed as mini-waterfalls. The <span class="emphasis"><em>evolutionary prototyping</em></span> approach starts with an initial concept, designs and implements a prototype, iteratively refines the prototype until it is acceptable, and then releases this, perhaps planning to include some throw away prototypes in the process.<a class="indexterm" id="IDX-CHP-22-1817"/><a class="indexterm" id="IDX-CHP-22-1818"/><a class="indexterm" id="IDX-CHP-22-1813"/><a class="indexterm" id="IDX-CHP-22-1814"/><a class="indexterm" id="IDX-CHP-22-1815"/><a class="indexterm" id="IDX-CHP-22-1816"/></p><p><span class="emphasis"><em>Staged delivery</em></span> follows a sequential process up to architectural design and then implements the separate components showing them to the customer as each is completed, going back to previous development steps if needed. <span class="emphasis"><em>Evolutionary delivery</em></span> is essentially a cross between evolutionary prototyping and staged delivery.<a class="indexterm" id="IDX-CHP-22-1819"/><a class="indexterm" id="IDX-CHP-22-1820"/></p><p>Rapid Application Development (RAD) emphasizes user involvement and small development teams, and it makes heavy use of prototyping and automated tools. In a slight twist on other processes, the development time frame is established up front and considered immovable. Then as many features as feasible are incorporated into the design to accommodate the deadline—some features may be sacrificed.</p><p>The <span class="emphasis"><em>Rational Unified Process (RUP)</em></span> is a notable commercial methodology that stems from Ivar Jacobson's 1987 <span class="emphasis"><em>Objectory Process</em></span>. It's a heavyweight but flexible object-oriented process that leans heavily on UML diagrams, with <span class="emphasis"><em>use case-driven design</em></span> (a use case describes a single user activity or interaction with the software system). It favors iterative development, continuous testing, and careful change management. As a commercial process, it is supported by a suite of commercial tools.<a class="indexterm" id="IDX-CHP-22-1821"/><a class="indexterm" id="IDX-CHP-22-1822"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-5" id="ftn.CHP-22-FN-5">5</a>] </sup>And there, perhaps, it doesn't matter so much, since there's no paying customer and no formal set of requirements—a lot of open source software is developed because the programmer feels like it. However, applying some development process to ad hoc open source work will almost certainly yield better programs.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-6" id="ftn.CHP-22-FN-6">6</a>] </sup>This is a common simplicifcation of Royce's original paper. Royce <span class="emphasis"><em>did</em></span> allow feedback up the waterfall, but didn't actively encourage it. Zealous managers imagined software development to be a strictly linear process, and soon removed these upstream paths; the waterfall was tarnished.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-7" id="ftn.CHP-22-FN-7">7</a>] </sup>Note how development flows downward, like the waterfall, but testing is seen as an uphill effort—a reasonably accurate model of software development!<a class="indexterm" id="IDX-CHP-22-1795"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-8" id="ftn.CHP-22-FN-8">8</a>] </sup>For example, <span class="emphasis"><em>Rapid Application Development (RAD)</em></span> tools with simple GUI builders.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-9" id="ftn.CHP-22-FN-9">9</a>] </sup>Boehm's process wasn't the first iterative model, but he was the first to popularize and emphasize the importance of iteration.<a class="indexterm" id="IDX-CHP-22-1804"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-10" id="ftn.CHP-22-FN-10">10</a>] </sup>This is a religious debate: Many programmers believe that it <span class="emphasis"><em>is</em></span> possible to make the software development process a repeatable, predictable thing, but the industry is currently not mature or disciplined enough to do so.<a class="indexterm" id="IDX-CHP-22-1805"/><a class="indexterm" id="IDX-CHP-22-1806"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="enough_comma_already_exclamation"/>Enough, Already!</h1></div></div></div><p>If you've read this far and haven't gotten bored yet, then you're doing well. Finally, and perhaps more importantly, what are the key points to draw from all this? A software craftsman has a good working understanding of development processes and programming styles, but anyone can get this from the right books. How do we apply this stuff usefully to our work? How can it improve our skill set?<a class="indexterm" id="IDX-CHP-22-1823"/><a class="indexterm" id="IDX-CHP-22-1824"/><a class="indexterm" id="IDX-CHP-22-1825"/><a class="indexterm" id="IDX-CHP-22-1826"/><a class="indexterm" id="IDX-CHP-22-1827"/><a class="indexterm" id="IDX-CHP-22-1828"/><a class="indexterm" id="IDX-CHP-22-1829"/></p><p>All of these processes share some common threads. The phases described in "<a class="xref" href="ch22s03.html#stages_of_development" title="STAGES OF DEVELOPMENT">STAGES OF DEVELOPMENT</a>" on page 428 are present in each. The processes really only differ in the length and relative positioning of these stages. Each activity is vital to the production of good-quality software. The better processes ensure that testing is not left as an afterthought, but is carried out continuously—and monitored—throughout the development process.</p><p>It's hard to compare or evaluate the different processes and programming styles. Which is best? Which will ensure that a high-quality product is shipped on time and to budget? There is no answer, because those are not the right questions. Which process is suitable depends on the nature of the project and the culture of your company. If you have 20 programmers who know nothing of object-oriented development and only ever use C, then trying to build an OO Java product is clearly a stupid idea.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>You'll pick a software recipe for a number of reasons—make sure they're good ones. The motivation for your choice of process says a lot about the maturity of your organization</em></span>.</p></dd></dl></div><p>We can see two procedural extremes: The anarchy of the ad hoc method contrasts with the strict regime of a rigid process. In the latter, any experimentation that could yield a more elegant architecture is discouraged. The user's real requirements may never filter down to a developer since it's lost in a sea of bureaucracy; the programmer just codes to a specification that's passed on to him from the previous process phase.</p><p>Following the <span class="emphasis"><em>Goldilocks prinicple</em></span>, the most flexible approach is somewhere in between. You <span class="emphasis"><em>do</em></span> need to know the process you're working to and where it's defined. Effective development requires discipline; you need a coherent strategy to get something out of the door on time (having a realistic schedule is another topic in its own right—see "<a class="xref" href="ch21s05.html" title="The Planning Game">The Planning Game</a>" on page 409). Experienced programmers know the value of their development processes, as well as the faults. They know how to work with it and when to step outside it. Good programmers don't just program. They understand their recipes and how to adapt them as appropriate. This is why our science is still a craft.</p><p>It's important not to be uptight and legalistic about the process you follow, but you must have an agreed framework for producing software. It must be appropriate for your development team—not every organization needs a high-ceremony process with many hoops and hurdles to navigate and lengthy forms to fill in.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>The process you adopt doesn't have to be high-ceremony and hard to follow. In fact, the exact opposite characteristics are generally hallmarks of a good process. You must have a defined process, though</em></span>.</p></dd></dl></div><p>New methodologies spring up (or rather evolve) from time to time. They tend to arrive with a big fanfare and a spurt of fireworks; they're claimed to be the silver bullet, the panacea that will make development better for our children and our children's children. Sadly, it's never the case. When it comes down to it, no matter which life cycle you follow, the programming team is only as good as its programmers. If there is no intuition, no flair, no experience, and no motivation present then, regardless of the development process you use, you won't reliably produce good code. You might be better able to track how far behind schedule you are, though.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="pick_a_process"/>Pick a Process</h1></div></div></div><p>Many factors contribute to a good choice of development process. However, the choice is seldom made on sensible grounds; a development process is used because <span class="emphasis"><em>It's the way we always do it</em></span>, <span class="emphasis"><em>It works well enough</em></span>, or <span class="emphasis"><em>It was the first thing we could think of</em></span>.<a class="indexterm" id="IDX-CHP-22-1830"/><a class="indexterm" id="IDX-CHP-22-1831"/></p><p>How do you know what development method is appropriate? Ultimately, if the process works for your team—if you collaborate well and produce good software on time—then you have a good development approach.</p><p>A good choice of process is based on the type and size of the project. Small modifications to an existing codebase don't need a large iterative development cycle; three-year industrial projects starting from scratch probably do. A good process choice suits the experience of the existing team members, has the developers willing (even eager) to use it, and is something that the project manager really understands.</p><p>On the flip side, there are plenty of bad reasons to choose a development process. There's no point in moving to a new process just because you feel like a change; a new process must be introduced to fix a problem with the current development model. There's no point in trying to make a political statement (I know people who've tried to foster an open development culture, just to swing the organization toward open sourcing their internal codebase). The ultimate bad motivation for picking a particular process is fashion. More buzzwords do not necessarily mean a more useful process.</p><p>This <span class="emphasis"><em>is</em></span> important: An inappropriate process really can ruin the quality of your code; you'll spend more time pandering to the demands of a procedural straitjacket than delivering software. A good process does not get in your way. Indeed, it enables your team to create more software, better and faster.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Process is vital. Most projects fail for nontechnical reasons. And bad process is almost always high on the list of reasons</em></span>.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id21"/>In a Nutshell</h1></div></div></div><p>Building software is like crime: It's better when it's organized. Every now and again, an undisciplined team will pull off something spectacular and create a software masterpiece. However, that <span class="emphasis"><em>is</em></span> the exception. The development process needs to be defined and understood and carried out by team members with appropriate skills to stand a chance of working well. Otherwise, you'll end up with software that's criminal.<a class="indexterm" id="IDX-CHP-22-1832"/></p><p>We need to use proven development processes and established design styles to allow us to build software that meets expectations against a backdrop of timescales, budgets, and changing requirements. Building software is hard—and we've just looked at another way to make it easier.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Understand the programming style and development process they are expected to work within</p></li><li class="listitem"><p>Exploit their development process to shape interactions with other software factory inhabitants; when the process becomes constraining, they'll sidestep it</p></li><li class="listitem"><p>Appreciate the pros and cons of different development recipes and can pick the appropriate one for any given situation</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ignore development process issues, and attempt to do things their own way</p></li><li class="listitem"><p>Do not know how the process shapes their interaction with other developers</p></li><li class="listitem"><p>Avoid thinking about this kind of stuff—<span class="emphasis"><em>it's for managers to worry about</em></span></p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id21"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a></span></dt><dd><p>Testing is a key phase of the development process. Often the pressures of Real World deadlines try to squeeze out room for it.</p></dd><dt><span class="term"><a class="xref" href="ch17.html" title="Chapter 17. TOGETHER WE STAND">Chapter 17</a></span></dt><dd><p>Teamwork: the cornerstone of large scale software development.</p></dd><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>Specifications are often the gates between phases of the development process.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e31181"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207586.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id22"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 553.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id21"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How do the choices of programming style and development process influence one another?</p></li><li class="listitem"><p>Which is the best programming style?</p></li><li class="listitem"><p>Which is the best development process?</p></li><li class="listitem"><p>Where does each development process listed in this chapter fall on the classification axes we saw in "<a class="xref" href="ch22s03.html" title="Development Processes">Development Processes</a>" on page 425?</p></li><li class="listitem"><p>If development processes and programming styles are recipes, what would a software development cookbook look like?</p></li><li class="listitem"><p>With a suitable process, can software construction become a predictable, repeatable task?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id22"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What development process and programming language style are you currently using?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Has it been formally agreed upon by the development team, or do you use it by convention?</p></li><li class="listitem"><p>How was it chosen? Was it chosen specifically for this project, or is it the recipe you always use?</p></li><li class="listitem"><p>Is it documented anywhere?</p></li><li class="listitem"><p>Does the team stick to the process? When problems arise and your back is against the wall, do you maintain the process, or is all ivory tower theory ignored in a rush to produce something—anything?</p></li></ol></div></li><li class="listitem"><p>Are your current processes and styles appropriate? Are they the best way for you to develop your software right now?</p></li><li class="listitem"><p>Does your organization appreciate that there are other development models that might be worth investigating?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_outer_limits"/>Chapter 23. THE OUTER LIMITS</h1></div><div><h3 class="subtitle"><i>The Different Programming Disciplines</i></h3></div></div></div><div class="epigraph"><p>Everything that irritates us about others can lead us to an understanding of ourselves.</p><div class="attribution"><span>--<span class="attribution">Carl Jung</span></span></div></div><p>I like sweeping generalizations and tenuous metaphors. Sue me. I've also been doing my research. I found that there are over 40 churches in the city I live in. Each one of these is subtly different; different types of people attend, and they do different things. They have different concerns and ways of working. They're located in different areas. However, they're all doing roughly the same thing.<a class="indexterm" id="IDX-CHP-23-1834"/></p><p><span class="emphasis"><em>What on earth has this got to do with programming?</em></span> I hear you ask. If you forgive the tenuous link, software development works in pretty much the same way. Okay, we don't all file into a building every Sunday morning (well, most of us don't). But, to outsiders, we do appear to engage in bizarre rituals and invoke arcane rites to get our own way with things that are out of the control of normal human beings.</p><p>The real comparison I draw, though, is that there is no single way to program, no one methodology that solves every problem. There is no one programming language. There are different classes of problems to be solved in many, many different arenas. The work in each differs by more than mere technology (i.e., which tools and code libraries are available); they differ by technique. Each requires a different skill set, a particular mindset, and subtly different ways of working. The differences might seem slight, but there is no replacement for specific experience of programming a particular type of system—if there was, job advertisements for programmers would be a lot more vague. It's important to know your field well and to appreciate its unique concerns. In a particular programming arena, the craftsman knows how to ply his trade, how to work his medium, and how to best use his tools.<a class="indexterm" id="IDX-CHP-23-1835"/><a class="indexterm" id="IDX-CHP-23-1836"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>There are various types of programming, in different problem domains. Each presents its own unique problems and requires specific skills and experience</em></span>.</p></dd></dl></div><p>In this chapter, we'll explore this. We'll take a guided tour of the vast field that is computer programming, discover some of the common problem domains we program in, see how they differ, and learn the particular problems and challenges of each.</p><p>Some of these arenas overlap. That's natural. Nothing is ever quite as clear-cut as you'd imagine. The following descriptions are necessarily general, since each of these is a big field with lots of variations within. Nonetheless, this should give you a taste of what's going on out there.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="applications_programming"/>Applications Programming</h1></div></div></div><p>This is what most non-techies think of when you mention the word <span class="emphasis"><em>programming</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-23-FN-1" id="CHP-23-FN-1">1</a>]</sup> It's probably the broadest category we'll consider in this chapter.</p><p>It is programming <span class="emphasis"><em>applications</em></span>—self-contained programs—typically for single-user, workstation-like computers. This world focuses on end users and how they use their desktop machines. For commercial reasons, we usually target the mainstream platforms—currently Windows and Mac OS. Although you hear a lot about Linux programming these days, that's still not where the applications work is (at least, at the time of writing). As portable devices become more powerful and their application development environments become richer, mobile applications work has moved from the embedded realm (see "<a class="xref" href="ch23s04.html" title="Embedded Programming">Embedded Programming</a>" on page 447) into this class of more general-purpose applications programming; the specific embedded hurdles have largely been removed.<a class="indexterm" id="IDX-CHP-23-1838"/></p><p>There are many languages and environments for this kind of work; C and C++ are common. We also see common use of Visual Basic and Delphi, Java, and .NET, plus a number of libraries and frameworks like MFC and Qt. This choice is made according to what is convenient for the developers—something that's well-enough known and provides all required features.</p><p>Modern applications programming has advanced rapidly since the dawn of personal computing. We now have rich development environments to work in with helpful framework code that automates a lot of tedious boilerplate stuff. We have threading support, libraries of standard user interface components, and facilities for network transparency. There is a lot of operating system support provided to make applications programming easier, but this also means that there's a lot to learn as you get started. You have to know a lot to <span class="emphasis"><em>really</em></span> understand what's going on around you.</p><p>All this extra support raises the bar to determine what a good application is. What was acceptable application behavior years ago is not today. People expect high-quality, robust programs, with a standard interface and look-and-feel, good responsiveness, user-friendliness (the ability to cope with the most inept user), and a plethora of features (even if the user will only take advantage of a fraction of them). The huge professional applications marketed today are the results of large development teams with departments specifically focusing on usability issues.</p><p>We are seeing a move toward web-based systems, applications that run on browsers, over a network. We'll look at them separately; this also cuts into the enterprise or distributed programming arenas somewhat (see "<a class="xref" href="ch23s05.html" title="Distributed Programming">Distributed Programming</a>" on page 450).</p><p>There are two main markets for applications programming: shrink-wrap software and custom applications.<a class="indexterm" id="IDX-CHP-23-1839"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="shrink-wrap_software"/>Shrink-Wrap Software</h2></div></div></div><p>Shrink-wrap software is developed for the mass market. It's used by a large number of people, or at least that's what the marketing departments are praying for. This is key: The market is speculative, so the software has to appeal to the broadest cross-section of consumers possible in order to make money. Since no customer commissions or pays for the development of shrink-wrap software, you must establish a profitable market before you begin work, or else you're throwing away time and effort. The software needs to differentiate itself from competing products in terms of features, performance, or a unique approach to the problem.</p><p>Shrink-wrap software might be bought over the counter in a box neatly wrapped in cellophane (hence the name), or it could be downloaded from the Internet. It could even be a subscription-based web service. The key point is the way you sell it and how that forces you to develop it.</p><p>Life is hard for shrink-wrap applications programmers. You can't control the environment the code runs in. It must gracefully handle all versions of the operating system, on different machine configurations, with different libraries and other apps installed, and it has to cope reliably with them all. That's a testing nightmare! Web applications programmers win half the battle (as we'll see later)—you have control over the server deployment. But you still have the headache of browser compatibility to contend with: Your web pages must render correctly on a wide range of target platforms.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="custom_applications"/>Custom Applications</h2></div></div></div><p>Custom applications are made-to-order—developed to a specific brief for a specific customer. Therefore, the focus isn't so much on an inviting UI, a never-ending feature list, or even to get it perfect and bug free. There's no commercial imperative to do this. Get it working. Get it shipped. Get the cash. This is a more certain business model.<a class="indexterm" id="IDX-CHP-23-1840"/><a class="indexterm" id="IDX-CHP-23-1841"/><a class="indexterm" id="IDX-CHP-23-1842"/><a class="indexterm" id="IDX-CHP-23-1843"/></p><p>Since a customer commissions this work, it will use this software or use nothing. With no real competition, the software only needs to be good <span class="emphasis"><em>enough</em></span>. Given half a chance, programmers will keep tinkering and improving their code until it reaches some mythical state of perfection. But in this situation, it doesn't make commercial sense to do so. It doesn't really matter if the program works fine, but crashes once a week; it costs less to restart it periodically than to engage in a lengthy bug hunt (assuming that it doesn't trash any data as it goes down).</p><div class="sidebar"><a id="the_rundown"/><p class="title"><b>THE RUNDOWN</b></p><p>Application work is fun. Modern PCs are powerful, so you don't have to worry too much about code size or performance, and you can concentrate on writing neat, elegant code. It's a buzz to know your application is used by tens of thousands of people around the world. —Steve (applications programmer for a major company)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>Typical shrink-wrap products are desktop applications like web browsers, spreadsheets, and so on. Custom software could be anything—a highly tailored inventory management system for a large retailer, for example.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>This tends to be the same kind of machine you are doing the development on (more often than not, an x86 Windows PC).</p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>You'll normally build code on the same workstation you run the program on. Modern <span class="emphasis"><em>integrated development environments</em></span> (<span class="emphasis"><em>IDEs</em></span>) provide comfortable working environments, bringing the editor, compiler, debugger, and help systems together in a single unified point-and-click interface. Many third-party components are available to simplify the development of common tasks. The full gamut of lan-guages is employed here: from low-level C/C++, through BASIC and Java, to scripting languages.</p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>Users expect high-quality programs that conform to standard interface principles. More features than any person could remember are the order of the day; this is a serious commercial requirement, and usually what differentiates one product from the next. New product revisions these days tend to introduce more features (and bugs) than any problems they might solve. This is what the market demands.</p></dd></dl></div></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-1" id="ftn.CHP-23-FN-1">1</a>] </sup>Which, of course, you don't. Admitting your job at a party can be an instant conversation killer. Well, unless it's a party full of nerds, in which case you're probably trying to escape, anyway!<a class="indexterm" id="IDX-CHP-23-1837"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="games_programming"/>Games Programming</h1></div></div></div><p>The exciting and glamorous world of games programming is a specific form of applications work, usually developing shrink-wrap software. A lot of the battle is waged with captivating marketing and a very good initial concept for the game play. This is a fine line that differentiates a great, successful game from the also-rans.<a class="indexterm" id="IDX-CHP-23-1844"/></p><p>These games often involve first-person, massive, immersive, 3D environments. To provide an absorbing experience, the graphics capability of the hardware is fully exploited, and the CPU is maxed out managing maps, enemies, and puzzles, while performing serious modeling of the physics of moving objects. This must all be coordinated in real time and stresses the hardware to its limits. A significant portion of games programming is optimizing the code to the execution platform. As faster hardware is released, the problem doesn't lessen; to stand out from other games, more optimization is required to squeeze a better experience out of the new platforms. This field is very much about staying on the cutting edge and using the latest state-of-the-art technology to do the coolest thing.<a class="indexterm" id="IDX-CHP-23-1845"/><a class="indexterm" id="IDX-CHP-23-1846"/></p><div class="sidebar"><a id="the_rundown-id1"/><p class="title"><b>THE RUNDOWN</b></p><p>Professional games development is about fun, but it's a hugely competitive industry where developers are expected to keep up with the latest technologies, furious deadlines, and nonnegotiable, last-minute change requests. Sweat, blood, and tears are required to write the software, only for it to meet the harsh public glare of a highly critical specialist press. But it can be hugely rewarding—once finished, you've made something that people can see, understand, and enjoy.—Thaddeus (professional games programmer)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>First-person, immersive, 3D games, strategy games, online puzzles.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>Desktop PC, games consoles, mobile devices (PDAs and mobile phones), arcade machines.</p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>Dedicated games platforms (including high-end graphics cards in standard PCs) have tailored development environments to help exploit their power. It still takes very talented developers to fully capitalize on the platform's functionality.</p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>Getting excellent game play; balancing features, user response, aesthetics, atmosphere, and difficulty. A good game unfolds very much like a story, and draws the player in.</p><p>Optimization is required to capitalize on the execution platform.</p></dd></dl></div></div><p>Modern games development teams often have a cast more akin to Hollywood movie production than to standard bean-counting software. We see teams including graphics artists and level designers and the development of storyboards, concept art, and proof-of-concept designs.</p><p>The software might target a (suitably souped-up) PC platform or dedicated games consoles. These machines have specific hardware to accelerate the many graphics operations required per second and special tools to help you harness their power. Console manufacturers provide development kits (special versions of the hardware and tailored software tools) to help you create products, assisting with code loading, testing, and debugging, while helping to avoid security features on production hardware that would impede development.</p><p>Multiplayer games provide richer game play. This brings network collaboration into the mix and requires some skill to get acceptable real-time performance out of slow Internet connections.</p><p>The quality of the ultimate product is determined by the feel of the game play. Everything is tweaked until the game feels right: the level design, the physics models, the graphics, the color of your underwear. Nothing is sacred. You might write the most beautiful code in the world; the program might never crash; it might do everything it was specified to do; it might be highly efficient. But if it lacks that special spark that makes it a compelling, addictive game, it will not be successful. Tricky stuff.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="systems_programming"/>Systems Programming</h1></div></div></div><p>Applications sit atop rich system libraries: layers of code for networking, graphical interfaces, multitasking, file access, multimedia, peripheral control, inter-process communication, and more. If applications programmers receive a lot of support from the underlying system, then someone's got to supply that underlying system. This is systems programming.</p><p>It is generally for workstation machines too, but it's not aimed at the end users. Systems software is aimed at the application developer; the public façade is a set of APIs to be used by software layers higher up the food chain. Systems software is concerned with the low-level logic that interacts with the computer at a very basic level, and also middle-level support frameworks that don't interface directly to hardware but provide important services to the rest of the system.</p><p>Work in this arena typically includes writing device drivers (controlling devices such as printers, storage media, output devices, etc.), writing common shared libraries and utilities for managing scarce resources, implementing the actual operating systems controlling the computer, and providing components such as filing systems and network stacks. Even compilers and installation tool suites can come under this heading, as they are support services for application programmers and are often intimately entwined with the program run-time environment.</p><div class="sidebar"><a id="the_rundown-id2"/><p class="title"><b>THE RUNDOWN</b></p><p>I wrote the USB stack for a proprietary operating system. I had to understand the OS, USB hardware, and the USB protocol, so there was a lot to take in. I had to keep up performance so the system worked well. Acting as the middleman, I was abstracting the hardware interfaces and providing a neat API for applications to use. I had to make this platform agnostic, which added extra complexity.—Dave (systems component writer)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>Operating systems, device drivers, a window manager, or a graphics subsystem.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>Since every execution environment needs some form of run-time support, there is system-level software in almost every electronic device. Systems software is required in the smallest embedded device and the largest mainframe computer.<a class="indexterm" id="IDX-CHP-23-1847"/></p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>Writing device drivers and operating system components tends to screw with the computer and make your system unstable, so it's common to develop on one machine and run the code on a second system. C is by far the most common language in this arena, although some library-level work is done in other languages (C++ is popular, as it aims to be a systems-capable language).</p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>The key here is stability, since these are foundational blocks of the entire computing environment. While an application might crash and have a chance to save work and gracefully recover, a device driver rarely has such a luxury; it is required to work correctly the entire time it runs. This could be an awfully long time, so even small memory leaks can become major problems.</p><p>The code must be efficient (enough), both in terms of space and speed, and will need to be appropriately tailored to the particular operating environment.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="embedded_programming"/>Embedded Programming</h1></div></div></div><p>Computer technology shows up everywhere in our daily lives, whether we're aware of it or not. We're constantly using devices and gizmos, from microwaves to watches, radios to thermostats. These consumer electronics products require software for control and operation. More often than not, this software is invisible to the device's user. It's not just consumer electronics appliances that contain embedded software: Anything with a microcontroller (e.g., laboratory instruments or the machines that issue parking tickets) is software driven. We must write programs that are embedded in the hardware devices: embedded software.<a class="indexterm" id="IDX-CHP-23-1848"/><a class="indexterm" id="IDX-CHP-23-1849"/></p><p>Embedded developers work under tight constraints:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are usually very scarce resources: restricted CPU power and/or strict memory limits. Memory limitations concern both ROM (for the program image) and RAM (space for the code to execute and to store information). On platforms without much capacity, you have to shoehorn a lot of software into the available device space. Sometimes this requires quite creative (and heroic) solutions, like decompressing program code or data on the fly.</p></li><li class="listitem"><p>The opportunities for user interface are quite limited: how do you pack all user interaction into two buttons and an LED? Indeed, there may be no user interface at all; there may be no direct interaction with a user—the software is expected to just work.</p></li></ul></div><p>These constraints have a profound impact on the nature of the code you write. Sadly, in the embedded environment (more than others), we end up sacrificing the purity of our code to get something working. Fast code that fits into the device's ROM and works is more important than theologically correct but large and slow software.</p><p>Embedded systems are designed to do one job and to do it reliably. It should appear as if the software is not there; the embedded device should just work, all the time. Failure is rarely an option; it might physically break the hardware. Contrast this to a desktop computer—it's a general-purpose machine. It has to be able to word process, play movies, browse websites, read email, manage your accounts, and so on. As users, we've been conditioned to accept the odd crash and a bit of instability. We'll sacrifice a little convenience for power and flexibility. Embedded work is a totally different ballpark.</p><p>A good example is the modern car industry. We see vehicles manufactured with many embedded systems, controlling all sorts of things: engine management, ABS brakes, safety features like air bags and seat belt pre-tensioners, climate control, the odometer, and so on. However, the users (in this case the driver and/or passengers) don't have to be at all aware that there are any microprocessors whirring away under the hood. They expect the car to just work. When an engine management system fails, the user becomes acutely aware of the software! Think also about mobile phones. They are obviously computer-driven devices, but few consumers think of them as a computer. We pack a lot of power into these small packages, but there are still strict operational limits that the software must work within.</p><p>An embedded system is typically the combination of a small computer, some dedicated hardware, and either a real-time operating system or a simple controlling program. It will have direct control over the hardware on the device. Embedded systems are usually made-to-order: developed for specific hardware, for a specific purpose. Simple embedded systems have only one piece of software running on them; no highly complex threaded programming environments are used—not even an operating system.</p><p>The code is usually stored in firmware, permanently held in a read-only memory chip. It is seldom updatable, so it has to work correctly the first time. There's no chance to get it wrong and ship a version 1.1. One simple mistake can render your miracle product a failure.<a class="indexterm" id="IDX-CHP-23-1850"/></p><p>Recently, memory and CPU power have become a lot cheaper as more and more mass market devices are created. Embedded environments have become more powerful and the constraints are widening. However, there will always be the need for very small devices with little horsepower that achieve just what they need to. Just.</p><p>You might consider that programming applications for handheld devices like PDAs is embedded-level or applications-level work, depending on where you stand.</p><div class="sidebar"><a id="the_rundown-id3"/><p class="title"><b>THE RUNDOWN</b></p><p>I like working near the metal—it really forces you to think about what's going on. You need tight code and a good understanding of what the hardware's doing. It can be tricky to debug problems, but these challenges are what makes it interesting. —Graham (embedded software developer)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>Control software for washing machines, hi-fis, mobile phones.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>Small, custom-made devices with very limited resources and meager UIs.</p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>Since you work with custom-made devices, the toolchain is also often custom made. Frequently, it's not very advanced at all, compared to the relative luxury of the applications programmer. (As the market broadens, we are seeing improvements here.) The code is developed in a cross-compilation environment, where the target platform is different from host compilation environment. (Clearly you can't compile C on a washing machine . . . yet.)</p><p>We write specialized software for each specific device. Embedded programming almost universally uses C, apart from really low-level work, which resorts to assembly code. C++ is making inroads into this area, and ADA has also been used.</p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>There are all sorts of problems you can encounter, largely depending on whether you are working with a commodity, off-the-shelf embedded platform or building your own. There are issues of real-time programming (for example, timely handling of hardware events and interrupts), direct hardware interfacing, and controlling peripheral connections, plus tedious low-level concerns like byte endianness and physical memory layout.</p><p>To ensure the system is robust, there must be a great emphasis on product testing.<sup>[<a class="footnote" href="#ftn.CHP-23-FN-02" id="CHP-23-FN-02">02</a>]</sup></p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-02" id="ftn.CHP-23-FN-02">02</a>] </sup>Of course any good software development—not just embedded work—needs a great emphasis on testing. In all environments, testing tends to suffer as it is squeezed out by overzealous marketing and management departments who do not really understand the nature of software. However, desktop applications can be more easily updated than the firmware in an embedded device.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="distributed_programming"/>Distributed Programming</h1></div></div></div><p>Distributed systems are comprised of more than one computer. As we'll see later, the World Wide Web is effectively a huge distributed system with information being stored on many computers across many continents and with applications delivered remotely via your web browser. It's not all about web browsers, though. Multimachine architectures are used in many situations. Working with and designing distributed systems ushers in a whole new world of problems.<a class="indexterm" id="IDX-CHP-23-1851"/><a class="indexterm" id="IDX-CHP-23-1852"/><a class="indexterm" id="IDX-CHP-23-1853"/><a class="indexterm" id="IDX-CHP-23-1854"/><a class="indexterm" id="IDX-CHP-23-1855"/><a class="indexterm" id="IDX-CHP-23-1856"/><a class="indexterm" id="IDX-CHP-23-1857"/></p><p>You might need to distribute a software system for a number of reasons. Perhaps some types of computers are more suited to particular tasks than others. Perhaps the system is in high demand, and you can share the workload among many machines on a network to improve performance. Perhaps there are physical location restrictions for certain machines that mandate distributing the system. Perhaps you need to interoperate a new installation with a legacy system or some old hardware.<a class="indexterm" id="IDX-CHP-23-1858"/></p><p>The goal is to design a system that is composed of a number of programs on different machines that all work as a cohesive whole. Tied together by a network connection, they might be physically co-located in a corporate server room or scattered across the globe, communicating over the Internet.</p><p>The disparate parts need to be glued together somehow; each of the programs needs to communicate, and it is desirable to call functions on remote machines as if they were locally linked to the code. This is known as <span class="emphasis"><em>remote procedure call (RPC)</em></span>, and such facilities are provided by a number of available <span class="emphasis"><em>middleware technologies</em></span>. These act as brokers for data transfer between machines; they describe how you discover and talk to services on other machines and how you publish your services for other programs to call. Middleware manages the policies involved with interoperability: there are security issues (Who's allowed to call whom?), network latency issues (What happens if a remote function call takes too long or a computer goes down?), considerations for balancing synchronous remote function calls with asynchronous calls, and more.<a class="indexterm" id="IDX-CHP-23-1859"/><a class="indexterm" id="IDX-CHP-23-1860"/></p><p>Some middleware systems employ object-oriented technologies; some take more of a procedural approach. The middleware is simply connectivity software and allows some degree of platform neutrality. As long as the middleware runs on a given platform, the client code shouldn't care what platform it's calling into—it could even be a ZX spectrum—the function calls all look the same. Of course, in the design of a distributed system, you will select the appropriate hardware for each task. It's doubtful you'll see any ZX spectrums hanging around!</p><p>Commonly used middlewares are CORBA, the Java RMI, Microsoft's DCOM, and .NET remoting. Using these, we split the system between user interface elements, the business logic (real workhorse code), and any storage required (e.g., a database and query engine). The user interface client may be a GUI program or a web-based front end. This is the classic <span class="emphasis"><em>tiered architecture approach</em></span> (described in "<a class="xref" href="ch14s03.html#client_foreword_slash_server_architecture" title="Client/Server Architecture">Client/Server Architecture</a>" on page 271). We also see the emergence of <span class="emphasis"><em>web APIs</em></span>—communications methods for services that use standard web protocols.<a class="indexterm" id="IDX-CHP-23-1861"/><a class="indexterm" id="IDX-CHP-23-1862"/><a class="indexterm" id="IDX-CHP-23-1863"/><a class="indexterm" id="IDX-CHP-23-1864"/></p><p><span class="emphasis"><em>Grid computing</em></span> and <span class="emphasis"><em>clustered systems</em></span> are specific distribution mechanisms that help numerical programming work (more on this later), enabling the creation of high performance, distributed computational algorithms. Clusters are tightly coupled systems; usually all the machines are in the same room, using the same hardware and OSes, linked by a specific cluster middleware. Grids are loosely coupled; they could be geographically scattered and run heterogeneous environments. They communicate via standard web protocols (e.g., HTTP/XML).<a class="indexterm" id="IDX-CHP-23-1865"/></p><div class="sidebar"><a id="the_rundown-id4"/><p class="title"><b>THE RUNDOWN</b></p><p>The Smallpox project, completed in 2003, was a grid computing project to help find a cure for smallpox by screening a huge number of potential drug molecules. It was a collaboration between scientists, universities, and businesses that identified 44 strong candidates for treatment of the disease.<a class="indexterm" id="IDX-CHP-23-1866"/><a class="indexterm" id="IDX-CHP-23-1867"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>An online purchase system, splitting work between front-end applications (web interface, in-shop kiosk, and/or phone ordering system), business logic (manages stock control, implements ordering system and secure billing) and the shared storage.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>Many different computer systems connect via a middleware, almost always sitting on top of standard networking protocols.</p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>Many and varied. This will depend on languages used, the nature of each computer in the system, and the type of middleware employed. Remotely callable interfaces are often defined in some form of interface definition language (IDL) and compiled to an implementation language representation that provides all the calling glue and provides hooks for each function implementation to be slotted in to.<a class="indexterm" id="IDX-CHP-23-1868"/></p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>Designing the correct split of services between computers and streamlining the communications involved. This can severely affect the scalability of a distributed system. What works for a few transactions per day may not work efficiently for 100 transactions per minute. This calls for a real need to design carefully. You also have to deal with computer availability and cope gracefully if one of the computers in the system becomes unavailable.<a class="indexterm" id="IDX-CHP-23-1869"/></p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="web_application_programming"/>Web Application Programming</h1></div></div></div><p>In 1990, Tim Berners-Lee created the first HTML browser and server, and the World Wide Web was born. Today it is a pervasive technology, and servers can not only deliver static pages of information, but they can dynamically create pages based on programs running on the webserver. This is a very specific form of distributed computing, where the user interface is hosted on a remote client: the web browser.<a class="indexterm" id="IDX-CHP-23-1870"/><a class="indexterm" id="IDX-CHP-23-1871"/><a class="indexterm" id="IDX-CHP-23-1872"/><a class="indexterm" id="IDX-CHP-23-1873"/><a class="indexterm" id="IDX-CHP-23-1874"/></p><p>Examples of this kind of application include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Online shopping</p></li><li class="listitem"><p>Bulletin boards, messaging services, and web-based email packages</p></li><li class="listitem"><p>Ticket availability and booking systems</p></li><li class="listitem"><p>Internet search engines</p></li></ul></div><p>Most people now use web applications without thought; it's as natural as a local word processor. These programs clearly have different characteristics from ordinary (so-called <span class="emphasis"><em>rich client</em></span>) desktop applications. There are different things that each can do well. Without heroic JavaScript coding, interaction in a browser-based application UI is a lot more limited.<a class="indexterm" id="IDX-CHP-23-1875"/></p><div class="sidebar"><a id="the_rundown-id5"/><p class="title"><b>THE RUNDOWN</b></p><p>A web app makes you treat the web browser as your OS. All good web developers start by learning client-side browser technologies inside out. Then you learn to write good server-side code (i.e., fast, concurrent, transactional, distributed, and correct). The best thing about the Web is that it is constantly evolving and users' expectations are always rising. The bad thing about the Web is that users' expectations are always rising and your code never stands still. —Alan (web applications programmer)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>Interactive services that require up-to-date infomation and feedback: ticket booking or shopping systems.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>The back end is a webserver (commonly Apache or IIS). This choice is under your control, since you deploy the web app. The clients are web browsers, and there are many variants. Each has its own quirks, and you have no control over what is used. You have to produce web pages that are compatible with most of these.<a class="indexterm" id="IDX-CHP-23-1876"/></p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>The environment consists of the specific webserver and the applications programming language you write the system in, running on that server. Common languages are Perl and PHP.<a class="indexterm" id="IDX-CHP-23-1877"/><a class="indexterm" id="IDX-CHP-23-1878"/></p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>Coping with different browsers; scalability.<a class="indexterm" id="IDX-CHP-23-1879"/></p></dd></dl></div></div><p>The web application operational model is different from vanilla applications programming—session state is held on a remote machine, which must manage numerous simultaneous client connections, storing their state between HTTP interactions and gracefully handling clients that stop connecting. To facilitate this, some information is stored on the server (e.g., the items each customer is ordering are placed in a database) and some on the local client (using web browser <span class="emphasis"><em>cookies</em></span>—nuggets of stored session state—to record the current user/session ID). Frameworks like ASP.NET and Java Servlets exist to speed web application development. Numerous off-the-shelf systems exist, such as content management systems and shopping cart systems.<a class="indexterm" id="IDX-CHP-23-1880"/></p><p>Many open standard protocols and encoding systems are used to represent and transfer information. HTTP is the common data transfer mechanism, and XML is often used to encode data packets (e.g., SOAP is a web-based communication protocol based on an XML schema).<a class="indexterm" id="IDX-CHP-23-1881"/><a class="indexterm" id="IDX-CHP-23-1882"/></p><p>The problems faced by web application programmers mainly revolve around interoperability with the many types of browsers that might be used, handling their HTML peculiarities and their odd JavaScript quirks. It's not unusual to develop tortuous HTML output to cope with all manners of flaws in the popular browsers. Web programmers often have to interface with legacy systems (customer databases, existing order management systems, etc.) to generate their information; this can get quite messy. Scalability is a real concern: A system might work fine when tested by five simultaneous users. But when it goes live, it must withstand 500 users accessing it at the same time. <span class="emphasis"><em>Load testing</em></span> is important here (see "Load testing" on page 139).</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="enterprise_programming"/>Enterprise Programming</h1></div></div></div><p><span class="emphasis"><em>Enterprise</em></span> is one of those tedious buzzwords that floats around, more management-speak than any programmer dialect. An enterprise is literally a business organization. So enterprise programming provides systems for entire companies, gluing all their separate systems together to form a unified, cohesive whole. Enterprise programming almost always means the development of large distributed systems.<a class="indexterm" id="IDX-CHP-23-1883"/><a class="indexterm" id="IDX-CHP-23-1884"/><a class="indexterm" id="IDX-CHP-23-1885"/><a class="indexterm" id="IDX-CHP-23-1886"/><a class="indexterm" id="IDX-CHP-23-1887"/><a class="indexterm" id="IDX-CHP-23-1888"/></p><p>They'll commonly be deployed on a company intranet (internal network) and link the different departments of the business together to improve workflow. The systems may or may not be customer facing. Once the organization is running an integrated computer system, it's generally not too hard to have automated customer interaction—for example, through a web-based shop interface. Perhaps an enterprise system will need to interface to other companies' systems too, to track the delivery status of goods being shipped, for example.<a class="indexterm" id="IDX-CHP-23-1889"/></p><p>Enterprise programming shares a lot of characteristics with made-to-order applications software. The product only really needs to be good <span class="emphasis"><em>enough</em></span>, since it's developed under contract for a specific customer, rather than speculatively for a general-market release. Quality here is not the measure of success (at least as determined by general stability and a larger feature set than any competitor); meeting the customer's objectives is.</p><p>Enterprise systems are written for installation on specific machines in a company's server room or on locked-down desktop machines. You have reasonable control over the execution environment, so you don't need to worry about making the code work on every release of the operating system and under every conceivable hardware configuration. This deftly sidesteps a lot of the headaches that applications programmers suffer.</p><div class="sidebar"><a id="the_rundown-id6"/><p class="title"><b>THE RUNDOWN</b></p><p>I work in the IT department of a large city bank. We write software to solve specific business needs. It's mission critical; what we do makes a real difference to the company's profits, so we have to take it seriously. With many thousands of dollars going through the system every hour, there's no room for error.—Richard (Enterprise programmer)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>Business systems for an entire company, managing its commercial operations.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>A tailored distributed system.</p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>Same as for distributed systems. We'll probably be working with huge data stores, perhaps various database technologies from previous internal systems (legacy systems in manager-speak). XML is all the rage here.</p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>Same as for distributed systems.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="numerical_programming"/>Numerical Programming</h1></div></div></div><p>This kind of work involves scientific, highly technical tasks making heavy use of mathematics. This is a very specialized area that requires writing applications specifically targeted at particular numerical problems. The programs are often aimed at supercomputers, the fastest type of computers, capable of massive number-crunching operations. Although we're living in times when the fastest computer changes from year to year, these are very expensive platforms, employed for specialized applications that require immense mathematical calculations.<a class="indexterm" id="IDX-CHP-23-1890"/><a class="indexterm" id="IDX-CHP-23-1891"/></p><p>Weather forecasting, for example, requires a supercomputer (or perhaps a gift of prophesy!). We also see supercomputers used for animated graphics, fluid dynamic calculations, and other areas that require highly complex mathematical investigation and calculation.<a class="indexterm" id="IDX-CHP-23-1892"/></p><p>A supercomputer is not a mainframe. The latter is a high-performance computer designed to concurrently execute as many programs as possible, often used as a centralized computing resource in a business setting. A supercomputer channels all its power into executing a few programs as fast as possible. There are a number of different supercomputer architectures exploiting different technological advances, each requiring different algorithmic approaches to fully exploit their power. General-purpose machines are now becoming powerful enough for serious numerical work—clustered, they can respectably make a poor man's supercomputer.<a class="indexterm" id="IDX-CHP-23-1893"/></p><p>Numerical work requires high-performance algorithms that execute calculations rapidly, to capitalize on the performance of the computing platform. It is common to make use of carefully designed, heavily optimized numerical libraries and to make explicit use of parallel processing, designing this into the computational algorithms and processes. This will involve both task and data parallelism: either performing many similar tasks on many CPUs at once or pipelining the algorithm, performing different parts of it on different CPUs.</p><p>This branch of programming requires heavy optimization to the characteristics of the target platform to achieve acceptable performance.<a class="indexterm" id="IDX-CHP-23-1894"/></p><div class="sidebar"><a id="the_rundown-id7"/><p class="title"><b>THE RUNDOWN</b></p><p>I work on software systems for an engineering firm. We model large mechanical installations to figure out where physical problems might lie now or in the future. I have to represent the real world in a mathematical way, figuring out how things (should) work. Once I've done this, it's a case of finding the right mathematical constructs to represent the systems in an acceptable, accurate way.—Andy (Numerical programming expert)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Typical products</strong></span></span></dt><dd><p>Fields involving highly complex mathematical investigation like nuclear energy research or petroleum exploration.</p></dd><dt><span class="term"><span class="strong"><strong>Target platform</strong></span></span></dt><dd><p>Supercomputers or grid-based computing clusters.</p></dd><dt><span class="term"><span class="strong"><strong>Development environment</strong></span></span></dt><dd><p>Although there is work on advancing numerical programming support in C++, and some of this work is performed in C, a lot of numerical programming is done in Fortran, which has excellent numeric support (that was what it was designed for: formula translation).<a class="indexterm" id="IDX-CHP-23-1895"/></p></dd><dt><span class="term"><span class="strong"><strong>Common problems and challenges</strong></span></span></dt><dd><p>Crafting efficient algorithms to really exploit the power of the supercomputer.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="so_what_question-id1"/>So What?</h1></div></div></div><div class="epigraph"><p>Freedom from the desire for an answer is essential to the understanding of a problem.</p><div class="attribution"><span>--<span class="attribution">Jiddu Krishnamurti</span></span></div></div><p>How do these programming niches affect us? What do they make us do differently? To be a good programmer, a true craftsman, you must know:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>What your discipline is—the kind of software you're producing.</p></li><li class="listitem"><p>How the discipline affects your architecture. (Is it a tiered enterprise system or tightly woven ball of embedded code? See <a class="xref" href="ch14.html" title="Chapter 14. SOFTWARE ARCHITECTURE">Chapter 14</a>.)</p></li><li class="listitem"><p>What is an appropriate code design in this field and what isn't. (For example, should you sacrifice clarity and elegance for performance, try to squeeze the executable image into the smallest size possible, or perhaps incorporate many hooks for future extensibility?)</p></li><li class="listitem"><p>The tools you use—what's available and what isn't.</p></li><li class="listitem"><p>Which is the most appropriate choice of programming language and which coding idioms you should employ.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Know your discipline. Learn its intricacies. Understand how to write excellent software that appropriately meets its requirements</em></span>.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id22"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Still round the corner there may wait, A new road or a secret gate.<a class="indexterm" id="IDX-CHP-23-1896"/></p><div class="attribution"><span>--<span class="attribution">J.R.R. Tolkien</span></span></div></div><p>We've dipped a toe in the water and sampled the different flavors of programming going on out there. Of course, there are other areas than those we've seen: some well defined, others more ephemeral. For example, <span class="emphasis"><em>safety-critical software</em></span> drives high-reliability systems like medical equipment and aircraft control. Here failure is not an option, and the code must be <span class="emphasis"><em>provably</em></span> correct; this has a profound affect on the way you design and write it.<a class="indexterm" id="IDX-CHP-23-1897"/></p><p>What have we learned? These fields all have one thing in common: their differences. Each requires fundamental design decisions to be made to suit software to them. Application-level code is not generally suited to an embedded environment. A workstation application design may not scale when applied to a distributed system.</p><p>This means that software developers tend to specialize in particular fields and learn to think in particular patterns that suit their worlds. Understanding the very real concerns of each environment will make you a more flexible and mature programmer. Ultimately, you must know your programming church and practice its rites and rituals well.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Understand the nature of the problems they face</p></li><li class="listitem"><p>Tailor their code and designs to the problem domain</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Have a naïvely narrow software worldview; they don't understand the forces that drive other types of software development</p></li><li class="listitem"><p>Write code ill-suited for the problem domain (choosing unsympathetic architectures or inappropriate code idioms)</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id22"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch07.html" title="Chapter 7. THE PROGRAMMER'S TOOLBOX">Chapter 7</a></span></dt><dd><p>Different niches have different qualities and ranges of development tools.</p></dd><dt><span class="term"><a class="xref" href="ch14.html" title="Chapter 14. SOFTWARE ARCHITECTURE">Chapter 14</a></span></dt><dd><p>Different problem domains call for very different software solutions.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e32102"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207588.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id23"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 557.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id22"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Which of the programming niches we've looked at here are particularly similar or share common characteristics? Which are particularly different?</p></li><li class="listitem"><p>Which of these programming disciplines is hardest?</p></li><li class="listitem"><p>Is it important to be an expert in one particular area or to have a good grounding in all of them without a particular specialism?</p></li><li class="listitem"><p>Which programming niche should trainee programmers be introduced to?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id23"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What programming arena are you working in right now? How does it affect the code that you're writing? What specific design and implementation decisions has it led you to make?</p></li><li class="listitem"><p>Do you have experience working in more than one programming discipline? How easy was it for you to switch mindsets and apply appropriate techniques in a different world?</p></li><li class="listitem"><p>Are any of the people you work with unaware of the forces that shape the particular kind of code you write? Do you have embedded software being written by programmers who only understand applications work? What can you do about this?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="where_next_question"/>Chapter 24. WHERE NEXT?</h1></div><div><h3 class="subtitle"><i>All's Well That Ends Well</i></h3></div></div></div><div class="epigraph"><p>What we call the beginning is often the end. And to make an end is to make a beginning. The end is where we start from.</p><div class="attribution"><span>--<span class="attribution">T.S. Eliot</span></span></div></div><p>Congratulations! You've reached the end of this book. Either that, or you're the kind of person who likes to spoil an ending by reading the last page first. (If you are: <span class="emphasis"><em>The butler did it</em></span>.) Presuming that you've read every chapter, by now you should have:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Learned many practical code-writing techniques that have already improved your source code.</p></li><li class="listitem"><p>Gained an understanding of how to write code in the Real World and the tricks that help you to produce useful code in the madness of the software factory.</p></li><li class="listitem"><p>Worked out some personal ways to improve your skill set. (You did attempt the questions, didn't you? If not, try them now.)</p></li><li class="listitem"><p>Discovered how to write effective code as part of a team, establishing practical steps to improve the way your team currently works together.</p></li><li class="listitem"><p>Found out more about cartoon monkeys than you ever really needed to.</p></li></ul></div><p>But more importantly, you should now appreciate that an exceptional programmer is one with the right attitude: one who always seeks to write the best code in any situation, who works well with others, and who can make pragmatic decisions in the heat of the software factory. The craftsman knows how to manage technical debt and seeks to address problems early, before they become software snares.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Becoming a good programmer requires you to adopt effective <span class="emphasis"><em>attitudes</em></span>—the angle of approach you take to software construction</em></span>.</p></dd></dl></div><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="but_what_now_question"/>But What Now?</h1></div></div></div><div class="epigraph"><p>The important thing is not to stop questioning. Curiosity has its own reason for existing. One cannot help but be in awe when he contemplates the mysteries of eternity, of life, of the marvelous structure of reality. It is enough if one tries merely to comprehend a little of this mystery every day. Never lose a holy curiosity.<a class="indexterm" id="IDX-CHP-24-1898"/></p><div class="attribution"><span>--<span class="attribution">Albert Einstein</span></span></div></div><p>As a code craftsman, you'll never reach perfection; the best you can ever achieve is a continual state of improvement. There's always more to learn. So what should you do now? The very fact that you're asking that question is pivotal—one of the most important charateristics of a code craftsman is a desire to improve.</p><p>If I wanted to become a skilled soccer player, I might find some books on soccer, buy a soccer training video, and then sit down with some popcorn and a few beers to learn how to play the game. Great. Ask me how it's going two months later. If I say, "I've read loads about it, and I know all the top moves of the premier players," then you won't be at all impressed: How well can I actually <span class="emphasis"><em>play</em></span>? It is a geniunely good idea to read about the game and to study it, but couch potato soccer skills aren't any real use.</p><p>I can only learn soccer by doing it—by getting dirty, out on a field, playing the game. <span class="emphasis"><em>Practice makes perfect</em></span>. I need to play with people who are skilled and who can train me well. I need to expend energy, feel the burn, and perhaps make a fool of myself in front of others. Slowly, gradually, painfully, I'll get better.</p><p>I hate to break it to you, but that's the only way to get good at code craft too. Just reading this book won't cut it. You have to get out there and <span class="emphasis"><em>do it</em></span>. Properly. So how can we translate this into practice? Here are a few simple ideas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Place this book on your bookshelf. Put what you've learned into practice as best you can right now. You can always refer to a specific chapter when you run into problems later on.</p><p>After a few months of working with this advice, pull out the book once more and give it another read. Pay particular attention to the questions in the "<a class="xref" href="ch23s12.html#getting_personal-id23" title="Getting Personal">Getting Personal</a>" sections—work out what your next steps must be to improve your code. Each time you go through this process, you'll identify new ways to improve your skills.</p></li><li class="listitem"><p>Maneuver your career into the path of great coders, and glean all you can from them. Learn what makes their code good and their attitudes constructive, and how you can apply these characteristics to yourself. Seek their advice, criticism, review, and opinion. Ask them to mentor you. (Bribe them with popcorn and alcohol if you have to!)</p></li><li class="listitem"><p>Keep programming, and expand your horizions. Write more code. Try out new techniques. Tackle new problems, different languages, and unfamiliar technologies.</p></li><li class="listitem"><p>Don't be afraid of making mistakes; you won't become a perfect programmer overnight. As you learn, you will almost certainly make many embarrassing faux pas. Don't let these stunt your growth or define you as a programmer. Unless you try out new techniques, you'll never learn and won't improve. George Bernard Shaw wrote, "A life spent making mistakes is more useful than a life spent doing nothing."</p><p>Receive advice and code review comments with a constructive attitude. Look back at what you've done, and see how it can be improved.</p></li><li class="listitem"><p>Develop outside interests that you can use as a frame of reference for technical knowledge. If all you ever study is programming, then you will become a very two-dimensional person and will not be able to fit code craft into the context of the Real World.</p></li><li class="listitem"><p>Find the classic books in your field. (<span class="emphasis"><em>Code Craft</em></span> is obviously one of them!) Get a copy of each, and digest it well. Every disicpline and every language has its renowned gurus—ensure you know who they are and what they've written.</p><p>Read the classic software tomes, like:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>The Mythical Man-Month</em></span> (Brooks 95)</p></li><li class="listitem"><p><span class="emphasis"><em>The Psychology of Computer Programming</em></span> (Weinberg 71)</p></li><li class="listitem"><p><span class="emphasis"><em>Peopleware: Productive Projects and Teams</em></span> (DeMarco 99)</p></li><li class="listitem"><p><span class="emphasis"><em>The Pragmatic Programmer</em></span> (Hunt Davis 99)</p></li><li class="listitem"><p><span class="emphasis"><em>Code Complete</em></span> (McConnell 04)</p></li><li class="listitem"><p><span class="emphasis"><em>The Practice of Programming</em></span> (Kernighan Pike 99)</p></li><li class="listitem"><p><span class="emphasis"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></span> (Gamma et al. 94)</p></li><li class="listitem"><p><span class="emphasis"><em>Refactoring: Improving the Design of Existing Code</em></span> (Fowler 99)</p></li></ul></div><p>Ask your peers which books they have found valuable. Seek out relevant magazines, websites, and conferences.</p></li><li class="listitem"><p>Teach. Mentor a lesser abled programmer. You'll learn a lot more by passing on your wisdom.</p></li><li class="listitem"><p>Broaden your skills base by joining a professional organization like the British Computer Society (BCS), the Association for Computing Machinery (ACM), or the ACCU (<a class="ulink" href="http://www.accu.org">www.accu.org</a>). Then join in—contribute. The more you participate, the more you'll invest in yourself. The ACCU, for example, is highly contributory. It runs mentored developer projects and encourages members to write for its periodicals. These organizations run programming contests, provide forums for social networking, and often have local chapters where you can meet like-minded people who care about the craft of programming.</p></li><li class="listitem"><p>Have fun! Enjoy cutting code to solve tricky problems. Produce software that makes you proud. Confucius said, "If you enjoy what you do, you'll never work another day in your life."</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Take responsibility for improving your skills. Never lose your passion for programming or your desire to do it with excellence</em></span>.</p></dd></dl></div></div></div>
<div class="appendix" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="answers_and_discussion"/>Appendix A. Answers and Discussion</h1></div></div></div><div class="epigraph"><p>Principles for the Development of a Complete Mind: Study the science of art. Study the art of science. Develop your senses—especially learn how to see. Realize that everything connects to everything else.</p><div class="attribution"><span>--<span class="attribution">Leonardo DaVinci</span></span></div></div><p>This part contains my musings on the questions at the end of each chapter. It's not a straight answer set—few of the questions have a definite <span class="emphasis"><em>yes</em></span> or <span class="emphasis"><em>no</em></span> response. Compare your answers with these.</p><p>The point of these questions is simply to get you thinking, to make you delve deeper into each subject, and to spur you to improve your programming skills.</p><p>If you're thinking of reading this just to get the "answers" without having thought about the questions first, I'd really encourage you not to. Spending even a little time mulling things over and getting personal will really pay off. As Confucius said, "I hear and I forget. I see and I remember. I do and I understand."</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_1_colon_on_the_defensive"/><a class="xref" href="ch01.html" title="Chapter 1. ON THE DEFENSIVE">Chapter 1</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id23"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Can you have</strong></span> <span class="bolditalic">too much</span> <span class="strong"><strong>defensive programming?</strong></span></p></li></ol></div><p>Yes—just as too many comments can degrade code readability, so can many defensive checks, if they are bad. Redundant checks can be avoided with careful coding; for example, by making a good choice of types.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should you add an assertion to your code for every bug you find and fix?</strong></span></p></li></ol></div><p>Fundamentally, it's not a bad practice. But think about where you'd add the assertions. Many, many faults are due to incorrect honoring of API contracts. If you passed garbage into a function, you would want to put some <span class="emphasis"><em>precondition</em></span> checking inside that function, rather than put a test at the call site. If the function returned garbage, you would either fix the function so that it won't again (and prove it's fixed) or write some <span class="emphasis"><em>postconditions</em></span>.<a class="indexterm" id="IDX-APP-1899"/></p><p>It would be more beneficial to add a new unit test for every bug you find and fix.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should assertions conditionally compile away to nothing in production builds? If not, which assertions should remain in release builds?</strong></span></p></li></ol></div><p>People hold passionate beliefs on this subject. The answer isn't black and white; there are powerful arguments for both sides. There are always some very nit-picky assertions that really don't <span class="emphasis"><em>need</em></span> to be left in production builds. But some assertion occurrences may still interest you in the field.</p><p>Now, if you do leave any constraint checks in releases, they <span class="emphasis"><em>must</em></span> change behavior—the program shouldn't abort on failure, just log the problem and move on.</p><p>Remember: Genuine run-time error checks should <span class="emphasis"><em>never</em></span> be removed; they should never be coded in assertions anyway.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are exceptions a better form of defensive barrier than C-style assertions?</strong></span></p></li></ol></div><p>They can be. Exceptions behave differently; while propagating back up the call stack, an exception can be caught and ignored—suppressing its effect. This makes exceptions more flexible tools. You can't ignore an <code class="literal">assert</code> that aborts execution; assertions are lower-level mechanisms.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should the defensive checking of pre- and postconditions be put <span class="bolditalic">inside</span> each function, or around each important function <span class="bolditalic">call</span> ?</strong></span></p></li></ol></div><p>In the function, without a doubt. This way, you only need to write tests once. The only reason you'd want to move them out is to gain flexibility, to choose what happens when a constraint fails. This isn't a compelling gain for such an explosion in complexity and potential for failure.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are constraints a perfect defensive tool? What are their drawbacks?</strong></span></p></li></ol></div><p>No, they are nowhere near perfect. Redundant constraints can be pests at best and hindrances at worst. For example, you could assert that a function parameter <code class="literal">i &gt;= 0</code>. But it's much better to make <code class="literal">i</code> an unsigned type that can't contain invalid values anyway.</p><p>Treat constraints that can be compiled out with a certain degree of suspicion: We must carefully check for any side effects (assertions can have subtle indirect consequences) and for timing issues in the debug build that alters its behavior from a release build. Ensure that assertions are logical constraints and not genuine run-time checks that mustn't be compiled out. It <span class="emphasis"><em>is</em></span> possible to put bugs in the bug-defense code!</p><p>But carefully used, constraints are still far better than dancing barefoot over the hot coals of chance.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Can you <span class="bolditalic">avoid</span> defensive programming?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you designed a <span class="bolditalic">better</span> language, would defensive programming still be necessary? How could you do this?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Does this show that C and C++ are flawed because they have so many areas for problems to manifest?</strong></span></p></li></ol></div></li></ol></div><p>Some language features certainly could be designed to avoid errors. For example, C doesn't check the index of any array lookup you perform. As a result, you can crash the program by accessing an invalid memory address. The Java run time, on the other hand, checks <span class="emphasis"><em>every</em></span> array index before lookup, so such an catastrophe will never arise. (Bad indexes will still cause an error though, just a better defined class of failure.)</p><p>Despite the long list of "improvements" you could make to the liberal C specification (and I urge you to think of as many as you can), you'll never be able to create a language that doesn't need defensive programming. Functions will always need to validate parameters, and classes will always need invariants to check that their data is internally consistent.</p><p>Although C and C++ do provide plenty of opportunity for things to go wrong, they also provide a great deal of power and expression. Whether that makes the languages flawed depends on your viewpoint—this is a topic ripe for holy war.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What sort of code do you not need to worry about writing defensively?</strong></span></p></li></ol></div><p>I've worked with people who refused to put any defensive code into an old program because it was <span class="emphasis"><em>so bad</em></span> that their defenses would make no difference. I managed to resist the urge to whack them with a large mallet.</p><p>You might argue that a small, stand-alone, single-file program or a test harness doesn't need this sort of careful defensive code or any rigorous constraints. But even in these situations, not being careful is just being sloppy. We should aim to be defensive all the time.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id24"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How carefully do you consider each statement that you type? Do you relentlessly check every function return code, even if you're <span class="strong"><strong>sure</strong></span> a function will not return an error?</strong></span><a class="indexterm" id="IDX-APP-1900"/></p></li></ol></div><p>I bet you don't check everything. It's far too easy to overlook certain function return codes, especially since some are deemed more important than others. How many C programmers check the return value of <code class="literal">printf</code>? How many actually <span class="emphasis"><em>know</em></span> that it returns anything?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>When you document a function, do you state the pre- and postconditions?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are they always implicit in the description of what the function does?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>If there are no pre- or postconditions, do you explicitly document this?</strong></span></p></li></ol></div></li></ol></div><p>No matter how obvious you think a contract is (from the function name or its description), explicitly stating the constraints removes any ambiguity—remember, it's always better to remove areas of assumption. Explicitly writing <span class="emphasis"><em>Preconditions: None</em></span> will document a contract explicitly.</p><p>Of course, you don't want every function to explicitly restate a global precondition. It would be laborious and tedious. If an entire API expects that pointer values mustn't be null, it's arguably better to document this once, globally.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Many companies pay lip service to defensive programming. Does your team recommend it? Take a look at the codebase—do they really? How widely are constraints codified in assertions? How thorough is the error checking in each function?</strong></span></p></li></ol></div><p>Very few companies have a culture of excellent code with the right level of defense. Code reviews are a good way to bring a team's code up to a reasonable standard; many eyes see many more potential errors.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are you naturally paranoid enough? Do you look both ways before crossing the road? Do you eat your greens? Do you check for every potential error in your code, no matter how unlikely?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How easy is it to do this thoroughly? Do you forget to think about errors?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Are there any ways to help yourself write more thorough defensive code?</strong></span></p></li></ol></div></li></ol></div><p>No one finds it naturally easy—thinking the worst of your carefully crafted new code is contrary to a programmer's instincts. Instead, expect the worst of any people who will be using your code. They're nowhere near as conscientious a programmer as you are!</p><p>A very helpful technique is to write unit tests for each function or class. Some experts strongly advise doing this <span class="emphasis"><em>before</em></span> writing a function, which makes a lot of sense. It helps you to think about all the error cases, rather than happily trusting that your code will work.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_2_colon_the_best_laid_plans"/><a class="xref" href="ch02.html" title="Chapter 2. THE BEST LAID PLANS">Chapter 2</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id24"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should you alter the layout of legacy code to conform to your latest code style? Is this a valuable use of code reformatting tools?</strong></span><a class="indexterm" id="IDX-APP-1901"/><a class="indexterm" id="IDX-APP-1902"/><a class="indexterm" id="IDX-APP-1903"/><a class="indexterm" id="IDX-APP-1904"/><a class="indexterm" id="IDX-APP-1905"/></p></li></ol></div><p>It's usually safest to leave legacy code however you find it, even if it's ugly and hard to work with. I'd only entertain reformatting if I was absolutely sure that none of the original authors would ever need to return.<a class="indexterm" id="IDX-APP-1906"/></p><p>By reformatting, you lose the ability to easily compare a particular revision of the source with a previous one—you'll be thrown by many, many formatting changes which may hide the one important difference you really need to see. You also risk introducing program errors in the reformatting.</p><p>As far as code reformatting tools go, they're nice curiosities, but I don't advocate the use of them. Some companies insist on running source files through beautifiers before checking any code into their repository. The advantage is that all code is homogenized, pasteurized, and uniformly formatted. The major disadvantage is that no tool is perfect; you'll lose some helpful nuances of the author's layout. Unless all the programmers on your team are gibbons, don't use a reformatting tool.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>A common layout convention is to split source lines at a set number of columns. What are the pros and cons of this? Is it useful?</strong></span></p></li></ol></div><p>As with many presentation concerns, there is no absolute answer; it is a matter of personal taste.</p><p>I like to split my code up so that it fits on an 80-column display. I've always done that, so it's a matter of habit as much as anything else. I don't disagree with people who like long lines, but I find long lines hard to work with. I set my editor up to wrap continuous lines rather than provide a horizontal scrollbar (horizontal scrolling is clumsy). In this environment, long lines tend to ruin the effect of any indentation.</p><p>As I see it, the main advantage of fixed column widths is not printability, as some would claim. It's the ability to have several editor windows open side by side on the same display.</p><p>In practice, C++ produces very long lines. It's more verbose than C; you end up calling member functions on objects referenced by another object through a templated container. . . . There are strategies to manage the many, many, long lines this may lead to. You can store intermediate references in temporary variables, for example.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How detailed should a <span class="bolditalic">reasonable</span> coding standard be?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How serious are deviations from the style? How many limbs should be amputated for not following it?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Can a standard become too detailed and restrictive? What would happen if it did?</strong></span></p></li></ol></div></li></ol></div><p>Six limbs should be amputated for deviations from any coding standard.</p><p>The correct answer really depends on the exhaustiveness of the coding standard and the coding culture you work in. There are usually much bigger software problems to address than a misplaced bracket, but brackets are easier to moan about. I have seen many coding standards that are so prescriptive and paralyzing that the poor programmers have just plain ignored them. To be useful and to be accepted, a coding standard should provide a little room for maneuvering, perhaps with a <span class="emphasis"><em>best practice</em></span> approach given as an example.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>When defining a new presentation style, how many items or cases need layout rules? What other presentation rules must be provided? List them</strong></span>.<a class="indexterm" id="IDX-APP-1907"/></p></li></ol></div><p>If you write out each layout rule individually, there will be an awfully large number of cases to consider. Coding style is a delicate interplay of many forces: indentation, yes, but also internal spacing, naming, positioning of operators, presentation of parentheses, contents of files, use and ordering of header files, and more, and more.<a class="indexterm" id="IDX-APP-1908"/></p><p>The following list of presentation items <span class="emphasis"><em>is</em></span> long, but it's far from complete. It's a good starting point for a style checklist. In practice, some items are more important to standardize than others. As you read this list, make sure that you have considered a personal preference for each item. Also make sure that you know the correct convention for your current software project.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Code margins</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The number of spaces per indent shapes the left edge of the code. It's common to see two- or four-space indents, though some programmers diplomatically choose three spaces. Smaller indents mean that you don't run into the right margin as quickly, but they look cluttered and make it harder to differentiate among levels. Larger indents are more distinct, but you run out of space more quickly.<a class="indexterm" id="IDX-APP-1910"/><a class="indexterm" id="IDX-APP-1909"/></p></li><li class="listitem"><p>Whether to indent with tabs or spaces is a long-running debate that has driven many programmers to therapy. Spaces are more portable; they'll display the same width in any editor. When displaying code using a variable width font,<sup>[<a class="footnote" href="#ftn.APP-FN-1" id="APP-FN-1">1</a>]</sup> tabs can give better alignment.</p></li><li class="listitem"><p>Page width determines how you format the right-hand code edge. You can limit lines to a fixed number of columns or let them grow forever, requiring horizontal window navigation. Fixed pages are often 79 or 80 characters wide. This is historic; 80 characters is a common terminal width, but the last column was not always usable for display.</p></li><li class="listitem"><p>There are choices for aligning certain constructs. At which level do you put <code class="literal">public:</code>, <code class="literal">private:</code>, and <code class="literal">protected:</code> in a class declaration? Where do <code class="literal">case</code> labels go in <code class="literal">switch</code> statements? How do you format labels for the <code class="literal">goto</code> statements you never use?<sup>[<a class="footnote" href="#ftn.APP-FN-2" id="APP-FN-2">2</a>]</sup></p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Spacing and separation</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can line up pieces of code with an internal tabular layout; for example, aligning operators in the same column across subsequent lines. This provides visual emphasis for the function of a block of statements. However, it does require extra typing and maintenance effort, and some programmers don't feel it is justified. A tabular horizontal layout would look something like:</p><a id="I_programlisting_d1e32722"/><pre class="programlisting">
int   cat   = 1;
int   dog   = 2;
char *mouse = "small and furry";
</pre></li><li class="listitem"><p>Whitespace can appear pretty much anywhere, and there are different ways to space out individual code statements. It's a good idea to put spaces around operators, like this: <code class="literal">hamster = "cute"</code>. It's akin to having spaces between words when you write. The alternative, <code class="literal">hamster="ugly"</code>, looks cramped and dense.</p></li><li class="listitem"><p>Similarly, function calls can be spaced in various ways. You might employ one of the following formats:</p><a id="I_programlisting_d1e32736"/><pre class="programlisting">
feedLion(mouse)
feedLion( hamster )
feedLion (motherInLaw)
</pre><p>Many view the latter option as bad—a mathematical equation wouldn't have a space after the function name. (The mother-in-law, however, might be a genuinely edible commodity.)</p><p>Should you follow a similar convention for keywords? How does <code class="literal">while(lionIsAsleep)</code> look? Cramped. Keywords aren't functions; they read more like words, so it's most common to see spaces around them.</p></li><li class="listitem"><p>If code gets too long for a single line, it must be split, but <span class="emphasis"><em>where</em></span> to split is another choice. Naturally, you'd break in the most logical place, but one man's logic is another man's folly. Lines are generally broken around an operator, but whether before or after it—whether the operator appears on the end of the previous or beginning of the next line—is a matter of taste.</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Variables</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A classic C/C++ contention is where to put the asterisk in a pointer declaration (a battle often called Star Wars). You can chose between these three:</p><a id="I_programlisting_d1e32760"/><pre class="programlisting">
int *mole;
int* badger;
int * toad;
</pre><p>The first two associate the "pointeryness" with the variable and with the type, respectively. The problem with associating with type is it doesn't work as expected for statements like this: <code class="literal">int* weasel, ferret;</code>. The third version is a reasonable fence-sitting alternative, but isn't as common.</p></li><li class="listitem"><p>Some C/C++ standards mandate that all constant names should be in uppercase letters to make them clear. Some argue that only preprocessor macro names should be capitalized.<a class="indexterm" id="IDX-APP-1913"/></p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Lines of code</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Exactly <span class="emphasis"><em>what</em></span> goes on each line is a layout concern; it is often mandated that every individual statement goes on its own line, making each one distinct and clear.</p></li><li class="listitem"><p>This leads on to the issue of <span class="emphasis"><em>side effects</em></span> in statements; should you allow code like <code class="literal">index[count++] = 2</code> or permit assignments in <code class="literal">if</code>s?<a class="indexterm" id="IDX-APP-1914"/></p></li><li class="listitem"><p>Some presentation styles will place code on the same line as an opening brace:</p><a id="I_programlisting_d1e32803"/><pre class="programlisting">
for (...) { ostrich++;
            buryHead(ostrich);
           }
</pre></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Constructs</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Should you always include braces, even if there's only one statement within them? You might allow braces to be missed when the code follows on the same line, like this:</p><a id="I_programlisting_d1e32814"/><pre class="programlisting">
if (weAreAllDoomed) startPanicking();
</pre></li><li class="listitem"><p>It's common to see <code class="literal">else</code> clauses aligned in the same column as their respective <code class="literal">if</code>, but you'll sometimes see them placed at a subordinate indent level.</p></li><li class="listitem"><p>How important is it to make <span class="emphasis"><em>special cases</em></span> clear? Some coding standards mandate that fall-throughs between <code class="literal">switch</code> statement <code class="literal">case</code>s should be flagged with comments. Similarly, <span class="emphasis"><em>no-ops</em></span> in loops should be flagged to avoid confusion; otherwise, this little bodiless loop that finds the end of a C string <code class="literal">str</code> may confuse the unwary:<a class="indexterm" id="IDX-APP-1915"/></p><a id="I_programlisting_d1e32848"/><pre class="programlisting">
char *end;
for (end = str; *end; ++end);
</pre></li><li class="listitem"><p>Should C++ inline methods be put inside the class declaration, outside it (directly afterward), or in a separate source file?</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Files</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The most basic decision is how to split a project into files and what information to put into each one. Is there one file per class or per function? Or can you split files into smaller or larger units than this, perhaps per library or section of code? What if there are a lot of very small related classes? Do you really want lots of very small related files?<sup>[<a class="footnote" href="#ftn.APP-FN-3" id="APP-FN-3">3</a>]</sup></p></li><li class="listitem"><p>Conventions for splitting a file into sections differ. Some programmers like to insert a number of blank lines as a separator, some prefer comment blocks, some like reams of ASCII art.</p></li><li class="listitem"><p>In C/C++, the exact order of <code class="literal">#include</code>d files may be fixed by a presentation style. There are different schools of thought here. Some prefer to neatly order system includes first, then project includes, then file-specific includes. Others feel that the exact opposite is safer; it <span class="emphasis"><em>can</em></span> prevent one header file from accidentally relying on headers normally included before itself. Some standards suggest that no <span class="emphasis"><em>header file</em></span> should <span class="emphasis"><em>ever</em></span> <code class="literal">#include</code> another, leaving it to be done long-hand in every implementation file.<a class="indexterm" id="IDX-APP-1916"/><a class="indexterm" id="IDX-APP-1917"/></p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Misc</strong></span></span></dt><dd><p>There will always be plenty of other issues specific to particular coding situations. How do you format embedded SQL commands in code that performs database access? Do you require consistent formatting in a project across different languages?</p></dd></dl></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which is more important—good code <span class="bolditalic">presentation</span> or good code <span class="bolditalic">design</span>? Why?</strong></span></p></li></ol></div><p>This is really a very artificial question. Both are fundamental for good code, and you should never be asked to sacrifice one for the other. If you ever are, beware. However, which one you just chose may say a lot about you as a programmer.</p><p>Bad formatting is certainly easier to fix than bad design, especially if you use clever tools to homogenize your code's formatting.</p><p>There is an interesting connection between presentation and design: Bad presentation often shows that the code was produced by a bad programmer, which probably means that it suffers from bad internal design too. Or it may imply that the code has been maintained by a series of different programmers, with a subsequent loss of the initial code design.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id25"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you write in a consistent style?</strong></span><a class="indexterm" id="IDX-APP-1918"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>When you work with other people's code, which layout style do you adopt—theirs or your own?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>How much of your coding style is dictated by your editor's auto-formatting? Is this an adequate reason for adopting a particular style?</strong></span></p></li></ol></div></li></ol></div><p>If you can't alter the way your editor positions the cursor for you, you shouldn't be using it (either you're too inept, or your editor is).</p><p>If you can't write code in a consistent style, you should have your programmer's license revoked. If you can't follow someone else's presentation style, you should be forced to maintain BASIC for the rest of your career.</p><p>Guard your attitude: The typical programmer cares more about his code, personal practices, and individual layout fetishes than the overall health of the project. Too often, there is an <span class="emphasis"><em>individual versus team</em></span> dilemma. If a programmer rebels against an imposed house style or can't maintain code using its existing presentation style, it is a bad sign. This suggests that the programmer can't see the big picture.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Tabs: Are they a work of the devil, or the best thing since sliced bread? Explain why</strong></span>.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you know if your editor inserts tabs automatically? Do you know what your editor's tab stop is?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Some <span class="bolditalic">hugely</span> popular editors indent with a mixture of tabs and spaces. Does this make the code any less maintainable?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>How many spaces should a tab correspond to?</strong></span></p></li></ol></div></li></ol></div><p>Since this is such a religious issue, I'll just say <span class="emphasis"><em>Tabs suck!</em></span> and back away quickly. Well, actually I'll add that the only thing more evil than indenting with tabs is indenting with tabs <span class="emphasis"><em>and</em></span> spaces—a nightmare!</p><p>If your editor <span class="emphasis"><em>is</em></span> inserting tabs (and probably spaces) without you noticing, try using another editor for a while to appreciate how frustrating it is. Try setting your tab stop to a different value, and see what a mess it makes of the code. <span class="emphasis"><em>Everyone uses the same editor, so it doesn't matter</em></span> is not a professional attitude. Everyone doesn't use the same editor, so it <span class="emphasis"><em>does</em></span> matter.</p><p>You'll hear people recommend their choice of tab-stop length and carefully justify their opinions. That's all very well; in fact a respected study claims that a <span class="emphasis"><em>three-</em></span> or <span class="emphasis"><em>four-</em></span> space tab stop provides optimum readability. (I favor four spaces because I don't like odd numbers!) However, a tab should correspond to <span class="emphasis"><em>no</em></span> fixed number of spaces. A tab is a tab, which is not a space or any multiple thereof. For code laid out using tabs, it shouldn't matter exactly how many spaces the tab is displayed as—the code should read well, regardless. Unfortunately, I have rarely seen tab-indented code that works this way. All too often, tabs and spaces are mixed together to make code line up neatly. This works fine with a tab stop set as the author intended. But it makes an unholy mess with any other setting.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you have a preferred layout style?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Describe it in a series of simple statements. Be complete. Include, for example, how you format</strong></span> <code class="literal">switch</code> <span class="strong"><strong>statements and split up long lines</strong></span>.</p></li><li class="listitem"><p><span class="strong"><strong>How many statements did it take? Is that what you expected?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Does your company have a coding standard?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Do you know where it is? Is it advertised? Have you read it?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If yes: Is it any good? Perform an honest critique, and feed your comments back to the document owners</strong></span>.</p></li><li class="listitem"><p><span class="strong"><strong>If no: Should it? ( Justify your answer.) Is there a common unwritten code style that everyone adopts? Can you drive the adoption of a standard?</strong></span></p></li></ol></div></li><li class="listitem"><p><span class="strong"><strong>Is there <span class="bolditalic">more</span> than one standard used, perhaps one per project? If so, how is code shared among projects?</strong></span></p></li></ol></div></li></ol></div><p>Make sure you are aware of any style guides (or undocumented conventions) that you should work to.</p><p>This question was partly motivated by personal experience: I was working in a large organization with several isolated departments, each following its own set of guidelines. As the separate products slowly converged, it made technological (and sound financial) sense to combine some parts of the codebases. The result was a mess of code with different styles of interface, different presentation, even different language use. It looked unorganized and unprofessional and was very hard to work with. It was painful.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How many different layout styles have you followed?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which did you feel most comfortable with?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Which was the most rigorously defined?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Is there a link?</strong></span></p></li></ol></div></li></ol></div><p>After a few years of programming, it's easy to settle into your own peculiar layout style without really thinking about how or why you arrived at it. Undoubtedly, it was a result of other code you've read and worked with, mixed with your own personal tastes. Take some time to consider this, and ensure that your coding style is sound. Perhaps now is the time to modify and improve it.</p><p>Changing your style isn't straightforward. There will still be your old legacy code to deal with—should you convert it to the new style, or leave it in the previous state?</p><p>Grab a text editor and type in this bit of code; it calculates the <span class="emphasis"><em>n</em></span> th prime number. It's written in one particular coding style. Present it as <span class="emphasis"><em>you'd</em></span> like to see it. Don't try to change the implementation at all.</p><a id="I_programlisting_d1e33081"/><pre class="programlisting">
<strong class="userinput"><code>/* Returns whether num is prime.*/</code></strong>
bool
isPrime( int num ) {
    for ( int x = 2; x &lt; num; ++x ) {
        if ( !( num % x ) ) return false;
    }
    return true;
}

<strong class="userinput"><code>/* This function calculates the 'n'th prime number.*/</code></strong>
int
prime( int pos ) {
    if ( pos ) {
        int x = prime( pos-1 ) + 1;
        while ( !isPrime( x ) ) {
            ++x;
        }
        return x;
    } else {
        return 1;
    }
}
</pre><p>That is a representative bit of Real World code, so don't dismiss this as a stupid and tedious exercise.</p><p>Note that I haven't given any suggested answer here. My reformatting is just as valid as yours, and indeed as valid as the original format. That's why this is a <span class="emphasis"><em>Getting Personal</em></span> question.</p><p>If you're reading these answers without chewing over the questions at all, go on—give this one a try. The book can wait while you type in a few lines. . . .</p><p>Now, take a look at what you've written.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>How different is your version? How many specific changes did you make?</p></li><li class="listitem"><p>For each change, ask yourself: Is it a personal aesthetic preference, or can you justify the change with some rationale? Question this rationale—is it truly valid? How strongly would you be prepared to defend it?</p></li><li class="listitem"><p>How comfortable were you with the original format? Did it bother you to read? Could you work in that coding style if you encountered code like it? <span class="emphasis"><em>Should</em></span> you be able to become comfortable with it?</p></li></ul></div><p>Give yourself bonus points if you wanted to reimplement the code to be more efficient, and extra bonus points if you resisted the temptation. (Premature optimization is a Bad Thing—see "<a class="xref" href="ch11s05.html" title="The Nuts and Bolts">The Nuts and Bolts</a>" on page 206.)</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-1" id="ftn.APP-FN-1">1</a>] </sup>More common in published code than in a source code editor.<a class="indexterm" id="IDX-APP-1911"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-2" id="ftn.APP-FN-2">2</a>] </sup>Because, of course, no high-quality programmer will use <code class="literal">goto</code>s in these enlightened times—see "<a class="xref" href="ch22.html#structured_programming" title="Structured Programming">Structured Programming</a>" on page 421.<a class="indexterm" id="IDX-APP-1912"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-3" id="ftn.APP-FN-3">3</a>] </sup>Java answers this by mandating the physical mapping of classname to filename.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_3_colon_whats_in_a_name_question"/><a class="xref" href="ch03.html" title="Chapter 3. WHAT'S IN A NAME?">Chapter 3</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id25"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are these good variable names? Answer with either</strong></span> <span class="bolditalic">yes</span> (explain why, and in what context), <span class="bolditalic">no</span> (explain why), or <span class="bolditalic">can't tell</span> (explain why).<a class="indexterm" id="IDX-APP-1919"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><strong class="userinput"><code>int apple_count</code></strong></p></li><li class="listitem"><p><strong class="userinput"><code>char foo</code></strong></p></li><li class="listitem"><p><strong class="userinput"><code>bool apple_count</code></strong></p></li><li class="listitem"><p><strong class="userinput"><code>char *string</code></strong></p></li><li class="listitem"><p><strong class="userinput"><code>int loop_counter</code></strong></p></li></ol></div></li></ol></div><p>The quality of a name depends on its context, and we can't honestly tell whether any of these are good or bad names. That's why the question asks for example contexts. There are some obvious contexts where the names might be bad: <code class="literal">apple_count</code> wouldn't be a particularly good name for a grapefruit counter.</p><p><code class="literal">foo</code> is <span class="emphasis"><em>never</em></span> a good name. I've yet to see anyone counting <span class="emphasis"><em>foo</em></span>s. <code class="literal">loop_counter</code> is also bad; even if a loop gets too big for a short counter name, you can still pick a more descriptive name, one that reflects the actual <span class="emphasis"><em>use</em></span> of the variable rather than its role as a loop counter.</p><p>We can't really tell whether <code class="literal">bool apple_count</code> is a good name, but it looks like it isn't—a boolean cannot hold a number. Perhaps it's recording whether a separate count of apples is valid, but if this was the case, it ought to be called something like <code class="literal">is_apple_count_valid</code>.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>When would these be appropriate function names? Which return types or parameters might you expect? Which return types would make them nonsensical?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><strong class="userinput"><code>doIt(...)</code></strong></p></li><li class="listitem"><p><strong class="userinput"><code>value(...)</code></strong></p></li><li class="listitem"><p><strong class="userinput"><code>sponge(...)</code></strong></p></li><li class="listitem"><p><strong class="userinput"><code>isApple(...)</code></strong></p></li></ol></div></li></ol></div><p>What each of these might mean depends on where you find them. A name depends on its context for meaning; that context is provided by the enclosing scope of the function. Context information can also be given by function parameters or return variables.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should a naming scheme favor the easy reading or easy writing of code? How would you make either easy?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How many times do you write a single piece of code? (Think about it.) How many times do you read it? Your answers should give some indication as to the relative importances</strong></span>.</p></li><li class="listitem"><p><span class="strong"><strong>What do you do when naming conventions collide? Say you're working on camelCase C++ code and need to do STL (using_underscore) library work. What's the best way to handle this situation?</strong></span></p></li></ol></div></li></ol></div><p>I've worked on C++ codebases that used such a collision of naming conventions to their advantage. The internal logic used camelCase, whereas libraries and components that extended the standard library followed STL naming_conventions. It actually worked quite well, neatly marking separate parts of the project.</p><p>Unfortunately, it doesn't always work that nicely. I've seen plenty of inconsistent code where there was no rhyme or reason behind the changing styles.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How long should a loop be before you need to give a meaningful loop counter name?</strong></span></p></li></ol></div><p>This depends on how long your piece of string is. It's clear, though, that a 100-line loop with a counter called <code class="literal">i</code> is not best practice.<sup>[<a class="footnote" href="#ftn.APP-FN-4" id="APP-FN-4">4</a>]</sup> Whenever you insert new code into a loop, check the counter name to see if it now needs adjustment.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>In C, if</strong></span> <code class="literal">assert</code> <span class="strong"><strong>is a macro, why is its name lowercase? Why should we name macros so they stand out?</strong></span><a class="indexterm" id="IDX-APP-1920"/></p></li></ol></div><p><code class="literal">assert</code> isn't capitalized because <code class="literal">assert</code> isn't capitalized. In an ideal world it would be, but standards being what they are, we have to live with this second-rate macro name. Sigh.</p><p>Fire is useful, but it can also be very dangerous. Macros are the same. Macros and <code class="literal">#define</code>d constant definitions <span class="emphasis"><em>are</em></span> dangerous—adopting the UPPERCASE name convention will prevent nasty collisions with ordinary names. It's as sensible as wearing safety goggles when a lunatic is walking around with a big pointy stick.</p><p>Because macros can be so painful, you should choose names that are very unlikely to cause headaches. More importantly, avoid using the preprocessor as much as humanly possible.</p><p>Long calculations can be made more readable by putting intermediate results in temporary variables. Suggest good naming heuristics for these types of variables.</p><p>Bad temporary names are <code class="literal">tmp</code>, <code class="literal">tmp1</code>, <code class="literal">tmp2</code>, and so on, or <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, and so on. These, unfortunately, are all common intermediate names.</p><p>Like any other item, temporary names should be meaningful (like <code class="literal">circle_radius</code> in a trigonometric calculation or <code class="literal">apple_count</code> in an arboreal analysis routine). In fact, in a complex calculation, good names can really serve to document the internal logic and show what's going on.</p><p>If you find a value that really has no nameable purpose, if it truly is an arbitrary intermediate value that's hard to name, then you'll begin to understand why <code class="literal">tmp</code> is so popular. Avoid calling anything <code class="literal">tmp</code> if possible—try to break the calculation in some other way that makes more sense.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What are the pros and cons of following your language's standard library naming conventions?</strong></span></p></li></ol></div><p>Standard libraries are often a source of language best practice, so it can be valuable to follow their conventions. Other programmers are used to the naming style, so they will have fewer nasty reading surprises and will feel at home with your code.</p><p>On the other hand, the library might not always present best practices, so think first! C's horribly named <code class="literal">assert</code> macro is a good example of this.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Can you wear out a name? Is it okay to repeat a local variable name in many different functions? Is it okay to use local names that override (and hide) global names? Why?</strong></span></p></li></ol></div><p>It is perfectly acceptable to repeat a local variable name in many different contexts. Sometimes it's good practice to: Why use a different loop index counter name all the time? It would only serve to make your code harder to read.</p><p><span class="emphasis"><em>Don't</em></span> hide global names with local variable names; it's really confusing. This is an indicator of brittle code.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Describe the mechanics of Hungarian Notation. What are the pros and cons of this naming convention? Does it have a place in modern code design?</strong></span><a class="indexterm" id="IDX-APP-1921"/><a class="indexterm" id="IDX-APP-1922"/></p></li></ol></div><p>Hungarian Notation is a naming convention that adorns variable and function names with cryptic prefixes to denote type. It's seen predominantly in C code. There are several subtly different dialects, but the most common Hungarian prefixes are shown in <a class="xref" href="apas03.html#common_hungarian_notation_prefixes" title="Table A-1. Common Hungarian Notation Prefixes">Table A-1</a>.</p><div class="table"><a id="common_hungarian_notation_prefixes"/><p class="title"><b>Table A-1. Common Hungarian Notation Prefixes</b></p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common Hungarian Notation Prefixes"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Prefix</p></th><th style="text-align: left" valign="bottom"><p>Which means . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">p</code></p></td><td style="text-align: left" valign="top"><p>pointer to . . . (<code class="literal">lp</code> means <span class="emphasis"><em>long pointer</em></span>, an old architectural issue—if you don't know, don't ask)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">r</code></p></td><td style="text-align: left" valign="top"><p>reference of . . .</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">k</code></p></td><td style="text-align: left" valign="top"><p>constant . . .</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">rg</code></p></td><td style="text-align: left" valign="top"><p>array of . . .</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">b</code></p></td><td style="text-align: left" valign="top"><p>boolean (<code class="literal">bool</code> or some C <code class="literal">typedef</code>)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">c</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">char</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">si</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">short int</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">i</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">int</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">li</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">long int</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">d</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">double</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ld</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">long double</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sz</code></p></td><td style="text-align: left" valign="top"><p>zero-terminated <code class="literal">char</code> string (Note: <span class="emphasis"><em>not</em></span> <code class="literal">p</code>)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">S</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">struct</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">C</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">class</code> (You can define your own class abbreviations, too.)</p></td></tr></tbody></table></div></div><br class="table-break"/><p>Hungarian Notation was relatively unbearable in C (not to mention unnecessary once the language became more strongly typed), and is rapidly nauseating in C++, since it doesn't really scale up to the many new type definitions you can introduce.</p><p>If you really want to confuse a maintenance programmer, use Hungarian Notation and then, a few months later, change the types of all the variables without correcting every single variable name (since it would take far too long to do <span class="emphasis"><em>that</em></span>). This is a real weakness with the naming scheme.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Avoid Hungarian Notation like the plague</em></span>.</p></dd></dl></div><p>Some naming conventions have diluted Hungarian leanings. Witness the <code class="literal">foo_ptr</code> and <code class="literal">m_foo</code> ideas mentioned earlier in the chapter. There are other cute conventions with similar intent: Some programmers call their global variables <code class="literal">theFoo</code> and their member variables <code class="literal">myFoo</code>. Perhaps this shows that <span class="emphasis"><em>some</em></span> Hungarian Notation is a good idea in principle; but taken to its logical extreme, it's a dictatorial tyrant of a convention. Be on your guard.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>We see many classes containing member functions acting as <span class="bolditalic">getters</span> and <span class="bolditalic">setters</span>; reading and writing the value of certain properties. What are the common naming conventions for these functions, and which is the best?</strong></span></p></li></ol></div><p>While some argue that the existence of get and set methods shows a weak design, we nonetheless see a lot of classes written like this. Some languages actually have built-in support for these operations.</p><p>There are several naming conventions to choose from. If you're writing in C++, using camelCase, and have some property called <span class="emphasis"><em>foo</em></span> of type <span class="emphasis"><em>Foo</em></span>, you might pick:</p><a id="I_programlisting_d1e33577"/><pre class="programlisting">
Foo &amp;getFoo();
void setFoo(const Foo &amp;) const;
</pre><p>or</p><a id="I_programlisting_d1e33581"/><pre class="programlisting">
Foo &amp;foo();
void setFoo(const Foo &amp;) const;
</pre><p>or perhaps</p><a id="I_programlisting_d1e33585"/><pre class="programlisting">
Foo &amp;foo();
void foo(const Foo &amp;) const;
</pre><p>Your choice may be dictated by a coding standard; otherwise, it's down to your sense of aesthetics. This is a case where I'd violate the <span class="emphasis"><em>Function name should always contain a verb</em></span> rule and go for the second option, since it reads the most naturally in code. Try it and see.</p><p>If a "getter" method has to perform a long calculation the first time it's run (even if it can cache the answer for future invocations), then I'd be wary. It's no longer a simple retrieval function, and these naming schemes don't imply this. <code class="literal">Tree::numApples</code> is a good getter name, unless the operation could block for a minute while an image recognition system detects all the apples. In that case, I'd like to see the behavior implied by name. <code class="literal">Tree::countApples()</code> hints at some greater activity—it's the verb in the name.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id26"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How good are you at naming? How many of these heuristics do you follow already? Do you consciously think about your naming and these sorts of rules, or do you just</strong></span> <span class="bolditalic">do it</span> <span class="strong"><strong>all naturally? In which areas can you improve?</strong></span><a class="indexterm" id="IDX-APP-1923"/><a class="indexterm" id="IDX-APP-1924"/><a class="indexterm" id="IDX-APP-1925"/></p></li></ol></div><p>Go back over the section "<a class="xref" href="ch11s05.html" title="The Nuts and Bolts">The Nuts and Bolts</a>" on page 44. Compare those guidelines with the last piece of code you wrote. How does it match up? How much of your naming necessarily follows existing coding conventions (as you're exhorted to do on page 50), and how much have you established from scratch?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does your coding standard mention naming at all?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does it cover all the cases we've looked at here? Is it <span class="bolditalic">sufficient</span>? Is it useful, or just superficial?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>How much naming detail <span class="bolditalic">is</span> appropriate in a coding standard?</strong></span></p></li></ol></div></li></ol></div><p>Sometimes a coding standard with comprehensive naming mandates can make it <span class="emphasis"><em>harder</em></span> to invent names—you have so many rules to try to satisfy that it's hard to remember and reconcile them all. Look with caution at anything more prescriptive than the guidelines laid out in <a class="xref" href="ch03.html" title="Chapter 3. WHAT'S IN A NAME?">Chapter 3</a>.</p><p>Good code craftsmen habitually name well, and don't need coding standards to "help" them. The standards-setters often claim that their standards will help less-experienced programmers to name well. But more often than not, these standards are not that helpful—inexperienced programmers commit more programming sins than just bad naming. Code reviews are required to ensure that their work is appropriate.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What's the worst name you've come across recently? How have names ever misled you? How would you have changed them to avoid future confusion?</strong></span></p></li></ol></div><p>Did you spot this in a formal review of someone else's work, or while trying to maintain some old, long-forgotten code?<sup>[<a class="footnote" href="#ftn.APP-FN-5" id="APP-FN-5">5</a>]</sup> Finding and correcting bad names just after they've been written (when you still know what the thing should really be called) is best. And it takes the least effort. Working it out months later can sometimes be quite painful.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you have to port code between platforms? How has this affected filenames, other names, and the overall code structure?</strong></span></p></li></ol></div><p>Older filesystems limited the number of characters you could use in a filename. This made file naming much messier (and more cryptic). Unless you have to port code to such an archaic system, this kind of limitation can be safely ignored.</p><p><span class="emphasis"><em>File-based polymorphism</em></span> is a cunning way to exploit filenames to achieve code substitutability at build time. It's often used to select platform-specific implementations in portable code. You can set up header file search paths, allowing one <code class="literal">#include</code> to pull in a different file depending on the current build platform.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-4" id="ftn.APP-FN-4">4</a>] </sup>But generally a 100-line loop itself is not best practice.</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-5" id="ftn.APP-FN-5">5</a>] </sup>Obviously, it would never be a problem you found in your <span class="emphasis"><em>own</em></span> code!</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_4_colon_the_write_stuff"/><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id26"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Grouping related code will make its relationships clear. How can we perform this grouping? Which methods document the relationships most strongly?</strong></span><a class="indexterm" id="IDX-APP-1926"/><a class="indexterm" id="IDX-APP-1927"/></p></li></ol></div><p>Obvious grouping devices are common name prefixes and suffixes; filesystem location; and putting items in the same class or structure, C++/C# namespace, Java package, source file, or code library. Can you think of more?</p><p>Relationships enforced by the language are the strongest—both obvious to read and also automatically checked for you. However, proximity of code layout is a more potent association than you'd think. Ordering also implies a lot—you'll think that the first item is more important than subsequent items. Exploit these facts to document your code.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>We should avoid using <span class="bolditalic">magic numbers</span> in our code. Is zero a magic number? What should you call a constant value representing zero?</strong></span><a class="indexterm" id="IDX-APP-1928"/></p></li></ol></div><p>The number zero has magic properties in many different contexts; in C code it is used as a <span class="emphasis"><em>null</em></span> pointer value, and the initial value for most loops. What <span class="emphasis"><em>could</em></span> you replace 0 with?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A single shared constant called <code class="literal">ZERO</code> is no better than writing <code class="literal">0</code>; it's <span class="emphasis"><em>just as</em></span> magic. The name doesn't imply what any zero actually means—is it a null pointer value, or a loop initialization value? This approach would defeat the purpose.</p></li><li class="listitem"><p>A different name for each zero constant would get very tedious because you'd have to create many similar variations on the theme of <code class="literal">for (int i = SOME_ZERO_START_VALUE; i &lt; SOME_END_VALUE; ++i)</code>. None of these zero constant names gives any new meaningful information, anyway.</p></li></ul></div><p>You'd have to think carefully about names for zero constants. The obvious choice would be something like <code class="literal">NO_BANANAS</code>, meaning <span class="emphasis"><em>no bananas counted</em></span>. But this <code class="literal">NO_</code> prefix could be confused as an abbreviation for number (like <code class="literal">NUM_</code>).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Self-documenting code makes good use of context to convey information. Show how you do this, and give an example of how a particular name would lead to a different interpretation in different functions?</strong></span></p></li></ol></div><p>There are many ways to exploit context to your documentation's advantage. Consider a <code class="literal">Cat</code> class. Inside it, member functions don't need to be called <code class="literal">setCatName</code>, <code class="literal">setCatColor</code>, and so on; the <span class="emphasis"><em>cat</em></span> part is implicit from the class context.</p><p>Many English words have a dual meaning. You'd expect the <code class="literal">count</code> variable in a search function to hold different information than one in a vampire database schema. More practically, a <code class="literal">name</code> variable in our <code class="literal">Cat</code> class clearly holds the cat's name, whereas one in an <code class="literal">Employee</code> class is more likely to hold a human's—with first name, last name, and title information. Same variable name, different contents. Exploit context information as much as possible, but ensure that the context in which you write is truly obvious.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it realistic to expect a newcomer to pick up some self-documenting code and understand it totally?</strong></span></p></li></ol></div><p>Yes, that's our aim—it <span class="emphasis"><em>is</em></span> realistic. However, the reader will still need overview and design documents describing the entire system, what it does, and how it's structured. If the code comments try to explain this, then they're in the wrong place (or it's a very small system).</p><p>With good code documentation, a newcomer should find it perfectly clear what a particular <span class="emphasis"><em>section of code</em></span> is doing. Comprehensive API docs show the meaning of any function call the newcomer may come across.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If code is truly self-documenting, how much other documentation is required?</strong></span></p></li></ol></div><p>It depends on the size and scope of the project. You'll require functional specifications and design documents. You may still need an implementation overview, and will definitely require thorough test specifications.</p><p>To document the design of a single piece of code, good literate comments mean that you shouldn't need any other documentation.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Why must more people than the original author understand any piece of code?</strong></span></p></li></ol></div><p>It's a reality of the software factory. Being the only person who understands some code is good job security for the unscrupulous programmer. Writing code that's worse than a cryptic crossword puzzle will guarantee you a job for life (or until the company folds, whichever happens first). The downside is that you'll spend your days immersed in your own foul concoctions.</p><p>In reality, code is dangerous if it can't be understood by anyone else. If you leave the company, move to another department, get promoted, or no longer have time to perform maintenance, then someone else must be able to take over. And if it doesn't come down to that, sometime down the road, when you've forgotten how your code works, a fatal fault will turn up that must be fixed by last Tuesday.</p><p>Code reviews can help to ensure that code is well understood and adequately documented.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>This simple C <span class="bolditalic">bubblesort</span> function could use some improvement. What specific things are wrong with it? Write an improved, self-documenting version</strong></span>.<a class="indexterm" id="IDX-APP-1929"/><a class="indexterm" id="IDX-APP-1930"/></p></li></ol></div><a id="I_programlisting_d1e33846"/><pre class="programlisting">
<strong class="userinput"><code>void bsrt(int a[], int n)
{
    for (int i = 0; i &lt; n-1; i++)
        for (int j = n-1; j &gt; i; j--)
            if (a[j-1] &gt; a[j])
            {
                int tmp = a[j-1];
                a[j-1]  = a[j];
                a[j]    = tmp;
            }
}</code></strong>
</pre><p>The first problem is that a bubblesort algorithm should never be used. There are plenty of better sorts. There's also probably a much better, generic language library function available; in C you can call <code class="literal">qsort</code>, for example. I've used bubblesort here as a simple code example.</p><p>The function's interface isn't clear <span class="emphasis"><em>at all</em></span>. The function name is too cryptic, and the parameter names mean nothing. I'd like to see an API documentation comment provided too, but I'll leave that out in the rewrite below.</p><p>Internally, the code is a mess. Its intent would be much clearer if the code that transposes array values is split out as a <code class="literal">swap</code> function. Then the reader can see what's going on. A little more massaging leads to this:</p><a id="I_programlisting_d1e33866"/><pre class="programlisting">
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

void bubblesort(int items[], int size)
{
    for (int pos1 = 0; pos1 &lt; size-1; pos1++)
        for (int pos2 = size-1; pos2 &gt; pos1; pos2—)
            if (items[pos2-1] &gt; items[pos2])
                swap(&amp;items[pos2-1], &amp;items[pos2]);
}
</pre><p>This is adequate C, although there are some more changes you might prefer. Depending on your religion, you might want braces around the loops. <code class="literal">swap</code> could be made into a macro for efficiency. This isn't a clever optimization though; you should really choose a more efficient sort algorithm.</p><p>In C++, I'd consider making <code class="literal">swap</code> inline, and take its parameters by reference (documenting the fact that they will be changed). The best choice would be to use the <code class="literal">std::swap</code> facility available in the language libraries.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Working with code documentation tools brings up some interesting issues. What's your opinion on these?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>When you review the documentation, should you perform a <span class="bolditalic">code review</span>, looking at the comments in the source files, or a <span class="bolditalic">specification review</span>, looking at the generated documents?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Where do you put documentation of protocols and other non-API issues?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Do you document private/internal functions? In C/C++, where do you place this documentation—in the header file or implementation file?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>In a large system, should you create a single, large API document or several smaller documents, one per area? What are the advantages of each approach?</strong></span></p></li></ol></div></li></ol></div><p>My thoughts on these questions are:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Review the generated spec; don't get too hung up about the layout of the comments in the source file. You're reviewing the content, not the code.</p></li><li class="listitem"><p>Don't be fooled into thinking documentation must be put in a <span class="emphasis"><em>header file</em></span> or in an <span class="emphasis"><em>implementation file</em></span>. Even if documentation tools are a Good Thing, it's not evil to have some separate "traditional" documents as well. Write about your protocol there.</p></li><li class="listitem"><p>Document any internal functions that <span class="emphasis"><em>need</em></span> documentation. You don't necessarily have to write exhaustive docs on all private parts. These docs should be hived off into the implementation file if they're reasonably large, to keep the public interface neat and simple.</p></li><li class="listitem"><p>Both! Use different invocations of the tool to generate a single, large document and documents for each subsystem.</p></li></ol></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you're working on a codebase that isn't literately documented, and you need to alter or add new methods or functions, is it a good idea to give them literate documentation comments, or should you leave them undocumented?</strong></span></p></li></ol></div><p>The craftsman <span class="emphasis"><em>wants to</em></span> document and automatically feels the need to write comment blocks. Now, if the code has a separate specification document, then your documentation should go in there alongside everything else. Otherwise, it's not too bad to start adding literate comments. Make sure that the original programmer isn't going to take offense, though!</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it possible to write self-documenting assembly code?</strong></span></p></li></ol></div><p>You can give it your best shot, but it's not going to be easy. Assembly code isn't particularly expressive; you're not programming at the level of intent, more at the level of <span class="emphasis"><em>do this, you dumb microprocessor</em></span>. Your code will be mostly comment blocks (probably good practice for assembly, anyway). Except for subroutine labels, there's not much else to self-document with.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id27"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What do you consider to be the best documented code you've come across? What made it so?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Did this code have a large number of external specifications? How many of them did you read? How can you be sure you knew enough about the code without reading them all?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>How much of this do you think was due to the author's programming style, and how much was because of any house style or guidelines he or she worked to?</strong></span></p></li></ol></div></li></ol></div><p>Well-documented code does not necessarily have any separate description documents. Internally, it employs good naming, logical modularization, simple techniques, clear layout, documented assumptions, and good commenting. House styles help, but they are no substitute for astute, sensitive programming. An idiot can follow the most stringent guidelines and still produce shabby shreds of code.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you write in more than one language, how does your documentation strategy differ in each?</strong></span></p></li></ol></div><p>Different languages are more or less expressive, and so what can and can't be documented within the language syntax varies. As much as anything else, this will affect how many comments you'd write.</p><p>You're probably better at writing self-documenting code in your most familiar programming language.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>In the last code you wrote, how did you make the important stuff stand out? Did you hide private information away appropriately?</strong></span></p></li></ol></div><p>Think carefully about this—the natural tendency is to dismissively say, <span class="emphasis"><em>Yeah, I wrote it okay</em></span>. Look at your code as if it had been written by some other muppet. Criticize it.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you're working on a team, how often do others come to you to ask you how something works? Could you avoid this with better-documented code?</strong></span></p></li></ol></div><p>A good two-pronged strategy to cope with this is:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the question is genuinely about something unclear in your code, after having explained it to the curious programmer (and learned what he really <span class="emphasis"><em>needed</em></span> to know), capture the information in some appropriate documentation. You can email this to him afterward, too, to ensure he took away the right information.</p></li><li class="listitem"><p>If the question was about something that was already explained in the documentation, point him at it, shout RTFM,<sup>[<a class="footnote" href="#ftn.APP-FN-6" id="APP-FN-6">6</a>]</sup> and give him a poke in the eye.</p></li></ol></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-6" id="ftn.APP-FN-6">6</a>] </sup><span class="emphasis"><em>Read The</em></span> (ahem . . . ) <span class="emphasis"><em>Manual</em></span>.<a class="indexterm" id="IDX-APP-1931"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_5_colon_a_passing_comment"/><a class="xref" href="ch05.html" title="Chapter 5. A PASSING COMMENT">Chapter 5</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id27"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How might the <span class="bolditalic">need for</span> and the <span class="bolditalic">content of</span> comments differ in the following types of code</strong></span>:<a class="indexterm" id="IDX-APP-1932"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Low-level assembly language (machine code)</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Shell scripts</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>A single-file test harness</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>A large C/C++ project</strong></span></p></li></ol></div></li></ol></div><p>Assembly language is less expressive, providing fewer opportunities for self-documenting code. Therefore, you'd expect more comments in assembly code, and you'd expect those comments to be at a much lower level than comments in other languages—assembly language comments generally <span class="emphasis"><em>would</em></span> explain how as well as why.<a class="indexterm" id="IDX-APP-1933"/></p><p>There isn't an enormous a difference between the remaining three. Shell scripts can be quite hard to read back; they are proto-Perl in this respect. Careful commenting helps. You're more likely to use literate programming techniques on a large C/C++ codebase.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>You can run tools to calculate what percentage of your source code lines are comments. How useful are these tools? How accurate a measure is this of comment quality?</strong></span></p></li></ol></div><p>This kind of metric will give insight into the code, but you shouldn't get too concerned about it. It isn't an accurate reflection of code quality. Well-documented code might not contain <span class="emphasis"><em>any</em></span> comments. Enormous revision histories or large corporate copyright messages can dominate small files, affecting this metric.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you come across some incomprehensible code, which is the better way to factor in some intelligibility: adding comments to document what you think is going on, or renaming variables/functions/types with more descriptive names? Which approach will most likely be easier? Which approach will be safer?</strong></span></p></li></ol></div><p>You should do both, as appropriate. Renaming is arguably the best approach, but it's dangerous if you don't know exactly what a function does. You might be giving it another equally bad name. When renaming, you must be sure you know the nature of the item you're changing.</p><p>Use the code's unit tests to ensure that your modifications don't break any behavior.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>When you document a C/C++ API with a code comment block, should it go in the public header file that declares the function or the source file containing the implementation? What are the pros and cons of each location?</strong></span><a class="indexterm" id="IDX-APP-1934"/><a class="indexterm" id="IDX-APP-1935"/></p></li></ol></div><p>This question was the cause of a big fight at one place I worked. Some argued for descriptions to go in the <code class="literal">.c</code> file. Being close to the function means that it's harder to write an incorrect comment and harder to write code that doesn't match the documentation. The comment is also more likely to be changed in line with any code changes.</p><p>However, when placed in a header file, the description is visible alongside the public interface—a logical location. Why should someone have to look into the implementation to read any public API docs?</p><p>A literate programming documentation tool should be able to pull comments out of either place, but sometimes it's quicker to just read comments in the source instead of using the tool—a bonus of the literate code approach. I favor placing the comments in header files.</p><p>Of course, in Java and C#, there's only one source file anyway; you'd conventionally use the Javadoc or C# XML comment format.<a class="indexterm" id="IDX-APP-1936"/><a class="indexterm" id="IDX-APP-1937"/><a class="indexterm" id="IDX-APP-1938"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id28"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Look carefully at the source files you've recently worked on. Inspect your commenting. Is it honestly any good? (I bet as you read through the code you'll find yourself making a few changes!)</strong></span></p></li></ol></div><p>When you read and review your own code, it's very easy to skip the comments, presuming they're correct or at least adequate. It is a good idea to spend some time looking at them and assess how well you've written them. Perhaps you could ask a trusted colleague to give you his or her (constructive) opinion on your commenting style.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do you ensure that your comments are genuinely valuable and not just personal ramblings that only you can understand?</strong></span></p></li></ol></div><p>Some considerations for this are: write whole sentences, avoid abbreviations, and keep comments neatly formatted and in a common language (both the native language and the selection of words used from the problem domain). Avoid inside jokes, throw-away statements, or anything that you're not entirely sure about.</p><p>Code reviews will highlight weaknesses in your comment strategy.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do the people you work with all comment to the same standard, in about the same way?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Who's the best at writing comments? Why do you think that? Who's the worst? How much of a correlation does this bear to these individuals' general quality of coding?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Do you think any imposed coding standards could raise the quality of the comments written by your team?</strong></span></p></li></ol></div></li></ol></div><p>Use code reviews to inspect the comment quality of your peers and to move your team toward a consistent quality of commenting.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you include history logging information in each source file? If yes:</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you do maintain it manually? Why, if your revision control system will insert this for you automatically? Is the history kept particularly accurate?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Is this <span class="bolditalic">really</span> a sensible practice? How often is this information needed? Why is it better if placed in the source file than in another, separate mechanism?</strong></span></p></li></ol></div></li></ol></div><p>It's human nature not to keep a history accurate, even with the best intentions in the world. It requires a lot of manual work that gets skipped when time is tight. You should use tools to help maintain a history and put the right information in the right place (which I don't believe is the source file at all).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you add your initials to or otherwise mark the comments you make in other people's code? Do you ever date comments? When and why do you do this—is it a useful practice? Has it ever been useful to find someone else's initials and timestamping?</strong></span></p></li></ol></div><p>For some comments, this is a useful practice. In other places, it's just inconvenient—extra comment noise that you have to read past to get to the really interesting stuff.</p><p>It's most useful with temporary <code class="literal">FIXME</code> or <code class="literal">TODO</code> comments, marking work in progress. Released production code probably shouldn't have these; no finished code should need a reader to understand the author or date of a particular change.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_6_colon_to_err_is_human"/><a class="xref" href="ch06.html" title="Chapter 6. TO ERR IS HUMAN">Chapter 6</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id28"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are <span class="bolditalic">return values</span> and <span class="bolditalic">exceptions</span> equivalent error reporting mechanisms? Prove it</strong></span>.</p></li></ol></div><p>Return values are equivalent to global <span class="emphasis"><em>status variables</em></span> because the same reason code information can be sent back by both mechanisms (although it is easier to ignore a status variable). You can write code that works in a similar manner using both of these approaches.<sup>[<a class="footnote" href="#ftn.APP-FN-7" id="APP-FN-7">7</a>]</sup></p><p>Exceptions are a very different beast. They involve a new control flow, something very different from simple reason codes. They are tightly bound into the language and program run time. While you <span class="emphasis"><em>can</em></span> simulate exceptions by hand-crafting code that propagates errors, you'd have to carefully consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>How to represent errors as arbitrary objects, not just as integer reason codes</p></li><li class="listitem"><p>Supporting exception class hierarchies and providing the ability to catch by base class</p></li><li class="listitem"><p>Propagating exceptions through <span class="emphasis"><em>any</em></span> function, even those without <code class="literal">try</code>, <code class="literal">catch</code>, or <code class="literal">throw</code> statements</p></li></ul></div><p>It's that final point which shows most clearly why the two are <span class="emphasis"><em>not</em></span> equivalent. Implemented at a language level, exceptions are not at all intrusive in your code. A hand-crafted facsimile must manage the possibility of failure at every point. Every function is forced to return an error code—even if it cannot fail itself—just to propagate other error information. This requires serious adaptation of the code.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What different implementations of <span class="bolditalic">tuple</span> return types can you think of? Don't limit yourself to a single programming language. What are the pros and cons of using tuples as a return value?</strong></span></p></li></ol></div><p>In C you can create a <code class="literal">struct</code> for every return type, linking it with an error reason code. This would look something like:<a class="indexterm" id="IDX-APP-1939"/></p><a id="I_programlisting_d1e34269"/><pre class="programlisting">
<strong class="userinput"><code>/* Declare the return type */</code></strong>
struct return_float
{
    int reason_code;
    float value;
};

<strong class="userinput"><code>/* A function using it ... */</code></strong>
return_float myFunction() { ... }
</pre><p>This is messy, tedious to write, cumbersome to use, and hard to read. You can exploit C++ templates or Java/C# generics to automatically build this scaffolding, or you can use C++'s <code class="literal">std::pair</code> class. Both approaches are seen in production C++ code. Both are tedious to use, with the extra declarations and the machinery necessary to return these types. Some languages, like Perl, support lists of arbitrary types; this is a much easier implementation mechanism. Functional languages also provide such a facility.<a class="indexterm" id="IDX-APP-1940"/><a class="indexterm" id="IDX-APP-1941"/></p><p>We've just seen some of the disadvantages of this technique: It's very intrusive in the code and not at all sympathetic to the reader. It is also not an idiomatic coding practice. There may be a performance hit when returning more than one argument, but this is not a compelling argument, unless you're working at the machine code level. The notable advantage is that a separate reason code doesn't interfere with any return value.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do exception implementations differ between languages?</strong></span></p></li></ol></div><p>The four main implementations we'll consider are: C++, Java, .NET, and Win32 structured exceptions. Win32 exceptions are bound to the operating platform, the others to their languages. Languages <span class="emphasis"><em>may</em></span> be implemented in terms of such underlying platform facilities, or they may not be.<a class="indexterm" id="IDX-APP-1942"/><a class="indexterm" id="IDX-APP-1943"/><a class="indexterm" id="IDX-APP-1944"/><a class="indexterm" id="IDX-APP-1945"/></p><p>They all follow a similar approach; you can <code class="literal">throw</code> an exception, which is later handled by a <code class="literal">catch</code> statement placed after code wrapped in a <code class="literal">try</code> block. They all follow the termination model's behavior.</p><p>Java, .NET, and Win32 also have a <code class="literal">finally</code> construct. It contains code that is run whether execution leaves the <code class="literal">try</code> block normally or abnormally. This can be a good place to put cleanup code to ensure that it always gets called. <code class="literal">finally</code> can be simulated in C++, but it isn't pleasant.</p><p>The raw Win32 exceptions (minus any language support provided by compilers) don't clean up as they unwind the stack, because the OS has no concept of destructors. They must be used with care—they are intended to handle situations more akin to signals than code logic errors.</p><p>Java exceptions (deriving from <code class="literal">Throwable</code>) and C# exceptions (deriving from <code class="literal">Exception</code>) automatically provide a diagnostic backtrace—very helpful in later debugging. .NET's CLI allows anything to be thrown, but C# does not expose the ability to do so (it does expose the ability to catch them, though). Other .NET languages can throw whatever they like.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Signals are an old-school Unix mechanism. Are they still needed now that we have modern techniques like exceptions?</strong></span></p></li></ol></div><p>Yes, they are still needed. Signals are a part of the ISO C standard, and so they aren't easy to remove, anyway. Signals date from (pre) System-V Unix implementations. They are an asynchronous mechanism to report system-level problems/events. Exceptions solve a different problem, reporting code logic errors that can percolate up to a handler. It makes no sense to throw an exception for signal-type events, especially using the termination model—it doesn't provide asynchronous handling.<a class="indexterm" id="IDX-APP-1946"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What is the best code structure for error handling?</strong></span></p></li></ol></div><p>There is simply no answer to this question. Different code strategies will work best in different situations. What's important is to reliably detect and handle errors with clear, readable, maintainable code.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How should you handle errors that occur in your error-handling code?</strong></span></p></li></ol></div><p>Errors signaled within error handlers should be dealt with as you would any other error. It gets nasty fast, though—you end up with error handlers nested within error handlers nested within error handlers. Be very careful about this, and check for a neater way to structure your code.</p><p>A better approach is to only perform operations that are guaranteed to succeed (or that honor the nothrow exception guarantee) in your error handlers. That way, your world is a much nicer place to be.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id29"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How thorough is the error handling in your current codebase? How does this contribute to the stability of the program?</strong></span></p></li></ol></div><p>There is a direct correlation between good error handling and stable code. Either your program is not required to be robust, or it <span class="emphasis"><em>must</em></span> systematically detect and handle all error conditions. If this isn't deeply rooted in the program's philosophy, then you will not have a reliable system.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you naturally consider error handling as you write code, or do you find it a distraction, preferring to come back to it later?</strong></span></p></li></ol></div><p>It's natural to dislike error handling; no one wants to focus on the negative aspects of program functionality all the time.<sup>[<a class="footnote" href="#ftn.APP-FN-8" id="APP-FN-8">8</a>]</sup> However, heed this important advice: Don't put it off until later. If you do, some potential errors will inevitably be missed, one day causing unexpected program behavior. Get into the habit of thinking about errors <span class="emphasis"><em>now</em></span>.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Go to the last (reasonably sized) function you wrote or worked on, and perform a careful review of the code. Find every abnormal occurence and potential error situation. How many of these were actually handled in your code?</strong></span></p><p><span class="strong"><strong>Now get someone else to review it. Don't be shy! Did they find any more? Why? What does this tell you about the code you're working on?</strong></span></p></li></ol></div><p>This is a telling insight into how thorough a programmer you really are. Make sure that you perform this exercise carefully—and <span class="emphasis"><em>do</em></span> ask someone else. Even the most accomplished programmer will miss some error cases.<sup>[<a class="footnote" href="#ftn.APP-FN-9" id="APP-FN-9">9</a>]</sup> If these are unlikely to manifest as bugs, you'll probably never notice and live forever in the shadow of potentially weird behavior.<a class="indexterm" id="IDX-APP-1947"/><a class="indexterm" id="IDX-APP-1948"/></p><p>When using exceptions, you can't easily ignore an error case—exceptions force their own way up the call stack, regardless of whether you handle them or not. You <span class="emphasis"><em>can</em></span> still write bad code if it isn't exception safe (it may exit in a bad state, or with leaked resources) or if it performs over-eager catches (consuming errors that can't actually be handled at that level—for this reason, don't write <code class="literal">catch(...)</code> to catch all exceptions).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you find it easier to manage and reason about error conditions using <span class="bolditalic">return values</span> or <span class="bolditalic">exceptions</span>? Are you sure you know what is involved in writing exception-safe code?</strong></span></p></li></ol></div><p>To some extent, this depends on what you're used to. Exceptions complement and extend return values. An exception user can also understand return values, but the opposite doesn't necessarily hold. Return values are more obvious, hence easier to use properly.</p><p>If you do use exceptions, it's important to know what issues to be aware of. Exception safety affects <span class="emphasis"><em>all</em></span> of your code, not just the parts that raise and catch errors. Exception safety is a large and involved subject that needs much study. Don't underestimate how seriously it affects the way you program.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-7" id="ftn.APP-FN-7">7</a>] </sup>They are not quite the same, though. In C++ you can return a <span class="emphasis"><em>proxy</em></span> value type that has behavior in its destructor. This infuses extra magic into the return code mechanism.</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-8" id="ftn.APP-FN-8">8</a>] </sup>If you are inclined that way, you'd probably make a very good software tester. But don't change careers just yet—really thorough programmers are few and far between.</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-9" id="ftn.APP-FN-9">9</a>] </sup>How often does anyone check for errors from C's <code class="literal">printf</code>, for example?</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_7_colon_the_programmers_toolbox"/><a class="xref" href="ch07.html" title="Chapter 7. THE PROGRAMMER'S TOOLBOX">Chapter 7</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id29"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it more important for everyone in a development team to use the same IDE, or for each person to pick the one that suits him or her best? What are the implications of different people using different tools?</strong></span></p></li></ol></div><p>All professional programmers should be responsible and informed enough to select the tools that make them most productive. No two programmers are the same, and different people will naturally prefer different tools. As long as the choice is made based on practical considerations, the team's overall effectiveness will be improved. But forcing strong-minded techies to use particular tools rarely enthuses them to work well.</p><p>If the people on a team <span class="emphasis"><em>are</em></span> all using different development environments, then they must work together properly. They must build <span class="emphasis"><em>identical</em></span> code, and each editor mustn't fight the others' layout rules every time a source file is edited.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What is the minimum set of tools that any programmer should have at his or her disposal?</strong></span></p></li></ol></div><p>You can't get by without at least:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Some rudimentary form of editor</p></li><li class="listitem"><p>The minimum language support required (either a compiler, an interpreter, or both—it depends on the language)</p></li><li class="listitem"><p>A computer to run them on</p></li></ul></div><p>But that minimum set won't make a very productive programmer. You need a toolbox of other tools to get any serious work done.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There must be a revision control system, or work is downright dangerous.</p></li><li class="listitem"><p>A reasonable set of libraries will prevent reinventing wheels and lower the risk of introducing avoidable bugs.</p></li><li class="listitem"><p>You also need a build tool to help construct the software system.</p></li></ul></div><p>That's a more realistic minimum set. The more fundamental tools you add in, the easier it is to develop, and the better the code that will be produced.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which are more powerful: command-line or GUI-based tools?</strong></span><a class="indexterm" id="IDX-APP-1949"/></p></li></ol></div><p>I should break your arm if you even began to answer this question. Command-line and GUI tools are different. End of story.</p><p>An interesting philosophical question is: <span class="emphasis"><em>In this context, how do you define "powerful?"</em></span> Does it mean having more esoteric features? Does it mean how easy the tool is to use? Does it mean how fast it runs? Or does it determine how well a tool fits into the rest of the toolchain? Decide on a definition, and then try justifying your answer in terms of that. Then I might not break your arm.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are there construction tools that aren't programs?</strong></span></p></li></ol></div><p>We already categorized languages and libraries as tools, so the answer is <span class="emphasis"><em>yes</em></span>. Other good examples to consider are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Regular expressions</p></li><li class="listitem"><p>Graphical components (GUI "widgets")</p></li><li class="listitem"><p>Network services</p></li><li class="listitem"><p>Common protocols and formats (like XML)<a class="indexterm" id="IDX-APP-1950"/></p></li><li class="listitem"><p>UML diagrams</p></li><li class="listitem"><p>Design methodologies (like CRC cards)</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What's most important for a tool?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Interoperability</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Flexibility</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Customization</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Power</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Ease of use and learning</strong></span></p></li></ol></div></li></ol></div><p>Each of these is important. The balance probably changes for different types of tools and the situations in which you'll use them.</p><p>Power is important; your tools must be powerful <span class="emphasis"><em>enough</em></span> for the tasks you set them to, or your life will be hell. If this weren't the case, programmers would edit their source code using Notepad or vi.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id30"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What are the common tools in your toolbox? Which do you use every day? Which do you use a few times a week? Which do you only call on occasionally?</strong></span><a class="indexterm" id="IDX-APP-1951"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How well do you know how to use them?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Are you getting the most from every tool?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>How did you learn to use them? Did you ever spend any time improving your skill with them?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Are these the <span class="bolditalic">best</span> tools you could be using?</strong></span></p></li></ol></div></li></ol></div><p>The last question in that list is critical. Honestly appraise whether there are any better tools you could be using. It really is worth spending some time looking around. If there are better tools, get your hands on them and start experimenting.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How up to date are your tools? Does it matter if they're not the latest cutting-edge versions?</strong></span></p></li></ol></div><p>Out-of-date tools can cause nasty problems, but so can the latest tool versions. The nastiest problems occur when one tool version is out of sync with rest of the toolchain. There may be a subtle functional mismatch because of the version skew, causing the toolchain not to work together properly. The symptom is seldom a toolchain failure, but code that behaves in surprising ways.</p><p>Out-of-date tools may miss important bug fixes. An update might not seem important until you've been bitten by the bug it addresses. Hindsight is a wonderful thing. If you get out of date, you could end up relying on tools that are no longer supported, written by companies that no longer exist. This can become a serious problem in a critical project.</p><p>Of course, you can't always download and install a new tool version on a whim. It may not be practical to upgrade for a number of reasons. It may cost more than you can afford. The upgrade may force you to upgrade your OS or other critical parts of your toolchain, when this isn't practical.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you favor an integrated tool set (like a visual development environment) or a discrete toolchain? What are the advantages of the <span class="bolditalic">other</span> approach? How much experience do you have with <span class="bolditalic">both</span> ways of working?</strong></span></p></li></ol></div><p>A careless answer here might cost you your arm (see the answer to question 3 in the "Mull It Over" section on page 491). Try to come up with a serious list of the benefits of the other way of working—to ensure you avoid a narrow-minded and opinionated view.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are you a <span class="bolditalic">Default Dan</span> or a <span class="bolditalic">Tweaker Tom</span>? Do you accept the default settings in your editor, or do you customize them to within an inch of their lives? Which is the "better" approach?</strong></span></p></li></ol></div><p>You learn to use and get the most out of your editor by discovering how to configure it. In that case, Tom <span class="emphasis"><em>might</em></span> have the most sensible approach. A pragmatic stance is probably somewhere between the two (a good example of the <span class="emphasis"><em>Goldilocks principle</em></span>; behavior at the extremes is rarely best). There's no point configuring features you'll never touch. Some things really don't matter—I'm not all that worried about the color scheme an editor uses. But others things do matter—I don't want to be forced to accept a default code layout style if it's grotesque.<a class="indexterm" id="IDX-APP-1952"/></p><p>It's far better to code to your carefully chosen layout style than have it dictated by the editor's default settings. Indeed, your house coding style may <span class="emphasis"><em>require</em></span> it. I'd rather configure my editor to automatically format code as I want, rather than fight its cursor positioning every time I hit ENTER.</p><p>This kind of discussion scales beyond editors to any kind of configurable software tool.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do you determine your budget for software tools? How do you know whether a tool is worth its cost?</strong></span></p></li></ol></div><p>It depends on what kind of organization you're working for and the kind of work you're doing. If your project has the tools budget of a small country's GDP, then the cost of tools is of no consequence—buy the best tools (which may not necessarily be the most expensive ones) and enjoy them. But a lone hacker working at home can't justify the same kind of expense for a top-notch toolchain. Often the freely available tools are more than adequate for this kind of home use.</p><p>Indeed, the freely available tools are often of a very high quality, which makes it hard to draw the line as to when paying for tools is worthwhile. Paying for a toolchain usually means that you can <span class="emphasis"><em>expect</em></span> good product support and demand future bug fixes or development work. However, this doesn't always pan out—companies go out of business and products are discontinued. This is <span class="emphasis"><em>perhaps</em></span> an argument for picking the most popular, widely used tools. There's safety in numbers.</p><p>If all reasonable criteria fail, the more expensive a tool is, the larger its box should be. If it costs a fortune but comes in a small box, don't buy it!</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_8_colon_testing_times"/><a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id30"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Write a test harness for the</strong></span> <code class="literal">greatest_common_divisor</code> <span class="strong"><strong>code example earlier in this chapter. Make it as exhaustive as you can. How many individual test cases have you included?</strong></span><a class="indexterm" id="IDX-APP-1953"/><a class="indexterm" id="IDX-APP-1954"/><a class="indexterm" id="IDX-APP-1955"/><a class="indexterm" id="IDX-APP-1956"/><a class="indexterm" id="IDX-APP-1957"/><a class="indexterm" id="IDX-APP-1958"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How many of these passed?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>How many failed?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Using these tests, identify any faults and repair the code</strong></span>.</p></li></ol></div></li></ol></div><p>There are a large number of tests you should run, even though there are very few invalid input combinations. Thinking of invalid inputs first: Test for <span class="emphasis"><em>zero</em></span>. It may or may not be an invalid value (we've seen no spec, so we can't tell), but you'd expect the code to cope reasonably with it.<a class="indexterm" id="IDX-APP-1959"/></p><p>Next, write tests considering combinations of usual inputs (say of 1, 10, and 100 in all orders). Then try numbers with no common multiple, like 733 and 449. Test for some very large numbers and for some negative numbers.</p><p>How do you write these test cases? Write a simple unit test function, and then place it into an automated test framework. For each test, don't programatically calculate what the correct output value should be;<sup>[<a class="footnote" href="#ftn.APP-FN-10" id="APP-FN-10">10</a>]</sup> just check against a known constant value. Keep your test code as simple as possible:</p><a id="I_programlisting_d1e34777"/><pre class="programlisting">
assert(greatest_common_divisor(10,  100) == 10);
assert(greatest_common_divisor(100, 10)  == 10);
assert(greatest_common_divisor(733, 449) == 0);
... more tests ...
</pre><p>There are a surprisingly large number of tests for this simple function. You could argue that for such a small piece of code, it's easier to inspect, review, and prove correctness rather than laborously create a set of tests. This seems like a valid argument. But—what if later on, someone makes modifications? Without the tests, you'd have to carefully reinspect and revalidate the code, an easy task to overlook.<a class="indexterm" id="IDX-APP-1960"/></p><p>Did you find the mistake in <code class="literal">greatest_common_divisor</code>? There's a clue coming up. If you don't want the puzzle spoiled, then look away now. . . . <span class="emphasis"><em>Try feeding it a negative argument</em></span>. This is a more robust (and more efficient) version written in C++:</p><a id="I_programlisting_d1e34792"/><pre class="programlisting">
int greatest_common_divisor(int a, int b)
{
    a = std::abs(a);
    b = std::abs(b);
    for (int div = std::min(a,b); div &gt; 0; --div)
    {
        if ((a % div == 0) &amp;&amp; (b % div == 0))
           return div;
    }
    return 0;
}
</pre><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How should the testing of a spreadsheet application and an automatic aircraft pilot differ?</strong></span></p></li></ol></div><p>In an ideal world, there would be no faults in either. In this utopia, both would be exhaustively tested and not released until perfect. Reality is somewhat different. Whereas you expect spreadsheets to crash from time to time,<sup>[<a class="footnote" href="#ftn.APP-FN-11" id="APP-FN-11">11</a>]</sup> you expect an autopilot to contain no errors at all. When human lives hang in the balance, software is developed in a very different way—far more formally and with much greater care. It is tested rigorously. There are safety standards at play here.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should you test all of the <span class="bolditalic">test code</span> that you write?</strong></span></p></li></ol></div><p>If you think about this for long enough it will give you a headache. You can't keep testing test code—how can you be sure the test code for your test code's test code is correct? The trick is to keep tests <span class="emphasis"><em>as simple as possible</em></span>. This way, the most likely testing errors will be lack of important test cases, not problems with the actual lines of test code.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Keep test code as simple as possible to prevent the introduction of errors</em></span>.</p></dd></dl></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How does a programmer's testing differ from a QA department member's testing?</strong></span></p></li></ol></div><p>Testers are more concerned with the black box style of testing and usually only perform product testing. It's rare to have testers working at the code level, because most products are executable software; there are comparatively few code library vendors.</p><p>Programmers are more concerned with white box tests, making sure their masterful creations work as they planned them to.</p><p>The secret aim of any programmer writing tests is to prove that his code works, not to find cases where it doesn't! I can easily write a load of tests to show how perfect my code is by deliberately avoiding all the bits I know are problematic. This is a good argument for getting someone other than the original programmer to create test harnesses.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it necessary to write a test harness for every single function?</strong></span></p></li></ol></div><p>You don't need to be quite so extreme. Some functions are easy enough to verify by inspection. Be careful not to get sloppy, though—remember to read the code <span class="emphasis"><em>cynically</em></span>. Simple getter and setter functions don't need a slew of individual tests.</p><p>At what code size do test harnesses become attractive? Generally when the code becomes sufficiently complex to require it. When a single glance can't prove the code is correct, write some test cases.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong><span class="bolditalic">Test-driven development</span> encourages you to write tests first, before any code. What sort of tests should you write?</strong></span></p></li></ol></div><p>Without having written any code, these can only be black box tests. Either that, or test-driven developers need a gift of prophecy.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should you write C/C++ tests to check for the handling of</strong></span> <code class="literal">NULL</code> <span class="strong"><strong>(zero) pointer parameters? What's the value of such a test?</strong></span></p></li></ol></div><p>If zero is an expected input value, then of course you must test for it.</p><p>But you don't always need to test for null pointers. If you don't specify magic behavior for a zero pointer value, then your function is quite within its rights to fall over when you pass it a bad pointer. In this case, zero could be as bad as a pointer to deallocated or invalid memory. It's rarely possible to test that the code will survive all bad pointers.<a class="indexterm" id="IDX-APP-1961"/></p><p>However, it <span class="emphasis"><em>can</em></span> be valuable to write code that is robust in the face of zero pointers, since they tend to fly around a lot. Many allocation routines return zero pointers for failure, and undefined pointers are often set to zero. If the dog might bite, it's a good idea to put a muzzle on it.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Your early code tests might not be on the final platform—you may not yet have access to it. Is it safest to defer testing until you <span class="bolditalic">do</span> have a target test platform, or to steam ahead now?</strong></span></p><p><span class="strong"><strong>If the code is intended to run in a different environment (perhaps on a high-capacity server, or some embedded device), how can you be sure that your tests are representative and adequate?</strong></span></p></li></ol></div><p>It depends on the nature of the code you're testing—whether it's a simple function doing housekeeping work or some hardware access logic. You must understand the differences between the development platform and the target environment. Memory constraints or processor speed may affect how the code runs. This probably isn't a big deal for the majority of the code you write, for which it is perfectly possible to create local test harnesses.</p><p>If your code exploits particular target platform features (parallel processors or particular hardware facilities), then you can't test fully without them. There may be simulators to check that the code runs; they are helpful, but not the definitive answer.</p><p>Putting all testing off until you have a target platform is a dangerous practice. By then you'll have a large body of code that you will have neither the time nor the inclination to test fully. For maximum confidence, test as early as you reasonably can.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do you know when you've finished and can stop testing? How much is <span class="bolditalic">enough</span>?</strong></span></p></li></ol></div><p>Since testing can't prove the absence of faults, you can never really tell when you're done. The task is potentially endless, and we're trying to come up with a test plan to make it a realistic exercise.</p><p>For simple blocks of code under black box testing, successfully running all the test cases in "<a class="xref" href="ch08s05.html" title="Choosing Unit Test Cases">Choosing Unit Test Cases</a>" on page 142 is sufficient. The larger your code gets, the more work you have to do.</p><p>You can measure the adequacy and exhaustiveness of your tests by the angle of attack you're taking. There are a few key strategies:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Coverage-based testing</strong></span></span></dt><dd><p>The test plan is specified in terms of <span class="emphasis"><em>coverage</em></span> of the software. For example: You may plan to execute every line of code at least once, execute every conditional branch both ways, or ensure that all system requirements are exercised at least once.<a class="indexterm" id="IDX-APP-1962"/></p></dd><dt><span class="term"><span class="strong"><strong>Fault-based testing</strong></span></span></dt><dd><p>This is based on weeding out a certain percentage of program faults. You start with a hypothetical number of faults, generally picked from prior experience. You then aim to detect and remove, say, 95 percent of them.</p></dd><dt><span class="term"><span class="strong"><strong>Error-based testing</strong></span></span></dt><dd><p>This approach focuses on the common points of error, where the software is likely to be brittle. For example, you'd eliminate off-by-one errors by testing all boundary values.</p></dd></dl></div><p>Based on this, here are some good reasons to stop testing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Regression test cases complete with a certain percentage passed (and no major <span class="emphasis"><em>show-stopping</em></span> failures remaining).</p></li><li class="listitem"><p>Coverage of code, functionality, or requirements reaches a specified point.</p></li><li class="listitem"><p>Exhibited bug rate falls below a certain level.</p></li></ul></div><p>Beyond these are some physical barriers, seldom movable, which will have a final say in determining an end point:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Hitting scheduled deadlines (testing deadlines or release deadlines). Development work has a nasty habit of overrunning and eating into the scheduled test time; this requires very careful management.<a class="indexterm" id="IDX-APP-1963"/></p></li><li class="listitem"><p>The test budget is depleted (a very sad criteria for stopping).</p></li><li class="listitem"><p>The beta or alpha testing period ends.</p></li></ul></div><p>In most organizations, the decision to stop testing and ship the product comes at a deadline. It's a compromise based on the remaining known faults, their severity, and the frequency of their occurrence, pitched against the need to get to market. The tests allow an informed judgment to be made about how acceptable the software is.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id31"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>For what percentage of your code do you write tests? Are you happy with this? Are your tests an automated part of the build process? What sort of testing do you give the remaining code? Is this adequate? What will you do about it?</strong></span><a class="indexterm" id="IDX-APP-1964"/><a class="indexterm" id="IDX-APP-1965"/><a class="indexterm" id="IDX-APP-1966"/><a class="indexterm" id="IDX-APP-1967"/><a class="indexterm" id="IDX-APP-1968"/></p></li></ol></div><p>Don't feel obliged to write a test harness for every scrap of code. But don't forget to use your brain, either. The implementation of a small function is often a no-brainer—so you tend to code it with no brain—and voilà: stupid errors. Since a simple function only needs a simple test, it's probably valuable to write it. In my code shop, we have a simple rule: <span class="emphasis"><em>Every</em></span> piece of code has a unit test, or it's not in the codebase.</p><p>Be sure that you <span class="emphasis"><em>are</em></span> performing the adequate and appropriate testing for which you are responsible, not just skipping an unpleasant task. Ask yourself this: How many of the errors that have bitten you recently could have been prevented by a good set of tests? Make sure you do something about it.</p><p>If your tests are not a part of the build system, then how do you ensure that the tests are ever run and that all the code passes them?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How good is your relationship with the people in your QA department? What personal reputation do you think you have with them?</strong></span></p></li></ol></div><p>It is vital to establish good working relationships between the QA department and the software developers. Rivalry often brews; the testing department is seen as a bunch of people who aim to get in the way of developers and hinder the path to release, rather than as a team who is helping to build a stable product. Usually the test and development departments sit far, far away from one another, only taking orders from their individual tribal chieftains.</p><p>Forget that.</p><p>Make them coffee. Take them out for lunch. Head down to the bar with them. Anything to prevent fostering a <span class="emphasis"><em>them and us</em></span> attitude.</p><p>Develop a professional working relationship. Make sure that you provide them with good, well-tested code—not just any old hurried junk. Throwing them your scraps to mop up will give the impression that you see them as servants working <span class="emphasis"><em>for</em></span> you, not colleagues working <span class="emphasis"><em>with</em></span> you.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What's your usual response to finding an error in your code?</strong></span></p></li></ol></div><p>There are several possible reactions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Disgust and disappointment</p></li><li class="listitem"><p>An urge to blame someone else</p></li><li class="listitem"><p>Happiness, if not downright <span class="emphasis"><em>excitement</em></span></p></li><li class="listitem"><p>Pretending you didn't find it, ignoring it, and hoping it will go away (as if <span class="emphasis"><em>that's</em></span> likely)</p></li></ul></div><p>Some of those are so plainly wrong that I'll assume you can rise above them. Does it seem a little crazy to suggest that you might be <span class="emphasis"><em>happy</em></span> to find a fault? Surely that's the reasonable reaction for a quality-conscious engineer—it's far better to find faults during development than for a user to find them in the field.</p><p>Your level of excitement will depend on where in the development life cycle the fault is found. Discovering a show-stopping bug the day before release won't make anyone smile.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you file a fault report for every code problem you uncover?</strong></span></p></li></ol></div><p>It's not really necessary to do this for every single fault: If no one's seen your code yet and it's not been integrated into the wider system, then you don't need to broadcast your incompetence! If you don't report a fault in the database, then you must make methodical notes so that you don't forget about it. For this reason, you might find it easier to use the fault-tracking system from the outset. You might be forced to raise fault reports if delivery is so late that people <span class="emphasis"><em>need</em></span> visibility of the remaining problems.</p><p>As soon as any code is released, you should make all of its faults public; you <span class="emphasis"><em>have</em></span> to file fault reports. This shows that you have identified each issue and have a plan to deal with it.</p><p>Whenever you discover a code fault, you should write a test case that excercises it and incorporate it into your suite of automatic tests to be run as a regression check. This acts as a form of documentation for the fault and ensures that it won't be reintroduced accidentally, later on.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How much testing are the project engineers expected to do?</strong></span></p></li></ol></div><p>It's important to know what's expected of you and to deliver that level of testing. But above this, don't just do what's <span class="emphasis"><em>expected</em></span>—do what <span class="emphasis"><em>needs</em></span> to be done.</p><p>Write a unit test for <span class="emphasis"><em>every</em></span> piece of code you create. If you need to modify someone else's work, write a test for it first if there isn't one. That way, you will know how well it currently works, what needs to be fixed, and how to prove that your modifications haven't busted anything.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-10" id="ftn.APP-FN-10">10</a>] </sup>This would open the door to more coding errors—imagine the pain of bugs in the test code!</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-11" id="ftn.APP-FN-11">11</a>] </sup>It's sad we've been conditioned to accept this.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_9_colon_finding_fault"/><a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id31"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it best for faults to be fixed by the original programmer who wrote the code? Or is the programmer who discovered the problem better placed to make a fix?</strong></span><a class="indexterm" id="IDX-APP-1969"/></p></li></ol></div><p>It's always helpful to approach any problem with a fresh pair of eyes. When debugging, this method avoids the common problem of a programmer reading what he <span class="emphasis"><em>meant</em></span> to write, not what the code actually says—too many bugs stay hidden that way.</p><p>On the other hand, the original programmer <span class="emphasis"><em>is</em></span> probably best placed to make the fix. He understands the code inside out (hopefully). He knows what repercussions a particular change will have. He'll be the quickest to pinpoint the location of a fault.</p><p>In Real World organizations, the choice of who makes a fix may be determined by individual free time and what other commitments the team has. For bugs that have been in the program since time immemorial, the original programmer is probably no longer available. He may have left the company, moved projects, or (worst of all) been promoted to management.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you tell when to use a debugger and when to use your brain?</strong></span></p></li></ol></div><p>Obviously, even the use of a debugger should be with your brain engaged. (Remember the golden rule of debugging?)</p><p>My rule of thumb is: Don't fire up a debugger until you know exactly what information you need to get out of it. The danger lies in using a debugger to putter around in the running code, not really knowing what you are looking for. You can waste hours doing this, with no real reward.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>You should learn unfamiliar code before you start trying to find and fix faults in it. But the time pressures of the software factory often dictate that you can't spend any serious time studying and understanding the program you're repairing. What's the best way forward?</strong></span></p></li></ol></div><p>In your dreams, you'd slap the people who wrote the schedule and take as long as necessary to fix the fault properly. Wake up, Alice. . . .</p><p>The best you can do is try to learn the code as you go along. Proceed with extra caution when working through it, and don't trust what you <span class="emphasis"><em>think</em></span> is happening—always make sure that the code is doing what you expect it to. When you think that you've found the cause of the bug, see if anyone on your team knows about the offending section of code. Discuss with them what you're going to do. Often when you describe the situation, you'll explain <span class="emphasis"><em>to yourself</em></span> the obvious thing you've just missed.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Describe good techniques to avoid memory-leak bugs</strong></span>.<a class="indexterm" id="IDX-APP-1970"/></p></li></ol></div><p>These are some good approaches:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Use a language where you're less likely to be bitten by them, such as Java or C#. (You can still be bitten by memory leaks in these languages. Do you know how?)<a class="indexterm" id="IDX-APP-1971"/><a class="indexterm" id="IDX-APP-1972"/></p></li><li class="listitem"><p>Use "safe" data structures that manage memory for you, so you don't have to worry about it.</p></li><li class="listitem"><p>Employ helpful language idioms, such as C++'s <code class="literal">auto_ptr</code>, to avoid problems.</p></li><li class="listitem"><p>Be rigorous and methodical in your handling of memory. For every allocation point, make sure there is a balancing deallocation point and that it will always be called.</p></li><li class="listitem"><p>Run your code through memory validator tools to ensure no bugs have crept through.</p></li></ol></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>When is it justifiable to have a quick stab at finding and fixing a fault, rather than adopting a more methodical approach?</strong></span></p></li></ol></div><p>You <span class="emphasis"><em>always</em></span> need to think about what you're doing. Even quick fiddling should be done with your brain firmly in gear. Don't blindly pepper the code with breakpoints to start digging around in the internals; try to think about how the code is designed and what it should be doing.</p><p>Gut feelings and your instant reactions may find a fault quickly in <span class="emphasis"><em>very small programs</em></span> (say, a few tens of lines). But in a program that's many thousands of lines long, you really need to know what's going on. There is no substitute for insight. There's nothing wrong with tracing the program's execution in a debugger to examine what it's doing, but chose the test points methodically.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id32"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How many debugging techniques/tools do you routinely use? What others have you seen that you might find useful?</strong></span></p></li></ol></div><p>Obviously the answer is <span class="emphasis"><em>none</em></span>. You always write perfect code the first time!</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What are the common problems and pitfalls in your language(s) of choice? How do you guard against these kinds of bugs in your own code?</strong></span></p></li></ol></div><p>It's important to know this kind of thing. It's what sets mediocre programmers apart from the experts. If you don't know where the dragons live, then you don't know how to avoid them.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are most of the bugs that occur in your code sloppy programming errors, or are they more subtle issues?</strong></span></p></li></ol></div><p>If you get bitten over and over again by little language snafus, it shows that you should write code more carefully. Take time with your code. Proofread it, and then reread it—you'll save time overall. A classic mistake is fixing one fault, not testing that it works, and then being bitten by undesirable side effects of your "fix."</p><p>There's no shame in having bugs in your code. Everyone gets them. Just make sure they're not stupid mistakes that you could have easily prevented.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you know how to use a debugger on your platform? How routinely do you use it? Describe how to</strong></span>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Produce a backtrace</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Inspect variable values</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Inspect value of fields within a structure</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Run an arbitrary function</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Swap thread contexts</strong></span></p></li></ol></div></li></ol></div><p>If you use a debugger all the time, then that's <span class="emphasis"><em>too much</em></span>. If you never use one, then that's <span class="emphasis"><em>too little</em></span>. Don't be afraid of your debugger, but don't use it as a crutch, either. Intelligent use of a debugger will allow you to hone right in to the location of a fault in little to no time.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_10_colon_the_code_that_jack_built"/><a class="xref" href="ch10.html" title="Chapter 10. THE CODE THAT JACK BUILT">Chapter 10</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id32"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Why should people with nice integrated development environments worry about using a command-line make utility, when they can just hit a single button to build their project?</strong></span><a class="indexterm" id="IDX-APP-1973"/><a class="indexterm" id="IDX-APP-1974"/></p></li></ol></div><p>Besides learning what's really going on behind the build button, knowing how to use make is a route to more powerful, flexible software construction. Rarely does a GUI build tool compare to the capabilities and malleability of makefiles. Simplification often <span class="emphasis"><em>is</em></span> a good thing, and GUI tools can help developers to create software quickly, but this simplicity comes at an expense.<a class="indexterm" id="IDX-APP-1975"/></p><p>GUI build tools simply do not scale well and are of little use on really large projects. Make does have a cryptic syntax, but it lets you do far, far more. For example, makefiles allow nesting of directories, creating a build hierarchy. Simplistic GUI tools only provide one level of depth, the nesting of projects inside a workspace.</p><p>People complain about make's complexity and that you can foul things up using it. This is a valid concern, but it is the same as with any power tool—you might injure yourself if you don't use it properly.</p><p>This doesn't mean that you should throw away all GUI build tools and start writing a raft of replacement makefiles. On the contrary: Use the right tool for the job. Balance simplicity and integration with power and extensibility; choose the tool that's required each time.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Why is it important to treat the extraction of source code as a separate step from building it?</strong></span></p></li></ol></div><p>The two <span class="emphasis"><em>are</em></span> logically different steps. In a properly crafted build system, you should be able to check out <span class="emphasis"><em>any</em></span> version of the software, no matter how old, and then issue the same make instruction to build it. Later you should be able to clean the tree and rebuild it using the same instruction, without checking everything back out again.</p><p>It's no loss to have these as two separate steps. You can easily wrap a script around them to make a single-step retrieve/build procedure—this will then be useful for an overnight build script. For these overnight scripts, it's vital to start from a fresh source tree each time (to avoid being caught out by problems carried over from the last tree). This is a good test of your source tree; by deleting it and performing a complete rebuild, you'll check that no files are missing or out of date (you might have forgetten to check something in).</p><p>Other problems with binding source extraction into the build step include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You don't want the build system to automatically check files out of the source repository as you do a build. You rarely want the whole world changing under your feet each time you rebuild. It's important to be in control of the code you're working on, not a slave to the build system behavior.</p></li><li class="listitem"><p>There is a bootstrapping problem: If extraction is a part of the build process, where do you get a source tree from in order to start the build? You'd have to check it out manually anyway! Or you'd have to recite more magic incantations to partially check out the build portions of the tree in order to perform a real checkout and build. Don't go there.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Where should the intermediate files from construction steps (e.g., object files) be put?</strong></span></p></li></ol></div><p>Some build systems dump object files beside the source file that generated them. Advanced build systems can create a parallel directory tree and build objects into <span class="emphasis"><em>there</em></span>, leaving the source directories intact. This keeps things neat, distinguishing source files from the build-generated files. There are downsides, though: It's harder to search around the hierarchy. You might want to force a source file recompilation by deleting a <code class="literal">.o</code> file, but with split trees you have to navigate further from the source to do so.</p><p>Another neat approach for object file placement is to put intermediate files within the source tree, but in their own subdirectory; out of way of the source files, but still close to hand. You'd end up with a directory hierarchy looking like <a class="xref" href="apas10.html#putting_built_object_files_in_a_subdirectory" title="Figure A-1. Putting built object files in a subdirectory">Figure A-1</a>.</p><p>This is a good way to support the building of <span class="emphasis"><em>multiple targets</em></span> from one source tree—each target has its own build subdirectory. Without this mechanism, you could start a debug build, finish it off in release mode, and have a link stage that's a disaster. Adopting this approach leads to a build tree looking <a class="xref" href="apas10.html#even_better_colon_putting_object_files_in_a_named" title="Figure A-2. Even better: Putting object files in a named subdirectory">Figure A-2</a>.</p><div class="figure"><a id="putting_built_object_files_in_a_subdirectory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e35363"/><img alt="Putting built object files in a subdirectory" src="tagoreillycom20080909nostarchimages207590.png"/></div></div><p class="title"><b>Figure A-1. Putting built object files in a subdirectory</b></p></div><br class="figure-break"/><div class="figure"><a id="even_better_colon_putting_object_files_in_a_named"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e35374"/><img alt="Even better: Putting object files in a named subdirectory" src="tagoreillycom20080909nostarchimages207592.png.jpg"/></div></div><p class="title"><b>Figure A-2. Even better: Putting object files in a <span class="emphasis"><em>named</em></span> subdirectory</b></p></div><br class="figure-break"/><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you add an automated test suite to the build system, should it run automatically after the software is built, or must you fire a separate command to invoke the tests?</strong></span></p></li></ol></div><p>You can easily provide a separate command (something like a <span class="emphasis"><em>tests</em></span> makefile target; you'd type <code class="literal">make tests</code> after <code class="literal">make all</code>). However, this extra step would be less likely to be performed—there's no requirement to do so. The tests may be overlooked. This is quite likely, human nature being what it is. The untested code could cause all sorts of problems, making the effort of writing tests fruitless. Ensure your unit tests are a part of the main build procedure.</p><p>Automated stress tests and load tests probably shouldn't be part of this build step, though. They might take too long to execute, only intended to be run on the overnight build. In this case, make an automated scaffold to run them, but don't trigger it during a normal build.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should the overnight build be a <span class="bolditalic">debug</span> or <span class="bolditalic">release</span> build?</strong></span></p></li></ol></div><p>Both. It's very important to test the release build configuration as early as possible. Debug builds shouldn't be released to the QA department, let alone outside the company.</p><p>It's important to test that both release and development build processes work—not just once when the build system is created, but on an ongoing basis. It's remarkably easy to make a minor update that breaks one or other build. If a build isn't tested until the last minute, you're going to be very angry when it fails with a deadline looming.</p><p>There may be serious differences between executables generated by debug and release builds. Some compilers exhibit markedly changed behavior in debug and release mode. One popular compiler is happy to pad out data buffers in debug builds, so memory overruns are harmless and go undetected—hardly a good debugging aid. If you only ever tested the debug build, switching to release mode just before the product ships means that you are bound to run into problems.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Write a make rule to automatically generate dependency information from your compiler. Show how to use this information in the makefile</strong></span>.</p></li></ol></div><p>There are several ways to achieve this, depending in part on how you get dependency information from your compiler. Say the hypothetical <code class="literal">compiler</code> takes an extra <code class="literal">-dep</code> parameter that cajoles it to create a dependency file as well as the object file. Let's say that the format of this generated file is already in make's dependency format.<sup>[<a class="footnote" href="#ftn.APP-FN-12" id="APP-FN-12">12</a>]</sup> Using GNU Make, you can specify a compilation rule that has the side effect of generating dependencies:</p><a id="I_programlisting_d1e35433"/><pre class="programlisting">
%.o: %.c
    compiler -object %.o <strong class="userinput"><code>-dep %.d</code></strong> %.c
</pre><p>You can then incorporate all generated dependency files directly into the makefile by putting this at the bottom of <code class="literal">Makefile</code>:</p><a id="I_programlisting_d1e35443"/><pre class="programlisting">
 include *.d
</pre><p>It's that easy! Of course, this is the simplest mechanism that will work. There are many refinements to clean this up. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can direct the dependency files into a separate directory. This prevents them from cluttering up the working directory and covering up the important files.<a class="indexterm" id="IDX-APP-1976"/><a class="indexterm" id="IDX-APP-1977"/></p></li><li class="listitem"><p>You can write an include rule to only pull in the <span class="emphasis"><em>correct</em></span> <code class="literal">.d</code> files. There may be other <code class="literal">.d</code> files lying around that you shouldn't include, making the wildcard <code class="literal">include</code> line dangerous: The inclusion of random information from invalid files will confuse make. This problem can crop up easily: If you remove a source file from the makefile but don't clean the build tree first, the old <code class="literal">.o</code> and <code class="literal">.d</code> files will hang around in the working directories until you remove them manually.</p></li><li class="listitem"><p>If the compiler permits, you can write a separate rule to create <code class="literal">.d</code> files, making them first-class citizens of the build system. This has the downside of slowing down the build process—the compiler will now be invoked <span class="emphasis"><em>twice</em></span> for each source file.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Recursive make is a popular method of creating a modular build system spanning several directories. However, it is fundamentally flawed. Describe its problems and suggest alternatives</strong></span>.</p></li></ol></div><p>Conventional wisdom suggests that all large codebases built with makefiles should use the recursive make technique. Yet as powerful as recursive make is, it's fundamentally flawed. Don't ignore it, though. It's important to understand how recursive make works (or doesn't work) because it's so prevalent (many codebases employ recursive make), and you need to you know its problems to understand what makes a better solution.<a class="indexterm" id="IDX-APP-1978"/><a class="indexterm" id="IDX-APP-1979"/><a class="indexterm" id="IDX-APP-1980"/></p><p>What renders recursive make a liability? It has a number of pitfalls:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Speed</strong></span></span></dt><dd><p>It's so <span class="emphasis"><em>slooooooow</em></span>. If you try to rebuild a source tree that's already up to date, a recursive build still has to trawl faithfully through each directory. For a reasonably sized project this takes ages, which is nonsensical when no action is necessary.</p><p>Each directory is built as a <span class="emphasis"><em>separate</em></span> make invocation.<sup>[<a class="footnote" href="#ftn.APP-FN-13" id="APP-FN-13">13</a>]</sup> This circumvents many potential optimizations; shared include files will be inspected over and over and over again. Although filesystems can cache information, this is still an unnecessary overhead. A sensible build system would only need to inspect each file once.</p></dd><dt><span class="term"><span class="strong"><strong>Dependencies</strong></span></span></dt><dd><p>Recursive make cannot follow dependencies correctly; subdirectory makefiles have no way of determining all dependency information. Your module makefile can observe that its local <code class="literal">func1.c</code> source file depends on a <code class="literal">shared.h</code> header in another directory. It will happily rebuild <code class="literal">func1.c</code> every time <code class="literal">shared.h</code> is changed. But what happens if <code class="literal">shared.h</code> is automatically generated by a separate module, based on some template file <code class="literal">shared.tmpl</code>? Your module can't know about this extra dependency. Even if it could, it doesn't know how to rebuild <code class="literal">shared.h</code>—that isn't its job. So if <code class="literal">shared.tmpl</code> is changed, <code class="literal">func1.c</code> will not be rebuilt appropriately.<a class="indexterm" id="IDX-APP-1981"/></p><p>The only way to plaster over this crack is to arrange for <code class="literal">shared.h</code> to be built first, <span class="emphasis"><em>before</em></span> <code class="literal">func1.c</code>'s module. The programmer must carefully define the <span class="emphasis"><em>order</em></span> of recursion to make sure the software rebuilds correctly.<sup>[<a class="footnote" href="#ftn.APP-FN-14" id="APP-FN-14">14</a>]</sup> The more indirect dependencies that exist, the worse the mess gets.</p><p>Faced with this problem, programmers devise nefarious work-arounds, like making several build passes over the tree or manually removing certain files to force a rebuild every time. These hacks only serve to slow the build down more and unnecessarily complicate the procedure.</p></dd><dt><span class="term"><span class="strong"><strong>Puts onus back on the developer</strong></span></span></dt><dd><p>Make was created to manage the complexity of rebuilding code. Recursive make turns this inside out and forces you to get involved in the build process again. We've seen how the programmer has to manage the order of recursion, kludging each makefile to work around limitations.</p></dd><dt><span class="term"><span class="strong"><strong>Subtlety</strong></span></span></dt><dd><p>Recursive make's problems are not at all obvious. That's why many people still think it's a good idea. When things go wrong, they do so in strange ways. The cause of a problem is rarely clear, so it'll be dismissed as "one of those freak events."</p><p>This adds up to a build system that is dangerously brittle.</p></dd></dl></div><p>These are all problems people wrongly attribute to make itself, arguing that it is defective. But in this respect, make is an innocent bystander. It's our <span class="emphasis"><em>use</em></span> of make that is at fault. The recursion introduces each of these problems; it inhibits make from doing its proper job.</p><p>So what's the solution to this mess? Clearly we don't want to throw away the nesting in our source trees. We need a build process that supports nesting but doesn't split up the build process recursively. This isn't too hard; we'll call the technique <span class="emphasis"><em>nested make</em></span>. It simply involves putting all build information in one master makefile. There is no longer a need for individual subdirectory makefiles. The über-makefile manages all source nesting internally.<a class="indexterm" id="IDX-APP-1982"/><a class="indexterm" id="IDX-APP-1983"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Contrary to popular belief, recursive make is a</em></span> bad <span class="emphasis"><em>build technique. Avoid it in favor of a more robust</em></span> nested make <span class="emphasis"><em>approach</em></span>.<a class="indexterm" id="IDX-APP-1984"/></p></dd></dl></div><p>You might be thinking that this is a more complex and less flexible approach. How can you manage a large build tree with just a single makefile?</p><p>A number of practical implementation techniques make it easy:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use make's include file mechanism. Put the list of each directory's source files in <span class="emphasis"><em>that</em></span> directory—it's far more maintainable and clear that way. Place this list in a file called something like <code class="literal">files.mk</code>, and include that from the master <code class="literal">Makefile</code>.<a class="indexterm" id="IDX-APP-1985"/></p></li><li class="listitem"><p>You can retain recursive make's modularity—entering <span class="emphasis"><em>any</em></span> component subdirectory to type <code class="literal">make</code>—by defining more intermediate targets. These targets construct specific parts of the project. Constructing modular builds this way can be more meaningful than recursive make's arbitrary directory-based approach, and it ensures that each intermediate target is always built properly.</p></li></ul></div><p>Nested make is no more complex than recursive make; in fact it can be <span class="emphasis"><em>less</em></span> complex. It produces more reliable, accurate, speedy builds.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id33"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you know how to perform different types of compilation using your build system? How can you build a debug or release version of the application from the same sources, with the same makefiles?</strong></span></p></li></ol></div><p>In an earlier answer, we saw a good solution to this problem: Build objects into different subdirectories, created by the build script, based on the type of build (one directory for debug files and one for release files).</p><p>You can achieve this in GNU Make by massaging filenames. Here's an example:</p><a id="I_programlisting_d1e35701"/><pre class="programlisting">
<strong class="userinput"><code># Define the source files</code></strong>
SRC_FILES = main.c func1.c func2.c

<strong class="userinput"><code># Default build type (if none specified)</code></strong>
BUILD_TYPE ?= release

<strong class="userinput"><code># Synthesize the object filenames
# (This is a magic GNU Make incantation that swaps
# the .c file suffix for .o)</code></strong>
OBJ_FILES = $(SRC_FILES:.c=.o)

<strong class="userinput"><code># Now the clever bit: add the build-type directory
# prefix to object filenames (more GNU Make magic)</code></strong>
OBJ_FILES = $(addprefix $(BUILD_TYPE)/, $(OBJ_FILES))
</pre><p>You'll obviously be doing more with the selected <code class="literal">BUILD_TYPE</code>, altering the compiler flags, for example. Don't forget that you'll need a rule to create the subdirectories, or your compiler will complain when it tries to generate output. Here's how to do this on Unix:</p><a id="I_programlisting_d1e35720"/><pre class="programlisting">
$(BUILD_TYPE):
    mkdir -p $(BUILD_TYPE)
</pre><p>Now you can type these two commands, one after the other, knowing the build system will cope perfectly:</p><a id="I_programlisting_d1e35724"/><pre class="programlisting">
BUILD_TYPE=release make all
BUILD_TYPE=debug make all
</pre><p>You <span class="emphasis"><em>can</em></span> create a simpler system without this subdirectory technique, but it will rely on doing a cleanout whenever you change the <code class="literal">BUILD_TYPE</code>.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How good is your current project's build process? Does it rate well against the characteristics in this chapter? How could you improve it? How easy is it to</strong></span>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Add a new file to a library?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Add a new directory of code?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Move or rename a file of code?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Add a different build configuration (say, a demo build)?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Build two configurations in one copy of the source tree without doing a clean in between?</strong></span></p></li></ol></div></li></ol></div><p>This shows both how well you know the build process and how maintainable it is. Comparing your build mechanism to other projects' is a good idea—it will show where your processes are inadequate and need improvement.</p><p>Consider moving and renaming source files. Both are common during refactoring and are very easy to overlook. These simple actions <span class="emphasis"><em>can</em></span> cause build systems to calculate dependencies incorrectly and build flawed code. I've been bitten more than once by such a problem; it takes a while to notice when this goes wrong.</p><p>Often there is "no time" in the programmers' busy schedules to spend on improving the build system; they are all far too busy trying to get a product out the door. This is a dangerous misconception. The build scripts are a part of the code and require as much maintenance and careful extension as any other source file. A safe and reliable build system is so important that time spent sorting it out is <span class="emphasis"><em>not</em></span> time wasted. It's time invested in the future of the codebase.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Have you ever created a build system from scratch? What drove you to its particular design?</strong></span></p></li></ol></div><p>As with any programming task, the shape of your solution is influenced by a number of factors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your prior experience</p></li><li class="listitem"><p>What you know</p></li><li class="listitem"><p>Your understanding of the problem <span class="emphasis"><em>at the moment</em></span></p></li><li class="listitem"><p>The limitations of the technology available</p></li><li class="listitem"><p>The amount of time you have to set it up</p></li></ul></div><p>Generally, a little time and a little usage will tell how good your design decisions were. You never appreciate all the requirements at first, and things change that no one can anticipate:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Requirements change—if the product becomes really successful, you may need to build different internationalized versions or target a new processor architecture. The build system must accommodate extension.</p></li><li class="listitem"><p>The code may need to be moved across to a new build toolchain, when no one ever anticipated that this should be a selectable option.</p></li></ul></div><p>How easily these modifications can be incorporated is a testament to the quality of your design. You'll learn with each change, gaining valuable experience for the next build system you craft.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Everyone suffers from flaws in a build system from time to time. When programming a build script, you're as likely to introduce bugs as you are when programming real code</strong></span>.</p><p><span class="strong"><strong>What kinds of build errors have you been bitten by, and how could you fix, or even prevent, them?</strong></span></p></li></ol></div><p>Common build errors include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Picking up dependency information incorrectly</p></li><li class="listitem"><p>Not coping gracefully with file system failures, like running out of disk space or incorrect file permissions; the build may continue with no indication that one of the steps failed</p></li><li class="listitem"><p>Source control problems: merges go wrong, or the wrong version of some source code is checked out</p></li><li class="listitem"><p>Library configuration errors, often using incompatible or out of date versions</p></li><li class="listitem"><p>Programmers not understanding how to use the build system, and making silly mistakes</p></li></ul></div><p>When something's not going as expected, step back and consider whether or not the build system is playing a part in the problem.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-12" id="ftn.APP-FN-12">12</a>] </sup>These are quite reasonable assumptions; many systems work like this.</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-13" id="ftn.APP-FN-13">13</a>] </sup>Just think of the overhead of starting up all those child processes!</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-14" id="ftn.APP-FN-14">14</a>] </sup>This is a one-up for GUI tools—without recursive make, they tend to manage dependencies properly.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_11_colon_the_need_for_speed"/><a class="xref" href="ch11.html" title="Chapter 11. THE NEED FOR SPEED">Chapter 11</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id33"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Optimization is a process of making trade-offs—sacrificing one quality of code for another desirable quality. Describe the kinds of trade-offs that lead to a performance increase</strong></span>.</p></li></ol></div><p>The kinds of decisions that profoundly influence a program's performance are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Number of features versus size of code</p></li><li class="listitem"><p>Program speed versus memory consumption</p></li><li class="listitem"><p>Storage and caching versus computation on demand</p></li><li class="listitem"><p>Guarded approach versus unguarded; optimistic versus pessimistic</p></li><li class="listitem"><p>Approximate calculations versus exact calculations</p></li><li class="listitem"><p>Inline versus function call; monolithic versus modular</p></li><li class="listitem"><p>Indexing an array versus searching a list</p></li><li class="listitem"><p>Passing a parameter by reference or address versus passing a copy</p></li><li class="listitem"><p>Implemented in hardware versus software</p></li><li class="listitem"><p>Hard-coded, direct access versus indirect access</p></li><li class="listitem"><p>Predetermined, fixed value versus variable and configurable</p></li><li class="listitem"><p>Compile-time work versus run-time work</p></li><li class="listitem"><p>Local function call versus remote call</p></li><li class="listitem"><p>Lazy computation versus eager computation</p></li><li class="listitem"><p>"Clever" algorithm versus clear code</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Look at each of the optimization alternatives listed in "<a class="xref" href="ch11s03.html" title="Why Not Optimize?">Why Not Optimize?</a>" on page 202. Describe what trade-offs are being made, if any</strong></span>.<a class="indexterm" id="IDX-APP-1986"/></p></li></ol></div><p>Some of these alternatives <span class="emphasis"><em>could</em></span> be considered optimizations, depending on how much of the system is under your control. If you specify the hardware platform that your program will run on, using a faster machine <span class="emphasis"><em>is</em></span> an optimization. If not, it's more of a work-around.</p><p>Many of the alternatives have hidden complexity costs. For example, relying on a certain host platform configuration (i.e., what services or background programs are running) leads to specific environmental dependencies that are hard to capture and easy to miss during installation or later maintenance.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Explain these terms and their exact relationship</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Performance</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Efficiency</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Optimized</strong></span></p></li></ul></div></li></ol></div><p>The <span class="emphasis"><em>efficiency</em></span> of code determines its <span class="emphasis"><em>performance</em></span>. <span class="emphasis"><em>Optimizing</em></span> is the act of improving the code's efficiency in order to improve performance. Notice that none of these terms directly describe <span class="emphasis"><em>speed of execution</em></span>; the quality required may not be speed, but rather memory footprint or data throughput.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What are the likely bottlenecks in a slow program?</strong></span></p></li></ol></div><p>It's common fallacy to think that everything is contending for the CPU and that bad code will be consuming all the processor time. Sometimes the CPU can be running almost idle, yet performance is dire. A program may stall for a number of reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Memory is being thrashed to and from swap space on the hard disk.</p></li><li class="listitem"><p>It is waiting on disk access.</p></li><li class="listitem"><p>It is waiting on slow database transactions.</p></li><li class="listitem"><p>There is bad locking behavior.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you avoid the need to optimize? What methods will prevent you from writing inefficient code?</strong></span></p></li></ol></div><p>We've seen how important it is to <span class="emphasis"><em>design</em></span> performance into a software system from the very beginning. You can only do this if you already have a firm idea of what the required performance characteristics are.</p><p>Once you have a sound design in place, write your code sensibly. Be aware which constructs are most efficient in your language, and avoid using the inefficient ones. For example, in C++, pass <code class="literal">const</code> references rather than expensive temporary copies.<sup>[<a class="footnote" href="#ftn.APP-FN-15" id="APP-FN-15">15</a>]</sup></p><p>It's useful to have a rough idea of the relative costs of different operations. If we scale time so that a processor executes one instruction a second, then a function call typically takes a few seconds, a virtual function call takes 10 to 30 seconds, a disk seek takes a few months, and the time between keystrokes of an average typist is several years. Try to work out this kind of measure for operations like a memory allocation, claiming a lock, creating a new thread, and a simple data structure lookup.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How does the presence of multiple threads affect optimization?</strong></span><a class="indexterm" id="IDX-APP-1987"/></p></li></ol></div><p>Threading can cause as many problems as it's supposed to solve. Naïvely threaded designs can introduce extra bottlenecks, particularly when locks are used badly, leading to long periods of deadlock.</p><p>Multithreaded programs are harder to profile, unless the profiler has good thread support; you need to interpret the profiler's results based on the relative thread priorities. If the threads are supposed to cooperate, you have to work out how the overall execution is progressing as several threads of control weave around one another.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Why <span class="bolditalic">don't</span> we write efficient code? What stops us from using high-performance algorithms in the first place?</strong></span></p></li></ol></div><p>There are many perfectly valid reasons for not writing optimized code on the first attempt:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You don't know the final pattern of usage. With no Real World test data, how can you choose the code design that will work best?</p></li><li class="listitem"><p>It's hard enough to get the program <span class="emphasis"><em>working</em></span>, let alone working <span class="emphasis"><em>fast</em></span>. To prove it's feasible, we choose designs that are easy to implement so that prototypes get finished quickly.</p></li><li class="listitem"><p>"High-performance" algorithms can be more complex and daunting to implement. Programmers naturally shy away from them, since it's an area where faults can be easily introduced.</p></li></ul></div><p>Programmers often think that the time taken to run some code is proportional to the amount of effort spent writing it.<sup>[<a class="footnote" href="#ftn.APP-FN-16" id="APP-FN-16">16</a>]</sup> You might have written some file-parsing code in hours, but it will always takes ages to execute, because disks are slow. The complex code you spent half a week getting right may only consume a few hundred processor cycles. In fact, neither the efficiency of a piece of code nor the amount of time you need to spend optimizing it bears any relation to the amount of time you spent writing it.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>A</strong></span> <code class="literal">List</code> <span class="strong"><strong>data type is implemented using an array. What is the worst case algorithmic complexity of each of the following</strong></span> <code class="literal">List</code> <span class="strong"><strong>methods?</strong></span><a class="indexterm" id="IDX-APP-1988"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>The constructor</strong></span></p></li><li class="listitem"><p><strong class="userinput"><code>append</code></strong>—<span class="strong"><strong>places a new item on the end of the list</strong></span></p></li><li class="listitem"><p><code class="literal">insert</code>—<span class="strong"><strong>slides a new item in between two existing list items, at a given position</strong></span></p></li><li class="listitem"><p><code class="literal">isEmpty</code>—<span class="strong"><strong>returns</strong></span> <code class="literal">true</code> <span class="strong"><strong>if the list contains no items</strong></span></p></li><li class="listitem"><p><code class="literal">contains</code>—<span class="strong"><strong>returns</strong></span> <code class="literal">true</code> <span class="strong"><strong>if the list contains a specified item</strong></span></p></li><li class="listitem"><p><code class="literal">get</code>—<span class="strong"><strong>returns the item with a given index</strong></span></p></li></ol></div></li></ol></div><p>The worst cases are:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The constructor is <code class="literal">O(1)</code> since it only needs to create an array; the list is initially empty. However, it's worth considering that the size of this array will affect the complexity of the constructor—most languages create arrays fully populated with objects, even if you don't plan to use them yet. If the constructors for these objects are nontrivial, then the <code class="literal">List</code> constructor will take some time to execute.</p><p>The array size might not be fixed—the constructor could take a parameter to determine this size (effectively setting the maximum possible list size). The method then becomes <code class="literal">O(n)</code>.</p></li><li class="listitem"><p>The <code class="literal">append</code> operation is <code class="literal">O(1)</code> on average: It simply has to write an array entry and update the list size. <span class="emphasis"><em>But</em></span>, if the array is full, it will have to reallocate, copy, and deallocate—a worst case complexity of <code class="literal">O(n)</code>, at least (it depends on the performance of your memory manager).</p></li><li class="listitem"><p><code class="literal">insert</code> is <code class="literal">O(n)</code> on average. You might be asked to insert an element at the very beginning of the list. This requires all the elements in the array to be shuffled down one place before writing the first element. The more items in the <code class="literal">List</code>, the longer this will take. However, the worst case, again, involves memory reallocation and could be much more than <code class="literal">O(n)</code>.</p></li><li class="listitem"><p>Unless you have a ridiculously bad implementation, <code class="literal">isEmpty</code> is <code class="literal">O(1)</code>. The list size will be known, so the return value is a single calculation based on this number.</p></li><li class="listitem"><p><code class="literal">contains</code> is <code class="literal">O(n)</code>, presuming the list contents are unordered. In the worst case, you will be asked to look for an item that doesn't exist and will have to traverse every single list item.</p></li><li class="listitem"><p><code class="literal">get</code> is <code class="literal">O(1)</code>, thanks to the array implementation. Indexing an array is a constant time operation. If <code class="literal">List</code> had been implemented as a <span class="emphasis"><em>linked list</em></span>, then this would have been an <code class="literal">O(n)</code> operation.</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id34"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How important (honestly) is code performance in your current project? What is the motivator for this performance requirement?</strong></span></p></li></ol></div><p>The performance requirements should not be arbitrarily chosen. They should be justified, not just a time limit pulled out of thin air. Every performance requirement is important; there are no specifications that don't matter. How much concern a particular requirement generates depends on how hard it is to meet. Whether it's hard or not, you still have to come up with a design that satisfies it.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>In your last optimization attempt</strong></span>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Did you use a profiler?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>If yes, how much improvement did you measure?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>If no, how did you know whether you made any kind of improvement?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Did you test that the code still worked after optimizing?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>If yes, how thoroughly did you test?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>If no, why not? How could you be sure the code still worked properly for <span class="bolditalic">all</span> cases?</strong></span></p></li></ol></div></li></ol></div><p>Only the most dramatic performance improvements can be detected without a profiler or some other good timing tests. Human perception is easily fooled—when you've just slaved to speed up the program, it will always <span class="emphasis"><em>appear</em></span> faster to you.</p><p>Test performance improvements carefully, and discard those that are not worthwhile. It's better to have clear code than a minuscule speed increase and unmaintainable logic.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you've not yet attempted to optimize the code you're currently working on, take a guess at which parts are the slowest and which bits consume the most memory. Now run it through a profiler—how accurate were you?</strong></span></p></li></ol></div><p>You'll probably be quite surprised at the results. The larger the program you profile, the less likely you are to correctly judge these bottlenecks.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How well specified are your program's performance requirements? Do you have a concrete plan to test that you meet these criteria?</strong></span><a class="indexterm" id="IDX-APP-1989"/></p></li></ol></div><p>Without a clear specification, no one can really complain that your program isn't fast enough!</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-15" id="ftn.APP-FN-15">15</a>] </sup>Conversely, this reference might inhibit other performance gains. Copies are guaranteed not to have aliasing issues; some compiler optimizations cannot be performed if there are potential variable aliases. As always, you must measure and work out what works best.</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-16" id="ftn.APP-FN-16">16</a>] </sup>That looks stupid when you see it written down, but it's a very easy trap to fall into at the codeface.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_12_colon_an_insecurity_complex"/><a class="xref" href="ch12.html" title="Chapter 12. AN INSECURITY COMPLEX">Chapter 12</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id34"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What is a "secure" program?</strong></span><a class="indexterm" id="IDX-APP-1990"/><a class="indexterm" id="IDX-APP-1991"/><a class="indexterm" id="IDX-APP-1992"/></p></li></ol></div><p>A secure program is able to stand up against attempts to abuse it, to break into it, or to use it for a purpose it was not intended for. This is more than a robust program; robust code meets its specification and doesn't crash when you apply a little pressure. However, a robust program might not have been designed with security in mind and could still leak sensitive information under some extreme conditions. Sometimes it's preferable to crash when used wrongly, rather than provide unintended output. So secure code <span class="emphasis"><em>might</em></span> crash!<a class="indexterm" id="IDX-APP-1993"/></p><p>The definition of a secure program depends on the security requirements for the application. These are defined in part by what you can expect from the supporting services (the OS and other applications). Given these, your application's objectives could be any of the following:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Confidentiality</strong></span></span></dt><dd><p>The system will not disclose information to the wrong people. They will get an access denied message, or will have no idea that the information exists in the first place.</p></dd><dt><span class="term"><span class="strong"><strong>Integrity</strong></span></span></dt><dd><p>The system won't allow unauthorized changing of information.</p></dd><dt><span class="term"><span class="strong"><strong>Availability</strong></span></span></dt><dd><p>The system works continually—even while being attacked. It's hard to guard against <span class="emphasis"><em>all</em></span> possible attacks (what if someone removes the power?), but it's possible to resist many attacks by including a level of redundancy in the design, or by providing a rapid restart after attack.</p></dd><dt><span class="term"><span class="strong"><strong>Authentication</strong></span></span></dt><dd><p>The system ensures that users are who they say they are, usually with a login and password mechanism.</p></dd><dt><span class="term"><span class="strong"><strong>Audit</strong></span></span></dt><dd><p>The system records information about all important operations, to catch or monitor the activities of attackers.</p></dd></dl></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What input must be validated in a secure program? What sort of validation is required?</strong></span></p></li></ol></div><p><span class="emphasis"><em>All</em></span> input must be validated. This includes command-line parameters, environment variables, GUI inputs, web form inputs (even those with client-side JavaScript checking), CGI-encoded URLs, cookie contents, file contents, and filenames.</p><p>You should check the input's size (if it's not a simple numeric variable), the validity of its format, and the actual contents of the data (that numbers are in range, and there are no embedded query strings).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you guard against attacks from the pool of trusted users?</strong></span><a class="indexterm" id="IDX-APP-1994"/></p></li></ol></div><p>Not very easily. They have been given a specific level of privilege because they are trusted not to abuse it. Most users will not intentionally abuse your software, but a small number will try to subvert programs for their own advantage.</p><p>There are a few techniques to manage this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Log every operation so you know who made what change and when.</p></li><li class="listitem"><p>Require two users to authenticate all really important operations.</p></li><li class="listitem"><p>Wrap each operation in an undoable transaction so it can be unrolled.</p></li><li class="listitem"><p>Back up all data stores periodically so you can retrieve lost data.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Where can an exploitable buffer overrun occur? What functions are particularly prone to buffer overrun?</strong></span><a class="indexterm" id="IDX-APP-1995"/></p></li></ol></div><p>Buffer overrun is probably the biggest security vulnerability, and it is a simple problem that is easy for an attacker to exploit. It can occur anywhere that a multi-location structure is addressed—either by copying data into or out of it or by indexing into it to access a specific item. Arrays and strings are the most common culprits.</p><p>It is most often seen in user input routines, although this is not the only habitat—it can exist within any data manipulation code. Exploitable buffers can be situated both on the stack (where function-local variables are placed) or on the heap (the pool of dynamically allocated memory).<a class="indexterm" id="IDX-APP-1996"/><a class="indexterm" id="IDX-APP-1997"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Can you avoid buffer overruns altogether?</strong></span></p></li></ol></div><p>Yes—as long as you are diligent in validating each function's input and can be sure that the stack of software leading up to each input (possibility implemented in the OS input routines or your language's run-time library) is safe.</p><p>Here are some key techniques to safeguard your code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use a language with no fixed-size buffers—for example, a language that has automatically extending strings. It's not just strings that are dangerous, though: Look for bounds-checked arrays and safe hash maps.</p></li><li class="listitem"><p>If you can't rely on language support, you <span class="emphasis"><em>must</em></span> bounds check all input.</p></li><li class="listitem"><p>In C, always use the safer standard library functions <code class="literal">strncpy</code>, <code class="literal">strncat</code>, <code class="literal">snprintf</code>, <code class="literal">fgets</code>, and so on. Don't use stdio routines like <code class="literal">printf</code>, and <code class="literal">scanf</code>—you can't guarantee their safety.<a class="indexterm" id="IDX-APP-1998"/><a class="indexterm" id="IDX-APP-1999"/></p></li><li class="listitem"><p>Never use third-party libraries that aren't provably safe.</p></li><li class="listitem"><p>Write your code in a managed execution environment (like Java or C#). Then buffer overrun attacks become almost nonexistent—the executive traps most overruns automatically.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you secure the memory in use by your application?</strong></span><a class="indexterm" id="IDX-APP-2000"/></p></li></ol></div><p>There are three times to think about memory security:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Before you use it. When you claim some memory, it contains arbitrary values. Don't write code that accidentally relies on the contents of uninitialized memory. A cracker could exploit this to attack your code. To be extra safe, zero all allocated memory before you use it.</p></li><li class="listitem"><p>During use. Lock memory containing sensitive information so it can't be swapped to disk. Obviously you must be using a secure OS—if one application can read any other's memory, then you've already lost!</p></li><li class="listitem"><p>After use. Often forgotten by application programmers is that when you release memory, it should be cleaned before you hand it back for the OS to recycle. If you don't do this, a rogue process could mine memory for the secret data you leave behind.</p></li></ol></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are C and C++ inherently less secure than alternative languages?</strong></span><a class="indexterm" id="IDX-APP-2001"/></p></li></ol></div><p>C and C++ produce more than their fair share of insecure applications and <span class="emphasis"><em>allow</em></span> you to write code containing classic security vulnerabilities. You definitely have to keep your brain switched on; even experienced developers must pay attention when writing C/C++ code to avoid buffer overruns. These languages don't exactly encourage secure programming.</p><p>However, other languages don't avoid all security problems either, just the ones C and C++ have made famous. A different language will most likely avoid potential buffer overruns, but you shouldn't have a false sense of security; many other problems that can't be avoided in the language itself remain. You must be aware of security issues when using <span class="emphasis"><em>any</em></span> language—you can't pick a "safe" language and forget all about security.</p><p>Indeed, buffer overrun is a vulnerability that can be very easily audited and worked around. If you need to program secure applications, then the language you use is a small concern among all the other problems.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Has the experience of C led to C++ being a better, more securely designed language?</strong></span></p></li></ol></div><p>C++ has gained an abstract <code class="literal">string</code> type that manages its own memory internally. This goes a long way toward avoiding buffer overruns, although traditional C-style <code class="literal">char</code> arrays remain for those who still want to shoot themselves in the foot. The <code class="literal">vector</code> is another handy device: a memory managing array. However, it is possible to overrun both of these structures—do you know how?</p><p>C++ could be considered more dangerous than C, because it stores a lot of function pointers on the heap (this is where virtual function tables are stored). If an attacker can overwrite one of those pointers, then he can redirect operation to his own evil code.<a class="indexterm" id="IDX-APP-2002"/></p><p>In many ways, C++ is more secure, or rather, it is more easy to use securely. However, it was not designed with security solely in mind, and provides its own set of security problems that the developer must be aware of.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do you know when your program has been compromised?</strong></span></p></li></ol></div><p>Without detection measures, you'll have no idea—and you will just have to keep an eye out for unusual system behavior or different patterns of activity. This is hardly scientific. A hacked system can remain a secret indefinitely. Even if a victim (or his software vendor) <span class="emphasis"><em>does</em></span> spot an attack, he probably doesn't want to release detailed information about it to invite more intruders. What company would publicize that its product has security flaws? If it is conscientious enough to release a security patch, not everyone will upgrade, leaving a well-documented security flaw in many operational systems.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id35"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What are the security requirements for your current project? How were these requirements established? Who knows about them? Where are they documented?</strong></span></p></li></ol></div><p>Answer this honestly. It's not too hard to make up something that sounds plausible. But unless the security requirements are formally documented, security has not really been addressed by your project. This should be something that every developer is aware of and knows how to fulfill.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What's the worst security bug in one of your shipped applications?</strong></span></p></li></ol></div><p>It's important to know about this, even if it's now ancient history. You have to know what you've got wrong in the past to stand any chance of avoiding it in the future. If you don't know of any past security vulnerabilities, then you've probably not been thorough in security testing—you've not been paying attention, or you've been very lucky to have nothing discovered.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How many security bulletins have been posted against your application?</strong></span></p></li></ol></div><p>Have these been caused by silly developer mistakes like stupid code errors, or do they stem from larger design problems? Most common problems that get documented in bulletins are the former.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Have you ever run a <span class="bolditalic">security audit</span>? What kinds of flaws did it reveal?</strong></span></p></li></ol></div><p>Unless you have a professional security specialist running this test, it will surely miss some security vulnerabilities. However, the audit will still uncover many glaring problems and is <span class="emphasis"><em>very</em></span> worthwhile.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What kind of person is most likely to attack your current system? How is this influenced by</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Your company</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>The type of user</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>The type of product</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>The popularity of the product</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>The competition</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>The platform you run on</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>The connectedness and public visibility of the system</strong></span></p></li></ul></div></li></ol></div><p>Everyone is a target to someone: a malicious user, unscrupulous competitors, and even terrorist organizations. Who do you trust?</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_13_colon_grand_designs"/><a class="xref" href="ch13.html" title="Chapter 13. GRAND DESIGNS">Chapter 13</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id35"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How does project size affect your software design and the work involved in creating it?</strong></span></p></li></ol></div><p>The larger a project gets, the more architectural design it requires in proportion to low-level code design. More time needs to be spent up front ensuring the design is right, because bad choices will have more serious consequences.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is a well-documented bad design better than an undocumented good one?</strong></span></p></li></ol></div><p>Documentation is part of what makes a design good. A well-documented bad design provides a route in to the code, even if it's a brightly illuminated dirt track to a cesspit. At the very least, it will teach you never to touch the code again.</p><p>A sufficiently simple piece of code shouldn't need reams of documentation, but any reasonably complex piece of software becomes hard to work with when there isn't adequate description.</p><p>Which is better? The undocumented good design is best: If it is a truly high-quality design, then it <span class="emphasis"><em>should</em></span> be obvious and self-documenting.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you measure the design quality of a piece of code? How can you quantify its simplicity, elegance, modularity, and so on?</strong></span></p></li></ol></div><p>Quality is difficult to quantify; it's largely an aesthetic judgment for design. What makes a picture beautiful? The kind of thing you can't hold in your hand and count. Hindsight will show how easy the code was to pick up or to modify. But that doesn't really help when you first come across some code. If I have two designs <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span>, and I think <span class="emphasis"><em>A</em></span> is more elegant, but in practice <span class="emphasis"><em>B</em></span> turns out to be more usable and copes with the pressures of reuse much better, then it is hard to argue that <span class="emphasis"><em>A</em></span> is the better design.</p><p>The only way to judge design quality is to <span class="emphasis"><em>look</em></span> at the code. Reading a little code generally gives a good impression of overall quality; if one small bit appears good, then the rest is likely to be of reasonable quality too. This doesn't always hold, but it's a handy yardstick. A realistic approach is this: If that little bit of code is bad, expect the whole codebase to be terrible. If the little bit is any good, then just suspect the codebase of harboring more subtle problems.</p><p>Running code tools that inspect the source, producing diagrams and documentation, can also help to gauge design quality.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is design a team activity? How important are teamworking skills in creating a good design?</strong></span></p></li></ol></div><p>Very important. Programming tasks are seldom a lone activity. In the software factory, most large-scale design activities involve more than one designer. Even if the work is split into separate areas, those areas interface at some point—so the designers must interface. If there <span class="emphasis"><em>is</em></span> only one designer, he or she must still be able to document and communicate the design effectively.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are different methodologies more suitable to different projects?</strong></span></p></li></ol></div><p>Yes, the scope of some projects will render certain design approaches unnecessary. If you are writing a set of device drivers, you won't find <span class="emphasis"><em>much</em></span> use in a full-blown OO design process.</p><p>If you are working on a very formal project, perhaps for a government agency, you'll need to use a very formal process that documents every stage and provides accountability for every design decision made. This may be quite different from an exploratory R&amp;D project in a software lab.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>In what ways can you determine whether a design is highly cohesive or weakly coupled?</strong></span></p></li></ol></div><p>Ultimately you have to look at the code and see how it fits together, but that's boring! You can get a good feel for coupling in a C or C++ project by looking at the <code class="literal">#include</code>s at the top of the file. If there are tons of them, the coupling is probably disastrous. Alternatively, you can run inspection tools that produce pretty pictures of your code.<a class="indexterm" id="IDX-APP-2003"/><a class="indexterm" id="IDX-APP-2004"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If you've solved a similar design problem in the past, how good an indicator is it of how difficult <span class="bolditalic">this</span> problem will be?</strong></span></p></li></ol></div><p>Experience teaches you how to design, so learn and then exploit your knowledge. But employ wisdom with this knowledge; don't run on autopilot. Different situations present different challenges—don't presume that one problem is the same as another just because it looks like it on the surface.</p><p>If you know how to use a hammer, don't make every problem into a nail.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is there a place for experimentation in design?</strong></span></p></li></ol></div><p>Yes, any design <span class="emphasis"><em>is</em></span> experimental until it has been implemented and found acceptable. Consider the "build one to throw away" approach that Frederick Brooks described. (Brooks 95) There's a lot to be said for experimentation.</p><p>Design is an iterative process; during each iteration you can try out design alternatives and decide which is most sensible. The more iterations you go through and the smaller in scope you make each one, the less painful any bad design decisions will be.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id36"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Look back and think about how you learned to design code. How could you convey the knowledge you've gained to a total novice?</strong></span></p></li></ol></div><p>How much do you honestly think you <span class="emphasis"><em>could</em></span> teach, and how much would have to come from the novice's inherent abilities and experience? Could you create a set of exercises based on your experience that would help someone else?</p><p>You wouldn't give a novice a large system to design at first. You'd start him off on a small self-contained project, and then perhaps get him to make extensions to existing programs, all the time keeping a mentoring eye on what he's doing.</p><p>Most programmers didn't get this kind of help themselves when they were learning to design. They learned through a process of trial and error. Do consider teaching and mentoring a novice—it really helps you to grow in your own abilities.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What experience do you have with using particular design methodologies? Were these good or bad experiences? What was the resulting code like? What might have worked better?</strong></span></p></li></ol></div><p>Was the taste left in your mouth by a methodology influenced by your prior experience and preferences? If you don't know how to use a particular methodology, it will be hard work and uncomfortable. A hard-core C programmer may dislike any form of object-oriented design, and his OO designs will be appalling. But that doesn't make OO a flawed approach.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you find it important to stick rigidly to the methodology you're using?</strong></span></p></li></ol></div><p>The design approach is a tool, a utility, like a programming language—you should only use it up to the point it remains <span class="emphasis"><em>useful</em></span>. If it stops being useful, it's no longer a utility! A methodology won't work if no one on the team knows how to perform it; use something they do know, or teach them first.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What was the best designed code you've ever seen? What was the worst designed?</strong></span></p></li></ol></div><p>I bet you'll easily remember the worst designed code. Bad code sticks out like a sore thumb, and likewise sticks in your memory. Well-designed code looks simple and obvious, so you probably won't step back and say, "What a great design!" You probably won't even notice there was much design work involved.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>A programming language is essentially a tool to implement your design, not a religion to argue about. How important is it <span class="bolditalic">really</span> to know language idioms?</strong></span></p></li></ol></div><p>It's very important, or you'll end up with code that doesn't make sense.</p><p>Some architectural decisions may be language independent, but low-level code design is <span class="emphasis"><em>heavily</em></span> influenced by the implementation language. An obvious example: Don't create a flat procedural design when you're coding in Java—it's just plain wrong.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you think programming is an <span class="bolditalic">engineering discipline</span>, a <span class="bolditalic">craft</span>, or an <span class="bolditalic">art</span>?</strong></span></p></li></ol></div><p>Quite simply, it depends on how you do it. It has elements of all three.</p><p>I prefer to think of programming as a craft—it requires skill, workmanship, discipline, and experience. Its products can be at once functional <span class="emphasis"><em>and</em></span> beautiful. There is an element of artistry in it; it's a creative process. Allied with this artistry is the mastery of tools and techniques. These are the hallmarks of a craft.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_14_colon_software_architecture"/><a class="xref" href="ch14.html" title="Chapter 14. SOFTWARE ARCHITECTURE">Chapter 14</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id36"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Define where</strong></span> <span class="bolditalic">architecture</span> <span class="strong"><strong>ends and</strong></span> <span class="bolditalic">software design</span> <span class="strong"><strong>begins</strong></span>.<a class="indexterm" id="IDX-APP-2005"/></p></li></ol></div><p>In truth, both terms can be defined to whatever suits you. In their common usage, the distinctions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Architecture</strong></span> is the high-level structural design. It looks at the wide-ranging implications of its choices, seeing how it will impact construction and maintenance costs, overall system complexity, ability to accommodate future extensions, and marketing concerns. The architecture is devised at the start of a project. It has serious consequences, at the very least on the further software design.</p></li><li class="listitem"><p><span class="strong"><strong>Software design</strong></span> is the next level down, a more refined and focused activity. It's concerned with code details—data structures, function signatures, and the exact flow of control through modules. Software design is conducted on a per-module basis. Its consequences are nowhere near as significant to the system as a whole.</p></li></ul></div><p>Exactly where the two meet depends in part on the size of the project. Software construction is an iterative and incremental process—although architecture is created first, design results can feed back up to the architecture.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>In what ways can a bad architecture affect a system? Are there parts that wouldn't be affected by architectural flaws?</strong></span></p></li></ol></div><p>Bad architecture will undermine any effort to write good software. It is fundamental to the quality of your code. If some code isn't affected by the flawed architecture, then it's probably either a stand-alone library or it never really belonged in the system in the first place.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How easy is it to repair architectural deficiencies once they become apparent?</strong></span></p></li></ol></div><p>During the early formative stages of a project, it's relatively easy to massage the architecture. But once development is committed to that architecture, with sufficient investment (design and code) slotted into its scaffold, it's very, <span class="emphasis"><em>very</em></span> hard to change. You might as well try rewriting the entire product from scratch.</p><p>This is why it is so important to get the architecture right the first time. You can refactor small bits of code, but not an entire structural foundation.</p><p>Of course, it is easier for us to rip up software and start it afresh than it is in the physical construction industry, but economics dictate that we can't do it. We usually only have one chance to get the architecture right, and if we don't, we will have to live with the consequences for the entire lifetime of the software system.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>To what extent does architecture affect the following things?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>System configuration</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Logging</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Error handling</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Security</strong></span></p></li></ol></div></li></ol></div><p>The architecture has a profound impact on each of these, or more correctly, each of these has a profound impact on the architecture. You need to establish requirements for these areas before embarking on serious architectural design. It will be hard to graft such features into the code at a later date, let alone into the overriding architecture.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The architecture determines <span class="emphasis"><em>what</em></span> should be configurable (a lot or a little) and <span class="emphasis"><em>how</em></span> it should be configured. The kind of configuration mechanism is determined by several factors: the importance of a shared "configuration manager" component, whether or not the system supports remote configuration, and who has rights to perform configuration (is it just the developers; should the software be tweaked by installers, maintainers, or users?). All of these concerns are fundamental architectural issues.</p></li><li class="listitem"><p>The separate components may log information using some shared facility, or they might use their own custom mechanisms. The architecture will define which approach is acceptable, how you access the logs, and also the sort of logging information that's important. This needs to address the requirements of the software developers as well as the software users. Should development logging information be produced by release versions?</p></li><li class="listitem"><p>Architectural error management concerns include whether or not there is a central error-logging service and the error-reporting scheme (how does an error propagate from the seedy back-end components to the user's sanitized GUI interface?). It also defines what kind of error mechanisms are used: perhaps a centralized table of error codes shared across all components or a common exception hierarchy. It will address how errors from third-party code are incorporated into the system.</p></li><li class="listitem"><p>Security issues will depend on the kind of software under development. A distributed Internet-based shop-front system has different security requirements from a small piece of code that will only ever be deployed on a stand-alone computer. Security is an important topic and can't be grafted in at the last minute; it must be addressed in the early architectural designs.</p></li></ol></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What experience or qualifications are required to be called a <span class="bolditalic">software architect</span>?</strong></span></p></li></ol></div><p>You can decide to <span class="emphasis"><em>call</em></span> yourself an architect, but you can't gain insight and experience overnight or magically conjure up the wisdom to make good design decisions.</p><p>Good architectural design requires a wealth of prior experience—learning from, devising, and refining real software systems. This can only be learned by actually doing it, not by watching someone else. Be wary of people who call themselves architects after working on just one release of software.</p><p>You can work on software architecture and not be called an architect; the use of this moniker often depends on company structure and culture. No formal qualifications are required before you claim the title—however in some countries, it is illegal to call yourself any kind of architect without professional accreditation.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should sales strategy influence architecture? If so, how? If not, why?</strong></span></p></li></ol></div><p>Yes, commercial concerns will inevitably affect the technical architecture. Otherwise, you'll build a system that is not a viable product; you'll rapidly find yourself out of a job and your company in receivership.</p><p>We <span class="emphasis"><em>must</em></span> address the commercial implications of our designs—for example, considering the consequences of failure modes and the cost associated with return-to-base or on-site system support. The architecture must minimize these events if they are problems (you can provide remote access and rich diagnostics to avoid such intense product support).</p><p>Commercial concerns also affect these architectural areas: customer support facilities (including how easy the system is to administer), the installation approach (performed by trained personnel or by an automated CD installer), and maintenance support and fee structures.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How would you architect for</strong></span> <span class="bolditalic">extensibility</span>? <span class="strong"><strong>How would you architect for</strong></span> <span class="bolditalic">performance</span>? <span class="strong"><strong>How do these design goals affect the system, and how do they complement one another?</strong></span><a class="indexterm" id="IDX-APP-2006"/></p></li></ol></div><p>There are a number of architectural decisions that follow from these two requirements.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Extensibility</strong></span> can be supported through architectural devices such as plug-ins, programmatic access to code (reflection), more language bindings, scripting capabilities, and extra levels of indirection.<a class="indexterm" id="IDX-APP-2007"/></p></li><li class="listitem"><p><span class="strong"><strong>Performance</strong></span> is achieved by streamlining the architecture, keeping it mean and lean. You must remove all unnecessary components and ensure the connections provided are timely and adequate. Perhaps caching layers must be incorporated to boost data throughput.</p></li></ul></div><p>As you can see, these two have little in common; every hook for extensibility will consume some, no matter how little, performance. Extra indirection has a cost—the indirection. If your goal is extensibility, this is an appropriate price to pay. A good architecture makes the correct high-level compromises to suit the perceived requirements.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id37"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How diverse is the range of architectural styles to which you are accustomed? What do you have the most experience with—how does it affect the software you write?</strong></span><a class="indexterm" id="IDX-APP-2008"/></p></li></ol></div><p>Architecture affects us in many ways. Different architectural styles lead to different design and coding techniques. We are creatures of habit, and these techniques will shape how we think and code, even when working within a different architecture later on.</p><p>It is healthy to be exposed to a number of different architectures and to be able to work with them. In practice, you will focus on one particular style. Make sure you understand how your code is shaped by this architecture, and check that you're writing sympathetic code when you do change architectures.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What personal experience do you have of architectures that succeeded or failed? What made them winning solutions or a hindrances?</strong></span></p></li></ol></div><p>First, we must define what architectural <span class="emphasis"><em>success</em></span> means. Is it an architecture with technical merit? Is it a system that achieves commercial profitability? Is it a bit of both? Place your answer here.</p><p>Software that buckles under the weight of inappropriate architecture usually suffers because the architecture was not suitably extensible. Important features cannot be accommodated. This inevitably means the product loses market share to the more nimble competitors. History is strewn with software products that have fallen by the wayside like this.</p><p>Another danger is legacy; a huge investment in architectural baggage is a great hindrance. It requires real insight and a fair bit of courage to throw away an old system or architecture and start from scratch. A rework must always learn lessons from the previous version.<a class="indexterm" id="IDX-APP-2009"/></p><p>An over-engineered architecture is just as dangerous as an insufficient one. If the architecture supports too much, it will make the product overly complex, cumbersome, and unacceptably slow. It usually means that even the simplest change requires modifying many components.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Get every developer on your current project to draw a picture of the system architecture—individually (without talking to anyone) and without any reference to system documentation or the code. Compare the pictures. See what strikes you about each developer's efforts—aside from the relative artistic merit!</strong></span></p></li></ol></div><p>Be fearful if the pictures bear no resemblance to one another. Don't worry if there are minor variations; different people will miss different small components, and each may be focused on different parts of the system. But if the diagrams contain wildly different components or the communication paths are not similar, then the team does not have the same mental model of the code. This will almost certainly lead to disaster. Pull the developers together and make sure they know what the system really looks like.</p><p>If all the diagrams <span class="emphasis"><em>do</em></span> look similar, then give yourselves a pat on the back. You get bonus points if the components are positioned similarly on each sheet of paper. This is a hint that there is a central architecture specification and, more importantly, that everyone understands it.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you have an architectural description that's commonly available for your current project? How up to date is it? Which kinds of view are you using? If you needed to explain the system to a newcomer or a potential customer, what would you really need to have documented?</strong></span></p></li></ol></div><p>Note how far your ideal documentation is from reality. What opportunities do you have to improve this situation? In a busy commercial environment, you'll rarely be able to schedule specific time to document the entire architecture, but you can plan to capture parts during the design and specification of new modules. In this way, you can construct a good architectural overview, piece by piece.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How does your system's architecture compare to the architecture of your competitors in the marketplace? How has your architecture been defined to determine your project's success?</strong></span></p></li></ol></div><p>It's important to understand how your architecture is designed to meet all your requirements and to ensure your success. (If it has not been designed with this in mind, then you're in trouble.) We've seen how architecture has the most fundamental affect on the shape and quality of a software system—it therefore really does have a large influence on your product's success or failure. You'll rarely see software products thriving <span class="emphasis"><em>despite</em></span> their bad architecture. If you do know of a successful one, it probably won't be around for very much longer.</p><p>An architecture must be able to support at least the same core functionality as competing systems and provide good support for the unique features that will cause someone to choose your product over anyone else's. The simple features that don't require architectural support are rarely as compelling as core functionality embedded deeply in the system.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_15_colon_software_evolution_or_software_revolution_question"/><a class="xref" href="ch15.html" title="Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?">Chapter 15</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id37"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What is the best metaphor for software growth?</strong></span><a class="indexterm" id="IDX-APP-2010"/><a class="indexterm" id="IDX-APP-2011"/><a class="indexterm" id="IDX-APP-2012"/><a class="indexterm" id="IDX-APP-2013"/></p></li></ol></div><p>There is none. In the immortal words of Forrest Gump, "Software is as software does." (Groom 94) Code construction has many correlations, yet no metaphor fully conveys its subtleties, just as you could never fully describe the beauty of a sunrise in words.</p><p>Analogies can be misleading; software is a very different substance from any physical item, and building it is accordingly different. There are fewer physical constraints, and you can manipulate it in many more ways.</p><p>There is a glimpse of truth in each metaphor. Learn what you can from them, but don't be tunneled into an incorrect view of software.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Looking at a program's development through the colorful lifetime metaphor I talked about in the introduction, what Real World events correspond to a program's</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Conception</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Birth</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Growth</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Coming of age</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Sending out into the Big Wide World</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Middle age</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Growing tired</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Retirement</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Death</strong></span></p></li></ul></div></li></ol></div><p>Although we've seen that metaphors are imperfect, investigating this one does teach us a lot about the lifetime of a software system. It's certainly not practical to try to place one developmental stage before the preceding steps—you can't release software until it has come of age. Well, you can, but the consequences are dire.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Conception</strong></span></span></dt><dd><p>The company observes an opening for a new product. The market requirements are established. The decision is made to build it.</p></dd><dt><span class="term"><span class="strong"><strong>Birth</strong></span></span></dt><dd><p>A project is initiated to build the software. Designers and programmers are drafted in. An architecture is established. The code is started.</p></dd><dt><span class="term"><span class="strong"><strong>Growth</strong></span></span></dt><dd><p>The code develops, and the program matures. It becomes more and more functionally complete. Deadlines loom.</p></dd><dt><span class="term"><span class="strong"><strong>Coming of age</strong></span></span></dt><dd><p>Finally, the code is complete. It passes all tests to QA's satisfaction. It's considered a job well done, and hopefully it wasn't too far behind schedule.</p></dd><dt><span class="term"><span class="strong"><strong>Sending out</strong></span></span></dt><dd><p>The program is released as version 1.0. It successfully meets the market's needs.</p></dd><dt><span class="term"><span class="strong"><strong>Middle age</strong></span></span></dt><dd><p>The program is heavily used by clients and has been deployed for some time. Now, several revisions later, it has accumulated extra functionality and a degree of bloating.</p></dd><dt><span class="term"><span class="strong"><strong>Growing tired</strong></span></span></dt><dd><p>Eventually, more nimble competition overtakes the program, with a greater feature set and better performance. No new customers choose our program, but existing customers clamor for upgrades. The software has become hard (even uneconomical) to extend.</p></dd><dt><span class="term"><span class="strong"><strong>Retirement</strong></span></span></dt><dd><p>Finally, the company decides to give up on development and cease support. It announces support is ending in <span class="emphasis"><em>x</em></span> months: a formal <span class="emphasis"><em>end-of-life</em></span> statement. Development stops, although some maintenance work continues.</p></dd><dt><span class="term"><span class="strong"><strong>Death</strong></span></span></dt><dd><p>We reach the inevitable: All development and maintenance stops. There is no longer anything offered by way of support. The world has moved on; soon, no one will remember what the program was called, let alone how to use it.</p></dd></dl></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is there a limit to software life—how long can you keep developing and working on a program before you have to start afresh?</strong></span></p></li></ol></div><p>This depends more on the market for the program than the quality of the software itself. Code can last indefinitely if it's well maintained and extended carefully. However, technologies go out of date rapidly, and trends change. Operating systems evolve quickly, hardware platforms become obsolete, and something that began as state-of-the-art, market-leading functionality will be given away for free a few years later. You must work hard to maintain the program's competitive advantage. Perhaps you'll have to continually add new functions, or port the software to new platforms.</p><p>Open source software is not immune to these competitive and market-related issues; in some cases the problem is worse. There may be little or no money involved, but there is a still a real market with advancing technology, lower barriers to entry, and greater chances to switch products.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does the size of a codebase correspond to the maturity of the project?</strong></span></p></li></ol></div><p>No. On many occasions, I have vastly improved a system by <span class="emphasis"><em>removing</em></span> code from it. Duplication can lead to massive code growth with little functional gain. The use of external libraries provides a lot of functionality without any discernible increase in project code size.</p><p>Many people quote <span class="emphasis"><em>lines of code</em></span> as a good measurement of development progress. Such metrics are useless unless interpreted correctly. This is merely a view of the <span class="emphasis"><em>amount of code written</em></span>, not of its quality or the purity of its design. It is certainly not a measure of its functionality.<a class="indexterm" id="IDX-APP-2014"/><a class="indexterm" id="IDX-APP-2015"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How important is</strong></span> <span class="bolditalic">backward compatibility</span> <span class="strong"><strong>when maintaining code?</strong></span><a class="indexterm" id="IDX-APP-2016"/><a class="indexterm" id="IDX-APP-2017"/></p></li></ol></div><p>This depends on the individual project and how it has been deployed. More often than not, it is very important to retain backward compatibility when you change code—especially with regard to file formats, data structures, and communication protocols. Few applications can justifiably break this rule—only systems with small deployments and no need to store, retrieve, or communicate legacy data.</p><p>You should also consider <span class="emphasis"><em>forward compatibility</em></span>. That is, designing code for extension and ensuring that future events will not render it inoperable. The Y2K bug is a good example of this rule being ignored, with expensive and potentially disastrous consequences.<a class="indexterm" id="IDX-APP-2018"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is code likely to rot more quickly if you alter it or if you leave it alone?</strong></span></p></li></ol></div><p>Code rots quickest when you attempt to alter it. It's true that leaving a program to slowly stagnate will ensure your competitors gain an advantage, eventually rendering your code worthless. Your <span class="emphasis"><em>product</em></span> will hear its death knell, but the <span class="emphasis"><em>code</em></span> itself is as beautiful as it ever was.</p><p>Careless maintenance and sloppy extension will really cripple code. New faults are introduced all too easily as other problems are cleaned up. The pressure for rapid turnaround leads to modifications that degrade code clarity and structure. Maintaining code often renders it unmaintainable.</p><p>It takes good programmers and informed project management to avoid this.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id38"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is the majority of the code you write brand new or a modification of existing source?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If it's brand-new code, do you create entirely new systems or new extensions to existing systems?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Does this affect</strong></span> <span class="bolditalic">how</span> <span class="strong"><strong>you write? In what ways?</strong></span></p></li></ol></div></li></ol></div><p>Different forces come into play in these different scenarios. When extending existing code or fitting new software into an old framework, you have to do a <span class="emphasis"><em>lot</em></span> of investigation up front to understand how all the existing stuff works. If you don't, you'll end up writing bad code that doesn't fit in properly, causing headaches in the future.</p><p>Brand-new code must be created with a view to future modification. It must be clear, extensible, and malleable to prevent such problems from cropping up later.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you have experience of working with preexisting codebases? If so</strong></span>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How has it shaped your current skill set? What lessons did you learn?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Was it predominantly good or bad code? What did you have to judge it against?</strong></span></p></li></ol></div></li></ol></div><p>A few years experience helps you to judge what's good software and what's bad. The telltale signs become clear, and you're able to quickly detect code that must be handled with care.</p><p>Although vaguely masochistic, it can be good experience to work with someone else's trashy code—it teaches you what <span class="emphasis"><em>not</em></span> to do, how one programmer's shortsightedness can make other programmer's lives painful later on. It helps you to appreciate the importance of taking responsibility for the code you write.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Have you ever made changes that degraded the quality of code? Why?</strong></span></p></li></ol></div><p>Common reasons (or excuses) are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>I didn't know any better at the time.</p></li><li class="listitem"><p>I was pressed for time and had to ship the code quickly.</p></li><li class="listitem"><p>It was too much work to do any other way.</p></li><li class="listitem"><p>I could only modify code that was under <span class="emphasis"><em>our</em></span> control—the problem was in another team's code or in third-party library code that we only had binaries for.</p></li></ul></div><p>None of these reasons are satisfactory.</p><p>For bonus points, come up with counter arguments against each of those excuses and find ways to avoid each situation. For example, if you're pressured to ship a code release quickly, you can make a simple hacky change now, and revise the work once the software is released to create a more engineered solution.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How many revisions has your current project gone through?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How much changed functionally between revisions? How did the code change?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Has it grown by</strong></span> <span class="bolditalic">luck</span>, <span class="strong"><strong>by</strong></span> <span class="bolditalic">design</span>, <span class="strong"><strong>or something between the two? How is this evident now?</strong></span></p></li></ol></div></li></ol></div><p>Here are some important things to consider.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The two are not necessarily connected. Even some very simple functional changes may require fundamental code rewrites. I've seen many projects where this was the case, where the system architecture didn't support future requirements and had to be radically altered.</p><p>And I've also seen the opposite: releases that were functionally identical to their predecessor, but where almost everything had changed under the covers. There is no point in performing a complete project rewrite if the system is spiraling toward its death, but when it has a viable commercial future and the current code cannot accommodate future requirements, such action may be justified.</p><p>It might be commercial suicide to release a new version with no new features—customers will refuse to upgrade unless it's worth their while. Therefore, a few minor features tend to be thrown in as bait, or the revision is released with a certain amount of spin (i.e., <span class="emphasis"><em>This revision includes significant bug fixes</em></span>).</p></li><li class="listitem"><p>You must know the history of your codebase to understand how it grew to this current shape and to be able to make informed modifications and appropriate tidy-ups.</p></li></ol></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How does your team safeguard code so that it can't be changed by more than one programmer at once?</strong></span></p></li></ol></div><p>Employ a <span class="emphasis"><em>revision control system</em></span> to manage code changes. Blocking file checkouts prevent more than one person from modifying a file at once. However, this is not enough. One change can be checked in with a contradictory change immediately following. You need to <span class="emphasis"><em>manage</em></span> the development carefully, so that each developer with access to the source code understands what his or her peers are doing and who is responsible for making which changes. Code reviews help to detect and correct when this kind of problem has occurred.</p><p>A good suite of regression tests will ensure that any modification you make does not break functionality.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_16_colon_code_monkeys"/><a class="xref" href="ch16.html" title="Chapter 16. CODE MONKEYS">Chapter 16</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id38"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How many programmers</strong></span> <span class="bolditalic">does</span> <span class="strong"><strong>it take to change a light bulb?</strong></span></p></li></ol></div><p>The question's wrong. It's a hardware problem, not a software one. Get the hardware engineers to fix it. Of course, the hardware engineers will want to work around the problem in software. . . .<a class="indexterm" id="IDX-APP-2019"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it better to be enthusiastic and less skilled (not incompetent) or to be incredibly talented and unmotivated?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Who will write the better code?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Who is the better programmer? (Not the same thing.)</strong></span></p><p><span class="strong"><strong>Which does more to shape the code you write: your technical competence or your attitude?</strong></span></p></li></ol></div></li></ol></div><p>There are various types of software systems, and the creation of each requires a different set of skills. That's how programmers can carve out niches in embedded programming, web services, financial systems, and so on. The coding task also differs with the heritage of the code. You might write:<a class="indexterm" id="IDX-APP-2020"/><a class="indexterm" id="IDX-APP-2021"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Simple "toy" programs</p></li><li class="listitem"><p>New systems from scratch</p></li><li class="listitem"><p>Extensions of existing systems</p></li><li class="listitem"><p>Maintenance work on old codebases</p></li></ul></div><p>Each task requires a different level of skill and discipline, and a very different development approach. We'll see this in the next question. Not every programmer who can write a personal "toy" can create a brand-new, industrial-strength system.</p><p>For all of these, the quality of the resulting code is determined as much by your technical competence as your <span class="emphasis"><em>attitude</em></span> regarding the task—indeed, the two must complement one another. If you lack some technical skills, then you must have an attitude that acknowledges this and compensates for it.</p><p>Your attitude can do more to shape the code you write than your current skill set can. If you're less skilled but desire to do a good job, then you're more likely to work well. You're also more likely to learn and to improve your skills.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>There are various different types of programs we write, differentiated by code "heritage." How does writing the following types of code differ?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>A "toy" program</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>A brand-new system</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Extensions to an existing system</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Maintenance work on an old codebase</strong></span></p></li></ol></div></li></ol></div><p>It might not look like there's a great different between these code scenarios, but they require surprisingly different approaches.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>A toy program</strong></span></span></dt><dd><p>This might be a small fun hack for your own use or a little utility to help develop a larger system. This program doesn't need to be bulletproof, have in-depth design, or have exhaustive features. It just needs to do enough to solve the immediate problem. Then it's thrown away.</p><p>Speed and ease of development is probably more important than design elegance or the theological purity of the construction process.</p></dd><dt><span class="term"><span class="strong"><strong>A new system</strong></span></span></dt><dd><p>Creating a brand-new professional system from scratch requires serious design and careful planning. You must take into account future use and extensions, and ensure that the whole system is adequately documented.</p></dd><dt><span class="term"><span class="strong"><strong>Extensions</strong></span></span></dt><dd><p>Few projects create a new system from the ground up. More often, we extend existing code, adding new features to an old codebase. The new work must knit correctly into the existing system. This can't be done properly without a thorough understanding of the original code and the ability to make changes that sit well alongside existing work.</p></dd><dt><span class="term"><span class="strong"><strong>Maintenance</strong></span></span></dt><dd><p>The most common software activity is the maintenance of existing code, fixing any remaining faults, and ensuring that it remains operational as the world around it changes. This needs a careful methodical approach. It probably requires a lot of exploratory work; it will stretch your deductive powers since few systems are ever documented well enough to easily maintain, especially as they grow old and near obsolescence.<a class="indexterm" id="IDX-APP-2022"/></p></dd></dl></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If programming is an art, what is the correct balance of consideration and planning versus intuition and gut instinct? Do you program by gut or by plan?</strong></span></p></li></ol></div><p>As we've seen, effective programmers use both approaches. Intuition and the artist's aesthetic sensibilities will help craft elegant code. Thoughtful planning works alongside to ensure the code is sound, pragmatic, and delivered on time.</p><p>We can't formulate an exact ratio or formula for the optimum balance. Effective programmers have both and know how to moderate the use of each.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_17_colon_together_we_stand"/><a class="xref" href="ch17.html" title="Chapter 17. TOGETHER WE STAND">Chapter 17</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id39"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Why write software in teams? What are the real advantages over writing a system on your own?</strong></span><a class="indexterm" id="IDX-APP-2023"/><a class="indexterm" id="IDX-APP-2024"/><a class="indexterm" id="IDX-APP-2025"/><a class="indexterm" id="IDX-APP-2026"/><a class="indexterm" id="IDX-APP-2027"/></p></li></ol></div><p>Software development might be easier on your own; you don't have to work with other weird programmers, you don't need to coordinate work or suffer ineffective management. However, it isn't hard to see the many benefits of software development in teams.</p><p>In a team you can solve larger problems by decomposing them between individual members. And you can create code faster too. Groups of developers combine talents to make something greater than the sum of their parts. In cases where there is no well-established design or prior art, the wider skill set and knowledge of the group has a distinct advantage; a collaborative approach will filter ideas and generate better solutions. Peer reviews ensure that work is sound.</p><p>There is also a personal motivation: Techies like working on cool projects. You can work on systems well beyond your own ability when developing in a team. This might be software that is much larger than an individual could tackle, which requires specialized skills, or that provides the chance to work alongside more experienced programmers.</p><p>In a Real World organization, even a lone developer is part of a larger team. If you're not working with other software developers, you are still part of a corporate team, working to create a final polished product. Without those other people, your software would never be released.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Describe the telltale signs of good and bad teamwork. What are the prerequisites for good teamwork, and what characterizes bad teamwork?</strong></span></p></li></ol></div><p>For effective teamwork, all of these factors must be in place:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The correct spread of people, with a range of appropriate technical skills.</p></li><li class="listitem"><p>Team members with a range of experience, who are each able to learn from others. A whole team of trainees will clearly be very unlikely to succeed. (However, they'd be much easier to mold and manage than a bunch of Demigurus who are far more set in their ways.)</p></li><li class="listitem"><p>Team member personality types must be complementary. To succeed, the team needs encouragers and motivators, not people who will drag morale down.</p></li><li class="listitem"><p>A clear and realistic goal (even better if it's an exciting project that the team members really want to see completed).</p></li><li class="listitem"><p>Motivation (whether financial or emotional).</p></li><li class="listitem"><p>Suitable specifications provided as soon as possible, so all members understand what they are building and to ensure that the individual pieces of work fit together.</p></li><li class="listitem"><p>Good management.</p></li><li class="listitem"><p>As small a team as realistically possible, but no smaller. Adding more people makes teamwork harder: There are more lines of communication, more people to coordinate, and more points of failure. We should try not to make things unnecessarily difficult.</p></li><li class="listitem"><p>A clear and universally understood software engineering process for the team to follow.</p></li><li class="listitem"><p>Backing from the company, not hindrances and unnecessary bureaucracy.</p></li></ul></div><p>In contrast, these are sure indicators of a team that is not able to work effectively. Note that this list includes a mix of internal and external factors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Unrealistic schedules with deadlines established before the team has scoped their work.</p></li><li class="listitem"><p>Unclear project objectives and a lack of project requirements.</p></li><li class="listitem"><p>Communication failures.</p></li><li class="listitem"><p>Bad or unqualified team leaders.</p></li><li class="listitem"><p>Badly defined individual roles and responsibilities—who's responsible for doing what?</p></li><li class="listitem"><p>Individual bad attitudes and personal agendas.</p></li><li class="listitem"><p>Incompetent team members.</p></li><li class="listitem"><p>Management not valuing individual engineers, and treating them like minions instead.</p></li><li class="listitem"><p>Individual appraisals based on criteria that don't match the team objectives.</p></li><li class="listitem"><p>Rapid turnover of team members.</p></li><li class="listitem"><p>No change in management procedure.</p></li><li class="listitem"><p>A lack of training or mentoring.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Compare software teamwork with the construction metaphor (see "<a class="xref" href="ch10.html#do_we_really_build_software_question" title="DO WE REALLY BUILD SOFTWARE?">DO WE REALLY BUILD SOFTWARE?</a>" on page 177). Does it reveal insights into our teamwork?</strong></span></p></li></ol></div><p>There are a number of different metaphors that can be used to describe our work (for example, DeMarco's <span class="emphasis"><em>sports team</em></span> or <span class="emphasis"><em>choral society</em></span> and the <span class="emphasis"><em>factory</em></span> we joke about here). (DeMarco 99) The problem with any metaphor is that it can only tell a partial truth. Software engineering has its own problems and challenges. Chemical engineering is different from civil engineering, which is different from making a movie, which is different from writing software.</p><p>While not perfect, <span class="emphasis"><em>building construction</em></span> is a useful metaphor. After all, we construct software according to a plan, from different components (some of which we build ourselves, others which we buy or bring in). These are the useful parallels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You need a team: You can't single-handedly build a skyscraper or an enterprise-level highly complex software superstructure.</p></li><li class="listitem"><p>The team has a goal: It works to finish the construction on time and on budget.</p></li><li class="listitem"><p>Someone commissions the work, for a purpose: There is an end-purpose for the work.</p></li><li class="listitem"><p>Each team member does something different: Different roles help to get the job done. There are architects, builders, carpenters, plumbers, electricians, foremen, office staff, security guards, and more. Each makes a valuable contribution.</p></li><li class="listitem"><p>There are team members with responsibility: The foreman is the people manager.</p></li></ul></div><p>But of course, buildings are very different from programs. Buildings can't be developed in an iterative and incremental manner. Any change to a building's specification will result in costly demolition prior to rebuilding. In our world of pure thought stuff, we can tear down and rebuild with very little material cost (but with the costs of time and labor). In software, we are better able to build abstract interfaces between blocks. The engineering discipline is different, but that doesn't mean we can't learn from the parallels with other professions.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Will external or internal factors do the most to ruin the effectiveness of a software development team?</strong></span></p></li></ol></div><p>They'll both conspire to destroy your development work. Internal factors like:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ineffective team members</p></li><li class="listitem"><p>Conflict</p></li><li class="listitem"><p>Confusion</p></li><li class="listitem"><p>Show-stopping bugs late in development</p></li><li class="listitem"><p>Inaccurate plans</p></li></ul></div><p>Mix with external factors like:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Unclear or shifting requirements</p></li><li class="listitem"><p>Unrealistic deadlines</p></li><li class="listitem"><p>Bad management</p></li><li class="listitem"><p>Corporate bureaucracy<a class="indexterm" id="IDX-APP-2028"/></p></li></ul></div><p>This makes the life of a software developer incredibly difficult. Internal and external pressures are equally likely to destroy your teamwork, although it's widely recognized that most projects fail for nontechnical reasons.</p><p>One thing is certain: There are far more detrimental influences on team performance than there are success factors. For this reason, you must guard your team's work closely, attempting to insulate yourself from both internal and external attacks.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How does a team's size affect the team dynamics?</strong></span></p></li></ol></div><p>With more people, the team members suffer increased</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Coordination effort</p></li><li class="listitem"><p>Communication effort (more people introduce more separate paths of communication; this grows exponentially)</p></li><li class="listitem"><p>Cooperation effort</p></li><li class="listitem"><p>Dependency on others (direct and indirect)</p></li></ul></div><p>Each of these <span class="emphasis"><em>can</em></span> make your work harder. However, it's clear that a team of programmers can produce greater software than a single coder. This means that there must be an appropriate balance of team size versus size of task; this will change depending on the kind of system being developed.</p><p>As a team gets bigger, there is more likelihood that individual programmers will slacken the effort they put in, since they can be carried by the rest of the team. Brooks's <span class="emphasis"><em>The Mythical Man-Month</em></span> shows that adding people to a project does not necessarily make it complete sooner. (Brooks 95)</p><p>With a larger project, there is more chance that management talent will differentiate success from failure and more scope for management to provoke catastrophic failure.</p><p>In general, smaller development teams are better; but they must still be large enough to accomplish the task.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you insulate a team from problems caused by inexperienced members?</strong></span></p></li></ol></div><p>There will always be inexperienced programmers. This is the same in any field of endeavor. In many professions, new recruits undergo some form of apprenticeship period and must complete a stage of academic study. This ensures that their skills are already honed to a reasonable level. Although ripe with academic programming courses (of varying quality), our software profession doesn't recognize any formal form of apprenticeship. Mentoring new programmers is a fantastic way to quickly bring fresh recruits to a reasonable standard.</p><p>A few techniques contribute to making inexperienced coders' work less risky:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Have realistic expectations; don't expect miracles from them. Allot trainees appropriate tasks.</p></li><li class="listitem"><p>Monitor their progress, and ensure they aren't afraid to raise questions and problems.</p></li><li class="listitem"><p>Don't require too much prior experience: Use popular languages and tools that will require less time to get up-to-speed.</p></li><li class="listitem"><p>Don't use bleeding edge technologies and techniques.</p></li><li class="listitem"><p>Standardize tools across teams so trainees only need to learn a toolset once.</p></li><li class="listitem"><p>Train them.</p></li><li class="listitem"><p>Review their code.</p></li><li class="listitem"><p>Mentor them.</p></li><li class="listitem"><p>Pair program with them.</p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id39"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What kind of team are you working in right now? Which of the stereotypes on pages 322 through 332 is it most like?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it like this by design?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Is it a healthy team?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Does it need to be changed?</strong></span></p><p><span class="strong"><strong>What factors have you encountered that prevent good teamwork?</strong></span></p></li></ol></div><p><span class="strong"><strong>If you haven't done so already, fill out the earlier action sheet carefully (see "<a class="xref" href="ch17s10.html" title="Action Sheet">Action Sheet</a>" on page 347). Make sure you work out how to improve your team and start to make the changes</strong></span>.</p></li></ol></div><p>Work out how you will carry out any required changes. Set goals and review the team's health in a few months' time.</p><p>Common team problems include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Unbalanced team composition</p></li><li class="listitem"><p>Ineffective team members</p></li><li class="listitem"><p>Bad management</p></li><li class="listitem"><p>Unrealistic deadlines</p></li><li class="listitem"><p>Shifting requirements</p></li><li class="listitem"><p>Communication failure</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are you a good team player? How could you work better with your teammates and build better software?</strong></span></p></li></ol></div><p>Look again at the personal characteristics in "<a class="xref" href="ch17s05.html" title="Personal Skills and Characteristics for Good Teamwork">Personal Skills and Characteristics for Good Teamwork</a>" on page 333. Determine how closely you model each of these and how you can improve.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What is the exact responsibility of a software engineer on your current team?</strong></span></p></li></ol></div><p>How much responsibility and authority does a software developer have? Are there several ranks of programmer job titles—if so, how do these roles differ? Does a development role involve any of the following activities?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Forming the project scope and objectives</p></li><li class="listitem"><p>Analysis</p></li><li class="listitem"><p>Estimating timescales</p></li><li class="listitem"><p>Architecture</p></li><li class="listitem"><p>Design</p></li><li class="listitem"><p>Review</p></li><li class="listitem"><p>Project management</p></li><li class="listitem"><p>Being a mentor</p></li><li class="listitem"><p>Investigating and implementing performance</p></li><li class="listitem"><p>Documentation</p></li><li class="listitem"><p>Integrating systems</p></li><li class="listitem"><p>Testing (to what level?)</p></li><li class="listitem"><p>Interaction with the customer</p></li><li class="listitem"><p>Planning enhancements or the next software revision</p></li></ul></div><p>This detail will differ from company to company and from project to project. Are there clear lines of accountability in your team? Are there technical and pastoral managers to whom developers are assigned?</p><p>Do you have a job description? Do you have a set of personal objectives? If so, are you fulfilling them right now, or are they actually incorrect?</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_18_colon_practicing_safe_source"/><a class="xref" href="ch18.html" title="Chapter 18. PRACTICING SAFE SOURCE">Chapter 18</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id40"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you reliably release your source code to other people?</strong></span><a class="indexterm" id="IDX-APP-2029"/><a class="indexterm" id="IDX-APP-2030"/><a class="indexterm" id="IDX-APP-2031"/></p></li></ol></div><p>The easiest option for proprietary source code is <span class="emphasis"><em>not</em></span> to release it—then you'll avoid all sorts of problems. If you must ship code, don't forget to sort out licensing and get NDAs in place first. Know the size and extent of your audience and, if it's important to you, take measures to ensure that the code doesn't leak further afield.</p><p>For open source projects, this is not such a big concern; by their nature, they ship as source.</p><p>Before release, make sure that there are clear copyright and license notices in every source code file.</p><p>There are several mechanisms for a source code release, with differing abilities to guard against your code getting into the wrong hands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Allow the external viewer to have access to your source control system. You can lock this down through an account that is granted read-only access, possibly using a shared <span class="emphasis"><em>anonymous</em></span> account if your code is publicly available.</p><p>Obviously, to see your VCS server, users must have some level of privilege and network access to your development environment, so this must be closely managed—both so that they don't do anything untoward and so that crackers can't get in to look at your code.</p></li><li class="listitem"><p><span class="emphasis"><em>Tarball</em></span> the source tree (create a compressed archive of files—this term is named after Unix's <code class="literal">tar</code> command). This tarball can be emailed, FTPed, or sent on a CD. Ensure that your method of dispatch is appropriately secure.<a class="indexterm" id="IDX-APP-2032"/></p></li></ul></div><p>Include a set of release notes with your code, and clearly display the source tree revision information (usually a source control version or build number) for later reference. Mark the released code in your source control repository with a label so that you can retrieve it at a later date.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Of the two models for repository file editing (locking file checkouts or concurrent modification), which is best?</strong></span></p></li></ol></div><p>Neither model of operation is better or worse than its counterpart. Each hides different file editing problems and forces users to work differently when modifications might collide.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The locking model requires you to check out a file to reserve it before making any modifications. You can be sure that no other developer's change will interfere with your work and that you have sole access to that file until you check it back in or release the file unchanged. The downside is that a reserved file is blocked until the owner has relinquished control. You have no immediate way of knowing how long this will take.</p><p>If the owner sits at the desk next to you, then it's annoying but not hard to work out. However, if the owner is on another continent, works different hours, or accidentally leaves the file checked out while on vacation, then you're stuck. The best you can do is subvert the checkout by fiddling with the owner's computer to release the file. This will undoubtedly cause hassle and confusion later.</p></li><li class="listitem"><p>The concurrent model avoids this problem and ensures that you can continue coding unhindered at all times. The hidden danger is the possibility of conflicting file modifications. If Fred alters lines 10 through 20 of <code class="literal">foo.c</code>, while George alters lines 15 through 25, a race is on! The first developer to check in the file won't have any problems, so if Fred wins, his work on lines 10 through 20 will be put into the repository. But when George tries to check in, the SCMS will tell him that his source tree is out of date—he has to merge Fred's change into his copy of <code class="literal">foo.c</code> first. The five conflicting lines will need to be merged manually; George must do extra work to understand Fred's change and integrate it with his own. Only then can he check his work in.</p><p>This isn't ideal, but it happens very rarely in reality, and most conflicts are not at all contentious. The more common case is when Fred modifies lines 10 through 20 and George modifies lines 40 through 50; the two modifications don't conflict and the SCMS can merge the changes automatically. If you do encounter conflicting concurrent modifications, it's often a sign that the code needs some refactoring.</p></li></ul></div><p>Neither mode of operation is perfect; but each works fine. Which you choose depends on the operation of your source control tool and the development process and culture you work in.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do the requirements for version control systems differ between a distributed and a single-site development team?</strong></span></p></li></ol></div><p>If a SCMS can accommodate remote sites, it will definitely be able to cope with a single-site development team, so we're mostly considering a set of <span class="emphasis"><em>extra</em></span> requirements for multisite operation. These extra requirements include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There must be a scaleable client/server architecture.</p></li><li class="listitem"><p>The tool must work effectively over low-bandwidth network links (which are common for satelite sites), <span class="emphasis"><em>or</em></span> your deployment must include a really high-quality intersite connection. Low-bandwidth links require intelligent data compression and sensible communications protocols (for example, the tools should send small file differences, rather than entire files).</p></li><li class="listitem"><p>There must be a centralized method to administer user accounts so that collaboration is seamless across sites.</p></li></ul></div><p>There are two main designs: wide area network communication and remote repository replication. The first performs all client communication with a central server hosted at the parent location. This requires a sufficiently fast and reliable communication channel between sites. The latter method reduces communication overhead by replicating the repository onto a remote server at low-load times. However, this adds a lot complication to the development process; you need to understand that the two repositories are not costantly synchronized, and you must work out sensible branching strategies to avoid conflicting lines of development work.</p><p>When evaluating source control systems, don't ignore these requirements, even if you only have one development site. In the future, you may need to add a secondary site or support for telecommuters. Bear this in mind as you scope your system.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What is a sound rationale for selecting a source code management system?</strong></span></p></li></ol></div><p>Good criteria for selecting a SCMS include:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Reliability</strong></span></span></dt><dd><p>Check that it is proven technology and won't suddenly lose your source files. The server must be robust and not prone to crashing every few days.</p></dd><dt><span class="term"><span class="strong"><strong>Capacity</strong></span></span></dt><dd><p>The tool must scale up well, handling large teams and large projects as well as small ones. In more demanding situations, does it consume a lot of disk space, soak up all network bandwidth, or take an excruciating time to run? Perhaps you require multisite repository synchronization, or does it work well enough on a low-bandwidth link?</p></dd><dt><span class="term"><span class="strong"><strong>Flexibility</strong></span></span></dt><dd><p>Does it provide all the operations and reports that you need? Does it handle all the filetypes that you want to control? Can it manage binary files? Does it support Unicode? Does it version directories, allowing the renaming and moving of files? Does it manage atomic change sets, or is each file individually versioned?</p></dd><dt><span class="term"><span class="strong"><strong>Branching</strong></span></span></dt><dd><p>To support more than one release, product variants, concurrent feature work, or to help with logical development, the tool <span class="emphasis"><em>must</em></span> support branching. Does it support sub-branches? Is merging easy, or is it prohibitively difficult?</p></dd><dt><span class="term"><span class="strong"><strong>Platforms</strong></span></span></dt><dd><p>Make sure that it works on all the platforms, hardware configurations, and operating systems that you work with.</p></dd><dt><span class="term"><span class="strong"><strong>Costs and licensing</strong></span></span></dt><dd><p>The SCMS must meet your budget constraints (remember, there are some <span class="emphasis"><em>very</em></span> free source systems). Consider whether there are extra license costs per client. Sometimes these are hidden extra costs; as your team grows, you must pay an SCMS tax.</p></dd><dt><span class="term"><span class="strong"><strong>Audit</strong></span></span></dt><dd><p>The repository must record who makes each change: Don't force everyone into one SCMS user account. The system must support your access policies, allowing you to restrict modification rights as required. Do you want it to provide automatic notification of changes?</p></dd><dt><span class="term"><span class="strong"><strong>Simplicity</strong></span></span></dt><dd><p>The tool must be easy to use, configure, and deploy. This is especially important if you don't have a full-time designated SCMS administrator.</p></dd></dl></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you separate bleeding-edge code under active development from stable code during team development?</strong></span></p></li></ol></div><p>You need a strategy to separate the two in the source control repository. Your choices are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don't separate them. Everyone has bleeding-edge code and must learn to cope with it. Don't check in anything that is obviously broken or nonfunctional.</p></li><li class="listitem"><p>Employ branches. Perform each line of development work on a separate branch, and merge the branches down at appropriate stable points. With this scheme, integration problems are only discovered on a merge; this places the burden of maintenance on the branch merger (which might be the developer working on the branch or a separate system integrator).</p></li><li class="listitem"><p>Use a <span class="emphasis"><em>stable</em></span> label, applied to the entire source tree as a <span class="emphasis"><em>baseline</em></span>. Developers check out this labeled baseline and then move the components they are developing to the latest version. They can then work and commit changes without affecting anyone else's stable source tree. When new development work is deemed stable (fit for public consumption) the label is moved. This change is picked up by other developers when they next synchronize to the baseline.<a class="indexterm" id="IDX-APP-2033"/><a class="indexterm" id="IDX-APP-2034"/></p></li></ul></div><p>Which you chose depends on the facilities of your SCMS and your development culture.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id40"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does your development team make effective use of source control?</strong></span><a class="indexterm" id="IDX-APP-2035"/><a class="indexterm" id="IDX-APP-2036"/></p></li></ol></div><p>Ultimately, does your SCMS help you to develop software easily, and does it facilitate collaboration better than any alternative? Consider tool setup issues like:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Are you using the right tool with the right feature set?</p></li><li class="listitem"><p>Do you have an SCMS administrator, or is it managed on an ad hoc basis?</p></li><li class="listitem"><p>Does everyone know how to use it? Is there an appropriate training scheme?</p></li><li class="listitem"><p>Is the repository integrated with your defect management or fault-tracking tool?</p></li></ul></div><p>Consider asset management issues like:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Is there agreement over the contents of check-in messages and the use of other revision metadata?</p></li><li class="listitem"><p>Do you have a consistent labeling scheme to mark important source tree revisions?</p></li><li class="listitem"><p>Do you have a defined (and documented) branching strategy, with provably correct merging?</p></li><li class="listitem"><p>Can you automatically create release notes from the source repository?</p></li><li class="listitem"><p>Are you able to re-create old builds? Have you addressed when the build toolchain altered, affecting code compatibility?</p></li><li class="listitem"><p>Can you build a product entirely from the contents of the repository, or do you need to supply any extra files?</p></li></ul></div><p>How important are each of these issues to your development team?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is your current work backed up? How important are backups to your development team? When are backups made?</strong></span></p></li></ol></div><p>If you can be bothered to write some code, it must be important, and so it must be backed up. There are several levels at which backups can be employed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Personal workstation backups. These will ensure that no work is lost from your local hard drive or from your source tree sandbox.</p></li><li class="listitem"><p>The server holding the source control repository. This ensures that you won't lose the central source tree files and their revision histories.</p></li></ul></div><p>The latter is the most important: It's criminally insane not to back up a source repository. If your workstation only contains sandbox development areas, then it's not as critical to back it up; there should be little work at any time that isn't checked in (remember to perform <span class="emphasis"><em>little and often</em></span> check-ins), so a loss of a local disk is not critical.</p><p>Consider also how you back up documents and any other non—source tree items you produce. Either check them in to the repository somewhere or make sure that they are stored in logical places on a shared fileserver, somewhere that is backed up. Without revision control, you will have to perform manual document versioning—it's as important to keep historical versions of specifications as it is to version the source code.</p><p>In a multiuser environment, the systems administrator will determine when backups are made. This is usually during the night when there is less computer activity and less information changing on the filesystems being backed up. (But what about multi-continent projects with massive time zone delays?)</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>On which computers is your source code held?</strong></span></p></li></ol></div><p>Obviously, it is held on the development servers and workstations within the company network. These sit safely in the office behind a corporate firewall. But also consider whether your code is held on laptops or on the home machines of telecommuters. How sensitive is the work? How should these machines be digitally and physically protected?</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chatper_19_colon_being_specific"/>Chatper 19: Being Specific</h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id41"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is a poor specification better than no specification at all?</strong></span><a class="indexterm" id="IDX-APP-2037"/></p></li></ol></div><p>A factually incorrect or painfully out-of-date specification is definitely worse. It will send readers down a blind alley and waste a lot of their time. The false information it contains could easily lead to broken code that will cost a lot of time, energy, and money to fix later on.</p><p>If a specification is ambiguous or misses important information, then you're hoping that the readers are experienced enough to recognize the problem and interpret the information carefully. Hopefully they'll all make the same set of assumptions about the missing information. A specification should really stand on its own and not require the intuition of its readership.</p><p>If a specification is too verbose and hides information, then it is probably better (in the long run) to rewrite it.</p><p>The number of factual inaccuracies in your company's specifications will probably frighten you! In my experience, very few companies have a set of consistently good specifications.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How detailed does a good specification have to be?</strong></span></p></li></ol></div><p>The answer is: <span class="emphasis"><em>appropriately detailed</em></span>, where the value of "appropriate" depends on the project, the team, the contents, the quality of related documents, and the lunar phase. Too much detail can definitely be counterproductive: Clearly, if a design specification was too detailed it would <span class="emphasis"><em>be</em></span> the code itself. However, ambiguity in key areas is a road to disaster.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it important that all the documents in a company/project have a common presentation style?</strong></span></p></li></ol></div><p>This is about as important as a uniform code style. That is, there are plenty of more important things to worry about, even if this is the most immediately visible problem with a specification. The importance of visual consistency depends (in part) on whether the documents are released outside the company or not. It looks more professional to ship consistent documents, all written in a similar style with the same template.</p><p>Ultimately, the content of your documents is far more important than their appearance.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How should you store documents? Should you provide an index of them (by type or by project), for example?</strong></span></p></li></ol></div><p>You must be able to quickly locate and retrieve a document that has been written. The actual storage scheme is unimportant, provided that it's well known and universally followed.</p><p>It usually makes sense to store all documents on a single central filestore, and group them by work package (this could be by project, by customer, by component, or by feature). It's helpful to maintain a central list of all stored documents to aid retrieval. However, this adds management overhead, and if not maintained, it will quickly fall out of use.</p><p>Large companies employ people to deal with the storage and retrieval of documents. Though experts at this task, their presence adds more steps to the working procedure and more links in the development process chain.</p><p>It's essential to keep documents under some form of revision control and to monitor which versions of the documents apply to which versions of the code. This is part of a <span class="emphasis"><em>configuration management</em></span> strategy (see "<a class="xref" href="ch18s03.html" title="Configuration Management">Configuration Management</a>" on page 356).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How should you conduct a specification review?</strong></span></p></li></ol></div><p>Document reviews work similarly to code reviews. They generally take place in a meeting, in which case there are some important prerequisites: the correct set of reviewers must be selected, and the material for review should be distributed with enough time for reviewers to adequately prepare.</p><p>Alternatively, the review can be run virtually by soliciting email feedback or by giving a printed copy to each reviewer and receiving his or her marked-up copies for inspection.</p><p>The review will address a number of things; the importance of each should be agreed upon up front:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The quality of the contents. (Is it complete, correct, and so on? This is paramount.)</p></li><li class="listitem"><p>The quality of the presentation style. (Does the document conform to project guidelines?)</p></li><li class="listitem"><p>The quality of the writing style. (Does the author write like Shakespeare or a five year old? For software specifications, both are bad!)<a class="indexterm" id="IDX-APP-2038"/></p></li></ul></div><p>In a meeting context, it's best to discuss general comments about the material and the overall approach first. (But be careful here: It's very easy to get waylaid by more specific technical issues at this stage.) Then the specifics of the material can be discussed. Since all the reviewers have looked at the material beforehand and have already amassed their comments, stepping through, section by section, is usually appropriate. Long sections might be traversed paragraph by paragraph if necessary.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does self-documenting code render all specifications useless? Specific ones?</strong></span><a class="indexterm" id="IDX-APP-2039"/></p></li></ol></div><p>Not entirely. Self-documenting code can avoid the need for design specifications or other maintenance documents. Literate API documentation placed in code comments can even replace functional specifications in <span class="emphasis"><em>some</em></span> cases, if the docs are really thorough. Be careful, though: If you try to write a lot of documentation in literate comments, you'd probably find it easier to type the same information into a word processor. Literate code documentation can never replace a requirements specification or a test specification.</p><p>A comprehensive set of automated test cases <span class="emphasis"><em>could</em></span> replace a software component's test specification, if the test were sufficiently clear and maintainable. However, they are seldom sufficient to replace final product validation tests.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can a document be collaborated on by more than one author?</strong></span></p></li></ol></div><p>With difficulty—few documentation systems provide the same collaborative facilities as a source code control tool. Look at wiki-webs for shared text editing, if you can cope with your documents being in an HTML-derivative form.<a class="indexterm" id="IDX-APP-2040"/></p><p>Otherwise, you have to split the document into sections and give one section to each person. Each section will have an inevitable difference in writing style, quality of content, and will be based on a different set of assumptions; check for this as the work is stitched back together. You might find it easier to split the sections into their own documents and put an umbrella document over the top of them. A leader must be appointed to coordinate the work of several people—to guide the writing process, collate the parts, and encourage people to complete their sections on time.</p><p>An alternative approach is to give one person overall writing responsibility, but with a strong element of peer review. The document's content and structure is agreed upon in meetings beforehand, then the writer retires to craft the document alone, before offering it for group review.</p><p>Be careful with any of these approaches, as writing by committee can produce laborious documents and can take a very long time.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id41"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Who decides on the contents of your documents?</strong></span><a class="indexterm" id="IDX-APP-2041"/><a class="indexterm" id="IDX-APP-2042"/></p></li></ol></div><p>This is defined by a company's development process, by a document template, or by convention. But just because there is a convention doesn't mean that it's actually good practice. Check that the types of documents you write, as well as their contents, are genuinely valuable to your software development process.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Consider your current project. Do you have:</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>A requirements specification?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>An architecture specification?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>A design specification?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>A functional specification?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Any other specification?</strong></span></p></li></ol></div><p><span class="strong"><strong>Are they up to date? Are they complete? Do you know how to get the latest versions? Can you access historical revisions?</strong></span></p></li></ol></div><p>If you don't have some of these or they're substandard, why? How can you remedy the problem?</p><p>Whose job is it to keep the documents up to date? Document versioning is an important aspect of specification generation—make sure that you have a clear plan for doing this.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you revision control your documents? If so, how?</strong></span><a class="indexterm" id="IDX-APP-2043"/></p></li></ol></div><p>Several techniques for managing document revisions are seen in the field:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Store them in an SCMS alongside the code.</p></li><li class="listitem"><p>Use a document (or even a workflow) management system.</p></li><li class="listitem"><p>Use the filesystem: Encode the document revision in its filename (possibly archiving old versions in a separate old directory).</p></li><li class="listitem"><p>Store old revisions in an email attachment sent to a "magic" user (grotesque, but—yes—I <span class="emphasis"><em>have</em></span> seen a company do this).</p></li></ul></div><p>Whichever scheme you use, it must address these issues:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ease of use and document accessibility</p></li><li class="listitem"><p>How to prevent two people from editing the same document at the same time</p></li><li class="listitem"><p>Differentiating the latest release version from the copy currently under development</p></li><li class="listitem"><p>How to avoid accidental deletion or overwriting the wrong document version</p></li><li class="listitem"><p>How to maintain the document history with each change</p></li><li class="listitem"><p>The ease of referencing a specific document revision</p></li></ul></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_20_colon_a_review_to_a_kill"/><a class="xref" href="ch20.html" title="Chapter 20. A REVIEW TO A KILL">Chapter 20</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id42"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does the required number of reviewers depend on the size of the code being reviewed?</strong></span><a class="indexterm" id="IDX-APP-2044"/></p></li></ol></div><p>Not really. If your code is particularly important, then you might consider inviting a few more reviewers, or you might make a particular effort to select reviewers with the most experience.</p><p>However, if the code is too large, you don't need more reviewers—you need a rewrite!</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which tools are useful aids for code reviewing?</strong></span><a class="indexterm" id="IDX-APP-2045"/></p></li></ol></div><p>Common sense, a keen pair of eyes, and an alert brain!</p><p>A number of software tools are also useful. Many different tools can inspect your code and help you to gauge its quality and relative risk to the entire codebase. They can trace the flow of execution, work out which code is executed most often, and calculate a value for each function's code complexity. This last metric is very useful when identifying which pieces of code need to be reviewed as soon as possible. A visual design program may help you to understand the code structure and its dependencies (particularly useful for reviewing class hierarchies in object-oriented languages).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Should you perform a code review before or after running it through source code checking tools?</strong></span></p></li></ol></div><p>After. Reviewers should probably use these tools themselves during review preparation, but authors must perform all possible checking on their own code before releasing it for review. They'd be foolish not to. It makes no sense to waste reviewers' time on code that could have been easily improved. Reserve review time to find more interesting problems.</p><p>If an issue is detected during a review, thought should be given to whether the same issue can be automatically detected in the future using a tool.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What preparation is required for a code review meeting?</strong></span></p></li></ol></div><p>The author has completed the code satisfactorily (otherwise he or she is wasting the reviewers' precious time). The chairman has arranged the meeting properly so that it will run smoothly. More interestingly, before the meeting, each reviewer must have already:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Read (and understood) the specification</p></li><li class="listitem"><p>Become familiar with the code</p></li><li class="listitem"><p>Drawn up a list of issues and questions (this step enforces discipline; if you don't force yourself to do this, it's easy to superficially skim the code and not really know it well enough to review thoroughly)</p></li></ul></div><p>There will always be things you'll find during methodical inspection in a review meeting that you missed beforehand. Even so, this prior preparation is essential to prevent the meeting from wasting a lot of people's time.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do you differentiate review comments to be acted upon immediately from those to chalk up for experience on the next project?</strong></span></p></li></ol></div><p>You must make a decision based on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>How important the identified problem is</p></li><li class="listitem"><p>Whether it's a matter of personal aesthetics or it breaks an agreed best practice</p></li><li class="listitem"><p>How much work is involved in the fix</p></li><li class="listitem"><p>How serious the effect of the change is on the rest of the code</p></li><li class="listitem"><p>How wrong (or misleading) the code is without the fix</p></li><li class="listitem"><p>How fragile or dangerous the change work is</p></li><li class="listitem"><p>Where the project is in the development cycle—you only want to make <span class="emphasis"><em>essential</em></span> changes near a release deadlin.</p></li></ul></div><p>There is no easy rule. If there is any ambiguity in a review meeting, then the chairman makes the ultimate choice. Sometimes problems are rated between <span class="emphasis"><em>must fix and nice to have</em></span>—the author implements as many high priority fixes as feasible in the available time. Other issues may be deferred to the next iteration of the component's development.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do you run a virtual review meeting?</strong></span><a class="indexterm" id="IDX-APP-2046"/></p></li></ol></div><p>Virtual reviews are commonly run by email. The review is organized by a chairman, who is usually the hub of communications. Certainly, the author must <span class="emphasis"><em>not</em></span> be the hub of communications; it would be too easy for him to select which comments are important and to ignore all the things he doesn't like. This is obviously a bad idea.</p><p>There is an important question with this approach: Do the reviewers get to see each other's comments? In a virtual review, debate is much harder to facilitate, especially if emails are directed only to the chairman. However, a 1,000-email conversation broadcast to all reviewers quickly becomes irritating and diverting. As an alternative, you could meet in a virtual chat room, use an instant messenger, a dedicated newsgroup, or a mailing list.</p><p>An alternative virtual review mechanism is to distribute printouts of the code in question. The reviewers scribble comments on their copies and return them to the author. You can run a similar scheme using a wiki: Post your code on the wiki and let reviewers add comments to the page. The format of how you conduct a review is less important than simply doing it somehow.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How useful are informal code reviews?</strong></span></p></li></ol></div><p>Informal reviews are much better than no review at all, but since they are less thorough, they'll inevitably find fewer faults (for the same quality of code reviewer).</p><p>Although terms are not officially defined, McConnell describes two types of informal review: (McConnell 96)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Walkthroughs</strong></span></span></dt><dd><p>These are very informal gatherings where programmers look over the code together. This could be in front of an editor, with changes made on the fly.</p></dd><dt><span class="term"><span class="strong"><strong>Code reading</strong></span></span></dt><dd><p>The author distributes copies of the code to a set of reviewers, who make comments on it and send them back to the author.<a class="indexterm" id="IDX-APP-2047"/></p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id42"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does your project perform code reviews? Does it perform</strong></span> <span class="emphasis"><em>enough</em></span> <span class="strong"><strong>code reviews?</strong></span><a class="indexterm" id="IDX-APP-2048"/><a class="indexterm" id="IDX-APP-2049"/></p></li></ol></div><p>Even if it makes a vaguely regular event of code reviews, there probably still isn't enough reviewing going on. Too little value is put on this practice; if the code seems to work, then people think that there's no point wasting valuable time reviewing it.</p><p>This attitude is careless. The time taken to track lingering code faults is often far greater than the effort of review. Code reviews are a sensible and pragmatic way to take control of your development process and ensure that your software is of high quality.</p><p>What can you do to improve on this in your current project?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you work with any programmers whose code is considered to be above review?</strong></span></p></li></ol></div><p>A respected Guru programmer (see "<a class="xref" href="ch16.html#the_guru" title="The Guru">The Guru</a>" on page 299) is often held in awe, and no one ever suggests that his work should be reviewed. No one probably dares. This reverence is misguided and dangerous.<a class="indexterm" id="IDX-APP-2050"/></p><p>In my experience, Gurus write some of the most review-worthy code you'll ever see: full of deep, incomprehensible, unmaintainable magic. The fact that they never put their code forward for review illustrates their incorrect attitude toward the task and the team. No one's code is above review; all code should be carefully scrutinized.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What percentage of your code has ever been subject to code review?</strong></span></p></li></ol></div><p>Unless you're a very unusual beast, this amount is undoubtedly small. How formal have the reviews been? How useful was each review, and how much did it contribute to the final quality of the code?</p><p>How much of your unreviewed code was pair programmed? How much <span class="emphasis"><em>should</em></span> have been reviewed? How much unreviewed code was critically important commercial code? How many bugs slipped through into production software, and how many of those bugs caused later problems?</p><p>Even if it's not a part of your project culture to run code reviews, make a point of inviting formal review for your work. Don't worry if no one else does it—your code will be exceptional by comparison!</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_21_colon_how_long_is_a_piece_of_string_question"/><a class="xref" href="ch21.html" title="Chapter 21. HOW LONG IS A PIECE OF STRING?">Chapter 21</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id43"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How can you rescue a slipping project and bring it back on track?</strong></span><a class="indexterm" id="IDX-APP-2051"/></p></li></ol></div><p>One technique to protect yourself from a failing project is to run, fast, like a rat from a sinking ship. It's not very professional, though!</p><p>Once a project is behind schedule, there's rarely anything you can do to bring it back on track—that is, unless there was a monster amount of contingency allocated. You might instead consider these strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Reschedule the project; see if you can agree a later delivery date with the customer.</p></li><li class="listitem"><p>De-scope the first release, possibly agreeing to a later release with the missing functionality. It's better to commit to doing less stuff, but doing it better and within the allotted time, than to implement loads of unnecessary functionality and slip badly.</p></li></ul></div><p>Don't blindly throw more developers at the project to speed things up. Brooks lucidly described how bad this idea is, especially when a project is failing. (Brooks 95) It would take the existing developers time to get the new guys up to speed, and there would then be extra overhead in managing the larger team. Any benefit would almost certainly be outweighed by the costs of new personnel.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What's the correct response to having a deadline imposed on you before feasibility or planning work commences?</strong></span><a class="indexterm" id="IDX-APP-2052"/></p></li></ol></div><p>Tact! The fixed delivery deadline might be a valid business requirement: You'll make money if you ship software on time; you'll make nothing if you don't. You can't always do the theologically correct thing and move a deadline or adjust the scope of the work.</p><p>Sometimes it helps your design effort to have early visibility of the anticipated project deadline. This information shows you how pure and well-thought-out your design can be, and it will help you to scope out the amount of code required and whether future flexibility can be considered. Ultimately, it will show you whether or not you need to hack out a quick-fix solution or the elegantly engineered code you always want to write. It might help you to make buy versus build decisions and to set the final quality expectations for the delivered software.</p><p>Make it clear that this is not an ideal way to develop software. <span class="emphasis"><em>Hopefully</em></span> someone will listen, and the managers will learn to stop promising such risky deadlines—it's a careless form of gambling with the success of a project and the future of an organization.<a class="indexterm" id="IDX-APP-2053"/><a class="indexterm" id="IDX-APP-2054"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do you ensure that a development plan is genuinely useful?</strong></span></p></li></ol></div><p>High-quality development plans are:<a class="indexterm" id="IDX-APP-2055"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Accurate</strong></span></span></dt><dd><p>They include all the tasks required to build the software and are based on sound timescale estimates.</p></dd><dt><span class="term"><span class="strong"><strong>Fine-grained</strong></span></span></dt><dd><p>There aren't a few large tasks with rough estimates, but many small tasks carefully sequenced. Our confidence in the accuracy of a small task's timescale is higher, so the quality of the overall plan will be higher.</p><p>If you think that a task comprises several parts (e.g., it is dependent on a third party and splits into the third-party release milestone, followed by a period of integration and bug fixing) then make this explicit on the plan.</p></dd><dt><span class="term"><span class="strong"><strong>Agreed</strong></span></span></dt><dd><p>Everyone buys into the plan: Management is happy with the level of inherent risk, while programmers agree that the timescales are accurate, no tasks are missing, and all the dependencies are correctly mapped out.</p></dd><dt><span class="term"><span class="strong"><strong>Visible</strong></span></span></dt><dd><p>They are used to make important decisions by individual developers and by managers. Timescale changes are communicated through the plan. The plan is versioned, and progress against the plan is recorded clearly.</p></dd><dt><span class="term"><span class="strong"><strong>Monitored</strong></span></span></dt><dd><p>If the schedule is poorly monitored, the timescale estimates become a worthless statistic. Progress must be checked against the plan. The course of the development effort is steered by this measurement.</p></dd></dl></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Why do different programmers work at different rates? How can you reflect this on the plan?</strong></span></p></li></ol></div><p>Programmers differ in many ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They have different technical abilities and reason about problems in different ways. This affects the quality of work produced.<a class="indexterm" id="IDX-APP-2056"/></p></li><li class="listitem"><p>Different levels of experience lead to different design choices.</p></li><li class="listitem"><p>People have different levels of commitment: responsibility for old projects, levels of enthusiasm for the company or project, respect for the craft of software construction, and external commitments (family pressures, socializing, etc.).</p></li><li class="listitem"><p>Some people are highly motivated and prepared to put in hours of overtime to get a project finished. Others want to work their minimum hours and then go party.</p></li></ul></div><p>It's not just the duration of a work package that differs between programmers. The quality of their code, the soundness of their design, and the bug count of their programs will differ too. It will even differ when the same programmer attempts the same task multiple times—with more experience, a programmer will work better the second time.<a class="indexterm" id="IDX-APP-2057"/></p><p>To reflect this on a project plan, check which developer each task is allocated to. If the task is not within his or her core competency, then increase the timescale estimate, or add in a block of contingency to the end. Consider putting in an extra up-front task to get the developer up to speed with the work, and make sure that you include any training that might be required.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id43"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What percentage of the projects that you've worked on have run to schedule?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>For those that did: What contributed to the success of the planning effort?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>For those that failed: What were the main problems?</strong></span></p></li></ol></div></li></ol></div><p>It's easier to characterize failure than success; you'll identify the single reason that something went wrong far more easily than a delicate balance of things working together well. When everything on a project is healthy, the whole thing appears to just work.</p><p>Iterative and incremental development helps to accommodate problems and de-risk the plan. Well-understood work packages, a fine-grained plan, and a good initial design are also key. High-quality testing performed early and often makes development much safer. Talented developers are also very useful!</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How accurate are your timescale estimates? How far off target are you normally?</strong></span></p></li></ol></div><p>This is a skill that you can continually improve. Experience is a great teacher. Hopefully, your later estimates have been more accurate than your earlier ones. Is this the case?</p><p>If you haven't yet been asked to make timescale estimates, start practicing now! Make a mini-plan for your current development task. Estimate timescales for the small parts of this mini-plan and see how accurate you are. This has the added benefit of making you think carefully about what you're doing, putting a good initial design into place. It will also force you to leave enough time for testing, debugging, and documentation—all good things.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_22_colon_recipe_for_a_program"/><a class="xref" href="ch22.html" title="Chapter 22. RECIPE FOR A PROGRAM">Chapter 22</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id44"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>How do the choices of programming style and development process influence one another?</strong></span><a class="indexterm" id="IDX-APP-2058"/><a class="indexterm" id="IDX-APP-2059"/><a class="indexterm" id="IDX-APP-2060"/><a class="indexterm" id="IDX-APP-2061"/><a class="indexterm" id="IDX-APP-2062"/><a class="indexterm" id="IDX-APP-2063"/><a class="indexterm" id="IDX-APP-2064"/><a class="indexterm" id="IDX-APP-2065"/><a class="indexterm" id="IDX-APP-2066"/><a class="indexterm" id="IDX-APP-2067"/></p></li></ol></div><p>They don't need to have any bearing on one another, but hopefully they're the kinds of things you think about together as you begin a project.</p><p>Iterative processes are easier to implement with programming methodologies that support componentization—the object-oriented paradigm. Linear processes are suitable for all types of programming styles, but are not necessarily the best match.</p><p>The developers' prior experiences and their personal preferences for programming style will have the greatest affect on these choices.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which is the best programming style?</strong></span></p></li></ol></div><p>Trick question! If you actually gave an answer, put down this book and give yourself 30 lashes with a wet noodle.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which is the best development process?</strong></span></p></li></ol></div><p>You can't possibly have fallen for this too? Electric shock therapy with a 9-volt battery is your only option.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Where does each development process listed in this chapter fall on the classification axes we saw in "<a class="xref" href="ch22s03.html" title="Development Processes">Development Processes</a>" on page 425?</strong></span><a class="indexterm" id="IDX-APP-2068"/></p></li></ol></div><p>First, a quick recap: The thick/thin classification relates to the bureaucracy and paperwork involved in a process, <span class="emphasis"><em>sequencing</em></span> describes how linear and predictive the process is, and the <span class="emphasis"><em>design direction</em></span> determines whether design starts from the minuscule implementation details or from the grand overview:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Ad hoc</strong></span></span></dt><dd><p>Who knows how to classify this mess? An ad hoc process could be anywhere on any axis, even constantly moving. Ad hoc developers are typically low on bureaucracy, but with no discipline at all, things fall through the cracks or are repeated time and time again. There's no sequencing whatsoever, so this anti-process rates off the scale, and if there <span class="emphasis"><em>is</em></span> any design, then it probably has nothing to do with what is actually being built, anyway!<a class="indexterm" id="IDX-APP-2069"/><a class="indexterm" id="IDX-APP-2070"/></p></dd><dt><span class="term"><span class="strong"><strong>Waterfall model</strong></span></span></dt><dd><p>This is a reasonably thick, very linear process. It generally leads to a top-down design, although it doesn't enforce this.</p></dd><dt><span class="term"><span class="strong"><strong>SSADM</strong></span></span></dt><dd><p>This scores full marks on the thick scale—there's paperwork and heavily documented steps aplenty here. The sequencing axis is full throttle toward linear.</p></dd><dt><span class="term"><span class="strong"><strong>V model</strong></span></span></dt><dd><p>Another thick, linear process (although some parts of this process are explicitly parallelized for efficiency). As with other waterfall variants, it leans toward top-down design.<a class="indexterm" id="IDX-APP-2071"/></p></dd><dt><span class="term"><span class="strong"><strong>Prototyping</strong></span></span></dt><dd><p>An explicitly cyclical process (although by fixing the number of prototypes anticipated, we can enforce some level of linearity on the development process). This tends to edge toward the thin camp, sometimes too much so: Prototypes by themselves are not sufficient to capture user requirements or design decisions, so when prototyping, it's dangerously easy to avoid capturing decisions in specifications.<a class="indexterm" id="IDX-APP-2072"/></p></dd><dt><span class="term"><span class="strong"><strong>Iterative and incremental</strong></span></span></dt><dd><p>Again nonlinear by design, this process can be as bureaucratic as you like, but some variants (especially as seen in the agile movement) can be quite thin. Iterative and incremental processes tend to stick in the middle of the design direction axis—at each iteration, we perform high-level design right through to low-level design. These design decisions are revised in the next cycle, and additional work repeat the top-level and bottom-level design.</p></dd><dt><span class="term"><span class="strong"><strong>Spiral model</strong></span></span></dt><dd><p>A thick version of an iterative and incremental process.<a class="indexterm" id="IDX-APP-2073"/></p></dd><dt><span class="term"><span class="strong"><strong>Agile methodologies</strong></span></span></dt><dd><p>Agile processes are thin and nonlinear. They do not fix a design direction; you are constantly redirecting the design. Compare design to driving to Paris: In a traditional process, you would point your car at Paris and drive; in an agile process, you'd start driving and make constant streering tweaks. You <span class="emphasis"><em>might</em></span> even map out sections of the middle of the journey before determining the best route out of your hometown.<a class="indexterm" id="IDX-APP-2074"/></p></dd></dl></div><p>Remember that an organization's implementation of a specific process model will be inevitably tailored to its particular ways of working. (This is perfectly healthy.) These tweaks can make a significant difference. For example, you might base your development around the V model but aim to make the interphase handoff procedure as lightweight as possible, to reduce unnecessary bureaucracy.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>If development processes and programming styles are recipes, what would a software development cookbook look like?</strong></span></p></li></ol></div><p>It would probably look dangerously like a software engineering textbook. There probably wouldn't be that many mouth-watering pictures! Just as the Naked Chef 's<sup>[<a class="footnote" href="#ftn.APP-FN-17" id="APP-FN-17">17</a>]</sup> recipes differ from Rachael Ray's, you could imagine a number of different approaches to a mythical software development cookbook.</p><p>You don't really see that many software development cookbooks because people don't shop around for new recipes that often. These things only tend to spring up when a marketing machine can gather sufficient momentum behind the next big thing.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>With a suitable process, can software construction become a predictable, repeatable task?</strong></span></p></li></ol></div><p>We're still not in a position where the software industry is able to make this claim. No matter how hard we try to homogenize the development process, the quality of code produced is ultimately determined by the quality (e.g., experience, ability, intuition, and flair) and the particular mood (e.g., ability to concentrate, being in the zone or constantly interrupted, see page 414) of the programmers doing the work. A master craftsman will produce more elegant, robust, and well-fashioned designs than a fresh apprentice.<a class="indexterm" id="IDX-APP-2075"/></p><p>With such variance, it's hard to reproducibly create software, even with the most prescriptive process. Using the same programmers, the same process, and trying to produce the same piece of software, you'll never get the exact same result. On different days, the team will make different choices, which will lead to radically different software with different inherent faults and strengths. (This point is hypothetical anyway; the same team would learn from its mistakes the first time around and create a different—probably better—piece of software on its second attempt.)</p><p>Agile methods exploit this, and celebrate the unpredictability of software construction. They attempt to address uncertainty by choosing pragmatic approaches that minimize the inherent risk of an unpredictable task.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id44"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What development process and programming language style are you currently using?</strong></span></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Has it been formally agreed upon by the development team, or do you use it by convention?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>How was it chosen? Was it chosen specifically for this project, or is it the recipe you always use?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Is it documented anywhere?</strong></span></p></li><li class="listitem"><p><span class="strong"><strong>Does the team stick to the process? When problems arise and your back is against the wall, do you maintain the process, or is all ivory tower theory ignored in a rush to produce something—anything?</strong></span></p></li></ol></div></li></ol></div><p>This question is probing how organized your development team is—and whether you develop software on purpose or by accident. Do you really <span class="emphasis"><em>know</em></span> how you produce software, or do you still rely on the heroic efforts of a few key team members to get your work done?</p><p>Can you point to a specific reference for your way of working? Is it documented? Is it understood? Is it understood by <span class="emphasis"><em>all</em></span> the developers, by <span class="emphasis"><em>all</em></span> the process managers, and by <span class="emphasis"><em>all</em></span> those who play some part in the construction process?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are your current processes and styles appropriate? Are they the best way for you to develop your software right now?</strong></span></p></li></ol></div><p>If you don't know how you're producing software, or if you're not using the best approach, what would be better, and why?</p><p>Watch for the danger of ad hoc methods. I've seen numerous organizations where there is no agreed method; one person produces wholly OO designs while another avoids OO and performs structural design. The code produced is ugly and inconsistent.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Does your organization appreciate that there are other development models that might be worth investigating?</strong></span></p></li></ol></div><p>Understand who makes decisions about this kind of thing—is it the developers, the software team leader, or the managers? Are these people sufficiently informed about software development processes? Understand why they've chosen to work in the current way: what problems have they already solved? Often the reason for an odd development procedure is historical—organizations evolve a set of working practices, they don't fashion them consciously.</p><p>What would it take to persuade your organization to adopt another process model?</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-FN-17" id="ftn.APP-FN-17">17</a>] </sup>If you think that sounds rude, see <a class="ulink" href="http://www.jamieoliver.com">www.jamieoliver.com</a>.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_23_colon_the_outer_limits"/><a class="xref" href="ch23.html" title="Chapter 23. THE OUTER LIMITS">Chapter 23</a></h1></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id45"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which of the programming niches we've looked at here are particularly similar or share common characteristics? Which are particularly different?</strong></span><a class="indexterm" id="IDX-APP-2076"/><a class="indexterm" id="IDX-APP-2077"/><a class="indexterm" id="IDX-APP-2078"/></p></li></ol></div><p>There is more in common than you might think. Crossovers include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Games and web applications could both be considered specific forms of applications programming.</p></li><li class="listitem"><p>Web programming is a form of distributed programming.</p></li><li class="listitem"><p>Some enterprise work can take the form of web applications.</p></li><li class="listitem"><p>Some systems implementation is for embedded platforms.</p></li><li class="listitem"><p>Numerical work is sometimes optimized by parallelizing and distributing the computation.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which of these programming disciplines is hardest?</strong></span></p></li></ol></div><p>Each type of programming presents a different set problems, and every individual program is complex in its own way. Otherwise, programming would take very little skill and any idiot could do it. (The fact that many idiots <span class="emphasis"><em>do</em></span> program doesn't bear discussion here!)</p><p>The "harder" programming worlds could be considered to be the ones that demand more formal processes to ensure adequate quality is met. For example, the world of safety-critical software (mentioned in "<a class="xref" href="ch23s10.html" title="In a Nutshell">In a Nutshell</a>" on page 456) is particularly fraught. Watertight specifications, very formal development and testing models, and certification to regulated standards are essential in this world, along with the inclusion of reliable failsafes.<a class="indexterm" id="IDX-APP-2079"/></p><p>Numerical work, in particular, would be hard for someone who doesn't have a head for math and designing complex algorithms. It requires extra statistical or scientific skills.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Is it important to be an expert in one particular area or to have a good grounding in all of them without a particular specialism?</strong></span></p></li></ol></div><p>An understanding of each area is helpful. However, to truly excel in a given area requires specific skills and expertise that can only be gained from experience in the trenches. To get this good experience, you'll probably have to focus on one particular work area. Vincent van Gogh remarked, "If one is the master of one thing and understands one thing well, one has at the same time insight into and understanding of many things." Learn the particular intricacies that set your discipline apart from the others.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Which programming niche should trainee programmers be introduced to?</strong></span></p></li></ol></div><p>This is seldom thought about by the writers of programming courses. It's a sad oversight; many courses are not tailored to programming in the Real World—more to some theoretical, androgynous branch of programming. Of course, this makes teaching programming much easier, and there are fewer issues to confuse the trainee with. But it is important to understand how to make appropriate coding choices when you're in the thick of the software factory, and someone has to teach this.</p><p>Compared to the other programming areas, applications programming is relatively unencumbered by specific rituals and practices, so this is presumably the easiest area to introduce programmers to. Because trainees rarely appreciate the wider world of software development, this is probably what they'd expect to learn anyway.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id45"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>What programming arena are you working in right now? How does it affect the code that you're writing? What specific design and implementation decisions has it led you to make?</strong></span></p></li></ol></div><p>It's important to understand the type of code you write so you can make the correct programming decisions. If you can't explain how your code has been shaped by the demands of the problem domain, then you may not have been thinking hard enough about what you're doing. Software has to survive in—and must therefore be shaped by—its environment.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Do you have experience working in more than one programming discipline? How easy was it for you to switch mindsets and apply appropriate techniques in a different world?</strong></span></p></li></ol></div><p>Be careful of the temptation to dismiss these differences and hop thoughtlessly from one domain to another. It can lead you to write bad code. You probably won't realize that your code isn't appropriate until the end of the game, when you're working on tedious bugs or trying to optimize your system to get it to meet the original requirements (e.g., code size or scalability). If that's when you realize your work isn't molded to its environment, then you're in a sticky position.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Are any of the people you work with unaware of the forces that shape the particular kind of code you write? Do you have embedded software being written by programmers who only understand applications work? What can you do about this?</strong></span></p></li></ol></div><p>Programmers who don't tailor their work to the requirements of the problem domain endanger your project. If they don't understand the inherent constraints (scalability, performance, code size, interoperability, and so on), their code will not match the specifications, and they will be weak links in the development chain.</p><p>Code and design review will help to catch this, as would pair programming.</p></div></div>
<div class="bibliography"><div class="titlepage"><div><div><h1 class="title"><a id="bibliography"/>BIBLIOGRAPHY</h1></div></div></div><div class="bibliodiv"><div class="bibliomixed"><a id="id2472692"/><p class="bibliomixed">
(Alexander 79)
<span class="author"><span class="surname">Alexander</span><span class="firstname">Christopher</span></span>. <span class="title">The Timeless Way of Building</span>. <span class="publisher"><span class="publishername">Oxford University Press</span></span>, <span class="date">1979</span>. 0195024028.
</p></div><div class="bibliomixed"><a id="id2472714"/><p class="bibliomixed">
(Aristotle)
<span class="author"><span class="surname">Aristotle</span></span> (384-322 bc). <span class="title">Rhetoric.</span> Book 1, Chapter 11, Section 20. 350 bc.
</p></div><div class="bibliomixed"><a id="id2472726"/><p class="bibliomixed">
(Beck 99)
<span class="author"><span class="surname">Beck</span><span class="firstname">Kent.</span></span> <span class="title">Extreme Programming Explained.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1999</span>. 0201616416.
</p></div><div class="bibliomixed"><a id="id2472747"/><p class="bibliomixed">
(Belbin 81)
<span class="author"><span class="surname">Belbin</span><span class="firstname">Meredith.</span></span> <span class="title">Management Teams: Why They Succeed or Fail.</span> <span class="publisher"><span class="publishername">Butterworth Heinemann</span></span>, <span class="date">1981.</span> 0750659106.
</p></div><div class="bibliomixed"><a id="id2472768"/><p class="bibliomixed">
(Bentley 82)
<span class="author"><span class="surname">Bentley</span><span class="firstname">Jon Louis.</span></span> <span class="title">Writing Efficient Programs.</span> <span class="publisher"><span class="publishername">Prentice Hall Professional</span></span>, <span class="date">1982</span>. 013970244X.
</p></div><div class="bibliomixed"><a id="id2472790"/><p class="bibliomixed">
(Bersoff et al. 80)
<span class="author"><span class="surname">Bersoff</span></span><span class="author"><span class="surname">Edward</span></span><span class="author"><span class="firstname">Vilas Henderson</span></span><span class="author"><span class="firstname">Stanley Siegel.</span></span> <span class="title">Software Configuration Management: An Investment in Product Integrity.</span> <span class="publisher"><span class="publishername">Longman Higher Education</span></span>, <span class="date">1980.</span> 0138217696.
</p></div><div class="bibliomixed"><a id="id2472820"/><p class="bibliomixed">
(Boehm 76)
<span class="author"><span class="surname">Boehm</span><span class="firstname">Barry.</span></span> "<span class="subtitle">Software Engineering.</span>" <span class="title">IEE Transactions on Computers</span>. <span class="volumenum">C-25</span>, <span class="issuenum">12</span>, <span class="pagenums">1,226-1,241.</span> <span class="date">1976.</span> http://www.computer.org/tc.
</p></div><div class="bibliomixed"><a id="id2472850"/><p class="bibliomixed">
(Boehm 81)
<span class="author"><span class="surname">Boehm</span><span class="firstname">Barry.</span></span> <span class="title">Software Engineering Economics.</span> <span class="publisher"><span class="publishername">Prentice Hall</span></span>, <span class="date">1981.</span> 0138221227.
</p></div><div class="bibliomixed"><a id="id2472872"/><p class="bibliomixed">
(Boehm 87)
<span class="author"><span class="surname">Boehm</span><span class="firstname">Barry.</span></span> "<span class="subtitle">Improving Software Productivity.</span>" <span class="title">IEEE computer</span>, <span class="volumenum">20</span>, <span class="issuenum">9.</span> <span class="date">1987</span>.
</p></div><div class="bibliomixed"><a id="id2472898"/><p class="bibliomixed">
(Boehm 88)
<span class="author"><span class="surname">Boehm</span><span class="firstname">Barry.</span></span> "<span class="subtitle">A Spiral Model of Software Development and Enhancement.</span>" <span class="title">IEEE computer</span>, <span class="volumenum">21</span>. <span class="date">May 5, 1988</span>.
</p></div><div class="bibliomixed"><a id="id2472921"/><p class="bibliomixed">
(Booch 97)
<span class="author"><span class="surname">Booch</span><span class="firstname">Grady.</span></span> <span class="title">Object Oriented Analysis and Design With Applications.</span> <span class="publisher"><span class="publishername">Benjamin/Cummings</span></span>, <span class="date">1994</span>. <span class="edition">Second Edition.</span> 0805353402.
</p></div><div class="bibliomixed"><a id="id2472946"/><p class="bibliomixed">
(Briggs 80)
<span class="author"><span class="surname">Briggs Myers</span><span class="firstname">Isabel.</span></span> <span class="title">Gifts Differing: Understanding Personality Type.</span> <span class="publisher"><span class="publishername">Consulting Psychologist's Press</span></span>, <span class="date">1980.</span> 0891060111.
</p></div><div class="bibliomixed"><a id="id2472968"/><p class="bibliomixed">
(Brooks 95)
<span class="author"><span class="surname">Brooks</span><span class="firstname">Frederick P.</span></span> Jr. <span class="title">The Mythical Man Month.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1995</span>. <span class="edition">Anniversary Edition.</span> 0201835959.
</p></div><div class="bibliomixed"><a id="id2472993"/><p class="bibliomixed">
(DeMarco 99)
<span class="author"><span class="surname">DeMarco</span></span><span class="author"><span class="surname">Tom</span></span><span class="author"><span class="firstname">Timothy Lister.</span></span> <span class="title">Peopleware: Productive Projects and Teams.</span> <span class="publisher"><span class="publishername">Dorset House</span></span>, <span class="date">1999.</span> <span class="edition">Second Edition.</span> 0932633439.
</p></div><div class="bibliomixed"><a id="id2473023"/><p class="bibliomixed">
(Dijkstra 68)
<span class="author"><span class="surname">Dijkstra</span><span class="firstname">Edsger W.</span></span> "<span class="subtitle">Go To Statement Considered Harmful.</span>" <span class="title">Communications of the ACM</span>, <span class="volumenum">11</span>, <span class="issuenum">3</span>, <span class="pagenums">147-148</span>. <span class="date">1968</span>.
</p></div><div class="bibliomixed"><a id="id2473052"/><p class="bibliomixed">
(Doxygen)
<span class="author"><span class="surname">van Heesch</span><span class="firstname">Dimitri.</span></span> <span class="title">Doxygen.</span> http://www.doxygen.org.
</p></div><div class="bibliomixed"><a id="id2473066"/><p class="bibliomixed">
(Economist 01)
"<span class="subtitle">Agility counts.</span>" <span class="title">The Economist.</span> <span class="date">September 20, 2001.</span>
</p></div><div class="bibliomixed"><a id="id2473079"/><p class="bibliomixed">
(Fagan 76)
<span class="author"><span class="surname">Fagan</span><span class="firstname">Michael.</span></span> "<span class="subtitle">Design and code inspections to reduce errors in program development.</span>" <span class="title">IBM Systems Journal</span>, <span class="volumenum">15</span>, <span class="issuenum">3</span>. <span class="date">1976</span>.
</p></div><div class="bibliomixed"><a id="id2473106"/><p class="bibliomixed">
(Feldman 78)
<span class="author"><span class="surname">Feldman</span><span class="firstname">Stuart.</span></span> "<span class="subtitle">Make—A Program for Maintaining Computer Programs.</span>" <span class="title">Bell Laboratories Computering Science Technical Report 57.</span> <span class="date">1978</span>.
</p></div><div class="bibliomixed"><a id="id2473128"/><p class="bibliomixed">
(Fowler 99)
<span class="author"><span class="surname">Fowler</span><span class="firstname">Martin.</span></span> <span class="title">Refactoring: Improving the Design of Existing Code.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1999</span>. 0201485672.
</p></div><div class="bibliomixed"><a id="id2473149"/><p class="bibliomixed">
(Gamma et al. 94)
<span class="author"><span class="surname">Gamma</span></span><span class="author"><span class="surname">Erich</span></span><span class="author"><span class="surname">Richard Helm</span></span><span class="author"><span class="surname">Ralph Johnson</span></span><span class="author"><span class="firstname">John Vlissides.</span></span> <span class="title">Design Patterns: Elements of Reusable Object-Oriented Software.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1994</span>. 0201633612.
</p></div><div class="bibliomixed"><a id="id2473183"/><p class="bibliomixed">
(Gosling et al. 94)
<span class="author"><span class="surname">Gosling</span></span><span class="author"><span class="surname">James</span></span><span class="author"><span class="surname">Bill Joy</span></span><span class="author"><span class="surname">Guy Steele</span></span><span class="author"><span class="firstname">Gilad Bracha.</span></span> <span class="title">The Java Language Specification.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">2000</span>. <span class="edition">Second Edition.</span> 0201310082. http://java.sun.com.
</p></div><div class="bibliomixed"><a id="id2473219"/><p class="bibliomixed">
(Gould 75)
<span class="author"><span class="surname">Gould</span><span class="firstname">John.</span></span> "<span class="subtitle">Some Psychological Evidence on How People Debug Computer Programs.</span>" <span class="title">International Journal of Man-Machine Studies.</span> <span class="date">1975</span>.
</p></div><div class="bibliomixed"><a id="id2473240"/><p class="bibliomixed">
(Groom 94)
<span class="author"><span class="surname">Groom</span><span class="firstname">Winston.</span></span> <span class="title">Forrest Gump.</span> <span class="publisher"><span class="publishername">Black Swan</span></span>, <span class="date">1994</span>. 0552996092.
</p></div><div class="bibliomixed"><a id="id2473261"/><p class="bibliomixed">
(Hoare 81)
<span class="author"><span class="surname">Hoare</span><span class="firstname">Charles.</span></span> "<span class="subtitle">The Emperor's Old Clothes.</span>" <span class="title">Communications of the ACM</span>, <span class="volumenum">24</span>, <span class="issuenum">2</span>. <span class="publisher"><span class="publishername">ACM</span></span>, <span class="date">1981</span>.
</p></div><div class="bibliomixed"><a id="id2473291"/><p class="bibliomixed">
(Humphrey 97)
<span class="author"><span class="surname">Humphrey</span><span class="firstname">Watts S.</span></span> <span class="title">Introduction to the Personal Software Process.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1997</span>. 0201548097.
</p></div><div class="bibliomixed"><a id="id2473313"/><p class="bibliomixed">
(Humphrey 98)
<span class="author"><span class="surname">Humphrey</span><span class="firstname">Watts S.</span></span> "<span class="subtitle">The Software Quality Profile.</span>" <span class="title">Software Quality Professional</span>. <span class="date">December 1998</span>. http://www.sei.cmu.edu/publications/articles/quality-profile/.
</p></div><div class="bibliomixed"><a id="id2473335"/><p class="bibliomixed">
(Hunt Davis 99)
<span class="author"><span class="surname">Hunt</span></span><span class="author"><span class="surname">Andrew</span></span><span class="author"><span class="firstname">David Thomas.</span></span> <span class="title">The Pragmatic Programmer.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1999</span>. 020161622X.
</p></div><div class="bibliomixed"><a id="id2473361"/><p class="bibliomixed">
(IEEE 84)
<span class="title">IEEE Standard Glossary of Software Engineering Terminology.</span> <span class="publisher"><span class="publishername">ANSI/IEEE</span></span>, <span class="date">1984</span>. ANSI/IEEE Standard 729.
</p></div><div class="bibliomixed"><a id="id2473376"/><p class="bibliomixed">
(ISO 84)
<span class="title">ISO7498:1984(E) Information Processing Systems—Open Systems Interconnection—Basic Reference Model.</span> <span class="publisher"><span class="publishername">International Standard for Information Systems</span></span>, <span class="date">1984</span>. ISO Standard ISO 7498:1984(E).
</p></div><div class="bibliomixed"><a id="id2473395"/><p class="bibliomixed">
(ISO 98)
<span class="title">ISO/IEC 14882:1998, Programming Languages—C++.</span> <span class="publisher"><span class="publishername">International Standard for Information Systems</span></span>, <span class="date">1998</span>. ISO Standard ISO/IEC 14882:1998.
</p></div><div class="bibliomixed"><a id="id2473411"/><p class="bibliomixed">
(ISO 99)
<span class="title">ISO/IEC 9899:1999, Programming Languages—C.</span> <span class="publisher"><span class="publishername">International Standard for Information Systems</span></span>, <span class="date">1999</span>. ISO Standard ISO/IEC 9899:1999.
</p></div><div class="bibliomixed"><a id="id2473427"/><p class="bibliomixed">
(ISO 05)
<span class="title">ISO/IEC 23270:2003, Information technology—C# Language Specification.</span> <span class="publisher"><span class="publishername">International Standard for Information Systems</span></span>, <span class="date">2005</span>. ISO Standard ISO/IEC 23270:2003.
</p></div><div class="bibliomixed"><a id="id2473443"/><p class="bibliomixed">
(Jackson 75)
<span class="author"><span class="surname">Jackson</span><span class="firstname">M.A.</span></span> <span class="title">Principles of Program Design.</span> <span class="publisher"><span class="publishername">Academic Press</span></span>, <span class="date">1975</span>. 0123790506.
</p></div><div class="bibliomixed"><a id="id2473464"/><p class="bibliomixed">
(Javadoc)
<span class="title">Javadoc.</span> <span class="publisher"><span class="publishername">Sun Microsystems, Inc.</span></span> http://java.sun.com/products/jdk/javadoc".
</p></div><div class="bibliomixed"><a id="id2473476"/><p class="bibliomixed">
(Kernighan Pike 99)
<span class="author"><span class="surname">Kernighan</span><span class="firstname">Brian W.</span></span><span class="author"><span class="firstname">Rob Pike.</span></span> <span class="title">The Practice of Programming.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1999</span>. 020161586X.
</p></div><div class="bibliomixed"><a id="id2473501"/><p class="bibliomixed">
(Kernighan Plaugher 76)
<span class="author"><span class="surname">Kernighan</span><span class="firstname">Brian W.</span></span><span class="author"><span class="firstname">P.J. Plaugher.</span></span> <span class="title">Software Tools.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1976</span>. 020103669X.
</p></div><div class="bibliomixed"><a id="id2473526"/><p class="bibliomixed">
(Kernighan Plaugher 78)
<span class="author"><span class="surname">Kernighan</span><span class="firstname">Brian W.</span></span><span class="author"><span class="firstname">P.J. Plaugher.</span></span> <span class="title">The Elements of Programming Style.</span> <span class="publisher"><span class="publishername">McGraw-Hill</span></span>, <span class="date">1978</span>. 0070341990.
</p></div><div class="bibliomixed"><a id="id2473552"/><p class="bibliomixed">
(Kernighan Ritchie 88)
<span class="author"><span class="surname">Kernighan</span><span class="firstname">Brian W.</span></span><span class="author"><span class="firstname">Dennis M.</span><span class="surname">Ritchie.</span></span> <span class="title">The C Programming Language.</span> <span class="publisher"><span class="publishername">Prentice Hall</span></span>, <span class="date">1988</span>. <span class="edition">Second Edition.</span> 0131103628.
</p></div><div class="bibliomixed"><a id="id2473583"/><p class="bibliomixed">
(Knuth 92)
<span class="author"><span class="surname">Knuth</span><span class="firstname">Donald.</span></span> <span class="title">Literate Programming.</span> <span class="publisher"><span class="publishername">CSLI Publications</span></span>, <span class="date">1992</span>. 0937073806.
</p></div><div class="bibliomixed"><a id="id2473604"/><p class="bibliomixed">
(Kurlansky 99)
<span class="author"><span class="surname">Kurlansky</span><span class="firstname">Mark.</span></span> <span class="title">The Basque History of the World.</span> <span class="publisher"><span class="publishername">Jonathan Cope</span></span>, <span class="date">1999</span>. 0224060554.
</p></div><div class="bibliomixed"><a id="id2473625"/><p class="bibliomixed">
(McConnell 96)
<span class="author"><span class="surname">McConnell</span><span class="firstname">Steve.</span></span> <span class="title">Rapid Development.</span> <span class="publisher"><span class="publishername">Microsoft Press</span></span>, <span class="date">1996</span>. 1556159005.
</p></div><div class="bibliomixed"><a id="id2473646"/><p class="bibliomixed">
(McConnell 04)
<span class="author"><span class="surname">McConnell</span><span class="firstname">Steve.</span></span> <span class="title">Code Complete: A Practical Handbook of Software Construction.</span> <span class="publisher"><span class="publishername">Microsoft Press</span></span>, <span class="date">2004</span>. <span class="edition">Second Edition</span>. 0735619670.
</p></div><div class="bibliomixed"><a id="id2473671"/><p class="bibliomixed">
(Meyers 97)
<span class="author"><span class="surname">Meyers</span><span class="firstname">Scott.</span></span> <span class="title">Effective C++.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1997</span>. Item 34: Minimize complication dependencies between files. 0201924889.
</p></div><div class="bibliomixed"><a id="id2473693"/><p class="bibliomixed">
(Miller 56)
<span class="author"><span class="surname">Miller</span><span class="firstname">George A.</span></span> "<span class="subtitle">The Magical Number Seven, Plus or Minus Two: Some Limits on our Capacity for Processing Information.</span>" First published in <span class="title">Psychological Review</span>, <span class="volumenum">63</span>, <span class="pagenums">81-97</span>. <span class="date">1956</span>.
</p></div><div class="bibliomixed"><a id="id2473721"/><p class="bibliomixed">
(Myers 86)
<span class="author"><span class="surname">Myers</span><span class="firstname">Ware.</span></span> "<span class="subtitle">Can software for the Strategic Defense Initiative ever be error-free?</span>" <span class="title">IEEE computer</span>. <span class="volumenum">19</span>, <span class="issuenum">10</span>, <span class="pagenums">61-67</span>. <span class="date">1986</span>.
</p></div><div class="bibliomixed"><a id="id2473751"/><p class="bibliomixed">
(Page Jones 96)
<span class="author"><span class="surname">Page-Jones</span><span class="firstname">Meilir.</span></span> <span class="title">What Every Programmer Should Know About Object-oriented Design.</span> <span class="publisher"><span class="publishername">Dorset House Publishing Co.</span></span>, <span class="date">1996</span>. 0932633315.
</p></div><div class="bibliomixed"><a id="id2473773"/><p class="bibliomixed">
(Royce 70)
<span class="author"><span class="surname">Royce</span><span class="firstname">W.W.</span></span> "<span class="subtitle">Managing the Development of Large Software Systems.</span>" <span class="publisher"><span class="publishername">Proceedings of IEEE WESCON</span></span>, <span class="date">August 1970</span>.
</p></div><div class="bibliomixed"><a id="id2473794"/><p class="bibliomixed">
(Simpsons 91)
Simpsons, The. "<span class="subtitle">Do the Bart Man.</span>" <span class="publisher"><span class="publishername">Geffen</span></span>, <span class="date">1991</span>. GEF87CD.
</p></div><div class="bibliomixed"><a id="id2473809"/><p class="bibliomixed">
(Stroustrup 97)
<span class="author"><span class="surname">Stroustrup</span><span class="firstname">Bjarne.</span></span> <span class="title">The C++ Programming Language.</span> <span class="publisher"><span class="publishername">Addison-Wesley</span></span>, <span class="date">1997</span>. <span class="edition">Third Edition</span>. 0-201-88954-4.
</p></div><div class="bibliomixed"><a id="id2473834"/><p class="bibliomixed">
(UML)
<span class="title">Unified Modeling Language.</span> Object Management Group. http://www.uml.org.
</p></div><div class="bibliomixed"><a id="id2473840"/><p class="bibliomixed">
(Vitruvius)
<span class="author"><span class="surname">Vitruvius Pollio</span><span class="firstname">Marcus</span></span> (c. 70-25 bc). <span class="title">De Architectura.</span> Book 1, Chapter 3, Section 2.
</p></div><div class="bibliomixed"><a id="id2473854"/><p class="bibliomixed">
(Weinberg 71)
<span class="author"><span class="surname">Weinberg</span><span class="firstname">Gerald.</span></span> <span class="title">The Psychology Of Computer Programming.</span> <span class="publisher"><span class="publishername">Van Nostrand Reinhold</span></span>, <span class="date">1971</span>. 0932633420.
</p></div><div class="bibliomixed"><a id="id2473876"/><p class="bibliomixed">
(Wulf 72)
<span class="author"><span class="surname">Wulf</span><span class="firstname">William A.</span></span> "<span class="subtitle">A Case Against the GOTO.</span>" <span class="publisher"><span class="publishername">Proceedings of the twenty-fifth National ACM Conference</span></span>, <span class="date">1972</span>.
</p></div></div></div></body></html>