<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Starting Out"><div class="titlepage"><div><div><h1 class="title"><a id="starting_out"/>Chapter 1. Starting Out</h1></div></div></div><p>If you’re the horrible sort of person who doesn’t read introductions, you might want to go back and read the last section anyway—it explains how to use this book, as well as how to load functions with GHC.<a id="IDX-CHP-1-0001" class="indexterm"/><a id="IDX-CHP-1-0002" class="indexterm"/><a id="IDX-CHP-1-0003" class="indexterm"/><a id="IDX-CHP-1-0004" class="indexterm"/><a id="IDX-CHP-1-0005" class="indexterm"/></p><p>First, let’s start GHC’s interactive mode and call some functions, so we can get a very basic feel for Haskell. Open a terminal and type <strong class="userinput"><code>ghci</code></strong>. You will be greeted with something like this:</p><a id="I_programlisting1_d1e345"/><pre class="programlisting">GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>GHCi’s default prompt is <code class="literal">Prelude&gt;</code>, but we’ll be using <code class="literal">ghci&gt;</code> as our prompt for the examples in this book. To make your prompt match the book’s, enter <strong class="userinput"><code>:set prompt "ghci&gt; "</code></strong> into GHCi. If you don’t want to do this every time you run GHCi, create a file called <span class="emphasis"><em>.ghci</em></span> in your home folder and set its contents to <strong class="userinput"><code>:set prompt "ghci&gt; "</code></strong>.</p></div><p>Congratulations, you’re in GHCi! Now let’s try some simple arithmetic:<a id="IDX-CHP-1-0006" class="indexterm"/><a id="IDX-CHP-1-0007" class="indexterm"/><a id="IDX-CHP-1-0008" class="indexterm"/><a id="IDX-CHP-1-0009" class="indexterm"/><a id="IDX-CHP-1-0010" class="indexterm"/><a id="IDX-CHP-1-0011" class="indexterm"/><a id="IDX-CHP-1-0012" class="indexterm"/><a id="IDX-CHP-1-0013" class="indexterm"/><a id="IDX-CHP-1-0014" class="indexterm"/><a id="IDX-CHP-1-0015" class="indexterm"/><a id="IDX-CHP-1-0016" class="indexterm"/><a id="IDX-CHP-1-0017" class="indexterm"/><a id="IDX-CHP-1-0018" class="indexterm"/><a id="IDX-CHP-1-0019" class="indexterm"/><a id="IDX-CHP-1-0020" class="indexterm"/><a id="IDX-CHP-1-0021" class="indexterm"/><a id="IDX-CHP-1-0022" class="indexterm"/><a id="IDX-CHP-1-0023" class="indexterm"/></p><a id="I_programlisting1_d1e434"/><pre class="programlisting">ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e437"/><img src="httpatomoreillycomsourcenostarchimages802506.png.jpg" alt="image with no caption"/></div></div><p>If we use several operators in one expression, Haskell will execute them in an order that takes into account the precedence of the operators. For instance, <code class="literal">*</code> has higher precedence than <code class="literal">-</code>, so <code class="literal">50 * 100 - 4999</code> is treated as <code class="literal">(50 * 100) - 4999</code>.</p><p>We can also use parentheses to explicitly specify the order of operations, like this:</p><a id="I_programlisting1_d1e458"/><pre class="programlisting">ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950</pre><p>Pretty cool, huh? (Yeah, I know it’s not, yet, but bear with me.)</p><p>One pitfall to watch out for is negative number constants. It’s always best to surround these with parentheses wherever they occur in an arithmetic expression. For example, entering <code class="literal">5 * -3</code> will make GHCi yell at you, but entering <code class="literal">5 * (-3)</code> will work just fine.<a id="IDX-CHP-1-0024" class="indexterm"/></p><p>Boolean algebra is also straightforward in Haskell. Like many other programming languages, Haskell has the Boolean values <code class="literal">True</code> and <code class="literal">False</code>, and uses the <code class="literal">&amp;&amp;</code> operator for conjunction (Boolean <span class="emphasis"><em>and</em></span>), the <code class="literal">||</code> operator for disjunction (Boolean <span class="emphasis"><em>or</em></span>), and the <code class="literal">not</code> operator to negate a <code class="literal">True</code> or <code class="literal">False</code> value:<a id="IDX-CHP-1-0025" class="indexterm"/></p><a id="I_programlisting1_d1e507"/><pre class="programlisting">ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False</pre><p>We can test two values for equality or inequality with the <code class="literal">==</code> and <code class="literal">/=</code> operators, like this:<a id="IDX-CHP-1-0026" class="indexterm"/><a id="IDX-CHP-1-0027" class="indexterm"/><a id="IDX-CHP-1-0028" class="indexterm"/><a id="IDX-CHP-1-0029" class="indexterm"/><a id="IDX-CHP-1-0030" class="indexterm"/><a id="IDX-CHP-1-0031" class="indexterm"/><a id="IDX-CHP-1-0032" class="indexterm"/><a id="IDX-CHP-1-0033" class="indexterm"/><a id="IDX-CHP-1-0034" class="indexterm"/><a id="IDX-CHP-1-0035" class="indexterm"/><a id="IDX-CHP-1-0036" class="indexterm"/><a id="IDX-CHP-1-0037" class="indexterm"/><a id="IDX-CHP-1-0038" class="indexterm"/><a id="IDX-CHP-1-0039" class="indexterm"/><a id="IDX-CHP-1-0040" class="indexterm"/><a id="IDX-CHP-1-0041" class="indexterm"/><a id="IDX-CHP-1-0042" class="indexterm"/><a id="IDX-CHP-1-0043" class="indexterm"/></p><a id="I_programlisting1_d1e583"/><pre class="programlisting">ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True</pre><p>Watch out when mixing and matching values, however! If we enter something like <code class="literal">5 + "llama"</code>, we get the following error message:</p><a id="I_programlisting1_d1e590"/><pre class="programlisting">No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"</pre><p>What GHCi is telling us here is that <code class="literal">"llama"</code> is not a number, so it does not know how to add it to 5. The <code class="literal">+</code> operator expects both of its inputs to be numbers.</p><p>On the other hand, the <code class="literal">==</code> operator works on any two items that can be compared, with one catch: they both have to be of the same type. For instance, if we tried entering <code class="literal">True == 5</code>, GHCi would complain.</p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">5 + 4.0</code> is a valid expression, because although <code class="literal">4.0</code> isn’t an integer, <code class="literal">5</code> is sneaky and can act like either an integer or a floating-point number. In this case, <code class="literal">5</code> adapts to match the type of the floating-point value <code class="literal">4.0</code>.</p></div><p>We’ll take a closer look at types a bit later.</p><div class="sect1" title="Calling Functions"><div class="titlepage"><div><div><h1 class="title"><a id="calling_functions"/>Calling Functions</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e632"/><img src="httpatomoreillycomsourcenostarchimages802508.png.jpg" alt="image with no caption"/></div></div><p>You may not have realized it, but we’ve actually been using functions this whole time. For instance, <code class="literal">*</code> is a function that takes two numbers and multiplies them. As you’ve seen, we apply (or <span class="emphasis"><em>call</em></span>) it by sandwiching it between the two numbers we want to multiply. This is called an <span class="emphasis"><em>infix</em></span> function.<a id="IDX-CHP-1-0044" class="indexterm"/></p><p>Most functions, however, are <span class="emphasis"><em>prefix</em></span> functions. When calling prefix functions in Haskell, the function name comes first, then a space, then its parameters (also separated by spaces). As an example, we’ll try calling one of the most boring functions in Haskell, <code class="literal">succ</code>:<a id="IDX-CHP-1-0045" class="indexterm"/><a id="IDX-CHP-1-0046" class="indexterm"/><a id="IDX-CHP-1-0047" class="indexterm"/><a id="IDX-CHP-1-0048" class="indexterm"/><a id="IDX-CHP-1-0049" class="indexterm"/><a id="IDX-CHP-1-0050" class="indexterm"/></p><a id="I_programlisting1_d1e679"/><pre class="programlisting">ghci&gt; succ 8
9</pre><p>The <code class="literal">succ</code> function takes one parameter that can be anything that has a well-defined successor, and returns that value. The successor of an integer value is just the next higher number.</p><p>Now let’s call two prefix functions that take multiple parameters, <code class="literal">min</code> and <code class="literal">max</code>:</p><a id="I_programlisting1_d1e694"/><pre class="programlisting">ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101</pre><p>The <code class="literal">min</code> and <code class="literal">max</code> functions each take two parameters that can be put in some order (like numbers!), and they return the one that’s smaller or larger, respectively.</p><p>Function application has the highest precedence of all the operations in Haskell. In other words, these two statements are equivalent.<a id="IDX-CHP-1-0051" class="indexterm"/><a id="IDX-CHP-1-0052" class="indexterm"/></p><a id="I_programlisting1_d1e714"/><pre class="programlisting">ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16</pre><p>This means that if we want to get the successor of <code class="literal">9 * 10</code>, we couldn’t simply write</p><a id="I_programlisting1_d1e722"/><pre class="programlisting">ghci&gt; succ 9 * 10</pre><p>Because of the precedence of operations, this would evaluate as the successor of 9 (which is 10) multiplied by 10, yielding 100. To get the result we want, we need to instead enter</p><a id="I_programlisting1_d1e726"/><pre class="programlisting">ghci&gt; succ (9 * 10)</pre><p>This returns 91.</p><p>If a function takes two parameters, we can also call it as an infix function by surrounding its name with backticks (<code class="literal">`</code>). For instance, the <code class="literal">div</code> function takes two integers and executes an integral division, as follows:</p><a id="I_programlisting1_d1e738"/><pre class="programlisting">ghci&gt; div 92 10
9</pre><p>However, when we call it like that, there may be some confusion as to which number is being divided by which. By using backticks, we can call it as an infix function, and suddenly it seems much clearer:<a id="IDX-CHP-1-0053" class="indexterm"/><a id="IDX-CHP-1-0054" class="indexterm"/><a id="IDX-CHP-1-0055" class="indexterm"/><a id="IDX-CHP-1-0056" class="indexterm"/><a id="IDX-CHP-1-0057" class="indexterm"/><a id="IDX-CHP-1-0058" class="indexterm"/><a id="IDX-CHP-1-0059" class="indexterm"/><a id="IDX-CHP-1-0060" class="indexterm"/><a id="IDX-CHP-1-0061" class="indexterm"/></p><a id="I_programlisting1_d1e781"/><pre class="programlisting">ghci&gt; 92 `div` 10
9</pre><p>Many programmers who are used to imperative languages tend to stick to the notion that parentheses should denote function application, and they have trouble adjusting to the Haskell way of doing things. Just remember, if you see something like <code class="literal">bar (bar 3)</code>, it means that we’re first calling the <code class="literal">bar</code> function with <code class="literal">3</code> as the parameter, then passing that result to the <code class="literal">bar</code> function again. The equivalent expression in C would be something like <code class="literal">bar(bar(3))</code>.</p></div></div>
<div class="sect1" title="Baby's First Functions"><div class="titlepage"><div><div><h1 class="title"><a id="baby_apostrophy_s_first_functions"/>Baby's First Functions</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e804"/><img src="httpatomoreillycomsourcenostarchimages802510.png.jpg" alt="image with no caption"/></div></div><p>The syntax of a function definition is similar to that of a function call: the function name is followed by parameters, which are separated by spaces. But then the parameter list is followed by the <code class="literal">=</code> operator, and the code that makes up the body of the function follows that.<a id="IDX-CHP-1-0062" class="indexterm"/></p><p>As an example, we’ll write a simple function that takes a number and multiplies it by two. Open up your favorite text editor and type in the following:</p><a id="I_programlisting1_d1e821"/><pre class="programlisting">doubleMe x = x + x</pre><p>Save this file as <span class="emphasis"><em>baby.hs</em></span>. Now run <code class="literal">ghci</code>, making sure that <span class="emphasis"><em>baby.hs</em></span> is in your current directory. Once in GHCi, enter <strong class="userinput"><code>:l baby</code></strong> to load the file. Now we can play with our new function:</p><a id="I_programlisting1_d1e837"/><pre class="programlisting">ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6</pre><p>Because <code class="literal">+</code> works on integers as well as on floating point numbers (indeed, on anything that can be considered a number), our function also works with any of these types.</p><p>Now let’s make a function that takes two numbers, multiplies each by two, then adds them together. Append the following code to <span class="emphasis"><em>baby.hs</em></span>:<a id="IDX-CHP-1-0063" class="indexterm"/><a id="IDX-CHP-1-0064" class="indexterm"/><a id="IDX-CHP-1-0065" class="indexterm"/><a id="IDX-CHP-1-0066" class="indexterm"/><a id="IDX-CHP-1-0067" class="indexterm"/><a id="IDX-CHP-1-0068" class="indexterm"/></p><a id="I_programlisting1_d1e877"/><pre class="programlisting">doubleUs x y = x * 2 + y * 2</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Functions in Haskell don’t have to be defined in any particular order, so it doesn’t matter which function comes first in the <span class="emphasis"><em>baby.hs</em></span> file.</p></div><p>Now save the file, and enter <strong class="userinput"><code>:l baby</code></strong> in GHCi to load your new function. Testing this function yields predictable results:</p><a id="I_programlisting1_d1e891"/><pre class="programlisting">ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478</pre><p>Functions that you define can also call each other. With that in mind, we could redefine <code class="literal">doubleUs</code> in the following way:</p><a id="I_programlisting1_d1e898"/><pre class="programlisting">doubleUs x y = doubleMe x + doubleMe y</pre><p>This is a very simple example of a common pattern you will see when using Haskell: Basic, obviously correct functions can be combined to form more complex functions. This is a great way to avoid code repetition. For example, what if one day mathematicians figure out that 2 and 3 are actually the same, and you have to change your program? You could just redefine <code class="literal">doubleMe</code> to be <code class="literal">x + x + x</code>, and since <code class="literal">doubleUs</code> calls <code class="literal">doubleMe</code>, it would now also automatically work correctly in this strange new world where 2 is equal to 3.<a id="IDX-CHP-1-0069" class="indexterm"/></p><p>Now let’s write a function that multiplies a number by 2, but only if that number is less than or equal to 100 (because numbers bigger than 100 are big enough as it is!).</p><a id="I_programlisting1_d1e921"/><pre class="programlisting">doubleSmallNumber x = if x &gt; 100
                        then x
                        else x*2</pre><p>This example introduces Haskell’s <code class="literal">if</code> statement. You’re probably already familiar with if statements from other languages, but what makes Haskell’s unique is that the <code class="literal">else</code> part is mandatory.<a id="IDX-CHP-1-0070" class="indexterm"/></p><p>Programs in imperative languages are essentially a series of steps that the computer executes when the program is run. When there is an <code class="literal">if</code> statement that doesn’t have a corresponding <code class="literal">else</code>, and the condition isn’t met, then the steps that fall under the <code class="literal">if</code> statement don’t get executed. Thus, in imperative languages, an <code class="literal">if</code> statement can just do nothing.</p><p>On the other hand, a Haskell program is a collection of functions. Functions are used to transform data values into result values, and every function should return some value, which can in turn be used by another function. Since every function has to return something, this implies that every <code class="literal">if</code> has to have a corresponding <code class="literal">else</code>. Otherwise, you could write a function that has a return value when a certain condition is met but doesn’t have one when that condition isn’t met! Briefly: Haskell’s <code class="literal">if</code> is an <span class="emphasis"><em>expression</em></span> that must return a value, and not a statement.<a id="IDX-CHP-1-0071" class="indexterm"/><a id="IDX-CHP-1-0072" class="indexterm"/><a id="IDX-CHP-1-0073" class="indexterm"/><a id="IDX-CHP-1-0074" class="indexterm"/><a id="IDX-CHP-1-0075" class="indexterm"/><a id="IDX-CHP-1-0076" class="indexterm"/><a id="IDX-CHP-1-0077" class="indexterm"/><a id="IDX-CHP-1-0078" class="indexterm"/><a id="IDX-CHP-1-0079" class="indexterm"/><a id="IDX-CHP-1-0080" class="indexterm"/><a id="IDX-CHP-1-0081" class="indexterm"/><a id="IDX-CHP-1-0082" class="indexterm"/><a id="IDX-CHP-1-0083" class="indexterm"/></p><p>Let’s say we want a function that adds one to every number that would be produced by our previous <code class="literal">doubleSmallNumber</code> function. The body of this new function would look like this:</p><a id="I_programlisting1_d1e1022"/><pre class="programlisting">doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1</pre><p>Note the placement of the parentheses. If we had omitted them, the function would only add one if <code class="literal">x</code> is less than or equal to 100. Also note the apostrophe (<code class="literal">'</code>) at the end of the function’s name. The apostrophe doesn’t have any special meaning in Haskell’s syntax, which means it’s a valid character to use in a function name. We usually use <code class="literal">'</code> to denote either a <span class="emphasis"><em>strict</em></span> version of a function (i.e., one that isn’t lazy), or a slightly modified version of a function or variable with a similar name.</p><p>Since <code class="literal">'</code> is a valid character for function names, we can write a function that looks like this:</p><a id="I_programlisting1_d1e1043"/><pre class="programlisting">conanO'Brien = "It's a-me, Conan O'Brien!"</pre><p>There are two things to note here. The first is that we didn’t capitalize <span class="emphasis"><em>Conan</em></span> in the name of the function. In Haskell, functions can’t begin with capital letters. (We’ll see why a bit later.) The second thing to note is that this function doesn’t take any parameters. When a function doesn’t take any parameters, we usually call it a <span class="emphasis"><em>definition</em></span> or a <span class="emphasis"><em>name</em></span>. Because we cannot change what names (or functions) mean once we have defined them, the function <code class="literal">conanO'Brien</code> and the string <code class="literal">"It's a-me, Conan O'Brien!"</code> can be used interchangeably.</p></div>
<div class="sect1" title="An Intro to Lists"><div class="titlepage"><div><div><h1 class="title"><a id="an_intro_to_lists"/>An Intro to Lists</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e1066"/><img src="httpatomoreillycomsourcenostarchimages802512.png.jpg" alt="image with no caption"/></div></div><p>Lists in Haskell are <span class="emphasis"><em>homogeneous</em></span> data structures, which means they store several elements of the same type. We can have a list of integers or a list of characters, for example, but we can’t have a list made up of both integers and characters.</p><p>Lists are surrounded by square brackets, and the list values are separated by commas:</p><a id="I_programlisting1_d1e1078"/><pre class="programlisting">ghci&gt; let lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Use the <code class="literal">let</code> keyword to define a name in GHCi. Entering <code class="literal">let a = 1</code> in GHCi is equivalent to writing <code class="literal">a = 1</code> in a script, then loading it with <code class="literal">:l</code>.<a id="IDX-CHP-1-0084" class="indexterm"/><a id="IDX-CHP-1-0085" class="indexterm"/><a id="IDX-CHP-1-0086" class="indexterm"/><a id="IDX-CHP-1-0087" class="indexterm"/><a id="IDX-CHP-1-0088" class="indexterm"/><a id="IDX-CHP-1-0089" class="indexterm"/><a id="IDX-CHP-1-0090" class="indexterm"/><a id="IDX-CHP-1-0091" class="indexterm"/><a id="IDX-CHP-1-0092" class="indexterm"/><a id="IDX-CHP-1-0093" class="indexterm"/><a id="IDX-CHP-1-0094" class="indexterm"/></p></div><div class="sect2" title="Concatenation"><div class="titlepage"><div><div><h2 class="title"><a id="concatenation"/>Concatenation</h2></div></div></div><p>One of the most common operations when working with lists is concatenation. In Haskell, this is done using the <code class="literal">++</code> operator:</p><a id="I_programlisting1_d1e1157"/><pre class="programlisting">ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; "hello" ++ " " ++ "world"
"hello world"
ghci&gt; ['w','o'] ++ ['o','t']
"woot"</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In Haskell, strings are really just lists of characters. For example, the string <code class="literal">"hello"</code> is actually the same as the list <code class="literal">['h','e','l','l','o']</code>. Because of this, we can use list functions on strings, which is really handy.</p></div><p>Be careful when repeatedly using the <code class="literal">++</code> operator on long strings. When you put together two lists, Haskell has to walk through the entire first list (the one on the left side of <code class="literal">++</code>). That’s not a problem when dealing with smaller lists, but appending something to the end of a list with fifty million entries is going to take a while.</p><p>However, adding something to the beginning of a list is a nearly instantaneous operation. We do this with the <code class="literal">:</code> operator (also called the <span class="emphasis"><em>cons</em></span> operator):</p><a id="I_programlisting1_d1e1184"/><pre class="programlisting">ghci&gt; 'A':" SMALL CAT"
"A SMALL CAT"
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]</pre><p>Notice how in the first example, <code class="literal">:</code> takes a character and a list of characters (a string) as its arguments. Similarly, in the second example, <code class="literal">:</code> takes a number and a list of numbers. The first argument to the <code class="literal">:</code> operator always needs to be a single item of the same type as the values in the list it’s being added to.</p><p>The <code class="literal">++</code> operator, on the other hand, always takes two lists as arguments. Even if you’re only adding a single element to the end of a list with <code class="literal">++</code>, you still have to surround that item with square brackets, so Haskell will treat it like a list:</p><a id="I_programlisting1_d1e1205"/><pre class="programlisting">ghci&gt; [1,2,3,4] ++ [5]
[1,2,3,4,5]</pre><p>Writing <code class="literal">[1,2,3,4] ++ 5</code> is wrong, because both parameters to <code class="literal">++</code> should be lists, and <code class="literal">5</code> isn’t a list; it’s a number.</p><p>Interestingly, in Haskell, <code class="literal">[1,2,3]</code> is just syntactic sugar for <code class="literal">1:2:3:[]</code>. <code class="literal">[]</code> is an empty list. If we prepend <code class="literal">3</code> to that, it becomes <code class="literal">[3]</code>. Then if we prepend <code class="literal">2</code> to that, it becomes <code class="literal">[2,3]</code>, and so on.<a id="IDX-CHP-1-0095" class="indexterm"/><a id="IDX-CHP-1-0096" class="indexterm"/><a id="IDX-CHP-1-0097" class="indexterm"/><a id="IDX-CHP-1-0098" class="indexterm"/><a id="IDX-CHP-1-0099" class="indexterm"/><a id="IDX-CHP-1-0100" class="indexterm"/><a id="IDX-CHP-1-0101" class="indexterm"/><a id="IDX-CHP-1-0102" class="indexterm"/><a id="IDX-CHP-1-0103" class="indexterm"/><a id="IDX-CHP-1-0104" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">[]</code>, <code class="literal">[[]]</code> and <code class="literal">[[],[],[]]</code> are all different things. The first is an empty list, the second is a list that contains one empty list, and the third is a list that contains three empty lists.</p></div></div><div class="sect2" title="Accessing List Elements"><div class="titlepage"><div><div><h2 class="title"><a id="accessing_list_elements"/>Accessing List Elements</h2></div></div></div><p>If you want to get an element of a list by index, use the <code class="literal">!!</code> operator. As with most programming languages, the indices start at 0:</p><a id="I_programlisting1_d1e1301"/><pre class="programlisting">ghci&gt; "Steve Buscemi" !! 6
'B'
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !! 1
33.2</pre><p>However, if you try (say) to get the sixth element from a list that only has four elements, you’ll get an error, so be careful!</p></div><div class="sect2" title="Lists Inside Lists"><div class="titlepage"><div><div><h2 class="title"><a id="lists_inside_lists"/>Lists Inside Lists</h2></div></div></div><p>Lists can contain lists as elements, and lists can contain lists that contain lists, and so on. . . .</p><a id="I_programlisting1_d1e1310"/><pre class="programlisting">ghci&gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !! 2
[1,2,2,3,4]</pre><p>Lists within a list can be of different lengths, but they can’t be of different types. Just like you can’t have a list that has some characters and some numbers as elements, you also can’t have a list that contains some lists of characters and some lists of numbers.</p></div><div class="sect2" title="Comparing Lists"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_lists"/>Comparing Lists</h2></div></div></div><p>Lists can be compared if the items they contain can be compared. When using <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code> and <code class="literal">&gt;</code> to compare two lists, they are compared in lexicographical order. This means that first the two list heads are compared, and if they’re equal, the second elements are compared. If the second elements are also equal, the third elements are compared, and so on, until differing elements are found. The order of the two lists is determined by the order of the first pair of differing elements.<a id="IDX-CHP-1-0105" class="indexterm"/><a id="IDX-CHP-1-0106" class="indexterm"/><a id="IDX-CHP-1-0107" class="indexterm"/><a id="IDX-CHP-1-0108" class="indexterm"/><a id="IDX-CHP-1-0109" class="indexterm"/><a id="IDX-CHP-1-0110" class="indexterm"/><a id="IDX-CHP-1-0111" class="indexterm"/><a id="IDX-CHP-1-0112" class="indexterm"/></p><p>For example, when we evaluate <code class="literal">[3,4,2] &lt; [3,4,3]</code>, Haskell sees that <code class="literal">3</code> and <code class="literal">3</code> are equal, so it compares <code class="literal">4</code> and <code class="literal">4</code>. Those two are also equal, so it compares <code class="literal">2</code> and <code class="literal">3</code>. <code class="literal">2</code> is smaller than <code class="literal">3</code>, so it comes to the conclusion that the first list is smaller than the second one. The same goes for <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>, and <code class="literal">&gt;</code>.</p><a id="I_programlisting1_d1e1404"/><pre class="programlisting">ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &lt; [3,4,3]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True</pre><p>Also, a nonempty list is always considered to be greater than an empty one. This makes the ordering of two lists well defined in all cases, including when one is a proper initial segment of the other.</p></div><div class="sect2" title="More List Operations"><div class="titlepage"><div><div><h2 class="title"><a id="more_list_operations"/>More List Operations</h2></div></div></div><p>Here are some more basic list functions, followed by examples of their usage.</p><p>The <code class="literal">head</code> function takes a list and returns its head, or first element:</p><a id="I_programlisting1_d1e1418"/><pre class="programlisting">ghci&gt; head [5,4,3,2,1]
5</pre><p>The <code class="literal">tail</code> function takes a list and returns its tail. In other words, it chops off a list’s head:</p><a id="I_programlisting1_d1e1425"/><pre class="programlisting">ghci&gt; tail [5,4,3,2,1]
[4,3,2,1]</pre><p>The <code class="literal">last</code> function returns a list’s last element:</p><a id="I_programlisting1_d1e1432"/><pre class="programlisting">ghci&gt; last [5,4,3,2,1]
1</pre><p>The <code class="literal">init</code> function takes a list and returns everything except its last element:</p><a id="I_programlisting1_d1e1439"/><pre class="programlisting">ghci&gt; init [5,4,3,2,1]
[5,4,3,2]</pre><p>To help us visualize these functions, we can think of a list as a monster, like this:<a id="IDX-CHP-1-0113" class="indexterm"/><a id="IDX-CHP-1-0114" class="indexterm"/><a id="IDX-CHP-1-0115" class="indexterm"/><a id="IDX-CHP-1-0116" class="indexterm"/><a id="IDX-CHP-1-0117" class="indexterm"/><a id="IDX-CHP-1-0118" class="indexterm"/><a id="IDX-CHP-1-0119" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e1476"/><img src="httpatomoreillycomsourcenostarchimages802514.png.jpg" alt="image with no caption"/></div></div><p>But what happens if we try to get the head of an empty list?</p><a id="I_programlisting1_d1e1483"/><pre class="programlisting">ghci&gt; head []
*** Exception: Prelude.head: empty list</pre><p>Oh my—it blows up in our face! If there’s no monster, it doesn’t have a head. When using <code class="literal">head</code>, <code class="literal">tail</code>, <code class="literal">last</code>, and <code class="literal">init</code>, be careful not to use them on empty lists. This error cannot be caught at compile time, so it’s always good practice to take precautions against accidentally telling Haskell to give you elements from an empty list.</p><p>The <code class="literal">length</code> function takes a list and returns its length:</p><a id="I_programlisting1_d1e1504"/><pre class="programlisting">ghci&gt; length [5,4,3,2,1]
5</pre><p>The <code class="literal">null</code> function checks if a list is empty. If it is, it returns <code class="literal">True</code>, otherwise it returns <code class="literal">False</code>.</p><a id="I_programlisting1_d1e1517"/><pre class="programlisting">ghci&gt; null [1,2,3]
False
ghci&gt; null []
True</pre><p>The <code class="literal">reverse</code> function reverses a list:</p><a id="I_programlisting1_d1e1524"/><pre class="programlisting">ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]</pre><p>The <code class="literal">take</code> function takes a number and a list. It extracts the specified number elements from the beginning of the list, like this:<a id="IDX-CHP-1-0120" class="indexterm"/><a id="IDX-CHP-1-0121" class="indexterm"/><a id="IDX-CHP-1-0122" class="indexterm"/><a id="IDX-CHP-1-0123" class="indexterm"/><a id="IDX-CHP-1-0124" class="indexterm"/><a id="IDX-CHP-1-0125" class="indexterm"/><a id="IDX-CHP-1-0126" class="indexterm"/><a id="IDX-CHP-1-0127" class="indexterm"/><a id="IDX-CHP-1-0128" class="indexterm"/><a id="IDX-CHP-1-0129" class="indexterm"/><a id="IDX-CHP-1-0130" class="indexterm"/></p><a id="I_programlisting1_d1e1584"/><pre class="programlisting">ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]</pre><p>If we try to <code class="literal">take</code> more elements than there are in the list, Haskell just returns the entire list. If we <code class="literal">take</code> 0 elements, we get an empty list.</p><p>The <code class="literal">drop</code> function works in a similar way, only it drops (at most) the specified number of elements from the beginning of a list:</p><a id="I_programlisting1_d1e1599"/><pre class="programlisting">ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[]</pre><p>The <code class="literal">maximum</code> function takes a list of items that can be put in some kind of order and returns the largest element. The <code class="literal">minimum</code> function is similar, but it returns the smallest item:</p><a id="I_programlisting1_d1e1609"/><pre class="programlisting">ghci&gt; maximum [1,9,2,3,4]
9
ghci&gt; minimum [8,4,2,1,5,6]
1</pre><p>The <code class="literal">sum</code> function takes a list of numbers and returns their sum. The <code class="literal">product</code> function takes a list of numbers and returns their product:</p><a id="I_programlisting1_d1e1619"/><pre class="programlisting">ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0</pre><p>The <code class="literal">elem</code> function takes an item and a list of items and tells us if that item is an element of the list. It’s usually called as an infix function because it’s easier to read that way.</p><a id="I_programlisting1_d1e1626"/><pre class="programlisting">ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False</pre></div></div>
<div class="sect1" title="Texas Ranges"><div class="titlepage"><div><div><h1 class="title"><a id="texas_ranges"/>Texas Ranges</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e1632"/><img src="httpatomoreillycomsourcenostarchimages802516.png.jpg" alt="image with no caption"/></div></div><p>What if we need a list made up of the numbers between 1 and 20? Sure, we could just type them all out, but that’s not a solution for gentlemen who demand excellence from their programming languages. Instead, we’ll use <span class="emphasis"><em>ranges</em></span>. Ranges are used to make lists composed of elements that can be <span class="emphasis"><em>enumerated</em></span>, or counted off in order.<a id="IDX-CHP-1-0131" class="indexterm"/><a id="IDX-CHP-1-0132" class="indexterm"/><a id="IDX-CHP-1-0133" class="indexterm"/><a id="IDX-CHP-1-0134" class="indexterm"/></p><p>For example, numbers can be enumerated: 1, 2, 3, 4, and so on. Characters can also be enumerated: the alphabet is an enumeration of characters from A to Z. Names, however, can’t be enumerated. (What comes after “John?” I don’t know!)</p><p>To make a list containing all the natural numbers from 1 to 20, you can just type <code class="literal">[1..20]</code>. In Haskell, this is exactly the same as typing <code class="literal">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code>. The only difference between the two is that writing out long enumeration sequences manually is stupid.</p><p>Here are a few more examples:</p><a id="I_programlisting1_d1e1673"/><pre class="programlisting">ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; ['K'..'Z']
"KLMNOPQRSTUVWXYZ"</pre><p>You can also specify a <span class="emphasis"><em>step</em></span> between items in your range. What if we want a list of every even number between 1 and 20? Or every third number between 1 and 20? It’s simply a matter of separating the first two elements with a comma and specifying the upper limit:</p><a id="I_programlisting1_d1e1680"/><pre class="programlisting">ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18]</pre><p>While they are pretty convenient, ranges with steps aren’t always as smart as people expect them to be. For example, you can’t enter <code class="literal">[1,2,4,8,16..100]</code> and expect to get all the powers of 2 that are no greater than 100. For one thing, you can only specify a single step size. Also, some sequences that aren’t arithmetic can’t be specified unambiguously by giving only their first few terms.<a id="IDX-CHP-1-0135" class="indexterm"/><a id="IDX-CHP-1-0136" class="indexterm"/><a id="IDX-CHP-1-0137" class="indexterm"/><a id="IDX-CHP-1-0138" class="indexterm"/><a id="IDX-CHP-1-0139" class="indexterm"/><a id="IDX-CHP-1-0140" class="indexterm"/><a id="IDX-CHP-1-0141" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>To make a list with all the numbers from 20 down to 1, you can’t just type <code class="literal">[20..1]</code>, you have to type <code class="literal">[20,19..1]</code>. When you use a range without steps (like <code class="literal">[20..1]</code>), Haskell will start with an empty list and then keep increasing the starting element by one until it reaches or surpasses the end element in the range. Because 20 is already greater than 1, the result will just be an empty list.</p></div><p>You can also use ranges to make infinite lists by not specifying an upper limit. For example, let’s create a list containing the first 24 multiples of 13. Here’s one way to do it:</p><a id="I_programlisting1_d1e1731"/><pre class="programlisting">ghci&gt; [13,26..24*13]
[13,26,39,52,65,78,91,104,117,130,143,156,169,
182,195,208,221,234,247,260,273,286,299,312]</pre><p>But there’s actually a better way—using an infinite list:</p><a id="I_programlisting1_d1e1735"/><pre class="programlisting">ghci&gt; take 24 [13,26..]
[13,26,39,52,65,78,91,104,117,130,143,156,169,182,
195,208,221,234,247,260,273,286,299,312]</pre><p>Because Haskell is <span class="emphasis"><em>lazy</em></span>, it won’t try to evaluate the entire infinite list immediately (which is good because it would never finish anyway). Instead, it will wait to see which elements you need to get from that infinite list. In the above example, it sees that you just want the first 24 elements, and it gladly obliges.</p><p>Here are a few functions that can be used to produce long or infinite lists:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">cycle</code> takes a list and replicates its elements indefinitely to form an infinite list. If you try to display the result, it will go on forever, so make sure to slice it off somewhere:</p><a id="I_programlisting1_d1e1750"/><pre class="programlisting">ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle "LOL ")
"LOL LOL LOL "</pre></li><li class="listitem"><p><code class="literal">repeat</code> takes an element and produces an infinite list of just that element. It’s like cycling a list with only one element:</p><a id="I_programlisting1_d1e1757"/><pre class="programlisting">ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]</pre></li><li class="listitem"><p><code class="literal">replicate</code> is an easier way to create a list composed of a single item. It takes the length of the list and the item to replicate, as follows:<a id="IDX-CHP-1-0142" class="indexterm"/><a id="IDX-CHP-1-0143" class="indexterm"/><a id="IDX-CHP-1-0144" class="indexterm"/><a id="IDX-CHP-1-0145" class="indexterm"/><a id="IDX-CHP-1-0146" class="indexterm"/><a id="IDX-CHP-1-0147" class="indexterm"/><a id="IDX-CHP-1-0148" class="indexterm"/><a id="IDX-CHP-1-0149" class="indexterm"/><a id="IDX-CHP-1-0150" class="indexterm"/></p><a id="I_programlisting1_d1e1807"/><pre class="programlisting">ghci&gt; replicate 3 10
[10,10,10]</pre></li></ul></div><p>One final note about ranges: watch out when using them with floating-point numbers! Because floating-point numbers, by their nature, only have finite precision, using them in ranges can yield some pretty funky results, as you can see here:</p><a id="I_programlisting1_d1e1811"/><pre class="programlisting">ghci&gt; [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]</pre></div>
<div class="sect1" title="I'm a List Comprehension"><div class="titlepage"><div><div><h1 class="title"><a id="i_apostrophy_m_a_list_comprehension"/>I'm a List Comprehension</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e1817"/><img src="httpatomoreillycomsourcenostarchimages802518.png" alt="image with no caption"/></div></div><p><span class="emphasis"><em>List comprehensions</em></span> are a way to filter, transform, and combine lists.<a id="IDX-CHP-1-0151" class="indexterm"/></p><p>They’re very similar to the mathematical concept of <span class="emphasis"><em>set comprehensions</em></span>. Set comprehensions are normally used for building sets out of other sets. An example of a simple set comprehension is: { 2 · <span class="emphasis"><em>x</em></span>|<span class="emphasis"><em>x</em></span> ∈ <span class="strong"><strong>N</strong></span>, <span class="emphasis"><em>x</em></span> ≤ 10}. The exact syntax used here isn’t crucial—what’s important is that this statement says, “take all the natural numbers less than or equal to 10, multiply each one by 2, and use these results to create a new set.”<a id="IDX-CHP-1-0152" class="indexterm"/></p><p>If we wanted to write the same thing in Haskell, we could do something like this with list operations: <code class="literal">take 10 [2,4..]</code>. However, we could also do the same thing using list comprehensions, like this:</p><a id="I_programlisting1_d1e1855"/><pre class="programlisting">ghci&gt; [x*2 | x &lt;- [1..10]]
[2,4,6,8,10,12,14,16,18,20]</pre><p>Let’s take a closer look at the list comprehension in this example to better understand list comprehension syntax.</p><p>In <code class="literal">[x*2 | x &lt;- [1..10]]</code>, we say that we <span class="emphasis"><em>draw</em></span> our elements from the list <code class="literal">[1..10]</code>. <code class="literal">[x &lt;- [1..10]]</code> means that <code class="literal">x</code> takes on the value of each element that is drawn from <code class="literal">[1..10]</code>. In other words, we <span class="emphasis"><em>bind</em></span> each element from <code class="literal">[1..10]</code> to <code class="literal">x</code>. The part before the vertical pipe (<code class="literal">|</code>) is the <span class="emphasis"><em>output</em></span> of the list comprehension. The output is the part where we specify how we want the elements that we’ve drawn to be reflected in the resulting list. In this example, we say that we want each element that is drawn from the list <code class="literal">[1..10]</code> to be doubled.</p><p>This may seem longer and more complicated than the first example, but what if we want to do something more complex than just doubling these numbers? This is where list comprehensions really come in handy.<a id="IDX-CHP-1-0153" class="indexterm"/><a id="IDX-CHP-1-0154" class="indexterm"/><a id="IDX-CHP-1-0155" class="indexterm"/><a id="IDX-CHP-1-0156" class="indexterm"/><a id="IDX-CHP-1-0157" class="indexterm"/><a id="IDX-CHP-1-0158" class="indexterm"/><a id="IDX-CHP-1-0159" class="indexterm"/><a id="IDX-CHP-1-0160" class="indexterm"/><a id="IDX-CHP-1-0161" class="indexterm"/></p><p>For example, let’s add a condition (also called a <span class="emphasis"><em>predicate</em></span>) to our comprehension. Predicates go at the end of the list comprehension and are separated from the rest of the comprehension by a comma. Let’s say we want only the elements which, after being doubled, are greater than or equal to 12:</p><a id="I_programlisting1_d1e1943"/><pre class="programlisting">ghci&gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12]
[12,14,16,18,20]</pre><p>What if we want all numbers from 50 to 100 whose remainder when divided by 7 is 3? Easy:</p><a id="I_programlisting1_d1e1948"/><pre class="programlisting">ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94]</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Weeding out parts of lists using predicates is also called <span class="emphasis"><em>filtering</em></span>.</p></div><p>Now for another example. Let’s say we want a comprehension that replaces every odd number greater than 10 with <code class="literal">"BANG!"</code>, and every odd number less than 10 with <code class="literal">"BOOM!"</code>. If a number isn’t odd, we throw it out of our list. For convenience, we’ll put that comprehension inside a function so we can easily reuse it:</p><a id="I_programlisting1_d1e1964"/><pre class="programlisting">boomBangs xs = [ if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x]</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember, if you’re trying to define this function inside GHCi, you have to include a <code class="literal">let</code> before the function name. However, if you’re defining this function inside a script and then loading that script into GHCi, you don’t have to mess around with <code class="literal">let</code>.</p></div><p>The <code class="literal">odd</code> function returns <code class="literal">True</code> when passed an odd number, otherwise it returns <code class="literal">False</code>. The element is included in the list only if all the predicates evaluate to <code class="literal">True</code>.</p><a id="I_programlisting1_d1e1989"/><pre class="programlisting">ghci&gt; boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"]</pre><p>We can include as many predicates as we want, all separated by commas. For instance, if we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we’d do:</p><a id="I_programlisting1_d1e1993"/><pre class="programlisting">ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]</pre><p>Not only can we have multiple predicates in list comprehensions, we can also draw values from several lists. When drawing values from several lists, every combination of elements from these lists is reflected in the resulting list:<a id="IDX-CHP-1-0162" class="indexterm"/><a id="IDX-CHP-1-0163" class="indexterm"/></p><a id="I_programlisting1_d1e2006"/><pre class="programlisting">ghci&gt; [x+y | x &lt;- [1,2,3], y &lt;- [10,100,1000]]
[11,101,1001,12,102,1002,13,103,1003]</pre><p>Here, <code class="literal">x</code> is drawn from <code class="literal">[1,2,3]</code> and <code class="literal">y</code> is drawn from <code class="literal">[10,100,1000]</code>. These two lists are combined in the following way. First, <code class="literal">x</code> becomes <code class="literal">1</code>, and while <code class="literal">x</code> is <code class="literal">1</code>, <code class="literal">y</code> takes on every value from <code class="literal">[10,100,1000]</code>. Because the output of the list comprehension is <code class="literal">x+y</code>, the values <code class="literal">11</code>, <code class="literal">101</code>, and <code class="literal">1001</code> are added to the beginning of the resulting list (<code class="literal">1</code> is added to <code class="literal">10</code>, <code class="literal">100</code>, and <code class="literal">1000</code>). After that, <code class="literal">x</code> becomes <code class="literal">2</code> and the same thing happens, resulting in the elements <code class="literal">12</code>, <code class="literal">102</code>, and <code class="literal">1002</code> being added to the resulting list. The same goes when <code class="literal">x</code> draws the value <code class="literal">3</code>.</p><p>In this manner, each element <code class="literal">x</code> from <code class="literal">[1,2,3]</code> is combined with each element <code class="literal">y</code> from <code class="literal">[10,100,1000]</code> in all possible ways, and <code class="literal">x+y</code> is used to make the resulting list from those combinations.</p><p>Here’s another example: if we have two lists, <code class="literal">[2,5,10]</code> and <code class="literal">[8,10,11]</code>, and we want to get the products of all possible combinations of numbers in those lists, we could use the following comprehension:</p><a id="I_programlisting1_d1e2114"/><pre class="programlisting">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110]</pre><p>As expected, the length of the new list is 9. Now, what if we wanted all possible products that are more than 50? We can just add another predicate:</p><a id="I_programlisting1_d1e2118"/><pre class="programlisting">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110]</pre><p>For epic hilarity, let’s make a list comprehension that combines a list of adjectives and a list of nouns.</p><a id="I_programlisting1_d1e2122"/><pre class="programlisting">ghci&gt; let nouns = ["hobo","frog","pope"]
ghci&gt; let adjectives = ["lazy","grouchy","scheming"]
ghci&gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"]</pre><p>We can even use list comprehensions to write our own version of the <code class="literal">length</code> function! We’ll call it <code class="literal">length'</code>. This function will replace every element in a list with <code class="literal">1</code>, then add them all up with <code class="literal">sum</code>, yielding the length of the list.</p><a id="I_programlisting1_d1e2138"/><pre class="programlisting">length' xs = sum [1 | _ &lt;- xs]</pre><p>Here we use underscore (<code class="literal">_</code>) as a temporary variable to store the items as we draw them from the input list, since we don’t actually care about the values.<a id="IDX-CHP-1-0164" class="indexterm"/><a id="IDX-CHP-1-0165" class="indexterm"/><a id="IDX-CHP-1-0166" class="indexterm"/><a id="IDX-CHP-1-0167" class="indexterm"/></p><p>Remember, strings are lists too, so we can use list comprehensions to process and produce strings. Here’s an example of a function that takes a string and removes all the lowercase letters from it:</p><a id="I_programlisting1_d1e2168"/><pre class="programlisting">removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']]</pre><p>The predicate here does all the work. It says that the character will be included in the new list only if it’s an element of the list <code class="literal">['A'..'Z']</code>. We can load the function in GHCi and test it out:</p><a id="I_programlisting1_d1e2175"/><pre class="programlisting">ghci&gt; removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci&gt; removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS"</pre><p>You can also create nested list comprehensions if you’re operating on lists that contain lists. For example, let’s take a list that contains several lists of numbers and remove all the odd numbers without flattening the list:</p><a id="I_programlisting1_d1e2179"/><pre class="programlisting">ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]</pre><p>Here the output of the outer list comprehension is another list comprehension. A list comprehension always results in a list of something, so we know that the result here will be a list of lists of numbers.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>You can split list comprehensions across several lines to improve their readability. If you’re not in GHCi, this can be a great help, especially when dealing with nested comprehensions.</p></div></div>
<div class="sect1" title="Tuples"><div class="titlepage"><div><div><h1 class="title"><a id="tuples"/>Tuples</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e2190"/><img src="httpatomoreillycomsourcenostarchimages802520.png" alt="image with no caption"/></div></div><p><span class="emphasis"><em>Tuples</em></span> are used to store several heterogeneous elements as a single value.</p><p>In some ways, tuples are a lot like lists. However, there are some fundamental differences. First, as mentioned, tuples are heterogeneous. This means that a single tuple can store elements of several different types. Second, tuples have a fixed size—you need to know how many elements you’ll be storing ahead of time.</p><p>Tuples are surrounded by parentheses, and their components are separated by commas:<a id="IDX-CHP-1-0168" class="indexterm"/><a id="IDX-CHP-1-0169" class="indexterm"/><a id="IDX-CHP-1-0170" class="indexterm"/><a id="IDX-CHP-1-0171" class="indexterm"/><a id="IDX-CHP-1-0172" class="indexterm"/><a id="IDX-CHP-1-0173" class="indexterm"/><a id="IDX-CHP-1-0174" class="indexterm"/><a id="IDX-CHP-1-0175" class="indexterm"/><a id="IDX-CHP-1-0176" class="indexterm"/></p><a id="I_programlisting1_d1e2242"/><pre class="programlisting">ghci&gt; (1, 3)
(1,3)
ghci&gt; (3, 'a', "hello")
(3,'a',"hello")
ghci&gt; (50, 50.4, "hello", 'b')
(50,50.4,"hello",'b')</pre><div class="sect2" title="Using Tuples"><div class="titlepage"><div><div><h2 class="title"><a id="using_tuples"/>Using Tuples</h2></div></div></div><p>As an example of when tuples would be useful, let’s think about how we’d represent a two-dimensional vector in Haskell. One way would be to use a two item list, in the form of <code class="literal">[x,y]</code>. But suppose we wanted to make a list of vectors, to represent the corners of a two-dimensional shape in a coordinate plane. We could just create a list of lists, like this: <code class="literal">[[1,2],[8,11],[4,5]]</code>.</p><p>The problem with this method, however, is that we could also make a list like <code class="literal">[[1,2],[8,11,5],[4,5]]</code> and try to use it in the place of a list of vectors. Even though it doesn’t make sense as a list of vectors, Haskell has no problem with this list appearing wherever the previous list can, since both are of the same type (a list of lists of numbers). This could make it more complicated to write functions to manipulate vectors and shapes.</p><p>In contrast, a tuple of size two (also called a <span class="emphasis"><em>pair</em></span>) and a tuple of size three (also called a <span class="emphasis"><em>triple</em></span>) are treated as two distinct types, which means a list can’t be composed of both pairs and triples. This makes tuples much more useful for representing vectors.<a id="IDX-CHP-1-0177" class="indexterm"/><a id="IDX-CHP-1-0178" class="indexterm"/></p><p>We can change our vectors to tuples by surrounding them with parentheses instead of square brackets, like this: <code class="literal">[(1,2),(8,11),(4,5)]</code>. Now, if we try to mix pairs and triples, we get an error, like this:</p><a id="I_programlisting1_d1e2283"/><pre class="programlisting">ghci&gt; [(1,2),(8,11,5),(4,5)]
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]</pre><p>Haskell also considers tuples that have the same length but contain different types of data to be distinct types of tuples. For example, you can’t make a list of tuples like <code class="literal">[(1,2),("One",2)]</code>, because the first is a pair of numbers, and the second is a pair containing a string followed by a number.</p><p>Tuples can be used to easily represent a wide variety of data. For instance, if we wanted to represent someone’s name and age in Haskell, we could use a triple: <code class="literal">("Christopher", "Walken", 55)</code>.</p><p>Remember, tuples are of a fixed size—you should only use them when you know in advance how many elements you’ll need. The reason tuples are so rigid in this way is that, as mentioned, the size of a tuple is treated as part of its type. Unfortunately, this means that you can’t write a general function to append an element to a tuple—you’d have to write a function for appending to a pair (to produce a triple), another one for appending to a triple (to produce a 4-tuple), another one for appending to a 4-tuple, and so on.<a id="IDX-CHP-1-0179" class="indexterm"/><a id="IDX-CHP-1-0180" class="indexterm"/><a id="IDX-CHP-1-0181" class="indexterm"/><a id="IDX-CHP-1-0182" class="indexterm"/><a id="IDX-CHP-1-0183" class="indexterm"/><a id="IDX-CHP-1-0184" class="indexterm"/></p><p>Like lists, tuples can be compared with each other if their components can be compared. However, unlike lists, you can’t compare two tuples of different sizes.</p><p>Although there are singleton lists, there’s no such thing as a singleton tuple. It makes sense when you think about it: a singleton tuple’s properties would simply be those of the value it contains, so distinguishing a new type wouldn’t give us any benefit.</p></div><div class="sect2" title="Using Pairs"><div class="titlepage"><div><div><h2 class="title"><a id="using_pairs"/>Using Pairs</h2></div></div></div><p>Storing data in pairs is very common in Haskell, and there are some useful functions in place to manipulate them. Here are two functions that operate on pairs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">fst</code> takes a pair and returns its first component:</p><a id="I_programlisting1_d1e2338"/><pre class="programlisting">ghci&gt; fst (8, 11)
8
ghci&gt; fst ("Wow", False)
"Wow"</pre></li><li class="listitem"><p><code class="literal">snd</code> takes a pair and—surprise!—returns its second component:</p><a id="I_programlisting1_d1e2345"/><pre class="programlisting">ghci&gt; snd (8, 11)
11
ghci&gt; snd ("Wow", False)
False</pre></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>These functions only operate on pairs. They won’t work on triples, 4-tuples, 5-tuples, etc. We’ll go over extracting data from tuples in different ways a bit later.</p></div><p>The <code class="literal">zip</code> function is a cool way to produce a list of pairs. It takes two lists, then “zips” them together into one list by joining the matching elements into pairs. It’s a really simple function, but it can be very useful when you want to combine two lists in a particular way or traverse two lists simultaneously. Here’s a demonstration:</p><a id="I_programlisting1_d1e2355"/><pre class="programlisting">ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1..5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]</pre><p>Notice that because pairs can have different types in them, <code class="literal">zip</code> can take two lists that contain elements of different types. But what happens if the lengths of the lists don’t match?<a id="IDX-CHP-1-0185" class="indexterm"/><a id="IDX-CHP-1-0186" class="indexterm"/><a id="IDX-CHP-1-0187" class="indexterm"/><a id="IDX-CHP-1-0188" class="indexterm"/></p><a id="I_programlisting1_d1e2378"/><pre class="programlisting">ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]</pre><p>As you can see in the above example, only as much of the longer list is used as needed—the rest is simply ignored. And because Haskell uses lazy evaluation, we can even zip finite lists with infinite lists:</p><a id="I_programlisting1_d1e2382"/><pre class="programlisting">ghci&gt; zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]</pre></div><div class="sect2" title="Finding the Right Triangle"><div class="titlepage"><div><div><h2 class="title"><a id="finding_the_right_triangle"/>Finding the Right Triangle</h2></div></div></div><p>Let’s wrap things up with a problem that combines tuples and list comprehensions. We’ll use Haskell to find a right triangle that fits all of these conditions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The lengths of the three sides are all integers.</p></li><li class="listitem"><p>The length of each side is less than or equal to 10.</p></li><li class="listitem"><p>The triangle’s perimeter (the sum of the side lengths) is equal to 24.</p></li></ul></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e2400"/><img src="httpatomoreillycomsourcenostarchimages802522.png.jpg" alt="image with no caption"/></div></div><p>A triangle is a right triangle if one of its angles is a right angle (a 90-degree angle). Right triangles have the useful property that if you square the lengths of the sides forming the right angle and then add those squares, that sum is equal to the square of the length of the side that’s opposite the right angle. In the picture, the sides that lie next to the right angle are labeled <code class="literal">a</code> and <code class="literal">b</code>, and the side opposite the right angle is labeled <code class="literal">c</code>. We call that side the <span class="emphasis"><em>hypotenuse</em></span>.</p><p>As a first step, let’s generate all possible triples with elements that are less than or equal to 10:<a id="IDX-CHP-1-0189" class="indexterm"/></p><a id="I_programlisting1_d1e2426"/><pre class="programlisting">ghci&gt; let triples = [ (a,b,c) | c &lt;- [1..10], a &lt;- [1..10], b &lt;- [1..10] ]</pre><p>We’re drawing from three lists on the right-hand side of the comprehension, and the output expression on the left combines them into a list of triples. If you evaluate <code class="literal">triples</code> in GHCi, you’ll get a list that is 1,000 entries long, so we won’t show it here.</p><p>Next, we’ll filter out triples that don’t represent right triangles by adding a predicate that checks to see if the Pythagorean theorem (<code class="literal">a^2 + b^2 == c^2</code>) holds. We’ll also modify the function to ensure that side <code class="literal">a</code> isn’t larger than the hypotenuse <code class="literal">c</code>, and that side <code class="literal">b</code> isn’t larger than side <code class="literal">a</code>:<a id="IDX-CHP-1-0190" class="indexterm"/></p><a id="I_programlisting1_d1e2454"/><pre class="programlisting">ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], a &lt;- [1..c], b &lt;- [1..a],
a^2 + b^2 == c^2]</pre><p>Notice how we changed the ranges in the lists that we draw values from. This ensures that we don’t check unnecessary triples, such as ones where side <code class="literal">b</code> is larger than the hypotenuse (in a right triangle, the hypotenuse is always the longest side). We also assumed that side <code class="literal">b</code> is never larger than side <code class="literal">a</code>. This doesn’t harm anything, because for every triple <code class="literal">(a,b,c)</code> with <code class="literal">a^2 + b^2 == c^2</code> and <code class="literal">b</code> &gt; <code class="literal">a</code> that is left out of consideration, the triple <code class="literal">(b,a,c)</code> is included—and is the same triangle, just with the legs reversed. (Otherwise, our list of results would contain pairs of triangles that are essentially the same.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In GHCi, you can’t break up definitions and expressions across multiple lines. In this book, however, we occasionally need to break up a single line so the code can all fit on the page. (Otherwise the book would have to be really wide, and it wouldn’t fit on any normal shelf—and then you’d have to buy bigger shelves!)</p></div><p>We’re almost done. Now, we just need to modify the function to only output the triangles whose perimeter equals 24:</p><a id="I_programlisting1_d1e2489"/><pre class="programlisting">ghci&gt; let rightTriangles' = [ (a,b,c) | c &lt;- [1..10],
 a &lt;- [1..c], b &lt;- [1..a], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles'
[(6,8,10)]</pre><p>And there’s our answer! This is a common pattern in functional programming: you start with a certain set of candidate solutions, and successively apply transformations and filters to them until you’ve narrowed the possibilities down to the one solution (or several solutions) that you’re after.</p></div></div></body></html>