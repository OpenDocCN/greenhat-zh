<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;FLOW FUNDAMENTALS"><div class="titlepage"><div><div><h1 class="title"><a id="flow_fundamentals"/>Chapter 1. FLOW FUNDAMENTALS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e557"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages651574.png.jpg"/></div></div><p>I'll assume at this point that you're sold on the idea that flows can solve your problems. Now, let's get specific about what flows are, what they're good for, and how you can implement and analyze them. This chapter focuses on the flows commonly found on TCP/IP networks, specifically, TCP, UDP, and ICMP flows.<a class="indexterm" id="IDX-CHP-1-0001"/><a class="indexterm" id="IDX-CHP-1-0002"/><a class="indexterm" id="IDX-CHP-1-0003"/></p><p>This chapter assumes you have a basic understanding of TCP/IP and tries to drag you into a deeper understanding of it. If you find yourself growing confused, I suggest you consult an introductory book such as Charles M. Kozierok's <span class="emphasis"><em>The TCP/IP Guide</em></span> (No Starch Press, 2005). I also encourage you to spend quality time with a packet sniffer watching TCP/IP transactions in the real world because there's no better way to learn network protocols than observing them carrying out real work.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Experienced network administrators might find that this chapter repeats topics they already know. If you already understand three-way handshake and if seeing <code class="literal">0x2</code> makes you think "TCP reset," then you might be tempted to skip this chapter. This chapter covers the material from a flow-based perspective, however, so if you decide to skip ahead, don't come sniveling to me when you get confused.<a class="indexterm" id="IDX-CHP-1-0004"/><a class="indexterm" id="IDX-CHP-1-0005"/></p></div><div class="sect1" title="What Is a Flow?"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_flow_question"/>What Is a Flow?</h1></div></div></div><p>Strictly speaking, a <span class="emphasis"><em>flow</em></span> is a series of packets that share the same source and destination IP addresses, source and destination ports, and IP protocol. This is also called a <span class="emphasis"><em>five-tuple IP flow</em></span>. The word <span class="emphasis"><em>flow</em></span> is also sometimes used to mean an aggregate of individual flows. A <span class="emphasis"><em>flow record</em></span> is a summary of information about a flow, recording which hosts communicated with which other hosts, when this communication occurred, how the traffic was transmitted, and other basic information about the network conversation. A flow analysis system collects flow information and gives you a system to search, filter, and print flow information. Flow records summarize every connection on your network.<a class="indexterm" id="IDX-CHP-1-0006"/><a class="indexterm" id="IDX-CHP-1-0007"/><a class="indexterm" id="IDX-CHP-1-0008"/></p><p>Do you want to know what kind of traffic is filling your Internet T1, what a client PC is doing, or what kind of errors are reaching a server? Check the flow records. Want to know what happened on the network yesterday between 3 <span class="keycap"><strong>am</strong></span> and 3:05 <span class="keycap"><strong>am</strong></span>, when the file server mysteriously crashed and rebooted? Check yesterday's flow records.</p><p>The good news is that most network hardware can report traffic as flows. Having that hardware send flow information to a recording host imposes only a small overhead; you don't need to install anything.</p><p>Because flow records do not include the data exchanged by a network connection, flow records are small. For example, as I write this, my data center has a DS3, several T1s, a gigabit Ethernet backbone, and assorted smaller subnets and DMZs. Still, three complete years of flow records use less than 100GB of disk space. Granted, that's not trivial, but it's a small amount of disk space by modern standards and far less than that required to capture the complete contents of every exchange.</p><p>Even with gigabytes of data, flow records do not allow unlimited troubleshooting. Anyone who has ever used a packet sniffer to watch a telnet or unencrypted web session understands that everything that traverses the network can be captured, analyzed, and reconstructed. A snooper can see exactly which websites a user visits, what files the user downloads, what the user transmits back to the site, and any usernames and passwords used in the exchange. Flow records do not contain this data; they simply tell the network administrator that a client visited a website running at a particular IP address, how many connections the user made to that site, how much data was exchanged, but not the contents of those exchanges.<a class="indexterm" id="IDX-CHP-1-0009"/></p><p>Recording only flow information rather than complete packets might sound limited, but the NSA performs similar analysis on phone records to catch criminals and terrorists. Similarly, the wireless wiretapping at AT&amp;T was discovered through netflow analysis. Knowing who talked to whom, when they talked, and how much each party said is terribly valuable.</p><div class="sidebar"><a id="flows_vs._sessions"/><p class="title">FLOWS VS. SESSIONS</p><p>Different protocols describe network interaction with words such as <span class="emphasis"><em>session</em></span>, <span class="emphasis"><em>transaction</em></span>, and <span class="emphasis"><em>conversation</em></span>. How do these differ from a flow? Remember that all traffic in a flow is going in the same direction. When a client connects to a web server and downloads a file, it creates a simple HTTP session. However, this one session (that is, this one transaction) is actually two flows: one going from the client to the server and another one going from the server to the client. Each flow mirrors the other.<a class="indexterm" id="IDX-CHP-1-0010"/><a class="indexterm" id="IDX-CHP-1-0011"/><a class="indexterm" id="IDX-CHP-1-0012"/><a class="indexterm" id="IDX-CHP-1-0013"/><a class="indexterm" id="IDX-CHP-1-0014"/><a class="indexterm" id="IDX-CHP-1-0015"/><a class="indexterm" id="IDX-CHP-1-0016"/></p></div></div></div>
<div class="sect1" title="Flow System Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="flow_system_architecture"/>Flow System Architecture</h1></div></div></div><p>A typical flow-based management system has three components: a sensor (or sensors), a collector, and a reporting system. Components can be combined as well, as you'll learn in <a class="xref" href="ch02.html" title="Chapter 2. COLLECTORS AND SENSORS">Chapter 2</a>.<a class="indexterm" id="IDX-CHP-1-0017"/><a class="indexterm" id="IDX-CHP-1-0018"/></p><p>A <span class="emphasis"><em>sensor</em></span>, also known as a <span class="emphasis"><em>probe</em></span>, is a device that listens to the network and captures traffic data. The sensor may be a switch, router, or firewall with integrated flow export capability, or it might be a piece of software listening to an Ethernet tap or a switch port in monitor mode. The sensor tracks network connections, and after it believes a connection has finished or the connection reaches a timeout, it transmits the data.<a class="indexterm" id="IDX-CHP-1-0019"/></p><p>The <span class="emphasis"><em>collector</em></span> is software that receives sensor records and writes them to disk. The collector is an absolutely critical piece of your flow-based management infrastructure. Unfortunately, there's no universally accepted on-disk format for storing flow records. This complicates analysis and restricts the reporting tools you can use, but you'll learn how to work around that in this book.</p><p>Finally, the <span class="emphasis"><em>reporting system</em></span> reads the collector files and produces human-friendly reports. The reporting system must understand the file format used by the collector.</p><p>You can find many different implementations of each component of a flow-based management system. Each hardware vendor's higher-end equipment has a flow sensor, and many people have written or implemented flow sensors for their preferred operating system. Several different collectors have come into prominence and faded, such as cflowd, and many people who wanted to demonstrate their mastery of the latest cool scripting language have written reporting systems to meet their particular needs.</p><p>A newcomer might look at the vast array of options and decide that flow management is too complicated to even begin to attempt. What's worse, much of this software is obsolete, but Internet mailing list archives from, say, 1998 strongly recommend it. The neophyte can spend hours tracking down software only to discover that it can no longer be built with a modern compiler. Additionally, many possible combinations are subtly incompatible.</p><p>This situation is beyond frustrating, and it makes many people abandon investigations into flow-based network management after only a couple hours.</p><p>This book presents a single set of software components that work together. The components either are still actively developed or have a widespread user base. The core platform is the flow-tools tool kit (<a class="ulink" href="http://code.google.com/p/flow-tools/">http://code.google.com/p/flow-tools/</a>). Flow-tools has been the standard freely available flow collector and reporting software for many years now and is compatible with all common sensors. Additionally, many reporting tools leverage flow-tools' data format when correctly configured. You'll learn how to make flow-tools integrate with some other popular tools in this book.<a class="indexterm" id="IDX-CHP-1-0020"/><a class="indexterm" id="IDX-CHP-1-0021"/></p></div>
<div class="sect1" title="The History of Network Flow"><div class="titlepage"><div><div><h1 class="title"><a id="the_history_of_network_flow"/>The History of Network Flow</h1></div></div></div><p>High-speed router and switch hardware directs traffic without going to the operating system, in other words, without making each forwarding decision in software. Decisions on packet routing are made at the lowest level possible, generally within the hardware itself. Circa 1996, Cisco invented a method by which routing decisions were guided by flows. Subsequently, the value of flow information was realized, and it was made accessible to network administrators as a feature called NetFlow.</p><div class="sect2" title="NetFlow Versions"><div class="titlepage"><div><div><h2 class="title"><a id="netflow_versions"/>NetFlow Versions</h2></div></div></div><p>NetFlow has undergone several revisions through its history.<a class="indexterm" id="IDX-CHP-1-0022"/></p><div class="sect3" title="NetFlow Version 1"><div class="titlepage"><div><div><h3 class="title"><a id="netflow_version_1"/>NetFlow Version 1</h3></div></div></div><p>NetFlow version 1 was the earliest Cisco release. Other vendors reverse-engineered the NetFlow reporting protocol and released their own NetFlow-compatible reporting systems. A few vendors still support NetFlow version 1, and if this is all you have, it will still solve many problems for you. It contains only the minimal flow information.</p></div><div class="sect3" title="NetFlow Version 5"><div class="titlepage"><div><div><h3 class="title"><a id="netflow_version_5"/>NetFlow Version 5</h3></div></div></div><p>The oldest widely deployed flow record format is NetFlow version 5. Many vendors, such as Juniper and Nokia, implemented this protocol.<a class="indexterm" id="IDX-CHP-1-0023"/><a class="indexterm" id="IDX-CHP-1-0024"/></p><p>NetFlow version 5 includes seven key values: source IP address, destination IP address, source port (TCP and UDP protocols only), destination port, IP protocol, the interface the flow arrived on the system on, and the IP type of service. It also includes information about BGP, the exporter IP address, and a few other traffic characteristics. Although flow records have become more detailed over the years, NetFlow version 5 suffices for most environments.</p></div><div class="sect3" title="NetFlow Version 7"><div class="titlepage"><div><div><h3 class="title"><a id="netflow_version_7"/>NetFlow Version 7</h3></div></div></div><p>NetFlow version 7 is supported only by high-end Cisco Catalyst switches. Its flow record format includes switching and routing information not available in version 5, such as the IP address of the next hop address for the flow. If you have hardware that supports NetFlow version 7, this book will show you how to take advantage of it.</p></div><div class="sect3" title="NetFlow Version 8"><div class="titlepage"><div><div><h3 class="title"><a id="netflow_version_8"/>NetFlow Version 8</h3></div></div></div><p>NetFlow version 8 is a cluster of similar formats that aggregate information. If you have many high-bandwidth connections and you must minimize the amount of resources you spend collecting and analyzing flow records, NetFlow version 8 might be useful. Cisco is the only vendor that supports it, however, and it's used only rarely. Given our ever-increasing computing power and disk capacity, however, NetFlow version 8 is usually not compelling.<a class="indexterm" id="IDX-CHP-1-0025"/><a class="indexterm" id="IDX-CHP-1-0026"/><a class="indexterm" id="IDX-CHP-1-0027"/><a class="indexterm" id="IDX-CHP-1-0028"/><a class="indexterm" id="IDX-CHP-1-0029"/></p></div><div class="sect3" title="NetFlow Version 9"><div class="titlepage"><div><div><h3 class="title"><a id="netflow_version_9"/>NetFlow Version 9</h3></div></div></div><p>NetFlow version 9 is Cisco's final version. It is template-based and extensible, meaning that third-party vendors can add arbitrary information into a NetFlow record. Version 9 is also the first version to support IP version 6 (IPv6). NetFlow version 9 is deployed in only a few commercial products.<a class="indexterm" id="IDX-CHP-1-0030"/></p></div></div><div class="sect2" title="NetFlow Competition"><div class="titlepage"><div><div><h2 class="title"><a id="netflow_competition"/>NetFlow Competition</h2></div></div></div><p>As Cisco deployed more and more NetFlow versions, other networking companies saw the benefit of exporting and reporting on flow data. For example, Cisco developed NetFlow based on the needs of its own customers, which were not necessarily the needs of the global networking community. Other vendors implemented similar flow-based reporting based on the needs of their customers. As a result, NetFlow competitors appeared, the best known of which is sFlow. Some equipment from vendors such as 3Com, HP, Extreme, and Juniper support sFlow.<a class="indexterm" id="IDX-CHP-1-0031"/><a class="indexterm" id="IDX-CHP-1-0032"/><a class="indexterm" id="IDX-CHP-1-0033"/><a class="indexterm" id="IDX-CHP-1-0034"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>sFlow is specifically not NetFlow because Cisco owns that word. People began to refer to <span class="emphasis"><em>flow export</em></span> instead of <span class="emphasis"><em>NetFlow</em></span> about the same time that sFlow was released.</p></div><p>As the number of competitors grew, the networking community saw the advantages of a common standards-defined flow export protocol. Current efforts focus on this standards-based approach.<a class="indexterm" id="IDX-CHP-1-0035"/></p></div><div class="sect2" title="The Latest Standards"><div class="titlepage"><div><div><h2 class="title"><a id="the_latest_standards"/>The Latest Standards</h2></div></div></div><p>In the early 2000s, the Internet Engineering Task Force created a working group to define flow formats and prevent further flow format fragmentation. The working group chose to use NetFlow version 9 as the base protocol, with minor changes to make it friendlier. Cisco is still involved but now as a member rather than the sole controlling interest.<a class="indexterm" id="IDX-CHP-1-0036"/></p><p>The latest version of the network flow standard is called IP Flow Information eXport (IPFIX). Although many hardware vendors are implementing IPFIX support as well as support for older versions, the format is rarely deployed. IPFIX is much more complicated than earlier flow versions and uses more system resources. The differences between earlier NetFlow versions are evolutionary, but NetFlow version 9 and IPFIX represent dramatic breaks from earlier versions. People are also investigating using IPFIX to manage non-network data, such as security events.<a class="indexterm" id="IDX-CHP-1-0037"/></p><p>The solutions you'll explore in this book address NetFlow versions 1 through 7. Versions 8 and 9 are rarely needed, and although IPv6 requires NetFlow version 9 or newer, most of the world is not interested in IPv6 and will remain disinterested until IP version 4 address space shortages become intolerable. Once IPv6 is no longer optional, I expect vendors to jump directly to IPFIX. When IPFIX becomes more widespread, I have no doubt that the user community will add IPFIX support to the tools covered in this book.<a class="indexterm" id="IDX-CHP-1-0038"/><a class="indexterm" id="IDX-CHP-1-0039"/><a class="indexterm" id="IDX-CHP-1-0040"/></p><div class="sidebar"><a id="netflow_vs._flow_export"/><p class="title">NETFLOW VS. FLOW EXPORT</p><p>Sometimes in this book I use the word <span class="emphasis"><em>NetFlow</em></span>; other times I use <span class="emphasis"><em>flow management</em></span> or <span class="emphasis"><em>flow export</em></span>. The difference between them is that Cisco owns the word NetFlow, while other vendors support a NetFlow-compatible flow export technology. You might be using NetFlow, or you might be using a NetFlow-compatible flow export system, depending on your equipment. The difference is only semantic, but whenever possible, I avoid annoying any multinational firm that could crush me like a bug.</p></div></div></div>
<div class="sect1" title="Flows in the Real World"><div class="titlepage"><div><div><h1 class="title"><a id="flows_in_the_real_world"/>Flows in the Real World</h1></div></div></div><p>"A <span class="emphasis"><em>flow</em></span> is a series of packets that all share the same source and destination IP addresses, source and destination ports, and IP protocol." What the heck does that mean, really? Let's pull this description apart and see what it really means in a few places in the real world. I'll start with the simplest network traffic, a ping request and response, and then proceed to more complicated examples of DNS and HTTP requests.</p><div class="sect2" title="ICMP Flows"><div class="titlepage"><div><div><h2 class="title"><a id="icmp_flows"/>ICMP Flows</h2></div></div></div><p>Although ICMP is most commonly associated with ping requests, it also carries the most basic instructions for Internet routing and management. Certain individual flows, such as ICMP redirects, can carry useful information, but to keep things simple, I'll cover the common ping.<a class="indexterm" id="IDX-CHP-1-0041"/><a class="indexterm" id="IDX-CHP-1-0042"/><a class="indexterm" id="IDX-CHP-1-0043"/></p><p>ICMP has no TCP-style flags and does not have ports like TCP and UDP do. Instead, ICMP packets are assigned an <span class="emphasis"><em>ICMP type</em></span> and an optional <span class="emphasis"><em>ICMP code</em></span>. The ICMP type identifies the general purpose of the packet. Ping requests and response messages have their own ICMP types, and an ICMP type might have associated ICMP codes that offer more detail. (You'll learn more about ICMP types and codes in <a class="xref" href="ch03.html" title="Chapter 3. VIEWING FLOWS">Chapter 3</a>.)</p><p>To ping a server, the client creates an ICMP packet with a source address of the client and a destination address of the server. The client sets the ICMP type to 8, or <code class="literal">echo-request</code>, and sends the packet onto the network. This ping packet is the entirety of the first flow.</p><p>In response, the server creates an ICMP packet with the server's source address, the client's destination address, and an ICMP type of 0, or <code class="literal">echo-response</code>. This is the complete second flow.</p><p>That said, if your client sends multiple ping requests, the flow system assigns subsequent pings to the same flow. A Windows system, for example, normally sends five ping requests and expects five ping replies. Your flow system records a single flow containing five requests and a separate flow containing five responses.<a class="indexterm" id="IDX-CHP-1-0044"/><a class="indexterm" id="IDX-CHP-1-0045"/></p><p>A flow sensor has no way of knowing when ICMP flows are complete, because the traffic contains no internal markers that say "No further packets will arrive." The sensor holds ICMP flows in memory until a timeout expires, at which point the sensor marks the flows as complete and transmits them to the collector.</p></div><div class="sect2" title="UDP Flows"><div class="titlepage"><div><div><h2 class="title"><a id="udp_flows"/>UDP Flows</h2></div></div></div><p>Now consider a basic DNS request to see how UDP flows function. UDP sessions are slightly more complex than ICMP flows: Although UDP doesn't use types and codes like ICMP and doesn't have flags like TCP, UDP uses TCP-style port numbers. Also, UDP has no built-in concept of a session or transaction, which is why people describe it as <span class="emphasis"><em>connectionless</em></span>. UDP does carry useful application-level data, however, and most UDP traffic is part of some sort of session or transaction. The most common UDP flows on the average network are DNS requests. A DNS request is among the simplest possible network requests and produces the shortest flows you'll see. Other UDP network protocols, such as bootp, generate many more packets per flow, but to understand flows, you'll look at the humble DNS request here.<a class="indexterm" id="IDX-CHP-1-0046"/><a class="indexterm" id="IDX-CHP-1-0047"/></p><p>A client connecting to a DNS server creates a UDP packet with a source IP of the client and a destination IP of the server. As with TCP, the UDP request originates from an unused port on the client side and uses the standard DNS port 53 as its destination. A simple DNS query, such as a request for the address of <a class="ulink" href="http://www.nostarch.com">www.nostarch.com</a>, fits entirely within one packet. This single packet is the start of the third sample flow.</p><p>The fourth flow begins when a server responds by creating a UDP packet with a source IP of the server and a destination IP of the client. Similarly, the source and destination ports are reversed from the packet sent by the client. A DNS response containing the information for a typical site also fits entirely within one packet.</p><p>These flows are now complete, and no more traffic will be passed as part of them. You can see these flows in <a class="xref" href="ch01s04.html#udp_network_transaction_with_flow_member" title="Figure 1-1. UDP network transaction with flow memberships">Figure 1-1</a>.</p><div class="figure"><a id="udp_network_transaction_with_flow_member"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e963"/><img alt="UDP network transaction with flow memberships" src="httpatomoreillycomsourcenostarchimages651576.png.jpg"/></div></div><p class="title">Figure 1-1. UDP network transaction with flow memberships</p></div><p>Because UDP is connectionless, the network traffic contains no markers to tell an observer that a particular conversation is complete. The packets have no TCP-esque FIN flag that announces "I'm done, so hang up now," so a flow sensor has no way to know that the flows are complete. The sensor holds those flows in memory until a timeout expires, at which point the sensor marks the flows as complete and transmits them to the collector.<a class="indexterm" id="IDX-CHP-1-0048"/><a class="indexterm" id="IDX-CHP-1-0049"/><a class="indexterm" id="IDX-CHP-1-0050"/><a class="indexterm" id="IDX-CHP-1-0051"/><a class="indexterm" id="IDX-CHP-1-0052"/></p></div><div class="sect2" title="TCP Flows"><div class="titlepage"><div><div><h2 class="title"><a id="tcp_flows"/>TCP Flows</h2></div></div></div><p>The most complicated network flows that I'll cover are TCP flows, such as those used by web servers and browsers. The TCP protocol includes ports such as those used by UDP but also includes internal flags that indicate the state of the connection. TCP tells the client and the server whether a connection is being requested, ongoing, or being torn down. For example, now that you have an IP address for <a class="ulink" href="http://www.nostarch.com">www.nostarch.com</a>, let's look at a web client requesting a single, static, simple web object from that site.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-1" id="CHP-1-FN-1">1</a>]</sup></p><p>The fifth flow begins when a client connecting to a web server sends a single packet to the server with a source IP of the client and a destination IP of the server. The client allocates an unused port on the local system for exclusive use by this connection, which is the packet's <span class="emphasis"><em>source port</em></span>. Web servers typically run on port 80, so this is the packet's destination port. On the first packet in the connection, the client sets the synchronization (SYN) request flag (this initial packet is usually referred to as a <span class="emphasis"><em>SYN request</em></span>). The client is contacting the server, saying "Hey, can I talk to you?"<a class="indexterm" id="IDX-CHP-1-0053"/><a class="indexterm" id="IDX-CHP-1-0054"/></p><p>When the server receives a SYN request on port 80 and decides to accept the connection, it prepares a <span class="emphasis"><em>response packet</em></span>. This response packet has a source address of the server and a destination address of the client. The source port is 80, the port requested by the client; the destination port is the earlier packet's source port.<a class="indexterm" id="IDX-CHP-1-0055"/></p><p>The sixth flow is the packet sent as a response to a SYN packet, so the server sets the acknowledgment (ACK) flag. Because the server hasn't sent any packets in this TCP/IP conversation before, it also sets the SYN flag to request synchronization (commonly called the <span class="emphasis"><em>SYN-ACK packet</em></span>).<a class="indexterm" id="IDX-CHP-1-0056"/></p><p>A second flow in one network transaction? Yep. Remember, a single flow shares the same source and destination IP addresses, among other things. You have one flow with a source address of the client and a second with the source address of the server. The source port of one flow matches the destination port of the other flow, permitting you to match the two together, but these are two separate flows. Flows let you determine how much traffic goes in each direction in any given transaction.</p><p>When the client receives the server's response, it matches the incoming packet with the connection it's trying to establish with that server. The client responds with a packet to the server from the assigned local port. The connection is now synchronized: Both the client and the server know the IP addresses involved in the connection and the port numbers on each side (as well as sequence numbers and other assorted characteristics that uniquely identify this connection). Because this packet is part of an existing connection, the SYN flag is not required. The client must acknowledge the SYN request the server included in its last packet, however, so this next packet includes the ACK flag.<a class="indexterm" id="IDX-CHP-1-0057"/><a class="indexterm" id="IDX-CHP-1-0058"/><a class="indexterm" id="IDX-CHP-1-0059"/></p><p>This packet from client to server might be the third in the transaction, but it's the second sent by the client to the server. It shares the source and destination IP addresses and port numbers of the first packet in the transaction, both of which are using the same IP protocol (TCP). This third packet is the second packet in the first flow. (<a class="xref" href="ch01s04.html#tcp_three-way_handshake_with_flow_member" title="Figure 1-2. TCP three-way handshake with flow memberships">Figure 1-2</a> illustrates this three-way handshake, noting the flows to which each packet is assigned.)</p><div class="figure"><a id="tcp_three-way_handshake_with_flow_member"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1050"/><img alt="TCP three-way handshake with flow memberships" src="httpatomoreillycomsourcenostarchimages651578.png.jpg"/></div></div><p class="title">Figure 1-2. TCP three-way handshake with flow memberships</p></div><p>Now that a connection exists, the client may transmit actual data, such as an HTTP GET request. The GET request is part of the first flow, from client to server. The server's response, including any HTML, images, or error codes, becomes part of the second flow, from server to client. Packets now stream back and forth, including ACKs as required to acknowledge receipt of earlier packets.</p><p>At the end of the transaction, one side or the other sends a packet with the "finish" (FIN) flag set. This packet is called a <span class="emphasis"><em>FIN request</em></span>, and it marks the end of the TCP/IP session. The other system sends an ACK and then a FIN of its own. The client sends an ACK to the final FIN, closing the connection. The flow sensor sees the FINs and ACKs, terminates both flows, and immediately transmits the TCP flow records to the collector.<a class="indexterm" id="IDX-CHP-1-0060"/></p></div><div class="sect2" title="Other Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="other_protocols"/>Other Protocols</h2></div></div></div><p>Flow management systems can track protocols other than ICMP, UDP, and TCP, but these three protocols comprise the overwhelming majority of network traffic. Your flow system will record traffic for protocols such as the AH and ESP protocols used for IPSec VPNs, but flows do not record the internal characteristics of this traffic.</p><p>For these less common protocols, a flow system records the protocol, time, number of packets, and other vital flow information.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-1" id="ftn.CHP-1-FN-1">1</a>] </sup>Of course, the No Starch Press website is fully dynamic, interactive, and individually generated for each viewer by a sophisticated self-modifying artificial intelligence, and it doesn't have any simple "individual objects." You should check it out. Buy something while you're there.</p></div></div></div>
<div class="sect1" title="Flow Export and Timeouts"><div class="titlepage"><div><div><h1 class="title"><a id="flow_export_and_timeouts"/>Flow Export and Timeouts</h1></div></div></div><p>Most medium to high-end routers and switches store flow data, but they don't necessarily provide a way for a human being to look at the flow data locally. Instead, to analyze flow records, you must first <span class="emphasis"><em>export</em></span> the flow records from the hardware to a computer. Flow sensors export their records when the corresponding network activity is complete or when a timeout expires.<a class="indexterm" id="IDX-CHP-1-0061"/><a class="indexterm" id="IDX-CHP-1-0062"/><a class="indexterm" id="IDX-CHP-1-0063"/></p><p>The exported record is not necessarily a complete TCP/IP session, however. For example, downloading an ISO image from an Internet site can take a very long time, and that session will probably be represented in several consecutive flow records.</p><p>Why break long-running sessions into multiple records? Suppose your router exported flow records only when each TCP/IP session finished. Now assume that one of your users started a large download likely to saturate your Internet connection for several hours. As the network administrator, you'll quickly get a call complaining that the Internet is really, really slow. To solve this problem, you'll want to identify what's happened on your network over the past few minutes, not just once the big download is complete. By breaking up the records of long-running connections into discrete flow records every few minutes, the router lets you view the data in close to real time. You can look at the flow records while this big download is still going on and identify the issue before it lasts all day. You can either shut down the offending user or, if the user is an executive or on the IT team, inform the caller the Internet will be slow for a while because of solar radiation interference and that they just have to wait.<a class="indexterm" id="IDX-CHP-1-0064"/></p><p>Network hardware creates flow records based on a configured <span class="emphasis"><em>timeout</em></span>, or the maximum amount of time the device can track an individual flow. When a particular connection lasts as long as the timeout, the device exports a flow record and creates a new record. For example, if your router had a one-minute flow timeout, it would export a record of the big download every minute. Although this record would not include the complete TCP session, you could look at your flow records and say, "During this minute, the biggest bandwidth user was this particular workstation downloading from this particular website." You have time to intervene if necessary.</p><p>Timeouts also help manage flow records for UDP, ICMP, and other non-TCP flows. The network device would create a flow record for each of these transactions. When the timeout expires, the device exports the flow record. Although a network device can't tell exactly when a UDP flow is finished, the timeout guarantees that the record of that is eventually exported.</p><p>You can change the timeout to fit your needs. I'll discuss the reasons for doing so later in this book, but you should know that changing the timeout impacts system resources. Increasing the timeout increases the memory and CPU the device needs for flow tracking.</p></div>
<div class="sect1" title="Packet-Sampled Flows"><div class="titlepage"><div><div><h1 class="title"><a id="packet-sampled_flows"/>Packet-Sampled Flows</h1></div></div></div><p>Flow export first appeared on routers with very limited hardware resources. On many of these devices, as interface bandwidths increased, tracking every packet required more horsepower than the router or tap could supply. Instead, the hardware <span class="emphasis"><em>sampled</em></span> packets to create flow data, recording and exporting only a specified fraction of the traffic passing through the device. This flow data was necessarily incomplete.<a class="indexterm" id="IDX-CHP-1-0065"/><a class="indexterm" id="IDX-CHP-1-0066"/><a class="indexterm" id="IDX-CHP-1-0067"/><a class="indexterm" id="IDX-CHP-1-0068"/></p><p>Today, most hardware can track most or all flows going through a machine in most small and medium-sized environments.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-2" id="CHP-1-FN-2">2</a>]</sup> Once you start to get into 10 gigabit networks, sampling 1 in 100 or 1 in 1,000 packets is the norm. As hardware capacity increases, we'll sample more fully, but bandwidth will increase similarly. Once terabit Ethernet becomes commonplace, I expect we'll have the capacity to perform flow capture on 10 gigabit Ethernet, if we'd even want that much data!<a class="indexterm" id="IDX-CHP-1-0069"/></p><p>Should you sample your network flows or record all of them? If at all possible, you should record all traffic that passes through your network. You should sample only if your hardware cannot support complete flow tracking. Sampling some data is better than not having any data, but recording as much detail as possible is far more useful for troubleshooting.</p><p>You should now have a good idea of how a flow system works, how its components fit together, and how to assemble a flow analysis system. Let's start with your flow-tools collector and your first sensor.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-2" id="ftn.CHP-1-FN-2">2</a>] </sup>I had a conversation with one of the senior techs at the Internet Software Consortium (ISC) about its flow export system. The ISC samples from its multiple gigabit Internet uplinks. If you, like ISC, have an amount of bandwidth that can be described only as " You have <span class="emphasis"><em>got</em></span> to be (bleep)ing kidding," you'll probably need to sample as well.</p></div></div></div></body></html>