- en: Chapter 1. FLOW FUNDAMENTALS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages651574.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I'll assume at this point that you're sold on the idea that flows can solve
    your problems. Now, let's get specific about what flows are, what they're good
    for, and how you can implement and analyze them. This chapter focuses on the flows
    commonly found on TCP/IP networks, specifically, TCP, UDP, and ICMP flows.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes you have a basic understanding of TCP/IP and tries to drag
    you into a deeper understanding of it. If you find yourself growing confused,
    I suggest you consult an introductory book such as Charles M. Kozierok's *The
    TCP/IP Guide* (No Starch Press, 2005). I also encourage you to spend quality time
    with a packet sniffer watching TCP/IP transactions in the real world because there's
    no better way to learn network protocols than observing them carrying out real
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Experienced network administrators might find that this chapter repeats topics
    they already know. If you already understand three-way handshake and if seeing
    `0x2` makes you think "TCP reset," then you might be tempted to skip this chapter.
    This chapter covers the material from a flow-based perspective, however, so if
    you decide to skip ahead, don't come sniveling to me when you get confused.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Flow?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strictly speaking, a *flow* is a series of packets that share the same source
    and destination IP addresses, source and destination ports, and IP protocol. This
    is also called a *five-tuple IP flow*. The word *flow* is also sometimes used
    to mean an aggregate of individual flows. A *flow record* is a summary of information
    about a flow, recording which hosts communicated with which other hosts, when
    this communication occurred, how the traffic was transmitted, and other basic
    information about the network conversation. A flow analysis system collects flow
    information and gives you a system to search, filter, and print flow information.
    Flow records summarize every connection on your network.
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to know what kind of traffic is filling your Internet T1, what a
    client PC is doing, or what kind of errors are reaching a server? Check the flow
    records. Want to know what happened on the network yesterday between 3 **am**
    and 3:05 **am**, when the file server mysteriously crashed and rebooted? Check
    yesterday's flow records.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that most network hardware can report traffic as flows. Having
    that hardware send flow information to a recording host imposes only a small overhead;
    you don't need to install anything.
  prefs: []
  type: TYPE_NORMAL
- en: Because flow records do not include the data exchanged by a network connection,
    flow records are small. For example, as I write this, my data center has a DS3,
    several T1s, a gigabit Ethernet backbone, and assorted smaller subnets and DMZs.
    Still, three complete years of flow records use less than 100GB of disk space.
    Granted, that's not trivial, but it's a small amount of disk space by modern standards
    and far less than that required to capture the complete contents of every exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Even with gigabytes of data, flow records do not allow unlimited troubleshooting.
    Anyone who has ever used a packet sniffer to watch a telnet or unencrypted web
    session understands that everything that traverses the network can be captured,
    analyzed, and reconstructed. A snooper can see exactly which websites a user visits,
    what files the user downloads, what the user transmits back to the site, and any
    usernames and passwords used in the exchange. Flow records do not contain this
    data; they simply tell the network administrator that a client visited a website
    running at a particular IP address, how many connections the user made to that
    site, how much data was exchanged, but not the contents of those exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Recording only flow information rather than complete packets might sound limited,
    but the NSA performs similar analysis on phone records to catch criminals and
    terrorists. Similarly, the wireless wiretapping at AT&T was discovered through
    netflow analysis. Knowing who talked to whom, when they talked, and how much each
    party said is terribly valuable.
  prefs: []
  type: TYPE_NORMAL
- en: FLOWS VS. SESSIONS
  prefs: []
  type: TYPE_NORMAL
- en: 'Different protocols describe network interaction with words such as *session*,
    *transaction*, and *conversation*. How do these differ from a flow? Remember that
    all traffic in a flow is going in the same direction. When a client connects to
    a web server and downloads a file, it creates a simple HTTP session. However,
    this one session (that is, this one transaction) is actually two flows: one going
    from the client to the server and another one going from the server to the client.
    Each flow mirrors the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Flow System Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical flow-based management system has three components: a sensor (or sensors),
    a collector, and a reporting system. Components can be combined as well, as you''ll
    learn in [Chapter 2](ch02.html "Chapter 2. COLLECTORS AND SENSORS").'
  prefs: []
  type: TYPE_NORMAL
- en: A *sensor*, also known as a *probe*, is a device that listens to the network
    and captures traffic data. The sensor may be a switch, router, or firewall with
    integrated flow export capability, or it might be a piece of software listening
    to an Ethernet tap or a switch port in monitor mode. The sensor tracks network
    connections, and after it believes a connection has finished or the connection
    reaches a timeout, it transmits the data.
  prefs: []
  type: TYPE_NORMAL
- en: The *collector* is software that receives sensor records and writes them to
    disk. The collector is an absolutely critical piece of your flow-based management
    infrastructure. Unfortunately, there's no universally accepted on-disk format
    for storing flow records. This complicates analysis and restricts the reporting
    tools you can use, but you'll learn how to work around that in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *reporting system* reads the collector files and produces human-friendly
    reports. The reporting system must understand the file format used by the collector.
  prefs: []
  type: TYPE_NORMAL
- en: You can find many different implementations of each component of a flow-based
    management system. Each hardware vendor's higher-end equipment has a flow sensor,
    and many people have written or implemented flow sensors for their preferred operating
    system. Several different collectors have come into prominence and faded, such
    as cflowd, and many people who wanted to demonstrate their mastery of the latest
    cool scripting language have written reporting systems to meet their particular
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: A newcomer might look at the vast array of options and decide that flow management
    is too complicated to even begin to attempt. What's worse, much of this software
    is obsolete, but Internet mailing list archives from, say, 1998 strongly recommend
    it. The neophyte can spend hours tracking down software only to discover that
    it can no longer be built with a modern compiler. Additionally, many possible
    combinations are subtly incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: This situation is beyond frustrating, and it makes many people abandon investigations
    into flow-based network management after only a couple hours.
  prefs: []
  type: TYPE_NORMAL
- en: This book presents a single set of software components that work together. The
    components either are still actively developed or have a widespread user base.
    The core platform is the flow-tools tool kit ([http://code.google.com/p/flow-tools/](http://code.google.com/p/flow-tools/)).
    Flow-tools has been the standard freely available flow collector and reporting
    software for many years now and is compatible with all common sensors. Additionally,
    many reporting tools leverage flow-tools' data format when correctly configured.
    You'll learn how to make flow-tools integrate with some other popular tools in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: The History of Network Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-speed router and switch hardware directs traffic without going to the operating
    system, in other words, without making each forwarding decision in software. Decisions
    on packet routing are made at the lowest level possible, generally within the
    hardware itself. Circa 1996, Cisco invented a method by which routing decisions
    were guided by flows. Subsequently, the value of flow information was realized,
    and it was made accessible to network administrators as a feature called NetFlow.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NetFlow has undergone several revisions through its history.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Version 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NetFlow version 1 was the earliest Cisco release. Other vendors reverse-engineered
    the NetFlow reporting protocol and released their own NetFlow-compatible reporting
    systems. A few vendors still support NetFlow version 1, and if this is all you
    have, it will still solve many problems for you. It contains only the minimal
    flow information.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Version 5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The oldest widely deployed flow record format is NetFlow version 5\. Many vendors,
    such as Juniper and Nokia, implemented this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetFlow version 5 includes seven key values: source IP address, destination
    IP address, source port (TCP and UDP protocols only), destination port, IP protocol,
    the interface the flow arrived on the system on, and the IP type of service. It
    also includes information about BGP, the exporter IP address, and a few other
    traffic characteristics. Although flow records have become more detailed over
    the years, NetFlow version 5 suffices for most environments.'
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Version 7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NetFlow version 7 is supported only by high-end Cisco Catalyst switches. Its
    flow record format includes switching and routing information not available in
    version 5, such as the IP address of the next hop address for the flow. If you
    have hardware that supports NetFlow version 7, this book will show you how to
    take advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Version 8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NetFlow version 8 is a cluster of similar formats that aggregate information.
    If you have many high-bandwidth connections and you must minimize the amount of
    resources you spend collecting and analyzing flow records, NetFlow version 8 might
    be useful. Cisco is the only vendor that supports it, however, and it's used only
    rarely. Given our ever-increasing computing power and disk capacity, however,
    NetFlow version 8 is usually not compelling.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Version 9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NetFlow version 9 is Cisco's final version. It is template-based and extensible,
    meaning that third-party vendors can add arbitrary information into a NetFlow
    record. Version 9 is also the first version to support IP version 6 (IPv6). NetFlow
    version 9 is deployed in only a few commercial products.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Competition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Cisco deployed more and more NetFlow versions, other networking companies
    saw the benefit of exporting and reporting on flow data. For example, Cisco developed
    NetFlow based on the needs of its own customers, which were not necessarily the
    needs of the global networking community. Other vendors implemented similar flow-based
    reporting based on the needs of their customers. As a result, NetFlow competitors
    appeared, the best known of which is sFlow. Some equipment from vendors such as
    3Com, HP, Extreme, and Juniper support sFlow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: sFlow is specifically not NetFlow because Cisco owns that word. People began
    to refer to *flow export* instead of *NetFlow* about the same time that sFlow
    was released.
  prefs: []
  type: TYPE_NORMAL
- en: As the number of competitors grew, the networking community saw the advantages
    of a common standards-defined flow export protocol. Current efforts focus on this
    standards-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: The Latest Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early 2000s, the Internet Engineering Task Force created a working group
    to define flow formats and prevent further flow format fragmentation. The working
    group chose to use NetFlow version 9 as the base protocol, with minor changes
    to make it friendlier. Cisco is still involved but now as a member rather than
    the sole controlling interest.
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of the network flow standard is called IP Flow Information
    eXport (IPFIX). Although many hardware vendors are implementing IPFIX support
    as well as support for older versions, the format is rarely deployed. IPFIX is
    much more complicated than earlier flow versions and uses more system resources.
    The differences between earlier NetFlow versions are evolutionary, but NetFlow
    version 9 and IPFIX represent dramatic breaks from earlier versions. People are
    also investigating using IPFIX to manage non-network data, such as security events.
  prefs: []
  type: TYPE_NORMAL
- en: The solutions you'll explore in this book address NetFlow versions 1 through
    7\. Versions 8 and 9 are rarely needed, and although IPv6 requires NetFlow version
    9 or newer, most of the world is not interested in IPv6 and will remain disinterested
    until IP version 4 address space shortages become intolerable. Once IPv6 is no
    longer optional, I expect vendors to jump directly to IPFIX. When IPFIX becomes
    more widespread, I have no doubt that the user community will add IPFIX support
    to the tools covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: NETFLOW VS. FLOW EXPORT
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes in this book I use the word *NetFlow*; other times I use *flow management*
    or *flow export*. The difference between them is that Cisco owns the word NetFlow,
    while other vendors support a NetFlow-compatible flow export technology. You might
    be using NetFlow, or you might be using a NetFlow-compatible flow export system,
    depending on your equipment. The difference is only semantic, but whenever possible,
    I avoid annoying any multinational firm that could crush me like a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Flows in the Real World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A *flow* is a series of packets that all share the same source and destination
    IP addresses, source and destination ports, and IP protocol." What the heck does
    that mean, really? Let''s pull this description apart and see what it really means
    in a few places in the real world. I''ll start with the simplest network traffic,
    a ping request and response, and then proceed to more complicated examples of
    DNS and HTTP requests.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although ICMP is most commonly associated with ping requests, it also carries
    the most basic instructions for Internet routing and management. Certain individual
    flows, such as ICMP redirects, can carry useful information, but to keep things
    simple, I'll cover the common ping.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP has no TCP-style flags and does not have ports like TCP and UDP do. Instead,
    ICMP packets are assigned an *ICMP type* and an optional *ICMP code*. The ICMP
    type identifies the general purpose of the packet. Ping requests and response
    messages have their own ICMP types, and an ICMP type might have associated ICMP
    codes that offer more detail. (You'll learn more about ICMP types and codes in
    [Chapter 3](ch03.html "Chapter 3. VIEWING FLOWS").)
  prefs: []
  type: TYPE_NORMAL
- en: To ping a server, the client creates an ICMP packet with a source address of
    the client and a destination address of the server. The client sets the ICMP type
    to 8, or `echo-request`, and sends the packet onto the network. This ping packet
    is the entirety of the first flow.
  prefs: []
  type: TYPE_NORMAL
- en: In response, the server creates an ICMP packet with the server's source address,
    the client's destination address, and an ICMP type of 0, or `echo-response`. This
    is the complete second flow.
  prefs: []
  type: TYPE_NORMAL
- en: That said, if your client sends multiple ping requests, the flow system assigns
    subsequent pings to the same flow. A Windows system, for example, normally sends
    five ping requests and expects five ping replies. Your flow system records a single
    flow containing five requests and a separate flow containing five responses.
  prefs: []
  type: TYPE_NORMAL
- en: A flow sensor has no way of knowing when ICMP flows are complete, because the
    traffic contains no internal markers that say "No further packets will arrive."
    The sensor holds ICMP flows in memory until a timeout expires, at which point
    the sensor marks the flows as complete and transmits them to the collector.
  prefs: []
  type: TYPE_NORMAL
- en: UDP Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now consider a basic DNS request to see how UDP flows function. UDP sessions
    are slightly more complex than ICMP flows: Although UDP doesn''t use types and
    codes like ICMP and doesn''t have flags like TCP, UDP uses TCP-style port numbers.
    Also, UDP has no built-in concept of a session or transaction, which is why people
    describe it as *connectionless*. UDP does carry useful application-level data,
    however, and most UDP traffic is part of some sort of session or transaction.
    The most common UDP flows on the average network are DNS requests. A DNS request
    is among the simplest possible network requests and produces the shortest flows
    you''ll see. Other UDP network protocols, such as bootp, generate many more packets
    per flow, but to understand flows, you''ll look at the humble DNS request here.'
  prefs: []
  type: TYPE_NORMAL
- en: A client connecting to a DNS server creates a UDP packet with a source IP of
    the client and a destination IP of the server. As with TCP, the UDP request originates
    from an unused port on the client side and uses the standard DNS port 53 as its
    destination. A simple DNS query, such as a request for the address of [www.nostarch.com](http://www.nostarch.com),
    fits entirely within one packet. This single packet is the start of the third
    sample flow.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth flow begins when a server responds by creating a UDP packet with
    a source IP of the server and a destination IP of the client. Similarly, the source
    and destination ports are reversed from the packet sent by the client. A DNS response
    containing the information for a typical site also fits entirely within one packet.
  prefs: []
  type: TYPE_NORMAL
- en: These flows are now complete, and no more traffic will be passed as part of
    them. You can see these flows in [Figure 1-1](ch01s04.html#udp_network_transaction_with_flow_member
    "Figure 1-1. UDP network transaction with flow memberships").
  prefs: []
  type: TYPE_NORMAL
- en: '![UDP network transaction with flow memberships](httpatomoreillycomsourcenostarchimages651576.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1. UDP network transaction with flow memberships
  prefs: []
  type: TYPE_NORMAL
- en: Because UDP is connectionless, the network traffic contains no markers to tell
    an observer that a particular conversation is complete. The packets have no TCP-esque
    FIN flag that announces "I'm done, so hang up now," so a flow sensor has no way
    to know that the flows are complete. The sensor holds those flows in memory until
    a timeout expires, at which point the sensor marks the flows as complete and transmits
    them to the collector.
  prefs: []
  type: TYPE_NORMAL
- en: TCP Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most complicated network flows that I'll cover are TCP flows, such as those
    used by web servers and browsers. The TCP protocol includes ports such as those
    used by UDP but also includes internal flags that indicate the state of the connection.
    TCP tells the client and the server whether a connection is being requested, ongoing,
    or being torn down. For example, now that you have an IP address for [www.nostarch.com](http://www.nostarch.com),
    let's look at a web client requesting a single, static, simple web object from
    that site.^([[1](#ftn.CHP-1-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: The fifth flow begins when a client connecting to a web server sends a single
    packet to the server with a source IP of the client and a destination IP of the
    server. The client allocates an unused port on the local system for exclusive
    use by this connection, which is the packet's *source port*. Web servers typically
    run on port 80, so this is the packet's destination port. On the first packet
    in the connection, the client sets the synchronization (SYN) request flag (this
    initial packet is usually referred to as a *SYN request*). The client is contacting
    the server, saying "Hey, can I talk to you?"
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives a SYN request on port 80 and decides to accept the
    connection, it prepares a *response packet*. This response packet has a source
    address of the server and a destination address of the client. The source port
    is 80, the port requested by the client; the destination port is the earlier packet's
    source port.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth flow is the packet sent as a response to a SYN packet, so the server
    sets the acknowledgment (ACK) flag. Because the server hasn't sent any packets
    in this TCP/IP conversation before, it also sets the SYN flag to request synchronization
    (commonly called the *SYN-ACK packet*).
  prefs: []
  type: TYPE_NORMAL
- en: A second flow in one network transaction? Yep. Remember, a single flow shares
    the same source and destination IP addresses, among other things. You have one
    flow with a source address of the client and a second with the source address
    of the server. The source port of one flow matches the destination port of the
    other flow, permitting you to match the two together, but these are two separate
    flows. Flows let you determine how much traffic goes in each direction in any
    given transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the client receives the server''s response, it matches the incoming packet
    with the connection it''s trying to establish with that server. The client responds
    with a packet to the server from the assigned local port. The connection is now
    synchronized: Both the client and the server know the IP addresses involved in
    the connection and the port numbers on each side (as well as sequence numbers
    and other assorted characteristics that uniquely identify this connection). Because
    this packet is part of an existing connection, the SYN flag is not required. The
    client must acknowledge the SYN request the server included in its last packet,
    however, so this next packet includes the ACK flag.'
  prefs: []
  type: TYPE_NORMAL
- en: This packet from client to server might be the third in the transaction, but
    it's the second sent by the client to the server. It shares the source and destination
    IP addresses and port numbers of the first packet in the transaction, both of
    which are using the same IP protocol (TCP). This third packet is the second packet
    in the first flow. ([Figure 1-2](ch01s04.html#tcp_three-way_handshake_with_flow_member
    "Figure 1-2. TCP three-way handshake with flow memberships") illustrates this
    three-way handshake, noting the flows to which each packet is assigned.)
  prefs: []
  type: TYPE_NORMAL
- en: '![TCP three-way handshake with flow memberships](httpatomoreillycomsourcenostarchimages651578.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2. TCP three-way handshake with flow memberships
  prefs: []
  type: TYPE_NORMAL
- en: Now that a connection exists, the client may transmit actual data, such as an
    HTTP GET request. The GET request is part of the first flow, from client to server.
    The server's response, including any HTML, images, or error codes, becomes part
    of the second flow, from server to client. Packets now stream back and forth,
    including ACKs as required to acknowledge receipt of earlier packets.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the transaction, one side or the other sends a packet with the
    "finish" (FIN) flag set. This packet is called a *FIN request*, and it marks the
    end of the TCP/IP session. The other system sends an ACK and then a FIN of its
    own. The client sends an ACK to the final FIN, closing the connection. The flow
    sensor sees the FINs and ACKs, terminates both flows, and immediately transmits
    the TCP flow records to the collector.
  prefs: []
  type: TYPE_NORMAL
- en: Other Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flow management systems can track protocols other than ICMP, UDP, and TCP, but
    these three protocols comprise the overwhelming majority of network traffic. Your
    flow system will record traffic for protocols such as the AH and ESP protocols
    used for IPSec VPNs, but flows do not record the internal characteristics of this
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: For these less common protocols, a flow system records the protocol, time, number
    of packets, and other vital flow information.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-1-FN-1)]) Of course, the No Starch Press website is fully dynamic,
    interactive, and individually generated for each viewer by a sophisticated self-modifying
    artificial intelligence, and it doesn't have any simple "individual objects."
    You should check it out. Buy something while you're there.
  prefs: []
  type: TYPE_NORMAL
- en: Flow Export and Timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most medium to high-end routers and switches store flow data, but they don't
    necessarily provide a way for a human being to look at the flow data locally.
    Instead, to analyze flow records, you must first *export* the flow records from
    the hardware to a computer. Flow sensors export their records when the corresponding
    network activity is complete or when a timeout expires.
  prefs: []
  type: TYPE_NORMAL
- en: The exported record is not necessarily a complete TCP/IP session, however. For
    example, downloading an ISO image from an Internet site can take a very long time,
    and that session will probably be represented in several consecutive flow records.
  prefs: []
  type: TYPE_NORMAL
- en: Why break long-running sessions into multiple records? Suppose your router exported
    flow records only when each TCP/IP session finished. Now assume that one of your
    users started a large download likely to saturate your Internet connection for
    several hours. As the network administrator, you'll quickly get a call complaining
    that the Internet is really, really slow. To solve this problem, you'll want to
    identify what's happened on your network over the past few minutes, not just once
    the big download is complete. By breaking up the records of long-running connections
    into discrete flow records every few minutes, the router lets you view the data
    in close to real time. You can look at the flow records while this big download
    is still going on and identify the issue before it lasts all day. You can either
    shut down the offending user or, if the user is an executive or on the IT team,
    inform the caller the Internet will be slow for a while because of solar radiation
    interference and that they just have to wait.
  prefs: []
  type: TYPE_NORMAL
- en: Network hardware creates flow records based on a configured *timeout*, or the
    maximum amount of time the device can track an individual flow. When a particular
    connection lasts as long as the timeout, the device exports a flow record and
    creates a new record. For example, if your router had a one-minute flow timeout,
    it would export a record of the big download every minute. Although this record
    would not include the complete TCP session, you could look at your flow records
    and say, "During this minute, the biggest bandwidth user was this particular workstation
    downloading from this particular website." You have time to intervene if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts also help manage flow records for UDP, ICMP, and other non-TCP flows.
    The network device would create a flow record for each of these transactions.
    When the timeout expires, the device exports the flow record. Although a network
    device can't tell exactly when a UDP flow is finished, the timeout guarantees
    that the record of that is eventually exported.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the timeout to fit your needs. I'll discuss the reasons for doing
    so later in this book, but you should know that changing the timeout impacts system
    resources. Increasing the timeout increases the memory and CPU the device needs
    for flow tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Packet-Sampled Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flow export first appeared on routers with very limited hardware resources.
    On many of these devices, as interface bandwidths increased, tracking every packet
    required more horsepower than the router or tap could supply. Instead, the hardware
    *sampled* packets to create flow data, recording and exporting only a specified
    fraction of the traffic passing through the device. This flow data was necessarily
    incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Today, most hardware can track most or all flows going through a machine in
    most small and medium-sized environments.^([[2](#ftn.CHP-1-FN-2)]) Once you start
    to get into 10 gigabit networks, sampling 1 in 100 or 1 in 1,000 packets is the
    norm. As hardware capacity increases, we'll sample more fully, but bandwidth will
    increase similarly. Once terabit Ethernet becomes commonplace, I expect we'll
    have the capacity to perform flow capture on 10 gigabit Ethernet, if we'd even
    want that much data!
  prefs: []
  type: TYPE_NORMAL
- en: Should you sample your network flows or record all of them? If at all possible,
    you should record all traffic that passes through your network. You should sample
    only if your hardware cannot support complete flow tracking. Sampling some data
    is better than not having any data, but recording as much detail as possible is
    far more useful for troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a good idea of how a flow system works, how its components
    fit together, and how to assemble a flow analysis system. Let's start with your
    flow-tools collector and your first sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-1-FN-2)]) I had a conversation with one of the senior techs at the
    Internet Software Consortium (ISC) about its flow export system. The ISC samples
    from its multiple gigabit Internet uplinks. If you, like ISC, have an amount of
    bandwidth that can be described only as " You have *got* to be (bleep)ing kidding,"
    you'll probably need to sample as well.
  prefs: []
  type: TYPE_NORMAL
