<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page261"/><img src="../images/285-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter15"/><a href="toc.html#chapter15"><b>IMPLEMENTING YOUR SNMP MIB</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">In this chapter we will implement the MIB we developed in Chapter 14 by writing an extension to the Net-SNMP agent to add support for the LAD-MIB. We’ll cover the following topics:</p>&#13;
<ul>&#13;
<li>The Net-SNMP Agent</li>&#13;
<li>The MIB skeleton: mib2c</li>&#13;
<li>The header file: ladProject.h</li>&#13;
<li>The code file: ladProject.c</li>&#13;
<li>Makefile revisited</li>&#13;
<li>Debugging</li>&#13;
<li>Traps</li>&#13;
</ul>&#13;
<p class="indent">Remember that our goal is to implement a working SNMP agent that supports our MIB. When queried for the objects we have defined, the agent will respond with the current values of those objects. We will also be able to assign values to the objects we defined with read-write access. For example, we will be able to use the snmptable command to retrieve values from the Alarm table, as shown below. Don’t be too concerned with the format of this command (though if you read Chapter 13, you should be familiar with it). The snmptable command retrieves the ladAlarmTable from a system called myappliance using SNMPv2 and the community name <i>public;</i> then it displays the table row by row to make it easy to read.</p>&#13;
<p class="imgl"><a id="page262"/><img src="../images/286-1.jpg" alt=""/></p>&#13;
<p class="indent">The SNMP commands will allow remote access to information kept within the ladd daemon’s internal data structures. As shown in Figure 15-1, SNMP is used between the remote system and the SNMP agent. The agent then uses PostgreSQL to request the information from RTA running within the ladd daemon.</p>&#13;
<p class="imgc"><img src="../images/286-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 15-1: SNMP agent as go-between</i></p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>You will notice some differences in file placement in this chapter compared with Chapter 13, because here we are designing the agent for the appliance itself. For clarity, we will be keeping our files under /opt rather than distributing them around the filesystem in their normal default locations.</i></p>&#13;
<p class="secl"><a id="chapter15.1"/><a href="toc.html#chapter15.1"><b>The Net-SNMP Agent</b></a></p>&#13;
<p class="noindent">We’ll be extending the Net-SNMP agent, so we’ll need to download the source tarball, which we can find at <a href="http://net-snmp.sourceforge.net/">http://net-snmp.sourceforge.net</a>. As of this writing, version 5.2.1 is current, so we’ll retrieve net-snmp-5.2.1.tar.gz. No doubt by the time you read this, Net-SNMP will be several releases ahead, but you can just grab the most current version. The process for extending the agent that we will be describing in this chapter hasn’t changed significantly in all the time the we have been working with it (that is, since at least UCD-SNMP 4.1).</p>&#13;
<p class="indent">Our goal is to set up a way of building our agent that will make it easy to download a new release of Net-SNMP in the future and just drop it into a build. The plan is to create a Makefile that will untar Net-SNMP, copy the agent extensions into the right location in the build tree, configure the Net-SNMP agent to include the extensions, and then build it. To upgrade to a newer version of Net-SNMP, all you need to do is drop a new version of the Net-SNMP source tarball into the directory and change the one line of the Makefile that defines the Net-SNMP version. We don’t have our extension ready yet, so let’s just start by untarring and building the vanilla agent. This will allow us to test the process before we complicate things with our MIB. The following is a simplified version of the Makefile you’ll find on the CD that comes with this book:</p>&#13;
<p class="imgl"><a id="page263"/><img src="../images/287-1.jpg" alt=""/></p>&#13;
<p class="indent">If you are using a newer version of Net-SNMP, just drop your tarball into the same directory as the Makefile, change <img src="../images/1.jpg" alt=""/> the NETSNMP_VERSION line to match your version, and continue with the instructions below.</p>&#13;
<p class="indent">We’ll put the Makefile and configure input files into the same directory as the tarball we just downloaded. Configure.input contains the interactive answers expected by the configure step. The -prefix option tells configure to use the /opt/snmp prefix to our file locations. Installation of Net-SNMP follows the familiar</p>&#13;
<p class="ex">./configure<br/>make<br/>make install</p>&#13;
<p class="noindent">steps of most Linux source packages, though we will let the Makefile do this for us.</p>&#13;
<p class="noindent1">Here’s what our configure.input looks like:</p>&#13;
<p class="ex">&lt;blank line&gt;<br/>2<br/>Not Set<br/>Not Set<br/>/var/log/snmpd.log<br/>/var/net-snmp</p>&#13;
<p class="indent"><a id="page264"/>The first line must be blank because the configure script asks us to hit <small>ENTER</small> when we are ready to enter the input.</p>&#13;
<p class="indent">The 2 selects SNMPv2 as our default version of SNMP. This doesn’t really apply to the agent because it takes its cue from the requests received, but the Net-SNMP package contains the source for management applications like snmpget and snmpwalk, as well.</p>&#13;
<p class="indent">The two Not Set lines are for system contact and system location (objects available in MIB-2). We will be overriding these values in our agent configuration file, so we’ll just set these objects to the string Not Set.</p>&#13;
<p class="indent">The next two lines are the default log file and persistent storage locations.</p>&#13;
<p class="indent">Give this a try by typing <b>make</b>. It will build the Net-SNMP applications (snmpget, snmpwalk, etc.), the libraries, and the agent. If it doesn’t work, try executing the steps by hand, without the Makefile. First untar the tarball and drop down into the directory it generates. Then run <b>./configure</b> and answer the questions as we have laid them out in configure input, above. Check the output from configure to see if you are missing something, like a library you need to install. If you don’t see anything wrong, type <b>make</b> (in the net-snmp.5.2.1 directory) and watch for errors. You can’t move on until this works.</p>&#13;
<p class="indent">Once you get make working, install Net-SNMP onto your development system. As root, type</p>&#13;
<p class="ex">make install</p>&#13;
<p class="indent">This will install files in several directories under /opt/snmp.</p>&#13;
<p class="ex">$ ls /opt/snmp<br/>bin/ include/ lib/ man/ sbin/ share/</p>&#13;
<p class="indent">The /opt/snmp directory tree is our staging area for the files we will need to copy to our appliance to get the agent working there. We won’t need the include or man directories on our appliance.</p>&#13;
<p class="indent">We may also decide to remove client applications like snmpget and snmpset from the bin directory on our appliance, but be sure <i>not</i> to remove snmptrap, since we will be using that to send traps from our appliance. The other commands may come in handy if we ever need to log in to the box for debugging or if we want to invoke them from the CLI or web interface for diagnostic purposes, but they are not necessary for the functioning of the agent or the sending of traps.</p>&#13;
<p class="indent"><a id="page265"/>The agent itself, snmpd, will be in the /opt/snmp/sbin directory, along with snmptrapd. We can remove snmptrapd, because it will not be needed on our appliance. You should keep it on your development system, though—it will come in handy when you want to test your ability to send traps.</p>&#13;
<p class="indent">MIB files reside in /opt/snmp/share/snmp/mibs. They are not strictly necessary for the appliance, but there are reasons we may want to include them. First, we may want to simplify creation of the filters used to send traps (see the example on logmuxd and SNMP traps in Chapter 7). Second, we may want to deliver them on the appliance for use by the customer’s network management software.</p>&#13;
<p class="indent">If we want to use the human-readable names for numeric object identifiers (OIDs) in logmuxd filters, we will have to tell the snmptrap command where to find these MIB files. We can either add these options to the command line used to invoke snmptrap:</p>&#13;
<p class="ex">-m ALL -M /opt/snmp/share/snmp/mibs</p>&#13;
<p class="noindent">or make these environment variables available to it:</p>&#13;
<p class="ex">export MIBS=ALL<br/>export MIBDIRS=/opt/snmp/share/snmp/mibs</p>&#13;
<p class="indent">This tells the SNMP commands (snmpget, snmpset, snmpwalk, snmptrap, and so on) to use all the MIB files found in the /opt/snmp/share/snmp/mibs directory.</p>&#13;
<p class="indent">Although you may be removing things from this staging area before installing the software on your appliance, let’s not do that quite yet. We’ll need some of what’s there for creating our MIB extension. In fact, you should add /opt/snmp/bin to your environment variable, like so:</p>&#13;
<p class="ex">export PATH=/opt/snmp/bin:$PATH</p>&#13;
<p class="indent">Now it’s time to move on and create the agent extension and implement the MIB.</p>&#13;
<p class="secl"><a id="chapter15.2"/><a href="toc.html#chapter15.2"><b>The MIB Skeleton: mib2c</b></a></p>&#13;
<p class="noindent">Net-SNMP kindly provides a utility that can read an MIB file and produce skeleton code for an agent extension. Later in this chapter, we’ll show you how to flesh out this skeleton into a complete implementation of your MIB.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>Net-SNMP provides multiple output code styles for mib2c; we will be using the older UCD-SNMP code style. The newer, so-called “MIB for Dummies” style is not what this chapter describes. We have chosen to use the older style because it’s sufficient for our needs (and it’s also where our experience lies).</i></p>&#13;
<p class="indent1">Before we can run mib2c, you’ll need to install the SNMP Perl module, which is provided in the Net-SNMP tarball. When you ran make earlier, it decompressed this tarball and created the directory net-snmp-5.2.1 (or whatever version you used). Drop down into this directory and then to perl/SNMP. There you’ll find a README file to explain how to build and install the SNMP Perl module. Alternatively, you can install the libsnmp-perl package if one is provided by your Linux distribution.</p>&#13;
<p class="indent"><a id="page266"/>We also need to make our MIB files (LADDIE-GROUP-SMI.txt and LAD-MIB.txt, which we created in Chapter 12) available to mib2c by copying them into the directory containing our other MIBs (/opt/snmp/share/ snmp/mibs). Or, if you prefer, you can add a period (.) to your MIBDIRS list like this:</p>&#13;
<p class="ex">export MIBDIRS=.:/opt/snmp/share/snmp/mibs</p>&#13;
<p class="indent">Now let’s run mib2c to generate the skeleton code. You’ll want to be in the same directory as your MIB files if you added the . to your directory path. Please note that we provide mib2c with a MIB module or OID, not the name of the MIB file.</p>&#13;
<p class="imgl"><img src="../images/290-1.jpg" alt=""/></p>&#13;
<p class="indent">In the middle of all this, you will see the following at line  <img src="../images/1.jpg" alt=""/>:</p>&#13;
<p class="imgl"><a id="page267"/><img src="../images/291-1.jpg" alt=""/></p>&#13;
<p class="indent">We use option one because that’s where we have experience. You may want to try the newer and more flexible Net-SNMP type, but we don’t need that flexibility for what we’re doing here.</p>&#13;
<p class="secl"><a id="chapter15.3"/><a href="toc.html#chapter15.3"><b>The Header File: ladProject.h</b></a></p>&#13;
<p class="noindent">Two files have been generated for us: ladProject.c and ladProject.h. The header file, ladProject.h, is short and sweet, and we won’t need to bother ourselves with it further. Here’s what it looks like:</p>&#13;
<p class="imgl"><img src="../images/291-2.jpg" alt=""/></p>&#13;
<p class="indent">These are prototypes for routines generated for us in the code file, ladProject.c.</p>&#13;
<p class="secl"><a id="chapter15.4"/><a href="toc.html#chapter15.4"><b>The Code File: ladProject.c</b></a></p>&#13;
<p class="noindent">The ladProject.c file is the one we’ll be modifying. Rather than describing the generated code and then making a second pass through it to add our modifications, we’ll just step through it, making our changes as we go. We’ll distinguish the code we add from what mib2c generated using bold text. Specifically, we need to make the following modifications to the generated skeleton code:</p>&#13;
<ol>&#13;
<li>Include the header for libpq (the PostgreSQL library).</li>&#13;
<li>Provide a function to connect to RTA in the ladd daemon.</li>&#13;
<li>Provide functions to read and write RTA tables over the connection to the ladd daemon.</li>&#13;
<li>Provide code to read each scalar in the MIB.</li>&#13;
<li><a id="page268"/>Provide code to read each table object in the ladAlarmTable.</li>&#13;
<li>Provide a write function for each writable object in the MIB.</li>&#13;
</ol>&#13;
<p class="secs"><a id="chapter15.5"/><a href="toc.html#chapter15.5"><i><b>Includes</b></i></a></p>&#13;
<p class="noindent">We begin by including the necessary header files. Remember, we will be marking our additions and modifications in bold.</p>&#13;
<p class="imgl"><img src="../images/292-1.jpg" alt=""/></p>&#13;
<p class="indent">Here we have accomplished our first goal by including <img src="../images/1.jpg" alt=""/> the header file that defines the libpq PostgreSQL API.</p>&#13;
<p class="secs"><a id="chapter15.6"/><a href="toc.html#chapter15.6"><i><b>The Base OID</b></i></a></p>&#13;
<p class="noindent">In this code, the comment generated by mib2c basically says it all. This is the base OID for all the objects defined in our MIB.</p>&#13;
<p class="imgl"><img src="../images/292-2.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter15.7"/><a href="toc.html#chapter15.7"><i><b>MIB Objects Definitions</b></i></a></p>&#13;
<p class="noindent">The next bit of code defines all the <i>leaf objects</i> in our MIB, by which we mean all the objects for which we will be returning values. A define is generated for each of these leaf objects to give a unique number to each object we will be processing. The name of the define is an all-uppercase version of the object name from the MIB file; for example, ladVersion becomes LADVERSION.</p>&#13;
<p class="indent"><a id="page269"/>Each object also has its own entry in the ladProject_variables table (shown below), which provides the following information for the object:</p>&#13;
<ul>&#13;
<li>A unique identifier to be used later in our case statements (the define name we just discussed)</li>&#13;
<li>The data type</li>&#13;
<li>Whether it is read-only or read-write</li>&#13;
<li>The function that will be called to read the object’s value</li> <li>The OID suffix, which, when appended to the base OID, will give the complete OID of the object</li>&#13;
</ul>&#13;
<p class="indent">We find the raw output of mib2c to be a little hard to read because the defines for the unique identifier values are mixed in with the table row definitions. In an attempt to make this more accessible, we have rearranged it a bit to put all the defines together and line everything up in columns. Unfortunately, mib2c has not generated perfect code for us, but we’ll take advantage of this to give a lesson on what should have been generated. Tools like mib2c are great time savers, but you should always be aware of what should have been generated and remember to check the output. Ultimately, you will be responsible for the code working properly. First, let’s take a look at the code, and then we’ll discuss the problems we see.</p>&#13;
<p class="imgl"><img src="../images/293-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page270"/><img src="../images/294-1.jpg" alt=""/></p>&#13;
<p class="indent">The first problem above is that the generated code includes <img src="../images/1.jpg" alt=""/> ladTrapZoneId and <img src="../images/2.jpg" alt=""/> ladTrapZoneName as readable objects, but it shouldn’t. These objects are only used in traps, and they are not readable or writable by the agent, so we have no code to write for them and will not need to indicate a callback for them here. We should remove these two lines.</p>&#13;
<p class="indent">Second, the OID suffix field is wrong for every object here. You append this suffix to the base OID (ladProject_variables_oid, defined in the previous section) to get the OID of the individual object. This is how we defined the base OID:</p>&#13;
<p class="imgl"><img src="../images/294-2.jpg" alt=""/></p>&#13;
<p class="indent">So, for example, the OID for ladAlarmState in the generated code should be:</p>&#13;
<p class="ex">{ 1, 3, 6, 1, 4, 1, 23528, 1, 1, 1, 1, 5 };</p>&#13;
<p class="indent">Let’s see if this is right. We can check it by running snmptranslate.</p>&#13;
<p class="ex">$ snmptranslate -On LAD-MIB:ladAlarmState .1.3.6.1.4.1.23528.1.1.1.2.1.1.5</p>&#13;
<p class="indent">That’s certainly not right. We’re missing two nodes from our OID hierarchy. If you perform this snmptranslate test on each of the scalars in the LAD-MIB, you’ll find they are all missing the numbers for ladSystem (1) and ladSystemScalars (1). If you repeat the test for the table columns, you’ll see that they are missing ladSystem (1) and ladSystemTables (2). This is like missing a few directory levels from a file pathname.</p>&#13;
<p class="indent">Let’s fix this table before we move on. Here is the corrected code, with the added numbers in bold:</p>&#13;
<p class="imgl"><img src="../images/294-3.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page271"/><img src="../images/295-1.jpg" alt=""/></p>&#13;
<p class="indent">That’s better. We’ve removed the objects from the trapInfo section, corrected the OIDs, and corrected the length of the suffix. Note also that we had to change the struct type we are using as a template for this array from variable4 to variable7, because our OIDs are now longer. A few different structs are provided by the Net-SNMP headers for different lengths of OIDs. You don’t want to use excess memory, but you do need a struct long enough for the longest suffix you will be defining. When we increased our suffix length from three to five for our table objects, we exceeded the length of variable4, and the next longer one is variable7. You can find these structures defined in var_struct.h in the directory include/net-snmp/agent, under the net-snmp-5.2.1 directory. You can look here for what’s available in case you need an even longer struct. See how variable7 is defined:</p>&#13;
<p class="imgl"><img src="../images/295-2.jpg" alt=""/></p>&#13;
<p class="indent">Notice the length of <img src="../images/1.jpg" alt=""/> the name field.</p>&#13;
<p class="secs"><a id="chapter15.8"/><a href="toc.html#chapter15.8"><i><b>RTA Access Routines</b></i></a></p>&#13;
<p class="noindent">Now we need to insert the functions we’ll be using to connect and communicate with the ladd daemon: lad_connect(), query(), and update().</p>&#13;
<p class="imgl"><img src="../images/295-3.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page272"/><img src="../images/296-1.jpg" alt=""/></p>&#13;
<p class="indent">We have defined <img src="../images/1.jpg" alt=""/> a global variable to hold the handle for our connection to Laddie and <img src="../images/2.jpg" alt=""/> the function to establish this connection, lad_connect. Notice the use of PQconnectdb, PQStatus, PQerrorMessage, and PQfinish. These are functions provided in libpq; you can read more about them in the documentation PostgreSQL provides for this library. Basically, we are attempting a connection to port 8888 (the port the ladd daemon decided to use) on local-host. If we fail, we return resources (PQfinish), log an error message using the DEBUGMSGTL macro we saw earlier, and return an error. Otherwise, we return success. Take note that DEBUGMSGTL takes a format statement and parameters like printf, but it requires an extra set of parentheses. We have replaced the default ladProject strings in the DEBUGMSGTL calls with the shorter LAD, just to save some horizontal space in our examples. The unchanged generated code you will see below uses ladProject by default. You should make these consistent in your code; that is, if you add new DEBUGMSGTL statements, use the same value mib2c generated. You are not required to keep the DEBUGMSGTL strings consistent with your project name, but it avoids confusion to do so. We only make the change in these examples to prevent line wrap, due to the limited horizontal space on a book’s printed page. You won’t need to do this in your code.</p>&#13;
<p class="indent">We follow this with our function to read values from RTA tables. You pass it the table and field names, a filter string (you might use this to select a table row), options, a buffer to return the value from the table, and the length of that buffer. We haven’t made any provisions for querying more than a single field from an RTA table at one time. (This isn’t really a problem, since Net-SNMP will only pass us one MIB object at a time to read.) While it’s true that a single MIB object could require reading multiple RTA tables—that is, there needn’t be a one-to-one correspondence between RTA fields and MIB objects—our MIB for Laddie does not require this.</p>&#13;
<p class="imgl"><img src="../images/296-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page273"/><img src="../images/297-1.jpg" alt=""/></p>&#13;
<p class="indent">We start by checking that <img src="../images/1.jpg" alt=""/> our connection to Laddie is still valid. If it is not, we reconnect by calling lad_connect(). Then we construct our query string and <img src="../images/2.jpg" alt=""/> execute the query using Pqexec(). The application programming interface (API) of the PostreSQL library allows you to request multiple values in a single query, which is why the result is returned as a list of tuples. We check that our tuples are okay. If they aren’t, we clean up, return resources, and <img src="../images/3.jpg" alt=""/> return an error to our caller. Otherwise, we extract the first value returned (there should only be one, in our case), return it in the buffer provided to us, then <img src="../images/4.jpg" alt=""/> return success.</p>&#13;
<p class="indent">The code below is very similar to the query routine above, but it builds an update request for writing to the field, then passes it to libpq. This is the routine our MIB write routines will call.</p>&#13;
<p class="imgl"><img src="../images/297-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page274"/><img src="../images/298-1.jpg" alt=""/></p>&#13;
<p class="indent">We should point out that these are just simple, generic routines for reading from and writing to a PostgreSQL database and, thus, RTA tables. There is nothing SNMP-specific or Laddie-specific about them. You could use them in any application written in C that needs to access RTA tables from another application on the same system—the only thing you’d need to change is the port number.</p>&#13;
<p class="secs"><a id="chapter15.9"/><a href="toc.html#chapter15.9"><i><b>The Initialization Routine</b></i></a></p>&#13;
<p class="noindent">Now we come to the fairly simple initialization routine that mib2c generated for us. Notice that we made no changes to the generated code. We could have put a call to lad_connect() here, but we refrained, for the sake of simplicity. Our first call to the query() or update() routines we defined above will detect that the connection does not exist and then create it for us.</p>&#13;
<p class="imgl"><img src="../images/298-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page275"/><img src="../images/299-1.jpg" alt=""/></p>&#13;
<p class="indent">The <img src="../images/1.jpg" alt=""/> REGISTER_MIB line will register your OID subtree with the central agent code so it will know to call you to read and write the objects in this subtree. Notice that we had to change the variable4 to variable7 here, as well.</p>&#13;
<p class="secs"><a id="chapter15.10"/><a href="toc.html#chapter15.10"><i><b>The Scalars</b></i></a></p>&#13;
<p class="noindent">The next routine is where all reads of scalars are processed. <i>Scalars</i> are leaf objects in the MIB (that is, they are not accessed by indexing into a table).</p>&#13;
<p class="indent">Before we dive into this function, let’s take a moment to look at the input parameters. They are described quite nicely in the AGENT.txt file that is provided with the Net-SNMP package (highly recommended reading, by the way), but we’ll summarize them here:</p>&#13;
<ul>&#13;
<li>vp is a pointer to the relevant entry in the array we discussed in the section “MIB Objects Definitions” on page 268.</li>&#13;
<li>name is the OID from the request, and length is the length of this OID.</li>&#13;
<li>exact indicates whether you are processing a request for the exact OID passed to you, like a GET or SET, or one that requires you to find the OID to process, like a GETNEXT. (GETNEXT is why name and length are also output parameters. You have to set them appropriately for GETNEXT requests to indicate the OID for which you are returning a value.)</li>&#13;
<li>var_len is an output parameter that the function must set to the length of the data being returned.</li>&#13;
<li>write_method is also an output parameter and is used to point to the function that will handle a SET for any of the OIDs you have made SET-able.</li>&#13;
<li>The function returns the value of the data requested, or a NULL if the data is not available.</li>&#13;
</ul>&#13;
<p class="indent">Now let’s tackle the body of the function. We have reformatted some of the lines to better fit the printed page, but otherwise, most of this routine remains as it was generated. We have highlighted the few lines that needed to be added or changed to retrieve the values from the RTA tables in the Laddie daemon. As you can see, very little work needs to be done in the SNMP agent to retrieve the readable values in our MIB. Each object requires a single access of a field in Laddie’s RTA-accessible tables.</p>&#13;
<p class="imgl"><img src="../images/299-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page276"/><img src="../images/300-1.jpg" alt=""/></p>&#13;
<p class="imgl"><img src="../images/300-2.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page277"/>Our only changes are in the switch statement. We call our query() routine to retrieve values from RTA tables in Laddie to fulfill the request. The value of ladVersion comes from the version field of Laddie’s Config table. We added <img src="../images/1.jpg" alt=""/> the options LIMIT 1 OFFSET 1 because the Config table has multiple rows for different purposes. Each row has a version field, but we only want one answer to our request, so we use the option LIMIT 1. We also want the second row of the table, so we add the option OFFSET 1.</p>&#13;
<p class="indent">We don’t have any such problem with the number of zones, which we take simply from <img src="../images/3.jpg" alt=""/> the nrows (number of rows) field in <img src="../images/2.jpg" alt=""/> the rta_tables table, but we do have to use the filter parameter to query() and select the row for which <img src="../images/4.jpg" alt=""/> the name field is Zone. The rta_tables table has a row for every RTA table in the ladd daemon, so we can just go to the row describing the Zone table to find the number of rows.</p>&#13;
<p class="secs"><a id="chapter15.11"/><a href="toc.html#chapter15.11"><i><b>Reading the Alarm Table</b></i></a></p>&#13;
<p class="noindent">The var_ladAlarmTable() function processes reads of objects in the ladAlarmTable. Again, most of our work will be to add code to the switch statement. The main difference in routines for reading tables is the need to handle the index to the table row and the determination of the table size.</p>&#13;
<p class="imgl"><img src="../images/301-1.jpg" alt=""/></p>&#13;
<p class="indent">The beginning of var_ladAlarmTable looks a lot like var_ladProject, where we implemented our scalars. All we’ve done so far is add a few local variables, specifically:</p>&#13;
<p class="indent"><img src="../images/1.jpg" alt=""/> table_size, which will hold the number of rows in our table.</p>&#13;
<p class="indent"><img src="../images/2.jpg" alt=""/> table_index, which shows the table row we want to retrieve.</p>&#13;
<p class="indent"><img src="../images/3.jpg" alt=""/> filter, which is what we will pass to query() to tell it which row we want.</p>&#13;
<p class="imgl"><a id="page278"/><img src="../images/302-1.jpg" alt=""/></p>&#13;
<p class="indent">This should be familiar from our discussion of LADNUMBEROFZONES in the section “The Scalars” on page 275. We need the length of the table for our processing below. Notice that the reaction to a failure to retrieve the table length is <img src="../images/1.jpg" alt=""/> returning NULL. This should never fail, but we still need to cover this case. If we fail to get the length of the table, the agent will just bypass this table as if it didn’t exist when someone walks our MIB.</p>&#13;
<p class="imgl"><img src="../images/302-2.jpg" alt=""/></p>&#13;
<p class="indent">In the code above we take advantage of <img src="../images/1.jpg" alt=""/> the header_simple_table() function provided by Net-SNMP. The AGENT.txt file defines a <i>simple table</i> as one that is singly indexed by an integer running from 1 to some determinable maximum value; all rows within that range are valid (no holes) and the data can be retrieved directly—for example, by indexing into an underlying data structure, such as our RTA Zone table.</p>&#13;
<p class="indent">The comment block was generated by mib2c, and it includes a constant called TABLE_SIZE that we have replaced with the variable table_size, as we discussed earlier.</p>&#13;
<p class="imgl"><img src="../images/302-3.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page279"/>We simply <img src="../images/1.jpg" alt=""/> take our table index from the end of our OID. The OID of the <i>instance</i> of an object is the OID of the <i>object definition,</i> suffixed by the instance index. In the case of any simple table, as defined above, the instance index will be the table row number (the first row starting with row 1, not row 0). We then use this to create the filter string for our calls to query the Zone table. We are getting all of our values for the objects in the ladAlarmTable from the Zone table, so we can just <img src="../images/2.jpg" alt=""/> create this filter once and use it in all of our queries.</p>&#13;
<p class="indent">The rest of the routine (below) is a switch statement indexed by the object requested.</p>&#13;
<p class="imgl"><img src="../images/303-1.jpg" alt=""/></p>&#13;
<p class="imgl"><img src="../images/303-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page280"/><img src="../images/304-1.jpg" alt=""/></p>&#13;
<p class="indent">In each of the cases, we query some field in the Zone table to get the value in our switch statement. If the query fails, we break out of the switch and return NULL, which tells the agent this value is not retrievable.</p>&#13;
<p class="indent">Another thing to notice here is that we have to return a write_method for each of the objects we have defined as having read-write access. Each writable object has its own write method—that is, a pointer to the routine called to handle SETs. Whenever a write (snmpset) is done, the main agent code first calls the read routine to find the appropriate write routine.</p>&#13;
<p class="secs"><a id="chapter15.12"/><a href="toc.html#chapter15.12"><i><b>Writing the Alarm Table</b></i></a></p>&#13;
<p class="noindent">Each of the write routines for writable objects looks basically the same, so we’ll just take the ladAlarmEnable object as an example.</p>&#13;
<p class="indent">The write routines all center around a switch statement selecting between different processing based on the action parameter. The cases in the switch will always be as follows:</p>&#13;
<ul>&#13;
<li><span class="bb">RESERVE1</span></li>&#13;
<li><span class="bb">RESERVE2</span></li>&#13;
<li><span class="bb">FREE</span></li>&#13;
<li><span class="bb">ACTION</span></li>&#13;
<li><span class="bb">UNDO</span></li>&#13;
<li><span class="bb">COMMIT</span></li>&#13;
</ul>&#13;
<p class="indent">Writing is much more complex than reading. When the agent receives an SNMPSET command for one of your objects, the read code we discussed above will be called to return the write_method (a pointer to the write routine for the specific object). This write function will then be called repeatedly with a different action parameter each time. If everything goes without a hitch, the write method will be called for RESERVE1, RESERVE2, ACTION, and COMMIT, in succession. The second RESERVE is to allow for dependencies between objects when a write is received for more than one object. If there is a failure returned from either RESERVE, you will be called with FREE to allow any allocated resources to be released. UNDO is provided for cases that fail further into the process. You have to promise (cross your heart and hope to die) that UNDO cannot fail, so your settings do not become inconsistent—or at least do your best, and keep this in mind. More information on this subject is provided with the Net-SNMP package in the AGENT.txt file in the top directory. Here is the code we have modified for Laddie’s agent.</p>&#13;
<p class="imgl"><a id="page281"/><img src="../images/305-1.jpg" alt=""/></p>&#13;
<p class="indent">We have changed the code generated by mib2c to make value static and to add another static variable to hold a saved value. This function will be called repeatedly with a sequence of action parameters, so we can save some information from call to call.</p>&#13;
<p class="imgl"><img src="../images/305-2.jpg" alt=""/></p>&#13;
<p class="indent">These should look familiar from our scalar and ladAlarmTable queries, above. Here, we’ll be using them for both queries and updates.</p>&#13;
<p class="ex"><b>table_index = name[name_len-1];</b></p>&#13;
<p class="noindent">This should look familiar, too. We’re grabbing the table index from the end of the OID.</p>&#13;
<p class="imgl"><img src="../images/305-3.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page282"/><img src="../images/306-1.jpg" alt=""/></p>&#13;
<p class="indent">The RESERVE1 action checks the value type and length for accuracy. The code to check for wrong type and wrong length was generated for us, but we’ve changed it a bit, replacing the printfs with DEBUGMSGTL macros. We’ve also added <img src="../images/1.jpg" alt=""/> a range check for the value being written. The enable value should always be either 0 or 1.</p>&#13;
<p class="imgl"><img src="../images/306-2.jpg" alt=""/></p>&#13;
<p class="indent">In Laddie we don’t have any use for RESERVE2 and FREE. Normally, RESERVE2 would be used for checking interdependencies between the objects in the var-bind list of the SNMP SET, and FREE would be used to free any resources we tied up temporarily, but neither of these apply to our Laddie MIB. No code is highlighted in RESERVE2 because we didn’t add anything. Even the comments were generated for us by mib2c.</p>&#13;
<p class="imgl"><img src="../images/306-3.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page283"/>In ACTION, we are retrieving the current value and saving it in saved_value before we write the new value to the RTA Zone table. If we run into trouble, we return an error. The value we save may be used in the UNDO case.</p>&#13;
<p class="imgl"><img src="../images/307-1.jpg" alt=""/></p>&#13;
<p class="indent">We UNDO by writing the saved value back, but only if ACTION got as far as retrieving the old value.</p>&#13;
<p class="imgl"><img src="../images/307-2.jpg" alt=""/></p>&#13;
<p class="indent">We have nothing to do in the COMMIT case. ACTION already wrote the value to the RTA table in the Laddie daemon.</p>&#13;
<p class="imgl"><img src="../images/307-3.jpg" alt=""/></p>&#13;
<p class="indent">If we didn’t return an error before this point, we return a successful completion.</p>&#13;
<p class="indent">All of the other write routines look just like this, so that wraps up our discussion of the LAD-MIB implementation. The next step is to build it.</p>&#13;
<p class="secl"><a id="chapter15.13"/><a href="toc.html#chapter15.13"><b>Makefile Revisited</b></a></p>&#13;
<p class="noindent">In “The Net-SNMP Agent” on page 262, we used a Makefile to generate our agent. Now we just have to modify this Makefile to include our LAD-MIB code.</p>&#13;
<p class="imgl"><img src="../images/307-4.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page284"/><img src="../images/308-1.jpg" alt=""/></p>&#13;
<p class="indent">The changes are fairly minor. We’ve added two lines to the setup case to <img src="../images/1.jpg" alt=""/> create the lad directory under agent/mibgroup and <img src="../images/2.jpg" alt=""/> copy our ladProject header and C file there.</p>&#13;
<p class="indent">The config case <img src="../images/3.jpg" alt=""/> adds "-lpq" to LDFLAGS to tell the linker to include libpq for the PostgreSQL code used by our update and query routines. We also <img src="../images/4.jpg" alt=""/> tell configure to include our MIB in the build.</p>&#13;
<p class="indent">That’s it! If Net-SNMP releases new security improvements, bug fixes, or new features, all we have to do is drop a new source tarball into the build directory, change the NETSNMP_VERSION line in the Makefile, and rebuild. Each Net-SNMP release has maintained backward compatibility since we started using it, when Net-SNMP was still UCD-SNMP, and it has been blissfully easy to roll a new Net-SNMP version into new releases of our appliance software. For this (among other things) we are eternally grateful to the maintainers of UCD/NET-SNMP.</p>&#13;
<p class="indent">In Chapter 14 we mentioned that our SNMP agent uses the old style, non-RTA configuration method (that is, a .conf file somewhere under /etc). You may have wondered why we didn’t discuss how to RTA-ize the SNMP agent so we could change its configuration on the fly, as we can with Laddie. Well, this is the reason. We don’t want to customize the basic agent because that would complicate rolling in new releases as they become available. Right now it’s simple—we don’t have changes to port to the agent each time we update, and all of our customizations are localized in our MIB extension.</p>&#13;
<p class="indent"><a id="page285"/>All we need to do now is build and install it.</p>&#13;
<p class="ex">make<br/>make install</p>&#13;
<p class="indent">You’ll also need to copy the files you need from /opt/snmp into your appliance build, but that’s beyond the scope of this chapter.</p>&#13;
<p class="secl"><a id="chapter15.14"/><a href="toc.html#chapter15.14"><b>Debugging</b></a></p>&#13;
<p class="noindent">Thanks to the DEBUGMSGTL macros, we have dropped in our MIB extension as we wrote it, and we are all set to trace the flow of control in our agent, should this become necessary. Just shut down the agent running in the background</p>&#13;
<p class="ex">/etc/rc.d/init.d/snmpd stop</p>&#13;
<p class="noindent">and run your own copy from the command line:</p>&#13;
<p class="ex">/opt/snmp/sbin/snmpd -D "LAD" -Le -f -c /opt/snmp/etc/snmp/snmpd.conf -C</p>&#13;
<p class="indent">The -c &lt;path to config file&gt; -C is from the normal command string to run the agent. We discussed this in Chapter 14. What’s new are the first three options.</p>&#13;
<p class="indent">The -D "LAD" activates our DEBUGMSGTL statements, which specified "LAD". Here’s one taken from the code we discussed above:</p>&#13;
<p class="ex">DEBUGMSGTL(("LAD", "reading ladAlarmState\n"));</p>&#13;
<p class="indent">The -Le tells the agent to send the output to stderr. Other options are stdout, syslog, or a file. See the man page for snmpd for more information.</p>&#13;
<p class="indent">The -f tells the agent not to fork and go into the background. This keeps it tied to our current terminal window so we can see the output.</p>&#13;
<p class="indent">Now query the agent using snmpget, snmpset, or snmpwalk from another terminal window and watch the output, or capture it to a file.</p>&#13;
<p class="secl"><a id="chapter15.15"/><a href="toc.html#chapter15.15"><b>Traps</b></a></p>&#13;
<p class="noindent">We have defined two traps in our MIB, but we will not be discussing how to send these traps in this chapter. In Chapter 14 we discussed the use of the snmptrap utility to send traps for us, and in Chapter 7 we explained how to use a log event to trigger an SNMP trap. Just keep in mind that the traps we have defined in our LAD-MIB are not generated by the SNMP agent. They are generated through the logging subsystem from events recorded by the ladd daemon, itself.</p>&#13;
<p class="secl"><a id="chapter15.16"/><a href="toc.html#chapter15.16"><b>Summary</b></a></p>&#13;
<p class="noindent"><a id="page286"/>In Chapter 14 you learned how to create a MIB to match an application, and in this chapter you learned how to create a MIB extension for the Net-SNMP agent to implement that MIB, as well as how to use the PostgreSQL interface library and RTA to retrieve the MIB data values from another daemon process. At this point you should feel comfortable that you could do this yourself from scratch.</p>&#13;
<p class="indent">You should also feel familiar enough with the structure of MIB and a Net-SNMP agent extension to hack new objects into the MIB and the code. There is no need to go back through generating skeleton code with mib2c. All you have to do is add the new objects to the MIB file (mostly cut-and-paste work), define new numbers for these variables in the list of defines, add the appropriate rows to the ladProject_variables array, and then add cases to the to the appropriate switch statements. Just keep in mind that while you can add things to a MIB, you cannot reassign OIDs. If you always add to the end of a branch, you should be in good shape.</p>&#13;
<p class="indent">In Chapter 14 we mentioned that we had neglected to include the edge and input columns from our Laddie table in our MIB. A good test of your understanding of these two chapters would be to go back and add one or both of these fields to the MIB and agent yourself.</p>&#13;
<p class="imgc"><a id="page287"/><img src="../images/311-1.jpg" alt=""/><a id="page288"/></p>&#13;
</div>&#13;
</body></html>