<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Syntax in Functions"><div class="titlepage"><div><div><h1 class="title"><a id="syntax_in_functions"/>Chapter 3. Syntax in Functions</h1></div></div></div><p>In this chapter, we’ll take a look at the syntax that enables you to write Haskell functions in a readable and sensible manner. We’ll look at how to quickly deconstruct values, avoid big <code class="literal">if else</code> chains, and store the results of intermediate computations so that you can reuse them multiple times.<a id="IDX-CHP-3-0001" class="indexterm"/></p><div class="sect1" title="Pattern Matching"><div class="titlepage"><div><div><h1 class="title"><a id="pattern_matching"/>Pattern Matching</h1></div></div></div><p><span class="emphasis"><em>Pattern matching</em></span> is used to specify patterns to which some data should conform and to deconstruct the data according to those patterns.<a id="IDX-CHP-3-0002" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e3726"/><img src="httpatomoreillycomsourcenostarchimages802532.png.jpg" alt="image with no caption"/></div></div><p>When defining functions in Haskell, you can create separate function bodies for different patterns. This leads to simple, readable code. You can pattern match on pretty much any data type—numbers, characters, lists, tuples, and so on. For example, let’s write a simple function that checks if the number we pass to it is a 7:<a id="IDX-CHP-3-0003" class="indexterm"/></p><a id="I_programlisting3_d1e3736"/><pre class="programlisting">lucky :: Int -&gt; String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"</pre><p>When you call <code class="literal">lucky</code>, the patterns will be checked from top to bottom. When the passed argument conforms to a specified pattern, the corresponding function body will be used. The only way a number can conform to the first pattern here is if it is a 7. In that case, the function body <code class="literal">"LUCKY NUMBER SEVEN!"</code> is used. If it’s not a 7, it falls through to the second pattern, which matches anything and binds it to <code class="literal">x</code>.</p><p>When we use a name that starts with a lowercase letter (like <code class="literal">x</code>, <code class="literal">y</code>, or <code class="literal">myNumber</code>) in our pattern instead of an actual value (like <code class="literal">7</code>), it will act as a catchall pattern. That pattern will always match the supplied value, and we will be able to refer to that value by the name that we used for the pattern.</p><p>The sample function could have also been easily implemented by using an <code class="literal">if</code> expression. However, what if we wanted to write a function that takes a number and prints it out as a word if it’s between 1 and 5; otherwise, it prints <code class="literal">"Not between 1 and 5"</code>? Without pattern matching, we would need to make a pretty convoluted <code class="literal">if/then/else</code> tree. However, pattern matching makes this a simple function to write:</p><a id="I_programlisting3_d1e3774"/><pre class="programlisting">sayMe :: Int -&gt; String
sayMe 1 = "One!"
sayMe 2 = "Two!"
sayMe 3 = "Three!"
sayMe 4 = "Four!"
sayMe 5 = "Five!"
sayMe x = "Not between 1 and 5"</pre><p>Note that if we moved the last pattern (<code class="literal">sayMe x</code>) to the top, the function would always print <code class="literal">"Not between 1 and 5"</code>, because the numbers wouldn’t have a chance to fall through and be checked for any other patterns.</p><p>Remember the factorial function we implemented in the previous chapter? We defined the factorial of a number <code class="literal">n</code> as <code class="literal">product [1..n]</code>. We can also define a factorial function <span class="emphasis"><em>recursively</em></span>. A function is defined recursively if it calls itself inside its own definition. The factorial function is usually defined this way in mathematics. We start by saying that the factorial of 0 is 1. Then we state that the factorial of any positive integer is that integer multiplied by the factorial of its predecessor. Here’s how that looks translated into Haskell terms:<a id="IDX-CHP-3-0004" class="indexterm"/></p><a id="I_programlisting3_d1e3799"/><pre class="programlisting">factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)</pre><p>This is the first time we’ve defined a function recursively. Recursion is important in Haskell, and we’ll take a closer look at it in <a class="xref" href="ch04.html" title="Chapter 4. Hello Recursion!">Chapter 4</a>.<a id="IDX-CHP-3-0005" class="indexterm"/><a id="IDX-CHP-3-0006" class="indexterm"/><a id="IDX-CHP-3-0007" class="indexterm"/></p><p>Pattern matching can also fail. For instance, we can define a function like this:</p><a id="I_programlisting3_d1e3822"/><pre class="programlisting">charName :: Char -&gt; String
charName 'a' = "Albert"
charName 'b' = "Broseph"
charName 'c' = "Cecil"</pre><p>This function seems to work fine at first. However, if we try to call it with an input that it didn’t expect, we get an error:</p><a id="I_programlisting3_d1e3826"/><pre class="programlisting">ghci&gt; charName 'a'
"Albert"
ghci&gt; charName 'b'
"Broseph"
ghci&gt; charName 'h'
"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName</pre><p>It complains that we have “non-exhaustive patterns,” and rightfully so. When making patterns, we should always include a catchall pattern at the end so our program doesn’t crash if we get some unexpected input.</p><div class="sect2" title="Pattern Matching with Tuples"><div class="titlepage"><div><div><h2 class="title"><a id="pattern_matching_with_tuples"/>Pattern Matching with Tuples</h2></div></div></div><p>Pattern matching can also be used on tuples. What if we wanted to write a function that takes two vectors in 2D space (represented as pairs) and adds them together? (To add two vectors, we add their x components separately and their y components separately.) Here’s how we might have done this if we didn’t know about pattern matching:</p><a id="I_programlisting3_d1e3835"/><pre class="programlisting">addVectors :: (Double, Double) -&gt; (Double, Double) -&gt; (Double, Double)
addVectors a b = (fst a + fst b, snd a + snd b)</pre><p>Well, that works, but there’s a better way to do it. Let’s modify the function so that it uses pattern matching:</p><a id="I_programlisting3_d1e3839"/><pre class="programlisting">addVectors :: (Double, Double) -&gt; (Double, Double) -&gt; (Double, Double)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)</pre><p>This is much better. It makes it clear that the parameters are tuples, and increases readability by giving names to the tuple components right away. Note that this is already a catchall pattern. The type of <code class="literal">addVectors</code> is the same in both cases, so we are guaranteed to get two pairs as parameters:</p><a id="I_programlisting3_d1e3846"/><pre class="programlisting">ghci&gt; :t addVectors
addVectors :: (Double, Double) -&gt; (Double, Double) -&gt; (Double, Double)</pre><p><code class="literal">fst</code> and <code class="literal">snd</code> extract the components of pairs. But what about triples? Well, there are no provided functions to extract the third component in a triple, but we can make our own:<a id="IDX-CHP-3-0008" class="indexterm"/><a id="IDX-CHP-3-0009" class="indexterm"/><a id="IDX-CHP-3-0010" class="indexterm"/><a id="IDX-CHP-3-0011" class="indexterm"/><a id="IDX-CHP-3-0012" class="indexterm"/><a id="IDX-CHP-3-0013" class="indexterm"/><a id="IDX-CHP-3-0014" class="indexterm"/><a id="IDX-CHP-3-0015" class="indexterm"/><a id="IDX-CHP-3-0016" class="indexterm"/><a id="IDX-CHP-3-0017" class="indexterm"/></p><a id="I_programlisting3_d1e3898"/><pre class="programlisting">first :: (a, b, c) -&gt; a
first (x, _, _) = x

second :: (a, b, c) -&gt; b
second (_, y, _) = y

third :: (a, b, c) -&gt; c
third (_, _, z) = z</pre><p>The <code class="literal">_</code> character means the same thing it does in list comprehensions. We really don’t care about that part, so we just use a <code class="literal">_</code> to represent a generic variable.</p></div><div class="sect2" title="Pattern Matching with Lists and List Comprehensions"><div class="titlepage"><div><div><h2 class="title"><a id="pattern_matching_with_lists_and_list_com"/>Pattern Matching with Lists and List Comprehensions</h2></div></div></div><p>You can also use pattern matching in list comprehensions, like this:</p><a id="I_programlisting3_d1e3913"/><pre class="programlisting">ghci&gt; let xs = [(1,3),(4,3),(2,4),(5,3),(5,6),(3,1)]
ghci&gt; [a+b | (a, b) &lt;- xs]
[4,7,6,8,11,4]</pre><p>If a pattern match fails, the list comprehension will just move on to the next element, and the element that failed won’t be included in the resulting list.</p><p>Regular lists can also be used in pattern matching. You can match with the empty list <code class="literal">[]</code> or any pattern that involves <code class="literal">:</code> and the empty list. (Remember that <code class="literal">[1,2,3]</code> is just syntactic sugar for <code class="literal">1:2:3:[]</code>.) A pattern like <code class="literal">x:xs</code> will bind the head of the list to <code class="literal">x</code> and the rest of it to <code class="literal">xs</code>. If the list has only a single element, then <code class="literal">xs</code> will simply be the empty list.<a id="IDX-CHP-3-0018" class="indexterm"/><a id="IDX-CHP-3-0019" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Haskell programmers use the <code class="literal">x:xs</code> pattern often, especially with recursive functions. However, patterns that include the <code class="literal">:</code> character will match only against lists of length one or more.<a id="IDX-CHP-3-0020" class="indexterm"/></p></div><p>Now that we’ve looked at how to pattern match against lists, let’s make our own implementation of the <code class="literal">head</code> function:</p><a id="I_programlisting3_d1e3971"/><pre class="programlisting">head' :: [a] -&gt; a
head' [] = error "Can't call head on an empty list, dummy!"
head' (x:_) = x</pre><p>After loading the function, we can test it, like this:<a id="IDX-CHP-3-0021" class="indexterm"/><a id="IDX-CHP-3-0022" class="indexterm"/><a id="IDX-CHP-3-0023" class="indexterm"/><a id="IDX-CHP-3-0024" class="indexterm"/><a id="IDX-CHP-3-0025" class="indexterm"/><a id="IDX-CHP-3-0026" class="indexterm"/></p><a id="I_programlisting3_d1e4001"/><pre class="programlisting">ghci&gt; head' [4,5,6]
4
ghci&gt; head' "Hello"
'H'</pre><p>Notice that if we want to bind something to several variables (even if one of them is just <code class="literal">_</code>), we must surround them in parentheses so Haskell can properly parse them.</p><p>Also notice the use of the <code class="literal">error</code> function. This function takes a string as an argument and generates a runtime error using that string. It essentially crashes your program, so it’s not good to use it too much. (But calling <code class="literal">head</code> on an empty list just doesn’t make sense!)</p><p>As another example, let’s write a simple function that takes a list and prints its elements out in a wordy, inconvenient format:</p><a id="I_programlisting3_d1e4019"/><pre class="programlisting">tell :: (Show a) =&gt; [a] -&gt; String
tell [] = "The list is empty"
tell (x:[]) = "The list has one element: " ++ show x
tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y
tell (x:y:_) = "This list is long. The first two elements are: " ++ show x
               ++ " and " ++ show y</pre><p>Note that <code class="literal">(x:[])</code> and <code class="literal">(x:y:[])</code> could be rewritten as <code class="literal">[x]</code> and <code class="literal">[x,y]</code>. However, we can’t rewrite <code class="literal">(x:y:_)</code> using square brackets, because it matches any list of length 2 or more.</p><p>Here are some examples of using this function:</p><a id="I_programlisting3_d1e4040"/><pre class="programlisting">ghci&gt; tell [1]
"The list has one element: 1"
ghci&gt; tell [True,False]
"The list has two elements: True and False"
ghci&gt; tell [1,2,3,4]
"This list is long. The first two elements are: 1 and 2"
ghci&gt; tell []
"The list is empty"</pre><p>The <code class="literal">tell</code> function is safe to use because it can match to the empty list, a singleton list, a list with two elements, and a list with more than two elements. It knows how to handle lists of any length, and so it will always return a useful value.</p><p>How about if instead we defined a function that only knows how to handle lists with three elements? Here’s an example of such a function:<a id="IDX-CHP-3-0027" class="indexterm"/><a id="IDX-CHP-3-0028" class="indexterm"/><a id="IDX-CHP-3-0029" class="indexterm"/><a id="IDX-CHP-3-0030" class="indexterm"/><a id="IDX-CHP-3-0031" class="indexterm"/><a id="IDX-CHP-3-0032" class="indexterm"/><a id="IDX-CHP-3-0033" class="indexterm"/><a id="IDX-CHP-3-0034" class="indexterm"/><a id="IDX-CHP-3-0035" class="indexterm"/></p><a id="I_programlisting3_d1e4086"/><pre class="programlisting">badAdd :: (Num a) =&gt; [a] -&gt; a
badAdd (x:y:z:[]) = x + y + z</pre><p>Here’s what happens when we give it a list that it doesn’t expect:</p><a id="I_programlisting3_d1e4090"/><pre class="programlisting">ghci&gt; badAdd [100,20]
*** Exception: examples.hs:8:0-25: Non-exhaustive patterns in function badAdd</pre><p>Yikes! Not cool! If this happened inside a compiled program instead of in GHCi, the program would crash.</p><p>One final thing to note about pattern matching with lists: You can’t use the <code class="literal">++</code> operator in pattern matches. (Remember that the <code class="literal">++</code> operator joins two lists into one.) For instance, if you tried to pattern match against <code class="literal">(xs ++ ys)</code>, Haskell wouldn’t be able to tell what would be in the <code class="literal">xs</code> list and what would be in the <code class="literal">ys</code> list. Though it seems logical to match stuff against <code class="literal">(xs ++ [x,y,z])</code>, or even just <code class="literal">(xs ++ [x])</code>, because of the nature of lists, you can’t.</p></div><div class="sect2" title="As-patterns"><div class="titlepage"><div><div><h2 class="title"><a id="as-patterns"/>As-patterns</h2></div></div></div><p>There’s also a special type of pattern called an <span class="emphasis"><em>as-pattern</em></span>. As-patterns allow you to break up an item according to a pattern, while still keeping a reference to the entire original item. To create an as-pattern, precede a regular pattern with a name and an <code class="literal">@</code> character.<a id="IDX-CHP-3-0036" class="indexterm"/><a id="IDX-CHP-3-0037" class="indexterm"/></p><p>For instance, we can create the following as-pattern: <code class="literal">xs@(x:y:ys)</code>. This pattern will match exactly the same lists that <code class="literal">x:y:ys</code> would, but you can easily access the entire original list using <code class="literal">xs</code>, instead of needing to type out <code class="literal">x:y:ys</code> every time. Here’s an example of a simple function that uses an as-pattern:</p><a id="I_programlisting3_d1e4152"/><pre class="programlisting">firstLetter :: String -&gt; String
firstLetter "" = "Empty string, whoops!"
firstLetter all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]</pre><p>After loading the function, we can test it as follows:</p><a id="I_programlisting3_d1e4156"/><pre class="programlisting">ghci&gt; firstLetter "Dracula"
"The first letter of Dracula is D"</pre></div></div></div>
<div class="sect1" title="Guards, Guards!"><div class="titlepage"><div><div><h1 class="title"><a id="guards_comma_guards_exclamation"/>Guards, Guards!</h1></div></div></div><p>We use patterns to check if the values passed to our functions are constructed in a certain way. We use <span class="emphasis"><em>guards</em></span> when we want our function to check if some property of those passed values is true or false. That sounds a lot like an <code class="literal">if</code> expression, and it is very similar. However, guards are a lot more readable when you have several conditions, and they play nicely with patterns.<a id="IDX-CHP-3-0038" class="indexterm"/><a id="IDX-CHP-3-0039" class="indexterm"/><a id="IDX-CHP-3-0040" class="indexterm"/><a id="IDX-CHP-3-0041" class="indexterm"/><a id="IDX-CHP-3-0042" class="indexterm"/><a id="IDX-CHP-3-0043" class="indexterm"/><a id="IDX-CHP-3-0044" class="indexterm"/><a id="IDX-CHP-3-0045" class="indexterm"/><a id="IDX-CHP-3-0046" class="indexterm"/><a id="IDX-CHP-3-0047" class="indexterm"/></p><p>Let’s dive in and write a function that uses guards. This function will berate you in different ways depending on your body mass index (BMI). Your BMI is calculated by dividing your weight (in kilograms) by your height (in meters) squared. If your BMI is less than 18.5, you’re considered underweight. If it’s anywhere from 18.5 to 25, you’re considered normal. A BMI of 25 to 30 is overweight, and more than 30 is obese. (Note that this function won’t actually calculate your BMI; it just takes it as an argument and then tells you off.) Here’s the function:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e4213"/><img src="httpatomoreillycomsourcenostarchimages802534.png" alt="image with no caption"/></div></div><a id="I_programlisting3_d1e4218"/><pre class="programlisting">bmiTell :: =&gt; Double -&gt; String
bmiTell bmi
    | bmi &lt;= 18.5 = "You're underweight, you emo, you!"
    | bmi &lt;= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi &lt;= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise   = "You're a whale, congratulations!"</pre><p>A guard is indicated by a pipe character (<code class="literal">|</code>), followed by a Boolean expression, followed by the function body that will be used if that expression evaluates to <code class="literal">True</code>. If the expression evaluates to <code class="literal">False</code>, the function drops through to the next guard, and the process repeats. Guards must be indented by at least one space. (I like to indent them by four spaces so that the code is more readable.)</p><p>For instance, if we call this function with a BMI of 24.3, it will first check if that’s less than or equal to 18.5. Because it isn’t, it falls through to the next guard. The check is carried out with the second guard, and because 24.3 is less than 25.0, the second string is returned.</p><p>Guards are very reminiscent of a big <code class="literal">if/else</code> tree in imperative languages, though they’re far more readable. While big <code class="literal">if/else</code> trees are usually frowned upon, sometimes a problem is defined in such a discrete way that you can’t get around them. Guards are a very nice alternative in these cases.</p><p>Many times, the last guard in a function is <code class="literal">otherwise</code>, which catches everything. If all the guards in a function evaluate to <code class="literal">False</code>, and we haven’t provided an <code class="literal">otherwise</code> catchall guard, evaluation falls through to the next pattern. (This is how patterns and guards play nicely together.) If no suitable guards or patterns are found, an error is thrown.<a id="IDX-CHP-3-0048" class="indexterm"/></p><p>Of course, we can also use guards with functions that take multiple parameters. Let’s modify <code class="literal">bmiTell</code> so that it takes a height and weight, and calculates the BMI for us:</p><a id="I_programlisting3_d1e4262"/><pre class="programlisting">bmiTell :: Double -&gt; Double -&gt; String
bmiTell weight height
    | weight / height ^ 2 &lt;= 18.5 = "You're underweight, you emo, you!"
    | weight / height ^ 2 &lt;= 25.0 = "You're supposedly
 normal. Pffft, I bet you're ugly!"
    | weight / height ^ 2 &lt;= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise                   = "You're a whale, congratulations!"</pre><p>Now, let’s see if I’m fat:<a id="IDX-CHP-3-0049" class="indexterm"/><a id="IDX-CHP-3-0050" class="indexterm"/><a id="IDX-CHP-3-0051" class="indexterm"/></p><a id="I_programlisting3_d1e4278"/><pre class="programlisting">ghci&gt; bmiTell 85 1.90
"You're supposedly normal. Pffft, I bet you're ugly!"</pre><p>Yay! I’m not fat! But Haskell just called me ugly. Whatever!</p><div class="note" title="Note"><h3 class="title">Note</h3><p>A common newbie mistake is to put an equal sign (<code class="literal">=</code>) after the function name and parameters, before the first guard. This will cause a syntax error.</p></div><p>As another simple example, let’s implement our own <code class="literal">max</code> function to compare two items and return the larger one:</p><a id="I_programlisting3_d1e4293"/><pre class="programlisting">max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b
    | a &lt;= b    = b
    | otherwise = a</pre><p>We can also implement our own <code class="literal">compare</code> function using guards:</p><a id="I_programlisting3_d1e4300"/><pre class="programlisting">myCompare :: (Ord a) =&gt; a -&gt; a -&gt; Ordering
a `myCompare` b
    | a == b    = EQ
    | a &lt;= b     = LT
    | otherwise = GT</pre><a id="I_programlisting3_d1e4302"/><pre class="programlisting">ghci&gt; 3 `myCompare` 2
GT</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Not only can we call functions as infix with backticks, we can also define them using backticks. Sometimes this makes them easier to read.</p></div></div>
<div class="sect1" title="where?!"><div class="titlepage"><div><div><h1 class="title"><a id="where_question_exclamation"/>where?!</h1></div></div></div><p>When programming, we usually want to avoid calculating the same value over and over again. It’s much easier to calculate something only once and store the result. In imperative programming languages, you would solve this problem by storing the result of a computation in a variable. In this section, you’ll learn how to use Haskell’s <code class="literal">where</code> keyword to store the results of intermediate computations, which provides similar functionality.</p><p>In the previous section, we defined a BMI calculator function like this:<a id="IDX-CHP-3-0052" class="indexterm"/><a id="IDX-CHP-3-0053" class="indexterm"/></p><a id="I_programlisting3_d1e4325"/><pre class="programlisting">bmiTell :: Double -&gt; Double -&gt; String
bmiTell weight height
    | weight / height ^ 2 &lt;= 18.5 = "You're underweight, you emo, you!"
    | weight / height ^ 2 &lt;= 25.0 = "You're
 supposedly normal. Pffft, I bet you're ugly!"
    | weight / height ^ 2 &lt;= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise                   = "You're a whale, congratulations!"</pre><p>Notice that we repeat the BMI calculation three times in this code. We can avoid this by using the <code class="literal">where</code> keyword to bind that value to a variable and then using that variable in place of the BMI calculation, like this:</p><a id="I_programlisting3_d1e4332"/><pre class="programlisting">bmiTell :: Double -&gt; Double -&gt; String
bmiTell weight height
    | bmi &lt;= 18.5 = "You're underweight, you emo, you!"
    | bmi &lt;= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi &lt;= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise   = "You're a whale, congratulations!"
    where bmi = weight / height ^ 2</pre><p>We put the <code class="literal">where</code> keyword after the guards and then use it to define one or more variables or functions. These names are visible across all the guards. If we decide that we want to calculate BMI a bit differently, we need to change it only once. This technique also improves readability by giving names to things, and it can even make our programs faster, since our values are calculated just once.</p><p>If we wanted to, we could even go a bit overboard and write our function like this:</p><a id="I_programlisting3_d1e4341"/><pre class="programlisting">bmiTell :: Double -&gt; Double -&gt; String
bmiTell weight height
    | bmi &lt;= skinny = "You're underweight, you emo, you!"
    | bmi &lt;= normal = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi &lt;= fat    = "You're fat! Lose some weight, fatty!"
    | otherwise     = "You're a whale, congratulations!"
    where bmi = weight / height ^ 2
          skinny = 18.5
          normal = 25.0
          fat = 30.0</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Notice that all the variable names are aligned in a single column. If you don’t align them like this, Haskell will get confused, and it won’t know that they’re all part of the same block.</p></div><div class="sect2" title="where's Scope"><div class="titlepage"><div><div><h2 class="title"><a id="where_apostrophy_s_scope"/>where's Scope</h2></div></div></div><p>The variables we define in the <code class="literal">where</code> section of a function are visible only to that function, so we don’t need to worry about them polluting the namespace of other functions. If we want to use a variable like this in several different functions, we must define it globally.<a id="IDX-CHP-3-0054" class="indexterm"/><a id="IDX-CHP-3-0055" class="indexterm"/><a id="IDX-CHP-3-0056" class="indexterm"/></p><p>Also, <code class="literal">where</code> bindings are <span class="emphasis"><em>not</em></span> shared across function bodies of different patterns. For instance, suppose we want to write a function that takes a name and greets the person nicely if it recognizes that name, but not so nicely if it doesn’t. We might define it like this:</p><a id="I_programlisting3_d1e4377"/><pre class="programlisting">greet :: String -&gt; String greet "Juan" = niceGreeting ++ " Juan!"
greet "Fernando" = niceGreeting ++ " Fernando!"
greet name = badGreeting ++ " " ++ name
    where niceGreeting = "Hello! So very nice to see you,"
          badGreeting = "Oh! Pfft. It's you."</pre><p>This function won’t work as written. Because <code class="literal">where</code> bindings aren’t shared across function bodies of different patterns, only the last function body sees the greetings defined by the <code class="literal">where</code> binding. To make this function work correctly, <code class="literal">badGreeting</code> and <code class="literal">niceGreeting</code> must be defined globally, like this:</p><a id="I_programlisting3_d1e4393"/><pre class="programlisting">badGreeting :: String
badGreeting = "Oh! Pfft. It's you."

niceGreeting :: String
niceGreeting = "Hello! So very nice to see you,"

greet :: String -&gt; String
greet "Juan" = niceGreeting ++ " Juan!"
greet "Fernando" = niceGreeting ++ " Fernando!"
greet name = badGreeting ++ " " ++ name</pre></div><div class="sect2" title="Pattern Matching with where"><div class="titlepage"><div><div><h2 class="title"><a id="pattern_matching_with_where"/>Pattern Matching with where</h2></div></div></div><p>You can also use <code class="literal">where</code> bindings to pattern match. We could have written the <code class="literal">where</code> section of our BMI function like this:</p><a id="I_programlisting3_d1e4407"/><pre class="programlisting">...
    where bmi = weight / height ^ 2
          (skinny, normal, fat) = (18.5, 25.0, 30.0)</pre><p>As an example of this technique, let’s write a function that gets a first name and last name, and returns the initials:</p><a id="I_programlisting3_d1e4411"/><pre class="programlisting">initials :: String -&gt; String -&gt; String
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
    where (f:_) = firstname
          (l:_) = lastname</pre><p>We could have also done this pattern matching directly in the function’s parameters (it would have been shorter and more readable), but this example shows that it’s possible to do it in the <code class="literal">where</code> bindings as well.<a id="IDX-CHP-3-0057" class="indexterm"/><a id="IDX-CHP-3-0058" class="indexterm"/><a id="IDX-CHP-3-0059" class="indexterm"/><a id="IDX-CHP-3-0060" class="indexterm"/><a id="IDX-CHP-3-0061" class="indexterm"/><a id="IDX-CHP-3-0062" class="indexterm"/><a id="IDX-CHP-3-0063" class="indexterm"/></p></div><div class="sect2" title="Functions in where Blocks"><div class="titlepage"><div><div><h2 class="title"><a id="functions_in_where_blocks"/>Functions in where Blocks</h2></div></div></div><p>Just as we’ve defined constants in <code class="literal">where</code> blocks, we can also define functions. Staying true to our healthy programming theme, let’s make a function that takes a list of weight/height pairs and returns a list of BMIs:</p><a id="I_programlisting3_d1e4457"/><pre class="programlisting">calcBmis :: [(Double, Double)] -&gt; [Double]
calcBmis xs = [bmi w h | (w, h) &lt;- xs]
    where bmi weight height = weight / height ^ 2</pre><p>And that’s all there is to it! The reason we needed to introduce <code class="literal">bmi</code> as a function in this example is that we can’t just calculate one BMI from the function’s parameters. We need to examine the list passed to the function, and there’s a different BMI for every pair in there.</p></div></div>
<div class="sect1" title="let It Be"><div class="titlepage"><div><div><h1 class="title"><a id="let_it_be"/>let It Be</h1></div></div></div><p><code class="literal">let</code> expressions are very similar to <code class="literal">where</code> bindings. <code class="literal">where</code> allows you bind to variables at the end of a function, and those variables are visible to the entire function, including all its guards. <code class="literal">let</code> expressions, on the other hand, allow you to bind to variables anywhere and are expressions themselves. However, they’re very local, and they don’t span across guards. Just like any Haskell construct that’s used to bind values to names, <code class="literal">let</code> expressions can be used in pattern matching.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e4484"/><img src="httpatomoreillycomsourcenostarchimages802536.png.jpg" alt="image with no caption"/></div></div><p>Now let’s see <code class="literal">let</code> in action. The following function returns a cylinder’s surface area, based on its height and radius:</p><a id="I_programlisting3_d1e4494"/><pre class="programlisting">cylinder :: Double -&gt; Double -&gt; Double
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^ 2
    in  sideArea + 2 * topArea</pre><p><code class="literal">let</code> expressions take the form of <code class="literal">let &lt;bindings&gt; in &lt;expression&gt;</code>. The variables that you define with <code class="literal">let</code> are visible within the entire <code class="literal">let</code> expression.</p><p>Yes, we could have also defined this with a <code class="literal">where</code> binding. So what’s the difference between the two? At first, it seems that the only difference is that <code class="literal">let</code> puts the bindings first and the expression later, whereas it’s the other way around with <code class="literal">where</code>.<a id="IDX-CHP-3-0064" class="indexterm"/><a id="IDX-CHP-3-0065" class="indexterm"/><a id="IDX-CHP-3-0066" class="indexterm"/><a id="IDX-CHP-3-0067" class="indexterm"/><a id="IDX-CHP-3-0068" class="indexterm"/></p><p>Really, the main difference between the two is that <code class="literal">let</code> expressions are . . . well . . . expressions, whereas <code class="literal">where</code> bindings aren’t. If something is an expression, then it has a value. <code class="literal">"boo!"</code> is an expression, as are <code class="literal">3 + 5</code> and <code class="literal">head [1,2,3]</code>. This means that you can use <code class="literal">let</code> expressions almost anywhere in your code, like this:</p><a id="I_programlisting3_d1e4563"/><pre class="programlisting">ghci&gt; 4 * (let a = 9 in a + 1) + 2
42</pre><p>Here are a few other useful ways to use <code class="literal">let</code> expressions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They can be used to introduce functions in a local scope:</p><a id="I_programlisting3_d1e4574"/><pre class="programlisting">ghci&gt; [let square x = x * x in (square 5, square 3, square 2)]
[(25,9,4)]</pre></li><li class="listitem"><p>They can be separated with semicolons, which is helpful when you want to bind several variables inline and can’t align them in columns:</p><a id="I_programlisting3_d1e4579"/><pre class="programlisting">ghci&gt; (let a = 100; b = 200; c = 300 in a*b*c,
 let foo="Hey "; bar = "there!" in foo ++ bar)
(6000000,"Hey there!")</pre></li><li class="listitem"><p>Pattern matching with <code class="literal">let</code> expressions can be very useful for quickly dismantling a tuple into components and binding those components to names, like this:<a id="IDX-CHP-3-0069" class="indexterm"/></p><a id="I_programlisting3_d1e4592"/><pre class="programlisting">ghci&gt; (let (a, b, c) = (1, 2, 3) in a+b+c) * 100
600</pre><p>Here, we use a <code class="literal">let</code> expression with a pattern match to deconstruct the triple <code class="literal">(1,2,3)</code>. We call its first component <code class="literal">a</code>, its second component <code class="literal">b</code>, and its third component <code class="literal">c</code>. The <code class="literal">in a+b+c</code> part says that the whole <code class="literal">let</code> expression will have the value of <code class="literal">a+b+c</code>. Finally, we multiply that value by <code class="literal">100</code>.</p></li><li class="listitem"><p>You can use <code class="literal">let</code> expressions inside list comprehensions. We’ll take a closer look at this next.</p></li></ul></div><p>If <code class="literal">let</code> expressions are so cool, why not use them all the time? Well, since <code class="literal">let</code> expressions are expressions, and are fairly local in their scope, they can’t be used across guards. Also, some people prefer <code class="literal">where</code> bindings because their variables are defined <span class="emphasis"><em>after</em></span> the function they’re being used in, rather than before. This allows the function body to be closer to its name and type declaration, which can make for more readable code.</p><div class="sect2" title="let in List Comprehensions"><div class="titlepage"><div><div><h2 class="title"><a id="let_in_list_comprehensions"/>let in List Comprehensions</h2></div></div></div><p>Let’s rewrite our previous example of calculating lists of weight/height pairs, but we’ll use a <code class="literal">let</code> expression inside a list comprehension instead of defining an auxiliary function with <code class="literal">where</code>:<a id="IDX-CHP-3-0070" class="indexterm"/></p><a id="I_programlisting3_d1e4659"/><pre class="programlisting">calcBmis :: [(Double, Double)] -&gt; [Double]
calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w / h ^ 2]</pre><p>Each time the list comprehension takes a tuple from the original list and binds its components to <code class="literal">w</code> and <code class="literal">h</code>, the <code class="literal">let</code> expression binds <code class="literal">w / h ^ 2</code> to the name <code class="literal">bmi</code>. Then we just present <code class="literal">bmi</code> as the output of the list comprehension.</p><p>We include a <code class="literal">let</code> inside a list comprehension much as we would use a predicate, but instead of filtering the list, it only binds values to names. The names defined in this <code class="literal">let</code> are visible to the output (the part before the <code class="literal">|</code>) and everything in the list comprehension that comes after the <code class="literal">let</code>. So, using this technique, we could make our function return only the BMIs of fat people, like this:</p><a id="I_programlisting3_d1e4696"/><pre class="programlisting">calcBmis :: [(Double, Double)] -&gt; [Double]
calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w / h ^ 2, bmi &gt; 25.0]</pre><p>The <code class="literal">(w, h) &lt;- xs</code> part of the list comprehension is called the <span class="emphasis"><em>generator</em></span>. We can’t refer to the <code class="literal">bmi</code> variable in the generator, because that is defined prior to the <code class="literal">let</code> binding.</p></div><div class="sect2" title="let in GHCi"><div class="titlepage"><div><div><h2 class="title"><a id="let_in_ghci"/>let in GHCi</h2></div></div></div><p>The <code class="literal">in</code> part of the binding can also be omitted when defining functions and constants directly in GHCi. If we do that, then the names will be visible throughout the entire interactive session:<a id="IDX-CHP-3-0071" class="indexterm"/></p><a id="I_programlisting3_d1e4725"/><pre class="programlisting">ghci&gt; let zoot x y z = x * y + z
ghci&gt; zoot 3 9 2
29
ghci&gt; let boot x y z = x * y + z in boot 3 4 2
14
ghci&gt; boot
&lt;interactive&gt;:1:0: Not in scope: `boot'</pre><p>Because we omitted the <code class="literal">in</code> part in our first line, GHCi knows that we’re not using <code class="literal">zoot</code> in that line, so it remembers it for the rest of the session. However, in the second <code class="literal">let</code> expression, we included the <code class="literal">in</code> part and called <code class="literal">boot</code> immediately with some parameters. A <code class="literal">let</code> expression that doesn’t leave out the <code class="literal">in</code> part is an expression in itself and represents a value, so GHCi just printed that value.</p></div></div>
<div class="sect1" title="case Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="case_expressions"/>case Expressions</h1></div></div></div><p><em class="replaceable"><code>case</code></em> <span class="emphasis"><em>expressions</em></span> allow you to execute blocks of code for specific values of a particular variable. Essentially, they are a way to use pattern matching almost anywhere in your code. Many languages (like C, C++, and Java) have some kind of case statement, so you may already be familiar with the concept.<a id="IDX-CHP-3-0072" class="indexterm"/><a id="IDX-CHP-3-0073" class="indexterm"/><a id="IDX-CHP-3-0074" class="indexterm"/><a id="IDX-CHP-3-0075" class="indexterm"/><a id="IDX-CHP-3-0076" class="indexterm"/><a id="IDX-CHP-3-0077" class="indexterm"/><a id="IDX-CHP-3-0078" class="indexterm"/><a id="IDX-CHP-3-0079" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e4793"/><img src="httpatomoreillycomsourcenostarchimages802538.png.jpg" alt="image with no caption"/></div></div><p>Haskell takes that concept and one-ups it. As the name implies, <code class="literal">case</code> expressions are expressions, much like <code class="literal">if else</code> expressions and <code class="literal">let</code> expressions. Not only can we evaluate expressions based on the possible cases of the value of a variable, we can also do pattern matching.</p><p>This is very similar to performing pattern matching on parameters in function definitions, where you take a value, pattern match it, and evaluate pieces of code based on that value. In fact, that kind of pattern matching is just syntactic sugar for <code class="literal">case</code> expressions. For example, the following two pieces of code do the same thing and are interchangeable:</p><a id="I_programlisting3_d1e4814"/><pre class="programlisting">head' :: [a] -&gt; a
head' [] = error "No head for empty lists!"
head' (x:_) = x</pre><a id="I_programlisting3_d1e4816"/><pre class="programlisting">head' :: [a] -&gt; a
head' xs = case xs of [] -&gt; error "No head for empty lists!"
                      (x:_) -&gt; x</pre><p>Here's the syntax for a <code class="literal">case</code> expression:<a id="IDX-CHP-3-0080" class="indexterm"/></p><a id="I_programlisting3_d1e4828"/><pre class="programlisting">case <em class="replaceable"><code>expression</code></em> of <em class="replaceable"><code>pattern</code></em> -&gt; <em class="replaceable"><code>result</code></em>
                   <em class="replaceable"><code>pattern</code></em> -&gt; <em class="replaceable"><code>result</code></em>
                   <em class="replaceable"><code>pattern</code></em> -&gt; <em class="replaceable"><code>result</code></em>
                   ...</pre><p>This is pretty simple. The first pattern that matches the expression is used. If it falls through the whole <code class="literal">case</code> expression and no suitable pattern is found, a runtime error occurs.</p><p>Pattern matching on function parameters can be done only when defining functions, but <code class="literal">case</code> expressions can be used anywhere. For instance, you can use them to perform pattern matching in the middle of an expression, like this:<a id="IDX-CHP-3-0081" class="indexterm"/></p><a id="I_programlisting3_d1e4868"/><pre class="programlisting">describeList :: [a] -&gt; String
describeList ls = "The list is " ++ case ls of [] -&gt; "empty."
                                               [x] -&gt; "a singleton list."
                                               xs -&gt; "a longer list."</pre><p>Here, the <code class="literal">case</code> expression works like this: <code class="literal">ls</code> is first checked against the pattern of an empty list. If <code class="literal">ls</code> is empty, the whole <code class="literal">case</code> expression then assumes the value of <code class="literal">"empty"</code>. If <code class="literal">ls</code> is not an empty list, then it’s checked against the pattern of a list with a single element. If the pattern match succeeds, the <code class="literal">case</code> expression then has the value of <code class="literal">"a singleton list"</code>. If neither of those two patterns match, then the catchall pattern, <code class="literal">xs</code>, applies. Finally, the result of the <code class="literal">case</code> expression is joined together with the string <code class="literal">"The list is"</code>. Each <code class="literal">case</code> expression represents a value. That’s why we were able to use <code class="literal">++</code> between the string <code class="literal">"The list is"</code> and our <code class="literal">case</code> expression.</p><p>Because pattern matching in function definitions is the same as using <code class="literal">case</code> expressions, we could have also defined the <code class="literal">describeList</code> function like this:</p><a id="I_programlisting3_d1e4927"/><pre class="programlisting">describeList :: [a] -&gt; String
describeList ls = "The list is " ++ what ls
    where what [] = "empty."
          what [x] = "a singleton list."
          what xs = "a longer list."</pre><p>This function acts just like the one in the previous example, although we used a different syntactic construct to define it. The function <code class="literal">what</code> gets called with <code class="literal">ls</code>, and then the usual pattern-matching action takes place. Once this function returns a string, it’s joined with <code class="literal">"The list is"</code>.</p></div></body></html>