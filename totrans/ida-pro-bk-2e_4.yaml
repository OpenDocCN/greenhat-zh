- en: Part IV. Extending IDA’s Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 15. IDA Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is a simple fact that no application can meet every need of every user. It
    is just not possible to anticipate every potential use case that may arise. Application
    developers are faced with the choice of responding to an endless stream of feature
    requests or offering users a means to solve their own problems. IDA takes the
    latter approach by integrating scripting features that allow users to exercise
    a tremendous amount of programmatic control over IDA’s actions.
  prefs: []
  type: TYPE_NORMAL
- en: Potential uses for scripts are infinite and can range from simple one-liners
    to full-blown programs that automate common tasks or perform complex analysis
    functions. From an automation standpoint, IDA scripts can be viewed as macros,^([[95](#ftn.CHP-15-FN-1)])
    while from an analysis point of view, IDA’s scripting languages serve as the query
    languages that provide programmatic access to the contents of an IDA database.
    IDA supports scripting using two different languages. IDA’s original, embedded
    scripting language is named *IDC*, perhaps because its syntax bears a close resemblance
    to C. Since the release of IDA 5.4,^([[96](#ftn.CHP-15-FN-2)]) integrated scripting
    with Python has also been supported through the integration of the IDAPython plug-in
    by Gergely Erdelyi.^([[97](#ftn.CHP-15-FN-3)]) For the remainder of this chapter
    we will cover the basics of writing and executing both IDC and Python scripts
    as well as some of the more useful functions available to script authors.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Script Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the details of either scripting language, it is useful to
    understand the most common ways that scripts can be executed. Three menu options,
    File ▸ Script File, File ▸ IDC Command, and File ▸ Python Command^([[98](#ftn.CHP-15-FN-4)])
    are available to access IDA’s scripting engine. Selecting File ▸ Script File indicates
    that you wish to run a standalone script, at which point you are presented with
    a file-selection dialog that lets you choose the script to run. Each time you
    run a new script, the program is added to a list of recent scripts to provide
    easy access to edit or rerun the script. [Figure 15-1](ch15.html#the_recent_scripts_window
    "Figure 15-1. The Recent Scripts window") shows the Recent Scripts window accessible
    via the View ▸ Recent Scripts menu option.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Recent Scripts window](httpatomoreillycomsourcenostarchimages854265.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1. The Recent Scripts window
  prefs: []
  type: TYPE_NORMAL
- en: Double-clicking a listed script causes the script to be executed. A pop-up,
    context-sensitive menu offers options to remove a script from the list or to open
    a script for editing using the editor specified under Options ▸ General on the
    Misc tab.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to executing a standalone script file, you may elect to open
    a script entry dialog using File ▸ IDC Command or File ▸ Python Command. [Figure 15-2](ch15.html#the_script_entry_dialog
    "Figure 15-2. The script entry dialog") shows the resulting script entry dialog
    (for an IDC script in this case), which is useful in situations where you wish
    to execute only a few statements but don’t want to go to the trouble of creating
    a standalone script file.
  prefs: []
  type: TYPE_NORMAL
- en: '![The script entry dialog](httpatomoreillycomsourcenostarchimages854268.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2. The script entry dialog
  prefs: []
  type: TYPE_NORMAL
- en: Some restrictions apply to the types of statements that you can enter in the
    script dialog, but the dialog is very useful in cases where creating a full-blown
    script file is overkill.
  prefs: []
  type: TYPE_NORMAL
- en: The last way to easily execute script commands is to use IDA’s command line.
    The command line is available only in GUI versions of IDA, and its presence is
    controlled by the value of the `DISPLAY_COMMAND_LINE` option in *<IDADIR>/cfg/idagui.cfg*.
    The command line has been enabled by default since IDA 5.4\. [Figure 15-3](ch15.html#the_ida_command_line
    "Figure 15-3. The IDA command line") shows the command line as it appears in the
    lower-left corner of the IDA workspace, beneath the output window.
  prefs: []
  type: TYPE_NORMAL
- en: '![The IDA command line](httpatomoreillycomsourcenostarchimages854271.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-3. The IDA command line
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter that will be used to execute the command line is labeled to
    the left of the command-line entry box. In [Figure 15-3](ch15.html#the_ida_command_line
    "Figure 15-3. The IDA command line"), the command line is configured to execute
    IDC statements. Clicking this label opens the pop-up menu shown in [Figure 15-3](ch15.html#the_ida_command_line
    "Figure 15-3. The IDA command line"), allowing either interpreter (IDC or Python)
    to be associated with the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Although the command line contains only a single line of text, you can enter
    multiple statements by separating each statement with a semicolon. As a convenience,
    the history of recent commands is accessible with the up arrow key. If you find
    yourself frequently needing to execute very short scripts, you will find the command
    line very useful.
  prefs: []
  type: TYPE_NORMAL
- en: With a basic ability to execute scripts under our belts, it is time to focus
    on the specifics of IDA’s two available scripting languages, IDC and Python. We
    begin with a description of IDA’s native scripting language, IDC, and conclude
    with a discussion of IDA’s Python integration, which will rely heavily on the
    foundation built by the IDC sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[95](#CHP-15-FN-1)]) Many applications offer facilities that allow users
    to record sequences of actions into a single complex action called a *macro*.
    Replaying or triggering a macro causes the entire sequence of recorded steps to
    be executed. Macros provided an easy means to automate a complex series of actions.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[96](#CHP-15-FN-2)]) For a comprehensive list of features introduced with
    each new version of IDA, visit [http://www.hex-rays.com/idapro/idanew48.htm](http://www.hex-rays.com/idapro/idanew48.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[97](#CHP-15-FN-3)]) See [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[98](#CHP-15-FN-4)]) This option is only available if Python is properly
    installed. Refer to [Chapter 3](ch03.html "Chapter 3. IDA Pro Background") for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: The IDC Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike for some other aspects of IDA, a reasonable amount of help is available
    for the IDC language in IDA’s help system. Topics available at the top level of
    the help system include *IDC language*, which covers the basics of IDC syntax,
    and *Index of IDC functions*, which provides an exhaustive list of built-in functions
    available to IDC programmers.
  prefs: []
  type: TYPE_NORMAL
- en: IDC is a scripting language that borrows most of its syntactic elements from
    C. Beginning with IDA 5.6, IDC actually takes on more of the flavor of C++ with
    the introduction of object-oriented features and exception handling. Because of
    its similarity to C and C++, we will describe IDC in terms of these languages
    and focus primarily on where IDC differs.
  prefs: []
  type: TYPE_NORMAL
- en: IDC Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDC is a loosely typed language, meaning that variables have no explicit type.
    The three primary datatypes used in IDC are integers (IDA documentation uses the
    type name *long*), strings, and floating point values, with the overwhelming majority
    of operations taking place on integers and strings. Strings are treated as a native
    datatype in IDC, and there is no need to keep track of the space required to store
    a string or whether a string is null terminated or not. Beginning with IDA 5.6,
    IDC incorporates a number of additional variable types, including objects, references,
    and function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'All variables must be declared prior to their use. IDC supports local variables
    and, since IDA 5.4, global variables as well. The IDC keyword `auto` is used to
    introduce a local variable declaration, and local variable declarations may include
    initial values. The following examples show legal IDC local variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: IDC recognizes C-style multiline comments using `/* */` and C++–style line-terminating
    comments using `//`. Also, note that several variables may be declared in a single
    statement and that all statements in IDC are terminated using a semicolon (as
    in C). IDC does not support C-style arrays (slices are introduced in IDA 5.6),
    pointers (though references are supported beginning with IDA 5.6), or complex
    datatypes such as structs and unions. Classes are introduced in IDA 5.6.
  prefs: []
  type: TYPE_NORMAL
- en: Global variable declarations are introduced using the `extern` keyword, and
    their declarations are legal both inside and outside of any function definition.
    It is not legal to provide an initial value when a global variable is declared.
    The following listing shows the declaration of two global variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Global variables are allocated the first time they are encountered during an
    IDA session and persist as long as that session remains active, regardless of
    the number of databases that you may open and close.
  prefs: []
  type: TYPE_NORMAL
- en: IDC Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a few exceptions, IDC supports virtually all of the arithmetic and logical
    operators available in C, including the ternary operator (`? :`). Compound assignment
    operators of the form `op=` (`+=`, `*=`, `>>=`, and the like) are not supported.
    The comma operator is supported beginning with IDA 5.6\. All integer operands
    are treated as signed values. This affects integer comparisons (which are always
    signed) and the right-shift operator (`>>`), which always performs an arithmetic
    shift with sign bit replication. If you require logical right shifts, you must
    implement them yourself by masking off the top bit of the result, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because strings are a native type in IDC, some operations on strings take on
    a different meaning than they might in C. The assignment of a string operand into
    a string variable results in a string copy operation; thus there is no need for
    string copying or duplicating functions such as C’s `strcpy` and `strdup`. Also,
    the addition of two string operands results in the concatenation of the two operands;
    thus “Hello” + “World” yields “HelloWorld”; there is no need for a concatenation
    function such as C’s `strcat`. Starting with IDA 5.6, IDC offers a slice operator
    for use with strings. Python programmers will be familiar with slices, which basically
    allow you to specify subsequences of array-like variables. Slices are specified
    using square brackets and a start (inclusive) and end (exclusive) index. At least
    one index is required. The following listing demonstrates the use of IDC slices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that while there are no array datatypes available in IDC, the slice operator
    effectively allows you to treat IDC strings as if they were arrays.
  prefs: []
  type: TYPE_NORMAL
- en: IDC Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in C, all simple statements are terminated with a semicolon. The only C-style
    compound statement that IDC does not support is the `switch` statement. When using
    `for` loops, keep in mind that IDC does not support compound assignment operators,
    which may affect you if you wish to count by anything other than one, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With IDA 5.6, IDC introduces `try`/`catch` blocks and the associated `throw`
    statement, which are syntactically similar to C++ exceptions.^([[99](#ftn.CHP-15-FN-5)])
    IDA’s built-in help contains specifics on IDC’s exception-handling implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For compound statements, IDC utilizes the same bracing (`{}`) syntax and semantics
    as C. Within a braced block, it is permissible to declare new variables as long
    as the variable declarations are the first statements within the block. However,
    IDC does not rigorously enforce the scope of the newly introduced variables, because
    such variables may be referenced beyond the block in which they were declared.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output statements (the `Message` function is analogous to C’s `printf`)
    will inform us that `x = 10` and `y = 0`. Given that IDC does not strictly enforce
    the scope of `x`, it is not terribly surprising that we are allowed to print the
    value of `x`. What is somewhat surprising is that `y` is accessible at all, given
    that the block in which `y` is declared is never executed. This is simply a quirk
    of IDC. Note that while IDC may loosely enforce variable scoping within a function,
    variables declared within one function continue to remain inaccessible in any
    other function.
  prefs: []
  type: TYPE_NORMAL
- en: IDC Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IDC supports user-defined functions in standalone programs (*.idc* files) only.
    User-defined functions are not supported when using the IDC command dialog (see
    [USING THE IDC COMMAND DIALOG](ch15s02.html#using_the_idc_command_dialog "USING
    THE IDC COMMAND DIALOG") in [USING THE IDC COMMAND DIALOG](ch15s02.html#using_the_idc_command_dialog
    "USING THE IDC COMMAND DIALOG")). IDC’s syntax for declaring user-defined functions
    is where it differs most from C. The `static` keyword is used to introduce a user-defined
    function, and the function’s parameter list consists solely of a comma-separated
    list of parameter names. The following listing details the basic structure of
    a user-defined function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Prior to IDA 5.6, all function parameters are strictly call-by-value. Call-by-reference
    parameter passing was introduced with IDA 5.6\. Interestingly, whether a parameter
    is passed using call-by-value or call-by-reference is determined by the manner
    in which the function is called, not the manner in which the function is declared.
    The unary `&` operator is used in a function call (*not* the function declaration)
    to denote that an argument is being passed by reference. The following examples
    show invocations of the `my_func` function from the previous listing making use
    of both call-by-value and call-by-reference parameter passing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Function declarations never indicate whether a function explicitly returns a
    value or what type of value is returned when a function does yield a result.
  prefs: []
  type: TYPE_NORMAL
- en: USING THE IDC COMMAND DIALOG
  prefs: []
  type: TYPE_NORMAL
- en: The IDC command dialog offers a simple interface for entering short sequences
    of IDC code. The command dialog is a great tool for rapidly entering and testing
    new scripts without the hassle of creating a standalone script file. The most
    important thing to keep in mind when using the command dialog is that you *must*
    not define any functions inside the dialog. In essence, IDA wraps your statements
    within a function and then calls that function in order to execute your statements.
    If you were to define a function within the dialog, the net effect would be a
    function defined within a function, and since nested function declarations are
    not allowed in IDC (or in C for that matter), a syntax error would result.
  prefs: []
  type: TYPE_NORMAL
- en: When you wish to return a value from a function, use a `return` statement to
    return the desired value. It is permissible to return entirely different datatypes
    from different paths of execution within a function. In other words, a function
    may return a string in some cases, while in other cases the same function may
    return an integer. As in C, use of a `return` statement within a function is optional.
    However, unlike C, any function that does not explicitly return a value implicitly
    returns the value zero.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, beginning with IDA 5.6, functions take a step closer to becoming
    first-class objects in IDC. It is now possible to pass function references as
    arguments to other functions and return function references as the result of a
    function. The following listing demonstrates the use of function parameters and
    functions as return values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: IDC Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another feature introduced in IDA 5.6 is the ability to define classes and,
    as a result, have variables that represent objects. In the discussion that follows,
    we assume that you have some familiarity with an object-oriented programming language
    such as C++ or Java.
  prefs: []
  type: TYPE_NORMAL
- en: IDA SCRIPTING EVOLVES
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t gotten the idea that a large number of changes to IDC were introduced
    with IDA 5.6, then you haven’t been paying attention. Following the integration
    of IDAPython in IDA 5.4, Hex-Rays looked to rejuvenate IDC, resulting in many
    of the features mentioned in this chapter being introduced in IDA 5.6\. Along
    the way, JavaScript was even contemplated as a potential addition to IDA’s scripting
    lineup.^([[100](#ftn.CHP-15-FN-6)]).
  prefs: []
  type: TYPE_NORMAL
- en: IDC defines a root class named `object` from which all classes ultimately derive,
    and single inheritance is supported when creating new classes. IDC does not make
    use of access specifiers such as `public` and `private`; all class members are
    effectively public. Class declarations contain only the definitions of the class’s
    member functions. In order to create data members within a class, you simply create
    an assignment statement that assigns a value to the data member. The following
    listing will help to clarify.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For more information on IDC classes and their syntax, refer to the appropriate
    section within IDA’s built-in help file.
  prefs: []
  type: TYPE_NORMAL
- en: IDC Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any scripting applications that require more than a few IDC statements,
    you are likely to want to create a standalone IDC program file. Among other things,
    saving your scripts as programs gives you some measure of persistence and portability.
  prefs: []
  type: TYPE_NORMAL
- en: 'IDC program files require you to make use of user-defined functions. At a minimum,
    you must define a function named `main` that takes no arguments. In most cases,
    you will also want to include the file *idc.idc* in order to pick up useful macro
    definitions that it contains. The following listing details the components of
    a minimal IDC program file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'IDC recognizes the following C-style preprocessor directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`#include`** <file>'
  prefs: []
  type: TYPE_NORMAL
- en: Includes the named file in the current file.
  prefs: []
  type: TYPE_NORMAL
- en: '**`#define`** <name> [optional value]'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a macro named *name* and optionally assigns it the specified value.
    IDC predefines a number of macros that may be used to test various aspects of
    your script’s execution environment. These include *_NT_*, *_LINUX_*, *_MAC_*,
    *_GUI_*, and `_`*TXT_* among others. See the *Predefined symbols* section of the
    IDA help file for more information on these and other symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '**`#ifdef`** <name>'
  prefs: []
  type: TYPE_NORMAL
- en: Tests for the existence of the named macro and optionally processes any statements
    that follow if the named macro exists.
  prefs: []
  type: TYPE_NORMAL
- en: '**`#else`**'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally used in conjunction with an `#ifdef` to provide an alternative set
    of statements to process in the event the named macro does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**`#endif`**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a required terminator for an `#ifdef` or `#ifdef/#else` block.
  prefs: []
  type: TYPE_NORMAL
- en: '**`#undef`** <name>'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the named macro.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling in IDC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No one is ever going to praise IDC for its error-reporting capabilities. There
    are two types of errors that you can expect to encounter when running IDC scripts:
    parsing errors and runtime errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Parsing errors* are those errors that prevent your program from ever being
    executed and include such things as syntax errors, references to undefined variables,
    and supplying an incorrect number of arguments to a function. During the parsing
    phase, IDC reports only the first parsing error that it encounters. In some cases,
    error messages correctly identify both the location and the type of an error (`hello_world.idc,20:
    Missing semicolon`), while in other cases, error messages offer no real assistance
    (`Syntax error near: <END>`). Only the first error encountered during parsing
    is reported. As a result, in a script with 15 syntax errors, it may take 15 attempts
    at running the script before you are informed of every error.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Runtime errors* are generally encountered less frequently than parsing errors.
    When encountered, runtime errors cause a script to terminate immediately. One
    example of a runtime error results from an attempt to call an undefined function
    that for some reason is not detected when the script is initially parsed. Another
    problem arises with scripts that take an excessive amount of time to execute.
    Once a script is started, there is no easy way to terminate the script if it inadvertently
    ends up in an infinite loop or simply takes longer to execute than you are willing
    to wait. Once a script has executed for more than two to three seconds, IDA displays
    the dialog shown in [Figure 15-4](ch15s02.html#script_cancellation_dialog "Figure 15-4. Script
    cancellation dialog").'
  prefs: []
  type: TYPE_NORMAL
- en: This dialog is the only means by which you can terminate a script that fails
    to terminate properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Script cancellation dialog](httpatomoreillycomsourcenostarchimages854274.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-4. Script cancellation dialog
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is another of IDC’s weak points. Other than liberal use of output
    statements, there is no way to debug IDC scripts. With the introduction of exception
    handling (`try/catch`) in IDA 5.6, it does become possible to build more robust
    scripts that can terminate or continue as gracefully as you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent Data Storage in IDC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps you are the curious type who, not trusting that we would provide sufficient
    coverage of IDA’s scripting capability, raced off to see what the IDA help system
    has to say on the subject. If so, welcome back, and if not, we appreciate you
    sticking with us this far. In any case, somewhere along the way you may have acquired
    knowledge that claims that IDC does in fact support arrays, in which case you
    must surely be questioning the quality of this book. We urge you to give us a
    chance to sort out this potential confusion.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, IDC does not support arrays in the traditional sense
    of declaring a large block of storage and then using a subscript notation to access
    individual items within that block. However, IDA’s documentation on scripting
    does mention something called *global persistent arrays*. IDC global arrays are
    better thought of as *persistent named objects*. The objects just happen to be
    sparse arrays.^([[101](#ftn.CHP-15-FN-7)]) Global arrays are stored within an
    IDA database and are persistent across script invocations and IDA sessions. Data
    is stored in global arrays by specifying an index and a data value to be stored
    at the specified index in the array. Each element in an array can simultaneously
    hold one integer value and one string value. IDC’s global arrays provide no means
    for storing floating point values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the overly curious, IDA’s internal mechanism for storing persistent arrays
    is called a netnode. While the array-manipulation functions described next provide
    an abstracted interface to netnodes, lower-level access to netnode data is available
    using the IDA SDK, which is discussed, along with netnodes, in [Chapter 16](ch16.html
    "Chapter 16. The IDA Software Development Kit").
  prefs: []
  type: TYPE_NORMAL
- en: 'All interaction with global arrays occurs through the use of IDC functions
    dedicated to array manipulation. Descriptions of these functions follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`long CreateArray(string name)`**'
  prefs: []
  type: TYPE_NORMAL
- en: This function creates a persistent object with the specified name. The return
    value is an integer handle required for all future access to the array. If the
    named object already exists, the return value is −1.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetArrayId(string name)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Once an array has been created, subsequent access to the array must be done
    through an integer handle, which can be obtained by looking up the array name.
    The return value for this function is an integer handle to be used for all future
    interaction with the array. If the named array does not exist, the return value
    is −1.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long SetArrayLong(long id, long idx, long value)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Stores an integer `value` into the array referred to by `id` at the position
    specified by `idx`. The return value is 1 on success or 0 on failure. The operation
    will fail if the array `id` is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long SetArrayString(long id, long idx, string str)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Stores a string `value` into the array referred to by `id` at the position specified
    by `idx`. The return value is 1 on success or 0 on failure. The operation will
    fail if the array `id` is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string or long GetArrayElement(long tag, long id, long idx)`**'
  prefs: []
  type: TYPE_NORMAL
- en: While there are distinct functions for storing data into an array depending
    on the type of data to be stored, there is only one function for retrieving data
    from an array. This function retrieves either an integer or a string value from
    the specified index (`idx`) in the specified array (`id`). Whether an integer
    or a string is retrieved is determined by the value of the `tag` parameter, which
    must be one of the constants `AR_LONG` (to retrieve an integer) or `AR_STR` (to
    retrieve a string).
  prefs: []
  type: TYPE_NORMAL
- en: '**`long DelArrayElement(long tag, long id, long idx)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the contents of the specified array location from the specified array.
    The value of `tag` determines whether the integer value or string value associated
    with the specified index is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '**`void DeleteArray(long id)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the array referenced by `id` and all of its associated contents. Once
    an array has been created, it continues to exist, even after a script terminates,
    until a call is made to `DeleteArray` to remove the array from the database in
    which it was created.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long RenameArray(long id, string newname)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Renames the array referenced by `id` to `newname`. Returns 1 if successful or
    0 if the operation fails.
  prefs: []
  type: TYPE_NORMAL
- en: Possible uses for global arrays include approximating global variables, approximating
    complex datatypes, and providing persistent storage across script invocations.
    Global variables for a script are simulated by creating a global array when the
    script begins and storing global values in the array. These global values are
    shared either by passing the array handle to functions requiring access to the
    values or by requiring any function that requires access to perform a name lookup
    for the desired array.
  prefs: []
  type: TYPE_NORMAL
- en: Values stored in an IDC global array persist for the lifetime of the database
    in which the script was executed. You may test for the existence of an array by
    examining the return value of the `CreateArray` function. If the values stored
    in an array are applicable only to a specific invocation of a script, then the
    array should be deleted before the script terminates. Deleting the array ensures
    that no global values carry over from one execution of a script to a subsequent
    execution of the same script.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[99](#CHP-15-FN-5)]) See [http://www.cplusplus.com/doc/tutorial/exceptions/](http://www.cplusplus.com/doc/tutorial/exceptions/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[100](#CHP-15-FN-6)]) See [http://www.hexblog.com/?p=101](http://www.hexblog.com/?p=101)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[101](#CHP-15-FN-7)]) Sparse arrays do not necessarily preallocate space
    for the entire array, nor are they limited to a particular maximum index. Instead,
    space for array elements is allocated on an as-needed basis when elements are
    added to the array.
  prefs: []
  type: TYPE_NORMAL
- en: Associating IDC Scripts with Hotkeys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Occasionally you may develop a script so amazing in its utility that you must
    have access to it with a keystroke or two. When this happens, you will want to
    assign a hotkey sequence that you can use to quickly activate your script. Fortunately
    IDA provides a simple means to do this. Every time IDA is launched, the script
    contained in *<IDADIR>/idc/ida.idc* is executed. The default version of this script
    contains an empty `main` function and thus does nothing. To associate a hotkey
    with one of your scripts, you need to add two lines to *ida.idc*. The first line
    you must add is an `include` directive to include your script file in *ida.idc*.
    The second line you must add is a call, within `main`, to the `AddHotkey` function
    to associate a specific hotkey with your amazing IDC function. This might leave
    *ida.idc* looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If the hotkey you are attempting to associate with your script has already been
    assigned to another IDA action (menu hotkey or plug-in activation sequence), `AddHotkey`
    silently fails with no way to detect the failure other than the fact that your
    function fails to execute when your hotkey sequence is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Two important points here are that the standard include directory for IDC scripts
    is *<IDADIR>/idc* and that you must not name your script function `main`. If you
    want IDA to find your script easily, you can copy it into *<IDADIR>/idc*. If you
    intend to leave your script file in another location, then you will need to specify
    the full path to your script in the `include` statement. While testing your script,
    it will be useful to run your script as a standalone program with a `main` function.
    Once you are ready to associate your script with a hotkey, however, you cannot
    use the name `main`, because it will conflict with the `main` function in *ida.idc*.
    You must rename your `main` function and use the new name in the call to `AddHotkey`.
  prefs: []
  type: TYPE_NORMAL
- en: Useful IDC Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have all the information required to write well-formed IDC
    scripts. What you are lacking is the ability to perform any useful interaction
    with IDA itself. IDC provides a long list of built-in functions that offer many
    different ways to access a database. All of the functions are documented to some
    degree in the IDA help system under the topic *Index of IDC functions*. In most
    cases, the documentation is nothing more than relevant lines copied from the main
    IDC include file, *idc.idc*. Becoming comfortable with the rather terse documentation
    is one of the more frustrating aspects of learning IDC. In general, there is no
    easy way to answer the question “How do I do *x* in IDC?” The most common way
    to figure out how to do something is to browse the list of IDC functions looking
    for one that, based on its name, appears to do what you need. This presumes, of
    course, that the functions are named according to their purpose, but their purpose
    may not always be obvious. For example, in many cases, functions that retrieve
    information from the database are named `Get`*`XXX`*; however; in many other cases,
    the `Get` prefix is not used. Functions that change the database may be named
    `Set`*`XXX`*, `Make`*`XXX`*, or something else entirely. In summary, if you want
    to use IDC, get used to browsing the list of functions and reading through their
    descriptions. If you find yourself at a complete loss, don’t be afraid to use
    the support forums at Hex-Rays.^([[102](#ftn.CHP-15-FN-8)])
  prefs: []
  type: TYPE_NORMAL
- en: The intent of the remainder of this section is to point out some of the more
    useful (in our experience) IDC functions and group them into functional areas.
    Even if you intend to script in Python only, familiarity with the listed functions
    will be useful to you because IDAPython provides Python equivalents to each function
    listed here. We make no attempt to cover every IDC function, however, since they
    are already covered in the IDA help system.
  prefs: []
  type: TYPE_NORMAL
- en: Functions for Reading and Modifying Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following functions provide access to individual bytes, words, and double
    words in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`long Byte(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a byte value from virtual address `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long Word(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a word (2-byte) value from virtual address `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long Dword(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a double word (4-byte) value from virtual address `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`void PatchByte(long addr, long val)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a byte value at virtual address `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`void PatchWord(long addr, long val)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a word value at virtual address `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`void PatchDword(long addr, long val)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a double word value at virtual address `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool isLoaded(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns 1 if `addr` contains valid data, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these functions takes the byte ordering (little-endian or big-endian)
    of the current processor module into account when reading and writing the database.
    The `Patch`*`XXX`* functions also trim the supplied value to an appropriate size
    by using only the proper number of low-order bytes according to the function called.
    For example, a call to `PatchByte(0x401010, 0x1234)` will patch location `0x401010`
    with the byte value `0x34` (the low-order byte of `0x1234`). If an invalid address
    is supplied while reading the database with `Byte`, `Word`, and `Dword`, the values
    `0xFF`, `0xFFFF`, and `0xFFFFFFFF` will be returned, respectively. Because there
    is no way to distinguish these error values from legitimate data stored in the
    database, you may wish to call `isLoaded` to determine whether an address in the
    database contains any data prior to attempting to read from that address.
  prefs: []
  type: TYPE_NORMAL
- en: Because of a quirk in refreshing IDA’s disassembly view, you may find that the
    results of a patch operation are not immediately visible. In such cases, scrolling
    away from the patched location and then scrolling back to the patched location
    generally forces the display to be updated properly.
  prefs: []
  type: TYPE_NORMAL
- en: User Interaction Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to perform any user interaction at all, you will need to familiarize
    yourself with IDC input/output functions. The following list summarizes some of
    IDC’s more useful interface functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`void Message(string format, ...)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Prints a formatted message to the output window. This function is analogous
    to C’s `printf` function and accepts a `printf`-style format string.
  prefs: []
  type: TYPE_NORMAL
- en: '**`void print(...)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Prints the string representation of each argument to the output window.
  prefs: []
  type: TYPE_NORMAL
- en: '**`void Warning(string format, ...)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays a formatted message in a dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string AskStr(string default, string prompt)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays an input dialog asking the user to enter a string value. Returns the
    user’s string or 0 if the dialog was canceled.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string AskFile(long doSave, string mask, string prompt)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays a file-selection dialog to simplify the task of choosing a file. New
    files may be created for saving data (`doSave = 1`), or existing files may be
    chosen for reading data (`doSave = 0`). The displayed list of files may be filtered
    according to `mask` (such as `*.*` or `*.idc`). Returns the name of the selected
    file or 0 if the dialog was canceled.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long AskYN(long default, string prompt)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Prompts the user with a yes or no question, highlighting a default answer (1
    = yes, 0 = no, −1 = cancel). Returns an integer representing the selected answer.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long ScreenEA()`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the virtual address of the current cursor location.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool Jump(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Jumps the disassembly window to the specified address.
  prefs: []
  type: TYPE_NORMAL
- en: Because IDC lacks any debugging facilities, you may find yourself using the
    `Message` function as your primary debugging tool. Several other `Ask`*`XXX`*
    functions exist to handle more specialized input cases such as integer input.
    Please refer to the help system documentation for a complete list of available
    `Ask`*`XXX`* functions. The `ScreenEA` function is very useful for picking up
    the current cursor location when you wish to create a script that tailors its
    behavior based on the location of the cursor. Similarly, the `Jump` function is
    useful when you have a script that needs to call the user’s attention to a specific
    location within the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: String-Manipulation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although simple string assignment and concatenation are taken care of with
    basic operators in IDC, more complex operations must be performed using available
    string-handling functions, some of which are detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`string form(string format, ...) // pre IDA 5.6`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a new string formatted according to the supplied format strings and
    values. This is the rough equivalent to C’s `sprintf` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string sprintf(string format, ...) // IDA 5.6+`**'
  prefs: []
  type: TYPE_NORMAL
- en: With IDA 5.6, `sprintf` replaces `form` (see above).
  prefs: []
  type: TYPE_NORMAL
- en: '**`long atol(string val)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Converts the decimal value `val` to its corresponding integer representation.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long xtol(string val)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Converts the hexadecimal value `val` (which may optionally begin with `0x`)
    to its corresponding integer representation.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string ltoa(long val, long radix)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a string representation of `val` in the specified `radix` (2, 8, 10,
    or 16).
  prefs: []
  type: TYPE_NORMAL
- en: '**`long ord(string ch)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the ASCII value of the one-character string `ch`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long strlen(string str)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the length of the provided string.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long strstr(string str, string substr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the index of `substr` within `str` or −1 if the substring is not found.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string substr(string str, long start, long end)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the substring containing the characters from `start` through `end-1`
    of `str`. Using slices (IDA 5.6+) this function is equivalent to `str[start:end]`.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that there is no character datatype in IDC, nor is there any array syntax.
    Lacking slices, if you want to iterate through the individual characters within
    a string, you must take successive one-character substrings for each character
    in the string.
  prefs: []
  type: TYPE_NORMAL
- en: File Input/Output Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output window may not always be the ideal place to send the output of your
    scripts. For scripts that generate a large amount of text or scripts that generate
    binary data, you may wish to output to disk files instead. We have already discussed
    using the `AskFile` function to ask a user for a filename. However, `AskFile`
    returns only a string containing the name of a file. IDC’s file-handling functions
    are detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`long fopen(string filename, string mode)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an integer file handle (or 0 on error) for use with all IDC file I/O
    functions. The `mode` parameter is similar to the modes used in C’s `fopen` (`r`
    to read, `w` to write, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '**`void fclose(long handle)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Closes the file specified by the file handle from `fopen`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long filelength(long handle)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the length of the indicated file or −1 on error.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long fgetc(long handle)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a single byte from the given file. Returns −1 on error.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long fputc(long val, long handle)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes a single byte to the given file. Returns 0 on success or −1 on error.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long fprintf(long handle, string format, ...)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes a formatted string to the given file.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long writestr(long handle, string str)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes the specified string to the given file.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string/long readstr(long handle)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a string from the given file. This function reads all characters (including
    non-ASCII) up to and including the next line feed (ASCII 0xA) character. Returns
    the string on success or −1 on end of file.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long writelong(long handle, long val, long bigendian)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes a 4-byte integer to the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long readlong(long handle, long bigendian)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a 4-byte integer from the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long writeshort(long handle, long val, long bigendian)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes a 2-byte integer to the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long readshort(long handle, long bigendian)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a 2-byte integer from the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool loadfile(long handle, long pos, long addr, long length)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads `length` number of bytes from position `pos` in the given file and writes
    those bytes into the database beginning at address `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool savefile(long handle, long pos, long addr, long length)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes `length` number of bytes beginning at database address `addr` to position
    `pos` in the given file.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Database Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The need to manipulate named locations arises fairly often in scripts. The
    following IDC functions are available for working with named locations in an IDA
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`string Name(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the name associated with the given address or returns the empty string
    if the location has no name. This function does not return user-assigned names
    when the names are marked as local.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string NameEx(long from, long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the name associated with `addr`. Returns the empty string if the location
    has no name. This function returns user-defined local names if `from` is any address
    within a function that also contains `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool MakeNameEx(long addr, string name, long flags)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns the given name to the given address. The name is created with attributes
    specified in the `flags` bitmask. These flags are described in the help file documentation
    for `MakeNameEx` and are used to specify attributes such as whether the name is
    local or public or whether it should be listed in the names window.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long LocByName(string name)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the address of the location with the given name. Returns BADADDR (−1)
    if no such name exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long LocByNameEx(long funcaddr, string localname)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for the given local name within the function containing `funcaddr`.
    Returns BADADDR (−1) if no such name exists in the given function.
  prefs: []
  type: TYPE_NORMAL
- en: Functions Dealing with Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many scripts are designed to perform analysis of functions within a database.
    IDA assigns disassembled functions a number of attributes, such as the size of
    the function’s local variable area or the size of the function’s arguments on
    the runtime stack. The following IDC functions can be used to access information
    about functions within a database.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetFunctionAttr(long addr, long attrib)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the requested attribute for the function containing the given address.
    Refer to the IDC help documentation for a list of attribute constants. As an example,
    to find the ending address of a function, use **`GetFunctionAttr(addr, FUNCATTR_END);`**.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string GetFunctionName(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the name of the function that contains the given address or an empty
    string if the given address does not belong to a function.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long NextFunction(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the starting address of the next function following the given address.
    Returns −1 if there are no more functions in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long PrevFunction(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the starting address of the nearest function that precedes the given
    address. Returns −1 if no function precedes the given address.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `LocByName` function to find the starting address of a function given
    the function’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Code Cross-Reference Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cross-references were covered in [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing"). IDC offers functions for accessing cross-reference information
    associated with any instruction. Deciding which functions meet the needs of your
    scripts can be a bit confusing. It requires you to understand whether you are
    interested in following the flows leaving a given address or whether you are interested
    in iterating over all of the locations that refer to a given address. Functions
    for performing both of the preceding operations are described here. Several of
    these functions are designed to support iteration over a set of cross-references.
    Such functions support the notion of a sequence of cross-references and require
    a `current` cross-reference in order to return a `next` cross-reference. Examples
    of using cross-reference iterators are provided in [Enumerating Cross-References](ch15s05.html#enumerating_cross-references
    "Enumerating Cross-References") in [Enumerating Cross-References](ch15s05.html#enumerating_cross-references
    "Enumerating Cross-References").
  prefs: []
  type: TYPE_NORMAL
- en: '**`long Rfirst(long from)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first location to which the given address transfers control. Returns
    BADADDR (−1) if the given address refers to no other address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long Rnext(long from, long current)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next location to which the given address (`from`) transfers control,
    given that `current` has already been returned by a previous call to `Rfirst`
    or `Rnext`. Returns BADADDR if no more cross-references exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long XrefType()`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a constant indicating the type of the last cross-reference returned
    by a cross-reference lookup function such as `Rfirst`. For code cross-references,
    these constants are `fl_CN` (near call), `fl_CF` (far call), `fl_JN` (near jump),
    `fl_JF` (far jump), and `fl_F` (ordinary sequential flow).
  prefs: []
  type: TYPE_NORMAL
- en: '**`long RfirstB(long to)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first location that transfers control to the given address. Returns
    BADADDR (−1) if there are no references to the given address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long RnextB(long to, long current)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next location that transfers control to the given address (`to`),
    given that `current` has already been returned by a previous call to `RfirstB`
    or `RnextB`. Returns BADADDR if no more cross-references to the given location
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: Each time a cross-reference function is called, an internal IDC state variable
    is set that indicates the type of the last cross-reference that was returned.
    If you need to know what type of cross-reference you have received, then you must
    call `XrefType` prior to calling another cross-reference lookup function.
  prefs: []
  type: TYPE_NORMAL
- en: Data Cross-Reference Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functions for accessing data cross-reference information are very similar
    to the functions used to access code cross-reference information. These functions
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`long Dfirst(long from)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first location to which the given address refers to a data value.
    Returns BADADDR (−1) if the given address refers to no other addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long Dnext(long from, long current)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next location to which the given address (`from`) refers a data
    value, given that `current` has already been returned by a previous call to `Dfirst`
    or `Dnext`. Returns BADADDR if no more cross-references exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long XrefType()`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a constant indicating the type of the last cross-reference returned
    by a cross-reference lookup function such as `Dfirst`. For data cross-references,
    these constants include `dr_O` (offset taken), `dr_W` (data write), and `dr_R`
    (data read).
  prefs: []
  type: TYPE_NORMAL
- en: '**`long DfirstB(long to)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first location that refers to the given address as data. Returns
    BADADDR (−1) if there are no references to the given address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long DnextB(long to, long current)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next location that refers to the given address (`to`) as data, given
    that `current` has already been returned by a previous call to `DfirstB` or `DnextB`.
    Returns BADADDR if no more cross-references to the given location exist.
  prefs: []
  type: TYPE_NORMAL
- en: As with code cross-references, if you need to know what type of cross-reference
    you have received, then you must call `XrefType` prior to calling another cross-reference
    lookup function.
  prefs: []
  type: TYPE_NORMAL
- en: Database Manipulation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number of functions exist for formatting the contents of a database. Here
    are descriptions of a few of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`void MakeUnkn(long addr, long flags)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Undefines the item at the specified address. The flags (see the IDC documentation
    for `MakeUnkn`) dictate whether subsequent items will also be undefined and whether
    any names associated with undefined items will be deleted. Related function `MakeUnknown`
    allows you to undefine large blocks of data.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long MakeCode(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Converts the bytes at the specified address into an instruction. Returns the
    length of the instruction or 0 if the operation fails.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool MakeByte(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Converts the item at the specified address into a data byte. `MakeWord` and
    `MakeDword` are also available.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool MakeComm(long addr, string comment)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a regular comment at the given address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool MakeFunction(long begin, long end)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Converts the range of instructions from `begin` to `end` into a function. If
    `end` is specified as `BADADDR (-1)`, IDA attempts to automatically identify the
    end of the function by locating the function’s return instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool MakeStr(long begin, long end)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a string of the current string type (as returned by `GetStringType`),
    spanning the bytes from `begin` to `end - 1`. If `end` is specified as `BADADDR`,
    IDA attempts to automatically identify the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Many other `Make`*`XXX`* functions exist that offer behavior similar to the
    functions just described. Please refer to the IDC documentation for a full list
    of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Database Search Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The majority of IDA’s search capabilities are accessible in IDC in the form
    of various `Find`*`XXX`* functions, some of which are described here. The `flags`
    parameter used in the `Find`*`XXX`* functions is a bitmask that specifies the
    behavior of the find operation. Three of the more useful flags are `SEARCH_DOWN`,
    which causes the search to scan toward higher addresses; `SEARCH_NEXT`, which
    skips the current occurrence in order to search for the next occurrence; and `SEARCH_CASE`,
    which causes binary and text searches to be performed in a case-sensitive manner.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long FindCode(long addr, long flags)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for an instruction from the given address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long FindData(long addr, long flags)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for a data item from the given address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long FindBinary(long addr, long flags, string binary)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for a sequence of bytes from the given address. The `binary` string
    specifies a sequence of hexadecimal byte values. If `SEARCH_CASE` is not specified
    and a byte value specifies an uppercase or lowercase ASCII letter, then the search
    will also match corresponding, complementary case values. For example, “41 42”
    will match “61 62” (and “61 42”) unless the `SEARCH_CASE` flag is set.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long FindText(long addr, long flags, long row, long column, string text)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for a `text` string from the given `column` on the given line (`row`)
    at the given address. Note that the disassembly text at a given address may span
    several lines, hence the need to specify on which line the search should begin.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that `SEARCH_NEXT` does not define the direction of search, which
    may be either up or down according to the `SEARCH_DOWN` flag. In addition, when
    `SEARCH_NEXT` is not specified, it is perfectly reasonable for a `Find`*`XXX`*
    function to return the same address that was passed in as the `addr` argument
    when the item at `addr` satisfies the search.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembly Line Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From time to time it is useful to extract the text, or portions of the text,
    of individual lines in a disassembly listing. The following functions provide
    access to various components of a disassembly line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`string GetDisasm(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns disassembly text for the given address. The returned text includes any
    comments but does not include address information.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string GetMnem(long addr)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the mnemonic portion of the instruction at the given address.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string GetOpnd(long addr, long opnum)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the text representation of the specified operand at the specified address.
    Operands are numbered from zero beginning with the leftmost operand.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetOpType(long addr, long opnum)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an integer representing the type for the given operand at the given
    address. Refer to the IDC documentation for `GetOpType` for a complete list of
    operand type codes.
  prefs: []
  type: TYPE_NORMAL
- en: '**`long GetOperandValue(long addr, long opnum)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the integer value associated with the given operand at the given address.
    The nature of the returned value depends on the type of the given operand as specified
    by `GetOpType`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`string CommentEx(long addr, long type)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the text of any comment present at the given address. If `type` is 0,
    the text of the regular comment is returned. If `type` is 1, the text of the repeatable
    comment is returned. If no comment is present at the given address, an empty string
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[102](#CHP-15-FN-8)]) The support forum is currently located at [http://www.hex-rays.com/forum/](http://www.hex-rays.com/forum/)
  prefs: []
  type: TYPE_NORMAL
- en: IDC Scripting Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point it is probably useful to see some examples of scripts that perform
    specific tasks. For the remainder of the chapter we present some fairly common
    situations in which a script can be used to answer a question about a database.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many scripts operate on individual functions. Examples include generating the
    call tree rooted at a specific function, generating the control flow graph of
    a function, or analyzing the stack frames of every function in a database. [Example 15-1](ch15s05.html#function_enumeration_script
    "Example 15-1. Function enumeration script") iterates through every function in
    a database and prints basic information about each function, including the start
    and end addresses of the function, the size of the function’s arguments, and the
    size of the function’s local variables. All output is sent to the output window.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-1. Function enumeration script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This script uses some of IDC’s structure-manipulation functions to obtain a
    handle to each function’s stack frame (`GetFrame`), determine the size of the
    stack frame (`GetStrucSize`), and determine the offset of the saved return address
    within the frame (`GetMemberOffset`). The first argument to the function lies
    4 bytes beyond the saved return address. The size of the function’s argument area
    is computed as the space between the first argument and the end of the stack frame.
    Since IDA can’t generate stack frames for imported functions, this script tests
    whether the function’s stack frame contains a saved return address as a simple
    means of identifying calls to an imported function.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within a given function, you may want to enumerate every instruction. [Example 15-2](ch15s05.html#instruction_enumeration_script
    "Example 15-2. Instruction enumeration script") counts the number of instructions
    contained in the function identified by the current cursor position:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2. Instruction enumeration script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The function begins ![](httpatomoreillycomsourcenostarchimages854061.png) by
    using `GetFunctionAttr` to determine the start address of the function containing
    the cursor address (`ScreenEA()`). If the beginning of a function is found, the
    next step ![](httpatomoreillycomsourcenostarchimages854063.png) is to determine
    the end address for the function, once again using the `GetFunctionAttr` function.
    Once the function has been bounded, a loop is executed to step through successive
    instructions in the function by using the search functionality of the `FindCode`
    function ![](httpatomoreillycomsourcenostarchimages854093.png). In this example,
    the `Warning` function is used to display results, since only a single line of
    output will be generated by the function and output displayed in a Warning dialog
    is much more obvious than output generated in the message window. Note that this
    example assumes that all of the instructions within the given function are contiguous.
    An alternative approach might replace the use of `FindCode` with logic to iterate
    over all of the code cross-references for each instruction within the function.
    Properly written, this second approach would handle noncontiguous, also known
    as “chunked,” functions.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Cross-References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iterating through cross-references can be confusing because of the number of
    functions available for accessing cross-reference data and the fact that code
    cross-references are bidirectional. In order to get the data you want, you need
    to make sure you are accessing the proper type of cross-reference for your situation.
    In our first cross-reference example, shown in [Example 15-3](ch15s05.html#enumerating_function_calls
    "Example 15-3. Enumerating function calls"), we derive the list of all function
    calls made within a function by iterating through each instruction in the function
    to determine if the instruction calls another function. One method of doing this
    might be to parse the results of `GetMnem` to look for `call` instructions. This
    would not be a very portable solution, because the instruction used to call a
    function varies among CPU types. Second, additional parsing would be required
    to determine exactly which function was being called. Cross-references avoid each
    of these difficulties because they are CPU-independent and directly inform us
    about the target of the cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3. Enumerating function calls
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we must iterate through each instruction in the function. For
    each instruction, we must then iterate through each cross-reference from the instruction.
    We are interested only in cross-references that call other functions, so we must
    test the return value of `XrefType` looking for `fl_CN` or `fl_CF`-type cross-references.
    Here again, this particular solution handles only functions whose instructions
    happen to be contiguous. Given that the script is already iterating over the cross-references
    from each instruction, it would not take many changes to produce a flow-driven
    analysis instead of the address-driven analysis seen here.
  prefs: []
  type: TYPE_NORMAL
- en: Another use for cross-references is to determine every location that references
    a particular location. For example, if we wanted to create a low-budget security
    analyzer, we might be interested in highlighting all calls to functions such as
    `strcpy` and `sprintf`.
  prefs: []
  type: TYPE_NORMAL
- en: DANGEROUS FUNCTIONS
  prefs: []
  type: TYPE_NORMAL
- en: 'The C functions `strcpy` and `sprintf` are generally acknowledged as dangerous
    to use because they allow for unbounded copying into destination buffers. While
    each may be safely used by programmers who conduct proper checks on the size of
    source and destination buffers, such checks are all too often forgotten by programmers
    unaware of the dangers of these functions. The `strcpy` function, for example,
    is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `strcpy` function’s defined behavior is to copy all characters up to and
    including the first null termination character encountered in the source buffer
    to the given destination buffer (`dest`). The fundamental problem is that there
    is no way to determine, at runtime, the size of any array. In this instance, `strcpy`
    has no means to determine whether the capacity of the destination buffer is sufficient
    to hold all of the data to be copied from source. Such unchecked copy operations
    are a major cause of buffer overflow vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown in [Example 15-4](ch15s05.html#enumerating_a_functionas_callers
    "Example 15-4. Enumerating a function’s callers"), we work in reverse to iterate
    across all of the cross-references *to* (as opposed to *from* in the preceding
    example) a particular symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-4. Enumerating a function’s callers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `LocByName` ![](httpatomoreillycomsourcenostarchimages854061.png)
    function is used to find the address of a given (by name) bad function. If the
    function’s address is found, a loop ![](httpatomoreillycomsourcenostarchimages854063.png)
    is executed in order to process all cross-references to the bad function. For
    each cross-reference, if the cross-reference type ![](httpatomoreillycomsourcenostarchimages854093.png)
    is determined to be a call-type ![](httpatomoreillycomsourcenostarchimages854095.png)
    cross-reference, the calling function’s name is determined ![](httpatomoreillycomsourcenostarchimages854099.png)
    and is displayed to the user ![](httpatomoreillycomsourcenostarchimages854101.png).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that some modifications may be required to perform a
    proper lookup of the name of an imported function. In ELF executables in particular,
    which combine a procedure linkage table (PLT) with a global offset table (GOT)
    to handle the details of linking to shared libraries, the names that IDA assigns
    to imported functions may be less than clear. For example, a PLT entry may appear
    to be named `_memcpy`, when in fact it is named `.memcpy` and IDA has replaced
    the dot with an underscore because IDA considers dots invalid characters within
    names. Further complicating matters is the fact that IDA may actually create a
    symbol named `memcpy` that resides in a section that IDA names `extern`. When
    attempting to enumerate cross-references to `memcpy`, we are interested in the
    PLT version of the symbol because this is the version that is called from other
    functions in the program and thus the version to which all cross-references would
    refer.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Exported Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 13](ch13.html "Chapter 13. Extending IDA’s Knowledge") we discussed
    the use of `idsutils` to generate *.ids* files that describe the contents of shared
    libraries. Recall that the first step in generating a *.ids* file involves generating
    a *.idt* file, which is a text file containing descriptions of each exported function
    contained in the library. IDC contains functions for iterating through the functions
    that are exported by a shared library. The script shown in [Example 15-5](ch15s05.html#a_script_to_generate_.idt_files
    "Example 15-5. A script to generate .idt files") can be run to generate an *.idt*
    file after opening a shared library with IDA:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-5. A script to generate *.idt* files
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output of the script is saved to a file chosen by the user. New functions
    introduced in this script include `GetEntryPointQty`, which returns the number
    of symbols exported by the library; `GetEntryOrdinal`, which returns an ordinal
    number (an index into the library’s export table); `GetEntryPoint`, which returns
    the address associated with an exported function that has been identified by ordinal
    number; and `GetInputFile`, which returns the name of the file that was loaded
    into IDA.
  prefs: []
  type: TYPE_NORMAL
- en: Finding and Labeling Function Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Versions of GCC later than 3.4 use `mov` statements rather than `push` statements
    in x86 binaries to place function arguments into the stack before calling a function.
    Occasionally this causes some analysis problems for IDA (newer versions of IDA
    handle this situation better), because the analysis engine relies on finding `push`
    statements to pinpoint locations at which arguments are pushed for a function
    call. The following listing shows an IDA disassembly when parameters are pushed
    onto the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the comments that IDA has placed in the right margin. Such commenting
    is possible only when IDA recognizes that parameters are being pushed and when
    IDA knows the signature of the function being called. When `mov` statements are
    used to place parameters onto the stack, the resulting disassembly is somewhat
    less informative, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, IDA has failed to recognize that the three `mov` statements preceding
    the call are being used to set up the parameters for the function call. As a result,
    we get less assistance from IDA in the form of automatic comments in the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have a situation where a script might be able to restore some of the
    information that we are accustomed to seeing in our disassemblies. [Example 15-6](ch15s05.html#automating_parameter_recognition
    "Example 15-6. Automating parameter recognition") is a first effort at automatically
    recognizing instructions that are setting up parameters for function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-6. Automating parameter recognition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The script works only on EBP-based frames and relies on the fact that when
    parameters are moved into the stack prior to a function call, GCC generates memory
    references relative to `esp`. The script iterates through all instructions in
    a function; for each instruction that writes to a memory location using `esp`
    as a base register, the script determines the depth within the stack and adds
    a comment indicating which parameter is being moved. The `GetFunctionFlags` function
    offers access to various flags associated with a function, such as whether the
    function uses an EBP-based stack frame. Running the script in [Example 15-6](ch15s05.html#automating_parameter_recognition
    "Example 15-6. Automating parameter recognition") yields the annotated disassembly
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The comments aren’t particularly informative. However, we can now tell at a
    glance that the three `mov` statements are used to place parameters onto the stack,
    which is a step in the right direction. By extending the script a bit further
    and exploring some more of IDC’s capabilities, we can come up with a script that
    provides almost as much information as IDA does when it properly recognizes parameters.
    The output of the final product is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The extended version of the script in [Example 15-6](ch15s05.html#automating_parameter_recognition
    "Example 15-6. Automating parameter recognition"), which is capable of incorporating
    data from function signatures into comments, is available on this book’s website.^([[103](#ftn.CHP-15-FN-9)])
  prefs: []
  type: TYPE_NORMAL
- en: Emulating Assembly Language Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of reasons why you might need to write a script that emulates
    the behavior of a program you are analyzing. For example, the program you are
    studying may be self-modifying, as many malware programs are, or the program may
    contain some encoded data that gets decoded when it is needed at runtime. Without
    running the program and pulling the modified data out of the running process’s
    memory, how can you understand the behavior of the program? The answer may lie
    with an IDC script. If the decoding process is not terribly complex, you may be
    able to quickly write an IDC script that performs the same actions that are performed
    by the program when it runs. Using a script to decode data in this way eliminates
    the need to run a program when you don’t know what the program does or you don’t
    have access to a platform on which you can run the program. An example of the
    latter case might occur if you were examining a MIPS binary with your Windows
    version of IDA. Without any MIPS hardware, you would not be able to execute the
    MIPS binary and observe any data decoding it might perform. You could, however,
    write an IDC script to mimic the behavior of the binary and make the required
    changes within the IDA database, all with no need for a MIPS execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: The following x86 code was extracted from a DEFCON^([[104](#ftn.CHP-15-FN-10)])
    Capture the Flag binary.^([[105](#ftn.CHP-15-FN-11)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code decodes a private key that has been embedded within the program binary.
    Using the IDC script shown in [Example 15-7](ch15s05.html#emulating_assembly_language_with_idc
    "Example 15-7. Emulating assembly language with IDC"), we can extract the private
    key without running the program:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-7. Emulating assembly language with IDC
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15-7](ch15s05.html#emulating_assembly_language_with_idc "Example 15-7. Emulating
    assembly language with IDC") is a fairly literal translation of the preceding
    assembly language sequence generated according to the following rather mechanical
    rules.'
  prefs: []
  type: TYPE_NORMAL
- en: For each stack variable and register used in the assembly code, declare an IDC
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each assembly language statement, write an IDC statement that mimics its
    behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading and writing stack variables is emulated by reading and writing the corresponding
    variable declared in your IDC script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading from a nonstack location is accomplished using the `Byte`, `Word`, or
    `Dword` function, depending on the amount of data being read (1, 2, or 4 bytes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing to a nonstack location is accomplished using the `PatchByte`, `PatchWord`,
    or `PatchDword` function, depending on the amount of data being written.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In general, if the code appears to contain a loop for which the termination
    condition is not immediately obvious, it is easiest to begin with an infinite
    loop such as `while (1) {}` and then insert a `break` statement when you encounter
    statements that cause the loop to terminate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the assembly code calls functions, things get complicated. In order to
    properly simulate the behavior of the assembly code, you must find a way to mimic
    the behavior of the function that has been called, including providing a return
    value that makes sense within the context of the code being simulated. This fact
    alone may preclude the use of IDC as a tool for emulating the behavior of an assembly
    language sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The important thing to understand when developing scripts such as the previous
    one is that it is not absolutely necessary to fully understand how the code you
    are emulating behaves on a global scale. It is often sufficient to understand
    only one or two instructions at a time and generate correct IDC translations for
    those instructions. If each instruction has been correctly translated into IDC,
    then the script as a whole should properly mimic the complete functionality of
    the original assembly code. We can delay further study of the assembly language
    algorithm until after the IDC script has been completed, at which point we can
    use the IDC script to enhance our understanding of the underlying assembly. Once
    we spend some time considering how our example algorithm works, we might shorten
    the preceding IDC script to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative, if we did not wish to modify the database in any way, we
    could replace the `PatchByte` function with a call to `Message` if we were dealing
    with ASCII data, or as an alternative we could write the data to a file if we
    were dealing with binary data.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[103](#CHP-15-FN-9)]) See [http://www.idabook.com/ch15_examples](http://www.idabook.com/ch15_examples).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[104](#CHP-15-FN-10)]) See [http://www.defcon.org/](http://www.defcon.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[105](#CHP-15-FN-11)]) Courtesy of Kenshoto, the organizers of CTF at DEFCON
    15\. Capture the Flag is an annual hacking competition held at DEFCON.
  prefs: []
  type: TYPE_NORMAL
- en: IDAPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDAPython is a plug-in developed by Gergely Erdelyi that integrates a Python
    interpreter into IDA. Combined with supplied Python bindings, this plug-in allows
    you to write Python scripts with full access to all of the capabilities of the
    IDC scripting language. One clear advantage gained with IDAPython is access to
    Python’s native data-handling capabilities as well as the full range of Python
    modules. In addition, IDAPython exposes a significant portion of IDA’s SDK functionality,
    allowing for far more powerful scripting than is possible using IDC. IDAPython
    has developed quite a following in the IDA community. Ilfak’s blog^([[106](#ftn.CHP-15-FN-12)])
    contains numerous interesting examples of problem solving with Python scripts,
    while questions, answers, and many other useful IDAPython scripts are frequently
    posted in the forums at OpenRCE.org.^([[107](#ftn.CHP-15-FN-13)]) In addition,
    third-party tools such as BinNavi^([[108](#ftn.CHP-15-FN-14)]) from Zynamics rely
    on IDA and IDAPython in order to perform various subtasks required by the tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since IDA 5.4, Hex-Rays has been including IDAPython as a standard plug-in.
    Source code for the plug-in is available for download on the IDA-Python project
    page,^([[109](#ftn.CHP-15-FN-15)]) and API documentation is available on the Hex-Rays
    website.^([[110](#ftn.CHP-15-FN-16)]) IDA enables the plug-in only when Python
    is found to be installed on the computer on which you are running IDA. The Windows
    version of IDA ships with and installs a compatible version of Python,^([[111](#ftn.CHP-15-FN-17)])
    while the Linux and OS X versions of IDA leave proper installation of Python up
    to you. On Linux, the current version of IDA (6.1) looks for Python 2.6\. IDAPython
    is compatible with Python 2.7, and IDA will work just fine if you create symlinks
    from the required Python 2.6 libraries to your existing Python 2.7 libraries.
    If you have Python 2.7, a command similar to the following will create the symlink
    that will make IDA happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: OS X users may find that the version of Python that ships with OS X is older
    than that required by IDA. If this is the case, a suitable Python installer should
    be downloaded from [www.python.org](http://www.python.org).^([[112](#ftn.CHP-15-FN-18)])
  prefs: []
  type: TYPE_NORMAL
- en: Using IDAPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDAPython bridges Python code into IDA by making available three Python modules,
    each serving a specific purpose. Access to the core IDA API (as exposed via the
    SDK) is made available with the `idaapi` module. All of the functions present
    in IDC are made available in IDAPython’s `idc` module. The third module that ships
    with IDAPython is `idautils`, which provides a number of utility functions, many
    of which yield Python lists of various database-related objects such as functions
    or cross-references. Modules `idc` and `idautils` are automatically imported for
    all IDAPython scripts. If you need `idaapi`, on the other hand, you must import
    it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: When using IDAPython, keep in mind that the plug-in embeds a single instance
    of the Python interpreter into IDA. This interpreter is not destroyed until you
    close IDA. As a result, you can view all of your scripts and statements as if
    they are running within a single Python shell session. For example, once you have
    imported the `idaapi` module for the first time in your IDA session, you need
    never import it again until you restart IDA. Similarly, initialized variables
    and function definitions retain their values until they are redefined or until
    you quit IDA.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of strategies for learning IDA’s Python API. If you already
    have some experience using IDC or programming with the IDA SDK, then you should
    feel right at home with the `idaapi` and `idc` modules. A quick review of the
    additional features in the `idautils` module should be all you really need to
    start making full use of IDAPython. If you have prior experience with IDC or the
    SDK, then you might dive into the Hex-Ray’s documentation for the Python API to
    develop a feel for the capabilities it offers. Remember that the `idc` module
    basically mirrors the IDC API and that you may find the list of IDC functions
    in IDA’s built-in help to be quite useful. Similarly, the descriptions of IDC
    functions presented earlier in this chapter are equally applicable to the corresponding
    functions in the `idc` module.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[106](#CHP-15-FN-12)]) See [http://www.hexblog.com](http://www.hexblog.com).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[107](#CHP-15-FN-13)]) See [http://www.openrce.org/articles/](http://www.openrce.org/articles/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[108](#CHP-15-FN-14)]) See [http://www.zynamics.com/binnavi.html](http://www.zynamics.com/binnavi.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[109](#CHP-15-FN-15)]) See [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[110](#CHP-15-FN-16)]) See [http://www.hex-rays.com/idapro/idapython_docs/index.html](http://www.hex-rays.com/idapro/idapython_docs/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[111](#CHP-15-FN-17)]) See [http://www.python.org/](http://www.python.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[112](#CHP-15-FN-18)]) See [http://www.python.org/download/mac/](http://www.python.org/download/mac/)
  prefs: []
  type: TYPE_NORMAL
- en: IDAPython Scripting Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By way of offering a compare and contrast between IDC and IDAPython, the following
    sections present the same example cases seen previously in the discussion of IDC.
    Wherever possible we endeavor to make maximum use of Python-specific features
    to demonstrate some of the efficiencies that can be gained by scripting in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the strengths of IDAPython is the way that it uses Python’s powerful
    datatypes to simplify access to collections of database objects. In [Example 15-8](ch15s07.html#function_enumeration_using_python
    "Example 15-8. Function enumeration using Python"), we reimplement the function
    enumeration script of [Example 15-1](ch15s05.html#function_enumeration_script
    "Example 15-1. Function enumeration script") in Python. Recall that the purpose
    of this script is to iterate over every function in a database and print basic
    information about each function, including the start and end addresses of the
    function, the size of the function’s arguments, and the size of the function’s
    local variable space. All output is sent to the output window.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-8. Function enumeration using Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For this particular script, the use of Python gains us little in the way of
    efficiency other than the use of the `Functions` ![](httpatomoreillycomsourcenostarchimages854061.png)
    list generator, which facilitates the `for` loop at ![](httpatomoreillycomsourcenostarchimages854063.png).
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 15-9](ch15s07.html#instruction_enumeration_in_python "Example 15-9. Instruction
    enumeration in Python") demonstrates how the instruction-counting script of [Example 15-2](ch15s05.html#instruction_enumeration_script
    "Example 15-2. Instruction enumeration script") might be written in Python, taking
    advantage of the list generators available in the `idautils` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-9. Instruction enumeration in Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Differences from the IDC version include the use of an SDK function ![](httpatomoreillycomsourcenostarchimages854061.png)
    (accessed via `idaapi`) to retrieve a reference to a function object (specifically
    a `func_t`) and the use of the `FuncItems` generator ![](httpatomoreillycomsourcenostarchimages854063.png)
    (from `idautils`) to provide easy iteration over all of the instructions within
    the function. Because we can’t use Python’s `len` function on a generator, we
    are still obligated to step through the generator list in order to count each
    instruction one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Cross-References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `idautils` module contains several generator functions that build cross-reference
    lists in a somewhat more intuitive way than we saw in IDC. [Example 15-10](ch15s07.html#enumerating_function_calls_using_python
    "Example 15-10. Enumerating function calls using Python") rewrites the function
    call enumeration script that we saw previously in [Example 15-3](ch15s05.html#enumerating_function_calls
    "Example 15-3. Enumerating function calls").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-10. Enumerating function calls using Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: New in this script is the use of the `XrefsFrom` generator ![](httpatomoreillycomsourcenostarchimages854061.png)
    (from `idautils`) to step through all cross-references from the current instruction.
    `XrefsFrom` returns a reference to an `xrefblk_t` object that contains detailed
    information about the current cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Exported Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 15-11](ch15s07.html#a_python_script_to_generate_idt_files "Example 15-11. A
    Python script to generate IDT files") is the Python version of the *.idt* generator
    script from [Example 15-5](ch15s05.html#a_script_to_generate_.idt_files "Example 15-5. A
    script to generate .idt files").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-11. A Python script to generate IDT files
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The two scripts look remarkably similar because IDAPython has no generator function
    for entry-point lists, so we are left to use the same set of functions that were
    used in [Example 15-5](ch15s05.html#a_script_to_generate_.idt_files "Example 15-5. A
    script to generate .idt files"). One difference worth noting is that IDAPython
    deprecates IDC’s file-handling functions in favor of Python’s built-in file-handling
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting provides a powerful means for extending IDA’s capabilities. Through
    the years, scripts have been used in a number of innovative ways to fill the needs
    of IDA users. Many useful scripts are available for download on the Hex-Rays website
    as well as the mirror site of the former IDA Palace.^([[113](#ftn.CHP-15-FN-19)])
    IDA scripts are perfect for small tasks and rapid development, but they are not
    ideally suited for all situations.
  prefs: []
  type: TYPE_NORMAL
- en: One of the principal limitations of the IDC language is its lack of support
    for complex datatypes and the lack of access to a more fully featured API such
    as the C standard library or the Windows API. At the expense of greater complexity,
    we can lift these limitations by moving away from scripted extensions and toward
    compiled extensions. As we will show in the next chapter, compiled extensions
    require the use of the IDA software development kit (SDK), which has a steeper
    learning curve than either IDC or IDAPython. However, the power available when
    developing extensions with the SDK is usually well worth the effort spent learning
    how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[113](#CHP-15-FN-19)]) See [http://old.idapalace.net/](http://old.idapalace.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16. The IDA Software Development Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the course of the book, we have used phrases like “IDA does this,”
    and “IDA does that.” While IDA certainly does an awful lot for us, the intelligence
    is more correctly attributed to the various modules upon which IDA relies. For
    example, it is the processor module that makes all of the decisions during the
    analysis phase, so one could argue that IDA is only as smart as the processor
    modules on which it relies. Of course, Hex-Rays puts tremendous effort into ensuring
    that its processor modules are as capable as possible, and for the casual user,
    IDA neatly hides its modular architecture beneath its user interface.
  prefs: []
  type: TYPE_NORMAL
- en: At some point you may find yourself needing more power than the IDC scripting
    language has to offer, whether for performance reasons or because you wish to
    do things that IDC simply was not designed to do. When that moment arrives, it
    is time to advance to using IDA’s *software development kit (SDK)* to build your
    own compiled modules for use with IDA.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IDC scripting engine is built on top of IDA’s SDK. All IDC functions are
    ultimately translated to calls to one or more SDK functions that perform the actual
    work. While it is true that if you can do something in IDC, you can do the same
    thing using the SDK, the reverse does not hold. The SDK offers far more power
    than is available using IDC alone, and many SDK actions have no IDC counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK exposes IDA’s internal programming interfaces in the form of C++ libraries
    and the header files required to interface to those libraries. The SDK is required
    in order to create loader modules to handle new file formats, processor modules
    to disassemble new CPU instruction sets, and plug-in modules that might be viewed
    as more powerful, compiled alternatives to scripts.
  prefs: []
  type: TYPE_NORMAL
- en: BELLS, WHISTLES, AND BULLETS TO THE FOOT
  prefs: []
  type: TYPE_NORMAL
- en: While working with C++, you will of course have access to a wide variety of
    C++ libraries, including your operating system’s native APIs. By utilizing such
    libraries, you may be tempted to incorporate a wide variety of sophisticated features
    into any modules that you build. However, you should be very careful what functionality
    you choose to incorporate in this way, as it may lead to instability in IDA. The
    most concrete example of this is the fact that IDA is a single-threaded application.
    No effort whatsoever is made to synchronize access to low-level database structures,
    nor does the SDK provide facilities for doing so. For IDA versions earlier than
    5.5, you should never create additional threads that may simultaneously access
    the database. For versions 5.5 and later, you may create additional threads, but
    any calls to SDK functions should be queued using the `exec_request_t and execute_sync`
    function described in *kernwin.hpp*. Also, you should understand that any blocking^([[114](#ftn.CHP-16-FN-1)])
    operations you perform will render IDA unresponsive until the operation completes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we introduce some of the core capabilities of the SDK. You will
    find these capabilities useful whether you are creating plug-ins, loader modules,
    or processor modules. As each of these types of modules is covered individually
    in the following three chapters, the examples in this chapter are offered without
    attempting to supply a specific context in which they might be used.
  prefs: []
  type: TYPE_NORMAL
- en: SDK Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA’s SDK is distributed in much the same manner as the other IDA extras that
    we have discussed so far. The Zip file containing the SDK can be found on your
    original IDA CD, or authorized users can download the SDK from the Hex-Rays website.
    Each version of the SDK is named for the version of IDA with which it is compatible
    (for example, *idasdk61.zip* goes with IDA version 6.1). The SDK features the
    same minimalist documentation typically found in other IDA-related tools, which
    in the case of the SDK means a top-level *readme.txt* file and additional README
    files for plug-ins, processor modules, and loaders.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK defines the published programming interface that modules may use to
    interact with IDA. Prior to SDK version 4.9, it was not uncommon for these interfaces
    to change enough that a module that successfully compiled under SDK 4.8 might
    no longer compile under a newer SDK, such as version 4.9, without the need for
    changes. With the introduction of version 4.9 of the SDK, Hex-Rays chose to standardize
    the existing API, which means that not only would modules require no changes to
    compile successfully with newer versions of the SDK, but modules would also be
    binary compatible with newer versions of IDA. This means that module users need
    no longer wait for module authors to update their source code or make available
    updated binary versions of their modules each time a new version of IDA is released.
    It does not mean that existing API interfaces are completely frozen; Hex-Rays
    continues to introduce new features with each new version of the SDK (that is,
    each new SDK is a superset of its predecessor). Modules that make use of these
    newer features are typically not compatible with older versions of IDA or the
    SDK. That said, there have been occasions where, for various reasons, functions
    have been renamed or marked as obsolete. The SDK offers macros to allow or disallow
    the use of deprecated functions, making it easy to note when a function has been
    deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: SDK Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to version 5.4, the Zip file containing the SDK does not contain a top-level
    directory. Because the SDK shares several subdirectory names with IDA, it is highly
    recommended that you create a dedicated SDK directory, such as idasdk53, and extract
    the SDK contents into that directory. This will make it much easier to distinguish
    SDK components from IDA components. Beginning with version 5.4, the IDA SDK is
    packaged within a top-level SDK directory, such as idasdk61, so this step is no
    longer needed. There is no requirement to install the SDK in a specific location
    relative to *<IDADIR>*. Regardless of where you choose to install your SDK, we
    will refer to the SDK directory generically as *<SDKDIR>* for the remainder of
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: SDK Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A basic understanding of the directory structure used within the SDK will be
    helpful, both in knowing where you might find documentation and in knowing where
    you can expect to find the modules that you build. A quick rundown of what you
    can expect to find in the SDK follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**bin directory**'
  prefs: []
  type: TYPE_NORMAL
- en: This directory is where the example build scripts save their compiled modules
    following a successful build. Installing a module involves copying the module
    from the appropriate subdirectory within *bin* to the appropriate subdirectory
    in *<IDADIR>*. Module installation will be covered in more detail in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture"), [Chapter 18](ch18.html "Chapter 18. Binary
    Files and IDA Loader Modules"), and [Chapter 19](ch19.html "Chapter 19. IDA Processor
    Modules"). This directory also contains a postprocessing tool required for the
    creation of processor modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**etc directory**'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains source code for two utilities that are required to build
    some SDK modules. Compiled versions of these utilities are also included with
    the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '**include directory**'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains the header files that define the interface to the IDA
    API. In short, every API data structure that you are allowed to use and every
    API function that you are allowed to call are declared in one of the header files
    in this directory. The SDK’s top-level *readme.txt* file contains an overview
    of some of the more commonly used header files in this directory. The files in
    this directory constitute the bulk of the documentation (as in “read the source”)
    for the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '**ldr directory**'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains the source code and build scripts for several example
    loader modules. The README file for loaders is nothing more than a rundown of
    the contents of this directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**lib directory**'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains a number of subdirectories, which in turn contain the
    link libraries required to build various IDA modules. The subdirectories are named
    after the compiler with which they should be used. For example, `x86_win_vc_32`
    (6.1 and later) or `vc.w32` (6.0 and earlier) contains the library to use with
    Visual Studio and 32-bit IDA on Windows, while `x64_mac_gcc_64` (6.1 and later)
    or `gcc64.mac64` (6.0 and earlier) contains the library for use with 64-bit IDA
    on OSX platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '**module directory**'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains the source code and build scripts for several example
    processor modules. The README file for processor modules is nothing more than
    a rundown of the contents of this directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**plug-ins directory**'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains the source code and build scripts for several example
    plug-in modules. The README file for plug-ins provides a high-level overview of
    the plug-in architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '**top-level directory**'
  prefs: []
  type: TYPE_NORMAL
- en: The top level of the SDK contains several make files used for building modules
    as well as the main *readme.txt* file for the SDK. Several additional *install_xxx.txt*
    files contain information regarding installation and configuration for various
    compilers (for example, *install_visual.txt* discusses Visual Studio configuration).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that documentation on using the SDK is sparse. For most developers,
    knowledge of the SDK has been derived through trial and error and extensive exploration
    of the contents of the SDK. You may have some luck posting questions to the *Research
    & Resources* forum on the Hex-Rays support forums, where other IDA users familiar
    with the SDK may answer them. An excellent third-party resource providing an introduction
    to the SDK and plug-in writing is Steve Micallef’s guide titled *IDA Plug-in Writing
    in C/C++*.^([[115](#ftn.CHP-16-FN-2)])
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Build Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the more frustrating aspects of using the SDK is not related to programming
    at all. Instead, you may find that it is relatively easy to code up a solution
    to a problem only to find that it is virtually impossible to successfully build
    your module. This is true because it can be difficult to support a wide variety
    of compilers with a single code base, and coding a solution is complicated by
    the fact that library file formats recognized by Windows compilers are often incompatible
    with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the examples included with the SDK were created to be built using Borland
    tools. From *install_make.txt* we have the following quote from Ilfak:'
  prefs: []
  type: TYPE_NORMAL
- en: WIN32 versions can be created only by Borland C++ CBuilder v4.0\. Probably the
    old BCC v5.2 will work too, but I haven’t checked it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That being said, other *install_xxx* files offer pointers on how to successfully
    build modules with other compilers. A few of the example modules contain files
    for building with Visual Studio (*<SDKDIR>/plugins/vcsample*, for example), while
    *install_visual.txt* offers a series of steps for properly configuring SDK projects
    using Visual C++ Express 2005.
  prefs: []
  type: TYPE_NORMAL
- en: In order to build modules using Unix-style tools, either on a Unix-style system
    such as Linux or using an environment such as MinGW, the SDK provides a script
    named *idamake.pl* that converts the Borland-style make files into Unix-style
    make files prior to initiating the build process. This process is discussed in
    *install_linux.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The command-line build scripts provided with the SDK expect an environment variable
    named IDA to point to *<SDKDIR>* . You can set this globally for all scripts by
    editing *<SDKDIR>/allmake.mak* and *<SDKDIR>/allmake.unx* to set this variable
    or by adding an IDA environment variable to your global environment.
  prefs: []
  type: TYPE_NORMAL
- en: Steve Micallef’s guide also provides excellent instructions for configuring
    build environments for building plug-ins with various compilers. Our personal
    preference when building SDK modules for Windows versions of IDA is to use the
    MinGW tools gcc and make. The examples presented in [Chapter 17](ch17.html "Chapter 17. The
    IDA Plug-in Architecture"), [Chapter 18](ch18.html "Chapter 18. Binary Files and
    IDA Loader Modules"), and [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules")
    include makefiles and Visual Studio project files that do not rely on any of the
    build scripts included with the SDK and that are easy to modify to suit the needs
    of your projects. Module-specific build configuration will also be discussed in
    each of these chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[114](#CHP-16-FN-1)]) A blocking operation is an action that causes a program
    to come to a halt while it awaits completion of the action.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[115](#CHP-16-FN-2)]) See [http://www.binarypool.com/idapluginwriting/](http://www.binarypool.com/idapluginwriting/).
  prefs: []
  type: TYPE_NORMAL
- en: The IDA Application Programming Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA’s API is defined by the contents of the header files in *<SDKDIR>/include*.
    There is no single-source index of available functions (though Steve Micallef
    has collected a rather nice subset in his plug-in writing guide). Many prospective
    SDK programmers find this fact initially difficult to come to terms with. The
    reality is that there is never an easy-to-find answer to the question, “How do
    I do *x* using the SDK?” The two principal options for answering such questions
    are to post the questions to an IDA user’s forum or attempt to answer them yourself
    by searching through the API documentation. What documentation, you say? Why,
    the header files, of course. Granted, these are not the most searchable of documents,
    but they do contain the complete set of API features. In this case, `grep` (or
    a suitable replacement, preferably built into your programming editor) is your
    friend. The catch is knowing what to search for, which is not always obvious.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to try to narrow your searches through the API. The first
    way is to leverage your knowledge of the IDC scripting language and attempt to
    locate similar functionality within the SDK using keywords and possibly function
    names derived from IDC. However—and this is an extremely frustrating point—while
    the SDK may contain functions that perform tasks identical to those of IDC functions,
    the names of those functions are seldom identical. This results in programmers
    learning two sets of API calls, one for use with IDC and one for use with the
    SDK. In order to address this situation, [Appendix B](apb.html "Appendix B. IDC/SDK
    Cross-Reference") presents a complete list of IDC functions and the corresponding
    SDK 6.1 actions that are carried out to execute those functions.
  prefs: []
  type: TYPE_NORMAL
- en: The second technique for narrowing down SDK-related searches is to become familiar
    with the content and, more important, the purpose of the various SDK header files.
    In general, related functions and associated data structures are grouped into
    headers files based on functional groups. For example, SDK functions that allow
    interaction with a user are grouped into *kernwin.hpp*. When a `grep`-style search
    fails to locate a capability that you require, some knowledge of which header
    file relates to that capability will narrow your search and hopefully limit the
    number of files that you need to dig deeper into.
  prefs: []
  type: TYPE_NORMAL
- en: Header Files Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the SDK’s *readme.txt* files provide a high-level overview of the most
    commonly used header files, this section highlights some other useful information
    for working with these files. First, the majority of the header files use the
    *.hpp* suffix, while a few use the *.h* suffix. This can easily lead to trivial
    errors when naming header files to be included in your files. Second, *ida.hpp*
    is the main header file for the SDK and should be included in all SDK-related
    projects. Third, the SDK utilizes preprocessor directives designed to preclude
    access to functions that Hex-Rays considers dangerous (such as `strcpy` and `sprintf`).
    For a complete list of these functions refer to the `USE_DANGEROUS_FUNCTIONS`
    macro prior to including *ida.hpp* in your own files. An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Failure to define `USE_DANGEROUS_FUNCTIONS` will result in a build error to
    the effect that `dont_use_snprintf` is an undefined symbol (in the case of an
    attempt to use the `snprintf` function). In order to compensate for restricting
    access to these so-called dangerous functions, the SDK defines safer equivalents
    for each, generally in the form of a `qstr`*`XXXX`* function such as `qstrncpy`
    and `qsnprintf`. These safer versions are also declared in *pro.h*.
  prefs: []
  type: TYPE_NORMAL
- en: Along similar lines, the SDK restricts access to many standard file input/output
    variables and functions such as `stdin`, `stdout`, `fopen`, `fwrite`, and `fprintf`.
    This restriction is due in part to limitations of the Borland compiler. Here again
    the SDK defines replacement functions in the form of `q`*`XXX`* counterparts such
    as `qfopen` and `qfprintf`. If you require access to the standard file functions,
    then you must define the `USE_STANDARD_FILE_FUNCTIONS` macro prior to including
    *fpro.h* (which is included from *kernwin.hpp*, which is, in turn, included from
    several other files).
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, each SDK header file contains a brief description of the file’s
    purpose and fairly extensive comments describing the data structures and functions
    that are declared in the file. Together these comments constitute IDA’s API documentation.
    Brief descriptions of some of the more commonly used SDK header files follow.
  prefs: []
  type: TYPE_NORMAL
- en: '**area.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file defines the `area_t` struct, which represents a contiguous block of
    addresses within a database. This struct serves as the base class for several
    other classes that build on the concept of an address range. It is seldom necessary
    to include this file directly, as it is typically included in files defining subclasses
    of `area_t`.
  prefs: []
  type: TYPE_NORMAL
- en: '**auto.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions used to work with IDA’s autoanalyzer. The autoanalyzer
    performs queued analysis tasks when IDA is not busy processing userinput events.
  prefs: []
  type: TYPE_NORMAL
- en: '**bytes.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions for working with individual database bytes. Functions
    declared in this file are used to read and write individual database bytes as
    well as manipulate the characteristics of those bytes. Miscellaneous functions
    also provide access to flags associated with instruction operands, while other
    functions allow manipulation of regular and repeatable comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**dbg.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions offering programmatic control of IDA’s debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**entry.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This header declares functions for working with a file’s entry points. For shared
    libraries, each exported function or data value is considered an entry point.
  prefs: []
  type: TYPE_NORMAL
- en: '**expr.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions and data structures for working with IDC constructs.
    It is possible to modify existing IDC functions, add new IDC functions, or execute
    IDC statements from within modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**fpro.h**'
  prefs: []
  type: TYPE_NORMAL
- en: This file contains the alternative file I/O functions, such as `qfopen`, discussed
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: '**frame.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This header contains functions used to manipulate stack frames.
  prefs: []
  type: TYPE_NORMAL
- en: '**funcs.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This header contains functions and data structures for working with disassembled
    functions as well as functions for working with FLIRT signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**gdl.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares support routines for generating graphs using either DOT or
    GDL.
  prefs: []
  type: TYPE_NORMAL
- en: '**ida.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the main header file required for working with the SDK. This file contains
    the definition of the `idainfo` structure as well as the declaration of the global
    variable `inf`, which contains a number of fields containing information about
    the current database as well as fields initialized from configuration file settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**idp.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file contains declarations of structures that form the foundation of processor
    modules. The global variable `ph`, which describes the current processor module,
    and the global variable `ash`, which describes the current assembler, are defined
    in this file.
  prefs: []
  type: TYPE_NORMAL
- en: '**kernwin.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions for interacting with the user and the user interface.
    The SDK equivalents of IDC’s `Ask`*`XXX`* functions are declared here, as are
    functions used to set the display position and configure hotkey associations.
  prefs: []
  type: TYPE_NORMAL
- en: '**lines.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions for generating formatted, colorized disassembly
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: '**loader.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file contains the declarations for the `loader_t` and `plugin_t` structures
    required for the creation of loader modules and plug-in modules, respectively,
    as well as functions useful during the file-loading phase and functions for activating
    plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: '**name.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions for manipulating named locations (as opposed to
    names within structures or stack frames, which are covered in *stuct.hpp* and
    *funcs.hpp*, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '**netnode.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: Netnodes are the lowest-level storage structure accessible via the API. The
    details of netnodes are typically hidden by the IDA user interface. This file
    contains the definition of the `netnode` class and functions for low-level manipulation
    of netnodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**pro.h**'
  prefs: []
  type: TYPE_NORMAL
- en: This file includes the top-level typedefs and macros required in any SDK module.
    You do not need to explicitly include this file in your projects, as it is included
    from *ida.hpp*. Among other things, the `IDA_SDK_VERSION` macro is defined in
    this file. `IDA_SDK_VERSION` provides a means to determine with which version
    of the SDK a module is being built, and it can be tested to provide conditional
    compilation when using different versions of the SDK. Note that `IDA_SDK_VERSION`
    was introduced with SDK version 5.2\. Prior to SDK 5.2, there is no official way
    to determine which SDK is being used. An unofficial header file that defines `IDA_SDK_VERSION`
    for older versions of the SDK (*sdk_versions.h*) is available on this book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '**search.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions for performing different types of searches on a
    database.
  prefs: []
  type: TYPE_NORMAL
- en: '**segment.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file contains the declaration of the `segment_t` class, a subclass of `area_t`,
    which is used to describe individual sections (`.text`, `.data`, etc.) within
    a binary. Functions for working with segments are also declared here.
  prefs: []
  type: TYPE_NORMAL
- en: '**struct.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file contains the declaration of the `struc_t` class and functions for
    manipulating structures within a database.
  prefs: []
  type: TYPE_NORMAL
- en: '**typeinf.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares functions for working with IDA type libraries. Among other
    things, functions declared here offer access to function signatures, including
    function return types and parameter sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '**ua.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares the `op_t` and `insn_t` classes used extensively in processor
    modules. Also declared here are functions used for disassembling individual instructions
    and for generating the text for various portions of each disassembled line.
  prefs: []
  type: TYPE_NORMAL
- en: '**xref.hpp**'
  prefs: []
  type: TYPE_NORMAL
- en: This file declares the datatypes and functions required for adding, deleting,
    and iterating code and data cross-references.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding list describes approximately half of the header files that ship
    with the SDK. You are encouraged to familiarize yourself not only with the files
    in this list but also with all of the other header files as well, as you dig deeper
    into the SDK. Functions that make up the published API are marked as `ida_export`.
    Only functions designated as `ida_export` are exported in the link libraries that
    ship with the SDK. Don’t be misled by the use of `idaapi`, as it merely signifies
    that a function is to use the `stdcall` calling convention on Windows platforms
    only. You may occasionally run across interesting-looking functions that are not
    designated as `ida_export`; you cannot use these functions in your modules.
  prefs: []
  type: TYPE_NORMAL
- en: Netnodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much of IDA’s API is built around C++ classes that model various aspects of
    a disassembled binary. The `netnode` class, on the other hand, seems wrapped in
    mystery because it appears to have no direct relationship to constructs within
    binary files (sections, functions, instructions, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Netnodes are the lowest-level and most-general-purpose data storage mechanism
    accessible within an IDA database. As a module programmer, you will seldom be
    required to work directly with netnodes. Many of the higher-level data structures
    hide the fact that they ultimately rely on netnodes for persistent storage within
    a database. Some of the ways that netnodes are used within a database are detailed
    in the file *nalt.hpp*, in which we learn, for example, that information about
    the shared libraries and functions that a binary imports is stored in a netnode
    named `import_node` (yes, netnodes may have names). Netnodes are also the persistent
    storage mechanisms that facilitate IDC’s global arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Netnodes are described in extensive detail in the file *netnode.hpp*. But from
    a high-level perspective, netnodes are storage structures used internally by IDA
    for a variety of purposes. However, their precise structure is kept hidden, even
    to SDK programmers. To provide an interface to these storage structures, the SDK
    defines a `netnode` class, which functions as an opaque wrapper around this internal
    storage structure. The `netnode` class contains a single data member called `netnodenumber`,
    which is an integer identifier used to access the internal representation of a
    netnode. Every netnode is uniquely identified by its `netnodenumber`. On 32-bit
    systems the `netnodenumber` is a 32-bit quantity, allowing for 2^(32) unique netnodes.
    On 64-bit systems, a `netnodenumber` is a 64-bit integer, which allows for 2^(64)
    unique netnodes. In most cases, the `netnodenumber` represents a virtual address
    within the database, which creates a natural mapping between each address within
    a database and any net-node that might be required to store information associated
    with that address. Comment text is an example of arbitrary information that may
    be associated with an address and thus stored within a netnode associated with
    that address.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended way to manipulate netnodes is by invoking member functions of
    the `netnode` class using an instantiated `netnode` object. Reading through *netnode.hpp*,
    you will notice that a number of nonmember functions exist that seem to support
    netnode manipulation. Use of these functions is discouraged in favor of member
    functions. You will note, however, that most of the member functions in the `netnode`
    class are thin wrappers around one of the nonmember functions.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, netnodes can be used to store several different types of information.
    Each netnode may be associated with a name of up to 512 characters and a primary
    value of up to 1,024 bytes. Member functions of the `netnode` class are provided
    to retrieve (`name`) or modify (`rename`) a netnode’s name. Additional member
    functions allow you to treat a netnode’s primary value as an integer (`set_long`,
    `long_value`), a string (`set`, `valstr`), or an arbitrary binary blob^([[116](#ftn.CHP-16-FN-3)])
    (`set`, `valobj`). The function used inherently determines how the primary value
    is treated.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where things get a little complicated. In addition to a name and a primary
    value, every `netnode` is also capable of storing 256 sparse arrays in which the
    array elements can be arbitrarily sized with values up to a maximum of 1,024 bytes
    each. These arrays fall into three overlapping categories. The first category
    of arrays is indexed using 32-bit index values and can potentially hold in excess
    of 4 billion items. The second category of arrays is indexed using 8-bit index
    values and can thus hold up to 256 items. The last category of arrays is actually
    hash tables that use strings for keys. Regardless of which of the three categories
    is used, each element of the array will accept values up to 1,024 bytes in size.
    In short, a netnode can hold a tremendous amount of data—now we just need to learn
    how to make it all happen.
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering where all of this information gets stored, you are not
    alone. All netnode content is stored within btree nodes in an IDA database. Btree
    nodes in turn are stored in an ID0 file, which in turn is archived into an IDB
    file when you close your database. Any netnode content that you create will not
    be visible in any of IDA’s display windows; the data is yours to manipulate as
    you please. This is why netnodes are an ideal place for persistent storage for
    any plug-ins and scripts that you may wish to use to store results from one invocation
    to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Netnodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A potentially confusing point about netnodes is that declaring a `netnode`
    variable within one of your modules does not necessarily create an internal representation
    of that netnode within the database. A netnode is not created internally until
    one of the following events takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: The netnode is assigned a name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The netnode is assigned a primary value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value is stored into one of the netnode’s internal arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are three constructors available for declaring netnodes within your modules.
    The prototypes for each, extracted from *netnode.hpp*, and examples of their use
    are shown in [Example 16-1](ch16s02.html#declaring_netnodes "Example 16-1. Declaring
    netnodes").
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-1. Declaring netnodes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, only one netnode (`n3`) is guaranteed to exist within the
    database after the code has executed. Netnodes `n1` and `n2` may exist if they
    had been previously created and populated with data. Whether it previously existed
    or not, `n1` is capable of receiving new data at this point. If `n2` did not exist,
    meaning that no netnode named `$ node 2` could be found in the database, then
    `n2` must be explicitly created (![](httpatomoreillycomsourcenostarchimages854095.png)
    or ![](httpatomoreillycomsourcenostarchimages854099.png)) before data can be stored
    into it. If we want to guarantee that we can store data into `n2`, we need to
    add the following safety check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example demonstrates the use of the `nodeidx_t` operator, which
    allows a netnode to be cast to a `nodeidx_t`. The `nodeidx_t` operator simply
    returns the `netnodenumber` data member of the associated netnode and allows `netnode`
    variables to be easily converted into integers.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to understand about netnodes is that a netnode *must* have
    a valid `netnodenumber` before you can store data into the netnode. A `netnodenumber`
    may be explicitly assigned, as with `n1` via a constructor shown at ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the previous example. Alternatively, a `netnodenumber` may be internally generated
    when a netnode is created using the `create` flag in a constructor (as with `n3`
    via a constructor shown in ![](httpatomoreillycomsourcenostarchimages854093.png))
    or via the `create` function (as with `n2`). Internally assigned `netnodenumbers`
    begin with `0xFF000000` and increment with each newly created netnode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have thus far neglected netnode `n0` in our example. As things currently
    stand, `n0` has neither a number nor a name. We could create `n0` by name using
    the `create` function in a manner similar to `n2`. Or we could use the alternate
    form of `create` to create an unnamed netnode with a valid, internally generated
    `netnodenumber`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point it is possible to store data into `n0`, though we have no way
    to retrieve that data in the future unless we record the assigned `netnodenumber`
    somewhere or assign `n0` a name. This demonstrates the fact that netnodes are
    easy to access when they are associated with a virtual address (similar to `n1`
    in our example). For all other netnodes, assigning a name makes it possible to
    perform a named lookup for all future references to the netnode (as with `n2`
    and `n3` in our example).
  prefs: []
  type: TYPE_NORMAL
- en: Note that for our named netnodes, we have chosen to use names prefixed with
    “`$` ”, which is in keeping with the practice, recommended in *netnode.hpp*, for
    avoiding conflicts with names IDA uses internally.
  prefs: []
  type: TYPE_NORMAL
- en: Data Storage in Netnodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you understand how to create a netnode that you can store data into,
    let’s return to the discussion of the internal array storage capability of net-nodes.
    To store a value into an array within a netnode, we need to specify five pieces
    of information: an index value, an index size (8 or 32 bits), a value to store,
    the number of bytes the value contains, and an array (one of 256 available for
    each category of array) in which to store the value. The index size parameter
    is specified implicitly by the function that we use to store or retrieve the data.
    The remaining values are passed into that function as parameters. The parameter
    that selects which of the 256 possible arrays a value is stored in is usually
    called a *tag*, and it is often specified (though it need not be) using a character.
    The netnode documentation distinguishes among a few special types of values termed
    *altvals*, *supvals*, and *hashvals*. By default, each of these values is typically
    associated with a specific array tag: `''A''` for altvals, `''S''` for supvals,
    and `''H''` for hashvals. A fourth type of value, called a *charval*, is not associated
    with any specific array tag.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that these value types are associated more with
    a specific way of storing data into a netnode than with a specific array within
    a netnode. It is possible to store any type of value in any array simply by specifying
    an alternate array tag when storing data. In all cases, it is up to you to remember
    what type of data you stored into a particular array location so that you can
    use retrieval methods appropriate to the type of the stored data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Altvals* provide a simple interface for storing and retrieving integer data
    in netnodes. Altvals may be stored into any array within a netnode but default
    to the `''A''` array. Regardless of which array you wish to store integers into,
    using the altval-related functions greatly simplifies matters. The code in [Example 16-2](ch16s02.html#accessing_netnode_altvals
    "Example 16-2. Accessing netnode altvals") demonstrates data storage and retrieval
    using altvals.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-2. Accessing netnode altvals
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you see a pattern that will be repeated for other types of
    netnode values, namely, the use of an *`XXX`*`set` function (in this case, `altset`)
    to store a value into a netnode and an *`XXX`*`val` function (in this case, `altval`)
    to retrieve a value from a netnode. If we want to store integers into arrays using
    8-bit index values, we need to use slightly different functions, as shown in the
    next example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here you see that the general rule of thumb for the use of 8-bit index values
    is to use a function with an `_idx8` suffix. Also note that none of the `_idx8`
    functions provide default values for the array tag parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Supvals* represent the most versatile means of storing and retrieving data
    in netnodes. Supvals represent data of arbitrary size, from 1 byte to a maximum
    of 1,024 bytes. When using 32-bit index values, the default array for storing
    and retrieving supvals is the `''S''` array. Again, however, supvals can be stored
    into any of the 256 available arrays by specifying an appropriate array tag value.
    Strings are a common form of arbitrary length data and as such are afforded special
    handling in supval manipulation functions. The code in [Example 16-3](ch16s02.html#storing_netnode_supvals
    "Example 16-3. Storing netnode supvals") provides examples of storing supvals
    into a netnode.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-3. Storing netnode supvals
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `supset` function requires an array index, a pointer to some data, the length
    of the data (in bytes), and an array tag that defaults to `'S'` if omitted. If
    the length parameter is omitted, it defaults to zero. When the length is specified
    as zero, `supset` assumes that the data being stored is a string, computes the
    length of the data as `strlen`(data) + 1, and stores a null termination character
    along with the string data.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from a supval takes a little care, as you may not know the amount
    of data contained within the supval before you attempt to retrieve it. When you
    retrieve data from a supval, bytes are copied out of the netnode into a user-supplied
    output buffer. How do you ensure that your output buffer is of sufficient size
    to receive the supval data? The first method is to retrieve all supval data into
    a buffer that is at least 1,024 bytes. The second method is to preset the size
    of your output buffers by querying the size of the supval. Two functions are available
    for retrieving supvals. The `supval` function is used to retrieve arbitrary data,
    while the `supstr` function is specialized for retrieving string data. Each of
    these functions expects a pointer to your output buffer along with the size of
    the buffer. The return value for `supval` is the number of bytes copied into the
    output buffer, while the return value for `supstr` is the length of the string
    copied to the output buffer not including the null terminator, even though the
    null terminator is copied to the buffer. Each of these functions recognizes the
    special case in which a `NULL` pointer is supplied in place of an output buffer
    pointer. In such cases, `supval` and `supstr` return the number of bytes of storage
    (including any null terminator) required to hold the supval data. [Example 16-4](ch16s02.html#retrieving_netnode_supvals
    "Example 16-4. Retrieving netnode supvals") demonstrates retrieval of supval data
    using the `supval` and `supstr` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-4. Retrieving netnode supvals
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using supvals, it is possible to access any data stored in any array within
    a netnode. For example, supval functions can be used to store and retrieve altval
    data by limiting the supset and supval operations to the size of an altval. Reading
    through *netnode.hpp*, you will see that this is in fact the case by observing
    the inlined implementation of the `altset` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Hashvals* offer yet another interface to netnodes. Rather than being associated
    with integer indexes, hashvals are associated with key strings. Overloaded versions
    of the `hashset` function make it easy to associate integer data or array data
    with a hash key, while the `hashval`, `hashstr`, and `hashval_long` functions
    allow retrieval of hashvals when provided with the appropriate hash key. Tag values
    associated with the `hash`*`XXX`* functions actually choose one of 256 hash tables,
    with the default table being `''H''`. Alternate tables are selected by specifying
    a tag other than `''H''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last interface to netnodes that we will mention is the *charval* interface.
    The `charval` and `charset` functions offer a simple means to store single-byte
    data into a netnode array. There is no default array associated with charval storage
    and retrieval, so you must specify an array tag for every charval operation. Charvals
    are stored into the same arrays as altvals and supvals, and the charval functions
    are simply wrappers around 1-byte supvals.
  prefs: []
  type: TYPE_NORMAL
- en: Another capability provided by the `netnode` class is the ability to iterate
    over the contents of a netnode array (or hash table). Iteration is performed using
    *`XXX`*`1st`, *`XXX`*`nxt`, *`XXX`*`last`, and *`XXX`*`prev` functions that are
    available for altvals, supvals, hashvals, and charvals. The example in [Example 16-5](ch16s02.html#enumerating_netnode_altvals
    "Example 16-5. Enumerating netnode altvals") illustrates iteration across the
    default altvals array (`'A'`).
  prefs: []
  type: TYPE_NORMAL
- en: Iteration over supvals, charvals, and hashvals is performed in a very similar
    manner; however, you will find that the syntax varies depending on the type of
    values being accessed. For example, iteration over hashvals returns hashkeys rather
    than array indexes, which must then be used to retrieve hashvals.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-5. Enumerating netnode altvals
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: NETNODES AND IDC GLOBAL ARRAYS
  prefs: []
  type: TYPE_NORMAL
- en: You may recall from [Chapter 15](ch15.html "Chapter 15. IDA Scripting") that
    the IDC scripting language provides persistent global arrays. Netnodes provide
    the backing storage for IDC global arrays. When you supply a name to the IDC `CreateArray`
    function, the string `$ idc_array` is prepended to the name that you supply to
    form a netnode name. The `netnodenumber` of the newly created netnode is returned
    to you as the IDC array identifier. The IDC `SetArrayLong` function stores an
    integer into the altvals (`'A'`) array, while the `SetArrayString` function stores
    a string into the supvals (`'S'`) array. When you retrieve a value from an IDC
    array using the `GetArrayElement` function, the tags that you supply (`AR_LONG
    or AR_STR`) represent the tags to the altval and supval arrays used to store the
    corresponding integer or strings data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Appendix B](apb.html "Appendix B. IDC/SDK Cross-Reference") offers additional
    insight into the use of netnodes within the implementations of IDC functions and
    exposes how netnodes are used to store various types of information (such as comments)
    within a database.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Netnodes and Netnode Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `netnode` class also provides functions for deleting individual array elements,
    the entire contents of an array, or the entire contents of a netnode. Removing
    an entire netnode is fairly straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When deleting individual array elements, or entire array contents, you must
    take care to choose the proper deletion function because the names of the functions
    are very similar and choosing the wrong form may result in significant loss of
    data. Commented examples demonstrating deletion of altvals follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note the similarity in the syntax to delete the entire contents of the default
    altval array ![](httpatomoreillycomsourcenostarchimages854061.png) and the syntax
    to delete a single element from the default altval array ![](httpatomoreillycomsourcenostarchimages854063.png).
    If for some reason you fail to specify an index when you want to delete a single
    element, you may end up deleting an entire array. Similar functions exist to delete
    supval, charval, and hashval data.
  prefs: []
  type: TYPE_NORMAL
- en: Useful SDK Datatypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA’s API defines a number of C++ classes designed to model components typically
    found in executable files. The SDK contains classes to describe functions, program
    sections, data structures, individual assembly language instructions, and individual
    operands within each instruction. Additional classes are defined to implement
    the tools that IDA uses to manage the disassembly process. Classes falling into
    this latter category define general database characteristics, loader module characteristics,
    processor module characteristics, and plug-in module characteristics, and they
    define the assembly syntax to be used for each disassembled instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more common general-purpose classes are described here. We defer
    discussion of classes that are more specific to plug-ins, loaders, and processor
    modules until the appropriate chapters covering those topics. Our goal here is
    to introduce classes, their purposes, and some important data members of each
    class. Useful functions for manipulating each class are described in [Commonly
    Used SDK Functions](ch16s02.html#commonly_used_sdk_functions "Commonly Used SDK
    Functions") in [Commonly Used SDK Functions](ch16s02.html#commonly_used_sdk_functions
    "Commonly Used SDK Functions").
  prefs: []
  type: TYPE_NORMAL
- en: '**`area_t`** **(area.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This struct describes a range of addresses and is the base class for several
    other classes. The struct contains two data members, `startEA` (inclusive) and
    `endEA` (exclusive), that define the boundaries of the address range. Member functions
    are defined that compute the size of the address range and that can perform comparisons
    between two areas.
  prefs: []
  type: TYPE_NORMAL
- en: '**`func_t`** **(funcs.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This class inherits from `area_t`. Additional data fields are added to the class
    to record binary attributes of the function, such as whether the function uses
    a frame pointer or not, and attributes describing the function’s local variables
    and arguments. For optimization purposes, some compilers may split functions into
    several noncontiguous regions within a binary. IDA terms these regions *chunks*
    or *tails*. The `func_t` class is also used to describe tail chunks.
  prefs: []
  type: TYPE_NORMAL
- en: '**`segment_t`** **(segment.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: The `segment_t` class is another subclass of `area_t`. Additional data fields
    describe the name of the segment, the permissions in effect in the segment (readable,
    writeable, executable), the type of the segment (code, data, etc.), and the number
    of bits used in a segment address (16, 32, or 64).
  prefs: []
  type: TYPE_NORMAL
- en: '**`idc_value_t`** **(expr.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This class describes the contents of an IDC value, which may contain at any
    time a string, an integer, or a floating-point value. The type is utilized extensively
    when interacting with IDC functions from within a compiled module.
  prefs: []
  type: TYPE_NORMAL
- en: '**`idainfo`** **(ida.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This struct is populated with characteristics describing the open database.
    A single global variable named `inf`, of type `idainfo`, is declared in *ida.hpp*.
    Fields within this struct describe the name of the processor module that is in
    use, the input file type (such as `f_PE` or `f_MACHO` via the `filetype_t` enum),
    the program entry point (`beginEA`), the minimum address within the binary (`minEA`),
    the maximum address in the binary (`maxEA`), the endianness of the current processor
    (`mf`), and a number of configuration settings parsed from *ida.cfg*.
  prefs: []
  type: TYPE_NORMAL
- en: '**`struc_t`** **(struct.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This class describes the layout of structured data within a disassembly. It
    is used to describe structures within the Structures window as well as to describe
    the composition of function stack frames. A `struc_t` contains flags describing
    attributes of the structure (such as whether it is a structure or union or whether
    the structure is collapsed or expanded in the IDA display window), and it also
    contains an array of structure members.
  prefs: []
  type: TYPE_NORMAL
- en: '**`member_t`** **(struct.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This class describes a single member of a structured datatype. Included data
    fields describe the byte offset at which the member begins and ends within its
    parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**`op_t`** **(ua.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This class describes a single operand within a disassembled instruction. The
    class contains a zero-based field to store the number of the operand (`n`), an
    operand type field (`type`), and a number of other fields whose meaning varies
    depending on the operand type. The `type` field is set to one of the `optype_t`
    constants defined in *ua.hpp* and describes the operand type or addressing mode
    used for the operand.
  prefs: []
  type: TYPE_NORMAL
- en: '**`insn_t`** **(ua.hpp)**'
  prefs: []
  type: TYPE_NORMAL
- en: This class contains information describing a single disassembled instruction.
    Fields within the class describe the instruction’s address within the disassembly
    (`ea`), the instruction’s type (`itype`), the instruction’s length in bytes (`size`),
    and an array of six possible operand values (`Operands`) of type `op_t` (IDA limits
    each instruction to a maximum of six operands). The `itype` field is set by the
    processor module. For standard IDA processor modules, the `itype` field is set
    to one of the enumerated constants defined in *allins.hpp*. When a third-party
    processor module is used, the list of potential `itype` values must be obtained
    from the module developer. Note that the `itype` field generally bears no relationship
    whatsoever to the binary opcode for the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding list is by no means a definitive guide to all of the datatypes
    used within the SDK. This list is intended merely as an introduction to some of
    the more commonly used classes and some of the more commonly accessed fields within
    those classes.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly Used SDK Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the SDK is programmed using C++ and defines a number of C++ classes, in
    many cases the SDK favors traditional C-style nonmember functions for manipulation
    of objects within a database. For most API datatypes, it is more common to find
    nonmember functions that require a pointer to an object than it is to find a member
    function to manipulate the object in the manner you desire.
  prefs: []
  type: TYPE_NORMAL
- en: In the summaries that follow, we cover API functions that provide functionality
    similar to many of the IDC functions introduced in [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting"). It is unfortunate that functions that perform identical tasks are
    named one thing in IDC and something different within the API.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Database Access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following functions, declared in *bytes.hpp*, provide access to individual
    bytes, words, and dwords within a database.
  prefs: []
  type: TYPE_NORMAL
- en: '| **`uchar get_byte(ea_t addr)`** Reads current byte value from virtual address
    `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`ushort get_word(ea_t addr)`** Reads current word value from virtual address
    `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`ulong get_long(ea_t addr)`** Reads current double word value from virtual
    address `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_many_bytes(ea_t addr, void *buffer, ssize_t len)`** Copies `len` bytes
    from the `addr` into the supplied buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| **`patch_byte(ea_t addr, ulong val)`** Sets a byte value at virtual address
    `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`patch_word(long addr, ulonglong val)`** Sets a word value at virtual address
    `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`patch_long(long addr, ulonglong val)`** Sets a double word value at virtual
    address `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`patch_many_bytes(ea_t addr, const void *buffer, size_t len)`** Patches
    the database beginning at `addr` with `len` bytes from the user-supplied `buffer`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`ulong get_original_byte(ea_t addr)`** Reads the original byte value (prior
    to patching) from virtual address `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`ulonglong get_original_word(ea_t addr)`** Reads the original word value
    from virtual address `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`ulonglong get_original_long(ea_t addr)`** Reads the original double word
    value from virtual address `addr`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`bool isLoaded(ea_t addr)`** Returns true if `addr` contains valid data,
    false otherwise. |'
  prefs: []
  type: TYPE_TB
- en: Additional functions exist for accessing alternative data sizes. Note that the
    `get_original_`*`XXX`* functions get the very first *original* value, which is
    not necessarily the value at an address prior to a patch. Consider the case when
    a byte value is patched twice; over time this byte has held three different values.
    After the second patch, both the current value and the original value are accessible,
    but there is no way to obtain the second value (which was set with the first patch).
  prefs: []
  type: TYPE_NORMAL
- en: User Interface Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interaction with the IDA user interface is handled by a single *dispatcher*
    function named `callui`. Requests for various user interface services are made
    by passing a user interface request (one of the enumerated `ui_notification_t`
    constants) to `callui` along with any additional parameters required by the request.
    Parameters required for each request type are specified in *kernwin.hpp*. Fortunately,
    a number of convenience functions that hide many of the details of using `callui`
    directly are also defined in *kernwin.hpp*. Several common convenience functions
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`msg(char *format, ...)`** Prints a formatted message to the message window.
    This function is analogous to C’s `printf` function and accepts a `printf`-style
    format string. |'
  prefs: []
  type: TYPE_TB
- en: '| **`warning(char *format, ...)`** Displays a formatted message in a dialog.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`char *askstr(int hist, char *default, char *format, ...)`** Displays an
    input dialog asking the user to enter a string value. The `hist` parameter dictates
    how the drop-down history list in the dialog should be populated and should be
    set to one of the `HIST_`*`xxx`* constants defined in *kernwin.hpp*. The `format`
    string and any additional parameters are use to form a prompt string. |'
  prefs: []
  type: TYPE_TB
- en: '| **`char *askfile_c(int dosave, char *default, char *prompt, ...)`** Displays
    a file save (`dosave` = 1) or file open (`dosave` = 0) dialog, initially displaying
    the directory and file mask specified by default (such as `C:\\windows\\*.exe`).
    Returns the name of the selected file or NULL if the dialog was canceled. |'
  prefs: []
  type: TYPE_TB
- en: '| **`askyn_c(int default, char *prompt, ...)`** Prompts the user with a yes
    or no question, highlighting a *default* answer (1 = yes, 0 = no,-1 = cancel).
    Returns an integer representing the selected answer. |'
  prefs: []
  type: TYPE_TB
- en: '| **`AskUsingForm_c(const char *form, ...)`** The `form` parameter is an ASCII
    string specification of a dialog and its associated input elements. This function
    may be used to build customized user interface elements when none of the SDK’s
    other convenience functions meet your needs. The format of the `form` string is
    detailed in *kernwin.hpp*. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_screen_ea()`** Returns the virtual address of the current cursor location.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`jumpto(ea_t addr)`** Jumps the disassembly window to the specified address.
    |'
  prefs: []
  type: TYPE_TB
- en: Many more user interface capabilities are available using the API than are available
    with IDC scripting, including the ability to create customized single- and multicolumn
    list selection dialogs. Users interested in these capabilities should consult
    *kernwin.hpp* and the `choose` and `choose2` functions in particular.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Database Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions are available for working with named locations within
    a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`get_name(ea_t from, ea_t addr, char *namebuf, size_t maxsize)`** Returns
    the name associated with `addr`. Returns the empty string if the location has
    no name. This function provides access to local names when `from` is any address
    in the function that contains `addr`. The name is copied into the provided output
    buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| **`set_name(ea_t addr, char *name, int flags)`** Assigns the given name to
    the given address. The name is created with attributes specified in the `flags`
    bitmask. Possible flag values are described in *name.hpp*. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_name_ea(ea_t funcaddr, char *localname)`** Searches for the given
    local name within the function containing `funcaddr`. Returns the address of the
    name or BADADDR (-1) if no such name exists in the given function. |'
  prefs: []
  type: TYPE_TB
- en: Function Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The API functions for accessing information about disassembled functions are
    declared in *funcs.hpp*. Functions for accessing stack frame information are declared
    in *frame.hpp*. Some of the more commonly used functions are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`func_t *get_func(ea_t addr)`** Returns a pointer to a `func_t` object
    that describes the function containing the indicated address. |'
  prefs: []
  type: TYPE_TB
- en: '| **`size_t get_func_qty()`** Returns the number of functions present in the
    database. |'
  prefs: []
  type: TYPE_TB
- en: '| **`func_t *getn_func(size_t n)`** Returns a pointer to a `func_t` object
    that represents the *n*th function in the database where *`n`* is between zero
    (inclusive) and `get_func_qty()` (exclusive). |'
  prefs: []
  type: TYPE_TB
- en: '| **`func_t *get_next_func(ea_t addr)`** Returns a pointer to a `func_t` object
    that describes the next function following the specified address. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_func_name(ea_t addr, char *name, size_t namesize)`** Copies the name
    of the function containing the indicated address into the supplied name buffer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`struc_t *get_frame(ea_t addr)`** Returns a pointer to a `struc_t` object
    that describes the stack frame for the function that contains the indicated address.
    |'
  prefs: []
  type: TYPE_TB
- en: Structure Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `struc_t` class is used to access function stack frames as well as structured
    datatypes defined within type libraries. Some of the basic functions for interacting
    with structures and their associated members are described here. Many of these
    functions make use of a type ID (`tid_t`) datatype. The API includes functions
    for mapping a `struc_t` to an associated `tid_t` and vice versa. Note that both
    the `struc_t` and `member_t` classes contain a `tid_t` data member, so obtaining
    type ID information is simple if you already have a pointer to a valid `struc_t`
    or `member_t` object.
  prefs: []
  type: TYPE_NORMAL
- en: '| **`tid_t get_struc_id(char *name)`** Looks up the type ID of a structure
    given its name. |'
  prefs: []
  type: TYPE_TB
- en: '| **`struc_t *get_struc(tid_t id)`** Obtains a pointer to a `struc_t` representing
    the structure specified by the given type ID. |'
  prefs: []
  type: TYPE_TB
- en: '| **`asize_t get_struc_size(struc_t *s)`** Returns the size of the given structure
    in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| **`member_t *get_member(struc_t *s, asize_t offset)`** Returns a pointer
    to a `member_t` object that describes the structure member that resides at the
    specified `offset` into the given structure. |'
  prefs: []
  type: TYPE_TB
- en: '| **`member_t *get_member_by_name(struc_t *s, char *name)`** Returns a pointer
    to a `member_t` object that describes the structure member identified by the given
    `name`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`tid_t add_struc(uval_t index, char *name, bool is_union=false)`** Appends
    a new structure with the given `name` into the standard structures list. The structure
    is also added to the Structures window at the given `index`. If `index` is `BADADDR`,
    the structure is added as the last structure in the Structures window. |'
  prefs: []
  type: TYPE_TB
- en: '| **`add_struc_member(struc_t *s, char *name, ea_t offset, flags_t flags, typeinfo_t
    *info, asize_t size)`** Adds a new member with the given `name` to the given structure.
    The member is either added at the indicated `offset` within the structure or appended
    to the end of the structure if `offset` is `BADADDR`. The `flags` parameter describes
    the datatype of the new member. Valid flags are defined using the `FF_`*`XXX`*
    constants described in *bytes.hpp*. The `info` parameter provides additional information
    for complex datatypes; it may be set to `NULL` for primitive datatypes. The `typeinfo_t`
    datatype is defined in *nalt.hpp*. The `size` parameter specifies the number of
    bytes occupied by the new member. |'
  prefs: []
  type: TYPE_TB
- en: Segment Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `segment_t` class stores information related to the different segments within
    a database (such as `.text` and `.data`) as listed in the View ▸ Open Subviews
    ▸ Segments window. Recall that what IDA terms *segments* are often referred to
    as *sections* by various executable file formats such as PE and ELF. The following
    functions provide basic access to `segment_t` objects. Additional functions dealing
    with the `segment_t` class are declared in *segment.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **`segment_t *getseg(ea_t addr)`** Returns a pointer to the `segment_t` object
    that contains the given address. |'
  prefs: []
  type: TYPE_TB
- en: '| **`segment_t *ida_export get_segm_by_name(char *name)`** Returns a pointer
    to the `segment_t` object with the given name. |'
  prefs: []
  type: TYPE_TB
- en: '| **`add_segm(ea_t para, ea_t start, ea_t end, char *name, char *sclass)`**
    Creates a new segment in the current database. The segment’s boundaries are specified
    with the `start` (inclusive) and `end` (exclusive) address parameters, while the
    segment’s name is specified by the `name` parameter. The segment’s class loosely
    describes the type of segment being created. Predefined classes include `CODE`
    and `DATA`. A complete list of predefined classes may be found in *segment.hpp*.
    The `para` parameter describes the base address of the section when segmented
    addresses (`seg:offset`) are being used, in which case `start` and `end` are interpreted
    as offsets rather than as virtual addresses. When segmented addresses are not
    being used, or all segments are based at 0, this parameter should be set to 0.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`add_segm_ex(segment_t *s, char *name, char *sclass, int flags)`** Alternate
    method for creating new segments. The fields of `s` should be set to reflect the
    address range of the segment. The segment is named and typed according to the
    `name` and `sclass` parameters. The `flags` parameter should be set to one of
    the `ADDSEG_`*`XXX`* values defined in *segment.hpp*. |'
  prefs: []
  type: TYPE_TB
- en: '| **`int get_segm_qty()`** Returns the number of sections present within the
    database. |'
  prefs: []
  type: TYPE_TB
- en: '| **`segment_t *getnseg(int n)`** Returns a pointer to a `segment_t` object
    populated with information about the *n*th program section in the database. |'
  prefs: []
  type: TYPE_TB
- en: '| **`int set_segm_name(segment_t *s, char *name, ...)`** Changes the name of
    the given segment. The name is formed by treating `name` as a format string and
    incorporating any additional parameters as required by the format string. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_segm_name(ea_t addr, char *name, size_t namesize)`** Copies the name
    of the segment containing the given address into the user-supplied `name` buffer.
    Note the `name` may be filtered to replace characters that IDA considers invalid
    (characters not specified as `NameChars` in *ida.cfg*) with a dummy character
    (typically an underscore as specified by `SubstChar` in *ida.cfg*). |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_segm_name(segment_t *s, char *name, size_t namesize)`** Copies the
    potentially filtered name of the given segment into the user-supplied `name` buffer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_true_segm_name(segment_t *s, char *name, size_t namesize)`** Copies
    the exact name of the given segment into the user-supplied `name` buffer without
    filtering any characters. |'
  prefs: []
  type: TYPE_TB
- en: One of the `add_segm` functions must be used to actually create a segment. Simply
    declaring and initializing a `segment_t` object does not actually create a segment
    within the database. This is true with all of the wrapper classes such as `func_t`
    and `struc_t`. These classes merely provide a convenient means to access attributes
    of an underlying database entity. The appropriate functions to create, modify,
    or delete actual database objects must be utilized in order to make persistent
    changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Code Cross-References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A number of functions and enumerated constants are defined in *xref.hpp* for
    use with code cross-references. Some of these are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`get_first_cref_from(ea_t from)`** Returns the first location to which
    the given address transfers control. Returns BADADDR (-1) if the given address
    refers to no other addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_next_cref_from(ea_t from, ea_t current)`** Returns the next location
    to which the given address (`from`) transfers control, given that `current` has
    already been returned by a previous call to `get_first_cref_from` or `get_next_cref_from`.
    Returns BADADDR if no more cross-references exist. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_first_cref_to(ea_t to)`** Returns the first location that transfers
    control to the given address. Returns BADADDR (-1) if there are no references
    to the given address. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_next_cref_to(ea_t to, ea_t current)`** Returns the next location that
    transfers control to the given address (`to`), given that `current` has already
    been returned by a previous call to `get_first_cref_to` or `get_next_cref_to`.
    Returns BADADDR if no more cross-references to the given location exist. |'
  prefs: []
  type: TYPE_TB
- en: Data Cross-References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The functions for accessing data cross-reference information (also declared
    in *xref.hpp*) are very similar to the functions used to access code cross-reference
    information. These functions are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`get_first_dref_from(ea_t from)`** Returns the first location to which
    the given address refers to a data value. Returns BADADDR (-1) if the given address
    refers to no other addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_next_dref_from(ea_t from, ea_t current)`** Returns the next location
    to which the given address (`from`) refers a data value, given that `current`
    has already been returned by a previous call to `get_first_dref_from` or `get_next_dref_from`.
    Returns BADADDR if no more cross-references exist. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_first_dref_to(ea_t to)`** Returns the first location that refers to
    the given address as data. Returns BADADDR (-1) if there are no references to
    the given address. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_next_dref_to(ea_t to, ea_t current)`** Returns the next location that
    refers to the given address (`to`) as data, given that `current` has already been
    returned by a previous call to `get_first_dref_to` or `get_next_dref_to`. Returns
    BADADDR if no more cross-references to the given location exist. |'
  prefs: []
  type: TYPE_TB
- en: The SDK contains no equivalent to IDC’s `XrefType` function. A variable named
    `lastXR` is declared in *xref.hpp*; however, it is not exported. If you need to
    determine the exact type of a cross-reference, you must iterate cross-references
    using an `xrefblk_t` structure. The `xrefblk_t` is described in “Enumerating Cross-References
  prefs: []
  type: TYPE_NORMAL
- en: Iteration Techniques Using the IDA API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the IDA API, there are often several different ways to iterate over various
    database objects. In the following examples we demonstrate some common iteration
    techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first technique for iterating through the functions within a database mimics
    the manner in which we performed the same task using IDC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can simply iterate through functions by index numbers, as
    shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can work at a somewhat lower level and make use of a data structure
    called an `areacb_t`, also known as an *area control block*, defined in *area.hpp*.
    Area control blocks are used to maintain lists of related `area_t` objects. A
    global `areacb_t` named `funcs` is exported (in *funcs.hpp*) as part of the IDA
    API. Using the `areacb_t` class, the previous example can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `get_next_area` member function ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) is used repeatedly to
    obtain the index values for each area in the `funcs` control block. A pointer
    to each related `func_t` area is obtained by supplying each index value to the
    `getn_area` member function ![](httpatomoreillycomsourcenostarchimages854093.png).
    Several global `areacb_t` variables are declared within the SDK, including the
    `segs` global, which is an area control block containing `segment_t` pointers
    for each section in the binary.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Structure Members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within the SDK, stack frames are modeled using the capabilities of the `struc_t`
    class. The example in [Example 16-6](ch16s02.html#enumerating_stack_frame_members
    "Example 16-6. Enumerating stack frame members") utilizes structure member iteration
    as a means of printing the contents of a stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-6. Enumerating stack frame members
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This example summarizes a function’s stack frame using information from the
    function’s `func_t` object and the associated `struc_t` representing the function’s
    stack frame. The `frsize` and and `frregs` fields specify the size of the local
    variable portion of the stack frame and the number of bytes dedicated to saved
    registers, respectively. The saved return address can be found within the frame
    following the local variables and the saved registers. Within the frame itself,
    the `memqty` field specifies the number of defined members contained in the frame
    structure, which also corresponds to the size of the `members` array. A loop is
    used to retrieve the name of each member and determine whether the member is a
    local variable or an argument based on its starting offset (`soff`) within the
    frame structure.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Cross-References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") we saw that it is possible
    to enumerate cross-references from IDC scripts. The same capabilities exist within
    the SDK, though in a some-what different form. As an example, let’s revisit the
    idea of listing all calls of a particular function (see [Example 15-4](ch15s05.html#enumerating_a_functionas_callers
    "Example 15-4. Enumerating a function’s callers") in [Enumerating Exported Functions](ch15s05.html#enumerating_exported_functions
    "Enumerating Exported Functions")). The following function almost works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The reason this function almost works is that there is no way to determine the
    type of cross-reference returned for each iteration of the loop (recall that there
    is no SDK equivalent for IDC’s `XrefType`). In this case we should verify that
    each cross-reference to the given function is in fact a call type (`fl_CN` or
    `fl_CF`) cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to determine the type of a cross-reference within the SDK, you
    must use an alternative form of cross-reference iteration facilitated by the `xrefblk_t`
    structure, which is described in *xref.hpp*. The basic layout of an `xrefblk_t`
    is shown in the following listing. (For full details, please see *xref.hpp*.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The member functions of `xrefblk_t` are used to initialize the structure ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) and perform the iteration
    ![](httpatomoreillycomsourcenostarchimages854093.png) and ![](httpatomoreillycomsourcenostarchimages854095.png),
    while the data members are used to access information about the last cross-reference
    that was retrieved. The `flags` value required by the `first_from` and `first_to`
    functions dictates which type of cross-references should be returned. Legal values
    for the `flags` parameter include the following (from *xref.hpp*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that no flag value restricts the returned references to code only. If you
    are interested in code cross-references, you must either compare the `xrefblk_t
    type` field to specific cross-reference types (such as `fl_JN`) or test the `iscode`
    field to determine if the last returned cross-reference was a code cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: The following modified version of the `list_callers` function demonstrates the
    use of an `xrefblk_t` iteration structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Through the use of an `xrefblk_t`, we now have the opportunity to examine ![](httpatomoreillycomsourcenostarchimages854061.png)
    the type of each cross-reference returned by the iterator and decide whether it
    is interesting to us or not. In this example we simply ignore any cross-reference
    that is not related to a function call. We did not use the `iscode` member of
    `xrefblk_t` because `iscode` is true for jump and ordinary flow cross-references
    in addition to call cross-references. Thus, `iscode` alone does not guarantee
    that the current cross-reference is related to a function call.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[116](#CHP-16-FN-3)]) *Binary large object*, or *blob*, is a term often used
    to refer to arbitray binary data of varying size.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functions and data structures described in this chapter only scratch the
    surface of IDA’s API. For each of the functional categories described, many more
    API functions exist that perform more specialized tasks and that provide much
    finer control over various database elements than can be implemented using IDC.
    In the following chapters we will cover the details of building plug-in modules,
    loader modules, and processor modules, and we will continue to expand our presentation
    of the capabilities of the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17. The IDA Plug-in Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Over the course of the next few chapters, we will cover the types of modules
    that can be constructed using the IDA SDK. We will also discuss new features (since
    IDA 5.7) that allow for the development of these same types of modules using one
    of IDA’s scripting languages. Whether you ever intend to create your own plug-ins
    or not, a basic understanding of plug-ins will greatly enhance your experience
    using IDA, since, arguably, the majority of third-party software developed for
    use with IDA is distributed in the form of plug-ins. In this chapter, we begin
    the exploration of IDA modules by discussing the purpose of IDA plug-ins, along
    with how to build, install, and configure them.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-ins are probably best described as the compiled, albeit more powerful,
    equivalents of IDA scripts. Plug-ins are usually associated with a hotkey and/or
    a menu item and are typically accessible only after a database has been opened.
    Individual plug-ins may be general purpose in nature and useful across a wide
    variety of binary file types and processor architectures, or they may be very
    specialized, designed to be used only with a specific file format or processor
    type. In all cases, by virtue of being compiled modules, plug-ins have full access
    to the IDA API and can generally perform much more complex tasks than you could
    ever hope to accomplish using scripting alone.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Plug-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All IDA modules, including plug-ins, are implemented as shared library components
    appropriate to the platform on which the plug-in is expected to execute. Under
    IDA’s modular architecture, modules are not required to export any functions.
    Instead, each module type must export a variable of a specific class. In the case
    of plug-ins, this class is called a `plugin_t` and is defined in the SDK’s *loader.hpp*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: THE EVOLVING IDA API
  prefs: []
  type: TYPE_NORMAL
- en: Since SDK 4.9, Hex-Rays has attempted to minimize changes to existing API functions
    between releases of IDA. One result of this policy is that binary plug-ins from
    an older version of IDA can often be copied directly into newer IDA installations
    and continue to work properly. Nonetheless, IDA’s API has grown with each new
    release, introducing new functions and new options to take advantage of IDA’s
    everexpanding list of capabilities. As the SDK has evolved, Hex-Rays has opted
    to deprecate the occasional API function. When a function (or any other symbol)
    is deprecated, Hex-Rays moves it into a code block bounded by a test of the `NO_OBSOLETE_FUNCS`
    macro. If you wish to ensure that your plug-ins (or other modules) are not using
    any deprecated functions, you should define `NO_OBSOLETE_FUNCS` prior to including
    any SDK header files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand how to create a plug-in, you must first understand the
    `plugin_t` class and its component data fields (the class has no member functions).
    The layout of the `plugin_t` class is shown here, with comments taken from *loader.hpp*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Every plug-in must export a `plugin_t` object named `PLUGIN`. Exporting your
    `PLUGIN` object is handled by *loader.hpp*, which leaves you responsible for declaring
    and initializing the actual object. Since successful plug-in creation relies on
    properly initializing this object, we describe the purpose of each member here.
    Note that even if you prefer to take advantage of IDA’s new scripted plug-in capabilities,
    you will still need to familiarize yourself with each of these fields because
    they are used in scripted plug-ins as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**`version`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member indicates the version number of the API that was used to build the
    plug-in. It is typically set to the constant `IDP_INTERFACE_VERSION`, which is
    declared in *idp.hpp*. The value of this constant has not changed since the API
    was standardized with SDK version 4.9\. The original intent of this field was
    to prevent plug-ins created with earlier versions of an SDK from being loaded
    into versions of IDA built with newer versions of the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '**`flags`**'
  prefs: []
  type: TYPE_NORMAL
- en: This field contains various flags indicating how IDA should treat the plug-in
    in various situations. The flags are set using a bitwise combination of the `PLUGIN_`*`XXX`*
    constants defined in *loader.hpp*. For many plug-ins, assigning zero to this field
    will be sufficient. Please refer to *loader.hpp* for the meanings of each flag
    bit.
  prefs: []
  type: TYPE_NORMAL
- en: '**`init`**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the first of three function pointers contained in the `plugin_t` class.
    This particular member is a pointer to the plug-in’s initialization function.
    The function takes no parameters and returns an `int`. IDA calls this function
    to offer your plug-in a chance to be loaded. Initialization of plug-ins is discussed
    in [Plug-in Initialization](ch17.html#plug-in_initialization "Plug-in Initialization")
    in [Plug-in Initialization](ch17.html#plug-in_initialization "Plug-in Initialization").
  prefs: []
  type: TYPE_NORMAL
- en: '**`term`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is another function pointer. IDA calls the associated function when
    your plug-in is unloaded. The function takes no arguments and returns no value.
    The purpose of this function is to perform any cleanup tasks (deallocating memory,
    closing handles, saving state, and so on) required by your plug-in before IDA
    unloads it. This field may be set to NULL if you have no actions to perform when
    your plug-in is unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '**`run`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member points to the function that should be called whenever a user activates
    (via a hotkey, menu item, or script invocation) your plug-in. This function is
    the heart of any plug-in, because it is here that the behaviors users associate
    with the plug-in are defined. This is the function that bears the most resemblance
    to scripted behaviors. The function receives a single integer parameter (discussed
    later under [Plug-in Execution](ch17.html#plug-in_execution "Plug-in Execution")
    in [Plug-in Execution](ch17.html#plug-in_execution "Plug-in Execution")) and returns
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '**`comment`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is a pointer to a character string that serves as a comment for
    the plug-in. It is not used directly by IDA and can safely be set to NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '**`help`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is a pointer to a character string that serves as a multiline help
    string. It is not used directly by IDA and can safely be set to NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '**`wanted_name`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is a pointer to a character string that holds the name of the plug-in.
    When a plug-in is loaded, this string is added to the Edit ▸ Plugins menu as a
    means of activating the plug-in. There is no requirement for the name to be unique
    among loaded plug-ins, though it is difficult to determine which of two identically
    named plug-ins will be activated when the name is selected from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: '**`wanted_hotkey`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is a pointer to a character string that holds the name of the hotkey
    (such as `"Alt-F8"`) that IDA will attempt to associate with the plugin. Here
    again, there is no need for this value to be unique among loaded plug-ins; however;
    if the value is not unique, the hotkey will be associated with the last plug-in
    to request it. [Configuring Plug-ins](ch17s04.html "Configuring Plug-ins") in
    [Configuring Plug-ins](ch17s04.html "Configuring Plug-ins") discusses how users
    may override the `wanted_hotkey` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of initializing a `plugin_t` object is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The function pointers included in the `plugin_t` class allow IDA to locate required
    functions in your plug-in without requiring you to export those functions or to
    choose specific names for those functions.
  prefs: []
  type: TYPE_NORMAL
- en: The Plug-in Life Cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical IDA session begins with the launch of the IDA application itself
    and proceeds through loading and analyzing a new binary file or existing database
    before settling down to wait for user interaction. During this process, there
    are three distinct points at which IDA offers plug-ins a chance to load:'
  prefs: []
  type: TYPE_NORMAL
- en: A plug-in may load immediately upon IDA startup, regardless of whether a database
    is being loaded or not. Loading in this manner is controlled by the presence of
    the `PLUGIN_FIX` bit in `PLUGIN.flags`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A plug-in may load immediately following a processor module and remain loaded
    until the processor module is unloaded. Tying a plug-in to a processor module
    is controlled by the `PLUGIN_PROC` bit in `PLUGIN.flags`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the absence of the flag bits just mentioned, IDA offers plug-ins the opportunity
    to load each time a database is opened in IDA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IDA offers plug-ins the opportunity to load by calling `PLUGIN.init`. When called,
    the `init` function should determine whether the plug-in is designed to be loaded
    given the current state of IDA. The meaning of *current state* varies depending
    on which of the three preceding situations are applicable when the plug-in is
    being loaded. Examples of states that a plug-in may be interested in include the
    input file type (a plug-in may be designed specifically for use with PE files,
    for example) and the processor type (a plug-in may be designed exclusively for
    use with x86 binaries).
  prefs: []
  type: TYPE_NORMAL
- en: To indicate its desires to IDA, `PLUGIN.init` must return one of the following
    values defined in *loader.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **PLUGIN_SKIP** Returning this value signals that the plug-in should not
    be loaded. |'
  prefs: []
  type: TYPE_TB
- en: '| **PLUGIN_OK** Returning this value instructs IDA to make the plug-in available
    for use with the current database. IDA loads the plug-in when the user activates
    the plug-in using a menu action or a hotkey. |'
  prefs: []
  type: TYPE_TB
- en: '| **PLUGIN_KEEP** Returning this value instructs IDA to make the plug-in available
    for use with the current database and keep the plug-in loaded in memory. |'
  prefs: []
  type: TYPE_TB
- en: Once a plug-in has been loaded, it may be activated in one of two ways. The
    most frequent method of activating a plug-in is at the direction of the user in
    response to a menu selection or hotkey activation. Each time a plug-in is activated
    in this way, IDA passes control to the plug-in by calling `PLUGIN.run`. An alternate
    method for plug-in activation is for the plug-in to hook into IDA’s event-notification
    system. In such cases, a plug-in must express interest in one or more types of
    IDA events and register a callback function to be called by IDA when any event
    of interest occurs.
  prefs: []
  type: TYPE_NORMAL
- en: When it is time for a plug-in to be unloaded, IDA calls `PLUGIN.term` (assuming
    it is non-NULL). The circumstances under which a plug-in is unloaded vary according
    to the bits set in `PLUGIN.flags`. Plug-ins that specify no flag bits are loaded
    according to the value returned by `PLUGIN.init`. These types of plug-ins are
    unloaded when the database for which they were loaded is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When a plug-in specifies the `PLUGIN_UNL` flag bit, the plug-in is unloaded
    after each call to `PLUGIN.run`. Such plug-ins must be reloaded (resulting in
    a call to `PLUGIN.init`) for each subsequent activation. Plug-ins that specify
    the `PLUGIN_PROC` flag bit are unloaded when the processor module for which they
    were loaded is unloaded. Processor modules are unloaded whenever a database is
    closed. Finally, plug-ins that specify the `PLUGIN_FIX` flag bit are unloaded
    only when IDA itself terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-in Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plug-ins are initialized in two phases. Static initialization of plug-ins takes
    place at compile time, while dynamic initialization takes place at load time via
    actions performed within `PLUGIN.init`. As discussed earlier, the `PLUGIN.flags`
    field, which is initialized at compile time, dictates several behaviors of a plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: When IDA is launched, the `PLUGIN.flags` field of every plug-in in *<IDADIR>/plugins*
    is examined. At this point, IDA calls `PLUGIN.init` for each plug-in that specifies
    the `PLUGIN_FIX` flag. `PLUGIN_FIX` plug-ins are loaded before any other IDA module
    and therefore have the opportunity to be notified of any event that IDA is capable
    of generating, including notifications generated by loader modules and processor
    modules. The `PLUGIN.init` function for such plug-ins should generally return
    either `PLUGIN_OK` or `PLUGIN_KEEP`, because it makes little sense to request
    it to be loaded at startup only to return `PLUGIN_SKIP` in `PLUGIN.init`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your plug-in is designed to perform a one-time initialization task
    at IDA startup, you may consider performing that task in the plug-in’s `init`
    function and returning `PLUGIN_SKIP` to indicate that the plug-in is no longer
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time a processor module is loaded, IDA samples the `PLUGIN_PROC` flag
    in every available plug-in and calls `PLUGIN.init` for each plug-in in which `PLUGIN_PROC`
    is set. The `PLUGIN_PROC` flag allows plug-ins to be created that respond to notifications
    generated by processor modules and thereby supplement the behavior of those modules.
    The `PLUGIN.init` function for such modules has access to the global `processor_t`
    object, `ph`, which may be examined and used to determine whether the plug-in
    should be skipped or retained. For example, a plug-in designed specifically for
    use with the MIPS processor module should probably return `PLUGIN_SKIP` if the
    x86 processor module is being loaded, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally, each time a database is loaded or created, the `PLUGIN.init` function
    for each plug-in that has not already been loaded is called to determine whether
    the plug-in should be loaded or not. At this point each plug-in may use any number
    of criteria to determine whether IDA should retain it or not. Examples of specialized
    plug-ins include those that offer behavior specific to certain file types (ELF,
    PE, Mach-O, etc.), processor types, or compiler types.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the reason, when a plug-in decides to return `PLUGIN_OK` (or `PLUGIN_KEEP`),
    the `PLUGIN.init` function should also take care of any one-time initialization
    actions necessary to ensure that the plug-in is capable of performing properly
    when it is eventually activated. Any resources that are requested by `PLUGIN.init`
    should be released in `PLUGIN.term`. A major difference between `PLUGIN_OK` and
    `PLUGIN_KEEP` is that `PLUGIN_KEEP` prevents a plug-in from being repeatedly loaded
    and unloaded and thus reduces the need to allocate, deallocate, and reallocate
    resources as might be required when a plug-in specifies `PLUGIN_OK`. As a general
    rule of thumb, `PLUGIN.init` should return `PLUGIN_KEEP` when future invocations
    of the plug-in may depend on states accumulated during previous invocations of
    the plug-in. A workaround for this is for plug-ins to store any state information
    in the open IDA database using a persistent storage mechanism such as netnodes.
    Using such a technique, subsequent invocations of the plug-in can locate and utilize
    data stored by earlier invocations of the plug-in. This method has the advantage
    of providing persistent storage not only across invocations of the plug-in but
    also across IDA sessions.
  prefs: []
  type: TYPE_NORMAL
- en: For plug-ins in which each invocation is completely independent of any previous
    invocations, it is often suitable for `PLUGIN.init` to return `PLUGIN_OK`, which
    has the advantage of reducing IDA’s memory footprint by keeping fewer modules
    loaded in memory at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Event Notification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While plug-ins are quite frequently activated directly by a user via a menu
    selection (Edit ▸ Plugins) or through the use of a hotkey, IDA’s event-notification
    capabilities offer an alternative means of activating plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want your plug-ins to be notified of specific events that take place
    within IDA, you must register a callback function to express interest in specific
    event types. The `hook_to_notification_point` function is used to inform IDA (1)
    that you are interested in a particular class of events and (2) that IDA should
    call the function that you indicate each time an event in the indicated class
    occurs. An example of using `hook_to_notification_point` to register interest
    in database events is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Four broad categories of notification exist: processor notifications (`idp_notify`
    in *idp.hpp*, `HT_IDP`), user interface notifications (`ui_notification_t` in
    *kernwin.hpp*, `HT_UI`), debugger events (`dbg_notification_t` in *dbg.hpp*, `HT_DBG`),
    and database events (`idp_event_t` in *idp.hpp*, `HT_IDB`). Within each event
    category are a number of individual notification codes that represent specific
    events for which you will receive notifications. Examples of database (`HT_IDB`)
    notifications include `idb_event::byte_patched`, to indicate that a database byte
    has been patched, and `idb_event::cmt_changed`, to indicate that a regular or
    repeatable comment has been changed. Each time an event occurs, IDA invokes each
    registered callback function, passing the specific event-notification code and
    any additional parameters specific to the notification code. Parameters supplied
    for each notification code are detailed in the SDK header files that define each
    notification code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the preceding example, we might define a callback function to handle
    database events as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This particular example recognizes only the `byte_patched` notification message,
    for which it prints the address of the patched byte, the new value of the byte,
    and the original value of the byte. Notification callback functions make use of
    the C++ variable arguments list, `va_list`, to provide access to a variable number
    of arguments, depending on which notification code is being sent to the function.
    The number and type of arguments provided for each notification code are specified
    in the header files in which each notification code is defined. The `byte_patched`
    notification code is defined in *loader.hpp* to receive one argument of type `ea_t`
    in its `va_list`. The C++ `va_arg` macro should be used to retrieve successive
    arguments from a `va_list`. The address of the patched byte is retrieved from
    the `va_list` at ![](httpatomoreillycomsourcenostarchimages854061.png) in the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of unhooking from database notification events is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: All well-behaved plug-ins should unhook any notifications whenever the plug-in
    is unloaded. This is one of the intended purposes of the `PLUGIN.term` function.
    Failure to unhook all of your active notifications will almost certainly result
    in crashing IDA shortly after your plug-in is unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-in Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far we have discussed several instances in which IDA calls functions belonging
    to a plug-in. Plug-in loading and unloading operations result in calls to `PLUGIN.init`
    and `PLUGIN.term`, respectively. User plug-in activation via the Edit ▸ Plugins
    menu or the plug-in’s associated hotkey results in a call to `PLUGIN.run`. Finally,
    callback functions registered by a plug-in may be called in response to various
    events that take place within IDA.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how a plug-in comes to be executed, it is important to understand
    a few essential facts. Plug-in functions are invoked from IDA’s main event-processing
    loop. While a plug-in is executing, IDA cannot process events, including queued
    analysis tasks or updates to the user interface. Therefore it is important that
    your plug-in perform its task as expeditiously as possible and return control
    to IDA. Otherwise IDA will be completely unresponsive, and there will be no way
    to regain control. In other words, once your plug-in is executing, there is no
    simple way to break out of it. You must either wait for your plug-in to complete
    or kill your IDA process. In the latter case, you are likely to have an open database
    on your hands that may or may not be corrupt and may or may not be repairable
    by IDA. The SDK offers three functions that you may use to work around this issue.
    The `show_wait_box` function may be called to display a dialog that displays the
    message *Please wait*. . . along with a Cancel button. You may periodically test
    whether the user pressed the Cancel button by calling the `wasBreak` function.
    The advantage to this approach is that when `wasBreak` is called, IDA will take
    the opportunity to update its user interface, and it allows your plug-in the opportunity
    to decide whether it should stop the processing that it is doing. In any case,
    you must call `hide_wait_box` to remove the Wait dialog from the display.
  prefs: []
  type: TYPE_NORMAL
- en: Do not attempt to get creative in your plug-ins by having your `PLUGIN.run`
    function create a new thread to handle the processing within your plug-in. IDA
    is not thread safe. There are no locking mechanisms in place to synchronize access
    to the many global variables used by IDA, nor are there any locking mechanisms
    to ensure the atomicity of database transactions. In other words, if you did create
    a new thread, and you used SDK functions to modify the database from within that
    thread, you could corrupt the database, because IDA might be in the middle of
    its own modification to the database that conflicts with your attempted changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping these limitations in mind, for most plug-ins, the bulk of the work
    performed by the plug-in will be implemented within `PLUGIN.run`. Building on
    our previously initialized `PLUGIN` object, a minimal (and boring) implementation
    for `PLUGIN.run` might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Every plug-in has the C++ and IDA APIs at its disposal. Additional capabilities
    are available by linking your plug-in with appropriate platform-specific libraries.
    For example, the complete Windows API is available for plug-ins developed to run
    with Windows versions of IDA. To do something more interesting than printing a
    message to the output window, you need to understand how to accomplish your desired
    task using available functions from the IDA SDK. Taking the code from [Example 16-6](ch16s02.html#enumerating_stack_frame_members
    "Example 16-6. Enumerating stack frame members"), for example, we might develop
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Using this function, we now have the core of a plug-in that dumps stack frame
    information for the currently selected function each time the plug-in is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Building Your Plug-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Windows, plug-ins are valid DLL files (that happen to use a *.plw* or .*p64*
    extension), while on Linux and Mac, a plug-in is a valid shared object file (that
    uses a *.plx/.plx64* or *.pmc/.pmc64* extension, respectively). Building plug-ins
    can be a tricky matter, because you must get all of the build settings correct
    or the build process is almost certain to fail. The SDK contains a number of sample
    plug-ins, each containing its own makefile. The makefiles were all created with
    Borland’s build tools for Windows in mind. This poses some challenges when you
    wish to build with a different tool chain or on a different platform. The *install_xxx.txt*
    files included with the SDK discuss the use of *<SDKDIR>/bin/idamake.pl* to build
    plug-ins using GNU make and gcc. The purpose of *idamake.pl* is to generate a
    GNU make-style makefile from the Borland-style makefiles and then invoke GNU make
    to build the plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our preference for building plug-ins is to use simplified makefiles with the
    GNU tools (via MinGW on Windows). The simplified makefile in [Example 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins
    "Example 17-1. A sample makefile for IDA plug-ins") can easily be adapted to your
    own plug-in projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-1. A sample makefile for IDA plug-ins
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding makefile uses the `uname` command to determine the platform on
    which it is running and configures some build flags accordingly. Additional source
    files can be added to the plug-in project by appending the names of the associated
    object files to the `$OBJS` variable and to the end of the makefile. If your plug-in
    requires additional libraries, you should specify the library names in `$EXTRALIBS`.
    The `$IDA_SDK` variable is used to specify the location of the *<SDKDIR>*, and
    `$IDA_SDK` may be specified as an absolute or a relative path. In this example,
    `$IDA_SDK` is specified as a relative path, indicating that *<SDKDIR>* lies two
    directories above the plug-in’s directory. This is in keeping with locating plug-in
    projects within *<SDKDIR>/plugins* (*<SDKDIR>/plugins/**idabook_plugin* in this
    case). If you choose to locate your plug-in’s project directory in some other
    location relative to *<SDKDIR>*, you must ensure that `$IDA_SDK` properly refers
    to *<SDKDIR>*. Finally, the preceding example is configured to store successfully
    compiled plug-ins in *<SDKDIR>/bin/plugins*. It is important to understand that
    successfully compiling a plug-in does not necessarily install the plug-in. We
    cover plug-in installation in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of Microsoft’s Visual C++ Express to build IDA modules is discussed
    in *install_visual.txt*. To create a project from scratch using Visual Studio
    2008, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** ▸ **New** ▸ **Project** to open the New Project dialog shown
    in [Figure 17-1](ch17s02.html#visual_studio_new_project-creation_dialo "Figure 17-1. Visual
    Studio new project-creation dialog").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Visual Studio new project-creation dialog](httpatomoreillycomsourcenostarchimages854277.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 17-1. Visual Studio new project-creation dialog
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Specify the project type as **Visual C++/Win32**, choose the **Win32 Project**
    template, and provide the name and location for your project. We typically create
    new plug-in projects within the *<SDKDIR>/plugins* directory in order to keep
    all of our plug-ins grouped together. When you click **OK**, the Win32 Application
    Wizard appears. Click **Next** to get to the Application Settings step and then
    set the Application type to **DLL** and the Additional options to **Empty project**
    before clicking **Finish**, as shown in [Figure 17-2](ch17s02.html#visual_studio_win32_application_wizard
    "Figure 17-2. Visual Studio Win32 Application Wizard").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Visual Studio Win32 Application Wizard](httpatomoreillycomsourcenostarchimages854280.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 17-2. Visual Studio Win32 Application Wizard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the basic framework of the project has been created, you must configure
    a few additional settings. Project properties in Visual Studio 2008 are accessed
    via Project ▸ Properties, which brings up the dialog shown in [Figure 17-3](ch17s02.html#visual_studio_project_properties_dialog
    "Figure 17-3. Visual Studio project properties dialog"). C/C++ configuration options
    only become available once a source file has been added to the project, either
    by adding and editing a new file or adding an existing file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Visual Studio project properties dialog](httpatomoreillycomsourcenostarchimages854283.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 17-3. Visual Studio project properties dialog
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The settings that require modification are spread throughout the Configuration
    Properties section at the left side of the dialog. [Figure 17-3](ch17s02.html#visual_studio_project_properties_dialog
    "Figure 17-3. Visual Studio project properties dialog") is representative of the
    manner in which properties are set throughout a project. For each property category
    selected in the left-hand portion of the dialog, a list of configurable properties
    is displayed in the right-hand portion of the dialog. Note that property categories
    are organized in a hierarchical fashion. Properties are edited using file-selection
    controls, single-line edit controls, multiline edit controls, or drop-down-list-selection
    controls. [Table 17-1](ch17s02.html#visual_studio_plug-in_configuration_valu "Table 17-1. Visual
    Studio Plug-in Configuration Values (32-bit)") details the properties that must
    be edited to create a plug-in project.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Visual Studio allows you to specify separate configuration options
    for Debug and Release versions of the project (see top left of [Figure 17-3](ch17s02.html#visual_studio_project_properties_dialog
    "Figure 17-3. Visual Studio project properties dialog")). If you intend to build
    separate Debug and Release versions of your plug-in, make certain that you have
    modified the properties in both configurations. Alternatively, you may save some
    time by selecting All Configurations from the Configurations drop-down list (at
    the top left of the Properties dialog), in which case your property changes will
    be applied to all build configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Table 17-1. Visual Studio Plug-in Configuration Values (32-bit)
  prefs: []
  type: TYPE_NORMAL
- en: '| Configuration Property Category | Specific Property | Property Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| General | Output Directory | As desired, often *<SDKDIR>\bin\plugins* |'
  prefs: []
  type: TYPE_TB
- en: '| C/C++▸General | Additional Include Directories | Add *<SDKDIR>\include* |'
  prefs: []
  type: TYPE_TB
- en: '| C/C++▸Preprocessor | Preprocessor Definitions | Append “;__NT__;__IDP__”
    |'
  prefs: []
  type: TYPE_TB
- en: '| C/C++▸Code Generation | Runtime Library | Multithreaded (Release)^([[a](#ftn.CHP-17-TFN-1)])
    Multithreaded Debug (Debug) (Not the DLL versions)^([[b](#ftn.CHP-17-TFN-2)])
    |'
  prefs: []
  type: TYPE_TB
- en: '| Linker▸General | Output File | Change extension to *.plw* |'
  prefs: []
  type: TYPE_TB
- en: '| Linker▸General | Additional Library Directories | Add *<SDKDIR>\lib\x86_win_vc_32*^([[c](#ftn.CHP-17-TFN-3)])
    |'
  prefs: []
  type: TYPE_TB
- en: '| Linker▸Input | Additional Dependencies | Add *ida.lib* (from *\lib\86_win_vc_32*)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Linker▸Command Line | Additional options | Add */EXPORT:PLUGIN* |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[a](#CHP-17-TFN-1)]) Multithreaded in this case refers to the C++ runtime
    library itself. IDA just happens to be a single-threaded application that makes
    use of this library. A single-threaded version of the C++ runtime library does
    not exist.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[b](#CHP-17-TFN-2)]) Choosing the DLL versions of the C++ library requires
    that *MSVCR80.DLL* be present on the system on which the plug-in will ultimately
    run. In order to remove this restriction, choose the non-DLL version of the C++
    runtime libraries, which produces a statically linked plug-in that is more portable.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[c](#CHP-17-TFN-3)]) Prior to SDK version 6.1, add library directory *<SDKDIR>\lib\vc.w32*.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Plug-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In comparison to the build process, plug-in installation is very simple. Installing
    a plug-in is accomplished by copying the compiled plug-in module to *<IDADIR>/plugins*.
    Note that Windows systems do not allow an executable file that is in use to be
    overwritten. So to install a plug-in on a Windows system, you must ensure that
    any previous version of the plug-in has been unloaded from IDA. Depending on the
    plug-in loading options, a plug-in may be unloaded when a database is closed.
    However, plug-ins that have the `PLUGIN_FIX` flag set may require IDA to be shut
    down entirely before the new plug-in can be copied to *<IDADIR>/plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux and OS X systems, executable files can be overwritten while they are
    in use, so you do not need to ensure that a plug-in is unloaded before installing
    a new version of it. However, the new version of the plug-in will not be loaded
    into IDA until the next time IDA offers plug-ins a chance to load.
  prefs: []
  type: TYPE_NORMAL
- en: Some IDA plug-ins are distributed in binary form only, while others are distributed
    in both source and binary format. Installing such plug-ins usually involves finding
    the proper version of the compiled plug-in for your version of IDA and copying
    that plug-in to *<IDADIR>/plugins*. Make sure that you read the documentation
    (if any!) that accompanies any plug-in that you wish to install, because some
    plug-ins require the installation of additional components in order to function
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Plug-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IDA provides a limited ability to configure plug-ins via settings in *<IDADIR>/plugins/plugins.cfg*.
    Settings in *plugins.cfg* can be used to specify the following information about
    a plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: An alternate menu description for the plug-in. This value overrides the plug-in’s
    `wanted_name` data member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nonstandard location or file extension for the plug-in. By default IDA searches
    for plug-ins in *<IDADIR>/plugins* and expects plug-ins to have a default, platform-specific
    file extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternate or additional hotkey used to activate the plug-in. This value overrides
    the plug-in’s `wanted_hotkey` data member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer value to be passed to the plug-in’s `PLUGIN.run` function each time
    the plug-in is activated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `DEBUG` flag for use with debugger plug-ins. Debugger plug-ins are
    discussed in [Chapter 24](ch24.html "Chapter 24. The IDA Debugger").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax of a valid plug-in configuration line is described in *plugins.cfg*.
    A few examples of plug-in configuration lines are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `wanted_name` and `wanted_hotkey` data members for a plug-in are chosen
    by the plug-in’s author and compiled into the plug-in. It is entirely possible
    that two plug-ins developed by different authors may have identical names or identical
    hotkey associations. Within *plugin.cfg*, the `plugin_name` field specifies the
    text (which overrides `PLUGIN.wanted_name`) to be added to the Edit ▸ Plugins
    menu. It is possible to assign several names—and therefore several menu items—to
    a single plug-in. Underscore characters in the `plugin_name` field are replaced
    with space characters before the name is added to the Edit ▸ Plugins menu.
  prefs: []
  type: TYPE_NORMAL
- en: The `plugin_file` field specifies the name of the compiled plug-in module file
    to which the current configuration line applies. If a full path is specified,
    IDA loads the plug-in from the specified path. If no path is specified, IDA looks
    for the plug-in in *<IDADIR>/plugins*. If no file extension is specified, then
    IDA assumes a default plug-in extension for the current platform. If a file extension
    is specified, IDA searches for an exact match to the plug-in filename.
  prefs: []
  type: TYPE_NORMAL
- en: The `hotkey` field specifies the hotkey that should be used to activate the
    plug-in. This field overrides the value of `PLUGIN.wanted_hotkey` and can be used
    to resolve conflicting hotkey assignments when two plug-ins have been built that
    use the same hotkey for activation. Alternatively, assigning more than one hotkey
    to a plug-in offers the ability to activate a plug-in in more than one way. In
    such cases, it is useful to specify unique integer arguments for `PLUGIN.run`
    depending on which hotkey was used to activate a plug-in. When you pass different
    integer values to `PLUGIN.run`, IDA makes it possible for a plug-in to determine
    exactly how it was activated. This capability is useful when a plug-in implements
    more than one behavior and each behavior is selected based on how the plug-in
    is activated. In the preceding configuration example, IDA passes the integer value
    2 to `idabook_plugin`’s `PLUGIN.run` function whenever the plug-in is activated
    via the alt-F3 hotkey sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Extending IDC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have presented plug-ins designed primarily to manipulate or extract
    information from a database. In this section, we present an example of extending
    the capabilities of the IDC scripting language.^([[117](#ftn.CHP-17-FN-1)]) As
    mentioned in [Chapter 16](ch16.html "Chapter 16. The IDA Software Development
    Kit"), IDC is implemented on top of the IDA API, so it should come as no surprise
    that the API can be used to enhance IDC when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") and [Chapter 16](ch16.html
    "Chapter 16. The IDA Software Development Kit"), you learned that IDC global arrays
    are actually a somewhat restricted abstraction of netnodes. Recall that in IDC
    you create global arrays by supplying a name and receiving an array ID in return.
    Internally your name gets prefixed with the string “$ idc_array ”, and the array
    ID that you receive is actually a netnode index value. How could we go about extending
    IDC in order to enable access to any netnode in an IDA database? We can already
    access any netnode whose index we happen to know by using the index as the array
    ID in IDC, so what we need is the ability to access any netnode whose name we
    happen to know. IDC currently prevents us from doing this because it prepends
    “$ idc_array ” to every netnode name we supply. Enter the SDK and the `set_idc_func_ex`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defined in *expr.hpp*, `set_idc_func_ex` may be used to create a new IDC function
    and map its behavior to C++ implementation. The prototype for `set_idc_func_ex`
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have introduced the `idc_func_t` datatype here in order to simplify
    the code somewhat. This datatype is not defined within the SDK. The arguments
    to `set_idc_func_ex` specify the name of the new IDC function that we are introducing
    (`idc_name`), a pointer to the C++ function that implements our new IDC behavior
    (`idc_impl`), a null-terminated array of characters that specify the argument
    types and sequence for the new IDC function (`args`), and flags (`extfunc_flags`)
    indicating whether an open database is required or whether the function never
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function, used as the initialization function for a plug-in,
    completes the process by creating the new IDC function we are designing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This function creates the new IDC function `CreateNetnode` and maps it to our
    implementation function `idc_create_netnode` ![](httpatomoreillycomsourcenostarchimages854061.png).
    The arguments to the new IDC function are specified as being a single parameter
    of type string (`VT_STR2`) ![](httpatomoreillycomsourcenostarchimages854063.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that actually implements the behavior of `CreateNetnode` is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The two arguments to this function represent the input argument array (`argv`)
    containing all of the parameters to `CreateNetnode` (there should be only one
    in this case) and an output parameter (`res`) used to receive the result of the
    IDC function we are implementing. The SDK datatype `idc_value_t` represents a
    single IDC value. Fields within this datatype indicate the current type of data
    represented by the value and the current contents of the value. The function begins
    by specifying that `CreateNetnode` returns a long (`VT_LONG`) value ![](httpatomoreillycomsourcenostarchimages854061.png).
    Since IDC variables are untyped, we must indicate internally what type of value
    the variable is holding at any given moment. Next, the function verifies that
    the caller of `CreateNetnode` has supplied an argument of type string (`VT_STR2`)
    ![](httpatomoreillycomsourcenostarchimages854063.png). If a valid argument has
    been supplied, a netnode is created with the supplied name ![](httpatomoreillycomsourcenostarchimages854093.png).
    The resulting netnode index number is returned to the caller as the result of
    the `CreateNetnode` function ![](httpatomoreillycomsourcenostarchimages854095.png).
    In this example, the result type is an integer value, so the result is stored
    into the `res->num` field. Had the result type been a string, we would have needed
    to call `res->set_string` to set the string value of the result. If the user fails
    to supply a string argument, the function fails and returns the invalid netnode
    index `−1` ![](httpatomoreillycomsourcenostarchimages854099.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We complete the plug-in with the following functions and `PLUGIN` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The trick to this plug-in is that it loads on IDA startup (`PLUGIN_FIX`) and
    remains hidden from the user because it is not added to the Edit ▸ Plugins menu
    (`PLUGIN_HIDE`) ![](httpatomoreillycomsourcenostarchimages854061.png). The plug-in
    is kept in memory for all databases, and all of the initialization takes place
    in the plug-in’s `init` function. As a result, the plug-in has nothing to do in
    its `run` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this plug-in is installed, an IDC programmer may access any named netnode
    in an IDA database using the netnode’s name, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: More information for using the SDK to interact with IDC is contained in the
    *expr.hpp* header file.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[117](#CHP-17-FN-1)]) Note that there is currently no way to programmatically
    extend the IDAPython API from within a compiled plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-in User Interface Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book makes no pretense at being a user interface development guide. However,
    there are many occasions in which a plug-in will need to interact with an IDA
    user to request or display information. In addition to the API’s `ask`*`XXX`*
    functions mentioned in [Chapter 16](ch16.html "Chapter 16. The IDA Software Development
    Kit"), a few more complex functions are available for user interaction via the
    IDA API. For more adventurous plug-in authors, it is worth remembering that plug-ins
    developed for GUI versions of IDA also have full access to the user interface
    functions that are available in various GUI libraries (Qt or Windows Native).
    Through the use of these functions it is possible to use virtually any type of
    graphical interface element within your plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the SDK’s `ask`*`XXX`* interface functions, things get a little more
    challenging when using the SDK to build user interface elements. One of the reasons
    for this is that the SDK attempts to provide a generic programming interface to
    accomplish the fairly complex task of displaying a GUI element to a user and accepting
    the user’s input.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SDK’s Chooser Dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first two functions that we will discuss are called `choose` and `choose2`.
    Each of these functions, along with various constants used to control its behavior,
    is declared in *kernwin.hpp*. The purpose of each function is to display a list
    of data elements to the user and ask the user to select one or more items from
    the list. The `choose` functions are capable of displaying virtually any type
    of data by virtue of the fact that they require you to specify formatting functions
    that are called to generate each line of text displayed in the chooser window.
    The two functions differ in that `choose` displays a single-column list, while
    `choose2` is capable of displaying a multicolumn list. In the following examples
    we demonstrate the simplest forms of these functions, which rely on many default
    parameters. If you want to explore the full range of capabilities of `choose`
    and `choose2`, please consult *kernwin.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For displaying a single column of information to a user, the simplest form
    of the `choose` function boils down to the following, once default parameters
    are omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `obj` parameter is a pointer to the block of data to be displayed,
    and `width` is the desired column width to be used in the chooser window. The
    `sizer` parameter is a pointer to a function that is capable of parsing the data
    pointed to by `obj` and returning the number of lines required to display that
    data. The `getline` parameter is a pointer to a function that can generate the
    character string representation of a single item selected from `obj`. Note that
    the `obj` pointer can point to any type of data as long as the `sizer` function
    can parse the data to determine the number of lines required to display the data
    and as long as the `getline` function can locate a specific data item using an
    integer index and generate a character string representation of that data item.
    The `title` parameter specifies the title string used in the generated chooser
    dialog. The `choose` function returns the index number (1..*n*) of the user-selected
    item or zero if the dialog was canceled by the user. The code in [Example 17-2](ch17s06.html#example_use_of_the_choose_function
    "Example 17-2. Example use of the choose function"), while not terribly exciting,
    is extracted from a plug-in that demonstrates the use of the `choose` function.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-2. Example use of the `choose` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Activating the plug-in from [Example 17-2](ch17s06.html#example_use_of_the_choose_function
    "Example 17-2. Example use of the choose function") results in the chooser dialog
    shown in [Figure 17-4](ch17s06.html#example_of_the_chooser_dialog "Figure 17-4. Example
    of the chooser dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the chooser dialog](httpatomoreillycomsourcenostarchimages854286.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-4. Example of the chooser dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'The `choose2` function offers a multicolumn variation of the chooser dialog.
    Again, we look at the simplest version of the function, accepting all possible
    default arguments, which boils down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We can observe a few differences between `choose2` and the `choose` function
    we saw earlier. First, the `ncol` parameter specifies the number of columns to
    be displayed, while the `widths` parameter is an array of integers that specify
    the width of each column. The format of the `getline` function changes somewhat
    in `choose2`. Since the `choose2` dialog can contain several columns, the `get-line`
    function must provide data for each column within a single line. The example code
    in [Example 17-3](ch17s06.html#example_use_of_the_choose2_function "Example 17-3. Example
    use of the choose2 function") shows the use of `choose2` in a demonstration plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-3. Example use of the `choose2` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The multicolumn chooser dialog generated using the code from [Example 17-3](ch17s06.html#example_use_of_the_choose2_function
    "Example 17-3. Example use of the choose2 function") is shown in [Figure 17-5](ch17s06.html#example_of_the_choose2_dialog
    "Figure 17-5. Example of the choose2 dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the choose2 dialog](httpatomoreillycomsourcenostarchimages854289.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-5. Example of the `choose2` dialog
  prefs: []
  type: TYPE_NORMAL
- en: Far more complex uses of both the `choose` and the `choose2` functions are possible.
    Each function is capable of creating either modal ^([[118](#ftn.CHP-17-FN-2)])
    or nonmodal dialogs, and each function can generate dialogs that allow for selection
    of multiple items. Also, each function accepts several additional parameters that
    allow you to be notified when various events take place within the dialog. When
    these functions are used to create nonmodal dialogs, the result is a new tabbed
    window displayed alongside the tabs of other IDA display windows, such as the
    Imports window. In fact, IDA’s Imports window is implemented using the `choose2`
    interface. For more information on the capabilities of `choose` and `choose2`,
    please refer to *kernwin.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Customized Forms with the SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For creating more complex user interface elements, the SDK provides the `AskUsingForm_c`
    function. The prototype for this function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The function seems simple enough, yet it is among the more complex user interface
    functions available in the SDK. This complexity is due to the nature of the `form`
    argument, which is used to specify the layout of various user interface elements
    within the custom dialog. `AskUsingForm_c` is similar to `printf` in that the
    `form` argument is essentially a format string that describes the layout of various
    input elements. Where `printf` format strings utilize output format specifiers
    that are replaced with formatted data, `AskUsingForm_c` format strings are composed
    of both output specifiers and form field specifiers that are replaced with instances
    of input elements when the form is displayed. `AskUsingForm_c` recognizes a completely
    different set of output field specifiers than `printf`. These specifiers are detailed
    in *kernwin.hpp* along with complete documentation on the use of `AskUsingForm_c`.
    The basic format of a form field specifier is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual components of a form field specifier are described in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`#hint text#`** This element is optional. If present, the hint text, excluding
    the# characters, is displayed as a tool tip when the mouse hovers over the associated
    input field. |'
  prefs: []
  type: TYPE_TB
- en: '| **`label`** Static text displayed as a label to the left of the associated
    input field. In the case of button fields, this is the button text. |'
  prefs: []
  type: TYPE_TB
- en: '| **`type`** A single character indicates the type of form field being specified.
    Form field types are described following this list. |'
  prefs: []
  type: TYPE_TB
- en: '| **`width`** The maximum number of input characters accepted by the associated
    input field. In the case of button fields, this field specifies an integer button
    identification code used to distinguish one button from another. |'
  prefs: []
  type: TYPE_TB
- en: '| **`swidth`** The display width of the input field. |'
  prefs: []
  type: TYPE_TB
- en: '| **`@hlp[]`** This field is described in *kernwin.hpp* as “the number of help
    screen from the *IDA.HLP* file.” Since the content of this file is dictated by
    Hex-Rays, it seems unlikely that this field will be of use in the majority of
    cases. Substitute a colon for this field in order to ignore it. |'
  prefs: []
  type: TYPE_TB
- en: 'The characters used for the `type` field specify what type of input field will
    be generated when the dialog is realized at runtime. Each type of form field requires
    an associated parameter in the variable arguments portion of the `AskUsingForm_c`
    parameter list. Form field type specifiers and their associated parameter type
    are shown here (as taken from *kernwin.hpp*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: All numeric fields interpret the user-supplied input as an IDC expression that
    is parsed and evaluated when the user clicks the dialog’s OK button. All fields
    require a pointer argument that is used for both input and output. When the form
    is first generated, initial values for all form fields are taken by dereferencing
    the associated pointers. Upon return, the user-supplied form field values are
    written into the associated memory locations. The pointer argument associated
    with a button (`B`) field is the address of a function that will be called if
    the associated button is pressed. The `formcb_t` function is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `code` argument to the button callback represents the code (width) value
    associated with the button that was clicked. By using a switch statement to test
    this code, you can use a single function to process many different buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for specifying radio button and checkbox controls differs slightly
    from the format of other types of form fields. These fields utilize the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Radio buttons and checkboxes may be grouped by listing their specifiers in order
    and denoting the end of the list using the following special format (note the
    extra `>` at the end).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'A radio button (or checkbox) group will be boxed to highlight the group. You
    can give the box a title by utilizing a special format when specifying the first
    element in the group, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to have a box title but do not want to use any hints, the hints
    may be omitted, leaving the following format specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: At this point let’s look at an example of a dialog constructed using `AskUsingForm_c`.
    [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog "Figure 17-6. Sample
    AskUsingForm_c dialog") shows a dialog that we will refer to throughout this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample AskUsingForm_c dialog](httpatomoreillycomsourcenostarchimages854292.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-6. Sample `AskUsingForm_c` dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Format strings used to create `AskUsingForm_c` dialogs are made up of individual
    lines that specify each aspect of the desired dialog. In addition to form field
    specifiers, the format string may contain static text that is displayed, verbatim,
    in the resulting dialog. Finally, the format string may contain a dialog title
    (which must be followed by two carriage returns) and one or more behavior directives
    (such as `STARTITEM`, which specifies the index of the form field that is initially
    active when the dialog is first displayed). The format string used to create the
    dialog in [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog "Figure 17-6. Sample
    AskUsingForm_c dialog") is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'By formatting the dialog specification as we have, one element per line, we
    are attempting to make it easier to map each field specifier to its corresponding
    field in [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog "Figure 17-6. Sample
    AskUsingForm_c dialog"). You may notice that in [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog
    "Figure 17-6. Sample AskUsingForm_c dialog"), all of the text and numeric input
    fields appear as drop-down list controls. In an effort to save you time, IDA populates
    each list with recently entered values whose type matches the type of the associated
    input field. The following plug-in code may be used to display the example dialog
    and process any results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note that when processing radio button and checkbox results, the first button
    in each group is considered button zero.
  prefs: []
  type: TYPE_NORMAL
- en: The `AskUsingForm_c` function provides a considerable amount of power for designing
    user interface elements for your plug-ins. The example here touches on many of
    the capabilities of this function, but many more are detailed in *kernwin.hpp*.
    Please refer to this file for more information on the `AskUsingForm_c` function
    and its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Windows-Only User Interface–Generation Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many developers have wrestled with the problem of creating user interfaces for
    their plug-ins. Plug-ins targeting the Windows-only GUI version of IDA (*idag.exe*)
    have the entire Windows graphical API at their disposal. The author of the mIDA^([[119](#ftn.CHP-17-FN-3)])
    plug-in from Tenable Security developed an alternate approach for creating the
    MDI^([[120](#ftn.CHP-17-FN-4)]) client windows used in the mIDA plug-in. A lengthy
    thread^([[121](#ftn.CHP-17-FN-5)]) on the challenges faced by the mIDA developers
    can be found in the IDA support forums. The thread also contains example code
    that demonstrates their solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ida-x86emu^([[122](#ftn.CHP-17-FN-6)]) plug-in takes a slightly different
    approach in its user interface. This plug-in relies on the fact that a handle
    to IDA’s main window can be obtained using the following SDK code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Using the main IDA window as a parent, ida-x86emu currently makes no attempt
    to integrate into the IDA workspace. All of the plug-in’s dialog interfaces are
    generated using a Windows resource editor, and all user interactions are handled
    using direct calls to Windows API functions. The use of a graphical dialog editor
    in conjunction with direct calls to native Windows API functions provides the
    most powerful user interface–generation capability at the expense of added complexity
    and the additional knowledge required to process Windows messages and work with
    lower-level interface functions.
  prefs: []
  type: TYPE_NORMAL
- en: User Interface Generation with Qt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Qt user interface introduced in IDA 6.0 offers plug-in developers the chance
    to create plug-ins with complex user interfaces capable of being used on all IDA
    platforms. Hex-Rays’ Daniel Pistelli^([[123](#ftn.CHP-17-FN-7)]) discusses some
    of the requirements for using Qt in your plug-ins in a blog post on the Hex-Rays
    blog. See ^([[124](#ftn.CHP-17-FN-8)]) In this section we will reiterate some
    of the important points that Daniel makes as well as point out some additional
    useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to make use of any Qt functionality in your plug-ins, you must
    begin by properly configuring a Qt development environment. IDA 6.1 ships with
    its own versions of the Qt 4.7.2 libraries.^([[125](#ftn.CHP-17-FN-9)]) When Hex-Rays
    builds its Qt libraries, it wraps the libraries in a C++ namespace named `QT`.
    To configure your development environment, obtain the appropriate Qt sources from
    Nokia. The Windows version of *idaq* is built with Visual Studio 2008,^([[126](#ftn.CHP-17-FN-10)])
    and the Linux and OS X versions use g++. The appropriate sources for Windows may
    be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Sources for Linux and OS X can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'See Daniel’s blog post for specific commands to configure your sources. The
    key to proper configuration is the following command-line parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This parameter causes the Qt sources to be wrapped in the `QT` name-space. In
    order to build any Qt-related plug-ins on Windows, you will need link libraries
    (*.lib* files) for each Qt library that you utilize in your plug-in. While IDA
    ships with a number of dynamic link libraries for Qt (see *<IDADIR>* for a complete
    list), the SDK ships with a very limited number of Qt link libraries for Windows
    (notably QtCore4 and QtGui), which may be found in *<SDKDIR>/lib/x86_win_qt*.
    If you need additional link libraries, you will need to link against the libraries
    that you build yourself from the Qt sources. On Linux and OS X, you can link directly
    with the Qt libraries that ship with IDA. On Linux, these can be found in *<IDADIR>*;
    on OS X these can be found in *<IDADIR>/idaq.app/Contents/Frameworks*. Note that
    linking against Qt libraries that don’t ship with IDA will make your plug-in somewhat
    less portable, unless you also distribute those libraries along with your plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'When configuring your Qt plug-in projects, make sure that your `qmake` project
    file contains the following configuration directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'IDA defines a number of functions for safer string handling within the SDK.
    These include functions such as `qstrlen` and `qsnprintf`, which have long been
    part of the SDK. With the move to a Qt-based GUI, this leads to problems because
    Qt also defines several functions named the same as those provided by IDA. The
    IDA functions reside in the global namespace, while the Qt functions reside in
    the `QT` namespace. The IDA versions of such functions can be called by explicitly
    referencing the global namespace as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you need a parent widget for any widgets that you are creating in your
    plug-in, the following statement will obtain a pointer to *idaq*’s top-level application
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This invokes a static method within Qt’s `QApplication` class that returns the
    widget pointer for the sole `QApplication` object in any Qt application.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on configuring your plug-ins to use Qt, refer to Daniel’s
    blog post. Additionally, the qwindow plug-in sample that ships with IDA’s SDK
    provides an example of a plug-in that makes use of Qt. Specifically it contains
    example code that creates an empty widget (using `create_tform`), uses callbacks
    to receive notification that the form is being made visible, obtains a QWidget
    pointer to the newly created form, and finally populates the form with a Qt button
    object. The collabREate and ida-x86emu plug-ins to be discussed in [Chapter 23](ch23.html
    "Chapter 23. Real-World IDA Plug-ins") also make use of Qt GUI elements to allow
    these plug-ins to be used on all IDA capable platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[118](#CHP-17-FN-2)]) A *modal dialog* must be closed before the user is
    allowed to continue interacting with the dialog’s parent application. File open
    and save dialogs are common examples of modal dialogs. Modal dialogs are typically
    used when an application requires information from a user before the application
    can continue execution. On the other hand, nonmodal or modeless dialogs allow
    the user to continue interacting with the parent application while the dialog
    remains open.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[119](#CHP-17-FN-3)]) See [http://cgi.tenablesecurity.com/tenable/mida.php](http://cgi.tenablesecurity.com/tenable/mida.php).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[120](#CHP-17-FN-4)]) The Windows *Multiple Document Interface (MDI)* allows
    multiple child (client) windows to be contained within a single container window.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[121](#CHP-17-FN-5)]) See [http://www.hex-rays.com/forum/viewtopic.php?f=8&t=1660&p=6752](http://www.hex-rays.com/forum/viewtopic.php?f=8&t=1660&p=6752)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[122](#CHP-17-FN-6)]) See [http://www.idabook.com/ida-x86emu](http://www.idabook.com/ida-x86emu)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[123](#CHP-17-FN-7)]) Daniel led the Hex-Rays effort to migrate IDA’s GUI
    to Qt.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[124](#CHP-17-FN-8)]) [http://www.hexblog.com/?p=250](http://www.hexblog.com/?p=250)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[125](#CHP-17-FN-9)]) IDA 6.0 utilized Qt 4.6.3.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[126](#CHP-17-FN-10)]) As a consequence, if you are building a Qt-related
    plug-in on Windows, you must use Visual Studio to build your plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: Scripted Plug-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA 5.6 introduced support for scripted loader modules. In IDA 5.7, support
    was added for scripted plug-ins ^([[127](#ftn.CHP-17-FN-11)]) and processor modules.
    While this does not necessarily allow for the development of more powerful plug-ins,
    it does somewhat lower the barrier to entry for potential plug-in developers and
    allows for a somewhat faster development cycle because the complex build process
    is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Although scripted plug-ins can be created using either IDC or Python, Python
    is probably the most appropriate choice given that it exposes so much of IDA’s
    SDK. Given this fact, there is no reason why Python plug-ins can’t be just as
    powerful as compiled C++ plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Python plug-in is a straightforward process. The primary requirement
    is to define a function named `PLUGIN_ENTRY` that returns an instance of `plugin_t`
    (defined in module `idaapi`). The `plugin_t` class contains members that mirror
    the members of the SDK’s C++ `plugin_t` class. [Example 17-4](ch17s07.html#a_minimal_python_plug-in
    "Example 17-4. A minimal Python plug-in") shows a simple Python plug-in that defines
    a class named `idabook_plugin_t`, which inherits from `plugin_t`; initializes
    all required members; and defines `init`, `term`, and `run` functions that implement
    the plug-in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-4. A minimal Python plug-in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Installation of the plug-in script is accomplished by copying the script to
    *<IDADIR>/plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: The same plug-in written in IDC appears in [Example 17-5](ch17s07.html#a_minimal_idc_plug-in
    "Example 17-5. A minimal IDC plug-in"). Since IDC does not define a plug-in–related
    base class, our obligation is to create a class that defines all the elements
    expected of a plug-in, ensuring that we name each element properly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-5. A minimal IDC plug-in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As with the Python example, the `PLUGIN_ENTRY` function serves to create and
    return an instance of our plug-in class. Installation, once again, involves copying
    the *.idc* file to *<IDADIR>/plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[127](#CHP-17-FN-11)]) See [http://www.hexblog.com/?p=120](http://www.hexblog.com/?p=120)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IDA plug-ins are the logical next step when scripting fails to meet your needs
    for extending IDA’s capabilities, though with the advent of scripted plug-ins,
    you may find yourself resisting the urge to dive into the SDK. Additionally, unless
    you are faced with the challenge of reverse engineering a file format that is
    unknown to IDA or a machine language for which IDA has no processor module, plug-ins
    may be the only type of IDA extension that you ever feel the need to explore.
    Nonetheless, in the next two chapters, we continue to explore the capabilities
    offered by IDA’s SDK by looking at the other types of modules that can be constructed
    for use with IDA: loaders and processor modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18. Binary Files and IDA Loader Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One day word will get out that you have become the resident IDA geek. You may
    relish the fact that you have hit the big time, or you may bemoan the fact that
    from that day forward, people will be interrupting you with questions about what
    some file does. Eventually, either as a result of one such question or simply
    because you enjoy using IDA to open virtually every file you can find, you may
    be confronted with the dialog shown in [Figure 18-1](ch18.html#loading_a_binary_file
    "Figure 18-1. Loading a binary file").
  prefs: []
  type: TYPE_NORMAL
- en: This is IDA’s standard file-loading dialog with a minor problem (from the user’s
    perspective). The short list of recognized file types contains only one entry,
    Binary file, indicating that none of IDA’s installed loader modules recognize
    the format of the file you want to load. Hopefully you will at least know what
    machine language you are dealing with (you do at least know where the file came
    from, right?) and can make an intelligent choice for the processor type, because
    that is about all you can do in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading a binary file](httpatomoreillycomsourcenostarchimages854295.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1. Loading a binary file
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will discuss IDA’s capabilities for helping you make sense
    of unrecognized file types, beginning with manual analysis of binary file formats
    and then using that as motivation for the development of your own IDA loader modules.
  prefs: []
  type: TYPE_NORMAL
- en: Unknown File Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An infinite number of file formats exist for storing executable code. IDA ships
    with loader modules to recognize many of the more common file formats, but there
    is no way that IDA can accommodate the ever-increasing number of formats in existence.
    Binary images may contain executable files formatted for use with specific operating
    systems, ROM images extracted from embedded systems, firmware images extracted
    from flash updates, or simply raw blocks of machine language, perhaps extracted
    from network packet captures. The format of these images may be dictated by the
    operating system (executable files), the target processor and system architecture
    (ROM images), or nothing at all (exploit shellcode embedded in application layer
    data).
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that a processor module is available to disassemble the code contained
    in the unknown binary, it will be your job to properly arrange the file image
    within an IDA database before informing IDA which portions of the binary represent
    code and which portions of the binary represent data. For most processor types,
    the result of loading a file using the binary format is simply a list of the contents
    of the file piled into a single segment beginning at address zero, as shown in
    [Example 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin "Example 18-1. Initial
    lines of a PE file loaded in binary mode").
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1. Initial lines of a PE file loaded in binary mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, depending on the sophistication of the selected processor module,
    some disassembly may take place. This may be the case when a selected processor
    is an embedded microcontroller that can make specific assumptions about the memory
    layout of ROM images. For those interested in such applications, Andy Whittaker
    has created an excellent walk-through^([[128](#ftn.CHP-18-FN-1)]) of reverse engineering
    a binary image for a Siemens C166 microcontroller application.
  prefs: []
  type: TYPE_NORMAL
- en: When faced with binary files, you will almost certainly need to arm yourself
    with as many resources related to the file as you can get your hands on. Such
    resources might include CPU references, operating system references, system design
    documentation, and any memory layout information obtained through debugging or
    hardware-assisted (such as via logic analyzers) analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, for the sake of example we assume that IDA does not
    recognize the Windows PE file format. PE is a well-known file format that many
    readers may be familiar with. More important, documents detailing the structure
    of PE files are widely available, which makes dissecting an arbitrary PE file
    a relatively simple task.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[128](#CHP-18-FN-1)]) See [http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx](http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Manually Loading a Windows PE File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you can find documentation on the format utilized by a particular file,
    your life will be significantly easier as you attempt to map the file into an
    IDA database. [Example 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin
    "Example 18-1. Initial lines of a PE file loaded in binary mode") shows the first
    few lines of a PE file loaded into IDA as a binary file. With no help from IDA,
    we turn to the PE specification,^([[129](#ftn.CHP-18-FN-2)]) which states that
    a valid PE file will begin with a valid MS-DOS header structure. A valid MS-DOS
    header structure in turn begins with the 2-byte signature `4Dh 5Ah` (`MZ`), which
    we see in the first two lines of [Example 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin
    "Example 18-1. Initial lines of a PE file loaded in binary mode").
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point an understanding of the layout of an MS-DOS header is required.
    The PE specification would tell us that the 4-byte value located at offset `0x3C`
    in the file indicates the offset to the next header we need to find—the PE header.
    Two strategies for breaking down the fields of the MS-DOS header are (1) to define
    appropriately sized data values for each field in the MS-DOS header or (2) to
    use IDA’s structure-creation facilities to define and apply an `IMAGE_DOS_HEADER`
    structure in accordance with the PE file specification.^([[130](#ftn.CHP-18-FN-3)])
    Using the latter approach would yield the following modified display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `e_lfanew` field ![](httpatomoreillycomsourcenostarchimages854061.png)
    has a value of `80h`, indicating that a PE header should be found at offset `80h`
    (128 bytes) into the database. Examining the bytes at offset `80h` should reveal
    the magic number for a PE header, `50h 45h` (`PE`), and allow us to build (based
    on our reading of the PE specification) and apply an `IMAGE_NT_HEADERS` structure
    at offset `80h` into the database. A portion of the resulting IDA listing might
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The preceding listings and discussion bear many similarities to the exploration
    of MS-DOS and PE header structures conducted in [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures"). In this case, however, the file has been loaded into IDA
    without the benefit of the PE loader, and rather than being a curiosity as they
    were in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures"), the
    header structures are essential to a successful understanding of the remainder
    of the database.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have revealed a number of interesting pieces of information
    that will help us to further refine our database layout. First, the `Machine`
    ![](httpatomoreillycomsourcenostarchimages854063.png) field in a PE header indicates
    the target CPU type for which the file was built. In this example the value `14Ch`
    indicates that the file is for use with x86 processor types. Had the machine type
    been something else, such as `1C0h` (ARM), we would actually need to close the
    database and restart our analysis, making certain that we select the correct processor
    type in the initial loading dialog. Once a database has been loaded, it is not
    possible to change the processor type in use with that database.
  prefs: []
  type: TYPE_NORMAL
- en: The `ImageBase` ![](httpatomoreillycomsourcenostarchimages854093.png) field
    indicates the base virtual address for the loaded file image. Using this information,
    we can finally begin to incorporate some virtual address information into the
    database. Using the Edit ▸ Segments ▸ Rebase Program menu option, we can specify
    a new base address for the first segment of the program, as shown in [Figure 18-2](ch18s02.html#specifying_a_new_base_address_for_a_prog
    "Figure 18-2. Specifying a new base address for a program").
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying a new base address for a program](httpatomoreillycomsourcenostarchimages854298.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2. Specifying a new base address for a program
  prefs: []
  type: TYPE_NORMAL
- en: In the current example, only one segment exists, because IDA creates only one
    segment to hold the entire file when a file is loaded in binary mode. The two
    checkbox options shown in the dialog determine how IDA handles relocation entries
    when segments are moved and whether IDA should move every segment present in the
    database, respectively. For a file loaded in binary mode, IDA will not be aware
    of any relocation information. Similarly, with only one segment present in the
    program, the entire image will be rebased by default.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddressOfEntryPoint` ![](httpatomoreillycomsourcenostarchimages854095.png)
    field specifies the relative virtual address (RVA) of the program entry point.
    An RVA is a relative offset from the program’s base virtual address, while the
    program entry point represents the address of the first instruction within the
    program that will be executed. In this case an entry point RVA of `1000h` indicates
    that the program will begin execution at virtual address `401000h` (`400000h +
    1000h`). This is an important piece of information, because it is our first indication
    of where we should begin looking for code within the database. Before we can do
    that, however, we need to properly map the remainder of the database to appropriate
    virtual addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The PE format makes use of sections to describe the mapping of file content
    to memory ranges. By parsing the section headers for each section in the file,
    we can complete the basic virtual memory layout of the database. The `NumberOfSections`
    ![](httpatomoreillycomsourcenostarchimages854099.png) field indicates the number
    of sections contained in a PE file; in this case there are four. Referring once
    again to the PE specification, we would learn that an array of section header
    structures immediately follows the `IMAGE_NT_HEADERS` structure. Individual elements
    in the array are `IMAGE_SECTION_HEADER` structures, which we could define in IDA’s
    Structures window and apply (four times in this case) to the bytes following the
    `IMAGE_NT_HEADERS` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss segment creation, two additional fields worth pointing out
    are `FileAlignment` ![](httpatomoreillycomsourcenostarchimages854101.png) and
    `SectionAlignment` ![](httpatomoreillycomsourcenostarchimages854103.png). These
    fields indicate how the data for each section is aligned^([[131](#ftn.CHP-18-FN-4)])
    within the file and how that same data will be aligned when mapped into memory,
    respectively. In our example, each section is aligned to a `200h` byte offset
    within the file; however, when loaded into memory, those same sections will be
    aligned on addresses that are multiples of `1000h`. The smaller `FileAlignment`
    value offers a means of saving space when an executable image is stored in a file,
    while the larger `SectionAlignment` value typically corresponds to the operating
    system’s virtual memory page size. Understanding how sections are aligned can
    help us avoid errors when we manually create sections within our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'After structuring each of the section headers, we finally have enough information
    to begin creating additional segments within the database. Applying an `IMAGE_SECTION_HEADER`
    template to the bytes immediately following the `IMAGE_NT_HEADERS` structure yields
    the first section header and results in the following data displayed in our example
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `Name` ![](httpatomoreillycomsourcenostarchimages854061.png) field informs
    us that this header describes the `.text` section. All of the remaining fields
    are potentially useful in formatting the database, but we will focus on the three
    that describe the layout of the section. The `PointerToRawData` ![](httpatomoreillycomsourcenostarchimages854063.png)
    field (`400h`) indicates the file offset at which the content of the section can
    be found. Note that this value is a multiple of the file alignment value, `200h`.
    Sections within a PE file are arranged in increasing file offset (and virtual
    address) order. Since this section begins at file offset `400h`, we can conclude
    that the first `400h` bytes of the file contain file header data. Therefore, even
    though they do not, strictly speaking, constitute a section, we can highlight
    the fact that they are logically related by grouping them into a section in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: The Edit ▸ Segments ▸ Create Segment command is used to manually create segments
    in a database. [Figure 18-3](ch18s02.html#the_segment-creation_dialog "Figure 18-3. The
    segment-creation dialog") shows the segment-creation dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![The segment-creation dialog](httpatomoreillycomsourcenostarchimages854301.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-3. The segment-creation dialog
  prefs: []
  type: TYPE_NORMAL
- en: When creating a segment, you may specify any name you wish. Here we choose .`headers`,
    because it is unlikely to be used as an actual section name in the file and it
    adequately describes the section’s content. You may manually enter the section’s
    start (inclusive) and end (exclusive) addresses, or they will be filled in automatically
    if you have highlighted the range of addresses that make up the section prior
    to opening the dialog. The section base value is described in the SDK’s *segment.hpp*
    file. In a nutshell, for x86 binaries, IDA computes the virtual address of a byte
    by shifting the segment base left four bits and adding the offset to the byte
    (`virtual = (base << 4) + offset`). A base value of zero should be used when segmentation
    is not used. The segment class can be used to describe the content of the segment.
    Several predefined class names such as `CODE`, `DATA`, and `BSS` are recognized.
    Predefined segment classes are also described in *segment.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: An unfortunate side effect of creating a new segment is that any data that had
    been defined within the bounds of the segment (such as the headers that we previously
    formatted) will be undefined. After reapplying all of the header structures discussed
    previously, we return to the header for the `.text` section to note that the `VirtualAddress`
    ![](httpatomoreillycomsourcenostarchimages854093.png) field (`1000h`) is an RVA
    that specifies the memory address at which the section content should be loaded
    and the `SizeOfRawData` ![](httpatomoreillycomsourcenostarchimages854095.png)
    field (`600h`) indicates how many bytes of data are present in the file. In other
    words, this particular section header tells us that the `.text` section is created
    by mapping the `600h` bytes from file offsets `400h-9FFh` to virtual addresses
    `401000h-4015FFh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our example file was loaded in binary mode, all of the bytes of the
    `.text` section are present in the database; we simply need to shift them into
    their proper locations. Following creation of the `.headers` section, we might
    have a display similar to the following at the end of the `.headers` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: When the `.headers` section was created, IDA split the original `seg000` to
    form the `.headers` section as we specified and a new `seg001` to hold the remaining
    bytes from `seg000`. The content for the `.text` section is resident in the database
    as the first `600h` bytes of `seg001`. We simply need to move the section to the
    proper location and size the `.text` section correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in creating the `.text` section involves moving `seg001` to virtual
    address `401000h`. Using the Edit ▸ Segments ▸ Move Current Segment command, we
    specify a new start address for `seg001`, as shown in [Figure 18-4](ch18s02.html#moving_a_segment
    "Figure 18-4. Moving a segment").
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving a segment](httpatomoreillycomsourcenostarchimages854304.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-4. Moving a segment
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to carve the `.text` section from the first `600h` bytes of
    the newly moved `seg001` using Edit ▸ Segments ▸ Create Segment. [Figure 18-5](ch18s02.html#manual_creation_of_the_.text_section
    "Figure 18-5. Manual creation of the .text section") shows the parameters, derived
    from the section header values, used to create the new section.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the end address is exclusive. Creation of the `.text` section
    splits `seg001` into the new `.text` section and all remaining bytes of the original
    file into a new section named `seg002`, which immediately follows the `.text`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Manual creation of the .text section](httpatomoreillycomsourcenostarchimages854307.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-5. Manual creation of the `.text` section
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the section headers, we now look at the second section, which
    appears as follows once it has been structured as an `IMAGE_SECTION_HEADER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Using the same data fields we examined for the `.text` section, we note that
    this section is named `.rdata`, occupies `200h` bytes in the file beginning at
    file offset `0A00h`, and maps to RVA `2000h` (virtual address `402000h`). It is
    important to note at this point that since we moved the `.text` segment, we can
    no longer easily map the `PointerToRawData` field to an offset within the database.
    Instead, we rely on the fact that the content for the `.rdata` section immediately
    follows the content for the `.text` section. In other words, the `.rdata` section
    currently resides in the first `200h` bytes of `seg002`. An alternative approach
    would be to create the sections in reverse order, beginning with the last section
    defined in the headers and working our way backwards until we finally create the
    `.text` section. This approach leaves sections positioned at their proper file
    offsets until they are moved to their corresponding virtual addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of the `.rdata` section proceeds in a manner similar to the creation
    of the `.text` section. In the first step, `seg002` is moved to `402000h`, and
    in the second step, the actual `.rdata` section is created to span the address
    range `402000h-402200h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section defined in this particular binary is called the `.bss` section.
    A `.bss` section is typically generated by compilers as a place to group all statically
    allocated variables (such as globals) that need to be initialized to zero when
    the program starts. Static variables with nonzero initial values are typically
    allocated in a `.data` (nonconstant) or `.rdata` (constant) section. The advantage
    of a `.bss` section is that it typically requires zero space in the disk image,
    with space being allocated for the section when the memory image of the executable
    is created by the operating system loader. In this example, the `.bss` section
    is specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the section header indicates that the size of the section within the file,
    `SizeOfRawData` ![](httpatomoreillycomsourcenostarchimages854061.png), is zero,
    while the `VirtualSize` ![](httpatomoreillycomsourcenostarchimages854063.png)
    of the section is `0x40` (`64`) bytes. In order to create this section in IDA,
    it is first necessary to create a gap (because we have no file content to populate
    the section) in the address space beginning at address `0x403000` and then define
    the `.bss` section to consume this gap. The easiest way to create this gap is
    to move the remaining sections of the binary into their proper places. When this
    task is complete, we might end up with a Segments window listing similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The right-hand portion of the listing has been truncated for the sake of brevity.
    You may notice that the segment end addresses are not adjacent to their subsequent
    segment start addresses. This is a result of creating the segments using their
    file sizes rather than taking into account their virtual sizes and any required
    section alignment. In order to have our segments reflect the true layout of the
    executable image, we could edit each end address to consume any gaps between segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question marks in the segments list represent unknown values for the permission
    bits on each section. For PE files, these values are specified via bits in the
    `Characteristics` field of each section header. There is no way to specify permissions
    for manually created sections other than by programmatically using a script or
    a plug-in. The following IDC statement sets the execute permission on the `.text`
    section in the previous listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, IDC does not define symbolic constants for each of the allowable
    permissions. Unix users may find it easy to remember that the section permission
    bits happen to correspond to the permission bits used in Unix file systems; thus
    read is 4, write is 2, and execute is 1\. You may combine the values using a bitwise
    `OR` to set more than one permission in a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step that we will cover in the manual loading process is to finally
    get the x86 processor module to do some work for us. Once the binary has been
    properly mapped into various IDA sections, we can return to the program entry
    point that we found in the headers (RVA `1000h`, or virtual address `401000h`)
    and ask IDA to convert the bytes at that location to code. If we wish to have
    IDA list the address as an entry point in the Exports window, we must programmatically
    designate it as such. Here is a Python one-liner to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Called in this manner, IDA will name the entry point `'start'`, add it as an
    exported symbol, and create code at the specified address, initiating a recursive
    descent to disassemble as much related code as possible. Please refer to IDA’s
    built-in help for more information on the `AddEntryPoint` function.
  prefs: []
  type: TYPE_NORMAL
- en: When a file is loaded in binary mode, IDA performs no automatic analysis of
    the file content. Among other things, no attempt is made to identify the compiler
    used to create the binary, no attempt is made to determine what libraries and
    functions the binary imports, and no type library or signature information is
    automatically loaded into the database. In all likelihood, we will need to do
    a substantial amount of work to produce a disassembly comparable to those we have
    seen IDA generate automatically. In fact, we have not even touched on other aspects
    of the PE headers and how we might incorporate such additional information into
    our manual loading process.
  prefs: []
  type: TYPE_NORMAL
- en: In rounding out our discussion of manual loading, consider that you would need
    to repeat each of the steps covered in this section every time you open a binary
    with the same format, one unknown to IDA. Along the way, you might choose to automate
    some of your actions by writing IDC scripts that perform some of the header parsing
    and segment creation for you. This is exactly the motivation behind and the purpose
    for IDA loader modules, which are covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[129](#CHP-18-FN-2)]) See [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)
    (EULA acceptance required).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[130](#CHP-18-FN-3)]) Refer to [Using Standard Structures](ch08s05.html "Using
    Standard Structures") in [Using Standard Structures](ch08s05.html "Using Standard
    Structures") for a discussion on adding these structure types in IDA.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[131](#CHP-18-FN-4)]) Alignment describes the starting address or offset
    of a block of data. The address or offset must be an even multiple of the alignment
    value. For example, when data is aligned to a `200h-` (`512-`) byte boundary,
    it must begin at an address (or offset) that is evenly divisible by `200h`.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Loader Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA relies on loader modules to perform the grunt work of creating the initial
    layout of new databases. Loaders are utilized when a user chooses to open a new
    file, and the loader’s job is to read the input file into the newly created database,
    create sections according to the structure of the input file, and generally organize
    the layout of the database prior to passing control to the processor module, whose
    job it is to perform any disassembly-related tasks. Once a database has been created,
    IDA may invoke special functions in the original loader in order to handle the
    movement of database segments and in order to produce an EXE file (File ▸ Produce
    File ▸ Create EXE File).
  prefs: []
  type: TYPE_NORMAL
- en: The loading process begins when a user chooses to open a new file (loaders are
    not used to load existing databases). Like plug-ins, loaders may be built as shared
    library components using the IDA SDK. Loaders were the first of IDA’s extension
    modules capable of being implemented using scripts (introduced in IDA 5.6).
  prefs: []
  type: TYPE_NORMAL
- en: Once a new binary has been selected, IDA loads, in a dynamic library sense,
    each loader module in the *<IDADIR>/loaders* directory and asks each module to
    examine the binary. All loaders that recognize the format of the new file are
    listed in the file-loading dialog, and it is up to the user to decide which loader
    should be used to load the file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an IDA Loader Using the SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA’s principle interface to any loader module takes place via a global `loader_t`
    object that each loader must declare and export. The `loader_t` struct is analogous
    to the `plugin_t` class used in plug-in modules. The following listing shows the
    layout of the `loader_t` struct as defined in *loader.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: As with the `plugin_t` class, the behavior of a `loader_t` object is defined
    by the functions (created by the loader’s author) to which its members point.
    Every loader must export a `loader_t` object named `LDSC` (*loader description*).
    Exporting your `LDSC` object is handled by *loader.hpp*, which leaves you responsible
    only for declaring and initializing the actual object. Note that several of the
    functions accept an input parameter of type `linput_t` (*loader input type*).
    An `linput_t` is an internal SDK class that provides a compiler-independent wrapper
    around the C standard `FILE` type. Functions implementing standard input operations
    for `linput_t` are declared in *diskio.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since successful loader creation relies on properly initializing the `LDSC`
    object, the purpose of each member is described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`version`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member serves the same purpose as the `version` member of the `plugin_t`
    class. Please refer to its description in [Chapter 17](ch17.html "Chapter 17. The
    IDA Plug-in Architecture").
  prefs: []
  type: TYPE_NORMAL
- en: '**`flags`**'
  prefs: []
  type: TYPE_NORMAL
- en: The only flag recognized for loaders is `LDRF_RELOAD`, defined in *loader.hpp*.
    For many loaders assigning zero to this field will be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**`accept_file`**'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this function is to provide basic recognition of a newly selected
    input file. This function should utilize the provided `linput_t` object to read
    enough information from a file to determine whether the loader can parse the given
    file. If the file is recognized, the loader should copy the file format name into
    the `fileformatname` output buffer. The function should return 0 if the file format
    is not recognized or nonzero if the format is recognized. `OR`ing the return value
    with the `ACCEPT_FIRST` flag requests that IDA list this loader first in the load-file
    dialog. When several loaders indicate `ACCEPT_FIRST`, the last loader queried
    will be listed first.
  prefs: []
  type: TYPE_NORMAL
- en: '**`load_file`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is another function pointer. IDA calls the associated function if
    the user chooses your loader to load the newly selected file. The function receives
    an `linput_t` object that should be used to read the selected file. The `neflags`
    parameter contains a bitwise `OR` of various `NEF_`*`XXX`* flags defined in *loader.hpp*.
    Several of these flags reflect the state of various checkbox settings from the
    load-file dialog. The `load_file` function is responsible for any required parsing
    of the input file content and loading and mapping some or all of the file content
    into the newly created database. If an unrecoverable error condition is recognized,
    `load_file` should call `loader_failure` to terminate the loading process.
  prefs: []
  type: TYPE_NORMAL
- en: '**`save_file`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member optionally points to a function capable of producing an executable
    file in response to the File ▸ Produce File ▸ Create EXE File command. Strictly
    speaking, the use of EXE here is a bit of a misnomer, because your `save_file`
    implementation could choose to generate any type of file that you wish. Since
    the loader is responsible for mapping a file into a database, it may also have
    the capability to map the database back into a file. In practice, the loader may
    not have loaded enough information from the original input file to be able to
    generate a valid output file based on database content alone. For example, the
    PE file loader supplied with IDA cannot regenerate an EXE file from a database
    file. If your loader is not capable of generating an output file, then you should
    set the `save_file` member to NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '**`move_segm`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is a pointer to a function that is called when a user attempts to
    move a segment within a database that was loaded with this loader. Since the loader
    may be aware of relocation information contained in the original binary, this
    function may be able to take relocation information into account as the segment
    is moved. This function is optional, and the pointer should be set to NULL if
    the function is not required (for example, when there are no relocated or fixed-up
    addresses in this file format).
  prefs: []
  type: TYPE_NORMAL
- en: '**`init_loader_options`**'
  prefs: []
  type: TYPE_NORMAL
- en: This member is a pointer to a function whose purpose is to set user-specified
    options via the wizard base-loading process available via File ▸ New. This function
    is useful only in the Windows native GUI version of IDA (idag) because this is
    the only version of IDA that offers these wizards. This function is called once
    a user has chosen a loader, prior to calling `load_file`. If the loader requires
    no configuration prior to the call to `load_file`, this member pointer may be
    set safely to NULL.
  prefs: []
  type: TYPE_NORMAL
- en: The `init_loader_options` function deserves additional explanation. It is important
    to understand that if File ▸ Open is used to open a file, this function will never
    be called. In more sophisticated loaders, such as IDA’s PE loader, this function
    is used to initialize XML-based wizards that step the user through the loading
    process. The XML templates for several wizards are stored in *<IDADIR>/cfg*; however,
    other than the existing templates, no documentation exists for creating your own
    wizard templates.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this chapter, we will develop two example loaders in order
    to review some commonly used loader operations.
  prefs: []
  type: TYPE_NORMAL
- en: The Simpleton Loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to demonstrate the basic operation of an IDA loader, we introduce
    the completely fictitious *simpleton* file format as defined by the following
    C struct (all values are little-endian):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The file format is very straightforward: a magic number file identifier and
    two integers describing the structure of the file, followed by all of the code
    contained in the file. Execution of the file begins with the first byte in the
    `code` block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hexdump of a small simpleton file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Several sample loaders are included with the SDK and may be found in the *<SDKDIR>/ldr*
    directory. We elect to build our loaders in individual subdirectories alongside
    the example loaders. In this case we are working in *<SDKDIR>/ldr/simpleton*.
    Our loader begins with the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The *idaldr.h* header file is a convenience file, included with the SDK (*<SDKDIR>/ldr/idaldr.h*),
    which includes several other header files and defines several macros, all of which
    are commonly used in loader modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next order of business is to declare the required `LDSC` object, which
    points to the various functions that implement our loader’s behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions used in this loader are described in the order in which they
    might be invoked, beginning with the `accept_simpleton_loader` function shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The entire purpose of this function is to determine whether the file being opened
    appears to be a simpleton file. The `n` parameter is a counter that indicates
    the number of times that our `accept_file` function has been called during the
    current loading process. The intent of this parameter is to allow a loader to
    recognize multiple related file formats. IDA will invoke your `accept_file` function
    with increasing values of `n` until your function returns 0\. For each unique
    format that your loader recognizes, you should fill in the `fileformatname` array
    and return nonzero. In this case, we elect to ignore anything other than the first
    call (when `n` is zero) by immediately returning 0\. The `lread4bytes` function,
    defined in *diskio.hpp*, is used to read the 4-byte magic number, and it returns
    0 if the read completed successfully. A useful feature of `lread4bytes` is its
    ability to read bytes in either big-endian or little-endian format, depending
    on the value of its Boolean third parameter (`false` reads little-endian; `true`
    reads big-endian). This feature can help reduce the number of calls to byte-swapping
    functions required during the loading process. If the required magic number is
    located, the final step in `accept_simpleton_file` is to copy the name of the
    file format into the `fileformatname` output parameter prior to returning 1 to
    indicate that the file format was recognized.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the simpleton loader, no special processing is required if a user chooses
    to load a simpleton file using File ▸ New rather than File ▸ Open, so no `init_loader_options`
    function is required. Therefore, the next function called in the loading sequence
    will be `load_simpleton_file`, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The bulk of the loading process takes place in a loader’s `load_file` function.
    Our simple loader performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the simpleton header from the file using `lread` from *diskio.hpp*. The
    `lread` function is very similar to the POSIX `read` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the code section from the file into the proper address space within the
    database using `file2base` from *loader.hpp*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new database segment containing the newly loaded bytes using `add_segm`
    from *segment.hpp*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify 32-bit addressing on our new code segment by calling `getseg` and `set_segm_addressing`
    from *segment.hpp*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a database header comment using `create_filename_cmt` from *loader.hpp*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a program entry point using `add_entry`, from *entry.hpp*, to provide the
    processor module with a starting point for the disassembly process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `file2base` function is a workhorse function for loaders. Its prototype
    appears here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This function reads bytes from the provided `linput_t` beginning at the file
    position specified by `pos`. The bytes are loaded into the database beginning
    at address `ea1`, up to but not including `ea2`. The total number of bytes read
    is calculated as `ea2-ea1`. The `patchable` parameter indicates whether IDA should
    maintain an internal mapping of file offsets to their corresponding locations
    in the database. To maintain such a mapping, this parameter should be set to `FILEREG_PATCHABLE`,
    which allows for the generation of IDA DIF files, as discussed in [Chapter 14](ch14.html
    "Chapter 14. Patching Binaries and Other IDA Limitations").
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add_entry` function is another important function in the loading process.
    The disassembly process can begin only with addresses known to contain instructions.
    For a recursive descent disassembler, such addresses are generally obtained by
    parsing a file for entry points (such as exported functions). The prototype for
    `add_entry` appears here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The `ord` parameter is useful for exported functions that may be exported by
    ordinal number in addition to function name. If the entry point has no associated
    ordinal number, `ord` should be set to the same value as the `ea` parameter. The
    `ea` parameter specifies the effective address of the entry point, while the `name`
    parameter specifies the name associated with the entry point. The symbolic name
    `_start` is often applied to a program’s initial execution address. The boolean
    `makecode` parameter specifies whether the specified address is to be treated
    as code (true) or not (false). Exported data items, such as `LDSC` within a loader
    module, are examples of noncode entry points.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final function that we have implemented in the simpleton loader, `save_simpleton_file`,
    is used to create a simpleton file from the database contents. Our implementation
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: A `loader_t`’s `save_file` function receives a `FILE` stream pointer, `fp`,
    to which the function should write its output. The `fileformatname` parameter
    is the same name filled in by the loader’s `accept_file` function. As mentioned
    earlier, the `save_file` function is called in response to IDA’s File ▸ Produce
    File ▸ Create EXE File command. In response to this command, IDA initially calls
    `save_file` with `fp` set to NULL. When called in this manner, `save_file` is
    being queried as to whether it can produce an output file of the type specified
    by `fileformatname`, in which case `save_file` should return 0 if it cannot create
    the specified file type or 1 if it can create the specified file. For example,
    the loader may be able to create a valid output file only if specific information
    is present within the database.
  prefs: []
  type: TYPE_NORMAL
- en: When called with a valid (non-NULL) `FILE` pointer, `save_file` should write
    a valid output file representation to the provided `FILE` stream. In such cases,
    IDA creates the `FILE` stream after presenting the user with a File Save dialog.
  prefs: []
  type: TYPE_NORMAL
- en: IDA AND FILE POINTERS
  prefs: []
  type: TYPE_NORMAL
- en: 'If you develop modules for Windows versions of IDA, a very important aspect
    of the behavior of an IDA `FILE` stream is noted in *fpro.h* and results from
    the fact that IDA’s core DLL, *ida_wll.dll*, is built using Borland tools. In
    short, Borland `FILE` pointers may not be shared between program modules, and
    any attempt to do so is likely to result in an access violation, potentially crashing
    IDA. To work around this problem, IDA offers a complete set of wrapper functions
    in the form of `qfxxx` (such as qfprintf declared in *fpro.h*) alternatives to
    the standard C-style `FILE` manipulation routines (such as `fprintf`). A word
    of caution when using these functions, however, is that the `qfxxx` functions
    do not always utilize the same parameters as their C-style counterparts (`qfwrite`
    and `fwrite`, for example). If you wish to use the C-style `FILE` manipulation
    functions, you must remember the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: You must define the `USE_STANDARD_FILE_FUNCTIONS` macro prior to including *fpro.h*
    in your module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must not mix IDA-provided `FILE` pointers with the C library `FILE` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must not mix `FILE` pointers obtained from the C library functions with
    IDA’s `qfxxx` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning to the `save_simpleton_file` function, the only truly interesting
    function used in implementing our `save_file` capability is the `base2file` function,
    which is the output counterpart to the `file2base` function used in `load_simpleton_file`.
    The `base2file` function simply writes a range of database values to a specified
    position within a supplied `FILE` stream.
  prefs: []
  type: TYPE_NORMAL
- en: While the simpleton file format borders on useless, it does serve one purpose,
    namely that it has allowed us to demonstrate the core functionality of IDA loader
    modules. The source code for the simpleton loader may be found on the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Building an IDA Loader Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process for building and installing an IDA loader module is virtually identical
    to the process for building an IDA plug-in module as discussed in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture"), with only a few minor differences.
    First, the file extensions used for loaders are *.ldw/.l64* on Windows, *.llx/.llx64*
    on Linux platforms, and *.lmc/.lmc64* on OS X. Second, this is a matter of personal
    preference, but when we build loaders, we store the newly created loader binaries
    into *<SDKDIR>/bin/loaders*. Third, loader modules are installed by copying the
    compiled loader binary to *<IDADIR>/loaders*. The plug-in makefile presented in
    [Example 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins "Example 17-1. A
    sample makefile for IDA plug-ins") is easily adapted to build the simpleton loader
    by changing the `PLUGIN_EXT` variable to a `LOADER_EXT` variable that reflects
    the proper loader file extensions for each IDA platform, changing all references
    to `idabook_plugin` to `simpleton`, and changing the `OUTDIR` variable to point
    to `$(IDA)/bin/loaders`.
  prefs: []
  type: TYPE_NORMAL
- en: A pcap Loader for IDA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Granted, the majority of network packets do not contain code that can be disassembled.
    However, if the packets happen to contain evidence of an exploit, the packets
    may contain binary code that might require disassembly for proper analysis. In
    order to demonstrate that IDA loaders can be used for many purposes, we now describe
    the construction of a loader capable of loading a pcap^([[132](#ftn.CHP-18-FN-5)])
    format packet-capture file into an IDA database. While this may be somewhat over
    the top, along the way we will demonstrate several more capabilities of IDA’s
    SDK. No attempt is made here to match the capabilities of tools such as Wireshark^([[133](#ftn.CHP-18-FN-6)])
    in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The development process for such a loader requires some research into the pcap
    file format, which reveals that a pcap file is structured with the following rough
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: A `pcap_file_header` contains a 32-bit magic number field, as well as other
    fields describing the content of the file, including the type of packets contained
    in the file. For the sake of simplification, we assume here that we are dealing
    only with `DLT_EN10MB` (10Mb Ethernet packets). In developing the pcap loader,
    one of our goals is to identify as much header data as possible in order to help
    users focus on packet content, particularly at the application layer. Our approach
    for accomplishing this goal is (1) to separate the file header from the packet
    data by creating a separate segment for each and (2) to identify as many header
    structures as possible with the packets segment so that the user does not need
    to manually parse the file content. The discussion that follows focuses only on
    the `load_file` component of the pcap loader, because the `accept_file` function
    is a simple adaptation of the `accept_simpleton_file` function changed to recognize
    the pcap magic number.
  prefs: []
  type: TYPE_NORMAL
- en: In order to highlight header structures, we will need to have some commonly
    used structures defined in the IDA Structures window during the loading phase.
    This allows the loader to automatically format groups of bytes as structures when
    the datatype for those bytes is known. Pcap header structures and various networking-related
    structures describing Ethernet, IP, TCP, and UDP headers are defined in IDA’s
    GNU C++ Unix type library; however, in versions of IDA prior to 5.3, the definition
    for the IP header struct (`iphdr`) is incorrect. The first step that `load_pcap_file`
    takes is to call a helper function we have written named `add_types` to take care
    of importing structures into the new database. We examine two possible versions
    of `add_types`, one that makes use of the types declared in IDA’s GNU C++ Unix
    type library and another version in which `add_types` takes care of all required
    structure declarations by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version loads the GNU C++ Unix type library and then pulls type identifiers
    from the newly loaded type library. This version of `add_types` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The `add_til` functions defined in *typinf.hpp* are used to load an existing
    type library file into a database. The `add_til` function was deprecated in favor
    of `add_til2` with the introduction of IDA version 5.1\. These functions are the
    SDK equivalent of loading a *.til* file using the Types window discussed in [Chapter 8](ch08.html
    "Chapter 8. Datatypes and Data Structures"). Once a type library has been loaded,
    the `til2idb` function may be utilized to import individual types into the current
    database. This is the programmatic equivalent of adding a standard structure to
    the Structures window, which was also described in [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures"). The `til2idb` function returns a type identifier that is
    required whenever we want to convert a range of bytes into a specific structured
    datatype. We have chosen to save these type identifiers into global variables
    (each of type `tid_t`) in order to provide faster access to types later in the
    loading process.
  prefs: []
  type: TYPE_NORMAL
- en: Two drawbacks to this first version of `add_types` are the fact that we need
    to import an entire type library just to gain access to six datatypes and, as
    mentioned previously, the built-in IDA definition of a structure may be incorrect,
    which would lead to problems when we attempt to apply these structures later in
    the loading process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second version of `add_types` demonstrates the process of building a type
    library on the fly by parsing actual C-style structure declarations. This version
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, a temporary, empty type library is created using the `new_til`
    function. The new type library is populated by parsing a string (`pcap_types`)
    that contains valid C structure definitions for the types required by the loader.
    The first few lines of the `pcap_types` string are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The declaration of `pcap_types` continues and includes structure definitions
    for all of the structures required by the pcap loader. In order to simplify the
    parsing process, we elected to change all data declarations used within the structure
    definitions to make use of standard C datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: The `HTI_PAK1` constant is defined in *typeinf.hpp* and is one of many `HTI_`*`XXX`*
    values that may be used to control the behavior of the internal C parser. In this
    case, structure packing on a 1-byte boundary is being requested. Following modification,
    a type library is expected to be sorted using `sort_til`, at which point it is
    ready to use. The `import_type` function pulls the requested structure type from
    the specified type library into the database in a manner similar to `til2idb`.
    In this version, again we save the returned type identifier into global variables
    for use later in the loading process. The function completes by deleting the temporary
    type library using the `free_til` function to release the memory consumed by the
    type library. In this version of `add_types`, unlike the first version, we have
    complete control over the datatypes that we choose to import into the database,
    and we have no need to import entire libraries of structures that we have no intention
    of using.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, it is also possible to save the temporary type library file to
    disk using the `store_til` function (which should be preceded by a call to `compact_til`).
    With so few types to construct, this has little benefit in this case, because
    it is just as easy to build the structures each time the loader is executed as
    it is to build and distribute a special-purpose type library that must be properly
    installed and in the end does not save a significant amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning our attention to the `load_pcap_file` function, we see the call to
    `add_types` to initialize the datatypes, as discussed previously; the creation
    of a file comment; followed by loading the pcap file header into the database,
    creating a section around the header bytes, and transforming the header bytes
    into a `pcap_file_header` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we see the use of `file2base` to load content from the newly opened
    disk file into the database. Once the pcap file header content has been loaded,
    it gets its own section in the database, and the `pcap_file_header` structure
    is applied to all of the header bytes using the `doStruct` function, declared
    in *bytes.hpp*, which is the SDK equivalent of using Edit ▸ Struct Var to convert
    a contiguous block of bytes into a structure. The `doStruct` function expects
    an address, a size, and a type identifier, and it converts size bytes at the given
    address into the given type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load_pcap_file` function continues by reading all of the packet content
    and creating a single `.packets` section around the packet content, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `mem2base` function is new and utilized to transfer
    content that has already been loaded into memory into the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load_pcap_file` function concludes by applying structure templates wherever
    possible throughout the database. We must apply structure templates after creating
    the segment; otherwise the act of creating the segment will remove all applied
    structure templates, negating all of our hard work. The third and final portion
    of the function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code simply steps through the database, one packet at a time,
    and examines a few fields within each packet header in order to determine both
    the type of structure to be applied and the location of the start of that structure.
    The following output represents the first few lines of a pcap file that has been
    loaded into a database using the pcap loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Applying structure templates in this manner, we can expand and collapse any
    header to show or hide its individual member fields. As displayed, it is fairly
    easy to observe that the byte at address `0000005E` is the first byte of an HTTP
    response packet.
  prefs: []
  type: TYPE_NORMAL
- en: Having a basic loading capability for pcap files lays the groundwork for developing
    plug-ins that perform more sophisticated tasks, such as TCP stream reassembly
    and various other forms of data extraction. Additional work could go into formatting
    various networking-related structures in a more user-friendly manner, such as
    displaying readable versions of an IP address and hosting byte-ordered displays
    for other fields within each header. Such improvements are left as challenges
    to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[132](#CHP-18-FN-5)]) See [http://www.tcpdump.org/](http://www.tcpdump.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[133](#CHP-18-FN-6)]) See [http://www.wireshark.org/](http://www.wireshark.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Loader Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you spend some time browsing the example loaders included with the SDK,
    you will find several different styles of loaders. One loader worth pointing out
    is the Java loader (*<SDKDIR>/ldr/javaldr*). For some file formats, the coupling
    between the loader and the processor module is very loose. Once the loader makes
    note of entry points into the code, the processor module needs no additional information
    in order to properly disassemble the code. Some processor modules may require
    substantially more information about the original input file and may be required
    to perform much of the same parsing that was previously completed by the loader.
    In order to avoid such duplication of effort, a loader and a processor may be
    paired in a much more tightly coupled manner. In fact, the approach taken in the
    Java loader is essentially to push all loading tasks (those that would usually
    take place in the loader’s `load_file` function) into the processor module using
    code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In the Java loader, the only work that takes place is to verify that the processor
    type is set to the Java processor, at which point the loader sends a `ph.loader`
    (defined in *idp.hpp*) notification message to the processor module to inform
    the processor that the loading phase has been initiated. Upon receipt of the notification,
    the Java processor takes over the responsibility for loading, and in the process
    it derives a significant amount of internal state information that will be reused
    when the processor is directed to perform its disassembly tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Whether this strategy makes sense for you depends entirely on if you are developing
    both a loader and an associated processor module and if you feel that the processor
    would benefit from access to the information traditionally derived within the
    loader (segmentation, file header fields, debugging information, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Another means to pass state information from the loader to the processor module
    involves the use of database netnodes. During the loading phase, the loader may
    choose to populate specific netnodes with information that can later be retrieved
    by the processor module during the disassembly phase. Note that frequently accessing
    the database to retrieve information stored in this manner may be somewhat slower
    than utilizing available C++ datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Scripted Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In IDA 5.6 Hex-Rays introduced the capability to implement loaders using Python
    or IDC scripts. In the Hex Blog posting announcing this new capability,^([[134](#ftn.CHP-18-FN-7)])
    Elias Bachaalany of Hex-Rays describes a loader, implemented in Python, used to
    load a particular type of malicious *.pdf* file containing shellcode. The nature
    of malicious *.pdf* files is such that the loader does not generalize across all
    *.pdf* files, but the loader is an excellent example of how to load unsupported
    file formats in IDA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scripted loaders may be implemented in either IDC or Python and require at
    least two functions, `accept_file` and `load_file`, which perform functions similar
    to those previously described for SDK-based loaders. An IDC-based loader for the
    Simpleton file format is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Other than the use of IDC functions in place of SDK functions, the similarities
    between the IDC version of the simpleton loader and the C++ version presented
    earlier should be fairly obvious. Loader scripts are installed by copying them
    to *<IDADIR>/loaders*.
  prefs: []
  type: TYPE_NORMAL
- en: Python may also be used to develop loaders and allows for more robust development
    because it offers much greater access to IDA’s underlying SDK. Implemented in
    Python, the simpleton loader might look something like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: One of the greatest strengths of scripting loaders (and plug-ins for that matter)
    is that they allow for rapid prototyping of modules that might eventually be implemented
    using the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[134](#CHP-18-FN-7)]) See [http://www.hexblog.com/?p=110](http://www.hexblog.com/?p=110).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have developed an understanding of how loaders fit into IDA’s modular
    architecture, you should find that loader modules are no more difficult to create
    than plug-in modules. Loaders clearly have their own particular subset of the
    SDK that they rely heavily on, the majority of which resides in *loader.hpp*,
    *segment.hpp*, *entry.hpp*, and *diskio.hpp*. Finally, since loaders execute before
    the processor module has a chance to analyze the newly loaded code, loaders should
    never bother themselves with any disassembly tasks, such as dealing with functions
    or disassembled instructions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we round out our discussion of IDA modules with an introduction
    to processor modules, the components most responsible for the overall formatting
    of a disassembled binary.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19. IDA Processor Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last type of IDA modules that can be built with the SDK are processor modules,
    which are by far the most complex of IDA’s module types. Processor modules are
    responsible for all of the disassembly operations that take place within IDA.
    Beyond the obvious conversion of machine language opcodes into their assembly
    language equivalents, processor modules are also responsible for tasks such as
    creating functions, generating cross-references, and tracking the behavior of
    the stack pointer. As it has done with plug-ins and loaders, Hex-Rays has made
    it possible (beginning with IDA 5.7) to author processor modules using one of
    IDA’s scripting languages.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious case that would require development of a processor module is reverse
    engineering a binary for which no processor module exists. Among other things,
    such a binary might represent firmware images for embedded microcontrollers or
    executable images pulled from handheld devices. A less-obvious use for a processor
    module might be to disassemble the instructions of a custom virtual machine embedded
    within an obfuscated executable. In such cases, an existing IDA processor module
    such as the `pc` module for x86 would help you understand only the virtual machine
    itself; it would offer no help at all in disassembling the virtual machine’s underlying
    byte code. Rolf Rolles demonstrated just such an application of a processor module
    in a paper posted to [OpenRCE.org](http://openrce.org).^([[135](#ftn.CHP-19-FN-1)])
    In [Appendix B](apb.html "Appendix B. IDC/SDK Cross-Reference") of his paper,
    Rolf also shares his thoughts on creating IDA processor modules; this is one of
    the few documents available on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of IDA modules, there are an infinite number of conceivable uses
    for plug-ins, and after scripts, plug-ins are by far the most commonly available
    third-party add-ons for IDA. The need for custom loader modules is far smaller
    than the need for plug-ins. This is not unexpected, as the number of binary file
    formats (and hence the need for loaders) tends to be much smaller than the number
    of conceivable uses for plug-ins. A natural consequence is that outside of modules
    donated to and distributed with IDA, there tend to be relatively few third-party
    loader modules published. Smaller still is the need for processor modules, as
    the number of instruction sets requiring decoding is smaller than the number of
    file formats that make use of those instruction sets. Here again, this leads to
    an almost complete lack of third-party processor modules other than the few distributed
    with IDA and its SDK. Judging by the subjects of posts to the Hex-Rays forums,
    it is clear that people are working on processor modules; these modules are simply
    not being released to the public.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we hope to shed additional light on the topic of creating IDA
    processor modules and help to demystify (at least somewhat) the last of IDA’s
    modular components. As a running example, we will develop a processor module to
    disassemble Python byte code. Since the components of a processor module can be
    lengthy, it will not be possible to include complete listings of every piece of
    the module. The complete source code for the Python processor module is available
    on the book’s companion website. It is important to understand that without the
    benefit of a Python loader module, it will not be possible to perform fully automated
    disassembly of compiled *.pyc* files. Lacking such a loader, you will need to
    load *.pyc* files in binary mode, select the Python processor module, identify
    a likely starting point for a function, and then convert the displayed bytes to
    Python instructions using Edit ▸ Code.
  prefs: []
  type: TYPE_NORMAL
- en: Python Byte Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python^([[136](#ftn.CHP-19-FN-2)]) is an object-oriented, interpreted programming
    language. Python is often used for scripting tasks in a manner similar to Perl.
    Python source files are commonly saved with a *.py* extension. Whenever a Python
    script is executed, the Python interpreter compiles the source code to an internal
    representation known as *Python byte code*.^([[137](#ftn.CHP-19-FN-3)]) This byte
    code is ultimately interpreted by a virtual machine. This entire process is somewhat
    analogous to the manner in which Java source is compiled to Java byte code, which
    is ultimately executed by a Java virtual machine. The primary difference is that
    Java users must explicitly compile their Java source into Java byte code, while
    Python source code is implicitly converted to byte code every time a user elects
    to execute a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid repeated translations from Python source to Python byte code,
    the Python interpreter may save the byte code representation of a Python source
    file in a *.pyc* file that may be loaded directly on subsequent execution, eliminating
    the time spent in translating the Python source. Users typically do not explicitly
    create *.pyc* files. Instead, the Python interpreter automatically creates *.pyc*
    files for any Python source module that is imported by another Python source module.
    The theory is that modules tend to get reused frequently, and you can save time
    if the byte code form of the module is readily available. Python byte code (*.pyc*)
    files are the rough equivalent of Java *.class* files.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the Python interpreter does not require source code when a corresponding
    byte code file is available, it may be possible to distribute some portions of
    a Python project as byte code rather than as source. In such cases, it might be
    useful to reverse engineer the byte code files in order to understand what they
    do, just as we might do with any other binary software distribution. This is the
    intended purpose of our example Python processor module—to provide a tool that
    can assist in reverse engineering Python byte code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[135](#CHP-19-FN-1)]) See “Defeating HyperUnpackMe2 With an IDA Processor
    Module” at [http://www.openrce.org/articles/full_view/28](http://www.openrce.org/articles/full_view/28)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[136](#CHP-19-FN-2)]) See [http://www.python.org/](http://www.python.org/)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[137](#CHP-19-FN-3)]) See [http://docs.python.org/library/dis.html#bytecodes](http://docs.python.org/library/dis.html#bytecodes)
    for a complete list of Python byte code instructions and their meanings. Also
    see *opcode.h* in the Python source distribution for a mapping of byte code mnemonics
    to their equivalent opcodes.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A little background on the Python interpreter may be useful as we develop the
    Python processor module. The Python interpreter implements a stack-based virtual
    machine that is capable of executing Python byte code. By *stack-based*, we mean
    that the virtual machine has no registers other than an instruction pointer and
    a stack pointer. The majority of Python byte code instructions manipulate the
    stack in some way by reading, writing, or examining stack content. The `BINARY_ADD`
    byte code instruction, for example, removes two items from the interpreter’s stack,
    adds those two items together, and places the single result value back on the
    top of the interpreter’s stack.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of instruction set layout, Python bytes codes are relatively simple
    to understand. All Python instructions consist of a single-byte opcode and either
    zero or two operand bytes. The processor example presented in this chapter does
    not require that you have any prior knowledge of Python byte code. In the few
    instances where specific knowledge is required, we will take the time to explain
    the byte code sufficiently. The primary goal of this chapter is to provide a basic
    understanding of IDA processor modules and some of the considerations that go
    into creating them. Python byte code is merely used as a means to facilitate this
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Processor Module Using the SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It wouldn’t be proper to begin a discussion of creating a processor module without
    including the standard disclaimer that documentation concerning processor modules
    is scarce. Other than reading through SDK include files and the source of processor
    modules included with the SDK, you will find that the SDK’s *readme.txt* file
    is the only other file that sheds any light on how to create a processor module,
    with a few notes under the heading “Description of processor modules.”
  prefs: []
  type: TYPE_NORMAL
- en: It is worth clarifying that while the README file references specific filenames
    within a processor module as if those filenames are set in stone, in fact they
    are not. They do, however, tend to be the filenames that are used in the included
    SDK examples, and they are also the filenames referenced in the build scripts
    included with those examples. Feel free to create your processor modules using
    any filenames you like, as long as you update your build scripts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general intent of referring to specific processor files is to convey the
    idea that a processor module consists of three logical components: an *analyzer*,
    an *instruction emulator*, and an *output generator*. We will cover the purpose
    of each of these functional components as we work our way through the creation
    of our Python processor module.'
  prefs: []
  type: TYPE_NORMAL
- en: Several example processors can be found in *<SDKDIR>/module*. One of the simpler
    processors to read through (if there is such a thing) is the z8 processor. Other
    processor modules vary in complexity based on their instruction sets and whether
    they take on any of the loading responsibilities. If you are thinking about writing
    your own processor module, one approach for getting started (recommended by Ilfak
    in the README file) is to copy an existing processor module and modify it to suit
    your needs. In such cases, you will want to find the processor module that most
    closely resembles the logical structure (not necessarily the processor architecture)
    that you envision for your module.
  prefs: []
  type: TYPE_NORMAL
- en: The processor_t Struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with plug-ins and loaders, processor modules export exactly one thing. For
    processors, that one thing is a `processor_t` struct that must be named `LPH`.
    This struct is exported automatically if you include *<SDKDIR>/module/idaidp.hpp*,
    which in turn includes many other SDK header files commonly required by processor
    modules. One of the reasons why writing a processor module is so challenging is
    that the `processor_t` struct contains 56 fields that must be initialized, and
    26 of those fields are function pointers, while 1 of the fields is a pointer to
    an array of one or more struct pointers that each point to a different type of
    struct (`asm_t`) that contains 59 fields requiring initialization. Easy enough,
    right? One of the principle inconveniences in building processor modules revolves
    around initializing all of the required static data, a proccess that can be error
    prone because of the large number of fields within each data structure. This is
    one of the reasons why Ilfak recommends using an existing processor as the basis
    for any new processors you develop.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the complexity of these data structures, we will not attempt to enumerate
    every possible field and its uses. Instead, we will highlight the major fields
    and refer you to *idp.hpp* for further details on these and other fields within
    each structure. The order in which we cover various `processor_t` fields bears
    no resemblance to the order in which those fields are declared within `processor_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Initialization of the LPH Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the behavioral aspects of your processor module, there are
    some static data requirements that you should take care of. As you build a disassembly
    module, you need to create a list of every assembly language mnemonic that you
    intend to recognize for your target processor. This list is created in the form
    of an array of `instruc_t` (defined in *idp.hpp*) structures and is commonly placed
    in a file named *ins.cpp*. As shown here, `instruc_t` is a simple structure whose
    purpose is twofold. First, it provides a table lookup for instruction mnemonics.
    Second, it describes some basic characteristics of each instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `feature` field is used to indicate behaviors such as whether the instruction
    reads or writes any of its operands and how execution continues once the instruction
    is executed (default, jump, call). The `CF` in `CF_`*`xxx`* stands for *canonical
    feature*. The `feature` field basically drives the concepts of control flow and
    cross-references. A few of the more interesting canonical feature flags are described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`CF_STOP`** The instruction does not pass control to the following instruction.
    Examples might include absolute jumps or function-return instructions. |'
  prefs: []
  type: TYPE_TB
- en: '| **`CF_CHGn`** The instruction modifies operand `n`, where `n` is in the range
    1..6. |'
  prefs: []
  type: TYPE_TB
- en: '| **`CF_USEn`** The instruction uses operand `n`, where `n` is in the range
    1..6, and *uses* means “reads” or “refers to” (but does not modify; see `CF_CHGn`)
    a memory location. |'
  prefs: []
  type: TYPE_TB
- en: '| **`CF_CALL`** The instruction calls a function. |'
  prefs: []
  type: TYPE_TB
- en: 'Instructions need not be listed in any particular order. In particular, there
    is no need to order instructions according to their associated binary opcodes,
    nor is there any requirement to have a one-to-one correspondence between the instructions
    in this array and valid binary opcodes. The first and last few lines of our example
    instruction array are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: In our example, because Python byte code is so simple, we will be maintaining
    a one-to-one correspondence between instructions and byte codes. Note that in
    order to do so, some instruction records must act as filler when an opcode is
    not defined, such as opcode 6 ![](httpatomoreillycomsourcenostarchimages854061.png)
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'An associated set of enumerated constants is typically defined in *ins.hpp*
    to provide a mapping from integers to instructions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have elected to explicitly assign a value to each enum, both for clarity’s
    sake and because there are gaps in our sequence because we have elected to use
    the actual Python opcodes as our instruction indexes. An additional constant has
    also been added (`PYTHON_LAST`) to provide easy reference to the end of the list.
    With a list of instructions and associated integer mapping in hand, we have sufficient
    information to initialize three fields of `LPH` (our global `processor_t`). These
    three fields are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We must initialize these fields with `STOP_CODE`, `PYTHON_LAST`, and `Instructions`,
    respectively. Together these fields enable a processor module to quickly look
    up the mnemonic for any instruction in the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most processor modules, we also need to define a set of register names
    and an associated set of enumerated constants for referring to them. If we were
    writing an x86 processor module, we might begin with something like the following,
    where for the sake of brevity we restrict ourselves to the basic x86 register
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RegNames` array is often declared in a file named *reg.cpp*. This file
    is also where the sample processor modules declare `LPH`, which enables `RegNames`
    to be declared statically. The associated register enumeration would be declared
    in a header file, usually named after the processor (perhaps *x86.hpp* in this
    case), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Make certain that you maintain the proper correspondence between the register
    name array and its associated set of constants. Together the register name array
    and the enumerated register constants allow a processor module to quickly look
    up register names when formatting instruction operands. These two data declarations
    are used to initialize additional fields in `LPH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: These two fields are often initialized with `qnumber(RegNames)` and `RegNames`,
    respectively, where `qnumber` is a macro, defined in *pro.h*, that computes the
    number of elements in a statically allocated array.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IDA processor module is always required to specify information about segment
    registers regardless of whether the actual processor uses segment registers or
    not. Since the x86 utilizes segment registers, the preceding example is fairly
    straightforward to configure. Segment registers are configured in the following
    fields within a `processor_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize our hypothetical x86 processor module, the previous five fields
    would be initialized, in order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the comments, ![](httpatomoreillycomsourcenostarchimages854061.png) and
    ![](httpatomoreillycomsourcenostarchimages854063.png), regarding segment registers.
    IDA always wants information about segment registers, even if your processor does
    not use them. Returning to our Python example, we don’t have nearly as much work
    to do in setting up register mappings, since the Python interpreter is a stack-based
    architecture and there are no registers, but we do need to deal with the segment
    register issue. The typical approach for doing so is to make up names and enumerated
    values to represent a minimal set of segment registers (code and data). Basically,
    we are faking the existence of segment registers for no other reason than because
    IDA expects them. However, even though IDA expects them, we are by no means obligated
    to use them, so we simply ignore them in our processor module. For our Python
    processor, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'With these declarations in place, we can return to initialize the appropriate
    fields within `LPH` using the following sequence of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving on to the implementation of any behavior in the Python processor,
    we take some time to knock off some remaining low-hanging fruit where initialization
    of the `LPH` structure is concerned. The first five fields of a `processor_t`
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The `version` field should look familiar, as it is also required in plug-in
    and loader modules. For custom processor modules, the `id` field should be a self-assigned
    value greater than 0x8000\. The `flag` field describes various characteristics
    of the processor module as a combination of `PR_`*`xxx`* flags defined in *idp.hpp*.
    For the Python processor, we choose to specify only `PR_RNAMESOK`, which allows
    register names to be used as location names (which is okay since we have no registers),
    and `PRN_DEC`, which sets the default number display format to decimal. The remaining
    two fields, `cnbits` and `dnbits`, are each set to 8.
  prefs: []
  type: TYPE_NORMAL
- en: The Analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point we have filled in enough of the `LPH` structure that we can begin
    thinking about the first portion of a processor module that will execute—the analyzer.
    In the example processor modules, the analyzer is typically implemented by a function
    named `ana` (you may name it anything you like) in a file named *ana.cpp*. The
    prototype for this function is very simple, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: You must initialize the `u_ana` member of the `LPH` object with a pointer to
    your analyzer function. The analyzer’s job is to analyze a single instruction,
    populate the global variable `cmd` with information about the instruction, and
    return the length of the instruction. The analyzer should not make any changes
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cmd` variable is a global instance of an `insn_t` object. The `insn_t`
    class, defined in *ua.hpp*, is used to describe a single instruction in the database.
    Its declaration is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Prior to calling your analyzer function, the IDA kernel (the core of IDA) fills
    in the first three fields of the `cmd` object with the segmented and linear address
    of the instruction. After that, it is the analyzer’s job to fill in the rest.
    The essential fields for the analyzer to fill in are `itype` ![](httpatomoreillycomsourcenostarchimages854061.png),
    `size` ![](httpatomoreillycomsourcenostarchimages854063.png), and `Operands` ![](httpatomoreillycomsourcenostarchimages854093.png).
    The `itype` field must be set to one of the enumerated instruction type values
    discussed previously. The `size` field must be set to the total size of the instruction
    (in bytes) and should be used as the return value of the instruction. If the instruction
    cannot be parsed, the analyzer should return a size of zero. Finally, an instruction
    may have up to six operands, and the analyzer should fill in information about
    each operand used by the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The analyzer function is often implemented using a switch statement. The first
    step in the analyzer is typically to request one or more (depending on the processor)
    bytes from the instruction stream and use those bytes as the switch test variable.
    The SDK offers special functions for use in the analyzer for the purpose of retrieving
    bytes from the instruction stream. These functions are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The `current instruction location` is initially the same value contained in
    *cmd.ip*. Each call to one of the `ua_next_`*`xxx`* functions has the side effect
    of incrementing `cmd.size` according to the number of bytes requested by the `ua_next_`*`xxx`*
    function being called (1, 2, 4, or 8). The retrieved bytes must be decoded enough
    to assign the appropriate instruction type enumerated value into the `itype` field,
    determine the number and type of any operands required by the instruction, and
    then determine the overall length of the instruction. As the decoding process
    progresses, additional instruction bytes may be required until a complete instruction
    has been retrieved from the instruction stream. As long as you utilize the `ua_next_`*`xxx`*
    function, `cmd.size` will be updated automatically for you, eliminating the need
    to keep track of the number of bytes you have requested for a given instruction.
    From a high-level perspective, the analyzer somewhat mimics the instruction fetch
    and instruction decode phases employed in real CPUs. Mirroring real life, instruction
    decoding tends to be easier for processors with fixed instruction sizes, as is
    often the case with RISC-style architectures, while instruction decoding tends
    to be more complicated for processors that use variable-length instructions, such
    as the x86.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the retrieved bytes, the analyzer must initialize one element in the
    `cmd.Operands` array for each operand used by the instruction. Instruction operands
    are represented using instances of the `op_t` class, which is defined in *ua.hpp*
    and summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Configuring an operand begins with setting the operand’s `type` field to one
    of the enumerated `optype_t` constants defined in *ua.hpp*. An operand’s `type`
    describes the source or destination of the operand data. In other words, the `type`
    field roughly describes the addressing mode employed to access the operand. Examples
    of operand types include `o_reg`, which means that the operand is the content
    of a register; `o_mem`, which means the operand is a memory address known at compile
    time; and `o_imm`, which means that the operand is immediate data contained within
    the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The `dtype` field specifies the size of the operand data. This field should
    be set to one of the `dt_`*`xxx`* values specified in *ua.hpp*. Example values
    include `dt_byte` for 8-bit data, `dt_word` for 16-bit data, and `dt_dword` for
    32-bit data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following x86 instructions demonstrate the correspondence of some of the
    primary operand datatypes to commonly used operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The manner in which the various unions within an `op_t` are used is dictated
    by the value of the `type` field. For example, when an operand is type `o_imm`,
    the immediate data value should be stored into the `value` field, and when the
    operand type is `o_reg`, the register number (from the enumerated set of register
    constants) should be stored into the `reg` field. Complete details on where to
    store each piece of an instruction are contained in *ua.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that none of the fields within an `op_t` describe whether the operand is
    being used as a source or a destination for data. In fact, it is not the analyzer’s
    job to determine such things. The canonical flags specified in the instruction
    names array are used in a later stage in the processor to determine exactly how
    an operand is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the fields within both the `insn_t` class and the `op_t` class are
    described as *processor dependent*, which means that you may use those fields
    for any purpose you wish. Such fields are often used for storing information that
    does not fit neatly into one of the other fields within these classes. The processor-dependent
    fields are also a convenient mechanism for passing information along to later
    stages of the processor so that those stages do not need to replicate the work
    of the analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of the ground rules for an analyzer covered, we can take a stab at
    crafting a minimal analyzer for Python byte code. Python byte code is very straightforward.
    Python opcodes are 1 byte long. Opcodes less than 90 have no operands, while opcodes
    greater than or equal to 90 each have a 2-byte operand. Our basic analyzer is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'For the Python processor module, we have elected to create an additional array
    of flags, one per instruction, used to supplement (and in some cases replicate)
    the canonical features of each instruction. The `HAS_JREL`, `HAS_JABS`, and `HAS_CALL`
    flags were defined for use in our `flags` array. We use these flags to indicate
    whether an instruction operand represents a relative jump offset, an absolute
    jump target, or the description of a function call stack, respectively. Explaining
    every detail of the analysis phase is difficult without descending into the operation
    of the Python interpreter, so we summarize the analyzer here and through comments
    in the preceding code, remembering that the analyzer’s job is to dissect a single
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: The analyzer gets the next instruction byte from the instruction stream and
    determines whether the byte is a valid Python opcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the instruction has no operands, `cmd.Operand[0]` (`cmd.Op1`) is initialized
    to `o_void`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the command has an operand, `cmd.Operand[0]` is initialized to reflect the
    type of the operand. Several processor-specific fields are used to carry information
    forward to later stages in the processor module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The length of the instruction is returned to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'More sophisticated instruction sets are almost certain to require more complex
    analyzer stages. Overall, however, any analyzer’s behavior may be generalized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read enough bytes from the instruction stream to determine whether the instruction
    is valid and to map the instruction to one of the enumerated instruction type
    constants, which is then saved in `cmd.itype`. This operation is often performed
    using a large switch statement to categorize instruction opcodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read any additional bytes required to properly determine the number of operands
    required by the instruction, the addressing modes in use by those operands, and
    the individual components of each operand (registers and immediate data). This
    data is used to populate elements of the `cmd.Operands` array. This operation
    may be factored into a separate operand-decoding function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the total length of the instruction and its operands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strictly speaking, once an instruction has been dissected, IDA has enough information
    to generate an assembly language representation of that instruction. In order
    to generate cross-references, facilitate the recursive descent process, and monitor
    the behavior of the program stack pointer, IDA must obtain additional details
    about the behavior of each instruction. This is the job of the emulator stage
    of an IDA processor module.
  prefs: []
  type: TYPE_NORMAL
- en: The Emulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whereas the analyzer stage is concerned with the structure of a single instruction,
    the emulator stage is concerned with the behavior of a single instruction. In
    IDA example processor modules, the emulator is typically implemented by a function
    named `emu` (you may name it anything you like) in a file named *emu.cpp*. Like
    the `ana` function, the prototype for this function is very simple, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: According to *idp.hpp*, the `emu` function is supposed to return the length
    of the instruction that was emulated; however, the majority of sample emulators
    seem to return the value 1.
  prefs: []
  type: TYPE_NORMAL
- en: You must initialize the `u_emu` member of the `LPH` object with a pointer to
    your emulator function. By the time `emu` is called, `cmd` has been initialized
    by the analyzer. The emulator’s primary purpose is to create code and data cross-references
    based on the behavior of the instruction described by `cmd`. The emulator is also
    the place to keep track of any changes to the stack pointer and create local variables
    based on observed access to a function’s stack frame. Unlike the analyzer, the
    emulator may change the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining whether an instruction results in the creation of any cross-references
    is typically done by examining the instruction’s canonical features in conjunction
    with the `type` field of the instruction’s operands. A very basic emulator function
    for an instruction set whose instructions may take up to two operands, which is
    representative of many of the SDK examples, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: For each instruction operand, the preceding function examines the instruction’s
    canonical features to determine whether a cross-reference of any kind should be
    generated. In this example, a function named `TouchArg` examines a single operand
    to determine what type of cross-reference should be generated and handles the
    details of generating the correct cross-reference. When generating cross-references
    from your emulator, you should use the cross-reference-creation functions declared
    in *ua.hpp* rather than in *xref.hpp*. The following rough guidelines may be used
    in determining what type of cross-references to generate.
  prefs: []
  type: TYPE_NORMAL
- en: If the operand type is `o_imm`, the operation is a read (`isRead` is true),
    and the operand value is a pointer, create an offset reference. Determine whether
    an operand is a pointer by calling the `isOff` function, for example, `isOff(uFlag,
    op.n)`. Add an offset cross-reference using `ua_add_off_drefs`, for example, `ua_add_off_drefs(op,
    dr_O);`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the operand type is `o_displ` and the operand value is a pointer, create
    an offset cross-reference with a read or write cross-reference type as appropriate,
    for example, `ua_add_off_drefs(op, isRead ? dr_R : dr_W);`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the operand type is `o_mem`, add a data cross-reference with a read or write
    cross-reference type as appropriate using `ua_add_dref`, for example, `ua_add_dref(op.offb,
    op.addr, isRead ? dr_R : dr_W);`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the operand type is `o_near`, add a code cross-reference with a jump or
    call cross-reference type as appropriate using `ua_add_cref`, for example, `ua_add_cref(op.offb,
    op.addr, feature & CF_CALL ? fl_CN : fl_JN);`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The emulator is also responsible for reporting on the behavior of the stack
    pointer register. The emulator should use the `add_auto_stkpnt2` function to inform
    IDA that an instruction changed the value of the stack pointer. The prototype
    for `add_auto_stkpnt2` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pfn` pointer should point to the function that contains the address being
    emulated. If `pfn` is NULL, it will be automatically determined by IDA. The `ea`
    parameter should specify the end address (typically `cmd.ea + cmd.size`) for the
    instruction that changes the stack pointer. The `delta` parameter is used to specify
    the number of bytes by which the stack pointer grows or shrinks. Use negative
    deltas when the stack is growing (such as after a `push` instruction) and positive
    deltas when the stack is shrinking (such as after a `pop` instruction). A simple
    4-byte adjustment to the stack pointer in conjunction with a `push` operation
    might be emulated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to maintain an accurate record of stack pointer behavior, the emulator
    should be able to recognize and emulate all instructions that change the stack
    pointer, not just the simple `push` and `pop` cases. A more complex example of
    tracking the stack pointer occurs when a function allocates its local variables
    by subtracting a constant value from the stack pointer. This case is illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Because CPU architectures vary significantly from one CPU to another, it is
    not possible for IDA (or any other program for that matter) to account for every
    possible way that an operand may be formed or every way that an instruction may
    reference other instructions or data. As a result, there is no precise cookbook
    recipe for building your emulator module. Reading through existing processor module
    source code along with a lot of trial and error may be required before your emulator
    does everything you want it to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The emulator for our example Python processor is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Again, owing to the architecture of the Python interpreter, we are severely
    limited in the types of cross-references that we can generate. In Python byte
    code, there is no concept of a memory address for data items, and the absolute
    address of each instruction can be determined only by parsing metainformation
    contained in the compiled Python (*.pyc*) file. Data items are either stored in
    tables and referenced by index values or they are stored on the program stack,
    where they cannot be directly referenced. Here again, while we can directly read
    data item index values from instruction operands, we cannot know the structure
    of the tables that hold the data unless we have parsed additional metainformation
    contained in the *.pyc* file. In our processor, we can compute only the target
    of relative jump instructions and the address of the next instruction because
    they are located relative to the current instruction address. The fact that our
    processor can provide a better disassembly only if it has a more detailed understanding
    of the file structure is a limitation that we discuss in [Processor Module Architecture](ch19s06.html
    "Processor Module Architecture") in [Processor Module Architecture](ch19s06.html
    "Processor Module Architecture").
  prefs: []
  type: TYPE_NORMAL
- en: For similar reasons, we have elected not to track the stack pointer’s behavior
    in our Python processor. This is primarily because IDA treats stack pointer changes
    as relevant only when those changes are made within the confines of a function
    and we have no means at present for recognizing function boundaries within Python
    code. If we were to implement stack-pointer tracking, it would be wise to remember
    that, as a stack-based architecture, virtually every Python instruction modifies
    the stack in some way. In this case, to simplify the process of determining how
    much the stack pointer is changed by each instruction, it might be easier to define
    an array of values, one per Python instruction, that contains the amount by which
    each instruction modifies the stack. These amounts would then be used in calls
    to `add_auto_stkpnt2` each time an instruction is emulated.
  prefs: []
  type: TYPE_NORMAL
- en: Once the emulator has added all of the cross-references that it can and made
    any other modifications to the database that it deems necessary, you are ready
    to start generating output. In the following section, we discuss the role of the
    outputter in generating IDA’s disassembly display.
  prefs: []
  type: TYPE_NORMAL
- en: The Outputter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of the outputter is to output a single disassembled instruction,
    as specified by the `cmd` global variable, to the IDA display. In IDA processor
    modules, the outputter is typically implemented by a function named `out` (you
    may name it anything you like) in a file named *out.cpp*. Like the `ana` and `emu`
    functions, the prototype for this function is very simple, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: You must initialize the `u_out` member of the `LPH` object with a pointer to
    your output function. By the time `out` is called, `cmd` has been initialized
    by the analyzer. Your output function should not make any changes to the database.
    You are also required to create a helper function whose sole purpose is to format
    and output a single instruction operand. This function is typically named `outop`
    and is pointed to by the `u_outop` member of `LPH`. Your `out` function should
    not call `outop` directly. Instead, you should call `out_one_operand` each time
    you need to print an operand portion of your disassembly lines. Data output operations
    are handled by a separate function typically named *`cpu`*`_data` and specified
    by the `d_out` member field of the `LPH` object. In our Python processor, this
    function is named `python_data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output lines in a disassembly listing are composed of several components, such
    as a prefix, a name label, a mnemonic, operands, and possibly a comment. The IDA
    kernel retains responsibility for rendering some of these components (such as
    prefixes, comments, and cross-references), while others are the responsibility
    of the processor’s outputter. Several useful functions for generating pieces of
    an output line are declared in *ua.hpp* under the following heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Colorizing portions of each output line is possible through the use of functions
    that insert special color tags into your output buffers. Additional functions
    for generating output lines may be found in *lines.hpp*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than use a console-style output model in which you write content directly
    to the IDA display, IDA utilizes a buffer-based output scheme in which you must
    write a single line of display text into a character buffer and then ask IDA to
    display your buffer. The basic process for generating an output line follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `init_output_buffer(char *buf, size_t bufsize)` (declared in *ua.hpp*)
    to initialize your output buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Utilize the buffer output functions in *ua.hpp* to generate a single line of
    content by adding to the initialized buffer. Most of these functions automatically
    write to the destination buffer specified in the previous step, so there is often
    no need to explicitly pass a buffer into these functions. These functions are
    typically named `out_`*`xxx`* or `Out`*`Xxx`*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `term_output_buffer()` to finalize your output buffer, making it ready
    to send to the IDA kernel for display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the output buffer to the kernel using either `MakeLine` or `printf_line`
    (both declared in *lines.hpp*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that `init_output_buffer`, `term_output_buffer`, and `MakeLine` are usually
    called only within your `out` function. Your `outop` function typically makes
    use of the current output buffer as initialized by `out` and usually has no need
    to initialize its own output buffers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strictly speaking, you can skip all of the buffer manipulation described in
    the first four steps of the preceding list and go straight to calling `MakeLine`
    as long as you don’t mind taking complete control of the buffer-generation process
    and passing up the convenience functions offered in *ua.hpp*. In addition to assuming
    a default destination for generated output (as specified via `init_out_buffer`),
    many of the convenience functions automatically work with the current contents
    of the `cmd` variable. Some of the more useful convenience functions from *ua.hpp*
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`OutMnem(int width, char *suffix)`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Outputs the mnemonic that corresponds to `cmd.itype` in a field of at least
    `width` characters, appending the specified suffix. At least one space is printed
    after the mnemonic. The default width is 8, and the default suffix is NULL. An
    example of the use of the suffix value might be for operand size modifiers, as
    in the following x86 mnemonics: `movsb`, `movsw`, `movsd`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`out_one_operand(int n)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Invokes your processor’s `outop` function to print `cmd.Operands[n]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`out_snprintf(const char *format, ...)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Appends formatted text to the current output buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '**`OutValue(op_t &op, int outflags)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Outputs constant fields of an operand. This function outputs `op.value` or `op.addr`,
    depending on the value of `outflags`. See *ua.hpp* for the meaning of `outflags`,
    which defaults to 0\. This function is meant to be called from within `outop`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`out_symbol(char c)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Outputs the given character using the current color for punctuation (`COLOR_SYMBOL`
    as defined in *lines.hpp*). This function is primarily used for outputting the
    syntactic elements within operands (thus called from `outop`), such as commas
    and brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '**`out_line(char *str, color_t color)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Appends the given string, in the given `color`, to the current output buffer.
    Colors are defined in *lines.hpp*. Note that this function does not output a line
    at all. A better name for this function might be `out_str`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`OutLine(char *str)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Same as `out_line` but without the use of color.
  prefs: []
  type: TYPE_NORMAL
- en: '**`out_register(char *str)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Outputs the given string using the current color for registers (`COLOR_REG`).
  prefs: []
  type: TYPE_NORMAL
- en: '**`out_tagon(color_t tag)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Inserts a *turn color on* tag into the output buffer. Subsequent output to the
    buffer will be displayed in the given color until a *turn color off* tag is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '**`out_tagoff(color_t tag)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Inserts a *turn color off* tag into the output buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to *ua.hpp* for additional output functions that may be of use
    in building your outputter.
  prefs: []
  type: TYPE_NORMAL
- en: 'One output capability that is missing from *ua.hpp* is the ability to easily
    output a register name. During the analysis phase, register numbers are stored
    into an operand’s `reg` or `phrase` field, depending on the addressing mode used
    for that operand. Since many operands make use of registers, it would be nice
    to have a function that quickly outputs a register string given a register number.
    The following function provides a minimal capability to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'IDA calls your `out` function only as needed, when an address comes into view
    in one of the IDA displays or when portions of a line are reformatted. Each time
    `out` is called, it is expected to output as many lines as are necessary to represent
    the instruction described in the `cmd` global variable. In order to do this, `out`
    will generally make one or more calls to `MakeLine` (or `printf_line`). In most
    cases one line (and hence one call to `MakeLine`) will be sufficient. When more
    than one line is required to describe an instruction, you should never add carriage
    returns to your output buffers in an attempt to generate several lines at once.
    Instead, you should make multiple calls to `MakeLine` to output each individual
    line. The prototype for `MakeLine` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: An `indent` value of −1 requests default indentation, which is the current value
    of `inf.indent` as specified in the Disassembly section of the Options ▸ General
    dialog. The `indent` parameter has additional meaning when an instruction (or
    data) spans several lines in the disassembly. In a multiline instruction, an indent
    of −1 designates a line as the most important line for that instruction. Please
    refer to the comments for the `printf_line` function in *lines.hpp* for more information
    on using `indent` in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have avoided discussion of comments. Like names and cross-references,
    comments are handled by the IDA kernel. However, you are afforded some control
    over which line of a multiline instruction the comment is displayed on. The display
    of comments is controlled to some extent by a global variable named `gl_comm`,
    which is declared in *lines.hpp*. The most important thing to understand about
    `gl_comm` is that comments cannot be displayed at all unless `gl_comm` is set
    to 1\. If `gl_comm` is 0, then a comment will not be displayed at the end of the
    output you have generated, even if the user has entered one and comments are enabled
    in the Options ▸ General settings. The trouble is, `gl_comm` defaults to 0, so
    you need to make sure that you set it to 1 at some point if you ever expect users
    to see comments while using your processor module. When your `out` function generates
    multiple lines, you need to control `gl_comm` if you want any user-entered comments
    to be displayed on anything other than your first line of output.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the highlights of building an outputter under our belts, here is the `out`
    function for our example Python processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: The function works its way through the components of a disassembled line in
    a very simple fashion. If Python instructions could take two operands, we might
    use `out_symbol` to output a comma and then call `out_one_operand` a second time
    to output the second operand. In most cases, your `outop` function will be somewhat
    more complex than your `out` function, as the structure of an operand is generally
    more complex than the high-level structure of an instruction. A typical approach
    for implementing the `outop` function is to use a switch statement to test the
    value of the operand’s `type` field and format the operand accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Python example, we are forced to use a very simple `outop` function,
    because in most cases we lack the information required to translate the integer
    operands into anything more intelligible. Our implementation is shown here, with
    special handling for comparisons and relative jumps only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to disassembled instructions, a disassembly listing usually contains
    bytes that should be represented as data. In the output stage, data display is
    handled by the `d_out` member of the `LPH` object. The kernel calls the `d_out`
    function to display any bytes that are not part of an instruction, whether the
    datatype of those bytes is unknown or whether the bytes have been formatted as
    data by the user or the emulator. The prototype for `d_out` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The `d_out` function should examine the flags associated with the address specified
    by the `ea` parameter and generate an appropriate representation of the data in
    the style of the assembly language being generated. This function must be specified
    for all processor modules. A bare-bones implementation is offered by the SDK in
    the form of the `intel_data` function, but it is unlikely to meet your specific
    needs. In our Python example, we actually have very little need to format static
    data because we don’t have the means to locate it. For the sake of example, we
    make use of the function shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Functions for accessing and testing the flags associated with any address in
    the database are available in *bytes.hpp*. In this example, the flags are tested
    to determine whether the address represents word or dword data, and appropriate
    output is generated using the appropriate data declaration keyword from the current
    assembler module. The global variable `ash` is an instance of an `asm_t` struct
    that describes characteristics of the assembler syntax that is being utilized
    in the disassembly. We would need significantly more logic in order to generate
    more complex data displays, such as arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Processor Notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 17](ch17.html "Chapter 17. The IDA Plug-in Architecture"), we discussed
    the ability of plug-ins to hook various notification messages using the `hook_to_notification_point`
    function. By hooking notifications, plug-ins could be informed of various actions
    taking place within the database. The concept of notification messages exists
    for processor modules as well, but processor notifications are implemented in
    a slightly different manner than plug-in notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'All processor modules should set a pointer to a notification function in the
    `LPH` object’s `notify` field. The prototype for `notify` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The `notify` function is a variable-arguments function that receives a notification
    code and a variable list of arguments specific to that notification code. The
    complete list of available processor notification codes may be found in *idp.hpp*.
    Notification messages exist for simple actions such as loading (`init`) and unloading
    (`term`) the processor to more complex notifications that code or data is being
    created, functions are being added or deleted, or segments are being added or
    deleted. The list of parameters supplied with each notification code is also specified
    in *idp.hpp*. Before looking at an example of a `notify` function, it is worth
    noting the following comments found only in some of the SDK’s sample processor
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to ensure that all modules that have hooked processor notifications
    are properly notified, the `invoke_callbacks` function should be called. This
    causes the kernel to propagate the given notification message to all registered
    callbacks. The `notify` function used in our Python processor is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'This `notify` function handles only two notification codes: `init` and `make_data`.
    The `init` notification is handled in order to explicitly force the kernel to
    treat data as little-endian. The `inf.mf` (most first) flag indicates the endianness
    value in use by the kernel (0 for little and 1 for big). The `make_data` notification
    is sent whenever an attempt is made to convert bytes to data. In our case, the
    `d_out` function is capable of dealing with only byte, word, and dword data, so
    the function tests the size of the data being created and disallows anything larger
    than 4 bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: Other processor_t Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to wind up the discussion on creating processor modules, we need to
    at least touch on several additional fields in the `LPH` object. As mentioned
    previously, there are a tremendous number of function pointers within this structure.
    If you read through the definition of the `processor_t` struct in *idp.hpp*, it
    is clear in some cases that you can safely set some function pointers to NULL,
    and the kernel will not call them. It seems reasonable to assume that you are
    required to provide implementations for all of the other functions required by
    `processor_t`. As a general rule of thumb, you can often get away with an empty
    stub function when you are at a loss as to what you should do. In our Python processor,
    where it was not clear that NULL was a valid value, we initialized function pointers
    as follows (refer to *idp.hpp* for the behavior of each function):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`header`** Points to empty function in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`footer`** Points to empty function in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`segstart`** Points to empty function in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`segend`** Points to empty function in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`is_far_jump`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`translate`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`realcvt`** Points to `ieee_realcvt` from *ieee.h*. |'
  prefs: []
  type: TYPE_TB
- en: '| **`is_switch`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`extract_address`** Points to a function that returns (BADADDR−1) in example.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`is_sp_based`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`create_func_frame`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`get_frame_retsize`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`u_outspec`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: '| **`set_idp_options`** Is set to NULL in example. |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to these function pointers, the following three data members are
    worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`shnames`** A NULL-terminated array of character pointers that point to
    short names (fewer than nine characters) associated with the processor (such as
    *python*). Terminate this array with a NULL pointer. |'
  prefs: []
  type: TYPE_TB
- en: '| **`lnames`** A NULL-terminated array of character pointers that point to
    long names associated with the processor (such as *Python 2.4 byte code*). This
    array should contain the same number of elements as the `shnames` array. |'
  prefs: []
  type: TYPE_TB
- en: '| **`asms`** NULL-terminated array of pointers to target assembler (`asm_t`)
    structs. |'
  prefs: []
  type: TYPE_TB
- en: The `shnames` and `lnames` arrays specify the names of all processor types that
    can be handled by the current processor module. Users may select alternate processors
    on the Analysis tab of the Options ▸ General dialog, as shown in [Figure 19-1](ch19s03.html#selecting_alternate_processors_and_assem
    "Figure 19-1. Selecting alternate processors and assemblers").
  prefs: []
  type: TYPE_NORMAL
- en: Processor modules that support multiple processors should process the `processor_t.newprc`
    notification in order to be informed of processor changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting alternate processors and assemblers](httpatomoreillycomsourcenostarchimages854310.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-1. Selecting alternate processors and assemblers
  prefs: []
  type: TYPE_NORMAL
- en: The `asm_t` structure is used to describe some of the syntactic elements of
    an assembly language, such as the format of hexadecimal numbers, strings, and
    character delimiters, as well as various keywords commonly used in assembly languages.
    The intent of the `asms` field is to allow several different styles of assembly
    language to be generated by a single processor module. Processor modules that
    support multiple assemblers should process the `processor_t.newasm` notification
    in order to be notified of processor changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, the completed version of our simple Python processor is capable
    of generating code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: While it is possible to generate Python disassemblies that reveal far more information
    than this, they require far greater knowledge of the *.pyc* file format than was
    assumed for this example. A somewhat more fully featured Python processor module
    is available on the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Building Processor Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process for building and installing an IDA processor module is very similar
    to the process for building plug-ins and loaders, with one major difference that,
    if not followed, can result in the inability of IDA to utilize your processor.
    Some minor differences in the build process include these:'
  prefs: []
  type: TYPE_NORMAL
- en: File extensions for processors are *.w32/.w64* on Windows, *.ilx/ilx64* on Linux,
    and *`.imc/.imc64`* on OS X platforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The build scripts for the SDK’s example processors (as well as our own) store
    newly created processor binaries into *<SDKDIR>/bin/procs*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Processor modules are installed by copying the compiled processor binary to
    *<IDADIR>/procs*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows processor modules are required to use a customized MS-DOS stub^([[138](#ftn.CHP-19-FN-4)])
    supplied with the SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows-based processor modules require a custom postprocessing step not required
    by plug-ins and loaders. The purpose of this step is to insert a processor description
    string into a specific location in the compiled processor binary. The description
    string is displayed in the processor drop-down list portion of IDA’s load-file
    dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you build a Windows-based processor module, you are expected to utilize
    a custom MS-DOS stub supplied with the SDK (*<SDKDIR>/module/stub*). In order
    to use a custom MS-DOS stub, you must instruct your linker to use your stub rather
    than the default stub it would otherwise include. When using Windows-specific
    compilers, it is occasionally possible to specify alternate stubs through the
    use of module definition (*.def* ) files. Borland build tools (used by Hex-Rays)
    support the specification of alternate stubs using *.def* files. The SDK includes
    *<SDKDIR>/module/idp.def* for your use if you happen to be using Borland tools.
    The GNU and Microsoft linkers both support *.def* files (albeit with a slightly
    different syntax); however, neither supports the specification of alternate MS-DOS
    stubs, which clearly poses a problem if you are using one of these compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming for a moment that you do manage to build your processor module with
    the SDK-supplied custom MS-DOS stub, you must still insert the processor description
    comment into the processor binary. This is the purpose of the *<SDKDIR>/bin/mkidp.exe*
    utility. You may add a description to a processor using the following syntax to
    invoke `mkidp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, *`module`* is the path to your processor module, while *`description`*
    is a textual description of your module in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a description to our Python processor module, we might use the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mkidp` utility attempts to insert the supplied description into the named
    module at an offset of 128 bytes into the file, in space that lies between the
    MS-DOS stub and the PE header, assuming such space exists. If there is not enough
    space because the PE header is too close to the end of the MS-DOS stub, you will
    receive the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Things become more dependent on your tools at this point, because processors
    built with the Microsoft linker will have enough space available to insert a description,
    while processors built using the GNU linker will not.
  prefs: []
  type: TYPE_NORMAL
- en: In order to clear up the confusion in our minds and allow us to use either Microsoft
    or GNU tools, we developed a utility that we call `fix_proc`, which is available
    in the [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules") section of
    the book’s website. The `fix_proc` utility uses the same command-line syntax as
    `mkidp`, but it provides additional behavior that allows it to insert a processor
    description into processor modules built with most compilers. When `fix_proc`
    is executed, it replaces a processor’s existing MS-DOS stub with the stub supplied
    with the SDK (thus eliminating the need to use *.def* files in the build process).
    At the same time, `fix_proc` performs the necessary actions to relocate the processor’s
    PE headers to create sufficient space to hold the processor-description string,
    before ultimately inserting the description string into the proper location within
    the processor binary. We use `fix_proc` as a replacement for `mkidp` in performing
    the required postprocessing steps on processor modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strictly speaking, use of the SDK’s MS-DOS stub for processor modules is not
    required. IDA is happy with a processor module as long as it finds a description
    string 128 bytes into the processor module. In `fix_proc`, we replace the existing
    MS-DOS stub with the SDK stub simply to avoid any possible conflicts over the
    space dedicated to the description string.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 19-1](ch19s04.html#postprocessing_ida_processor_modules "Table 19-1. Postprocessing
    IDA Processor Modules (by Compiler)") describes the features of processors based
    on the tools used to build them.'
  prefs: []
  type: TYPE_NORMAL
- en: Only processors that have valid descriptions will be listed in the file-loading
    dialog. In other words, without a valid description field, it is not possible
    to select a processor module.
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-1. Postprocessing IDA Processor Modules (by Compiler)
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Initial Build |   | After mkidp |   | After fix_proc |   |'
  prefs: []
  type: TYPE_TB
- en: '| Tool | Uses .def? | Has stub? | Has stub? | Has Description? | Has stub?
    | Has Description? |'
  prefs: []
  type: TYPE_TB
- en: '| Borland | Yes | Yes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft | No | No | No | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| GNU | No | No | No | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: All of these differences in the build process require a few more modifications
    to the makefile presented in [Example 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins
    "Example 17-1. A sample makefile for IDA plug-ins") than were required to build
    loader modules. [Example 19-1](ch19s04.html#a_makefile_for_the_python_processor_modu
    "Example 19-1. A makefile for the Python processor module") shows a makefile modified
    to build our example Python processor.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-1. A makefile for the Python processor module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the minor changes to account for different suffixes and default
    file locations for processors, the primary differences are the definition of a
    description string ![](httpatomoreillycomsourcenostarchimages854061.png), the
    specification of a utility to insert description strings ![](httpatomoreillycomsourcenostarchimages854063.png),
    and the addition of a build step to insert the description string in Windows processor
    modules ![](httpatomoreillycomsourcenostarchimages854093.png).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[138](#CHP-19-FN-4)]) An MS-DOS header stub includes an MS-DOS file header
    as well as code to warn users that a Windows program cannot be executed in MS-DOS
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Existing Processors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps you are considering developing a processor module, but you notice that
    an existing processor module does almost everything that you need. If you have
    the source code for the processor module, then you might easily modify it to suit
    your needs. On the other hand, if you don’t have the source code, you might feel
    that you are out of luck. Fortunately, IDA offers a mechanism for customizing
    existing processors through the use of plug-ins. By hooking the appropriate processor
    notifications, a plug-in module can intercept calls to one or more of an existing
    processor’s analyzer, emulator, and outputter stages. Potential applications for
    customizing a processor include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the capabilities of an existing processor to recognize additional
    instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correcting broken behavior in an existing processor module (though it is probably
    faster just to let Ilfak know you found a bug)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the output of an existing processor module to suit your particular
    needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following notification codes, declared in `processor_t` and discussed in
    *idp.hpp*, may be hooked by plug-ins that want to intercept calls to various stages
    of a processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`custom_ana`** Behaves as `u_ana`; however, any new instructions must use
    a `cmd.itype` value of 0x8000 or higher. |'
  prefs: []
  type: TYPE_TB
- en: '| **`custom_emu`** Provides emulation for custom instruction types. You may
    call `(*ph.u_emu)()` if you wish to invoke the processor’s existing emulator.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`custom_out`** Generates output for custom instructions or provides custom
    output for existing instructions. You may call `(*ph.u_out)()` if you wish to
    invoke the processor’s `out` function. |'
  prefs: []
  type: TYPE_TB
- en: '| **`custom_outop`** Outputs a single custom operand. You may call `(*ph.u_outop)(op)`
    if you wish to invoke the processor’s existing `outop` function. |'
  prefs: []
  type: TYPE_TB
- en: '| **`custom_mnem`** Generates the mnemonic for a custom instruction. |'
  prefs: []
  type: TYPE_TB
- en: 'The following code excerpts are from a plug-in that modifies the output of
    the x86 processor module to replace the `leave` instruction with a `cya` instruction
    and to swap the display order for instructions that have two operands (similar
    to the AT&T-style syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The plug-in’s `init` function verifies that the current processor is the x86
    processor ![](httpatomoreillycomsourcenostarchimages854061.png) and then hooks
    processor notifications ![](httpatomoreillycomsourcenostarchimages854063.png).
    In the callback `hook` function, the plug-in processes the `custom_out` notification
    to recognize the `leave` instruction ![](httpatomoreillycomsourcenostarchimages854093.png)
    and generates an alternative output line ![](httpatomoreillycomsourcenostarchimages854095.png).
    For two operand instructions, the `hook` function temporarily saves the operands
    associated with the current command, before swapping them within the command just
    prior to invoking the x86 processor’s `u_out` function ![](httpatomoreillycomsourcenostarchimages854099.png)
    to handle all of the details of printing the line. Upon return, the command’s
    operands are swapped back to their original order. Finally, the plug-in’s flags
    ![](httpatomoreillycomsourcenostarchimages854101.png) specify that the plug-in
    should be loaded when a processor is loaded, should not be listed on the Edit
    ▸ Plugins menu, and modifies the database. The following output shows the effects
    of the customizations performed by the plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: You can observe the plug-in’s effects by noting that constants appear as the
    first operand in four instructions ![](httpatomoreillycomsourcenostarchimages854103.png)
    and that the `cya` instruction is used in place of the `leave` instruction ![](httpatomoreillycomsourcenostarchimages854133.png).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis"), we will look
    at using a custom processor plug-in to aid in the analysis of certain types of
    obfuscated binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Processor Module Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you set about designing processor modules, one of the things you will need
    to consider is whether the processor will be closely coupled with a specific loader
    or can be decoupled from all loaders. For example, consider the x86 processor
    module. This module makes no assumptions about the type of file that is being
    disassembled. Therefore, it is easily incorporated and used in conjunction with
    a wide variety of loaders such as the PE, ELF, and Mach-O loaders.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, loaders show versatility when they are capable of handling
    a file format independently of the processor used with the file. For example,
    the PE loader works equally well whether it contains x86 code or ARM code; the
    ELF loader works equally well whether it contains x86, MIPS, or SPARC code; and
    the Mach-O loader works fine whether it contains PPC or x86 code.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world CPUs lend themselves to the creation of processor modules that do
    not rely on a specific input file format. Virtual machine languages, on the other
    hand, pose a much larger challenge. Whereas a wide variety of loaders (such as
    ELF, a.out, and PE) may be used to load code for execution on native hardware,
    a virtual machine typically acts as both a loader and a CPU. The net result is
    that, for virtual machines, both the file format and the underlying byte code
    are intimately related. One cannot exist without the other. We bumped up against
    this limitation several times in the development of the Python processor module.
    In many cases, it simply was not possible to generate more readable output without
    a deeper understanding of the structure of the file being disassembled.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the Python processor to have access to the additional information
    that it requires, we could build a Python loader that configures the database
    in a manner very specific to the Python processor so that the Python processor
    knows exactly where to find the information it needs. In this scenario, a significant
    amount of loader state data would need to pass from the loader to the processor.
    One approach is to store such data in database netnodes, where that data could
    later be retrieved by the processor module.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to build a loader that does nothing other than recognize
    *.pyc* files and then tells the processor module that it should handle all of
    the other loading tasks, in which case the processor will surely know how to locate
    all of the information needed for disassembling the *.pyc* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'IDA facilitates the construction of tightly coupled loaders and processor modules
    by allowing a loader to defer all loading operations to an associated processor
    module. This is how the SDK’s included Java loader and Java processor are constructed.
    In order for a loader to defer loading to the processor module, the loader should
    first accept a file by returning a file type of `f_LOADER` (defined in *ida.hpp*).
    If the loader is selected by the user, the loader’s `load_file` function should
    ensure that the proper processor type has been specified by calling `set_processor_type`
    (*idp.hpp*) if necessary before sending a loader-notification message to the processor.
    To build a tightly coupled Python loader/processor combination, we might build
    a loader with the following `load_file` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: When the processor module receives the `loader` notification, it takes responsibility
    for mapping the input file into the database and making sure that it has access
    to any information that will be required in any of the `ana`, `emu`, and `out`
    stages. A Python loader and processor combination that operates in this manner
    is available on the book’s companion website.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting a Processor Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced in IDA 5.7, the capability to create processor modules using one
    of IDA’s scripting languages somewhat simplifies the creation of processor modules.
    If nothing else, it completely eliminates the build phase of module creation.
    Elias Bachaalany of Hex-Rays introduced scripted processor modules in a post on
    Hex Blog^([[139](#ftn.CHP-19-FN-5)]) and IDA’s EFI bytecode processor module is
    implemented as a Python script (see *<IDADIR>/procs/ebc.py*). Note that while
    the Hex Blog post serves as useful background, the actual API used for scripting
    processor modules seems to have evolved. The best place for you to start development
    of your own processor module script is with the template module that ships with
    the SDK (see *<SDKDIR>/module/script/proctemplate.py*). Among other things, this
    template enumerates all of the fields required in a Python processor module.
  prefs: []
  type: TYPE_NORMAL
- en: Scripted processor modules make use of nearly all elements discussed previously.
    Understanding these elements will ease your transition to scripted modules. Additionally,
    the three Python processor modules that currently ship with IDA (as of IDA 6.1)
    serve as excellent examples from which to begin your own module development. The
    structure of these two modules is a bit easier to understand than the C++ examples
    that ship with the SDK, which span several files and require you to correctly
    configure a build environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a very high level, two things are required to implement a processor module
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a subclass `idaapi.processor_t`, providing implementations for all required
    processor module functions such as `emu`, `ana`, `out`, and `outop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `PROCESSOR_ENTRY` function (not a member of your subclass) that returns
    an instance of your processor class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following listing begins to outline some of the required elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: A valid Python processor module contains far more fields and functions than
    shown above, essentially mirroring the fields required in any processor module
    implemented in C++. Once your script is complete, installation of your module
    is accomplished by copying your script to *<IDADIR>/procs*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[139](#CHP-19-FN-5)]) See [http://www.hexblog.com/?p=116](http://www.hexblog.com/?p=116).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the most complex of IDA’s modular extensions, processor modules take time
    to learn and even more time to create, although the use of scripting can ease
    this pain to some extent. However, if you are in a niche reverse engineering market,
    or you simply like to be on the leading edge of the reverse engineering community,
    you will almost certainly find yourself with the need to develop a processor module
    at some point. We cannot emphasize enough the role that patience and trial and
    error play in any processor-development situation. The hard work more than pays
    off when you are able to reuse your processor module with each new binary you
    collect.
  prefs: []
  type: TYPE_NORMAL
- en: With the end of this chapter, we conclude our discussion of IDA’s extensibility
    features. Over the course of the next several chapters, we will discuss many of
    the ways IDA is used in real-world scenarios and look at how users have leveraged
    IDA extensions to perform a variety of interesting analysis tasks.
  prefs: []
  type: TYPE_NORMAL
