- en: Chapter 19. Ruby on Rails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rails has become so closely connected with Ruby that it is now quite commonplace
    for people to talk about programming “in” Ruby on Rails as though “Ruby on Rails”
    were the name of the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Rails is a framework—a set of tools and code libraries—that can be
    used in cahoots with Ruby. It gives you the ability to develop database-driven
    websites that respond to user interaction. For example, users might enter and
    save data on one page and search for data on other pages. This makes Rails suitable
    for creating dynamic websites that generate web pages “on the fly” rather than
    loading up static, predesigned pages. Typical applications include collaborative
    sites such as online communities, multi-author books or wikis, shopping sites,
    discussion forums, and blogs.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll provide a hands-on guide to creating a blog shortly. First, though, let’s
    take a closer look at the nitty-gritty details of the Rails framework.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter will give you a taste of developing in Ruby on Rails. Bear in mind,
    however, that Rails is a big and complex framework, and I will cover only the
    fundamental features. At the time of writing, Rails 3 is the latest version, but
    Rails 2 is still widely used; therefore, both versions are covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rails is not a standard part of Ruby, so you may need to install it as a separate
    operation. Note that Ruby and Rails ship as standard with some operating systems,
    such as Mac OS X. There is, however, no guarantee that these are the latest versions,
    and you may want to update the default installation manually.
  prefs: []
  type: TYPE_NORMAL
- en: Do It Yourself . . .
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various ways in which Rails can be installed. The easiest way is to
    use an all-in-one installer (some alternatives are described in this chapter).
    However, you may also install Rails and the tools it requires one at a time. Rails
    may be installed using the Ruby Gems “package manager.” As long as you are connected
    to the Internet, Ruby Gems will go online to find and install the latest version
    of Rails.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Ruby Gems documentation, go to [http://docs.rubygems.org/](http://docs.rubygems.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command prompt, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If, instead of installing the latest version, you want to install a specific
    version of Rails, you should append `--version=` followed by the appropriate version
    number when entering the previous command. For example, to install Rails 2.3.8,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can download and install Rails from the Ruby on Rails website,
    [http://www.rubyonrails.org/](http://www.rubyonrails.org/). Most Rails applications
    require a database, which you will need to install as a separate operation. Many
    people use either SQLite or the free MySQL database server. MySQL is the more
    powerful of the two systems and is used on many professional websites. However,
    many people find SQLite simpler to use for local development of Ruby applications.
    Installation of SQLite varies according to which operating system is being used.
    SQLite3 is pre-installed on Mac OS X Leopard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation of SQLite3 can be notably tricky on Windows. You should begin
    by running this command at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay close attention to the message that is displayed when this executes. This
    tells you which version of the SQLite3 DLL you need to install and the web address
    from which you can download it. This DLL is a requirement. Failure to install
    it will mean that SQLite3 will not be available for use with Rails. This message
    will state something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to follow the instructions, download the correct DLL, and copy it into
    the *\bin* directory beneath your Ruby installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the SQLite site for more information on SQLite: [http://www.sqlite.org/docs.html](http://www.sqlite.org/docs.html).
    You can find installation help on MySQL in [Appendix B](apb.html "Appendix B. Installing
    MySQL for Ruby on Rails") of this book. Many other database servers can also be
    used including Microsoft SQL Server, PostgresSQL, and Oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you plan to install or update Rails from scratch or if you need to update
    the version pre-installed with your operating system, you should refer to Rails
    Guides website at [http://guides.rubyonrails.org/getting_started.html](http://guides.rubyonrails.org/getting_started.html).
    These guides provide detailed OS-specific information relating to Rails 3\. Several
    Rails wikis also provide information on supporting older versions of Rails—for
    example, [http://en.wikibooks.org/wiki/Ruby_on_Rails](http://en.wikibooks.org/wiki/Ruby_on_Rails).
  prefs: []
  type: TYPE_NORMAL
- en: Or Use an “All-in-One” Installer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Various all-in-one Ruby and Rails setup programs are available. These include
    the Bitnami RubyStack installers for Windows, Linux, and Mac: [http://www.bitnami.org/stack/rubystack/](http://www.bitnami.org/stack/rubystack/).
    Windows users can also use the Rails installer from RubyForge: [http://www.rubyforge.org/frs/?group_id=167](http://www.rubyforge.org/frs/?group_id=167).
    These installers provide their own installation guides.'
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Rails application is divided into three main areas: the Model, the View,
    and the Controller. Put simply, the Model is the data part—the database and any
    programmatic operations (such as calculations) that are done upon that data. The
    View is what the end user sees; in Rails terms, that generally means the web pages
    that appear in the browser. The Controller is the programming logic—the “glue”
    that joins the Model to the View.'
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller methodology is used in various forms by all kinds
    of programming languages and frameworks. It is more fully described in [Digging
    Deeper](ch19s10.html#digging_deeper-id18 "Digging Deeper") in [Digging Deeper](ch19s10.html#digging_deeper-id18
    "Digging Deeper"). For the sake of brevity, I will henceforward call it MVC.
  prefs: []
  type: TYPE_NORMAL
- en: A First Ruby on Rails Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without more ado, let’s start programming with Rails. I’ll assume you have Rails
    installed, along with a web server. I happen to be using the WEBrick server, which
    is installed as standard with Rails, but you may use some other server such as
    Apache, LightTPD, or Mongrel. You can find more information on web servers in
    [Appendix D](apd.html "Appendix D. Ruby and Rails Development Software").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A web server is a program that delivers data, such as web pages, using the Hypertext
    Transfer Protocol (HTTP). You don’t need to understand how this works. You just
    need to be aware that you need a web server for use with Rails.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes you are using only the “raw” Rails development tools—programs
    that are executed from the command line—plus, at the very least, a text editor
    and a web browser; as a consequence, you will find that you frequently have to
    enter commands at the system prompt. If you are using an integrated development
    environment for Rails, you will probably be able to accomplish these tasks much
    more easily using the tools provided by the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the source code examples supplied for the other chapters in this book,
    the sample code for the Ruby on Rails applications in this chapter is not complete
    and “ready to run.” There are three reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Each Rails application comprises a great many files and folders, most of which
    are autogenerated by Rails, so it would be pointless to distribute them separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I would also have to supply the data for each database, and you would have to
    import it prior to using it. Importing databases is often more difficult than
    creating your own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only is it simpler to create Rails applications yourself, but doing so will
    also help you understand how Rails works. I have, however, supplied some sample
    files—component parts of a complete application—with which you can compare your
    own code in case you run into problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Rails Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of simplicity, this first application will not use a database at
    all. This will let you explore the View and the Controller without having to worry
    about the complexities of the Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, open a system prompt (on Windows, select the Start menu, and enter
    **`cmd`** into the Run or Search box). Navigate to a directory into which you
    intend to place your Rails applications. Let’s assume this is *C:\railsapps*.
    Check that Rails is installed and that its home directory is on the system path.
    To do this, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If all is well, you should now see a screenful of help about using the `rails`
    command. If you don’t see this, there is a problem with your Rails installation
    that you need to fix before continuing. Refer to [Installing Rails](ch19.html#installing_rails
    "Installing Rails") in [Installing Rails](ch19.html#installing_rails "Installing
    Rails").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When there are any differences in the commands or code for Rails 2 and Rails
    3, these will be indicated in the text with the Rails version number—Rails 2 or
    Rails 3—in the margin next to the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming Rails is working, you can now create an application. Enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After a bit of whirring of your hard disk, you should see a list of the files
    that Rails has just created (the actual list is quite long, and some of the items
    created are different in Rails 2 and Rails 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at these files using your computer’s file manager. Beneath the
    directory in which you ran the Rails command (*\helloworld*), you will see that
    several new directories have been created: *\app*, *\config*, *\db*, and so on.
    Some of these have subdirectories. The *\app* directory, for example, contains
    *\controllers*, *\helpers*, *\models*, and *\views*. The *\views* directory itself
    contains a subdirectory, *\layouts*.'
  prefs: []
  type: TYPE_NORMAL
- en: The directory structure in a Rails application is far from random; the directories
    (or *folders*) and the names of the files they contain define the relationships
    between the various parts of the application. The idea behind this is that by
    adopting a well-defined file-and-folder structure, you can avoid the necessity
    of writing lots of configuration files to link the various bits of the application
    together. There is a simplified guide to the default directory structure of Rails
    in [Digging Deeper](ch19s10.html#digging_deeper-id18 "Digging Deeper") in [Digging
    Deeper](ch19s10.html#digging_deeper-id18 "Digging Deeper").
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, at the system prompt, change the directory to the top-level folder (*\helloworld*)
    of your newly generated Rails application. Assuming you are still in the *C:\railsapps*
    directory and you named the Rails application *helloworld*, as suggested earlier,
    you would (on Windows) enter this command to change to that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the server. If (like me) you are using WEBrick, you should enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that servers other than WEBrick may be started in different ways, and
    if the previous does not work, you will need to consult the server’s documentation.
    You should now see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Problems?
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead of seeing a message confirming that the server has started, you
    see error messages, check that you have entered the server command exactly as
    shown for the version of Rails being used, and check that it is run from within
    the appropriate directory: *\helloworld*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still have problems, it is possible that the default port (3000) is
    already in use—for example, if you already have an Apache server installed on
    the same PC. In that case, try some other value such as `3003`, placing this number
    after `-p` when you run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you see error messages that include the text `no such file to load -- sqlite3`,
    be sure you have correctly installed SQLite3 as explained in [Installing Rails](ch19.html#installing_rails
    "Installing Rails") in [Installing Rails](ch19.html#installing_rails "Installing
    Rails"). If you are attempting to use MySQL and the error message includes the
    text `no such file to load–mysql`, refer to [Appendix B](apb.html "Appendix B. Installing
    MySQL for Ruby on Rails").
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now fire up a web browser. Enter the host name, followed by a colon and the
    port number, into its address bar. The host name should (normally) be *localhost*,
    and the port number should match the one used when starting the server, or else
    it defaults to 3000\. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The browser should now display a page welcoming you aboard Rails. If not, verify
    that your server is running on the port specified in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860169.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, a Controller is where much of your Ruby code will live.
    It is the part of the application that sits between the View (what appears in
    the browser) and the Model (what happens to the data). Because this is a “Hello
    world” application, let’s create a Controller to say “hello.” In the spirit of
    originality, I’ll call this the *SayHello* controller. Once again, you can create
    this by running a script at the system prompt. You will need to open another command
    window in the directory from which you previously ran the server script (for example,
    *C:\railsapps\helloworld*). You can’t reuse your existing command window because
    the server is running in that one, and you would need to close it down to get
    back to the prompt—and that would stop your Rails application from working!
  prefs: []
  type: TYPE_NORMAL
- en: 'At the prompt, enter this (be sure to use the capitalization of `SayHello`
    as shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few moments, you will be informed that various files and directories
    have been created, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `generate controller` script also creates the file *application_controller.rb*
    in Rails 3 or *application.rb* in Rails 2, which is the controller for the entire
    application, plus a folder, */views/say_hello*, which you will make use of shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how Rails has parsed the name `SayHello` into two lowercase words, `say`
    and `hello`, separated by an underscore, and it has used this name as the first
    part of the generated Ruby files such as `say_hello_controller.rb`. This is just
    one example of the “configuration by convention” approach that Rails uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the controller file *say_hello_controller.rb*, which has been created
    in *\helloworld\app\controllers*. Open this file in a text editor. This empty
    method has been autogenerated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this class you can write some code to be executed when a certain page
    is displayed. Edit the class definition to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This now contains two methods, `index` and `bye`. Each method contains a single
    line of code. In spite of the fact that I have omitted parentheses (a parentheses-light
    style of coding is favored by many Rails developers), you can probably deduce
    that `render` is a method that takes a hash as an argument; the hash itself contains
    a key-value pair comprising a symbol and a string. For parentheses-lovers, the
    `index` method can be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And there you have your first real Rails application. To try it, you need to
    go back to the web browser and enter the full “address” of the two functions you
    just wrote. But first you may need to restart your server. Just press ctrl-C in
    the command window where the server is running. When the server exits, restart
    by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s just one more thing you have to do in Rails 3\. You need to tell it
    how to find a “route” specified by an address entered into web browser. This step
    is not required for Rails 2\. In Rails 3, open the *routes.rb* file in your *helloworld\config\*
    folder. Now edit it to match the following (or simply uncomment the line of code
    that you’ll find at the bottom of the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now ready to test the application. To do so, you just need to enter
    an address to access a controller method. The address takes the form of the host
    and port (the same as you entered previously—for example, *http://localhost:3000*),
    plus the name of the controller (*/say_hello*) and finally the name of a specific
    method (*/index* or */bye*). Try entering these, as shown next, into your browser’s
    address field, once again ensuring that you are using the appropriate port number
    if it is not 3000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Your browser should display “Hello world” and “Bye bye” respectively for each
    address. If all is working at this point, you can bathe in the warm glow of having
    created your first Ruby on Rails application. If however, you are seeing MySQL
    database errors, read [Can’t Find the Database?](apbs04.html "Can’t Find the Database?")
    in [Configuring MySQL](apbs03.html "Configuring MySQL") and fix the problem before
    continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Incidentally, Rails uses the `index` method as a default so you can use the
    index view as your home page and omit that part of the URL when entering the address
    into the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Anatomy of a Simple Rails Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving on, let’s take a closer look at the class that you have created
    in this application. Rails has named the class by appending *Controller* to the
    name you specified when running the controller generator script (`HelloWorld`),
    and it has made it a descendant of the ApplicationController class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But what exactly is the ApplicationController class? You may recall that I
    mentioned that the `generate controller` script you ran earlier silently created
    a file called *application_controller.rb* (Rails 3) or *application.rb* (Rails
    2) inside the */app/controllers* folder. This file is the application controller,
    and if you open it, you will see that it contains a class called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, the SayHelloController class descends from the ApplicationController class
    that itself descends from the Base class in the `ActionController` module. You
    can prove this by climbing back through the hierarchy and asking each class to
    display itself. This, incidentally, also gives you the chance to try doing some
    real Ruby programming in the SayHelloController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just edit the contents of *say_hello_controller.rb* file to match the following
    (or copy and paste the code from the *sayhello1.rb* file in the code archive for
    this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '*sayhello1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the result, enter this address into your browser (once again, change
    the port number if necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Your web browser should now display the following (in Rails 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rails 2 it will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry about the actual class ancestry; the internal implementation details
    of the Rails framework are not of immediate interest. The important thing to understand
    is that a controller is a real Ruby object that inherits behavior from the ApplicationController
    class and its ancestors. Any Rails controller class you write or that is autogenerated
    by running scripts can contain normal Ruby code, just like all the other classes
    you’ve written in previous chapters. Within a controller, you can use all the
    usual Ruby classes such as strings and hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'But bear in mind that the end result needs to be displayed in a web page. This
    has certain consequences. For example, instead of putting linefeeds (`"\n"`) into
    strings, you should use HTML paragraph (`<P>`) or break (`<br />`) tags, and it
    is only permissible to call `render` once each time a page is displayed, which
    explains why I’ve constructed a string in the course of calling the method recursively
    and then passed this to the `render` method right at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The Generate Controller Script Summarized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving on, let’s consolidate the fundamental details of running the Rails
    `generate controller` script and learn a few extra tricks you can use when creating
    views. Each time a new controller is generated, it creates a Ruby code file in
    the *app/controllers* directory, with a name matching the name you entered but
    all in lowercase, with any noninitial capitals that you specified being preceded
    by an underscore and *_controller* appended. So, if you entered *SayHello*, the
    controller file will be called *say_hello_controller.rb*. The controller will
    contain a class definition such as `SayHelloController`. You may subsequently
    add to this class some “view methods” such as `index` and `bye`. Alternatively,
    you may use the `generate` script to create one or more empty view methods automatically
    by including those view names when you execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Rails will now create the file *say_hello_controller.rb*, containing this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not you specify views, a folder in the */views* directory is created
    with a name matching the controller (*views/say_hello*). In fact, the script also
    creates a few other files including some more Ruby files in the */helpers* folder,
    but in our simple application you can ignore these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you specified view names when running the controller script, some files
    with matching names and the extension *.html.erb* will be added to the appropriate
    view folder. For instance, if you entered the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'the */views/say_hello* directory should now contain a file called *xxx.html.erb*.
    If, on the other hand, you entered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'the *views/blather* directory should now contain three files: *xxx.html.erb*,
    *bye.html.erb*, and *snibbit.html.erb*.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be possible to create an entire application by coding everything inside
    a Controller and doing all the formatting inside view methods. However, you would
    soon end up with some pretty ugly web pages. To apply more formatting, you need
    to create a View that more accurately defines the layout of a web page.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a View as an HTML page that will be displayed when someone
    logs onto a specific web address—in which case, the name of the View forms the
    final part of the address as in the previous examples where the */index* and */bye*
    parts of the URL took you to views that displayed data supplied by the `index`
    and `bye` methods in the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: You can create HTML view “templates” that match these web addresses and the
    corresponding method names. Using an HTML (or plaintext) editor, create a file
    named *index.html.erb* in the *\app\views\say_hello* directory, if such a template
    does not already exist. Remember, as explained previously (in [The Generate Controller
    Script Summarized](ch19s07.html "The Generate Controller Script Summarized") in
    [The Generate Controller Script Summarized](ch19s07.html "The Generate Controller
    Script Summarized")), you can optionally autocreate one or more view templates
    when you initially generate the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a view template, you can edit it in order to control the way
    data is displayed in the web page. That means you won’t need to display plain,
    unformatted text using the `render` method in the Controller from now on. But,
    with the View being out of the Controller’s control (so to speak), how can the
    Controller pass data to the View? In turns out that it can do this by assigning
    data to an instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the code in *say_hello_controller.rb* (or delete it and paste in the code
    from the file *sayhello2.rb*, supplied in the source code archive) so that it
    matches the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*sayhello2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This version calls the `showFamily()` method in order to build up a string inside
    two HTML “unordered list” tags, `<ul>` and `</ul>`. Each time a class name is
    found, it is placed between two HTML “list item” tags, `<li>` and `</li>`. The
    complete string forms a valid HTML fragment, and the `index` method simply assigns
    this string a variable named `@class_hierarchy`.
  prefs: []
  type: TYPE_NORMAL
- en: HTML Tags in the Controller?
  prefs: []
  type: TYPE_NORMAL
- en: Some Ruby on Rails developers object to having *any* HTML tags, no matter how
    -trivial, included in the Controller code. In my opinion, if you intend to display
    the end results in a web page, it little matters where you put the odd `<p>`,
    `<ul>`, or `<li>` tag. Although the MVC paradigm encourages strong separation
    between the program code of the Controller and the layout definition of the View,
    you will inevitably have to make some compromises—at the very least by putting
    some program code into the View. Avoiding the use of HTML tags in the Controller
    is, largely, an aesthetic rather than a pragmatic objection. I personally have
    no very strong views on the subject, though (be warned!) other people do.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do now is to find some way of putting that HTML fragment into
    a fully formed HTML page. That’s where the View comes in. Open the view file you
    just created, *index.html.erb*, in the *app/views/say_hello* folder. According
    to the Rails naming convention, this is the default view (the “index” page) that
    is partnered with the *say_hello_controller.rb* file. Since Rails works out relationships
    based on file, folder, class, and method names, you don’t have to load or require
    any files by name or write any configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *index.html.erb* file, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line is nothing more than plain HTML formatting that defines the
    text enclosed by the `<h1></h1>` tags as a heading. The next line is more interesting.
    It contains the variable `@class_hierarchy`. Look back at the `index` method in
    *say_hello_controller.rb*, and you’ll see that this is the variable to which you
    assigned a string. Here in the View, `@class_hierarchy` is placed between two
    odd-looking delimiters: `<%=` and `%>`. These are special Rails tags. They are
    used to embed bits of Ruby that will be executed prior to displaying a web page
    in the browser. The page that is finally displayed will be a fully formed HTML
    page that includes any HTML fragments from the view template plus the results,
    after execution, of any embedded Ruby code. Try it now, by entering the page address
    into your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This should now display the heading “This is the Controller’s Class Hierarchy”
    in big, bold letters followed by a list of classes each element of which is preceded
    by a dot. In Rails 2, this is what you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in Rails 3, you seem to have a problem. Instead of a list, the HTML
    tags are rendered literally like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This definitely is not what you want. The explanation for this is that the
    default treatment of HTML tags embedded in strings has changed between Rails 2
    and Rails 3\. In Rails 2, tags were passed through to the View unmodified. In
    Rails 3, substitution is done to ensure that HTML tags are displayed on the screen
    rather than rendered by the browser. For example, the `<li>` tag is changed to
    `&lt;li&gt;` where `&lt;` and `&gt;` are the HTML codes for angle brackets (`<`
    and `>`). To ensure that HTML tags are not substituted in this way, you need to
    use the `raw` method, passing to it a string argument. This is *index.html.erb*
    rewritten for Rails 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now when you log onto the address [http://localhost:3000/say_hello](http://localhost:3000/say_hello)
    in Rails 3, you should see class names shown as a bulleted list with no HTML tags
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could, if you want, remove all the HTML from the view file by creating
    the heading in the Controller and assigning the resulting string to another variable.
    You can do this by editing the `index` method in *say_hello_controller.rb* to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then edit the view file *(/app/views/say_hello/index.html.erb*) to match the
    code shown next (or cut and paste the code from the sample file into *index.html.erb*)
    for use with Rails 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '*say_hello_rails3.html.erb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For Rails 2, use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*say_hello.html.erb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you do this, the end result, as displayed in the web page, will remain unchanged.
    All that’s happened is that some formatting has been moved out of the view template
    and into the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Rails Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two variations on the Rails tags that you can place into Rails HTML
    Embedded Ruby (ERb) template files. The ones you’ve used so far include an equal
    sign in the opening delimiter: `<%=`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These tags cause Rails not only to evaluate Ruby expressions but also to display
    the results in a web page. If you omit the equals sign from the opening delimiter,
    then the code will be evaluated, but the result will not be displayed: `<%`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ERb files contain a mix of HTML markup and Ruby code between tags such as `<%=`
    and `%>`. Rails processes these files before the final pages are displayed in
    the web browser, executing the embedded Ruby and constructing the HTML page as
    a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want, you can place quite long pieces of code—your entire Ruby program
    even!—between `<%` and `%>` tags and then use `<%=` and `%>` when you want to
    display something in the web page. In fact, you could rewrite your application
    by omitting the Controller entirely and putting everything into the View. Try
    it by editing *app/views/say_hello/index.html.erb* to match the following (or
    copy and paste the code from the file *embed_ruby_rails2.html.erb* or *embed_ruby_rails3.html.erb*
    according to the Rails version being used):'
  prefs: []
  type: TYPE_NORMAL
- en: '*embed_ruby_rails3.rhtml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this particular case, the text displayed in the web page will be slightly
    different from before since it now shows the class hierarchy of the *view’s* class,
    rather than that of the controller’s class. As you will see, the view descends
    from the ActionView::Base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also divide a contiguous block of code by placing the individual lines
    between `<%` and `%>` tags instead of placing the entire block between a single
    pair. The advantage of doing this is that it lets you put standard HTML tags outside
    the individually delimited lines of Ruby code. You could, for instance, put this
    into a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I’ve assigned an array of chars to the variable, `arr`, between one set
    of tags. I’ve written a block to reverse-sort the array and assigned the result
    to another variable between a second set of tags. Then I’ve assigned 1 to the
    variable, `i`; and finally I’ve written this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'But instead of enclosing the method between a single set of `<% %>` tags, I’ve
    enclosed each separate line within its own pair of tags. Why should I do this?
    Well, there are two reasons. First, I want the string in the middle of the block
    to be displayed on the web page, so I need to use the `<%=` tag there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And second, I want the whole set of strings to be displayed as an HTML list.
    So, I’ve placed the `<ul>` and `</ul>` tags before and after the Ruby code block,
    and I’ve placed the line of code that displays each array item inside `<li>` and
    `</li>` tags. Notice that these tags are *inside* the Ruby code block but *outside*
    the embedded Ruby tags on this particular line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: So, by dividing up a contiguous block of Ruby code into separately delimited
    lines, I am no longer forced to construct strings to contain HTML tags. Instead,
    I have been able to do the useful trick of mixing HTML into the Ruby code itself.
    To be honest, I haven’t really mixed it in at all—the Ruby code is still closed
    off inside the tags; what I’ve done is told Rails to mix in the HTML at specific
    points prior to displaying the page in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Incidentally, you may find it interesting to compare the version of the application
    that puts all the embedded Ruby code into the view (*index.html.erb*) with the
    previous version in which the code was all put into the Controller (the version
    of *say_hello_controller.rb* supplied in the sample file *sayhello2.rb*) and only
    tiny bits of embedded Ruby (a couple of variables) were placed into the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You will probably agree that the first version, in which the programming logic
    was put into the Controller rather than embedded into the View, is neater. On
    the whole, Ruby code belongs in Ruby code files, and HTML formatting belongs in
    HTML files. Although embedded Ruby provides an easy way of letting a View and
    a Controller communicate, it is generally better to keep embedded Ruby code short
    and simple and put more complex Ruby code into Ruby code files.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s Make a Blog!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many people, the one thing that really “turned them on” to Ruby on Rails
    was the 20-minute demo given by Rails’s creator, David Heinemeier Hansson, in
    which he showed how to create a simple weblog. That demo was originally done using
    Rails 1 and has since been updated (and changed somewhat) for Rails 2 and Rails
    3\. You can watch the latest demos online at [http://www.rubyonrails.com/screencasts/](http://www.rubyonrails.com/screencasts/).
  prefs: []
  type: TYPE_NORMAL
- en: A blog is a great way to show how easy it is to create a fairly complex application
    using Rails. In the remainder of this chapter, I’ll explain how you can create
    a very simple blog application. I’ll use a feature called *migrations*, which
    will cut out a lot of the hard work of creating the database structure of the
    Model.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that I have tried to keep the creation of this application as simple
    as possible. It is not an exact duplication of David Heinemeier Hansson’s tutorial,
    and it has only a subset of the features of a fully functional blog (there are
    no user comments and no administration interface, for example). Once you have
    completed my blog application, you may want to study the screencast tutorials
    mentioned earlier. These will show you alternative ways of producing similar results,
    and they will also take you further toward the creation of a more complex blog.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can compare the code of your blog application with one I created. My code
    is supplied in the *\blog* subdirectory of the code accompanying this chapter.
    This blog application is not “ready to run,” however, because it requires a database
    that you will have to create. You should create your own blog application by following
    the instructions given in the chapter. You may use the supplied code as a reference
    to check that the files you create match the ones I created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command prompt in the directory in which you keep your Rails applications
    (for example, *C:\railsapps*), and execute a command to create an application
    called Blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Create the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s create a database. Here I am assuming you are using either the SQLite3
    or MySQL database. As said earlier, SQLite3 is regarded as the standard database
    system for local development with Rails 3, and it is easier to set up and use.
    MySQL, on the other hand, is an industry-standard database that is more likely
    to be used for deployment on a website. If you are using SQLite3, you won’t need
    to take any special actions to create the database—Rails does it for you. You
    can skip straight to [Scaffolding](ch19s10.html#scaffolding "Scaffolding") in
    [Creating a MySQL Database](ch19s10.html#creating_a_mysql_database "Creating a
    MySQL Database"). If you are using MySQL, you should follow the steps outlined
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MySQL Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using MySQL, open a MySQL prompt by running the MySQL Command Line
    Client from the MySQL program group. When prompted, enter your MySQL password.
    Now you should see this prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following at the prompt (be sure to put the semicolon at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: MySQL should reply “Query OK” to confirm that the database has been created.
    Now ensure that your database configuration file for your Rails application contains
    the appropriate entries for the development database. If you are using some other
    database (not MySQL), your configuration entries must refer to that database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the folder in which Rails created your new blog application, and open
    the file *database.yml* in the *\config\* subdirectory. Assuming you are using
    MySQL, enter *mysql* as the adapter, *localhost* as the host, your MySQL username
    (for example, *root*), and your password, if you have one. The database name should
    match the database you just created. Here is an example (where you would enter
    an actual password instead of *`mypassword`*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the server is running when you make changes to *database.yml*, you should
    restart the server afterward!
  prefs: []
  type: TYPE_NORMAL
- en: It is common to have multiple configurations—for example, for development, test,
    and production. For the sake of simplicity, here you will create a development
    configuration only; you may comment out any other entries in *database.yml*.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are going to use a feature called *scaffolding* to create a model, views,
    and controllers all in one go. Scaffolding is a convenient way of getting a simple
    application up and running quickly. Move into the new *\blog* directory, and enter
    the following at the system prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This tells the scaffold generator to create a model comprising Ruby code to
    access a database table called *post* with three columns, *title*, *body*, and
    *created_at*, each of which has the data type (*string*, *text* and *datetime*)
    specified after the colon. To create the database structure based on this model,
    you need to run a “migration” to update the database table itself.
  prefs: []
  type: TYPE_NORMAL
- en: Migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scaffold script has created a database migration file for you. Navigate
    to the *\db\migrate* directory. You will see that this contains a numbered migration
    file whose name ends with *_create_posts.rb*. If you open this file, you can see
    how the table structure is represented in Ruby code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: An application may, over time, gain numerous migrations, each of which contains
    information on a specific iteration of the Model—changes and additions made to
    the table structure of the database. Experienced Rails developers can use migrations
    selectively to activate different versions of the Model. Here, however, you will
    use this migration to create the initial structure of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the system prompt in your application’s main directory (for example, */blog*),
    you can use the `rake` tool to run the migration. Enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After a few moments, you should see a message stating that the `rake` task has
    completed and that CreatePosts has been migrated.
  prefs: []
  type: TYPE_NORMAL
- en: Partials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s create a new partial view template. A *partial* is a fragment of a
    web page template that Rails may insert, at runtime, into one or more complete
    web pages. If, for example, you plan to have the same data entry form in multiple
    pages on your site, you could create that form inside a partial template. The
    names of partial templates begin with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Errors?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using MySQL and you see errors when you run `rake`, first verify
    that MySQL is installed, as explained in [Appendix B](apb.html "Appendix B. Installing
    MySQL for Ruby on Rails"). Also watch out for any error messages that begin with
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see this, you will need to add the specified entry to a file named *Gemfile*,
    which you will find in the top-level directory of your application (for example,
    *\blog*). For example, given the previous message, you would need to add this
    text to G*emfile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called *_post.html.erb* in your *\app\views\posts\* directory.
    Open this file, and edit its contents to match the following (or you may copy
    the *_post.html.erb* from the sample project in the source code archive):'
  prefs: []
  type: TYPE_NORMAL
- en: '*_post.html.erb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your changes. Then open the file named *show.html.erb*. This file was
    automatically created by the scaffold script. Delete the following “boilerplate”
    code from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Rails to render the `_post` partial template at this point. The
    code in *show.html.erb* should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Test It!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And that’s it! Now you are ready to test your application. First, run the server.
    At the prompt in the *\blog* directory, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rails 3*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '*Rails 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that if you are not using the default port, 3000, you will need to specify
    the actual port number after `-p` as explained earlier in this chapter, for example:
    `rails server -p3003`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into your web browser, and enter the following address (again, use the actual
    port number if this is not 3000):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see your page with its index page active. This is what should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860173.png)'
  prefs: []
  type: TYPE_IMG
- en: Now click the New Post link. In the New Post page, enter a title and some body
    text. Then click **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860177.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next page that displays is the Show page. This is defined by the combination
    of the *show.html.erb* view and the *_post.html.erb* partial. Now carry on entering
    posts and clicking the links to navigate through the various defined views.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860181.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, this chapter assumes you are using Rails “in the raw,”
    by entering all the necessary commands at the system prompt. Some IDEs provide
    a more integrated environment, which allows you to generate and code your application
    using built-in tools and utilities. You will find an overview of some Ruby and
    Rails IDEs in [Appendix D](apd.html "Appendix D. Ruby and Rails Development Software").
  prefs: []
  type: TYPE_NORMAL
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: The three letters “MVC” are fundamental to understanding how Rails works. Here
    I explain the underlying concepts. You will also learn about the Rails directory
    structure and alternative Ruby frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: MVC
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, Rails adopts the Model-View-Controller (MVC) paradigm.
    Put simply, these may be thought of as the database (Model), the display (View),
    and the programming logic (Controller).
  prefs: []
  type: TYPE_NORMAL
- en: Although these three component parts are, in theory, separate entities, there
    is, in practice, inevitably a degree of overlap. For instance, some calculations
    may be done in the Model with others done in the Controller; operations that affect
    the formatting of data could happen in the Controller or in the View. There are
    no hard-and-fast rules—just a general principle that, as much as possible, operations
    “close to the data” should happen in the Model, operations “close to the display”
    should happen in the View, and everything else should go into the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: That’s MVC in theory. Now let’s see how it is implemented by Rails.
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**'
  prefs: []
  type: TYPE_NORMAL
- en: The Model in Ruby on Rails is a combination of tables in a database—handled
    by a database server such as MySQL—and a matching set of Ruby classes to work
    upon those tables. For example, in a blog you might have a database containing
    a table called Posts. In that case, the Rails model would also contain a Ruby
    class named Post (notice that Rails works with plurals—the Posts table can contain
    many Post objects). The Ruby Post class would typically contain methods to find,
    save, or load individual Post records from the Posts database. This combination
    of database tables and corresponding Ruby classes comprises a Rails Model.
  prefs: []
  type: TYPE_NORMAL
- en: '**View**'
  prefs: []
  type: TYPE_NORMAL
- en: The View is pretty much what it sounds like—the visual representation of a Ruby
    on Rails application. It is (typically but not necessarily) created in the form
    of HTML templates with some Ruby code mixed in. In fact, other view types (for
    example, a graphical view made using Adobe’s Flex or Microsoft’s Silverlight)
    are possible, but the Rails default is HTML. These templates, which generally
    have the extension *.html.erb* (but may also use the extension *.rhtml* that was
    the Rails 1 default), are not loaded directly into a web browser—after all, web
    browsers haven’t any way of running Ruby code. Instead, they are preprocessed
    by a separate tool that executes the Ruby code in order to interact with the Model
    (finding or editing data as necessary); then, as an end result, it creates a new
    HTML page whose basic layout is defined by an ERb template but whose actual data
    (that is, the blog posts, shopping cart items, or whatever) are provided by the
    Model. This makes it possible to create highly dynamic web pages that change as
    a user interacts with them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: The Controller takes the form of Ruby code files that act as go-betweens that
    link the Model and the View. For example, in the web page (the View), a user might
    click a button to add a new post to a blog; using ordinary HTML, this button submits
    a value named `Create`. This causes a method named `create`, in a `post` “controller”
    (a file of Ruby code) to save the new blog entry (some text) that has been entered
    in the web page (the View) into the database (the data repository of the Model).
  prefs: []
  type: TYPE_NORMAL
- en: The Rails Folders
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplified guide to the top-level folders generated by Rails, with
    a brief description of the files and folders they contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *app* | This contains the code specific to this application. Subfolders may
    include *app\controllers*, *app\models*, *app\views*, *app\helpers*, and *app\mailers*.
    |'
  prefs: []
  type: TYPE_TB
- en: '| *config* | This contains configuration files for the Rails environment, the
    routing map, the database, and other dependencies; database configuration is put
    into the file *database.yml*. |'
  prefs: []
  type: TYPE_TB
- en: '| *db* | This contains the database schema in *schema.rb* and may contain code
    that works on the data in the database. If migrations have been applied, it will
    also contain migration files in the *\migrate* subdirectory. |'
  prefs: []
  type: TYPE_TB
- en: '| *doc* | This may contain RDOC documentation (see [Appendix A](apa.html "Appendix A. Documenting
    Ruby with RDoc") for more on RDOC). |'
  prefs: []
  type: TYPE_TB
- en: '| *lib* | This may contain code libraries (that is, code that does not logically
    belong in *\controllers, \models*, or *\helpers*) for the application. |'
  prefs: []
  type: TYPE_TB
- en: '| *log* | This may contain error logs. |'
  prefs: []
  type: TYPE_TB
- en: '| *public* | This directory contains “static” files that may be used by the
    web server. It has subdirectories for *images*, *stylesheets*, and *javascripts*.
    |'
  prefs: []
  type: TYPE_TB
- en: '| *script* | This contains scripts that Rails uses to perform various tasks
    such as generating certain file types and running the web server. |'
  prefs: []
  type: TYPE_TB
- en: '| *test* | This may contain tests generated by Rails or specified by the user.
    |'
  prefs: []
  type: TYPE_TB
- en: '| *tmp* | This contains temporary files used by Rails. |'
  prefs: []
  type: TYPE_TB
- en: '| *vendor* | This may contain third-party libraries that do not form part of
    the default Rails installation. |'
  prefs: []
  type: TYPE_TB
- en: Other Ruby Frameworks
  prefs: []
  type: TYPE_NORMAL
- en: Rails may be the most famous Ruby framework, but it certainly is not the only
    one. Others such as Ramaze and Sinatra also have a dedicated following. A framework
    called Merb was once seen as the closest competitor to Rails. However, in December
    2008, the Rails and Merb teams announced they would be collaborating on the next
    iteration of Rails, and it was that collaboration that resulted in Rails 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in exploring other Ruby frameworks, follow these links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ramaze: [http://www.ramaze.net/](http://www.ramaze.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sinatra: [http://www.sinatrarb.com/](http://www.sinatrarb.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Waves: [http://www.rocket.ly/waves](http://www.rocket.ly/waves)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bear in mind that open source Ruby frameworks have a tendency to come and go,
    waxing and waning according to the enthusiasm or other commitments of the core
    developers. The Ramaze team maintains a list of Ruby frameworks on its home wiki:
    [http://wiki.ramaze.net/Home#other-frameworks](http://wiki.ramaze.net/Home#other-frameworks).'
  prefs: []
  type: TYPE_NORMAL
