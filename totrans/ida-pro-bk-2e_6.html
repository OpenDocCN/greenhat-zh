<html><head></head><body><div class="part" title="Part&#xA0;VI.&#xA0;The IDA Debugger"><div class="titlepage"><div><div><h1 class="title"><a id="the_ida_debugger"/>Part VI. The IDA Debugger</h1></div></div></div><div class="partintro" id="id3246823" title="The IDA Debugger"><div/><p/></div></div>
<div class="chapter" title="Chapter&#xA0;24.&#xA0;The IDA Debugger"><div class="titlepage"><div><div><h1 class="title"><a id="the_ida_debugger-id1"/>Chapter 24. The IDA Debugger</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id23"/><div class="mediaobject"><a id="I_mediaobject1_d1e41123"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>IDA is most widely known as a disassembler, and it is clearly one of the finest tools available for performing static analysis of binaries. Given the sophistication of modern anti–static analysis techniques, it is not uncommon to combine static analysis tools and techniques with dynamic analysis tools and techniques in order to take advantage of the best of both worlds. Ideally, all of these tools would be integrated into a single package. Hex-Rays made that move when it introduced a debugger in version 4.5 of IDA and solidified IDA’s role as a general-purpose reverse engineering tool. With each successive version of IDA, its debugging capabilities have been improved. In its latest version, IDA is capable of local and remote debugging on a number of different platforms and supports a number of different processors. IDA may also be configured to act as a frontend to Microsoft’s WinDbg debugger, making it possible to perform Windows kernel debugging.<a class="indexterm" id="IDX-CHP-24-0001"/></p><p>Over the course of the next few chapters, we will cover the basic features of IDA’s debugger, using the debugger to assist with obfuscated code analysis and remote debugging of Windows, Linux, or OS X binaries. While we assume that the reader possesses some familiarity with the use of debuggers, we will review many of the basic capabilities of debuggers in general as we progress through the features of IDA’s debugger.<a class="indexterm" id="IDX-CHP-24-0002"/><a class="indexterm" id="IDX-CHP-24-0003"/><a class="indexterm" id="IDX-CHP-24-0004"/><a class="indexterm" id="IDX-CHP-24-0005"/><a class="indexterm" id="IDX-CHP-24-0006"/></p><div class="sect1" title="Launching the Debugger"><div class="titlepage"><div><div><h1 class="title"><a id="launching_the_debugger"/>Launching the Debugger</h1></div></div></div><p>Debuggers are typically used to perform one of two tasks: examining memory images (core dumps) associated with crashed processes and executing processes in a very controlled manner. A typical debugging session begins with the selection of a process to debug. There are two ways this is generally accomplished. First, most debuggers are capable of <span class="emphasis"><em>attaching</em></span> to a running process (assuming the user has permission to do so). Depending on the debugger being used, the debugger itself may be able to present a list of available processes to choose from. Lacking such capability, the user must determine the ID of the process to which he wishes to attach and then command the debugger to attach to the specified process. The precise manner by which a debugger attaches to a process varies from one operating system to another and is beyond the scope of this book. When attaching to an existing process, it is not possible to monitor or control the process’s initial start-up sequence, because all of the startup and initialization code will already have completed before you have a chance to attach to the process.<a class="indexterm" id="IDX-CHP-24-0007"/></p><p>The manner by which you attach to a process with the IDA debugger depends on whether a database is currently open or not. When no database is open, the Debugger ▸ Attach menu is available, as shown in <a class="xref" href="ch24.html#attaching_to_an_arbitrary_process" title="Figure 24-1. Attaching to an arbitrary process">Figure 24-1</a>.</p><div class="figure"><a id="attaching_to_an_arbitrary_process"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41174"/><img alt="Attaching to an arbitrary process" src="httpatomoreillycomsourcenostarchimages854356.png.jpg"/></div></div><p class="title">Figure 24-1. Attaching to an arbitrary process</p></div><p>Available options allow selection of different IDA debuggers (remote debugging is covered in <a class="xref" href="ch26.html" title="Chapter 26. Additional Debugger Features">Chapter 26</a>). Options vary depending on the platform on which you are running IDA. Selecting a local debugger causes IDA to display a list of running processes to which you may attach. <a class="xref" href="ch24.html#debugger_process-selection_dialog" title="Figure 24-2. Debugger process-selection dialog">Figure 24-2</a> shows an example of such a list.</p><div class="figure"><a id="debugger_process-selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41188"/><img alt="Debugger process-selection dialog" src="httpatomoreillycomsourcenostarchimages854359.png.jpg"/></div></div><p class="title">Figure 24-2. Debugger process-selection dialog</p></div><p>Once a process has been selected, the debugger creates a temporary database by taking a memory snapshot of the running process. In addition to the memory image of the running process, the temporary database contains sections for all shared libraries loaded by the process, resulting in a substantially larger and more cluttered database than you may be accustomed to. One drawback to attaching to a process in this manner is that IDA has less information available to disassemble the process because IDA’s loader never processes the corresponding executable file image and an automated analysis of the binary is never performed. In fact, once the debugger has attached to the process, the only instructions that will be disassembled in the binary are the instruction referenced by the instruction pointer and those that flow from it. Attaching to a process immediately pauses the process, allowing you the opportunity to set breakpoints prior to resuming execution of the process.<a class="indexterm" id="IDX-CHP-24-0008"/><a class="indexterm" id="IDX-CHP-24-0009"/></p><p>An alternate way to attach to a running process is to open the associated executable in IDA before attempting to attach to the running process. With a database open, the Debugger menu takes on an entirely different form, as shown in <a class="xref" href="ch24.html#debugger_menu_with_a_database_open" title="Figure 24-3. Debugger menu with a database open">Figure 24-3</a>.</p><div class="figure"><a id="debugger_menu_with_a_database_open"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41208"/><img alt="Debugger menu with a database open" src="httpatomoreillycomsourcenostarchimages854362.png.jpg"/></div></div><p class="title">Figure 24-3. Debugger menu with a database open</p></div><p>If you are not presented with this menu (or one very like it), then you probably have not yet specified a debugger to use for the currently open file type. In such cases, Debugger ▸ Select Debugger will present a list of suitable debuggers given the current file type. <a class="xref" href="ch24.html#debugger_selection_dialog" title="Figure 24-4. Debugger selection dialog">Figure 24-4</a> shows a typical debugger selection dialog.<a class="indexterm" id="IDX-CHP-24-0010"/></p><div class="figure"><a id="debugger_selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41225"/><img alt="Debugger selection dialog" src="httpatomoreillycomsourcenostarchimages854365.png.jpg"/></div></div><p class="title">Figure 24-4. Debugger selection dialog</p></div><p>You may make your selection the default debugger for the current file type by checking the box at the bottom of the dialog. The current default debugger, if any, is noted just above the checkbox. Once you have selected a debugger, you may change debuggers at any time via the Debug ▸ Switch Debugger menu.<a class="indexterm" id="IDX-CHP-24-0011"/><a class="indexterm" id="IDX-CHP-24-0012"/><a class="indexterm" id="IDX-CHP-24-0013"/><a class="indexterm" id="IDX-CHP-24-0014"/><a class="indexterm" id="IDX-CHP-24-0015"/><a class="indexterm" id="IDX-CHP-24-0016"/><a class="indexterm" id="IDX-CHP-24-0017"/><a class="indexterm" id="IDX-CHP-24-0018"/><a class="indexterm" id="IDX-CHP-24-0019"/><a class="indexterm" id="IDX-CHP-24-0020"/><a class="indexterm" id="IDX-CHP-24-0021"/><a class="indexterm" id="IDX-CHP-24-0022"/><a class="indexterm" id="IDX-CHP-24-0023"/><a class="indexterm" id="IDX-CHP-24-0024"/></p><p>When Debugger ▸ Attach to Process is selected, IDA’s behavior will vary depending on the type of file opened in the active database. If the file is an executable file, IDA will display a list of all processes that have the same name as the file opened in the database. If IDA can find no process with a matching name, IDA will display a list of every running process and leave it to you to choose the correct process to attach to. In any case, you may attach to any of the displayed processes, but IDA has no way to guarantee that the process was started with same binary image that is loaded in the open IDA database.</p><p>IDA behaves differently if the currently open database is a shared library. On Windows systems, IDA will filter the displayed process list to just those processes that have the corresponding <span class="emphasis"><em>.dll</em></span> file loaded. For example, if you are currently analyzing <span class="emphasis"><em>wininet.dll</em></span> in IDA, then when you select Debugger ▸ Attach to Process, you will see only those processes that currently have <span class="emphasis"><em>wininet.dll</em></span> loaded. On Linux and OS X systems, IDA does not have this filtering ability and displays every process to which you have the rights to attach.<a class="indexterm" id="IDX-CHP-24-0025"/></p><p>As an alternative to attaching to an existing process, you may opt to launch a new process under debugger control. With no database open, a new process can be launched via Debugger ▸ Run. When a database is open, a new process can be launched via Debugger ▸ Start Process or Debugger ▸ Run to Cursor. Using the former causes the new process to execute until it hits a breakpoint (which you need to have set prior to choosing Debugger ▸ Start Process) or until you elect to pause the process using Debugger ▸ Pause Process. Using Debugger ▸ Run to Cursor automatically sets a breakpoint at the current cursor location prior to starting the new process. In this case, the new process will execute until the current cursor location is reached or until an earlier breakpoint is hit. If execution never reaches the current cursor location (or any other breakpoint), the process will continue to run until it is forcibly paused or terminated (Debugger ▸ Terminate Process).<a class="indexterm" id="IDX-CHP-24-0026"/><a class="indexterm" id="IDX-CHP-24-0027"/><a class="indexterm" id="IDX-CHP-24-0028"/><a class="indexterm" id="IDX-CHP-24-0029"/><a class="indexterm" id="IDX-CHP-24-0030"/></p><p>Launching a process under debugger control (as opposed to attaching to an existing process) is the only way to monitor every action the process takes. With breakpoints set prior to process initiation, it becomes possible to closely monitor a process’s entire startup sequence. Controlling startup sequences is particularly important in the case of programs that have been obfuscated, because you will often want to pause the process immediately after the de-obfuscation routines complete and before the process begins its normal operations.<a class="indexterm" id="IDX-CHP-24-0031"/></p><p>Another advantage to launching a process from an open IDA database is that IDA performs its initial autoanalysis on the process image before launching the process. This results in significantly better disassembly quality over that attained when attaching the debugger to an existing process.</p><p>IDA’s debugger is capable of both local and remote debugging. For local debugging, you can only debug binaries that will run on your platform. There is no emulation layer that allows binaries from alternate platforms or CPU types to be executed within IDA’s local debugger. For remote debugging, IDA ships with a number of debugging servers including implementations for Windows 32/64, Windows CE/ARM, Mac OS X 32/64, Linux 32/64/ARM, and Android. The debugging servers are intended to execute alongside the binary that you intend to debug. Once you have a remote debugging server running, IDA can communicate with the server to launch or attach to a target process on the remote machine. For Windows CE ARM devices, IDA communicates with the remote device using ActiveSync and installs the debugging server remotely. IDA is also capable of communicating with the <code class="literal">gdbserver</code><sup>[<a class="footnote" href="#ftn.CHP-24-FN-1" id="CHP-24-FN-1">216</a>]</sup> component of the GNU Debugger<sup>[<a class="footnote" href="#ftn.CHP-24-FN-2" id="CHP-24-FN-2">217</a>]</sup> (gdb) or with programs that are linked with a suitable gdb remote stub.<sup>[<a class="footnote" href="#ftn.CHP-24-FN-3" id="CHP-24-FN-3">218</a>]</sup> Finally, for remote debugging on Symbian devices, you must install and configure Metrowerk’s App TRK<sup>[<a class="footnote" href="#ftn.CHP-24-FN-4" id="CHP-24-FN-4">219</a>]</sup> in order for IDA to communicate with the device over a serial port. In any case, IDA is capable of acting as a debugger frontend only for processing running on x86, x64, MIPS, ARM, and PPC processors. Remote debugging is discussed in <a class="xref" href="ch26.html" title="Chapter 26. Additional Debugger Features">Chapter 26</a>.<a class="indexterm" id="IDX-CHP-24-0032"/><a class="indexterm" id="IDX-CHP-24-0033"/><a class="indexterm" id="IDX-CHP-24-0034"/><a class="indexterm" id="IDX-CHP-24-0035"/></p><p>As with any other debugger, if you intend to use IDA’s debugger to launch new processes, the original executable file is required to be present on the debugging host, and the original binary will be executed with the full privileges of the user running IDA. In other words, it is not sufficient to have only an IDA database loaded with the binary you wish to debug. This is extremely important to understand if you intend to use the IDA debugger for malware analysis. You can easily infect the debugging target machine if you fail to properly control the malware sample. IDA attempts to warn you of this possibility anytime you select Debugger ▸ Start Process (or Debugger ▸ Attach to process with an open database) by displaying a debugger warning message stating the following:<a class="indexterm" id="IDX-CHP-24-0036"/><a class="indexterm" id="IDX-CHP-24-0037"/><a class="indexterm" id="IDX-CHP-24-0038"/><a class="indexterm" id="IDX-CHP-24-0039"/><a class="indexterm" id="IDX-CHP-24-0040"/><a class="indexterm" id="IDX-CHP-24-0041"/><a class="indexterm" id="IDX-CHP-24-0042"/><a class="indexterm" id="IDX-CHP-24-0043"/></p><div class="blockquote"><blockquote class="blockquote"><p>You are going to launch the debugger. Debugging a program means that its code will be executed on your system.</p><p>Be careful with malicious programs, viruses and trojans!</p><p>REMARK: if you select ‘No’, the debugger will be automatically disabled.</p><p>Are you sure you want to continue?</p></blockquote></div><p>Selecting No in response to this warning causes the Debugger menu to be removed from the IDA menu bar. The Debugger menu will not be restored until you close the active database.</p><p>It is highly recommended that you perform any debugging of malicious software within a sandbox environment. In contrast, the x86 emulator plug-in discussed in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a> neither requires that the original binary be present nor executes any of the binary’s instructions on the machine performing the emulation.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-1" id="ftn.CHP-24-FN-1">216</a>] </sup>See <a class="ulink" href="http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server">http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-2" id="ftn.CHP-24-FN-2">217</a>] </sup>See <a class="ulink" href="http://www.gnu.org/software/gdb/">http://www.gnu.org/software/gdb/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-3" id="ftn.CHP-24-FN-3">218</a>] </sup>See <a class="ulink" href="http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub">http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-4" id="ftn.CHP-24-FN-4">219</a>] </sup>See <a class="ulink" href="http://www.tools.ext.nokia.com/agents/index.htm">http://www.tools.ext.nokia.com/agents/index.htm</a>.</p></div></div></div>
<div class="sect1" title="Basic Debugger Displays"><div class="titlepage"><div><div><h1 class="title"><a id="basic_debugger_displays"/>Basic Debugger Displays</h1></div></div></div><p>Regardless of how you happen to launch the debugger, once your process of interest has been paused under debugger control, IDA enters its debugger mode (as opposed to normal disassembly mode), and you are presented with several default displays. The default debugger display is shown in <a class="xref" href="ch24s02.html#ida_debugger_display" title="Figure 24-5. IDA debugger display">Figure 24-5</a>.</p><div class="figure"><a id="ida_debugger_display"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41436"/><img alt="IDA debugger display" src="httpatomoreillycomsourcenostarchimages854367.png.jpg"/></div></div><p class="title">Figure 24-5. IDA debugger display</p></div><p>If you are accustomed to using other Windows debuggers such as OllyDbg<sup>[<a class="footnote" href="#ftn.CHP-24-FN-5" id="CHP-24-FN-5">220</a>]</sup> or Immunity Debugger,<sup>[<a class="footnote" href="#ftn.CHP-24-FN-6" id="CHP-24-FN-6">221</a>]</sup> one of your first thoughts might be that not much information is displayed on the screen. This is primarily a result of the fact that IDA defaults to a font size that is actually readable. If you find yourself missing the micro fonts used in other debuggers, you can easily change things via the Options ▸ Font menu. You may also wish to make use of saved IDA desktops (Windows ▸ Save Desktop) if you develop a fondness for a specific layout of your debugger windows.<a class="indexterm" id="IDX-CHP-24-0044"/><a class="indexterm" id="IDX-CHP-24-0045"/><a class="indexterm" id="IDX-CHP-24-0046"/><a class="indexterm" id="IDX-CHP-24-0047"/><a class="indexterm" id="IDX-CHP-24-0048"/><a class="indexterm" id="IDX-CHP-24-0049"/><a class="indexterm" id="IDX-CHP-24-0050"/><a class="indexterm" id="IDX-CHP-24-0051"/><a class="indexterm" id="IDX-CHP-24-0052"/><a class="indexterm" id="IDX-CHP-24-0053"/></p><p>As shown in the <a class="xref" href="ch24s02.html#ida_debugger_display" title="Figure 24-5. IDA debugger display">Figure 24-5</a>, the debugger toolbar <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e41492"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> replaces the disassembly toolbar. A number of standard (from a debugging standpoint) tools are present, including process control tools and breakpoint manipulation tools.<a class="indexterm" id="IDX-CHP-24-0054"/><a class="indexterm" id="IDX-CHP-24-0055"/></p><p>The IDA View-EIP <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e41506"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> disassembly window is a default disassembly listing window when the debugger is active. It also happens to be synchronized with the current value of the instruction pointer register. If IDA detects that a register points to a memory location within the disassembly window, the name of that register is displayed in the left margin, opposite the address to which the register points. In <a class="xref" href="ch24s02.html#ida_debugger_display" title="Figure 24-5. IDA debugger display">Figure 24-5</a>, the location to which EIP points is flagged in IDA View-EIP (note that EDX also points to the same location in this example). By default, IDA highlights breakpoints in red and the next instruction to be executed (the one to which the instruction pointer points) in blue. Debugger-related disassemblies are generated via the same disassembly process used in standard disassembly mode. Thus, IDA’s debugger offers perhaps the best disassembly capability to be found in a debugger. Additionally, if you launched the debugger from an open IDA database, IDA is able to characterize all of the executable content based on analysis performed prior to launching the debugger. IDA’s ability to disassemble any library code that has been loaded by the process will be somewhat more limited because IDA has not had a chance to analyze the associated <span class="emphasis"><em>.dll</em></span> file prior to launching the debugger.</p><p>The Stack View <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e41519"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> window is another standard disassembly view primarily used to display the data contents of the process’s runtime stack. All registers that point to stack locations are noted as such in the General Registers <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e41525"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> view (such as EBP in this case). Through the use of comments, IDA makes every attempt to provide context information for each data item on the stack. When the stack item is a memory address, IDA attempts to resolve the address to a function location (this helps highlight the location from which a function was called). When the stack item is a data pointer, a reference to the associated data item is displayed. The remaining default displays include the Hex view <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e41531"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>, which offers a standard hex dump of memory, the Modules <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e41537"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> view, which displays a list of modules currently loaded in the process image, and the Threads <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e41543"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> view, which displays a list of threads in the current process. Double-clicking any listed thread causes the IDA View-EIP disassembly window to jump to the current instruction within the selected thread and updates the General Registers view to reflect the current values for registers within the selected thread.<a class="indexterm" id="IDX-CHP-24-0056"/></p><p>The General Registers window (also shown in <a class="xref" href="ch24s02.html#the_general_registers_display" title="Figure 24-6. The General Registers display">Figure 24-6</a>) displays the current contents of the CPU’s general-purpose registers. Additional windows for displaying the contents of the CPU’s segment, floating-point, or MMX registers may be opened from the Debugger menu.<a class="indexterm" id="IDX-CHP-24-0057"/></p><div class="figure"><a id="the_general_registers_display"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41565"/><img alt="The General Registers display" src="httpatomoreillycomsourcenostarchimages854370.png.jpg"/></div></div><p class="title">Figure 24-6. The General Registers display</p></div><p>Within the General Registers window, register contents are displayed to the right of the associated register name followed by a description of each register’s content. The CPU flag bits are displayed down the rightmost column. Right-clicking a register value or flag bit provides access to a Modify menu item, which allows you to change the contents of any register or CPU flag. Menu options offer quick access to zero a value, toggle a value, increment a value, or decrement a value. Toggling values is particularly useful for changing CPU flag bits. Right-clicking any register value also provides access to the Open Register Window menu item. Selecting Open Register Window causes IDA to open a new disassembly window centered at the memory location held in the selected register. If you ever find that you have inadvertently closed either IDA View-EIP or IDA View-ESP, use the Open Register Window command on the appropriate register to reopen the lost window. If a register appears to point to a valid memory location, then the right-angle arrow control to the right of that register’s value will be active and highlighted in black. Clicking an active arrow opens a new disassembly view centered on the corresponding memory location.<a class="indexterm" id="IDX-CHP-24-0058"/><a class="indexterm" id="IDX-CHP-24-0059"/><a class="indexterm" id="IDX-CHP-24-0060"/><a class="indexterm" id="IDX-CHP-24-0061"/></p><p>The Modules window displays a list of all executable files and shared libraries loaded into the process memory space. Double-clicking any module named in the list opens a list of symbols exported by that module. <a class="xref" href="ch24s02.html#the_modules_window_with_associated_modul" title="Figure 24-7. The Modules window with associated module contents">Figure 24-7</a> shows an example of the contents of <span class="emphasis"><em>kernel32.dll</em></span>. The symbol list provides an easy way to track down functions within loaded libraries if you wish to set breakpoints on entry to those functions.<a class="indexterm" id="IDX-CHP-24-0062"/><a class="indexterm" id="IDX-CHP-24-0063"/></p><div class="figure"><a id="the_modules_window_with_associated_modul"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41601"/><img alt="The Modules window with associated module contents" src="httpatomoreillycomsourcenostarchimages854373.png"/></div></div><p class="title">Figure 24-7. The Modules window with associated module contents</p></div><p>Additional debugger displays are accessible using various debugger menu selections. Displays pertaining to debugger operations will be discussed in the following section, “Process Control.” Along with the debugger-specific displays, all traditional IDA subviews, such as Functions and Segments, remain available via the Views ▸ Open Subviews command.<a class="indexterm" id="IDX-CHP-24-0064"/><a class="indexterm" id="IDX-CHP-24-0065"/><a class="indexterm" id="IDX-CHP-24-0066"/><a class="indexterm" id="IDX-CHP-24-0067"/><a class="indexterm" id="IDX-CHP-24-0068"/><a class="indexterm" id="IDX-CHP-24-0069"/><a class="indexterm" id="IDX-CHP-24-0070"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-5" id="ftn.CHP-24-FN-5">220</a>] </sup>See <a class="ulink" href="http://www.ollydbg.de/">http://www.ollydbg.de/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-6" id="ftn.CHP-24-FN-6">221</a>] </sup>See <a class="ulink" href="http://www.immunityinc.com/products-immdbg.shtml">http://www.immunityinc.com/products-immdbg.shtml</a>.</p></div></div></div>
<div class="sect1" title="Process Control"><div class="titlepage"><div><div><h1 class="title"><a id="process_control"/>Process Control</h1></div></div></div><p>Perhaps the most important feature of any debugger is the ability to closely control—and modify, if desired—the behavior of the process being debugged. To that end, most debuggers offer commands that allow one or more instructions to be executed before returning control to the debugger. Such commands are often used in conjunction with breakpoints that allow the user to specify that execution should be interrupted when a designated instruction is reached or when a specific condition is met.</p><p>Basic execution of a process under debugger control is accomplished through the use of various Step, Continue, and Run commands. Because they are used so frequently, it is helpful to become familiar with the toolbar buttons and hotkey sequences associated with these commands. <a class="xref" href="ch24s03.html#debugger_process_control_tools" title="Figure 24-8. Debugger process control tools">Figure 24-8</a> shows the toolbar buttons associated with execution of a process.<a class="indexterm" id="IDX-CHP-24-0071"/></p><div class="figure"><a id="debugger_process_control_tools"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41648"/><img alt="Debugger process control tools" src="httpatomoreillycomsourcenostarchimages854376.png.jpg"/></div></div><p class="title">Figure 24-8. Debugger process control tools</p></div><p>The behavior of each of these commands is described in the following list:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="strong"><strong>Continue</strong></span> Resumes execution of a paused process. Execution continues until a breakpoint is hit, the user pauses or terminates execution, or the process terminates on its own.</td></tr><tr><td><span class="strong"><strong>Pause</strong></span> Pauses a running process.</td></tr><tr><td><span class="strong"><strong>Terminate</strong></span> Terminates a running process.</td></tr><tr><td><span class="strong"><strong>Step Into</strong></span> Executes the next instruction only. If the next instruction is a function call, breaks on the first instruction of the target function. Hence the name <span class="emphasis"><em>Step Into</em></span>, since execution steps into any function being called.</td></tr><tr><td><span class="strong"><strong>Step Over</strong></span> Executes the next instruction only. If the next instruction is a function call, treats the call as a single instruction, breaking once the function returns. Hence the name <span class="emphasis"><em>Step Over</em></span>, since stepping proceeds over functions rather than through them as with Step Into. Execution may be interrupted prior to completion of the function call if a breakpoint is encountered. Step Over is very useful as a time-saver when the behavior of a function is well known and uninteresting.</td></tr><tr><td><span class="strong"><strong>Run Until Return</strong></span> Resumes execution of the current function and does not stop until that function returns (or a breakpoint is encountered). This operation is useful when you have seen enough of a function and you wish to get out of it or when you inadvertently step into a function that you meant to step over.</td></tr><tr><td><span class="strong"><strong>Run to Cursor</strong></span> Resumes execution of the process and stops when execution reaches the current cursor location (or a breakpoint is hit). This feature is useful for running through large blocks of code without the need to set a permanent breakpoint at each location where you wish to pause. Beware that the program may not pause if the cursor location is bypassed or otherwise never reached.</td></tr></table><p>In addition to toolbar and hotkey access, all of the execution control commands are accessible via the Debugger menu. Regardless of whether a process pauses after a single step or hitting a breakpoint, each time the process pauses, all debugger-related displays are updated to reflect the state of the process (CPU registers, flags, memory contents) at the time the process was paused.<a class="indexterm" id="IDX-CHP-24-0072"/><a class="indexterm" id="IDX-CHP-24-0073"/><a class="indexterm" id="IDX-CHP-24-0074"/><a class="indexterm" id="IDX-CHP-24-0075"/><a class="indexterm" id="IDX-CHP-24-0076"/><a class="indexterm" id="IDX-CHP-24-0077"/><a class="indexterm" id="IDX-CHP-24-0078"/><a class="indexterm" id="IDX-CHP-24-0079"/><a class="indexterm" id="IDX-CHP-24-0080"/><a class="indexterm" id="IDX-CHP-24-0081"/><a class="indexterm" id="IDX-CHP-24-0082"/></p><div class="sect2" title="Breakpoints"><div class="titlepage"><div><div><h2 class="title"><a id="breakpoints"/>Breakpoints</h2></div></div></div><p><span class="emphasis"><em>Breakpoints</em></span> are a debugger feature that goes hand in hand with process execution and interruption (pausing). Breakpoints are set as a means of interrupting program execution at very specific locations within the program. In a sense a breakpoint is a more permanent extension of the Run to Cursor concept in that once a breakpoint is set at a given address, execution will always be interrupted when execution reaches that location, regardless of whether the cursor remains positioned on that location or not. However, while there is only one cursor to which execution can run, it is possible to set many breakpoints all over a program, the arrival at any one of which will interrupt execution of the program. Breakpoints are set in IDA by navigating to the location at which you want execution to pause and using the F2 hotkey (or right-clicking and selecting Add Breakpoint). Addresses at which breakpoints have been set are highlighted with a red (by default) band across the entire disassembly line. A breakpoint may be removed by pressing F2 a second time to toggle the breakpoint off. A complete list of breakpoints currently set within a program may be viewed via Debugger ▸ Breakpoints ▸ Breakpoint List.<a class="indexterm" id="IDX-CHP-24-0083"/><a class="indexterm" id="IDX-CHP-24-0084"/><a class="indexterm" id="IDX-CHP-24-0085"/><a class="indexterm" id="IDX-CHP-24-0086"/><a class="indexterm" id="IDX-CHP-24-0087"/><a class="indexterm" id="IDX-CHP-24-0088"/><a class="indexterm" id="IDX-CHP-24-0089"/><a class="indexterm" id="IDX-CHP-24-0090"/></p><p>By default, IDA utilizes <span class="emphasis"><em>software breakpoints</em></span>, which are implemented by replacing the opcode byte at the breakpoint address with a software breakpoint instruction. For x86 binaries, this is the <code class="literal">int 3</code> instruction, which uses opcode value <code class="literal">0xCC</code>. Under normal circumstances, when a software breakpoint instruction is executed, the operating system transfers control to any debugger that may be monitoring the interrupted process. As discussed in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>, obfuscated code may take advantage of the behavior of software breakpoints in an attempt to hinder normal operation of any attached debugger.<a class="indexterm" id="IDX-CHP-24-0091"/></p><p>As an alternative to software breakpoints, some CPUs (such as the x86, actually 386, and later) offer support for <span class="emphasis"><em>hardware-assisted breakpoints</em></span>. Hardware breakpoints are typically configured through the use of dedicated CPU registers. For x86 CPUs, these registers are called DR0–7 (debug registers 0 through 7). A maximum of four hardware breakpoints can be specified using x86 registers DR0–3. The remaining x86 debug registers are used to specify additional constraints on each breakpoint. When a hardware breakpoint is enabled, there is no need to substitute a special instruction into the program being debugged. Instead, the CPU itself decides whether execution should be interrupted or not based on values contained within the debug registers.<a class="indexterm" id="IDX-CHP-24-0092"/></p><p>Once a breakpoint has been set, it is possible to modify various aspects of its behavior. Beyond simply interrupting the process, debuggers often support the concept of <span class="emphasis"><em>conditional breakpoints</em></span>, which allow users to specify a condition that must be satisfied before the breakpoint is actually honored. When such a breakpoint is reached and the associated condition is not satisfied, the debugger automatically resumes execution of the program. The general idea is that the condition is expected to be satisfied at some point in the future, resulting in interruption of the program only when the condition you are interested in has been satisfied.<a class="indexterm" id="IDX-CHP-24-0093"/></p><p>The IDA debugger supports both conditional and hardware breakpoints. In order to modify the default (unconditional, software-based) behavior of a breakpoint, you must edit a breakpoint after it has been set. In order to access the breakpoint-editing dialog, you must right-click an existing breakpoint and select Edit Breakpoint. <a class="xref" href="ch24s03.html#the_breakpoint_settings_dialog" title="Figure 24-9. The Breakpoint Settings dialog">Figure 24-9</a> shows the resulting Breakpoint Settings dialog.<a class="indexterm" id="IDX-CHP-24-0094"/></p><div class="figure"><a id="the_breakpoint_settings_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e41809"/><img alt="The Breakpoint Settings dialog" src="httpatomoreillycomsourcenostarchimages854379.png.jpg"/></div></div><p class="title">Figure 24-9. The Breakpoint Settings dialog</p></div><p>The Location box indicates the address of the breakpoint being edited, while the Enabled checkbox indicates whether the breakpoint is currently active or not. A breakpoint that is disabled is not honored regardless of any condition that may be associated with the breakpoint. The Hardware checkbox is used to request that the breakpoint be implemented in hardware rather than software.<a class="indexterm" id="IDX-CHP-24-0095"/><a class="indexterm" id="IDX-CHP-24-0096"/><a class="indexterm" id="IDX-CHP-24-0097"/><a class="indexterm" id="IDX-CHP-24-0098"/></p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>A word of caution concerning hardware breakpoints: Though the x86 only supports four hardware breakpoints at any given time, as of this writing (IDA version 6.1), IDA will happily allow you to designate more than four hardware breakpoints. However, only four of them will be honored. Any additional hardware breakpoints will be ignored.<a class="indexterm" id="IDX-CHP-24-0099"/></p></div><p>When specifying a hardware breakpoint, you must use the Hardware breakpoint mode radio buttons to specify whether the breakpoint behavior is to break on execute, break on write, or break on read/write. The latter two categories (break on write and break on read/write) allow you to create breakpoints that trigger when a specific memory location (usually a data location) is accessed, regardless of what instruction happens to be executing at the time the access takes place. This is very useful if you are more interested in when your program accesses a piece of data than where the data is accessed from.</p><p>In addition to specifying a mode for your hardware breakpoint, you must specify a size. For execute breakpoints the size must be 1 byte. For write or read/write breakpoints, the size may be set to 1, 2, or 4 bytes. When the size is set to 2 bytes, the breakpoint’s address must be word aligned (a multiple of 2 bytes). Similarly, for 4-byte breakpoints, the breakpoint address must be double-word aligned (a multiple of 4 bytes). A hardware breakpoint’s size is combined with its address to form a range of bytes over which the breakpoint may be triggered. An example may help to explain. Consider a 4-byte write breakpoint set at address <code class="literal">0804C834h</code>. This breakpoint will be triggered by a 1-byte write to <code class="literal">0804C837h</code>, a 2-byte write to <code class="literal">0804C836h</code>, and a 4-byte write to <code class="literal">0804C832h</code>, among others. In each of these cases, at least 1 byte in the range <code class="literal">0804C834h0804C837h</code> is written. More information on the behavior of x86 hardware breakpoints can be found in the <span class="emphasis"><em>Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B: System Programming Guide, Part 2</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-24-FN-7" id="CHP-24-FN-7">222</a>]</sup><a class="indexterm" id="IDX-CHP-24-0100"/><a class="indexterm" id="IDX-CHP-24-0101"/></p><p>Conditional breakpoints are created by providing an expression in the Breakpoint Settings dialog’s Condition field. Conditional breakpoints are a debugger feature, not an instruction set or CPU feature. When a breakpoint is triggered, it is the debugger’s job to evaluate any associated conditional expression and determine whether the program should be paused (the condition is met) or whether execution should simply continue (the condition is not met). Therefore, conditions may be specified for both software and hardware breakpoints.</p><p>IDA breakpoint conditions are specified using IDC (not Python) expressions. Expressions that evaluate to non-zero are considered true, satisfying the breakpoint condition and triggering the breakpoint. Expressions that evaluate to zero are considered false, failing to satisfy the breakpoint condition and failing to trigger the associated breakpoint. In order to assist in the creation of breakpoint expressions, IDA makes special register variables available within IDC (again, not Python) to provide direct access to register contents in breakpoint expressions. These variables are named after the registers themselves and include <code class="literal">EAX</code>, <code class="literal">EBX</code>, <code class="literal">ECX</code>, <code class="literal">EDX</code>, <code class="literal">ESI</code>, <code class="literal">EDI</code>, <code class="literal">EBP</code>, <code class="literal">ESP</code>, <code class="literal">EFL</code>, <code class="literal">AX</code>, <code class="literal">BX</code>, <code class="literal">CX</code>, <code class="literal">DX</code>, <code class="literal">SI</code>, <code class="literal">DI</code>, <code class="literal">BP</code>, <code class="literal">SP</code>, <code class="literal">AL</code>, <code class="literal">AH</code>, <code class="literal">BL</code>, <code class="literal">BH</code>, <code class="literal">CL</code>, <code class="literal">CH</code>, <code class="literal">DL</code>, and <code class="literal">DH</code>. These register variables are accessible only when the debugger is active.</p><p>Unfortunately, no variables exist that allow direct access to the processor flag bits. In order to access individual CPU flags, you need to call the <code class="literal">GetRegValue</code> function to obtain the value of the desired flag bit, such as <code class="literal">CF</code>. If you need a reminder regarding valid register and flag names, refer to the labels along the left and right edges of the General Registers window. A few example breakpoint expressions are shown here:<a class="indexterm" id="IDX-CHP-24-0102"/></p><a id="I_programlisting1_d1e41963"/><pre class="programlisting">EAX == 100             // break if eax holds the value 100
ESI &gt; EDI              // break if esi is greater than edi
Dword(EBP-20) == 10    // Read current stack frame (var_20) and compare to 10
GetRegValue("ZF")      // break if zero flag is set
EAX = 1                // Set EAX to 1, this also evaluates to true (non-zero)
EIP = 0x0804186C       // Change EIP, perhaps to bypass code</pre><p>Two things to note about breakpoint expressions are the fact that IDC functions may be called to access process information (as long as the function returns a value) and the fact that assignment can be used as a means of modifying register values at specific locations during process execution. Ilfak himself demonstrated this technique as an example of overriding a function return value.<sup>[<a class="footnote" href="#ftn.CHP-24-FN-8" id="CHP-24-FN-8">223</a>]</sup></p><p>The last breakpoint options that can be configured in the Breakpoint Settings dialog are grouped into the Actions box on the right side of the dialog. The Break checkbox specifies whether program execution should actually be paused (assuming any associated condition is true) when the break-point is reached. It may seem unusual to create a breakpoint that doesn’t break, but this is actually a useful feature if all you want to do is modify a specific memory or register value each time an instruction is reached without requiring the program to be paused at the same time. Selecting the Trace checkbox causes a trace event to be logged each time the breakpoint is hit.<a class="indexterm" id="IDX-CHP-24-0103"/><a class="indexterm" id="IDX-CHP-24-0104"/><a class="indexterm" id="IDX-CHP-24-0105"/><a class="indexterm" id="IDX-CHP-24-0106"/><a class="indexterm" id="IDX-CHP-24-0107"/><a class="indexterm" id="IDX-CHP-24-0108"/><a class="indexterm" id="IDX-CHP-24-0109"/><a class="indexterm" id="IDX-CHP-24-0110"/><a class="indexterm" id="IDX-CHP-24-0111"/><a class="indexterm" id="IDX-CHP-24-0112"/><a class="indexterm" id="IDX-CHP-24-0113"/><a class="indexterm" id="IDX-CHP-24-0114"/><a class="indexterm" id="IDX-CHP-24-0115"/></p></div><div class="sect2" title="Tracing"><div class="titlepage"><div><div><h2 class="title"><a id="tracing"/>Tracing</h2></div></div></div><p>Tracing offers a means of logging specific events that occur while a process is executing. Trace events are logged to a fixed-size trace buffer and may optionally be logged to a trace file. Two styles of tracing are available: instruction tracing and function tracing. When <span class="emphasis"><em>instruction tracing</em></span> is enabled (Debugger ▸ Tracing ▸ Instruction Tracing), IDA records the address, the instruction, and the values of any registers (other than EIP) that were changed by the instruction. Instruction tracing can slow down a debugged process considerably, because the debugger must single-step the process in order to monitor and record all register values. <span class="emphasis"><em>Function tracing</em></span> (Debugger ▸ Tracing ▸ Function Tracing) is a subset of instruction tracing in which only function calls (and optionally returns) are logged. No register values are logged for function trace events.<a class="indexterm" id="IDX-CHP-24-0116"/></p><p>Three types of individual trace events are also available: write traces, read/write traces, and execution traces. As their names imply, each allows logging of a trace event when a specific action occurs at a designated address. Each of these individual traces is implemented using nonbreaking breakpoints with the <code class="literal">trace</code> option set. Write and read/write traces are implemented using hardware breakpoints and thus fall under the same restrictions mentioned previously for hardware breakpoints, the most significant being that no more than four hardware-assisted breakpoints or traces may be active at any given time. By default, execution traces are implemented using software breakpoints, and thus there is no limit on the number of execution traces that can be set within a program.<a class="indexterm" id="IDX-CHP-24-0117"/><a class="indexterm" id="IDX-CHP-24-0118"/><a class="indexterm" id="IDX-CHP-24-0119"/></p><p><a class="xref" href="ch24s03.html#the_tracing_options_dialog" title="Figure 24-10. The Tracing Options dialog">Figure 24-10</a> shows the Tracing Options (Debugger ▸ Tracing ▸ Tracing Options) dialog used to configure the debugger’s tracing operations.</p><p>Options specified here apply to function and instruction tracing only. These options have no effect on individual trace events. The Trace buffer size option specifies the maximum number of trace events that may be displayed at any given time. For a given buffer size <span class="emphasis"><em>n</em></span>, only the <span class="emphasis"><em>n</em></span> most recent trace events are displayed. Naming a log file causes all trace events to be appended to the named file. A file dialog is not offered when specifying a log file, so you must specify the complete path to the log file yourself. An IDC expression may be entered as a stop condition. The condition is evaluated prior to tracing through each instruction. If the condition evaluates to true, execution is immediately paused. The effect of this expression is to act as a conditional breakpoint that is not tied to any specific location.</p><div class="figure"><a id="the_tracing_options_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e42070"/><img alt="The Tracing Options dialog" src="httpatomoreillycomsourcenostarchimages854383.png.jpg"/></div></div><p class="title">Figure 24-10. The Tracing Options dialog</p></div><p>The Mark consecutive traced events with same IP option, when checked, causes consecutive trace events originating from the same instruction (<span class="emphasis"><em>IP</em></span> here means <span class="emphasis"><em>Instruction Pointer</em></span>) to be flagged with an equal sign. An example in which consecutive events can originate at the same instruction address occurs when the <code class="literal">REP</code><sup>[<a class="footnote" href="#ftn.CHP-24-FN-9" id="CHP-24-FN-9">224</a>]</sup> prefix is used in <code class="literal">x86</code> programs. In order for an instruction trace to show each repetition at the same instruction address, the Log if same IP option must also be selected. Without this option selected, an instruction prefixed with <code class="literal">REP</code> is listed only once each time it is encountered. The following listing shows a partial instruction trace using the default trace settings:<a class="indexterm" id="IDX-CHP-24-0120"/><a class="indexterm" id="IDX-CHP-24-0121"/><a class="indexterm" id="IDX-CHP-24-0122"/><a class="indexterm" id="IDX-CHP-24-0123"/><a class="indexterm" id="IDX-CHP-24-0124"/><a class="indexterm" id="IDX-CHP-24-0125"/></p><a id="I_programlisting1_d1e42123"/><pre class="programlisting">Thread   Address             Instruction    Result
   ------   -------             -----------    ------
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  00000150
 .text:sub_401320+17 rep movsb      ECX=00000000 ESI=0022FE2C EDI=0022FCF4
   00000150 .text:sub_401320+19 pop esi        ESI=00000000 ESP=0022FCE4</pre><p>Note that the <code class="literal">movsb</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42136"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is listed only once.</p><p>In the following listing, Log if same IP has been selected, resulting in each iteration of the <code class="literal">rep</code> loop being logged:</p><a id="I_programlisting1_d1e42147"/><pre class="programlisting">Thread   Address             Instruction   Result
------   -------             -----------   ------
000012AC .text:sub_401320+17 rep movsb     ECX=0000000B
 ESI=0022FE21 EDI=0022FCE9 EFL=00010206 RF=1
000012AC .text:sub_401320+17 rep movsb     ECX=0000000A ESI=0022FE22 EDI=0022FCEA
000012AC .text:sub_401320+17 rep movsb     ECX=00000009 ESI=0022FE23 EDI=0022FCEB
000012AC .text:sub_401320+17 rep movsb     ECX=00000008 ESI=0022FE24 EDI=0022FCEC
000012AC .text:sub_401320+17 rep movsb     ECX=00000007 ESI=0022FE25 EDI=0022FCED
000012AC .text:sub_401320+17 rep movsb     ECX=00000006 ESI=0022FE26 EDI=0022FCEE
000012AC .text:sub_401320+17 rep movsb     ECX=00000005 ESI=0022FE27 EDI=0022FCEF
000012AC .text:sub_401320+17 rep movsb     ECX=00000004 ESI=0022FE28 EDI=0022FCF0
000012AC .text:sub_401320+17 rep movsb     ECX=00000003 ESI=0022FE29 EDI=0022FCF1
000012AC .text:sub_401320+17 rep movsb     ECX=00000002 ESI=0022FE2A EDI=0022FCF2
000012AC .text:sub_401320+17 rep movsb     ECX=00000001 ESI=0022FE2B EDI=0022FCF3
000012AC .text:sub_401320+17 rep movsb     ECX=00000000
 ESI=0022FE2C EDI=0022FCF4 EFL=00000206 RF=0
000012AC .text:sub_401320+19 pop esi       ESI=00000000 ESP=0022FCE4</pre><p>Finally, in the following listing, the Mark consecutive traced events with same IP option has been enabled, resulting in special markings that highlight the fact that the instruction pointer has not changed from one instruction to the next:<a class="indexterm" id="IDX-CHP-24-0126"/><a class="indexterm" id="IDX-CHP-24-0127"/><a class="indexterm" id="IDX-CHP-24-0128"/><a class="indexterm" id="IDX-CHP-24-0129"/><a class="indexterm" id="IDX-CHP-24-0130"/><a class="indexterm" id="IDX-CHP-24-0131"/></p><a id="I_programlisting1_d1e42176"/><pre class="programlisting">Thread   Address             Instruction  Result
------   -------             -----------  ------
000017AC .text:sub_401320+17 rep movsb    ECX=0000000B ESI=0022F
E21 EDI=0022FCE9 EFL=00010206 RF=1
=        =                   =            ECX=0000000A ESI=0022FE22 EDI=0022FCEA
=        =                   =            ECX=00000009 ESI=0022FE23 EDI=0022FCEB
=        =                   =            ECX=00000008 ESI=0022FE24 EDI=0022FCEC
=        =                   =            ECX=00000007 ESI=0022FE25 EDI=0022FCED
=        =                   =            ECX=00000006 ESI=0022FE26 EDI=0022FCEE
=        =                   =            ECX=00000005 ESI=0022FE27 EDI=0022FCEF
=        =                   =            ECX=00000004 ESI=0022FE28 EDI=0022FCF0
=        =                   =            ECX=00000003 ESI=0022FE29 EDI=0022FCF1
=        =                   =            ECX=00000002 ESI=0022FE2A EDI=0022FCF2
=        =                   =            ECX=00000001 ESI=0022FE2B EDI=0022FCF3
=        =                   =            ECX=00000000 ESI=0022FE2C
 EDI=0022FCF4 EFL=00000206 RF=0
000017AC .text:sub_401320+19 pop esi      ESI=00000000 ESP=0022FCE4</pre><p>The last two options we will mention concerning tracing are Trace over debugger segments and Trace over library functions. When Trace over debugger segments is selected, instruction and function call tracing is temporarily disabled anytime execution proceeds to a program segment outside any of the file segments originally loaded into IDA. The most common example of this is a call to a shared library function. Selecting Trace over library functions temporarily disables function and instruction tracing anytime execution enters a function that IDA has identified as a library function (perhaps via FLIRT signature matching). Library functions linked into a binary should not be confused with library functions that a binary accesses via a shared library file such as a DLL. Both of these options are enabled by default, resulting in better performance while tracing (because the debugger does not need to step into library code) as well as a substantial reduction in the number of trace events generated, since instruction traces through library code can rapidly fill the trace buffer.</p></div><div class="sect2" title="Stack Traces"><div class="titlepage"><div><div><h2 class="title"><a id="stack_traces"/>Stack Traces</h2></div></div></div><p>A <span class="emphasis"><em>stack trace</em></span> is a display of the current call stack, or sequence of function calls that have been made in order for execution to reach a particular location within a binary. <a class="xref" href="ch24s03.html#a_sample_stack_trace" title="Figure 24-11. A sample stack trace">Figure 24-11</a> shows a sample stack trace generated using the Debugger ▸ Stack Trace command.<a class="indexterm" id="IDX-CHP-24-0132"/></p><div class="figure"><a id="a_sample_stack_trace"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e42198"/><img alt="A sample stack trace" src="httpatomoreillycomsourcenostarchimages854386.png"/></div></div><p class="title">Figure 24-11. A sample stack trace</p></div><p>The top line in a stack trace lists the name of the function currently executing. The second line indicates the function that called the current function and the address from which that call was made. Successive lines indicate the point from which each function was called. A debugger is able to create a stack trace display by walking the stack and parsing each stack frame that it encounters, and it typically relies on the contents of the frame pointer register (EBP for x86) to locate the base of each stack frame. When a stack frame is located, the debugger can extract a pointer to the next stack frame (the saved frame pointer) as well as the saved return address, which is used to locate the call instruction used to invoke the current function. IDA’s debugger cannot trace through stack frames that do not utilize EBP as a frame pointer. At the function (rather than individual instruction) level, stack traces are useful for answering the question, “How did I get here?” or, more correctly, “What sequence of function calls led to this particular location?”<a class="indexterm" id="IDX-CHP-24-0133"/><a class="indexterm" id="IDX-CHP-24-0134"/><a class="indexterm" id="IDX-CHP-24-0135"/></p></div><div class="sect2" title="Watches"><div class="titlepage"><div><div><h2 class="title"><a id="watches"/>Watches</h2></div></div></div><p>While debugging a process, you may wish to constantly monitor the value contained in one or more variables. Rather than requiring you to navigate to the desired memory locations each time the process is paused, many debuggers allow you to specify lists of memory locations whose values should be displayed each time the process is stopped in the debugger. Such lists are called <span class="emphasis"><em>watch lists</em></span>, because they allow you to watch as the contents of designated memory locations change during program execution. Watch lists are simply a navigational convenience; they do not cause execution to pause like a breakpoint.<a class="indexterm" id="IDX-CHP-24-0136"/></p><p>Because they are focused on data, watch points (addresses designated to be watched) are most commonly set in the stack, heap, or data sections of a binary. Watches are set in the IDA debugger by right-clicking a memory item of interest and selecting Add Watch. Determining exactly which address to set a watch on may require some thought. Determining the address of a global variable is somewhat less challenging than determining the address of a local variable because global variables are allocated and assigned fixed addresses at compile time. Local variables, on the other hand, don’t exist until runtime, and even then they exist only once the function in which they are declared has been called. With the debugger active, once you have stepped into a function, IDA is capable of reporting the addresses of local variables within that function. <a class="xref" href="ch24s03.html#debugger_resolution_of_a_local_variable" title="Figure 24-12. Debugger resolution of a local variable address">Figure 24-12</a> shows the result of mousing over a local variable named <code class="literal">arg_0</code> (actually a parameter passed into the function).<a class="indexterm" id="IDX-CHP-24-0137"/><a class="indexterm" id="IDX-CHP-24-0138"/><a class="indexterm" id="IDX-CHP-24-0139"/></p><div class="figure"><a id="debugger_resolution_of_a_local_variable"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e42250"/><img alt="Debugger resolution of a local variable address" src="httpatomoreillycomsourcenostarchimages854389.png"/></div></div><p class="title">Figure 24-12. Debugger resolution of a local variable address</p></div><p>Double-clicking a local variable within an active function causes IDA to jump the main IDA View window to the address of that local variable. Having arrived at the variable’s address, you may then add a watch on that address using the Add Watch context-sensitive menu option, though you will need to manually enter the address into the Watch Address dialog. If, instead, you take the time to name the memory location, IDA will automatically add a watch if you apply the same menu option to the name rather than the address.<a class="indexterm" id="IDX-CHP-24-0140"/><a class="indexterm" id="IDX-CHP-24-0141"/><a class="indexterm" id="IDX-CHP-24-0142"/><a class="indexterm" id="IDX-CHP-24-0143"/><a class="indexterm" id="IDX-CHP-24-0144"/><a class="indexterm" id="IDX-CHP-24-0145"/><a class="indexterm" id="IDX-CHP-24-0146"/></p><p>You can access a list of all watches currently in effect via Debugger ▸ Watches ▸ Watch List. You can delete individual watches by highlighting the desired watch in the watch list and pressing DELETE.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-7" id="ftn.CHP-24-FN-7">222</a>] </sup>See <a class="ulink" href="http://www.intel.com/products/processor/manuals/">http://www.intel.com/products/processor/manuals/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-8" id="ftn.CHP-24-FN-8">223</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html">http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html</a> and <a class="ulink" href="http://www.hexblog.com/2005/11/stealth_plugin_1.html">http://www.hexblog.com/2005/11/stealth_plugin_1.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-9" id="ftn.CHP-24-FN-9">224</a>] </sup>The <code class="literal">REP</code> prefix is an instruction modifier that causes certain x86 string instructions such as <code class="literal">movs</code> and <code class="literal">scas</code> to be repeated based on a count contained in the ECX register.</p></div></div></div>
<div class="sect1" title="Automating Debugger Tasks"><div class="titlepage"><div><div><h1 class="title"><a id="automating_debugger_tasks"/>Automating Debugger Tasks</h1></div></div></div><p>In <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a> through <a class="xref" href="ch19.html" title="Chapter 19. IDA Processor Modules">Chapter 19</a>, we covered the basics of IDA scripting and the IDA SDK and demonstrated the usefulness of these capabilities during static analysis of binaries. Launching a process and working in the more dynamic environment of a debugger doesn’t make scripting and plug-ins any less useful. Interesting uses for the automation provided by scripts and plug-ins include analyzing runtime data available while a process is being debugged, implementing complex breakpoint conditions, and implementing measures to subvert anti-debugging techniques.</p><div class="sect2" title="Scripting Debugger Actions"><div class="titlepage"><div><div><h2 class="title"><a id="scripting_debugger_actions"/>Scripting Debugger Actions</h2></div></div></div><p>All of the IDA scripting capabilities discussed in <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a> continue to be accessible when you are using the IDA debugger. Scripts may be launched from the File menu, associated with hotkeys, and invoked from the IDA scripting command line. In addition, user-created IDC functions may be referenced from breakpoint conditions and tracing termination expressions.</p><p>Basic scripting functions offer the capability to set, modify, and enumerate breakpoints and the ability to read and write register and memory values. Memory access is provided by the <code class="literal">DbgByte</code>, <code class="literal">PatchDbgByte</code>, <code class="literal">DbgWord</code>, <code class="literal">PatchDbgWord</code>, <code class="literal">DbgDword</code>, and <code class="literal">PatchDbgDword</code> functions (analogous to the <code class="literal">Byte</code>, <code class="literal">Word</code>, <code class="literal">Dword</code>, and <code class="literal">Patch</code><em class="replaceable"><code>XXX</code></em> functions described in <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>). Register and breakpoint manipulation is made possible by the following functions (please see the IDA help file for a complete list).</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long GetRegValue(string reg)</code></strong></span></dt><dd><p>Returns the value of the named register, such as EAX, as discussed previously. In IDC only, register values may also be easily accessed by using the desired register’s name as a variable within an IDC expression.</p></dd><dt><span class="term"><strong class="userinput"><code>bool SetRegValue(number val, string name)</code></strong></span></dt><dd><p>Sets the value of the named register, such as EAX. If you are using IDC, register values may also be modified directly by using the desired register name on the left side of an assignment statement.<a class="indexterm" id="IDX-CHP-24-0147"/><a class="indexterm" id="IDX-CHP-24-0148"/><a class="indexterm" id="IDX-CHP-24-0149"/><a class="indexterm" id="IDX-CHP-24-0150"/><a class="indexterm" id="IDX-CHP-24-0151"/><a class="indexterm" id="IDX-CHP-24-0152"/><a class="indexterm" id="IDX-CHP-24-0153"/><a class="indexterm" id="IDX-CHP-24-0154"/><a class="indexterm" id="IDX-CHP-24-0155"/><a class="indexterm" id="IDX-CHP-24-0156"/></p></dd><dt><span class="term"><strong class="userinput"><code>bool AddBpt(long addr)</code></strong></span></dt><dd><p>Adds a software breakpoint at the indicated address.</p></dd><dt><span class="term"><strong class="userinput"><code>bool AddBptEx(long addr, long size, long type)</code></strong></span></dt><dd><p>Adds a breakpoint of the specified size and type at the indicated address. Type should be one of the <code class="literal">BPT_</code><em class="replaceable"><code>xxx</code></em> constants described in <span class="emphasis"><em>idc.idc</em></span> or the IDA help file.</p></dd><dt><span class="term"><strong class="userinput"><code>bool DelBpt(long addr)</code></strong></span></dt><dd><p>Deletes a breakpoint at the specified address.</p></dd><dt><span class="term"><strong class="userinput"><code>long GetBptQty()</code></strong></span></dt><dd><p>Returns the number of breakpoints set within a program.</p></dd><dt><span class="term"><strong class="userinput"><code>long GetBptEA(long bpt_num)</code></strong></span></dt><dd><p>Returns the address at which the indicated breakpoint is set.</p></dd><dt><span class="term"><strong class="userinput"><code>long/string GetBptAttr(long addr, number attr)</code></strong></span></dt><dd><p>Returns an attribute associated with the breakpoint at the indicated address. The return value may be a number or a string depending on which attribute value has been requested. Attributes are specified using one of the <code class="literal">BPTATTR_</code><em class="replaceable"><code>xxx</code></em> values described in <span class="emphasis"><em>idc.idc</em></span> or the IDA help file.</p></dd><dt><span class="term"><strong class="userinput"><code>bool SetBptAttr(long addr, number attr, long value)</code></strong></span></dt><dd><p>Sets the specified attribute of the specified breakpoint to the specified value. Do not use this function to set breakpoint condition expressions (use <code class="literal">SetBptCnd</code> instead).</p></dd><dt><span class="term"><strong class="userinput"><code>bool SetBptCnd(long addr, string cond)</code></strong></span></dt><dd><p>Sets the breakpoint condition to the provided conditional expression, which must be a valid IDC expression.</p></dd><dt><span class="term"><strong class="userinput"><code>long CheckBpt(long addr)</code></strong></span></dt><dd><p>Gets the breakpoint status at the specified address. Return values indicate whether there is no breakpoint, the breakpoint is disabled, the breakpoint is enabled, or the breakpoint is active. An active breakpoint is a breakpoint that is enabled while the debugger is also active.</p></dd></dl></div><p>The following script demonstrates how to install a custom IDC breakpoint-handling function at the current cursor location:</p><a id="I_programlisting1_d1e42469"/><pre class="programlisting">#include &lt;idc.idc&gt;
/*
 * The following should return 1 to break, and 0 to continue execution.
 */
static my_breakpoint_condition() {
   return AskYN(1, "my_breakpoint_condition activated, break now?") == 1;
}

/*
 * This function is required to register my_breakpoint_condition
 * as a breakpoint conditional expression
 */
static main() {
   auto addr;
   addr = ScreenEA();
   AddBpt(addr);
   SetBptCnd(addr, "my_breakpoint_condition()");
}</pre><p>The complexity of <code class="literal">my_breakpoint_condition</code> is entirely up to you. In this example, each time the breakpoint is hit, a dialog will be displayed asking the user if she would like to continue execution of the process or pause at the current location. The value returned by <code class="literal">my_breakpoint_condition</code> is used by the debugger to determine whether the breakpoint should be honored or ignored.<a class="indexterm" id="IDX-CHP-24-0157"/><a class="indexterm" id="IDX-CHP-24-0158"/><a class="indexterm" id="IDX-CHP-24-0159"/><a class="indexterm" id="IDX-CHP-24-0160"/><a class="indexterm" id="IDX-CHP-24-0161"/><a class="indexterm" id="IDX-CHP-24-0162"/><a class="indexterm" id="IDX-CHP-24-0163"/><a class="indexterm" id="IDX-CHP-24-0164"/><a class="indexterm" id="IDX-CHP-24-0165"/></p><p>Programmatic control of the debugger is possible from both the SDK and through the use of scripts. Within the SDK, IDA utilizes an event-driven model and provides callback notifications to plug-ins when specific debugger events occur. Unfortunately, IDA’s scripting capabilities don’t facilitate the use of an event-driven paradigm within scripts. As a result, Hex-Rays introduced a number of scripting functions that allow for synchronous control of the debugger from within scripts. The basic approach required to drive the debugger using a script is to initiate a debugger action and then wait for the corresponding debugger event code. Keep in mind that a call to a synchronous debugger function (which is all you can do in a script) blocks all other IDA operations until the call completes. The following list details several of the debugging extensions available for scripts:<a class="indexterm" id="IDX-CHP-24-0166"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long GetDebuggerEvent(long wait_evt, long timeout)</code></strong></span></dt><dd><p>Waits for a debugger event (as specified by <code class="literal">wait_evt</code>) to take place within the specified number of seconds (−1 waits forever). Returns an event type code that indicates the type of event that was received. Specify <code class="literal">wait_evt</code> using a combination of one or more <code class="literal">WFNE_</code><em class="replaceable"><code>xxx</code></em> (WFNE stands for Wait For Next Event) flags. Possible return values are documented in the IDA help file.</p></dd><dt><span class="term"><span class="strong"><strong>b</strong></span><strong class="userinput"><code>ool RunTo(long addr)</code></strong></span></dt><dd><p>Runs the process until the specified location is reached or until a breakpoint is hit.</p></dd><dt><span class="term"><strong class="userinput"><code>bool StepInto()</code></strong></span></dt><dd><p>Steps the process one instruction, stepping into any function calls.</p></dd><dt><span class="term"><strong class="userinput"><code>bool StepOver()</code></strong></span></dt><dd><p>Steps the process one instruction, stepping over any function calls. This call may terminate early if a breakpoint is hit.</p></dd><dt><span class="term"><strong class="userinput"><code>bool StepUntilRet()</code></strong></span></dt><dd><p>Runs until the current function call returns or until a breakpoint is hit.</p></dd><dt><span class="term"><strong class="userinput"><code>bool EnableTracing(long trace_level, long enable)</code></strong></span></dt><dd><p>Enables (or disables) the generation of trace events. The <code class="literal">trace_level</code> parameter should be set to one of the <code class="literal">TRACE_</code><em class="replaceable"><code>xxx</code></em> constants defined in <span class="emphasis"><em>idc.idc</em></span>.<a class="indexterm" id="IDX-CHP-24-0167"/><a class="indexterm" id="IDX-CHP-24-0168"/><a class="indexterm" id="IDX-CHP-24-0169"/><a class="indexterm" id="IDX-CHP-24-0170"/><a class="indexterm" id="IDX-CHP-24-0171"/><a class="indexterm" id="IDX-CHP-24-0172"/></p></dd><dt><span class="term"><strong class="userinput"><code>long GetEvent</code></strong><em class="replaceable"><code>XXX</code></em><strong class="userinput"><code>()</code></strong></span></dt><dd><p>A number of functions are available for retrieving information related to the current debug event. Some of these functions are valid only for specific event types. You should test the return value of <code class="literal">GetDebuggerEvent</code> in order to make sure that a particular <code class="literal">GetEvent</code><em class="replaceable"><code>XXX</code></em> function is valid.</p></dd></dl></div><p><code class="literal">GetDebuggerEvent</code> must be called after each function that causes the process to execute in order to retrieve the debugger’s event code. Failure to do so may prevent follow-up attempts to step or run the process. For example, the following code fragment will step the debugger only one time because <code class="literal">GetDebuggerEvent</code> does not get called to clear the last event type in between invocations of <code class="literal">StepOver</code>.</p><a id="I_programlisting1_d1e42627"/><pre class="programlisting">StepOver();
StepOver();    //this and all subsequent calls will fail
StepOver();
StepOver();</pre><p>The proper way to perform an execution action is to follow up each call with a call to <code class="literal">GetDebuggerEvent</code>, as shown in the following example:</p><a id="I_programlisting1_d1e42635"/><pre class="programlisting">StepOver();
GetDebuggerEvent(WFNE_SUSP, −1);
StepOver();
GetDebuggerEvent(WFNE_SUSP, −1);
StepOver();
GetDebuggerEvent(WFNE_SUSP, −1);
StepOver();
GetDebuggerEvent(WFNE_SUSP, −1);</pre><p>The calls to <code class="literal">GetDebuggerEvent</code> allow execution to continue even if you choose to ignore the return value from <code class="literal">GetDebuggerEvent</code>. The event type <code class="literal">WFNE_SUSP</code> indicates that we wish to wait for an event that results in suspension of the debugged process, such as an exception or a breakpoint. You may have noticed that there is no function that simply resumes execution of a suspended process.<sup>[<a class="footnote" href="#ftn.CHP-24-FN-10" id="CHP-24-FN-10">225</a>]</sup> However, it is possible to achieve the same effect by using the <code class="literal">WFNE_CONT</code> flag in a call to <code class="literal">GetDebuggerEvent</code>, as shown here:</p><a id="I_programlisting1_d1e42665"/><pre class="programlisting">GetDebuggerEvent(WFNE_SUSP | WFNE_CONT, −1);</pre><p>This particular call waits for the next available suspend event after first resuming execution by continuing the process from the current instruction.</p><p>Additional functions are provided for automatically launching the debugger and attaching to running processes. See IDA’s help file for more information on these functions.</p><p>An example of a simple debugger script for collecting statistics on the addresses of each executed instruction (provided the debugger is enabled) is shown here:</p><a id="I_programlisting1_d1e42673"/><pre class="programlisting">static main() {
     auto ca, code, addr, count, idx;
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    ca = GetArrayId("stats");
     if (ca != −1) {
        DeleteArray(ca);
     }
     ca = CreateArray("stats");
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>    EnableTracing(TRACE_STEP, 1);
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>    for (code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1); code &gt; 0;
            code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>       addr = GetEventEa();
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>       count = GetArrayElement(AR_LONG, ca, addr) + 1;
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>       SetArrayLong(ca, addr, count);
     }
     EnableTracing(TRACE_STEP, 0);
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>    for (idx = GetFirstIndex(AR_LONG, ca);
            idx != BADADDR;
            idx = GetNextIndex(AR_LONG, ca, idx)) {
        count = GetArrayElement(AR_LONG, ca, idx);
        Message("%x: %d\n", idx, count);
     }
<img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/>    DeleteArray(ca);
  }</pre><p>The script begins <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42726"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> by testing for the presence of a global array named <code class="literal">stats</code>. If one is found, the array is removed and re-created so that we can start with an empty array. Next <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42735"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, single-step tracing is enabled before entering a loop <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42741"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> to drive the single-stepping process. Each time a debug event is generated, the address of the associated event is retrieved <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42747"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>, the current count for the associated address is retrieved from the global array and incremented <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42754"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>, and the array is updated with the new count <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42760"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>. Note that the instruction pointer is used as the index into the sparse global array, which saves time looking up the address in some other form of data structure. Once the process completes, a second loop <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42766"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> is used to retrieve and print all values from array locations that have valid values. In this case, the only array indexes that will have valid values represent addresses from which instructions were fetched. The script finishes off <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42772"/><img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/></span> by deleting the global array that was used to gather the statistics. Example output from this script is shown here:<a class="indexterm" id="IDX-CHP-24-0173"/></p><a id="I_programlisting1_d1e42781"/><pre class="programlisting">401028: 1
40102b: 1
40102e: 2
401031: 2
401034: 2
401036: 1
40103b: 1</pre><p>A slight alteration of the preceding example can be used to gather statistics on what types of instructions are executed during the lifetime of a process. The following example shows the modifications required in the first loop to gather instruction-type data rather than address data:</p><a id="I_programlisting1_d1e42786"/><pre class="programlisting">for (code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1); code &gt; 0;
          code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)) {
        addr = GetEventEa();
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>       mnem = GetMnem(addr);
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>       count = GetHashLong(ht, mnem) + 1;
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>       SetHashLong(ht, mnem, count);
     }</pre><p>Rather than attempting to classify individual opcodes, we choose to group instructions by mnemonics <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42808"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. Because mnemonics are strings, we make use of the hash-table feature of global arrays to retrieve the current count associated with a given mnemonic <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42814"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and save the updated count <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42820"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> back into the correct hash table entry. Sample output from this modified script is shown here:</p><a id="I_programlisting1_d1e42826"/><pre class="programlisting">add:   18
and:   2
call:  46
cmp:   16
dec:   1
imul:  2
jge:   2
jmp:   5
jnz:   7
js:    1
jz:    5
lea:   4
mov:   56
pop:   25
push:  59
retn:  19
sar:   2
setnz: 3
test:  3
xor:   7</pre><p>In <a class="xref" href="ch25.html" title="Chapter 25. Disassembler/Debugger Integration">Chapter 25</a> we will revisit the use of debugger-interaction capabilities as a means to assist in de-obfuscating binaries.</p></div><div class="sect2" title="Automating Debugger Actions with IDA Plug-ins"><div class="titlepage"><div><div><h2 class="title"><a id="automating_debugger_actions_with_ida_plu"/>Automating Debugger Actions with IDA Plug-ins</h2></div></div></div><p>In <a class="xref" href="ch16.html" title="Chapter 16. The IDA Software Development Kit">Chapter 16</a> you learned that IDA’s SDK offers significant power for developing a variety of compiled extensions that can be integrated into IDA and that have complete access to the IDA API. The IDA API offers a superset of all the capabilities available in IDC, and the debugging extensions are no exception. Debugger extensions to the API are declared in <span class="emphasis"><em>&lt;SDKDIR&gt;/dbg.hpp</em></span> and include C++ counterparts to all of the IDC functions discussed thus far, along with a complete asynchronous debugger interface capability.<a class="indexterm" id="IDX-CHP-24-0174"/><a class="indexterm" id="IDX-CHP-24-0175"/><a class="indexterm" id="IDX-CHP-24-0176"/><a class="indexterm" id="IDX-CHP-24-0177"/><a class="indexterm" id="IDX-CHP-24-0178"/><a class="indexterm" id="IDX-CHP-24-0179"/><a class="indexterm" id="IDX-CHP-24-0180"/><a class="indexterm" id="IDX-CHP-24-0181"/><a class="indexterm" id="IDX-CHP-24-0182"/><a class="indexterm" id="IDX-CHP-24-0183"/><a class="indexterm" id="IDX-CHP-24-0184"/></p><p>For asynchronous interaction, plug-ins gain access to debugger notifications by hooking the <code class="literal">HT_DBG</code> notification type (see <span class="emphasis"><em>loader.hpp</em></span>). Debugger notifications are declared in the <code class="literal">dbg_notification_t</code> enum found in <span class="emphasis"><em>dbg.hpp</em></span>.<a class="indexterm" id="IDX-CHP-24-0185"/><a class="indexterm" id="IDX-CHP-24-0186"/></p><p>Within the debugger API, commands for interacting with the debugger are typically defined in pairs, with one function used for synchronous interaction (as with scripts) and the second function used for asynchronous interaction. Generically, the synchronous form of a function is named <code class="literal">COMMAND()</code>, and its asynchronous counterpart is named <code class="literal">request_COMMAND()</code>. The <code class="literal">request_</code><em class="replaceable"><code>XXX</code></em> versions are used to queue debugger actions for later processing. Once you finish queuing asynchronous requests, you must invoke the <code class="literal">run_requests</code> function to initiate processing of your request queue. As your requests are processed, debugger notifications will be delivered to any callback functions that you may have registered via <code class="literal">hook_to_notification_point</code>.</p><p>Using asynchronous notifications, we can develop an asynchronous version of the address-counting script from the previous section. The first task is to make sure that we hook and unhook debugger notifications. We will do this in the plug-in’s <code class="literal">init</code> and <code class="literal">term</code> methods, as shown here:</p><a id="I_programlisting1_d1e42927"/><pre class="programlisting">//A netnode to gather stats into
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> netnode stats("$ stats", 0, true);

int idaapi init(void) {
   hook_to_notification_point(HT_DBG, dbg_hook, NULL);
   return PLUGIN_KEEP;
}

void idaapi term(void) {
   unhook_from_notification_point(HT_DBG, dbg_hook, NULL);
}</pre><p>Note that we have also elected to declare a global netnode <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42937"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, which we will use to collect statistics. Next we consider what we want the plug-in to do when it is activated via its assigned hotkey. Our example plug-in <code class="literal">run</code> function is shown here:</p><a id="I_programlisting1_d1e42946"/><pre class="programlisting">void idaapi run(int arg) {
     stats.altdel();   //clear any existing stats
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    request_enable_step_trace();
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>    request_step_until_ret();
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>    run_requests();
  }</pre><p>Since we are using asynchronous techniques in this example, we must first submit a request to enable step tracing <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42968"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and then submit a request to resume execution of the process being debugged. For the sake of simplicity, we will gather statistics on the current function only, so we will issue a request to run until the current function returns <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42974"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. With our requests properly queued, we kick things off by invoking <code class="literal">run_requests</code> to process the current request queue <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e42983"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>.<a class="indexterm" id="IDX-CHP-24-0187"/><a class="indexterm" id="IDX-CHP-24-0188"/><a class="indexterm" id="IDX-CHP-24-0189"/><a class="indexterm" id="IDX-CHP-24-0190"/><a class="indexterm" id="IDX-CHP-24-0191"/></p><p>All that remains is to process the notifications that we expect to receive by creating our <code class="literal">HT_DBG</code> callback function. A simple callback that processes only two messages is shown here:</p><a id="I_programlisting1_d1e43010"/><pre class="programlisting">int idaapi dbg_hook(void *user_data, int notification_code, va_list va) {
     switch (notification_code) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>       case dbg_trace:  //notification arguments are detailed in dbg.hpp
           va_arg(va, thid_t);
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>          ea_t ea = va_arg(va, ea_t);
           //increment the count for this address
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>          stats.altset(ea, stats.altval(ea) + 1);
           return 0;
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>       case dbg_step_until_ret:
           //print results
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>          for
(nodeidx_t i = stats.alt1st(); i != BADNODE; i = stats.altnxt(i)) {
               msg("%x: %d\n", i, stats.altval(i));
           }
           //delete the netnode and stop tracing
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>          stats.kill();
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>          request_disable_step_trace();
<img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/>          run_requests();
           break;
     }
  }</pre><p>The <code class="literal">dbg_trace</code> notification <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43067"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> will be received for each instruction that executes until we turn tracing off. When a trace notification is received, the address of the trace point is retrieved from the args list <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43073"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and then used to update the appropriate netnode array index <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43079"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The <code class="literal">dbg_step_until_ret</code> notification <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43089"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> is sent once the process hits the <code class="literal">return</code> statement to leave the function in which we started. This notification is our signal that we should stop tracing and print any statistics we have gathered. A loop is used <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43098"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> to iterate through all valid index values of the <code class="literal">stats</code> netnode before destroying the netnode <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43107"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> and requesting that step tracing be disabled <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43113"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span>. Since this example uses asynchronous commands, the request to disable tracing is added to the queue, which means we have to issue <code class="literal">run_requests</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e43123"/><img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/></span> in order for the queue to be processed. An important warning about synchronous versus asynchronous interaction with the debugger is that you should never call the synchronous version of a function while actively processing an asynchronous notification message.</p><p>Synchronous interaction with the debugger using the SDK is done in a manner very similar to scripting the debugger. As with many of the SDK functions we have seen in previous chapters, the names of debugger-related functions typically do not match the names of related scripting functions, so you may need to spend some time combing through <span class="emphasis"><em>dbg.hpp</em></span> in order to find the functions you are looking for. The biggest disparity in names between scripting and the SDK is the SDK’s version of <code class="literal">GetDebuggerEvent</code>, which is called <code class="literal">wait_for_next_event</code> in the SDK. The other major difference between script functions and the SDK is that variables corresponding to the CPU registers are not automatically declared for you within the SDK. In order to access the values of CPU registers from the SDK, you must use the <code class="literal">get_reg_val</code> and <code class="literal">set_reg_val</code> functions to read and write registers, respectively.<a class="indexterm" id="IDX-CHP-24-0192"/><a class="indexterm" id="IDX-CHP-24-0193"/><a class="indexterm" id="IDX-CHP-24-0194"/><a class="indexterm" id="IDX-CHP-24-0195"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-24-FN-10" id="ftn.CHP-24-FN-10">225</a>] </sup>In reality, there is a macro named <code class="literal">ResumeProcess</code> that is defined as <code class="literal">GetDebuggerEvent(WFNE_CONT|WFNE_NOWAIT, 0)</code>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id23"/>Summary</h1></div></div></div><p>IDA may not have the largest share of the debugger market, but its debugger is powerful and integrates seamlessly with the disassembly side of IDA. While the debugger’s user interface, like that of any debugger, requires some initial getting used to, it offers all of the fundamental features that users require in a basic debugger. Strong points include scripting and plug-in capabilities along with the familiar user interface of IDA’s disassembly displays and the power of its analysis capabilities. Together the unified disassembler/debugger combination provides a solid tool for performing static analysis, dynamic analysis, or a combination of both.</p></div>
<div class="chapter" title="Chapter&#xA0;25.&#xA0;Disassembler/Debugger Integration"><div class="titlepage"><div><div><h1 class="title"><a id="disassembler_solidus_debugger_integratio"/>Chapter 25. Disassembler/Debugger Integration</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id24"/><div class="mediaobject"><a id="I_mediaobject2_d1e43168"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>An integrated disassembler/debugger combination such as IDA should be a pretty powerful tool for manipulating binaries and seamlessly applying static and dynamic techniques as part of the reverse engineering process. This turns out to be true if you understand the capabilities and limitations of each tool individually and in combination.</p><p>In this chapter we will discuss some important points concerning the manner in which the static side of IDA interacts with its dynamic side, and we will take a look at techniques that can be employed with IDA’s debugger in order to defeat certain anti-debugging (and anti-disassembly) techniques in the context of malware analysis. In that regard, it is important to remember that the goal in malware analysis is usually not to run the malware but to obtain a disassembly of sufficient quality to allow static analysis tools to take over. Recall from <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a> that there are many techniques designed specifically to prevent disassemblers from performing properly. In the face of such anti-disassembly techniques, the debugger is simply one means to an end. By running an obfuscated program under debugger control, we will attempt to obtain a de-obfuscated version of the program, which we then prefer to analyze using the disassembler.<a class="indexterm" id="IDX-CHP-25-0001"/><a class="indexterm" id="IDX-CHP-25-0002"/><a class="indexterm" id="IDX-CHP-25-0003"/><a class="indexterm" id="IDX-CHP-25-0004"/><a class="indexterm" id="IDX-CHP-25-0005"/></p><div class="sect1" title="Background"><div class="titlepage"><div><div><h1 class="title"><a id="background"/>Background</h1></div></div></div><p>Some background on debugger-assisted de-obfuscation may be useful before proceeding. It is well known that an obfuscated program must de-obfuscate itself before it can get down to its intended business. The following steps provide a basic and somewhat simplistic guide for dynamic de-obfuscation of binaries.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Open an obfuscated program with a debugger.</p></li><li class="listitem"><p>Search for and set a breakpoint on the end of the de-obfuscation routine.</p></li><li class="listitem"><p>Launch the program from the debugger and wait for your breakpoint to trigger.</p></li><li class="listitem"><p>Utilize the debugger’s memory-dumping features to capture the current state of the process to a file.</p></li><li class="listitem"><p>Terminate the process before it can do anything malicious.</p></li><li class="listitem"><p>Perform static analysis on the captured process image.</p></li></ol></div><p>Most modern debuggers contain enough features to perform the tasks just mentioned. OllyDbg<sup>[<a class="footnote" href="#ftn.CHP-25-FN-1" id="CHP-25-FN-1">226</a>]</sup> is a very popular Windows-only debugger often used for such work. Step 2 is not always as straightforward as it may sound. It may take a combination of tools, including spending some amount of time in a disassembler such as IDA, or a lot of single stepping before the end of the de-obfuscation algorithm can be properly identified. In many cases, the end of de-obfuscation is marked by a behavior rather than a specific instruction. One such behavior might be a large change in the instruction pointer value, indicating a jump to a location far from the de-obfuscation code. In the case of <code class="literal">UPX</code>-packed binaries, for example, all you need to do is observe that the instruction pointer holds a value that is less than the program’s entry point address to know that de-obfuscation is complete and the program has jumped to the newly de-obfuscated code. In generic terms, this process is called <span class="emphasis"><em>original entry point (OEP) recognition</em></span>, the OEP being the address at which the program would have begun execution had it not been obfuscated.<a class="indexterm" id="IDX-CHP-25-0006"/><a class="indexterm" id="IDX-CHP-25-0007"/></p><p>Complicating matters, some modern obfuscators are capable of transforming an input executable into an equivalent byte code program, which is then executed on a custom virtual machine generated by the obfuscator.<sup>[<a class="footnote" href="#ftn.CHP-25-FN-2" id="CHP-25-FN-2">227</a>]</sup> Executables protected with such virtualizing obfuscators cannot be analyzed with the traditional expectation of recovering the original binary or locating the original entry point. This is a result of the fact that the original x86 (or other processor) instructions are not embedded in the obfuscated binary and are therefore unavailable for recovery.<a class="indexterm" id="IDX-CHP-25-0008"/><a class="indexterm" id="IDX-CHP-25-0009"/><a class="indexterm" id="IDX-CHP-25-0010"/><a class="indexterm" id="IDX-CHP-25-0011"/></p><p>If you are not careful, step 3 can be a dangerous one. In any case, you should always think twice before you allow a piece of malware to run unhindered in the hope that you have set your breakpoints or breakpoint conditions properly. If the program manages to bypass your breakpoint(s), it may well proceed to execute malicious code before you know what has happened. For this reason, attempts to de-obfuscate malware under debugger control should always be conducted in a sandbox environment that you are not afraid to wipe clean in the event things go wrong.</p><p>Step 4 may require some level of effort, because memory dumping is usually supported in debuggers, while entire-process image dumping may not be. The OllyDump<sup>[<a class="footnote" href="#ftn.CHP-25-FN-3" id="CHP-25-FN-3">228</a>]</sup> plug-in, by Gigapede, adds process-dumping capabilities to OllyDbg. Keep in mind that the image that gets dumped from memory contains content from a running process and does not necessarily reflect the original state of the binary at rest in a disk file. In malware analysis, however, the goal is generally to create not a working de-obfuscated executable file, but rather an image file that is correctly structured so that it can be loaded into a disassembler for further analysis.<a class="indexterm" id="IDX-CHP-25-0012"/><a class="indexterm" id="IDX-CHP-25-0013"/><a class="indexterm" id="IDX-CHP-25-0014"/></p><p>One of the trickiest parts of reconstructing a binary image from an obfuscated process is restoration of the program’s imported function table. As part of the obfuscation process, a program’s import table is often obfuscated as well. As a result, the de-obfuscation process must also take care of linking the newly de-obfuscated process to all of the shared libraries and functions the process requires in order to execute properly. The only trace of this process is usually a table of imported function addresses somewhere within the process’s memory image. When dumping a de-obfuscated process image to a file, steps are often taken to attempt to reconstruct a valid import table in the dumped process image. In order to do this, the headers of the dumped image need to be modified to point to a new import table structure that must properly reflect all of the shared library dependencies of the original de-obfuscated program. A popular tool for automating this process is the ImpREC<sup>[<a class="footnote" href="#ftn.CHP-25-FN-4" id="CHP-25-FN-4">229</a>]</sup> (Import REConstruction) utility by MackT. As with process dumping, keep in mind that extracting a standalone executable may not be your primary goal in malware analysis, in which case reconstructing valid headers and a working import table is less important than knowing which functions have been resolved and where the addresses of those functions have been stored.<a class="indexterm" id="IDX-CHP-25-0015"/><a class="indexterm" id="IDX-CHP-25-0016"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-1" id="ftn.CHP-25-FN-1">226</a>] </sup>See <a class="ulink" href="http://www.ollydbg.de/">http://www.ollydbg.de/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-2" id="ftn.CHP-25-FN-2">227</a>] </sup>For a discussion of one such obfuscator, VMProtect, see “Unpacking Virtualization Obfuscators” by Rolf Rooles at <a class="ulink" href="http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf">http://www.usenix.org/event/woot09/tech/full_papers/rolles.pdf</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-3" id="ftn.CHP-25-FN-3">228</a>] </sup>See <a class="ulink" href="http://www.woodmann.com/collaborative/tools/index.php/OllyDump">http://www.woodmann.com/collaborative/tools/index.php/OllyDump</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-4" id="ftn.CHP-25-FN-4">229</a>] </sup>See <a class="ulink" href="http://www.woodmann.com/collaborative/tools/index.php/ImpREC">http://www.woodmann.com/collaborative/tools/index.php/ImpREC</a>.</p></div></div></div>
<div class="sect1" title="IDA Databases and the IDA Debugger"><div class="titlepage"><div><div><h1 class="title"><a id="ida_databases_and_the_ida_debugger"/>IDA Databases and the IDA Debugger</h1></div></div></div><p>It is important that we begin with an understanding of how the debugger treats your database when you initiate (and terminate) a debugging session. A debugger needs a process image to work with. Debuggers obtain process images either by attaching to existing processes or by creating new processes from executable files. An IDA database does not contain a valid process image, nor in most cases can a valid process image be reconstructed from a database (if one could, then File ▸ Produce File ▸ Create EXE File might be simple to implement). When you launch a debugger session from IDA, the disassembler side informs the debugger side of the name of the original input file, which the debugger uses to create and attach to a new process. Information provided to the debugger includes disassembly formatting, symbol names, data formatting, and any comments that you have entered into the database. An important point to understand is that any patches (changes in byte content) you have applied to your database will not be reflected in the process being debugged. In other words, it is not possible to patch changes into the database and expect to observe the effect of those changes when you launch the debugger.<a class="indexterm" id="IDX-CHP-25-0017"/><a class="indexterm" id="IDX-CHP-25-0018"/><a class="indexterm" id="IDX-CHP-25-0019"/><a class="indexterm" id="IDX-CHP-25-0020"/><a class="indexterm" id="IDX-CHP-25-0021"/><a class="indexterm" id="IDX-CHP-25-0022"/><a class="indexterm" id="IDX-CHP-25-0023"/></p><p>The opposite holds true as well. When you have finished debugging a process and you return to disassembly mode, by default the only changes that will be reflected in the database are cosmetic in nature (such as renamed variables or functions). Any memory changes, such as self-modified code, are not pulled back into the database for you to analyze. If you wish to migrate any content, such as newly de-obfuscated code, from the debugger back to your disassembly database, IDA will allow you to do so via the Debugger ▸ Take Memory Snapshot command. The resulting confirmation dialog is shown in <a class="xref" href="ch25s02.html#memory_snapshot_confirmation_dialog" title="Figure 25-1. Memory snapshot confirmation dialog">Figure 25-1</a>.<a class="indexterm" id="IDX-CHP-25-0024"/></p><div class="figure"><a id="memory_snapshot_confirmation_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e43345"/><img alt="Memory snapshot confirmation dialog" src="httpatomoreillycomsourcenostarchimages854392.png.jpg"/></div></div><p class="title">Figure 25-1. Memory snapshot confirmation dialog</p></div><p>The default option is to copy loader segments from the running process to the database. <span class="emphasis"><em>Loader segments</em></span> are those segments that were loaded into the database by the IDA loader module used to create the current database. In the case of an obfuscated program, one or more of these segments probably contain data that has been obfuscated and are therefore nearly impossible to analyze in the disassembler. These are precisely the segments that you will want to copy back from the running process image in order to take advantage of the de-obfuscation work performed by the process running under debugger control.</p><p>Selecting All segments causes all segments created by the debugger to be copied back to the database. These segments include the contents of all shared libraries loaded in support of the process as well as additional process-related segments, such as the stack and heap contents.</p><p>When the debugger is used to attach to an existing process with no associated database, none of the debugger segments will be flagged as loader segments because the file was not loaded by one of IDA’s loaders. In such cases, you may elect to capture all available segments into a new database. Alternatively, you may elect to edit segment attributes and designate one or more segments as loader segments. Segment attributes may be edited by first opening the Segments window (View ▸ Open Subviews ▸ Segments). Any segment marked as a loader segment will contain an <span class="emphasis"><em>L</em></span> in the L column of the Program Segmentation window. Right-clicking a segment of interest and selecting Edit Segment opens the segment attributes dialog shown in <a class="xref" href="ch25s02.html#segment_editing_dialog_with_the_loader_s" title="Figure 25-2. Segment editing dialog with the Loader segment checkbox">Figure 25-2</a>.<a class="indexterm" id="IDX-CHP-25-0025"/><a class="indexterm" id="IDX-CHP-25-0026"/><a class="indexterm" id="IDX-CHP-25-0027"/><a class="indexterm" id="IDX-CHP-25-0028"/><a class="indexterm" id="IDX-CHP-25-0029"/><a class="indexterm" id="IDX-CHP-25-0030"/></p><div class="figure"><a id="segment_editing_dialog_with_the_loader_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e43389"/><img alt="Segment editing dialog with the Loader segment checkbox" src="httpatomoreillycomsourcenostarchimages854395.png.jpg"/></div></div><p class="title">Figure 25-2. Segment editing dialog with the Loader segment checkbox</p></div><p>Selecting the Loader segment checkbox marks the segment as a loader segment and allows it to be copied into the database along with all other loader segments.</p><p>The segment attributes dialog is also useful when you have created a process from an open database and wish to add additional loader segments before taking a memory snapshot. For example, if an obfuscated process extracts the original code into a block of memory allocated in the heap (or a memory-mapped block), you will want to mark that memory block as a loader segment before you snapshot memory; otherwise, the de-obfuscated code will not be copied back into your database.</p></div>
<div class="sect1" title="Debugging Obfuscated Code"><div class="titlepage"><div><div><h1 class="title"><a id="debugging_obfuscated_code"/>Debugging Obfuscated Code</h1></div></div></div><p>We have mentioned a number of times that loading an obfuscated program in a debugger, allowing it to run until the de-obfuscation is complete, and then taking a memory snapshot of the program in its de-obfuscated state seems like a good strategy for obtaining a de-obfuscated version of a program. Controlled execution is probably a better way of thinking about this process than debugging, because all we are really doing is observing the code in operation and then taking a memory snapshot at the appropriate moment. A debugger simply happens to be the tool that allows us to accomplish this task. At least that is what we are hoping for. In <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a> we discussed several anti-disassembly and anti-debugging techniques that obfuscators utilize in an attempt to prevent us from obtaining a clear picture of a program. It is time to see how IDA’s debugger can help us bypass some of these techniques.</p><p>For this chapter we will assume that the obfuscated programs we are dealing with employ some form of encryption or compression on the interesting portions of the binary. The level of difficulty in obtaining a clear picture of that code depends entirely on the sophistication of any anti-analysis techniques used in the obfuscation process and the measures that can be developed to circumvent these techniques. Before we get started, however, here are a few rules to live by when working with malware in a debugging environment:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Protect your network and host environments. Always work in a sandbox environment.</p></li><li class="listitem"><p>On initial analysis, use single stepping when possible. It may be tedious, but it is your best defense against a program escaping your control.</p></li><li class="listitem"><p>Always think twice before executing a debugger command that will allow more than a single instruction to execute. If you have not planned properly, the program you are debugging may run into a malicious portion of the code.</p></li><li class="listitem"><p>When possible, use hardware breakpoints. It is difficult to set software breakpoints in obfuscated code, because de-obfuscation algorithms may modify the breakpoint instructions that you have inserted or compute checksums over regions of code.<sup>[<a class="footnote" href="#ftn.CHP-25-FN-5" id="CHP-25-FN-5">230</a>]</sup><a class="indexterm" id="IDX-CHP-25-0031"/><a class="indexterm" id="IDX-CHP-25-0032"/></p></li><li class="listitem"><p>When examining a program for the first time, it is best to allow the debugger to handle all exceptions generated by the program so that you can make informed decisions about which exceptions to pass to the program and which exceptions the debugger should continue to catch.</p></li><li class="listitem"><p>Be prepared to restart debugging often, because one wrong step can lead you down a road to failure (for example, if you allow the process to detect the debugger). Keep detailed notes regarding addresses that are safe to run to so that you can rapidly recover when you restart the process.</p></li></ol></div><p>In general, you should always take a very cautious approach the first time you start to work with a particular obfuscated program. In most cases your primary goal should be to obtain a de-obfuscated version of the program. Speeding up the de-obfuscation process by learning exactly how far you can go before you need to set a breakpoint should be a secondary goal, and it is probably best saved for a follow-on exercise once you have managed to successfully de-obfuscate a program for the first time.</p><div class="sect2" title="Launching the Process"><div class="titlepage"><div><div><h2 class="title"><a id="launching_the_process"/>Launching the Process</h2></div></div></div><p>Whether you have spent minutes or hours studying a malicious executable with IDA, you will probably want to gain control of it at the earliest opportunity the first time you launch it in the debugger. One of the easiest ways to gain control over a process is to set a breakpoint at the process entry point, the first instruction executed once the operation has finished creating the process’s memory image. In most cases this will be the symbol labeled <code class="literal">start</code>; however, in some cases it won’t. The PE file format, for example, allows for the designation TLS<sup>[<a class="footnote" href="#ftn.CHP-25-FN-6" id="CHP-25-FN-6">231</a>]</sup> callback functions designed to perform initialization and destruction tasks for data that is local to each thread, and these TLS callback functions are invoked before control is ever transferred to <code class="literal">start</code>.<a class="indexterm" id="IDX-CHP-25-0033"/><a class="indexterm" id="IDX-CHP-25-0034"/><a class="indexterm" id="IDX-CHP-25-0035"/><a class="indexterm" id="IDX-CHP-25-0036"/><a class="indexterm" id="IDX-CHP-25-0037"/></p><p>Malware authors are well aware of TLS callback functions and have made use of these functions to have code executed before a program’s main entry point code gets a chance to run. The hope is that anyone analyzing the malware will fail to notice the presence of the TLS callback, with a resulting failure to understand the true behavior of the program being analyzed. IDA properly parses PE file headers and recognizes the presence of any TLS callbacks contained within a PE file, adding any such functions to the binary’s list of entry points in the Exports window. <a class="xref" href="ch25s03.html#exports_window_showing_a_tls_callback_fu" title="Figure 25-3. Exports window showing a TLS callback function">Figure 25-3</a> shows the Exports window for an executable that contains a TLS callback.<a class="indexterm" id="IDX-CHP-25-0038"/></p><div class="figure"><a id="exports_window_showing_a_tls_callback_fu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e43488"/><img alt="Exports window showing a TLS callback function" src="httpatomoreillycomsourcenostarchimages854398.png.jpg"/></div></div><p class="title">Figure 25-3. Exports window showing a TLS callback function</p></div><p>The bottom line when it comes to TLS callbacks is to recognize their presence and then set breakpoints at the beginning of each TLS callback function to ensure that you gain control of the process before it is too late.</p><p>Many debuggers offer options to specify when (if at all) the debugger should pause following initial process creation, and IDA is no exception. <a class="xref" href="ch25s03.html#debugger_pausing_events" title="Figure 25-4. Debugger pausing events">Figure 25-4</a> shows a portion of IDA’s Debugger Setup dialog (Debugger ▸ Debugger Options).<a class="indexterm" id="IDX-CHP-25-0039"/></p><div class="figure"><a id="debugger_pausing_events"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e43507"/><img alt="Debugger pausing events" src="httpatomoreillycomsourcenostarchimages854401.png.jpg"/></div></div><p class="title">Figure 25-4. Debugger pausing events</p></div><p>Each of the available options offers the opportunity to automatically pause the process being debugged when specific events occur. Each of these events is summarized in the following list:<a class="indexterm" id="IDX-CHP-25-0040"/><a class="indexterm" id="IDX-CHP-25-0041"/><a class="indexterm" id="IDX-CHP-25-0042"/><a class="indexterm" id="IDX-CHP-25-0043"/><a class="indexterm" id="IDX-CHP-25-0044"/><a class="indexterm" id="IDX-CHP-25-0045"/><a class="indexterm" id="IDX-CHP-25-0046"/><a class="indexterm" id="IDX-CHP-25-0047"/><a class="indexterm" id="IDX-CHP-25-0048"/><a class="indexterm" id="IDX-CHP-25-0049"/><a class="indexterm" id="IDX-CHP-25-0050"/><a class="indexterm" id="IDX-CHP-25-0051"/></p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="strong"><strong>Stop on debugging start</strong></span> This option offers the earliest opportunity to pause the debugger following process creation. For example, on Windows 7, this will pause the process at the beginning of the <code class="literal">RtlUserThread-Star</code><code class="literal">t</code> function within <span class="emphasis"><em>ntdll.dll</em></span>. This will pause execution before any program code, including TLS callback functions, is executed.</td></tr><tr><td><span class="strong"><strong>Stop on process entry point</strong></span> Causes the debugger to pause execution once the program entry point is reached. This typically coincides with the symbol named <code class="literal">start</code> (or its equivalent) in your IDA database. Any TLS callback functions will already have executed before this event takes place.</td></tr><tr><td><span class="strong"><strong>Stop on thread start/exit</strong></span> Pauses the debugger each time a new thread starts or an existing thread terminates. On a Windows system, when this event fires, the debugger will pause somewhere within <span class="emphasis"><em>kernel32.dll</em></span>.</td></tr><tr><td><span class="strong"><strong>Stop on library load/unload</strong></span>  Pauses the debugger each time a new library is loaded or an existing library is unloaded. On a Windows system, when this event fires, the debugger will pause somewhere within <span class="emphasis"><em>kernel32.dll</em></span>.</td></tr><tr><td><span class="strong"><strong>Stop on debugging message</strong></span> Pauses execution each time the process outputs a message using the debug print facility. On Windows systems, this corresponds to a call to <code class="literal">OutputDebugString</code>, and execution is paused within <span class="emphasis"><em>kernel32.dll</em></span>.</td></tr></table><p>Understanding where the process is likely to be paused for each of these debugger events is important in order to keep the process you are debugging from executing further than you intend it to. Once you are certain that you will gain control of the process in a predictable manner, you can move on to getting some work done with the debugger.</p></div><div class="sect2" title="Simple Decryption and Decompression Loops"><div class="titlepage"><div><div><h2 class="title"><a id="simple_decryption_and_decompression_loop"/>Simple Decryption and Decompression Loops</h2></div></div></div><p>When we say <span class="emphasis"><em>simple decryption and decompression loops</em></span>, we mean loops that employ no nested obfuscation techniques and for which you can identify, with certainty, all possible exit points. When you encounter such loops, the easiest way to get through them is to set a breakpoint at all possible exit points and then allow the loop to execute. Consider single stepping through such loops one or two times in order to get a feel for them; then set breakpoints accordingly. When setting a breakpoint immediately following a loop, you should make sure that the bytes at the address at which you are setting the breakpoint will not be changed during the course of the loop; otherwise, a software breakpoint may fail to trigger. When in doubt, use a hardware breakpoint.<a class="indexterm" id="IDX-CHP-25-0052"/><a class="indexterm" id="IDX-CHP-25-0053"/></p><p>If your goal is to develop a fully automated de-obfuscation process, you will need to develop an algorithm for recognizing when the de-obfuscation process has completed. When this condition is satisfied, your automated solution can pause the process, at which point you can acquire a memory snapshot. For simple de-obfuscation routines, recognizing the end of the de-obfuscation stage may be as simple as noting a large change in the value of the instruction pointer or the execution of a specific instruction. For example, the beginning and end of the <code class="literal">UPX</code> decompression routine for an obfuscated Windows executable are shown in the following listing:<a class="indexterm" id="IDX-CHP-25-0054"/><a class="indexterm" id="IDX-CHP-25-0055"/><a class="indexterm" id="IDX-CHP-25-0056"/></p><a id="I_programlisting2_d1e43635"/><pre class="programlisting">UPX1:00410370 start proc near
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>   UPX1:00410370 pusha
    UPX1:00410371 mov     esi, offset off_40A000
    UPX1:00410376 lea     edi, [esi-9000h]
    UPX1:0041037C push    edi
    ...
    UPX1:004104EC pop     eax
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>   UPX1:004104ED popa                            ; opcode 0x53
    UPX1:004104EE lea     eax, [esp-80h]
    UPX1:004104F2
    UPX1:004104F2 loc_4104F2:                       ; CODE XREF: start+186↓j
    UPX1:004104F2 push    0
    UPX1:004104F4 cmp     esp, eax
    UPX1:004104F6 jnz     short loc_4104F2
    UPX1:004104F8 sub     esp, 0FFFFFF80h
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>   UPX1:004104FB jmp     loc_40134C</pre><p>Several characteristics of this routine can be used to automatically recognize its completion. First, the routine begins by pushing all registers onto the stack at the program entry point <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43657"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. The complementary operation of popping all registers occurs near the end of the routine <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43663"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> after the program has been decompressed. Finally, control is transferred <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43669"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> to the newly unpacked program. Thus, one strategy for automating decompression would be to step trace the program until the current instruction is a <code class="literal">popa</code>. Because step tracing is slow, the IDC script shown in <a class="xref" href="ch25s03.html#simple_upx_unpacker_script" title="Example 25-1. Simple UPX unpacker script">Example 25-1</a> takes the slightly different approach of scanning for the <code class="literal">popa</code> instruction and then running the program to the address of the <code class="literal">popa</code>:</p><div class="example"><a id="simple_upx_unpacker_script"/><p class="title">Example 25-1. Simple UPX unpacker script</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;

    #define POPA 0x53

    static main() {
       auto addr, seg;
       addr = BeginEA();   //Obtain the entry point address
       seg = SegName(addr);
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>      while (addr != BADADDR &amp;&amp; SegName(addr) == seg) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>         if (Byte(addr) == POPA) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>            RunTo(addr);
             GetDebuggerEvent(WFNE_SUSP, −1);
             Warning("Program is unpacked!");
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>            TakeMemorySnapshot(1);
             return;
            }
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>         addr = FindCode(addr, SEARCH_NEXT | SEARCH_DOWN);
       }
       Warning("Failed to locate popa!");
    }</pre></div></div><p>The script in <a class="xref" href="ch25s03.html#simple_upx_unpacker_script" title="Example 25-1. Simple UPX unpacker script">Example 25-1</a> is designed to be launched within an IDA database, prior to launching the debugger, and assumes that you have previously selected a debugger using Debugger ▸ Select debugger. The script takes care of the details of launching the debugger and gaining control of the newly created process. This script relies on some very specific features of UPX and is therefore not a good candidate for use as a generic de-obfuscation script. It does, however, demonstrate some concepts that might be used in later efforts. The script depends on the fact that the decompression routine resides at the end of one of the program segments (typically named <code class="literal">UPX1</code>) and that <code class="literal">UPX</code> does not make use of any desynchronization techniques to prevent proper disassembly.<a class="indexterm" id="IDX-CHP-25-0057"/><a class="indexterm" id="IDX-CHP-25-0058"/><a class="indexterm" id="IDX-CHP-25-0059"/><a class="indexterm" id="IDX-CHP-25-0060"/></p><div class="sidebar"><a id="obfuscating_obfuscators"/><p class="title">OBFUSCATING OBFUSCATORS</p><p>UPX is one of the more popular obfuscation utilities in use today (perhaps because it is free). Its popularity does not make it a particularly effective tool, however. One of the principal drawbacks to its effectiveness is the fact that UPX itself offers a command-line option to restore a UPX-packed binary to its original form. Consequently, a cottage industry has evolved for developing tools to prevent UPX from unpacking itself. Because UPX performs some integrity checks on a compressed binary before it will unpack that binary, simple changes that cause the integrity checks to fail without affecting the operation of the compressed binary render UPX’s own unpacking feature inoperative. One such technique involves changing the default UPX section names to anything other than UPX0, UPX1, and UPX2. For this reason, it is useful to avoid hardcoding these segment names into any scripts that you develop for unpacking UPX.</p></div><p>The script relies on these facts in order to scan forward, one instruction at a time <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43755"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, from the program entry point, as long as the next instruction lies within the same program segment <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43761"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and until the current instruction is a <code class="literal">popa</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43770"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. Once the <code class="literal">popa</code> instruction is located, the debugger is invoked <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43780"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> to execute the process up to the address of the <code class="literal">popa</code> instruction, at which point the program has been decompressed. The last step is to take a memory snapshot <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43789"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> to pull the de-obfuscated program bytes back into our database for further analysis.</p><p>An even more general-purpose solution for automated unpacking is to exploit the fact that many de-obfuscation routines are appended to the end of a binary and perform a jump to the original entry point, which occurs much earlier in the binary, once de-obfuscation is complete. In some cases, the original entry point may lie in an entirely different program segment, while in other cases, the original entry point simply precedes any address used by the de-obfuscation code. The Python script in <a class="xref" href="ch25s03.html#generic_attempt_to_run_until_oep_is_hit" title="Example 25-2. Generic attempt to run until OEP is hit">Example 25-2</a> offers a more basic means of running a simple de-obfuscation algorithm until it jumps to the program’s original entry point:<a class="indexterm" id="IDX-CHP-25-0061"/><a class="indexterm" id="IDX-CHP-25-0062"/></p><div class="example"><a id="generic_attempt_to_run_until_oep_is_hit"/><p class="title">Example 25-2. Generic attempt to run until OEP is hit</p><div class="example-contents"><pre class="programlisting">start = BeginEA()
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  RunTo(start)
   GetDebuggerEvent(WFNE_SUSP, −1)
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>  EnableTracing(TRACE_STEP, 1)
   code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)
   while code &gt; 0:
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>     if GetEventEa() &lt; start: break
      code = GetDebuggerEvent(WFNE_ANY | WFNE_CONT, −1)
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>  PauseProcess()
   GetDebuggerEvent(WFNE_SUSP, −1)
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>  EnableTracing(TRACE_STEP, 0)
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>  MakeCode(GetEventEa())
   TakeMemorySnapshot(1)</pre></div></div><p>Similar to the script in <a class="xref" href="ch25s03.html#simple_upx_unpacker_script" title="Example 25-1. Simple UPX unpacker script">Example 25-1</a>, this script should be launched from the disassembler rather than the debugger and again assumes that a debugger has been selected. The script handles the details of launching the debugger and gaining the necessary control of the newly created process. This particular script makes two assumptions: that all code prior to the entry point is obfuscated and that nothing malicious takes place prior to transferring control to an address that precedes the entry point. The script begins by launching the debugger and pausing at the program entry point <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43854"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. Next, the program enables step tracing <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43860"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and loops to test the address of each generated event <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43866"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. Once the event address precedes the program entry point address, de-obfuscation is assumed to be complete, and the process is paused <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43872"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> and step tracing disabled <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43879"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>. Finally, for good measure, the script ensures that the bytes at the current instruction pointer location are formatted as code <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e43885"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>.</p><p>When stepping your way through obfuscated code, it is not uncommon to encounter the warning shown in <a class="xref" href="ch25s03.html#debugger_instruction_pointer_warning" title="Figure 25-5. Debugger instruction pointer warning">Figure 25-5</a>.</p><div class="figure"><a id="debugger_instruction_pointer_warning"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e43898"/><img alt="Debugger instruction pointer warning" src="httpatomoreillycomsourcenostarchimages854405.png.jpg"/></div></div><p class="title">Figure 25-5. Debugger instruction pointer warning</p></div><p>This warning indicates that the instruction pointer is pointing into an item that IDA believed was data or that the instruction pointer is pointing into the middle of a previously disassembled instruction. This warning is frequently encountered when single stepping through code that utilizes disassembly desynchronization techniques. It is also often encountered when a program jumps to a region that was once data and is now code, as happens following the de-obfuscation of a program. Answering yes to the question causes IDA to reformat the bytes in question as code, which should be the proper thing to do since the instruction pointer indicates that this is the next item to be fetched for execution.<a class="indexterm" id="IDX-CHP-25-0063"/><a class="indexterm" id="IDX-CHP-25-0064"/><a class="indexterm" id="IDX-CHP-25-0065"/></p><p>Note that because of its use of step tracing, the script in <a class="xref" href="ch25s03.html#generic_attempt_to_run_until_oep_is_hit" title="Example 25-2. Generic attempt to run until OEP is hit">Example 25-2</a> will be substantially slower than the script in <a class="xref" href="ch25s03.html#simple_upx_unpacker_script" title="Example 25-1. Simple UPX unpacker script">Example 25-1</a>. However, for the price of slower execution, we gain a couple of advantages. First, we are able to specify a termination condition that is not tied to any one address. This is not possible when using breakpoints alone. Second, this script is immune to any attempts to desynchronize the disassembler because instruction boundaries are determined purely based on runtime values of the instruction pointer rather than static disassembly analysis. In its announcement introducing scripted debugging features,<sup>[<a class="footnote" href="#ftn.CHP-25-FN-7" id="CHP-25-FN-7">232</a>]</sup> Hex-Rays presents a far more robust script for performing the tasks of a <span class="emphasis"><em>universal unpacker</em></span>.</p></div><div class="sect2" title="Import Table Reconstruction"><div class="titlepage"><div><div><h2 class="title"><a id="import_table_reconstruction"/>Import Table Reconstruction</h2></div></div></div><p>Once a binary has been de-obfuscated, analysis of that binary can begin. While we may never intend to execute the de-obfuscated program (in fact, we cannot execute that program if a snapshot was pulled directly into an IDA database), a program’s import table is almost always a valuable resource for developing an understanding of the program’s behavior.</p><p>Under normal circumstances, IDA is able to parse a program’s import table as part of the file-loading process upon initial database creation. Unfortunately, in obfuscated programs, the only import table that IDA sees at load time belongs to the de-obfuscation component of the program. This import table typically contains a bare minimum of functions required to complete the de-obfuscation process. The most sophisticated obfuscators may generate empty import tables, in which case the de-obfuscation component must contain all of the code necessary to load libraries and resolve necessary functions on its own.</p><p>As for the binary that has been obfuscated, in most cases its import table has been obfuscated as well and is reconstructed, in some form, as part of the de-obfuscation process. The reconstruction process typically relies on newly de-obfuscated data in order to perform its own library loading and function address resolution. For Windows programs, this nearly always involves calls to the <code class="literal">LoadLibrary</code> function combined with repeated calls to <code class="literal">GetProcAddress</code> to resolve required function addresses.</p><p>More sophisticated import table reconstruction routines may utilize custom lookup functions in place of <code class="literal">GetProcAddress</code> in order to avoid triggering any breakpoints set on <code class="literal">GetProcAddress</code> itself. Such routines may also substitute the use of hash values in place of strings for identifying which function’s address is being requested. In rare cases, import table reconstructors may go so far as to bypass <code class="literal">LoadLibrary</code> as well, in which case the reconstruction routine must implement its own custom version of that function.<a class="indexterm" id="IDX-CHP-25-0066"/><a class="indexterm" id="IDX-CHP-25-0067"/></p><p>The net result of the import table reconstruction process is usually a table of function addresses, none of which have much meaning in a static analysis context. If we take a memory snapshot of a process, the best we are likely to come up with is something like the following partial listing:</p><a id="I_programlisting2_d1e43971"/><pre class="programlisting">UPX1:0040A000 dword_40A000    dd 7C812F1Dh        ; DATA XREF: start+1↓o
UPX1:0040A004 dword_40A004    dd 7C91043Dh        ; DATA XREF: sub_403BF3+68↑r
UPX1:0040A004                                     ; sub_405F0B+2B4↑r ...
UPX1:0040A008                 dd 7C812ADEh
UPX1:0040A00C dword_40A00C    dd 7C9105D4h        ; DATA XREF: sub_40621F+5D↑r
UPX1:0040A00C                                     ; sub_4070E8+F↑r ...
UPX1:0040A010                 dd 7C80ABC1h
UPX1:0040A014 dword_40A014    dd 7C901005h        ; DATA XREF: sub_401564+34↑r
UPX1:0040A014                                     ; sub_4015A0+27↑r ...</pre><p>This block of data depicts a number of 4-byte values, all in close proximity to one another and referenced from various locations with the program. The problem is that these values, such as <code class="literal">7C812F1Dh</code>, represent addresses of library functions as they were mapped in the process we were debugging. Within the code section of the program itself, we would see function calls similar to the following:</p><a id="I_programlisting2_d1e43978"/><pre class="programlisting">UPX0:00403C5B               <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    ds:dword_40A004
UPX0:00403C61                 test    eax, eax
UPX0:00403C63                 jnz     short loc_403C7B
UPX0:00403C65                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>call    sub_40230F
UPX0:00403C6A                 mov     esi, eax
UPX0:00403C6C                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>call    ds:dword_40A058</pre><p>Note that two of the function calls, <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44000"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44006"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> refer to the contents of the reconstructed import table, while a third function call <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44012"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> refers to a function whose body is present in the database. In an ideal world, each entry in the reconstructed import table would be named after the function whose address it contains.</p><p>This problem is best addressed before taking a memory snapshot of the de-obfuscated process. As shown in the next listing, if we view the same memory range from within the debugger, we get an entirely different picture. Since the debugger has access to the memory regions in which each referenced function lies, the debugger is able to display addresses (such as <code class="literal">7C812F1Dh</code>) as their corresponding symbolic names (in this case <code class="literal">kernel32_GetCommandLineA</code>).</p><a id="I_programlisting2_d1e44027"/><pre class="programlisting">UPX1:0040A000 off_40A000 dd offset kernel32_GetCommand
LineA ; DATA XREF:UPX0:loc_40128F↑r
UPX1:0040A000                                               ; start+1↓o
UPX1:0040A004 off_40A004 dd offset ntdll_RtlFreeHeap        ; DATA XREF:
 UPX0:004011E4↑r
UPX1:0040A004                                               ; UPX0:0040120A↑r ...
UPX1:0040A008 off_40A008 dd offset kernel32_GetVersionExA   ; DATA
 XREF: UPX0:004011D4↑r
UPX1:0040A00C dd offset ntdll_RtlAllocateHeap               ; DATA
 XREF: UPX0:004011B3↑r
UPX1:0040A00C                                               ; sub_405E98+D↑r ...
UPX1:0040A010 off_40A010 dd offset kernel32_GetProcessHeap  ; DATA
 XREF: UPX0:004011AA↑r
UPX1:0040A014 dd offset ntdll_RtlEnterCriticalSection ; DATA XREF: sub_401564+34↑r
UPX1:0040A014                                         ; sub_4015A0+27↑r ...</pre><p>It is worth noting at this point that the debugger adopts a slightly different naming scheme than we are accustomed to. The debugger prefixes all functions exported from shared libraries with the name of the associated library followed by an underscore. For example, the function <code class="literal">GetCommandLineA</code> in <span class="emphasis"><em>kernel32.dll</em></span> is assigned the name <code class="literal">kernel32_GetCommandLineA</code>. This ensures that unique names are generated should two libraries export the same name.<a class="indexterm" id="IDX-CHP-25-0068"/><a class="indexterm" id="IDX-CHP-25-0069"/><a class="indexterm" id="IDX-CHP-25-0070"/><a class="indexterm" id="IDX-CHP-25-0071"/><a class="indexterm" id="IDX-CHP-25-0072"/><a class="indexterm" id="IDX-CHP-25-0073"/><a class="indexterm" id="IDX-CHP-25-0074"/><a class="indexterm" id="IDX-CHP-25-0075"/></p><p>We need to overcome two problems with the import table shown in the preceding listing. First, in order for function calls to become more readable, we need to name each entry in the import table according to the function it references. If the entries are named properly, IDA will automatically display function signatures from its type libraries. Naming each import table entry is a relatively easy task as long as we have a name to assign. This leads to the second problem: obtaining the proper name. One approach is to parse the debugger-generated name, strip off the library name, and assign the remaining text as the name of the import table entry. The only problem with this approach is the fact that library names and function names may both contain underscore characters, making it difficult in some cases to determine the exact length of a function’s name within a longer name string. Recognizing this difficulty, this is nonetheless the approach taken by the <span class="emphasis"><em>renimp.idc</em></span> import table–renaming script that ships with IDA (found in <span class="emphasis"><em>&lt;IDADIR&gt;/idc</em></span>).</p><p>In order for this script to execute properly, it must be run while the debugger is active (so that it has access to loaded library names), and we must be able to locate the reconstructed import table within the de-obfuscated binary. One strategy for determining where the reconstructed import table will lie is to track calls to <code class="literal">GetProcAddress</code> and note where the results are stored into memory. <a class="xref" href="ch25s03.html#upx_code_to_resolve_and_store_imported_f" title="Example 25-3. UPX code to resolve and store imported function addresses">Example 25-3</a> shows the code used by UPX to call <code class="literal">GetProcAddress</code> and store the result.</p><div class="example"><a id="upx_code_to_resolve_and_store_imported_f"/><p class="title">Example 25-3. UPX code to resolve and store imported function addresses</p><div class="example-contents"><pre class="programlisting">UPX1:00408897           <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    dword ptr [esi+8090h]
UPX1:0040889D             or      eax, eax
UPX1:0040889F             jz      short loc_4088A8
UPX1:004088A1            <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     [ebx], eax
UPX1:004088A3            <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>add     ebx, 4</pre></div></div><p>The call to <code class="literal">GetProcAddress</code> takes place at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44115"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, with the result being stored into memory at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44121"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Making note of the value held in the <code class="literal">ebx</code> register at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44130"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> will tell us where the import table is located. The <code class="literal">ebx</code> register is advanced by four bytes at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44140"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> to prepare it for the next iteration of the function resolution loop.</p><p>Once we have located the reconstructed import table, <span class="emphasis"><em>renimp.idc</em></span> requires that we highlight the contents of the table using a click-and-drag operation from the beginning to the end of the table. The <span class="emphasis"><em>renimp.idc</em></span> script iterates across the selection, obtains the name of the referenced function, strips the library name prefix, and names the import table entry accordingly. Following execution of this script, the import table shown previously is transformed into the import table shown here:<a class="indexterm" id="IDX-CHP-25-0076"/></p><a id="I_programlisting2_d1e44157"/><pre class="programlisting">UPX1:0040A000 ; LPSTR __stdcall GetCommandLineA()
UPX1:0040A000 GetCommandLineA dd offset kernel32_GetCommandLineA
UPX1:0040A000                                         ; DATA XREF: UPX0:loc_40128F↑r
UPX1:0040A000                                         ; start+1↓o
UPX1:0040A004 RtlFreeHeap dd offset ntdll_RtlFreeHeap ; DATA XREF: UPX0:004011E4↑r
UPX1:0040A004                                         ; UPX0:0040120A↑r ...
UPX1:0040A008 ; BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
UPX1:0040A008 GetVersionExA dd offset kernel32_GetVersionExA ; DATA
 XREF: UPX0:004011D4↑r
UPX1:0040A00C RtlAllocateHeap dd offset ntdll_RtlAllocateHeap ; DATA
 XREF: UPX0:004011B3↑r
UPX1:0040A00C                                         ; sub_405E98+D↑r ...
UPX1:0040A010 ; HANDLE __stdcall GetProcessHeap()
UPX1:0040A010 GetProcessHeap dd offset kernel
32_GetProcessHeap ; DATA XREF: UPX0:004011AA↑r
UPX1:0040A014 RtlEnterCriticalSection dd offset ntdll_RtlEnterCriticalSection
UPX1:0040A014                                         ; DATA XREF: sub_401564+34↑r
UPX1:0040A014                                         ; sub_4015A0+27↑r ...</pre><p>We see that the script has done the work of renaming each import table entry, but IDA has added function prototypes for each function whose type information IDA is aware of. Note that no type information would be visible if the library name prefix had not been stripped from each function name. The <span class="emphasis"><em>renimp.idc</em></span> script can fail to properly extract an imported function name when the name of the module in which the function resides contains an underscore. The ws2_32 networking library is a well-known example of a module whose name happens to contain an underscore. Special handling of ws2_32 takes place within <span class="emphasis"><em>renimp.idc</em></span>; however, any other module whose name contains an underscore will cause <span class="emphasis"><em>renimp.idc</em></span> to parse function names incorrectly.<a class="indexterm" id="IDX-CHP-25-0077"/><a class="indexterm" id="IDX-CHP-25-0078"/></p><p>An alternative approach to renaming import table entries may be employed when a single instruction is responsible for storing all resolved function addresses as UPX does in <a class="xref" href="ch25s03.html#upx_code_to_resolve_and_store_imported_f" title="Example 25-3. UPX code to resolve and store imported function addresses">Example 25-3</a>. If such an instruction can be identified, such as the instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44180"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> in the listing, then we can take advantage of the fact that breakpoint conditions in IDA are specified using IDC statements. In this case we might set a conditional breakpoint at address <code class="literal">004088A1</code> and make the conditional expression invoke a function that we define. Here we name the function <code class="literal">createImportLabel</code> and define it as follows:<a class="indexterm" id="IDX-CHP-25-0079"/><a class="indexterm" id="IDX-CHP-25-0080"/></p><a id="I_programlisting2_d1e44200"/><pre class="programlisting">static createImportLabel() {
   auto n = Name(EAX);
   auto i = strstr(n, "_");
   while (i != −1) {
      n = n[i+1:];
      i = strstr(n, "_");
   }
   MakeUnkn(EBX,DOUNK_EXPAND);
   MakeDword(EBX);
   if (MakeNameEx(EBX,n,SN_NOWARN) == 0) {
      MakeNameEx(EBX,n + "_",SN_NOWARN);
   }
   return 0;
}</pre><p>This function begins by querying for the name referenced by EAX. Recall that EAX contains the result of the call to <code class="literal">GetProcAddress</code> and thus should refer to a function within some DLL. Next, the function loops to truncate the name to just that portion following the last underscore found in the original name. Finally, a series of function calls is made to properly format the target location (referenced by EBX) as a 4-byte data item, and apply a name to that location. By returning zero, the function informs IDA that the breakpoint should not be honored, with the result that execution continues without pausing.<a class="indexterm" id="IDX-CHP-25-0081"/><a class="indexterm" id="IDX-CHP-25-0082"/><a class="indexterm" id="IDX-CHP-25-0083"/><a class="indexterm" id="IDX-CHP-25-0084"/><a class="indexterm" id="IDX-CHP-25-0085"/></p><p>In <a class="xref" href="ch24.html" title="Chapter 24. The IDA Debugger">Chapter 24</a>, we discussed how to specify breakpoint conditions in IDA’s debugger. Installing a user-defined function as a breakpoint handler is not quite as straightforward as setting and editing a breakpoint and entering <code class="literal">createImportLabel()</code> as the breakpoint condition. While this is exactly the condition that we wish to enter in this case, the problem is that, from IDA’s perspective, <code class="literal">createImportLabel</code> is an undefined function. The workaround for this is to create a script file (IDC by definition) containing our function along with a simple <code class="literal">main</code> function that looks something like the following:</p><a id="I_programlisting2_d1e44238"/><pre class="programlisting">static main() {
   <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>AddBpt(ScreenEA());
   <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>SetBptCnd(ScreenEA(), "createImportLabel()");
}</pre><p>Placing the cursor on the instruction that you wish to set the breakpoint on and then running this script (File ▸ Script File) results in a conditional breakpoint that calls <code class="literal">createImportLabel</code> each time it is hit. The <code class="literal">AddBpt</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44260"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> adds a breakpoint at the specified location (the cursor location in this case), and the <code class="literal">SetBptCnd</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44269"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> adds a condition to an existing breakpoint. The condition is specified as a string containing the IDC statement to evaluate each time the breakpoint is hit. With this breakpoint in place, once the de-obfuscation has completed, we will have a labeled import table without having to go through the trouble of locating the table within the process’s memory space.</p><p>Yet another approach for deriving name information involves searching memory for the file headers associated with a function address and then parsing the export table described in those headers to locate the name of the function being referenced. This is essentially a reverse lookup of a function name given the function’s address. Scripts (<span class="emphasis"><em>RebuildImports.idc/RebuildImports.py</em></span>) based on this concept are available on the book’s website. Either of these scripts may be executed in lieu of <span class="emphasis"><em>renimp.idc</em></span> with nearly identical results. The problems faced by <span class="emphasis"><em>renimp.idc</em></span> when dealing with modules whose names contain an underscore character are avoided because function names are extracted directly from export tables present in the process address space.<a class="indexterm" id="IDX-CHP-25-0086"/><a class="indexterm" id="IDX-CHP-25-0087"/><a class="indexterm" id="IDX-CHP-25-0088"/><a class="indexterm" id="IDX-CHP-25-0089"/><a class="indexterm" id="IDX-CHP-25-0090"/><a class="indexterm" id="IDX-CHP-25-0091"/><a class="indexterm" id="IDX-CHP-25-0092"/><a class="indexterm" id="IDX-CHP-25-0093"/><a class="indexterm" id="IDX-CHP-25-0094"/></p><p>The effect of naming each import table entry properly carries through to the disassembly itself, as shown in the following automatically updated disassembly listing:</p><a id="I_programlisting2_d1e44326"/><pre class="programlisting">UPX0:00403C5B call    ds:RtlFreeHeap
UPX0:00403C61 test    eax, eax
UPX0:00403C63 jnz     short loc_403C7B
UPX0:00403C65 call    sub_40230F
UPX0:00403C6A mov     esi, eax
UPX0:00403C6C call    ds:RtlGetLastWin32Error</pre><p>The name of each renamed import table entry is propagated to all locations from which imported functions are called, making the disassembly far more readable. It is worth noting that any formatting changes that you make while you’re working within the debugger are automatically applied to the database view as well. In other words, there is no need to take a memory snapshot simply to capture formatting changes that you have made. The purpose of a memory snapshot is to migrate memory content (code and data) from a processes address space back into an IDA database.</p></div><div class="sect2" title="Hiding the Debugger"><div class="titlepage"><div><div><h2 class="title"><a id="hiding_the_debugger"/>Hiding the Debugger</h2></div></div></div><p>A popular method of preventing the use of debuggers as de-obfuscation tools is <span class="emphasis"><em>debugger detection</em></span>. The authors of obfuscation tools understand just as well as you do that debuggers are useful for undoing their handiwork. In response, they often take measures to prevent their tools from running if the tools detect the presence of a debugger. We discussed a few debugger-detection methods in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>. As mentioned in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>, Nicolas Falliere’s article “Windows Anti-Debug Reference”<sup>[<a class="footnote" href="#ftn.CHP-25-FN-8" id="CHP-25-FN-8">233</a>]</sup> contains an excellent summary of a number of Windows-specific techniques for detecting the presence of a debugger. You can counter several of these detection techniques by using a simple script to start your debugger session and automatically configure some breakpoints. While it is possible to use Python to counter some of these techniques, we will ultimately be using conditional breakpoints, which we can only specify using IDC. For this reason the sample code that follows is all written in IDC.</p><p>In order to launch a debugging session from a script, we begin with the following code:</p><a id="I_programlisting2_d1e44350"/><pre class="programlisting">auto n;
   for (n = 0; n &lt; GetEntryPointQty(); n++) {
      auto ord = GetEntryOrdinal(n);
      if (GetEntryName(ord) == "TlsCallback_0") {
         AddBpt(GetEntryPoint(ord));
         break;
      }
   }
   RunTo(BeginEA());
   GetDebuggerEvent(WFNE_SUSP, −1);</pre><p>These statements check for the presence of a TLS callback function, set a breakpoint if one is found, and then launch the debugger, requesting to break on the entry point address before waiting for the operation to complete (strictly speaking, we should test the return value of <code class="literal">GetDebuggerEvent</code> as well). Once our script regains control, we have an active debugger session, and the process we wish to debug is mapped into memory along with all libraries on which it depends.<a class="indexterm" id="IDX-CHP-25-0095"/><a class="indexterm" id="IDX-CHP-25-0096"/><a class="indexterm" id="IDX-CHP-25-0097"/><a class="indexterm" id="IDX-CHP-25-0098"/><a class="indexterm" id="IDX-CHP-25-0099"/><a class="indexterm" id="IDX-CHP-25-0100"/><a class="indexterm" id="IDX-CHP-25-0101"/><a class="indexterm" id="IDX-CHP-25-0102"/><a class="indexterm" id="IDX-CHP-25-0103"/><a class="indexterm" id="IDX-CHP-25-0104"/></p><p>The first debugger detection we will bypass is the <code class="literal">IsDebugged</code> field of the process environment block (PEB). This is a 1-byte field that is set to the value 1 if the process is being debugged and 0 otherwise. The field lies 2 bytes into the PEB, so all we need to do is find the PEB and patch the proper byte to the value 0. This also happens to be the field tested by the Windows API function <code class="literal">IsDebuggerPresent</code>, so we manage to kill two birds with one stone in this case. If we know that we have stopped at the program entry point as opposed to a TLS callback, then locating the PEB turns out to be rather simple, because the EBX register contains a pointer to the PEB upon entry to the process. If instead the process has stopped at a TLS callback function, then we need a more general-purpose means of finding the PEB. We will take an approach similar to that often used in shellcode and obfuscators. The basic idea is to locate the current <span class="emphasis"><em>thread information block (TIB)</em></span><sup>[<a class="footnote" href="#ftn.CHP-25-FN-9" id="CHP-25-FN-9">234</a>]</sup> and follow an embedded pointer to find the PEB. The following code locates the PEB and makes the appropriate patch:<a class="indexterm" id="IDX-CHP-25-0105"/><a class="indexterm" id="IDX-CHP-25-0106"/></p><a id="I_programlisting2_d1e44411"/><pre class="programlisting">auto seg;
   auto peb = 0;
   auto tid = GetCurrentThreadId();
   auto tib = sprintf("TIB[%08X]", tid); //IDA naming convention
   for (seg = FirstSeg(); seg != BADADDR; seg = NextSeg(seg)) {
      if (SegName(seg) == tib) {
         peb = Dword(seg + 0x30); //read PEB pointer from TIB
         break;
      }
   }
   if (peb != 0) {
      PatchDbgByte(peb + 2, 0);  //Set PEB!IsDebugged to zero
   }</pre><p>Note that the <code class="literal">PatchDbgByte</code> function was not introduced until IDA 5.5. When used with versions prior to IDA 5.5, <code class="literal">PatchByte</code> will work but will also modify (patch) the database if the address specified is present in the database.</p><p>Another anti-debugging technique mentioned in Falliere’s article involves testing several bits in another field of the PEB named <code class="literal">NtGlobalFlags</code>. The bits relate to the operation of a process’s heap and are set to 1 when a process is being debugged. Assuming variable <code class="literal">peb</code> remains set from the previous example, the following code retrieves the <code class="literal">NtGlobalFlags</code> field from the PEB, resets the offending bits, and stores the flags back into the PEB.<a class="indexterm" id="IDX-CHP-25-0107"/><a class="indexterm" id="IDX-CHP-25-0108"/><a class="indexterm" id="IDX-CHP-25-0109"/><a class="indexterm" id="IDX-CHP-25-0110"/><a class="indexterm" id="IDX-CHP-25-0111"/></p><a id="I_programlisting2_d1e44448"/><pre class="programlisting">globalFlags = Dword(peb + 0x68) &amp; ~0x70; //read and mask PEB.NtGlobalFlags
PatchDword(peb + 0x68, globalFlags);     //patch PEB.NtGlobalFlags</pre><p>Several techniques in Falliere’s article rely on differences in information returned by system functions when a process is being debugged as opposed to when a process is not being debugged. The first function mentioned in the article is <code class="literal">NtQueryInformationProcess</code>, found in <span class="emphasis"><em>ntdll.dll</em></span>. Using this function, a process may request information regarding its <span class="emphasis"><em>ProcessDebugPort</em></span>. If the process is being debugged, the result is non-zero; if it is not being debugged, the result should be zero. One way to avoid detection in this manner is to set a breakpoint on <code class="literal">NtQueryInformationProcess</code> and then specify a breakpoint condition function to filter out <code class="literal">ProcessDebugPort</code> requests. In order to automatically locate this instruction, we take the following steps:<a class="indexterm" id="IDX-CHP-25-0112"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Look up the address of <code class="literal">NtQueryInformationProcess</code>.</p></li><li class="listitem"><p>Set a breakpoint on <code class="literal">NtQueryInformationProcess</code>.</p></li><li class="listitem"><p>Add a breakpoint condition to call a function we will name <code class="literal">bpt_NtQueryInformationProcess</code>, which will be executed each time <code class="literal">NtQuery-InformationProcess</code> gets called.</p></li></ol></div><p>In order to find the address of <code class="literal">NtQueryInformationProcess</code>, we need to remember that the function will be named <code class="literal">ntdll_NtQueryInformationProcess</code> in the debugger. The code to configure the necessary breakpoint appears here:</p><a id="I_programlisting2_d1e44502"/><pre class="programlisting">func = LocByName("ntdll_NtQueryInformationProcess");
   AddBpt(func);
   SetBptCnd(func, "bpt_NtQueryInformationProcess()");</pre><p>What remains is for us to implement the breakpoint function that will keep the debugger hidden from an inquiring process. The prototype for <code class="literal">NtQueryInformationProcess</code> is shown here:</p><a id="I_programlisting2_d1e44509"/><pre class="programlisting">NTSTATUS WINAPI NtQueryInformationProcess(
      __in       HANDLE ProcessHandle,
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>     __in       PROCESSINFOCLASS ProcessInformationClass,
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>     __out      PVOID ProcessInformation,
      __in       ULONG ProcessInformationLength,
      __out_opt  PULONG ReturnLength
  );</pre><p>Information about a process is requested by providing an integer query identifier in the <code class="literal">ProcessInformationClass</code> parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44528"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. Information is returned via the user-supplied buffer pointed to by the <code class="literal">ProcessInformation</code> parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44537"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. A caller may pass the enumerated constant <code class="literal">ProcessDebugPort</code> (value 7) in order to query the debugging status of a given process. If a process is being debugged by a user-space debugger, the return value passed via the supplied pointer will be non-zero. If the process is not being debugged, the return value will be zero. A breakpoint function that always sets the <code class="literal">ProcessDebugPort</code> return value to zero is shown here:<a class="indexterm" id="IDX-CHP-25-0113"/><a class="indexterm" id="IDX-CHP-25-0114"/></p><a id="I_programlisting2_d1e44556"/><pre class="programlisting">#define ProcessDebugPort 7
  static bpt_NtQueryInformationProcess() {
     auto p_ret;
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>   if (Dword(ESP + 8) == ProcessDebugPort) {//test ProcessInformationClass
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>       p_ret = Dword(ESP + 12);
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>       if (p_ret) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>          PatchDword(p_ret, 0);  //fake no debugger present
        }
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>       EIP = Dword(ESP);   //skip function, just return
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>       ESP = ESP + 24;     //stdcall so clear args from stack
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>       EAX = 0;            //signifies success
     }
     return 0;  //don't pause at the breakpoint
  }</pre><p>Recall that this function is invoked each time <code class="literal">NtQueryInformationProcess</code> is called. On entry, the stack pointer is pointing to the saved return address, which lies on top of the five arguments to <code class="literal">NtQueryInformationProcess</code>. The breakpoint function begins by examining the value of the <code class="literal">ProcessInformation-Class</code> to determine whether the caller is requesting <code class="literal">ProcessDebugPort</code> information <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44615"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. If the caller is requesting <code class="literal">ProcessDebugPort</code>, the function continues by retrieving the return value pointer <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44625"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, testing that it is non-null <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44631"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, and finally storing a return value of zero <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44637"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> to make it appear that no debugger is attached. In order to skip the remainder of the function, EIP is then modified by reading the saved return address <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44643"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>, after which ESP is adjusted to simulate a <code class="literal">stdcall</code> return <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44653"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>. <code class="literal">NtQueryInformationProcess</code> returns an NTSTATUS code, which is set to 0 (success) at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44662"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> before returning.<a class="indexterm" id="IDX-CHP-25-0115"/></p><p>Another function mentioned in Falliere’s article is <code class="literal">NtSetInformation-Thread</code>, which is also found in <span class="emphasis"><em>ntdll.dll</em></span>. The prototype for this function is shown here:</p><a id="I_programlisting2_d1e44679"/><pre class="programlisting">NTSTATUS NtSetInformationThread(
   IN HANDLE  ThreadHandle,
   IN THREADINFOCLASS  ThreadInformationClass,
   IN PVOID  ThreadInformation,
   IN ULONG  ThreadInformationLength
);</pre><p>The anti-debugging technique involves passing the value <code class="literal">ThreadHideFromDebugger</code> in the <code class="literal">ThreadInformationClass</code> parameter, which causes a thread to be detached from a debugger. Bypassing this technique involves the same basic setup as the previous example. The resulting setup code is shown here:<a class="indexterm" id="IDX-CHP-25-0116"/><a class="indexterm" id="IDX-CHP-25-0117"/><a class="indexterm" id="IDX-CHP-25-0118"/></p><a id="I_programlisting2_d1e44699"/><pre class="programlisting">func = LocByName("ntdll_NtSetInformationThread");
AddBpt(func);                  //break at function entry
SetBptCnd(func, "bpt_NtSetInformationThread()");</pre><p>The associated breakpoint function is shown here:</p><a id="I_programlisting2_d1e44703"/><pre class="programlisting">#define ThreadHideFromDebugger 0x11
  static bpt_NtSetInformationThread() {
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    if
 (Dword(ESP + 8) == ThreadHideFromDebugger) {//test ThreadInformationClass
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>       EAX = 0;        //STATUS_SUCCESS
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>       EIP = Dword(ESP); //just return
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>       ESP = ESP + 20;   //simulate stdcall
     }
     return 0;
  }</pre><p>On entry we test the value of the <code class="literal">ThreadInformationClass</code> parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44734"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and bypass the function body if the user has specified <code class="literal">ThreadHideFromDebugger</code>. Bypassing the function body is accomplished by setting our desired return value <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44743"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and modifying the instruction pointer by reading the saved return address out of the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44749"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. We simulate the <code class="literal">stdcall</code> return by making a 20-byte adjustment to ESP <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44759"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>.</p><p>The last function that we will discuss, whose use as an anti-debugging technique is also discussed in Falliere’s article, is <code class="literal">OutputDebugStringA</code> from <span class="emphasis"><em>kernel32.dll</em></span>. The prototype of this function is shown here:<a class="indexterm" id="IDX-CHP-25-0119"/></p><a id="I_programlisting2_d1e44776"/><pre class="programlisting">void WINAPI OutputDebugStringA(
   __in_opt  LPCTSTR lpOutputString
);</pre><p>In this example, <code class="literal">WINAPI</code> is a synonym for <code class="literal">_stdcall</code> and is used to specify the calling convention employed by <code class="literal">OutputDebugStringA</code>. Strictly speaking, this function has no return value, as specified by the <code class="literal">void</code> return type in its prototype; however, according to the article, this function “returns” 1 when no debugger is attached to the calling process, and it “returns” the address of the string passed as a parameter if it is called while a debugger is attached to the calling process. Under normal circumstances, <code class="literal">_stdcall</code> functions that do return a value return that value in the EAX register. Since EAX must hold some value when <code class="literal">OutputDebugStringA</code> returns, it can be argued that this is the return value of the function; however, since the official return type is <code class="literal">void</code>, there is no documentation or guarantee as to what value EAX may actually hold in this case. This particular anti-debugging technique simply relies on the observed behavior of the function. One solution to the observed change in return values is to ensure that EAX contains 1 whenever <code class="literal">OutputDebugStringA</code> returns. The following IDC code implements this technique:<a class="indexterm" id="IDX-CHP-25-0120"/><a class="indexterm" id="IDX-CHP-25-0121"/><a class="indexterm" id="IDX-CHP-25-0122"/><a class="indexterm" id="IDX-CHP-25-0123"/></p><a id="I_programlisting2_d1e44819"/><pre class="programlisting">func = LocByName("kernel32_OutputDebugStringA");
  AddBpt(func);
  //fix the return value as expected in non-debugged processes
  //also adjust EIP and ESP
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> SetBptCnd(func, "!((EAX = 1) &amp;&amp; (EIP = Dword(ESP)) &amp;&amp; (ESP = ESP + 8))");</pre><p>This example uses the same technique for automatically locating the end of the <code class="literal">OutputDebugStringA</code> function that we used in the preceding examples. However, in contrast to the preceding example, the work that needs to be done when the breakpoint is hit is simple enough to be specified in an IDC expression <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e44832"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> (rather than requiring a dedicated function). In this case, the breakpoint expression modifies (note this is assignment rather than comparison) the EAX register to ensure that it contains 1 when the function returns and also adjusts EIP and ESP to bypass the function. The breakpoint condition is negated to cause the breakpoint to be skipped in all cases, because the result of the Boolean <span class="emphasis"><em>and</em></span> expression is always expected to be nonzero.</p><p>A script (<span class="emphasis"><em>HideDebugger.idc</em></span>) that combines all of the elements presented in this section into a useful tool for simultaneously initiating debugging sessions and implementing measures to combat anti-debugging attempts is available on the book’s website. For more information on hiding the presence of the debugger, please see Ilfak’s blog, where he presents several hiding techniques.<sup>[<a class="footnote" href="#ftn.CHP-25-FN-10" id="CHP-25-FN-10">235</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-5" id="ftn.CHP-25-FN-5">230</a>] </sup>Keep in mind that the software breakpoint instruction inserted by the debugger will cause the checksum computation to yield a result other than the expected result.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-6" id="ftn.CHP-25-FN-6">231</a>] </sup>For more information on Thread Local Storage (TLS) callback functions, please refer to the PE file format specification <a class="ulink" href="http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx">http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-7" id="ftn.CHP-25-FN-7">232</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/scriptable.htm">http://www.hex-rays.com/idapro/scriptable.htm</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-8" id="ftn.CHP-25-FN-8">233</a>] </sup>See <a class="ulink" href="http://www.symantec.com/connect/articles/windows-anti-debug-reference/">http://www.symantec.com/connect/articles/windows-anti-debug-reference/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-9" id="ftn.CHP-25-FN-9">234</a>] </sup>This is also known as a <span class="emphasis"><em>thread environment block (TEB)</em></span>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-10" id="ftn.CHP-25-FN-10">235</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html">http://www.hexblog.com/2005/11/simple_trick_to_hide_ida_debug.html</a>, <a class="ulink" href="http://www.hexblog.com/2005/11/stealth_plugin_1.html">http://www.hexblog.com/2005/11/stealth_plugin_1.html</a>, and <a class="ulink" href="http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html">http://www.hexblog.com/2005/11/the_ultimate_stealth_method_1.html</a>.</p></div></div></div>
<div class="sect1" title="IdaStealth"><div class="titlepage"><div><div><h1 class="title"><a id="idastealth"/>IdaStealth</h1></div></div></div><p>While the <span class="emphasis"><em>HideDebugger</em></span> script discussed in the previous section is useful for demonstrating some basic programmatic interaction with the debugger and some basics of library function hooking, the total number of known anti-debugging techniques and the complexity of those techniques argue for more robust anti-anti-debugging than can be provided by a simple script. Fortunately, the IdaStealth plug-in is designed to meet our needs for a power debugger-hiding capability. Written by Jan Newger, IdaStealth was the winner of Hex-Rays’s 2009 plug-in writing contest. The plug-in is written in C++ and is available in both source and binary form.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span><a class="indexterm" id="IDX-CHP-25-0124"/><a class="indexterm" id="IDX-CHP-25-0125"/><a class="indexterm" id="IDX-CHP-25-0126"/><a class="indexterm" id="IDX-CHP-25-0127"/><a class="indexterm" id="IDX-CHP-25-0128"/></p></td><td style="text-align: left" valign="top"><p>IDAStealth</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Jan Newger</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>C++Source and binary</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Windows debugger-hiding plug-in</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.newgre.net/idastealth/">http://www.newgre.net/idastealth/</a></p></td></tr></tbody></table></div><p>The binary components of IDAStealth consist of a plug-in and a helper library, both of which need to be installed to <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>. Upon initial activation, IDAStealth presents the configuration dialog shown in <a class="xref" href="ch25s04.html#idastealth_configuration_dialog" title="Figure 25-6. IDAStealth configuration dialog">Figure 25-6</a>.</p><div class="figure"><a id="idastealth_configuration_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e44947"/><img alt="IDAStealth configuration dialog" src="httpatomoreillycomsourcenostarchimages854408.png.jpg"/></div></div><p class="title">Figure 25-6. IDAStealth configuration dialog</p></div><p>Several tabs full of options allow you to decide which anti-anti-debugging techniques you wish to employ. Once activated, IDAStealth implements evasion techniques for virtually every known debugger-detection technique, including those discussed in the Falliere article and those addressed by the <span class="emphasis"><em>HideDebugger.idc</em></span> script developed earlier.</p></div>
<div class="sect1" title="Dealing with Exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="dealing_with_exceptions"/>Dealing with Exceptions</h1></div></div></div><p>Occasionally, programs expect to handle any exceptions generated during their execution. As we saw in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>, obfuscated programs often go so far as to intentionally generate exceptions as both an anti–control flow technique and an anti-debugging technique. Unfortunately, exceptions are often indicative of a problem, and the purpose of debuggers is to assist us in localizing problems. Therefore, debuggers typically want to handle all exceptions that occur when a program is running in order to help us find bugs.<a class="indexterm" id="IDX-CHP-25-0129"/><a class="indexterm" id="IDX-CHP-25-0130"/></p><p>When a program expects to handle its own exceptions, we need to prevent the debugger from intercepting such exceptions, or, at a minimum, once an exception is intercepted, we need a means to have the debugger forward the exception to the process at our discretion. Fortunately, IDA’s debugger has the capability to pass along individual exceptions as they occur or to automatically pass along all exceptions of a specified type.</p><p>Automated exception processing is configured via the Debugger ▸ Debugger Options command; the resulting dialog is shown in <a class="xref" href="ch25s05.html#the_debugger_setup_dialog" title="Figure 25-7. The Debugger Setup dialog">Figure 25-7</a>.<a class="indexterm" id="IDX-CHP-25-0131"/></p><div class="figure"><a id="the_debugger_setup_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e44984"/><img alt="The Debugger Setup dialog" src="httpatomoreillycomsourcenostarchimages854411.png.jpg"/></div></div><p class="title">Figure 25-7. The Debugger Setup dialog</p></div><p>In addition to allowing several events to be configured to automatically stop the debugger and a number of events to be automatically logged to IDA’s message window, the Debugger Setup dialog is used to configure the debugger’s exception-handling behavior. The Edit Exceptions button opens the Exceptions configuration dialog shown in <a class="xref" href="ch25s05.html#the_exceptions_configuration_dialog" title="Figure 25-8. The Exceptions configuration dialog">Figure 25-8</a>.<a class="indexterm" id="IDX-CHP-25-0132"/></p><div class="figure"><a id="the_exceptions_configuration_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e45001"/><img alt="The Exceptions configuration dialog" src="httpatomoreillycomsourcenostarchimages854414.png"/></div></div><p class="title">Figure 25-8. The Exceptions configuration dialog</p></div><p>For each exception type known to the debugger, the dialog lists an operating system–specific exception code, the name of the exception, whether the debugger will stop the process or not (<code class="literal">Stop/No</code>), and whether the debugger will handle the exception or automatically pass the exception to the application (<code class="literal">Debugger/Application</code>). A master list of exceptions and default settings for handling each exception is contained in <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/exceptions.cfg</em></span>. In addition, the configuration file contains messages to be displayed whenever an exception of a given type occurs while the debugger is executing a process. Changes to the debugger’s default exception-handling behavior may be made by editing <span class="emphasis"><em>exceptions.cfg</em></span> with a text editor. In <span class="emphasis"><em>exceptions.cfg</em></span>, the values <code class="literal">stop</code> and <code class="literal">nostop</code> are used to indicate whether the debugger should suspend the process or not when a given exception occurs.<a class="indexterm" id="IDX-CHP-25-0133"/></p><p>Exception handling may also be configured on a persession (that is, while you have a particular database open) basis by editing individual exceptions via the Exceptions configuration dialog. To modify the debugger’s behavior for a given exception type, right-click the desired exception in the Exceptions configuration dialog and select <span class="strong"><strong>Edit</strong></span>. <a class="xref" href="ch25s05.html#the_exception_editing_dialog" title="Figure 25-9. The Exception editing dialog">Figure 25-9</a> shows the resulting Exception editing dialog.<a class="indexterm" id="IDX-CHP-25-0134"/></p><div class="figure"><a id="the_exception_editing_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e45046"/><img alt="The Exception editing dialog" src="httpatomoreillycomsourcenostarchimages854417.png.jpg"/></div></div><p class="title">Figure 25-9. The Exception editing dialog</p></div><p>Two options, corresponding to the two configurable options in <span class="emphasis"><em>exceptions.cfg</em></span>, may be configured for any exception. First, it is possible to specify whether the debugger should stop the process when an exception of the specified type occurs or whether execution should continue. Beware: Allowing the process to continue may result in an infinite exception-generation loop if you also elect to have the debugger handle the exception.</p><p>The second configuration option allows you to decide whether a given exception type should be passed to the application being debugged so the application can have a chance to process the exception using its own exception handlers. When the proper operation of an application depends on such exception handlers being executed, you should choose to pass the associated exception types to the application. This may be required when analyzing obfuscated code such as that generated by the tElock utility (which registers its own exception handlers) described in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>.<a class="indexterm" id="IDX-CHP-25-0135"/><a class="indexterm" id="IDX-CHP-25-0136"/><a class="indexterm" id="IDX-CHP-25-0137"/><a class="indexterm" id="IDX-CHP-25-0138"/><a class="indexterm" id="IDX-CHP-25-0139"/><a class="indexterm" id="IDX-CHP-25-0140"/></p><p>Unless you have configured IDA to continue execution and to pass a specific exception type to the application, IDA will pause execution and report exceptions to you as they occur. If you elect to continue execution of the program, IDA will then display the Exception Handling dialog shown in <a class="xref" href="ch25s05.html#the_exception_handling_dialog" title="Figure 25-10. The Exception Handling dialog">Figure 25-10</a>.</p><div class="figure"><a id="the_exception_handling_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e45086"/><img alt="The Exception Handling dialog" src="httpatomoreillycomsourcenostarchimages854420.png.jpg"/></div></div><p class="title">Figure 25-10. The Exception Handling dialog</p></div><p>At this point you have the option of changing the manner in which IDA handles the given exception type (Change exception definition), passing the exception on to the application (Yes), or allowing IDA to eat the exception (No). Passing the exception to the application allows the application to handle the exception using any configured exception handlers. If you choose No, IDA attempts to continue execution, which is likely to fail unless you have corrected the condition that was responsible for causing the exception.</p><p>A special circumstance arises when you are single stepping through code and IDA determines that the instruction you are about to execute will generate an exception, as is the case with an <code class="literal">int 3</code>, an <code class="literal">icebp</code>, or a <code class="literal">popf</code> that will set the trace flag; IDA displays the dialog shown in <a class="xref" href="ch25s05.html#the_exception_confirmation_dialog" title="Figure 25-11. The exception confirmation dialog">Figure 25-11</a>.</p><div class="figure"><a id="the_exception_confirmation_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e45109"/><img alt="The exception confirmation dialog" src="httpatomoreillycomsourcenostarchimages854423.png.jpg"/></div></div><p class="title">Figure 25-11. The exception confirmation dialog</p></div><p>In most cases, the Run option is the most suitable choice and results in the application seeing the behavior that it expects when a debugger is not attached (as noted in the dialog). In working through this dialog, you are simply acknowledging that an exception is about to be generated. If you choose Run, in short order you will then be notified that an exception has occurred, and when you continue execution, you will be presented with the Exception Handling dialog of <a class="xref" href="ch25s05.html#the_exception_handling_dialog" title="Figure 25-10. The Exception Handling dialog">Figure 25-10</a> to decide how the exception should be dealt with.<a class="indexterm" id="IDX-CHP-25-0141"/><a class="indexterm" id="IDX-CHP-25-0142"/><a class="indexterm" id="IDX-CHP-25-0143"/><a class="indexterm" id="IDX-CHP-25-0144"/><a class="indexterm" id="IDX-CHP-25-0145"/></p><p>Determining how an application will handle an exception requires that we know how to trace exception handlers, which in turn requires that we know how to locate exception handlers. Ilfak discusses tracing Windows SEH handlers in a blog post titled “Tracing exception handlers.”<sup>[<a class="footnote" href="#ftn.CHP-25-FN-11" id="CHP-25-FN-11">236</a>]</sup> The basic idea is to locate any interesting exception handlers by walking the application’s list of installed exception handlers. For Windows SEH exceptions, a pointer to the head of this list may be found as the first dword in the thread environment block (TEB). The list of exception handlers is a standard linked-list data structure that contains a pointer to the next exception handler in the chain and a pointer to the function that should be called to handle any exception that is generated. Exceptions are passed down the list from one handler to another until a handler chooses to handle the exception and notify the operating system that the process may resume normal execution. If none of the installed exception handlers choose to handle the current exception, the operating system terminates the process or, when the process is being debugged, notifies the debugger that an exception has occurred within the debugged process.<a class="indexterm" id="IDX-CHP-25-0146"/><a class="indexterm" id="IDX-CHP-25-0147"/><a class="indexterm" id="IDX-CHP-25-0148"/><a class="indexterm" id="IDX-CHP-25-0149"/><a class="indexterm" id="IDX-CHP-25-0150"/></p><p>Under the IDA debugger, TEBs are mapped to an IDA database section named <code class="literal">TIB[</code><em class="replaceable"><code>NNNNNNNN</code></em><code class="literal">]</code>, where <em class="replaceable"><code>NNNNNNNN</code></em> is the eight-digit hexadecimal representation of the thread’s identification number. The following listing shows an example of the first dword in one such section:</p><a id="I_programlisting2_d1e45174"/><pre class="programlisting">TIB[000009E0]:7FFDF000 TIB_000009E0_ segment byte public 'DATA' use32
  TIB[000009E0]:7FFDF000 assume cs:TIB_000009E0_
  TIB[000009E0]:7FFDF000 ;org 7FFDF000h
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> TIB[000009E0]:7FFDF000 dd offset dword_22FFE0</pre><p>The first three lines show summary information about the segment, while the fourth line <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e45184"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> contains the first dword of the section, indicating that the first exception handler record may be found at address <code class="literal">22FFE0h</code> (<code class="literal">off-set dword_22FFE0</code>). If no exception handlers were installed for this particular thread, the first dword in the TEB would contain the value <code class="literal">0FFFFFFFFh</code>, indicating that the end of the exception handler chain had been reached. In this example, examining two dwords at address <code class="literal">22FFE0h</code> shows the following:</p><a id="I_programlisting2_d1e45203"/><pre class="programlisting">Stack[000009E0]:0022FFE0 <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>
dword_22FFE0 dd 0FFFFFFFFh     ; DATA XREF: TIB[000009E0]:7FFDF000↓o
Stack[000009E0]:0022FFE4              <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>dd offset loc_7C839AA8</pre><p>The first dword <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e45219"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> contains the value <code class="literal">0FFFFFFFFh</code>, indicating that this is the last exception handler record in the chain. The second dword <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e45228"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> contains the address <code class="literal">7C839AA8h</code> (<code class="literal">offset loc_7C839AA8</code>), indicating that the function at <code class="literal">loc_7C839AA8</code> should be called to process any exceptions that may arise during the execution of the process. If we were interested in tracing the handling of any exceptions in this process, we might begin by setting a breakpoint at address <code class="literal">7C839AA8h</code>.<a class="indexterm" id="IDX-CHP-25-0151"/></p><p>Because it is a relatively simple task to walk the SEH chain, a useful feature for the debugger to implement would be a display of the chain of SEH handlers that are installed for the current thread. Given such a display, it should be easy to navigate to each SEH handler, at which point you may decide whether you want to insert a breakpoint within the handler or not. Unfortunately, this is another feature available in OllyDbg that is not available in IDA’s debugger. To address this shortcoming, we have developed an SEH Chain plug-in, which, when invoked from within the debugger, will display the list of exception handlers that are installed for the current thread. An example of this display is shown in <a class="xref" href="ch25s05.html#the_seh_chain_display" title="Figure 25-12. The SEH Chain display">Figure 25-12</a>.<a class="indexterm" id="IDX-CHP-25-0152"/></p><div class="figure"><a id="the_seh_chain_display"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e45262"/><img alt="The SEH Chain display" src="httpatomoreillycomsourcenostarchimages854427.png.jpg"/></div></div><p class="title">Figure 25-12. The SEH Chain display</p></div><p>This plug-in utilizes the SDK’s <code class="literal">choose2</code> function to display a nonmodal dialog that lists the current exception-handler chain. For each installed exception handler, the address of the exception-handler record (the two-dword list record) and the address of the corresponding exception handler are displayed. Double-clicking an exception handler jumps the active disassembly view (either IDA View-EIP or IDA View-ESP) to the address of the SEH handler function. The entire purpose of this plug-in is to simplify the process of locating exception handlers. The source code for the SEH Chain plug-in may be found on the website for this book.</p><p>The flip side of the exception-handling process is the manner in which an exception handler returns control (if it chooses to do so) to the application in which the exception occurred. When an exception-handler function is called by the operating system, the function is granted access to all of the CPU register’s contents as they were set at the moment the exception took place. In the process of handling the exception, the function may elect to modify one or more CPU register values prior to returning control to the application. The intent of this process is for an exception handler to be given the opportunity to repair the state of the process sufficiently so that the process may resume normal execution. If the exception handler determines that the process should be allowed to continue, the operating system is notified, and the process’s register values are restored, using any modifications made by the exception handler. As discussed in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>, some anti–reverse engineering utilities make use of exception handlers to alter a process’s flow of execution by modifying the saved value of the instruction pointer during the exception-handling phase. When the operating system returns control to the affected process, execution resumes at the address specified by the modified instruction pointer.<a class="indexterm" id="IDX-CHP-25-0153"/><a class="indexterm" id="IDX-CHP-25-0154"/><a class="indexterm" id="IDX-CHP-25-0155"/><a class="indexterm" id="IDX-CHP-25-0156"/></p><p>In his blog post on tracing exceptions, Ilfak discusses the fact that Windows SEH exception handlers return control to the affected process via the <span class="emphasis"><em>ntdll.dll</em></span> function <code class="literal">NtContinue</code> (also known as <code class="literal">ZwContinue</code>). Since <code class="literal">NtContinue</code> has access to all of the process’s saved register values (via one of its arguments), it is possible to determine exactly where the process will resume execution by examining the value contained in the saved instruction pointer from within <code class="literal">NtContinue</code>. Once we know where the process is set to resume execution, we can set a breakpoint in order to avoid stepping through operating system code and to stop the process at the earliest opportunity once it resumes execution. The following steps outline the process we need to follow:<a class="indexterm" id="IDX-CHP-25-0157"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Locate <code class="literal">NtContinue</code> and set a nonstopping breakpoint on its first instruction.</p></li><li class="listitem"><p>Add a breakpoint condition to this breakpoint.</p></li><li class="listitem"><p>When the breakpoint is hit, obtain the address of the saved registers by reading the <code class="literal">CONTEXT</code> pointer from the stack.</p></li><li class="listitem"><p>Retrieve the process’s saved instruction pointer value from the <code class="literal">CONTEXT</code> record.</p></li><li class="listitem"><p>Set a breakpoint on the retrieved address and allow execution to continue.</p></li></ol></div><p>Using a process similar to the debugger-hiding script, we can automate all of these tasks and associate them with the initiation of a debugging session. The following code demonstrates launching a process in the debugger and setting a breakpoint on <code class="literal">NtContinue</code>:</p><a id="I_programlisting2_d1e45339"/><pre class="programlisting">static main() {
   auto func;
   RunTo(BeginEA());
   GetDebuggerEvent(WFNE_SUSP, −1);
   func = LocByName("ntdll_NtContinue");
   AddBpt(func);
   SetBptCnd(func, "bpt_NtContinue()");
}</pre><p>The purpose of this code is simply to set a conditional breakpoint on the entry of <code class="literal">NtContinue</code>. The behavior of the breakpoint is implemented by the IDC function <code class="literal">bpt_NtContinue</code>, which is shown here:</p><a id="I_programlisting2_d1e45350"/><pre class="programlisting">static bpt_NtContinue() {
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    auto p_ctx = Dword(ESP + 4);            //get CONTEXT pointer argument
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>    auto next_eip = Dword(p_ctx + 0xB8);    //retrieve eip from CONTEXT
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>    AddBpt(next_eip);                  //set a breakpoint at the new eip
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>    SetBptCnd(next_eip, "Warning(\"Exception return hit\") || 1");
          return 0;           //don't stop
  }</pre><p>This function locates the pointer to the process’s saved register context information <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e45378"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, retrieves the saved instruction pointer value from offset <code class="literal">0xB8</code> within the <code class="literal">CONTEXT</code> structure <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e45390"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and sets a breakpoint on this address <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e45396"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. In order to make it clear to the user why execution has stopped, a breakpoint condition (which is always true) is added to display a message to the user <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e45403"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>. We choose to do this because the breakpoint was not set explicitly by the user, and the user may not correlate the event to the return from an exception handler.<a class="indexterm" id="IDX-CHP-25-0158"/></p><p>This example represents a simple means of handling exception returns. Much more sophisticated logic could be added to the breakpoint function <code class="literal">bpt_NtContinue</code>. For example, if you suspect that an exception handler is manipulating the contents of debug registers, perhaps to prevent you from setting hardware breakpoints, you might opt to restore the values of the debug registers to known good values prior to returning control to the process being debugged.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-25-FN-11" id="ftn.CHP-25-FN-11">236</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/2005/12/tracing_exception_handlers.html">http://www.hexblog.com/2005/12/tracing_exception_handlers.html</a>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id24"/>Summary</h1></div></div></div><p>In addition to their obvious uses in tracking down bugs in software, debuggers may also be used as effective reverse engineering tools. For malware and obfuscated code analysis, the ability to utilize a single application for both static and dynamic analysis can save valuable time and the effort required to generate data with one tool that can be analyzed with a second tool. Given the wide variety of debuggers available today, IDA’s debugger may not be the ideal choice for tracking down runtime problems in your applications. However, if you anticipate the need to conduct any reverse engineering of an application or if you simply desire a high-quality disassembly to refer to during the debugging process, IDA’s debugger may serve your needs well. In <a class="xref" href="ch26.html" title="Chapter 26. Additional Debugger Features">Chapter 26</a>, we conclude the book by covering more advanced features of IDA’s debugger, including remote debugging and debugging on Linux and OS X.</p></div>
<div class="chapter" title="Chapter&#xA0;26.&#xA0;Additional Debugger Features"><div class="titlepage"><div><div><h1 class="title"><a id="additional_debugger_features"/>Chapter 26. Additional Debugger Features</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id25"/><div class="mediaobject"><a id="I_mediaobject3_d1e45428"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>Over the last two chapters, we have covered the majority of the debugger’s basic features including scripting debugger actions, as well as its usefulness in de-obfuscating code. In this chapter, we round out our discussion of the debugger by looking at remote debugging with IDA, the use of the Bochs x86 emulator<sup>[<a class="footnote" href="#ftn.CHP-26-FN-1" id="CHP-26-FN-1">237</a>]</sup> as a debugging platform, and the Appcall<sup>[<a class="footnote" href="#ftn.CHP-26-FN-2" id="CHP-26-FN-2">238</a>]</sup> feature that effectively extends IDA’s scripting capabilities to include any function defined with a process and its associated libraries.<a class="indexterm" id="IDX-CHP-26-0001"/><a class="indexterm" id="IDX-CHP-26-0002"/><a class="indexterm" id="IDX-CHP-26-0003"/><a class="indexterm" id="IDX-CHP-26-0004"/></p><div class="sect1" title="Remote Debugging with IDA"><div class="titlepage"><div><div><h1 class="title"><a id="remote_debugging_with_ida"/>Remote Debugging with IDA</h1></div></div></div><p>All versions of IDA ship with server components designed to facilitate remote debugging sessions. In addition, IDA is capable of interfacing with remote gdb sessions that make use of <code class="literal">gdb_server</code> or built-in gdb stubs. One of the principal advantages of remote debugging is the ability to use the GUI debugger interface as a frontend for any debugging session. For the most part, other than initial setup and establishing the connection to the remote debugging server, remote debugging sessions differ little from local debugging sessions.<a class="indexterm" id="IDX-CHP-26-0005"/><a class="indexterm" id="IDX-CHP-26-0006"/><a class="indexterm" id="IDX-CHP-26-0007"/><a class="indexterm" id="IDX-CHP-26-0008"/><a class="indexterm" id="IDX-CHP-26-0009"/><a class="indexterm" id="IDX-CHP-26-0010"/><a class="indexterm" id="IDX-CHP-26-0011"/><a class="indexterm" id="IDX-CHP-26-0012"/><a class="indexterm" id="IDX-CHP-26-0013"/><a class="indexterm" id="IDX-CHP-26-0014"/><a class="indexterm" id="IDX-CHP-26-0015"/><a class="indexterm" id="IDX-CHP-26-0016"/></p><div class="sect2" title="Using a Hex-Rays Debugging Server"><div class="titlepage"><div><div><h2 class="title"><a id="using_a_hex-rays_debugging_server"/>Using a Hex-Rays Debugging Server</h2></div></div></div><p>Remote debugging begins by launching an appropriate debugging server component on the computer on which a process is to be debugged. IDA ships with the following server components:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>win32_remote.exe</code></strong> Server component executed on Windows computers for the purpose of debugging 32-bit Windows applications</td></tr><tr><td><strong class="userinput"><code>win64_remotex64.exe</code></strong> Server component executed on 64-bit Windows computers for the purpose of debugging 64-bit Windows applications (IDA Advanced only)</td></tr><tr><td><strong class="userinput"><code>wince_remote_arm.dll</code></strong> Server component uploaded to Windows CE devices (via ActiveSync)</td></tr><tr><td><strong class="userinput"><code>mac_server</code></strong> Server component executed on OS X computers for the purpose of debugging 32-bit OS X applications</td></tr><tr><td><strong class="userinput"><code>mac_serverx64</code></strong> Server component executed on 64-bit OS X computers for the purpose of debugging 64-bit OS X applications (IDA Advanced only)</td></tr><tr><td><strong class="userinput"><code>linux_server</code></strong> Server component executed on Linux computers for the purpose of debugging 32-bit Linux applications</td></tr><tr><td><strong class="userinput"><code>linux_serverx64</code></strong> Server component executed on 64-bit Linux computers for the purpose of debugging 64-bit Linux applications (IDA Advanced only)</td></tr><tr><td><strong class="userinput"><code>armlinux_server</code></strong> Server component executed on ARM-based computers for the purpose of debugging ARM applications</td></tr><tr><td><strong class="userinput"><code>android_server</code></strong> Server component executed on Android devices for the purpose of debugging Android applications</td></tr></table><p>In order to perform remote debugging on any platform, the only component you are required to execute on that platform is the appropriate server component. It is not necessary to install a full version of IDA on the remote platform. In other words, if you intend to use a Windows version of IDA as your debugging client, and you wish to remotely debug Linux applications, the only file, other than the binary that is being debugged, that you need to copy to and execute on the Linux system is <span class="emphasis"><em>linux_server</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-26-FN-3" id="CHP-26-FN-3">239</a>]</sup></p><p>Regardless of the platform you intend to run the server on, the server components accept three command-line options, as listed here:<a class="indexterm" id="IDX-CHP-26-0017"/><a class="indexterm" id="IDX-CHP-26-0018"/><a class="indexterm" id="IDX-CHP-26-0019"/><a class="indexterm" id="IDX-CHP-26-0020"/><a class="indexterm" id="IDX-CHP-26-0021"/><a class="indexterm" id="IDX-CHP-26-0022"/></p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>-p&lt;</code></strong><strong class="userinput"><code><em class="replaceable"><code>port number</code></em></code></strong><strong class="userinput"><code>&gt;</code></strong> is used to specify an alternate TCP port for the server to listen on. The default port is 23946. Note that no space should be entered between the <code class="literal">-p</code> and the port number.</td></tr><tr><td><strong class="userinput"><code>-P&lt;</code></strong><strong class="userinput"><code><em class="replaceable"><code>password</code></em></code></strong><strong class="userinput"><code>&gt;</code></strong> is used to specify a password that must be supplied in order for a client to connect to the debug server. Note that no space should be entered between the <code class="literal">-P</code> and the provided password.</td></tr><tr><td><strong class="userinput"><code>-v</code></strong> places the server in verbose mode.</td></tr></table><p>There is no option to restrict the IP address on which the server listens. If you wish to restrict incoming connections, you may do so using host-based firewall rules as applicable to your debugging platform. Once a server has been launched, IDA may be executed from any supported operating system and used to provide a client interface to the debug server; however, a server can handle only one active debugging session at any given time. If you wish to maintain several simultaneous debugging sessions, you must launch several instances of the debugging server on several different TCP ports.</p><p>From the client perspective, remote debugging is initiated by specifying a server hostname and ports via the Debugger ▸ Process Options command, as shown in <a class="xref" href="ch26.html#the_debugger_process_options_dialog" title="Figure 26-1. The debugger process options dialog">Figure 26-1</a>. This action must be performed prior to starting or attaching to the process you intend to debug.<a class="indexterm" id="IDX-CHP-26-0023"/></p><div class="figure"><a id="the_debugger_process_options_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e45638"/><img alt="The debugger process options dialog" src="httpatomoreillycomsourcenostarchimages854430.png.jpg"/></div></div><p class="title">Figure 26-1. The debugger process options dialog</p></div><p>The first four fields in this dialog apply to both local and remote debugging sessions, while the Hostname, Port, and Password fields apply only to remote debugging sessions. The fields of this dialog are summarized here.</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="strong"><strong>Application</strong></span> The full path to the application binary that you wish to debug. For local debugging sessions, this is a path in the local filesystem. For a remote debugging session, this is the path on the debugging server. If you choose not to use a full path, the remote server will search its current working directory.</td></tr><tr><td><span class="strong"><strong>Input file</strong></span> The full path to the file that was used to create the IDA database. For local debugging sessions, this is a path in the local filesystem. For a remote debugging session, this is the path on the debugging server. If you choose not to use a full path, the remote server will search its current working directory.</td></tr><tr><td><span class="strong"><strong>Directory</strong></span> The working directory in which the process should be launched. For local debugging, this directory must exist in the local file-system. For remote debugging, this is a directory on the debugging server.</td></tr><tr><td><span class="strong"><strong>Parameters</strong></span> Used to specify any command-line parameters to be passed to the process when it is started. Note that shell metacharacters (such as <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, and <code class="literal">|</code>) are not honored here. Any such characters will be passed to the process as command-line arguments. Thus it is not possible to launch a process under the debugger and have that process perform any sort of input or output redirection. For remote debugging sessions, process output is displayed in the console that was used to launch the debugging server.</td></tr><tr><td><span class="strong"><strong>Hostname</strong></span> The hostname or IP address of the remote debugging server. Leave this field blank for local debugging sessions.</td></tr><tr><td><span class="strong"><strong>Port</strong></span> The TCP port number on which the remote debugging server is listening.</td></tr><tr><td><span class="strong"><strong>Password</strong></span> The password expected by the remote debugging server. Note that the data entered into this field is not masked, making it possible for the password to be viewed by anyone who can observe your display. Further, this password is transmitted to the remote server as plain text, making it observable by anyone who can intercept your network packets.</td></tr></table><p>At first glance, the Application and Input File fields in <a class="xref" href="ch26.html#the_debugger_process_options_dialog" title="Figure 26-1. The debugger process options dialog">Figure 26-1</a> may seem to be identical. When the file opened in your IDA database is the same as the executable file that you wish to run on the remote computer, these two fields will hold the same value. However, in some cases, you may wish to debug a library file (such as a DLL) that you are analyzing in an IDA database. It is not possible to debug a library file directly because library files are not standalone executables. In such cases, you will set the Input File field to the path of the library file. The Application field must be set to the name of an application that makes use of the library file that you wish to debug.<a class="indexterm" id="IDX-CHP-26-0024"/><a class="indexterm" id="IDX-CHP-26-0025"/><a class="indexterm" id="IDX-CHP-26-0026"/><a class="indexterm" id="IDX-CHP-26-0027"/><a class="indexterm" id="IDX-CHP-26-0028"/><a class="indexterm" id="IDX-CHP-26-0029"/></p><p>The procedures for connecting to a remote gdb server are nearly identical to the procedures for attaching to a remote IDA debugging server with two minor exceptions. First, no password is required to connect to a <code class="literal">gdb_server</code>, and second, IDA allows specification of gdb-specific behaviors via the Set specific options button within the debugger setup dialog. <a class="xref" href="ch26.html#gdb_configuration_dialog" title="Figure 26-2. GDB Configuration dialog">Figure 26-2</a> shows the GDB Configuration dialog.<a class="indexterm" id="IDX-CHP-26-0030"/><a class="indexterm" id="IDX-CHP-26-0031"/><a class="indexterm" id="IDX-CHP-26-0032"/></p><div class="figure"><a id="gdb_configuration_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e45725"/><img alt="GDB Configuration dialog" src="httpatomoreillycomsourcenostarchimages854433.png.jpg"/></div></div><p class="title">Figure 26-2. GDB Configuration dialog</p></div><p>Of note is the fact that IDA has no way of knowing the architecture of the computer on which the <code class="literal">gdb_server</code> is running and that you are obligated to specify a processor type (which defaults to Intel x86) and potentially the endian-ness of that processor. IDA is currently capable of providing a debugging interface for x86, ARM, PowerPC, and MIPS processors.<a class="indexterm" id="IDX-CHP-26-0033"/><a class="indexterm" id="IDX-CHP-26-0034"/><a class="indexterm" id="IDX-CHP-26-0035"/><a class="indexterm" id="IDX-CHP-26-0036"/><a class="indexterm" id="IDX-CHP-26-0037"/><a class="indexterm" id="IDX-CHP-26-0038"/></p></div><div class="sect2" title="Attaching to a Remote Process"><div class="titlepage"><div><div><h2 class="title"><a id="attaching_to_a_remote_process"/>Attaching to a Remote Process</h2></div></div></div><p>A number of different scenarios exist if you intend to attach to a running process on your remote debugging server. First, if you have no database open in IDA, you may select Debugger ▸ Attach and choose from IDA’s list of available debuggers. If you choose one of IDA’s remote debuggers, you are presented with the configuration dialog shown in <a class="xref" href="ch26.html#remote_debugger_configuration" title="Figure 26-3. Remote debugger configuration">Figure 26-3</a>.</p><div class="figure"><a id="remote_debugger_configuration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e45771"/><img alt="Remote debugger configuration" src="httpatomoreillycomsourcenostarchimages854436.png.jpg"/></div></div><p class="title">Figure 26-3. Remote debugger configuration</p></div><p>Once you provide the appropriate connection parameters and click OK, IDA obtains and displays a process list from the remote debugging server, allowing you to select and attach to a specific process.<a class="indexterm" id="IDX-CHP-26-0039"/><a class="indexterm" id="IDX-CHP-26-0040"/><a class="indexterm" id="IDX-CHP-26-0041"/><a class="indexterm" id="IDX-CHP-26-0042"/><a class="indexterm" id="IDX-CHP-26-0043"/><a class="indexterm" id="IDX-CHP-26-0044"/><a class="indexterm" id="IDX-CHP-26-0045"/><a class="indexterm" id="IDX-CHP-26-0046"/><a class="indexterm" id="IDX-CHP-26-0047"/><a class="indexterm" id="IDX-CHP-26-0048"/><a class="indexterm" id="IDX-CHP-26-0049"/><a class="indexterm" id="IDX-CHP-26-0050"/><a class="indexterm" id="IDX-CHP-26-0051"/><a class="indexterm" id="IDX-CHP-26-0052"/></p><p>In the second scenario, you might already have a binary open in IDA and wish to attach to a remote process. In this case you may need to select a debugger (if none has been previously specified for the open file type) or switch your debugger type (if a remote debugger is not currently selected). Once a debugger has been selected, you must provide hostname and password information for the remote debugger server, as shown in <a class="xref" href="ch26.html#the_debugger_process_options_dialog" title="Figure 26-1. The debugger process options dialog">Figure 26-1</a>, at which point you may attach to a remote process using Debugger ▸ Attach to Process.</p></div><div class="sect2" title="Exception Handling During Remote Debugging"><div class="titlepage"><div><div><h2 class="title"><a id="exception_handling_during_remote_debuggi"/>Exception Handling During Remote Debugging</h2></div></div></div><p>In <a class="xref" href="ch25.html" title="Chapter 25. Disassembler/Debugger Integration">Chapter 25</a> we discussed the IDA debugger’s handling of exceptions and how to modify the debugger’s exception-handling behavior. During remote debugging sessions, the debugger’s default exception-handling behavior is dictated by the <span class="emphasis"><em>exceptions.cfg</em></span> file, which resides on the client machine (the machine on which you are actually running IDA). This allows you to modify <span class="emphasis"><em>exceptions.cfg</em></span> and reload the changes via the Debugger Setup dialog (see <a class="xref" href="ch25s03.html#debugger_pausing_events" title="Figure 25-4. Debugger pausing events">Figure 25-4</a>) without the need to access the remote server.<a class="indexterm" id="IDX-CHP-26-0053"/><a class="indexterm" id="IDX-CHP-26-0054"/></p></div><div class="sect2" title="Using Scripts and Plug-ins During Remote Debugging"><div class="titlepage"><div><div><h2 class="title"><a id="using_scripts_and_plug-ins_during_remote"/>Using Scripts and Plug-ins During Remote Debugging</h2></div></div></div><p>During a remote debugging session, it remains possible to utilize scripts and plug-ins to automate debugging tasks. Any scripts or plug-ins that you choose to execute will run within IDA on the client machine. IDA will in turn handle any actions that are required to interact with the remote process, such as setting breakpoints, querying state, modifying memory, or resuming execution. From the script’s perspective, all behaviors will appear just as if the debugging session was taking place locally. The only thing to remember is to make sure that your scripts and plug-ins are tailored to the architecture on which the target process is running and not the architecture on which the IDA client is running (unless they happen to be the same). In other words, if you are running the Windows version of IDA as a client for remote debugging on Linux, do not expect your Windows debugger-hiding script to do you any good.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-26-FN-1" id="ftn.CHP-26-FN-1">237</a>] </sup>See <a class="ulink" href="http://bochs.sourceforge.net/">http://bochs.sourceforge.net/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-26-FN-2" id="ftn.CHP-26-FN-2">238</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=112">http://www.hexblog.com/?p=112</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-26-FN-3" id="ftn.CHP-26-FN-3">239</a>] </sup>Note that the <span class="emphasis"><em>*_server</em></span> binaries distributed with IDA depend on a number of shared libraries. You can use <code class="literal">ldd</code> (or <code class="literal">otool -L</code> on OS X) to list these dependencies.</p></div></div></div>
<div class="sect1" title="Debugging with Bochs"><div class="titlepage"><div><div><h1 class="title"><a id="debugging_with_bochs"/>Debugging with Bochs</h1></div></div></div><p>Bochs is an open source x86 emulation environment. Bochs is capable of full-system emulation of x86 computer systems and includes emulation for common I/O devices and a custom BIOS. Bochs provides an emulation-based alternative to virtualization software such as VMware Workstation. Elias Bachaalany of the Hex-Rays development team has taken the lead on integrating Bochs with IDA to provide an emulation-based alternative to traditional debugging.<sup>[<a class="footnote" href="#ftn.CHP-26-FN-4" id="CHP-26-FN-4">240</a>]</sup> Windows versions of IDA ship with and install a compatible version of Bochs, while non-Windows users wishing to make use of Bochs must make sure that version 2.4.2 or later is installed on their system.<a class="indexterm" id="IDX-CHP-26-0055"/><a class="indexterm" id="IDX-CHP-26-0056"/><a class="indexterm" id="IDX-CHP-26-0057"/><a class="indexterm" id="IDX-CHP-26-0058"/><a class="indexterm" id="IDX-CHP-26-0059"/><a class="indexterm" id="IDX-CHP-26-0060"/></p><p>With Bochs installed, IDA offers a Local Bochs debugger choice whenever you have an x86 binary open in IDA. The availability of Bochs offers the opportunity to perform local debugging of Windows applications on non-Windows systems, because the application will be emulated rather than executed as a native process. Because it’s an emulator, Bochs configuration options differ somewhat from those available with more traditional debuggers. One of the most important things to understand about Bochs is that it can operate in three distinct modes: disk image mode, IDB mode, and PE mode. The choice of mode is made using the Bochs specific debugger configuration dialog shown in <a class="xref" href="ch26s02.html#bochs_debugger_options_dialog" title="Figure 26-4. Bochs debugger options dialog">Figure 26-4</a>.<a class="indexterm" id="IDX-CHP-26-0061"/></p><div class="figure"><a id="bochs_debugger_options_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e45922"/><img alt="Bochs debugger options dialog" src="httpatomoreillycomsourcenostarchimages854439.png.jpg"/></div></div><p class="title">Figure 26-4. Bochs debugger options dialog</p></div><p>Each of the available modes offers a drastically different degree of fidelity in terms of the quality and type of emulation being performed.</p><div class="sect2" title="Bochs IDB Mode"><div class="titlepage"><div><div><h2 class="title"><a id="bochs_idb_mode"/>Bochs IDB Mode</h2></div></div></div><p>Working from the ground up, IDB is the most basic Bochs mode. In IDB mode, the only code that Bochs is aware of is the code contained in your database. Memory regions are mapped into Bochs and populated by copying bytes from the database. A configurable amount of stack space is provided based on settings in the Bochs options dialog, and IDA will make its own decision as to where the stack will be allocated. Emulated execution begins (meaning the instruction pointer is initially positioned) at the database symbol named <code class="literal">ENTRY</code> if one has been defined. If an <code class="literal">ENTRY</code> symbol is not present, IDA tests to see if a range of locations is currently selected in the open database and uses the beginning of the range as the debugger entry point. If no selection exists, then the current cursor location is taken as the initial instruction pointer value. When running in IDB mode, keep in mind that Bochs has no notion of any operating system support such as shared libraries or the location of any well-known structures within a typical process address space. It is equally possible to step through a PE file, an ELF file, a Mach-O file, or a raw blob of machine code such as an exploit payload as long as the code makes no reference to anything that might reside outside the database. One way that IDB might be used is for executing a single function in an effort to understand its behavior without the requirement to craft a complete process or disk image to do so.<a class="indexterm" id="IDX-CHP-26-0062"/><a class="indexterm" id="IDX-CHP-26-0063"/><a class="indexterm" id="IDX-CHP-26-0064"/><a class="indexterm" id="IDX-CHP-26-0065"/><a class="indexterm" id="IDX-CHP-26-0066"/><a class="indexterm" id="IDX-CHP-26-0067"/><a class="indexterm" id="IDX-CHP-26-0068"/><a class="indexterm" id="IDX-CHP-26-0069"/><a class="indexterm" id="IDX-CHP-26-0070"/></p></div><div class="sect2" title="Bochs PE Mode"><div class="titlepage"><div><div><h2 class="title"><a id="bochs_pe_mode"/>Bochs PE Mode</h2></div></div></div><p>PE mode offers the opportunity to debug at something approaching the process level. When PE mode is selected and activated, IDA’s Bochs control module (an IDA plug-in) takes over and behaves much like the Windows process loader would if you were actually launching a native Windows process. A PE mode process receives process (PEB) and thread (TEB) environment blocks, along with a stack that mimics those that would be created in an actual process.<a class="indexterm" id="IDX-CHP-26-0071"/></p><p>The Bochs plug-in also loads (without executing any code) a number of common Windows libraries into the emulated process address space in order to properly handle any library calls made by the process. The exact set of libraries that Bochs loads on debugger start is configurable and is specified in <span class="emphasis"><em>&lt;IDADIR&gt;/plugins/bochs/startup.idc</em></span>. Any library may be loaded as is or may be designated to be stubbed out. If a library is marked to be stubbed, then the Bochs plug-in will automatically hook every function exported by that library and redirect execution to a Bochs interception function (refer to <span class="emphasis"><em>startup.idc</em></span> and the IDA help system for more details). This stubbing technique provides an extensible means for users to define custom behaviors for any library function. For any library that is stubbed by IDA, it is possible to define a corresponding script file in which you may define your custom behaviors. For any library, <span class="emphasis"><em>foolib.dll</em></span> for example, the Bochs plug-in scans for a related script named <span class="emphasis"><em>api_foolib.idc</em></span> or <span class="emphasis"><em>api_foolib.py</em></span> within the <span class="emphasis"><em>&lt;IDADIR&gt;/plugins/bochs</em></span> directory. IDA ships with <span class="emphasis"><em>&lt;IDADIR&gt;/plugins/bochs/api_kernel32.idc</em></span>, which provides a good example of the structure of such a file and the implementation of custom behaviors for a number of functions.</p><p>The ability to hook library functions and define custom implementations is important in PE mode because there is no operating system layer to perform all of the heavy lifting needed by the shared libraries. For example, by providing an alternate, script-based behavior for a function such as <code class="literal">VirtualAlloc</code>, which would fail if it could not communicate with the operating system, it is possible to convince (to some degree) the emulated process that it is running as an actual process. The goal when creating such script-based behaviors is to provide the emulated process with the responses it would expect to see if were communicating with the actual library functions, which in turn were communicating with the actual operating system.<a class="indexterm" id="IDX-CHP-26-0072"/></p><p>If you use IDA on a non-Windows platform, you may take full advantage of Bochs PE mode by copying any required libraries (as specified in <span class="emphasis"><em>startup.idc</em></span>) from a Windows system onto your IDA system and editing <span class="emphasis"><em>startup.idc</em></span> to point at the directory containing all of the copied libraries. The following listing shows an example of the required changes.<a class="indexterm" id="IDX-CHP-26-0073"/><a class="indexterm" id="IDX-CHP-26-0074"/><a class="indexterm" id="IDX-CHP-26-0075"/><a class="indexterm" id="IDX-CHP-26-0076"/><a class="indexterm" id="IDX-CHP-26-0077"/><a class="indexterm" id="IDX-CHP-26-0078"/></p><a id="I_programlisting3_d1e46048"/><pre class="programlisting">// Define additional DLL path
// (add triple slashes to enable the following lines)
/// path /home/idauser/xp_dlls/=c:\winnt\system32\</pre><p>When using PE mode, one difference you will note when launching a process under Bochs is that IDA does not open a warning dialog to remind you of the danger of launching a potentially malicious process under debugger control. This is because the only process that gets created is the Bochs emulator process, and all of the code that you are debugging is viewed by the Bochs emulator as data that happens to represent code for it to emulate. No native process is ever created from the binary that you are debugging.</p></div><div class="sect2" title="Bochs Disk Image Mode"><div class="titlepage"><div><div><h2 class="title"><a id="bochs_disk_image_mode"/>Bochs Disk Image Mode</h2></div></div></div><p>The third mode of operation for the Bochs debugger is called disk image mode. Aside from IDA’s ability to make use of Bochs, Bochs is a full-blown x86 system emulator on its own. It is quite possible to create hard drive images, using the <code class="literal">bximage</code> tool supplied with Bochs; install an operating system on the disk image, using Bochs and any required installation medium for the desired operating system; and ultimately use Bochs to run your guest operating system within an emulated environment.</p><p>If your primary goal in using IDA/Bochs is to understand the behavior of a single process, then disk image mode may not be for you. Isolating and observing a single process executing within a fully emulated operating system is not an easy task and requires a detailed understanding of the operating system and how it manages processes and memory. Where you may find IDA/Bochs useful is in analyzing system BIOS and boot code, which can be followed relatively easily before the operating system code takes over.</p><p>In disk image mode, you have no executable file image to load into IDA. Instead, IDA ships with a loader that recognizes Bochs configuration (<span class="emphasis"><em>boch-src</em></span>) files.<sup>[<a class="footnote" href="#ftn.CHP-26-FN-5" id="CHP-26-FN-5">241</a>]</sup> A <span class="emphasis"><em>bochsrc</em></span> file is used to describe the hardware execution environment when Bochs is used as a full system emulator. IDA’s default <span class="emphasis"><em>bochsrc</em></span> file is located at <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/bochsrc.cfg</em></span>. Among other things, a <span class="emphasis"><em>bochsrc</em></span> file is used to specify the locations of the system BIOS, video ROM, and disk image files. IDA’s <span class="emphasis"><em>bochsrc</em></span> loader offers minimal loading services, doing nothing more than reading the first sector of the first disk image file specified in the Bochs configuration file being loaded and then selecting the Bochs debugger for use with the new database. The use of IDA/Bochs in a master boot record development scenario is discussed on the Hex-Rays blog.<sup>[<a class="footnote" href="#ftn.CHP-26-FN-6" id="CHP-26-FN-6">242</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-26-FN-4" id="ftn.CHP-26-FN-4">240</a>] </sup>See “Designing a minimal operating system to emulate 32/64bits x86 code snippets, shellcode or malware in Bochs” from Recon 2011 (<a class="ulink" href="http://www.recon.cx/">http://www.recon.cx/</a>).</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-26-FN-5" id="ftn.CHP-26-FN-5">241</a>] </sup>See <a class="ulink" href="http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html">http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html</a> for information on the <code class="literal">bochsrc</code> file format.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-26-FN-6" id="ftn.CHP-26-FN-6">242</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=103">http://www.hexblog.com/?p=103</a>.</p></div></div></div>
<div class="sect1" title="Appcall"><div class="titlepage"><div><div><h1 class="title"><a id="appcall"/>Appcall</h1></div></div></div><p>The debugger’s Appcall feature effectively extends the capabilities of IDC or IDAPython to make any function in the active process callable from a script. There are an infinite number of uses for such a capability, including mapping additional memory into the process address space (by calling <code class="literal">VirtualAlloc</code> or similar) and injecting new libraries into the process being debugged (by calling <code class="literal">LoadLibrary</code> or by calling functions within the process to perform tasks you would rather perform manually, such as decoding blocks of data or computing hash values).<a class="indexterm" id="IDX-CHP-26-0079"/><a class="indexterm" id="IDX-CHP-26-0080"/><a class="indexterm" id="IDX-CHP-26-0081"/><a class="indexterm" id="IDX-CHP-26-0082"/><a class="indexterm" id="IDX-CHP-26-0083"/></p><p>In order to make use of Appcall, the function you wish to invoke must be loaded in the address space of the process being debugged, and IDA must know or be informed of the function’s prototype so that parameters may be marshaled and unmarshaled properly. Any Appcall that you do make will be made in the context of the current debugger thread after first saving the thread’s state (essentially all registers associated with the thread). Once the Appcall completes, IDA restores the thread state, and the debugger is ready to resume execution as if no Appcall had ever taken place.</p><p>Let’s look at an example in which Appcall is used to allocate a 4096-byte block of memory into the current (Windows) process address space. In this case, the Windows API function that we wish to invoke is named <code class="literal">VirtualAlloc</code> and its prototype is shown here:</p><a id="I_programlisting3_d1e46136"/><pre class="programlisting">LPVOID WINAPI VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize,
                           DWORD flAllocationType, DWORD flProtect);</pre><p>The call that we wish to make using Appcall might look something like the following if we were to write it in C:</p><a id="I_programlisting3_d1e46140"/><pre class="programlisting">VirtualAlloc(NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</pre><p>This function call ultimately translates into the following once all of the constants are resolved:</p><a id="I_programlisting3_d1e46144"/><pre class="programlisting">VirtualAlloc(0, 4096, 0x3000, 4);</pre><p>Recall that while a Windows process is being debugged, IDA prefixes the name of every library function with the name of the library to which the function belongs. Thus, <code class="literal">VirtualAlloc</code> will be named <code class="literal">kernel32_VirtualAlloc</code> when the debugger is active, as shown is the following listing:</p><a id="I_programlisting3_d1e46154"/><pre class="programlisting">kernel32.dll:766B2FB6 ; ====== S U B R O U T I N E ========
kernel32.dll:766B2FB6
kernel32.dll:766B2FB6 ; Attributes: bp-based frame
kernel32.dll:766B2FB6
kernel32.dll:766B2FB6 kernel32_VirtualAlloc proc near</pre><p>No type information is displayed because IDA’s type libraries know nothing about a function named <code class="literal">kernel32_VirtualAlloc</code>. Since Appcall requires knowledge of a function’s type signature, we must add the information into the database ourselves using the <code class="literal">Set Function Type</code> command. An exact type signature is not required as long as the signature we specify allows IDA to properly transfer our parameters to the function we are invoking. In this case, we supply the following signature:<a class="indexterm" id="IDX-CHP-26-0084"/><a class="indexterm" id="IDX-CHP-26-0085"/><a class="indexterm" id="IDX-CHP-26-0086"/><a class="indexterm" id="IDX-CHP-26-0087"/><a class="indexterm" id="IDX-CHP-26-0088"/></p><a id="I_programlisting3_d1e46180"/><pre class="programlisting">kernel32.dll:766B2FB6 ; Attributes: bp-based frame
kernel32.dll:766B2FB6
kernel32.dll:766B2FB6 ; int __stdcall kernel32_VirtualAlloc(int, int, int, int)
kernel32.dll:766B2FB6 kernel32_VirtualAlloc proc near</pre><p>At this point we are ready to use Appcall to have more memory allocated into our process. Using IDC, this is extremely easy because all we need to do is invoke the function just as if it was an IDC function. Entering the function call at the IDA command line and using the <code class="literal">Message</code> function to display the results yields the following output:</p><a id="I_programlisting3_d1e46187"/><pre class="programlisting">IDC&gt;Message("%x\n", kernel32_VirtualAlloc(0, 4096, 0x3000, 4));
3c0000</pre><p>The result in this case is a new 4096-byte block allocated to the process at address <code class="literal">0x3c0000</code>. In order to make the new memory block show up in IDA, we must use the Debugger ▸ Refresh memory command or wait for IDA to perform a refresh in conjunction with other debugger operations.<a class="indexterm" id="IDX-CHP-26-0089"/></p><p>The syntax for performing an Appcall in Python is slightly different, making use of the <code class="literal">Appcall</code> variable defined in the <code class="literal">idaapi</code> module. However, the requirements to have a named function with an assigned type signature remain. When performed in Python, the same Appcall to <code class="literal">VirtualAlloc</code> would be done as follows:</p><a id="I_programlisting3_d1e46210"/><pre class="programlisting">Python&gt;Message("%x\n" % Appcall.kernel32_VirtualAlloc(0, 4096, 0x3000, 4))
3d0000</pre><p>Additional information and examples related to Appcall and its uses may be found on the Hex-Rays blog.<sup>[<a class="footnote" href="#ftn.CHP-26-FN-7" id="CHP-26-FN-7">243</a>]</sup><a class="indexterm" id="IDX-CHP-26-0090"/><a class="indexterm" id="IDX-CHP-26-0091"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-26-FN-7" id="ftn.CHP-26-FN-7">243</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=113">http://www.hexblog.com/?p=113</a>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id25"/>Summary</h1></div></div></div><p>Whether through the efforts of the Hex-Rays development team or through user contributions, IDA’s debugger is continually evolving. The best place to keep up with all of these changes is the Hex-Rays blog (<a class="ulink" href="http://www.hexblog.com/">http://www.hexblog.com/</a>), where the Hex-Rays developers frequently preview features that will appear in upcoming versions of IDA. Keeping up with user-contributed extensions requires a little more effort. Occasionally, interesting IDA extensions are announced in the IDA support forums, but you are just as likely to see them announced in various reverse engineering forums (such as <a class="ulink" href="http://www.openrce.org/">http://www.openrce.org/</a>), see them entered into Hex-Rays’s annual plug-in writing contest, or simply stumble across them while performing an Internet search.</p><p>IDA’s debugger is both full featured and extensible. With both local and remote capabilities, as well as the ability to act as a frontend to a number of popular debuggers such as gdb and WinDbg, IDA offers a consistent debugging interface across a large number of popular platforms. Given the ability to script extensions or build compiled debugger plug-ins, the limits of the debugger’s capabilities are constantly being extended. Among current debuggers, IDA’s debugger enjoys perhaps the most active development and benefits from the fact that all of its core developers are themselves accomplished reverse engineers who share a personal as well as professional interest in making the debugger a powerful and useful tool.</p></div></body></html>