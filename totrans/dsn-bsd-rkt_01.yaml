- en: Chapter 1. LOADABLE KERNEL MODULES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 可加载内核模块
- en: The simplest way to introduce code into a running kernel is through a *loadable
    kernel module (LKM)*, which is a kernel subsystem that can be loaded and unloaded
    after bootup, allowing a system administrator to dynamically add and remove functionality
    from a live system. This makes LKMs an ideal platform for kernel-mode rootkits.
    In fact, the vast majority of modern rootkits are simply LKMs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码引入运行中的内核的最简单方法是通过*可加载内核模块（LKM）*，这是一个在启动后可以加载和卸载的内核子系统，允许系统管理员动态地向运行中的系统添加和删除功能。这使得LKMs成为内核模式rootkits的理想平台。事实上，绝大多数现代rootkits仅仅是LKMs。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In FreeBSD 3.0, substantial changes were made to the kernel module subsystem,
    and the LKM Facility was renamed the Dynamic Kernel Linker (KLD) Facility. Subsequently,
    the term KLD is commonly used to describe LKMs under FreeBSD.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD 3.0中，对内核模块子系统进行了重大更改，并将LKM功能重命名为动态内核链接器（KLD）功能。随后，术语KLD通常用于描述FreeBSD下的LKMs。
- en: In this chapter we'll discuss LKM (that is, KLD) programming within FreeBSD
    for programmers new to kernel hacking.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论FreeBSD中针对新接触内核开发的程序员的LKM（即KLD）编程。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, the terms *device driver*, *KLD*, *LKM*, *loadable module*,
    and *module* are all used interchangeably.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，术语*设备驱动程序*、*KLD*、*LKM*、*可加载模块*和*模块*都是可以互换使用的。
- en: Module Event Handler
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块事件处理程序
- en: 'Whenever a KLD is loaded into or unloaded from the kernel, a function known
    as the *module event handler* is called. This function handles the initialization
    and shutdown routines for the KLD. Every KLD must include an event handler.^([[1](#ftn.CHP-1-FN-1)])
    The prototype for the event handler function is defined in the `<sys/module.h>`
    header as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每当KLD被加载到或从内核卸载时，都会调用一个称为*模块事件处理程序*的函数。此函数处理KLD的初始化和关闭例程。每个KLD都必须包含一个事件处理程序.^([[1](#ftn.CHP-1-FN-1)])
    事件处理程序函数的原型定义在`<sys/module.h>`头文件中，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'where `module_t` is a pointer to a `module` structure and `modeventtype_t`
    is defined in the `<sys/module.h>` header as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`module_t`是`module`结构的指针，`modeventtype_t`在`<sys/module.h>`头文件中定义如下：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an example of an event handler function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个事件处理程序函数的示例：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function will print "Hello, world!" when the module loads, "Good-bye, cruel
    world!" when it unloads, and will return with an error (`EOPNOTSUPP`)^([[2](#ftn.CHP-1-FN-2)])
    on shutdown and quiesce.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块加载时，此函数将打印"Hello, world!"，当它卸载时，将打印"Good-bye, cruel world!"，并在关闭和静默时返回错误（`EOPNOTSUPP`)^([[2](#ftn.CHP-1-FN-2)])。
- en: '* * *'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-1-FN-1)]) ¹ Actually, this isn't entirely true. You can have a KLD
    that just includes a `sysctl`. You can also dis-pense with module handlers if
    you wish and just use `SYSINIT` and `SYSUNINIT` directly to register func-tions
    to be invoked on load and unload, respectively. You can't, however, indicate failure
    in those.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-1-FN-1)]) ¹ 实际上，这并不完全正确。你可以有一个只包含`sysctl`的KLD。你也可以省略模块处理程序，直接使用`SYSINIT`和`SYSUNINIT`来注册在加载和卸载时调用的函数。然而，你无法在这些函数中指示失败。
- en: '^([[2](#CHP-1-FN-2)]) ² `EOPNOTSUPP` stands for *Error: Operation not supported*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-1-FN-2)]) ² `EOPNOTSUPP`代表*错误：不支持操作*
- en: The DECLARE_MODULE Macro
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DECLARE_MODULE宏
- en: 'When a KLD is loaded (by the `kldload(8)` command, described in ["Hello, world!"](ch01s03.html
    ""Hello, world!"")), it must link and register itself with the kernel. This can
    be easily accomplished by calling the `DECLARE_MODULE` macro, which is defined
    in the `<sys/module.h>` header as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个KLD被加载（通过`kldload(8)`命令，详见["Hello, world!"](ch01s03.html "Hello, world!")"")时，它必须与内核链接并注册自己。这可以通过调用定义在`<sys/module.h>`头文件中的`DECLARE_MODULE`宏轻松实现，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is a brief description of each parameter :'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个参数的简要描述：
- en: '**`name`**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**`name`**'
- en: This specifies the generic module name, which is passed as a character string.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了通用模块名称，它作为字符串传递。
- en: '**`data`**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**`data`**'
- en: 'This parameter specifies the official module name and event handler function,
    which is passed as a `moduledata` structure. `struct moduledata` is defined in
    the `<sys/module.h>` header as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数指定了官方模块名称和事件处理程序函数，它作为`moduledata`结构传递。`struct moduledata`在`<sys/module.h>`头文件中定义如下：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**`sub`**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**`sub`**'
- en: This specifies the system startup interface, which identifies the module type.
    Valid entries for this parameter can be found in the `<sys/kernel.h>` header within
    the `sysinit_sub_id` enumeration list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了系统启动接口，用于识别模块类型。此参数的有效条目可以在`sysinit_sub_id`枚举列表中的`<sys/kernel.h>`头文件中找到。
- en: For our purposes, we'll always set this parameter to `SI_SUB_DRIVERS`, which
    is used when registering a device driver.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将始终将此参数设置为`SI_SUB_DRIVERS`，当注册设备驱动程序时使用。
- en: '**`order`**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**`order`**'
- en: This specifies the KLD's order of initialization within the subsystem. You'll
    find valid entries for this parameter in the `<sys/kernel.h>` header within the
    `sysinit_elem_order` enumeration list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了子系统内KLD的初始化顺序。您可以在`sysinit_elem_order`枚举列表中的`<sys/kernel.h>`头文件中找到此参数的有效条目。
- en: For our purposes, we'll always set this parameter to `SI_ORDER_MIDDLE`, which
    will initialize the KLD somewhere in the middle.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将始终将此参数设置为`SI_ORDER_MIDDLE`，这将使KLD在中间某个位置初始化。
- en: '"Hello, world!"'
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"Hello, world!"'
- en: You now know enough to write your first KLD. Listing 1-1 is a complete "Hello,
    world!" module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经具备了编写第一个KLD的知识。列表1-1是一个完整的“Hello, world!”模块。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 1-1: hello.c*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-1: hello.c*'
- en: As you can see, this module is simply a combination of the sample event handler
    function from [Module Event Handler](ch01.html#module_event_handler "Module Event
    Handler") and a filled-out `DECLARE_MODULE` macro.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此模块仅仅是来自[模块事件处理器](ch01.html#module_event_handler "模块事件处理器")的示例事件处理函数和填充的`DECLARE_MODULE`宏的组合。
- en: To compile this module, you can use the system Makefile^([[3](#ftn.CHP-1-FN-3)])
    `bsd.kmod.mk`. Listing 1-2 shows the complete Makefile for hello.c.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此模块，您可以使用系统Makefile^([[3](#ftn.CHP-1-FN-3)]) `bsd.kmod.mk`。列表1-2显示了hello.c的完整Makefile。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing1-2: Makefile*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-2: Makefile*'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, we'll adapt this Makefile to compile every KLD by filling
    out *`KMOD`* and *`SRCS`* with the appropriate module name and source listing(s),
    respectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将通过填写*`KMOD`*和*`SRCS`*来编译每个KLD，分别使用适当的模块名称和源列表。
- en: 'Now, assuming the Makefile and hello.c are in the same directory, simply type
    **`make`** and (if we haven''t botched anything) the compilation should proceed—very
    verbosely—and produce an executable file named hello.ko, as shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设Makefile和hello.c在同一个目录中，只需简单地输入**`make`**，（如果我们没有出错）编译应该会继续——非常详细——并生成一个名为hello.ko的可执行文件，如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can load and unload hello.ko with the `kldload(8)` and `kldunload(8)` utilities,^([[4](#ftn.CHP-1-FN-4)])
    as shown below:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kldload(8)`和`kldunload(8)`实用程序加载和卸载hello.ko，^([[4](#ftn.CHP-1-FN-4)])
    如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Excellent—you have successfully loaded and unloaded code into a running kernel.
    Now, let's try something a little more advanced.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀——您已成功将代码加载到运行中的内核中。现在，让我们尝试一些更高级的操作。
- en: '* * *'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-1-FN-3)]) ³ A *Makefile* is used to simplify the process of converting
    a file or files from one form to another by describing the dependencies and build
    scripts for a given output. For more on Makefiles, see the make(1) manual page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-1-FN-3)]) ³ Makefile用于通过描述给定输出的依赖关系和构建脚本来简化将文件或文件从一种形式转换为另一种形式的过程。有关Makefile的更多信息，请参阅make(1)手册页。
- en: ^([[4](#CHP-1-FN-4)]) ⁴ With a Makefile that includes `<bsd.kmod.mk>`, you can
    also use `make load` and `make unload` to load and unload the module once you
    have built it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-1-FN-4)]) ⁴ 包含`<bsd.kmod.mk>`的Makefile，您还可以在构建模块后使用`make load`和`make
    unload`来加载和卸载模块。
- en: System Call Modules
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用模块
- en: '*System call modules* are simply KLDs that install a system call. In operating
    systems, a *system call*, also known as a *system service request*, is the mechanism
    an application uses to request service from the operating system''s kernel.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统调用模块*仅仅是安装系统调用的KLD。在操作系统上，*系统调用*，也称为*系统服务请求*，是应用程序请求操作系统内核服务的一种机制。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 2](ch02.html "Chapter 2. HOOKING"), [Chapter 3](ch03.html "Chapter 3. DIRECT
    KERNEL OBJECT MANIPULATION"), and [Chapter 6](ch06.html "Chapter 6. PUTTING IT
    ALL TOGETHER"), you'll be writing rootkits that either hack the existing system
    calls or install new ones. Thus, this section serves as a primer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。挂钩")、[第3章](ch03.html "第3章。直接内核对象操作")和[第6章](ch06.html "第6章。整合一切")中，您将编写rootkits，这些rootkits要么是对现有系统调用的黑客攻击，要么是安装新的系统调用。因此，本节作为入门指南。
- en: 'There are three items that are unique to each system call module: the system
    call function, the `sysent` structure, and the offset value.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统调用模块都有三个独特项：系统调用函数、`sysent`结构和偏移值。
- en: The System Call Function
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用函数
- en: 'The system call function implements the system call. Its function prototype
    is defined in the `<sys/sysent.h>` header as:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用函数实现了系统调用。其函数原型在`<sys/sysent.h>`头文件中定义：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: where `struct thread *` points to the currently running thread, and `void *`
    points to the system call's arguments' structure, if there is any.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`struct thread *`指向当前运行的线程，`void *`指向系统调用参数的结构体，如果有的话。
- en: Here is an example system call function that takes in a character pointer (i.e.,
    a string) and outputs it to the system console and logging facility via `printf(9)`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例系统调用函数，它接受一个字符指针（即字符串）并将其通过`printf(9)`输出到系统控制台和日志设施。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the system call's arguments are ❶ declared within a structure (`sc_example_args`).
    Also, notice that these arguments are accessed within the system call function
    by ❷ first declaring a `struct sc_example_args` pointer (`uap`) and then assigning
    ❸ the coerced `void` pointer (`syscall_args`) to that pointer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，系统调用的参数是在结构体（`sc_example_args`）内声明的。另外，请注意，这些参数是在系统调用函数内通过❶首先声明一个`struct
    sc_example_args`指针（`uap`）然后将其赋值给❷强制转换的`void`指针（`syscall_args`）来访问的。
- en: Keep in mind that the system call's arguments reside in user space but that
    the system call function executes in kernel space.^([[5](#ftn.CHP-1-FN-5)]) Thus,
    when you access the arguments via `uap`, you are actually working by value, not
    reference. This means that, with this approach, you aren't able to modify the
    actual arguments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，系统调用的参数位于用户空间，但系统调用函数在内核空间中执行。因此，当您通过`uap`访问参数时，您实际上是在按值操作，而不是按引用操作。这意味着，使用这种方法，您无法修改实际的参数。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Kernel/User Space Transitions](ch01s05.html "Kernel/User Space Transitions"),
    I'll detail how to modify data residing in user space while in kernel space.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[内核/用户空间转换](ch01s05.html "内核/用户空间转换")中，我将详细介绍如何在内核空间中修改用户空间中的数据。
- en: It is probably worth mentioning that the kernel expects each system call argument
    to be of size `register_t` (which is an `int` on i386, but is typically a `long`
    on other platforms) and that it builds an array of `register_t` values that are
    then cast to `void *` and passed as the arguments. For this reason, you might
    need to include explicit padding in your arguments' structure to make it work
    correctly if it has any types that aren't of size `register_t` (e.g., `char`,
    or `int` on a 64-bit platform). The `<sys/sysproto.h>` header provides some macros
    to do this, along with examples.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可能值得提一下，内核期望每个系统调用参数的大小为`register_t`（在i386上是一个`int`，但在其他平台上通常是`long`），并且它构建了一个`register_t`值的数组，然后将这些值强制转换为`void
    *`并作为参数传递。因此，如果您的参数结构体中有任何不是`register_t`大小的类型（例如，`char`或64位平台上的`int`），您可能需要在参数结构体中显式添加填充以使其正确工作。《<sys/sysproto.h>`头文件提供了一些宏来完成这项工作，以及一些示例。
- en: The sysent Structure
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用结构
- en: 'System calls are defined by their entries in a `sysent` structure, which is
    defined in the `<sys/sysent.h>` header as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用是通过`sysent`结构中的条目定义的，该结构在`<sys/sysent.h>`头文件中定义如下：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the complete `sysent` structure for the example system call (shown
    in [The System Call Function](ch01s04.html#the_system_call_function "The System
    Call Function")):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例系统调用完整的`sysent`结构（在[系统调用函数](ch01s04.html#the_system_call_function "The
    System Call Function")中展示）：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Recall that the example system call has only one argument (a character pointer)
    and is named `sc_example`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，示例系统调用只有一个参数（一个字符指针）并命名为`sc_example`。
- en: 'One additional point is also worth mentioning. In FreeBSD, the system call
    table is simply an array of `sysent` structures, and it is declared in the `<sys/sysent.h>`
    header as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点。在FreeBSD中，系统调用表只是一个`sysent`结构的数组，它在`<sys/sysent.h>`头文件中声明如下：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Whenever a system call is installed, its `sysent` structure is placed within
    an open element in `sysent[]`. (This is an important point that will come into
    play in [Chapter 2](ch02.html "Chapter 2. HOOKING") and [Chapter 6](ch06.html
    "Chapter 6. PUTTING IT ALL TOGETHER").)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每当安装一个系统调用时，其`sysent`结构就被放置在`sysent[]`中的一个开放元素中。（这是一个重要的点，将在[第2章](ch02.html
    "第2章. HOOKING")和[第6章](ch06.html "第6章. PUTTING IT ALL TOGETHER")中发挥作用。）
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, I'll refer to FreeBSD's system call table as *`sysent[]`*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将把FreeBSD的系统调用表称为*`sysent[]`*。
- en: The Offset Value
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏移值
- en: The *offset value* (also known as the *system call number*) is a unique integer
    between 0 and 456 that is assigned to each system call to indicate its `sysent`
    structure's offset within `sysent[]`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*偏移值*（也称为*系统调用号*）是一个介于0和456之间的唯一整数，它被分配给每个系统调用，以指示其`sysent`结构在`sysent[]`中的偏移量。'
- en: 'Within a system call module, the offset value needs to be explicitly declared.
    This is typically done as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The constant `NO_SYSCALL` sets `offset` to the next available or open element
    in `sysent[]`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Although you could manually set `offset` to any unused system call number, it's
    considered good practice to avoid doing so when implementing something dynamic,
    like a KLD.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a list of used and unused system call numbers, see the file /sys/kern/syscalls.master.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The SYSCALL_MODULE Macro
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from [The DECLARE_MODULE Macro](ch01s02.html "The DECLARE_MODULE Macro")
    that when a KLD is loaded, it must link and register itself with the kernel and
    that you use the `DECLARE_MODULE` macro to do so. However, when writing a system
    call module, the `DECLARE_MODULE` macro is somewhat inconvenient, as you''ll soon
    see. Thus, we use the `SYSCALL_MODULE` macro instead, which is defined in the
    `<sys/sysent.h>` header as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, if we were to use the `DECLARE_MODULE` macro, we would've had
    to set up a `syscall_module_data` and `moduledata` structure first; thankfully,
    `SYSCALL_MODULE` saves us this trouble.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a brief description of each parameter in `SYSCALL_MODULE`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**`name`**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This specifies the generic module name, which is passed as a character string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**`offset`**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: This specifies the system call's offset value, which is passed as an integer
    pointer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**`new_sysent`**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: This specifies the completed `sysent` structure, which is passed as a `struct
    sysent` pointer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**`evh`**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This specifies the event handler function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**`arg`**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: This specifies the arguments to be passed to the event handler function. For
    our purposes, we'll always set this parameter to `NULL`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Example
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Listing 1-3 is a complete system call module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 1-3: sc_example.c*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this module is simply a combination of all the components described
    throughout this section, with the addition of an event handler function. Simple,
    no?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results of loading this module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So far, so good. Now, let's write a simple user space program to execute and
    test this new system call. But first, an explanation of the `modfind`, `modstat`,
    and `syscall` functions is required.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The modfind Function
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `modfind` function returns the modid of a kernel module based on its module
    name.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Modids* are integers used to uniquely identify each loaded module in the system.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The modstat Function
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `modstat` function returns the status of a kernel module referred to by
    its modid.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The returned information is stored in `stat`, a `module_stat` structure, which
    is defined in the `<sys/module.h>` header as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The syscall Function
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `syscall` function executes the system call specified by its system call
    number.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Executing the System Call
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing 1-4 is a user space program designed to execute the system call in
    Listing 1-3 (which is named `sc_example`). This program takes one command-line
    argument: a string to be passed to `sc_example`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 1-4: interface.c*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we first call ❶ `modfind` and `modstat` to determine `sc_example`'s
    offset value. This value is then passed to ❷ `syscall`, along with the first command-line
    argument, which effectively executes `sc_example`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先调用 ❶ `modfind` 和 `modstat` 来确定 `sc_example` 的偏移值。然后，将此值传递给 ❷ `syscall`，同时传递第一个命令行参数，这实际上执行了
    `sc_example`。
- en: 'Some sample output follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例输出：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Executing the System Call Without C Code
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无需 C 代码执行系统调用
- en: 'While writing a user space program to execute a system call is the "proper"
    way to do it, when you just want to test a system call module, it''s annoying
    to have to write an additional program first. To execute a system call without
    writing a user space program, here''s what I do:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写用户空间程序来执行系统调用是“正确”的方式，但当你只想测试一个系统调用模块时，不得不先编写一个额外的程序是很烦人的。为了在不编写用户空间程序的情况下执行系统调用，这里是我的做法：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As the preceding demonstration shows, by taking advantage of Perl's command-line
    execution (i.e., the `-e` option), its `syscall` function, and the fact that you
    know your system call's offset value, you can quickly test any system call module.
    One thing to keep in mind is that you cannot use string literals with Perl's `syscall`
    function, which is why I use a variable (`$str`) to pass the string to `sc_example`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的演示所示，通过利用 Perl 的命令行执行（即 `-e` 选项）、其 `syscall` 函数以及你知道的系统调用偏移值，你可以快速测试任何系统调用模块。需要注意的是，你不能使用字符串字面量与
    Perl 的 `syscall` 函数一起使用，这就是为什么我使用变量（`$str`）将字符串传递给 `sc_example`。
- en: '* * *'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[5](#CHP-1-FN-5)]) ⁵ FreeBSD segregates its virtual memory into two parts:
    *user space* and *kernel space*. User space is where all user-mode applications
    run, while kernel space is where the kernel and kernel exten-sions (i.e., LKMs)
    run. Code running in user space cannot access kernel space directly (but code
    running in kernel space *can* access user space). To access kernel space from
    user space, an application issues a system call.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-1-FN-5)]) ⁵ FreeBSD 将其虚拟内存分为两部分：*用户空间* 和 *内核空间*。用户空间是所有用户模式应用程序运行的地方，而内核空间是内核和内核扩展（即
    LKMs）运行的地方。在用户空间运行的可执行代码不能直接访问内核空间（但运行在内核空间的可执行代码 *可以* 访问用户空间）。要从用户空间访问内核空间，应用程序需要发出系统调用。
- en: Kernel/User Space Transitions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核/用户空间转换
- en: I'll now describe a set of core functions that you can use from kernel space
    to copy, manipulate, and overwrite the data stored in user space. We'll put these
    functions to much use throughout this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将描述一组核心函数，你可以从内核空间使用这些函数来复制、操作和覆盖存储在用户空间中的数据。我们将在整本书中多次使用这些函数。
- en: The copyin and copyinstr Functions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: copyin 和 copyinstr 函数
- en: The `copyin` and `copyinstr` functions allow you to copy a continuous region
    of data from user space to kernel space.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyin` 和 `copyinstr` 函数允许你从用户空间复制一个连续的数据区域到内核空间。'
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `copyin` function copies `len` bytes of data from the user space address
    `uaddr` to the kernel space address `kaddr`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyin` 函数将从用户空间地址 `uaddr` 复制 `len` 字节数据到内核空间地址 `kaddr`。'
- en: The `copyinstr` function is similar, except that it copies a null-terminated
    string, which is at most `len` bytes long, with the number of bytes actually copied
    returned in `done`.^([[6](#ftn.CHP-1-FN-6)])
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyinstr` 函数类似，但它是复制一个以空字符终止的字符串，其长度最多为 `len` 字节，实际复制的字节数在 `done` 中返回。^([[6](#ftn.CHP-1-FN-6)])'
- en: The copyout Function
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: copyout 函数
- en: The `copyout` function is similar to `copyin`, except that it operates in the
    opposite direction, copying data from kernel space to user space.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyout` 函数与 `copyin` 类似，但它操作的方向相反，从内核空间复制数据到用户空间。'
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The copystr Function
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: copystr 函数
- en: The `copystr` function is similar to `copyinstr`, except that it copies a string
    from one kernel space address to another.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`copystr` 函数与 `copyinstr` 类似，但它将字符串从一个内核空间地址复制到另一个内核空间地址。'
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '* * *'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#CHP-1-FN-6)]) ⁶ In Listing 1-3, the system call function should, admittedly,
    first call `copyinstr` to copy in the user space string and then print that. As
    is, it prints a userland string directly from kernel space, which can trigger
    a fatal panic if the page holding the string is unmapped (i.e., swapped out or
    not faulted in yet). That's why it's just an example and not a real system call.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-1-FN-6)]) ⁶ 在列表 1-3 中，系统调用函数应该首先调用 `copyinstr` 来复制用户空间字符串，然后打印它。实际上，它直接从内核空间打印用户空间字符串，如果包含该字符串的页面未映射（即，已交换出或尚未故障恢复），则可能触发致命的恐慌。这就是为什么它只是一个示例，而不是真正的系统调用。
- en: Character Device Modules
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符设备模块
- en: '*Character device modules* are KLDs that create or install a character device.
    In FreeBSD, a *character device* is the interface for accessing a specific device
    within the kernel. For example, data is read from and written to the system console
    via the character device /dev/console.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符设备模块* 是创建或安装字符设备的 KLD。在 FreeBSD 中，*字符设备* 是在内核中访问特定设备的接口。例如，数据通过字符设备 /dev/console
    从系统控制台读取和写入。'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 4](ch04.html "Chapter 4. KERNEL OBJECT HOOKING") you'll be writing
    rootkits that hack the existing character devices on the system. Thus, this section
    serves as a primer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.html "第 4 章。内核对象挂钩") 中，您将编写用于破解系统现有字符设备的 rootkits。因此，本节作为入门指南。
- en: 'There are three items that are unique to each character device module: a `cdevsw`
    structure, the character device functions, and a device registration routine.
    We''ll discuss each in turn below.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符设备模块都有三个独特项：一个 `cdevsw` 结构、字符设备函数和一个设备注册例程。我们依次讨论每个。
- en: The cdevsw Structure
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cdevsw 结构
- en: 'A character device is defined by its entries in a character device switch table,
    `struct cdevsw`, which is defined in the `<sys/conf.h>` header as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备由其在字符设备切换表 `struct cdevsw` 中的条目定义，该表在 `<sys/conf.h>` 头文件中如下定义：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Table 1-1](ch01s06.html#entry_points_for_character_device_drivers "Table 1-1. Entry
    Points for Character Device Drivers") provides a brief description of the most
    relevant entry points.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01s06.html#entry_points_for_character_device_drivers "表 1-1。字符设备驱动程序的入口点")
    提供了最相关入口点的简要描述。'
- en: '**Table 1-1. Entry Points for Character Device Drivers**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1。字符设备驱动程序的入口点**'
- en: '| Entry Point | Description |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 入口点 | 描述 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d_open` | Opens a device for I/O operations |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `d_open` | 为 I/O 操作打开设备 |'
- en: '| `d_close` | Closes a device |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `d_close` | 关闭设备 |'
- en: '| `d_read` | Reads data from a device |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `d_read` | 从设备读取数据 |'
- en: '| `d_write` | Writes data to a device |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `d_write` | 向设备写入数据 |'
- en: '| `d_ioctl` | Performs an operation other than a read or a write |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `d_ioctl` | 执行除读取或写入之外的操作 |'
- en: '| `d_poll` | Polls a device to see if there is data to be read or space available
    for writing |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `d_poll` | 轮询设备以查看是否有可读数据或可写空间 |'
- en: 'Here is an example `cdevsw` structure for a simple read/write character device
    module:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的读写字符设备模块的 `cdevsw` 结构示例：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that I do not define every entry point or fill out every attribute. This
    is perfectly okay. For every entry point left null, the operation is considered
    unsupported. For example, when creating a write-only device, you would not declare
    the read entry point.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有定义每个入口点或填写每个属性。这是完全可以的。对于每个留空的入口点，该操作被认为是未支持的。例如，在创建只写设备时，您不会声明读取入口点。
- en: 'Still, there are two elements that must be defined in every `cdevsw` structure:
    `d_version`, which indicates the versions of FreeBSD that the driver supports,
    and `d_name`, which specifies the device''s name.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，每个 `cdevsw` 结构中必须定义两个元素：`d_version`，它表示驱动程序支持的 FreeBSD 版本，以及 `d_name`，它指定设备名称。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The constant *`D_VERSION`* is defined in the *`<sys/conf.h>`* header, along
    with other version numbers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 *`D_VERSION`* 在 *`<sys/conf.h>`* 头文件中定义，以及其他版本号。
- en: Character Device Functions
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符设备函数
- en: For every entry point defined in a character device module's `cdevsw` structure,
    you must implement a corresponding function. The function prototype for each entry
    point is defined in the `<sys/conf.h>` header.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在字符设备模块的 `cdevsw` 结构中定义的每个入口点，您必须实现相应的函数。每个入口点的函数原型在 `<sys/conf.h>` 头文件中定义。
- en: Below is an example implementation for the write entry point.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是写入入口点的示例实现。
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, this function simply calls `copyinstr` to copy a string from
    user space and store it in a buffer, `buf`, in kernel space.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此函数简单地调用 `copyinstr` 从用户空间复制一个字符串并将其存储在内核空间的缓冲区 `buf` 中。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Example](ch01s06.html#example-id1 "Example") I'll show and explain some
    more entry-point implementations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例](ch01s06.html#example-id1 "示例") 中，我将展示并解释一些更多的入口点实现。
- en: The Device Registration Routine
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备注册例程
- en: 'The device registration routine creates or installs the character device on
    /dev and registers it with the device file system (DEVFS). You can accomplish
    this by calling the `make_dev` function within the event handler function as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设备注册例程在 /dev 上创建或安装字符设备，并将其与设备文件系统 (DEVFS) 注册。您可以通过在事件处理函数中调用 `make_dev` 函数来完成此操作，如下所示：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example function will register the character device, `cd_example`, when
    the module loads by calling the `make_dev` function, which will create a `cd_example`
    device node on /dev. Also, this function will unregister the character device
    when the module unloads by calling the `destroy_dev` function, which takes as
    its sole argument the `cdev` structure returned from a preceding `make_dev` call.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例函数在模块加载时通过调用`make_dev`函数注册字符设备`cd_example`，该函数将在`/dev`上创建一个`cd_example`设备节点。此外，此函数在模块卸载时通过调用`destroy_dev`函数注销字符设备，该函数的单一参数是从先前的`make_dev`调用返回的`cdev`结构。
- en: Example
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: Listing 1-5 shows a complete character device module (based on Rajesh Vaidheeswarran's
    cdev.c) that installs a simple read/write character device. This device acts on
    an area of kernel memory, reading and writing a single character string from and
    to it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-5 显示了一个完整的字符设备模块（基于Rajesh Vaidheeswarran的cdev.c），该模块安装了一个简单的读写字符设备。该设备作用于内核内存的一个区域，从它那里读取和写入单个字符字符串。
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 1-5: cd_example.c*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-5：cd_example.c*'
- en: 'The following is a breakdown of the above listing. First, at the beginning,
    we declare the character device''s entry points (open, close, read, and write).
    Next, we appropriately fill out a `cdevsw` structure. Afterward, we declare two
    global variables: `buf`, which is used to store the character string that this
    device will be reading in, and `len`, which is used to store the string length.
    Next, we implement each entry point. The open entry point simply initializes `buf`
    and then returns. The close entry point does nothing, more or less, but it still
    needs to be implemented in order to close the device. The write entry point is
    what is called to store the character string (from user space) in `buf`, and the
    read entry point is what is called to return it. Lastly, the event handler function
    takes care of the character device''s registration routine.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对上述列表的分解。首先，在开始时，我们声明字符设备的入口点（打开、关闭、读取和写入）。接下来，我们适当地填写一个`cdevsw`结构。之后，我们声明两个全局变量：`buf`，用于存储该设备将要读取的字符字符串，以及`len`，用于存储字符串长度。接下来，我们实现每个入口点。打开入口点简单地初始化`buf`然后返回。关闭入口点基本上什么都不做，但仍需要实现以关闭设备。写入入口点是将字符字符串（从用户空间）存储在`buf`中的调用，而读取入口点则是返回它的调用。最后，事件处理函数负责字符设备的注册例程。
- en: 'Notice that the character device module calls `DEV_MODULE` at the end, instead
    of `DECLARE_MODULE`. The `DEV_MODULE` macro is defined in the `<sys/conf.h>` header
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符设备模块在末尾调用`DEV_MODULE`，而不是`DECLARE_MODULE`。`DEV_MODULE` 宏在`<sys/conf.h>`头文件中定义如下：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, `DEV_MODULE` wraps `DECLARE_MODULE`. `DEV_MODULE` simply allows
    you to call `DECLARE_MODULE` without having to explicitly set up a `moduledata`
    structure first.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`DEV_MODULE` 包装了`DECLARE_MODULE`。`DEV_MODULE` 只允许您调用`DECLARE_MODULE`，而无需首先显式设置`moduledata`结构。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *`DEV_MODULE`* macro is typically associated with character device modules.
    Thus, when I write a generic KLD (such as the "Hello, world!" example in ["Hello,
    world!"](ch01s03.html ""Hello, world!"")), I'll continue to use the *`DECLARE_MODULE`*
    macro, even if *`DEV_MODULE`* would save space and time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*`DEV_MODULE`* 宏通常与字符设备模块相关联。因此，当我在写一个通用的KLD（例如在["Hello, world!"](ch01s03.html
    ""Hello, world!"")中的"Hello, world!"示例）时，我将继续使用*`DECLARE_MODULE`* 宏，即使*`DEV_MODULE`*
    可以节省空间和时间。'
- en: Testing the Character Device
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试字符设备
- en: 'Now let''s look at the user space program (Listing 1-6) that we''ll use to
    interact with the `cd_example` character device. This program (based on Rajesh
    Vaidheeswarran''s testcdev.c) calls each `cd_example` entry point in the following
    order: open, write, read, close; then it exits.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们将用来与`cd_example`字符设备交互的用户空间程序（列表 1-6）。此程序（基于Rajesh Vaidheeswarran的testcdev.c）按照以下顺序调用每个`cd_example`入口点：打开、写入、读取、关闭；然后退出。
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 1-6: interface.c*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-6：interface.c*'
- en: 'Here are the results of loading the character device module and interacting
    with it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是加载字符设备模块并与它交互的结果：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Linker Files and Modules
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接文件和模块
- en: Before wrapping up this chapter, let's take a brief look at the `kldstat(8)`
    command, which displays the status of any files dynamically linked into the kernel.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们简要地看一下`kldstat(8)`命令，该命令显示动态链接到内核的任何文件的状态。
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the above listing, three "modules" are loaded: the kernel (`kernel`), the
    ACPI power-management module (`acpi.ko`), and the "Hello, world!" module (`hello.ko`)
    that we developed in ["Hello, world!"](ch01s03.html ""Hello, world!"").'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中，加载了三个“模块”：内核（`kernel`）、ACPI电源管理模块（`acpi.ko`）以及我们在 ["Hello, world!"](ch01s03.html
    ""Hello, world!"") 中开发的“Hello, world!”模块（`hello.ko`）。
- en: 'Running the command `kldstat -v` (for more verbose output) gives us the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令 `kldstat -v`（以获得更详细的输出）会给出以下信息：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that `kernel` contains multiple "submodules" (`xpt`, `probe`, and `cam`).
    This brings us to the real point of this section. In the preceding output, `kernel`
    and `hello.ko` are technically linker files, and `xpt`, `probe`, `cam`, and `hello`
    are the actual modules. This means that the arguments(s) for `kldload(8)` and
    `kldunload(8)` are actually linker files, not modules, and that for every module
    loaded into the kernel, there is an accompanying linker file. (This point will
    come into play when we discuss hiding KLDs.)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`kernel` 包含多个“子模块”（`xpt`、`probe` 和 `cam`）。这引出了本节真正的重点。在前面的输出中，`kernel` 和
    `hello.ko` 技术上来说是链接器文件，而 `xpt`、`probe`、`cam` 和 `hello` 是实际的模块。这意味着 `kldload(8)`
    和 `kldunload(8)` 的参数实际上是链接器文件，而不是模块，并且对于每个加载到内核中的模块，都有一个相应的链接器文件。（这一点在我们讨论隐藏 KLD
    时会发挥作用。）
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For our purposes, think of a linker file as an usher (or escort) for one or
    more kernel modules, guiding them into kernel space.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的而言，可以将链接器文件想象为引导一个或多个内核模块进入内核空间的引路人（或护送者）。
- en: Concluding Remarks
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter has been a whirlwind tour of FreeBSD kernel-module programming.
    I've described some of the various types of KLDs that we'll encounter again and
    again, and you've seen numerous small examples to give you a feel for what the
    remainder of this book is like.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对 FreeBSD 内核模块编程进行了一次快速浏览。我描述了一些我们将反复遇到的 KLD 类型，并且你看到了许多小例子，以让你对本书的其余部分有所感受。
- en: Two additional points are also worth mentioning. First, the kernel source tree,
    which is located in /usr/src/sys/,^([[7](#ftn.CHP-1-FN-7)]) is the best reference
    and learning tool for a newbie FreeBSD kernel hacker. If you have yet to look
    through this directory, by all means, do so; much of the code in this book is
    gleaned from there.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两点也值得提及。首先，内核源代码树位于 /usr/src/sys/，^([[7](#ftn.CHP-1-FN-7)]) 是新晋 FreeBSD 内核黑客的最佳参考和学习工具。如果你还没有查看这个目录，请务必查看；本书中的大部分代码都是从那里提炼出来的。
- en: Second, consider setting up a FreeBSD machine with a debug kernel or kernel-mode
    debugger; this helps considerably when you write your own kernel code. The following
    online resources will help you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑设置一个带有调试内核或内核模式调试器的 FreeBSD 机器；当你编写自己的内核代码时，这会大有裨益。以下在线资源将帮助你。
- en: '*The FreeBSD Developer''s Handbook*, specifically Chapter 10, located at [http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook](http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《FreeBSD 开发者手册》*，特别是第 10 章，位于 [http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook](http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook)。'
- en: '*Debugging Kernel Problems* by Greg Lehey, located at [http://www.lemis.com/grog/Papers/Debug-tutorial/tutorial.pdf](http://www.lemis.com/grog/Papers/Debug-tutorial/tutorial.pdf)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《调试内核问题》*，作者 Greg Lehey，位于 [http://www.lemis.com/grog/Papers/Debug-tutorial/tutorial.pdf](http://www.lemis.com/grog/Papers/Debug-tutorial/tutorial.pdf)'
- en: '* * *'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[7](#CHP-1-FN-7)]) ⁷ Typically, there is also a symlink from /sys/ to /usr/src/sys/.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-1-FN-7)]) ⁷ 通常，从 /sys/ 到 /usr/src/sys/ 之间也存在一个符号链接。
