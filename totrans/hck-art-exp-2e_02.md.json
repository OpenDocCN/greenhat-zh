["```\nStart out down Main Street headed east. Continue on Main Street until you see\na church on your right. If the street is blocked because of construction, turn\nright there at 15th Street, turn left on Pine Street, and then turn right on\n16th Street. Otherwise, you can just continue and make a right on 16th Street.\nContinue on 16th Street, and turn left onto Destination Road. Drive straight\ndown Destination Road for 5 miles, and then you'll see the house on the right.\nThe address is 743 Destination Road.\n```", "```\nIf *`(condition) then {   Set of instructions to execute if the condition is met;`*\n}\nElse\n{\n  *`Set of instruction to execute if the condition is not met; }`*\n```", "```\nDrive down Main Street;\nIf (street is blocked)\n{\n  Turn right on 15th Street;\n  Turn left on Pine Street;\n  Turn right on 16th Street;\n}\nElse\n{\n  Turn right on 16th Street;\n}\n```", "```\nDrive down Main Street;\nIf (street is blocked)\n{\n  Turn right on 15th Street;\n  Turn left on Pine Street;\n  Turn right on 16th Street;\n}\nElse\n  Turn right on 16th Street;\n```", "```\nIf (there is only one instruction in a set of instructions)\n  The use of curly braces to group the instructions is optional;\nElse\n{\n  The use of curly braces is necessary;\n  Since there must be a logical way to group these instructions;\n}\n```", "```\nWhile (you are hungry)\n{\n  Find some food;\n  Eat the food;\n}\n```", "```\nUntil (you are not hungry)\n{\n  Find some food;\n  Eat the food;\n}\n```", "```\nWhile (there is not a church on the right)\n   Drive down Main Street;\n```", "```\nFor (5 iterations)\n  Drive straight for 1 mile;\n```", "```\nSet the counter to 0;\nWhile (the counter is less than 5)\n{\n  Drive straight for 1 mile;\n  Add 1 to the counter;\n}\n```", "```\nFor (i=0; i<5; i++)\n  Drive straight for 1 mile;\n```", "```\nBegin going East on Main Street;\nWhile (there is not a church on the right)\n  Drive down Main Street;\nIf (street is blocked)\n{\n  Turn right on 15th Street;\n  Turn left on Pine Street;\n  Turn right on 16th Street;\n}\nElse\n  Turn right on 16th Street;\nTurn left on Destination Road;\nFor (i=0; i<5; i++)\n  Drive straight for 1 mile;\nStop at 743 Destination Road;\n```", "```\nint a, b;\nfloat k;\nchar z;\n```", "```\nint a = 13, b;\nfloat k;\nchar z = 'A';\n\nk = 3.14;\nz = 'w';\nb = a + 5;\n```", "```\nint a, b;\na = 5;\nb = a++ * 6;\n```", "```\nb = a * 6;\na = a + 1;\n```", "```\na = a + 1;\nb = a * 6;\n```", "```\n!(a < b)    is equivalent to    (a >= b)\n```", "```\nWhile (hungry == 1)\n{\n  Find some food;\n  Eat the food;\n}\n```", "```\nWhile (hungry)\n{\n  Find some food;\n  Eat the food;\n}\n```", "```\nWhile ((hungry) && !(cat_present))\n{\n  Find some food;\n  If(!(food_is_on_a_mousetrap))\n    Eat the food;\n}\n```", "```\nFunction Turn(variable_direction)\n{\n  Activate the variable_direction blinker;\n  Slow down;\n  Check for oncoming traffic;\n  while(there is oncoming traffic)\n  {\n    Stop;\n    Watch for oncoming traffic;\n  }\n  Turn the steering wheel to the variable_direction;\n  while(turn is not complete)\n  {\n    if(speed < 5 mph)\n      Accelerate;\n  }\n  Turn the steering wheel back to the original position;\n  Turn off the variable_direction blinker;\n}\n```", "```\nint factorial(int x)\n{\n  int i;\n  for(i=1; i < x; i++)\n    x *= i;\n  return x;\n}\n```", "```\nint a=5, b;\nb = factorial(a);\n```", "```\nint factorial(int);\n```", "```\nvoid turn(variable_direction, target_street_name)\n{\n  Look for a street sign;\n  current_intersection_name = read street sign name;\n  while(current_intersection_name != target_street_name)\n  {\n    Look for another street sign;\n    current_intersection_name = read street sign name;\n  }\n\n  Activate the variable_direction blinker;\n  Slow down;\n  Check for oncoming traffic;\n  while(there is oncoming traffic)\n  {\n    Stop;\n    Watch for oncoming traffic;\n  }\n  Turn the steering wheel to the variable_direction;\n  while(turn is not complete)\n  {\n    if(speed < 5 mph)\n      Accelerate;\n  }\n  Turn the steering wheel right back to the original position;\n  Turn off the variable_direction blinker;\n}\n```", "```\nBegin going East on Main Street;\nwhile (there is not a church on the right)\n   Drive down Main Street;\nif (street is blocked)\n{\n  Turn(right, 15th Street);\n  Turn(left, Pine Street);\n  Turn(right, 16th Street);\n}\nelse\n  Turn(right, 16th Street);\nTurn(left, Destination Road);\nfor (i=0; i<5; i++)\n  Drive straight for 1 mile;\nStop at 743 Destination Road;\n```", "```\n#include <stdio.h>\n\nint main()\n{\n  int i;\n  for(i=0; i < 10; i++)       // Loop 10 times.\n  {\n    puts(\"Hello, world!\\n\");  // put the string to the output.\n  }\n  return 0;                   // Tell OS the program exited without errors.\n}\n```", "```\nreader@hacking:~/booksrc $ gcc firstprog.c\nreader@hacking:~/booksrc $ ls -l a.out\n-rwxr-xr-x 1 reader reader 6621 2007-09-06 22:16 a.out\nreader@hacking:~/booksrc $ ./a.out\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ objdump -D a.out | grep -A20 main.:\n08048374 <main>:\n 8048374:       55                      push   %ebp\n 8048375:       89 e5                   mov    %esp,%ebp\n 8048377:       83 ec 08                sub    $0x8,%esp\n 804837a:       83 e4 f0                and    $0xfffffff0,%esp\n 804837d:       b8 00 00 00 00          mov    $0x0,%eax\n 8048382:       29 c4                   sub    %eax,%esp\n 8048384:       c7 45 fc 00 00 00 00    movl   $0x0,0xfffffffc(%ebp)\n 804838b:       83 7d fc 09             cmpl   $0x9,0xfffffffc(%ebp)\n 804838f:       7e 02                   jle    8048393 <main+0x1f>\n 8048391:       eb 13                   jmp    80483a6 <main+0x32>\n 8048393:       c7 04 24 84 84 04 08    movl   $0x8048484,(%esp)\n 804839a:       e8 01 ff ff ff          call   80482a0 <printf@plt>\n 804839f:       8d 45 fc                lea    0xfffffffc(%ebp),%eax\n 80483a2:       ff 00                   incl   (%eax)\n 80483a4:       eb e5                   jmp    804838b <main+0x17>\n 80483a6:       c9                      leave\n 80483a7:       c3                      ret\n 80483a8:       90                      nop\n 80483a9:       90                      nop\n 80483aa:       90                      nop\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ objdump -M intel -D a.out | grep -A20 main.:\n08048374 <main>:\n 8048374:       55                      push   ebp\n 8048375:       89 e5                   mov    ebp,esp\n 8048377:       83 ec 08                sub    esp,0x8\n 804837a:       83 e4 f0                and    esp,0xfffffff0\n 804837d:       b8 00 00 00 00          mov    eax,0x0\n 8048382:       29 c4                   sub    esp,eax\n 8048384:       c7 45 fc 00 00 00 00    mov    DWORD PTR [ebp-4],0x0\n 804838b:       83 7d fc 09             cmp    DWORD PTR [ebp-4],0x9\n 804838f:       7e 02                   jle    8048393 <main+0x1f>\n 8048391:       eb 13                   jmp    80483a6 <main+0x32>\n 8048393:       c7 04 24 84 84 04 08    mov    DWORD PTR [esp],0x8048484\n 804839a:       e8 01 ff ff ff          call   80482a0 <printf@plt>\n 804839f:       8d 45 fc                lea    eax,[ebp-4]\n 80483a2:       ff 00                   inc    DWORD PTR [eax]\n 80483a4:       eb e5                   jmp    804838b <main+0x17>\n 80483a6:       c9                      leave\n 80483a7:       c3                      ret\n 80483a8:       90                      nop\n 80483a9:       90                      nop\n 80483aa:       90                      nop\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x804837a\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\n\nBreakpoint 1, 0x0804837a in main ()\n(gdb) info registers\neax            0xbffff894       -1073743724\necx            0x48e0fe81       1222704769\nedx            0x1      1\nebx            0xb7fd6ff4       -1208127500\nesp            0xbffff800       0xbffff800\nebp            0xbffff808       0xbffff808\nesi            0xb8000ce0       -1207956256\nedi            0x0      0\neip            0x804837a        0x804837a <main+6>\neflags         0x286    [ PF SF IF ]\ncs             0x73     115\nss             0x7b     123\nds             0x7b     123\nes             0x7b     123\nfs             0x0      0\ngs             0x33     51\n(gdb) quit\nThe program is running.  Exit anyway? (y or n) y\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q\n(gdb) set dis intel\n(gdb) quit\nreader@hacking:~/booksrc $ echo \"set dis intel\" > ~/.gdbinit\nreader@hacking:~/booksrc $ cat ~/.gdbinit\nset dis intel\nreader@hacking:~/booksrc $\n```", "```\noperation <destination>, <source>\n```", "```\n8048375:        89 e5                 mov    ebp,esp\n8048377:        83 ec 08              sub    esp,0x8\n```", "```\n804838b:        83 7d fc 09           cmp    DWORD PTR [ebp-4],0x9\n804838f:        7e 02                 jle    8048393 <main+0x1f>\n8048391:        eb 13                 jmp    80483a6 <main+0x32>\n```", "```\nreader@hacking:~/booksrc $ gcc -g firstprog.c \nreader@hacking:~/booksrc $ ls -l a.out\n-rwxr-xr-x 1 matrix users 11977 Jul 4 17:29 a.out\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n(gdb) list\n1       #include <stdio.h>\n2\n3       int main()\n4       {\n5               int i;\n6               for(i=0; i < 10; i++)\n7               {\n 8                       printf(\"Hello, world!\\n\");\n9               }\n10      }\n(gdb) disassemble main\nDump of assembler code for function main():\n0x08048384 <main+0>:    push   ebp\n*`0x08048385 <main+1>:    mov    ebp,esp 0x08048387 <main+3>:    sub    esp,0x8 0x0804838a <main+6>:    and    esp,0xfffffff0 0x0804838d <main+9>:    mov    eax,0x0 0x08048392 <main+14>:   sub    esp,eax`*\n`0x08048394 <main+16>:   mov    DWORD PTR [ebp-4],0x0`\n0x0804839b <main+23>:   cmp    DWORD PTR [ebp-4],0x9\n0x0804839f <main+27>:   jle    0x80483a3 <main+31>\n0x080483a1 <main+29>:   jmp    0x80483b6 <main+50>\n0x080483a3 <main+31>:   mov    DWORD PTR [esp],0x80484d4\n0x080483aa <main+38>:   call   0x80482a8 <_init+56>\n0x080483af <main+43>:   lea    eax,[ebp-4]\n0x080483b2 <main+46>:   inc    DWORD PTR [eax]\n0x080483b4 <main+48>:   jmp    0x804839b <main+23>\n0x080483b6 <main+50>:   leave\n0x080483b7 <main+51>:   ret\nEnd of assembler dump.\n(gdb) break main\nBreakpoint 1 at 0x8048394: file firstprog.c, line 6.\n(gdb) run\nStarting program: /hacking/a.out\n\nBreakpoint 1, main() at firstprog.c:6\n6               for(i=0; i < 10; i++)\n(gdb) info register eip\neip            0x8048394        0x8048394\n(gdb)\n```", "```\ngdb) i r eip\neip            0x8048384        0x8048384 <main+16>\n(gdb) x/o 0x8048384\n0x8048384 <main+16>:    077042707\n(gdb) x/x $eip\n0x8048384 <main+16>:    0x00fc45c7\n(gdb) x/u $eip\n0x8048384 <main+16>:    16532935\n(gdb) x/t $eip\n0x8048384 <main+16>:    00000000111111000100010111000111\n(gdb)\n```", "```\n(gdb) x/2x $eip\n0x8048384 <main+16>:    0x00fc45c7     0x83000000\n(gdb) x/12x $eip\n0x8048384 <main+16>:    0x00fc45c7     0x83000000     0x7e09fc7d     0xc713eb02\n0x8048394 <main+32>:    0x84842404     0x01e80804     0x8dffffff     0x00fffc45\n0x80483a4 <main+48>:    0xc3c9e5eb     0x90909090     0x90909090     0x5de58955\n(gdb)\n```", "```\n(gdb) x/8xb $eip\n0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00    0x00    0x00    0x00    0x83\n(gdb) x/8xh $eip\n0x8048384 <main+16>:    0x45c7  0x00fc  0x0000  0x8300  0xfc7d  0x7e09  0xeb02  0xc713\n(gdb) x/8xw $eip\n0x8048384 <main+16>:    0x00fc45c7      0x83000000      0x7e09fc7d      0xc713eb02\n0x8048394 <main+32>:    0x84842404      0x01e80804      0x8dffffff      0x00fffc45 \n(gdb)\n```", "```\n(gdb) x/4xb $eip\n0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00\n(gdb) x/4ub $eip\n0x8048384 <main+16>:    199     69      252     0\n(gdb) x/1xw $eip\n0x8048384 <main+16>:    0x00fc45c7\n(gdb) x/1uw $eip\n0x8048384 <main+16>:    16532935\n(gdb) quit\nThe program is running.  Exit anyway? (y or n) y\nreader@hacking:~/booksrc $ bc -ql\n199*(256^3) + 69*(256^2) + 252*(256^1) + 0*(256^0)\n3343252480\n0*(256^3) + 252*(256^2) + 69*(256^1) + 199*(256^0)\n16532935\nquit\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x8048384: file firstprog.c, line 6.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\n\nBreakpoint 1, main () at firstprog.c:6\n6         for(i=0; i < 10; i++)\n(gdb) i r $eip\neip            0x8048384        0x8048384 <main+16>\n(gdb) x/i $eip\n0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0\n(gdb) x/3i $eip\n0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0\n0x804838b <main+23>:    cmp    DWORD PTR [ebp-4],0x9\n0x804838f <main+27>:    jle    0x8048393 <main+31>\n(gdb) x/7xb $eip\n0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00    0x00    0x00    0x00\n(gdb) x/i $eip\n0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0\n(gdb)\n```", "```\n\t8048384:      c7 45 fc 00 00 00 00   mov   DWORD PTR [ebp-4],0x0\n```", "```\n(gdb) i r ebp\nebp            0xbffff808       0xbffff808\n(gdb) x/4xb $ebp - 4\n0xbffff804:     0xc0    0x83    0x04    0x08\n(gdb) x/4xb 0xbffff804\n0xbffff804:     0xc0    0x83    0x04    0x08\n(gdb) print $ebp - 4\n$1 = (void *) 0xbffff804\n(gdb) x/4xb $1\n0xbffff804:     0xc0    0x83    0x04    0x08\n(gdb) x/xw $1\n0xbffff804:     0x080483c0\n(gdb\n```", "```\n(gdb) nexti\n0x0804838b      6        for(i=0; i < 10; i++)\n(gdb) x/4xb $1\n0xbffff804:     0x00   0x00    0x00    0x00\n(gdb) x/dw $1\n0xbffff804:     0\n(gdb) i r eip\neip            0x804838b       0x804838b <main+23>\n(gdb) x/i $eip\n0x804838b <main+23>:    cmp   DWORD PTR [ebp-4],0x9\n(gdb)\n```", "```\n(gdb) x/10i $eip\n0x804838b <ma in+23>:   cmp   DWORD PTR [ebp-4],0x9\n0x804838f <main+27>:   jle   0x8048393 <main+31>\n0x8048391 <main+29>:   jmp   0x80483a6 <main+50>\n`0x8048393 <main+31>:   mov   DWORD PTR [esp],0x8048484`\n0x804839a <main+38>:   call  0x80482a0 <printf@plt>\n0x804839f <main+43>:   lea   eax,[ebp-4]\n0x80483a2 <main+46>:   inc   DWORD PTR [eax]\n0x80483a4 <main+48>:   jmp   0x804838b <main+23>\n0x80483a6 *`<main+50>:   leave`*\n0x80483a7 <main+51>:   ret\n(gdb)\n```", "```\n(gdb) nexti\n0x0804838f      6          for(i=0; i < 10; i++)\n(gdb) x/i $eip\n0x804838f <main+27>:     jle    0x8048393 <main+31>\n(gdb) nexti\n8            printf(\"Hello, world!\\n\");\n(gdb) i r eip\neip            0x8048393        0x8048393 <main+31>\n(gdb) x/2i $eip\n0x8048393 <main+31>:    mov    DWORD PTR [esp],0x8048484\n0x804839a <main+38>:    call   0x80482a0 <printf@plt>\n(gdb)\n```", "```\n\t(gdb) i r esp\n\tesp           0xbffff800       0xbffff800\n\t(gdb)\n```", "```\n\t(gdb) x/2xw 0x8048484\n\t0x8048484:      0x6c6c6548      0x6f57206f\n\t(gdb) x/6xb 0x8048484\n\t0x8048484:      0x48    0x65    0x6c   0x6c   0x6f   0x20\n\t(gdb) x/6ub 0x8048484\n\t0x8048484:      72      101     108    108    111 32\n\t(gdb)\n```", "```\n\tOct   Dec   Hex   Char           Oct   Dec   Hex   Char\n\t------------------------------------------------------------\n\t000   0     00    NUL '\\0'       100   64    40    @\n\t001   1     01    SOH            101   65    41    A\n\t002   2     02    STX            102   66    42    B\n\t003   3     03    ETX            103   67    43    C\n\t004   4     04    EOT            104   68    44    D\n\t005   5     05    ENQ            105   69    45    E\n\t006   6     06    ACK            106   70    46    F\n\t007   7     07    BEL '\\a'       107   71    47    G\n\t010   8     08    BS  '\\b'       `110   72    48    H`\n\t011   9     09    HT  '\\t'       111   73    49    I\n\t012   10    0A    LF  '\\n'       112   74    4A    J\n\t013   11    0B    VT  '\\v'       113   75    4B    K\n\t014   12    0C    FF  '\\f'       114   76    4C    L\n\t015   13    0D    CR  '\\r'       115   77    4D    M\n\t016   14    0E    SO             116   78    4E    N\n\t017   15    0F    SI             117   79    4F    O\n\t020   16    10    DLE            120   80    50    P\n\t021   17    11    DC1            121   81    51    Q\n\t022   18    12    DC2            122   82    52    R\n\t023   19    13    DC3            123   83    53    S\n\t024   20    14    DC4            124   84    54    T\n\t025   21    15    NAK            125   85    55    U\n\t026   22    16    SYN            126   86    56    V\n\t027   23    17    ETB            127   87    57    W\n\t030   24    18    CAN            130   88    58    X\n\t031   25    19    EM             131   89    59    Y\n\t032   26    1A    SUB            132   90    5A    Z\n\t033   27    1B    ESC            133   91    5B    [\n\t034   28    1C    FS             134   92    5C    \\   '\\\\'\n\t035   29    1D    GS             135   93    5D    ]\n\t036   30    1E    RS             136   94    5E    ^\n\t037   31    1F    US             137   95    5F    _\n\t040   32    20    SPACE          140   96    60    `\n\t041   33    21    !              141   97    61    a\n\t042   34    22    \"              142   98    62    b\n\t043   35    23    #              143   99    63    c\n\t044   36    24    $              144   100   64    d\n\t045   37    25    %              `145   101   65    e`\n\t046   38    26    &              146   102   66    f\n\t047   39    27    '              147   103   67    g\n\t050   40    28    (              150   104   68    h\n\t051   41    29    )              151   105   69    i\n\t052   42    2A    *              152   106   6A    j\n\t053   43    2B    +              153   107   6B    k\n\t054   44    2C    ,              `154  108   6C     l`\n\t055   45    2D    -              155   109   6D    m\n\t056   46    2E    .              156   110   6E    n\n\t057   47    2F    /              `157  111   6F    o`\n\t060   48    30    0              160   112   70    p\n\t061   49    31    1              161   113   71    q\n\t062   50    32    2              162   114   72    r\n\t063   51    33    3              163   115   73    s\n\t064   52    34    4              164   116   74    t\n\t065   53    35    5              165   117   75    u\n\t066   54    36    6              166   118   76    v\n\t067   55    37    7              167   119   77    w\n\t070   56    38    8              170   120   78    x\n\t071   57    39    9              171   121   79    y\n\t072   58    3A    :              172   122   7A    z\n\t073   59    3B    ;              173   123   7B    {\n\t074   60    3C    <              174   124   7C    |\n\t075   61    3D    =              175   125   7D    }\n\t076   62    3E    >              176   126   7E    ~\n\t077   63    3F    ?              177   127   7F    DEL\n```", "```\n(gdb) x/6cb 0x8048484\n0x8048484:      72 'H'  101 'e' 108 'l' 108 'l' 111 'o' 32 ' '\n(gdb) x/s 0x8048484\n0x8048484:       \"Hello, world!\\n\"\n(gdb)\n```", "```\n(gdb) x/2i $eip\n0x8048393 <main+31>:    mov    DWORD PTR [esp],0x8048484\n0x804839a <main+38>:    call   0x80482a0 <printf@plt>\n(gdb) x/xw $esp\n0xbffff800:     0xb8000ce0\n(gdb) nexti\n0x0804839a      8           printf(\"Hello, world!\\n\");\n(gdb) x/xw $esp\n0xbffff800:     0x08048484 \n(gdb)\n```", "```\n(gdb) x/i $eip\n0x804839a <main+38>:    call   0x80482a0 <printf@plt>\n(gdb) nexti\n`Hello, world!`\n6         for(i=0; i < 10; i++)\n(gdb)\n```", "```\n(gdb) x/2i $eip\n0x804839f <main+43>:    lea    eax,[ebp-4]\n0x80483a2 <main+46>:    inc    DWORD PTR [eax]\n(gdb)\n```", "```\n(gdb) x/i $eip\n0x804839f <main+43>:    lea    eax,[ebp-4]\n(gdb) print $ebp - 4\n$2 = (void *) 0xbffff804\n(gdb) x/x $2\n0xbffff804:     0x00000000\n(gdb) i r eax\neax            0xd      13\n(gdb) nexti\n0x080483a2      6         for(i=0; i < 10; i++)\n(gdb) i r eax\neax            0xbffff804       -1073743868\n(gdb) x/xw $eax\n0xbffff804:     0x00000000\n(gdb) x/dw $eax\n0xbffff804:     0\n(gdb)\n```", "```\ngdb) x/i $eip\n0x80483a2 <main+46>:    inc    DWORD PTR [eax]\n(gdb) x/dw $eax\n0xbffff804:     0\n(gdb) nexti\n0x080483a4      6         for(i=0; i < 10; i++)\n(gdb) x/dw $eax\n0xbffff804:     1\n(gdb)\n```", "```\n(gdb) x/i $eip\n0x80483a4 <main+48>:    jmp    0x804838b <main+23> \n(gdb)\n```", "```\n(gdb) disass main\nDump of assembler code for function main:\n0x08048374 <main+0>:    push   ebp\n0x08048375 <main+1>:    mov    ebp,esp\n0x08048377 <main+3>:    sub    esp,0x8\n0x0804837a <main+6>:    and    esp,0xfffffff0\n0x0804837d <main+9>:    mov    eax,0x0\n0x08048382 <main+14>:   sub    esp,eax\n`0x08048384 <main+16>:   mov    DWORD PTR [ebp-4],0x0 0x0804838b <main+23>:   cmp    DWORD PTR [ebp-4],0x9 0x0804838f <main+27>:   jle    0x8048393 <main+31> 0x08048391 <main+29>:   jmp    0x80483a6 <main+50>`\n*`0x08048393 <main+31>:   mov    DWORD PTR [esp],0x8048484 0x0804839a <main+38>:   call   0x80482a0 <printf@plt>`*\n`0x0804839f <main+43>:   lea    eax,[ebp-4] 0x080483a2 <main+46>:   inc    DWORD PTR [eax] 0x080483a4 <main+48>:   jmp    0x804838b <main+23>`\n0x080483a6 <main+50>:   leave\n0x080483a7 <main+51>:   ret\nEnd of assembler dump.\n(gdb) list\n1       #include <stdio.h>\n2\n3       int main()\n4       {\n5         int i;\n`6         for(i=0; i < 10; i++) 7         {`\n8           *`printf(\"Hello, world!\\n\");`*\n`9         }`\n10      } \n(gdb)\n```", "```\n#include <stdio.h>\nint main()\n{\n  char str_a[20];\n  str_a[0]  = 'H';\n  str_a[1]  = 'e';\n  str_a[2]  = 'l';\n  str_a[3]  = 'l';\n  str_a[4]  = 'o';\n  str_a[5]  = ',';\n  str_a[6]  = ' ';\n  str_a[7]  = 'w';\n  str_a[8]  = 'o';\n  str_a[9]  = 'r';\n  str_a[10] = 'l';\n  str_a[11] = 'd';\n  str_a[12] = '!';\n  str_a[13] = '\\n';\n  str_a[14] = 0;\n  printf(str_a);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o char_array char_array.c\nreader@hacking:~/booksrc $ ./char_array\nHello, world!\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n   char str_a[20];\n\n   strcpy(str_a, \"Hello, world!\\n\");\n   printf(str_a); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -g -o char_array2 char_array2.c\nreader@hacking:~/booksrc $ gdb -q ./char_array2\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list\n1       #include <stdio.h>\n2       #include <string.h>\n3\n4       int main() {\n5          char str_a[20];\n`6 7          strcpy(str_a, \"Hello, world!\\n\"); 8          printf(str_a);`\n9       }\n(gdb) break 6\n\nBreakpoint 1 at 0x80483c4: file char_array2.c, line 6.\n(gdb) break strcpy\nFunction \"strcpy\" not defined.\nMake breakpoint pending on future shared library load? (y or [n]) y\nBreakpoint 2 (strcpy) pending.\n(gdb) break 8\nBreakpoint 3 at 0x80483d7: file char_array2.c, line 8\\. \n(gdb)\n```", "```\n(gdb) run\nStarting program: /home/reader/booksrc/char_array2 \nBreakpoint 4 at 0xb7f076f4\nPending breakpoint \"strcpy\" resolved\n\nBreakpoint 1, main () at char_array2.c:7\n7          strcpy(str_a, \"Hello, world!\\n\");\n(gdb) i r eip\neip            0x80483c4        0x80483c4 <main+16>\n(gdb) x/5i $eip\n0x80483c4 <main+16>:    mov    DWORD PTR [esp+4],0x80484c4\n0x80483cc <main+24>:    lea    eax,[ebp-40]\n0x80483cf <main+27>:    mov    DWORD PTR [esp],eax\n0x80483d2 <main+30>:    call   0x80482c4 <strcpy@plt>\n0x80483d7 <main+35>:    lea    eax,[ebp-40]\n(gdb) continue\nContinuing.\n\nBreakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\n(gdb) i r eip\n`eip            0xb7f076f4       0xb7f076f4 <strcpy+4>`\n(gdb) x/5i $eip\n0xb7f076f4 <strcpy+4>:  mov    esi,DWORD PTR [ebp+8]\n0xb7f076f7 <strcpy+7>:  mov    eax,DWORD PTR [ebp+12]\n0xb7f076fa <strcpy+10>: mov    ecx,esi\n0xb7f076fc <strcpy+12>: sub    ecx,eax\n0xb7f076fe <strcpy+14>: mov    edx,eax\n(gdb) continue\nContinuing.\n\nBreakpoint 3, main () at char_array2.c:8\n8          printf(str_a);\n(gdb) i r eip\neip            0x80483d7        0x80483d7 <main+35>\n(gdb) x/5i $eip\n0x80483d7 <main+35>:    lea    eax,[ebp-40]\n0x80483da <main+38>:    mov    DWORD PTR [esp],eax\n0x80483dd <main+41>:    call   0x80482d4 <printf@plt>\n0x80483e2 <main+46>:    leave\n0x80483e3 <main+47>:    ret\n(gdb)\n```", "```\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/char_array2 \nError in re-setting breakpoint 4:\nFunction \"strcpy\" not defined.\n\nBreakpoint 1, main () at char_array2.c:7\n7          strcpy(str_a, \"Hello, world!\\n\");\n(gdb) bt\n#0  main () at char_array2.c:7\n(gdb) cont\nContinuing.\n\nBreakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\n(gdb) bt\n#0  0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\n#1  0x080483d7 in main () at char_array2.c:7\n(gdb) cont\nContinuing.\n\nBreakpoint 3, main () at char_array2.c:8\n8          printf(str_a);\n(gdb) bt\n#0  main () at char_array2.c:8\n(gdb)\n```", "```\nreader@hacking:~/booksrc $ pcalc 0y01001001\n        73              0x49            0y1001001\nreader@hacking:~/booksrc $ pcalc 0y10110110 + 1\n        183             0xb7            0y10110111\nreader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111\n        256             0x100           0y100000000\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   printf(\"The 'int' data type is\\t\\t %d bytes\\n\", sizeof(int));\n   printf(\"The 'unsigned int' data type is\\t %d bytes\\n\", sizeof(unsigned int));\n   printf(\"The 'short int' data type is\\t %d bytes\\n\", sizeof(short int));\n   printf(\"The 'long int' data type is\\t %d bytes\\n\", sizeof(long int));\n   printf(\"The 'long long int' data type is %d bytes\\n\", sizeof(long long int));\n   printf(\"The 'float' data type is\\t %d bytes\\n\", sizeof(float));\n   printf(\"The 'char' data type is\\t\\t %d bytes\\n\", sizeof(char));\n}\n```", "```\nreader@hacking:~/booksrc $ gcc datatype_sizes.c\nreader@hacking:~/booksrc $ ./a.out\nThe 'int' data type is           4 bytes\nThe 'unsigned int' data type is  4 bytes\nThe 'short int' data type is     2 bytes\nThe 'long int' data type is      4 bytes\nThe 'long long int' data type is 8 bytes\nThe 'float' data type is         4 bytes\nThe 'char' data type is          1 bytes\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n   char str_a[20]; // A 20-element character array\n   char *pointer;  // A pointer, meant for a character array\n   char *pointer2; // And yet another one\n\n   strcpy(str_a, \"Hello, world!\\n\");\n   pointer = str_a; // Set the first pointer to the start of the array.\n   printf(pointer);\n\n   pointer2 = pointer + 2; // Set the second one 2 bytes further in.\n   printf(pointer2);       // Print it.\n   strcpy(pointer2, \"y you guys!\\n\"); // Copy into that spot.\n   printf(pointer);        // Print again.\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o pointer pointer.c\nreader@hacking:~/booksrc $ ./pointer\nHello, world!\nllo, world!\nHey you guys!\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gcc -g -o pointer pointer.c\nreader@hacking:~/booksrc $ gdb -q ./pointer\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list\n1       #include <stdio.h>\n2       #include <string.h>\n3\n4       int main()  {\n5           char str_a[20]; // A 20-element character array\n6           char *pointer;  // A pointer, meant for a character array\n7           char *pointer2; // And yet another one\n8\n9           strcpy(str_a, \"Hello, world!\\n\");\n10          pointer = str_a; // Set the first pointer to the start of the array.\n(gdb)\n11          printf(pointer);\n12\n13          pointer2 = pointer + 2; // Set the second one 2 bytes further in.\n14          printf(pointer2); // Print it.\n15          strcpy(pointer2, \"y you guys!\\n\"); // Copy into that spot.\n16          printf(pointer); // Print again.\n17      }\n(gdb) break 11\nBreakpoint 1 at 0x80483dd: file pointer.c, line 11.\n(gdb) run\nStarting program: /home/reader/booksrc/pointer\n\nBreakpoint 1, main () at pointer.c:11\n11         printf(pointer);\n(gdb) x/xw pointer\n0xbffff7e0:     0x6c6c6548\n(gdb) x/s pointer\n0xbffff7e0:      \"Hello, world!\\n\"\n(gdb)\n```", "```\n(gdb) x/xw &pointer\n0xbffff7dc:     0xbffff7e0\n(gdb) print &pointer\n$1 = (char **) 0xbffff7dc\n(gdb) print pointer\n$2 = 0xbffff7e0 \"Hello, world!\\n\"\n(gdb)\n```", "```\n#include <stdio.h>\n\nint main() {\n   int int_var = 5;\n   int *int_ptr;\n\n`int_ptr = &int_var; // put the address of int_var into int_ptr`\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -g addressof.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list\n1       #include <stdio.h>\n2\n3       int main() {\n4               int int_var = 5;\n5               int *int_ptr;\n6\n7               int_ptr = &int_var; // Put the address of int_var into int_ptr.\n8       }\n(gdb) break 8\nBreakpoint 1 at 0x8048361: file addressof.c, line 8.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\n\nBreakpoint 1, main () at addressof.c:8\n8       }\n(gdb) print int_var\n$1 = 5\n(gdb) print &int_var\n$2 = (int *) 0xbffff804\n(gdb) print int_ptr\n$3 = (int *) 0xbffff804\n(gdb) print &int_ptr\n$4 = (int **) 0xbffff800\n(gdb)\n```", "```\n(gdb) print *int_ptr\n$5 = 5\n```", "```\n#include <stdio.h>\n\nint main() {\n   int int_var = 5;\n   int *int_ptr;\n\n   int_ptr = &int_var; // Put the address of int_var into int_ptr.\n\n   printf(\"int_ptr = 0x%08x\\n\", int_ptr);\n   printf(\"&int_ptr = 0x%08x\\n\", &int_ptr);\n   printf(\"*int_ptr = 0x%08x\\n\\n\", *int_ptr);\n\n   printf(\"int_var is located at 0x%08x and contains %d\\n\", &int_var, int_var);\n   printf(\"int_ptr is located at 0x%08x, contains 0x%08x, and points to %d\\n\\n\",\n      &int_ptr, int_ptr, *int_ptr);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc addressof2.c\nreader@hacking:~/booksrc $ ./a.out\nint_ptr = 0xbffff834\n&int_ptr = 0xbffff830\n*int_ptr = 0x00000005\n\nint_var is located at 0xbffff834 and contains 5\nint_ptr is located at 0xbffff830, contains 0xbffff834, and points to 5\n\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   char string[10];\n   int A = -73;\n   unsigned int B = 31337;\n\n   strcpy(string, \"sample\");\n   // Example of printing with different format string\n   printf(\"[A] Dec: %d, Hex: %x, Unsigned: %u\\n\", A, A, A);\n   printf(\"[B] Dec: %d, Hex: %x, Unsigned: %u\\n\", B, B, B);\n   printf(\"[field width on B] 3: '%3u', 10: '%10u', '%08u'\\n\", B, B, B);\n   printf(\"[string] %s Address %08x\\n\", string, string);\n\n   // Example of unary address operator (dereferencing) and a %x format string\n   printf(\"variable A is at address: %08x\\n\", &A);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o fmt_strings fmt_strings.c\nreader@hacking:~/booksrc $ ./fmt_strings\n[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223\n[B] Dec: 31337, Hex: 7a69, Unsigned: 31337\n[field width on B] 3: '31337', 10: '     31337', '00031337'\n[string] sample Address  bffff870\nvariable A is at address: bffff86c\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n   char message[10];\n   int count, i;\n\n   strcpy(message, \"Hello, world!\");\n\n   printf(\"Repeat how many times? \");\n   scanf(\"%d\", &count);\n\n   for(i=0; i < count; i++)\n      printf(\"%3d - %s\\n\", i, message);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o input input.c\nreader@hacking:~/booksrc $ ./input\nRepeat how many times? 3\n  0 - Hello, world!\n  1 - Hello, world!\n  2 - Hello, world!\nreader@hacking:~/booksrc $ ./input\nRepeat how many times? 12\n  0 - Hello, world!\n  1 - Hello, world!\n  2 - Hello, world!\n  3 - Hello, world!\n  4 - Hello, world!\n  5 - Hello, world!\n  6 - Hello, world!\n  7 - Hello, world!\n  8 - Hello, world!\n  9 - Hello, world!\n 10 - Hello, world!\n 11 - Hello, world!\nreader@hacking:~/booksrc $\n```", "```\n(typecast_data_type) variable\n```", "```\n#include <stdio.h>\n\nint main() {\n   int a, b;\n   float c, d;\n\n   a = 13;\n   b = 5;\n\n   c = a / b;                 // Divide using integers.\n   d = (float) a / (float) b; // Divide integers typecast as floats.\n\n   printf(\"[integers]\\t a = %d\\t b = %d\\n\", a, b);\n   printf(\"[floats]\\t c = %f\\t d = %f\\n\", c, d);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc typecasting.c\nreader@hacking:~/booksrc $ ./a.out\n[integers]       a = 13 b = 5\n[floats]         c = 2.000000    d = 2.600000\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   int i;\n\n   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};\n   int int_array[5] = {1, 2, 3, 4, 5};\n\n   char *char_pointer;\n   int *int_pointer;\n\n   char_pointer = char_array;\n   int_pointer = int_array;\n\n   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\n      printf(\"[integer pointer] points to %p, which contains the integer %d\\n\",\n            int_pointer, *int_pointer);\n      int_pointer = int_pointer + 1;\n   }\n\n   for(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\n      printf(\"[char pointer] points to %p, which contains the char '%c'\\n\",\n            char_pointer, *char_pointer);\n      char_pointer = char_pointer + 1;\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc pointer_types.c\nreader@hacking:~/booksrc $ ./a.out\n[integer pointer] points to 0xbffff7f0, which contains the integer 1\n[integer pointer] points to 0xbffff7f4, which contains the integer 2\n[integer pointer] points to 0xbffff7f8, which contains the integer 3\n[integer pointer] points to 0xbffff7fc, which contains the integer 4\n[integer pointer] points to 0xbffff800, which contains the integer 5\n[char pointer] points to 0xbffff810, which contains the char 'a'\n[char pointer] points to 0xbffff811, which contains the char 'b'\n[char pointer] points to 0xbffff812, which contains the char 'c'\n[char pointer] points to 0xbffff813, which contains the char 'd'\n[char pointer] points to 0xbffff814, which contains the char 'e'\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   int i;\n\n   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};\n   int int_array[5] = {1, 2, 3, 4, 5};\n\n   char *char_pointer;\n   int *int_pointer;\n\n   `char_pointer = int_array; // The char_pointer and int_pointer now    int_pointer = char_array; // point to incompatible data types.`\n\n   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\n      printf(\"[integer pointer] points to %p, which contains the char '%c'\\n\",\n            int_pointer, *int_pointer);\n      int_pointer = int_pointer + 1;\n   }\n\n   for(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\n      printf(\"[char pointer] points to %p, which contains the integer %d\\n\",\n            char_pointer, *char_pointer);\n      char_pointer = char_pointer + 1;\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc pointer_types2.c\npointer_types2.c: In function `main':\npointer_types2.c:12: warning: assignment from incompatible pointer type\npointer_types2.c:13: warning: assignment from incompatible pointer type\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./a.out\n[integer pointer] points to 0xbffff810, which contains the char 'a'\n[integer pointer] points to 0xbffff814, which contains the char 'e'\n[integer pointer] points to 0xbffff818, which contains the char '8'\n[integer pointer] points to 0xbffff81c, which contains the char '\n[integer pointer] points to 0xbffff820, which contains the char '?'\n[char pointer] points to 0xbffff7f0, which contains the integer 1\n[char pointer] points to 0xbffff7f1, which contains the integer 0\n[char pointer] points to 0xbffff7f2, which contains the integer 0\n[char pointer] points to 0xbffff7f3, which contains the integer 0\n[char pointer] points to 0xbffff7f4, which contains the integer 2\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   int i;\n\n   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};\n   int int_array[5] = {1, 2, 3, 4, 5};\n\n   char *char_pointer;\n   int *int_pointer;\n\n   char_pointer = (char *) int_array; // Typecast into the\n   int_pointer = (int *) char_array;  // pointer's data type.\n\n   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\n      printf(\"[integer pointer] points to %p, which contains the char '%c'\\n\",\n            int_pointer, *int_pointer);\n      `int_pointer = (int *) ((char *) int_pointer + 1);`\n   }\n\n   for(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\n      printf(\"[char pointer] points to %p, which contains the integer %d\\n\",\n            char_pointer, *char_pointer);\n      `char_pointer = (char *) ((int *) char_pointer + 1);`\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc pointer_types3.c\nreader@hacking:~/booksrc $ ./a.out\n[integer pointer] points to 0xbffff810, which contains the char 'a'\n[integer pointer] points to 0xbffff811, which contains the char 'b'\n[integer pointer] points to 0xbffff812, which contains the char 'c'\n[integer pointer] points to 0xbffff813, which contains the char 'd'\n[integer pointer] points to 0xbffff814, which contains the char 'e'\n[char pointer] points to 0xbffff7f0, which contains the integer 1\n[char pointer] points to 0xbffff7f4, which contains the integer 2\n[char pointer] points to 0xbffff7f8, which contains the integer 3\n[char pointer] points to 0xbffff7fc, which contains the integer 4\n[char pointer] points to 0xbffff800, which contains the integer 5\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   int i;\n\n   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};\n   int int_array[5] = {1, 2, 3, 4, 5};\n\n   void *void_pointer;\n\n   void_pointer = (void *) char_array;\n\n   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\n      printf(\"[char pointer] points to %p, which contains the char '%c'\\n\",\n            void_pointer, *((char *) void_pointer));\n      void_pointer = (void *) ((char *) void_pointer + 1);\n   }\n\n   void_pointer = (void *) int_array;\n\n   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\n      printf(\"[integer pointer] points to %p, which contains the integer %d\\n\",\n            void_pointer, *((int *) void_pointer));\n      void_pointer = (void *) ((int *) void_pointer + 1);\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc pointer_types4.c\nreader@hacking:~/booksrc $ ./a.out\n[char pointer] points to 0xbffff810, which contains the char 'a'\n[char pointer] points to 0xbffff811, which contains the char 'b'\n[char pointer] points to 0xbffff812, which contains the char 'c'\n[char pointer] points to 0xbffff813, which contains the char 'd'\n[char pointer] points to 0xbffff814, which contains the char 'e'\n[integer pointer] points to 0xbffff7f0, which contains the integer 1\n[integer pointer] points to 0xbffff7f4, which contains the integer 2\n[integer pointer] points to 0xbffff7f8, which contains the integer 3\n[integer pointer] points to 0xbffff7fc, which contains the integer 4\n[integer pointer] points to 0xbffff800, which contains the integer 5\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   int i;\n\n   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};\n   int int_array[5] = {1, 2, 3, 4, 5};\n\n   unsigned int hacky_nonpointer;\n\n   hacky_nonpointer = (unsigned int) char_array;\n\n   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\n      printf(\"[hacky_nonpointer] points to %p, which contains the char '%c'\\n\",\n            hacky_nonpointer, *((char *) hacky_nonpointer));\n      `hacky_nonpointer = hacky_nonpointer + sizeof(char);`\n   }\n\n   hacky_nonpointer = (unsigned int) int_array;\n\n   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\n      printf(\"[hacky_nonpointer] points to %p, which contains the integer %d\\n\",\n            hacky_nonpointer, *((int *) hacky_nonpointer));\n      `hacky_nonpointer = hacky_nonpointer + sizeof(int);`\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc pointer_types5.c\nreader@hacking:~/booksrc $ ./a.out\n[hacky_nonpointer] points to 0xbffff810, which contains the char 'a'\n[hacky_nonpointer] points to 0xbffff811, which contains the char 'b'\n[hacky_nonpointer] points to 0xbffff812, which contains the char 'c'\n[hacky_nonpointer] points to 0xbffff813, which contains the char 'd'\n[hacky_nonpointer] points to 0xbffff814, which contains the char 'e'\n[hacky_nonpointer] points to 0xbffff7f0, which contains the integer 1\n[hacky_nonpointer] points to 0xbffff7f4, which contains the integer 2\n[hacky_nonpointer] points to 0xbffff7f8, which contains the integer 3\n[hacky_nonpointer] points to 0xbffff7fc, which contains the integer 4\n[hacky_nonpointer] points to 0xbffff800, which contains the integer 5\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main(int arg_count, char *arg_list[]) {\n   int i;\n   printf(\"There were %d arguments provided:\\n\", arg_count);\n   for(i=0; i < arg_count; i++)\n      printf(\"argument #%d\\t-\\t%s\\n\", i, arg_list[i]);\n}\nreader@hacking:~/booksrc $ gcc -o commandline commandline.c\nreader@hacking:~/booksrc $ ./commandline\nThere were 1 arguments provided:\nargument #0     -       ./commandline\nreader@hacking:~/booksrc $ ./commandline this is a test\nThere were 5 arguments provided:\nargument #0     -       ./commandline\nargument #1     -       this\nargument #2     -       is\nargument #3     -       a\nargument #4     -       test\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nvoid usage(char *program_name) {\n   printf(\"Usage: %s <message> <# of times to repeat>\\n\", program_name);\n   exit(1);\n}\n\nint main(int argc, char *argv[]) {\n   int i, count;\n\n   if(argc < 3)      // If fewer than 3 arguments are used,\n      usage(argv[0]); // display usage message and exit.\n\n   count = atoi(argv[2]); // Convert the 2nd arg into an integer.\n   printf(\"Repeating %d times..\\n\", count);\n\n   for(i=0; i < count; i++)\n      printf(\"%3d - %s\\n\", i, argv[1]); // Print the 1st arg.\n}\n```", "```\nreader@hacking:~/booksrc $ gcc convert.c\nreader@hacking:~/booksrc $ ./a.out\nUsage: ./a.out <message> <# of times to repeat>\nreader@hacking:~/booksrc $ ./a.out 'Hello, world!' 3\nRepeating 3 times..\n  0 - Hello, world!\n  1 - Hello, world!\n  2 - Hello, world!\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nvoid usage(char *program_name) {\n   printf(\"Usage: %s <message> <# of times to repeat>\\n\", program_name);\n   exit(1);\n}\n\nint main(int argc, char *argv[]) {\n   int i, count;\n\n//  if(argc < 3)      // If fewer than 3 arguments are used,\n//    usage(argv[0]); // display usage message and exit.\n\n   count = atoi(argv[2]); // Convert the 2nd arg into an integer.\n   printf(\"Repeating %d times..\\n\", count);\n\n   for(i=0; i < count; i++)\n      printf(\"%3d - %s\\n\", i, argv[1]); // Print the 1st arg.\n}\n```", "```\nreader@hacking:~/booksrc $ gcc convert2.c\nreader@hacking:~/booksrc $ ./a.out test\nSegmentation fault (core dumped)\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gcc -g convert2.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) run test\nStarting program: /home/reader/booksrc/a.out test\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n(gdb) where\n#0  0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n#1  0xb800183c in ?? ()\n#2  0x00000000 in ?? ()\n(gdb) break main\nBreakpoint 1 at 0x8048419: file convert2.c, line 14.\n(gdb) run test\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/a.out test\n\nBreakpoint 1, main (argc=2, argv=`0xbffff894`) at convert2.c:14\n14         count = atoi(argv[2]); // convert the 2nd arg into an integer\n(gdb) cont\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n(gdb) x/3xw 0xbffff894\n0xbffff894:     0xbffff9b3      0xbffff9ce      0x00000000\n(gdb) x/s 0xbffff9b3\n0xbffff9b3:      \"/home/reader/booksrc/a.out\"\n(gdb) x/s 0xbffff9ce\n0xbffff9ce:      \"test\"\n(gdb) x/s 0x00000000\n0x0:     <Address 0x0 out of bounds>\n(gdb) quit\nThe program is running.  Exit anyway? (y or n) y\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nvoid func3() {\n   int i = 11;\n   printf(\"\\t\\t\\t[in func3] i = %d\\n\", i);\n}\n\nvoid func2() {\n   int i = 7;\n   printf(\"\\t\\t[in func2] i = %d\\n\", i);\n   func3();\n   printf(\"\\t\\t[back in func2] i = %d\\n\", i);\n}\n\nvoid func1() {\n   int i = 5;\n   printf(\"\\t[in func1] i = %d\\n\", i);\n   func2();\n   printf(\"\\t[back in func1] i = %d\\n\", i);\n}\n\nint main() {\n   int i = 3;\n   printf(\"[in main] i = %d\\n\", i);\n   func1();\n   printf(\"[back in main] i = %d\\n\", i);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc scope.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] i = 3\n        [in func1] i = 5\n                [in func2] i = 7\n                        [in func3] i = 11\n                [back in func2] i = 7\n        [back in func1] i = 5\n[back in main] i = 3\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint j = 42; // j is a global variable.\n\nvoid func3() {\n   int i = 11, j = 999; // Here, j is a local variable of func3().\n   printf(\"\\t\\t\\t[in func3] i = %d, j = %d\\n\", i, j);\n}\n\nvoid func2() {\n   int i = 7;\n   printf(\"\\t\\t[in func2] i = %d, j = %d\\n\", i, j);\n   printf(\"\\t\\t[in func2] setting j = 1337\\n\");\n   j = 1337; // Writing to j\n   func3();\n   printf(\"\\t\\t[back in func2] i = %d, j = %d\\n\", i, j);\n}\n\nvoid func1() {\n   int i = 5;\n   printf(\"\\t[in func1] i = %d, j = %d\\n\", i, j);\n   func2();\n   printf(\"\\t[back in func1] i = %d, j = %d\\n\", i, j);\n}\n\nint main() {\n   int i = 3;\n   printf(\"[in main] i = %d, j = %d\\n\", i, j);\n   func1();\n   printf(\"[back in main] i = %d, j = %d\\n\", i, j);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc scope2.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] i = 3, j = 42\n        [in func1] i = 5, j = 42\n                [in func2] i = 7, j = 42\n                [in func2] setting j = 1337\n                        [in func3] i = 11, j = 999\n                [back in func2] i = 7, j = 1337\n        [back in func1] i = 5, j = 1337\n[back in main] i = 3, j = 1337 \nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint j = 42; // j is a global variable.\n\nvoid func3() {\n   int i = 11, j = 999; // Here, j is a local variable of func3().\n   printf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\n   printf(\"\\t\\t\\t[in func3] j @ 0x%08x = %d\\n\", &j, j);\n}\n\nvoid func2() {\n   int i = 7;\n   printf(\"\\t\\t[in func2] i @ 0x%08x = %d\\n\", &i, i);\n   printf(\"\\t\\t[in func2] j @ 0x%08x = %d\\n\", &j, j);\n   printf(\"\\t\\t[in func2] setting j = 1337\\n\");\n   j = 1337; // Writing to j\n   func3();\n   printf(\"\\t\\t[back in func2] i @ 0x%08x = %d\\n\", &i, i);\n   printf(\"\\t\\t[back in func2] j @ 0x%08x = %d\\n\", &j, j);\n}\n\nvoid func1() {\n   int i = 5;\n   printf(\"\\t[in func1] i @ 0x%08x = %d\\n\", &i, i);\n   printf(\"\\t[in func1] j @ 0x%08x = %d\\n\", &j, j);\n   func2();\n   printf(\"\\t[back in func1] i @ 0x%08x = %d\\n\", &i, i);\n   printf(\"\\t[back in func1] j @ 0x%08x = %d\\n\", &j, j);\n}\n\nint main() {\n   int i = 3;\n   printf(\"[in main] i @ 0x%08x = %d\\n\", &i, i);\n   printf(\"[in main] j @ 0x%08x = %d\\n\", &j, j);\n   func1();\n   printf(\"[back in main] i @ 0x%08x = %d\\n\", &i, i);\n   printf(\"[back in main] j @ 0x%08x = %d\\n\", &j, j);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc scope3.c \nreader@hacking:~/booksrc $ ./a.out\n[in main] i @ 0xbffff834 = 3\n[in main] j @ 0x08049988 = 42\n        [in func1] i @ 0xbffff814 = 5\n        [in func1] j @ 0x08049988 = 42\n                [in func2] i @ 0xbffff7f4 = 7\n                [in func2] j @ 0x08049988 = 42\n                [in func2] setting j = 1337\n                        [in func3] i @ 0xbffff7d4 = 11\n                        [in func3] j @ 0xbffff7d0 = 999\n                [back in func2] i @ 0xbffff7f4 = 7\n                [back in func2] j @ 0x08049988 = 1337\n        [back in func1] i @ 0xbffff814 = 5\n        [back in func1] j @ 0x08049988 = 1337\n[back in main] i @ 0xbffff834 = 3\n[back in main] j @ 0x08049988 = 1337\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gcc -g scope3.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 1\n1       #include <stdio.h>\n2\n3       int j = 42; // j is a global variable.\n4\n5       void func3() {\n6          int i = 11, j = 999; // Here, j is a local variable of func3().\n7          printf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\n8          printf(\"\\t\\t\\t[in func3] j @ 0x%08x = %d\\n\", &j, j);\n9       }\n10\n(gdb) break 7\nBreakpoint 1 at 0x8048388: file scope3.c, line 7.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\n[in main] i @ 0xbffff804 = 3\n[in main] j @ 0x08049988 = 42\n        [in func1] i @ 0xbffff7e4 = 5\n        [in func1] j @ 0x08049988 = 42\n                [in func2] i @ 0xbffff7c4 = 7\n                [in func2] j @ 0x08049988 = 42\n                [in func2] setting j = 1337\n\nBreakpoint 1, func3 () at scope3.c:7\n7          printf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\n(gdb) bt\n#0  func3 () at scope3.c:7\n#1  0x0804841d in func2 () at scope3.c:17\n#2  0x0804849f in func1 () at scope3.c:26\n#3  0x0804852b in main () at scope3.c:35\n(gdb)\n```", "```\n(gdb) bt full\n#0  func3 () at scope3.c:7\n        i = 11\n        j = 999\n#1  0x0804841d in func2 () at scope3.c:17\n        i = 7\n#2  0x0804849f in func1 () at scope3.c:26\n        i = 5\n#3  0x0804852b in main () at scope3.c:35\n        i = 3\n(gdb)\n```", "```\n#include <stdio.h>\n\nvoid function() { // An example function, with its own context\n   int var = 5;\n   static int static_var = 5; // Static variable initialization\n\n   printf(\"\\t[in function] var = %d\\n\", var);\n   printf(\"\\t[in function] static_var = %d\\n\", static_var);\n   var++;          // Add one to var.\n   static_var++;   // Add one to static_var.\n}\n\nint main() { // The main function, with its own context\n   int i;\n   static int static_var = 1337; // Another static, in a different context\n\n   for(i=0; i < 5; i++) { // Loop 5 times.\n      printf(\"[in main] static_var = %d\\n\", static_var);\n      function(); // Call the function.\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc static.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] static_var = 1337\n        [in function] var = 5\n        [in function] static_var = 5\n[in main] static_var = 1337\n        [in function] var = 5\n        [in function] static_var = 6\n[in main] static_var = 1337\n        [in function] var = 5\n        [in function] static_var = 7\n[in main] static_var = 1337\n        [in function] var = 5\n        [in function] static_var = 8\n[in main] static_var = 1337\n        [in function] var = 5\n        [in function] static_var = 9\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nvoid function() { // An example function, with its own context\n   int var = 5;\n   static int static_var = 5; // Static variable initialization\n\n   printf(\"\\t[in function] var  @ %p = %d\\n\", &var, var);\n   printf(\"\\t[in function] static_var @ %p = %d\\n\", &static_var, static_var);\n   var++;          // Add 1 to var.\n   static_var++;   // Add 1 to static_var.\n}\n\nint main() { // The main function, with its own context\n   int i;\n   static int static_var = 1337; // Another static, in a different context\n\n   for(i=0; i < 5; i++) { // loop 5 times\n      printf(\"[in main] static_var @ %p = %d\\n\", &static_var, static_var);\n      function(); // Call the function.\n   } \n}\n```", "```\nreader@hacking:~/booksrc $ gcc static2.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] static_var @ 0x804968c = 1337\n        [in function] var  @ 0xbffff814 = 5\n        [in function] static_var @ 0x8049688 = 5\n[in main] static_var @ 0x804968c = 1337\n        [in function] var  @ 0xbffff814 = 5\n        [in function] static_var @ 0x8049688 = 6\n[in main] static_var @ 0x804968c = 1337\n        [in function] var  @ 0xbffff814 = 5\n        [in function] static_var @ 0x8049688 = 7\n[in main] static_var @ 0x804968c = 1337\n        [in function] var  @ 0xbffff814 = 5\n        [in function] static_var @ 0x8049688 = 8\n[in main] static_var @ 0x804968c = 1337\n        [in function] var  @ 0xbffff814 = 5\n        [in function] static_var @ 0x8049688 = 9\nreader@hacking:~/booksrc $\n```", "```\nvoid test_function(int a, int b, int c, int d) {\n   int flag;\n   char buffer[10];\n\n   flag = 31337;\n   buffer[0] = 'A';\n}\n\nint main() {\n   test_function(1, 2, 3, 4);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -g stack_example.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main():\n`0x08048357 <main+0>:    push   ebp 0x08048358 <main+1>:    mov    ebp,esp 0x0804835a <main+3>:    sub    esp,0x18 0x0804835d <main+6>:    and    esp,0xfffffff0 0x08048360 <main+9>:    mov    eax,0x0 0x08048365 <main+14>:   sub    esp,eax`\n0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4\n0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3\n0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2\n0x0804837f <main+40>:   mov    DWORD PTR [esp],0x1\n0x08048386 <main+47>:   call   0x8048344 <test_function>\n0x0804838b <main+52>:   leave\n0x0804838c <main+53>:   ret\nEnd of assembler dump\n(gdb) disass test_function()\nDump of assembler code for function test_function:\n`0x08048344 <test_function+0>:   push   ebp 0x08048345 <test_function+1>:   mov    ebp,esp 0x08048347 <test_function+3>:   sub    esp,0x28`\n0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69\n0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41\n0x08048355 <test_function+17>:  leave\n0x08048356 <test_function+18>:  ret\nEnd of assembler dump\n(gdb)\n```", "```\n(gdb) disass main\nDump of assembler code for function main:\n0x08048357 <main+0>:    push   ebp\n0x08048358 <main+1>:    mov    ebp,esp\n0x0804835a <main+3>:    sub    esp,0x18\n0x0804835d <main+6>:    and    esp,0xfffffff0\n0x08048360 <main+9>:    mov    eax,0x0\n0x08048365 <main+14>:   sub    esp,eax\n`0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4 0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3 0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2 0x0804837f <main+40>:   mov    DWORD PTR [esp],0x1`\n0x08048386 <main+47>:   call   0x8048344 <test_function>\n0x0804838b <main+52>:   leave\n0x0804838c <main+53>:   ret\nEnd of assembler dump\n(gdb)\n```", "```\n(gdb) list main\n4\n5          flag = 31337;\n6          buffer[0] = 'A';\n7       }\n8\n9       int main() {\n10         test_function(1, 2, 3, 4);\n11      }\n(gdb) break 10\nBreakpoint 1 at 0x8048367: file stack_example.c, line 10.\n(gdb) break test_function\nBreakpoint 2 at 0x804834a: file stack_example.c, line 5.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\n\nBreakpoint 1, main () at stack_example.c:10\n10         test_function(1, 2, 3, 4);\n(gdb) i r esp ebp eip\nesp            0xbffff7f0       0xbffff7f0\nebp            0xbffff808       0xbffff808\neip            0x8048367        0x8048367 <main+16>\n(gdb) x/5i $eip\n0x8048367 <main+16>:    mov    DWORD PTR [esp+12],0x4\n0x804836f <main+24>:    mov    DWORD PTR [esp+8],0x3\n0x8048377 <main+32>:    mov    DWORD PTR [esp+4],0x2\n0x804837f <main+40>:    mov    DWORD PTR [esp],0x1\n0x8048386 <main+47>:    call   0x8048344 <test_function>\n(gdb)\n```", "```\n(gdb) cont\nContinuing.\n\nBreakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:5\n5          flag = 31337;\n(gdb) i r esp ebp eip\nesp            0xbffff7c0       0xbffff7c0\nebp            0xbffff7e8       0xbffff7e8\neip            0x804834a        0x804834a <test_function+6>\n(gdb) disass test_function\nDump of assembler code for function test_function:\n0x08048344 <test_function+0>:   push   ebp\n0x08048345 <test_function+1>:   mov    ebp,esp\n0x08048347 <test_function+3>:   sub    esp,0x28\n0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69\n0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41\n0x08048355 <test_function+17>:  leave\n0x08048356 <test_function+18>:  ret\nEnd of assembler dump.\n(gdb) print $ebp-12\n$1 = (void *) 0xbffff7dc\n(gdb) print $ebp-40\n$2 = (void *) 0xbffff7c0\n(gdb) x/16xw $esp\n0xbffff7c0:   0x00000000      0x08049548      0xbffff7d8      0x08048249\n0xbffff7d0:     0xb7f9f729      0xb7fd6ff4      0xbffff808      0x080483b9\n0xbffff7e0:     0xb7fd6ff4      0xbffff89c      0xbffff808      0x0804838b\n0xbffff7f0:      `0x00000001      0x00000002      0x00000003      0x00000004`\n(gdb)\n```", "```\n#include <stdio.h>\n\nint global_var;\n\nint global_initialized_var = 5;\n\nvoid function() {  // This is just a demo function.\n   int stack_var; // Notice this variable has the same name as the one in main().\n\n   printf(\"the function's stack_var is at address 0x%08x\\n\", &stack_var);\n}\n\nint main() {\n   int stack_var; // Same name as the variable in function()\n   static int static_initialized_var = 5;\n   static int static_var;\n   int *heap_var_ptr;\n\n   heap_var_ptr = (int *) malloc(4);\n\n   // These variables are in the data segment.\n   printf(\"global_initialized_var is at address 0x%08x\\n\", &global_initialized_var);\n   printf(\"static_initialized_var is at address 0x%08x\\n\\n\", &static_initialized_var);\n\n   // These variables are in the bss segment.\n   printf(\"static_var is at address 0x%08x\\n\", &static_var);\n   printf(\"global_var is at address 0x%08x\\n\\n\", &global_var);\n\n   // This variable is in the heap segment.\n   printf(\"heap_var is at address 0x%08x\\n\\n\", heap_var_ptr);\n\n   // These variables are in the stack segment.\n   printf(\"stack_var is at address 0x%08x\\n\", &stack_var);\n   function(); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc memory_segments.c\nreader@hacking:~/booksrc $ ./a.out \nglobal_initialized_var is at address 0x080497ec\nstatic_initialized_var is at address 0x080497f0\n\nstatic_var is at address 0x080497f8\nglobal_var is at address 0x080497fc\n\nheap_var is at address 0x0804a008\n\nstack_var is at address 0xbffff834\nthe function's stack_var is at address 0xbffff814\nreader@hack ing:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n   char *char_ptr;  // A char pointer\n   int *int_ptr;    // An integer pointer\n   int mem_size;\n\n   if (argc < 2)     // If there aren't command-line arguments,\n      mem_size = 50; // use 50 as the default value.\n   else\n      mem_size = atoi(argv[1]);\n\n   printf(\"\\t[+] allocating %d bytes of memory on the heap for char_ptr\\n\", mem_size);\n   char_ptr = (char *) malloc(mem_size); // Allocating heap memory\n\n   if(char_ptr == NULL) {  // Error checking, in case malloc() fails\n      fprintf(stderr, \"Error: could not allocate heap memory.\\n\");\n      exit(-1);\n   }\n\n   strcpy(char_ptr, \"This is memory is located on the heap.\");\n   printf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\n\n   printf(\"\\t[+] allocating 12 bytes of memory on the heap for int_ptr\\n\");\n   int_ptr = (int *) malloc(12); // Allocated heap memory again\n\n   if(int_ptr == NULL) {  // Error checking, in case malloc() fails\n      fprintf(stderr, \"Error: could not allocate heap memory.\\n\");\n      exit(-1);\n   }\n\n   *int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.\n   printf(\"int_ptr (%p) --> %d\\n\", int_ptr, *int_ptr);\n\n   printf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\n   free(char_ptr); // Freeing heap memory\n\n   printf(\"\\t[+] allocating another 15 bytes for char_ptr\\n\");\n   char_ptr = (char *) malloc(15); // Allocating more heap memory\n\n   if(char_ptr == NULL) {  // Error checking, in case malloc() fails\n      fprintf(stderr, \"Error: could not allocate heap memory.\\n\");\n      exit(-1);\n   }\n\n   strcpy(char_ptr, \"new memory\");\n   printf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\n\n   printf(\"\\t[-] freeing int_ptr's heap memory...\\n\");\n   free(int_ptr); // Freeing heap memory\n   printf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\n   free(char_ptr); // Freeing the other block of heap memory \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o heap_example heap_example.c\nreader@hacking:~/booksrc $ ./heap_example\n        [+] allocating 50 bytes of memory on the heap for char_ptr\nchar_ptr (0x804a008) --> 'This is memory is located on the heap.'\n        [+] allocating 12 bytes of memory on the heap for int_ptr\nint_ptr (0x804a040) --> 31337\n        [-] freeing char_ptr's heap memory...\n        [+] allocating another 15 bytes for char_ptr\nchar_ptr (0x804a050) --> 'new memory'\n        [-] freeing int_ptr's heap memory...\n        [-] freeing char_ptr's heap memory... \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./heap_example 100\n        [+] allocating 100 bytes of memory on the heap for char_ptr\nchar_ptr (0x804a008) --> 'This is memory is located on the heap.'\n        [+] allocating 12 bytes of memory on the heap for int_ptr\nint_ptr (0x804a070) --> 31337\n        [-] freeing char_ptr's heap memory...\n        [+] allocating another 15 bytes for char_ptr\nchar_ptr (0x804a008) --> 'new memory'\n        [-] freeing int_ptr's heap memory...\n        [-] freeing char_ptr's heap memory...\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid *errorchecked_malloc(unsigned int); // Function prototype for errorchecked_malloc()\n\nint main(int argc, char *argv[]) {\n   char *char_ptr;  // A char pointer\n   int *int_ptr;    // An integer pointer\n   int mem_size;\n\n   if (argc < 2)     // If there aren't command-line arguments,\n      mem_size = 50; // use 50 as the default value.\n   else\n      mem_size = atoi(argv[1]);\n\n   printf(\"\\t[+] allocating %d bytes of memory on the heap for char_ptr\\n\", mem_size);\n   char_ptr = (char *) errorchecked_malloc(mem_size); // Allocating heap memory\n\n   strcpy(char_ptr, \"This is memory is located on the heap.\");\n   printf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\n   printf(\"\\t[+] allocating 12 bytes of memory on the heap for int_ptr\\n\");\n   int_ptr = (int *) errorchecked_malloc(12); // Allocated heap memory again\n\n   *int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.\n   printf(\"int_ptr (%p) --> %d\\n\", int_ptr, *int_ptr);\n\n   printf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\n   free(char_ptr); // Freeing heap memory\n\n   printf(\"\\t[+] allocating another 15 bytes for char_ptr\\n\");\n   char_ptr = (char *) errorchecked_malloc(15); // Allocating more heap memory\n\n   strcpy(char_ptr, \"new memory\");\n   printf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\n\n   printf(\"\\t[-] freeing int_ptr's heap memory...\\n\");\n   free(int_ptr); // Freeing heap memory\n   printf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\n   free(char_ptr); // Freeing the other block of heap memory\n}\n\nvoid *errorchecked_malloc(unsigned int size) { // An error-checked malloc() function\n   void *ptr;\n   ptr = malloc(size);\n   if(ptr == NULL) {\n      fprintf(stderr, \"Error: could not allocate heap memory.\\n\");\n      exit(-1);\n   }\n   return ptr; \n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\nvoid usage(char *prog_name, char *filename) {\n   printf(\"Usage: %s <data to add to %s>\\n\", prog_name, filename);\n   exit(0);\n}\n\nvoid fatal(char *);            // A function for fatal errors\nvoid *ec_malloc(unsigned int); // An error-checked malloc() wrapper\n\nint main(int argc, char *argv[]) {\n   int fd; // file descriptor\n   char *buffer, *datafile;\n\n   buffer = (char *) ec_malloc(100);\n   datafile = (char *) ec_malloc(20);\n   strcpy(datafile, \"/tmp/notes\");\n\n   if(argc < 2)                 // If there aren't command-line arguments,\n      usage(argv[0], datafile); // display usage message and exit.\n   strcpy(buffer, argv[1]);     // Copy into buffer.\n\n   printf(\"[DEBUG] buffer   @ %p: \\'%s\\'\\n\", buffer, buffer);\n   printf(\"[DEBUG] data file @ %p: \\'%s\\'\\n\", datafile, datafile);\n\n   strncat(buffer, \"\\n\", 1); // Add a newline on the end.\n\n// Opening file\n   fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\n   if(fd == -1)\n      fatal(\"in main() while opening file\");\n   printf(\"[DEBUG] file descriptor is %d\\n\", fd);\n// Writing data\n   if(write(fd, buffer, strlen(buffer)) == -1)\n      fatal(\"in main() while writing buffer to file\");\n// Closing file\n   if(close(fd) == -1)\n      fatal(\"in main() while closing file\");\n\n   printf(\"Note has been saved.\\n\");\n   free(buffer);\n   free(datafile);\n}\n\n// A function to display an error message and then exit\nvoid fatal(char *message) {\n   char error_message[100];\n\n   strcpy(error_message, \"[!!] Fatal Error \");\n   strncat(error_message, message, 83);\n   perror(error_message);\n   exit(-1);\n}\n\n// An error-checked malloc() wrapper function\nvoid *ec_malloc(unsigned int size) {\n   void *ptr;\n   ptr = malloc(size);\n   if(ptr == NULL)\n      fatal(\"in ec_malloc() on memory allocation\");\n   return ptr; \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o simplenote simplenote.c \nreader@hacking:~/booksrc $ ./simplenote \nUsage: ./simplenote <data to add to /tmp/notes>\nreader@hacking:~/booksrc $ ./simplenote \"this is a test note\"\n[DEBUG] buffer   @ 0x804a008: 'this is a test note'\n[DEBUG] data file @ 0x804a070: '/tmp/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ cat /tmp/notes \nthis is a test note\nreader@hacking:~/booksrc $ ./simplenote \"great, it works\"\n[DEBUG] buffer   @ 0x804a008: 'great, it works'\n[DEBUG] datafile @ 0x804a070: '/tmp/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ cat /tmp/notes \nthis is a test note\ngreat, it works\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   int i, bit_a, bit_b;\n   printf(\"bitwise OR operator  |\\n\");\n   for(i=0; i < 4; i++) {\n      bit_a = (i & 2) / 2; // Get the second bit.\n      bit_b = (i & 1);     // Get the first bit.\n      printf(\"%d | %d = %d\\n\", bit_a, bit_b, bit_a | bit_b);\n   }\n   printf(\"\\nbitwise AND operator  &\\n\");\n   for(i=0; i < 4; i++) {\n      bit_a = (i & 2) / 2; // Get the second bit.\n      bit_b = (i & 1);     // Get the first bit.\n      printf(\"%d & %d = %d\\n\", bit_a, bit_b, bit_a & bit_b);\n   } \n}\n```", "```\nreader@hacking:~/booksrc $ gcc bitwise.c\nreader@hacking:~/booksrc $ ./a.out\nbitwise OR operator  |\n0 | 0 = 0\n0 | 1 = 1\n1 | 0 = 1\n1 | 1 = 1\n\nbitwise AND operator  &\n0 & 0 = 0\n0 & 1 = 0\n1 & 0 = 0\n1 & 1 = 1 \nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <fcntl.h>\n\nvoid display_flags(char *, unsigned int);\nvoid binary_print(unsigned int);\n\nint main(int argc, char *argv[]) {\n   display_flags(\"O_RDONLY\\t\\t\", O_RDONLY);\n   display_flags(\"O_WRONLY\\t\\t\", O_WRONLY);\n   display_flags(\"O_RDWR\\t\\t\\t\", O_RDWR);\n   printf(\"\\n\");\n   display_flags(\"O_APPEND\\t\\t\", O_APPEND);\n   display_flags(\"O_TRUNC\\t\\t\\t\", O_TRUNC);\n   display_flags(\"O_CREAT\\t\\t\\t\", O_CREAT);\n   printf(\"\\n\");\n   display_flags(\"O_WRONLY|O_APPEND|O_CREAT\", O_WRONLY|O_APPEND|O_CREAT);\n}\n\nvoid display_flags(char *label, unsigned int value) {\n   printf(\"%s\\t: %d\\t:\", label, value);\n   binary_print(value);\n   printf(\"\\n\");\n}\n\nvoid binary_print(unsigned int value) {\n   unsigned int mask = 0xff000000; // Start with a mask for the highest byte.\n   unsigned int shift = 256*256*256; // Start with a shift for the highest byte.\n   unsigned int byte, byte_iterator, bit_iterator;\n\n   for(byte_iterator=0; byte_iterator < 4; byte_iterator++) {\n      byte = (value & mask) / shift; // Isolate each byte.\n      printf(\" \");\n      for(bit_iterator=0; bit_iterator < 8; bit_iterator++) { // Print the byte's bits.\n         if(byte & 0x80) // If the highest bit in the byte isn't 0,\n            printf(\"1\");       // print a 1.\n         else\n            printf(\"0\");       // Otherwise, print a 0.\n         byte *= 2;         // Move all the bits to the left by 1.\n      }\n      mask /= 256;       // Move the bits in mask right by 8.\n      shift /= 256;      // Move the bits in shift right by 8.\n   } \n}\n```", "```\nreader@hacking:~/booksrc $ gcc fcntl_flags.c \nreader@hacking:~/booksrc $ ./a.out\nO_RDONLY                        : 0     : 00000000 00000000 00000000 00000000\nO_WRONLY                        : 1     : 00000000 00000000 00000000 00000001\nO_RDWR                          : 2     : 00000000 00000000 00000000 00000010\n\nO_APPEND                        : 1024  : 00000000 00000000 00000100 00000000\nO_TRUNC                         : 512   : 00000000 00000000 00000010 00000000\nO_CREAT                         : 64    : 00000000 00000000 00000000 01000000\n\nO_WRONLY|O_APPEND|O_CREAT       : 1089  : 00000000 00000000 00000100 01000001 \n$\n```", "```\nreader@hacking:~/booksrc $ ls -l /etc/passwd simplenote*\n-rw-r--r-- 1 root   root   1424 2007-09-06 09:45 /etc/passwd\n-rwxr-xr-x 1 reader reader 8457 2007-09-07 02:51 simplenote\n-rw------- 1 reader reader 1872 2007-09-07 02:51 simplenote.c \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ chmod 731 simplenote.c\nreader@hacking:~/booksrc $ ls -l simplenote.c\n-rwx-wx--x 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $ chmod ugo-wx simplenote.c\nreader@hacking:~/booksrc $ ls -l simplenote.c\n-r-------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $ chmod u+w simplenote.c\nreader@hacking:~/booksrc $ ls -l simplenote.c\n-rw------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ls -l /tmp/notes \n-rw------- 1 reader reader 36 2007-09-07 02:52 /tmp/notes \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ id reader\n`uid=999(reader)` gid=999(reader)\ngroups=999(reader),4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),4\n4(video),46(plugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(a\ndmin)\nreader@hacking:~/booksrc $ id matrix\nuid=500(matrix) gid=500(matrix) groups=500(matrix)\nreader@hacking:~/booksrc $ id root\nuid=0(root) gid=0(root) groups=0(root)\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ sudo su jose\njose@hacking:/home/reader/booksrc $ id\nuid=501(jose) gid=501(jose) groups=501(jose)\njose@hacking:/home/reader/booksrc $\n```", "```\njose@hacking:/home/reader/booksrc $ ls -l /tmp/notes\n-rw------- 1 reader reader 36 2007-09-07 05:20 /tmp/notes\njose@hacking:/home/reader/booksrc $ ./simplenote \"a note for jose\"\n[DEBUG] buffer   @ 0x804a008: 'a note for jose'\n[DEBUG] datafile @ 0x804a070: '/tmp/notes'\n[!!] Fatal Error in main() while opening file: Permission denied\njose@hacking:/home/reader/booksrc $ cat /tmp/notes\ncat: /tmp/notes: Permission denied\njose@hacking:/home/reader/booksrc $ exit\nexit\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ which chsh\n/usr/bin/chsh\nreader@hacking:~/booksrc $ ls -l /usr/bin/chsh /etc/passwd\n-rw-r--r-- 1 root root  1424 2007-09-06 21:05 /etc/passwd\n-rwsr-xr-x 1 root root 23920 2006-12-19 20:35 /usr/bin/chsh\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main() {\n   printf(\"real uid: %d\\n\", getuid());\n   printf(\"effective uid: %d\\n\", geteuid()); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o uid_demo uid_demo.c\nreader@hacking:~/booksrc $ ls -l uid_demo\n-rwxr-xr-x 1 reader reader 6825 2007-09-07 05:32 uid_demo\nreader@hacking:~/booksrc $ ./uid_demo\nreal uid: 999\neffective uid: 999\nreader@hacking:~/booksrc $ sudo chown root:root ./uid_demo\nreader@hacking:~/booksrc $ ls -l uid_demo\n-rwxr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo\nreader@hacking:~/booksrc $ ./uid_demo \nreal uid: 999\neffective uid: 999 \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ chmod u+s ./uid_demo\nchmod: changing permissions of `./uid_demo': Operation not permitted\nreader@hacking:~/booksrc $ sudo chmod u+s ./uid_demo\nreader@hacking:~/booksrc $ ls -l uid_demo\n-rwsr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo\nreader@hacking:~/booksrc $ ./uid_demo \nreal uid: 999\neffective uid: 0 \nreader@hacking:~/booksrc $\n```", "```\n// A function to display an error message and then exit\nvoid fatal(char *message) {\n   char error_message[100];\n\n   strcpy(error_message, \"[!!] Fatal Error \");\n   strncat(error_message, message, 83);\n   perror(error_message);\n   exit(-1);\n}\n\n// An error-checked malloc() wrapper function\nvoid *ec_malloc(unsigned int size) {\n   void *ptr;\n   ptr = malloc(size);\n   if(ptr == NULL)\n      fatal(\"in ec_malloc() on memory allocation\");\n   return ptr;\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n`#include \"hacking.h\"`\n\nvoid usage(char *prog_name, char *filename) {\n   printf(\"Usage: %s <data to add to %s>\\n\", prog_name, filename);\n   exit(0);\n}\n\nvoid fatal(char *);            // A function for fatal errors\nvoid *ec_malloc(unsigned int); // An error-checked malloc() wrapper\n\nint main(int argc, char *argv[]) {\n   `int userid, fd; // File descriptor`\n   char *buffer, *datafile;\n\n   buffer = (char *) ec_malloc(100);\n   datafile = (char *) ec_malloc(20);\n   `strcpy(datafile, \"/var/notes\");`\n\n   if(argc < 2)                // If there aren't command-line arguments,\n      usage(argv[0], datafile); // display usage message and exit.\n\n   strcpy(buffer, argv[1]);  // Copy into buffer.\n\n   printf(\"[DEBUG] buffer   @ %p: \\'%s\\'\\n\", buffer, buffer);\n   printf(\"[DEBUG] datafile @ %p: \\'%s\\'\\n\", datafile, datafile);\n\n // Opening the file\n   fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\n   if(fd == -1)\n      fatal(\"in main() while opening file\");\n   printf(\"[DEBUG] file descriptor is %d\\n\", fd);\n\n   `userid = getuid(); // Get the real user ID.`\n\n// Writing data\n   `if(write(fd, &userid, 4) == -1) // Write user ID before note data.       fatal(\"in main() while writing userid to file\");    write(fd, \"\\n\", 1); // Terminate line.     if(write(fd, buffer, strlen(buffer)) == -1) // Write note.       fatal(\"in main() while writing buffer to file\");    write(fd, \"\\n\", 1); // Terminate line.`\n\n// Closing file\n   if(close(fd) == -1)\n      fatal(\"in main() while closing file\");\n\n   printf(\"Note has been saved.\\n\");\n   free(buffer);\n   free(datafile); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o notetaker notetaker.c\nreader@hacking:~/booksrc $ sudo chown root:root ./notetaker\nreader@hacking:~/booksrc $ sudo chmod u+s ./notetaker\nreader@hacking:~/booksrc $ ls -l ./notetaker\n-rwsr-xr-x 1 root root 9015 2007-09-07 05:48 ./notetaker\nreader@hacking:~/booksrc $ ./notetaker \"this is a test of multiuser notes\"\n[DEBUG] buffer   @ 0x804a008: 'this is a test of multiuser notes'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ ls -l /var/notes\n-rw------- 1 root reader 39 2007-09-07 05:49 /var/notes\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ cat /var/notes\ncat: /var/notes: Permission denied\nreader@hacking:~/booksrc $ sudo cat /var/notes\n?\nthis is a test of multiuser notes\nreader@hacking:~/booksrc $ sudo hexdump -C /var/notes\n00000000  `e7 03 00 00` 0a 74 68 69  73 20 69 73 20 61 20 74  |.....this is a t|\n00000010  65 73 74 20 6f 66 20 6d  75 6c 74 69 75 73 65 72  |est of multiuser|\n00000020  20 6e 6f 74 65 73 0a                              | notes.|\n00000027\nreader@hacking:~/booksrc $ pcalc 0x03e7\n        999             0x3e7           0y1111100111\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"hacking.h\"\n#define FILENAME \"/var/notes\"\n\nint print_notes(int, int, char *);   // Note printing function.\nint find_user_note(int, int);        // Seek in file for a note for user.\nint search_note(char *, char *);     // Search for keyword function.\nvoid fatal(char *);                  // Fatal error handler\n\nint main(int argc, char *argv[]) {\n   int userid, printing=1, fd; // File descriptor\n   char searchstring[100];\n\n   if(argc > 1)                        // If there is an arg,\n      strcpy(searchstring, argv[1]);   //   that is the search string;\n   else                                // otherwise,\n      searchstring[0] = 0;             //   search string is empty.\n\n   userid = getuid();\n   fd = open(FILENAME, O_RDONLY);   // Open the file for read-only access.\n   if(fd == -1)\n      fatal(\"in main() while opening file for reading\");\n\n   while(printing)\n      printing = print_notes(fd, userid, searchstring);\n   printf(\"-------[ end of note data ]-------\\n\");\n   close(fd);\n}\n\n// A function to print the notes for a given uid that match\n// an optional search string;\n// returns 0 at end of file, 1 if there are still more notes.\nint print_notes(int fd, int uid, char *searchstring) {\n   int note_length;\n   char byte=0, note_buffer[100];\n\n   note_length = find_user_note(fd, uid);\n   if(note_length == -1)  // If end of file reached,\n      return 0;           //   return 0.\n\n   read(fd, note_buffer, note_length); // Read note data.\n   note_buffer[note_length] = 0;       // Terminate the string.\n\n   if(search_note(note_buffer, searchstring)) // If searchstring found,\n      printf(note_buffer);                    //   print the note.\n   return 1;\n}\n\n// A function to find the next note for a given userID;\n// returns -1 if the end of the file is reached;\n// otherwise, it returns the length of the found note.\nint find_user_note(int fd, int user_uid) {\n   int note_uid=-1;\n   unsigned char byte;\n   int length;\n\n   while(note_uid != user_uid) {  // Loop until a note for user_uid is found.\n\n      if(read(fd, &note_uid, 4) != 4) // Read the uid data.\n         return -1; // If 4 bytes aren't read, return end of file code.\n      if(read(fd, &byte, 1) != 1) // Read the newline separator.\n         return -1;\n\n      byte = length = 0;\n      while(byte != '\\n') {  // Figure out how many bytes to the end of line.\n         if(read(fd, &byte, 1) != 1) // Read a single byte.\n            return -1;     // If byte isn't read, return end of file code.\n         length++;\n      }\n   }\n   lseek(fd, length * -1, SEEK_CUR); // Rewind file reading by length bytes.\n\n   printf(\"[DEBUG] found a %d byte note for user id %d\\n\", length, note_uid);\n   return length;\n}\n\n// A function to search a note for a given keyword;\n// returns 1 if a match is found, 0 if there is no match.\nint search_note(char *note, char *keyword) {\n   int i, keyword_length, match=0;\n\n   keyword_length = strlen(keyword);\n   if(keyword_length == 0)  // If there is no search string,\n      return 1;              // always \"match\".\n\n   for(i=0; i < strlen(note); i++) { // Iterate over bytes in note.\n      if(note[i] == keyword[match])  // If byte matches keyword,\n         match++;   // get ready to check the next byte;\n      else {        //   otherwise,\n         if(note[i] == keyword[0]) // if that byte matches first keyword byte,\n            match = 1;  // start the match count at 1.\n         else\n            match = 0;  // Otherwise it is zero.\n      }\n      if(match == keyword_length) // If there is a full match,\n         return 1;   // return matched.\n   }\n   return 0;  // Return not matched.\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o notesearch notesearch.c\nreader@hacking:~/booksrc $ sudo chown root:root ./notesearch\nreader@hacking:~/booksrc $ sudo chmod u+s ./notesearch\nreader@hacking:~/booksrc $ ./notesearch\n[DEBUG] found a 34 byte note for user id 999\nthis is a test of multiuser notes\n-------[ end of note data ]------- \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ sudo su jose\njose@hacking:/home/reader/booksrc $ ./notetaker \"This is a note for jose\"\n[DEBUG] buffer   @ 0x804a008: 'This is a note for jose'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\njose@hacking:/home/reader/booksrc $ ./notesearch \n[DEBUG] found a 24 byte note for user id 501\nThis is a note for jose\n-------[ end of note data ]------- \njose@hacking:/home/reader/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./notetaker \"This is another note for the reader user\"\n[DEBUG] buffer   @ 0x804a008: 'This is another note for the reader user'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ ./notesearch \n[DEBUG] found a 34 byte note for user id 999\nthis is a test of multiuser notes\n[DEBUG] found a 41 byte note for user id 999\nThis is another note for the reader user\n-------[ end of note data ]------- \nreader@hacking:~/booksrc $\n```", "```\n\tstruct tm {\n\t     int     tm_sec;        /* seconds */\n\t     int     tm_min;        /* minutes */\n\t     int     tm_hour;       /* hours */\n\t     int     tm_mday;       /* day of the month */\n\t     int     tm_mon;        /* month */\n\t     int     tm_year;       /* year */\n\t     int     tm_wday;       /* day of the week */\n\t     int     tm_yday;       /* day in the year */\n\t     int     tm_isdst;      /* daylight saving time */ \n\t};\n```", "```\n#include <stdio.h>\n#include <time.h>\n\nint main() {\n   long int seconds_since_epoch;\n   struct tm current_time, *time_ptr;\n   int hour, minute, second, day, month, year;\n\n   seconds_since_epoch = time(0); // Pass time a null pointer as argument.\n   printf(\"time() - seconds since epoch: %ld\\n\", seconds_since_epoch);\n\n   time_ptr = &current_time;  // Set time_ptr to the address of\n                              // the current_time struct.\n   localtime_r(&seconds_since_epoch, time_ptr);\n\n   // Three different ways to access struct elements:\n   hour = current_time.tm_hour;  // Direct access\n   minute = time_ptr->tm_min;    // Access via pointer\n   second = *((int *) time_ptr); // Hacky pointer access\n\n   printf(\"Current time is: %02d:%02d:%02d\\n\", hour, minute, second); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc time_example.c\nreader@hacking:~/booksrc $ ./a.out\ntime() - seconds since epoch: 1189311588\nCurrent time is: 04:19:48\nreader@hacking:~/booksrc $ ./a.out\ntime() - seconds since epoch: 1189311600\nCurrent time is: 04:20:00\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <time.h>\n\nvoid dump_time_struct_bytes(struct tm *time_ptr, int size) {\n   int i;\n   unsigned char *raw_ptr;\n   printf(\"bytes of struct located at 0x%08x\\n\", time_ptr);\n   raw_ptr = (unsigned char *) time_ptr;\n   for(i=0; i < size; i++)\n   {\n      printf(\"%02x \", raw_ptr[i]);\n      if(i%16 == 15) // Print a newline every 16 bytes.\n         printf(\"\\n\");\n   }\n   printf(\"\\n\");\n}\n\nint main() {\n   long int seconds_since_epoch;\n   struct tm current_time, *time_ptr;\n   int hour, minute, second, i, *int_ptr;\n\n   seconds_since_epoch = time(0); // Pass time a null pointer as argument.\n   printf(\"time() - seconds since epoch: %ld\\n\", seconds_since_epoch);\n\n   time_ptr = &current_time;  // Set time_ptr to the address of\n                              // the current_time struct.\n   localtime_r(&seconds_since_epoch, time_ptr);\n\n   // Three different ways to access struct elements:\n   hour = current_time.tm_hour;  // Direct access\n   minute = time_ptr->tm_min;    // Access via pointer\n   second = *((int *) time_ptr); // Hacky pointer access\n\n   printf(\"Current time is: %02d:%02d:%02d\\n\", hour, minute, second);\n\n   dump_time_struct_bytes(time_ptr, sizeof(struct tm));\n\n   minute = hour = 0;  // Clear out minute and hour.\n   int_ptr = (int *) time_ptr;\n\n   for(i=0; i < 3; i++) {\n      printf(\"int_ptr @ 0x%08x : %d\\n\", int_ptr, *int_ptr);\n      int_ptr++; // Adding 1 to int_ptr adds 4 to the address,\n   }             // since an int is 4 bytes in size. \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -g time_example2.c\nreader@hacking:~/booksrc $ ./a.out\ntime() - seconds since epoch: 1189311744\nCurrent time is: 04:22:24\nbytes of struct located at 0xbffff7f0\n18 00 00 00 16 00 00 00 04 00 00 00 09 00 00 00\n08 00 00 00 6b 00 00 00 00 00 00 00 fb 00 00 00\n00 00 00 00 00 00 00 00 28 a0 04 08\nint_ptr @ 0xbffff7f0 : 24\nint_ptr @ 0xbffff7f4 : 22\nint_ptr @ 0xbffff7f8 : 4\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint func_one() {\n   printf(\"This is function one\\n\");\n   return 1;\n}\n\nint func_two() {\n   printf(\"This is function two\\n\");\n   return 2;\n}\n\nint main() {\n   int value;\n   int (*function_ptr) ();\n\n   function_ptr = func_one;\n   printf(\"function_ptr is 0x%08x\\n\", function_ptr);\n   value = function_ptr();\n   printf(\"value returned was %d\\n\", value);\n\n   function_ptr = func_two;\n   printf(\"function_ptr is 0x%08x\\n\", function_ptr);\n   value = function_ptr();\n   printf(\"value returned was %d\\n\", value); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc funcptr_example.c\nreader@hacking:~/booksrc $ ./a.out\nfunction_ptr is 0x08048374\nThis is function one\nvalue returned was 1\nfunction_ptr is 0x0804838d\nThis is function two\nvalue returned was 2 \nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n   int i;\n   printf(\"RAND_MAX is %u\\n\", RAND_MAX);\n   srand(time(0));\n\n   printf(\"random values from 0 to RAND_MAX\\n\");\n   for(i=0; i < 8; i++)\n      printf(\"%d\\n\", rand());\n   printf(\"random values from 1 to 20\\n\");\n   for(i=0; i < 8; i++)\n      printf(\"%d\\n\", (rand()%20)+1); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc rand_example.c\nreader@hacking:~/booksrc $ ./a.out\nRAND_MAX is 2147483647\nrandom values from 0 to RAND_MAX\n815015288\n1315541117\n2080969327\n450538726\n710528035\n907694519\n1525415338\n1843056422\nrandom values from 1 to 20\n2\n3\n8\n5\n9\n1\n4\n20\nreader@hacking:~/booksrc $ ./a.out\nRAND_MAX is 2147483647\nrandom values from 0 to RAND_MAX\n678789658\n577505284\n1472754734\n2134715072\n1227404380\n1746681907\n341911720\n93522744\nrandom values from 1 to 20\n6\n16\n12\n19\n8\n19\n2\n1\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <stdlib.h>\n#include \"hacking.h\"\n\n#define DATAFILE \"/var/chance.data\" // File to store user data\n\n// Custom user struct to store information about users\nstruct user {\n   int uid;\n   int credits;\n   int highscore;\n   char name[100];\n   int (*current_game) ();\n};\n\n// Function prototypes\nint get_player_data();\nvoid register_new_player();\nvoid update_player_data();\nvoid show_highscore();\nvoid jackpot();\nvoid input_name();\nvoid print_cards(char *, char *, int);\nint take_wager(int, int);\nvoid play_the_game();\nint pick_a_number();\nint dealer_no_match();\nint find_the_ace();\nvoid fatal(char *);\n\n// Global variables\nstruct user player;      // Player struct\n\nint main() {\n   int choice, last_game;\n\n   srand(time(0)); // Seed the randomizer with the current time.\n\n   if(get_player_data() == -1)  // Try to read player data from file.\n      register_new_player();    // If there is no data, register a new player.\n\n   while(choice != 7) {\n      printf(\"-=[ Game of Chance Menu ]=-\\n\");\n      printf(\"1 - Play the Pick a Number game\\n\");\n      printf(\"2 - Play the No Match Dealer game\\n\");\n      printf(\"3 - Play the Find the Ace game\\n\");\n      printf(\"4 - View current high score\\n\");\n      printf(\"5 - Change your user name\\n\");\n      printf(\"6 - Reset your account at 100 credits\\n\");\n      printf(\"7 - Quit\\n\");\n      printf(\"[Name: %s]\\n\", player.name);\n      printf(\"[You have %u credits] ->  \", player.credits);\n      scanf(\"%d\", &choice);\n\n      if((choice < 1) || (choice > 7))\n         printf(\"\\n[!!] The number %d is an invalid selection.\\n\\n\", choice);\n      else if (choice < 4) {          // Otherwise, choice was a game of some sort.\n            if(choice != last_game) { // If the function ptr isn't set\n               if(choice == 1)        // then point it at the selected game\n                  player.current_game = pick_a_number;\n               else if(choice == 2)\n                  player.current_game = dealer_no_match;\n               else\n                  player.current_game = find_the_ace;\n               last_game = choice;    // and set last_game.\n            }\n            play_the_game();          // Play the game.\n         }\n      else if (choice == 4)\n         show_highscore();\n      else if (choice == 5) {\n         printf(\"\\nChange user name\\n\");\n         printf(\"Enter your new name: \");\n         input_name();\n         printf(\"Your name has been changed.\\n\\n\");\n      }\n      else if (choice == 6) {\n         printf(\"\\nYour account has been reset with 100 credits.\\n\\n\");\n         player.credits = 100;\n      }\n   }\n   update_player_data();\n   printf(\"\\nThanks for playing! Bye.\\n\");\n}\n\n// This function reads the player data for the current uid\n// from the file. It returns -1 if it is unable to find player\n// data for the current uid.\nint get_player_data() { \n   int fd, uid, read_bytes;\n   struct user entry;\n\n   uid = getuid();\n\n   fd = open(DATAFILE, O_RDONLY);\n   if(fd == -1) // Can't open the file, maybe it doesn't exist\n      return -1;\n   read_bytes = read(fd, &entry, sizeof(struct user));    // Read the first chunk.\n   while(entry.uid != uid && read_bytes > 0) { // Loop until proper uid is found.\n      read_bytes = read(fd, &entry, sizeof(struct user)); // Keep reading.\n   }\n   close(fd); // Close the file.\n   if(read_bytes  < sizeof(struct user)) // This means that the end of file was reached.\n      return -1;\n   else\n      player = entry; // Copy the read entry into the player struct.\n   return 1;          // Return a success.\n}\n\n// This is the new user registration function.\n// It will create a new player account and append it to the file.\nvoid register_new_player()  { \n   int fd;\n\n   printf(\"-=-={ New Player Registration }=-=-\\n\");\n   printf(\"Enter your name: \");\n   input_name();\n\n   player.uid = getuid();\n   player.highscore = player.credits = 100;\n\n   fd = open(DATAFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\n   if(fd == -1)\n      fatal(\"in register_new_player() while opening file\");\n   write(fd, &player, sizeof(struct user));\n   close(fd);\n\n   printf(\"\\nWelcome to the Game of Chance %s.\\n\", player.name);\n   printf(\"You have been given %u credits.\\n\", player.credits);\n}\n\n// This function writes the current player data to the file.\n// It is used primarily for updating the credits after games.\nvoid update_player_data() {\n   int fd, i, read_uid;\n   char burned_byte;\n\n   fd = open(DATAFILE, O_RDWR);\n   if(fd == -1) // If open fails here, something is really wrong.\n      fatal(\"in update_player_data() while opening file\");\n   read(fd, &read_uid, 4);          // Read the uid from the first struct.\n   while(read_uid != player.uid) {  // Loop until correct uid is found.\n      for(i=0; i < sizeof(struct user) - 4; i++) // Read through the\n         read(fd, &burned_byte, 1);             // rest of that struct.\n      read(fd, &read_uid, 4);      // Read the uid from the next struct. \n   }\n   write(fd, &(player.credits), 4);   // Update credits.\n   write(fd, &(player.highscore), 4); // Update highscore.\n   write(fd, &(player.name), 100);    // Update name.\n   close(fd);\n}\n\n// This function will display the current high score and\n// the name of the person who set that high score.\nvoid show_highscore() {\n   unsigned int top_score = 0;\n   char top_name[100];\n   struct user entry;\n   int fd;\n\n   printf(\"\\n====================| HIGH SCORE |====================\\n\");\n   fd = open(DATAFILE, O_RDONLY);\n   if(fd == -1)\n      fatal(\"in show_highscore() while opening file\");\n   while(read(fd, &entry, sizeof(struct user)) > 0) { // Loop until end of file.\n      if(entry.highscore > top_score) {   // If there is a higher score,\n            top_score = entry.highscore;  // set top_score to that score\n            strcpy(top_name, entry.name); // and top_name to that username.\n         }\n   }\n   close(fd);\n   if(top_score > player.highscore)\n      printf(\"%s has the high score of %u\\n\", top_name, top_score);\n   else\n      printf(\"You currently have the high score of %u credits!\\n\", player.highscore);\n   printf(\"======================================================\\n\\n\");\n}\n\n// This function simply awards the jackpot for the Pick a Number game.\nvoid jackpot() {\n   printf(\"*+*+*+*+*+* JACKPOT *+*+*+*+*+*\\n\");\n   printf(\"You have won the jackpot of 100 credits!\\n\");\n   player.credits += 100;\n}\n\n// This function is used to input the player name, since \n// scanf(\"%s\", &whatever) will stop input at the first space.\nvoid input_name() {\n   char *name_ptr, input_char='\\n';\n   while(input_char == '\\n')    // Flush any leftover \n      scanf(\"%c\", &input_char); // newline chars.\n\n   name_ptr = (char *) &(player.name); // name_ptr = player name's address\n   while(input_char != '\\n') {  // Loop until newline.\n      *name_ptr = input_char;   // Put the input char into name field.\n      scanf(\"%c\", &input_char); // Get the next char.\n      name_ptr++;               // Increment the name pointer.\n   }\n   *name_ptr = 0;  // Terminate the string.\n}\n\n// This function prints the 3 cards for the Find the Ace game.\n// It expects a message to display, a pointer to the cards array,\n// and the card the user has picked as input. If the user_pick is\n// -1, then the selection numbers are displayed.\nvoid print_cards(char *message, char *cards, int user_pick) {\n   int i;\n\n   printf(\"\\n\\t*** %s ***\\n\", message);\n   printf(\"      \\t._.\\t._.\\t._.\\n\");\n   printf(\"Cards:\\t|%c|\\t|%c|\\t|%c|\\n\\t\", cards[0], cards[1], cards[2]);\n   if(user_pick == -1)\n      printf(\" 1 \\t 2 \\t 3\\n\");\n   else {\n      for(i=0; i < user_pick; i++)\n         printf(\"\\t\");\n      printf(\" ^-- your pick\\n\");\n   }\n}\n\n// This function inputs wagers for both the No Match Dealer and\n// Find the Ace games. It expects the available credits and the\n// previous wager as arguments. The previous_wager is only important\n// for the second wager in the Find the Ace game. The function\n// returns -1 if the wager is too big or too little, and it returns\n// the wager amount otherwise.\nint take_wager(int available_credits, int previous_wager) {\n   int wager, total_wager;\n\n   printf(\"How many of your %d credits would you like to wager?  \", available_credits);\n   scanf(\"%d\", &wager);\n   if(wager < 1) {   // Make sure the wager is greater than 0.\n      printf(\"Nice try, but you must wager a positive number!\\n\");\n      return -1;\n   }\n   total_wager = previous_wager + wager;\n   if(total_wager > available_credits) {  // Confirm available credits\n      printf(\"Your total wager of %d is more than you have!\\n\", total_wager);\n      printf(\"You only have %d available credits, try again.\\n\", available_credits);\n      return -1;\n   }\n   return wager;\n}\n\n// This function contains a loop to allow the current game to be\n// played again. It also writes the new credit totals to file\n// after each game is played.\nvoid play_the_game() { \n   int play_again = 1;\n   int (*game) ();\n   char selection;\n\n   while(play_again) {\n      printf(\"\\n[DEBUG] current_game pointer @ 0x%08x\\n\", player.current_game);\n      if(player.current_game() != -1) {         // If the game plays without error and\n         if(player.credits > player.highscore)  // a new high score is set,\n            player.highscore = player.credits;  // update the highscore.\n         printf(\"\\nYou now have %u credits\\n\", player.credits);\n         update_player_data();                  // Write the new credit total to file.\n         printf(\"Would you like to play again? (y/n)  \");\n         selection = '\\n';\n         while(selection == '\\n')               // Flush any extra newlines.\n            scanf(\"%c\", &selection);\n         if(selection == 'n')\n            play_again = 0;\n      }\n      else               // This means the game returned an error,\n         play_again = 0; // so return to main menu.\n   }\n}\n\n// This function is the Pick a Number game.\n// It returns -1 if the player doesn't have enough credits.\nint pick_a_number() { \n   int pick, winning_number;\n\n   printf(\"\\n####### Pick a Number ######\\n\");\n   printf(\"This game costs 10 credits to play. Simply pick a number\\n\");\n   printf(\"between 1 and 20, and if you pick the winning number, you\\n\");\n   printf(\"will win the jackpot of 100 credits!\\n\\n\");\n   winning_number = (rand() % 20) + 1; // Pick a number between 1 and 20.\n   if(player.credits < 10) {\n      printf(\"You only have %d credits. That's not enough to play!\\n\\n\", player.credits);\n      return -1;  // Not enough credits to play \n   }\n   player.credits -= 10; // Deduct 10 credits.\n   printf(\"10 credits have been deducted from your account.\\n\");\n   printf(\"Pick a number between 1 and 20: \");\n   scanf(\"%d\", &pick);\n\n   printf(\"The winning number is %d\\n\", winning_number);\n   if(pick == winning_number)\n      jackpot();\n   else\n      printf(\"Sorry, you didn't win.\\n\");\n   return 0;\n}\n\n// This is the No Match Dealer game.\n// It returns -1 if the player has 0 credits.\nint dealer_no_match() { \n   int i, j, numbers[16], wager = -1, match = -1;\n\n   printf(\"\\n::::::: No Match Dealer :::::::\\n\");\n   printf(\"In this game, you can wager up to all of your credits.\\n\");\n   printf(\"The dealer will deal out 16 random numbers between 0 and 99.\\n\");\n   printf(\"If there are no matches among them, you double your money!\\n\\n\");\n\n   if(player.credits == 0) {\n      printf(\"You don't have any credits to wager!\\n\\n\");\n      return -1;\n   }\n   while(wager == -1)\n      wager = take_wager(player.credits, 0);\n\n   printf(\"\\t\\t::: Dealing out 16 random numbers :::\\n\");\n   for(i=0; i < 16; i++) {\n      numbers[i] = rand() % 100; // Pick a number between 0 and 99.\n      printf(\"%2d\\t\", numbers[i]);\n      if(i%8 == 7)               // Print a line break every 8 numbers.\n         printf(\"\\n\");\n   }\n   for(i=0; i < 15; i++) {       // Loop looking for matches.\n      j = i + 1;\n      while(j < 16) {\n         if(numbers[i] == numbers[j])\n            match = numbers[i];\n         j++;\n      }\n   }\n   if(match != -1) {\n      printf(\"The dealer matched the number %d!\\n\", match);\n      printf(\"You lose %d credits.\\n\", wager);\n      player.credits -= wager;\n   } else {\n      printf(\"There were no matches! You win %d credits!\\n\", wager);\n      player.credits += wager;\n   }\n   return 0;\n}\n\n// This is the Find the Ace game.\n// It returns -1 if the player has 0 credits.\nint find_the_ace() {\n   int i, ace, total_wager;\n   int invalid_choice, pick = -1, wager_one = -1, wager_two = -1;\n   char choice_two, cards[3] = {'X', 'X', 'X'};\n\n   ace = rand()%3; // Place the ace randomly.\n\n   printf(\"******* Find the Ace *******\\n\");\n   printf(\"In this game, you can wager up to all of your credits.\\n\");\n   printf(\"Three cards will be dealt out, two queens and one ace.\\n\");\n   printf(\"If you find the ace, you will win your wager.\\n\");\n   printf(\"After choosing a card, one of the queens will be revealed.\\n\");\n   printf(\"At this point, you may either select a different card or\\n\");\n   printf(\"increase your wager.\\n\\n\");\n\n   if(player.credits == 0) {\n      printf(\"You don't have any credits to wager!\\n\\n\");\n      return -1;\n   }\n\n   while(wager_one == -1) // Loop until valid wager is made.\n      wager_one = take_wager(player.credits, 0);\n\n   print_cards(\"Dealing cards\", cards, -1);\n   pick = -1;\n   while((pick < 1) || (pick > 3)) { // Loop until valid pick is made.\n      printf(\"Select a card: 1, 2, or 3  \");\n      scanf(\"%d\", &pick);\n   }\n   pick--; // Adjust the pick since card numbering starts at 0.\n   i=0;\n   while(i == ace || i == pick) // Keep looping until\n      i++;                      // we find a valid queen to reveal.\n   cards[i] = 'Q';\n   print_cards(\"Revealing a queen\", cards, pick);\n   invalid_choice = 1;\n   while(invalid_choice) {       // Loop until valid choice is made.\n      printf(\"Would you like to:\\n[c]hange your pick\\tor\\t[i]ncrease your wager?\\n\");\n      printf(\"Select c or i:  \");\n      choice_two = '\\n';\n      while(choice_two == '\\n')  // Flush extra newlines.\n         scanf(\"%c\", &choice_two);\n      if(choice_two == 'i') {    // Increase wager.\n            invalid_choice=0;    // This is a valid choice.\n            while(wager_two == -1)   // Loop until valid second wager is made.\n               wager_two = take_wager(player.credits, wager_one);\n         }\n      if(choice_two == 'c') {    // Change pick.\n         i = invalid_choice = 0; // Valid choice\n         while(i == pick || cards[i] == 'Q') // Loop until the other card\n            i++;                             // is found,\n         pick = i;                           // and then swap pick.\n         printf(\"Your card pick has been changed to card %d\\n\", pick+1);\n      }\n   }\n\n   for(i=0; i < 3; i++) {  // Reveal all of the cards.\n      if(ace == i)\n         cards[i] = 'A';\n      else\n         cards[i] = 'Q';\n   }\n   print_cards(\"End result\", cards, pick);\n\n   if(pick == ace) {  // Handle win.\n      printf(\"You have won %d credits from your first wager\\n\", wager_one);\n      player.credits += wager_one;\n      if(wager_two != -1) {\n         printf(\"and an additional %d credits from your second wager!\\n\", wager_two);\n         player.credits += wager_two;\n      }\n   } else { // Handle loss.\n      printf(\"You have lost %d credits from your first wager\\n\", wager_one);\n      player.credits -= wager_one;\n      if(wager_two != -1) {\n         printf(\"and an additional %d credits from your second wager!\\n\", wager_two);\n         player.credits -= wager_two;\n      }\n   }\n   return 0; \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o game_of_chance game_of_chance.c \nreader@hacking:~/booksrc $ sudo chown root:root ./game_of_chance\nreader@hacking:~/booksrc $ sudo chmod u+s ./game_of_chance\nreader@hacking:~/booksrc $ ./game_of_chance\n-=-={ New Player Registration }=-=-\nEnter your name: Jon Erickson\n\nWelcome to the Game of Chance, Jon Erickson.\nYou have been given 100 credits.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 100 credits] ->  1\n\n[DEBUG] current_game pointer @ 0x08048e6e\n\n####### Pick a Number ######\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nwill win the jackpot of 100 credits!\n\n10 credits have been deducted from your account.\nPick a number between 1 and 20: 7\nThe winning number is 14.\nSorry, you didn't win.\n\nYou now have 90 credits.\nWould you like to play again? (y/n)  n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 90 credits] ->  2\n\n[DEBUG] current_game pointer @ 0x08048f61\n\n::::::: No Match Dealer :::::::\nIn this game you can wager up to all of your credits.\nThe dealer will deal out 16 random numbers between 0 and 99.\nIf there are no matches among them, you double your money!\n\nHow many of your 90 credits would you like to wager?  30\n                ::: Dealing out 16 random numbers :::\n88      68      82      51      21      73      80      50\n11      64      78      85      39      42      40      95\nThere were no matches! You win 30 credits!\n\nYou now have 120 credits\nWould you like to play again? (y/n)  n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 120 credits] ->  3\n\n[DEBUG] current_game pointer @ 0x0804914c\n******* Find the Ace *******\nIn this game you can wager up to all of your credits.\nThree cards will be dealt: two queens and one ace.\nIf you find the ace, you will win your wager.\nAfter choosing a card, one of the queens will be revealed.\nAt this point you may either select a different card or\nincrease your wager.\n\nHow many of your 120 credits would you like to wager?  50\n\n        *** Dealing cards ***\n        ._.     ._.     ._.\nCards:  |X|     |X|     |X|\n         1       2       3\nSelect a card: 1, 2, or 3:  2\n\n        *** Revealing a queen ***\n        ._.     ._.     ._.\nCards:  |X|     |X|     |Q|\n                 ^-- your pick\nWould you like to\n[c]hange your pick      or      [i]ncrease your wager?\nSelect c or i:  c\nYour card pick has been changed to card 1.\n\n        *** End result ***\n\n        ._.     ._.     ._.\nCards:  |A|     |Q|     |Q|\n         ^-- your pick\nYou have won 50 credits from your first wager.\n\nYou now have 170 credits.\nWould you like to play again? (y/n)  n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 170 credits] ->  4\n\n====================| HIGH SCORE |====================\nYou currently have the high score of 170 credits!\n======================================================\n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 170 credits] ->  7\n\nThanks for playing! Bye.\nreader@hacking:~/booksrc $ sudo su jose\njose@hacking:/home/reader/booksrc $ ./game_of_chance\n-=-={ New Player Registration }=-=-\nEnter your name: Jose Ronnick\n\nWelcome to the Game of Chance Jose Ronnick.\nYou have been given 100 credits.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score 5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jose Ronnick]\n[You have 100 credits] ->  4\n====================| HIGH SCORE |====================\nJon Erickson has the high score of 170.\n======================================================\n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jose Ronnick]\n[You have 100 credits] ->  7\n\nThanks for playing! Bye.\njose@hacking:~/booksrc $ exit\nexit \nreader@hacking:~/booksrc $\n```"]