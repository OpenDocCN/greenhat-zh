["```\naStr = 'hello world'\nputs( \"#{aStr}\" )\nputs( \"#{2*10}\" )\n```", "```\n\"#{def x(s)\n        puts(s.reverse)\n    end;\n(1..3).each{x(aStr)}}\"\n```", "```\ndlrow olleh\ndlrow olleh\ndlrow olleh\n```", "```\nputs( eval(\"1 + 2\" ) )    #=> 3\nputs( \"#{1 + 2}\" )        #=> 3\n```", "```\nexp = gets().chomp()    #<= User enters 2*4\nputs( eval( exp ))      #=> 8\nputs( \"#{exp}\" )        #=> 2*4\n```", "```\nputs( \"#{eval(exp)}\" )\n```", "```\nprint(\"Enter a string method name (e.g. reverse or upcase):\")\n                                   # user enters: upcase\nmethodname = gets().chomp()\nexp2 = \"'Hello world'.\"<< methodname\nputs( eval( exp2 ) )               #=> HELLO WORLD\nputs( \"#{exp2}\" )                  #=> 'Hello world'.upcase\nputs( \"#{eval(exp2)}\" )            #=> HELLO WORLD\n```", "```\neval( 'def aMethod( x )\n    return( x * 2 )\nend\n\nnum = 100\nputs( \"This is the result of the calculation:\" )\nputs( aMethod( num ))' )\n```", "```\nThis is the result of the calculation:\n200\n```", "```\ninput = \"\"\nuntil input == \"q\"\n    input = gets().chomp()\n    if input != \"q\" then eval( input ) end\nend\n```", "```\ndef x(aStr); puts(aStr.upcase);end\ndef y(aStr); puts(aStr.reverse);end\n```", "```\nx(\"hello world\")\ny(\"hello world\")\n```", "```\nHELLO WORLD\ndlrow olleh\n```", "```\nclass MyClass\n def initialize\n   @aVar = \"Hello world\"\n end\nend\n\nob = MyClass.new\np( ob.instance_eval { @aVar } )         #=> \"Hello world\"\np( ob.instance_eval( \"@aVar\" ) )        #=> \"Hello world\"\n```", "```\np( ob.eval( \"@aVar\" )  )    # This won't work!\n```", "```\nclass Object\n    public :eval\nend\n```", "```\npublic :eval\n```", "```\np( ob.eval( \"@aVar\" ) )        #=> \"Hello world\"\n```", "```\nmodule X\nend\n\nclass Y\n    @@x = 10\n    include X\nend\n\nX::module_eval{ define_method(:xyz){ puts(\"hello\" ) } }\nY::class_eval{ define_method(:abc){ puts(\"hello, hello\" ) } }\n```", "```\nob = Y.new\nob.xyz        #=> hello\nob.abc        #=> hello, hello\n```", "```\nX::class_eval{ define_method(:xyz2){ puts(\"hello again\" ) } }\nY::module_eval{ define_method(:abc2){ puts(\"hello, hello again\") }}\n```", "```\nString::class_eval{ define_method(:bye){ puts(\"goodbye\" ) } }\n\"Hello\".bye        #=> goodbye\n```", "```\nY.class_eval( \"@@x\" )\n```", "```\nob = X.new\nX.class_eval( 'def hi;puts(\"hello\");end' )\nob.hi        #=> hello\n```", "```\nclass X\n    def self.addvar( aSymbol, aValue )\n        class_variable_set( aSymbol, aValue )\n    end\n\n    def self.getvar( aSymbol )\n        return class_variable_get( aSymbol )\n    end\nend\n\nX.addvar( :@@newvar, 2000 )\nputs( X.getvar( :@@newvar ) )    #=> 2000\n```", "```\np( X.class_variables )    #=> [\"@@abc\", \"@@newvar\"]\n```", "```\nob = X.new\nob.instance_variable_set(\"@aname\", \"Bert\")\n```", "```\ndef addMethod( m, &block )\n    self.class.send( :define_method, m , &block )\nend\n```", "```\nob.addMethod( :xyz ) { puts(\"My name is #{@aname}\") }\n```", "```\nob2 = X.new\nob2.instance_variable_set(\"@aname\", \"Mary\")\nob2.xyz\n```", "```\nob2.instance_variable_get( :@aname )\n```", "```\nX::const_set( :NUM, 500 )\nputs( X::const_get( :NUM ) )\n```", "```\nclass X\n    def y\n        puts( \"ymethod\" )\n   end\nend\n\nprint( \"Enter a class name: \")                  #<= Enter: X\ncname = gets().chomp\nob = Object.const_get(cname).new\np( ob )                                         #=> #<X:0x2bafdc0>\nprint( \"Enter a method to be called: \" )        #<= Enter: y\nmname = gets().chomp\nob.method(mname).call                           #=> ymethod\n```", "```\nputs(\"What shall we call this class? \")\nclassName = gets.strip().capitalize()\nObject.const_set(className,Class.new)\nputs(\"I'll give it a method called 'myname'\" )\nclassName = Object.const_get(className)\nclassName::module_eval{ define_method(:myname){\n        puts(\"The name of my class is '#{self.class}'\" ) }\n    }\n\nx = className.new\nx.myname\n```", "```\nThe name of my class is 'Xxx'\n```", "```\ndef getBinding(str)\n    return binding()\nend\nstr = \"hello\"\nputs( eval( \"str + ' Fred'\" ) )                    #=> \"hello Fred\"\nputs( eval( \"str + ' Fred'\", getBinding(\"bye\") ) ) #=> \"bye Fred\"\n```", "```\ndef getBinding()\n    str = \"bye\"\n    return binding()\nend\nstr = \"hello\"\nputs( eval( \"str + ' Fred'\" )   )                  #=> \"hello Fred\"\nputs( eval( \"str + ' Fred'\", getBinding() ) )      #=> \"bye Fred\"\nputs( eval( \"str + ' Fred'\" )   )                  #=> \"hello Fred\"\n```", "```\nclass MyClass\n   @@x = \" x\"\n   def initialize(s)\n      @mystr = s\n   end\n   def getBinding\n      return binding()\n   end\nend\n\nclass MyOtherClass\n   @@x = \" y\"\n   def initialize(s)\n      @mystr = s\n   end\n   def getBinding\n      return binding()\n   end\nend\n\n@mystr = self.inspect\n@@x = \" some other value\"\n\nob1 = MyClass.new(\"ob1 string\")\nob2 = MyClass.new(\"ob2 string\")\nob3 = MyOtherClass.new(\"ob3 string\")\n\nputs(eval(\"@mystr << @@x\", ob1.getBinding))\nputs(eval(\"@mystr << @@x\", ob2.getBinding))\nputs(eval(\"@mystr << @@x\", ob3.getBinding))\nputs(eval(\"@mystr << @@x\", binding))\n```", "```\nob1 string x\nob2 string x\nob3 string y\nmain some other value\n```", "```\nob1 string some other value\nob2 string some other value\nob3 string some other value\nmain some other value\n```", "```\n# @@x = \" some other value\"\n```", "```\nob1 string x\nob2 string x\nob3 string y\n...uninitialized class variable @@x in Object (NameError)\n```", "```\nname = \"Fred\"\nputs( name.send( :reverse ) )    #=> derF\nputs( name.send( :upcase ) )     #=> FRED\n```", "```\nname = MyString.new( gets() )\nmethodname = gets().chomp.to_sym #<= to_sym is not strictly necessary\nname.send(methodname)\n```", "```\nclass MyString < String\n    def initialize( aStr )\n        super aStr\n    end\n\n    def show\n        puts self\n    end\n\n    def rev\n        puts self.reverse\n    end\nend\n\nprint(\"Enter your name: \")          #<= Enter: Fred\nname = MyString.new( gets() )\nprint(\"Enter a method name: \" )     #<= Enter: rev\nmethodname = gets().chomp.to_sym\nputs( name.send(methodname) )       #=> derF\n```", "```\ndef addMethod( m, &block )\n    self.class.send( :define_method, m , &block )\nend\n```", "```\nputs( \"hello\".reverse )  #=> olleh\nclass String\n    remove_method( :reverse )\nend\nputs( \"hello\".reverse )  #=> undefined method error!\n```", "```\nclass Y\n    def somemethod\n        puts(\"Y's somemethod\")\n    end\nend\n\nclass Z < Y\n    def somemethod\n        puts(\"Z's somemethod\")\n    end\nend\n\nzob = Z.new\nzob.somemethod                     #=> Z's somemethod\nclass Z\n     remove_method( :somemethod )  # Remove somemethod from Z class\nend\n\nzob.somemethod                     #=> Y's somemethod\n```", "```\nzob = Z.new\nzob.somemethod                       #=> Z's somemethod\n\nclass Z\n   undef_method( :somemethod )       #=> undefine somemethod\nend\n\nzob.somemethod                       #=> undefined method error\n```", "```\ndef method_missing( methodname )\n   puts( \"Sorry, #{methodname} does not exist\" )\nend\nxxx        #=> Sorry, xxx does not exist\n```", "```\ndef method_missing( methodname, *args )\n      puts( \"Class #{self.class} does not understand:\n                   #{methodname}( #{args.inspect} )\" )\nend\n```", "```\nob = X.new\nob.aaa            #=> Class X does not understand: aaa( [] )\nob.aaa( 1,2,3 )   #=> Class X does not understand: aaa( [1, 2, 3] )\n```", "```\ndef method_missing( methodname, *args )\n       self.class.send( :define_method, methodname,\n            lambda{ |*args| puts( args.inspect) } )\nend\n```", "```\nob3 = Z.new\nob3.ddd( 1,2,3)\nob3.ddd( 4,5,6 )\n```", "```\nClass Z does not understand: ddd( [1, 2, 3] )\nNow creating method ddd( )\n[4, 5, 6]\n```", "```\nprogram = \"\"\ninput = \"\"\nline = \"\"\nuntil line.strip() == \"q\"\n    print( \"?- \" )\n    line = gets()\n    case( line.strip() )\n    when ''\n        puts( \"Evaluating...\" )\n        eval( input )\n        program += input\n        input = \"\"\n    when '1'\n        puts( \"Program Listing...\" )\n        puts( program )\n   else\n        input += line\n    end\nend\n```", "```\ndef a(s)             # <= press Enter after each line\nreturn s.reverse     # <= press enter (and so on...)\nend\n                     # <- Enter a blank line here to eval these two methods\ndef b(s)\nreturn a(s).upcase\nend\n                     # <- Enter a blank line here to eval these two methods\nputs( a(\"hello\" ) )\n\n                     # <- Enter a blank line to eval\n                     #=> olleh\nputs( b(\"goodbye\" ) )\n                     # <- Enter a blank line to eval\n                     #=> EYBDOOG\n```", "```\nWrite a program interactively.\nEnter a blank line to evaluate.\nEnter 'q' to quit.\n?- def a(s)\n?- return s.reverse\n?- end\n?-\nEvaluating...\n?- def b(s)\n?- return a(s).upcase\n?- end\n?-\nEvaluating...\n?- puts(a(\"hello\"))\n?-\nEvaluating...\nolleh\n?- b(\"goodbye\")\n?-\nEvaluating...\nEYBDOOG\n```", "```\ns = \"Hello\"\ns << \" world\"\ns.freeze\ns << \" !!!\"   # Error: \"can't modify frozen string\"\n```", "```\na = [1,2,3]\na.freeze\nif !(a.frozen?) then\n    a << [4,5,6]\nend\n```", "```\ndef addMethod( m, &block )\n    self.class.send( :define_method, m , &block )\nend\n```", "```\nob.freeze\nob.addMethod( :abc ) { puts(\"This is the abc method\") }\n```", "```\nif not( ob.frozen? ) then\n  ob.addMethod(:def){puts(\"'def' is not a good name for a method\")}\nend\n```", "```\nX.freeze\nif not( X.frozen? ) then\n  ob.addMethod(:def){puts(\"'def' is not a good name for a method\")}\nend\n```"]