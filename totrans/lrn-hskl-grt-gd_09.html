<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;More Input and More Output"><div class="titlepage"><div><div><h1 class="title"><a id="more_input_and_more_output"/>Chapter 9. More Input and More Output</h1></div></div></div><p>Now that you understand the concepts behind Haskell’s I/O, we can start doing fun stuff with it. In this chapter, we’ll interact with files, make random numbers, deal with command-line arguments, and more. Stay tuned!<a id="IDX-CHP-9-0001" class="indexterm"/></p><div class="sect1" title="Files and Streams"><div class="titlepage"><div><div><h1 class="title"><a id="files_and_streams"/>Files and Streams</h1></div></div></div><p>Armed with the knowledge about how I/O actions work, we can move on to reading and writing files with Haskell. But first, let’s take a look at how we can use Haskell to easily process streams of data. A <span class="emphasis"><em>stream</em></span> is a succession of pieces of data entering or exiting a program over time. For instance, when you’re inputting characters into a program via the keyboard, those characters can be thought of as a stream.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e14963"/><img src="httpatomoreillycomsourcenostarchimages802620.png.jpg" alt="image with no caption"/></div></div><div class="sect2" title="Input Redirection"><div class="titlepage"><div><div><h2 class="title"><a id="input_redirection"/>Input Redirection</h2></div></div></div><p>Many interactive programs get the user’s input via the keyboard. However, it’s often more convenient to get the input by feeding the contents of a text file to the program. To achieve this, we use <span class="emphasis"><em>input redirection</em></span>.<a id="IDX-CHP-9-0002" class="indexterm"/><a id="IDX-CHP-9-0003" class="indexterm"/><a id="IDX-CHP-9-0004" class="indexterm"/><a id="IDX-CHP-9-0005" class="indexterm"/></p><p>Input redirection will come in handy with our Haskell programs, so let’s take a look at how it works. To begin, create a text file that contains the following little haiku, and save it as <span class="emphasis"><em>haiku.txt</em></span>:</p><a id="I_programlisting9_d1e14995"/><pre class="programlisting">I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless</pre><p>Yeah, the haiku sucks—what of it? If anyone knows of any good haiku tutorials, let me know.</p><p>Now we’ll write a little program that continuously gets a line from the input and then prints it back in all uppercase:</p><a id="I_programlisting9_d1e15001"/><pre class="programlisting">import Control.Monad
import Data.Char

main = forever $ do
    l &lt;- getLine
    putStrLn $ map toUpper l</pre><p>Save this program as <span class="emphasis"><em>capslocker.hs</em></span> and compile it.</p><p>Instead of inputting lines via the keyboard, we’ll have <span class="emphasis"><em>haiku.txt</em></span> be the input by redirecting it into our program. To do that, we add a <code class="literal">&lt;</code> character after our program name and then specify the file that we want to act as the input. Check it out:</p><a id="I_programlisting9_d1e15016"/><pre class="programlisting">$ ghc --make capslocker
[1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )
Linking capslocker ...
$ ./capslocker &lt; haiku.txt
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
capslocker &lt;stdin&gt;: hGetLine: end of file</pre><p>What we’ve done is pretty much equivalent to running <code class="literal">capslocker</code>, typing our haiku at the terminal, and then issuing an end-of-file character (usually done by pressing <span class="keycap">ctrl</span>-D). It’s like running <code class="literal">capslocker</code> and saying, “Wait, don’t read from the keyboard. Take the contents of this file instead!”</p></div><div class="sect2" title="Getting Strings from Input Streams"><div class="titlepage"><div><div><h2 class="title"><a id="getting_strings_from_input_streams"/>Getting Strings from Input Streams</h2></div></div></div><p>Let’s take a look at an I/O action that makes processing input streams easier by allowing us to treat them as normal strings: <code class="literal">getContents</code>. <code class="literal">getContents</code> reads everything from the standard input until it encounters an end-of-file character. Its type is <code class="literal">getContents :: IO String</code>. What’s cool about <code class="literal">getContents</code> is that it does lazy I/O. This means that when we do <code class="literal">foo &lt;- getContents</code>, <code class="literal">getContents</code> doesn’t read all of the input at once, store it in memory, and then bind it to <code class="literal">foo</code>. No, <code class="literal">getContents</code> is lazy! It will say, “Yeah yeah, I’ll read the input from the terminal later as we go along, when you really need it!”<a id="IDX-CHP-9-0006" class="indexterm"/><a id="IDX-CHP-9-0007" class="indexterm"/><a id="IDX-CHP-9-0008" class="indexterm"/><a id="IDX-CHP-9-0009" class="indexterm"/><a id="IDX-CHP-9-0010" class="indexterm"/><a id="IDX-CHP-9-0011" class="indexterm"/><a id="IDX-CHP-9-0012" class="indexterm"/></p><p>In our <span class="emphasis"><em>capslocker.hs</em></span> example, we used <code class="literal">forever</code> to read the input line by line and then print it back in uppercase. If we opt to use <code class="literal">getContents</code>, it takes care of the I/O details for us, such as when to read input and how much of that input to read. Because our program is about taking some input and transforming it into some output, we can make it shorter by using <code class="literal">getContents</code>:</p><a id="I_programlisting9_d1e15103"/><pre class="programlisting">import Data.Char

main = do
    contents &lt;- getContents
    putStr $ map toUpper contents</pre><p>We run the <code class="literal">getContents</code> I/O action and name the string it produces <code class="literal">contents</code>. Then we map <code class="literal">toUpper</code> over that string and print that result to the terminal. Keep in mind that because strings are basically lists, which are lazy, and <code class="literal">getContents</code> is I/O lazy; it won’t try to read all of the content at once and store that into memory before printing out the caps-locked version. Rather, it will print out the caps-locked version as it reads, because it will read a line from the input only when it must.</p><p>Let’s test it:</p><a id="I_programlisting9_d1e15121"/><pre class="programlisting">$ ./capslocker &lt; haiku.txt
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS</pre><p>So, it works. What if we just run <code class="literal">capslocker</code> and try to type in the lines ourselves? (To exit the program, just press <span class="keycap">ctrl</span>-D.)</p><a id="I_programlisting9_d1e15131"/><pre class="programlisting">$ ./capslocker
hey ho
HEY HO
lets go
LETS GO</pre><p>Pretty nice! As you can see, it prints our caps-locked input line by line.<a id="IDX-CHP-9-0013" class="indexterm"/></p><p>When the result of <code class="literal">getContents</code> is bound to <code class="literal">contents</code>, it’s not represented in memory as a real string, but more like a promise that the string will be produced eventually. When we map <code class="literal">toUpper</code> over <code class="literal">contents</code>, that’s also a promise to map that function over the eventual contents. Finally, when <code class="literal">putStr</code> happens, it says to the previous promise, “Hey, I need a caps-locked line!” It doesn’t have any lines yet, so it says to <code class="literal">contents</code>, “How about getting a line from the terminal?” And that’s when <code class="literal">getContents</code> actually reads from the terminal and gives a line to the code that asked it to produce something tangible. That code then maps <code class="literal">toUpper</code> over that line and gives it to <code class="literal">putStr</code>, which prints the line. And then <code class="literal">putStr</code> says, “Hey, I need the next line—come on!” This repeats until there’s no more input, which is signified by an end-of-file character.</p><p>Now let’s make a program that takes some input and prints out only those lines that are shorter than 10 characters:</p><a id="I_programlisting9_d1e15176"/><pre class="programlisting">main = do
    contents &lt;- getContents
    putStr (shortLinesOnly contents)

shortLinesOnly :: String -&gt; String
shortLinesOnly = unlines . filter (\line -&gt; length line &lt; 10) . lines</pre><p>We’ve made the I/O part of our program as short as possible. Because our program is supposed to print something based on some input, we can implement it by reading the input contents, running a function on them, and then printing out what that function gives back.</p><p>The <code class="literal">shortLinesOnly</code> function takes a string, like <code class="literal">"short\nlooooooong\nbort"</code>. In this example, that string has three lines: two of them are short, and the middle one is long. It applies the <code class="literal">lines</code> function to that string, which converts it to <code class="literal">["short", "looooooong", "bort"]</code>. That list of strings is then filtered so that only those lines that are shorter than 10 characters remain in the list, producing <code class="literal">["short", "bort"]</code>. Finally, <code class="literal">unlines</code> joins that list into a single newline-delimited string, giving <code class="literal">"short\nbort"</code>.</p><p>Let’s give it a go. Save the following text as <span class="emphasis"><em>shortlines.txt</em></span>.</p><a id="I_programlisting9_d1e15209"/><pre class="programlisting">i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short</pre><p>And now we’ll compile our program, which we saved as <span class="emphasis"><em>shortlinesonly.hs</em></span>:<a id="IDX-CHP-9-0014" class="indexterm"/><a id="IDX-CHP-9-0015" class="indexterm"/><a id="IDX-CHP-9-0016" class="indexterm"/></p><a id="I_programlisting9_d1e15227"/><pre class="programlisting">$ ghc --make shortlinesonly
[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
Linking shortlinesonly ...</pre><p>To test it, we’re going to redirect the contents of <span class="emphasis"><em>shortlines.txt</em></span> into our program, as follows:</p><a id="I_programlisting9_d1e15234"/><pre class="programlisting">$ ./shortlinesonly &lt; shortlines.txt
i'm short
so am i
short</pre><p>You can see that only the short lines were printed to the terminal.</p></div><div class="sect2" title="Transforming Input"><div class="titlepage"><div><div><h2 class="title"><a id="transforming_input"/>Transforming Input</h2></div></div></div><p>The pattern of getting some string from the input, transforming it with a function, and outputting the result is so common that there is a function that makes that job even easier, called <code class="literal">interact</code>. <code class="literal">interact</code> takes a function of type <code class="literal">String -&gt; String</code> as a parameter and returns an I/O action that will take some input, run that function on it, and then print out the function’s result. Let’s modify our program to use <code class="literal">interact</code>:<a id="IDX-CHP-9-0017" class="indexterm"/></p><a id="I_programlisting9_d1e15258"/><pre class="programlisting">main = interact shortLinesOnly

shortLinesOnly :: String -&gt; String
shortLinesOnly = unlines . filter (\line -&gt; length line &lt; 10) . lines</pre><p>We can use this program either by redirecting a file into it or by running it and then giving it input from the keyboard, line by line. Its output is the same in both cases, but when we’re doing input via the keyboard, the output is interspersed with what we typed in, just as when we manually typed in our input to our <code class="literal">capslocker</code> program.</p><p>Let’s make a program that continuously reads a line and then outputs whether or not that line is a palindrome. We could just use <code class="literal">getLine</code> to read a line, tell the user if it’s a palindrome, and then run <code class="literal">main</code> all over again. But it’s simpler if we use <code class="literal">interact</code>. When using <code class="literal">interact</code>, think about what you need to do to transform some input into the desired output. In our case, we want to replace each line of the input with either <code class="literal">"palindrome"</code> or <code class="literal">"not a palindrome"</code>.</p><a id="I_programlisting9_d1e15286"/><pre class="programlisting">respondPalindromes :: String -&gt; String
respondPalindromes =
    unlines .
    map (\xs -&gt; if isPal xs then "palindrome" else "not a palindrome") .
    lines

isPal :: String -&gt; Bool
isPal xs = xs == reverse xs</pre><p>This program is pretty straightforward. First, it turns a string like this:<a id="IDX-CHP-9-0018" class="indexterm"/></p><a id="I_programlisting9_d1e15295"/><pre class="programlisting">"elephant\nABCBA\nwhatever"</pre><p>into an array like this:</p><a id="I_programlisting9_d1e15299"/><pre class="programlisting">["elephant", "ABCBA", "whatever"]</pre><p>Then it maps the lambda over it, giving the results:</p><a id="I_programlisting9_d1e15304"/><pre class="programlisting">["not a palindrome", "palindrome", "not a palindrome"]</pre><p>Next, <code class="literal">unlines</code> joins that list into a single, newline-delimited string. Now we just make a main I/O action:</p><a id="I_programlisting9_d1e15311"/><pre class="programlisting">main = interact respondPalindromes</pre><p>Let’s test it:</p><a id="I_programlisting9_d1e15315"/><pre class="programlisting">$ ./palindromes
hehe
not a palindrome
ABCBA
palindrome
cookie
not a palindrome</pre><p>Even though we created a program that transforms one big string of input into another, it acts as if we made a program that does it line by line. That’s because Haskell is lazy, and it wants to print the first line of the result string, but it can’t because it doesn’t have the first line of the input yet. So as soon as we give it the first line of input, it prints the first line of the output. We get out of the program by issuing an end-of-line character.</p><p>We can also use this program by just redirecting a file into it. Create the following file and save it as <span class="emphasis"><em>words.txt</em></span>.<a id="IDX-CHP-9-0019" class="indexterm"/><a id="IDX-CHP-9-0020" class="indexterm"/><a id="IDX-CHP-9-0021" class="indexterm"/></p><a id="I_programlisting9_d1e15335"/><pre class="programlisting">dogaroo
radar
rotor
madam</pre><p>This is what we get by redirecting it into our program:</p><a id="I_programlisting9_d1e15339"/><pre class="programlisting">$ ./palindrome &lt; words.txt
not a palindrome
palindrome
palindrome
palindrome</pre><p>Again, we get the same output as if we had run our program and put in the words ourselves at the standard input. We just don’t see the input that our program gets because that input came from the file.</p><p>So now you see how lazy I/O works and how we can use it to our advantage. You can just think in terms of what the output is supposed to be for some given input and write a function to do that transformation. In lazy I/O, nothing is eaten from the input until it absolutely must be, because what we want to print right now depends on that input.</p></div></div></div>
<div class="sect1" title="Reading and Writing Files"><div class="titlepage"><div><div><h1 class="title"><a id="reading_and_writing_files"/>Reading and Writing Files</h1></div></div></div><p>So far, we’ve worked with I/O by printing stuff to the terminal and reading from it. But what about reading and writing files? Well, in a way, we’ve already been doing that.<a id="IDX-CHP-9-0022" class="indexterm"/><a id="IDX-CHP-9-0023" class="indexterm"/><a id="IDX-CHP-9-0024" class="indexterm"/></p><p>One way to think about reading from the terminal is that it’s like reading from a (somewhat special) file. The same goes for writing to the terminal— it’s kind of like writing to a file. We can call these two files <span class="emphasis"><em>stdout</em></span> and <span class="emphasis"><em>stdin</em></span>, meaning standard output and standard input, respectively. Writing to and reading from files is very much like writing to the standard output and reading from the standard input.<a id="IDX-CHP-9-0025" class="indexterm"/></p><p>We’ll start off with a really simple program that opens a file called <span class="emphasis"><em>girlfriend.txt</em></span>, which contains a verse from Avril Lavigne’s hit song “Girlfriend,” and just prints out to the terminal. Here’s <span class="emphasis"><em>girlfriend.txt</em></span>:</p><a id="I_programlisting9_d1e15385"/><pre class="programlisting">Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!</pre><p>And here’s our program:</p><a id="I_programlisting9_d1e15389"/><pre class="programlisting">import System.IO

main = do
    handle &lt;- openFile "girlfriend.txt" ReadMode
    contents &lt;- hGetContents handle
    putStr contents
    hClose handle</pre><p>If we compile and run it, we get the expected result:</p><a id="I_programlisting9_d1e15393"/><pre class="programlisting">$ ./girlfriend
Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!</pre><p>Let’s go over this line by line. The first line is just four exclamations, to get our attention. In the second line, Avril tells us that she doesn’t like our current partner of the female persuasion. The third line serves to emphasize that disapproval, and the fourth line suggests we should go about finding a suitable replacement.</p><p>Let’s also go over the program line by line. Our program is several I/O actions glued together with a <code class="literal">do</code> block. In the first line of the <code class="literal">do</code> block is a new function called <code class="literal">openFile</code>. It has the following type signature:</p><a id="I_programlisting9_d1e15409"/><pre class="programlisting">openFile :: FilePath -&gt; IOMode -&gt; IO Handle</pre><p><code class="literal">openFile</code> takes a file path and an <code class="literal">IOMode</code> and returns an I/O action that will open a file and yield the file’s associated handle as its result. <code class="literal">FilePath</code> is just a type synonym for <code class="literal">String</code>, defined as follows:</p><a id="I_programlisting9_d1e15424"/><pre class="programlisting">type FilePath = String</pre><p><code class="literal">IOMode</code> is a type that’s defined like this:</p><a id="I_programlisting9_d1e15430"/><pre class="programlisting">data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode</pre><p>Just like our type that represents the seven possible values for the days of the week, this type is an enumeration that represents what we want to do with our opened file. Notice that this type is <code class="literal">IOMode</code> and not <code class="literal">IO Mode</code>. <code class="literal">IO Mode</code> would be the type of I/O action that yields a value of some type <code class="literal">Mode</code> as its result. <code class="literal">IOMode</code> is just a simple enumeration.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e15450"/><img src="httpatomoreillycomsourcenostarchimages802622.png.jpg" alt="image with no caption"/></div></div><p>Finally, <code class="literal">openFile</code> returns an I/O action that will open the specified file in the specified mode. If we bind that action’s result to something, we get a <code class="literal">Handle</code>, which represents where our file is. We’ll use that handle so we know which file to read from.<a id="IDX-CHP-9-0026" class="indexterm"/><a id="IDX-CHP-9-0027" class="indexterm"/><a id="IDX-CHP-9-0028" class="indexterm"/><a id="IDX-CHP-9-0029" class="indexterm"/></p><p>In the next line, we have a function called <code class="literal">hGetContents</code>. It takes a <code class="literal">Handle</code>, so it knows which file to get the contents from, and returns an <code class="literal">IO String</code>—an I/O action that holds contents of the file as its result. This function is pretty much like <code class="literal">getContents</code>. The only difference is that <code class="literal">getContents</code> will automatically read from the standard input (that is, from the terminal), whereas <code class="literal">hGetContents</code> takes a file handle that tells it which file to read from. In all other respects, they work the same.</p><p>Just like <code class="literal">getContents</code>, <code class="literal">hGetContents</code> won’t attempt to read all the file at once and store it in memory but will read the content only as needed. This is really cool because we can treat <code class="literal">contents</code> as the whole content of the file, but it’s not really loaded in memory. So if this were a really huge file, doing <code class="literal">hGetContents</code> wouldn’t choke up our memory.</p><p>Note the difference between a handle and the actual contents of the file. A handle just points to our current position in the file. The contents are what’s actually in the file. If you imagine your whole filesystem as a really big book, the handle is like a bookmark that shows where you’re currently reading (or writing).</p><p>With <code class="literal">putStr contents</code>, we print the contents out to the standard output, and then we do <code class="literal">hClose</code>, which takes a handle and returns an I/O action that closes the file. You need to close the file yourself after opening it with <code class="literal">openFile</code>! Your program may terminate if you try to open a file whose handle hasn’t been closed.</p><div class="sect2" title="Using the withFile Function"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_withfile_function"/>Using the withFile Function</h2></div></div></div><p>Another way of working with the contents of a file as we just did is to use the <code class="literal">withFile</code> function, which has the following type signature:</p><a id="I_programlisting9_d1e15534"/><pre class="programlisting">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</pre><p>It takes a path to a file, an <code class="literal">IOMode</code>, and a function that takes a handle and returns some I/O action. Then it returns an I/O action that will open that file, do something with the file, and close it. Furthermore, if anything goes wrong while we’re operating on our file, <code class="literal">withFile</code> makes sure that the file handle gets closed. This might sound a bit complicated, but it’s really simple, especially if we use lambdas.</p><p>Here’s our previous example rewritten to use <code class="literal">withFile</code>:<a id="IDX-CHP-9-0030" class="indexterm"/><a id="IDX-CHP-9-0031" class="indexterm"/><a id="IDX-CHP-9-0032" class="indexterm"/><a id="IDX-CHP-9-0033" class="indexterm"/><a id="IDX-CHP-9-0034" class="indexterm"/></p><a id="I_programlisting9_d1e15568"/><pre class="programlisting">import System.IO

main = do
    withFile "girlfriend.txt" ReadMode (\handle -&gt; do
        contents &lt;- hGetContents handle
        putStr contents)</pre><p><code class="literal">(\handle -&gt; ...)</code> is the function that takes a handle and returns an I/O action, and it’s usually done like this, with a lambda. It needs to take a function that returns an I/O action, rather than just taking an I/O action to do and then closing the file, because the I/O action that we would pass to it wouldn’t know on which file to operate. This way, <code class="literal">withFile</code> opens the file and then passes the handle to the function we gave it. It gets an I/O action back from that function and then makes an I/O action that’s just like the original action, but it also makes sure that the file handle gets closed, even if something goes awry.</p></div><div class="sect2" title="It's Bracket Time"><div class="titlepage"><div><div><h2 class="title"><a id="it_apostrophy_s_bracket_time"/>It's Bracket Time</h2></div></div></div><p>Usually, if a piece of code calls <code class="literal">error</code> (such as when we try to apply <code class="literal">head</code> to an empty list) or if something goes very wrong when doing input and output, our program terminates, and we see some sort of error message. In such circumstances, we say that an <span class="emphasis"><em>exception</em></span> gets raised. The <code class="literal">withFile</code> function makes sure that despite an exception being raised, the file handle is closed.</p><p>This sort of scenario comes up often. We acquire some resource (like a file handle), and we want to do something with it, but we also want to make sure that the resource gets released (for example, the file handle is closed). Just for such cases, the <code class="literal">Control.Exception</code> module offers the <code class="literal">bracket</code> function. It has the following type signature:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e15603"/><img src="httpatomoreillycomsourcenostarchimages802624.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting9_d1e15608"/><pre class="programlisting">bracket :: IO a -&gt; (a -&gt; IO b) -&gt; (a -&gt; IO c) -&gt; IO c</pre><p>Its first parameter is an I/O action that acquires a resource, such as a file handle. Its second parameter is a function that releases that resource. This function gets called even if an exception has been raised. The third parameter is a function that also takes that resource and does something with it. The third parameter is where the main stuff happens, like reading from a file or writing to it.</p><p>Because <code class="literal">bracket</code> is all about acquiring a resource, doing something with it, and making sure it gets released, implementing <code class="literal">withFile</code> is really easy:<a id="IDX-CHP-9-0035" class="indexterm"/><a id="IDX-CHP-9-0036" class="indexterm"/><a id="IDX-CHP-9-0037" class="indexterm"/><a id="IDX-CHP-9-0038" class="indexterm"/></p><a id="I_programlisting9_d1e15636"/><pre class="programlisting">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
withFile name mode f = bracket (openFile name mode)
    (\handle -&gt; hClose handle)
    (\handle -&gt; f handle)</pre><p>The first parameter that we pass to <code class="literal">bracket</code> opens the file, and its result is a file handle. The second parameter takes that handle and closes it. <code class="literal">bracket</code> makes sure that this happens even if an exception is raised. Finally, the third parameter to <code class="literal">bracket</code> takes a handle and applies the function <code class="literal">f</code> to it, which takes a file handle and does stuff with that handle, like reading from or writing to the corresponding file.</p></div><div class="sect2" title="Grab the Handles!"><div class="titlepage"><div><div><h2 class="title"><a id="grab_the_handles_exclamation"/>Grab the Handles!</h2></div></div></div><p>Just as <code class="literal">hGetContents</code> works like <code class="literal">getContents</code> but for a specific file, functions like <code class="literal">hGetLine</code>, <code class="literal">hPutStr</code>, <code class="literal">hPutStrLn</code>, <code class="literal">hGetChar</code>, and so on work just like their counterparts without the <code class="literal">h</code> but take only a handle as a parameter and operate on that specific file instead of on standard input or standard output. For example, <code class="literal">putStrLn</code> takes a string and returns an I/O action that will print out that string to the terminal and a newline after it. <code class="literal">hPutStrLn</code> takes a handle and a string and returns an I/O action that will write that string to the file associated with the handle and then put a newline after it. In the same vein, <code class="literal">hGetLine</code> takes a handle and returns an I/O action that reads a line from its file.</p><p>Loading files and then treating their contents as strings is so common that we have three nice little functions to make our work even easier: <code class="literal">readFile</code>, <code class="literal">writeFile</code>, and <code class="literal">appendFile.</code></p><p>The <code class="literal">readFile</code> function has a type signature of <code class="literal">readFile :: FilePath -&gt; IO String</code>. (Remember that <code class="literal">FilePath</code> is just a fancy name for <code class="literal">String</code>.) <code class="literal">readFile</code> takes a path to a file and returns an I/O action that will read that file (lazily, of course) and bind its contents to something as a string. It’s usually more handy than calling <code class="literal">openFile</code> and then calling <code class="literal">hGetContents</code> with the resulting handle. Here’s how we could have written our previous example with <code class="literal">readFile</code>:</p><a id="I_programlisting9_d1e15725"/><pre class="programlisting">import System.IO

main = do
    contents &lt;- readFile "girlfriend.txt"
    putStr contents</pre><p>Because we don’t get a handle with which to identify our file, we can’t close it manually, so Haskell does that for us when we use <code class="literal">readFile</code>.</p><p>The <code class="literal">writeFile</code> function has a type of <code class="literal">writeFile :: FilePath -&gt; String -&gt; IO ()</code>. It takes a path to a file and a string to write to that file and returns an I/O action that will do the writing. If such a file already exists, it will be stomped down to zero length before being written to. Here’s how to turn <span class="emphasis"><em>girlfriend.txt</em></span> into a caps-locked version and write it to <span class="emphasis"><em>girlfriendcaps.txt</em></span>:<a id="IDX-CHP-9-0039" class="indexterm"/><a id="IDX-CHP-9-0040" class="indexterm"/><a id="IDX-CHP-9-0041" class="indexterm"/><a id="IDX-CHP-9-0042" class="indexterm"/><a id="IDX-CHP-9-0043" class="indexterm"/><a id="IDX-CHP-9-0044" class="indexterm"/><a id="IDX-CHP-9-0045" class="indexterm"/><a id="IDX-CHP-9-0046" class="indexterm"/><a id="IDX-CHP-9-0047" class="indexterm"/><a id="IDX-CHP-9-0048" class="indexterm"/><a id="IDX-CHP-9-0049" class="indexterm"/><a id="IDX-CHP-9-0050" class="indexterm"/><a id="IDX-CHP-9-0051" class="indexterm"/><a id="IDX-CHP-9-0052" class="indexterm"/><a id="IDX-CHP-9-0053" class="indexterm"/></p><a id="I_programlisting9_d1e15807"/><pre class="programlisting">import System.IO
import Data.Char

main = do
    contents &lt;- readFile "girlfriend.txt"
    writeFile "girlfriendcaps.txt" (map toUpper contents)</pre><p>The <code class="literal">appendFile</code> function has the same type signature as <code class="literal">writeFile</code> and acts almost the same way. The only difference is that <code class="literal">appendFile</code> doesn’t truncate the file to zero length if it already exists. Instead, it appends stuff to the end of that file.</p></div></div>
<div class="sect1" title="To-Do Lists"><div class="titlepage"><div><div><h1 class="title"><a id="to-do_lists"/>To-Do Lists</h1></div></div></div><p>Let’s put the <code class="literal">appendFile</code> function to use by making a program that adds a task to a text file that lists stuff that we have to do. We’ll assume that the file is named <span class="emphasis"><em>todo.txt</em></span> and that it contains one task per line. Our program will take a line from the standard input and add it to our to-do list:</p><a id="I_programlisting9_d1e15831"/><pre class="programlisting">import System.IO

main = do
    todoItem &lt;- getLine
    appendFile "todo.txt" (todoItem ++ "\n")</pre><p>Notice that we added the <code class="literal">"\n"</code> to the end of each line, because <code class="literal">getLine</code> doesn’t give us a newline character at the end.</p><p>Save the file as <span class="emphasis"><em>appendtodo.hs</em></span>, compile it, and then run it a few times and give it some to-do items.</p><a id="I_programlisting9_d1e15846"/><pre class="programlisting">$ ./appendtodo
Iron the dishes
$ ./appendtodo
Dust the dog
$ ./appendtodo
Take salad out of the oven
$ cat todo.txt
Iron the dishes
Dust the dog
Take salad out of the oven</pre><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">cat</code> is a program on Unix-type systems that can be used to print text files to the terminal. On Windows systems, you can use your favorite text editor to see what’s inside <span class="emphasis"><em>todo.txt</em></span> at any given time.<a id="IDX-CHP-9-0054" class="indexterm"/></p></div><div class="sect2" title="Deleting Items"><div class="titlepage"><div><div><h2 class="title"><a id="deleting_items"/>Deleting Items</h2></div></div></div><p>We already made a program to add a new item to our to-do list in <span class="emphasis"><em>todo.txt</em></span>. Now let’s make a program to remove an item. We’ll use a few new functions from <code class="literal">System.Directory</code> and one new function from <code class="literal">System.IO</code>, which will all be explained after the code listing.</p><a id="I_programlisting9_d1e15875"/><pre class="programlisting">import System.IO
import System.Directory
import Data.List

main = do
    contents &lt;- readFile "todo.txt"
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line)
                                    [0..] todoTasks
    putStrLn "These are your TO-DO items:"
    mapM_ putStrLn numberedTasks
    putStrLn "Which one do you want to delete?"
    numberString &lt;- getLine
    let number = read numberString
        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    hPutStr tempHandle newTodoItems
    hClose tempHandle
    removeFile "todo.txt"
    renameFile tempName "todo.txt"</pre><p>First, we read <span class="emphasis"><em>todo.txt</em></span> and bind its contents to <code class="literal">contents</code>. Then we split the contents into a list of strings, with one line for each string. So <code class="literal">todoTasks</code> is now something like this:</p><a id="I_programlisting9_d1e15888"/><pre class="programlisting">["Iron the dishes", "Dust the dog", "Take salad out of the oven"]</pre><p>We zip the numbers from <code class="literal">0</code> onward and that list with a function that takes a number (like <code class="literal">3</code>) and a string (like <code class="literal">"hey"</code>) and returns a new string (like <code class="literal">"3 - hey"</code>). Now <code class="literal">numberedTasks</code> looks like this:</p><a id="I_programlisting9_d1e15907"/><pre class="programlisting">["0 - Iron the dishes"
,"1 - Dust the dog"
,"2 - Take salad out of the oven"
]</pre><p>We then use <code class="literal">mapM_ putStrLn numberedTasks</code> to print each task on a separate line, ask the user which one to delete, and wait for the user to enter a number. Let’s say we want to delete number <code class="literal">1</code> (<code class="literal">Dust the dog</code>), so we punch in <code class="literal">1</code>. <code class="literal">numberString</code> is now <code class="literal">"1"</code>, and because we want a number rather than a string, we apply <code class="literal">read</code> to that to get <code class="literal">1</code> and use a <code class="literal">let</code> to bind that to <code class="literal">number</code>.<a id="IDX-CHP-9-0055" class="indexterm"/><a id="IDX-CHP-9-0056" class="indexterm"/><a id="IDX-CHP-9-0057" class="indexterm"/><a id="IDX-CHP-9-0058" class="indexterm"/><a id="IDX-CHP-9-0059" class="indexterm"/><a id="IDX-CHP-9-0060" class="indexterm"/></p><p>Remember the <code class="literal">delete</code> and <code class="literal">!!</code> functions from <code class="literal">Data.List</code>? <code class="literal">!!</code> returns an element from a list with some index. <code class="literal">delete</code> deletes the first occurrence of an element in a list and returns a new list without that occurrence. <code class="literal">(todoTasks !! number)</code> results in <code class="literal">"Dust the dog"</code>. We delete the the first occurrence of <code class="literal">"Dust the dog"</code> from <code class="literal">todoTasks</code> and then join that into a single line with <code class="literal">unlines</code> and name that <code class="literal">newTodoItems</code>.</p><p>Then we use a function that we haven’t met before, from <code class="literal">System.IO</code>: <code class="literal">openTempFile</code>. Its name is pretty self-explanatory. It takes a path to a temporary directory and a template name for a file and opens a temporary file. We used <code class="literal">"."</code> for the temporary directory, because <code class="literal">.</code> denotes the current directory on just about any operating system. We used <code class="literal">"temp"</code> as the template name for the temporary file, which means that the temporary file will be named <span class="emphasis"><em>temp</em></span> plus some random characters. It returns an I/O action that makes the temporary file, and the result in that I/O action is a pair of values: the name of the temporary file and a handle. We could just open a normal file called <span class="emphasis"><em>todo2.txt</em></span> or something like that, but it’s better practice to use <code class="literal">openTempFile</code> so you know you’re probably not overwriting anything.</p><p>Now that we have a temporary file opened, we write <code class="literal">newTodoItems</code> to it. The old file is unchanged, and the temporary file contains all the lines that the old one does, except the one we deleted.</p><p>After that, we close both the original and the temporary files, and remove the original one with <code class="literal">removeFile</code>, which takes a path to a file and deletes it. After deleting the old <span class="emphasis"><em>todo.txt</em></span>, we use <code class="literal">renameFile</code> to rename the temporary file to <span class="emphasis"><em>todo.txt</em></span>. <code class="literal">removeFile</code> and <code class="literal">renameFile</code> (which are both in <code class="literal">System.Directory</code>) take file paths, not handles, as their parameters.</p><p>Save this as <span class="emphasis"><em>deletetodo.hs</em></span>, compile it, and try it:</p><a id="I_programlisting9_d1e16065"/><pre class="programlisting">$ ./deletetodo
These are your TO-DO items:
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
Which one do you want to delete?
1</pre><p>Now let’s see which items remain:</p><a id="I_programlisting9_d1e16069"/><pre class="programlisting">$ cat todo.txt
Iron the dishes
Take salad out of the oven</pre><p>Ah, cool! Let’s delete one more item:<a id="IDX-CHP-9-0061" class="indexterm"/><a id="IDX-CHP-9-0062" class="indexterm"/><a id="IDX-CHP-9-0063" class="indexterm"/><a id="IDX-CHP-9-0064" class="indexterm"/></p><a id="I_programlisting9_d1e16089"/><pre class="programlisting">$ ./deletetodo
These are your TO-DO items:
0 - Iron the dishes
1 - Take salad out of the oven
Which one do you want to delete?
0</pre><p>And examining the file, we see that only one item remains:</p><a id="I_programlisting9_d1e16093"/><pre class="programlisting">$ cat todo.txt
Take salad out of the oven</pre><p>So, everything is working. However, there’s one thing that about this program that’s kind of off. If something goes wrong after we open our temporary file, the program terminates, but the temporary file doesn’t get cleaned up. Let’s remedy that.</p></div><div class="sect2" title="Cleaning Up"><div class="titlepage"><div><div><h2 class="title"><a id="cleaning_up"/>Cleaning Up</h2></div></div></div><p>To make sure our temporary file is cleaned up in case of a problem, we’re going to use the <code class="literal">bracketOnError</code> function from <code class="literal">Control.Exception</code>. It’s very similar to <code class="literal">bracket</code>, but whereas the <code class="literal">bracket</code> will acquire a resource and then make sure that some cleanup always gets done after we’ve used it, <code class="literal">bracketOnError</code> performs the cleanup only if an exception has been raised. Here’s the code:</p><a id="I_programlisting9_d1e16117"/><pre class="programlisting">import System.IO
import System.Directory
import Data.List
import Control.Exception

main = do
    contents &lt;- readFile "todo.txt"
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line)
                                    [0..] todoTasks
    putStrLn "These are your TO-DO items:"
    mapM_ putStrLn numberedTasks
    putStrLn "Which one do you want to delete?"
    numberString &lt;- getLine
    let number = read numberString
        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks
    bracketOnError (openTempFile "." "temp")
        (\(tempName, tempHandle) -&gt; do
            hClose tempHandle
            removeFile tempName)
        (\(tempName, tempHandle) -&gt; do
            hPutStr tempHandle newTodoItems
            hClose tempHandle
            removeFile "todo.txt"
            renameFile tempName "todo.txt")</pre><p>Instead of just using <code class="literal">openTempFile</code> normally, we use it with <code class="literal">bracketOnError</code>. Next, we write what we want to happen if an error occurs; that is, we want to close the temporary handle and remove the temporary file. Finally, we write what we want to do with the temporary file while things are going well, and these lines are the same as they were before. We write the new items, close the temporary handle, remove our current file, and rename the temporary file.<a id="IDX-CHP-9-0065" class="indexterm"/><a id="IDX-CHP-9-0066" class="indexterm"/><a id="IDX-CHP-9-0067" class="indexterm"/><a id="IDX-CHP-9-0068" class="indexterm"/><a id="IDX-CHP-9-0069" class="indexterm"/><a id="IDX-CHP-9-0070" class="indexterm"/></p></div></div>
<div class="sect1" title="Command-Line Arguments"><div class="titlepage"><div><div><h1 class="title"><a id="command-line_arguments"/>Command-Line Arguments</h1></div></div></div><p>Dealing with command-line arguments is pretty much a necessity if you want to make a script or application that runs on a terminal. Luckily, Haskell’s standard library has a nice way of getting command-line arguments for a program.<a id="IDX-CHP-9-0071" class="indexterm"/></p><p>In the previous section, we made one program for adding an item to our to-do list and one program for removing an item. A problem with them is that we just hardcoded the name of our to-do file. We decided that the file will be named <span class="emphasis"><em>todo.txt</em></span> and that users will never have a need for managing several to-do lists.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e16169"/><img src="httpatomoreillycomsourcenostarchimages802626.png.jpg" alt="image with no caption"/></div></div><p>One solution is to always ask the users which file they want to use as their to-do list. We used that approach when we wanted to know which item to delete. It works, but it’s not the ideal solution because it requires the users to run the program, wait for the program to ask them something, and then give the program some input. That’s called an <span class="emphasis"><em>interactive</em></span> program.</p><p>The difficult bit with interactive command-line programs is this: What if you want to automate the execution of that program, as with a script? It’s harder to make a script that interacts with a program than a script that just calls one or more programs. That’s why we sometimes want users to tell a program what they want when they run the program, instead of having the program ask the user once it’s running. And what better way to have the users tell the program what they want it to do when they run it than via command-line arguments?</p><p>The <code class="literal">System.Environment</code> module has two cool I/O actions that are useful for getting command-line arguments: <code class="literal">getArgs</code> and <code class="literal">getProgName</code>. <code class="literal">getArgs</code> has a type of <code class="literal">getArgs :: IO [String]</code> and is an I/O action that will get the arguments that the program was run with and yield a list of those arguments. <code class="literal">getProgName</code> has a type of <code class="literal">getProgName :: IO String</code> and is an I/O action that yields the program name. Here’s a small program that demonstrates how these two work:<a id="IDX-CHP-9-0072" class="indexterm"/><a id="IDX-CHP-9-0073" class="indexterm"/><a id="IDX-CHP-9-0074" class="indexterm"/></p><a id="I_programlisting9_d1e16218"/><pre class="programlisting">import System.Environment
import Data.List

main = do
   args &lt;- getArgs
   progName &lt;- getProgName
   putStrLn "The arguments are:"
   mapM putStrLn args
   putStrLn "The program name is:"
   putStrLn progName</pre><p>First, we bind the command-line arguments to <code class="literal">args</code> and program name to <code class="literal">progName</code>. Next, we use <code class="literal">putStrLn</code> to print all the program’s arguments and then the name of the program itself. Let’s compile this as <code class="literal">arg-test</code> and try it out:</p><a id="I_programlisting9_d1e16234"/><pre class="programlisting">$ ./arg-test first second w00t "multi word arg"
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test</pre></div>
<div class="sect1" title="More Fun with To-Do Lists"><div class="titlepage"><div><div><h1 class="title"><a id="more_fun_with_to-do_lists"/>More Fun with To-Do Lists</h1></div></div></div><p>In the previous examples, we made one program for adding tasks and an entirely separate program for deleting them. Now we’re going to join that into a single program, and whether it adds or deletes items will depend on the command-line arguments we pass to it. We’ll also make it able to operate on different files, not just <span class="emphasis"><em>todo.txt</em></span>.</p><p>We’ll call our program <code class="literal">todo</code>, and it will be able to do three different things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>View tasks</p></li><li class="listitem"><p>Add tasks</p></li><li class="listitem"><p>Delete tasks</p></li></ul></div><p>To add a task to the <span class="emphasis"><em>todo.txt</em></span> file, we enter it at the terminal:</p><a id="I_programlisting9_d1e16264"/><pre class="programlisting">$ ./todo add todo.txt "Find the magic sword of power"</pre><p>To view the tasks, we enter the <code class="literal">view</code> command:<a id="IDX-CHP-9-0075" class="indexterm"/><a id="IDX-CHP-9-0076" class="indexterm"/><a id="IDX-CHP-9-0077" class="indexterm"/><a id="IDX-CHP-9-0078" class="indexterm"/><a id="IDX-CHP-9-0079" class="indexterm"/><a id="IDX-CHP-9-0080" class="indexterm"/></p><a id="I_programlisting9_d1e16301"/><pre class="programlisting">$ ./todo view todo.txt</pre><p>To remove a task, we use its index:</p><a id="I_programlisting9_d1e16305"/><pre class="programlisting">$ ./todo remove todo.txt 2</pre><div class="sect2" title="A Multitasking Task List"><div class="titlepage"><div><div><h2 class="title"><a id="a_multitasking_task_list"/>A Multitasking Task List</h2></div></div></div><p>We’ll start by making a function that takes a command in the form of a string, like <code class="literal">"add"</code> or <code class="literal">"view"</code>, and returns a function that takes a list of arguments and returns an I/O action that does what we want:</p><a id="I_programlisting9_d1e16318"/><pre class="programlisting">import System.Environment
import System.Directory
import System.IO
import Data.List

dispatch :: String -&gt; [String] -&gt; IO ()
dispatch "add" = add
dispatch "view" = view
dispatch "remove" = remove</pre><p>We’ll define <code class="literal">main</code> like this:</p><a id="I_programlisting9_d1e16325"/><pre class="programlisting">main = do
    (command:argList) &lt;- getArgs
    dispatch command argList</pre><p>First, we get the arguments and bind them to <code class="literal">(command:argList)</code>. This means that the first argument will be bound to <code class="literal">command</code>, and the rest of the arguments will be bound to <code class="literal">argList</code>. In the next line of our <code class="literal">main</code> block, we apply the <code class="literal">dispatch</code> function to the command, which results in the <code class="literal">add</code>, <code class="literal">view</code>, or <code class="literal">remove</code> function. We then apply that function to <code class="literal">argList</code>.</p><p>Suppose we call our program like this:</p><a id="I_programlisting9_d1e16359"/><pre class="programlisting">$ ./todo add todo.txt "Find the magic sword of power"</pre><p><code class="literal">command</code> is <code class="literal">"add"</code>, and <code class="literal">argList</code> is <code class="literal">["todo.txt", "Find the magic sword of power"]</code>. That way, the second pattern match of the <code class="literal">dispatch</code> function will succeed, and it will return the <code class="literal">add</code> function. Finally, we apply that to <code class="literal">argList</code>, which results in an I/O action that adds the item to our to-do list.</p><p>Now let’s implement the <code class="literal">add</code>, <code class="literal">view</code>, and <code class="literal">remove</code> functions. Let’s start with <code class="literal">add</code>:</p><a id="I_programlisting9_d1e16398"/><pre class="programlisting">add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")</pre><p>We might call our program like so:<a id="IDX-CHP-9-0081" class="indexterm"/><a id="IDX-CHP-9-0082" class="indexterm"/></p><a id="I_programlisting9_d1e16413"/><pre class="programlisting">./todo add todo.txt "Find the magic sword of power"</pre><p>The <code class="literal">"add"</code> will be bound to <code class="literal">command</code> in the first pattern match in the <code class="literal">main</code> block, whereas <code class="literal">["todo.txt", "Find the magic sword of power"]</code> will be passed to the function that we get from the <code class="literal">dispatch</code> function. So, because we’re not dealing with bad input right now, we just pattern match against a list with those two elements immediately and return an I/O action that appends that line to the end of the file, along with a newline character.</p><p>Next, let’s implement the list-viewing functionality. If we want to view the items in a file, we do <code class="literal">./todo view todo.txt</code>. So in the first pattern match, <code class="literal">command</code> will be <code class="literal">"view"</code>, and <code class="literal">argList</code> will be <code class="literal">["todo.txt"]</code>. Here’s the function in full:<a id="IDX-CHP-9-0083" class="indexterm"/></p><a id="I_programlisting9_d1e16455"/><pre class="programlisting">view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line)
                        [0..] todoTasks
    putStr $ unlines numberedTasks</pre><p>When we made our <code class="literal">deletetodo</code> program, which could only delete items from a to-do list, it had the ability to display the items in a to-do list, so this code is very similar to that part of the previous program.</p><p>Finally, we’re going to implement <code class="literal">remove</code>. It’s very similar to the program that only deleted the tasks, so if you don’t understand how deleting an item here works, review <a class="xref" href="ch09s03.html#deleting_items" title="Deleting Items">Deleting Items</a> in <a class="xref" href="ch09s03.html#deleting_items" title="Deleting Items">Deleting Items</a>. The main difference is that we’re not hardcoding the filename as <span class="emphasis"><em>todo.txt</em></span> but instead getting it as an argument. We’re also getting the target task number as an argument, rather than prompting the user for it.</p><a id="I_programlisting9_d1e16474"/><pre class="programlisting">remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line)
                                    [0..] todoTasks
    putStrLn "These are your TO-DO items:"
    mapM_ putStrLn numberedTasks
    let number = read numberString
        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks
    bracketOnError (openTempFile "." "temp")
        (\(tempName, tempHandle) -&gt; do
            hClose tempHandle
            removeFile tempName)

        (\(tempName, tempHandle) -&gt; do
            hPutStr tempHandle newTodoItems
            hClose tempHandle
            removeFile "todo.txt"
            renameFile tempName "todo.txt")</pre><p>We opened the file based on <code class="literal">fileName</code> and opened a temporary file, deleted the line with the index that the user wants to delete, wrote that to the temporary file, removed the original file, and renamed the temporary file back to <code class="literal">fileName</code>.<a id="IDX-CHP-9-0084" class="indexterm"/></p><p>Here’s the whole program in all its glory:</p><a id="I_programlisting9_d1e16489"/><pre class="programlisting">import System.Environment
import System.Directory
import System.IO
import Data.List

dispatch :: String -&gt; [String] -&gt; IO ()
dispatch "add" = add
dispatch "view" = view
dispatch "remove" = remove

main = do
    (command:argList) &lt;- getArgs
    dispatch command argList

add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")

view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line)
                        [0..] todoTasks
    putStr $ unlines numberedTasks

remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line)
                                    [0..] todoTasks
    putStrLn "These are your TO-DO items:"
    mapM_ putStrLn numberedTasks
    let number = read numberString
        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks
    bracketOnError (openTempFile "." "temp")
        (\(tempName, tempHandle) -&gt; do
            hClose tempHandle
            removeFile tempName)
        (\(tempName, tempHandle) -&gt; do
            hPutStr tempHandle newTodoItems
            hClose tempHandle
            removeFile "todo.txt"
            renameFile tempName "todo.txt")</pre><p>To summarize our solution, we made a <code class="literal">dispatch</code> function that maps from commands to functions that take some command-line arguments in the form of a list and return an I/O action. We see what the <code class="literal">command</code> is, and based on that, we get the appropriate function from the <code class="literal">dispatch</code> function. We call that function with the rest of the command-line arguments to get back an I/O action that will do the appropriate thing, and then just perform that action. Using higher-order functions allows us to just tell the <code class="literal">dispatch</code> function to give us the appropriate function, and then tell that function to give us an I/O action for some command-line arguments.<a id="IDX-CHP-9-0085" class="indexterm"/><a id="IDX-CHP-9-0086" class="indexterm"/></p><p>Let’s try our app!</p><a id="I_programlisting9_d1e16518"/><pre class="programlisting">$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven

$ ./todo add todo.txt "Pick up children from dry cleaners"

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
3 - Pick up children from dry cleaners

$ ./todo remove todo.txt 2

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Pick up children from dry cleaners :</pre><p>Another cool thing about using the <code class="literal">dispatch</code> function is that it’s easy to add functionality. Just add an extra pattern to <code class="literal">dispatch</code> and implement the corresponding function, and you’re laughing! As an exercise, you can try implementing a <code class="literal">bump</code> function that will take a file and a task number and return an I/O action that bumps that task to the top of the to-do list.</p></div><div class="sect2" title="Dealing with Bad Input"><div class="titlepage"><div><div><h2 class="title"><a id="dealing_with_bad_input"/>Dealing with Bad Input</h2></div></div></div><p>We could extend this program to make it fail a bit more gracefully in the case of bad input, instead of printing out an ugly error message from Haskell. We can start by adding a catchall pattern at the end the <code class="literal">dispatch</code> function and making it return a function that ignores the argument list and tells us that such a command doesn’t exist:<a id="IDX-CHP-9-0087" class="indexterm"/><a id="IDX-CHP-9-0088" class="indexterm"/><a id="IDX-CHP-9-0089" class="indexterm"/></p><a id="I_programlisting9_d1e16553"/><pre class="programlisting">dispatch :: String -&gt; [String] -&gt; IO ()
dispatch "add" = add
dispatch "view" = view
dispatch "remove" = remove
dispatch command = doesntExist command

doesntExist :: String -&gt; [String] -&gt; IO ()
doesntExist command _ =
    putStrLn $ "The " ++ command ++ " command doesn't exist"</pre><p>We might also add catchall patterns to the <code class="literal">add</code>, <code class="literal">view</code>, and <code class="literal">remove</code> functions, so that the program tells users if they have supplied the wrong number of arguments to a given command. Here’s an example:</p><a id="I_programlisting9_d1e16566"/><pre class="programlisting">add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")
add _ = putStrLn "The add command takes exactly two arguments"</pre><p>If <code class="literal">add</code> is applied to a list that doesn’t have exactly two elements, the first pattern match will fail, but the second one will succeed, helpfully informing users of their erronous ways. We can add a catchall pattern like this to <code class="literal">view</code> and <code class="literal">remove</code> as well.</p><p>Note that we haven’t covered all of the cases where our input is bad. For instance, suppose we run our program like this:</p><a id="I_programlisting9_d1e16581"/><pre class="programlisting">./todo</pre><p>In this case, it will crash, because we use the <code class="literal">(command:argList)</code> pattern in our <code class="literal">do</code> block, but that doesn’t consider the possibility that there are no arguments at all! We also don’t check to see if the file we’re operating on exists before trying to open it. Adding these precautions isn’t hard, but it is a bit tedious, so making this program completely idiot-proof is left as an exercise to the reader.</p></div></div>
<div class="sect1" title="Randomness"><div class="titlepage"><div><div><h1 class="title"><a id="randomness"/>Randomness</h1></div></div></div><p>Many times while programming, you need to get some random data (well, <span class="emphasis"><em>pseudo</em></span>-random data, since we all know that the only true source of randomness is a monkey on a unicycle with cheese in one hand and its butt in the other). For example, you may be making a game where a die needs to be thrown, or you need to generate some data to test your program. In this section, we’ll take a look at how to make Haskell generate seemingly random data and why we need external input to generate values that are random enough.<a id="IDX-CHP-9-0090" class="indexterm"/><a id="IDX-CHP-9-0091" class="indexterm"/><a id="IDX-CHP-9-0092" class="indexterm"/><a id="IDX-CHP-9-0093" class="indexterm"/><a id="IDX-CHP-9-0094" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e16623"/><img src="httpatomoreillycomsourcenostarchimages802628.png.jpg" alt="image with no caption"/></div></div><p>Most programming languages have functions that give you back some random number. Each time you call that function, you retrieve a different random number. How about Haskell? Well, remember that Haskell is a purely functional language. That means it has referential transparency. And <span class="emphasis"><em>that</em></span> means a function, if given the same parameters twice, must produce the same result twice. That’s really cool, because it allows us to reason about programs, and it enables us to defer evaluation until we really need it. However, this makes it a bit tricky for getting random numbers.</p><p>Suppose we have a function like this:</p><a id="I_programlisting9_d1e16635"/><pre class="programlisting">randomNumber :: Int
randomNumber = 4</pre><p>It’s not very useful as a random number function, because it will always return <code class="literal">4</code>. (Even though I can assure you that the <code class="literal">4</code> is completely random, because I used a die to determine it.)</p><p>How do other languages make seemingly random numbers? Well, they take some initial data, like the current time, and based on that, generate numbers that are seemingly random. In Haskell, we can generate random numbers by making a function that takes as its parameter some initial data, or randomness, and produces a random number. We use I/O to bring randomness into our program from outside.</p><p>Enter the <code class="literal">System.Random</code> module. It has all the functions that satisfy our need for randomness. Let’s just dive into one of the functions it exports: <code class="literal">random</code>. Here is its type signature:<a id="IDX-CHP-9-0095" class="indexterm"/></p><a id="I_programlisting9_d1e16660"/><pre class="programlisting">random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)</pre><p>Whoa! We have some new type classes in this type declaration! The <code class="literal">RandomGen</code> type class is for types that can act as sources of randomness. The <code class="literal">Random</code> type class is for types whose values can be random. We can generate random Boolean values by randomly producing either <code class="literal">True</code> or <code class="literal">False</code>. We can also generate numbers that are random. Can a function take on a random value? I don’t think so! If we try to translate the type declaration of <code class="literal">random</code> to English, we get something like this: It takes a random generator (that’s our source of randomness) and returns a random value and a new random generator. Why does it also return a new generator as well as a random value? Well, you’ll see in a moment.<a id="IDX-CHP-9-0096" class="indexterm"/><a id="IDX-CHP-9-0097" class="indexterm"/><a id="IDX-CHP-9-0098" class="indexterm"/></p><p>To use our <code class="literal">random</code> function, we need to get our hands on one of those random generators. The <code class="literal">System.Random</code> module exports a cool type, namely <code class="literal">StdGen</code>, which is an instance of the <code class="literal">RandomGen</code> type class. We can make a <code class="literal">StdGen</code> manually, or we can tell the system to give us one based on a multitude of (sort of) random stuff.</p><p>To manually make a random generator, use the <code class="literal">mkStdGen</code> function. It has a type of <code class="literal">mkStdGen :: Int -&gt; StdGen</code>. It takes an integer, and based on that, gives us a random generator. Okay then, let’s try using <code class="literal">random</code> and <code class="literal">mkStdGen</code> in tandem to get a (hardly) random number.<a id="IDX-CHP-9-0099" class="indexterm"/></p><a id="I_programlisting9_d1e16732"/><pre class="programlisting">ghci&gt; random (mkStdGen 100)
&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Random a' arising from a use of `random' at &lt;interactive&gt;:1:0-20
    Probable fix: add a type signature that fixes these type variable(s)</pre><p>What’s this? Ah, right, the <code class="literal">random</code> function can return a value of any type that’s part of the <code class="literal">Random</code> type class, so we need to inform Haskell which type we want. Also let’s not forget that it returns a random value and a random generator in a pair.</p><a id="I_programlisting9_d1e16742"/><pre class="programlisting">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)</pre><p>Finally, a number that looks kind of random! The first component of the tuple is our number, and the second component is a textual representation of our new random generator. What happens if we call random with the same random generator again?</p><a id="I_programlisting9_d1e16746"/><pre class="programlisting">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)</pre><p>Of course, we get the same result for the same parameters. So let’s try giving it a different random generator as a parameter:</p><a id="I_programlisting9_d1e16750"/><pre class="programlisting">ghci&gt; random (mkStdGen 949494) :: (Int, StdGen)
(539963926,466647808 1655838864)</pre><p>Great, a different number! We can use the type annotation to get different types back from that function.</p><a id="I_programlisting9_d1e16754"/><pre class="programlisting">ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)
(0.8938442,1597344447 1655838864)

ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)
(False,1485632275 40692)
ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)
(1691547873,1597344447 1655838864)</pre><div class="sect2" title="Tossing a Coin"><div class="titlepage"><div><div><h2 class="title"><a id="tossing_a_coin"/>Tossing a Coin</h2></div></div></div><p>Let’s make a function that simulates tossing a coin three times. If <code class="literal">random</code> didn’t return a new generator along with a random value, we would need to make this function take three random generators as a parameter and return coin tosses for each of them. But if one generator can make a random value of type <code class="literal">Int</code> (which can take on a load of different values), it should be able to make three coin tosses (which can have only eight different end results). So this is where <code class="literal">random</code> returning a new generator along with a value comes in handy.<a id="IDX-CHP-9-0100" class="indexterm"/><a id="IDX-CHP-9-0101" class="indexterm"/></p><p>We’ll represent a coin with a simple <code class="literal">Bool</code>: <code class="literal">True</code> is tails, and <code class="literal">False</code> is heads.</p><a id="I_programlisting9_d1e16790"/><pre class="programlisting">threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen =
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)</pre><p>We call <code class="literal">random</code> with the generator we got as a parameter to get a coin and a new generator. Then we call it again, only this time with our new generator, to get the second coin. We do the same for the third coin. Had we called it with the same generator every time, all the coins would have had the same value, so we would get only <code class="literal">(False, False, False)</code> or <code class="literal">(True, True, True)</code> as a result.</p><a id="I_programlisting9_d1e16803"/><pre class="programlisting">ghci&gt; threeCoins (mkStdGen 21)
(True,True,True)
ghci&gt; threeCoins (mkStdGen 22)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 943)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 944)
(True,True,True)</pre><p>Notice that we didn’t need to call <code class="literal">random gen :: (Bool, StdGen)</code>. Since we already specified that we want Booleans in the type declaration of the function, Haskell can infer that we want a Boolean value in this case.</p></div><div class="sect2" title="More Random Functions"><div class="titlepage"><div><div><h2 class="title"><a id="more_random_functions"/>More Random Functions</h2></div></div></div><p>What if we want to flip more coins? For that, there’s a function called <code class="literal">randoms</code>, which takes a generator and returns an infinite sequence of values based on that generator.<a id="IDX-CHP-9-0102" class="indexterm"/></p><a id="I_programlisting9_d1e16821"/><pre class="programlisting">ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Int]
[-1807975507,545074951,-1015194702,-1622477312,-502893664]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Bool]
[True,True,True,True,False]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Float]
[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]</pre><p>Why doesn’t <code class="literal">randoms</code> return a new generator as well as a list? We could implement the <code class="literal">randoms</code> function very easily like this:</p><a id="I_programlisting9_d1e16831"/><pre class="programlisting">randoms' :: (RandomGen g, Random a) =&gt; g -&gt; [a]
randoms' gen = let (value, newGen) = random gen in value:randoms' newGen</pre><p>This is a recursive definition. We get a random value and a new generator from the current generator, and then make a list that has the value as its head and random numbers based on the new generator as its tail. Because we need to be able to potentially generate an infinite amount of numbers, we can’t give the new random generator back.<a id="IDX-CHP-9-0103" class="indexterm"/></p><p>We could make a function that generates a finite stream of numbers and a new generator like this:</p><a id="I_programlisting9_d1e16840"/><pre class="programlisting">finiteRandoms :: (RandomGen g, Random a, Num n) =&gt; n -&gt; g -&gt; ([a], g)
finiteRandoms 0 gen = ([], gen)
finiteRandoms n gen =
    let (value, newGen) = random gen
        (restOfList, finalGen) = finiteRandoms (n-1) newGen
    in  (value:restOfList, finalGen)</pre><p>Again, this is a recursive definition. We say that if we want zero numbers, we just return an empty list and the generator that was given to us. For any other number of random values, we first get one random number and a new generator. That will be the head. Then we say that the tail will be <code class="literal">n - 1</code> numbers generated with the new generator. Then we return the head and the rest of the list joined and the final generator that we got from getting the <code class="literal">n - 1</code> random numbers.</p><p>What if we want a random value in some sort of range? All the random integers so far were outrageously big or small. What if we want to throw a die? Well, we use <code class="literal">randomR</code> for that purpose. It has this type:</p><a id="I_programlisting9_d1e16855"/><pre class="programlisting">randomR :: (RandomGen g, Random a) :: (a, a) -&gt; g -&gt; (a, g)</pre><p>This means that it’s kind of like <code class="literal">random</code>, but it takes as its first parameter a pair of values that set the lower and upper bounds, and the final value produced will be within those bounds.<a id="IDX-CHP-9-0104" class="indexterm"/><a id="IDX-CHP-9-0105" class="indexterm"/><a id="IDX-CHP-9-0106" class="indexterm"/><a id="IDX-CHP-9-0107" class="indexterm"/><a id="IDX-CHP-9-0108" class="indexterm"/><a id="IDX-CHP-9-0109" class="indexterm"/><a id="IDX-CHP-9-0110" class="indexterm"/></p><a id="I_programlisting9_d1e16888"/><pre class="programlisting">ghci&gt; randomR (1,6) (mkStdGen 359353)
(6,1494289578 40692)
ghci&gt; randomR (1,6) (mkStdGen 35935335)
(3,1250031057 40692)</pre><p>There’s also <code class="literal">randomRs</code>, which produces a stream of random values within our defined ranges. Check this out:</p><a id="I_programlisting9_d1e16895"/><pre class="programlisting">ghci&gt; take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]
"ndkxbvmomg"</pre><p>It looks like a super secret password, doesn’t it?</p></div><div class="sect2" title="Randomness and I/O"><div class="titlepage"><div><div><h2 class="title"><a id="randomness_and_i_solidus_o"/>Randomness and I/O</h2></div></div></div><p>You may be wondering what this section has to do with I/O. We haven’t done anything concerning I/O so far. We’ve always made our random number generator manually by creating it with some arbitrary integer. The problem is that if we do that in our real programs, they will always return the same random numbers, which is no good for us. That’s why <code class="literal">System.Random</code> offers the <code class="literal">getStdGen</code> I/O action, which has a type of <code class="literal">IO StdGen</code>. It asks the system for some initial data and uses it to jump-start the <span class="emphasis"><em>global generator</em></span>. <code class="literal">getStdGen</code> fetches that global random generator when you bind it to something.</p><p>Here’s a simple program that generates a random string:</p><a id="I_programlisting9_d1e16921"/><pre class="programlisting">import System.Random

main = do
    gen &lt;- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)</pre><p>Now let’s test it:</p><a id="I_programlisting9_d1e16925"/><pre class="programlisting">$ ./random_string
pybphhzzhuepknbykxhe
$ ./random_string
eiqgcxykivpudlsvvjpg
$ ./random_string
nzdceoconysdgcyqjruo
$ ./random_string
bakzhnnuzrkgvesqplrx</pre><p>But you need to be careful. Just performing <code class="literal">getStdGen</code> twice will ask the system for the same global generator twice. Suppose we do this:<a id="IDX-CHP-9-0111" class="indexterm"/><a id="IDX-CHP-9-0112" class="indexterm"/><a id="IDX-CHP-9-0113" class="indexterm"/><a id="IDX-CHP-9-0114" class="indexterm"/></p><a id="I_programlisting9_d1e16950"/><pre class="programlisting">import System.Random

main = do
    gen &lt;- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen2 &lt;- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen2)</pre><p>We will get the same string printed out twice!</p><p>The best way to get two different strings is to use the <code class="literal">newStdGen</code> action, which splits our current random generator into two generators. It updates the global random generator with one of them and yields the other as its result.</p><a id="I_programlisting9_d1e16959"/><pre class="programlisting">import System.Random

main = do
    gen &lt;- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen' &lt;- newStdGen
    putStr $ take 20 (randomRs ('a','z') gen')</pre><p>Not only do we get a new random generator when we bind <code class="literal">newStdGen</code> to something, but the global one gets updated as well. This means that if we do <code class="literal">getStdGen</code> again and bind it to something, we’ll get a generator that’s not the same as <code class="literal">gen</code>.</p><p>Here’s a little program that will make the user guess which number it’s thinking of:</p><a id="I_programlisting9_d1e16975"/><pre class="programlisting">import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    askForNumber gen

askForNumber :: StdGen -&gt; IO ()
askForNumber gen = do
    let (randNumber, newGen) = randomR (1,10) gen :: (Int, StdGen)
    putStrLn "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString

        if randNumber == number
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        askForNumber newGen</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e16978"/><img src="httpatomoreillycomsourcenostarchimages802630.png.jpg" alt="image with no caption"/></div></div><p>We make a function <code class="literal">askForNumber</code>, which takes a random number generator and returns an I/O action that will prompt you for a number, and then tell you if you guessed it right.<a id="IDX-CHP-9-0115" class="indexterm"/></p><p>In <code class="literal">askForNumber</code>, we first generate a random number and a new generator based on the generator that we got as a parameter and call them <code class="literal">randNumber</code> and <code class="literal">newGen</code>. (For this example, let’s say that the number generated was 7.) Then we tell the user to guess which number we’re thinking of. We perform <code class="literal">getLine</code> and bind its result to <code class="literal">numberString</code>. When the user enters <code class="literal">7</code>, <code class="literal">numberString</code> becomes <code class="literal">"7"</code>. Next, we use <code class="literal">when</code> to check if the string the user entered is an empty string. If it isn’t, the action consisting of the <code class="literal">do</code> block that is passed to <code class="literal">when</code> is performed. We use <code class="literal">read</code> on <code class="literal">numberString</code> to convert it to a number, so <code class="literal">number</code> is now <code class="literal">7</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If the user enters some input that <code class="literal">read</code> can’t parse (like <code class="literal">"haha"</code>), our program will crash with an ugly error message. If you don’t want your program to crash on erronous input, use <code class="literal">reads</code>, which returns an empty list when it fails to read a string. When it succeeds, it returns a singleton list with a tuple that has your desired value as one component and a string with what it didn’t consume as the other. Try it!</p></div><p>We check if the number that we entered is equal to the one generated randomly and give the user the appropriate message. Then we perform <code class="literal">askForNumber</code> recursively, but this time with the new generator that we got. This gives us an I/O action that’s just like the one we performed, except that it depends on a different generator.</p><p><code class="literal">main</code> consists of just getting a random generator from the system and calling <code class="literal">askForNumber</code> with it to get the initial action.</p><p>Here’s our program in action:</p><a id="I_programlisting9_d1e17066"/><pre class="programlisting">$ ./guess_the_number
Which number in the range from 1 to 10 am I thinking of?
4
Sorry, it was 3
Which number in the range from 1 to 10 am I thinking of?
10
You are correct!
Which number in the range from 1 to 10 am I thinking of?
2
Sorry, it was 4
Which number in the range from 1 to 10 am I thinking of?
5
Sorry, it was 10
Which number in the range from 1 to 10 am I thinking of?</pre><p>Here’s another way to make this same program:<a id="IDX-CHP-9-0116" class="indexterm"/><a id="IDX-CHP-9-0117" class="indexterm"/><a id="IDX-CHP-9-0118" class="indexterm"/><a id="IDX-CHP-9-0119" class="indexterm"/><a id="IDX-CHP-9-0120" class="indexterm"/><a id="IDX-CHP-9-0121" class="indexterm"/><a id="IDX-CHP-9-0122" class="indexterm"/></p><a id="I_programlisting9_d1e17096"/><pre class="programlisting">import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    let (randNumber, _) = randomR (1,10) gen :: (Int, StdGen)
    putStrLn "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        newStdGen
        main</pre><p>It’s very similar to the previous version, but instead of making a function that takes a generator and then calls itself recursively with the new updated generator, we do all the work in <code class="literal">main</code>. After telling the user whether he was correct in his guess, we update the global generator and then call <code class="literal">main</code> again. Both approaches are valid, but I like the first one more since it does less stuff in <code class="literal">main</code> and also provides a function I can reuse easily.</p></div></div>
<div class="sect1" title="Bytestrings"><div class="titlepage"><div><div><h1 class="title"><a id="bytestrings"/>Bytestrings</h1></div></div></div><p>Lists are certainly useful. So far, we’ve used them pretty much everywhere. There are a multitude of functions that operate on them, and Haskell’s laziness allows us to exchange the <code class="literal">for</code> and <code class="literal">while</code> loops of other languages for filtering and mapping over lists. Since evaluation will happen only when it really needs to, things like infinite lists (and even infinite lists of infinite lists!) are no problem for us. That’s why lists can also be used to represent streams, either when reading from the standard input or when reading from files. We can just open a file and read it as a string, even though it will be accessed only when the need arises.<a id="IDX-CHP-9-0123" class="indexterm"/><a id="IDX-CHP-9-0124" class="indexterm"/><a id="IDX-CHP-9-0125" class="indexterm"/><a id="IDX-CHP-9-0126" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e17135"/><img src="httpatomoreillycomsourcenostarchimages802632.png.jpg" alt="image with no caption"/></div></div><p>However, processing files as strings has one drawback: It tends to be slow. Lists are really lazy. Remember that a list like <code class="literal">[1,2,3,4]</code> is syntactic sugar for <code class="literal">1:2:3:4:[]</code>. When the first element of the list is forcibly evaluated (say by printing it), the rest of the list <code class="literal">2:3:4:[]</code> is still just a promise of a list, and so on. We call that promise a <span class="emphasis"><em>thunk</em></span>.<a id="IDX-CHP-9-0127" class="indexterm"/><a id="IDX-CHP-9-0128" class="indexterm"/></p><p>A thunk is basically a deferred computation. Haskell achieves its laziness by using thunks and computing them only when it must, instead of computing everything up front. So you can think of lists as promises that the next element will be delivered once it really has to be, and along with it, the promise of the element after it. It doesn’t take a big mental leap to conclude that processing a simple list of numbers as a series of thunks might not be the most efficient technique in the world.<a id="IDX-CHP-9-0129" class="indexterm"/><a id="IDX-CHP-9-0130" class="indexterm"/></p><p>That overhead doesn’t bother us most of the time, but it turns out to be a liability when reading big files and manipulating them. That’s why Haskell has <span class="emphasis"><em>bytestrings</em></span>. Bytestrings are sort of like lists, only each element is one byte (or 8 bits) in size. The way they handle laziness is also different.</p><div class="sect2" title="Strict and Lazy Bytestrings"><div class="titlepage"><div><div><h2 class="title"><a id="strict_and_lazy_bytestrings"/>Strict and Lazy Bytestrings</h2></div></div></div><p>Bytestrings come in two flavors: strict and lazy. Strict bytestrings reside in <code class="literal">Data.ByteString</code>, and they do away with the laziness completely. There are no thunks involved. A strict bytestring represents a series of bytes in an array. You can’t have things like infinite strict bytestrings. If you evaluate the first byte of a strict bytestring, you must evaluate the whole thing.<a id="IDX-CHP-9-0131" class="indexterm"/></p><p>The other variety of bytestrings resides in <code class="literal">Data.ByteString.Lazy</code>. They’re lazy, but not quite as lazy as lists. Since there are as many thunks in a list as there are elements, they are kind of slow for some purposes. Lazy bytestrings take a different approach. They are stored in chunks (not to be confused with thunks!), and each chunk has a size of 64KB. So if you evaluate a byte in a lazy bytestring (by printing it, for example), the first 64KB will be evaluated. After that, it’s just a promise for the rest of the chunks. Lazy bytestrings are kind of like lists of strict bytestrings, with a size of 64KB. When you process a file with lazy bytestrings, it will be read chunk by chunk. This is cool because it won’t cause the memory usage to skyrocket, and the 64KB probably fits neatly into your CPU’s L2 cache.</p><p>If you look through the documentation for <code class="literal">Data.ByteString.Lazy</code>, you will see that it has a lot of functions with the same names as the ones from <code class="literal">Data.List</code>, but the type signatures have <code class="literal">ByteString</code> instead of <code class="literal">[a]</code> and <code class="literal">Word8</code> instead of <code class="literal">a</code>. These functions are similar to the ones that work on lists. Because the names are the same, we’re going to do a qualified import in a script and then load that script into GHCi to play with bytestrings:</p><a id="I_programlisting9_d1e17218"/><pre class="programlisting">import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString as S</pre><p><code class="literal">B</code> has lazy bytestring types and functions, whereas <code class="literal">S</code> has strict ones. We’ll mostly be using the lazy versions.<a id="IDX-CHP-9-0132" class="indexterm"/><a id="IDX-CHP-9-0133" class="indexterm"/><a id="IDX-CHP-9-0134" class="indexterm"/><a id="IDX-CHP-9-0135" class="indexterm"/></p><p>The <code class="literal">pack</code> function has the type signature <code class="literal">pack :: [Word8] -&gt; ByteString</code>. This means that it takes a list of bytes of type <code class="literal">Word8</code> and returns a <code class="literal">ByteString</code>. You can think of it as taking a list, which is lazy, and making it less lazy, so that it’s lazy only at 64KB intervals.</p><p>The <code class="literal">Word8</code> type is like <code class="literal">Int</code>, but it represents an unsigned 8-bit number. This means that it has a much smaller range of only 0 to 255. And just like <code class="literal">Int</code>, it’s in the <code class="literal">Num</code> type class. For instance, we know that the value <code class="literal">5</code> is polymorphic in that it can act like any numeric type, including <code class="literal">Word8</code>.</p><p>Here’s how we pack lists of numbers into bytestrings:</p><a id="I_programlisting9_d1e17280"/><pre class="programlisting">ghci&gt; B.pack [99,97,110]
Chunk "can" Empty
ghci&gt; B.pack [98..120]
Chunk "bcdefghijklmnopqrstuvwx" Empty</pre><p>We packed only a handful of values into a bytestring, so they fit inside one chunk. <code class="literal">Empty</code> is like <code class="literal">[]</code> for lists—they both represent an empty sequence.</p><p>As you can see, you don’t need to specify that your numbers are of type <code class="literal">Word8</code>, because the type system can make numbers choose that type. If you try to use a big number like <code class="literal">336</code> as a <code class="literal">Word8</code>, it will just wrap around to <code class="literal">80</code>.</p><p>When we need to examine a bytestring byte by byte, we need to unpack it. The <code class="literal">unpack</code> function is the inverse of <code class="literal">pack</code>. It takes a bytestring and turns it into a list of bytes.</p><p>Here’s an example:</p><a id="I_programlisting9_d1e17315"/><pre class="programlisting">ghci&gt; let by = B.pack [98,111,114,116]
ghci&gt; by
Chunk "bort" Empty
ghci&gt; B.unpack by
[98,111,114,116]</pre><p>You can also go back and forth between strict and lazy bytestrings. The <code class="literal">toChunks</code> function takes a lazy bytestring and converts it to a list of strict ones. The <code class="literal">fromChunks</code> function takes a list of strict bytestrings and converts it to a lazy bytestring:</p><a id="I_programlisting9_d1e17325"/><pre class="programlisting">ghci&gt; B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]
Chunk "()*" (Chunk "+,-" (Chunk "./0" Empty))</pre><p>This is good if you have a lot of small strict bytestrings and you want to process them efficiently without joining them into one big strict bytestring in memory first.</p><p>The bytestring version of <code class="literal">:</code> is called <code class="literal">cons</code>. It takes a byte and a bytestring and puts the byte at the beginning.<a id="IDX-CHP-9-0136" class="indexterm"/><a id="IDX-CHP-9-0137" class="indexterm"/></p><a id="I_programlisting9_d1e17351"/><pre class="programlisting">ghci&gt; B.cons 85 $ B.pack [80,81,82,84]
Chunk "U" (Chunk "PQRT" Empty)</pre><p>The bytestring modules have a load of functions that are analogous to those in <code class="literal">Data.List</code>, including, but not limited to, <code class="literal">head</code>, <code class="literal">tail</code>, <code class="literal">init</code>, <code class="literal">null</code>, <code class="literal">length</code>, <code class="literal">map</code>, <code class="literal">reverse</code>, <code class="literal">foldl</code>, <code class="literal">foldr</code>, <code class="literal">concat</code>, <code class="literal">takeWhile</code>, <code class="literal">filter</code>, and so on. For a complete listing of bytestring functions, check out the documentation for the bytestring package at <a class="ulink" href="http://hackage.haskell.org/package/bytestring/">http://hackage.haskell.org/package/bytestring/</a>.<a id="IDX-CHP-9-0138" class="indexterm"/><a id="IDX-CHP-9-0139" class="indexterm"/><a id="IDX-CHP-9-0140" class="indexterm"/><a id="IDX-CHP-9-0141" class="indexterm"/><a id="IDX-CHP-9-0142" class="indexterm"/><a id="IDX-CHP-9-0143" class="indexterm"/></p><p>The bytestring modules also have functions that have the same name and behave the same as some functions found in <code class="literal">System.IO</code>, but <code class="literal">Strings</code> are replaced with <code class="literal">ByteStrings</code>. For instance, the <code class="literal">readFile</code> function in <code class="literal">System.IO</code> has this type:</p><a id="I_programlisting9_d1e17441"/><pre class="programlisting">readFile :: FilePath -&gt; IO String</pre><p>The <code class="literal">readFile</code> function from the bytestring modules has the following type:</p><a id="I_programlisting9_d1e17448"/><pre class="programlisting">readFile :: FilePath -&gt; IO ByteString</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>If you’re using strict bytestrings and you attempt to read a file, all of that file will be read into memory at once! With lazy bytestrings, the file will be read in neat chunks.</p></div></div><div class="sect2" title="Copying Files with Bytestrings"><div class="titlepage"><div><div><h2 class="title"><a id="copying_files_with_bytestrings"/>Copying Files with Bytestrings</h2></div></div></div><p>Let’s make a program that takes two filenames as command-line arguments and copies the first file into the second file. Note that <code class="literal">System.Directory</code> already has a function called <code class="literal">copyFile</code>, but we’re going to implement our own file-copying function and program anyway. Here’s the code:</p><a id="I_programlisting9_d1e17464"/><pre class="programlisting">import System.Environment
import System.Directory
import System.IO
import Control.Exception
import qualified Data.ByteString.Lazy as B

main = do
    (fileName1:fileName2:_) &lt;- getArgs
    copy fileName1 fileName2

copy source dest = do
    contents &lt;- B.readFile source
    bracketOnError
        (openTempFile "." "temp")
        (\(tempName, tempHandle) -&gt; do
            hClose tempHandle
            removeFile tempName)
        (\(tempName, tempHandle) -&gt; do
            B.hPutStr tempHandle contents
            hClose tempHandle
            renameFile tempName dest)</pre><p>To begin, in <code class="literal">main</code>, we just get the command-line arguments and call our <code class="literal">copy</code> function, which is where the magic happens. One way to do this would be to just read from one file and write to another. But if something goes wrong (such as we don’t have enough disk space to copy the file), we’ll be left with a messed-up file. So we’ll write to a temporary file first. Then if something goes wrong, we can just delete that file.<a id="IDX-CHP-9-0144" class="indexterm"/></p><p>First, we use <code class="literal">B.readFile</code> to read the contents of our source file. Then we use <code class="literal">bracketOnError</code> to set up our error handling. We acquire the resource with <code class="literal">openTempFile "." "temp"</code>, which yields a tuple that consists of a temporary filename and a handle. Next, we say what we want to happen if an error occurs. If something goes wrong, we close the handle and remove the temporary file. Finally, we do the copying itself. We use <code class="literal">B.hPutStr</code> to write the contents to our temporary file. We close the temporary file and rename it to what we want it to be in the end.</p><p>Notice that we just used <code class="literal">B.readFile</code> and <code class="literal">B.hPutStr</code> instead of their regular variants. We didn’t need to use special bytestring functions for opening, closing, and renaming files. We just need to use the bytestring functions when reading and writing.</p><p>Let’s test it:</p><a id="I_programlisting9_d1e17503"/><pre class="programlisting">$ ./bytestringcopy bart.txt bort.txt</pre><p>A program that doesn’t use bytestrings could look just like this. The only difference is that we used <code class="literal">B.readFile</code> and <code class="literal">B.writeFile</code> instead of <code class="literal">readFile</code> and <code class="literal">writeFile</code>.</p><p>Many times, you can convert a program that uses normal strings to a program that uses bytestrings just by doing the necessary imports and then putting the qualified module names in front of some functions. Sometimes, you need to convert functions that you wrote to work on strings so that they work on bytestrings, but that’s not hard.</p><p>Whenever you need better performance in a program that reads a lot of data into strings, give bytestrings a try. Chances are you’ll get some good performance boosts with very little effort on your part. I usually write programs using normal strings and then convert them to use bytestrings if the performance is not satisfactory.</p></div></div></body></html>