<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;A Fistful of Monads"><div class="titlepage"><div><div><h1 class="title"><a id="a_fistful_of_monads"/>Chapter 13. A Fistful of Monads</h1></div></div></div><p>When we first talked about functors in <a class="xref" href="ch07.html" title="Chapter 7. Making Our Own Types and Type Classes">Chapter 7</a>, you saw that they are a useful concept for values that can be mapped over. Then, in <a class="xref" href="ch11.html" title="Chapter 11. Applicative Functors">Chapter 11</a>, we took that concept one step further with applicative functors, which allow us to view values of certain data types as values with contexts and use normal functions on those values while preserving the meaning of those contexts.<a id="IDX-CHP-13-0001" class="indexterm"/></p><p>In this chapter, you’ll learn about <span class="emphasis"><em>monads</em></span>, which are just beefed-up applicative functors, much like applicative functors are beefed-up functors.</p><div class="sect1" title="Upgrading Our Applicative Functors"><div class="titlepage"><div><div><h1 class="title"><a id="upgrading_our_applicative_functors"/>Upgrading Our Applicative Functors</h1></div></div></div><p>When we started off with functors, you saw that it’s possible to map functions over various data types using the <code class="literal">Functor</code> type class. The introduction to functors had us asking the question, “When we have a function of type <code class="literal">a -&gt; b</code> and some data type <code class="literal">f a</code>, how do we map that function over the data type to end up with <code class="literal">f b</code>?” You saw how to map something over a <code class="literal">Maybe a</code>, a list <code class="literal">[a]</code>, an <code class="literal">IO a</code>, and so on. You even saw how to map a function <code class="literal">a -&gt; b</code> over other functions of type <code class="literal">r -&gt; a</code> to get functions of type <code class="literal">r -&gt; b</code>. To answer the question of how to map a function over some data type, all we needed to do was look at the type of <code class="literal">fmap</code>:<a id="IDX-CHP-13-0002" class="indexterm"/><a id="IDX-CHP-13-0003" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e24277"/><img src="httpatomoreillycomsourcenostarchimages802674.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting13_d1e24282"/><pre class="programlisting">fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</pre><p>And then we just needed to make it work for our data type by writing the appropriate <code class="literal">Functor</code> instance.</p><p>Then you saw a possible improvement of functors and had a few more questions. What if that function <code class="literal">a -&gt; b</code> is already wrapped inside a functor value? Say we have <code class="literal">Just (*3)</code>—how do we apply that to <code class="literal">Just 5</code>? What if we don’t want to apply it to <code class="literal">Just 5</code>, but to a <code class="literal">Nothing</code> instead? Or if we have <code class="literal">[(*2),(+4)]</code>, how do we apply that to <code class="literal">[1,2,3]</code>? How could that even work? For this, the <code class="literal">Applicative</code> type class was introduced:</p><a id="I_programlisting13_d1e24316"/><pre class="programlisting">(&lt;*&gt;) :: (Applicative f) =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</pre><p>You also saw that you can take a normal value and wrap it inside a data type. For instance, we can take a <code class="literal">1</code> and wrap it so that it becomes a <code class="literal">Just 1</code>. Or we can make it into a <code class="literal">[1]</code>. It could even become an I/O action that does nothing and just yields <code class="literal">1</code>. The function that does this is called <code class="literal">pure</code>.</p><p>An applicative value can be seen as a value with an added context—a <span class="emphasis"><em>fancy</em></span> value, to put it in technical terms. For instance, the character <code class="literal">'a'</code> is just a normal character, whereas <code class="literal">Just 'a'</code> has some added context. Instead of a <code class="literal">Char</code>, we have a <code class="literal">Maybe Char</code>, which tells us that its value might be a character, but it could also be an absence of a character. The <code class="literal">Applicative</code> type class allows us to use normal functions on these values with context, and that context is preserved. Observe an example:</p><a id="I_programlisting13_d1e24356"/><pre class="programlisting">ghci&gt; (*) &lt;$&gt; Just 2 &lt;*&gt; Just 8
Just 16
ghci&gt; (++) &lt;$&gt; Just "klingon" &lt;*&gt; Nothing
Nothing
ghci&gt; (-) &lt;$&gt; [3,4] &lt;*&gt; [1,2,3]
[2,1,0,3,2,1]</pre><p>So now that we treat them as applicative values, <code class="literal">Maybe a</code> values represent computations that might have failed, <code class="literal">[a]</code> values represent computations that have several results (nondeterministic computations), <code class="literal">IO a</code> values represent values that have side effects, and so on.</p><p>Monads are a natural extension of applicative functors, and they provide a solution to the following problem: If we have a value with a context, <code class="literal">m a</code>, how do we apply to it a function that takes a normal <code class="literal">a</code> and returns a value with a context? In other words, how do we apply a function of type <code class="literal">a -&gt; m b</code> to a value of type <code class="literal">m a</code>? Essentially, we want this function:</p><a id="I_programlisting13_d1e24384"/><pre class="programlisting">(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</pre><p>If we have a fancy value and a function that takes a normal value but returns a fancy value, how do we feed that fancy value into the function? This is the main concern when dealing with monads. We write <code class="literal">m a</code> instead of <code class="literal">f a</code>, because the <code class="literal">m</code> stands for <code class="literal">Monad</code>, but monads are just applicative functors that support <code class="literal">&gt;&gt;=</code>. The <code class="literal">&gt;&gt;=</code> function is called <span class="emphasis"><em>bind</em></span>.<a id="IDX-CHP-13-0004" class="indexterm"/><a id="IDX-CHP-13-0005" class="indexterm"/><a id="IDX-CHP-13-0006" class="indexterm"/><a id="IDX-CHP-13-0007" class="indexterm"/><a id="IDX-CHP-13-0008" class="indexterm"/></p><p>When we have a normal value <code class="literal">a</code> and a normal function <code class="literal">a -&gt; b</code>, it’s really easy to feed the value to the function—we just apply the function to the value normally, and that’s it. But when we’re dealing with values that come with certain contexts, it takes a bit of thinking to see how these fancy values are fed to functions and how to take into account their behavior. But you’ll see that it’s as easy as one, two, three.</p></div></div>
<div class="sect1" title="Getting Your Feet Wet with Maybe"><div class="titlepage"><div><div><h1 class="title"><a id="getting_your_feet_wet_with_maybe"/>Getting Your Feet Wet with Maybe</h1></div></div></div><p>Now that you have a vague idea of what monads are about, let’s make that idea a little more concrete. Much to no one’s surprise, <code class="literal">Maybe</code> is a monad. Here, we’ll explore it a bit more to see how it works in this role.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Make sure you understand applicative functors at this point. (We discussed them in <a class="xref" href="ch11.html" title="Chapter 11. Applicative Functors">Chapter 11</a>.) You should have a feel for how the various <code class="literal">Applicative</code> instances work and what kinds of computations they represent. To understand monads, you’ll be taking your existing applicative functor knowledge and upgrading it.</p></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e24460"/><img src="httpatomoreillycomsourcenostarchimages802676.png.jpg" alt="image with no caption"/></div></div><p>A value of type <code class="literal">Maybe a</code> represents a value of type <code class="literal">a</code>, but with the context of possible failure attached. A value of <code class="literal">Just "dharma"</code> means that the string <code class="literal">"dharma"</code> is there. A value of <code class="literal">Nothing</code> represents its absence, or if you look at the string as the result of a computation, it means that the computation has failed.</p><p>When we looked at <code class="literal">Maybe</code> as a functor, we saw that if we want to <code class="literal">fmap</code> a function over it, the function is mapped over what’s inside if that’s a <code class="literal">Just</code> value. Otherwise, the <code class="literal">Nothing</code> is kept, because there’s nothing to map it over!</p><a id="I_programlisting13_d1e24496"/><pre class="programlisting">ghci&gt; fmap (++"!") (Just "wisdom")
Just "wisdom!"
ghci&gt; fmap (++"!") Nothing
Nothing</pre><p>As an applicative functor, <code class="literal">Maybe</code> functions similarly. However, with applicative functors, the function itself is in a context, along with the value to which it’s being applied. <code class="literal">Maybe</code> is an applicative functor in such a way that when we use <code class="literal">&lt;*&gt;</code> to apply a function inside a <code class="literal">Maybe</code> to a value that’s inside a <code class="literal">Maybe</code>, they both must be <code class="literal">Just</code> values for the result to be a <code class="literal">Just</code> value; otherwise, the result is <code class="literal">Nothing</code>. This makes sense. If you’re missing either the function or the thing you’re applying it to, you can’t make something up out of thin air, so you need to propagate the failure.</p><a id="I_programlisting13_d1e24525"/><pre class="programlisting">ghci&gt; Just (+3) &lt;*&gt; Just 3
Just 6
ghci&gt; Nothing &lt;*&gt; Just "greed"
Nothing
ghci&gt; Just ord &lt;*&gt; Nothing
Nothing</pre><p>Using the applicative style to have normal functions act on <code class="literal">Maybe</code> values works in a similar way. All the values must be <code class="literal">Just</code> values; otherwise, it’s all for <code class="literal">Nothing</code>!</p><a id="I_programlisting13_d1e24538"/><pre class="programlisting">ghci&gt; max &lt;$&gt; Just 3 &lt;*&gt; Just 6
Just 6
ghci&gt; max &lt;$&gt; Just 3 &lt;*&gt; Nothing
Nothing</pre><p>And now, let’s think about how we would use <code class="literal">&gt;&gt;=</code> with <code class="literal">Maybe</code>. <code class="literal">&gt;&gt;=</code> takes a monadic value and a function that takes a normal value. It returns a monadic value and manages to apply that function to the monadic value. How does it do that if the function takes a normal value? Well, it must take into account the context of that monadic value.</p><p>In this case, <code class="literal">&gt;&gt;=</code> would take a <code class="literal">Maybe a</code> value and a function of type <code class="literal">a -&gt; Maybe b</code>, and somehow apply the function to the <code class="literal">Maybe a</code>. To figure out how it does that, we can use the understanding that we have from <code class="literal">Maybe</code> being an applicative functor. Let’s say that we have a function <code class="literal">\x -&gt; Just (x+1)</code>. It takes a number, adds <code class="literal">1</code> to it, and wraps it in a <code class="literal">Just</code>:</p><a id="I_programlisting13_d1e24579"/><pre class="programlisting">ghci&gt; (\x -&gt; Just (x+1)) 1
Just 2
ghci&gt; (\x -&gt; Just (x+1)) 100
Just 101</pre><p>If we feed it <code class="literal">1</code>, it evaluates to <code class="literal">Just 2</code>. If we give it the number <code class="literal">100</code>, the result is <code class="literal">Just 101</code>. It seems very straightforward. But how do we feed a <code class="literal">Maybe</code> value to this function? If we think about how <code class="literal">Maybe</code> acts as an applicative functor, answering this is pretty easy. We feed it a <code class="literal">Just</code> value, take what’s inside the <code class="literal">Just</code>, and apply the function to it. If we give it a <code class="literal">Nothing</code>, then we’re left with a function but <code class="literal">Nothing</code> to apply it to. In that case, let’s just do what we did before and say that the result is <code class="literal">Nothing</code>.</p><p>Instead of calling it <code class="literal">&gt;&gt;=</code>, let’s call it <code class="literal">applyMaybe</code> for now. It takes a <code class="literal">Maybe a</code> and a function that returns a <code class="literal">Maybe b</code>, and manages to apply that function to the <code class="literal">Maybe a</code>. Here it is in code:</p><a id="I_programlisting13_d1e24634"/><pre class="programlisting">applyMaybe :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
applyMaybe Nothing f  = Nothing
applyMaybe (Just x) f = f x</pre><p>Now let’s play with it. We’ll use it as an infix function so that the <code class="literal">Maybe</code> value is on the left side and the function is on the right:</p><a id="I_programlisting13_d1e24641"/><pre class="programlisting">ghci&gt; Just 3 `applyMaybe` \x -&gt; Just (x+1)
Just 4
ghci&gt; Just "smile" `applyMaybe` \x -&gt; Just (x ++ " :)")
Just "smile :)"
ghci&gt; Nothing `applyMaybe` \x -&gt; Just (x+1)
Nothing
ghci&gt; Nothing `applyMaybe` \x -&gt; Just (x ++ " :)")
Nothing</pre><p>In this example, when we used <code class="literal">applyMaybe</code> with a <code class="literal">Just</code> value and a function, the function was simply applied to the value inside the <code class="literal">Just</code>. When we tried to use it with a <code class="literal">Nothing</code>, the whole result was <code class="literal">Nothing</code>. What about if the function returns a <code class="literal">Nothing</code>? Let’s see:</p><a id="I_programlisting13_d1e24664"/><pre class="programlisting">ghci&gt; Just 3 `applyMaybe` \x -&gt; if x &gt; 2 then Just x else Nothing
Just 3
ghci&gt; Just 1 `applyMaybe` \x -&gt; if x &gt; 2 then Just x else Nothing
Nothing</pre><p>The results are just what we expected. If the monadic value on the left is a <code class="literal">Nothing</code>, the whole thing is <code class="literal">Nothing</code>. And if the function on the right returns a <code class="literal">Nothing</code>, the result is <code class="literal">Nothing</code> again. This is similar to when we used <code class="literal">Maybe</code> as an applicative and we got a <code class="literal">Nothing</code> result if there was a <code class="literal">Nothing</code> somewhere in the mix.</p><p>It looks like we’ve figured out how to take a fancy value, feed it to a function that takes a normal value, and return a fancy one. We did this by keeping in mind that a <code class="literal">Maybe</code> value represents a computation that might have failed.</p><p>You might be asking yourself, “How is this useful?” It may seem like applicative functors are stronger than monads, since applicative functors allow us to take a normal function and make it operate on values with contexts. In this chapter, you’ll see that monads, as an upgrade of applicative functors, can also do that. In fact, they can do some other cool stuff that applicative functors can’t do.</p><p>We’ll come back to <code class="literal">Maybe</code> in a minute, but first, let’s check out the type class that belongs to monads.</p></div>
<div class="sect1" title="The Monad Type Class"><div class="titlepage"><div><div><h1 class="title"><a id="the_monad_type_class"/>The Monad Type Class</h1></div></div></div><p>Just like functors have the <code class="literal">Functor</code> type class, and applicative functors have the <code class="literal">Applicative</code> type class, monads come with their own type class: <code class="literal">Monad</code>! (Wow, who would have thought?)<a id="IDX-CHP-13-0009" class="indexterm"/><a id="IDX-CHP-13-0010" class="indexterm"/><a id="IDX-CHP-13-0011" class="indexterm"/><a id="IDX-CHP-13-0012" class="indexterm"/><a id="IDX-CHP-13-0013" class="indexterm"/><a id="IDX-CHP-13-0014" class="indexterm"/><a id="IDX-CHP-13-0015" class="indexterm"/></p><a id="I_programlisting13_d1e24751"/><pre class="programlisting">class Monad m where
    return :: a -&gt; m a

    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b

    (&gt;&gt;) :: m a -&gt; m b -&gt; m b
    x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y

    fail :: String -&gt; m a
    fail msg = error msg</pre><p>The first line says <code class="literal">class Monad m where</code>. But wait, didn’t I say that monads are just beefed-up applicative functors? Shouldn’t there be a class constraint in there along the lines of <code class="literal">class (Applicative m) = &gt; Monad m where</code>, so that a type must be an applicative functor before it can be made a monad? Well, there should, but when Haskell was made, it hadn’t occurred to people that applicative functors were a good fit for Haskell. But rest assured, every monad is an applicative functor, even if the <code class="literal">Monad</code> class declaration doesn’t say so.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e24765"/><img src="httpatomoreillycomsourcenostarchimages802678.png.jpg" alt="image with no caption"/></div></div><p>The first function that the <code class="literal">Monad</code> type class defines is <code class="literal">return</code>. It’s the same as <code class="literal">pure</code> from the <code class="literal">Applicative</code> type class. So, even though it has a different name, you’re already acquainted with it. <code class="literal">return</code>’s type is <code class="literal">(Monad m) =&gt; a -&gt; m a</code>. It takes a value and puts it in a minimal default context that still holds that value. In other words, <code class="literal">return</code> takes something and wraps it in a monad. We already used <code class="literal">return</code> when handling I/O in <a class="xref" href="ch08.html" title="Chapter 8. Input and Output">Chapter 8</a>. We used it to take a value and make a bogus I/O action that does nothing but yield that value. For <code class="literal">Maybe</code>, it takes a value and wraps it in a <code class="literal">Just</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Just a reminder: <code class="literal">return</code> is nothing like the <code class="literal">return</code> that’s in most other languages. It doesn’t end function execution. It just takes a normal value and puts it in a context.</p></div><p>The next function is <code class="literal">&gt;&gt;=</code>, or bind. It’s like function application, but instead of taking a normal value and feeding it to a normal function, it takes a monadic value (that is, a value with a context) and feeds it to a function that takes a normal value but returns a monadic value.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e24820"/><img src="httpatomoreillycomsourcenostarchimages802680.png.jpg" alt="image with no caption"/></div></div><p>Next up, we have <code class="literal">&gt;&gt;=</code>. We won’t pay too much attention to it for now because it comes with a default implementation, and it’s rarely implemented when making <code class="literal">Monad</code> instances. We’ll take a closer look at it in <a class="xref" href="ch13s04.html#banana_on_a_wire" title="Banana on a Wire">Banana on a Wire</a> in <a class="xref" href="ch13s04.html#banana_on_a_wire" title="Banana on a Wire">Banana on a Wire</a>.<a id="IDX-CHP-13-0016" class="indexterm"/><a id="IDX-CHP-13-0017" class="indexterm"/><a id="IDX-CHP-13-0018" class="indexterm"/><a id="IDX-CHP-13-0019" class="indexterm"/><a id="IDX-CHP-13-0020" class="indexterm"/></p><p>The final function of the <code class="literal">Monad</code> type class is <code class="literal">fail</code>. We never use it explicitly in our code. Instead, it’s used by Haskell to enable failure in a special syntactic construct for monads that you’ll meet later. We don’t need to concern ourselves with <code class="literal">fail</code> too much for now.</p><p>Now that you know what the <code class="literal">Monad</code> type class looks like, let’s take a look at how <code class="literal">Maybe</code> is an instance of <code class="literal">Monad</code>!</p><a id="I_programlisting13_d1e24882"/><pre class="programlisting">instance Monad Maybe where
    return x = Just x
    Nothing &gt;&gt;= f = Nothing
    Just x &gt;&gt;= f  = f x
    fail _ = Nothing</pre><p><code class="literal">return</code> is the same as <code class="literal">pure</code>, so that one is a no-brainer. We do what we did in the <code class="literal">Applicative</code> type class and wrap it in a <code class="literal">Just</code>. The <code class="literal">&gt;&gt;=</code> function is the same as our <code class="literal">applyMaybe</code>. When feeding the <code class="literal">Maybe a</code> to our function, we keep in mind the context and return a <code class="literal">Nothing</code> if the value on the left is <code class="literal">Nothing</code> Again, if there’s no value, then there’s no way to apply our function to it. If it’s a <code class="literal">Just</code>, we take what’s inside and apply <code class="literal">f</code> to it.</p><p>We can play around with <code class="literal">Maybe</code> as a monad:</p><a id="I_programlisting13_d1e24924"/><pre class="programlisting">ghci&gt; return "WHAT" :: Maybe String
Just "WHAT"
ghci&gt; Just 9 &gt;&gt;= \x -&gt; return (x*10)
Just 90
ghci&gt; Nothing &gt;&gt;= \x -&gt; return (x*10)
Nothing</pre><p>There’s nothing new or exciting on the first line, since we already used <code class="literal">pure</code> with <code class="literal">Maybe</code>, and we know that <code class="literal">return</code> is just <code class="literal">pure</code> with a different name.</p><p>The next two lines showcase <code class="literal">&gt;&gt;=</code> a bit more. Notice how when we fed <code class="literal">Just 9</code> to the function <code class="literal">\x -&gt; return (x*10)</code>, the <code class="literal">x</code> took on the value <code class="literal">9</code> inside the function. It seems as though we were able to extract the value from a <code class="literal">Maybe</code> without pattern matching. And we still didn’t lose the context of our <code class="literal">Maybe</code> value, because when it’s <code class="literal">Nothing</code>, the result of using <code class="literal">&gt;&gt;=</code> will be <code class="literal">Nothing</code> as well.</p></div>
<div class="sect1" title="Walk the Line"><div class="titlepage"><div><div><h1 class="title"><a id="walk_the_line"/>Walk the Line</h1></div></div></div><p>Now that you know how to feed a <code class="literal">Maybe a</code> value to a function of type <code class="literal">a -&gt; Maybe b</code> while taking into account the context of possible failure, let’s see how we can use <code class="literal">&gt;&gt;=</code> repeatedly to handle computations of several <code class="literal">Maybe a</code> values.<a id="IDX-CHP-13-0021" class="indexterm"/><a id="IDX-CHP-13-0022" class="indexterm"/><a id="IDX-CHP-13-0023" class="indexterm"/><a id="IDX-CHP-13-0024" class="indexterm"/></p><p>Pierre has decided to take a break from his job at the fish farm and try tightrope walking. He is not that bad at it, but he does have one problem: Birds keep landing on his balancing pole! They come and take a short rest, chat with their avian friends, and then take off in search of breadcrumbs. This wouldn’t bother him so much if the number of birds on the left side of the pole were always equal to the number of birds on the right side. But sometimes, all the birds decide that they like one side better. They throw him off balance, which results in an embarrassing tumble for Pierre (he is using a safety net).</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e25012"/><img src="httpatomoreillycomsourcenostarchimages802682.png.jpg" alt="image with no caption"/></div></div><p>Let’s say that Pierre keeps his balance if the number of birds on the left side of the pole and on the right side of the pole is within three. So if there’s one bird on the right side and four birds on the left side, he is okay. But if a fifth bird lands on the left side, he loses his balance and takes a dive.</p><p>We’re going to simulate birds landing on and flying away from the pole and see if Pierre is still at it after a certain number of bird arrivals and departures. For instance, we want to see what happens to Pierre if first one bird arrives on the left side, then four birds occupy the right side, and then the bird that was on the left side decides to fly away.</p><div class="sect2" title="Code, Code, Code"><div class="titlepage"><div><div><h2 class="title"><a id="code_comma_code_comma_code"/>Code, Code, Code</h2></div></div></div><p>We can represent the pole with a simple pair of integers. The first component will signify the number of birds on the left side and the second component the number of birds on the right side:</p><a id="I_programlisting13_d1e25026"/><pre class="programlisting">type Birds = Int
type Pole = (Birds, Birds)</pre><p>First, we made a type synonym for <code class="literal">Int</code>, called <code class="literal">Birds</code>, because we’re using integers to represent how many birds there are. And then we made a type synonym <code class="literal">(Birds, Birds)</code> and called it <code class="literal">Pole</code> (not to be confused with a person of Polish descent).</p><p>Now, how about adding functions that take a number of birds and land them on one side of the pole or the other?<a id="IDX-CHP-13-0025" class="indexterm"/><a id="IDX-CHP-13-0026" class="indexterm"/><a id="IDX-CHP-13-0027" class="indexterm"/></p><a id="I_programlisting13_d1e25059"/><pre class="programlisting">landLeft :: Birds -&gt; Pole -&gt; Pole
landLeft n (left, right) = (left + n, right)

landRight :: Birds -&gt; Pole -&gt; Pole
landRight n (left, right) = (left, right + n)</pre><p>Let’s try them out:</p><a id="I_programlisting13_d1e25063"/><pre class="programlisting">ghci&gt; landLeft 2 (0, 0)
(2,0)
ghci&gt; landRight 1 (1, 2)
(1,3)
ghci&gt; landRight (-1) (1, 2)
(1,1)</pre><p>To make birds fly away, we just had a negative number of birds land on one side. Because landing a bird on the <code class="literal">Pole</code> returns a <code class="literal">Pole</code>, we can chain applications of <code class="literal">landLeft</code> and <code class="literal">landRight</code>:</p><a id="I_programlisting13_d1e25079"/><pre class="programlisting">ghci&gt; landLeft 2 (landRight 1 (landLeft 1 (0, 0)))
(3,1)</pre><p>When we apply the function <code class="literal">landLeft 1</code> to <code class="literal">(0, 0)</code> we get <code class="literal">(1, 0)</code>. Then we land a bird on the right side, resulting in <code class="literal">(1, 1)</code>. Finally, two birds land on the left side, resulting in <code class="literal">(3, 1)</code>. We apply a function to something by first writing the function and then writing its parameter, but here it would be better if the pole went first and then the landing function. Suppose we make a function like this:</p><a id="I_programlisting13_d1e25099"/><pre class="programlisting">x -: f = f x</pre><p>We can apply functions by first writing the parameter and then the function:</p><a id="I_programlisting13_d1e25103"/><pre class="programlisting">ghci&gt; 100 -: (*3)
300
ghci&gt; True -: not
False
ghci&gt; (0, 0) -: landLeft 2
(2,0)</pre><p>By using this form, we can repeatedly land birds on the pole in a more readable manner:<a id="IDX-CHP-13-0028" class="indexterm"/><a id="IDX-CHP-13-0029" class="indexterm"/></p><a id="I_programlisting13_d1e25113"/><pre class="programlisting">ghci&gt; (0, 0) -: landLeft 1 -: landRight 1 -: landLeft 2
(3,1)</pre><p>Pretty cool! This version is equivalent to the one before where we repeatedly landed birds on the pole, but it looks neater. Here, it’s more obvious that we start off with <code class="literal">(0, 0)</code> and then land one bird on the left, then one on the right, and finally, two on the left.</p></div><div class="sect2" title="I'll Fly Away"><div class="titlepage"><div><div><h2 class="title"><a id="i_apostrophy_ll_fly_away"/>I'll Fly Away</h2></div></div></div><p>So far so good, but what happens if ten birds land on one side?</p><a id="I_programlisting13_d1e25125"/><pre class="programlisting">ghci&gt; landLeft 10 (0, 3)
(10,3)</pre><p>Ten birds on the left side and only three on the right? That’s sure to send poor Pierre falling through the air! This is pretty obvious here, but what if we had a sequence of landings like this:</p><a id="I_programlisting13_d1e25129"/><pre class="programlisting">ghci&gt; (0, 0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)
(0,2)</pre><p>It might seem as if everything is okay, but if you follow the steps here, you’ll see that at one time there are four birds on the right side and no birds on the left! To fix this, we need to take another look at our <code class="literal">landLeft</code> and <code class="literal">landRight</code> functions.</p><p>We want the <code class="literal">landLeft</code> and <code class="literal">landRight</code> functions to be able to fail. We want them to return a new pole if the balance is okay but fail if the birds land in a lopsided manner. And what better way to add a context of failure to value than by using <code class="literal">Maybe</code>! Let’s rework these functions:</p><a id="I_programlisting13_d1e25150"/><pre class="programlisting">landLeft :: Birds -&gt; Pole -&gt; Maybe Pole
landLeft n (left, right)
    | abs ((left + n) - right) &lt; 4 = Just (left + n, right)
    | otherwise                    = Nothing

landRight :: Birds -&gt; Pole -&gt; Maybe Pole
landRight n (left, right)
    | abs (left - (right + n)) &lt; 4 = Just (left, right + n)
    | otherwise                    = Nothing</pre><p>Instead of returning a <code class="literal">Pole</code>, these functions now return a <code class="literal">Maybe Pole</code>. They still take the number of birds and the old pole as before, but then they check if landing that many birds on the pole would throw Pierre off balance. We use guards to check if the difference between the number of birds on the new pole is less than <code class="literal">4</code>. If it is, we wrap the new pole in a <code class="literal">Just</code> and return that. If it isn’t, we return a <code class="literal">Nothing</code>, indicating failure.</p><p>Let’s give these babies a go:</p><a id="I_programlisting13_d1e25171"/><pre class="programlisting">ghci&gt; landLeft 2 (0, 0)
Just (2,0)
ghci&gt; landLeft 10 (0, 3)
Nothing</pre><p>When we land birds without throwing Pierre off balance, we get a new pole wrapped in a <code class="literal">Just</code>. But when many more birds end up on one side of the pole, we get a <code class="literal">Nothing</code>. This is cool, but we seem to have lost the ability to repeatedly land birds on the pole. We can’t do <code class="literal">landLeft 1 (landRight 1 (0, 0))</code> anymore, because when we apply <code class="literal">landRight 1</code> to <code class="literal">(0, 0)</code>, we don’t get a <code class="literal">Pole</code>, but a <code class="literal">Maybe Pole</code>. <code class="literal">landLeft 1</code> takes a <code class="literal">Pole</code>, rather than a <code class="literal">Maybe Pole</code>.</p><p>We need a way of taking a <code class="literal">Maybe Pole</code> and feeding it to a function that takes a <code class="literal">Pole</code> and returns a <code class="literal">Maybe Pole</code>. Luckily, we have <code class="literal">&gt;&gt;=</code>, which does just that for <code class="literal">Maybe</code>. Let’s give it a go:</p><a id="I_programlisting13_d1e25224"/><pre class="programlisting">ghci&gt; landRight 1 (0, 0) &gt;&gt;= landLeft 2
Just (2,1)</pre><p>Remember that <code class="literal">landLeft 2</code> has a type of <code class="literal">Pole -&gt; Maybe Pole</code>. We couldn’t just feed it the <code class="literal">Maybe Pole</code> that is the result of <code class="literal">landRight 1 (0, 0)</code>, so we use <code class="literal">&gt;&gt;=</code> to take that value with a context and give it to <code class="literal">landLeft 2</code>. <code class="literal">&gt;&gt;=</code> does indeed allow us to treat the <code class="literal">Maybe</code> value as a value with context. If we feed a <code class="literal">Nothing</code> into <code class="literal">landLeft 2</code>, the result is <code class="literal">Nothing</code>, and the failure is propagated:</p><a id="I_programlisting13_d1e25262"/><pre class="programlisting">ghci&gt; Nothing &gt;&gt;= landLeft 2
Nothing</pre><p>With this, we can now chain landings that may fail, because <code class="literal">&gt;&gt;=</code> allows us to feed a monadic value to a function that takes a normal one. Here’s a sequence of bird landings:</p><a id="I_programlisting13_d1e25269"/><pre class="programlisting">ghci&gt; return (0, 0) &gt;&gt;= landRight 2 &gt;&gt;= landLeft 2 &gt;&gt;= landRight 2
Just (2,4)</pre><p>At the beginning, we used <code class="literal">return</code> to take a pole and wrap it in a <code class="literal">Just</code>. We could have just applied <code class="literal">landRight 2</code> to <code class="literal">(0, 0)</code>—it would have been the same—but this way, we can be more consistent by using <code class="literal">&gt;&gt;=</code> for every function. <code class="literal">Just (0, 0)</code> is fed to <code class="literal">landRight 2</code>, resulting in <code class="literal">Just (0, 2)</code>. This, in turn, gets fed to <code class="literal">landLeft 2</code>, resulting in <code class="literal">Just (2, 2)</code>, and so on.</p><p>Remember the following example from before we introduced failure into Pierre’s routine?</p><a id="I_programlisting13_d1e25306"/><pre class="programlisting">ghci&gt; (0, 0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)
(0,2)</pre><p>It didn’t simulate his interaction with birds very well. In the middle, his balance was off, but the result didn’t reflect that. Let’s fix that now by using monadic application (<code class="literal">&gt;&gt;=</code>) instead of normal application:<a id="IDX-CHP-13-0030" class="indexterm"/><a id="IDX-CHP-13-0031" class="indexterm"/><a id="IDX-CHP-13-0032" class="indexterm"/><a id="IDX-CHP-13-0033" class="indexterm"/><a id="IDX-CHP-13-0034" class="indexterm"/><a id="IDX-CHP-13-0035" class="indexterm"/></p><a id="I_programlisting13_d1e25338"/><pre class="programlisting">ghci&gt; return (0, 0) &gt;&gt;= landLeft 1 &gt;&gt;= landRight 4 &gt;&gt;= landLeft (-1) &gt;&gt;= landRight (-2)
Nothing</pre><p>The final result represents failure, which is what we expected. Let’s see how this result was obtained:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">return</code> puts <code class="literal">(0, 0)</code> into a default context, making it a <code class="literal">Just (0, 0)</code>.</p></li><li class="listitem"><p><code class="literal">Just (0, 0) &gt;&gt;= landLeft 1</code> happens. Since the <code class="literal">Just (0, 0)</code> is a <code class="literal">Just</code> value, <code class="literal">landLeft 1</code> gets applied to <code class="literal">(0, 0)</code>, resulting in a <code class="literal">Just (1, 0)</code>, because the birds are still relatively balanced.</p></li><li class="listitem"><p><code class="literal">Just (1, 0) &gt;&gt;= landRight 4</code> takes place, and the result is <code class="literal">Just (1, 4)</code>, as the balance of the birds is still intact, although just barely.</p></li><li class="listitem"><p><code class="literal">Just (1, 4)</code> gets fed to <code class="literal">landLeft (-1)</code>. This means that <code class="literal">landLeft (-1) (1, 4)</code> takes place. Now because of how <code class="literal">landLeft</code> works, this results in a <code class="literal">Nothing</code>, because the resulting pole is off balance.</p></li><li class="listitem"><p>Now that we have a <code class="literal">Nothing</code>, it gets fed to <code class="literal">landRight (-2)</code>, but because it’s a <code class="literal">Nothing</code>, the result is automatically <code class="literal">Nothing</code>, as we have nothing to apply <code class="literal">landRight (-2)</code> to.</p></li></ol></div><p>We couldn’t have achieved this by just using <code class="literal">Maybe</code> as an applicative. If you try it, you’ll get stuck, because applicative functors don’t allow for the applicative values to interact with each other very much. They can, at best, be used as parameters to a function by using the applicative style.</p><p>The applicative operators will fetch their results and feed them to the function in a manner appropriate for each applicative, and then put the final applicative value together, but there isn’t that much interaction going on between them. Here, however, each step relies on the previous one’s result. On every landing, the possible result from the previous one is examined and the pole is checked for balance. This determines whether the landing will succeed or fail.</p></div><div class="sect2" title="Banana on a Wire"><div class="titlepage"><div><div><h2 class="title"><a id="banana_on_a_wire"/>Banana on a Wire</h2></div></div></div><p>Now let’s devise a function that ignores the current number of birds on the balancing pole and just makes Pierre slip and fall. We’ll call it <code class="literal">banana</code>:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e25433"/><img src="httpatomoreillycomsourcenostarchimages802684.png" alt="image with no caption"/></div></div><a id="I_programlisting13_d1e25438"/><pre class="programlisting">banana :: Pole -&gt; Maybe Pole
banana _ = Nothing</pre><p>We can chain this function together with our bird landings. It will always cause our walker to fall, because it ignores whatever is passed to it and always returns a failure.</p><a id="I_programlisting13_d1e25442"/><pre class="programlisting">ghci&gt; return (0, 0) &gt;&gt;= landLeft 1 &gt;&gt;= banana &gt;&gt;= landRight 1
Nothing</pre><p>The value <code class="literal">Just (1, 0)</code> gets fed to <code class="literal">banana</code>, but it produces a <code class="literal">Nothing</code>, which causes everything to result in a <code class="literal">Nothing</code>. How unfortunate!<a id="IDX-CHP-13-0036" class="indexterm"/><a id="IDX-CHP-13-0037" class="indexterm"/><a id="IDX-CHP-13-0038" class="indexterm"/></p><p>Instead of making functions that ignore their input and just return a predetermined monadic value, we can use the <code class="literal">&gt;&gt;</code> function. Here’s its default implementation:</p><a id="I_programlisting13_d1e25475"/><pre class="programlisting">(&gt;&gt;) :: (Monad m) =&gt; m a -&gt; m b -&gt; m b
m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n</pre><p>Normally, passing some value to a function that ignores its parameter and always returns some predetermined value always results in that predetermined value. With monads, however, their context and meaning must be considered as well. Here’s how <code class="literal">&gt;&gt;</code> acts with <code class="literal">Maybe</code>:</p><a id="I_programlisting13_d1e25485"/><pre class="programlisting">ghci&gt; Nothing &gt;&gt; Just 3
Nothing
ghci&gt; Just 3 &gt;&gt; Just 4
Just 4
ghci&gt; Just 3 &gt;&gt; Nothing
Nothing</pre><p>If we replace <code class="literal">&gt;&gt;</code> with <code class="literal">&gt;&gt;= \_ -&gt;</code>, it’s easy to see what’s happening.</p><p>We can replace our <code class="literal">banana</code> function in the chain with a <code class="literal">&gt;&gt;</code> and then a <code class="literal">Nothing</code> for guaranteed and obvious failure:</p><a id="I_programlisting13_d1e25507"/><pre class="programlisting">ghci&gt; return (0, 0) &gt;&gt;= landLeft 1 &gt;&gt; Nothing &gt;&gt;= landRight 1
Nothing</pre><p>What would this look like if we hadn’t made the clever choice of treating <code class="literal">Maybe</code> values as values with a failure context and feeding them to functions? Here’s how a series of bird landings would look:</p><a id="I_programlisting13_d1e25514"/><pre class="programlisting">routine :: Maybe Pole
routine = case landLeft 1 (0, 0) of
    Nothing -&gt; Nothing
    Just pole1 -&gt; case landRight 4 pole1 of
        Nothing -&gt; Nothing
        Just pole2 -&gt; case landLeft 2 pole2 of
            Nothing -&gt; Nothing
            Just pole3 -&gt; landLeft 1 pole3</pre><p>We land a bird on the left, and then we examine the possibility of failure and the possibility of success. In the case of failure, we return a <code class="literal">Nothing</code>. In the case of success, we land birds on the right and then do the same thing all over again. Converting this monstrosity into a neat chain of monadic applications with <code class="literal">&gt;&gt;=</code> is a classic example of how the <code class="literal">Maybe</code> monad saves a lot of time when you need to successively do computations that are based on computations that might have failed.<a id="IDX-CHP-13-0039" class="indexterm"/><a id="IDX-CHP-13-0040" class="indexterm"/><a id="IDX-CHP-13-0041" class="indexterm"/><a id="IDX-CHP-13-0042" class="indexterm"/><a id="IDX-CHP-13-0043" class="indexterm"/><a id="IDX-CHP-13-0044" class="indexterm"/></p><p>Notice how the <code class="literal">Maybe</code> implementation of <code class="literal">&gt;&gt;=</code> features exactly this logic of seeing if a value is <code class="literal">Nothing</code> and acting on that knowledge. If the value is <code class="literal">Nothing</code>, it returns a <code class="literal">Nothing</code> immediately. If the value is not <code class="literal">Nothing</code>, it goes forward with what’s inside the <code class="literal">Just</code>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e25581"/><img src="httpatomoreillycomsourcenostarchimages802686.png.jpg" alt="image with no caption"/></div></div><p>In this section, we looked at how some functions work better when the values that they return support failure. By turning those values into <code class="literal">Maybe</code> values and replacing normal function application with <code class="literal">&gt;&gt;=</code>, we got a mechanism for handling failure pretty much for free. This is because <code class="literal">&gt;&gt;=</code> is supposed to preserve the context of the value to which it applies functions. In this case, the context was that our values were values with failure. So, when we applied functions to such values, the possibility of failure was always taken into account.</p></div></div>
<div class="sect1" title="do Notation"><div class="titlepage"><div><div><h1 class="title"><a id="do_notation"/>do Notation</h1></div></div></div><p>Monads in Haskell are so useful that they got their own special syntax, called <code class="literal">do</code> notation. You already encountered <code class="literal">do</code> notation in <a class="xref" href="ch08.html" title="Chapter 8. Input and Output">Chapter 8</a>, when we used it for gluing together several I/O actions into one. Well, as it turns out, <code class="literal">do</code> notation isn’t just for <code class="literal">IO</code> but can be used for any monad. Its principle is still the same: gluing together monadic values in sequence.</p><p>Consider this familiar example of monadic application:</p><a id="I_programlisting13_d1e25618"/><pre class="programlisting">ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Just (show x ++ "!"))
Just "3!"</pre><p>Been there, done that. Feeding a monadic value to a function that returns one—no big deal. Notice how when we do this, <code class="literal">x</code> becomes <code class="literal">3</code> inside the lambda. Once we’re inside that lambda, it’s just a normal value rather than a monadic value. Now, what if we had another <code class="literal">&gt;&gt;=</code> inside that function? Check this out:</p><a id="I_programlisting13_d1e25631"/><pre class="programlisting">ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Just "!" &gt;&gt;= (\y -&gt; Just (show x ++ y)))
Just "3!"</pre><p>Ah, a nested use of <code class="literal">&gt;&gt;=</code>! In the outermost lambda, we feed <code class="literal">Just "!"</code> to the lambda <code class="literal">\y -&gt; Just (show x ++ y)</code>. Inside this lambda, the <code class="literal">y</code> becomes <code class="literal">"!"</code>. <code class="literal">x</code> is still <code class="literal">3</code>, because we got it from the outer lambda. All this sort of reminds me of the following expression:<a id="IDX-CHP-13-0045" class="indexterm"/><a id="IDX-CHP-13-0046" class="indexterm"/></p><a id="I_programlisting13_d1e25665"/><pre class="programlisting">ghci&gt; let x = 3; y = "!" in show x ++ y
"3!"</pre><p>The main difference here is that the values in our <code class="literal">&gt;&gt;=</code> example are monadic. They are values with a failure context. We can replace any of them with a failure:</p><a id="I_programlisting13_d1e25672"/><pre class="programlisting">ghci&gt; Nothing &gt;&gt;= (\x -&gt; Just "!" &gt;&gt;= (\y -&gt; Just (show x ++ y)))
Nothing
ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Nothing &gt;&gt;= (\y -&gt; Just (show x ++ y)))
Nothing
ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Just "!" &gt;&gt;= (\y -&gt; Nothing))
Nothing</pre><p>In the first line, feeding a <code class="literal">Nothing</code> to a function naturally results in a <code class="literal">Nothing</code>. In the second line, we feed <code class="literal">Just 3</code> to a function, and the <code class="literal">x</code> becomes <code class="literal">3</code>. But then we feed a <code class="literal">Nothing</code> to the inner lambda, and the result of that is <code class="literal">Nothing</code>, which causes the outer lambda to produce <code class="literal">Nothing</code> as well. So this is sort of like assigning values to variables in <code class="literal">let</code> expressions, except that the values in question are monadic values.</p><p>To further illustrate this point, let’s write this in a script and have each <code class="literal">Maybe</code> value take up its own line:</p><a id="I_programlisting13_d1e25710"/><pre class="programlisting">foo :: Maybe String
foo = Just 3   &gt;&gt;= (\x -&gt;
      Just "!" &gt;&gt;= (\y -&gt;
      Just (show x ++ y)))</pre><p>To save us from writing all these annoying lambdas, Haskell gives us <code class="literal">do</code> notation. It allows us to write the previous piece of code like this:</p><a id="I_programlisting13_d1e25717"/><pre class="programlisting">foo :: Maybe String
foo = do
    x &lt;- Just 3
    y &lt;- Just "!"
    Just (show x ++ y)</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e25720"/><img src="httpatomoreillycomsourcenostarchimages802688.png.jpg" alt="image with no caption"/></div></div><p>It would seem as though we’ve gained the ability to temporarily extract things from <code class="literal">Maybe</code> values without needing to check if the <code class="literal">Maybe</code> values are <code class="literal">Just</code> values or <code class="literal">Nothing</code> values at every step. How cool! If any of the values that we try to extract from are <code class="literal">Nothing</code>, the whole <code class="literal">do</code> expression will result in a <code class="literal">Nothing</code>. We’re yanking out their (possibly existing) values and letting <code class="literal">&gt;&gt;=</code> worry about the context that comes with those values.</p><p><code class="literal">do</code> expressions are just different syntax for chaining monadic values.<a id="IDX-CHP-13-0047" class="indexterm"/><a id="IDX-CHP-13-0048" class="indexterm"/><a id="IDX-CHP-13-0049" class="indexterm"/><a id="IDX-CHP-13-0050" class="indexterm"/><a id="IDX-CHP-13-0051" class="indexterm"/></p><div class="sect2" title="Do As I Do"><div class="titlepage"><div><div><h2 class="title"><a id="do_as_i_do"/>Do As I Do</h2></div></div></div><p>In a <code class="literal">do</code> expression, every line that isn’t a <code class="literal">let</code> line is a monadic value. To inspect its result, we use <code class="literal">&lt;-</code>. If we have a <code class="literal">Maybe String</code> and we bind it to a variable with <code class="literal">&lt;-</code>, that variable will be a <code class="literal">String</code>, just as when we used <code class="literal">&gt;&gt;=</code> to feed monadic values to lambdas.</p><p>The last monadic value in a <code class="literal">do</code> expression—like <code class="literal">Just (show x ++ y)</code> here—can’t be used with <code class="literal">&lt;-</code> to bind its result, because that wouldn’t make sense if we translated the <code class="literal">do</code> expression back to a chain of <code class="literal">&gt;&gt;=</code> applications. Rather, its result is the result of the whole glued-up monadic value, taking into account the possible failure of any of the previous ones. For instance, examine the following line:</p><a id="I_programlisting13_d1e25823"/><pre class="programlisting">ghci&gt; Just 9 &gt;&gt;= (\x -&gt; Just (x &gt; 8))
Just True</pre><p>Because the left parameter of <code class="literal">&gt;&gt;=</code> is a <code class="literal">Just</code> value, the lambda is applied to <code class="literal">9</code>, and the result is a <code class="literal">Just True</code>. We can rewrite this in <code class="literal">do</code> notation, as follows:</p><a id="I_programlisting13_d1e25842"/><pre class="programlisting">marySue :: Maybe Bool
marySue = do
    x &lt;- Just 9
    Just (x &gt; 8)</pre><p>Comparing these two versions, it’s easy to see why the result of the whole monadic value is the result of the last monadic value in the <code class="literal">do</code> expression with all the previous ones chained into it.</p></div><div class="sect2" title="Pierre Returns"><div class="titlepage"><div><div><h2 class="title"><a id="pierre_returns"/>Pierre Returns</h2></div></div></div><p>Our tightrope walker’s routine can also be expressed with <code class="literal">do</code> notation. <code class="literal">landLeft</code> and <code class="literal">landRight</code> take a number of birds and a pole and produce a pole wrapped in a <code class="literal">Just</code>. The exception is when the tightrope walker slips, in which case a <code class="literal">Nothing</code> is produced. We used <code class="literal">&gt;&gt;=</code> to chain successive steps because each one relied on the previous one, and each one had an added context of possible failure. Here are two birds landing on the left side, then two birds landing on the right, and then one bird landing on the left:</p><a id="I_programlisting13_d1e25873"/><pre class="programlisting">routine :: Maybe Pole
routine = do
    start &lt;- return (0, 0)
    first &lt;- landLeft 2 start
    second &lt;- landRight 2 first
    landLeft 1 second</pre><p>Let’s see if he succeeds:<a id="IDX-CHP-13-0052" class="indexterm"/><a id="IDX-CHP-13-0053" class="indexterm"/></p><a id="I_programlisting13_d1e25887"/><pre class="programlisting">ghci&gt; routine
Just (3,2)</pre><p>He does!</p><p>When we were doing these routines by explicitly writing <code class="literal">&gt;&gt;=</code>, we usually said something like <code class="literal">return (0, 0) &gt;&gt;= landLeft 2</code>, because <code class="literal">landLeft 2</code> is a function that returns a <code class="literal">Maybe</code> value. However, with <code class="literal">do</code> expressions, each line must feature a monadic value. So we explicitly pass the previous <code class="literal">Pole</code> to the <code class="literal">landLeft landRight</code> functions. If we examined the variables to which we bound our <code class="literal">Maybe</code> values, <code class="literal">start</code> would be <code class="literal">(0, 0)</code>, <code class="literal">first</code> would be <code class="literal">(2, 0)</code> and so on.<a id="IDX-CHP-13-0054" class="indexterm"/></p><p>Because <code class="literal">do</code> expressions are written line by line, they may look like imperative code to some people. But they’re just sequential, as each value in each line relies on the result of the previous ones, along with their contexts (in this case, whether they succeeded or failed).</p><p>Again, let’s take a look at what this piece of code would look like if we hadn’t used the monadic aspects of <code class="literal">Maybe</code>:</p><a id="I_programlisting13_d1e25946"/><pre class="programlisting">routine :: Maybe Pole
routine =
    case Just (0, 0) of
        Nothing -&gt; Nothing
        Just start -&gt; case landLeft 2 start of
            Nothing -&gt; Nothing
            Just first -&gt; case landRight 2 first of
                Nothing -&gt; Nothing
                Just second -&gt; landLeft 1 second</pre><p>See how in the case of success, the tuple inside <code class="literal">Just (0, 0)</code> becomes <code class="literal">start</code>, the result of <code class="literal">landLeft 2 start</code> becomes <code class="literal">first</code>, and so on?</p><p>If we want to throw Pierre a banana peel in <code class="literal">do</code> notation, we can do the following:</p><a id="I_programlisting13_d1e25968"/><pre class="programlisting">routine :: Maybe Pole
routine = do
    start &lt;- return (0, 0)
    first &lt;- landLeft 2 start
    Nothing
    second &lt;- landRight 2 first
    landLeft 1 second</pre><p>When we write a line in <code class="literal">do</code> notation without binding the monadic value with <code class="literal">&lt;-</code>, it’s just like putting <code class="literal">&gt;&gt;</code> after the monadic value whose result we want to ignore. We sequence the monadic value but we ignore its result, because we don’t care what it is. Plus, it’s prettier than writing its equivalent form of <code class="literal">_ &lt;- Nothing</code>.</p><p>When to use <code class="literal">do</code> notation and when to explicitly use <code class="literal">&gt;&gt;=</code> is up to you. I think this example lends itself to explicitly writing <code class="literal">&gt;&gt;=</code>, because each step relies specifically on the result of the previous one. With <code class="literal">do</code> notation, we need to specifically write on which pole the birds are landing, but every time we just use the pole that was the result of the previous landing. But still, it gave us some insight into <code class="literal">do</code> notation.<a id="IDX-CHP-13-0055" class="indexterm"/><a id="IDX-CHP-13-0056" class="indexterm"/><a id="IDX-CHP-13-0057" class="indexterm"/><a id="IDX-CHP-13-0058" class="indexterm"/><a id="IDX-CHP-13-0059" class="indexterm"/></p></div><div class="sect2" title="Pattern Matching and Failure"><div class="titlepage"><div><div><h2 class="title"><a id="pattern_matching_and_failure"/>Pattern Matching and Failure</h2></div></div></div><p>In <code class="literal">do</code> notation, when we bind monadic values to names, we can utilize pattern matching, just as in <code class="literal">let</code> expressions and function parameters. Here’s an example of pattern matching in a <code class="literal">do</code> expression:</p><a id="I_programlisting13_d1e26041"/><pre class="programlisting">justH :: Maybe Char
justH = do
    (x:xs) &lt;- Just "hello"
    return x</pre><p>We use pattern matching to get the first character of the string <code class="literal">"hello"</code>, and then we present it as the result. So <code class="literal">justH</code> evaluates to <code class="literal">Just 'h'</code>.</p><p>What if this pattern matching were to fail? When matching on a pattern in a function fails, the next pattern is matched. If the matching falls through all the patterns for a given function, an error is thrown, and the program crashes. On the other hand, failed pattern matching in <code class="literal">let</code> expressions results in an error being produced immediately, because the mechanism of falling through patterns isn’t present in <code class="literal">let</code> expressions.</p><p>When pattern matching fails in a <code class="literal">do</code> expression, the <code class="literal">fail</code> function (part of the <code class="literal">Monad</code> type class) enables it to result in a failure in the context of the current monad, instead of making the program crash. Here’s its default implementation:</p><a id="I_programlisting13_d1e26073"/><pre class="programlisting">fail :: (Monad m) =&gt; String -&gt; m a
fail msg = error msg</pre><p>So, by default, it does make the program crash. But monads that incorporate a context of possible failure (like <code class="literal">Maybe</code>) usually implement it on their own. For <code class="literal">Maybe</code>, it’s implemented like so:</p><a id="I_programlisting13_d1e26083"/><pre class="programlisting">fail _ = Nothing</pre><p>It ignores the error message and makes a <code class="literal">Nothing</code>. So when pattern matching fails in a <code class="literal">Maybe</code> value that’s written in <code class="literal">do</code> notation, the whole value results in a <code class="literal">Nothing</code>. This is preferable to having your program crash. Here’s a <code class="literal">do</code> expression with a pattern match that’s bound to fail:</p><a id="I_programlisting13_d1e26102"/><pre class="programlisting">wopwop :: Maybe Char
wopwop = do
    (x:xs) &lt;- Just ""
    return x</pre><p>The pattern matching fails, so the effect is the same as if the whole line with the pattern were replaced with a <code class="literal">Nothing</code>. Let’s try this out:<a id="IDX-CHP-13-0060" class="indexterm"/><a id="IDX-CHP-13-0061" class="indexterm"/></p><a id="I_programlisting13_d1e26118"/><pre class="programlisting">ghci&gt; wopwop
Nothing</pre><p>The failed pattern matching has caused a failure within the context of our monad instead of causing a program-wide failure, which is pretty neat.</p></div></div>
<div class="sect1" title="The List Monad"><div class="titlepage"><div><div><h1 class="title"><a id="the_list_monad"/>The List Monad</h1></div></div></div><p>So far, you’ve seen how <code class="literal">Maybe</code> values can be viewed as values with a failure context, and how we can incorporate failure handling into our code by using <code class="literal">&gt;&gt;=</code> to feed them to functions. In this section, we’re going to take a look at how to use the monadic aspects of lists to bring nondeterminism into our code in a clear and readable manner.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e26134"/><img src="httpatomoreillycomsourcenostarchimages802690.png.jpg" alt="image with no caption"/></div></div><p>In <a class="xref" href="ch11.html" title="Chapter 11. Applicative Functors">Chapter 11</a>, we talked about how lists represent nondeterministic values when they’re used as applicatives. A value like <code class="literal">5</code> is deterministic—it has only one result, and we know exactly what it is. On the other hand, a value like <code class="literal">[3,8,9]</code> contains several results, so we can view it as one value that is actually many values at the same time. Using lists as applicative functors showcases this nondeterminism nicely.<a id="IDX-CHP-13-0062" class="indexterm"/><a id="IDX-CHP-13-0063" class="indexterm"/><a id="IDX-CHP-13-0064" class="indexterm"/></p><a id="I_programlisting13_d1e26164"/><pre class="programlisting">ghci&gt; (*) &lt;$&gt; [1,2,3] &lt;*&gt; [10,100,1000]
[10,100,1000,20,200,2000,30,300,3000]</pre><p>All the possible combinations of multiplying elements from the left list with elements from the right list are included in the resulting list. When dealing with nondeterminism, there are many choices that we can make, so we just try all of them. This means the result is a nondeterministic value as well, but it has many more results.</p><p>This context of nondeterminism translates to monads very nicely. Here’s what the <code class="literal">Monad</code> instance for lists looks like:</p><a id="I_programlisting13_d1e26173"/><pre class="programlisting">instance Monad [] where
    return x = [x]
    xs &gt;&gt;= f = concat (map f xs)
    fail _ = []</pre><p>As you know, <code class="literal">return</code> does the same thing as <code class="literal">pure</code>, and you’re already familiar with <code class="literal">return</code> for lists. <code class="literal">return</code> takes a value and puts it in a minimal default context that still yields that value. In other words, <code class="literal">return</code> makes a list that has only that one value as its result. This is useful when we want to just wrap a normal value into a list so that it can interact with nondeterministic values.<a id="IDX-CHP-13-0065" class="indexterm"/><a id="IDX-CHP-13-0066" class="indexterm"/></p><p><code class="literal">&gt;&gt;=</code> is about taking a value with a context (a monadic value) and feeding it to a function that takes a normal value and returns one that has context. If that function just produced a normal value instead of one with a context, <code class="literal">&gt;&gt;=</code> wouldn’t be so useful—after one use, the context would be lost.</p><p>Let’s try feeding a nondeterministic value to a function:</p><a id="I_programlisting13_d1e26213"/><pre class="programlisting">ghci&gt; [3,4,5] &gt;&gt;= \x -&gt; [x,-x]
[3,-3,4,-4,5,-5]</pre><p>When we used <code class="literal">&gt;&gt;=</code> with <code class="literal">Maybe</code>, the monadic value was fed into the function while taking care of possible failures. Here, it takes care of non-determinism for us.</p><p><code class="literal">[3,4,5]</code> is a nondeterministic value, and we feed it into a function that returns a nondeterministic value as well. The result is also nondeterministic, and it features all the possible results of taking elements from the list <code class="literal">[3,4,5]</code> and passing them to the function <code class="literal">\x -&gt; [x,-x]</code>. This function takes a number and produces two results: one negated and one that’s unchanged. So when we use <code class="literal">&gt;&gt;=</code> to feed this list to the function, every number is negated and also kept unchanged. The <code class="literal">x</code> from the lambda takes on every value from the list that’s fed to it.</p><p>To see how this is achieved, we can just follow the implementation. First, we start with the list <code class="literal">[3,4,5]</code>. Then we map the lambda over it and get the following result:</p><a id="I_programlisting13_d1e26244"/><pre class="programlisting">[[3,-3],[4,-4],[5,-5]]</pre><p>The lambda is applied to every element, and we get a list of lists. Finally, we just flatten the list, and voilà, we’ve applied a nondeterministic function to a nondeterministic value!</p><p>Nondeterminism also includes support for failure. The empty list <code class="literal">[]</code> is pretty much the equivalent of <code class="literal">Nothing</code>, because it signifies the absence of a result. That’s why failing is just defined as the empty list. The error message gets thrown away. Let’s play around with lists that fail:</p><a id="I_programlisting13_d1e26256"/><pre class="programlisting">ghci&gt; [] &gt;&gt;= \x -&gt; ["bad","mad","rad"]
[]
ghci&gt; [1,2,3] &gt;&gt;= \x -&gt; []
[]</pre><p>In the first line, an empty list is fed into the lambda. Because the list has no elements, there are none to be passed to the function, so the result is an empty list. This is similar to feeding <code class="literal">Nothing</code> to a function. In the second line, each element is passed to the function, but the element is ignored and the function just returns an empty list. Because the function fails for every element that goes in it, the result is a failure.</p><p>Just as with <code class="literal">Maybe</code> values, we can chain several lists with <code class="literal">&gt;&gt;=</code>, propagating the nondeterminism:</p><a id="I_programlisting13_d1e26271"/><pre class="programlisting">ghci&gt; [1,2] &gt;&gt;= \n -&gt; ['a','b'] &gt;&gt;= \ch -&gt; return (n, ch)
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e26275"/><img src="httpatomoreillycomsourcenostarchimages802692.png.jpg" alt="image with no caption"/></div></div><p>The numbers from the list <code class="literal">[1,2]</code> are bound to <code class="literal">n</code>, and the characters from the list <code class="literal">['a','b']</code> are bound to <code class="literal">ch</code>. Then we do <code class="literal">return (n, ch)</code> (or <code class="literal">[(n, ch)]</code>), which means taking a pair of <code class="literal">(n, ch)</code> and putting it in a default minimal context. In this case, it’s making the smallest possible list that still presents <code class="literal">(n, ch)</code> as the result and features as little nondeterminism as possible. Its effect on the context is minimal. We’re saying, “For every element in <code class="literal">[1,2]</code>, go over every element in <code class="literal">['a','b']</code> and produce a tuple of one element from each list.”</p><p>Generally speaking, because <code class="literal">return</code> takes a value and wraps it in a minimal context, it doesn’t have any extra effect (like failing in <code class="literal">Maybe</code> or resulting in more nondeterminism for lists), but it does present something as its result.</p><p>When you have nondeterministic values interacting, you can view their computation as a tree where every possible result in a list represents a separate branch. Here’s the previous expression rewritten in <code class="literal">do</code> notation:</p><a id="I_programlisting13_d1e26326"/><pre class="programlisting">listOfTuples :: [(Int, Char)]
listOfTuples = do
    n &lt;- [1,2]
    ch &lt;- ['a','b']
    return (n, ch)</pre><p>This makes it a bit more obvious that <code class="literal">n</code> takes on every value from <code class="literal">[1,2]</code> and <code class="literal">ch</code> takes on every value from <code class="literal">['a','b']</code>. Just as with <code class="literal">Maybe</code>, we’re extracting the elements from the monadic values and treating them like normal values, and <code class="literal">&gt;&gt;=</code> takes care of the context for us. The context in this case is nondeterminism.</p><div class="sect2" title="do Notation and List Comprehensions"><div class="titlepage"><div><div><h2 class="title"><a id="do_notation_and_list_comprehensions"/>do Notation and List Comprehensions</h2></div></div></div><p>Using lists with <code class="literal">do</code> notation might remind you of something you’ve seen before. For instance, check out the following piece of code:<a id="IDX-CHP-13-0067" class="indexterm"/><a id="IDX-CHP-13-0068" class="indexterm"/><a id="IDX-CHP-13-0069" class="indexterm"/><a id="IDX-CHP-13-0070" class="indexterm"/><a id="IDX-CHP-13-0071" class="indexterm"/><a id="IDX-CHP-13-0072" class="indexterm"/><a id="IDX-CHP-13-0073" class="indexterm"/></p><a id="I_programlisting13_d1e26386"/><pre class="programlisting">ghci&gt; [ (n, ch) | n &lt;- [1,2], ch &lt;- ['a','b'] ]
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]</pre><p>Yes, list comprehensions! In our <code class="literal">do</code> notation example, <code class="literal">n</code> became every result from <code class="literal">[1,2]</code>. For every such result, <code class="literal">ch</code> was assigned a result from <code class="literal">['a','b']</code>, and then the final line put <code class="literal">(n, ch)</code> into a default context (a singleton list) to present it as the result without introducing any additional nondeterminism. In this list comprehension, the same thing happened, but we didn’t need to write <code class="literal">return</code> at the end to present <code class="literal">(n, ch)</code> as the result, because the output part of a list comprehension did that for us.</p><p>In fact, list comprehensions are just syntactic sugar for using lists as monads. In the end, list comprehensions and lists in <code class="literal">do</code> notation translate to using <code class="literal">&gt;&gt;=</code> to do computations that feature nondeterminism.</p></div><div class="sect2" title="MonadPlus and the guard Function"><div class="titlepage"><div><div><h2 class="title"><a id="monadplus_and_the_guard_function"/>MonadPlus and the guard Function</h2></div></div></div><p>List comprehensions allow us to filter our output. For instance, we can filter a list of numbers to search only for numbers whose digits contain a <code class="literal">7</code>:</p><a id="I_programlisting13_d1e26431"/><pre class="programlisting">ghci&gt; [ x | x &lt;- [1..50], '7' `elem` show x ]
[7,17,27,37,47]</pre><p>We apply <code class="literal">show</code> to <code class="literal">x</code> to turn our number into a string, and then we check if the character <code class="literal">'7'</code> is part of that string.</p><p>To see how filtering in list comprehensions translates to the list monad, we need to check out the <code class="literal">guard</code> function and the <code class="literal">MonadPlus</code> type class.<a id="IDX-CHP-13-0074" class="indexterm"/></p><p>The <code class="literal">MonadPlus</code> type class is for monads that can also act as monoids. Here is its definition:<a id="IDX-CHP-13-0075" class="indexterm"/></p><a id="I_programlisting13_d1e26467"/><pre class="programlisting">class Monad m =&gt; MonadPlus m where
    mzero :: m a
    mplus :: m a -&gt; m a -&gt; m a</pre><p><code class="literal">mzero</code> is synonymous with <code class="literal">mempty</code> from the <code class="literal">Monoid</code> type class, and <code class="literal">mplus</code> corresponds to <code class="literal">mappend</code>. Because lists are monoids as well as monads, they can be made an instance of this type class:</p><a id="I_programlisting13_d1e26485"/><pre class="programlisting">instance MonadPlus [] where
    mzero = []
    mplus = (++)</pre><p>For lists, <code class="literal">mzero</code> represents a nondeterministic computation that has no results at all—a failed computation. <code class="literal">mplus</code> joins two nondeterministic values into one. The <code class="literal">guard</code> function is defined like this:<a id="IDX-CHP-13-0076" class="indexterm"/><a id="IDX-CHP-13-0077" class="indexterm"/></p><a id="I_programlisting13_d1e26506"/><pre class="programlisting">guard :: (MonadPlus m) =&gt; Bool -&gt; m ()
guard True = return ()
guard False = mzero</pre><p><code class="literal">guard</code> takes a Boolean value. If that value is <code class="literal">True</code>, guard takes a <code class="literal">()</code> and puts it in a minimal default context that still succeeds. If the Boolean value is <code class="literal">False</code>, guard makes a failed monadic value. Here it is in action:</p><a id="I_programlisting13_d1e26522"/><pre class="programlisting">ghci&gt; guard (5 &gt; 2) :: Maybe ()
Just ()
ghci&gt; guard (1 &gt; 2) :: Maybe ()
Nothing
ghci&gt; guard (5 &gt; 2) :: [()]
[()]
ghci&gt; guard (1 &gt; 2) :: [()]
[]</pre><p>This looks interesting, but how is it useful? In the list monad, we use it to filter out nondeterministic computations:</p><a id="I_programlisting13_d1e26526"/><pre class="programlisting">ghci&gt; [1..50] &gt;&gt;= (\x -&gt; guard ('7' `elem` show x) &gt;&gt; return x)
[7,17,27,37,47]</pre><p>The result here is the same as the result of our previous list comprehension. How does <code class="literal">guard</code> achieve this? Let’s first see how <code class="literal">guard</code> functions in conjunction with <code class="literal">&gt;&gt;</code>:</p><a id="I_programlisting13_d1e26539"/><pre class="programlisting">ghci&gt; guard (5 &gt; 2) &gt;&gt; return "cool" :: [String]
["cool"]
ghci&gt; guard (1 &gt; 2) &gt;&gt; return "cool" :: [String]
[]</pre><p>If <code class="literal">guard</code> succeeds, the result contained within it is an empty tuple. So then we use <code class="literal">&gt;&gt;</code> to ignore that empty tuple and present something else as the result. However, if <code class="literal">guard</code> fails, then so will the <code class="literal">return</code> later on, because feeding an empty list to a function with <code class="literal">&gt;&gt;=</code> always results in an empty list. <code class="literal">guard</code> basically says, “If this Boolean is <code class="literal">False</code>, then produce a failure right here. Otherwise, make a successful value that has a dummy result of <code class="literal">()</code> inside it.” All this does is to allow the computation to continue.</p><p>Here’s the previous example rewritten in <code class="literal">do</code> notation:<a id="IDX-CHP-13-0078" class="indexterm"/><a id="IDX-CHP-13-0079" class="indexterm"/><a id="IDX-CHP-13-0080" class="indexterm"/><a id="IDX-CHP-13-0081" class="indexterm"/></p><a id="I_programlisting13_d1e26587"/><pre class="programlisting">sevensOnly :: [Int]
sevensOnly = do
    x &lt;- [1..50]
    guard ('7' `elem` show x)
    return x</pre><p>Had we forgotten to present <code class="literal">x</code> as the final result by using <code class="literal">return</code>, the resulting list would just be a list of empty tuples. Here’s this again in the form of a list comprehension:</p><a id="I_programlisting13_d1e26597"/><pre class="programlisting">ghci&gt; [ x | x &lt;- [1..50], '7' `elem` show x ]
[7,17,27,37,47]</pre><p>So filtering in list comprehensions is the same as using <code class="literal">guard</code>.</p></div><div class="sect2" title="A Knight's Quest"><div class="titlepage"><div><div><h2 class="title"><a id="a_knight_apostrophy_s_quest"/>A Knight's Quest</h2></div></div></div><p>Here’s a problem that really lends itself to being solved with nondeterminism. Say we have a chessboard and only one knight piece on it. We want to find out if the knight can reach a certain position in three moves. We’ll just use a pair of numbers to represent the knight’s position on the chessboard. The first number will determine the column he is in, and the second number will determine the row.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e26611"/><img src="httpatomoreillycomsourcenostarchimages802694.png.jpg" alt="image with no caption"/></div></div><p>Let’s make a type synonym for the knight’s current position on the chessboard:</p><a id="I_programlisting13_d1e26618"/><pre class="programlisting">type KnightPos = (Int, Int)</pre><p>Now suppose that the knight starts at <code class="literal">(6, 2)</code>. Can he get to <code class="literal">(6, 1)</code> in exactly three moves? What’s the best move to make next from his current position? I know—how about all of them! We have nondeterminism at our disposal, so instead of picking one move, let’s pick all of them at once. Here is a function that takes the knight’s position and returns all of his next moves:</p><a id="I_programlisting13_d1e26628"/><pre class="programlisting">moveKnight :: KnightPos -&gt; [KnightPos]
moveKnight (c,r) = do
    (c', r') &lt;- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)
               ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)
               ]
    guard (c' `elem` [1..8] &amp;&amp; r' `elem` [1..8])
    return (c', r')</pre><p>The knight can always take one step horizontally or vertically and two steps horizontally or vertically, but his movement must be both horizontal and vertical. <code class="literal">(c', r')</code> takes on every value from the list of movements and then <code class="literal">guard</code> makes sure that the new move, <code class="literal">(c', r')</code>, is still on the board. If it’s not, it produces an empty list, which causes a failure and <code class="literal">return (c', r')</code> isn’t carried out for that position.</p><p>This function can also be written without the use of lists as monads. Here is how to write it using <code class="literal">filter</code>:</p><a id="I_programlisting13_d1e26649"/><pre class="programlisting">moveKnight :: KnightPos -&gt; [KnightPos]
moveKnight (c, r) = filter onBoard
    [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)
    ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)
    ]
    where onBoard (c, r) = c `elem` [1..8] &amp;&amp; r `elem` [1..8]</pre><p>Both of these versions do the same thing, so pick the one that looks nicer to you. Let’s give it a whirl:</p><a id="I_programlisting13_d1e26654"/><pre class="programlisting">ghci&gt; moveKnight (6, 2)
[(8,1),(8,3),(4,1),(4,3),(7,4),(5,4)]
ghci&gt; moveKnight (8, 1)
[(6,2),(7,3)]</pre><p>Works like a charm! We take one position, and we just carry out all the possible moves at once, so to speak.</p><p>So now that we have a nondeterministic next position, we just use <code class="literal">&gt;&gt;=</code> to feed it to <code class="literal">moveKnight</code>. Here’s a function that takes a position and returns all the positions that you can reach from it in three moves:</p><a id="I_programlisting13_d1e26666"/><pre class="programlisting">in3 :: KnightPos -&gt; [KnightPos]
in3 start = do
    first &lt;- moveKnight start
    second &lt;- moveKnight first
    moveKnight second</pre><p>If you pass it <code class="literal">(6, 2)</code>, the resulting list is quite big. This is because if there are several ways to reach some position in three moves, the move crops up in the list several times.<a id="IDX-CHP-13-0082" class="indexterm"/><a id="IDX-CHP-13-0083" class="indexterm"/><a id="IDX-CHP-13-0084" class="indexterm"/><a id="IDX-CHP-13-0085" class="indexterm"/><a id="IDX-CHP-13-0086" class="indexterm"/></p><p>Here’s the preceding code without <code class="literal">do</code> notation:</p><a id="I_programlisting13_d1e26697"/><pre class="programlisting">in3 start = return start &gt;&gt;= moveKnight &gt;&gt;= moveKnight &gt;&gt;= moveKnight</pre><p>Using <code class="literal">&gt;&gt;=</code> once gives us all possible moves from the start. When we use <code class="literal">&gt;&gt;=</code> the second time, for every possible first move, every possible next move is computed, and the same goes for the last move.</p><p>Putting a value in a default context by applying <code class="literal">return</code> to it and then feeding it to a function with <code class="literal">&gt;&gt;=</code> is the same as just normally applying the function to that value, but we did it here anyway for style.</p><p>Now, let’s make a function that takes two positions and tells us if you can get from one to the other in exactly three steps:</p><a id="I_programlisting13_d1e26717"/><pre class="programlisting">canReachIn3 :: KnightPos -&gt; KnightPos -&gt; Bool
canReachIn3 start end = end `elem` in3 start</pre><p>We generate all the possible positions in three steps, and then we see if the position we’re looking for is among them. Here’s how to check if we can get from <code class="literal">(6, 2)</code> to <code class="literal">(6, 1)</code> in three moves:</p><a id="I_programlisting13_d1e26728"/><pre class="programlisting">ghci&gt; (6, 2) `canReachIn3` (6, 1)
True</pre><p>Yes! How about from <code class="literal">(6, 2)</code> to <code class="literal">(7, 3)</code>?</p><a id="I_programlisting13_d1e26738"/><pre class="programlisting">ghci&gt; (6, 2) `canReachIn3` (7, 3)
False</pre><p>No! As an exercise, you can change this function so that when you can reach one position from the other, it tells you which move to take. In <a class="xref" href="ch14.html" title="Chapter 14. For a Few Monads More">Chapter 14</a>, you’ll see how to modify this function so that we also pass it the number of moves to take, instead of that number being hardcoded as it is now.</p></div></div>
<div class="sect1" title="Monad Laws"><div class="titlepage"><div><div><h1 class="title"><a id="monad_laws"/>Monad Laws</h1></div></div></div><p>Just like functors and applicative functors, monads come with a few laws that all monad instances must abide by. Just because something is made an instance of the <code class="literal">Monad</code> type class doesn’t mean that it’s actually a monad. For a type to truly be a monad, the monad laws must hold for that type. These laws allow us to make reasonable assumptions about the type and its behavior.<a id="IDX-CHP-13-0087" class="indexterm"/><a id="IDX-CHP-13-0088" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject13_d1e26763"/><img src="httpatomoreillycomsourcenostarchimages802696.png.jpg" alt="image with no caption"/></div></div><p>Haskell allows any type to be an instance of any type class as long as the types check out. It can’t check if the monad laws hold for a type though, so if we’re making a new instance of the <code class="literal">Monad</code> type class, we need to be reasonably sure that all is well with the monad laws for that type. We can rely on the types that come with the standard library to satisfy the laws, but when we go about making our own monads, we need to manually check whether the laws hold. But don’t worry, they’re not complicated.</p><div class="sect2" title="Left Identity"><div class="titlepage"><div><div><h2 class="title"><a id="left_identity"/>Left Identity</h2></div></div></div><p>The first monad law states that if we take a value, put it in a default context with <code class="literal">return</code>, and then feed it to a function by using <code class="literal">&gt;&gt;=</code>, that’s the same as just taking the value and applying the function to it. To put it formally, <code class="literal">return x &gt;&gt;= f</code> is the same damn thing as <code class="literal">f x</code>.</p><p>If you look at monadic values as values with a context, and <code class="literal">return</code> as taking a value and putting it in a default minimal context that still presents that value as the function’s result, this law makes sense. If that context is really minimal, feeding this monadic value to a function shouldn’t be much different than just applying the function to the normal value—and indeed, it isn’t different at all.</p><p>For the <code class="literal">Maybe</code> monad, <code class="literal">return</code> is defined as <code class="literal">Just</code>. The <code class="literal">Maybe</code> monad is all about possible failure, and if we have a value that we want to put in such a context, treating it as a successful computation makes sense, because we know what the value is. Here are some examples of <code class="literal">return</code> usage with <code class="literal">Maybe</code>:</p><a id="I_programlisting13_d1e26816"/><pre class="programlisting">ghci&gt; return 3 &gt;&gt;= (\x -&gt; Just (x+100000))
Just 100003
ghci&gt; (\x -&gt; Just (x+100000)) 3
Just 100003</pre><p>For the list monad, <code class="literal">return</code> puts something in a singleton list. The <code class="literal">&gt;&gt;=</code> implementation for lists goes over all the values in the list and applies the function to them. However, since there’s only one value in a singleton list, it’s the same as applying the function to that value:</p><a id="I_programlisting13_d1e26826"/><pre class="programlisting">ghci&gt; return "WoM" &gt;&gt;= (\x -&gt; [x,x,x])
["WoM","WoM","WoM"]
ghci&gt; (\x -&gt; [x,x,x]) "WoM"
["WoM","WoM","WoM"]</pre><p>You’ve learned that for <code class="literal">IO</code>, using <code class="literal">return</code> makes an I/O action that has no side effects but just presents a value as its result. So it makes sense that this law holds for <code class="literal">IO</code> as well.</p></div><div class="sect2" title="Right Identity"><div class="titlepage"><div><div><h2 class="title"><a id="right_identity"/>Right Identity</h2></div></div></div><p>The second law states that if we have a monadic value and we use <code class="literal">&gt;&gt;=</code> to feed it to <code class="literal">return</code>, the result is our original monadic value. Formally, <code class="literal">m &gt;&gt;= return</code> is no different than just <code class="literal">m</code>.<a id="IDX-CHP-13-0089" class="indexterm"/><a id="IDX-CHP-13-0090" class="indexterm"/></p><p>This law might be a bit less obvious than the first one. Let’s take a look at why it should hold. When we feed monadic values to functions by using <code class="literal">&gt;&gt;=</code>, those functions take normal values and return monadic ones. <code class="literal">return</code> is also one such function, if you consider its type.</p><p><code class="literal">return</code> puts a value in a minimal context that still presents that value as its result. This means that, for instance, for <code class="literal">Maybe</code>, it doesn’t introduce any failure; for lists, it doesn’t introduce any extra nondeterminism.</p><p>Here’s a test run for a few monads:</p><a id="I_programlisting13_d1e26883"/><pre class="programlisting">ghci&gt; Just "move on up" &gt;&gt;= (\x -&gt; return x)
Just "move on up"
ghci&gt; [1,2,3,4] &gt;&gt;= (\x -&gt; return x)
[1,2,3,4]
ghci&gt; putStrLn "Wah!" &gt;&gt;= (\x -&gt; return x)
Wah!</pre><p>In this list example, the implementation for <code class="literal">&gt;&gt;=</code> is as follows:</p><a id="I_programlisting13_d1e26890"/><pre class="programlisting">xs &gt;&gt;= f = concat (map f xs)</pre><p>So when we feed <code class="literal">[1,2,3,4]</code> to <code class="literal">return</code>, first <code class="literal">return</code> gets mapped over <code class="literal">[1,2,3, 4]</code>, resulting in <code class="literal">[[1],[2],[3],[4]]</code>. Then this is concatenated, and we have our original list.</p><p>Left identity and right identity are basically laws that describe how <code class="literal">return</code> should behave. It’s an important function for making normal values into monadic ones, and it wouldn’t be good if the monadic value that it produced had any more than the minimal context needed.<a id="IDX-CHP-13-0091" class="indexterm"/></p></div><div class="sect2" title="Associativity"><div class="titlepage"><div><div><h2 class="title"><a id="associativity"/>Associativity</h2></div></div></div><p>The final monad law says that when we have a chain of monadic function applications with <code class="literal">&gt;&gt;=</code>, it shouldn’t matter how they’re nested. Formally written, doing <code class="literal">(m &gt;&gt;= f) &gt;&gt;= g</code> is just like doing <code class="literal">m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code>.</p><p>Hmmm, now what’s going on here? We have one monadic value, <code class="literal">m</code>, and two monadic functions, <code class="literal">f</code> and <code class="literal">g</code>. When we’re using <code class="literal">(m &gt;&gt;= f) &gt;&gt;= g</code>, we’re feeding <code class="literal">m</code> to <code class="literal">f</code>, which results in a monadic value. Then we feed that monadic value to <code class="literal">g</code>. In the expression <code class="literal">m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code>, we take a monadic value and we give it to a function that feeds the result of <code class="literal">f x</code> to <code class="literal">g</code>. It’s not easy to see how those two are equal, so let’s take a look at an example that makes this equality a bit clearer.</p><p>Remember when we had our tightrope walker, Pierre, walk a rope while birds landed on his balancing pole? To simulate birds landing on his balancing pole, we made a chain of several functions that might produce failure:</p><a id="I_programlisting13_d1e26968"/><pre class="programlisting">ghci&gt; return (0, 0) &gt;&gt;= landRight 2 &gt;&gt;= landLeft 2 &gt;&gt;= landRight 2
Just (2,4)</pre><p>We started with <code class="literal">Just (0, 0)</code> and then bound that value to the next monadic function, <code class="literal">landRight 2</code>. The result of that was another monadic value, which got bound to the next monadic function, and so on. If we were to explicitly parenthesize this, we would write the following:</p><a id="I_programlisting13_d1e26978"/><pre class="programlisting">ghci&gt; ((return (0, 0) &gt;&gt;= landRight 2) &gt;&gt;= landLeft 2) &gt;&gt;= landRight 2
Just (2,4)</pre><p>But we can also write the routine like this:</p><a id="I_programlisting13_d1e26982"/><pre class="programlisting">return (0, 0) &gt;&gt;= (\x -&gt;
landRight 2 x &gt;&gt;= (\y -&gt;
landLeft 2 y &gt;&gt;= (\z -&gt;
landRight 2 z)))</pre><p><code class="literal">return (0, 0)</code> is the same as <code class="literal">Just (0, 0)</code>, and when we feed it to the lambda, the <code class="literal">x</code> becomes <code class="literal">(0, 0)</code>. <code class="literal">landRight</code> takes a number of birds and a pole (a tuple of numbers), and that’s what it gets passed. This results in a <code class="literal">Just (0, 2)</code>, and when we feed this to the next lambda, <code class="literal">y</code> is <code class="literal">(0, 2)</code>. This goes on until the final bird landing produces a <code class="literal">Just (2, 4)</code>, which is indeed the result of the whole expression.</p><p>So it doesn’t matter how you nest feeding values to monadic functions. What matters is their meaning. Let’s consider another way to look at this law. Suppose we compose two functions named <code class="literal">f</code> and <code class="literal">g</code>:</p><a id="I_programlisting13_d1e27022"/><pre class="programlisting">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
f . g = (\x -&gt; f (g x))</pre><p>If the type of <code class="literal">g</code> is <code class="literal">a -&gt; b</code> and the type of <code class="literal">f</code> is <code class="literal">b -&gt; c</code>, we arrange them into a new function that has a type of <code class="literal">a -&gt; c</code>, so that its parameter is passed between those functions. Now what if those two functions were monadic? What if the values they returned were monadic values? If we had a function of type <code class="literal">a -&gt; m b</code>, we couldn’t just pass its result to a function of type <code class="literal">b -&gt; m c</code>, because that function accepts a normal <code class="literal">b</code>, not a monadic one. We could, however, use <code class="literal">&gt;&gt;=</code> to make that happen.</p><a id="I_programlisting13_d1e27054"/><pre class="programlisting">(&lt;=&lt;) :: (Monad m) =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)
f &lt;=&lt; g = (\x -&gt; g x &gt;&gt;= f)</pre><p>So now we can compose two monadic functions:</p><a id="I_programlisting13_d1e27058"/><pre class="programlisting">ghci&gt; let f x = [x,-x]
ghci&gt; let g x = [x*3,x*2]
ghci&gt; let h = f &lt;=&lt; g
ghci&gt; h 3
[9,-9,6,-6]</pre><p>Okay, that’s cool. But what does that have to do with the associativity law? Well, when we look at the law as a law of compositions, it states that <code class="literal">f &lt;=&lt; (g &lt;=&lt; h)</code> should be the same as <code class="literal">(f &lt;=&lt; g) &lt;=&lt; h</code>. This is just another way of saying that for monads, the nesting of operations shouldn’t matter.</p><p>If we translate the first two laws to use <code class="literal">&lt;=&lt;</code>, then the left identity law states that for every monadic function <code class="literal">f</code>, <code class="literal">f &lt;=&lt; return</code> is the same as writing just <code class="literal">f</code>. The right identity law says that <code class="literal">return &lt;=&lt; f</code> is also no different from <code class="literal">f</code>. This is similar to how if <code class="literal">f</code> is a normal function, <code class="literal">(f . g) . h</code> is the same as <code class="literal">f . (g . h)</code>, <code class="literal">f . id</code> is always the same as <code class="literal">f</code>, and <code class="literal">id . f</code> is also just <code class="literal">f</code>.</p><p>In this chapter, we took a look at the basics of monads and learned how the <code class="literal">Maybe</code> monad and the list monad work. In the next chapter, we’ll explore a whole bunch of other cool monads, and we’ll also make our own.</p></div></div></body></html>