<html><head></head><body><div class="chapter" title="Chapter&#xA0;16.&#xA0;Regular Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="regular_expressions"/>Chapter 16. Regular Expressions</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id19"/><div class="mediaobject"><a id="I_mediaobject16_d1e17899"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>Regular expressions provide you with powerful ways to find and modify patterns in text—not only short bits of text such as might be entered at a command prompt but also huge stores of text such as might be found in files on disk.<a id="IDX-CHP-16-0001" class="indexterm"/></p><p>A regular expression takes the form of a pattern that is compared with a string. Regular expressions also provide the means by which you can modify strings so that, for example, you might change specific characters by putting them into uppercase, you might replace every occurrence of “Diamond” with “Ruby,” or you might read in a file of programming code, extract all the comments, and write out a new documentation file containing all the comments but none of the code. You’ll find out how to write a comment-extraction tool shortly. First, though, let’s take a look at some very simple regular expressions.</p><div class="sect1" title="Making Matches"><div class="titlepage"><div><div><h1 class="title"><a id="making_matches"/>Making Matches</h1></div></div></div><p>Just about the simplest regular expression is a sequence of characters (such as “abc”) that you want to find in a string. A regular expression to match “abc” can be created by placing those letters between two forward slash delimiters, like this: <code class="literal">/abc/</code>. You can test for a match using the <code class="literal">=˜</code> operator method like this:<a id="IDX-CHP-16-0002" class="indexterm"/><a id="IDX-CHP-16-0003" class="indexterm"/><a id="IDX-CHP-16-0004" class="indexterm"/><a id="IDX-CHP-16-0005" class="indexterm"/><a id="IDX-CHP-16-0006" class="indexterm"/></p><p><span class="emphasis"><em>regex0.rb</em></span></p><a id="I_programlisting16_d1e17950"/><pre class="programlisting">p( /abc/ =˜ 'abc' )                 #=&gt; 0</pre><p>If a match is made, an integer representing the character position in the string is returned. If no match is made, <code class="literal">nil</code> is returned.</p><a id="I_programlisting16_d1e17957"/><pre class="programlisting">p( /abc/ =˜ 'xyzabcxyzabc' )        #=&gt; 3
p( /abc/ =˜ 'xycab' )               #=&gt; nil</pre><p>You can also specify a group of characters, between square brackets, in which case a match will be made with any one of those characters in the string. Here, for example, the first match is made with “c”; then that character’s position in the string is returned:</p><a id="I_programlisting16_d1e17961"/><pre class="programlisting">p( /[abc]/ =˜ 'xycba' )             #=&gt; 2</pre><p>Although I’ve used forward-slash delimiters in the previous examples, there are alternative ways of defining regular expressions: You can specifically create a new Regexp object initialized with a string, or you can precede the regular expression with <code class="literal">%r</code> and use custom delimiters—nonalphanumeric characters—as you can with strings (see <a class="xref" href="ch03.html" title="Chapter 3. Strings and Ranges">Chapter 3</a>). In the following example, I use curly bracket delimiters:<a id="IDX-CHP-16-0007" class="indexterm"/><a id="IDX-CHP-16-0008" class="indexterm"/><a id="IDX-CHP-16-0009" class="indexterm"/><a id="IDX-CHP-16-0010" class="indexterm"/></p><p><span class="emphasis"><em>regex1.rb</em></span></p><a id="I_programlisting16_d1e17991"/><pre class="programlisting">regex1 = Regexp.new('^[a-z]*$')
regex2 = /^[a-z]*$/
regex3 = %r{^[a-z]*$}</pre><p>Each of the previous examples defines a regular expression that matches an all-lowercase string (I’ll explain the details of the expressions shortly). These expressions can be used to test strings like this:</p><a id="I_programlisting16_d1e17996"/><pre class="programlisting">def test( aStr, aRegEx )
    if aRegEx =˜ aStr then
        puts( "All lowercase" )
    else
        puts( "Not all lowercase" )
    end
end

test( "hello", regex1 )             #=&gt; matches: "All lowercase"
test( "hello", regex2 )             #=&gt; matches: "All lowercase"
test( "Hello", regex3 )             #=&gt; no match: "Not all lowercase"</pre><p>To test for a match, you can use <code class="literal">if</code> and the <code class="literal">=˜</code> operator:<a id="IDX-CHP-16-0011" class="indexterm"/><a id="IDX-CHP-16-0012" class="indexterm"/><a id="IDX-CHP-16-0013" class="indexterm"/><a id="IDX-CHP-16-0014" class="indexterm"/><a id="IDX-CHP-16-0015" class="indexterm"/><a id="IDX-CHP-16-0016" class="indexterm"/><a id="IDX-CHP-16-0017" class="indexterm"/><a id="IDX-CHP-16-0018" class="indexterm"/><a id="IDX-CHP-16-0019" class="indexterm"/><a id="IDX-CHP-16-0020" class="indexterm"/><a id="IDX-CHP-16-0021" class="indexterm"/><a id="IDX-CHP-16-0022" class="indexterm"/><a id="IDX-CHP-16-0023" class="indexterm"/></p><a id="I_programlisting16_d1e18064"/><pre class="programlisting">if /def/ =˜ 'abcdef'</pre><p>The previous expression evaluates to true if a match is made (and an integer is returned); it would evaluate to false if no match were made (and <code class="literal">nil</code> were returned):</p><p><span class="emphasis"><em>if_test.rb</em></span></p><a id="I_programlisting16_d1e18074"/><pre class="programlisting">RegEx = /def/
Str1  = 'abcdef'
Str2  = 'ghijkl'

if RegEx =˜ Str1 then
    puts( 'true' )
else
    puts( 'false' )
end                          #=&gt; displays: true

if RegEx =˜ Str2 then
    puts( 'true' )
else
    puts( 'false' )
end                          #=&gt; displays: false</pre><p>Frequently, it is useful to attempt to match some expression from the very start of a string; you can use the character <code class="literal">^</code> followed by a match term to specify this. It may also be useful to make a match from the end of the string; you use the character <code class="literal">$</code> preceded by a match term to specify that.</p><p><span class="emphasis"><em>start_end1.rb</em></span></p><a id="I_programlisting16_d1e18087"/><pre class="programlisting">puts( /^a/ =˜ 'abc' )        #=&gt; 0
puts( /^b/ =˜ 'abc' )        #=&gt; nil
puts( /c$/ =˜ 'abc' )        #=&gt; 2
puts( /b$/ =˜ 'abc' )        #=&gt; nil</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>As mentioned previously, when a <code class="literal">nil</code> value is passed to <code class="literal">print</code> or <code class="literal">puts</code> in Ruby 1.9, nothing is displayed. In Ruby 1.8, <code class="literal">nil</code> is displayed. To be sure that <code class="literal">nil</code> is displayed in Ruby 1.9, use <code class="literal">p</code> instead of <code class="literal">puts</code>.</p></div><p>Matching from the start or end of a string becomes more useful when it forms part of a more complex expression. Often such an expression tries to match zero or more instances of a specified pattern. The <code class="literal">*</code> character is used to indicate zero or more matches of the pattern that it follows. Formally, this is known as a <span class="emphasis"><em>quantifier</em></span>. Consider this example:</p><p><span class="emphasis"><em>start_end2.rb</em></span></p><a id="I_programlisting16_d1e18126"/><pre class="programlisting">p( /^[a-z 0-9]*$/ =˜ 'well hello 123' )</pre><p>Here, the regular expression specifies a range of characters between square brackets. This range includes all lowercase characters (a–z), all digits (0–9), and the space character (that’s the space between the <code class="literal">z</code> and the <code class="literal">0</code> in the expression shown earlier). The <code class="literal">^</code> character means the match must be made from the start of the string, the <code class="literal">*</code> character after the range means that zero or more matches with the characters in the range must be made, and the <code class="literal">$</code> character means that the matches must be made right up to the end of the string. In other words, this pattern will only match a string containing lowercase characters, digits, and spaces from the start right to the end of the string:<a id="IDX-CHP-16-0024" class="indexterm"/><a id="IDX-CHP-16-0025" class="indexterm"/><a id="IDX-CHP-16-0026" class="indexterm"/></p><a id="I_programlisting16_d1e18159"/><pre class="programlisting">puts( /^[a-z 0-9]*$/ =˜ 'well hello 123' ) # match at 0
puts( /^[a-z 0-9]*$/ =˜ 'Well hello 123' ) # no match due to ^ and upcase W</pre><p>Actually, this pattern will also match an empty string, since <code class="literal">*</code> indicates that <span class="emphasis"><em>zero or more</em></span> matches are acceptable:</p><a id="I_programlisting16_d1e18169"/><pre class="programlisting">puts( /^[a-z 0-9]*$/ =˜ '' )        # this matches!</pre><p>If you want to exclude empty strings, use <code class="literal">+</code> (to match <span class="emphasis"><em>one or more</em></span> occurrences of the pattern):</p><a id="I_programlisting16_d1e18179"/><pre class="programlisting">puts( /^[a-z 0-9]+$/ =˜ '' )        # no match</pre><p>Try the code in <span class="emphasis"><em>start_end2.rb</em></span> for more examples of ways in which <code class="literal">^</code>, <code class="literal">$</code>, <code class="literal">*</code> and <code class="literal">+</code> may be combined with ranges to create a variety of different match patterns.</p><p>You could use these techniques to determine specific characteristics of strings, such as whether a given string is uppercase, lowercase, or mixed case:</p><p><span class="emphasis"><em>regex2.rb</em></span></p><a id="I_programlisting16_d1e18204"/><pre class="programlisting">aStr = "HELLO WORLD"

case aStr
    when /^[a-z 0-9]*$/
        puts( "Lowercase" )
    when /^[A-Z 0-9]*$/
        puts( "Uppercase" )
    else
        puts( "Mixed case\n" )
end</pre><p>Since the string assigned to <code class="literal">aStr</code> is currently all uppercase, the previous code displays the “Uppercase” string. But if <code class="literal">aStr</code> were assigned <code class="literal">hello world</code>, it would display “Lowercase,” and if <code class="literal">aStr</code> were assigned <code class="literal">Hello World</code>, it would display “Mixed case.”</p><p>Often regular expressions are used to process the text in a file on disk. Let’s suppose, for example, that you want to display all the full-line comments in a Ruby file but omit all the code and partial-line comments. You could do this by trying to match from the start of each line (<code class="literal">^</code>) zero or more whitespace characters (a whitespace character is represented by <code class="literal">\s</code>) up to a comment character (<code class="literal">#</code>).</p><p><span class="emphasis"><em>regex3a.rb</em></span></p><a id="I_programlisting16_d1e18237"/><pre class="programlisting"># displays all the full-line comments in a Ruby file
File.foreach( 'regex1.rb' ){ |line|
    if line =˜ /^\s*#/ then
        puts( line )
    end
}</pre></div></div>
<div class="sect1" title="Match Groups"><div class="titlepage"><div><div><h1 class="title"><a id="match_groups"/>Match Groups</h1></div></div></div><p>You can also use a regular expression to match one or more substrings. To do this, you should put part of the regular expression between parentheses. Here I have two groups (sometimes called <span class="emphasis"><em>captures</em></span>): The first tries to match the string “hi”, and the second tries to match a string starting with “h” followed by any three characters (a dot means “match any single character,” so the three dots here will match any three consecutive characters) and ending with “o”:<a id="IDX-CHP-16-0027" class="indexterm"/><a id="IDX-CHP-16-0028" class="indexterm"/></p><p><span class="emphasis"><em>groups.rb</em></span></p><a id="I_programlisting16_d1e18260"/><pre class="programlisting">/(hi).*(h...o)/ =˜ "The word 'hi' is short for 'hello'."</pre><p>After evaluating groups in a regular expression, a number of variables, equal to the number of groups, will be assigned the matched value of those groups. These variables take the form of a <code class="literal">$</code> followed by a number: <code class="literal">$1</code>, <code class="literal">$2</code>, <code class="literal">$3</code>, and so on. After executing the previous code, I can access the variables <code class="literal">$1</code> and <code class="literal">$2</code> like this:</p><a id="I_programlisting16_d1e18283"/><pre class="programlisting">print( $1, " ", $2, "\n" )        #=&gt; hi hello</pre><p>Note that if the entire regular expression is unmatched, none of the group variables will be initialized. This would be the case if, for example, “hi” were in the string but “hello” was not. Both group variables would then be <code class="literal">nil</code>.</p><p>Here is another example, which returns three groups, indicated by pairs of parentheses (<code class="literal">()</code>), each of which contains a single character given by the dot: <code class="literal">(.)</code>. Groups <code class="literal">$1</code> and <code class="literal">$3</code> are then displayed:</p><a id="I_programlisting16_d1e18304"/><pre class="programlisting">/(.)(.)(.)/ =˜ "abcdef"
print( $1, " ", $3, "\n" )        #=&gt; a c</pre><p>Here is a new version of the comment-matching program that was given earlier (<span class="emphasis"><em>regex3a.rb</em></span>); this has now been adapted to use the value of the group <code class="literal">()</code> containing a dot followed by an asterisk <code class="literal">(.*)</code> to return all the characters (zero or more) following the string matched by the preceding part of the regular expression (which here is <code class="literal">^\s*#</code>). This new version reads the text from the specified file and matches zero or more whitespace (<code class="literal">\s*</code>) characters from the start of the current line (<code class="literal">^</code>) up to the first occurrence of a hash mark: <code class="literal">#</code>.</p><p><span class="emphasis"><em>regex3b.rb</em></span><a id="IDX-CHP-16-0029" class="indexterm"/></p><a id="I_programlisting16_d1e18339"/><pre class="programlisting">File.foreach( 'regex1.rb' ){ |line|
    if line =˜ /^\s*#(.*)/ then
        puts( $1 )
    end
}</pre><p>The end result of this is that only lines in which the first printable character is <code class="literal">#</code> are matched; <code class="literal">$1</code> prints out the text of those lines minus the <code class="literal">#</code> character itself. As you will see shortly, this simple technique provides the basis of a useful tool for extracting documentation from a Ruby file.<a id="IDX-CHP-16-0030" class="indexterm"/></p><p>You aren’t limited merely to extracting and displaying characters verbatim; you can also modify text. This example displays the text from a Ruby file but changes all Ruby line-comment characters (<code class="literal">#</code>) preceding full-line comments to C-style line comments (<code class="literal">//</code>):</p><p><span class="emphasis"><em>regex4.rb</em></span></p><a id="I_programlisting16_d1e18368"/><pre class="programlisting">File.foreach( 'regex1.rb' ){ |line|
   line = line.sub(/(^\s*)#(.*)/, '\1//\2')
      puts( line )
}</pre><p>In this example, the <code class="literal">sub</code> method of the String class has been used; this takes a regular expression as its first argument (<code class="literal">/(^\s*)#(.*)/</code>) and a replacement string as the second argument (<code class="literal">'\1//\2'</code>). The replacement string may contain numbered placeholders such as <code class="literal">\1</code> and <code class="literal">\2</code> to match any groups in the regular expression—here there are two groups between parentheses: <code class="literal">(^\s*)</code> and <code class="literal">(.*)</code>. The <code class="literal">sub</code> method returns a new string in which the matches made by the regular expression are substituted into the replacement string, while any unmatched elements (here the <code class="literal">#</code> character) are omitted. So, for example, let’s assume that the following comments are found in the input file:</p><a id="I_programlisting16_d1e18400"/><pre class="programlisting"># aStr = "hello world"
# aStr = "Hello World"</pre><p>After substitution using our regular expression, the displayed output is as follows:</p><a id="I_programlisting16_d1e18404"/><pre class="programlisting">// aStr = "hello world"
// aStr = "Hello World"</pre></div>
<div class="sect1" title="MatchData"><div class="titlepage"><div><div><h1 class="title"><a id="matchdata"/>MatchData</h1></div></div></div><p>The <code class="literal">=˜</code> operator is not the only means of finding a match. The Regexp class also has a <code class="literal">match</code> method. This works in similar way to <code class="literal">=˜</code>, but when a match is made, it returns a MatchData object rather than an integer. A MatchData object contains the result of a pattern match. At first sight, this may appear to be a string.<a id="IDX-CHP-16-0031" class="indexterm"/><a id="IDX-CHP-16-0032" class="indexterm"/></p><p><span class="emphasis"><em>match.rb</em></span></p><a id="I_programlisting16_d1e18431"/><pre class="programlisting">puts( /cde/ =˜ 'abcdefg' )        #=&gt; 2
puts( /cde/.match('abcdefg') )    #=&gt; cde</pre><p>In fact, it is an instance of the MatchData class that contains a string:</p><a id="I_programlisting16_d1e18435"/><pre class="programlisting">p( /cde/.match('abcdefg') )       #=&gt; #&lt;MatchData: "cde" &gt;</pre><p>A MatchData object may contain groups, or <span class="emphasis"><em>captures</em></span>, and these can be returned in an array using either the <code class="literal">to_a</code> or <code class="literal">captures</code> method, like this:<a id="IDX-CHP-16-0033" class="indexterm"/><a id="IDX-CHP-16-0034" class="indexterm"/><a id="IDX-CHP-16-0035" class="indexterm"/></p><p><span class="emphasis"><em>matchdata.rb</em></span></p><a id="I_programlisting16_d1e18464"/><pre class="programlisting">x = /(^.*)(#)(.*)/.match( 'def myMethod # This is a very nice method' )
x.captures.each{ |item| puts( item ) }</pre><p>The previous displays the following:</p><a id="I_programlisting16_d1e18468"/><pre class="programlisting">def myMethod
#
 This is a very nice method</pre><p>Note that there is a subtle difference between the <code class="literal">captures</code> and <code class="literal">to_a</code> methods. The first returns only the captures:</p><a id="I_programlisting16_d1e18479"/><pre class="programlisting">x.captures    #=&gt;["def myMethod ","#"," This is a very nice method"]</pre><p>The second returns the original string (at index 0) followed by the captures:</p><a id="I_programlisting16_d1e18483"/><pre class="programlisting">x.to_a    #=&gt;["def myMethod # This is a very nice method","def myMethod
","#"," This is a very nice method"]</pre></div>
<div class="sect1" title="Prematch and Postmatch"><div class="titlepage"><div><div><h1 class="title"><a id="prematch_and_postmatch"/>Prematch and Postmatch</h1></div></div></div><p>The MatchData class supplies the <code class="literal">pre_match</code> and <code class="literal">post_match</code> methods to return the strings preceding or following a match. Here, for example, I am making a match on the comment character, <code class="literal">#</code>:<a id="IDX-CHP-16-0036" class="indexterm"/><a id="IDX-CHP-16-0037" class="indexterm"/></p><p><span class="emphasis"><em>pre_post_match.rb</em></span></p><a id="I_programlisting16_d1e18512"/><pre class="programlisting">x = /#/.match( 'def myMethod # This is a very nice method' )
puts( x.pre_match )        #=&gt; def myMethod
puts( x.post_match )       #=&gt;  This is a very nice method</pre><p>Alternatively, you can use the special variables, <code class="literal">$`</code> (with a backquote) and <code class="literal">$'</code> (with a normal quote), to access pre- and postmatches, respectively:<a id="IDX-CHP-16-0038" class="indexterm"/><a id="IDX-CHP-16-0039" class="indexterm"/><a id="IDX-CHP-16-0040" class="indexterm"/><a id="IDX-CHP-16-0041" class="indexterm"/></p><a id="I_programlisting16_d1e18542"/><pre class="programlisting">x = /#/.match( 'def myMethod # This is a very nice method' )
puts( $` )                 #=&gt; def myMethod
puts( $' )                 #=&gt;  This is a very nice method</pre><p>When using <code class="literal">match</code> with groups, you can use array-style indexing to obtain specific items. Index 0 is the original string; higher indexes are the groups:<a id="IDX-CHP-16-0042" class="indexterm"/><a id="IDX-CHP-16-0043" class="indexterm"/><a id="IDX-CHP-16-0044" class="indexterm"/><a id="IDX-CHP-16-0045" class="indexterm"/><a id="IDX-CHP-16-0046" class="indexterm"/><a id="IDX-CHP-16-0047" class="indexterm"/><a id="IDX-CHP-16-0048" class="indexterm"/><a id="IDX-CHP-16-0049" class="indexterm"/><a id="IDX-CHP-16-0050" class="indexterm"/></p><p><span class="emphasis"><em>match_groups.rb</em></span></p><a id="I_programlisting16_d1e18596"/><pre class="programlisting">puts( /(.)(.)(.)/.match("abc")[2] )                 #=&gt; "b"</pre><p>You can use the special variable <code class="literal">$˜</code> to access the last MatchData object, and once again you can refer to groups using array-style indexing:<a id="IDX-CHP-16-0051" class="indexterm"/><a id="IDX-CHP-16-0052" class="indexterm"/></p><a id="I_programlisting16_d1e18613"/><pre class="programlisting">puts( $˜[0], $˜[1], $˜[3] )</pre><p>However, to use the full range of methods of the Array class, you must use <code class="literal">to_a</code> or <code class="literal">captures</code> to return the match groups as an array:</p><a id="I_programlisting16_d1e18624"/><pre class="programlisting">puts( $˜.sort )               # this doesn't work!
puts( $˜.captures.sort )      # this does</pre></div>
<div class="sect1" title="Greedy Matching"><div class="titlepage"><div><div><h1 class="title"><a id="greedy_matching"/>Greedy Matching</h1></div></div></div><p>When a string contains more than one potential match, you may sometimes want to return the string up to the <span class="emphasis"><em>first</em></span> match (that is, as little of the string as possible consistent with the match pattern), and at other times you may want the string up to the <span class="emphasis"><em>last</em></span> match (that is, as much of the string as possible).</p><p>In the latter case (getting as much of the string as possible), the match is said to be <span class="emphasis"><em>greedy</em></span>. The <code class="literal">*</code> and <code class="literal">+</code> pattern quantifiers are greedy. However, you can put them on a diet, to make them return the least possible, by putting <code class="literal">?</code> after them:<a id="IDX-CHP-16-0053" class="indexterm"/></p><p><span class="emphasis"><em>greedy1.rb</em></span></p><a id="I_programlisting16_d1e18659"/><pre class="programlisting">puts( /.*at/.match('The cat sat on the mat!') )  #=&gt; The cat sat on the mat
puts( /.*?at/.match('The cat sat on the mat!') ) #=&gt; The cat</pre><p>You can control the greediness of pattern matching to do things such as process directory paths (here matching on the <code class="literal">\</code> character):<a id="IDX-CHP-16-0054" class="indexterm"/></p><p><span class="emphasis"><em>greedy2.rb</em></span></p><a id="I_programlisting16_d1e18674"/><pre class="programlisting">puts( /.+\\/.match('C:\mydirectory\myfolder\myfile.txt') )
    #=&gt; C:\mydirectory\myfolder\
puts( /.+?\\/.match('C:\mydirectory\myfolder\myfile.txt') )
    #=&gt; C:\</pre></div>
<div class="sect1" title="String Methods"><div class="titlepage"><div><div><h1 class="title"><a id="string_methods"/>String Methods</h1></div></div></div><p>Up to now, I’ve used methods of the Regexp class when processing strings. In fact, pattern matching can go both ways because the String class has a few regular expression methods of its own. These include <code class="literal">=˜</code> and <code class="literal">match</code> (so you can switch the order of the String and Regexp objects when matching), plus the <code class="literal">scan</code> method that iterates through a string looking for as many matches as possible. Each match is added to an array. Here, for example, I am looking for matches on the letters <span class="emphasis"><em>a</em></span>, <span class="emphasis"><em>b</em></span>, or <span class="emphasis"><em>c</em></span>. The <code class="literal">match</code> method returns the first match (“a”) wrapped up in a MatchData object, but the <code class="literal">scan</code> method keeps scanning along the string and returns all the matches it finds as elements in an array:</p><p><span class="emphasis"><em>match_scan.rb</em></span></p><a id="I_programlisting16_d1e18709"/><pre class="programlisting">TESTSTR = "abc is not cba"
puts( "\n--match--" )
b = /[abc]/.match( TESTSTR )        #=&gt; "a" (MatchData)
puts( "--scan--" )
a = TESTSTR.scan(/[abc]/)           #=&gt; ["a", "b", "c", "c", "b", "a"]</pre><p>The <code class="literal">scan</code> method may optionally be passed a block so that the elements of the array created by <code class="literal">scan</code> can be processed in some way:</p><a id="I_programlisting16_d1e18719"/><pre class="programlisting">a = TESTSTR.scan(/[abc]/){|c| print( c.upcase ) }     #=&gt; ABCCBA</pre><p>A number of other String methods can be used with regular expressions. One version of the <code class="literal">String.slice</code> method takes a regular expression as an argument and returns any matched substring, leaving the original (<span class="emphasis"><em>receiver</em></span>) string unmodified. The <code class="literal">String.slice!</code> method (note the <code class="literal">!</code> at the end) deletes the matched substring from the receiver string and returns the substring:<a id="IDX-CHP-16-0055" class="indexterm"/></p><p><span class="emphasis"><em>string_slice.rb</em></span></p><a id="I_programlisting16_d1e18743"/><pre class="programlisting">s = "def myMethod # a comment "

puts( s.slice( /m.*d/ ) )      #=&gt; myMethod
puts( s )                      #=&gt; def myMethod # a comment
puts( s.slice!( /m.*d/ ) )     #=&gt; myMethod
puts( s )                      #=&gt; def  # a comment</pre><p>The <code class="literal">split</code> method splits a string into substrings, based on a pattern. The results (minus the pattern) are returned as an array:<a id="IDX-CHP-16-0056" class="indexterm"/></p><p><span class="emphasis"><em>string_ops.rb</em></span></p><a id="I_programlisting16_d1e18759"/><pre class="programlisting">s = "def myMethod # a comment"

p( s.split( /m.*d/ ) )   #=&gt; ["def ", " # a comment"]
p( s.split( /\s/ ) )     #=&gt; ["def", "myMethod", "#", "a", "comment"]</pre><p>You can also split on an empty pattern (<code class="literal">//</code>):</p><a id="I_programlisting16_d1e18766"/><pre class="programlisting">p( s.split( // ) )</pre><p>In this case, an array of characters is returned:</p><a id="I_programlisting16_d1e18770"/><pre class="programlisting">["d", "e", "f", " ", "m", "y", "M", "e", "t", "h", "o", "d", " ", "#", " ",
"a", " ", "c", "o", "m", "m", "e", "n", "t"]</pre><p>You can use the <code class="literal">sub</code> method to match a regular expression and replace its first occurrence with a string. If no match is made, the string is returned unchanged:<a id="IDX-CHP-16-0057" class="indexterm"/><a id="IDX-CHP-16-0058" class="indexterm"/><a id="IDX-CHP-16-0059" class="indexterm"/><a id="IDX-CHP-16-0060" class="indexterm"/></p><a id="I_programlisting16_d1e18795"/><pre class="programlisting">s = "def myMethod # a comment"
s2 = "The cat sat on the mat"
p( s.sub( /m.*d/, "yourFunction" ) )  #=&gt; "def yourFunction # a comment"
p( s2.sub( /at/, "aterpillar" ) )     #=&gt; "The caterpillar sat on the mat"</pre><p>The <code class="literal">sub!</code> method works like <code class="literal">sub</code> but modifies the original (receiver) string. Alternatively, you can use the <code class="literal">gsub</code> method (or <code class="literal">gsub!</code> to modify the receiver) to substitute all occurrences of the pattern with a string:<a id="IDX-CHP-16-0061" class="indexterm"/></p><a id="I_programlisting16_d1e18816"/><pre class="programlisting">p( s2.gsub( /at/, "aterpillar" ) )
        #=&gt; "The caterpillar saterpillar on the materpillar"</pre></div>
<div class="sect1" title="File Operations"><div class="titlepage"><div><div><h1 class="title"><a id="file_operations"/>File Operations</h1></div></div></div><p>I said earlier that regular expressions are often used to process data stored in files on disk. In some earlier examples, I read in data from a disk file, did some pattern matching, and displayed the results on the screen. Here is one more example in which I count the words in a file. You do this by scanning each line in order to create an array of words (that is, sequences of alphanumeric characters) and then adding the size of each array to the variable, <code class="literal">count</code>:</p><p><span class="emphasis"><em>wordcount.rb</em></span></p><a id="I_programlisting16_d1e18829"/><pre class="programlisting">count = 0
File.foreach( 'regex1.rb' ){ |line|
    count += line.scan( /[a-z0-9A-Z]+/ ).size
}
puts( "There are #{count} words in this file." )</pre><p>If you want to verify that the word count is correct, you could display a numbered list of words read in from the file. This is what is do here:</p><p><span class="emphasis"><em>wordcount2.rb</em></span></p><a id="I_programlisting16_d1e18836"/><pre class="programlisting">File.foreach( 'regex1.rb' ){ |line|
    line.scan( /[a-z0-9A-Z]+/ ).each{ |word|
        count +=1
        print( "[#{count}] #{word}\n" )
    }
}</pre><p>Now let’s see how to deal with two files at once—one for reading, another for writing. The next example opens the file <span class="emphasis"><em>testfile1.txt</em></span> for writing and passes the file variable, <code class="literal">f</code>, into a block. I now open a second file, <span class="emphasis"><em>regex1.rb</em></span>, for reading and use <code class="literal">File.foreach</code> to pass into a second block each line of text read from this file. I use a simple regular expression to create a new string to match lines with Ruby-style comments; the code substitutes C-style comment characters (<code class="literal">//</code>) for the Ruby comment character (<code class="literal">#</code>) when that character is the first nonwhitespace character on a line and writes each line to <span class="emphasis"><em>testfile1.txt</em></span> with code lines unmodified (because there are no matches on those) and with comment lines changed to C-style comment lines:<a id="IDX-CHP-16-0062" class="indexterm"/></p><p><span class="emphasis"><em>regexp_file1.rb</em></span></p><a id="I_programlisting16_d1e18870"/><pre class="programlisting">File.open( 'testfile1.txt', 'w' ){ |f|
    File.foreach( 'regex1.rb' ){ |line|
        f.puts( line.sub(/(^\s*)#(.*)/, '\1//\2')  )
    }
}</pre><p>This illustrates just how much can be done with regular expressions and very little coding. The next example shows how you might read in one file (here the file <span class="emphasis"><em>regex1.rb</em></span>) and write out two new files—one of which (<span class="emphasis"><em>comments.txt</em></span>) contains only line comments, while the other (<span class="emphasis"><em>nocomments.txt</em></span>) contains all the other lines.</p><p><span class="emphasis"><em>regexp_file2.rb</em></span></p><a id="I_programlisting16_d1e18887"/><pre class="programlisting">file_out1 = File.open( 'comments.txt', 'w' )
file_out2 = File.open( 'nocomments.txt', 'w' )

File.foreach( 'regex1.rb' ){ |line|
    if line =˜ /^\s*#/ then
        file_out1.puts( line )
    else
        file_out2.puts( line )
    end
}

file_out1.close
file_out2.close</pre><div class="sidebar"><a id="digging_deeper-id15"/><p class="title">Digging Deeper</p><p>This section provides a handy summary of regular expressions followed by some short examples in ready-to-use Ruby code.<a id="IDX-CHP-16-0063" class="indexterm"/><a id="IDX-CHP-16-0064" class="indexterm"/><a id="IDX-CHP-16-0065" class="indexterm"/><a id="IDX-CHP-16-0066" class="indexterm"/><a id="IDX-CHP-16-0067" class="indexterm"/><a id="IDX-CHP-16-0068" class="indexterm"/><a id="IDX-CHP-16-0069" class="indexterm"/><a id="IDX-CHP-16-0070" class="indexterm"/><a id="IDX-CHP-16-0071" class="indexterm"/><a id="IDX-CHP-16-0072" class="indexterm"/><a id="IDX-CHP-16-0073" class="indexterm"/><a id="IDX-CHP-16-0074" class="indexterm"/><a id="IDX-CHP-16-0075" class="indexterm"/><a id="IDX-CHP-16-0076" class="indexterm"/><a id="IDX-CHP-16-0077" class="indexterm"/><a id="IDX-CHP-16-0078" class="indexterm"/><a id="IDX-CHP-16-0079" class="indexterm"/><a id="IDX-CHP-16-0080" class="indexterm"/><a id="IDX-CHP-16-0081" class="indexterm"/><a id="IDX-CHP-16-0082" class="indexterm"/><a id="IDX-CHP-16-0083" class="indexterm"/><a id="IDX-CHP-16-0084" class="indexterm"/><a id="IDX-CHP-16-0085" class="indexterm"/></p><p><span class="bolditalic">Regular Expression Elements</span></p><p>This is a list of some of the elements that can be used in regular expressions:<a id="IDX-CHP-16-0086" class="indexterm"/><a id="IDX-CHP-16-0087" class="indexterm"/><a id="IDX-CHP-16-0088" class="indexterm"/><a id="IDX-CHP-16-0089" class="indexterm"/><a id="IDX-CHP-16-0090" class="indexterm"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">^</code></p></td><td style="text-align: left" valign="top"><p>Beginning of a line or string</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">$</code></p></td><td style="text-align: left" valign="top"><p>End of a line or string</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">.</code></p></td><td style="text-align: left" valign="top"><p>Any character except newline</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td><td style="text-align: left" valign="top"><p>Zero or more previous regular expression</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">*?</code><a id="IDX-CHP-16-0091" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>Zero or more previous regular expression (nongreedy)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td><td style="text-align: left" valign="top"><p>One or more previous regular expression</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">+?</code><a id="IDX-CHP-16-0092" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>One or more previous regular expression (nongreedy)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">[]</code></p></td><td style="text-align: left" valign="top"><p>Range specification (for example, <code class="literal">[a-z]</code> means a character in the range a-z)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\w</code><a id="IDX-CHP-16-0093" class="indexterm"/><a id="IDX-CHP-16-0094" class="indexterm"/><a id="IDX-CHP-16-0095" class="indexterm"/><a id="IDX-CHP-16-0096" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>An alphanumeric character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\W</code></p></td><td style="text-align: left" valign="top"><p>A nonalphanumeric character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\s</code><a id="IDX-CHP-16-0097" class="indexterm"/><a id="IDX-CHP-16-0098" class="indexterm"/><a id="IDX-CHP-16-0099" class="indexterm"/><a id="IDX-CHP-16-0100" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>A whitespace character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\S</code></p></td><td style="text-align: left" valign="top"><p>A nonwhitespace character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\d</code><a id="IDX-CHP-16-0101" class="indexterm"/><a id="IDX-CHP-16-0102" class="indexterm"/><a id="IDX-CHP-16-0103" class="indexterm"/><a id="IDX-CHP-16-0104" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>A digit</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\D</code></p></td><td style="text-align: left" valign="top"><p>A nondigit character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\b</code><a id="IDX-CHP-16-0105" class="indexterm"/><a id="IDX-CHP-16-0106" class="indexterm"/><a id="IDX-CHP-16-0107" class="indexterm"/><a id="IDX-CHP-16-0108" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>A backspace (when in a range specification)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\b</code></p></td><td style="text-align: left" valign="top"><p>Word boundary (when not in a range specification)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">\B</code></p></td><td style="text-align: left" valign="top"><p>Nonword boundary</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td><td style="text-align: left" valign="top"><p>Zero or more repetitions of the preceding</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td><td style="text-align: left" valign="top"><p>One or more repetitions of the preceding</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">{m,n}</code></p></td><td style="text-align: left" valign="top"><p>At least <code class="literal">m</code> and at most <code class="literal">n</code> repetitions of the preceding</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">?</code></p></td><td style="text-align: left" valign="top"><p>At most one repetition of the preceding</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">|</code></p></td><td style="text-align: left" valign="top"><p>Either the preceding or next expression may match</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">()</code></p></td><td style="text-align: left" valign="top"><p>A group</p></td></tr></tbody></table></div><p><span class="bolditalic">Regular Expression Examples</span></p><p>Here are a few more sample regular expressions:</p><p><span class="emphasis"><em>overview.rb</em></span></p><a id="I_programlisting16_d1e19275"/><pre class="programlisting"># match chars...
puts( 'abcdefgh'.match( /cdefg/ ) )       # literal chars
        #=&gt; cdefg
puts( 'abcdefgh'.match( /cd..g/ ) )       # dot matches any char
        #=&gt; cdefg

# list of chars in square brackets...
puts( 'cat'.match( /[fc]at/ )
        #=&gt; cat
puts( "batman's father's cat".match( /[fc]at/ ) )
        #=&gt; fat
p( 'bat'.match( /[fc]at/ ) )
        #=&gt; nil

# match char in a range...
puts( 'ABC100x3Z'.match( /[A-Z][0-9][A-Z0-9]/ ) )
        #=&gt; C10
puts( 'ABC100x3Z'.match( /[a-z][0-9][A-Z0-9]/ ) )
        #=&gt; x3Z

# escape 'special' chars with \
puts( 'ask who?/what?'.match( /who\?\/w..t\?/ ) )
        #=&gt; who?/what?
puts( 'ABC 100x3Z'.match( /\s\S\d\d\D/ ) )
        #=&gt;  100x (note the leading space)

# scan for all occurrences of pattern 'abc' with at least 2 and
# no more than 3 occurrences of the letter 'c'
p( 'abcabccabcccabccccabccccccabcccccccc'.scan( /abc{2,3}/ ) )
        #=&gt; ["abcc", "abccc", "abccc", "abccc", "abccc"]

# match either of two patterns
puts( 'my cat and my dog'.match( /cat|dog/ ) )             #=&gt; cat

puts( 'my hamster and my dog'.match( /cat|dog/ ) )     #=&gt; dog</pre><p><span class="bolditalic">Symbols and Regular Expressions</span></p><p>Ruby 1.9 permits you to use <code class="literal">match</code> with a symbol. The symbol is converted to a string, and the index of the match is returned. Symbols cannot be used in this manner with Ruby 1.8.<a id="IDX-CHP-16-0109" class="indexterm"/><a id="IDX-CHP-16-0110" class="indexterm"/><a id="IDX-CHP-16-0111" class="indexterm"/><a id="IDX-CHP-16-0112" class="indexterm"/></p><p><span class="emphasis"><em>regexp_symbols.rb</em></span></p><a id="I_programlisting16_d1e19309"/><pre class="programlisting">p( :abcdefgh.match( /cdefg/ ) )                   #=&gt; 2
p( :abcdefgh.match( /cd..g/ ) )                   #=&gt; 2
p( :cat.match( /[fc]at/ ) )                       #=&gt; 0
p( :cat.match( /[xy]at/ ) )                       #=&gt; nil
p( :ABC100x3Z.match( /[A-Z][0-9][A-Z0-9]/ ) )     #=&gt; 2
p( :ABC100x3Z.match( /[a-z][0-9][A-Z0-9]/ ) )     #=&gt; 6</pre></div></div></body></html>