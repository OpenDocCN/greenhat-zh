- en: Part II. Basic IDA Usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分. 基本IDA使用
- en: Chapter 4. Getting Started with IDA
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 开始使用IDA
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: It’s about time we got down to actually using IDA. The remainder of this book
    is dedicated to various features of IDA and how you can leverage them to best
    suit your reverse engineering needs. In this chapter we begin by covering the
    options you are presented with when you launch IDA, and then we describe just
    what is happening when you open a binary file for analysis. Finally, we’ll present
    a quick overview of the user interface to lay the groundwork for the remaining
    chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是时候真正开始使用IDA了。本书的剩余部分将致力于IDA的各种功能和如何利用它们来满足你的逆向工程需求。在本章中，我们首先介绍当你启动IDA时呈现给你的选项，然后描述当你打开二进制文件进行分析时究竟发生了什么。最后，我们将快速概述用户界面，为后续章节奠定基础。
- en: For the sake of standardization, examples in both this chapter and the remainder
    of the book will be presented with the Windows Qt GUI interface unless an example
    requires a specific, different version of IDA (such as an example of Linux debugging).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标准化，本章和本书剩余部分中的示例将以Windows Qt GUI界面呈现，除非示例需要特定版本的IDA（例如Linux调试的示例）。
- en: Launching IDA
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动IDA
- en: Any time you launch IDA, you will be greeted briefly by a splash screen that
    displays a summary of your license information. Once the splash screen clears,
    IDA displays another dialog offering three ways to proceed to its desktop environment,
    as shown in [Figure 4-1](ch04.html#launching_ida-id1 "Figure 4-1. Launching IDA").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你启动IDA时，都会看到一个显示你的许可信息摘要的启动屏幕。一旦启动屏幕消失，IDA将显示另一个对话框，提供三种进入其桌面环境的方式，如图[图4-1](ch04.html#launching_ida-id1
    "图4-1. 启动IDA")所示。
- en: '![Launching IDA](httpatomoreillycomsourcenostarchimages854073.png.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![启动IDA](httpatomoreillycomsourcenostarchimages854073.png.jpg)'
- en: Figure 4-1. Launching IDA
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 启动IDA
- en: If you prefer not to see the welcome message, feel free to uncheck the Display
    at startup checkbox at the bottom of the dialog. If you check the box, future
    sessions will begin as if you had clicked the Go button, and you will be taken
    directly to an empty IDA workspace. If at some point you find yourself longing
    for the Welcome dialog (after all, it conveniently allows you to return to recently
    used files), you will need to edit IDA’s registry key to set the `DisplayWelcome`
    value back to *`1`*. Alternatively, selecting Windows ▸ Reset hidden messages
    will restore *all* previously hidden messages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想看到欢迎信息，请随意取消勾选对话框底部的“启动时显示”复选框。如果你勾选了复选框，未来的会话将开始得就像你点击了“Go”按钮一样，你将被直接带到空的IDA工作空间。如果在某个时候你渴望看到欢迎对话框（毕竟，它方便地让你返回到最近使用的文件），你需要编辑IDA的注册表键，将`DisplayWelcome`值设置回*`1`*。或者，选择Windows
    ▸ 重置隐藏消息将恢复*所有*之前隐藏的消息。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When installed on Windows, IDA creates the following registry key: `HKEY_CURRENT_USER\Software\Hex-Rays\IDA`.^([[29](#ftn.CHP-4-FN-1)])
    Many options that can be configured within IDA itself (as opposed to editing one
    of the configuration files) are stored within this registry key. However, on other
    platforms, IDA stores such values in a binary data file *($HOME/.idapro/ida.reg)*
    that is not easily edited.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装在Windows上时，IDA创建以下注册表键：`HKEY_CURRENT_USER\Software\Hex-Rays\IDA`^([[29](#ftn.CHP-4-FN-1)])。IDA本身可以配置的许多选项（而不是编辑配置文件之一）都存储在这个注册表键中。然而，在其他平台上，IDA将这些值存储在一个二进制数据文件*($HOME/.idapro/ida.reg)*中，这个文件不易编辑。
- en: 'Each of the three options shown in [Figure 4-1](ch04.html#launching_ida-id1
    "Figure 4-1. Launching IDA") offers a slightly different method to proceed to
    the IDA desktop. These three launch options are reviewed here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-1](ch04.html#launching_ida-id1 "图4-1. 启动IDA")中显示的三个选项提供了不同的方法进入IDA桌面。这里回顾这三个启动选项：'
- en: '**New**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**新建**'
- en: Choosing New opens a standard File Open dialog to select the file to be analyzed.
    Following file selection, one or more additional dialogs are displayed that allow
    you to choose specific file-analysis options before the file is loaded, analyzed,
    and displayed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“新建”将打开一个标准的文件打开对话框来选择要分析的文件。在文件选择之后，将显示一个或多个额外的对话框，允许你在文件加载、分析和显示之前选择特定的文件分析选项。
- en: '**Go**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go**'
- en: The Go button terminates the load process and causes IDA to open with an empty
    workspace. At this point, if you want to open a file, you may drag and drop a
    binary file onto your IDA desktop, or you may use one of the options from the
    File menu to open a file. The File ▸ Open command results in a File Open dialog,
    as described previously. By default, IDA utilizes a *known extensions* filter
    to limit the view of the File dialog. Make sure that you modify or clear the filter
    (such as choosing All Files) so that the File dialog correctly displays the file
    you are interested in opening.^([[30](#ftn.CHP-4-FN-2)]) When you open a file
    this way, IDA attempts to automatically identify the selected file’s type; however,
    you should pay careful attention to the Loading dialog to see which loaders have
    been selected to process the file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “Go”按钮终止加载过程，并导致IDA以空工作区打开。在此阶段，如果您想打开一个文件，您可以将二进制文件拖放到IDA桌面上，或者您可以使用文件菜单中的选项之一来打开文件。文件
    ▸ 打开命令将显示之前描述的文件打开对话框。默认情况下，IDA使用一个*已知扩展名*过滤器来限制文件对话框的视图。请确保您修改或清除过滤器（例如选择所有文件），以便文件对话框正确显示您想要打开的文件.^([[30](#ftn.CHP-4-FN-2)])
    以这种方式打开文件时，IDA会尝试自动识别所选文件的类型；然而，您应该仔细注意加载对话框，以查看哪些加载器已被选中来处理该文件。
- en: '**Previous**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Previous**'
- en: You should utilize the Previous button when you wish to open one of the files
    in the list of recent files that is directly below the Previous button. The list
    of recently used files is populated with values from the `History` subkey of IDA’s
    Windows registry key (or *ida.reg* on non-Windows platforms). The maximum length
    of the history list is initially set to 10, but this limit may be raised as high
    as 100 by editing the appropriate entry in *idagui.cfg* or *idatui.cfg* (see [Chapter 11](ch11.html
    "Chapter 11. Customizing IDA")). Utilizing the history list is the most convenient
    option for resuming work on recently used database files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望打开位于“Previous”按钮下方直接下面的最近文件列表中的一个文件时，应使用“Previous”按钮。最近使用的文件列表由IDA的Windows注册表键的“History”子键（或在非Windows平台上为*ida.reg*）中的值填充。历史列表的最大长度最初设置为10，但可以通过编辑*idagui.cfg*或*idatui.cfg*（见[第11章](ch11.html
    "第11章。自定义IDA"））中的适当条目将其提高到高达100。利用历史列表是恢复最近使用的数据库文件工作的最方便的选项。
- en: IDA File Loading
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA文件加载
- en: When choosing to open a new file using the File ▸ Open command, you will be
    presented with the loading dialog shown in [Figure 4-2](ch04.html#the_ida_load_a_new_file_dialog
    "Figure 4-2. The IDA Load a New File dialog"). IDA generates a list of potential
    file types and displays that list at the top of the dialog. This list represents
    the IDA loaders that are best suited for dealing with the selected file. The list
    is created by executing each of the file loaders in IDA’s *loaders* directory
    in order to find any loaders^([[31](#ftn.CHP-4-FN-3)]) that recognize the new
    file. Note that in [Figure 4-2](ch04.html#the_ida_load_a_new_file_dialog "Figure 4-2. The
    IDA Load a New File dialog"), both the Windows PE loader (*pe.ldw*) and the MS-DOS
    EXE loader (*dos.ldw*) claim to recognize the selected file. Readers familiar
    with the PE file format will not be surprised by this, as the PE file format is
    an extended form of the MS-DOS EXE file format. The last entry in the list, Binary
    File, will always be present since it is IDA’s default for loading files that
    it does not recognize, and this provides the lowest-level method for loading any
    file. When offered the choice of several loaders, it is not a bad initial strategy
    to simply accept the default selection unless you possess specific information
    that contradicts IDA’s determination.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择使用文件 ▸ 打开命令打开新文件时，您将看到[图4-2](ch04.html#the_ida_load_a_new_file_dialog "图4-2.
    IDA加载新文件对话框")中所示的加载对话框。IDA生成一个潜在文件类型的列表，并在对话框顶部显示该列表。此列表代表最适合处理所选文件的IDA加载器。列表是通过按顺序执行IDA的*loaders*目录中的每个文件加载器来创建的，以找到任何识别新文件的加载器^([[31](#ftn.CHP-4-FN-3)])。请注意，在[图4-2](ch04.html#the_ida_load_a_new_file_dialog
    "图4-2. IDA加载新文件对话框")中，Windows PE加载器（*pe.ldw*）和MS-DOS EXE加载器（*dos.ldw*）都声称可以识别所选文件。熟悉PE文件格式的读者对此不会感到惊讶，因为PE文件格式是MS-DOS
    EXE文件格式的扩展形式。列表中的最后一个条目，二进制文件，将始终存在，因为它是IDA加载它不识别的文件的默认设置，这为加载任何文件提供了最低级别的加载方法。当提供多个加载器的选择时，除非您拥有与IDA的判断相矛盾的具体信息，否则简单地接受默认选择不是一个坏的开端策略。
- en: '![The IDA Load a New File dialog](httpatomoreillycomsourcenostarchimages854075.png.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![IDA加载新文件对话框](httpatomoreillycomsourcenostarchimages854075.png.jpg)'
- en: Figure 4-2. The IDA Load a New File dialog
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2. IDA加载新文件对话框
- en: At times, Binary File will be the only entry that appears in the loader list.
    In such cases, the implied message is that none of the loaders recognize the chosen
    file. If you opt to continue the loading process, make sure that you select the
    processor type in accordance with your understanding of the file contents.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，二进制文件将是加载列表中出现的唯一条目。在这种情况下，隐含的信息是没有任何加载器能识别所选文件。如果你选择继续加载过程，请确保根据你对文件内容的理解选择处理器类型。
- en: The Processor Type drop-down menu allows you to specify which processor module
    (from IDA’s *procs* directory) should be used during the disassembly process.
    In most cases, IDA will choose the proper processor based on information that
    it reads from the executable file’s headers. When IDA can’t properly determine
    the processor type associated with the file being opened, you will need to manually
    select a processor type before continuing with the file-loading operation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器类型下拉菜单允许你在反汇编过程中指定应使用哪个处理器模块（来自IDA的*procs*目录）。在大多数情况下，IDA将根据从可执行文件头中读取的信息选择正确的处理器。当IDA无法正确确定与打开的文件关联的处理器类型时，你需要在继续文件加载操作之前手动选择处理器类型。
- en: The Loading Segment and Loading Offset fields are active only when the Binary
    File input format is chosen in conjunction with an x86 family processor. Since
    the binary loader is unable to extract any memory layout information, the segment
    and offset values entered here are combined to form the base address for the loaded
    file content. Should you forget to specify a base address during the initial loading
    process, the base address of the IDA image can be modified at any time using the
    Edit ▸ Segments ▸ Rebase Program command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择与x86系列处理器一起的二进制文件输入格式时，加载段和加载偏移字段才处于活动状态。由于二进制加载器无法提取任何内存布局信息，因此在此处输入的段和偏移值将组合形成加载文件内容的基址。如果在初始加载过程中忘记指定基址，可以使用“编辑
    ▸ 段落 ▸ 重置程序”命令在任何时候修改IDA图像的基址。
- en: The Kernel Options buttons provide access to configure the specific disassembly
    analysis options that IDA will utilize to enhance the recursive-descent process.
    In the overwhelming majority of cases, the default options provide the best possible
    disassembly. The IDA help files provide additional information on available kernel
    options.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 内核选项按钮提供了访问配置IDA将用于增强递归下降过程的特定反汇编分析选项的权限。在绝大多数情况下，默认选项提供了最佳的反汇编效果。IDA的帮助文件提供了有关可用内核选项的更多信息。
- en: The Processor Options button provides access to configuration options that apply
    to the selected processor module. However, processor options are not necessarily
    available for every processor module. Limited help is available for processor
    options as these options are very highly dependent on the selected processor module
    and the programming proficiency of the module’s author.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器选项按钮提供了访问适用于所选处理器模块的配置选项的权限。然而，并非每个处理器模块都一定有处理器选项。处理器选项的帮助有限，因为这些选项非常高度依赖于所选处理器模块以及模块作者的编程能力。
- en: The remaining Options checkboxes are used to gain finer control over the file-loading
    process. Each of the options is described further in IDA’s help file. The options
    are not applicable to all input file types, and in most cases, you can rely on
    the default selections. Specific cases when you may need to modify these options
    will be covered in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的选项复选框用于对文件加载过程进行更精细的控制。IDA的帮助文件中进一步描述了每个选项。这些选项并不适用于所有输入文件类型，在大多数情况下，你可以依赖默认选择。可能需要修改这些选项的具体情况将在[第21章](ch21.html
    "第21章。混淆代码分析")中介绍。
- en: Using the Binary File Loader
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用二进制文件加载器
- en: When you opt to utilize the binary loader, you need to be prepared to do more
    than your usual share of the processing work. With no file header information
    to guide the analysis process, it is up to you to step in and perform tasks that
    more capable loaders often do automatically. Examples of situations that may call
    for the use of the binary loader include the analysis of ROM images and exploit
    payloads that may have been extracted from network packet captures or log files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择使用二进制加载器时，你需要准备好做比平时更多的处理工作。由于没有文件头信息来指导分析过程，这就需要你自己介入并执行那些更强大的加载器通常会自动完成的任务。可能需要使用二进制加载器的情况包括分析ROM镜像和可能从网络数据包捕获或日志文件中提取的利用负载。
- en: When the x86 processor module is paired with the binary loader, the dialog shown
    in [Figure 4-3](ch04.html#x86_mode_selection "Figure 4-3. x86 mode selection")
    will be displayed. With no recognizable file headers available to assist IDA,
    it is up to the user to specify whether code should be treated as 16-bit or 32-bit
    mode code. Other processors for which IDA can distinguish between 16- and 32-bit
    modes include ARM and MIPS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当x86处理器模块与二进制加载器配对时，将显示[图4-3](ch04.html#x86_mode_selection "图4-3. x86模式选择")所示的对话框。由于没有可识别的文件头部可供IDA协助，用户必须指定代码应被视为16位还是32位模式代码。IDA可以区分16位和32位模式的其它处理器包括ARM和MIPS。
- en: '![x86 mode selection](httpatomoreillycomsourcenostarchimages854077.png.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![x86模式选择](httpatomoreillycomsourcenostarchimages854077.png.jpg)'
- en: Figure 4-3. x86 mode selection
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3. x86模式选择
- en: Binary files contain no information concerning their memory layout (at least
    no information that IDA knows how to recognize). When an x86 processor type has
    been selected, base address information must be specified in the loader dialog’s
    Loading Segment and Loading Offset fields, as mentioned earlier. For all other
    processor types, IDA displays the memory layout dialog shown in [Figure 4-4](ch04.html#the_memory_organization_dialog
    "Figure 4-4. The Memory Organization dialog"). As a convenience, you may create
    a RAM section, a ROM section, or both and designate the address range of each.
    The Input File options are used to specify which portion of the input file (the
    default is the entire file) should be loaded and to which address the file content
    should be mapped.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件不包含有关其内存布局的信息（至少IDA不知道如何识别的信息）。当选择x86处理器类型时，必须在加载对话框的加载段和加载偏移量字段中指定基本地址信息，如前所述。对于所有其他处理器类型，IDA将显示[图4-4](ch04.html#the_memory_organization_dialog
    "图4-4. 内存组织对话框")所示的内存布局对话框。为了方便起见，你可以创建一个RAM部分、一个ROM部分或两者都创建，并指定每个部分的地址范围。输入文件选项用于指定应加载输入文件的哪个部分（默认为整个文件），以及文件内容应映射到的地址。
- en: '![The Memory Organization dialog](httpatomoreillycomsourcenostarchimages854079.png.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![内存组织对话框](httpatomoreillycomsourcenostarchimages854079.png.jpg)'
- en: Figure 4-4. The Memory Organization dialog
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4. 内存组织对话框
- en: '[Figure 4-5](ch04.html#binary_file_loading "Figure 4-5. Binary file loading")
    shows the last step of a binary load—a gentle reminder that you need to do some
    work. The message highlights the fact that IDA has no header information available
    to help it distinguish code bytes from data bytes in the binary file. At this
    point, you are reminded to designate one of the addresses in the file as an entry
    point by telling IDA to turn the byte(s) at that address into code (C is the hotkey
    used to force IDA to treat a byte as code). For binary files, IDA will not perform
    any initial disassembly until you take the time to identify at least one byte
    as code.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-5](ch04.html#binary_file_loading "图4-5. 二进制文件加载")展示了二进制加载的最后一步——这是一个温和的提醒，表明你需要做一些工作。信息强调了这样一个事实，即IDA没有可用的头部信息来帮助它区分二进制文件中的代码字节和数据字节。此时，你会被提醒指定文件中的一个地址作为入口点，通过告诉IDA将该地址的字节（字节）转换为代码（C是强制IDA将该字节视为代码的热键）。对于二进制文件，IDA在你花费时间至少识别一个字节为代码之前，不会执行任何初始反汇编。'
- en: '![Binary file loading](httpatomoreillycomsourcenostarchimages854081.png.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![二进制文件加载](httpatomoreillycomsourcenostarchimages854081.png.jpg)'
- en: Figure 4-5. Binary file loading
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5. 二进制文件加载
- en: '* * *'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[29](#CHP-4-FN-1)]) Older versions of IDA used `HKEY_CURRENT_USER\Software\Datarescue\IDA`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#CHP-4-FN-1)]) 旧版本的IDA使用`HKEY_CURRENT_USER\Software\Datarescue\IDA`。
- en: ^([[30](#CHP-4-FN-2)]) On non-Windows systems, it is not uncommon for executable
    files to have no file extension at all.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#CHP-4-FN-2)]) 在非Windows系统中，可执行文件完全没有文件扩展名并不罕见。
- en: ^([[31](#CHP-4-FN-3)]) IDA loaders will be discussed further in [Chapter 18](ch18.html
    "Chapter 18. Binary Files and IDA Loader Modules").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#CHP-4-FN-3)]) IDA加载器将在[第18章](ch18.html "第18章. 二进制文件和IDA加载器模块")中进一步讨论。
- en: IDA Database Files
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA数据库文件
- en: When you are happy with your loading options and click OK to close the dialog,
    the real work of loading the file begins. At this point, IDA’s goal is to load
    the selected executable file into memory and to analyze the relevant portions.
    This results in the creation of an IDA database whose components are stored in
    four files, each with a base name matching the selected executable and whose extensions
    are .*id0*, .*id1*, .*nam*, and .*til*. The .*id0* file contains the content of
    a B-tree–style database, while the *.id1* file contains flags that describe each
    program byte. The .*nam* file contains index information related to named program
    locations as displayed in IDA’s Names window (discussed further in [Chapter 5](ch05.html
    "Chapter 5. IDA Data Displays")). Finally, the .*til* file is used to store information
    concerning local type definitions specific to a given database. The formats of
    each of these files are proprietary to IDA, and they are not easily edited outside
    of the IDA environment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对加载选项满意并点击“确定”关闭对话框时，加载文件的实际工作就开始了。此时，IDA的目标是将选定的可执行文件加载到内存中，并分析相关部分。这将在四个文件中创建一个IDA数据库，每个文件都有一个与所选可执行文件匹配的基本名称，其扩展名为
    .*id0*、.*id1*、.*nam* 和 .*til*。.*id0* 文件包含B树风格数据库的内容，而 *.id1* 文件包含描述每个程序字节的标志。.*nam*
    文件包含与IDA名称窗口中显示的命名程序位置相关的索引信息（在[第5章](ch05.html "第5章。IDA数据显示")中进一步讨论）。最后，.*til*
    文件用于存储有关特定数据库的本地类型定义的信息。这些文件的格式是IDA专有的，并且它们在IDA环境之外不易编辑。
- en: For convenience, these four files are archived, and optionally compressed, into
    a single IDB file whenever you close your current project. When people refer to
    an IDA database, they are typically referring to the IDB file. An uncompressed
    database file is usually 10 times the size of the original input binary file.
    When the database is closed properly, you should never see files with *.id0*,
    *.id1*, *.nam*, or *.til* extensions in your working directories. Their presence
    often indicates that a database was not closed properly (for example, when IDA
    crashes) and that the database may be corrupt.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，每当您关闭当前项目时，这四个文件都会存档，并且可选地压缩成一个IDB文件。当人们提到IDA数据库时，他们通常指的是IDB文件。未压缩的数据库文件通常是原始输入二进制文件大小的10倍。当正确关闭数据库时，您的工作目录中不应出现具有
    *.id0*、*.id1*、*.nam* 或 *.til* 扩展名的文件。它们的存在通常表明数据库没有正确关闭（例如，当IDA崩溃时），并且数据库可能已损坏。
- en: LOADER WARNINGS
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器警告
- en: 'Once a loader begins to analyze a file, it may encounter circumstances that
    require additional user input in order to complete the loading process. One example
    of this occurs with PE files that have been created with PDB debugging information.
    If IDA determines that a *Program Database (PDB)* file may exist, you will be
    asked whether you want IDA to locate and to process the corresponding PDB file
    as shown in this message:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载器开始分析文件，它可能会遇到需要额外用户输入才能完成加载过程的情况。这种情况的一个例子是带有PDB调试信息的PE文件。如果IDA确定可能存在*程序数据库（PDB）*文件，您将被询问是否希望IDA查找并处理相应的PDB文件，如该消息所示：
- en: IDA Pro has determined that the input file was linked with debug information.
    Do you want to look for the corresponding PDB file at the local symbol store and
    the Microsoft Symbol Server?
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IDA Pro确定输入文件与调试信息链接。您是否希望在本地符号存储和Microsoft符号服务器中查找相应的PDB文件？
- en: 'A second example of a loader-generated informational message occurs with obfuscated
    programs such as malware. Obfuscation techniques often play fast and loose with
    file format specifications, which can cause problems for loaders expecting well-structured
    files. Knowing this, the PE loader performs some validation on import tables,
    and if the import tables do not seem to be formatted according to convention,
    IDA will display the following message:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器生成信息消息的第二个例子出现在混淆程序，如恶意软件中。混淆技术通常对文件格式规范处理得很快，这可能会给期望良好结构化文件的加载器带来问题。了解这一点后，PE加载器对导入表进行一些验证，如果导入表似乎没有按照惯例格式化，IDA将显示以下消息：
- en: The imports segment seems to be destroyed. This MAY mean that the file was packed
    or otherwise modified in order to make it more difficult to analyze. If you want
    to see the imports segment in the original form, please reload it with the ‘make
    imports section’ checkbox cleared.
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 导入段似乎已被破坏。这可能意味着文件被打包或以其他方式修改，以使其分析更加困难。如果您想以原始形式查看导入段，请清除“制作导入部分”复选框后重新加载。
- en: Examples of this error and how to deal with it will be covered in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本错误示例及其处理方法将在[第21章](ch21.html "第21章。混淆代码分析")中介绍。
- en: It is important to understand that once a database has been created for a given
    executable, IDA no longer requires access to that executable unless you intend
    to use IDA’s integrated debugger to debug the executable itself. From a security
    standpoint, this is a nice feature. For instance, when you are analyzing a malware
    sample, you can pass the associated database among analysts without passing along
    the malicious executable itself. There are no known cases in which an IDA database
    has been used as an attack vector for malicious software.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，一旦为给定的可执行文件创建了数据库，IDA就不再需要访问该可执行文件，除非你打算使用IDA的集成调试器来调试可执行文件本身。从安全的角度来看，这是一个很好的特性。例如，当你分析恶意软件样本时，你可以将相关的数据库在分析师之间传递，而不必传递恶意可执行文件本身。据知，没有已知案例表明IDA数据库被用作恶意软件的攻击向量。
- en: At its heart, IDA is nothing more than a database application. New databases
    are created and populated automatically from executable files. The various displays
    that IDA offers are simply views into the database that reveal information in
    a format useful to the software reverse engineer. Any modifications that users
    make to the database are reflected in the views and saved with the database, but
    these changes have no effect on the original executable file. The power of IDA
    lies in the tools it contains to analyze and manipulate the data within the database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，IDA（Interactive Disassembler）不过是一个数据库应用程序。新的数据库会自动从可执行文件中创建并填充。IDA提供的各种显示仅仅是数据库的视图，以对软件逆向工程师有用的格式揭示信息。用户对数据库所做的任何修改都会反映在视图中，并随数据库一起保存，但这些更改对原始的可执行文件没有任何影响。IDA的力量在于它包含用于分析和操作数据库内数据的工具。
- en: IDA Database Creation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA数据库创建
- en: Once you have chosen a file to analyze and specified your options, IDA initiates
    the creation of a database. For this process, IDA turns control over to the selected
    loader module, whose job it is to load the file from disk, parse any file-header
    information that it may recognize, create various program sections containing
    either code or data as specified in the file’s headers, and, finally, identify
    specific entry points into the code before returning control to IDA. In this regard,
    IDA loader modules behave much as operating system loaders behave. The IDA loader
    will determine a virtual memory layout based on information contained in the program
    file headers and configure the database accordingly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了要分析的文件并指定了你的选项，IDA就会启动数据库的创建过程。在这个过程中，IDA将控制权转交给选定的加载模块，该模块的职责是从磁盘加载文件，解析可能识别的任何文件头信息，创建包含代码或数据的各种程序部分，这些代码或数据在文件头中指定，最后在返回控制权给IDA之前，识别代码中的特定入口点。在这方面，IDA加载模块的行为与操作系统加载模块的行为非常相似。IDA加载器将根据程序文件头中的信息确定虚拟内存布局，并据此配置数据库。
- en: Once the loader has finished, the disassembly engine within IDA takes over and
    begins passing one address at a time to the selected processor module. The processor
    module’s job is to determine the type of instruction located at that address,
    the length of the instruction at that address, and the location(s) at which execution
    can continue from that address (e.g., is the current instruction sequential or
    branching?). When IDA is comfortable that it has found all of the instructions
    in the file, it makes a second pass through the list of instruction addresses
    and asks the processor module to generate the assembly language version of each
    instruction for display.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器完成后，IDA内部的反汇编引擎接管并开始逐个传递地址给选定的处理器模块。处理器模块的职责是确定该地址上指令的类型、该地址上指令的长度以及从该地址继续执行的位置（例如，当前指令是顺序的还是分支的？）。当IDA确信它已经找到了文件中的所有指令时，它将对指令地址列表进行第二次遍历，并要求处理器模块为每个指令生成汇编语言版本以供显示。
- en: 'Following this disassembly, IDA automatically conducts additional analysis
    of the binary file to extract additional information likely to be useful to the
    analyst. Users can expect to find some or all of the following information incorporated
    into the database once IDA completes its initial analysis:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此反汇编之后，IDA会自动对二进制文件进行额外的分析，以提取对分析师可能有用的额外信息。用户可以期待在IDA完成其初始分析后，以下信息中的一些或全部被纳入数据库：
- en: '**Compiler identification**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器识别**'
- en: It is often useful to know what compiler was used to build a piece of software.
    Identifying the compiler that was used can help us understand function-calling
    conventions used in a binary as well as determine what libraries the binary may
    be linked with. When a file is loaded, IDA attempts to identify the compiler that
    was used to create the input file. If the compiler can be identified, the input
    file is scanned for sequences of boilerplate code known to be used by that compiler.
    Such functions are color coded in an effort to reduce the amount of code that
    needs to be analyzed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 了解用于构建软件的编译器通常很有用。识别所使用的编译器可以帮助我们理解二进制文件中使用的函数调用约定，以及确定二进制文件可能链接的库。当文件被加载时，IDA
    会尝试识别用于创建输入文件的编译器。如果编译器可以被识别，输入文件将扫描该编译器已知使用的样板代码序列。这些函数将以颜色编码，以减少需要分析的代码量。
- en: '**Function argument and local variable identification**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数参数和局部变量识别**'
- en: Within each identified function (addresses that are targets of call instructions),
    IDA performs a detailed analysis of the behavior of the stack pointer register
    in order to both recognize accesses to variables located within the stack and
    understand the layout of the function’s stack frame.^([[32](#ftn.CHP-4-FN-4)])
    Names are automatically generated for such variables based on their use as either
    local variables within the function or as arguments passed into the function as
    part of the function call process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个已识别的函数（调用指令的目标地址）中，IDA 会详细分析栈指针寄存器的行为，以便识别位于栈内的变量访问，并理解函数栈帧的布局。[^([[32](#ftn.CHP-4-FN-4))]
    基于这些变量作为函数中的局部变量或作为函数调用过程中传递给函数的参数的使用，自动生成这些变量的名称。
- en: '**Datatype information**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据类型信息**'
- en: Utilizing knowledge of common library functions and their required parameters,
    IDA adds comments to the database to indicate the locations at which parameters
    are passed into these functions. These comments save the analyst a tremendous
    amount of time by providing information that would otherwise need to be retrieved
    from various application programming interface (API) references.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 利用对常见库函数及其所需参数的了解，IDA 在数据库中添加注释，以指示参数传递到这些函数的位置。这些注释通过提供信息节省了分析师大量时间，这些信息否则需要从各种应用程序编程接口（API）参考中检索。
- en: Closing IDA Databases
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭 IDA 数据库
- en: Any time you close a database, whether you are closing IDA altogether or simply
    switching to a different database, you are presented with the Save Database dialog,
    as shown in [Figure 4-6](ch04s02.html#the_save_database_dialog "Figure 4-6. The
    Save Database dialog").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时关闭数据库，无论是完全关闭 IDA 还是简单地切换到不同的数据库，都会出现保存数据库对话框，如图 4-6 所示。
- en: '![The Save Database dialog](httpatomoreillycomsourcenostarchimages854083.png.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![保存数据库对话框](httpatomoreillycomsourcenostarchimages854083.png.jpg)'
- en: Figure 4-6. The Save Database dialog
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6. 保存数据库对话框
- en: 'If this is the initial save of a newly created database, the new database filename
    is derived from the input filename by replacing the input extension with the *.idb*
    extension (e.g., *example.exe* yields a database named *example.idb*). When the
    input file has no extension, *.idb* is appended to form the name of the database
    (e.g., *httpd* yields *httpd.idb*). The available save options and their associated
    implications are summarized in the following list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是新创建数据库的初始保存，新数据库的文件名将从输入文件名中派生，将输入扩展名替换为 *.idb* 扩展名（例如，*example.exe* 生成名为
    *example.idb* 的数据库）。当输入文件没有扩展名时，将添加 *.idb* 以形成数据库的名称（例如，*httpd* 生成 *httpd.idb*）。以下列表总结了可用的保存选项及其相关影响：
- en: '**Don’t pack database**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要打包数据库**'
- en: This option simply flushes changes to the four database component files and
    closes the desktop *without* creating an IDB file. This option is *not recommended*
    when closing your databases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项仅将更改刷新到四个数据库组件文件，并关闭桌面，而**不**创建 IDB 文件。在关闭数据库时，**不推荐**使用此选项。
- en: '**Pack database (Store)**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包数据库（存储）**'
- en: Selecting the Store option results in the four database component files being
    archived into a single IDB file. Any previous IDB will be overwritten without
    confirmation. No compression is used with the Store option. Once the IDB file
    has been created, the four database component files are deleted.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 选择存储选项会将四个数据库组件文件存档为一个单一的 IDB 文件。任何之前的 IDB 文件都将被覆盖，而无需确认。存储选项不使用压缩。一旦创建 IDB
    文件，四个数据库组件文件将被删除。
- en: '**Pack database (Deflate)**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包数据库（Deflate）**'
- en: The Deflate option is identical to the Store option, with the exception that
    the database component files are compressed within the IDB archive.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Deflate选项与Store选项相同，只是数据库组件文件是在IDB存档内压缩的。
- en: '**Collect garbage**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**收集垃圾**'
- en: Requesting garbage collection causes IDA to delete any unused memory pages from
    the database prior to closing it. Select this option in conjunction with Deflate
    in order to create the smallest possible IDB file. This option is not generally
    required unless disk space is at a premium.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请求垃圾回收会导致IDA在关闭数据库之前删除任何未使用的内存页面。选择此选项与Deflate一起使用，以创建尽可能小的IDB文件。除非磁盘空间非常紧张，否则通常不需要此选项。
- en: '**DON’T SAVE the database**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要保存数据库**'
- en: You may wonder why anyone would choose not to save his work. It turns out that
    this option is the only way to discard changes that you have made to a database
    since the last time it was saved. When this option is selected, IDA simply deletes
    the four database component files and leaves any existing IDB file untouched.
    Using this option is as close as you will get to an undo or revert capability
    while using IDA.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么有人会选择不保存他的工作。实际上，这个选项是唯一一种方法来丢弃自上次保存以来对数据库所做的更改。当选择此选项时，IDA会简单地删除四个数据库组件文件，而不会触及任何现有的IDB文件。使用此选项是你在使用IDA时获得撤销或恢复功能的最接近方式。
- en: Reopening a Database
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新打开数据库
- en: Granted, reopening an existing database doesn’t involve rocket science,^([[33](#ftn.CHP-4-FN-5)])
    so you may be wondering why this topic is covered at all. Under ordinary circumstances,
    returning to work on an existing database is as simple as selecting the database
    using one of IDA’s file-opening methods. Database files open much faster the second
    (and subsequent) time around because there is no analysis to perform. As an added
    bonus, IDA restores your IDA desktop to the same state it was in at the time it
    was closed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，重新打开一个现有的数据库并不涉及火箭科学，^([[33](#ftn.CHP-4-FN-5)]) 因此你可能想知道为什么这个主题会被涵盖。在正常情况下，返回到现有的数据库工作非常简单，只需使用IDA的文件打开方法之一选择数据库。数据库文件在第二次（以及随后的）打开时打开得更快，因为没有分析要执行。作为额外的奖励，IDA会将你的IDA桌面恢复到关闭时的状态。
- en: Now for the bad news. Believe or not, IDA crashes on occasion. Whether because
    of a bug in IDA itself or because of a bug in some bleeding-edge plug-in you have
    installed, crashes leave open databases in a potentially corrupt state. Once you
    restart IDA and attempt to reopen the affected database, you are likely to see
    one of the dialogs shown in [Figure 4-7](ch04s02.html#database_restore_dialog
    "Figure 4-7. Database Restore dialog") and [Figure 4-8](ch04s02.html#database_repair_dialog
    "Figure 4-8. Database Repair dialog").
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是坏消息的时候了。信不信由你，IDA有时会崩溃。无论是由于IDA本身的错误还是由于你安装的一些前沿插件中的错误，崩溃都会使打开的数据库处于可能损坏的状态。一旦你重新启动IDA并尝试重新打开受影响的数据库，你很可能会看到[图4-7](ch04s02.html#database_restore_dialog
    "图4-7. 数据库恢复对话框")和[图4-8](ch04s02.html#database_repair_dialog "图4-8. 数据库修复对话框")中显示的其中一个对话框。
- en: '![Database Restore dialog](httpatomoreillycomsourcenostarchimages854085.png.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![数据库恢复对话框](httpatomoreillycomsourcenostarchimages854085.png.jpg)'
- en: Figure 4-7. Database Restore dialog
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-7. 数据库恢复对话框
- en: When IDA crashes, there is no opportunity for IDA to close the active database,
    and the intermediate database files do not get deleted. If this was not the first
    time that you were working with a particular database, you may have a situation
    in which both an IDB file and potentially corrupt intermediate files are present
    at the same time. The IDB file represents the last-known good state of the database,
    while the intermediate files contain any changes that may have been made since
    the last save operation. In this case, you will be offered the choice to revert
    to the saved version or resume use of the open, potentially corrupt version, as
    shown in [Figure 4-7](ch04s02.html#database_restore_dialog "Figure 4-7. Database
    Restore dialog"). Choosing Continue with Unpacked Base by no means guarantees
    that you will recover your work. The unpacked database is probably in an inconsistent
    state, which will prompt IDA to offer the dialog shown in [Figure 4-8](ch04s02.html#database_repair_dialog
    "Figure 4-8. Database Repair dialog"). In this case, IDA itself recommends that
    you consider restoring from the packed data, so consider yourself warned if you
    opt to go with a repaired database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当 IDA 崩溃时，IDA 没有机会关闭活动数据库，中间数据库文件也不会被删除。如果你不是第一次使用特定的数据库，你可能会遇到同时存在 IDB 文件和可能损坏的中间文件的情况。IDB
    文件代表数据库的最后一个已知良好状态，而中间文件包含自上次保存操作以来可能进行的任何更改。在这种情况下，你将有机会选择恢复到保存版本或继续使用打开的、可能损坏的版本，如图
    [图 4-7](ch04s02.html#database_restore_dialog "图 4-7。数据库恢复对话框") 所示。选择“继续使用未打包的基”并不能保证你将恢复你的工作。未打包的数据库可能处于不一致的状态，这会提示
    IDA 提供如图 [图 4-8](ch04s02.html#database_repair_dialog "图 4-8。数据库修复对话框") 所示的对话框。在这种情况下，IDA
    本身建议你考虑从打包数据中恢复，所以如果你选择使用修复后的数据库，请务必小心。
- en: '![Database Repair dialog](httpatomoreillycomsourcenostarchimages854087.png.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![数据库修复对话框](httpatomoreillycomsourcenostarchimages854087.png.jpg)'
- en: Figure 4-8. Database Repair dialog
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8。数据库修复对话框
- en: When an active database has never been saved, thus leaving only intermediate
    files present at the time of the crash, IDA offers the repair option in [Figure 4-8](ch04s02.html#database_repair_dialog
    "Figure 4-8. Database Repair dialog") as soon as you try to open the original
    executable file again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动数据库从未保存，因此在崩溃时只留下中间文件时，当你再次尝试打开原始可执行文件时，IDA 会立即在 [图 4-8](ch04s02.html#database_repair_dialog
    "图 4-8。数据库修复对话框") 中提供修复选项。
- en: '* * *'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[32](#CHP-4-FN-4)]) Stack frames are discussed further in [Chapter 6](ch06.html
    "Chapter 6. Disassembly Navigation").
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#CHP-4-FN-4)]) 栈帧的讨论在 [第 6 章](ch06.html "第 6 章。反汇编导航") 中进一步展开。
- en: ^([[33](#CHP-4-FN-5)]) Unless you happen to be opening *rocket_science.idb*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[33](#CHP-4-FN-5)]) 除非你恰好正在打开 *rocket_science.idb*。
- en: Introduction to the IDA Desktop
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA 桌面简介
- en: Given the amount of time you are likely to spend staring at your IDA desktop,
    you will want to spend some time familiarizing yourself with its various components.
    [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The IDA desktop") shows
    an overview of a default IDA desktop. The behavior of the desktop during file
    analysis is discussed in the following section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你可能会花大量时间盯着 IDA 桌面，你将想要花些时间熟悉其各种组件。[图 4-9](ch04s03.html#the_ida_desktop "图
    4-9。IDA 桌面") 展示了一个默认 IDA 桌面的概览。文件分析期间桌面行为将在下一节中讨论。
- en: 'Areas of interest in this introductory view include the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简介视图中感兴趣的区域包括以下内容：
- en: The *toolbar area* ![](httpatomoreillycomsourcenostarchimages854061.png) contains
    tools corresponding to the most commonly used IDA operations. Toolbars are added
    to and removed from the desktop using the View ▸ Toolbars command. Using drag-and-drop,
    you can reposition each of the toolbars to suit your needs. [Figure 4-9](ch04s03.html#the_ida_desktop
    "Figure 4-9. The IDA desktop") shows IDA’s basic mode toolbar with a single row
    of tool buttons. An advanced mode toolbar is available using View ▸ Toolbars ▸
    Advanced mode. The Advanced mode toolbars contain three full rows of tool buttons.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*工具栏区域* ![](httpatomoreillycomsourcenostarchimages854061.png) 包含与 IDA 最常用操作相对应的工具。使用“视图”▸“工具栏”命令可以将工具栏添加到或从桌面中移除。使用拖放，你可以重新定位每个工具栏以满足你的需求。[图
    4-9](ch04s03.html#the_ida_desktop "图 4-9。IDA 桌面") 展示了 IDA 的基本模式工具栏，其中包含一行工具按钮。使用“视图”▸“工具栏”▸“高级模式”可以获取高级模式工具栏。高级模式工具栏包含三行完整的工具按钮。'
- en: '![The IDA desktop](httpatomoreillycomsourcenostarchimages854089.png.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![IDA 桌面](httpatomoreillycomsourcenostarchimages854089.png.jpg)'
- en: Figure 4-9. The IDA desktop
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-9。IDA 桌面
- en: The horizontal color band is IDA’s *overview navigator* ![](httpatomoreillycomsourcenostarchimages854063.png),
    also called the *navigation band*. The navigation band presents a linear view
    of the address space of the loaded file. By default, the entire address range
    of the binary is represented. You can zoom in and out of the address range by
    right-clicking anywhere within the navigation band and selecting one of the available
    zoom options. Different colors represent different types of file content, such
    as data or code. A small *current position indicator* (yellow by default) points
    at the navigation band address that corresponds to the current address range being
    displayed in the disassembly window. Hovering the mouse cursor over any portion
    of the navigation band yields a tool tip that describes that location in the binary.
    Clicking the navigation band jumps the disassembly view to the selected location
    within the binary. The colors used in the navigation band can be customized using
    the Options ▸ Colors command. Dragging the navigation band away from the IDA desktop
    yields a detached Overview Navigator, as shown in [Figure 4-10](ch04s03.html#the_overview_navigator
    "Figure 4-10. The Overview Navigator"). Also shown in [Figure 4-10](ch04s03.html#the_overview_navigator
    "Figure 4-10. The Overview Navigator") is the current position indicator (the
    half-length, downward-facing arrow to the left of location ![](httpatomoreillycomsourcenostarchimages854061.png))
    and a *color key* identifying the file content by functional groups.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平颜色带是 IDA 的 **概览导航器** ![水平颜色带](httpatomoreillycomsourcenostarchimages854063.png)，也称为
    **导航带**。导航带展示了加载文件的地址空间线性视图。默认情况下，二进制文件的整个地址范围都被表示。您可以通过在导航带内任何位置右键单击并选择可用的缩放选项来放大或缩小地址范围。不同的颜色代表不同类型的文件内容，例如数据或代码。一个小的
    **当前位置指示器**（默认为黄色）指向与在反汇编窗口中显示的当前地址范围相对应的导航带地址。将鼠标光标悬停在导航带的任何部分上都会显示一个工具提示，描述二进制中的该位置。单击导航带会将反汇编视图跳转到二进制中的选定位置。导航带中使用的颜色可以通过选项
    ▸ 颜色命令进行自定义。将导航带从 IDA 桌面拖离会产生一个分离的概览导航器，如图 [图 4-10](ch04s03.html#the_overview_navigator
    "图 4-10. 概览导航器") 所示。图 [图 4-10](ch04s03.html#the_overview_navigator "图 4-10. 概览导航器")
    还显示了当前位置指示器（位于位置 ![当前位置指示器](httpatomoreillycomsourcenostarchimages854061.png)
    左侧的半长向下箭头）和一个 **颜色键**，通过功能组识别文件内容。
- en: '![The Overview Navigator](httpatomoreillycomsourcenostarchimages854091.png.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![概览导航器](httpatomoreillycomsourcenostarchimages854091.png.jpg)'
- en: Figure 4-10. The Overview Navigator
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-10. 概览导航器
- en: 'Coming back to [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The IDA
    desktop"), *tabs* ![](httpatomoreillycomsourcenostarchimages854093.png) are provided
    for each of the currently open data displays. Data displays contain information
    extracted from the binary and represent the various views into the database. The
    majority of your analysis work is likely to take place through interaction with
    the available data displays. [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The
    IDA desktop") shows three of the available data displays: IDA-View, Functions,
    and Graph Overview. Additional data displays are available via the View ▸ Open
    Subviews menu, and this menu is also used to restore any displays that have been
    closed, whether on purpose or inadvertently.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 [图 4-9](ch04s03.html#the_ida_desktop "图 4-9. IDA 桌面")，为每个当前打开的数据显示提供了 **标签**
    ![标签](httpatomoreillycomsourcenostarchimages854093.png)。数据显示包含从二进制中提取的信息，并代表对数据库的各种视图。您的大部分分析工作可能将通过与可用的数据显示的交互来完成。[图
    4-9](ch04s03.html#the_ida_desktop "图 4-9. IDA 桌面") 显示了三个可用的数据显示：IDA-View、函数和图形概览。通过视图
    ▸ 打开子视图菜单可以获得更多数据显示，并且此菜单也用于恢复任何已关闭的显示，无论是故意还是意外关闭的。
- en: 'The *disassembly view* ![](httpatomoreillycomsourcenostarchimages854095.png)
    is the primary data display. Two display styles are available for the disassembly
    view: graph view (default) and listing view. In graph view, IDA displays a flowchart-style
    graph of a single function at any given time. When this is combined with the *graph
    overview*, you can gain an understanding of the flow of the function using a visual
    breakdown of the function’s structure. When the IDA-View window is active, the
    spacebar toggles between graph view–style and listing-style displays. If you wish
    to make listing view your default, you must uncheck Use graph view by default
    on the Graph tab via the Options ▸ General menu, as shown in [Figure 4-11](ch04s03.html#ida_graph_options
    "Figure 4-11. IDA graph options").'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*反汇编视图* ![](httpatomoreillycomsourcenostarchimages854095.png) 是主要的数据显示。反汇编视图有两种显示风格：图形视图（默认）和列表视图。在图形视图中，IDA
    在任何给定时间显示单个函数的流程图风格图形。当与 *图形概览* 结合使用时，您可以通过对函数结构的视觉分解来了解函数的流程。当 IDA-View 窗口处于活动状态时，空格键在图形视图样式和列表视图样式之间切换。如果您希望将列表视图设置为默认视图，您必须在“图形”选项卡中取消选中“默认使用图形视图”，通过“选项”▸“常规”菜单进行，如图
    [图 4-11](ch04s03.html#ida_graph_options "图 4-11。IDA 图形选项") 所示。'
- en: '![IDA graph options](httpatomoreillycomsourcenostarchimages854097.png.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![IDA 图形选项](httpatomoreillycomsourcenostarchimages854097.png.jpg)'
- en: Figure 4-11. IDA graph options
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-11。IDA 图形选项
- en: In graph view, it is seldom possible to fit the entire graph of a function into
    the display area at one time. The *graph overview* ![](httpatomoreillycomsourcenostarchimages854099.png),
    present only when graph view is active, provides a zoomed-out snapshot of the
    basic graph structure. A dotted rectangle indicates the current display within
    the graph view. Clicking within the graph overview repositions the graph view
    accordingly.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图形视图中，通常很难一次将整个函数图放入显示区域。仅在图形视图活动时才提供的 *图形概览* ![](httpatomoreillycomsourcenostarchimages854099.png)，提供了一个基本图形结构的缩略图。一个虚线矩形指示图形视图中当前显示的内容。在图形概览中单击将相应地重新定位图形视图。
- en: The *Output window* ![](httpatomoreillycomsourcenostarchimages854101.png) is
    where you can expect to find any informational messages generated by IDA. Here
    you will find status messages concerning the progress of the file-analysis phase,
    along with any error messages resulting from user-requested operations. The Output
    window roughly equates to a console output device.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*输出窗口* ![](httpatomoreillycomsourcenostarchimages854101.png) 是您可以预期找到由 IDA
    生成的任何信息消息的地方。在这里，您可以找到有关文件分析阶段进度的状态消息，以及由用户请求的操作产生的任何错误消息。输出窗口大致相当于控制台输出设备。'
- en: The *Functions window* ![](httpatomoreillycomsourcenostarchimages854103.png)
    rounds out the default IDA display windows and will be discussed further in [Chapter 5](ch05.html
    "Chapter 5. IDA Data Displays").
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*函数窗口* ![](httpatomoreillycomsourcenostarchimages854103.png) 完善了 IDA 的默认显示窗口，将在
    [第 5 章](ch05.html "第 5 章。IDA 数据显示") 中进一步讨论。'
- en: Desktop Behavior During Initial Analysis
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始分析期间的桌面行为
- en: 'A tremendous amount of activity takes place within the IDA desktop during the
    initial autoanalysis of a newly opened file. You can gain an understanding of
    this analysis by observing various desktop displays during the analysis process.
    Desktop activity you may observe includes the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在对新打开的文件进行初始自动分析期间，IDA 桌面内发生大量活动。您可以通过在分析过程中观察各种桌面显示来了解这种分析。您可能观察到的桌面活动包括以下内容：
- en: Progress messages printed to the Output window
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印到输出窗口的进度消息
- en: Initial location and disassembly output generated for the disassembly window
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为反汇编窗口生成的初始位置和反汇编输出
- en: Initial population of the Functions window, followed by periodic updates as
    the analysis progresses
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着分析进展，函数窗口的初始填充，然后定期更新
- en: Transformation of the navigation band as new areas of the binary are recognized
    as code and data, blocks of code are further recognized as functions, and, finally,
    functions are recognized specifically as library code using IDA’s pattern-matching
    techniques
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着二进制新区域被识别为代码和数据，代码块被进一步识别为函数，最后，使用 IDA 的模式匹配技术将函数特别识别为库代码，导航带的转换
- en: The current position indicator traversing the navigation band to show the regions
    currently being analyzed
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前位置指示器在导航带中遍历以显示当前正在分析的区域
- en: The following output is representative of messages generated by IDA during the
    initial analysis of a newly opened binary file. Notice that the messages form
    a narrative of the analysis process and offer insight into the sequence of operations
    performed by IDA during that analysis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是 IDA 在对新打开的二进制文件进行初始分析期间生成的消息的示例。请注意，这些消息构成了分析过程的故事，并提供了对 IDA 在该分析期间执行的操作顺序的见解。
- en: '[PRE0]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Two particularly helpful progress messages are `You may start to explore the
    input file right now` ![](httpatomoreillycomsourcenostarchimages854061.png) and
    `The initial autoanalysis has been finished` ![](httpatomoreillycomsourcenostarchimages854063.png).
    The first message informs you that IDA has made enough progress with its analysis
    that you can begin navigating through the various data displays. Navigating does
    not imply changing, however, and you should wait to make any changes to the database
    until the analysis phase has been completed. If you attempt to change the database
    prior to completion of the analysis phase, the analysis engine may come along
    later and modify your changes further, or you may even prevent the analysis engine
    from doing its job correctly. The second of these messages, which is fairly self-explanatory,
    indicates that you can expect no more automatic changes to take place in the desktop
    data displays. At this point it is safe to make any changes you like to the database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 两个特别有用的进度消息是“你现在可以开始探索输入文件了” ![](httpatomoreillycomsourcenostarchimages854061.png)
    和“初始自动分析已完成” ![](httpatomoreillycomsourcenostarchimages854063.png)。第一条消息通知你 IDA
    在分析方面已经取得了足够的进展，你可以开始浏览各种数据显示。导航并不意味着更改，你应该等待分析阶段完成后才对数据库进行任何更改。如果在分析阶段完成之前尝试更改数据库，分析引擎可能会稍后修改你的更改，或者你甚至可能阻止分析引擎正确执行其任务。第二条消息相当直观，表明你不需要在桌面数据显示中期待更多的自动更改。此时，你可以安全地对数据库进行任何你喜欢的更改。
- en: IDA Desktop Tips and Tricks
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA 桌面技巧与窍门
- en: 'IDA offers a tremendous amount of information, and its desktop can become cluttered.
    Here are some tips for making the best use of your desktop:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 提供了大量的信息，其桌面可能会变得杂乱。以下是一些关于如何充分利用桌面的一些技巧：
- en: The more screen real estate you dedicate to IDA, the happier you will be. Use
    this fact to justify the purchase of a king-size monitor (or two)!
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你为 IDA 贡献的屏幕空间越多，你将越快乐。利用这个事实来证明购买一个超大型显示器（或两个）的合理性！
- en: Don’t forget the View ▸ Open Subviews command as a means of restoring data displays
    that you have inadvertently closed.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记使用“视图 ▸ 打开子视图”命令来恢复你意外关闭的数据显示。
- en: The Windows ▸ Reset Desktop command offers a useful way to quickly restore your
    desktop to its original layout.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “窗口 ▸ 重置桌面”命令提供了一种快速恢复桌面原始布局的有用方法。
- en: Utilize the Windows ▸ Save Desktop command to save a current layout of desktop
    configurations that you find particularly useful. The Windows ▸ Load Desktop command
    is used to quickly revert to a saved layout.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“窗口 ▸ 保存桌面布局”命令来保存当前桌面配置的布局，这些布局可能特别有用。使用“窗口 ▸ 加载桌面布局”命令可以快速恢复到保存的布局。
- en: The only window for which the display font can be changed is the Disassembly
    window (either graph or listing view). Fonts are set using the Options ▸ Font
    command.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一可以更改显示字体的窗口是“反汇编窗口”（无论是图形还是列表视图）。字体设置通过“选项 ▸ 字体”命令进行。
- en: Reporting Bugs
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告bug
- en: As with any piece of software, IDA has been known to contain an occasional bug,
    so what can you expect from Hex-Rays if you think you have found a bug in IDA
    itself? First, Hex-Rays has one of the most responsive support systems you can
    will ever deal with. Second, don’t be surprised if you hear back from Ilfak himself
    within a day of submitting a support request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何软件一样，IDA 有时会包含一些偶尔的bug，如果你认为你在 IDA 本身中发现了bug，你期望从 Hex-Rays 得到什么？首先，Hex-Rays
    拥有你可以遇到的反应最快的支持系统之一。其次，如果你在提交支持请求后一天内收到 Ilfak 本人的回复，请不要感到惊讶。
- en: Two methods are available for submitting bug reports. You can send email to
    [support@hex-rays.com](mailto:support@hex-rays.com), or if you prefer not to use
    email, you may post to the Bug Reports forum on the Hex-Rays bulletin boards.
    In either case, you should both verify that you can reproduce your bug and be
    prepared to provide Hex-Rays with a copy of the database file involved with the
    problem. Recall that Hex-Rays only provides SDK support for an additional fee.
    For bugs related to a plug-in that you have installed, you will need to contact
    the plug-in’s author. For bugs related to a plug-in that you are developing, you
    will need to take advantage of the support forums available for IDA users and
    hope for a helpful response from a fellow user.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提交错误报告有两种方法。您可以发送电子邮件到[support@hex-rays.com](mailto:support@hex-rays.com)，或者如果您不想使用电子邮件，您也可以在Hex-Rays公告板上的错误报告论坛上发帖。在两种情况下，您都应该验证您能否重现您的错误，并准备好向Hex-Rays提供涉及问题的数据库文件的副本。请记住，Hex-Rays仅提供额外费用的SDK支持。对于与您已安装的插件相关的错误，您需要联系插件的作者。对于与您正在开发的插件相关的错误，您需要利用IDA用户可用的支持论坛，并希望得到其他用户的帮助性回复。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Familiarity with the IDA workspace will greatly enhance your experience with
    IDA. Reverse engineering binary code is difficult enough without having to struggle
    with your tools. The options that you choose during the initial loading phase
    and the subsequent autoanalysis performed by IDA set the stage for all of the
    analysis that you will do later. At this point you may be content with the work
    that IDA has accomplished on your behalf, and for simple binaries, autoanalysis
    may be all that you need. On the other hand, if you wonder what puts the *interactive*
    in IDA, you are now ready to dive deeper into the functionality of IDA’s many
    data displays. In the coming chapters you will be introduced to each of the primary
    displays, the circumstances under which you will find each one useful, and how
    to utilize these displays to enhance and update your databases.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉IDA工作空间将大大增强您使用IDA的体验。在没有与您的工具斗争的情况下，逆向工程二进制代码就已经足够困难了。您在初始加载阶段所做的选择以及IDA随后进行的自动分析为所有后续分析奠定了基础。在这个阶段，您可能对IDA为您完成的工作感到满意，对于简单的二进制文件，自动分析可能就是您所需要的。另一方面，如果您想知道是什么让IDA的*交互性*如此之强，那么您现在就可以更深入地了解IDA众多数据显示的功能了。在接下来的章节中，您将了解到每个主要显示，您将在什么情况下发现每个显示有用，以及如何利用这些显示来增强和更新您的数据库。
- en: Chapter 5. IDA Data Displays
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。IDA数据显示
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: At this point you should have some confidence loading binaries into IDA and
    letting IDA work its magic while you sip your favorite beverage. Once IDA’s initial
    analysis phase is complete, it is time for you to take control. One of the best
    ways for you to familiarize yourself with IDA’s displays is simply to browse around
    the various tabbed subwindows that IDA populates with data about your binary.
    The efficiency and effectiveness of your reverse engineering sessions will improve
    as your comfort level with IDA increases.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对将二进制文件加载到IDA并让IDA施展魔法同时品尝您最喜欢的饮料有些信心。一旦IDA的初始分析阶段完成，就是您接管的时候了。您熟悉IDA显示的最好方法之一就是简单地浏览IDA填充有关您二进制文件数据的各种选项卡子窗口。随着您对IDA的舒适度提高，您逆向工程会议的效率和效果也会提高。
- en: 'Before we dive into the major IDA subdisplays, it is useful to cover a few
    basic rules concerning IDA’s user interface:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨IDA的主要子显示之前，了解一些关于IDA用户界面的基本规则是有用的：
- en: '**There is no undo in IDA**.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDA中没有撤销操作**。'
- en: If something unexpected happens to your database as a result of an inadvertent
    keypress, you are on your own to restore your displays to their previous states.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于意外按键导致您的数据库出现问题，您需要自己将显示恢复到之前的状态。
- en: '**Almost all actions have an associated menu item, hotkey, and toolbar button**.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**几乎所有操作都有一个相关的菜单项、热键和工具栏按钮**。'
- en: Remember, the IDA toolbar is highly configurable, as is the mapping of hotkeys
    to menu actions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，IDA工具栏高度可配置，热键到菜单操作的映射也是如此。
- en: '**IDA offers good, context-sensitive menu actions in response to right mouse
    clicks**.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDA在鼠标右键点击时提供良好的上下文相关菜单操作**。'
- en: While these menus do not offer an exhaustive list of permissible actions at
    a given location, they do serve as good reminders for the most common actions
    you will be performing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些菜单并没有提供在特定位置允许执行的所有操作的详尽列表，但它们确实作为你将要执行的最常见操作的良好提醒。
- en: With these facts in mind, let’s begin our coverage of the principal IDA data
    displays.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些事实，让我们开始介绍主要的IDA数据显示。
- en: The Principal IDA Displays
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要的IDA显示
- en: In its default configuration, IDA creates seven (as of version 6.1) display
    windows during the initial loading-and-analysis phase for a new binary. Each of
    these display windows is accessible via a set of title tabs displayed immediately
    beneath the navigation band (shown previously in [Figure 4-9](ch04s03.html#the_ida_desktop
    "Figure 4-9. The IDA desktop")). The three immediately visible windows are the
    IDA-View window, the Functions window, and the Output window. Whether or not they
    are open by default, all of the windows discussed in this chapter can be opened
    via the View ▸ Open Subviews menu. Keep this fact in mind, as it is fairly easy
    to inadvertently close the display windows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置下，IDA在为新二进制文件加载和分析阶段创建七个（截至版本6.1）显示窗口。这些显示窗口中的每一个都可以通过立即显示在导航带下方的一组标题标签访问（如前所述的[图4-9](ch04s03.html#the_ida_desktop
    "图4-9. IDA桌面"))。三个立即可见的窗口是IDA-View窗口、函数窗口和输出窗口。无论它们是否默认打开，本章中讨论的所有窗口都可以通过“视图 ▸
    打开子视图”菜单打开。请记住这个事实，因为不小心关闭显示窗口是相当容易的。
- en: The esc key is one of the more useful hotkeys in all of IDA. When the disassembly
    window is active, the esc key functions in a manner similar to a web browser’s
    back button and is therefore very useful in navigating the disassembly display
    (navigation is covered in detail in [Chapter 6](ch06.html "Chapter 6. Disassembly
    Navigation")). Unfortunately, when any other window is active, the esc key serves
    to close the window. Occasionally, this is exactly what you want. At other times,
    you will immediately wish you had that closed window back.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: esc键是IDA中所有快捷键中比较有用的一种。当反汇编窗口处于活动状态时，esc键的功能类似于网络浏览器的后退按钮，因此在导航反汇编显示（导航将在第6章中详细说明）时非常有用。不幸的是，当任何其他窗口处于活动状态时，esc键的作用是关闭窗口。有时，这正是你想要的。在其他时候，你可能会立刻希望那个关闭的窗口能回来。
- en: The Disassembly Window
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反汇编窗口
- en: Also known as the IDA-View window, the disassembly window will be your primary
    tool for manipulating and analyzing binaries. Accordingly, it is important that
    you become intimately familiar with the manner in which information is presented
    in the disassembly window.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为IDA-View窗口，反汇编窗口将是您操作和分析二进制文件的主要工具。因此，熟悉反汇编窗口中信息呈现的方式非常重要。
- en: 'Two display formats are available for the disassembly window: the default graph-based
    view and a text-oriented listing view. Most IDA users tend to prefer one view
    over the other, and the view that better suits your needs is often determined
    by how you prefer to visualize a program’s flow. If you prefer to use the text
    listing view as your default disassembly view, you can change the default by using
    the Options ▸ General dialog to turn off Use graph view by default on the Graph
    tab. Whenever the disassembly view is active, you can easily switch between graph
    and listing views at any time by using the spacebar.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编窗口提供了两种显示格式：默认的基于图形的视图和以文本为导向的列表视图。大多数IDA用户倾向于偏好其中一种视图，而最适合你需求的视图通常取决于你如何偏好可视化程序的流程。如果你偏好使用文本列表视图作为默认的反汇编视图，你可以通过使用“选项
    ▸ 一般”对话框在“图形”选项卡上关闭“默认使用图形视图”来更改默认设置。每当反汇编视图处于活动状态时，你可以通过使用空格键在任何时候轻松地在图形和列表视图之间切换。
- en: IDA Graph View
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDA图形视图
- en: '[Figure 5-1](ch05.html#ida_graph_view-id1 "Figure 5-1. IDA graph view") shows
    a very simple function displayed in graph view. Graph views are somewhat reminiscent
    of program flowcharts in that a function is broken up into basic blocks^([[34](#ftn.CHP-5-FN-1)])
    so you can visualize the function’s control flow from one block to another.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-1](ch05.html#ida_graph_view-id1 "图5-1. IDA图形视图") 展示了一个在图形视图中显示的非常简单的函数。图形视图在某种程度上让人联想到程序流程图，因为一个函数被分解成基本块^([[34](#ftn.CHP-5-FN-1)))，这样你可以可视化函数从一块到另一块的控制流。'
- en: '![IDA graph view](httpatomoreillycomsourcenostarchimages854105.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![IDA图形视图](httpatomoreillycomsourcenostarchimages854105.png)'
- en: Figure 5-1. IDA graph view
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1. IDA图形视图
- en: 'Onscreen, you’ll notice IDA uses different colored arrows to distinguish various
    types of flows^([[35](#ftn.CHP-5-FN-2)]) between the blocks of a function. Basic
    blocks that terminate with a conditional jump generate two possible flows depending
    on the condition being tested: the *Yes edge* arrow (yes, the branch is taken)
    is green by default, and the *No edge* arrow (no, the branch is not taken) is
    red by default. Basic blocks that terminate with only one potential successor
    block utilize a *Normal edge* (blue by default) to point to the next block to
    be executed.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，你会注意到IDA使用不同颜色的箭头来区分函数块之间的各种类型的数据流^([[35](#ftn.CHP-5-FN-2)])。以条件跳转结束的基本块会根据测试的条件生成两种可能的数据流：默认情况下，*是边*箭头（是的，分支被采取）是绿色的，而*否边*箭头（不，分支没有被采取）是红色的。以只有一个潜在后继块结束的基本块使用默认为蓝色的*正常边*来指向下一个要执行的基本块。
- en: In graph mode, IDA displays one function at a time. For users with a wheel mouse,
    graph zooming is possible using the ctrl- wheel combination. Keyboard zoom control
    requires ctrl-+ to zoom in or ctrl- − to zoom out (using the + and − keys on the
    numeric keypad). Large or complex functions may cause the graph view to become
    extremely cluttered, making the graph difficult to navigate. In such cases, the
    Graph Overview window (see [Figure 5-2](ch05.html#the_graph_overview_window "Figure 5-2. The
    Graph Overview window")) is available to provide some situational awareness. The
    overview window always displays the complete block structure of the graph along
    with a dashed frame that indicates the region of the graph currently being viewed
    in the disassembly window. The dashed frame can be dragged across the overview
    window to rapidly reposition the graph view to any desired location on the graph.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形模式下，IDA一次显示一个函数。对于使用滚轮鼠标的用户，可以通过ctrl-滚轮组合进行图形缩放。键盘缩放控制需要使用ctrl-+来放大或ctrl-
    −来缩小（使用数字键盘上的+和-键）。大型或复杂的函数可能会导致图形视图变得极其杂乱，使得图形难以导航。在这种情况下，可以使用图形概览窗口（见[图5-2](ch05.html#the_graph_overview_window
    "图5-2. 图形概览窗口"))来提供一些情境感知。概览窗口始终显示图形的完整块结构，以及一个虚线框，该框指示当前在反汇编窗口中查看的图形区域。可以拖动虚线框穿过概览窗口，快速重新定位图形视图到图形上的任何所需位置。
- en: '![The Graph Overview window](httpatomoreillycomsourcenostarchimages854107.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图形概览窗口](httpatomoreillycomsourcenostarchimages854107.png)'
- en: Figure 5-2. The Graph Overview window
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2. 图形概览窗口
- en: 'With the graph display, there are several ways that you can manipulate the
    view to suit your needs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图形显示时，有几种方法可以操纵视图以满足你的需求：
- en: '**Panning**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**平移**'
- en: First, in addition the using the Graph Overview window to rapidly reposition
    the graph, you can also reposition the graph by clicking and dragging the background
    of the graph view.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了使用图形概览窗口快速重新定位图形外，你还可以通过点击并拖动图形视图的背景来重新定位图形。
- en: HEY, ISN’T SOMETHING MISSING HERE?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，这里是不是缺少了什么？
- en: When using graph view, it may seem as if less information is available to you
    about each line of the disassembly. The reason for this is that IDA chooses to
    hide many of the more traditional pieces of information about each disassembled
    line (such as virtual address information) in order to minimize the amount of
    space required to display each basic block. You can choose to display additional
    information with each disassembly line by choosing among the available *disassembly
    line parts* accessible via the *Disassembly* tab from Options ▸ General. For example,
    to add virtual addresses to each disassembly line, we enable *line prefixes*,
    transforming the graph from [Figure 5-1](ch05.html#ida_graph_view-id1 "Figure 5-1. IDA
    graph view") into the graph shown in [Figure 5-3](ch05.html#graph_view_with_line_prefixes_enabled
    "Figure 5-3. Graph view with line prefixes enabled").
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用图形视图时，可能会觉得关于每条反汇编指令的信息似乎更少。这是因为IDA选择隐藏关于每条反汇编指令的许多更传统信息（例如虚拟地址信息），以最小化显示每个基本块所需的空间。你可以通过从选项
    ▸ 通用中的*反汇编*选项卡中选择，来选择显示每条反汇编指令的附加信息。例如，要为每条反汇编指令添加虚拟地址，我们启用*行前缀*，将图形从[图5-1](ch05.html#ida_graph_view-id1
    "图5-1. IDA图形视图")转换为[图5-3](ch05.html#graph_view_with_line_prefixes_enabled "图5-3.
    启用行前缀的图形视图")所示的图形。
- en: '![Graph view with line prefixes enabled](httpatomoreillycomsourcenostarchimages854109.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![启用行前缀的图形视图](httpatomoreillycomsourcenostarchimages854109.png)'
- en: Figure 5-3. Graph view with line prefixes enabled
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3. 启用行前缀的图形视图
- en: '**Rearranging blocks**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新排列块**'
- en: Individual blocks within the graph can be dragged to new positions by clicking
    the title bar for the desired block and dragging it to a new position. Beware
    that IDA performs only minimal rerouting of any edges associated with a moved
    block. You can manually reroute edges by dragging vertices to new locations. New
    vertices can be introduced into an edge by double-clicking the desired location
    within an edge while holding the shift key. If at any point you find yourself
    wishing to revert to the default layout for your graph, you can do so by right-clicking
    the graph and choosing Layout Graph.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过单击所需块的标题栏并将其拖动到新位置来将图中的单个块拖动到新位置。请注意，IDA仅对移动的块关联的任何边缘进行最小重路由。您可以通过将顶点拖动到新位置来手动重路由边缘。在按住shift键的同时双击边缘内的所需位置可以引入新的顶点。如果您在任何时候希望将图形的默认布局恢复为默认布局，可以通过右键单击图形并选择“布局图形”来实现。
- en: '**Grouping and collapsing blocks**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**分组和折叠块**'
- en: Blocks can be grouped, either individually or together with other blocks, and
    collapsed to reduce the clutter in the display. Collapsing blocks is a particularly
    useful technique for keeping track of blocks that you have already analyzed. You
    can collapse any block by right-clicking the block’s title bar and selecting Group
    Nodes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将块分组，无论是单独还是与其他块一起，并且可以折叠以减少显示中的杂乱。折叠块是跟踪您已经分析过的块的特别有用的技术。您可以通过右键单击块的标题栏并选择“分组节点”来折叠任何块。
- en: '**Creating additional disassembly windows**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建额外的反汇编窗口**'
- en: If you ever find yourself wanting to view graphs of two functions simultaneously,
    all you need to do is open another disassembly window using Views ▸ Open Subviews
    ▸ Disassembly. The first disassembly window opened is titled *IDA View-A*. Subsequent
    disassembly windows are titled *IDA View-B*, *IDA View-C*, and so on. Each disassembly
    is independent of the other, and it is perfectly acceptable to view a graph in
    one window while viewing a text listing in another or to view three different
    graphs in three different windows.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想同时查看两个函数的图形，您只需使用“视图”▸“打开子视图”▸“反汇编”打开另一个反汇编窗口。第一个打开的反汇编窗口标题为“IDA View-A”。随后的反汇编窗口标题为“IDA
    View-B”、“IDA View-C”等等。每个反汇编都是独立的，在另一个窗口中查看文本列表的同时查看一个窗口中的图形或在三个不同的窗口中查看三个不同的图形是完全可接受的。
- en: Keep in mind that your control over the view extends beyond just these examples.
    Additional IDA graphing capabilities are covered in [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing"), while more information on the manipulation of IDA’s graph view
    is available in the IDA help file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您对视图的控制不仅限于这些示例。额外的IDA图形功能在[第9章](ch09.html "第9章。交叉引用和图形")中有介绍，而关于操作IDA图形视图的更多信息可以在IDA帮助文件中找到。
- en: IDA Text View
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDA文本视图
- en: The text-oriented disassembly window is the traditional display used for viewing
    and manipulating IDA-generated disassemblies. The text display presents the entire
    disassembly listing of a program (as opposed to a single function at a time in
    graph mode) and provides the only means for viewing the data regions of a binary.
    All of the information available in the graph display is available in the text
    display in one form or another.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以文本为主的反汇编窗口是用于查看和操作IDA生成的反汇编的传统显示方式。文本显示呈现程序的整个反汇编列表（与图形模式中一次显示一个函数相反）并提供查看二进制数据区域的唯一方式。图形显示中可用的所有信息都以某种形式在文本显示中可用。
- en: '[Figure 5-4](ch05.html#the_ida_text_view "Figure 5-4. The IDA text view") shows
    the text view listing of the same function shown in [Figure 5-1](ch05.html#ida_graph_view-id1
    "Figure 5-1. IDA graph view") and [Figure 5-3](ch05.html#graph_view_with_line_prefixes_enabled
    "Figure 5-3. Graph view with line prefixes enabled"). The disassembly is presented
    in linear fashion, with virtual addresses displayed by default. Virtual addresses
    are typically displayed in a `[SECTION NAME]:[VIRTUAL ADDRESS]` format such as
    `.text:004011C1`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-4](ch05.html#the_ida_text_view "图5-4。IDA文本视图")显示了与[图5-1](ch05.html#ida_graph_view-id1
    "图5-1。IDA图形视图")和[图5-3](ch05.html#graph_view_with_line_prefixes_enabled "图5-3。启用行前缀的图形视图")中显示的相同函数的文本视图列表。反汇编以线性方式呈现，默认情况下显示虚拟地址。虚拟地址通常以`[节名称]:[虚拟地址]`格式显示，例如`.text:004011C1`。'
- en: '![The IDA text view](httpatomoreillycomsourcenostarchimages854111.png.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![IDA文本视图](httpatomoreillycomsourcenostarchimages854111.png.jpg)'
- en: Figure 5-4. The IDA text view
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4。IDA文本视图
- en: The left portion of the display, seen at ![](httpatomoreillycomsourcenostarchimages854061.png),
    is called the *arrows window* and is used to depict nonlinear flow within a function.
    Solid arrows represent unconditional jumps, while dashed arrows represent conditional
    jumps. When a jump (conditional or unconditional) transfers control to an earlier
    address in the program, a heavy weighted line (solid or dashed) is used. Such
    reverse flow in a program often indicates the presence of a loop. In [Figure 5-4](ch05.html#the_ida_text_view
    "Figure 5-4. The IDA text view"), a loop arrow flows from address `004011CF` to
    `004011C5`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的左侧部分，如图 ![](httpatomoreillycomsourcenostarchimages854061.png) 所示，被称为 *箭头窗口*，用于表示函数中的非线性流程。实线箭头表示无条件跳转，而虚线箭头表示条件跳转。当跳转（条件或无条件）将控制权转移到程序中的较早地址时，使用粗重的线条（实线或虚线）。这种程序中的反向流程通常表明存在循环。在
    [图 5-4](ch05.html#the_ida_text_view "图 5-4. IDA 文本视图") 中，循环箭头从地址 `004011CF` 流向
    `004011C5`。
- en: The declarations at ![](httpatomoreillycomsourcenostarchimages854063.png) (also
    present in graph view) represent IDA’s best estimate concerning the layout of
    the function’s stack frame.^([[36](#ftn.CHP-5-FN-3)]) IDA computes the structure
    of a function’s stack frame by performing detailed analysis of the behavior of
    the stack pointer and any stack frame pointer used within a function. Stack displays
    are discussed further in [Chapter 6](ch06.html "Chapter 6. Disassembly Navigation").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages854063.png) 中的声明（也存在于图形视图中）代表 IDA
    对函数堆栈帧布局的最佳估计。[36](#ftn.CHP-5-FN-3)] IDA 通过对堆栈指针和函数内使用的任何堆栈帧指针的行为进行详细分析来计算函数堆栈帧的结构。堆栈显示在
    [第 6 章](ch06.html "第 6 章. 汇编导航") 中进一步讨论。
- en: The comments (a semicolon introduces a comment) at ![](httpatomoreillycomsourcenostarchimages854093.png)
    are *cross-references*. In this case we see code cross-references (as opposed
    to data cross-references), which indicate that another program instruction transfers
    control to the location containing the cross-reference comment. Cross-references
    are the subject of [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing").
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages854093.png) 中的注释（分号引入注释）是 *交叉引用*。在这种情况下，我们看到代码交叉引用（与数据交叉引用相对），这表明另一个程序指令将控制权转移到包含交叉引用注释的位置。交叉引用是
    [第 9 章](ch09.html "第 9 章. 交叉引用和绘图") 的主题。
- en: For the remainder of the book we will primarily utilize the text display for
    examples. We’ll use the graph display only in cases where it may provide significantly
    more clarity. In [Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation")
    we will cover the specifics of manipulating the text display in order to clean
    up and annotate a disassembly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将主要使用文本显示来举例。只有在它可能提供显著更多清晰度的情况下，我们才会使用图形显示。在 [第 7 章](ch07.html "第
    7 章. 汇编操作") 中，我们将介绍如何操作文本显示以清理和注释汇编的细节。
- en: The Functions Window
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数窗口
- en: 'The Functions window is used to list every function that IDA has recognized
    in the database. A Functions window entry might look like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 函数窗口用于列出 IDA 在数据库中识别的每个函数。函数窗口条目可能看起来如下：
- en: '[PRE1]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This particular line indicates that the `malloc` function can be found in the
    `.text` section of the binary at virtual address `00BDC260`, is 384 bytes (hex
    180) long, returns to the caller (`R`), and uses the EBP register (`B`) to reference
    its local variables. Flags used to describe a function (such as `R` and `B` above)
    are described in IDA’s built-in help file (or by right-clicking a function and
    choosing Properties. The flags are shown as editable checkboxes in the resulting
    Properties dialog).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行特别指示，`malloc` 函数可以在虚拟地址 `00BDC260` 的二进制文件的 `.text` 部分找到，长度为 384 字节（十六进制 180），返回给调用者（`R`），并使用
    EBP 寄存器（`B`）来引用其局部变量。用于描述函数的标志（如上例中的 `R` 和 `B`）在 IDA 的内置帮助文件中描述（或通过右键单击一个函数并选择属性。标志在结果属性对话框中显示为可编辑的复选框）。
- en: As with other display windows, double-clicking an entry in the Functions window
    causes the disassembly window to jump to the location of the selected function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他显示窗口一样，双击函数窗口中的条目会导致汇编窗口跳转到所选函数的位置。
- en: The Output Window
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出窗口
- en: The Output window at the bottom of the IDA workspace rounds out the default
    set of windows that are visible when a new file is opened. The Ouput window serves
    as IDA’s output console and is the place to look for information on tasks IDA
    is performing. When a binary is first opened, for example, messages are generated
    to indicate both what phase of analysis IDA is in at any given time and what actions
    IDA is carrying out to create the new database. As you work with a database, the
    Output window is used to output the status of various operations that you perform.
    The contents of the Output window can be copied to the system clipboard or cleared
    entirely by right-clicking anywhere in the window and selecting the appropriate
    operation. The Output window will often be the primary means by which you display
    output from any scripts and plug-ins that you develop for IDA.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: IDA工作区底部的输出窗口补充了在新文件打开时可见的默认窗口集。输出窗口作为IDA的输出控制台，是查找IDA正在执行的任务信息的地方。例如，当首次打开二进制文件时，会生成消息来指示IDA在任何给定时间处于分析哪个阶段以及IDA正在执行哪些操作以创建新数据库。随着你与数据库一起工作，输出窗口用于输出你执行的各种操作的状态。可以通过在窗口的任何位置右键单击并选择适当的操作来复制输出窗口的内容或将内容全部清除。输出窗口通常是显示你为IDA开发的任何脚本和插件输出的主要方式。
- en: '* * *'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[34](#CHP-5-FN-1)]) A *basic block* is a maximal sequence of instructions
    that executes, without branching, from beginning to end. Each basic block therefore
    has a single entry point (the first instruction in the block) and a single exit
    point (the last instruction in the block). The first instruction in a basic block
    is often the target of a branching instruction, while the last instruction in
    a basic block is often a branch instruction.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#CHP-5-FN-1)]) 基本块是执行，没有分支，从开始到结束的最大指令序列。因此，每个基本块都有一个单一的入口点（块中的第一条指令）和一个单一的出口点（块中的最后一条指令）。基本块中的第一条指令通常是分支指令的目标，而基本块中的最后一条指令通常是分支指令。
- en: ^([[35](#CHP-5-FN-2)]) IDA uses the term *flow* to indicate how execution can
    continue from a given instruction. A *normal* (also called *ordinary*) flow indicates
    default sequential execution of instructions. A *jump* flow indicates that the
    current instruction jumps (or may jump) to a nonsequential location. A *call*
    flow indicates that the current instruction calls a subroutine.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#CHP-5-FN-2)]) IDA使用术语*流*来表示从给定指令继续执行的方式。*正常*（也称为*普通*）流表示指令的默认顺序执行。*跳转*流表示当前指令跳转（或可能跳转）到非顺序位置。*调用*流表示当前指令调用子程序。
- en: ^([[36](#CHP-5-FN-3)]) A *stack frame* (or *activation record*) is a block of
    memory, allocated in a program’s runtime stack, that contains both the parameters
    passed into a function and the local variables declared within the function. Stack
    frames are allocated upon entry into a function and released as the function exits.
    Stack frames are discussed in more detail in [Chapter 6](ch06.html "Chapter 6. Disassembly
    Navigation").
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#CHP-5-FN-3)]) 栈帧（或激活记录）是在程序运行时栈中分配的一块内存，其中包含传递给函数的参数和在函数内声明的局部变量。栈帧在函数进入时分配，在函数退出时释放。栈帧在[第6章](ch06.html
    "第6章. 拆解导航")中有更详细的讨论。
- en: Secondary IDA Displays
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二级IDA显示
- en: In addition to the disassembly, Functions, and Output windows, IDA opens a number
    of other tabbed windows on your IDA desktop. These tabs are present just under
    the navigation band (see ![](httpatomoreillycomsourcenostarchimages854093.png)
    in [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The IDA desktop")).
    These windows are used to provide alternate or specialized views into the database.
    The utility of these displays depends on both the characteristics of the binary
    you are analyzing and your skill with IDA. Several of these windows are sufficiently
    specialized to require more detailed coverage in later chapters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拆解、函数和输出窗口之外，IDA在你的IDA桌面打开了许多其他标签页窗口。这些标签页位于导航栏下方（参见![图4-9](httpatomoreillycomsourcenostarchimages854093.png)在[图4-9](ch04s03.html#the_ida_desktop
    "图4-9. IDA桌面"))）。这些窗口用于提供对数据库的替代或专用视图。这些显示的效用取决于你正在分析的二进制文件的特征以及你在IDA中的技能。其中一些窗口足够专业化，需要在后面的章节中提供更详细的介绍。
- en: The Hex View Window
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十六进制视图窗口
- en: Hex View is something of a misnomer in this case, as the IDA Hex View window
    can be configured to display a variety of formats and doubles as a hex editor.
    By default, the Hex View window provides a standard hex dump of the program content
    with 16 bytes per line and ASCII equivalents displayed alongside. As with the
    disassembly window, several hex views can be opened simultaneously. The first
    Hex window is titled *Hex View-A*, the second *Hex View-B*, the next *Hex View-C*,
    and so on. By default, the first Hex window is synchronized with the first disassembly
    window. When a disassembly view is synchronized with a hex view, scrolling in
    one window causes the other window to scroll to the same location (same virtual
    address). In addition, when an item is selected in disassembly view, the corresponding
    bytes are highlighted in hex view. In [Figure 5-5](ch05s02.html#synchronized_hex_and_disassembly_views
    "Figure 5-5. Synchronized hex and disassembly views"), the disassembly view cursor
    is positioned at address `0040108C`, a call instruction, causing the five bytes
    that make up the instruction to be highlighted in the Hex window.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，十六进制视图的名称有些误导，因为IDA的十六进制视图窗口可以配置为显示各种格式，并且充当十六进制编辑器。默认情况下，十六进制视图窗口提供标准十六进制转储程序内容，每行16字节，并显示ASCII等效值。与反汇编窗口一样，可以同时打开多个十六进制视图。第一个十六进制窗口标题为*十六进制视图-A*，第二个*十六进制视图-B*，下一个*十六进制视图-C*，依此类推。默认情况下，第一个十六进制窗口与第一个反汇编窗口同步。当反汇编视图与十六进制视图同步时，在一个窗口中滚动会导致另一个窗口滚动到相同的位置（相同的虚拟地址）。此外，当在反汇编视图中选择一个项目时，相应的字节在十六进制视图中会被突出显示。在[图5-5](ch05s02.html#synchronized_hex_and_disassembly_views
    "图5-5. 同步十六进制和反汇编视图")中，反汇编视图的光标位于地址`0040108C`，这是一个调用指令，导致构成指令的五个字节在十六进制窗口中被突出显示。
- en: '![Synchronized hex and disassembly views](httpatomoreillycomsourcenostarchimages854113.png.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![同步十六进制和反汇编视图](httpatomoreillycomsourcenostarchimages854113.png.jpg)'
- en: Figure 5-5. Synchronized hex and disassembly views
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5. 同步十六进制和反汇编视图
- en: Also shown in [Figure 5-5](ch05s02.html#synchronized_hex_and_disassembly_views
    "Figure 5-5. Synchronized hex and disassembly views") is the hex display context
    menu, available when you right-click anywhere within the hex display. This context
    menu is where you may specify with which, if any, disassembly view you would like
    to synchronize a particular hex display. Deselecting the synchronization option
    allows a Hex window to be scrolled independently of any disassembly window. Selecting
    the Edit menu option turns the Hex View into a hex editor. Once you are finished
    editing, you must either commit or cancel your changes in order to return to view
    mode. The Data Format menu item allows you to select from a variety of display
    formats such as 1-, 2-, 4-, or 8-byte hexadecimal; signed decimal; or unsigned
    decimal integers and various floating point formats. The Columns menu option allows
    you to change the number of columns used in the display, and the Text option allows
    you to turn the text dump on and off.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5-5](ch05s02.html#synchronized_hex_and_disassembly_views "图5-5. 同步十六进制和反汇编视图")中同样显示的是十六进制显示上下文菜单，当你在十六进制显示的任何位置右键单击时都会出现此菜单。这个上下文菜单是您指定要使用哪个（如果有的话）反汇编视图与特定的十六进制显示同步的地方。取消选择同步选项允许十六进制窗口独立于任何反汇编窗口进行滚动。选择编辑菜单选项将十六进制视图转换为十六进制编辑器。一旦完成编辑，您必须提交或取消更改才能返回到查看模式。数据格式菜单项允许您从各种显示格式中选择，例如1、2、4或8字节十六进制；有符号十进制；或无符号十进制整数以及各种浮点格式。列菜单选项允许您更改显示中使用的列数，而文本选项允许您打开或关闭文本转储。
- en: In some cases you may find that the Hex window shows nothing but question marks.
    This is IDA’s way of telling you that it has no idea what values might occupy
    a given virtual address range. Such is the case when a program contains a bss^([[37](#ftn.CHP-5-FN-4)])
    section, which typically occupies no space within a file but is expanded by the
    loader to accommodate the program’s static storage requirements.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能会发现十六进制窗口只显示问号。这是IDA告诉你它不知道哪些值可能占据给定的虚拟地址范围的方式。当程序包含一个bss^([[37](#ftn.CHP-5-FN-4)])部分时，这种情况就会发生，这部分通常在文件中不占用空间，但由加载程序扩展以适应程序的静态存储需求。
- en: The Exports Window
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出窗口
- en: 'The Exports window lists the entry points into a file. These include the program’s
    execution entry point, as specified in its header section, along with any functions
    and variables that the file exports for use by other files. Exported functions
    are commonly found in shared libraries such as Windows DLL files. Exported entries
    are listed by name, virtual address, and, if applicable, by ordinal number.^([[38](#ftn.CHP-5-FN-5)])
    For executable files, the Exports window always contains at least one entry: the
    program’s execution entry point. IDA names this entry point `start`. A typical
    Exports window entry follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 导出窗口列出了文件中的入口点。这包括程序在头文件中指定的执行入口点，以及任何为其他文件使用而导出的函数和变量。导出函数通常可以在共享库中找到，例如Windows
    DLL文件。导出条目按名称、虚拟地址列出，如果适用，还可以按序号列出。^([[38](#ftn.CHP-5-FN-5)]) 对于可执行文件，导出窗口始终至少包含一个条目：程序的执行入口点。IDA将此入口点命名为`start`。典型的导出窗口条目如下：
- en: '[PRE2]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As with many of the other IDA windows, double-clicking an entry in the Exports
    window will jump the disassembly window to the address associated with that entry.
    The Exports window offers functionality available in command-line tools such as
    `objdump` (`-T`), `readelf (-s`), and `dumpbin` (`/EXPORTS`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他IDA窗口一样，双击导出窗口中的条目将使反汇编窗口跳转到与该条目关联的地址。导出窗口还提供了类似于命令行工具`objdump` (`-T`)、`readelf
    (-s`)和`dumpbin` (`/EXPORTS`)的功能。
- en: The Imports Window
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入窗口
- en: 'The Imports window is a counterpart to the Exports window. It lists all functions
    that are imported by the binary being analyzed. The Imports window is relevant
    only when a binary makes use of shared libraries. Statically linked binaries have
    no external dependencies and therefore no imports. Each entry in the Imports window
    lists the name of an imported item (function or data) and the name of the library
    that contains that item. Since the code for an imported function resides in a
    shared library, the addresses listed with each entry refer to the virtual address
    of the associated import table entry.^([[39](#ftn.CHP-5-FN-6)]) An example of
    an Import window entry is shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 导入窗口是导出窗口的对应窗口。它列出了正在分析的二进制文件所导入的所有函数。导入窗口仅在二进制文件使用共享库时才相关。静态链接的二进制文件没有外部依赖，因此没有导入。导入窗口中的每一项都列出了导入项（函数或数据）的名称以及包含该项的库的名称。由于导入函数的代码位于共享库中，因此每一项中列出的地址是指相关导入表条目的虚拟地址。^([[39](#ftn.CHP-5-FN-6)])
    下面展示了导入窗口条目的一个示例：
- en: '[PRE3]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Double-clicking this import would jump the disassembly window to address `0040E108`.
    The contents of this memory location in hex view would be `?? ?? ?? ??`. IDA is
    a static analysis tool, and it has no way to know what address will be entered
    into this memory location when the program is executed. The Imports window also
    offers functionality available in command-line tools such as `objdump` (`-T`),
    `readelf` (`-s`), and `dumpbin` (`/IMPORTS`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 双击此导入将使反汇编窗口跳转到地址`0040E108`。在十六进制视图中，此内存位置的 内容将是`?? ?? ?? ??`。IDA是一个静态分析工具，它无法知道程序执行时将进入此内存位置的地址。导入窗口还提供了类似于命令行工具`objdump`
    (`-T`)、`readelf` (`-s`)和`dumpbin` (`/IMPORTS`)的功能。
- en: An important point to remember about the Imports window is that it displays
    only the symbols that a binary wants handled automatically by the dynamic loader.
    Symbols that a binary chooses to load on its own using a mechanism such as `dlopen/dlsym`
    or `LoadLibrary/GetProcAddress` will not be listed in the Imports window.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导入窗口的一个重要要点是，它仅显示二进制文件希望由动态加载器自动处理的符号。那些二进制文件选择使用`dlopen/dlsym`或`LoadLibrary/GetProcAddress`等机制自行加载的符号将不会在导入窗口中列出。
- en: The Structures Window
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构窗口
- en: The Structures window is used to display the layout of any complex data structures,
    such as C structs or unions, that IDA determines are in use within a binary. During
    the analysis phase, IDA consults its extensive library of function-type signatures
    in an attempt to match function parameter types to memory used within the program.
    The Structures window shown in [Figure 5-6](ch05s02.html#the_structures_window-id1
    "Figure 5-6. The Structures window") indicates that IDA believes the program uses
    the `sockaddr`^([[40](#ftn.CHP-5-FN-7)]) data structure.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 结构窗口用于显示IDA确定的二进制文件中使用的任何复杂数据结构的布局，例如C结构体或联合体。在分析阶段，IDA会咨询其庞大的函数类型签名库，试图将函数参数类型与程序中使用的内存进行匹配。如图[图5-6](ch05s02.html#the_structures_window-id1
    "图5-6. 结构窗口")所示的结构窗口表明，IDA认为程序使用了`sockaddr`^([[40](#ftn.CHP-5-FN-7)])数据结构。
- en: '![The Structures window](httpatomoreillycomsourcenostarchimages854115.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![结构窗口](httpatomoreillycomsourcenostarchimages854115.png)'
- en: Figure 5-6. The Structures window
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-6. 结构窗口
- en: There are many possible reasons why IDA may have arrived at this conclusion.
    One such reason might be that IDA has observed a call to the C library `connect`^([[41](#ftn.CHP-5-FN-8)])
    function to establish a new network connection. Double-clicking the name of a
    data structure (`sockaddr` in this case) causes IDA to expand the structure, and
    this allows you to see the detailed layout of the structure, including individual
    field names and sizes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: IDA得出这一结论可能有多种可能的原因。其中一个可能的原因是，IDA观察到对C库`connect`^([[41](#ftn.CHP-5-FN-8)])函数的调用以建立新的网络连接。双击数据结构（在本例中为`sockaddr`）的名称会导致IDA展开该结构，从而允许您查看结构的详细布局，包括各个字段名称和大小。
- en: The two primary uses for the Structures window are (1) to provide a ready reference
    for the layout of standard data structures and (2) to provide you with a means
    to create your own data structures for use as memory layout templates when you
    discover custom data structures within a program. Structure definition and the
    application of structures within disassemblies are covered in more detail in [Chapter 8](ch08.html
    "Chapter 8. Datatypes and Data Structures").
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 结构窗口的两个主要用途是（1）提供标准数据结构布局的便捷参考，以及（2）在您在程序中发现自定义数据结构时，提供创建自己的数据结构的方法，以便将其用作内存布局模板。结构定义和在反汇编中的应用将在第8章（[第8章.
    数据类型和数据结构](ch08.html "第8章. 数据类型和数据结构"））中更详细地介绍。
- en: The Enums Window
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举窗口
- en: The Enums window is somewhat similar to the Structures window. When IDA detects
    the use of a standard enumerated datatype (C `enum`), that datatype will be listed
    in the Enums window. You can make your disassemblies far more readable by using
    enums in place of integer constants. Like the Structures window, the Enums window
    offers facilities for defining your own enumerated types that you can use with
    your disassembled binaries.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举窗口在某种程度上类似于结构窗口。当IDA检测到使用标准枚举数据类型（C `enum`）时，该数据类型将列在枚举窗口中。您可以通过使用枚举而不是整数常量来使您的反汇编代码更加易读。与结构窗口类似，枚举窗口提供了定义您自己的枚举类型的功能，您可以使用这些类型与您的反汇编二进制文件一起使用。
- en: '* * *'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[37](#CHP-5-FN-4)]) A *bss* section is created by a compiler to house all
    of a program’s uninitialized, static variables. Since no initial value is assigned
    to these variables, there is no need to allocate space for them in the program’s
    file image, so the section’s size is noted in one of the program’s headers. When
    the program is executed, the loader allocates the required space and initializes
    the entire block to zero.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[37](#CHP-5-FN-4))) 编译器创建*bss*部分来存放程序的所有未初始化的静态变量。由于这些变量没有分配初始值，因此不需要在程序的文件映像中为它们分配空间，因此该部分的尺寸在程序的一个头文件中记录。当程序执行时，加载器分配所需的空间并将整个块初始化为零。
- en: ^([[38](#CHP-5-FN-5)]) An export ordinal number may be used in a shared library
    to make a function accessible by number rather than name. The use of ordinals
    can speed the address lookup process and allow programmers to hide the names of
    their functions. Export ordinals are used in Windows DLLs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[38](#CHP-5-FN-5))) 在共享库中可以使用导出序号来通过数字而不是名称使函数可访问。使用序号可以加快地址查找过程，并允许程序员隐藏他们函数的名称。导出序号在Windows
    DLL中使用。
- en: ^([[39](#CHP-5-FN-6)]) An import table provides space for a loader to store
    addresses of imported functions once the required libraries have been loaded and
    the addresses of those functions are known. A single import table entry holds
    the address of one imported function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[39](#CHP-5-FN-6)]) 导入表为加载器提供了空间，以便在加载所需的库并且知道这些函数的地址后存储导入函数的地址。单个导入表条目包含一个导入函数的地址。
- en: ^([[40](#CHP-5-FN-7)]) A `sockaddr` structure is a datatype in the C standard
    library often used to represent an endpoint in a network connection. A `sockaddr`
    variable can be used to hold an IP address and port number as part of the process
    of establishing a TCP connection to a remote computer.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[40](#CHP-5-FN-7)]) `sockaddr`结构是C标准库中的一个数据类型，通常用于表示网络连接中的一个端点。`sockaddr`变量可以用来存储IP地址和端口号，作为建立与远程计算机的TCP连接的过程的一部分。
- en: ^([[41](#CHP-5-FN-8)]) `int connect(int sockfd, const struct sockaddr *serv_addr,
    socklen_t addrlen);`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[41](#CHP-5-FN-8)]) `int connect(int sockfd, const struct sockaddr *serv_addr,
    socklen_t addrlen);`
- en: Tertiary IDA Displays
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三级IDA显示
- en: The last windows that we will discuss are those that IDA does not open by default.
    Each of these windows is available via View ▸ Open Subviews, but they tend to
    provide information to which you may not require immediate access and are thus
    initially kept out of the way.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个窗口是 IDA 默认不打开的窗口。每个这些窗口都可以通过视图 ▸ 打开子视图访问，但它们通常提供的信息可能不是你立即需要的，因此最初被放在一边。
- en: The Strings Window
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串窗口
- en: The Strings window is the built-in IDA equivalent of the `strings` utility and
    then some. In IDA versions 5.1 and earlier, the Strings window was open as part
    of the default desktop; however, with version 5.2, the Strings window is no longer
    open by default, though it remains available via View ▸ Open Subviews ▸ Strings.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串窗口是 IDA 内置的 `strings` 工具的等价物，并且还包含更多功能。在 IDA 5.1 及更早版本中，字符串窗口作为默认桌面的一部分打开；然而，从版本
    5.2 开始，字符串窗口不再默认打开，尽管它仍然可以通过视图 ▸ 打开子视图 ▸ 字符串来访问。
- en: The purpose of the Strings window is to display a list of strings extracted
    from a binary along with the address at which each string resides. Like double-clicking
    names in the Names window, double-clicking any string listed in the Strings window
    causes the disassembly window to jump to the address of the selected string. When
    used with cross-references ([Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing")), the Strings window provides the means to rapidly spot an interesting
    string and to track back to any location in the program that references that string.
    For example, you might see the string *SOFTWARE\Microsoft\Windows\Current Version\Run*
    listed and wonder why an application is referencing this particular key within
    the Windows registry. As you will see in the following chapter, navigating to
    the program location that references this string takes only four clicks. Understanding
    the operation of the Strings window is essential to using it effectively. IDA
    does not permanently store the strings it extracts from a binary. Therefore, every
    time the Strings window is opened, the entire database must be scanned or rescanned
    for string content. String scanning is performed in accordance with the settings
    of the Strings window, and you can access these settings by right-clicking within
    the Strings window and selecting Setup. As shown in [Figure 5-7](ch05s03.html#the_setup_strings_window
    "Figure 5-7. The Setup Strings window"), the Setup Strings window is used to specify
    the types of strings that IDA should scan for. The default string type that IDA
    scans for is a C-style, null-terminated, 7-bit, ASCII string of at least five
    characters in length.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串窗口的目的是显示从二进制文件中提取的字符串列表以及每个字符串所在的地址。就像在名称窗口中双击名称一样，在字符串窗口中双击任何列出的字符串会导致反汇编窗口跳转到所选字符串的地址。当与交叉引用（[第
    9 章](ch09.html "第 9 章。交叉引用和绘图"））一起使用时，字符串窗口提供了快速定位有趣字符串并追踪到程序中引用该字符串的任何位置的手段。例如，你可能会看到列出的字符串
    *SOFTWARE\Microsoft\Windows\Current Version\Run* 并想知道为什么一个应用程序会引用 Windows 注册表中的这个特定键。正如你将在下一章中看到的那样，导航到引用此字符串的程序位置只需要四步点击。理解字符串窗口的操作对于有效地使用它至关重要。IDA
    不会永久存储从二进制文件中提取的字符串。因此，每次打开字符串窗口时，整个数据库都必须扫描或重新扫描以获取字符串内容。字符串扫描按照字符串窗口的设置进行，你可以通过在字符串窗口内右键单击并选择设置来访问这些设置。如图
    [图 5-7](ch05s03.html#the_setup_strings_window "图 5-7。设置字符串窗口") 所示，设置字符串窗口用于指定
    IDA 应扫描的字符串类型。IDA 默认扫描的字符串类型是至少五个字符长度的 C 风格、空终止、7 位 ASCII 字符串。每次你通过点击确定关闭设置字符串窗口时，IDA
    将根据新设置重新扫描数据库中的字符串。有两个设置选项值得特别提及：
- en: '![The Setup Strings window](httpatomoreillycomsourcenostarchimages854117.png.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![设置字符串窗口](httpatomoreillycomsourcenostarchimages854117.png.jpg)'
- en: Figure 5-7. The Setup Strings window
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7。设置字符串窗口
- en: 'If you expect to encounter anything other than C-style strings, you should
    reconfigure the Setup Strings window to choose the appropriate string type to
    search for. For example, Windows programs often make use of Unicode strings, while
    Borland Delphi binaries use Pascal-style strings with a 2-byte length. Every time
    you close the Setup Strings window by clicking OK, IDA will rescan the database
    for strings in accordance with the new settings. Two setup options deserve special
    mention:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预计会遇到除 C 风格字符串之外的内容，你应该重新配置设置字符串窗口以选择适当的字符串类型进行搜索。例如，Windows 程序通常使用 Unicode
    字符串，而 Borland Delphi 二进制文件使用具有 2 字节长度的 Pascal 风格字符串。每次你通过点击确定关闭设置字符串窗口时，IDA 将根据新设置重新扫描数据库中的字符串。有两个设置选项值得特别提及：
- en: '**Display only defined strings**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅显示已定义的字符串**'
- en: This option restricts the Strings window to displaying only named string data
    items that have been automatically created by IDA or manually created by the user.
    With this option selected, all other options are disabled, and IDA will not automatically
    scan for additional string content.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项限制字符串窗口仅显示由IDA自动创建或由用户手动创建的命名字符串数据项。选择此选项后，所有其他选项都将被禁用，并且IDA不会自动扫描额外的字符串内容。
- en: '**Ignore instructions/data definitions**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**忽略指令/数据定义**'
- en: This option causes IDA to scan for strings across instruction and existing data
    definitions. Using this option allows IDA to (1) see strings that may be embedded
    in the code portion of a binary and have been mistakenly converted into instructions
    or (2) to see strings within data that may be formatted as something other than
    a string (such as an array of bytes or integers). This option will also lead to
    the generation of many *junk* strings, which are sequences that happen to consist
    of five or more ASCII characters whether or not they are legible. The effect of
    using this option is similar to using the `strings` command with the `-a` switch.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项导致IDA在指令和现有数据定义中扫描字符串。使用此选项允许IDA（1）查看可能嵌入在二进制代码部分且被错误地转换为指令的字符串，或者（2）查看可能格式化为除字符串之外的内容（如字节数组或整数）的数据中的字符串。此选项还会生成许多*垃圾*字符串，这些字符串恰好由五个或更多ASCII字符组成，无论它们是否可读。使用此选项的效果类似于使用带有`-a`开关的`strings`命令。
- en: '[Figure 5-8](ch05s03.html#example_of_undetected_string_data "Figure 5-8. Example
    of undetected string data") demonstrates that IDA does not necessarily show all
    strings within a binary if the strings setup is not configured properly. In this
    case, Ignore instructions/data definitions has not been selected.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-8](ch05s03.html#example_of_undetected_string_data "图5-8. 未检测到的字符串数据示例")演示了如果字符串设置配置不当，IDA不一定显示二进制中的所有字符串。在这种情况下，未选择忽略指令/数据定义。'
- en: '![Example of undetected string data](httpatomoreillycomsourcenostarchimages854119.png.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![未检测到的字符串数据示例](httpatomoreillycomsourcenostarchimages854119.png.jpg)'
- en: Figure 5-8. Example of undetected string data
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-8. 未检测到的字符串数据示例
- en: The result is that the string at location `.rdata:0040C19C` (“Please guess a
    number between 1 and %d.”) remains undetected. The moral here is to make sure
    that you are looking for all of the types of strings you expect to encounter in
    all of the places you might find them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，位于`.rdata:0040C19C`位置的字符串（“请猜一个介于1和%d之间的数字。”）未被检测到。这里的教训是要确保你在所有可能找到它们的地方寻找你期望遇到的所有类型的字符串。
- en: The Names Window
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称窗口
- en: The Names window, shown in [Figure 5-9](ch05s03.html#the_names_window-id1 "Figure 5-9. The
    Names window"), provides a summary listing of all of the global names within a
    binary. A *name* is nothing more than a symbolic description given to a program
    virtual address. IDA initially derives the list of names from symbol-table and
    signature analysis during the initial loading of a file. Names can be sorted alphabetically
    or in virtual address order (either ascending or descending). The Names window
    is useful for rapidly navigating to known locations within a program listing.
    Double-clicking any Names window entry will immediately jump the disassembly view
    to display the selected name.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 名称窗口，如图[图5-9](ch05s03.html#the_names_window-id1 "图5-9. 名称窗口")所示，提供了二进制中所有全局名称的总结列表。*名称*不过是对程序虚拟地址给出的符号描述。IDA最初在文件初始加载期间从符号表和签名分析中推导出名称列表。名称可以按字母顺序或虚拟地址顺序（升序或降序）排序。名称窗口对于快速导航到程序列表中的已知位置非常有用。双击名称窗口中的任何条目将立即跳转到反汇编视图以显示所选名称。
- en: '![The Names window](httpatomoreillycomsourcenostarchimages854121.png.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![名称窗口](httpatomoreillycomsourcenostarchimages854121.png.jpg)'
- en: Figure 5-9. The Names window
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-9. 名称窗口
- en: 'Displayed names are both color and letter coded. The coding scheme is summarized
    below:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的名称既有颜色编码也有字母编码。编码方案总结如下：
- en: '| **F** | A regular function. These are functions that IDA does not recognize
    as library functions. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **F** | 一个普通函数。这些是IDA不识别为库函数的函数。|'
- en: '| **L** | A library function. IDA recognizes library functions through the
    use of signature-matching algorithms. If a signature does not exist for a given
    library function, the function will be labeled as a regular function instead.
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **L** | 这是一个库函数。IDA通过使用签名匹配算法来识别库函数。如果某个库函数没有签名，该函数将被标记为普通函数。|'
- en: '| **I** | An imported name, most commonly a function name imported from a shared
    library. The difference between this and a library function is that no code is
    present for an imported name, while the body of a library function will be present
    in the disassembly. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **I** | 导入的名称，最常见的是从共享库中导入的函数名称。与库函数的区别在于，导入的名称没有代码，而库函数的主体将在反汇编中存在。'
- en: '| **C** | Named code. These are named program instruction locations that IDA
    does not consider to be part of any function. This is possible when IDA finds
    a name in a program’s symbol table but never sees a `call` to the corresponding
    program location. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **C** | 命名的代码。这些是IDA认为不属于任何函数的程序指令位置。当IDA在程序的符号表中找到一个名称，但从未看到对应程序位置的`call`时，这是可能的。'
- en: '| **D** | Data. Named data locations typically represent global variables.
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **D** | 数据。命名的数据位置通常代表全局变量。'
- en: '| **A** | String data. This is a referenced data location containing a sequence
    of characters that conform to one of IDA’s known string data types, such as a
    null-terminated ASCII C string. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **A** | 字符串数据。这是一个包含符合IDA已知字符串数据类型之一（如以空字符终止的ASCII C字符串）的字符序列的数据位置。'
- en: 'As you browse through disassemblies, you will notice that there are many named
    locations for which no name is listed in the Names window. In the process of disassembling
    a program, IDA generates names for all locations that are referenced directly
    either as code (a branch or call target) or as data (read, written, or address
    taken). If a location is named in the program’s symbol table, IDA adopts the name
    from the symbol table. If no symbol table entry is available for a given program
    location, IDA generates a default name for use in the disassembly. When IDA chooses
    to name a location, the virtual address of the location is combined with a prefix
    that indicates what type of location is being named. Incorporating the virtual
    address into a generated name ensures that all generated names will be unique,
    as no two locations can share the same virtual address. Autogenerated names of
    this type are not displayed in the Names window. Some of the more common prefixes
    used for autogenerated names include these:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览反汇编代码时，你会注意到有许多在“名称”窗口中没有列出名称的命名位置。在反汇编程序的过程中，IDA为所有直接引用的位置生成名称，无论是作为代码（分支或调用目标）还是作为数据（读取、写入或取地址）。如果一个位置在程序的符号表中命名，IDA将采用符号表中的名称。如果没有给定程序位置的符号表条目，IDA将为反汇编生成一个默认名称。当IDA选择命名一个位置时，该位置的虚拟地址将与一个表示正在命名的位置类型的前缀结合。将虚拟地址纳入生成的名称确保所有生成的名称都是唯一的，因为两个位置不能共享相同的虚拟地址。此类自动生成的名称不会在“名称”窗口中显示。用于自动生成名称的一些更常见的前缀包括以下这些：
- en: '| **`sub_`****``*`xxxxxx`*``** | A subroutine at address *`xxxxxx`* |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **`sub_`****``*`xxxxxx`*``** | 地址 *`xxxxxx`* 的子程序'
- en: '| **`loc_`****``*`xxxxxx`*``** | An instruction location at address *`xxxxxx`*
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| **`loc_`****``*`xxxxxx`*``** | 地址 *`xxxxxx`* 的指令位置'
- en: '| **`byte_`****``*`xxxxxx`*``** | 8-bit data at location *`xxxxxx`* |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **`byte_`****``*`xxxxxx`*``** | 位置 *`xxxxxx`* 的8位数据'
- en: '| **`word_`****``*`xxxxxx`*``** | 16-bit data at location *`xxxxxx`* |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **`word_`****``*`xxxxxx`*``** | 位置 *`xxxxxx`* 的16位数据'
- en: '| **`dword_`****``*`xxxxxx`*``** | 32-bit data at location *`xxxxxx`* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **`dword_`****``*`xxxxxx`*``** | 位置 *`xxxxxx`* 的32位数据'
- en: '| **`unk_`****``*`xxxxxx`*``** | Data of unknown size at location *`xxxxxx`*
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **`unk_`****``*`xxxxxx`*``** | 位置 *`xxxxxx`* 的未知大小数据'
- en: Throughout the course of the book we will show additional algorithms that IDA
    applies in choosing names for program data locations.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将展示IDA在为程序数据位置选择名称时应用的更多算法。
- en: The Segments Window
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 段窗口
- en: 'The Segments window displays a summary listing of the segments present in the
    binary file. Note that what IDA terms *segments* are most often called *sections*
    when discussing the structure of binary files. Do not confuse the use of the term
    *segments* in this manner with the memory segments associated with CPUs that implement
    a segmented memory architecture. Information presented in the window includes
    the segment name, start and end addresses, and permission flags. The start and
    end addresses represent the virtual address range to which the program sections
    will be mapped at runtime. The following listing is an example of Segments window
    content from a Windows binary:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Segments窗口显示了二进制文件中存在的段的总览列表。请注意，IDA所说的*段*在讨论二进制文件结构时通常被称为*节*。不要将这种使用*段*的方式与实现分段内存架构的CPU相关的内存段混淆。窗口中显示的信息包括段名、起始和结束地址以及权限标志。起始和结束地址表示程序节在运行时将被映射到的虚拟地址范围。以下列表是来自Windows二进制文件的Segments窗口内容的示例：
- en: '[PRE4]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we might quickly suspect that something is funny with this particular
    binary since it uses nonstandard segment names and has two executable segments
    that are writable, thus indicating the possibility of self-modifying code (more
    on this in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis")). The
    fact that IDA knows the size of a segment does not indicate that IDA knows the
    contents of the segment. For a variety of reasons, segments often occupy less
    space on disk than they do in memory. In such cases, IDA displays values for the
    portions of the segment that IDA has determined it could fill from the disk file.
    For the remainder of the segment, IDA displays question marks.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会很快怀疑这个特定的二进制文件有问题，因为它使用非标准的段名，并且有两个可写可执行的段，这表明可能存在自修改代码的可能性（关于这一点，请参阅[第21章](ch21.html
    "第21章。混淆代码分析")）。IDA知道段的大小并不表示IDA知道段的内容。由于各种原因，段在磁盘上通常比在内存中占用的空间要少。在这种情况下，IDA会显示IDA已确定可以从磁盘文件填充的部分的值。对于段的其他部分，IDA会显示问号。
- en: Double-clicking any entry in the window jumps the disassembly view to the start
    of the selected segment. Right-clicking an entry provides a context menu from
    which you can add new segments, delete existing segments, or edit the properties
    of existing segments. These features are particularly useful when reverse engineering
    files with nonstandard formats, as the binary’s segment structure may not have
    been detected by the IDA loader.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 双击窗口中的任何条目，将反汇编视图跳转到所选段的起始位置。右键单击条目提供了一个上下文菜单，您可以从该菜单添加新段、删除现有段或编辑现有段的属性。这些功能在逆向工程非标准格式的文件时特别有用，因为二进制文件的段结构可能没有被IDA加载器检测到。
- en: Command-line counterparts to the Segments window include `objdump` (`-h`), `readelf`
    (`-S`), and `dumpbin` (`/HEADERS`).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Segments窗口的命令行对应项包括`objdump`（`-h`）、`readelf`（`-S`）和`dumpbin`（`/HEADERS`）。
- en: The Signatures Window
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名窗口
- en: IDA makes use of an extensive library of signatures for identifying known blocks
    of code. Signatures are used to identify common compiler-generated startup sequences
    in an attempt to determine the compiler that may have been used to build a given
    binary. Signatures are also used to categorize functions as known library functions
    inserted by a compiler or as functions added to the binary as a result of static
    linking. When IDA identifies library functions for you, you can focus more of
    your effort on the code that IDA did not recognize (which is probably far more
    interesting to you than reverse engineering the inner workings of `printf`).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: IDA利用一个庞大的签名库来识别已知的代码块。签名用于识别常见的编译器生成的启动序列，以尝试确定可能用于构建给定二进制的编译器。签名还用于将函数分类为编译器插入的已知库函数，或作为静态链接结果添加到二进制中的函数。当IDA为您识别库函数时，您可以更多地专注于IDA未识别的代码（这可能比逆向工程`printf`的内部工作原理对您更有趣）。
- en: 'The Signatures window is used to list the signatures that IDA has already matched
    against the open binary file. An example from a Windows PE file is shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 签名窗口用于列出IDA已经与打开的二进制文件匹配的签名。以下是一个来自Windows PE文件的示例：
- en: '[PRE5]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example indicates that IDA has applied the `vc32rtf` signatures (from *<IDADIR>/sigs*)
    against the binary and, in doing so, has been able to recognize 501 functions
    as library functions. That’s 501 functions that you will not need to reverse engineer!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，IDA已经应用了`vc32rtf`签名（来自`<IDADIR>/sigs`），针对二进制文件进行处理，从而能够识别出501个库函数。这意味着你将不需要对这501个函数进行逆向工程！
- en: In at least two cases, you will want to know how to apply additional signatures
    against your binaries. In the first case, IDA may fail to recognize the compiler
    that was used to build a binary, with a resulting inability to select appropriate
    signatures to apply. In this case, you may wish to force IDA to apply one or more
    signatures that your preliminary analysis has led you to believe IDA should try.
    The second situation involves creating your own signatures for libraries that
    may not have existing signatures included with IDA. An example might be the creation
    of signatures for the static version of the OpenSSL libraries that ship with FreeBSD
    8.0\. DataRescue makes a toolkit available for generating custom signatures that
    can be used by IDA’s signature-matching engine. We’ll cover the generation of
    custom signatures in [Chapter 12](ch12.html "Chapter 12. Library Recognition Using
    FLIRT Signatures"). Regardless of why you want to apply new signatures, either
    pressing the insert key or right-clicking the Signatures window will offer you
    the Apply new signature option, at which time you can choose from a list of all
    signatures known to your installation of IDA.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在至少两种情况下，你可能需要知道如何对你的二进制文件应用额外的签名。在第一种情况下，IDA可能无法识别用于构建二进制文件的编译器，从而导致无法选择适当的签名进行应用。在这种情况下，你可能希望强制IDA应用一个或多个你认为IDA应该尝试的签名。第二种情况涉及为可能没有包含在IDA中的库创建自己的签名。一个例子可能是为FreeBSD
    8.0中随附的OpenSSL库的静态版本创建签名。DataRescue提供了一套工具包，可以生成由IDA的签名匹配引擎使用的自定义签名。我们将在[第12章](ch12.html
    "第12章。使用FLIRT签名识别库")中介绍自定义签名的生成。无论你为什么想要应用新的签名，按下插入键或在签名窗口内右键单击都将提供“应用新签名”选项，此时你可以从IDA安装所知的所有签名列表中进行选择。
- en: The Type Libraries Window
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型库窗口
- en: Similar in concept to the Signatures window is the Type Libraries window. Type
    libraries represent IDA’s accumulated knowledge of predefined datatypes and function
    prototypes gleaned from header files included with most popular compilers. By
    processing header files, IDA understands the datatypes that are expected by common
    library functions and can annotate your disassemblies accordingly. Similarly,
    from these header files IDA understands both the size and layout of complex data
    structures. All of this type information is collected into TIL files (*<IDADIR>/til*)
    and applied any time a binary is analyzed. As with signatures, IDA must first
    be able to deduce the libraries that a program uses before it can select an appropriate
    set of TIL files to load. You can request that IDA load additional type libraries
    by pressing the insert key or by right-clicking within the Type Libraries window
    and choosing Load type library. Type libraries are covered in more detail in [Chapter 13](ch13.html
    "Chapter 13. Extending IDA’s Knowledge").
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与签名窗口在概念上相似的是类型库窗口。类型库代表了IDA从大多数流行编译器包含的头文件中积累的对预定义数据类型和函数原型的知识。通过处理头文件，IDA能够理解常见库函数期望的数据类型，并相应地注释你的反汇编代码。同样，从这些头文件中，IDA也能理解复杂数据结构的尺寸和布局。所有这些类型信息都被收集到TIL文件（`<IDADIR>/til`）中，并在分析任何二进制文件时应用。与签名一样，在IDA能够选择适当的TIL文件集进行加载之前，它必须首先能够推断出程序使用的库。你可以通过按插入键或在类型库窗口内右键单击并选择“加载类型库”来请求IDA加载额外的类型库。类型库的详细信息将在[第13章](ch13.html
    "第13章。扩展IDA的知识")中介绍。
- en: The Function Calls Window
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数调用窗口
- en: In any program, a function can both call and be called by other functions. In
    fact, it is a fairly simple task to construct a graph that displays the relationships
    between callers and callees. Such a graph is called a *function call graph* or
    *function call tree* (we will demonstrate how to have IDA generate such graphs
    in [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing")). On occasion,
    we may not be interested in seeing the entire call graph of a program; instead,
    we may be interested only in knowing the immediate neighbors of a given function.
    For our purposes, we will call Y a neighbor of X if Y directly calls X or X directly
    calls Y.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何程序中，一个函数既可以调用其他函数，也可以被其他函数调用。实际上，构建一个显示调用者和被调用者之间关系的图是一项相当简单的任务。这样的图被称为*函数调用图*或*函数调用树*（我们将在[第9章](ch09.html
    "第9章。交叉引用和绘图")中演示如何让IDA生成这样的图）。有时，我们可能对查看程序的整个调用图不感兴趣；相反，我们可能只对知道给定函数的即时邻居感兴趣。为了我们的目的，如果我们说Y是X的邻居，那么Y直接调用X或者X直接调用Y。
- en: The Function Calls window provides the answer to this neighbor question. When
    you open the Function Calls window, IDA determines the neighbors of the function
    in which the cursor is positioned and generates a display such as that shown in
    [Figure 5-10](ch05s03.html#the_function_calls_window-id1 "Figure 5-10. The Function
    Calls window").
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用窗口提供了对这个邻居问题的答案。当你打开函数调用窗口时，IDA确定光标所在函数的邻居，并生成类似于[图5-10](ch05s03.html#the_function_calls_window-id1
    "图5-10. 函数调用窗口")所示的显示。
- en: '![The Function Calls window](httpatomoreillycomsourcenostarchimages854123.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![函数调用窗口](httpatomoreillycomsourcenostarchimages854123.png)'
- en: Figure 5-10. The Function Calls window
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-10. 函数调用窗口
- en: In this example, we see that the function named `sub_40182C` is called from
    six different locations in `_main` and `_main` in turn makes 15 other function
    calls. Double-clicking any line within the Function Calls window immediately jumps
    the disassembly window to the selected calling or called function (or caller and
    callee). IDA cross-references (xrefs) are the mechanisms that underlie the generation
    of the Function Calls windows. Xrefs will be covered in more detail in [Chapter 9](ch09.html
    "Chapter 9. Cross-References and Graphing").
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到名为`sub_40182C`的函数在`_main`和`_main`中从六个不同的位置被调用，而`_main`又依次调用了15个其他函数。在函数调用窗口中双击任何一行会立即将反汇编窗口跳转到选定的调用或被调用函数（或调用者和被调用者）。IDA交叉引用（xrefs）是生成函数调用窗口的底层机制。交叉引用将在[第9章](ch09.html
    "第9章。交叉引用和绘图")中更详细地介绍。
- en: The Problems Window
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题窗口
- en: 'The Problems window is IDA’s way of informing you of any difficulties that
    it has encountered in disassembling a binary and how it has chosen to deal with
    those difficulties. In some instances, you may be able to manipulate the disassembly
    to help IDA overcome a problem, and in other instances you may not. You can expect
    to encounter problems in even the simplest of binaries. In many cases, simply
    choosing to ignore the problems is not a bad strategy. In order to correct many
    of the problems, you need to have a better understanding of the binary than IDA
    has, which for most of us is probably not going to happen. A sample set of problems
    follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 问题窗口是IDA通知你它在反汇编二进制文件时遇到的任何困难以及它如何处理这些困难的方式。在某些情况下，你可能能够操作反汇编来帮助IDA克服问题，而在其他情况下你可能不能。你可能会在即使是简单的二进制文件中遇到问题。在许多情况下，简单地选择忽略问题不是一个坏策略。为了纠正许多问题，你需要比IDA更好的理解二进制文件，对于我们大多数人来说，这可能不太可能发生。以下是一些问题示例：
- en: '[PRE6]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each problem is characterized by (1) the address at which the problem occurs,
    (2) the type of problem encountered, and (3) the instruction present at the problem
    location. In this example, we see a `BOUNDS` problem and a `DECISION` problem.
    A `BOUNDS` problem occurs when the destination of a `call` or `jump` either can’t
    be determined (as in this example, since the value of `eax` is unknown to IDA)
    or appears to lie outside the range of virtual addresses in a program. A `DECISION`
    problem is most often not a problem at all. A `DECISION` usually represents an
    address at which IDA has chosen to disassemble bytes as instructions rather than
    data even though the address has never been referenced during the recursive descent
    instruction traversal (see [Chapter 1](ch01.html "Chapter 1. Introduction to Disassembly")).
    A complete list of problem types and suggestions for how to deal with them is
    available in the built-in IDA help file (see topic *Problems List*).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每个问题都有以下特征：（1）问题发生的位置地址，（2）遇到的问题类型，以及（3）问题位置处的指令。在这个例子中，我们看到一个 `BOUNDS` 问题和一个
    `DECISION` 问题。当 `call` 或 `jump` 的目标无法确定（如本例中，因为 IDA 未知 `eax` 的值）或似乎位于程序虚拟地址范围之外时，就会发生
    `BOUNDS` 问题。`DECISION` 问题通常根本不是问题。`DECISION` 通常表示 IDA 选择将字节反汇编为指令而不是数据的位置，即使该地址在递归下降指令遍历过程中从未被引用（参见[第
    1 章](ch01.html "第 1 章. 反汇编简介")）。有关问题类型及其处理建议的完整列表可在内置的 IDA 帮助文件中找到（参见主题 *问题列表*）。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At first glance, the number of displays that IDA offers can seem overwhelming.
    You may find it easiest to stick with the primary displays until you are comfortable
    enough to begin exploring the additional display offerings. In any case, you should
    certainly not feel obligated to use everything that IDA throws at you. Not every
    window will be useful in every reverse engineering scenario.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，IDA 提供的显示数量可能会让你感到不知所措。你可能发现，在足够熟悉之前，坚持使用主要显示是最容易的。无论如何，你当然不应该觉得有义务使用 IDA
    抛给你的所有功能。并非每个窗口在每种逆向工程场景中都会有用。
- en: In addition to the windows covered in this chapter, you will be confronted by
    a tremendous number of dialogs as you endeavor to master IDA. We will introduce
    key dialogs as they become relevant in the remainder of the book. Finally, other
    than the default disassembly view graph, we have elected not to cover graphs in
    this chapter. The IDA menu system distinguishes graphs as a separate category
    of display from the subviews discussed in this chapter. We will cover the reasons
    behind this in [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing"),
    which deals exclusively with graphs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章中提到的窗口外，在你努力掌握 IDA 的过程中，你将面临大量的对话框。我们将随着书中剩余部分的相关性介绍关键对话框。最后，除了默认的反汇编视图图之外，我们选择在本章中不涵盖图形。IDA
    菜单系统将图形区分为一个独立的显示类别，与本章讨论的子视图不同。我们将在第 9 章（[第 9 章. 跨引用和图形](ch09.html "第 9 章. 跨引用和图形")）中解释这一选择的原因，该章专门讨论图形。
- en: At this point, you should be starting to get comfortable with the IDA user interface.
    In the next chapter, we begin to focus on the many ways that you can manipulate
    a disassembly to enhance your understanding of its behavior and to generally make
    your life easier with IDA.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该开始熟悉 IDA 用户界面了。在下一章中，我们将开始关注你如何通过操作反汇编来增强对其行为的理解，以及如何使你的生活使用 IDA 更为便捷。
- en: Chapter 6. Disassembly Navigation
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 反汇编导航
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: In this and the following chapter we cover the heart of what puts the *Interactive*
    in *IDA Pro*, which is, in a nutshell, ease of navigation and ease of manipulation.
    The focus of this chapter is navigation; specifically, we show how IDA facilitates
    moving around a disassembly in a logical manner. So far, we have shown that at
    a basic level IDA simply combines the features of many common reverse engineering
    tools into an integrated disassembly display. Navigating around the display is
    one of the essential skills required in order to master IDA. Static disassembly
    listings offer no inherent navigational capability other than scrolling up and
    down the listing. Even with the best text editors, such *dead listings* are very
    difficult to navigate, as the best they have to offer is generally nothing more
    than an integrated, `grep`-style search. As you shall see, IDA’s database underpinnings
    provide for exceptional navigational features.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和接下来的章节中，我们将介绍赋予IDA Pro中“交互”核心的东西，简而言之，就是导航和操作的便捷性。本章的重点是导航；具体来说，我们展示了IDA如何以逻辑方式方便地在反汇编中移动。到目前为止，我们已经展示了在基本层面上IDA只是将许多常见逆向工程工具的功能组合到一个集成的反汇编显示中。静态反汇编列表除了滚动上下之外，没有固有的导航能力。即使是最优秀的文本编辑器，这些“死列表”也很难导航，因为它们所能提供的最好的东西通常只是集成式的、类似`grep`风格的搜索。正如您将看到的，IDA的数据库基础提供了卓越的导航功能。
- en: Basic IDA Navigation
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本IDA导航
- en: In your initial experience with IDA, you may be happy to make use of nothing
    more than the navigational features that IDA has to offer. In addition to offering
    fairly standard search features that you are accustomed to from your use of text
    editors or word processors, IDA develops and displays a comprehensive list of
    cross-references that behave in a manner similar to hyperlinks on a web page.
    The end result is that, in most cases, navigating to locations of interest requires
    nothing more than a double-click.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用IDA的初始体验中，您可能会很高兴只使用IDA提供的导航功能。除了提供您从使用文本编辑器或文字处理器中习惯的标准搜索功能之外，IDA还开发和显示了一个全面的交叉引用列表，其行为类似于网页上的超链接。最终结果是，在大多数情况下，导航到感兴趣的位置只需要双击即可。
- en: Double-Click Navigation
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双击导航
- en: When a program is disassembled, every location in the program is assigned a
    virtual address. As a result, we can navigate anywhere within a program by providing
    the virtual address of the location we are interested in visiting. Unfortunately
    for us, maintaining a catalog of addresses in our head is not a trivial task.
    This fact motivated early programmers to assign symbolic names to program locations
    that they wished to reference, making things a whole lot easier on themselves.
    The assignment of symbolic names to program addresses was not unlike the assignment
    of mnemonic instruction names to program opcodes; programs became easier to read
    and write by making them easier to remember.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序被反汇编时，程序中的每个位置都会被分配一个虚拟地址。因此，我们可以通过提供我们感兴趣访问的位置的虚拟地址来在程序中导航到任何地方。不幸的是，在我们脑海中维护地址目录并不是一个简单任务。这个事实促使早期的程序员为他们希望引用的程序位置分配符号名称，这使得事情变得容易得多。对程序地址分配符号名称并不像对程序操作码分配助记指令名称；通过使它们更容易记住，程序变得更容易阅读和编写。
- en: As we discussed previously, IDA generates symbolic names during the analysis
    phase by examining a binary’s symbol table or by automatically generating a name
    based on how a location is referenced within the binary. In addition to its symbolic
    purpose, any name displayed in the disassembly window is a potential navigation
    target similar to a hyperlink on a web page. The two differences between these
    names and standard hyperlinks are (1) that the names are never highlighted in
    any way to indicate that they can be followed and (2) that IDA requires a double-click
    to follow rather than the single-click required by a hyperlink. We have already
    seen the use of names in various subwindows such as the Functions, Imports, and
    Exports windows. Recall that for each of these windows, double-clicking a name
    caused the disassembly view to jump to the referenced location. This is one example
    of the double-click navigation at work. In the following listing, each of the
    symbols labeled ![](httpatomoreillycomsourcenostarchimages854061.png) represents
    a named navigational target. Double-clicking any of them will cause IDA to relocate
    the display to the selected location.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，IDA在分析阶段通过检查二进制的符号表或根据二进制中位置的引用自动生成名称来生成符号名称。除了其符号目的之外，在反汇编窗口中显示的任何名称都是一个潜在的导航目标，类似于网页上的超链接。这些名称与标准超链接之间的两个区别是（1）名称永远不会以任何方式突出显示以指示它们可以被跟随，以及（2）IDA需要双击来跟随，而不是超链接所需的单击。我们已经看到了在函数、导入和导出等子窗口中使用名称的例子。回想一下，对于这些窗口中的每一个，双击一个名称都会使反汇编视图跳转到引用的位置。这是双击导航工作的一个例子。在下面的列表中，每个标记为
    ![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)
    的符号代表一个命名的导航目标。双击其中的任何一个都会导致IDA将显示重新定位到所选位置。
- en: '[PRE7]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For navigational purposes, IDA treats two additional display entities as navigational
    targets. First, cross-references (shown at ![](httpatomoreillycomsourcenostarchimages854063.png)
    here) are treated as navigational targets. Cross-references are generally formated
    as a name and a hex offset. The cross-reference at the right of `loc_40134E` in
    the previous listing refers to a location that is `4D[16]` or `77[10]` bytes beyond
    the start of `sub_4012E4`. Double-clicking the cross-reference text will jump
    the display to the referencing location (`00401331` in this case). Cross-references
    are covered in more detail in [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing").
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导航目的，IDA将另外两个显示实体视为导航目标。首先，交叉引用（如图 ![httpatomoreillycomsourcenostarchimages854063.png](httpatomoreillycomsourcenostarchimages854063.png)
    所示）被视为导航目标。交叉引用通常格式化为名称和十六进制偏移量。在前面列表中`loc_40134E`右侧的交叉引用指的是`sub_4012E4`起始处`4D[16]`或`77[10]`字节之外的位置。双击交叉引用文本将使显示跳转到引用位置（在本例中为`00401331`）。交叉引用将在[第9章](ch09.html
    "第9章。交叉引用和绘图")中更详细地介绍。
- en: The second type of display entity afforded special treatment in a navigational
    sense is one that uses hexadecimal values. If a displayed hexadecimal value represents
    a valid virtual address within the binary, then double-clicking the value will
    reposition the disassembly window to display the selected virtual address. In
    the listing that follows, double-clicking any of the values indicated by ![](httpatomoreillycomsourcenostarchimages854093.png)
    will jump the display, because each is a valid virtual address within the given
    binary, while double-clicking any of the values indicated by ![](httpatomoreillycomsourcenostarchimages854095.png)
    will have no effect.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航方面，第二种获得特殊处理的显示实体是使用十六进制值。如果一个显示的十六进制值代表二进制中的有效虚拟地址，那么双击该值将重新定位反汇编窗口以显示所选的虚拟地址。在下面的列表中，双击任何由
    ![httpatomoreillycomsourcenostarchimages854093.png](httpatomoreillycomsourcenostarchimages854093.png)
    指示的值将跳转显示，因为每个值都是给定二进制中的有效虚拟地址，而双击任何由 ![httpatomoreillycomsourcenostarchimages854095.png](httpatomoreillycomsourcenostarchimages854095.png)
    指示的值将没有任何效果。
- en: '[PRE8]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A final note about double-click navigation concerns the IDA Output window, which
    is most often used to display informational messages. When a navigational target,
    as previously described, appears as the first item in a message, double-clicking
    the message will jump the display to the indicated target.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 关于双击导航的最后一项说明是IDA输出窗口，它通常用于显示信息消息。当导航目标，如之前所述，作为消息中的第一个项目出现时，双击消息将使显示跳转到指示的目标。
- en: '[PRE9]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the Output window excerpt just shown, the two messages indicated by ![](httpatomoreillycomsourcenostarchimages854099.png)
    can be used to navigate to the addresses indicated at the start of the respective
    messages. Double-clicking any of the other messages, including those at ![](httpatomoreillycomsourcenostarchimages854101.png),
    will result in no action at all.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚显示的输出窗口摘录中，由 ![httpatomoreillycomsourcenostarchimages854099.png](httpatomoreillycomsourcenostarchimages854099.png)
    指示的两个消息可以使用来导航到各自消息开头指示的地址。双击任何其他消息，包括 ![httpatomoreillycomsourcenostarchimages854101.png]
    中的消息，将不会执行任何操作。
- en: Jump to Address
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳转到地址
- en: Occasionally, you will know exactly what address you would like to navigate
    to, yet no name will be handy in the disassembly window to offer simple double-click
    navigation. In such a case, you have a few options. The first, and most primitive,
    option is to use the disassembly window scroll bar to scroll the display up or
    down until the desired location comes into view. This is usually feasible only
    when the location you are navigating to is known by its virtual address, since
    the disassembly window is organized linearly by virtual address. If all you know
    is a named location such as a subroutine named `foobar`, then navigating via the
    scroll bar becomes something of a needle-in-a-haystack search. At that point,
    you might choose to sort the Functions window alphabetically, scroll to the desired
    name, and double-click the name. A third option is to use one of IDA’s search
    features available via the Search menu, which typically involves specifying some
    search criteria before asking IDA to perform a search. In the case of searching
    for a known location, this is usually overkill.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能确切知道想要导航到的地址，但在反汇编窗口中没有可用的名称来提供简单的双击导航。在这种情况下，您有几个选择。第一个，也是最原始的选择，是使用反汇编窗口的滚动条向上或向下滚动显示，直到所需的地点出现在视图中。这通常只有在您要导航到的位置是按虚拟地址知道的时才可行，因为反汇编窗口是按虚拟地址线性组织的。如果您只知道一个命名的位置，例如名为
    `foobar` 的子程序，那么通过滚动条导航就变成了一种类似大海捞针的搜索。在这种情况下，您可能选择按字母顺序对函数窗口进行排序，滚动到所需的名称，然后双击该名称。第三个选项是使用
    IDA 的搜索功能之一，这些功能通常通过搜索菜单提供，这通常涉及在请求 IDA 执行搜索之前指定一些搜索条件。在搜索已知位置的情况下，这通常是过度的。
- en: Ultimately, the easiest way to get to a known disassembly location is to make
    use of the Jump to Address dialog shown in [Figure 6-1](ch06.html#the_jump_to_address_dialog
    "Figure 6-1. The Jump to Address dialog").
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，到达已知的反汇编位置最简单的方法是使用[图6-1](ch06.html#the_jump_to_address_dialog "图6-1. 地址跳转对话框")中显示的地址跳转对话框。
- en: '![The Jump to Address dialog](httpatomoreillycomsourcenostarchimages854125.png.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![地址跳转对话框](httpatomoreillycomsourcenostarchimages854125.png.jpg)'
- en: Figure 6-1. The Jump to Address dialog
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. 地址跳转对话框
- en: The Jump to Address dialog is accessed via Jump ▸ Jump to Address, or by using
    the G hotkey while the disassembly window is active. Thinking of this dialog as
    the *Go* dialog may help you remember the associated hotkey. Navigating to any
    location in the binary is as simple as specifying the address (a name or hex value
    will do) and clicking OK, which will immediately jump the display to the desired
    location. Values entered into the dialog are remembered and made available on
    subsequent use via a drop-down list. This history feature makes returning to previously
    requested locations somewhat easier.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 地址跳转对话框可以通过“跳转 ▸ 跳转到地址”访问，或者在反汇编窗口处于活动状态时使用 G 快捷键。将此对话框视为“转到”对话框可能有助于您记住相关的快捷键。要导航到二进制中的任何位置，只需指定地址（可以是名称或十六进制值）并点击“确定”，这将立即将显示跳转到所需位置。对话框中输入的值将被记住，并在后续使用时通过下拉列表提供。此历史功能使得返回之前请求的位置变得相对容易。
- en: Navigation History
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航历史
- en: If we compare IDA’s document-navigation functions to those of a web browser,
    we might equate names and addresses to hyperlinks, as each can be followed relatively
    easily to view a new location. Another feature IDA shares with traditional web
    browsers is the concept of forward and backward navigation based on the order
    in which you navigate the disassembly. Each time you navigate to a new location
    within a disassembly, your current location is appended to a history list. Two
    menu operations are available for traversing this list. First, Jump ▸ Jump to
    Previous Position repositions the disassembly to the most recent entry in the
    history list. The behavior is conceptually identical to a web browser’s *back*
    button. The associated hotkey is esc, and it is one of the most useful hotkeys
    that you can commit to memory. Be forewarned, however, that using esc when any
    window other than the disassembly window is active causes the active window to
    be closed. (You can always reopen windows that you closed accidentally via View
    ▸ Open Subviews.) Backward navigation is extremely handy when you have followed
    a chain of function calls several levels deep and you decide that you want to
    navigate back to your original position within the disassembly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将IDA的文档导航功能与网络浏览器的功能进行比较，我们可以将名称和地址等同于超链接，因为每个都可以相对容易地跟随以查看新位置。IDA与传统的网络浏览器共享的另一项功能是基于你导航反汇编的顺序的前进和后退导航概念。每次你导航到反汇编中的新位置时，你的当前位置都会附加到历史列表中。有两个菜单操作可用于遍历此列表。首先，Jump
    ▸ 跳转到上一个位置将反汇编重新定位到历史列表中的最新条目。其行为在概念上与网络浏览器的*后退*按钮相同。相关的快捷键是esc，这是你可以记住的最有用的快捷键之一。然而，警告你，当除了反汇编窗口之外的任何窗口处于活动状态时使用esc会导致活动窗口关闭。（你可以通过View
    ▸ Open Subviews重新打开你意外关闭的窗口。）当你跟随了多层函数调用链并决定想要导航回反汇编中的原始位置时，后退导航非常方便。
- en: Jump ▸ Jump to Next Position is the counterpart operation that moves the disassembly
    window forward in the history list in a manner similar to a web browser’s *forward*
    button. For the sake of completeness, the associated hotkey for this operation
    is ctrl-enter, though it tends to be less useful than using esc for backward navigation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Jump ▸ 跳转到下一个位置是与该操作对应的操作，它以类似于网络浏览器*前进*按钮的方式将反汇编窗口向前移动历史列表。为了完整性起见，此操作的关联快捷键是ctrl-enter，尽管它通常不如使用esc进行后退导航有用。
- en: Finally, two of the more useful toolbar buttons, shown in [Figure 6-2](ch06.html#forward_and_backward_navigation_buttons
    "Figure 6-2. Forward and backward navigation buttons"), provide the familiar browser-style
    forward and backward behavior. Each of the buttons is associated with a drop-down
    history list that offers you instant access to any location in the navigation
    history without having to trace your steps through the entire list.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两个更有用的工具栏按钮，如图6-2所示，提供了熟悉的浏览器风格的前进和后退行为。每个按钮都关联一个下拉历史列表，它允许你立即访问导航历史中的任何位置，而无需在整个列表中追踪你的步骤。
- en: '![Forward and backward navigation buttons](httpatomoreillycomsourcenostarchimages854127.png.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![前进和后退导航按钮](httpatomoreillycomsourcenostarchimages854127.png.jpg)'
- en: Figure 6-2. Forward and backward navigation buttons
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2. 前进和后退导航按钮
- en: Stack Frames
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈帧
- en: Because IDA Pro is such a low-level analysis tool, many of its features and
    displays expect the user to be somewhat familiar with the low-level details of
    compiled languages, many of which center on the specifics of generating machine
    language and managing the memory used by a high-level program. Therefore, from
    time to time this book covers some of the theory of compiled programs in order
    to make sense of the related IDA displays.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IDA Pro是一个低级分析工具，许多其功能和显示都期望用户对编译语言的低级细节有一定了解，这些细节大多集中在生成机器语言和管理高级程序使用的内存的具体细节上。因此，本书不时会涵盖一些编译程序的理论，以便理解相关的IDA显示。
- en: One such low-level concept is that of the stack frame. *Stack frames* are blocks
    of memory allocated within a program’s runtime stack and dedicated to a specific
    invocation of a function. Programmers typically group executable statements into
    units called *functions* (also called *procedures*, *subroutines*, or *methods*).
    In some cases this may be a requirement of the language being used. In most cases
    it is considered good programming practice to build programs from such functional
    units.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个低级概念是栈帧。*栈帧*是在程序运行时堆栈内分配的内存块，专门用于函数的特定调用。程序员通常将可执行语句组合成称为*函数*（也称为*过程*、*子程序*或*方法*）的单位。在某些情况下，这可能使用户使用的语言的要求。在大多数情况下，将程序构建成这样的功能单元被认为是良好的编程实践。
- en: When a function is not executing, it typically requires little to no memory.
    When a function is called, however, it may require memory for several reasons.
    First, the caller of a function may wish to pass information into the function
    in the form of parameters (arguments), and these parameters need to be stored
    somewhere the function can find them. Second, the function may need temporary
    storage space while performing its task. This temporary space is often allocated
    by a programmer through the declaration of local variables, which can be used
    within the function but cannot be accessed once the function has completed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数未执行时，它通常需要的内存很少或不需要。但是，当函数被调用时，它可能需要内存，原因有几个。首先，函数的调用者可能希望以参数（参数）的形式将信息传递给函数，并且这些参数需要存储在函数可以找到它们的地方。其次，函数在执行任务时可能需要临时存储空间。这种临时空间通常是通过程序员通过声明局部变量来分配的，这些局部变量可以在函数内部使用，但在函数完成后无法访问。
- en: 'Compilers utilize stack frames (also called *activation records*) to make the
    allocation and deallocation of function parameters and local variables transparent
    to the programmer. A compiler inserts code to place a function’s parameters into
    the stack frame prior to transferring control to the function itself, at which
    point the compiler inserts code to allocate enough memory to hold the function’s
    local variables. As a consequence of the way stack frames are constructed, the
    address to which the function should return is also stored within the new stack
    frame. A pleasant result of the use of stack frames is that recursion becomes
    possible, as each recursive call to a function is given its own stack frame, neatly
    segregating each call from its predecessor. The following steps detail the operations
    that take place when a function is called:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器利用栈帧（也称为*活动记录*）使函数参数和局部变量的分配和释放对程序员来说是透明的。编译器在将控制权传递给函数本身之前，插入代码将函数的参数放入栈帧中，此时编译器插入代码以分配足够的内存来存储函数的局部变量。由于栈帧的构建方式，函数应返回的地址也存储在新的栈帧中。使用栈帧的一个令人愉快的结果是递归成为可能，因为每个递归调用函数都有自己的栈帧，从而清晰地隔离了每个调用与其前一个调用。以下步骤详细说明了函数被调用时发生的操作：
- en: The caller places any parameters required by the function being called into
    locations as dictated by the calling convention (see [Calling Conventions](ch06s02.html#calling_conventions
    "Calling Conventions") in [Calling Conventions](ch06s02.html#calling_conventions
    "Calling Conventions")) employed by the called function. This operation may result
    in a change to the program stack pointer if parameters are placed on the runtime
    stack.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将函数所需的所有参数放入由被调用函数使用的调用约定（参见[调用约定](ch06s02.html#calling_conventions "调用约定")）指定的位置。如果参数放在运行时堆栈上，此操作可能会导致程序堆栈指针发生变化。
- en: The caller transfers control to the function being called. This is usually performed
    with an instruction such as the x86 `CALL` or the MIPS `JAL`. A return address
    is typically saved onto the program stack or in a CPU register.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将控制权传递给被调用的函数。这通常通过像x86的`CALL`或MIPS的`JAL`这样的指令来完成。返回地址通常被保存在程序堆栈或CPU寄存器中。
- en: If necessary, the called function takes steps to configure a frame pointer^([[42](#ftn.CHP-6-FN-1)])
    and saves any register values that the caller expects to remain unchanged.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，被调用的函数会采取步骤配置一个帧指针^([[42](#ftn.CHP-6-FN-1)])并保存调用者期望保持不变的任何寄存器值。
- en: The called function allocates space for any local variables that it may require.
    This is often done by adjusting the program stack pointer to reserve space on
    the runtime stack.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数为其可能需要的任何局部变量分配空间。这通常是通过调整程序堆栈指针来在运行时堆栈上预留空间来完成的。
- en: The called function performs its operations, potentially generating a result.
    In the course of performing its operations, the called function may access the
    parameters passed to it by the calling function. If the function returns a result,
    the result is often placed into a specific register or registers that the caller
    can examine once the function returns.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数执行其操作，可能生成一个结果。在执行操作的过程中，被调用的函数可能会访问调用函数传递给它的参数。如果函数返回一个结果，这个结果通常会被放置到一个或多个特定的寄存器中，调用者可以在函数返回后检查这些寄存器。
- en: Once the function has completed its operations, any stack space reserved for
    local variables is released. This is often done by reversing the actions performed
    in step 4.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦函数完成其操作，为局部变量保留的栈空间就会被释放。这通常是通过逆转第4步中执行的操作来完成的。
- en: Any registers whose values were saved (in step 3) on behalf of the caller are
    restored to their original values. This includes the restoration of the caller’s
    frame pointer register.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为调用者保存的任何寄存器值（在第3步中保存）都会恢复到其原始值。这包括恢复调用者的帧指针寄存器。
- en: The called function returns control to the caller. Typical instructions for
    this include the x86 `RET` and the MIPS `JR` instructions. Depending on the calling
    convention in use, this operation may also serve to clear one or more parameters
    from the program stack.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数将控制权返回给调用者。典型的指令包括x86的`RET`指令和MIPS的`JR`指令。根据使用的调用约定，此操作还可能用于清除程序栈中的一个或多个参数。
- en: Once the caller regains control, it may need to remove parameters from the program
    stack. In such cases a stack adjustment may be required to restore the program
    stack pointer to the value that it held prior to step 1.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调用者恢复控制，它可能需要从程序栈中移除参数。在这种情况下，可能需要进行栈调整，以将程序栈指针恢复到第1步之前的值。
- en: Steps 3 and 4 are so commonly performed upon entry to a function that together
    they are called the function’s *prologue*. Similarly, steps 6 through 8 are so
    frequently performed at the end of a function that together they make up the function’s
    *epilogue*. With the exception of step 5, which represents the body of the function,
    all of these operations constitute the overhead associated with calling a function.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步和第4步在函数进入时通常都会执行，因此它们一起被称为函数的*序言*。同样，第6步到第8步在函数结束时经常执行，因此它们共同构成了函数的*尾声*。除了代表函数主体的第5步之外，所有这些操作都构成了调用函数时的开销。
- en: Calling Conventions
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用约定
- en: With a basic understanding of what stack frames are, we can take a closer look
    at exactly how they are structured. The examples that follow reference the x86
    architecture and the behavior associated with common x86 compilers such as Microsoft
    Visual C/C++ or GNU’s gcc/g++. One of the most important steps in the creation
    of a stack frame involves the placement of function parameters onto the stack
    by the calling function. The calling function must store parameters exactly as
    the function being called expects to find them; otherwise, serious problems can
    arise. Functions advertise the manner in which they expect to receive their arguments
    by selecting and adhering to a specific calling convention.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在对栈帧有一个基本理解的基础上，我们可以更仔细地看看它们是如何结构的。以下示例参考了x86架构以及与常见的x86编译器（如Microsoft Visual
    C/C++或GNU的gcc/g++）相关的行为。创建栈帧最重要的步骤之一是调用函数将函数参数放置到栈上。调用函数必须按照被调用函数期望找到的方式存储参数；否则，可能会出现严重问题。函数通过选择并遵循特定的调用约定来声明它们期望接收参数的方式。
- en: A *calling convention* dictates exactly where a caller should place any parameters
    that a function requires. Calling conventions may require parameters to be placed
    in specific registers, on the program stack, or in both registers and on the stack.
    Equally important to when parameters are passed on the program stack is determining
    who is responsible for removing them from the stack once the called function has
    completed. Some calling conventions dictate that the caller is responsible for
    removing parameters that it placed on the stack, while other calling conventions
    dictate that the called function will take care of removing the parameters from
    the stack. Adherence to publicized calling conventions is essential in maintaining
    the integrity of the program stack pointer.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用约定*确切地规定了调用者应将函数所需的任何参数放置在何处。调用约定可能要求参数放置在特定的寄存器中、程序堆栈上，或者同时在寄存器和堆栈上。与参数在程序堆栈上传递的时间同等重要的是确定谁负责在调用函数完成后从堆栈上移除它们。一些调用约定规定调用者负责从堆栈上移除它放置的参数，而其他调用约定规定被调用函数将负责从堆栈上移除参数。遵守公开的调用约定对于维护程序堆栈指针的完整性至关重要。'
- en: The C Calling Convention
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C调用约定
- en: The default calling convention used by most C compilers for the x86 architecture
    is called the *C calling convention*. The `_cdecl` modifier may be used by C/C++
    programs to force compilers to utilize the C calling convention when the default
    calling convention may have been overridden. We will refer to this calling convention
    as the `cdecl` calling convention from here on. The `cdecl` calling convention
    specifies that the caller place parameters to a function on the stack in right-to-left
    order and that the caller (as opposed to the callee) remove the parameters from
    the stack after the called function completes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数C编译器用于x86架构的默认调用约定被称为*C调用约定*。C/C++程序可以使用`_cdecl`修饰符强制编译器在默认调用约定可能已被覆盖时使用C调用约定。从现在起，我们将此调用约定称为`cdecl`调用约定。`cdecl`调用约定指定调用者将函数的参数按从右到左的顺序放置在堆栈上，并且调用者（而不是被调用者）在调用函数完成后从堆栈上移除参数。
- en: One result of placing parameters on the stack in right-to-left order is that
    the leftmost (first) parameter of the function will always be on the top of the
    stack when the function is called. This makes the first parameter easy to find
    regardless of the number of parameters the function expects, and it makes the
    `cdecl` calling convention ideally suited for use with functions that can take
    a variable number of arguments (such as `printf`).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数按从右到左的顺序放置在堆栈上的一个结果是，当函数被调用时，函数的最左端（第一个）参数将始终位于堆栈的顶部。这使得无论函数期望多少参数，第一个参数都很容易找到，并且这使得`cdecl`调用约定非常适合用于可以接受可变数量参数的函数（如`printf`）。
- en: Requiring the calling function to remove parameters from the stack means that
    you will often see instructions that make an adjustment to the program stack pointer
    immediately following the return from a called function. In the case of functions
    that can accept a variable number of arguments, the caller is ideally suited to
    make this adjustment, as the caller knows exactly how many arguments it has chosen
    to pass to the function and can easily make the correct adjustment, whereas the
    called function never knows ahead of time how many parameters it may receive and
    would have a difficult time making the necessary stack adjustment.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要求调用函数从堆栈中移除参数意味着你经常会看到在调用函数返回后立即调整程序堆栈指针的指令。对于可以接受可变数量参数的函数，调用者非常适合进行这种调整，因为调用者确切地知道它选择了多少参数传递给函数，并且可以轻松地进行正确的调整，而调用函数事先永远不知道它可能接收多少参数，并且很难进行必要的堆栈调整。
- en: 'In the following examples we consider calls to a function having the following
    prototype:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们考虑对具有以下原型的函数的调用：
- en: '[PRE10]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, this function will use the `cdecl` calling convention, expecting
    the four parameters to be pushed in right-to-left order and requiring the caller
    to clean the parameters off the stack. A compiler might generate code for a call
    to this function as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此函数将使用`cdecl`调用约定，期望四个参数按从右到左的顺序压入，并要求调用者清理堆栈上的参数。编译器可能会生成如下调用此函数的代码：
- en: '[PRE11]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The four `push` operations beginning at ![](httpatomoreillycomsourcenostarchimages854061.png)
    result in a net change to the program stack pointer (ESP) of 16 bytes (`4 * sizeof(int)`
    on a 32-bit architecture), which is undone at ![](httpatomoreillycomsourcenostarchimages854063.png)
    following the return from `demo_cdecl`. If `demo_cdecl` is called 50 times, each
    call will be followed by an adjustment similar to that at ![](httpatomoreillycomsourcenostarchimages854063.png).
    The following example also adheres to the `cdecl` calling convention while eliminating
    the need for the caller to explicitly clean parameters off the stack following
    each call to `demo_cdecl`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ![](httpatomoreillycomsourcenostarchimages854061.png) 开始的四个 `push` 操作导致程序栈指针（ESP）净变化为16字节（在32位架构上为
    `4 * sizeof(int)`），在从 `demo_cdecl` 返回后通过 ![](httpatomoreillycomsourcenostarchimages854063.png)
    进行撤销。如果 `demo_cdecl` 被调用50次，每次调用之后都会进行类似的调整。以下示例也遵循 `cdecl` 调用约定，同时消除了调用者每次调用
    `demo_cdecl` 后显式清理栈上参数的需求。
- en: '[PRE12]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the compiler has preallocated storage space for the parameters
    to `demo_cdecl` at the top of the stack during the function prologue. When the
    parameters for `demo_cdecl` are placed on the stack, there is no change to the
    program stack pointer, which eliminates the need to adjust the stack pointer when
    the call to `demo_cdecl` completes. The GNU compilers (gcc and g++) utilize this
    technique to place function parameters onto the stack.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器在函数前导部分为 `demo_cdecl` 的参数在栈顶预分配了存储空间。当 `demo_cdecl` 的参数放置在栈上时，程序栈指针没有变化，这消除了在
    `demo_cdecl` 调用完成后调整栈指针的需求。GNU编译器（gcc和g++）利用这种技术将函数参数放置到栈上。
- en: Note that either method results in the stack pointer pointing to the leftmost
    argument when the function is called.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两种方法都会导致在函数调用时栈指针指向最左边的参数。
- en: The Standard Calling Convention
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准调用约定
- en: '*Standard* in this case is a bit of a misnomer as it is a name that Microsoft
    created for its own calling convention marked by the use of the `_stdcall` modifier
    in a function declaration, as shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，“标准”一词有点名不副实，因为它是一个微软为其自己的调用约定创建的名称，该约定在函数声明中使用 `_stdcall` 修饰符，如下所示：
- en: '[PRE13]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to avoid any confusion surrounding the word *standard*, we will refer
    to this calling convention as the `stdcall` calling convention for the remainder
    of the book.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免对“标准”一词的任何混淆，我们将在此书余下的部分中将此调用约定称为 `stdcall` 调用约定。
- en: 'As with the `cdecl` calling convention, `stdcall` requires that function parameters
    be placed on the program stack in right-to-left order. The difference when using
    `stdcall` is that the called function is responsible for clearing the function
    parameters from the stack when the function has finished. In order for a function
    to do this, the function must know exactly how many parameters are on the stack.
    This is possible only for functions that accept a fixed number of parameters.
    As a result, variable argument functions such as `printf` cannot make use of the
    `stdcall` calling convention. The `demo_stdcall` function, for example, expects
    three integer parameters, occupying a total of 12 bytes on the stack (`3 * sizeof(int)`
    on a 32-bit architecture). An x86 compiler can use a special form of the `RET`
    instruction to simultaneously pop the return address from the top of the stack
    and add 12 to the stack pointer to clear the function parameters. In the case
    of `demo_stdcall`, we might see the following instruction used to return to the
    caller:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `cdecl` 调用约定一样，`stdcall` 要求函数参数以从右到左的顺序放置在程序栈上。使用 `stdcall` 的区别在于，被调用的函数负责在函数完成后清理函数参数从栈上。为了执行此操作，函数必须确切知道栈上有多少个参数。这仅适用于接受固定数量参数的函数。因此，像
    `printf` 这样的可变参数函数无法使用 `stdcall` 调用约定。例如，`demo_stdcall` 函数期望有三个整数参数，在栈上总共占用12字节（在32位架构上为
    `3 * sizeof(int)`）。x86编译器可以使用 `RET` 指令的特殊形式，同时从栈顶弹出返回地址并将12加到栈指针上以清理函数参数。在 `demo_stdcall`
    的情况下，我们可能会看到以下指令用于返回给调用者：
- en: '[PRE14]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The primary advantage to the use of `stdcall` is the elimination of code to
    clean parameters off the stack following every function call, which results in
    slightly smaller, slightly faster programs. By convention Microsoft utilizes the
    `stdcall` convention for all fixed-argument functions exported from shared library
    (DLL) files. This is an important point to remember if you are attempting to generate
    function prototypes or binary-compatible replacements for any shared library components.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stdcall`的主要优势是消除了在每个函数调用后清理栈上参数的代码，这导致程序稍微小一些，稍微快一些。按照惯例，Microsoft为从共享库（DLL）文件导出的所有固定参数函数使用`stdcall`约定。如果你试图生成函数原型或任何共享库组件的二进制兼容替代品，这是一个需要记住的重要点。
- en: The fastcall Convention for x86
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86的fastcall约定
- en: A variation on the `stdcall` convention, the `fastcall` calling convention passes
    up to two parameters in CPU registers rather than on the program stack. The Microsoft
    Visual C/C++ and GNU gcc/g++ (version 3.4 and later) compilers recognize the `fastcall`
    modifier in function declarations. When `fastcall` is specified, the first two
    parameters passed to a function will be placed in the ECX and EDX registers, respectively.
    Any remaining parameters are placed on the stack in right-to-left order similar
    to `stdcall`. Also similar to `stdcall`, `fastcall` functions are responsible
    for removing parameters from the stack when they return to their caller. The following
    declaration demonstrates the use of the `fastcall` modifier.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdcall`约定的一个变体，`fastcall`调用约定通过CPU寄存器而不是程序栈传递最多两个参数。Microsoft Visual C/C++和GNU
    gcc/g++（版本3.4及以后）编译器在函数声明中识别`fastcall`修饰符。当指定`fastcall`时，传递给函数的前两个参数将分别放置在ECX和EDX寄存器中。任何剩余的参数都按右到左的顺序放置在栈上，类似于`stdcall`。同样，与`stdcall`类似，`fastcall`函数在返回调用者时负责从栈中移除参数。以下声明演示了`fastcall`修饰符的使用。'
- en: '[PRE15]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A compiler might generate the following code in order to call `demo_fastcall`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能会生成以下代码来调用`demo_fastcall`：
- en: '[PRE16]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that no stack adjustment is required upon return from the call to `demo_fastcall`,
    as `demo_fastcall` is responsible for clearing parameters `y` and `z` from the
    stack as it returns to the caller. It is important to understand that because
    two arguments are passed in registers, the called function needs to clear only
    8 bytes from the stack even though there are four arguments to the function.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从`demo_fastcall`的调用返回时不需要进行栈调整，因为`demo_fastcall`负责在返回调用者时清除参数`y`和`z`。重要的是要理解，由于有两个参数通过寄存器传递，即使函数有四个参数，调用函数只需要从栈中清除8个字节。
- en: C++ Calling Conventions
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++调用约定
- en: Nonstatic member functions in C++ classes differ from standard functions in
    that they must make available the `this` pointer, which points to the object used
    to invoke the function. The address of the object used to invoke the function
    must be supplied by the caller and is therefore provided as a parameter when calling
    nonstatic member functions. The C++ language standard does not specify how `this`
    should be passed to nonstatic member functions, so it should come as no surprise
    that different compilers use different techniques when passing `this`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: C++类中的非静态成员函数与标准函数不同，因为它们必须提供指向用于调用该函数的对象的`this`指针。用于调用该函数的对象的地址必须由调用者提供，因此在调用非静态成员函数时作为参数提供。C++语言标准没有指定`this`应该如何传递给非静态成员函数，因此不同编译器在传递`this`时使用不同的技术并不令人惊讶。
- en: Microsoft Visual C++ offers the `thiscall` calling convention, which passes
    `this` in the ECX register and requires the nonstatic member function to clean
    parameters off the stack as in `stdcall`. The GNU `g++` compiler treats `this`
    as the implied first parameter to any nonstatic member function and behaves in
    all other respects as if the `cdecl` convention is being used. Thus, for `g++-`compiled
    code, `this` is placed on top of the stack prior to calling the nonstatic member
    function, and the caller is responsible for removing parameters (there will always
    be at least one) from the stack once the function returns. Additional features
    of compiled C++ are discussed in [Chapter 8](ch08.html "Chapter 8. Datatypes and
    Data Structures").
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Visual C++提供了`thiscall`调用约定，它将`this`传递到ECX寄存器，并要求非静态成员函数像`stdcall`一样清理堆栈上的参数。GNU
    `g++`编译器将`this`视为任何非静态成员函数的隐含第一个参数，并在所有其他方面表现得像使用了`cdecl`约定。因此，对于`g++`编译的代码，`this`在调用非静态成员函数之前放在堆栈顶部，调用者负责在函数返回后从堆栈中移除参数（将始终至少有一个）。编译后的C++的附加功能将在[第8章](ch08.html
    "第8章。数据类型和数据结构")中讨论。
- en: Other Calling Conventions
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他调用约定
- en: 'Complete coverage of every existing calling convention would require a book
    in its own right. Calling conventions are often language-, compiler-, and CPU-specific,
    and some research on your part may be required as you encounter code generated
    by less-common compilers. A few situations deserve special mention, however: optimized
    code, custom assembly language code, and system calls.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 完全覆盖每个现有的调用约定需要一本专著。调用约定通常是语言、编译器和CPU特定的，当你遇到由不太常见的编译器生成的代码时，可能需要进行一些研究。然而，有一些情况值得特别提及：优化代码、自定义汇编语言代码和系统调用。
- en: When functions are exported for use by other programmers (such as library functions),
    it is important that they adhere to well-known calling conventions so that programmers
    can easily interface to those functions. On the other hand, if a function is intended
    for internal program use only, then the calling convention used by that function
    need be known only within that function’s program. In such cases, optimizing compilers
    may choose to use alternate calling conventions in order to generate faster code.
    Instances in which this may occur include the use of the `/GL` option with Microsoft
    Visual C++ and the use of the `regparm` keyword with GNU gcc/g++.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被导出供其他程序员使用（例如库函数）时，它们遵循众所周知的调用约定非常重要，这样程序员可以轻松地与这些函数接口。另一方面，如果一个函数仅用于程序内部，那么该函数使用的调用约定只需要在该函数的程序内部知晓。在这种情况下，优化编译器可能会选择使用不同的调用约定以生成更快的代码。可能发生这种情况的实例包括使用Microsoft
    Visual C++的`/GL`选项和使用GNU gcc/g++的`regparm`关键字。
- en: When programmers go to the trouble of using assembly language, they gain complete
    control over how parameters will be passed to any functions that they happen to
    create. Unless they wish to make their functions available to other programmers,
    assembly language programmers are free to pass parameters in any way they see
    fit. As a result, you may need to take extra care when analyzing custom assembly
    code. Custom assembly code is often encountered in obfuscation routines and shellcode.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员费心使用汇编语言时，他们可以完全控制参数如何传递到他们创建的任何函数。除非他们希望使他们的函数可供其他程序员使用，汇编语言程序员可以自由地以他们认为合适的方式传递参数。因此，在分析自定义汇编代码时，你可能需要格外小心。自定义汇编代码通常在混淆例程和shellcode中遇到。
- en: A *system call* is a special type of function call used to request an operating
    system service. System calls usually effect a state transition from user mode
    to kernel mode in order for the operating system kernel to service the user’s
    request. The manner in which system calls are initiated varies across operating
    systems and CPUs. For example, Linux x86 system calls may be initiated using the
    `int 0x80` instruction or the `sysenter` instruction, while other x86 operating
    systems may use only the `sysenter` instruction or alternate interrupt numbers.
    On many x86 systems (Linux being an exception) parameters for system calls are
    placed on the runtime stack, and a system call number is placed in the EAX register
    immediately prior to initiating the system call. Linux system calls accept their
    parameters in specific registers and occasionally in memory when there are more
    parameters than available registers.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统调用*是一种特殊类型的函数调用，用于请求操作系统服务。系统调用通常在用户模式到内核模式之间实现状态转换，以便操作系统内核处理用户请求。系统调用启动的方式因操作系统和CPU而异。例如，Linux
    x86系统调用可能使用`int 0x80`指令或`sysenter`指令启动，而其他x86操作系统可能仅使用`sysenter`指令或不同的中断号。在许多x86系统上（Linux除外），系统调用参数放置在运行时栈上，并在启动系统调用之前将系统调用号放置在EAX寄存器中。Linux系统调用接受其参数在特定寄存器中，有时在内存中（当参数多于可用寄存器时）。'
- en: Local Variable Layout
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量布局
- en: Unlike the calling conventions that dictate the manner in which parameters are
    passed into a function, there are no conventions that mandate the layout of a
    function’s local variables. When compiling a function, one task a compiler is
    faced with is to compute the amount of space required by a function’s local variables.
    Another task is to determine whether those variables can be allocated in CPU registers
    or whether they must be allocated on the program stack. The exact manner in which
    these allocations are made is irrelevant to both the caller of a function and
    to any functions that may, in turn, be called. Most notably, it is typically impossible
    to determine a function’s local variable layout based on examination of the function’s
    source code.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 与规定参数传递方式的调用约定不同，没有约定强制规定函数局部变量的布局。在编译函数时，编译器面临的一个任务是计算函数局部变量所需的空间量。另一个任务是确定这些变量是否可以分配在CPU寄存器中，或者是否必须在程序栈上分配。这些分配的确切方式对函数的调用者以及可能被调用的任何函数都无关紧要。最值得注意的是，通常无法通过检查函数的源代码来确定函数的局部变量布局。
- en: Stack Frame Examples
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈帧示例
- en: 'Consider the following function compiled on a 32-bit x86-based computer:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在基于32位x86的计算机上编译的函数：
- en: '[PRE17]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We compute the minimum amount of stack space required for local variables as
    76 bytes (three 4-byte integers and a 64-byte buffer). This function could use
    either `stdcall` or `cdecl`, and the stack frame will look the same. [Figure 6-3](ch06s02.html#an_esp-based_stack_frame
    "Figure 6-3. An ESP-based stack frame") shows one possible implementation of a
    stack frame for an invocation of `demo_stackframe`, assuming that no frame pointer
    register is used (thus the stack pointer, ESP, serves as the frame pointer). This
    frame would be set up on entry to `demo_stackframe` with the one-line prologue:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算局部变量所需的最小栈空间为76字节（三个4字节整数和一个64字节缓冲区）。此函数可以使用`stdcall`或`cdecl`，栈帧看起来将相同。[图6-3](ch06s02.html#an_esp-based_stack_frame
    "图6-3. 基于ESP的栈帧")显示了`demo_stackframe`调用的一种可能的栈帧实现，假设没有使用帧指针寄存器（因此栈指针ESP充当帧指针）。此栈帧将在`demo_stackframe`的入口处设置，使用一行前导代码：
- en: '[PRE18]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Offset column indicates the base+displacement address required to reference
    any of the local variables or parameters in the stack frame.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移列指示引用栈帧中任何局部变量或参数所需的基址+位移地址。
- en: '![An ESP-based stack frame](httpatomoreillycomsourcenostarchimages854129.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![基于ESP的栈帧](httpatomoreillycomsourcenostarchimages854129.png)'
- en: Figure 6-3. An ESP-based stack frame
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3. 基于ESP的栈帧
- en: 'Generating functions that utilize the stack pointer to compute all variable
    references requires a little more effort on the part of the compiler, as the stack
    pointer changes frequently and the compiler must make sure that proper offsets
    are used at all times when referencing any variables within the stack frame. Consider
    the call made to `bar` in function `demo_stackframe`, the code for which is shown
    here:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 生成利用栈指针计算所有变量引用的函数需要编译器付出更多努力，因为栈指针频繁变化，编译器必须确保在引用栈帧内的任何变量时始终使用正确的偏移量。考虑在 `demo_stackframe`
    函数中对 `bar` 的调用，其代码如下：
- en: '[PRE19]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `push` at ![](httpatomoreillycomsourcenostarchimages854061.png) correctly
    pushes local variable `y` per the offset in [Figure 6-3](ch06s02.html#an_esp-based_stack_frame
    "Figure 6-3. An ESP-based stack frame"). At first glance it might appear that
    the `push` at ![](httpatomoreillycomsourcenostarchimages854063.png) incorrectly
    references local variable `y` a second time. However, because we are dealing with
    an ESP-based frame and the `push` at ![](httpatomoreillycomsourcenostarchimages854061.png)
    modifies ESP, all of the offsets in [Figure 6-3](ch06s02.html#an_esp-based_stack_frame
    "Figure 6-3. An ESP-based stack frame") must be temporarily adjusted each time
    ESP changes. Following ![](httpatomoreillycomsourcenostarchimages854061.png),
    the new offset for local variable `z` becomes `[esp+4]` as correctly referenced
    in the `push` at ![](httpatomoreillycomsourcenostarchimages854063.png). When examining
    functions that reference stack frame variables using the stack pointer, you must
    be careful to note any changes to the stack pointer and adjust all future variable
    offsets accordingly. One advantage of using the stack pointer to reference all
    stack frame variables is that all other registers remain available for other purposes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![图](httpatomoreillycomsourcenostarchimages854061.png) 处的 `push` 指令正确地根据 [图
    6-3](ch06s02.html#an_esp-based_stack_frame "图 6-3. 基于 ESP 的栈帧") 中的偏移量将局部变量 `y`
    压入栈中。乍一看，![图](httpatomoreillycomsourcenostarchimages854063.png) 处的 `push` 指令似乎错误地再次引用了局部变量
    `y`。然而，因为我们处理的是基于 ESP 的帧，且 ![图](httpatomoreillycomsourcenostarchimages854061.png)
    处的 `push` 修改了 ESP，所以每当 ESP 发生变化时，[图 6-3](ch06s02.html#an_esp-based_stack_frame
    "图 6-3. 基于 ESP 的栈帧") 中的所有偏移量都必须临时调整。在 ![图](httpatomoreillycomsourcenostarchimages854061.png)
    之后，局部变量 `z` 的新偏移量变为 `[esp+4]`，正如 ![图](httpatomoreillycomsourcenostarchimages854063.png)
    处的 `push` 指令中所正确引用的那样。在检查使用栈指针引用栈帧变量的函数时，必须注意栈指针的任何变化，并相应地调整所有未来的变量偏移量。使用栈指针引用所有栈帧变量的一个优点是，所有其他寄存器都可用于其他目的。
- en: Once `demo_stackframe` has completed, it needs to return to the caller. Ultimately
    a `ret` instruction will be used to pop the desired return address off the top
    of the stack into the instruction pointer register (EIP in this case). Before
    the return address can be popped, the local variables need to be removed from
    the top of the stack so that the stack pointer correctly points to the saved return
    address when the `ret` instruction is executed. For this particular function the
    resulting epilogue becomes
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `demo_stackframe` 完成执行，它需要返回调用者。最终将使用 `ret` 指令从栈顶弹出所需的返回地址到指令指针寄存器（在本例中为
    EIP）。在返回地址弹出之前，需要从栈顶移除局部变量，以便在执行 `ret` 指令时栈指针能够正确地指向保存的返回地址。对于这个特定的函数，其结束部分变为
- en: '[PRE20]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At the expense of dedicating a register for use as a frame pointer and some
    code to configure the frame pointer on entry to the function, the job of computing
    local variable offsets can be made easier. In x86 programs, the EBP (*extended
    base pointer*) register is typically dedicated for use as a stack frame pointer.
    By default, most compilers generate code to use a frame pointer, though options
    typically exist for specifying that the stack pointer should be used instead.
    GNU gcc/g++, for example, offers the `-fomit-frame-pointer` compiler option, which
    generates functions that do not rely on a fixed-frame pointer register.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为帧指针分配一个寄存器并添加一些在函数入口配置帧指针的代码，可以简化计算局部变量偏移量的工作。在 x86 程序中，EBP（扩展基指针）寄存器通常被专门用于作为栈帧指针。默认情况下，大多数编译器生成的代码会使用帧指针，尽管通常存在指定应使用栈指针的选项。例如，GNU
    gcc/g++ 提供了 `-fomit-frame-pointer` 编译器选项，该选项生成的函数不依赖于固定的帧指针寄存器。
- en: 'In order to see what the stack frame for `demo_stackframe` will look like using
    a dedicated frame pointer, we need to consider this new prologue code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用专门的帧指针查看 `demo_stackframe` 的栈帧结构，我们需要考虑这个新的前导代码：
- en: '[PRE21]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `push` instruction at ![](httpatomoreillycomsourcenostarchimages854093.png)
    saves the value of EBP currently being used by the caller. Functions that adhere
    to the System V Application Binary Interface for Intel 32-bit Processors^([[43](#ftn.CHP-6-FN-2)])
    are allowed to modify the EAX, ECX, and EDX registers but are required to preserve
    the caller’s values for all other registers. Therefore, if we wish to use EBP
    as a frame pointer, we must save the current value of EBP before we change it,
    and we must restore the value of EBP before we return to the caller. If any other
    registers need to be saved on behalf of the caller (ESI or EDI, for example),
    compilers may choose to save them at the same time EBP is saved, or they may defer
    saving them until local variables have been allocated. Thus, there is no standard
    location within a stack frame for the storage of saved registers.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在![此处](httpatomoreillycomsourcenostarchimages854093.png)的`push`指令保存了调用者当前使用的EBP值。遵循Intel
    32位处理器System V应用程序二进制接口的函数^([[43](#ftn.CHP-6-FN-2)])允许修改EAX、ECX和EDX寄存器，但必须保留调用者所有其他寄存器的值。因此，如果我们想使用EBP作为帧指针，我们必须在更改它之前保存当前的EBP值，并且在返回调用者之前必须恢复EBP的值。如果需要代表调用者保存其他寄存器（例如ESI或EDI），编译器可以选择在保存EBP的同时保存它们，或者它们可以选择在分配局部变量之后延迟保存。因此，在堆栈帧中没有标准的位置用于保存已保存的寄存器。
- en: Once EBP has been saved, it can be changed to point to the current stack location.
    This is accomplished by the `mov` instruction at ![](httpatomoreillycomsourcenostarchimages854095.png),
    which copies the current value of the stack pointer into EBP. Finally, as in the
    non-EBP-based stack frame, space for local variables is allocated at ![](httpatomoreillycomsourcenostarchimages854099.png).
    The resulting stack frame layout is shown in [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame").
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 保存EBP之后，它可以改变以指向当前的堆栈位置。这是通过![此处](httpatomoreillycomsourcenostarchimages854095.png)的`mov`指令实现的，该指令将当前堆栈指针的值复制到EBP中。最后，就像在非EBP基于的堆栈帧中一样，在![此处](httpatomoreillycomsourcenostarchimages854099.png)分配了局部变量的空间。结果堆栈帧布局如图[6-4](ch06s02.html#an_ebp-based_stack_frame
    "图6-4. 基于EBP的堆栈帧")所示。
- en: '![An EBP-based stack frame](httpatomoreillycomsourcenostarchimages854131.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![基于EBP的堆栈帧](httpatomoreillycomsourcenostarchimages854131.png)'
- en: Figure 6-4. An EBP-based stack frame
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4. 基于EBP的堆栈帧
- en: 'With a dedicated frame pointer, all variable offsets are computed relative
    to the frame pointer register. It is most often (though not necessarily) the case
    that positive offsets are used to access function parameters, while negative offsets
    are required to access local variables. With a dedicated frame pointer in use,
    the stack pointer may be freely changed without affecting the offset to any variables
    within the frame. The call to function `bar` can now be implemented as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专门的帧指针，所有变量偏移量都是相对于帧指针寄存器计算的。通常情况下（尽管并非总是如此），正偏移量用于访问函数参数，而负偏移量用于访问局部变量。在使用专门的帧指针的情况下，栈指针可以自由更改，而不会影响帧内任何变量的偏移量。函数`bar`的调用现在可以如下实现：
- en: '[PRE22]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The fact that the stack pointer has changed following the `push` at ![](httpatomoreillycomsourcenostarchimages854101.png)
    has no effect on the access to local variable `z` in the succeeding `push`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在![此处](httpatomoreillycomsourcenostarchimages854101.png)的`push`之后栈指针的变化对后续`push`中对局部变量`z`的访问没有影响。
- en: 'Finally, the use of a frame pointer necessitates a slightly different epilogue
    once the function completes, as the caller’s frame pointer must be restored prior
    to returning. Local variables must be cleared from the stack before the old value
    of the frame pointer can be retrieved, but this is made easy by the fact that
    the current frame pointer points to the old frame pointer. In x86 programs utilizing
    EBP as a frame pointer, the following code represents a typical epilogue:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数完成后，使用帧指针需要稍微不同的结尾，因为调用者的帧指针必须在返回之前恢复。在恢复旧帧指针的旧值之前，必须从栈中清除局部变量，但这一点通过当前帧指针指向旧帧指针的事实变得容易。在利用EBP作为帧指针的x86程序中，以下代码代表了一个典型的结尾：
- en: '[PRE23]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This operation is so common that the x86 architecture offers the `leave` instruction
    as an abbreviated means of accomplishing the same task.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作如此常见，以至于x86架构提供了`leave`指令作为完成相同任务的简写方式。
- en: '[PRE24]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While the names of registers and instructions used will certainly differ for
    other processor architectures, the basic process of building stack frames will
    remain the same. Regardless of the architecture, you will want to familiarize
    yourself with typical prologue and epilogue sequences so that you can quickly
    move on to analyzing more interesting code within functions.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他处理器架构使用的寄存器和指令的名称肯定会不同，但构建栈帧的基本过程将保持不变。无论架构如何，你都应该熟悉典型的序言和尾声序列，这样你就可以快速转向分析函数内部更有趣的代码。
- en: IDA Stack Views
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA 栈视图
- en: Stack frames are clearly a runtime concept; a stack frame can’t exist without
    a stack and without a running program. While this is true, it doesn’t mean that
    you should ignore the concept of a stack frame when you are performing static
    analysis with tools such as IDA. All of the code required to set up stack frames
    for each function is present within a binary. Through careful analysis of this
    code, we can gain a detailed understanding of the structure of any function’s
    stack frame even when the function is not running. In fact, some of IDA’s most
    sophisticated analysis is performed specifically to determine the layout of stack
    frames for every function that IDA disassembles. During initial analysis, IDA
    goes to great lengths to monitor the behavior of the the stack pointer over the
    course of a function by making note of every `push` or `pop` operation along with
    any arithmetic operations that may change the stack pointer, such as adding or
    subtracting constant values. The first goal of this analysis is to determine the
    exact size of the local variable area allocated to a function’s stack frame. Additional
    goals include determining whether a dedicated frame pointer is in use in a given
    function (by recognizing a `push ebp/mov ebp, esp` sequence, for example) and
    recognizing all memory references to variables within a function’s stack frame.
    For example, if IDA noted the following instruction in the body of `demo_stackframe`
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 栈帧显然是一个运行时概念；没有栈和没有正在运行程序，栈帧就无法存在。虽然这是真的，但这并不意味着你在使用ID等工具进行静态分析时应该忽略栈帧的概念。为每个函数设置栈帧所需的全部代码都包含在二进制文件中。通过仔细分析这段代码，我们可以在函数未运行时对其栈帧结构获得详细的理解。实际上，IDA的一些最复杂分析正是为了确定IDA反汇编的每个函数的栈帧布局。在初始分析期间，IDA会不遗余力地通过记录每次`push`或`pop`操作以及可能改变栈指针的算术操作（如添加或减去常量值）来监控函数执行过程中栈指针的行为。这次分析的首要目标是确定分配给函数栈帧的局部变量区域的确切大小。其他目标包括确定在给定函数中是否使用了专用帧指针（例如，通过识别`push
    ebp/mov ebp, esp`序列）以及识别函数栈帧内所有变量的内存引用。例如，如果IDA在`demo_stackframe`的主体中注意到以下指令：
- en: '[PRE25]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: it would understand that the first argument to the function (`a` in this case)
    is being loaded into the EAX register (refer to [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame")). Through careful analysis of the stack
    frame structure, IDA can distinguish between memory references that access function
    arguments (those that lie below the saved return address) and references that
    access local variables (those that lie above the saved return address). IDA takes
    the additional step of determining which memory locations within a stack frame
    are directly referenced. For example, while the stack frame in [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame") is 96 bytes in size, there are only seven
    variables that we are likely to see referenced (four locals and three parameters).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 它会理解函数的第一个参数（在这种情况下是`a`）被加载到EAX寄存器中（参见图6-4）。通过仔细分析栈帧结构，IDA可以区分访问函数参数（位于保存的返回地址下方）和访问局部变量（位于保存的返回地址上方）的内存引用。IDA还采取额外的步骤来确定栈帧中哪些内存位置被直接引用。例如，虽然图6-4中的栈帧大小为96字节，但我们可能只会看到七个变量被引用（四个局部变量和三个参数）。
- en: 'Understanding the behavior of a function often comes down to understanding
    the types of data that the function manipulates. When reading a disassembly listing,
    one of the first opportunities that you will have to understand the data a function
    manipulates is to view the breakdown of the function’s stack frame. IDA offers
    two views into any function’s stack frame: a summary view and a detail view. In
    order to understand these two views, we will refer to the following version of
    `demo_stackframe`, which we have compiled using gcc.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 理解函数的行为通常归结于理解函数操作的数据类型。在阅读反汇编列表时，你将有机会了解函数操作的数据，那就是查看函数栈帧的分解。IDA 为任何函数的栈帧提供两种视图：总结视图和详细视图。为了理解这两种视图，我们将参考以下使用
    gcc 编译的 `demo_stackframe` 版本。
- en: '[PRE26]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, local variables `x` and `y` are initialized from parameters
    `c` and `b`, respectively. Local variable `z` is initialized with the constant
    value 10, and the first character in the 64-byte local array, named `buffer`,
    is initialized to the letter `'A'`. The corresponding IDA disassembly of this
    function appears here.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，局部变量 `x` 和 `y` 分别从参数 `c` 和 `b` 初始化。局部变量 `z` 使用常量值 10 初始化，64 字节局部数组 `buffer`
    的第一个字符初始化为字母 `'A'`。这个函数对应的 IDA 反汇编代码如下。
- en: '[PRE27]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are many points to cover in this listing as we begin to acquaint ourselves
    with IDA’s disassembly notation. We begin at ![](httpatomoreillycomsourcenostarchimages854061.png)
    by noting that IDA believes this function uses the EBP register as a frame pointer
    based on analysis of the function prologue. At ![](httpatomoreillycomsourcenostarchimages854063.png)
    we learn that gcc has allocated 120 bytes (78h equates to 120) of local variable
    space in the stack frame. This includes 8 bytes for passing the two parameters
    to `bar` at ![](httpatomoreillycomsourcenostarchimages854093.png), but it is still
    far greater than the 76 bytes we had estimated previously and demonstrates that
    compilers occasionally pad the local variable space with extra bytes in order
    to ensure a particular alignment within the stack frame. Beginning at ![](httpatomoreillycomsourcenostarchimages854095.png),
    IDA provides a summary stack view that lists every variable that is directly referenced
    within the stack frame, along with the variable’s size and offset distance from
    the frame pointer.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始熟悉 IDA 的反汇编符号时，这个列表中有许多要点需要涵盖。我们从 ![](httpatomoreillycomsourcenostarchimages854061.png)
    开始，注意到 IDA 根据对函数前导的分析认为这个函数使用 EBP 寄存器作为帧指针。在 ![](httpatomoreillycomsourcenostarchimages854063.png)
    我们了解到 gcc 在栈帧中为局部变量分配了 120 字节（78h 等于 120）的空间。这包括为在 ![](httpatomoreillycomsourcenostarchimages854093.png)
    处的 `bar` 函数传递两个参数而分配的 8 字节，但这仍然远大于我们之前估计的 76 字节，并表明编译器有时会通过额外的字节填充局部变量空间，以确保栈帧中的特定对齐。从
    ![](httpatomoreillycomsourcenostarchimages854095.png) 开始，IDA 提供了一个总结的栈视图，列出了在栈帧中直接引用的每个变量，以及变量的大小和从帧指针的偏移距离。
- en: IDA assigns names to variables based on their location relative to the saved
    return address. Local variables lie above the saved return address, while function
    parameters lie below the saved return address. Local variable names are derived
    using the `var_` prefix joined with a hexadecimal suffix that indicates the distance,
    in bytes, that the variable lies above the saved frame pointer. Local variable
    `var_C`, in this case, is a 4-byte (dword) variable that lies 12 bytes above the
    saved frame pointer (`[ebp-0Ch]`). Function parameter names are generated using
    the `arg_` prefix combined with a hexadecimal suffix that represents the relative
    distance from the topmost parameter. Thus the topmost 4-byte parameter would be
    named `arg_0`, while successive parameters would be named `arg_4`, `arg_8`, `arg_C`,
    and so on. In this particular example `arg_0` is not listed because the function
    makes no use of parameter `a`. Because IDA fails to locate any memory reference
    to `[ebp+8]` (the location of the first parameter), `arg_0` is not listed in the
    summary stack view. A quick scan of the summary stack view reveals that there
    are many stack locations that IDA has failed to name because no direct references
    to those locations exist in the program code.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: IDA根据变量相对于保存的返回地址的位置来分配变量名称。局部变量位于保存的返回地址之上，而函数参数位于保存的返回地址之下。局部变量名称是通过使用`var_`前缀与表示变量相对于保存的帧指针的字节距离的十六进制后缀结合来派生的。在这个例子中，局部变量`var_C`是一个4字节（dword）变量，位于保存的帧指针之上12字节（`[ebp-0Ch]`）。函数参数名称是通过使用`arg_`前缀与表示从最高参数的相对距离的十六进制后缀结合来生成的。因此，最顶部的4字节参数将被命名为`arg_0`，而后续的参数将被命名为`arg_4`、`arg_8`、`arg_C`等等。在这个特定的例子中，`arg_0`没有被列出，因为该函数没有使用参数`a`。由于IDA未能定位到
    `[ebp+8]`（第一个参数的位置）的任何内存引用，`arg_0`在总结栈视图中没有被列出。快速扫描总结栈视图可以发现，由于程序代码中不存在对这些位置的直接引用，IDA未能为许多栈位置命名。
- en: Note
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The only stack variables that IDA will automatically generate names for are
    those that are directly referenced within a function.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: IDA将自动为那些在函数内部直接引用的栈变量生成名称。
- en: An important difference between IDA’s disassembly listing and the stack frame
    analysis that we performed earlier is the fact that nowhere in the disassembly
    listing do we see memory references similar to `[ebp-12]`. Instead, IDA has replaced
    all constant offsets with symbolic names corresponding to the symbols in the stack
    view and their relative offsets from the stack frame pointer. This is in keeping
    with IDA’s goal of generating a higher-level disassembly. It is simply easier
    to deal with symbolic names than numeric constants. In fact, as we will see later,
    IDA allows us to change the names of any stack variable to whatever we wish, making
    the names that much easier for us to remember. The summary stack view serves as
    a map from IDA-generated names to their corresponding stack frame offsets. For
    example, where the memory reference `[ebp+arg_8]` appears in the disassembly,
    `[ebp+10h]` or `[ebp+16]` could be used instead. If you prefer numeric offsets,
    IDA will happily show them to you. Right-clicking `arg_8` at ![](httpatomoreillycomsourcenostarchimages854099.png)
    yields the context-sensitive menu shown in [Figure 6-5](ch06s02.html#selecting_an_alternate_display_format
    "Figure 6-5. Selecting an alternate display format"), which contains several options
    to change the display format.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的汇编列表与我们之前执行的栈帧分析之间的重要区别在于，在汇编列表中我们看不到类似于 `[ebp-12]` 的内存引用。相反，IDA用与栈视图中的符号及其相对于栈帧指针的相对偏移相对应的符号名称替换了所有常量偏移。这与IDA生成高级汇编的目标相一致。处理符号名称比处理数字常数要简单得多。实际上，正如我们稍后将看到的，IDA允许我们将任何栈变量的名称更改为我们想要的任何名称，这使得名称更容易记住。总结栈视图充当从IDA生成的名称到其对应的栈帧偏移的映射。例如，在汇编中出现的内存引用
    `[ebp+arg_8]`，可以使用 `[ebp+10h]` 或 `[ebp+16]` 代替。如果您更喜欢数字偏移，IDA会乐意向您展示。在![httpatomoreillycomsourcenostarchimages854099.png](httpatomoreillycomsourcenostarchimages854099.png)处的`arg_8`上右键单击，会显示[图6-5](ch06s02.html#selecting_an_alternate_display_format
    "图6-5. 选择一个替代显示格式")中所示的相关上下文菜单，其中包含几个更改显示格式的选项。
- en: '![Selecting an alternate display format](httpatomoreillycomsourcenostarchimages854137.png.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![选择一个替代显示格式](httpatomoreillycomsourcenostarchimages854137.png.jpg)'
- en: Figure 6-5. Selecting an alternate display format
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5. 选择一个替代显示格式
- en: In this example, since we have source code available for comparison, we can
    map the IDA-generated variable names back to the names used in the original source
    using a variety of clues available in the disassembly.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于我们有可用的源代码进行比较，我们可以使用反汇编中可用的各种线索将IDA生成的变量名映射回原始源代码中使用的名称。
- en: 'First, `demo_stackframe` takes three parameters: `a`, `b`, and `c`. These correspond
    to variables `arg_0`, `arg_4`, and `arg_8` respectively (though `arg_0` is missing
    in the disassembly because it is never referenced).'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`demo_stackframe`函数接受三个参数：`a`、`b`和`c`。它们分别对应于变量`arg_0`、`arg_4`和`arg_8`（尽管`arg_0`在反汇编中缺失，因为它从未被引用过）。
- en: Local variable `x` is initialized from parameter `c`. Thus `var_C` corresponds
    to `x` since it is initialized from `arg_8` at ![](httpatomoreillycomsourcenostarchimages854101.png).
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部变量`x`是从参数`c`初始化的。因此`var_C`对应于`x`，因为它是从`arg_8`初始化的，如![更多](httpatomoreillycomsourcenostarchimages854101.png)所示。
- en: Similarly, local variable `y` is initialized from parameter `b`. Thus, `var_5C`
    corresponds to `y` since it is initialized from `arg_4` at ![](httpatomoreillycomsourcenostarchimages854103.png).
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，局部变量`y`是从参数`b`初始化的。因此，`var_5C`对应于`y`，因为它是从`arg_4`初始化的，如![更多](httpatomoreillycomsourcenostarchimages854103.png)所示。
- en: Local variable `z` corresponds to `var_60` since it is initialized with the
    value 10 at ![](httpatomoreillycomsourcenostarchimages854133.png).
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部变量`z`对应于`var_60`，因为它初始化为10，如![更多](httpatomoreillycomsourcenostarchimages854133.png)所示。
- en: The 64-byte character array `buffer` begins at `var_58` since `buffer[0]` is
    initialized with *A* (ASCII 0x41) at ![](httpatomoreillycomsourcenostarchimages854135.png).
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 64字节的字符数组`buffer`从`var_58`开始，因为`buffer[0]`被初始化为*A*（ASCII 0x41），如![更多](httpatomoreillycomsourcenostarchimages854135.png)所示。
- en: The two arguments for the call to `bar` are moved into the stack at ![](httpatomoreillycomsourcenostarchimages854093.png)
    rather than being pushed onto the stack. This is typical of current versions of
    gcc (versions 3.4 and later). IDA recognizes this convention and elects not to
    create local variable references for the two items at the top of the stack frame.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`bar`时，两个参数被移动到堆栈中![更多](httpatomoreillycomsourcenostarchimages854093.png)，而不是推送到堆栈。这在当前版本的gcc（版本3.4及以后）中很典型。IDA识别这个约定，并选择不为堆栈帧顶部的两个项目创建局部变量引用。
- en: In addition to the summary stack view, IDA offers a detailed stack frame view
    in which every byte allocated to a stack frame is accounted for. The detailed
    view is accessed by double-clicking any variable name associated with a given
    stack frame. Double-clicking `var_C` in the previous listing would bring up the
    stack frame view shown in [Figure 6-6](ch06s02.html#ida_stack_frame_view "Figure 6-6. IDA
    stack frame view") (esc closes the window).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 除了总结堆栈视图之外，IDA还提供了一个详细的堆栈帧视图，其中对分配给每个堆栈帧的每个字节都进行了记录。通过双击与给定堆栈帧相关联的任何变量名可以访问详细视图。双击前一个列表中的`var_C`将显示[图6-6](ch06s02.html#ida_stack_frame_view
    "图6-6. IDA堆栈帧视图")中所示的堆栈帧视图（按Esc键关闭窗口）。
- en: '![IDA stack frame view](httpatomoreillycomsourcenostarchimages854139.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![IDA堆栈帧视图](httpatomoreillycomsourcenostarchimages854139.png)'
- en: Figure 6-6. IDA stack frame view
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6. IDA堆栈帧视图
- en: Because the detailed view accounts for every byte in the stack frame, it occupies
    significantly more space than the summary view, which lists only referenced variables.
    The portion of the stack frame shown in [Figure 6-6](ch06s02.html#ida_stack_frame_view
    "Figure 6-6. IDA stack frame view") spans a total of 32 bytes, which represents
    only a small portion of the entire stack frame. Note that no names are assigned
    to bytes that are not referenced directly within the function. For example, parameter
    `a`, corresponding to `arg_0`, was never referenced within `demo_stackframe`.
    With no memory reference to analyze, IDA opts to do nothing with the corresponding
    bytes in the stack frame, which occupy offsets `+00000008` through `+0000000B`.
    On the other hand, `arg_4` was directly referenced at ![](httpatomoreillycomsourcenostarchimages854103.png)
    in the disassembly listing, where its contents were loaded into the 32-bit EAX
    register. Based on the fact that 32 bits of data were moved, IDA is able to infer
    that the `arg_4` is a 4-byte quantity and labels it as such (`db` defines 1 byte
    of storage; `dw` defines 2 bytes of storage, also called a *word*; and `dd` defines
    4 bytes of storage, also called a *double word*).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于详细视图考虑了堆栈帧中的每一个字节，它占用的空间比只列出引用变量的摘要视图大得多。在[图6-6](ch06s02.html#ida_stack_frame_view
    "图6-6. IDA堆栈帧视图")中显示的堆栈帧部分总共占用32字节，这仅代表整个堆栈帧的一小部分。请注意，没有直接在函数内部引用的字节没有被分配名称。例如，参数`a`对应于`arg_0`，在`demo_stackframe`中从未被引用。由于没有内存引用进行分析，IDA选择不对堆栈帧中相应的字节进行操作，这些字节占用偏移量`+00000008`到`+0000000B`。另一方面，`arg_4`在反汇编列表中的![](httpatomoreillycomsourcenostarchimages854103.png)处被直接引用，其内容被加载到32位EAX寄存器中。基于移动了32位数据的事实，IDA能够推断出`arg_4`是一个4字节量，并将其标记为这样（`db`定义1字节的存储；`dw`定义2字节的存储，也称为*字*；`dd`定义4字节的存储，也称为*双字*）。
- en: Two special values shown in [Figure 6-6](ch06s02.html#ida_stack_frame_view "Figure 6-6. IDA
    stack frame view") are “ `s`” and “ `r`” (each starts with a leading space). These
    pseudo variables are IDA’s special representation of the saved return address
    (“ `r`”) and the saved register value(s) (“ `s`” representing only EBP in this
    example). These values are included in the stack frame view for completeness,
    as every byte in the stack frame is accounted for.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-6](ch06s02.html#ida_stack_frame_view "图6-6. IDA堆栈帧视图")中显示的两个特殊值是“ `s`”和“
    `r`”（每个都以一个前置空格开头）。这些伪变量是IDA对保存的返回地址（“ `r`”）和保存的寄存器值（在本例中，“ `s`”仅代表EBP）的特殊表示。这些值包含在堆栈帧视图中以保持完整性，因为堆栈帧中的每一个字节都被考虑在内。
- en: Stack frame view offers a detailed look at the inner workings of compilers.
    In [Figure 6-6](ch06s02.html#ida_stack_frame_view "Figure 6-6. IDA stack frame
    view") it is clear that the compiler has inserted 8 extra bytes between the saved
    frame pointer “ `s`” and the local variable `x` (`var_C`). These bytes occupy
    offsets `−00000001` through `−00000008` in the stack frame. Further, a little
    math performed on the offset associated with each variable listed in the summary
    view reveals that the compiler has allocated 76 (rather than 64 per the source
    code) bytes to the character buffer at `var_58`. Unless you happen to be a compiler
    writer yourself or are willing to dig deep into the source code for gcc, all you
    can do is speculate as to why these extra bytes are allocated in this manner.
    In most cases we can chalk up the extra bytes to padding for alignment, and usually
    the presence of these extra bytes has no impact on a program’s behavior. After
    all, if a programmer asks for 64 bytes and is given 76, the program should behave
    no differently, especially since the programmer shouldn’t be using more than the
    64 bytes requested. On the other hand, if you happen to be an exploit developer
    and learn that it is possible to overflow this particular buffer, then you might
    be very interested in the fact that nothing interesting can even begin to happen
    until you have supplied at least 76 bytes, which is the effective size of the
    buffer as far as the compiler is concerned. In [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures") we will return to the stack frame view and its uses in dealing
    with more complex datatypes such as arrays and structures.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 栈帧视图提供了对编译器内部工作原理的详细观察。在[图6-6](ch06s02.html#ida_stack_frame_view "图6-6. IDA栈帧视图")中可以清楚地看到，编译器在保存的帧指针“`s`”和局部变量`x`(`var_C`)之间插入了8个额外的字节。这些字节占据了栈帧中的`−00000001`到`−00000008`的偏移量。此外，对总结视图中列出的每个变量的偏移量进行一些数学运算，可以发现编译器为`var_58`中的字符缓冲区分配了76个字节（而不是源代码中的64个字节）。除非你恰好是编译器编写者或者愿意深入研究gcc的源代码，否则你所能做的就是推测为什么以这种方式分配这些额外的字节。在大多数情况下，我们可以将这些额外的字节归因于对齐的填充，并且通常这些额外的字节对程序的行为没有影响。毕竟，如果一个程序员请求64个字节并得到了76个字节，程序的行为应该没有不同，尤其是程序员不应该使用超过请求的64个字节。另一方面，如果你恰好是漏洞开发者并且了解到可以溢出这个特定的缓冲区，那么你可能会对这样一个事实非常感兴趣：直到你提供了至少76个字节，也就是编译器所认为的缓冲区的有效大小，才可能发生任何有趣的事情。在[第8章](ch08.html
    "第8章. 数据类型和数据结构")中，我们将回到栈帧视图及其在处理更复杂的类型，如数组和结构体时的用途。
- en: '* * *'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[42](#CHP-6-FN-1)]) A *frame pointer* is a register that points to a location
    inside a stack frame. Variables within the stack frame are typically referenced
    by their relative distance from the location to which the frame pointer points.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[42](#CHP-6-FN-1)]) 栈帧指针是一个指向栈帧内部位置的寄存器。栈帧内的变量通常通过它们与栈帧指针指向的位置的相对距离来引用。
- en: ^([[43](#CHP-6-FN-2)]) See [http://www.sco.com/developers/devspecs/abi386-4.pdf](http://www.sco.com/developers/devspecs/abi386-4.pdf).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[43](#CHP-6-FN-2)]) 见[http://www.sco.com/developers/devspecs/abi386-4.pdf](http://www.sco.com/developers/devspecs/abi386-4.pdf)。
- en: Searching the Database
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索数据库
- en: 'IDA makes it easy to navigate to things that you know about and designs many
    of its data displays to summarize specific types of information (names, strings,
    imports, and so on), making them easy to find as well. However, what features
    are offered to help you conduct more general searches through your databases?
    If you take time to review the contents of the Search menu, you will find a long
    list of options, the majority of which take you to the next item in some category.
    For example, Search ▸ Next Code moves the cursor to the next location containing
    an instruction. You may also wish to familiarize yourself with the options available
    on the Jump menu. For many of these, you are presented with a list of locations
    to choose from. Jump ▸ Jump to Function, for example, brings up a list of all
    functions, allowing you to quickly choose one and navigate to it. While these
    canned search features may often be useful, two types of general-purpose searches
    are worth more detailed discussion: text searches and binary searches.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 使您能够轻松导航到已知的内容，并设计了许多数据显示来总结特定类型的信息（名称、字符串、导入等），使它们也易于查找。然而，提供了哪些功能来帮助您在数据库中进行更通用的搜索？如果您花时间查看搜索菜单的内容，您会发现一个长长的选项列表，其中大部分会将您带到某个类别的下一个项目。例如，搜索
    ▸ 下一个代码会将光标移动到包含指令的下一个位置。您还可能希望熟悉跳转菜单上的选项。对于这些选项中的许多，您将看到一个可以选择的位置列表。例如，跳转 ▸ 跳转到函数会弹出一个包含所有函数的列表，让您可以快速选择一个并导航到它。虽然这些预定义的搜索功能可能经常很有用，但两种通用搜索类型值得更详细的讨论：文本搜索和二进制搜索。
- en: Text Searches
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本搜索
- en: 'IDA text searches amount to substring searches through the disassembly listing
    view. Text searches are initiated via Search ▸ Text (hotkey: alt-T), which opens
    the dialog shown in [Figure 6-7](ch06s03.html#text_search_dialog "Figure 6-7. Text
    Search dialog"). A number of self-explanatory options dictate specific details
    concerning the search to be performed. As shown, POSIX-style regular expressions
    are permitted. The *Identifier* search is somewhat misnamed. In reality it restricts
    the search to find whole words only and can match any whole word on an assembly
    line, including opcode mnemonics or constant values. An Identifier search for
    `401116` would fail to find a symbol named `loc_401116`.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的文本搜索相当于在反汇编列表视图中进行子串搜索。文本搜索通过搜索 ▸ 文本（快捷键：alt-T）启动，打开如图 [图 6-7](ch06s03.html#text_search_dialog
    "图 6-7. 文本搜索对话框") 所示的对话框。一些自解释的选项规定了要执行搜索的具体细节。如图所示，允许使用 POSIX 风格的正则表达式。*标识符*搜索的名称有些误导。实际上，它限制搜索只查找整个单词，并且可以匹配汇编行上的任何整个单词，包括操作码助记符或常量值。对
    `401116` 的标识符搜索将无法找到名为 `loc_401116` 的符号。
- en: Selecting *Find all occurences* causes the search results to be opened in a
    new window, allowing easy navigation to any single match of the search criteria.
    Finally, the previous search can be repeated to locate the next match using ctrl-T
    or Search ▸ Next Text.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 选择*查找所有匹配项*会导致搜索结果在一个新窗口中打开，允许轻松导航到任何单个匹配项。最后，可以使用 ctrl-T 或搜索 ▸ 下一个文本重复之前的搜索以定位下一个匹配项。
- en: '![Text Search dialog](httpatomoreillycomsourcenostarchimages854141.png.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![文本搜索对话框](httpatomoreillycomsourcenostarchimages854141.png.jpg)'
- en: Figure 6-7. Text Search dialog
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7. 文本搜索对话框
- en: Binary Searches
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制搜索
- en: If you need to search for specific binary content such as a known sequence of
    bytes, then text searches are not the answer. Instead, you need to use IDA’s binary
    search facilities. While the text search searches the disassembly window, the
    binary search will search only the content portion of the Hex View window. Either
    the hex dump or the ASCII dump can be searched, depending on how the search string
    is specified. A binary search is initiated using Search ▸ Sequence of Bytes, or
    alt-B. [Figure 6-8](ch06s03.html#binary_search_dialog "Figure 6-8. Binary Search
    dialog") shows the Binary Search dialog. To search for a sequence of hex bytes,
    the search string should be specified as a space-separated list of two-digit hex
    values such as `CA FE BA BE`, which offers identical behavior as a search for
    `ca fe ba be`, despite the availability of a Case-sensitive option.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要搜索特定的二进制内容，例如已知的字节序列，则文本搜索不是答案。相反，你需要使用IDA的二进制搜索功能。虽然文本搜索搜索反汇编窗口，但二进制搜索将只搜索十六进制视图窗口的内容部分。可以搜索十六进制转储或ASCII转储，具体取决于如何指定搜索字符串。使用“搜索
    ▸ 字节序列”或alt-B启动二进制搜索。[图6-8](ch06s03.html#binary_search_dialog "图6-8. 二进制搜索对话框")显示了二进制搜索对话框。要搜索一系列十六进制字节，搜索字符串应指定为两个十六进制值的空间分隔列表，例如`CA
    FE BA BE`，这提供了与搜索`ca fe ba be`相同的行为，尽管有“区分大小写”选项可用。
- en: To alternatively search for embedded string data (effectively searching the
    ASCII dump portion of the Hex View window), you must surround the search strings
    with quotes. Use the Unicode strings option to search for the Unicode version
    of your search string.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索嵌入的字符串数据（实际上是在搜索十六进制视图窗口的ASCII转储部分），你必须用引号包围搜索字符串。使用Unicode字符串选项来搜索搜索字符串的Unicode版本。
- en: The Case-sensitive option can be a cause of confusion. For string searches it
    is fairly straightforward; a search for “hello” will successfully find “HELLO”
    if Case-sensitive is not selected. Things get a little interesting if you perform
    a hex search and leave Case-sensitive unchecked. If you conduct a case-insensitive
    search for `E9 41 C3`, you may be surprised when your search matches `E9 61 C3`.
    The two strings are considered to match because 0x41 corresponds to the character
    *A* while 0x61 corresponds to *a*. So, even though you have specified a hex search,
    0x41 is considered equivalent to 0x61 because you failed to specify a case-sensitive
    search.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: “区分大小写”选项可能会引起混淆。对于字符串搜索来说，这相当直接；如果没有选择“区分大小写”，则搜索“hello”将成功找到“HELLO”。如果你执行了十六进制搜索并且没有勾选“区分大小写”，事情会变得有点有趣。如果你对`E9
    41 C3`进行不区分大小写的搜索，当你发现搜索匹配`E9 61 C3`时可能会感到惊讶。这两个字符串被认为是匹配的，因为0x41对应于字符*A*，而0x61对应于*a*。所以，即使你指定了十六进制搜索，0x41也被认为是等同于0x61的，因为你没有指定区分大小写的搜索。
- en: '![Binary Search dialog](httpatomoreillycomsourcenostarchimages854143.png.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![二进制搜索对话框](httpatomoreillycomsourcenostarchimages854143.png.jpg)'
- en: Figure 6-8. Binary Search dialog
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8. 二进制搜索对话框
- en: Note
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When conducting hex searches, make sure that you specify Case-sensitive if you
    want to restrict the search to exact matches. This is important if you are searching
    for specific opcode sequences rather than ASCII text.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行十六进制搜索时，确保如果你想要将搜索限制为精确匹配，则指定“区分大小写”。如果你正在搜索特定的操作码序列而不是ASCII文本，这一点非常重要。
- en: Searching for subsequent matches for binary data is done using ctrl-B or Search
    ▸ Next Sequence of Bytes. Finally, it is not necessary to conduct your binary
    searches from within the Hex View window. IDA allows you to specify binary search
    criteria while the disassembly view is active, in which case a successful search
    will jump the disassembly window to the location whose underlying bytes match
    the specified search criteria.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ctrl-B或“搜索 ▸ 下一个字节序列”来搜索二进制数据的后续匹配。最后，没有必要在十六进制视图窗口内进行二进制搜索。IDA允许你在反汇编视图活动时指定二进制搜索条件，在这种情况下，成功的搜索将跳转到与指定搜索条件匹配的底层字节的位置。
- en: Summary
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The intent of this chapter was to provide you with the minimum essential skills
    for effectively making your way around a disassembly. The overwhelming majority
    of your interactions with IDA will involve the operations that we have discussed
    so far. With navigation safely under your belt, the logical next step is learning
    how to modify IDA databases to suit your particular needs. In the next chapter
    we begin to look at how to make the most basic changes to a disassembly as a means
    of adding new knowledge based on our understanding of a binary’s content and behavior.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是为你提供有效导航反汇编所需的最基本技能。你与IDA的大多数交互将涉及我们迄今为止讨论的操作。在安全掌握导航之后，下一个合乎逻辑的步骤是学习如何修改IDA数据库以适应你的特定需求。在下一章中，我们将开始探讨如何通过理解二进制的内容和行为来添加新知识，从而对反汇编进行最基本的更改。
- en: Chapter 7. Disassembly Manipulation
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 反汇编操作
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: After navigation, the next most significant features of IDA are designed to
    allow you to modify the disassembly to suit your needs. In this chapter we will
    show that because of IDA’s underlying database nature, changes that you make to
    a disassembly are easily propagated to all IDA subviews to maintain a consistent
    picture of your disassembly. One of the most powerful features that IDA offers
    is the ability to easily manipulate disassemblies to add new information or reformat
    a listing to suit your particular needs. IDA automatically handles operations
    such as global search and replace when it makes sense to do so and makes trivial
    work of reformatting instructions and data and vice versa, features not available
    in other disassembly tools.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 导航之后，IDA的下一个最重要的功能设计是为了让你能够修改反汇编代码以适应你的需求。在本章中，我们将展示由于IDA的底层数据库特性，你对反汇编所做的更改可以轻松传播到IDA的所有子视图中，以保持反汇编的一致性视图。IDA提供的一项最强大的功能是能够轻松地操作反汇编代码，以添加新信息或重新格式化列表以适应你的特定需求。当这样做有意义时，IDA会自动处理全局搜索和替换等操作，并将重新格式化指令和数据以及反之的操作变得简单，这些功能在其他反汇编工具中不可用。
- en: Note
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember: There is no undo in IDA. Keep this in mind as you start manipulating
    the database. The closest you’re going to get is saving the database often and
    reverting to a recently saved version of the database.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：在IDA中没有撤销操作。在你开始操作数据库时，请记住这一点。你所能得到的最佳选择是经常保存数据库，并回滚到最近保存的数据库版本。
- en: Names and Naming
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称和命名
- en: 'At this point, we have encountered two categories of names in IDA disassemblies:
    names associated with virtual addresses (named locations) and names associated
    with stack frame variables. In the majority of cases IDA will automatically generate
    all of these names according to the guidelines previously discussed. IDA refers
    to such automatically generated names as *dummy names*.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在IDA反汇编中遇到了两类名称：与虚拟地址（命名位置）相关的名称和与栈帧变量相关的名称。在大多数情况下，IDA将自动根据之前讨论的指南生成所有这些名称。IDA将这些自动生成的名称称为*占位名称*。
- en: Unfortunately, these names seldom hint at the intended purpose of a location
    or variable and therefore don’t generally add to our understanding of a program’s
    behavior. As you begin to analyze any program, one of the first and most common
    ways that you will want to manipulate a disassembly listing is to change default
    names into more meaningful names. Fortunately, IDA allows you to easily change
    any name and handles all of the details of propagating all name changes throughout
    the entire disassembly. In most cases, changing a name is as simple as clicking
    the name you wish to change (this highlights the name) and using the N hotkey
    to open a name-change dialog. Alternatively, right-clicking the name to be changed
    generally presents a context-sensitive menu that contains a Rename option, as
    shown in [Figure 6-5](ch06s02.html#selecting_an_alternate_display_format "Figure 6-5. Selecting
    an alternate display format"). The name-change process does differ somewhat between
    stack variables and named locations, and these differences are detailed in the
    following sections.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些名称很少暗示位置或变量的预期用途，因此通常不会增加我们对程序行为的理解。当你开始分析任何程序时，你将想要操纵反汇编列表的第一种和最常见的方法之一是将默认名称更改为更有意义的名称。幸运的是，IDA
    允许你轻松地更改任何名称，并处理在整个反汇编中传播所有名称更改的所有细节。在大多数情况下，更改名称就像单击你想要更改的名称（这将突出显示名称）并使用 N 快捷键打开名称更改对话框一样简单。或者，右键单击要更改的名称通常会出现一个上下文相关的菜单，其中包含一个重命名选项，如图
    [图 6-5](ch06s02.html#selecting_an_alternate_display_format "图 6-5. 选择另一种显示格式")
    所示。名称更改过程在栈变量和命名位置之间略有不同，这些差异将在以下各节中详细说明。
- en: Parameters and Local Variables
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数和局部变量
- en: Names associated with stack variables are the simplest form of name in a disassembly
    listing, primarily because they are not associated with a specific virtual address
    and thus can never appear in the Names window. As in most programming languages,
    such names are considered to be restricted in scope based on the function to which
    a given stack frame belongs. Thus, every function in a program might have its
    own stack variable named `arg_0`, but no function may have more than one variable
    named `arg_0`. The dialog shown in [Figure 7-1](ch07.html#renaming_a_stack_variable
    "Figure 7-1. Renaming a stack variable") is used to rename a stack variable.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 与栈变量关联的名称是反汇编列表中最简单的名称形式，主要是因为它们与特定的虚拟地址无关，因此永远不会出现在名称窗口中。与大多数编程语言一样，这些名称被认为是基于给定栈帧所属的函数的作用域受限。因此，程序中的每个函数可能都有自己的名为
    `arg_0` 的栈变量，但没有任何函数可以有多个名为 `arg_0` 的变量。用于重命名栈变量的对话框如图 [图 7-1](ch07.html#renaming_a_stack_variable
    "图 7-1. 重命名栈变量") 所示。
- en: '![Renaming a stack variable](httpatomoreillycomsourcenostarchimages854145.png.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![重命名栈变量](http://atomoreilly.com/source/nostarch/images/854145.png.jpg)'
- en: Figure 7-1. Renaming a stack variable
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1. 重命名栈变量
- en: Once a new name is supplied, IDA takes care of changing every occurrence of
    the old name in the context of the current function. Changing the name of `var_5C`
    to `y` for `demo_stackframe` would result in the new listing shown here, with
    changes at ![](httpatomoreillycomsourcenostarchimages854061.png).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供了新的名称，IDA 会负责更改当前函数上下文中旧名称的所有出现。将 `var_5C` 的名称更改为 `y` 用于 `demo_stackframe`
    将导致此处显示的新列表，其中包含在 ![图](http://atomoreilly.com/source/nostarch/images/854061.png)
    的更改。
- en: '[PRE28]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Should you ever wish to revert to the default name for a given variable, open
    the renaming dialog and enter a blank name, and IDA will regenerate the default
    name for you.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望恢复给定变量的默认名称，请打开重命名对话框并输入一个空名称，IDA 将为你生成默认名称。
- en: Named Locations
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名位置
- en: Renaming a named location or adding a name to an unnamed location is slightly
    different from changing the name of a stack variable. The process for accessing
    the name-change dialog is identical (hotkey N), but things quickly change. [Figure 7-2](ch07.html#renaming_a_location
    "Figure 7-2. Renaming a location") shows the renaming dialog associated with named
    locations.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名命名位置或将名称添加到未命名的位置与更改栈变量名称略有不同。访问名称更改对话框的过程相同（快捷键 N），但情况很快就会改变。[图 7-2](ch07.html#renaming_a_location
    "图 7-2. 重命名位置") 显示了与命名位置关联的重命名对话框。
- en: This dialog informs you exactly what address you are naming along with a list
    of attributes that can be associated with the name. The maximum name length merely
    echoes a value from one of IDA’s configuration files (*<IDADIR>/cfg/ida.cfg*).
    You are free to use names longer than this value, which will cause IDA to complain
    weakly by informing you that you have exceeded the maximum name length and offering
    to increase the maximum name length for you. Should you choose to do so, the new
    maximum name length value will be enforced (weakly) only in the current database.
    Any new databases that you create will continue to be governed by the maximum
    name length contained in the configuration file.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框会告诉你确切地命名了哪个地址，以及可以与该名称相关联的属性列表。最大名称长度仅从IDA的配置文件中的一个值（*<IDADIR>/cfg/ida.cfg*）中回显。你可以使用比这个值更长的名称，这会导致IDA弱弱地提醒你已超出最大名称长度，并建议为你增加最大名称长度。如果你选择这样做，新的最大名称长度值将仅（弱弱地）在当前数据库中强制执行。你创建的任何新数据库将继续受配置文件中包含的最大名称长度的约束。
- en: '![Renaming a location](httpatomoreillycomsourcenostarchimages854147.png.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![重命名位置](httpatomoreillycomsourcenostarchimages854147.png.jpg)'
- en: Figure 7-2. Renaming a location
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2. 重命名位置
- en: 'The following attributes can be associated with any named location:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性可以与任何命名位置相关联：
- en: '**Local name**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部名称**'
- en: A local name is restricted in scope to the current function, so the uniqueness
    of local names is enforced only within a given function. Like local variables,
    two different functions may contain identical local names, but a single function
    cannot contain two local names that are identical. Named locations that exist
    outside function boundaries cannot be designated as local names. These include
    names that represent function names as well as global variables. The most common
    use for local names is to provide symbolic names for the targets of jumps within
    a function, such as those associated with branching control structures.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 局部名称的范围限制在当前函数内，因此局部名称的唯一性仅在给定函数内强制执行。像局部变量一样，两个不同的函数可能包含相同的局部名称，但单个函数不能包含两个相同的局部名称。存在于函数边界之外的位置的命名位置不能指定为局部名称。这包括代表函数名称以及全局变量的名称。局部名称最常见的使用是为函数内跳转的目标提供符号名称，例如与分支控制结构相关联的名称。
- en: '**Include in names list**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含在名称列表中**'
- en: Selecting this option causes a name to be added to the Names window, which can
    make the name easier to find when you wish to return to it. Autogenerated (dummy)
    names are never included in the Names window by default.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项会在名称窗口中添加一个名称，这可以使名称更容易找到，当你希望返回时。默认情况下，自动生成的（虚拟）名称永远不会包含在名称窗口中。
- en: '**Public name**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共名称**'
- en: A public name is typically a name that is being exported by a binary such as
    a shared library. IDA’s parsers typically discover public names while parsing
    file headers during initial loading into the database. You can force a symbol
    to be treated as public by selecting this attribute. In general, this has very
    little effect on the disassembly other than to cause public annotations to be
    added to the name in the disassembly listing and in the Names window.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 公共名称通常是二进制文件（如共享库）导出的名称。IDA的解析器通常在将文件头解析到数据库中时发现公共名称。你可以通过选择此属性强制将符号视为公共。通常，这除了在反汇编列表和名称窗口中添加公共注释外，对反汇编几乎没有影响。
- en: '**Autogenerated name**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动生成名称**'
- en: This attribute appears to have no discernible effect on disassemblies. Selecting
    it does not cause IDA to automatically generate a name.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性似乎对反汇编没有可察觉的影响。选择它不会导致IDA自动生成名称。
- en: '**Weak name**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱名称**'
- en: A weak symbol is a specialized form of public symbol utilized only when no public
    symbol of the same name is found to override it. Marking a symbol as weak has
    some significance to an assembler but little significance in an IDA disassembly.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 弱符号是一种仅在找不到相同名称的公共符号来覆盖它时使用的特殊公共符号。将符号标记为弱符号对汇编器有一定的意义，但在IDA反汇编中意义不大。
- en: '**Create name anyway**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**无论如何创建名称**'
- en: As discussed previously, no two locations within a function may be given the
    same name. Similarly, no two locations outside any function (in the global scope)
    may be given the same name. This option is somewhat confusing, as it behaves differently
    depending on the type of name you are attempting to create.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数内部不允许两个位置具有相同的名称。同样，任何函数外部（全局作用域内）的位置也不允许具有相同的名称。这个选项有些令人困惑，因为它的行为取决于你尝试创建的名称类型。
- en: If you are editing a name at the global scope (such as a function name or global
    variable) and you attempt to assign a name that is already in use in the database,
    IDA will display the conflicting name dialog, shown in [Figure 7-3](ch07.html#name_conflict_dialog
    "Figure 7-3. Name conflict dialog"), offering to automatically generate a unique
    numeric suffix to resolve the conflict. This dialog is presented regardless of
    whether you have selected the Create name anyway option or not.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编辑全局范围内的名称（如函数名称或全局变量），并且尝试分配数据库中已使用的名称，IDA 将显示冲突名称对话框，如图 [图 7-3](ch07.html#name_conflict_dialog
    "图 7-3. 名称冲突对话框") 所示，自动生成一个唯一的数字后缀以解决冲突。无论你是否选择了“无论如何创建名称”选项，都会显示此对话框。
- en: If, however, you are editing a local name within a function and you attempt
    to assign a name that is already in use, the default behavior is simply to reject
    the attempt. If you are determined to use the given name, you must select Create
    name anyway in order to force IDA to generate a unique numeric suffix for the
    local name. Of course, the simplest way to resolve any name conflict is to choose
    a name that is not already in use.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数内部编辑局部名称，并尝试分配一个已使用的名称，默认行为是简单地拒绝尝试。如果你决心使用给定的名称，你必须选择“无论如何创建名称”以强制 IDA
    为局部名称生成一个唯一的数字后缀。当然，解决任何名称冲突的最简单方法是选择一个尚未使用的名称。
- en: '![Name conflict dialog](httpatomoreillycomsourcenostarchimages854149.png.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![名称冲突对话框](httpatomoreillycomsourcenostarchimages854149.png.jpg)'
- en: Figure 7-3. Name conflict dialog
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3. 名称冲突对话框
- en: Register Names
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器名称
- en: A third type of name that is often overlooked is the register name. Within the
    boundaries of a function, IDA allows registers to be renamed. It may be useful
    to rename a register when a compiler has elected to allocate a variable in a register
    rather than on the program stack, and you wish to refer to the variable using
    a name more suited to its purpose than *EDX*, for example. Register renaming works
    much the same as renaming in any other location. Use the N hotkey, or right-click
    the register name and select **Rename** to open the register-renaming dialog.
    When you rename a register you are, in effect, providing an alias with which to
    refer to the register for the duration of the current function (IDA even denotes
    this alias with an `alias = register` syntax at the beginning of the function).
    IDA takes care of replacing all instances of the register name with the alias
    that you provide. It is not possible to rename a register used in code that does
    not belong to a function.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种常被忽视的名称类型是寄存器名称。在函数的范围内，IDA 允许重命名寄存器。当编译器选择在寄存器中分配变量而不是在程序堆栈上，而你希望使用比 *EDX*
    更适合其用途的名称来引用变量时，重命名寄存器可能很有用。寄存器重命名的工作方式与在其他位置重命名相同。使用 N 快捷键，或右键单击寄存器名称并选择 **重命名**
    以打开寄存器重命名对话框。当你重命名寄存器时，实际上是在为当前函数的持续时间提供一个别名，以引用寄存器（IDA 甚至在函数开头使用 `alias = register`
    语法来表示这个别名）。IDA 会负责将寄存器名称的所有实例替换为你提供的别名。无法重命名用于不属于函数的代码中的寄存器。
- en: Commenting in IDA
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 IDA 中的注释
- en: Another useful feature in IDA is the ability to embed comments in your databases.
    Comments are a particularly useful way to leave notes for yourself regarding your
    progress as you analyze a program. In particular, comments are helpful for describing
    sequences of assembly language instructions in a higher-level fashion. For example,
    you might opt to write comments using C language statements to summarize the behavior
    of a particular function. On subsequent analysis of the function, the comments
    would serve to refresh your memory faster than reanalyzing the assembly language
    statements.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 中的另一个有用功能是能够在数据库中嵌入注释。注释是在分析程序时为自己留下关于进度笔记的特别有用的方式。特别是，注释有助于以更高级的形式描述汇编语言指令序列。例如，你可能选择使用
    C 语言语句编写注释来总结特定函数的行为。在随后的函数分析中，注释将有助于比重新分析汇编语言语句更快地刷新你的记忆。
- en: 'IDA offers several styles of comments, each suited for a different purpose.
    Comments may be associated with any line of the disassembly listing using options
    available from Edit ▸ Comments. Hotkeys or context menus offer alternate access
    to IDA’s commenting features. To help you understand IDA’s commenting features,
    we refer to the following disassembly of the function `bar`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 提供了多种注释样式，每种样式都适合不同的目的。可以使用从“编辑”▸“注释”中可用的选项将注释与反汇编列表中的任何一行相关联。快捷键或上下文菜单提供了对
    IDA 注释功能的另一种访问方式。为了帮助您理解 IDA 的注释功能，我们参考以下对函数 `bar` 的反汇编：
- en: '[PRE29]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The majority of IDA comments are prefixed with a semicolon to indicate that
    the remainder of the line is to be considered a comment. This is similar to commenting
    styles used by many assemblers and equates to #-style comments in many scripting
    languages or //-style comments in C++.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 'IDA 的大多数注释都以前缀分号 (;) 开头，以表明该行剩余部分应被视为注释。这与许多汇编器使用的注释风格相似，在许多脚本语言中相当于 #-style
    注释，在 C++ 中相当于 //-style 注释。'
- en: Regular Comments
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常规注释
- en: The most straightforward comment is the *regular comment*. Regular comments
    are placed at the end of existing assembly lines, as at ![](httpatomoreillycomsourcenostarchimages854061.png)
    in the preceding listing. Right-click in the right margin of the disassembly or
    use the colon (:) hotkey to activate the comment entry dialog. Regular comments
    will span multiple lines if you enter multiple lines in the comment entry dialog.
    Each of the lines will be indented to line up on the right side of the disassembly.
    To edit or delete a comment, you must reopen the comment entry dialog and edit
    or delete all of the comment text as appropriate. By default, regular comments
    are displayed as blue text.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的注释是 *常规注释*。常规注释放置在现有汇编行的末尾，如前一个列表中的 ![](httpatomoreillycomsourcenostarchimages854061.png)
    所示。在反汇编的右侧边缘右键单击或使用冒号 (:) 快捷键来激活注释输入对话框。如果您在注释输入对话框中输入多行，常规注释将跨越多行。每一行都将缩进以与反汇编的右侧对齐。要编辑或删除注释，您必须重新打开注释输入对话框并相应地编辑或删除所有注释文本。默认情况下，常规注释以蓝色文本显示。
- en: IDA itself makes extensive use of regular comments. During the analysis phase,
    IDA inserts regular comments to describe parameters that are being pushed for
    function calls. This occurs only when IDA has parameter name or type information
    for the function being called. This information is typically contained within
    type libraries, which are discussed in [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures") and [Chapter 13](ch13.html "Chapter 13. Extending IDA’s
    Knowledge"), but also may be entered manually.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 本身大量使用常规注释。在分析阶段，IDA 插入常规注释来描述正在为函数调用推入的参数。这仅在 IDA 有被调用函数的参数名称或类型信息时发生。这些信息通常包含在类型库中，这在
    [第 8 章](ch08.html "第 8 章。数据类型和数据结构") 和 [第 13 章](ch13.html "第 13 章。扩展 IDA 的知识")
    中讨论过，但也可能手动输入。
- en: Repeatable Comments
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重复注释
- en: A *repeatable comment* is a comment that is entered once but that may appear
    automatically in many locations throughout the disassembly. Location ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the previous listing shows a repeatable comment. In a disassembly listing the
    default color for repeatable comments is blue, making them indistinguishable from
    regular comments. It is the behavior rather than the appearance that matters in
    this case. The behavior of repeatable comments is tied to the concept of cross-references.
    When one program location refers to a second location that contains a repeatable
    comment, the comment associated with the second location is echoed at the first
    location. By default, the echoed comment appears as gray text, making the repeated
    comment distinguishable from other comments. The hotkey for repeatable comments
    is the semicolon (;), making it very easy to confuse repeatable comments and regular
    comments.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *可重复的注释* 是一种只输入一次但可能在反汇编的许多位置自动出现的注释。前一个列表中的位置 ![](httpatomoreillycomsourcenostarchimages854063.png)
    展示了一个可重复的注释。在反汇编列表中，可重复注释的默认颜色是蓝色，这使得它们与常规注释难以区分。在这种情况下，重要的是行为而不是外观。可重复注释的行为与交叉引用的概念相关联。当一个程序位置引用包含可重复注释的第二个位置时，与第二个位置关联的注释会在第一个位置被回显。默认情况下，回显的注释以灰色文本显示，使得重复的注释与其他注释可区分。可重复注释的热键是分号
    (;)，这使得很容易混淆可重复注释和常规注释。
- en: In the previous listing, note that the comment at ![](httpatomoreillycomsourcenostarchimages854093.png)
    is identical to the comment at ![](httpatomoreillycomsourcenostarchimages854063.png).
    The comment at ![](httpatomoreillycomsourcenostarchimages854063.png) has been
    repeated because the instruction at ![](httpatomoreillycomsourcenostarchimages854093.png)
    (`jge short loc_40106C`) refers to the address of ![](httpatomoreillycomsourcenostarchimages854063.png)
    (`0040106C`).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个列表中，请注意，![](httpatomoreillycomsourcenostarchimages854093.png) 处的注释与 ![](httpatomoreillycomsourcenostarchimages854063.png)
    处的注释相同。![](httpatomoreillycomsourcenostarchimages854063.png) 处的注释被重复，因为 ![](httpatomoreillycomsourcenostarchimages854093.png)
    处的指令 (`jge short loc_40106C`) 引用了 ![](httpatomoreillycomsourcenostarchimages854063.png)
    (`0040106C`) 的地址。
- en: A regular comment added at a location that is displaying a repeated comment
    overrides the repeated comment so that only the regular comment will be displayed.
    If you entered a regular comment at ![](httpatomoreillycomsourcenostarchimages854093.png),
    the repeatable comment inherited from ![](httpatomoreillycomsourcenostarchimages854063.png)
    would no longer be displayed at ![](httpatomoreillycomsourcenostarchimages854093.png).
    If you then deleted the regular comment at ![](httpatomoreillycomsourcenostarchimages854093.png),
    the repeatable comment would once again be displayed.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示重复注释的位置添加的常规注释会覆盖重复注释，因此只会显示常规注释。如果您在 ![](httpatomoreillycomsourcenostarchimages854093.png)
    处输入了常规注释，那么从 ![](httpatomoreillycomsourcenostarchimages854063.png) 继承的可重复注释将不会在
    ![](httpatomoreillycomsourcenostarchimages854093.png) 处显示。如果您随后删除了 ![](httpatomoreillycomsourcenostarchimages854093.png)
    处的常规注释，可重复注释将再次显示。
- en: A variant form of repeatable comment is associated with strings. Whenever IDA
    automatically creates a string variable, a virtual repeatable comment is added
    at all locations referencing the string variable. We say *virtual* because the
    comment cannot be edited by the user. The content of the virtual comment is set
    to the content of the string variable and displayed throughout the database just
    as a repeatable comment would be. As a result, any program locations that refer
    to the string variable will display the contents of the string variable as a repeated
    comment. The three comments annotated ![](httpatomoreillycomsourcenostarchimages854095.png)
    demonstrate such comments displayed as a result of references to string variables.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串相关联的重复性注释的变体。每当 IDA 自动创建一个字符串变量时，就会在所有引用该字符串变量的位置添加一个虚拟重复性注释。我们称之为“虚拟”，因为用户无法编辑该注释。虚拟注释的内容设置为字符串变量的内容，并在整个数据库中像可重复注释一样显示。因此，任何引用字符串变量的程序位置都会显示字符串变量的内容作为重复注释。标注为
    ![](httpatomoreillycomsourcenostarchimages854095.png) 的三个注释展示了由于字符串变量的引用而显示的此类注释。
- en: Anterior and Posterior Lines
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前后行
- en: '*Anterior and posterior lines* are full-line comments that appear either immediately
    before (anterior) or after (posterior) a given disassembly line. These comments
    are the only IDA comments that are *not* prefixed with the semicolon character.
    An example of an anterior line comment appears at ![](httpatomoreillycomsourcenostarchimages854099.png)
    in the previous listing. You can distinguish an anterior line from a posterior
    line by comparing the address associated with the line to the address associated
    with the instruction immediately preceding or following the line.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*前后行* 是全行注释，出现在给定反汇编行的前面（前）或后面（后）。这些注释是 IDA 中唯一不带分号字符前缀的注释。前一个列表中的 ![](httpatomoreillycomsourcenostarchimages854099.png)
    显示了一个前行注释的例子。您可以通过比较行的地址与该行之前或之后指令的地址来区分前行和后行。'
- en: Function Comments
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数注释
- en: '*Function comments* allow you to group comments for display at the top of a
    function’s disassembly listing. An example of a function comment is shown at ![](httpatomoreillycomsourcenostarchimages854101.png),
    where the function prototype has been entered. You enter function comments by
    first highlighting the function name at the top of the function (![](httpatomoreillycomsourcenostarchimages854103.png))
    and then adding either a regular or repeatable comment. Repeatable function comments
    are echoed at any locations that call the commented function. IDA will automatically
    generate function prototype-style comments when you use the Set Function Type
    command discussed in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures").'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数注释* 允许您将注释分组显示在函数反汇编列表的顶部。一个函数注释的示例在 ![](httpatomoreillycomsourcenostarchimages854101.png)
    中展示，其中已经输入了函数原型。您可以通过首先突出显示函数名称（![](httpatomoreillycomsourcenostarchimages854103.png)）在函数顶部，然后添加一个常规或可重复注释来输入函数注释。可重复的函数注释在调用注释函数的任何位置都会被回显。当您使用第
    8 章中讨论的“设置函数类型”命令时，IDA 会自动生成函数原型风格的注释。'
- en: Basic Code Transformations
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本代码变换
- en: In many cases you will be perfectly content with the disassembly listings that
    IDA generates. In some cases you won’t. As the types of files that you analyze
    diverge farther and farther from ordinary executables generated with common compilers,
    you may find that you need to take more control of the disassembly analysis and
    display processes. This will be especially true if you find yourself performing
    analysis of obfuscated code or files that utilize a custom (unknown to IDA) file
    format.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您会对 IDA 生成的反汇编列表感到非常满意。在某些情况下，您可能不会。随着您分析的类型文件越来越远离由常用编译器生成的普通可执行文件，您可能会发现您需要更多地控制反汇编分析和显示过程。如果您发现自己正在分析混淆代码或使用
    IDA 所不熟悉的自定义（未知于 IDA）文件格式的文件，这尤其正确。
- en: 'Code transformations facilitated by IDA include the following:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 便利的代码变换包括以下内容：
- en: Converting data into code
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据转换为代码
- en: Converting code into data
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码转换为数据
- en: Designating a sequence of instructions as a function
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一系列指令指定为函数
- en: Changing the starting or ending address of an existing function
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改现有函数的起始或结束地址
- en: Changing the display format for instruction operands
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改指令操作数的显示格式
- en: The degree to which you utilize these operations depends on a wide variety of
    factors and personal preferences. In general, if a binary is very complex, or
    if IDA is not familiar with the code sequences generated by the compiler used
    to build the binary, then IDA will encounter more problems during the analysis
    phase, and you will need to make manual adjustments to the disassembled code.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 您对这些操作的使用程度取决于广泛的因素和个人偏好。一般来说，如果一个二进制文件非常复杂，或者 IDA 不熟悉用于构建二进制文件的编译器生成的代码序列，那么
    IDA 在分析阶段可能会遇到更多问题，您将需要手动调整反汇编代码。
- en: Code Display Options
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码显示选项
- en: The simplest transformations that you can make to a disassembly listing involve
    customizing the amount of information that IDA generates for each disassembly
    line. Each disassembled line can be considered as a collection of parts that IDA
    refers to, not surprisingly, as *disassembly line parts*. Labels, mnemonics, and
    operands are always present in a disassembly line. You can select additional parts
    for each disassembly line via Options ▸ General on the Disassembly tab, as shown
    in [Figure 7-4](ch07s03.html#disassembly_line_display_options "Figure 7-4. Disassembly
    line display options").
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对反汇编列表进行的 simplest 变换涉及自定义 IDA 为每条反汇编行生成的信息量。每条反汇编行都可以被视为 IDA 所指的部件集合，不出所料，这些部件被称为
    *反汇编行部件*。标签、助记符和操作数总是存在于反汇编行中。您可以通过在反汇编选项卡上的“选项 ▸ 通用”中，选择为每条反汇编行选择额外的部件，如图 [图
    7-4](ch07s03.html#disassembly_line_display_options "图 7-4. 反汇编行显示选项") 所示。
- en: '![Disassembly line display options](httpatomoreillycomsourcenostarchimages854151.png.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![反汇编行显示选项](httpatomoreillycomsourcenostarchimages854151.png.jpg)'
- en: Figure 7-4. Disassembly line display options
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4. 反汇编行显示选项
- en: The *Display Disassembly Line Parts* section in the upper right offers several
    options for customizing disassembly lines. For IDA’s text disassembly view, line
    prefixes, comments, and repeatable comments are selected by default. Each item
    is described here and shown in the listing that follows.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 上右角的 *显示反汇编行部件* 部分提供了几个选项来定制反汇编行。对于 IDA 的文本反汇编视图，默认选中了行前缀、注释和可重复注释。每个选项在此都有描述，并在随后的列表中展示。
- en: '**Line prefixes**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**行前缀**'
- en: A line prefix is the `section:address` portion of each disassembly line. Deselecting
    this option causes the line prefix to be removed from each disassembly line (the
    default in graph view). To illustrate this option, we have disabled line prefixes
    in the next listing.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 行前缀是每条反汇编行的`section:address`部分。取消选择此选项会导致行前缀从每条反汇编行中移除（在图形视图中默认设置）。为了说明此选项，我们在下一个列表中已禁用行前缀。
- en: '**Stack pointer**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈指针**'
- en: IDA performs extensive analysis on each function in order to track changes to
    the program stack pointer. This analysis is essential in understanding the layout
    of each function’s stack frame. Selecting the Stack pointer option causes IDA
    to display the relative change to the stack pointer throughout the course of each
    function. This may be useful in recognizing discrepancies in calling conventions
    (IDA may not understand that a particular function uses `stdcall`, for example)
    or unusual manipulations of the stack pointer. Stack pointer tracking is shown
    in the column under ![](httpatomoreillycomsourcenostarchimages854061.png). In
    this example, the stack pointer has changed by four bytes following the first
    instruction and a total of 0x7C bytes following the third instruction. By the
    time the function completes, the stack pointer is restored to its original value
    (a relative change of zero bytes). Whenever IDA encounters a function return statement
    and detects that the stack pointer value is not zero, an error condition is flagged
    and the instruction line highlighted in red. In some cases, this might be a deliberate
    attempt to frustrate automated analysis. In other cases, it may be that a compiler
    utilizes prologues and epilogues that IDA can’t accurately analyze.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 对每个函数进行广泛的分析，以跟踪程序栈指针的变化。这种分析对于理解每个函数的栈帧布局至关重要。选择栈指针选项会导致 IDA 在每个函数执行过程中显示栈指针的相对变化。这可能在识别调用约定中的差异（例如，IDA
    可能不理解特定函数使用 `stdcall`）或对栈指针的异常操作时很有用。栈指针跟踪显示在 ![](httpatomoreillycomsourcenostarchimages854061.png)
    下的列中。在这个例子中，在第一条指令之后栈指针改变了四个字节，在第三条指令之后总共改变了 0x7C 字节。当函数完成时，栈指针恢复到其原始值（相对变化为零字节）。每当
    IDA 遇到函数返回语句并检测到栈指针值不为零时，会标记错误条件并将指令行以红色突出显示。在某些情况下，这可能是故意试图阻碍自动化分析。在其他情况下，可能是一个编译器使用了
    IDA 无法准确分析的前置和后置代码。
- en: '**Comments and repeatable comments**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释和可重复注释**'
- en: Deselecting either of these options inhibits the display of the respective comment
    type. This may be useful if you wish to declutter a disassembly listing.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 取消选择这两个选项之一将抑制显示相应的注释类型。如果您希望清理反汇编列表，这可能很有用。
- en: '**Auto comments**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动注释**'
- en: IDA can automatically comment some instruction types. This can serve as a reminder
    as to how particular instructions behave. No comments are added for trivial instructions
    such as the x86 `mov`. The comments at ![](httpatomoreillycomsourcenostarchimages854063.png)
    are examples of auto comments. User comments take precedence over auto comments;
    in this case if you want to see IDA’s automatic comment for a line, you’ll have
    to remove any comments you’ve added (regular or repeatable).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 可以自动注释某些指令类型。这可以作为关于特定指令行为的提醒。对于像 x86 的 `mov` 这样的简单指令不会添加注释。![](httpatomoreillycomsourcenostarchimages854063.png)
    中的注释是自动注释的示例。用户注释优先于自动注释；在这种情况下，如果您想查看 IDA 对某行的自动注释，您必须删除您添加的任何注释（常规或可重复的）。
- en: '**Bad instruction** **`<BAD>`** **marks**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误指令** **`<BAD>`** **标记**'
- en: IDA can mark instructions that are legal for the processor but that may not
    be recognized by some assemblers. Undocumented (as opposed to illegal) CPU instructions
    may fall in this category. In such cases IDA will disassemble the instruction
    as a sequence of data bytes and display the undocumented instruction as a comment
    prefaced with `<BAD>`. The intent is to generate a disassembly that most assemblers
    can handle. Refer to the IDA help file for more information on the use of `<BAD>`
    marks.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 可以标记处理器合法但某些汇编器可能无法识别的指令。与非法指令（而不是未记录的）相比，未记录的 CPU 指令可能属于此类。在这种情况下，IDA 将将指令反汇编为一系列数据字节，并将未记录的指令作为以
    `<BAD>` 开头的注释显示。目的是生成大多数汇编器都可以处理的反汇编。有关 `<BAD>` 标记的使用信息，请参阅 IDA 帮助文件。
- en: '**Number of opcode bytes**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作码字节数**'
- en: Most disassemblers are capable of generating listing files that display the
    generated machine language bytes side by side with the assembly language instructions
    from which they are derived. IDA allows you to view the machine language bytes
    associated with each instruction by synchronizing a hex display to the disassembly
    listing display. You can optionally view machine language bytes mixed with assembly
    language instructions by specifying the number of machine language bytes that
    IDA should display for each instruction.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数反汇编器都能够生成显示生成的机器语言字节与从中派生出的汇编语言指令并排的列表文件。IDA允许你通过将十六进制显示与反汇编列表显示同步来查看与每个指令相关的机器语言字节。你可以选择性地通过指定IDA应为每个指令显示的机器语言字节数量来查看与汇编语言指令混合的机器语言字节。
- en: This is fairly straightforward when you are disassembling code for processors
    that have a fixed instruction size, but it is somewhat more difficult for variable-length
    instruction processors such as the x86, for which instructions may range from
    one to more than a dozen bytes in size. Regardless of the instruction length,
    IDA reserves display space in the disassembly listing for the number of bytes
    that you specify here, pushing the remaining portions of the disassembly line
    to the right to accommodate the specified number of opcode bytes. Number of opcode
    bytes has been set to 5 in the following disassembly and can be seen in the columns
    under ![](httpatomoreillycomsourcenostarchimages854093.png). The + symbol at ![](httpatomoreillycomsourcenostarchimages854095.png)
    indicates that the specified instruction is too long to be fully displayed given
    the current settings.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在拆解具有固定指令大小的处理器代码时，这相当直接，但对于像x86这样的变长指令处理器来说，这要困难一些，因为指令的大小可能从一两个字节到十几个字节不等。无论指令长度如何，IDA都会在反汇编列表中为这里指定的字节数保留显示空间，将反汇编行的剩余部分推到右边，以适应指定的指令字节数量。以下反汇编中指令字节数量已设置为5，可在![httpatomoreillycomsourcenostarchimages854093.png](httpatomoreillycomsourcenostarchimages854093.png)下的列中看到。![httpatomoreillycomsourcenostarchimages854095.png](httpatomoreillycomsourcenostarchimages854095.png)处的加号符号表示，根据当前设置，指定的指令太长而无法完全显示。
- en: '[PRE30]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can further customize the disassembly display by adjusting the indentation
    values and margins shown in the lower right of [Figure 7-4](ch07s03.html#disassembly_line_display_options
    "Figure 7-4. Disassembly line display options"). Any changes to these options
    affect only the current database. Global settings for each of these options are
    stored in the main configuration file, *<IDADIR>/cfg/ida.cfg*.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调整[图7-4](ch07s03.html#disassembly_line_display_options "图7-4. 反汇编行显示选项")右下角显示的缩进值和边距来进一步自定义反汇编显示。对这些选项的任何更改都仅影响当前数据库。每个这些选项的全局设置存储在主配置文件*<IDADIR>/cfg/ida.cfg*中。
- en: Formatting Instruction Operands
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化指令操作数
- en: During the disassembly process, IDA makes many decisions regarding how to format
    operands associated with each instruction. The biggest decisions generally revolve
    around how to format various integer constants used by the wide variety of instruction
    types. Among other things, these constants can represent relative offsets in jump
    or call instructions, absolute addresses of global variables, values to be used
    in arithmetic operations, or programmer-defined constants. In order to make a
    disassembly more readable, IDA attempts to use symbolic names rather than numbers
    whenever possible. In some cases, formatting decisions are made based on the context
    of the instruction being disassembled (such as a call instruction); in other cases,
    the decision is based on the data being used (such as access to a global variable
    or an offset into a stack frame). In many other cases, the exact context in which
    a constant is being used may not be clear. When this happens, the associated constant
    is typically formatted as a hexadecimal constant.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编过程中，IDA会就如何格式化与每个指令关联的操作数做出许多决定。最大的决定通常围绕如何格式化各种整数常量，这些常量被各种指令类型广泛使用。这些常量可以表示跳转或调用指令中的相对偏移量、全局变量的绝对地址、用于算术运算的值或程序员定义的常量。为了使反汇编更易于阅读，IDA尽可能地使用符号名称而不是数字。在某些情况下，格式化决策是基于正在反汇编的指令的上下文（例如调用指令）；在其他情况下，决策是基于使用的数据（例如访问全局变量或堆栈帧中的偏移量）。在许多其他情况下，常量被使用的确切上下文可能不清楚。当这种情况发生时，相关的常量通常格式化为十六进制常量。
- en: If you happen not to be one of the few people in the world who eat, sleep, and
    breathe hex, then you will welcome IDA’s operand formatting features. Right-clicking
    any constant in a disassembly opens a context-sensitive menu similar to that shown
    in [Figure 7-5](ch07s03.html#formatting_options_for_constants "Figure 7-5. Formatting
    options for constants").
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是世界上少数几个吃、睡、呼吸十六进制的人之一，那么你将欢迎IDA的操作数格式化功能。在反汇编中右键单击任何常数都会打开一个类似于[图7-5](ch07s03.html#formatting_options_for_constants
    "图7-5. 常数的格式化选项")所示的上下文相关菜单。
- en: '![Formatting options for constants](httpatomoreillycomsourcenostarchimages854153.png.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![常数的格式化选项](httpatomoreillycomsourcenostarchimages854153.png.jpg)'
- en: Figure 7-5. Formatting options for constants
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-5. 常数的格式化选项
- en: In this case, menu options are offered enabling the constant (`41h`) to be reformatted
    as decimal, octal, or binary values. Since the constant in this example falls
    within the ASCII printable range, an option is also presented to format the value
    as a character constant. In all cases, the menu displays the exact text that will
    replace the operand text should a particular option be selected.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，菜单选项允许将常数（`41h`）重新格式化为十进制、八进制或二进制值。由于此示例中的常数位于ASCII可打印范围内，因此还提供了一个选项，可以将值格式化为字符常数。在所有情况下，菜单都会显示如果选择特定选项将替换操作数文本的确切文本。
- en: In many cases, programmers use named constants in their source code. Such constants
    may be the result of `#define` statements (or their equivalent), or they may belong
    to a set of enumerated constants. Unfortunately, by the time a compiler is finished
    with the source code, it is no longer possible to determine whether the source
    used a symbolic constant or a literal, numeric constant. IDA maintains a large
    catalog of named constants associated with many common libraries such as the C
    standard library or the Windows API. This catalog is accessible via the Use standard
    symbolic constant option on the context-sensitive menu associated with any constant
    value. Selecting this option for the constant `0Ah` in [Figure 7-5](ch07s03.html#formatting_options_for_constants
    "Figure 7-5. Formatting options for constants") opens the symbol-selection dialog
    shown in [Figure 7-6](ch07s03.html#symbol-selection_dialog "Figure 7-6. Symbol-selection
    dialog").
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，程序员会在源代码中使用命名常数。这些常数可能是`#define`语句（或其等效项）的结果，或者它们可能属于一组枚举常数。不幸的是，当编译器完成源代码后，就不再可能确定源代码是否使用了符号常数或字面量、数值常数。IDA维护了一个与许多常见库（如C标准库或Windows
    API）关联的命名常数的大型目录。此目录可通过任何常数值相关的上下文相关菜单上的“使用标准符号常数”选项访问。选择[图7-5](ch07s03.html#formatting_options_for_constants
    "图7-5. 常数的格式化选项")中的常数`0Ah`的此选项将打开[图7-6](ch07s03.html#symbol-selection_dialog "图7-6.
    符号选择对话框")所示的符号选择对话框。
- en: '![Symbol-selection dialog](httpatomoreillycomsourcenostarchimages854155.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![符号选择对话框](httpatomoreillycomsourcenostarchimages854155.png)'
- en: Figure 7-6. Symbol-selection dialog
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-6. 符号选择对话框
- en: 'The dialog is populated from IDA’s internal list of constants after filtering
    according to the value of the constant we are attempting to format. In this case
    we see all of the constants that IDA knows to be equated with the value `0Ah`.
    If we determined that the value was being used in conjunction with the creation
    of an X.25-style network connection, then we might select AF_CCITT and end up
    with the following disassembly line:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框是从IDA的内部常数列表中填充的，根据我们尝试格式化的常数的值进行过滤。在这种情况下，我们看到IDA知道等同于值`0Ah`的所有常数。如果我们确定该值是在创建X.25风格的网络连接时使用的，那么我们可能会选择AF_CCITT，并最终得到以下反汇编行：
- en: '[PRE31]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The list of standard constants is a useful way to determine whether a particular
    constant may be associated with a known name and can save a lot of time reading
    through API documentation in search of potential matches.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 标准常数的列表是确定特定常数是否可能与已知名称相关联的有用方法，并且可以节省大量时间阅读API文档以寻找潜在匹配项。
- en: Manipulating Functions
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数操作
- en: There are a number of reasons that you may wish to manipulate functions after
    the initial autoanalysis has been completed. In some cases, such as when IDA fails
    to locate a call to a function, functions may not be recognized, as there may
    be no obvious way to reach them. In other cases, IDA may fail to properly locate
    the end of a function, requiring some manual intervention on your part to correct
    the disassembly. IDA may have trouble locating the end of a function if a compiler
    has split the function across several address ranges or when, in the process of
    optimizing code, a compiler merges common end sequences of two or more functions
    in order to save space.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始自动分析完成后，你可能会有许多原因想要操作函数。在某些情况下，例如当IDA未能定位到函数调用时，函数可能不会被识别，因为没有明显的方法可以到达它们。在其他情况下，IDA可能无法正确地定位函数的结束，需要你手动干预来纠正反汇编。如果编译器将函数拆分到几个地址范围，或者在优化代码的过程中，编译器合并两个或更多函数的共同结束序列以节省空间，IDA可能难以定位函数的结束。
- en: Creating New Functions
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新函数
- en: Under certain circumstances, new functions can be created where no function
    exists. New functions can be created from existing instructions that do not already
    belong to a function, or they can be created from raw data bytes that have not
    been defined by IDA in any other manner (such as double words or strings). You
    create functions by placing the cursor on the first byte or instruction to be
    included in the new function and selecting Edit ▸ Functions ▸ Create Function.
    IDA attempts to convert data to code if necessary. Then it scans forward to analyze
    the structure of the function and search for a return statement. If IDA can locate
    a suitable end of the function, it generates a new function name, analyzes the
    stack frame, and restructures the code in the form of a function. If it can’t
    locate the end of the function or encounters any illegal instructions, then the
    operation fails.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可以在没有函数存在的地方创建新函数。可以从不属于任何函数的现有指令创建新函数，或者可以从IDA未以任何其他方式定义的原始数据字节创建新函数（例如双字或字符串）。你通过将光标放在新函数要包含的第一个字节或指令上，然后选择编辑
    ▸ 函数 ▸ 创建函数来创建函数。如果需要，IDA会尝试将数据转换为代码。然后它向前扫描以分析函数的结构并搜索返回语句。如果IDA可以定位到函数的合适结束，它将生成一个新的函数名，分析堆栈帧，并以函数的形式重构代码。如果它无法定位函数的结束或遇到任何非法指令，则操作失败。
- en: Deleting Functions
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除函数
- en: You can delete existing functions using Edit ▸ Functions ▸ Delete Function.
    You may wish to delete a function if you believe that IDA has erred in its autoanalysis.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用编辑 ▸ 函数 ▸ 删除函数来删除现有函数。如果你认为IDA在自动分析中出错，你可能想要删除函数。
- en: Function Chunks
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数块
- en: Function chunks are commonly found in code generated by the Microsoft Visual
    C++ compiler. Chunks are the result of the compiler moving blocks of code that
    are less frequently executed in order to squeeze frequently executed blocks into
    memory pages that are less likely to be swapped out.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 函数块通常出现在由Microsoft Visual C++编译器生成的代码中。块是编译器移动执行频率较低的代码块的结果，以便将频繁执行的块挤压到不太可能被交换出去的内存页中。
- en: 'When a function is split in such a manner, IDA attempts to locate all of the
    associated chunks by following the jumps that lead to each chunk. In most cases
    IDA does a good job of locating all of the chunks and listing each chunk in the
    function’s header, as shown in the following partial function disassembly:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数以这种方式拆分时，IDA会尝试通过跟随指向每个块的跳转来定位所有相关的块。在大多数情况下，IDA能够很好地定位所有块，并在函数的标题中列出每个块，如下面的部分函数反汇编所示：
- en: '[PRE32]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Function chunks are easily reached by double-clicking the address associated
    with the chunk, as at ![](httpatomoreillycomsourcenostarchimages854061.png). Within
    the disassembly listing, function chunks are denoted by comments that delimit
    their instructions and that refer to the owning function, as shown in this listing:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击与块关联的地址，可以轻松访问函数块，如图所示 ![链接](http://atomoreilly.com/source/nostarch/images/854061.png)。在反汇编列表中，函数块由注释表示，这些注释界定它们的指令并引用所属函数，如下列所示：
- en: '[PRE33]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In some cases IDA may fail to locate every chunk associated with a function,
    or functions may be misidentified as chunks rather than as functions in their
    own right. In such cases, you may find that you need to create your own function
    chunks or delete existing function chunks.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，IDA可能无法定位与函数关联的每个块，或者函数可能被错误地识别为块而不是作为独立的函数。在这种情况下，你可能需要创建自己的函数块或删除现有的函数块。
- en: You create new function chunks by selecting the range of addresses that belong
    to the chunk, which must not be part of any existing function, and selecting Edit
    ▸ Functions ▸ Append Function Tail. At this point you will be asked to select
    the parent function from a list of all defined functions.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过选择属于该块的范围地址来创建新的函数块，这些地址必须不属于任何现有函数，并选择“编辑”▸“函数”▸“追加函数尾部”。此时，您将需要从一个包含所有定义函数的列表中选择父函数。
- en: Note
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In disassembly listings, function chunks are referred to as just that: function
    chunks. In the IDA menu system, functions chunks are instead referred to as function
    tails.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编列表中，函数块被称为函数块。在IDA菜单系统中，函数块被称为函数尾部。
- en: You can delete existing function chunks by positioning the cursor on any line
    within the chunk to be deleted and selecting Edit ▸ Functions ▸ Remove Function
    Tail. At this point you will be asked to confirm your action prior to deleting
    the selected chunk.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将光标定位在要删除的块内的任何一行，并选择“编辑”▸“函数”▸“删除函数尾部”来删除现有的函数块。此时，您将需要确认您的操作，然后再删除所选块。
- en: If function chunks are turning out to be more trouble than they are worth, you
    can ask IDA not to create function chunks by deselecting the Create function tails
    loader option when you first load a file into IDA. This option is one of the loader
    options accessible via Kernel Options (see [Chapter 4](ch04.html "Chapter 4. Getting
    Started with IDA")) in the initial file-load dialog. If you disable function tails,
    the primary difference that you may notice is that functions that would otherwise
    have contained tails contain jumps to regions outside the function boundaries.
    IDA high-lights such jumps using red lines and arrows in the arrow windows on
    the left side of the disassembly. In the graph view for the corresponding function,
    the targets of such jumps are not displayed.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数块带来的麻烦比它们的价值大，您可以在首次将文件加载到IDA时取消选择“创建函数尾部加载器”选项，以请求IDA不要创建函数块。此选项是可以通过内核选项（参见[第4章](ch04.html
    "第4章。IDA入门")）在初始文件加载对话框中访问的加载器选项之一。如果您禁用函数尾部，您可能注意到的主要区别是，原本包含尾部的函数现在包含跳转到函数边界之外的区域的跳转。IDA使用红色线条和箭头在左侧的汇编窗口中突出显示此类跳转。在对应函数的图形视图中，此类跳转的目标不会显示。
- en: Function Attributes
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数属性
- en: IDA associates a number of attributes with each function that it recognizes.
    The function properties dialog shown in [Figure 7-7](ch07s03.html#function_editing_dialog
    "Figure 7-7. Function editing dialog") can be used to edit many of these attributes.
    Each attribute that can be modified is explained here.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: IDA将其识别的每个函数关联到多个属性。如图[图7-7](ch07s03.html#function_editing_dialog "图7-7。函数编辑对话框")所示的函数属性对话框可以用来编辑这些属性中的许多。这里解释了可以修改的每个属性。
- en: '**Name of function**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数名称**'
- en: An alternative means for changing the name of a function.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 改变函数名称的另一种方法。
- en: '**Start address**'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**起始地址**'
- en: The address of the first instruction in the function. IDA most often determines
    this automatically, either during analysis or from the address used during the
    create function operation.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中第一条指令的地址。IDA通常在分析期间或从创建函数操作期间使用的地址自动确定此地址。
- en: '![Function editing dialog](httpatomoreillycomsourcenostarchimages854157.png.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![函数编辑对话框](httpatomoreillycomsourcenostarchimages854157.png.jpg)'
- en: Figure 7-7. Function editing dialog
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-7。函数编辑对话框
- en: '**End address**'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**结束地址**'
- en: The address following the last instruction in the function. Most frequently,
    this is the address of the location that follows the function’s return instruction.
    In most cases, this address is determined automatically during the analysis phase
    or as part of function creation. In cases where IDA has trouble determining the
    true end of a function, you may need to edit this value manually. Remember, this
    address is not actually part of the function but follows the last instruction
    in the function.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中最后一条指令之后的地址。在大多数情况下，这是函数返回指令之后的地址。在大多数情况下，此地址在分析阶段或作为函数创建的一部分自动确定。在IDA难以确定函数真正结束的情况中，您可能需要手动编辑此值。请记住，此地址实际上不是函数的一部分，而是位于函数的最后一条指令之后。
- en: '**Local variables area**'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部变量区域**'
- en: This represents the number of stack bytes dedicated to local variables (see
    [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame "Figure 6-4. An EBP-based stack
    frame")) for the function. In most cases, this value is computed automatically
    based on analysis of stack pointer behavior within the function.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表分配给局部变量的栈字节数（参见[图6-4](ch06s02.html#an_ebp-based_stack_frame "图6-4. 基于EBP的栈帧"))。在大多数情况下，这个值是根据函数内栈指针的行为自动计算的。
- en: '**Saved registers**'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**保存的寄存器**'
- en: This is the number of bytes used to save registers (see [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame")) on behalf of the caller. IDA considers
    the saved register region to lie on top of the saved return address and below
    any local variables associated with the function. Some compilers choose to save
    registers on top of a function’s local variables. IDA considers the space required
    to save such registers as belonging to the local variable area rather than a dedicated
    saved registers area.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于保存寄存器的字节数（参见[图6-4](ch06s02.html#an_ebp-based_stack_frame "图6-4. 基于EBP的栈帧"))，代表调用者的行为。IDA认为保存的寄存器区域位于保存的返回地址之上，并且位于与函数相关的任何局部变量之下。一些编译器选择在函数的局部变量之上保存寄存器。IDA认为保存此类寄存器所需的空间属于局部变量区域，而不是专门的保存寄存器区域。
- en: '**Purged bytes**'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '**已清除的字节**'
- en: Purged bytes shows the number of bytes of parameters that a function removes
    from the stack when it returns to its caller. For `cdecl` functions, this value
    is always zero. For `stdcall` functions, this value represents the amount of space
    consumed by any parameters that are passed on the stack (see [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame")). In x86 programs, IDA can automatically
    determine this value when it observes the use of the `RET N` variant of the return
    instruction.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 已清除的字节显示函数返回到其调用者时从栈中移除的参数字节数。对于`cdecl`函数，此值始终为零。对于`stdcall`函数，此值表示通过栈传递的任何参数消耗的空间（参见[图6-4](ch06s02.html#an_ebp-based_stack_frame
    "图6-4. 基于EBP的栈帧"))。在x86程序中，当IDA观察到返回指令的`RET N`变体使用时，可以自动确定此值。
- en: '**Frame pointer delta**'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧指针增量**'
- en: In some cases, compilers may adjust a function’s frame pointer to point somewhere
    into the middle of the local variable area rather than at the saved frame pointer
    at the bottom of the local variable area. This distance from the adjusted frame
    pointer to the saved frame pointer is termed the *frame pointer delta*. In most
    cases any frame pointer delta will be computed automatically when the function
    is analyzed. Compilers utilize a stack frame delta as a speed optimization. The
    purpose of the delta is to keep as many stack frame variables as possible within
    reach of a 1-byte signed offset (−128..+127) from the frame pointer.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，编译器可能会调整函数的帧指针，使其指向局部变量区域的中间位置，而不是局部变量区域底部的保存帧指针。从调整后的帧指针到保存帧指针的距离称为*帧指针增量*。在大多数情况下，任何帧指针增量都会在分析函数时自动计算。编译器利用栈帧增量作为速度优化。增量目的是将尽可能多的栈帧变量保持在帧指针1字节有符号偏移（-128..+127）的范围内。
- en: Additional attribute checkboxes are available to further characterize the function.
    As with other fields within the dialog, these checkboxes generally reflect the
    results of IDA’s automatic analysis. The following attributes can be toggled on
    and off.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的附加属性复选框可用于进一步描述函数。与其他对话框中的字段一样，这些复选框通常反映了IDA的自动分析结果。以下属性可以打开和关闭。
- en: '**Does not return**'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**不返回**'
- en: The function does not return to its caller. When such a function is called,
    IDA does not assume that execution continues following the associated call instruction.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不会返回到其调用者。当调用此类函数时，IDA不会假设执行会继续跟随相关的调用指令。
- en: '**Far function**'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**远函数**'
- en: Used to mark a function as a far function on segmented architectures. Callers
    of the function would need to specify both a segment and an offset value when
    calling the function. The need to use far calls is typically dictated by the memory
    model in use within a program rather than by the fact that the architecture supports
    segmentation, for example, the use of the *large* (as opposed to *flat*) memory
    model on an x86.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在分段架构中将函数标记为远函数。函数的调用者调用函数时需要指定一个段和一个偏移值。使用远调用的需要通常是由程序中使用的内存模型决定的，而不是由架构支持分段的事实决定的，例如，在x86上使用*大*（与*平坦*相对）内存模型。
- en: '**Library func**'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**库函数**'
- en: Flags a function as library code. Library code might include support routines
    included by a compiler or functions that are part of a statically linked library.
    Marking a function as a library function causes the function to be displayed using
    the assigned library function coloring to distinguish it from nonlibrary code.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数标记为库代码。库代码可能包括编译器包含的支持例程或属于静态链接库的函数。将函数标记为库函数会导致函数使用分配的库函数着色显示，以区分非库代码。
- en: '**Static func**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态函数**'
- en: Does nothing other than display the static modifier in the function’s attribute
    list.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在函数的属性列表中显示静态修饰符外，不做任何事情。
- en: '**BP based frame**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于BP的帧**'
- en: Indicates that the function utilizes a frame pointer. In most cases you determine
    this automatically by analyzing the function’s prologue. If analysis fails to
    recognize that a frame pointer is used in the given function, you can manually
    select this attribute. If you do manually select this attribute, make sure that
    you adjust the saved register size (usually increased by the size of the saved
    frame pointer) and local variable size (usually decreased by the size of the saved
    frame pointer) accordingly. For frame pointer–based frames, memory references
    that make use of the frame pointer are formatted to make use of symbolic stack
    variable names rather than numeric offsets. If this attribute is not set, then
    stack frame references are assumed to be relative to the stack pointer register.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 表示该函数使用帧指针。在大多数情况下，你可以通过分析函数的前导部分自动确定这一点。如果分析未能识别出在给定函数中使用帧指针，你可以手动选择此属性。如果你手动选择此属性，请确保相应地调整保存的寄存器大小（通常增加保存的帧指针的大小）和局部变量大小（通常减少保存的帧指针的大小）。对于基于帧指针的帧，使用帧指针的内存引用格式化为使用符号栈变量名而不是数值偏移。如果未设置此属性，则假定栈帧引用相对于栈指针寄存器。
- en: '**BP equals to SP**'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**BP等于SP**'
- en: Some functions configure the frame pointer to point to the top of the stack
    frame (along with the stack pointer) upon entering a function. This attribute
    should be set in such cases. This is essentially the same as having a frame pointer
    delta equal in size to the local variable area.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数在进入函数时会将帧指针配置为指向栈帧的顶部（与栈指针一起）。在这种情况下，应设置此属性。这本质上等同于拥有一个与局部变量区域大小相等的帧指针增量。
- en: Stack Pointer Adjustments
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈指针调整
- en: As we mentioned previously, IDA makes every effort to track changes to the stack
    pointer at each instruction within a function. The accuracy that IDA manages to
    achieve in doing so significantly impacts the accuracy of the function’s stack
    frame layout. When IDA is unable to determine whether an instruction alters the
    stack pointer, you may find that you need to specify a manual stack pointer adjustment.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，IDA会尽力跟踪函数中每条指令对栈指针的更改。IDA在这样做时达到的准确性对函数栈帧布局的准确性有显著影响。当IDA无法确定一条指令是否改变了栈指针时，你可能需要手动指定栈指针调整。
- en: 'The most straightforward example of such a case occurs when one function calls
    another function that makes use of the `stdcall` calling convention. If the function
    being called resides in a shared library that IDA does not have knowledge of (IDA
    ships with knowledge of the signatures and calling conventions of many common
    library functions), then IDA will be unaware that the function utilizes `stdcall`
    and will fail to account for the fact that the stack pointer will have been modified
    by the called function prior to returning. Thus, IDA will reflect an inaccurate
    value for the stack pointer for the remainder of the function. The following function
    call sequence, in which `some_imported_func` resides in a shared library, demonstrates
    this problem (note that the stack pointer line part option has been turned on):'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '这种情况的最直接例子发生在当一个函数调用另一个使用`stdcall`调用约定的函数时。如果被调用的函数位于IDA没有知识的共享库中（IDA附带许多常见库函数的签名和调用约定知识），那么IDA将不知道该函数使用`stdcall`，并且无法考虑到在返回之前被调用的函数已经修改了栈指针。因此，IDA将反映一个不准确的栈指针值，直到函数结束。以下函数调用序列，其中`some_imported_func`位于共享库中，展示了这个问题（注意栈指针行部分选项已被打开）:'
- en: '[PRE34]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since `some_imported_func` uses `stdcall`, it cleans the three parameters from
    the stack as it returns, and the correct stack pointer value at ![](httpatomoreillycomsourcenostarchimages854061.png)
    should be `01C`. One way to fix this problem is to associate a manual stack adjustment
    with the instruction at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Stack adjustments can be added by highlighting the address to which the adjustment
    applies, selecting Edit ▸ Functions ▸ Change Stack Pointer (hotkey alt-K), and
    specifying the number of bytes by which the stack pointer changes, in this case
    12.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `some_imported_func` 使用 `stdcall`，它在返回时会清理三个参数从栈中，在 ![](httpatomoreillycomsourcenostarchimages854061.png)
    处的正确栈指针值应该是 `01C`。修复这个问题的方法之一是将手动栈调整与 ![](httpatomoreillycomsourcenostarchimages854063.png)
    处的指令关联起来。可以通过突出显示需要调整的地址，选择编辑 ▸ 函数 ▸ 更改栈指针（快捷键 alt-K），并指定栈指针变化的字节数，在这种情况下是 12。
- en: 'While the previous example serves to illustrate a point, there is a better
    solution to this particular problem. Consider the case in which `some_imported_func`
    is called many different times. In that case, we would need to make the stack
    adjustment we just made at each location from which `some_imported_func` is called.
    Clearly this could be very tedious, and we might miss something. The better solution
    is to educate IDA regarding the behavior of `some_imported_func`. Because we are
    dealing with an imported function, when we attempt to navigate to it, we eventually
    end up at the import table entry for that function, which looks something like
    the following entry:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子有助于说明一个观点，但针对这个问题有一个更好的解决方案。考虑这种情况，`some_imported_func` 被多次调用。在这种情况下，我们需要在每个调用
    `some_imported_func` 的位置进行我们刚才所做的栈调整。显然，这可能会非常繁琐，我们可能会遗漏某些东西。更好的解决方案是教育 IDA 了解
    `some_imported_func` 的行为。因为我们处理的是一个导入函数，当我们尝试导航到它时，我们最终会到达该函数的导入表条目，该条目看起来可能如下所示：
- en: '[PRE35]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Even though this is an imported function, IDA allows you to edit one piece
    of information concerning its behavior: the number of purged bytes associated
    with the function. By editing this function, you can specify the number of bytes
    that it clears off the stack when it returns, and IDA will propagate the information
    that you supply to every location that calls the function, instantly correcting
    the stack pointer computations at each of those locations.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这是一个导入函数，IDA 允许你编辑与其行为有关的一块信息：与该函数关联的清除字节数。通过编辑此函数，你可以指定它在返回时从栈中清除的字节数，IDA
    将将你提供的信息传播到调用该函数的每个位置，立即纠正那些位置的栈指针计算。
- en: In order to improve its automated analysis, IDA incorporates advanced techniques
    that attempt to resolve stack pointer discrepancies by solving a system of linear
    equations related to the behavior of the stack pointer. As a result, you may not
    even realize that IDA has no prior knowledge of the details of functions such
    as `some_imported_func`. For more information on these techniques, refer to Ilfak’s
    blog post titled “Simplex method in IDA Pro” at [http://hexblog.com/2006/06/](http://hexblog.com/2006/06/).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高其自动分析能力，IDA 结合了高级技术，通过解决与栈指针行为相关的线性方程组来尝试解决栈指针差异。因此，你可能甚至没有意识到 IDA 对 `some_imported_func`
    等函数的细节没有任何先验知识。有关这些技术的更多信息，请参阅 Ilfak 的博客文章，标题为“IDA Pro 中的单纯形法”在 [http://hexblog.com/2006/06/](http://hexblog.com/2006/06/)。
- en: Converting Data to Code (and Vice Versa)
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据转换为代码（反之亦然）
- en: During the automatic analysis phase, bytes are occasionally categorized incorrectly.
    Data bytes may be incorrectly classified as code bytes and disassembled into instructions,
    or code bytes may be incorrectly classified as data bytes and formatted as data
    values. This happens for many reasons, including the fact that some compilers
    embed data into the code section of programs or the fact that some code bytes
    are never directly referenced as code and IDA opts not to disassemble them. Obfuscated
    programs in particular tend to blur the distinction between code sections and
    data sections.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动分析阶段，字节有时会被错误地分类。数据字节可能被错误地分类为代码字节并反汇编成指令，或者代码字节可能被错误地分类为数据字节并以数据值格式化。这种情况可能由许多原因造成，包括一些编译器将数据嵌入到程序的代码部分，或者一些代码字节从未直接作为代码引用，而
    IDA 选择不将其反汇编。特别是混淆程序往往会模糊代码段和数据段之间的区别。
- en: 'Regardless of the reason that you wish to reformat your disassembly, doing
    so is fairly easy. The first option for reformatting anything is to remove its
    current formatting (code or data). It is possible to undefine functions, code,
    or data by right-clicking the item that you wish to undefine and selecting Undefine
    (also Edit ▸ Undefine or hotkey U) from the resulting context-sensitive menu.
    Undefining an item causes the underlying bytes to be reformatted as a list of
    raw byte values. Large regions can be undefined by using a click-and-drag operation
    to select a range of addresses prior to performing the undefine operation. As
    an example, consider the simple function listing that follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你希望重新格式化反汇编的原因是什么，这样做都是相当简单的。重新格式化任何内容的第一个选项是移除其当前格式（代码或数据）。可以通过右键单击要取消定义的项目并从结果上下文相关菜单中选择“取消定义”（也可以选择“编辑”▸“取消定义”或使用快捷键U）来取消定义函数、代码或数据。取消定义项目会导致底层字节以原始字节值的列表形式重新格式化。可以通过使用点击并拖动操作来选择在执行取消定义操作之前的一组地址，从而取消定义大区域。以下是一个简单的函数列表示例：
- en: '[PRE36]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Undefining this function would yield the series of uncategorized bytes shown
    here, which we could choose to reformat in virtually any manner:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 取消定义此函数将产生这里显示的一系列未分类的字节，我们可以选择以几乎任何方式重新格式化：
- en: '[PRE37]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To disassemble a sequence of undefined bytes, right-click the first byte to
    be disassembled and select Code (also Edit ▸ Code or hotkey C). This causes IDA
    to disassemble all bytes until it encounters a defined item or an illegal instruction.
    Large regions can be converted to code by using a click-and-drag operation to
    select a range of addresses prior to performing the code-conversion operation.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 要反汇编一系列未定义的字节，右键单击要反汇编的第一个字节，并选择“代码”（也可以选择“编辑”▸“代码”或使用快捷键C）。这将导致IDA反汇编所有字节，直到遇到一个已定义的项目或非法指令。可以通过使用点击并拖动操作来选择在执行代码转换操作之前的一组地址，从而将大区域转换为代码。
- en: The complementary operation of converting code to data is a little more complex.
    First, it is not possible to convert code to data using the context menu. Available
    alternatives include Edit ▸ Data and the D hotkey. Bulk conversions of instructions
    to data are easiest to accomplish by first undefining all of the instructions
    that you wish to convert to data and then formatting the data appropriately. Basic
    data formatting is discussed in the following section.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码转换为数据的互补操作要复杂一些。首先，无法使用上下文菜单将代码转换为数据。可用的替代方案包括“编辑”▸“数据”和D快捷键。将指令批量转换为数据的最简单方法是在适当格式化数据之前，首先取消定义所有要转换为数据的指令。基本数据格式化将在下一节中讨论。
- en: Basic Data Transformations
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据转换
- en: Properly formatted data can be as important in developing an understanding of
    a program’s behavior as properly formatted code. IDA takes information from a
    variety of sources and uses many algorithms in order to determine the most appropriate
    way to format data within a disassembly. A few examples serve to illustrate how
    data formats are selected.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 正确格式化的数据在理解程序行为方面可能和正确格式化的代码一样重要。IDA从各种来源获取信息，并使用许多算法来确定在反汇编中格式化数据的最佳方式。一些示例可以说明如何选择数据格式。
- en: Datatypes and/or sizes can be inferred from the manner in which registers are
    used. An instruction observed to load a 32-bit register from memory implies that
    the associated memory location holds a 4-byte datatype (though we may not be able
    to distinguish between a 4-byte integer and a 4-byte pointer).
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以从寄存器使用方式推断数据类型和/或大小。观察到从内存加载32位寄存器的指令意味着相关的内存位置持有4字节的数据类型（尽管我们可能无法区分4字节整数和4字节指针）。
- en: Function prototypes can be used to assign datatypes to function parameters.
    IDA maintains a large library of function prototypes for exactly this purpose.
    Analysis is performed on the parameters passed to functions in an attempt to tie
    a parameter to a memory location. If such a relationship can be uncovered, then
    a datatype can be applied to the associated memory location. Consider a function
    whose single parameter is a pointer to a CRITICAL_SECTION (a Windows API datatype).
    If IDA can determine the address passed in a call to this function, then IDA can
    flag that address as a CRITICAL_SECTION object.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数原型可以用来为函数参数分配数据类型。IDA维护了一个大型函数原型库，专门用于此目的。分析函数传递的参数，试图将参数与内存位置关联起来。如果可以揭示这种关系，则可以将数据类型应用于相关的内存位置。考虑一个只有一个参数的函数，该参数是指向CRITICAL_SECTION（Windows
    API数据类型）的指针。如果IDA可以确定传递给此函数调用的地址，那么IDA可以将该地址标记为CRITICAL_SECTION对象。
- en: Analysis of a sequence of bytes can reveal likely datatypes. This is precisely
    what happens when a binary is scanned for string content. When long sequences
    of ASCII characters are encountered, it is not unreasonable to assume that they
    represent character arrays.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对字节序列的分析可以揭示可能的类型。这正是当对二进制文件进行字符串内容扫描时发生的情况。当遇到长序列的ASCII字符时，可以合理地假设它们代表字符数组。
- en: In the next few sections we discuss some basic transformations that you can
    perform on data within your disassemblies.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论一些基本的数据转换，这些转换可以在你的反汇编中执行。
- en: Specifying Data Sizes
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定数据大小
- en: The simplest way to modify a piece of data is to adjust its size. IDA offers
    a number of data size/type specifiers. The most commonly encountered specifiers
    are `db`, `dw`, and `dd`, representing 1-, 2-, and 4-byte data, respectively.
    The first way to change a data item’s size is via the Options ▸ Setup Data Types
    dialog shown in [Figure 7-8](ch07s04.html#the_datatype_setup_dialog "Figure 7-8. The
    datatype setup dialog").
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 修改数据的最简单方法就是调整其大小。IDA提供了一系列数据大小/类型指定符。最常遇到的指定符是`db`、`dw`和`dd`，分别代表1字节、2字节和4字节的数据。改变数据项大小的第一种方法是通过显示在[图7-8](ch07s04.html#the_datatype_setup_dialog
    "图7-8. 数据类型设置对话框")中的“选项 ▸ 设置数据类型”对话框。
- en: There are two parts to this dialog. The left side of the dialog contains a column
    of buttons used to immediately change the data size of the currently selected
    item. The right side of the dialog contains a column of checkboxes used to configure
    what IDA terms the *data carousel*. Note that for each button on the left, there
    is a corresponding checkbox on the right. The data carousel is a revolving list
    of datatypes that contains only those types whose checkboxes are selected. Modifying
    the contents of the data carousel has no immediate impact on the IDA display.
    Instead, each type on the data carousel is listed on the context-sensitive menu
    that appears when you right-click a data item. Thus, it is easier to reformat
    data to a type listed in the data carousel than to a type not listed in the data
    carousel. Given the datatypes selected in [Figure 7-8](ch07s04.html#the_datatype_setup_dialog
    "Figure 7-8. The datatype setup dialog"), right-clicking a data item would offer
    you the opportunity to reformat that item as byte, word, or double-word data.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框分为两部分。对话框的左侧包含一列按钮，用于立即更改当前选中项的数据大小。对话框的右侧包含一列复选框，用于配置IDA所说的“数据转盘”。请注意，左侧的每个按钮都对应右侧的一个复选框。数据转盘是一个循环列表，包含仅那些复选框被选中的数据类型。修改数据转盘的内容不会立即影响IDA显示。相反，数据转盘上的每个类型都会列在当你右键点击数据项时出现的上下文相关菜单中。因此，将数据重新格式化为数据转盘列表中的类型比重新格式化为未列出的类型要容易。考虑到[图7-8](ch07s04.html#the_datatype_setup_dialog
    "图7-8. 数据类型设置对话框")中选定的数据类型，右键点击数据项将为你提供将该项重新格式化为字节、字或双字数据的机会。
- en: '![The datatype setup dialog](httpatomoreillycomsourcenostarchimages854159.png.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![数据类型设置对话框](httpatomoreillycomsourcenostarchimages854159.png.jpg)'
- en: Figure 7-8. The datatype setup dialog
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-8. 数据类型设置对话框
- en: 'The name for the data carousel derives from the behavior of the associated
    data formatting hotkey: D. When you press D, the item at the currently selected
    address is reformatted to the next type in the data carousel list. With the three-item
    list specified previously, an item currently formatted as `db` toggles to `dw`,
    an item formatted as `dw` toggles to `dd`, and an item formatted as `dd` toggles
    back to `db` to complete the circuit around the carousel. Using the data hotkey
    on a nondata item such as code causes the item to be formatted as the first datatype
    in the carousel list (`db` in this case).'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转盘的名称来源于与之关联的数据格式化快捷键的行为：D。当你按下D键时，当前选中的地址处的项目将被重新格式化为数据转盘列表中的下一个类型。在之前指定的三项列表中，当前格式化为`db`的项目将切换到`dw`，格式化为`dw`的项目将切换到`dd`，格式化为`dd`的项目将切换回`db`，以完成转盘的循环。在非数据项（如代码）上使用数据快捷键会导致该项目被格式化为转盘列表中的第一个数据类型（在这种情况下为`db`）。
- en: Toggling through datatypes causes data items to grow, shrink, or remain the
    same size. If an item’s size remains the same, then the only observable change
    is in the way the data is formatted. If you reduce an item’s size, from `dd` (4
    bytes) to `db` (1 byte) for example, any extra bytes (3 in this case) become undefined.
    If you increase the size of an item, IDA complains if the bytes following the
    item are already defined and asks you, in a roundabout way, if you want IDA to
    undefine the next item in order to expand the current item. The message you encounter
    in such cases is “Directly convert to data?” This message generally means that
    IDA will undefine a sufficient number of succeeding items to satisfy your request.
    For example, when converting byte data (`db`) to double-word data (`dd`), 3 additional
    bytes must be consumed to form the new data item.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据类型之间切换会导致数据项增长、缩小或保持相同大小。如果一个项的大小保持不变，那么唯一可观察的变化就是数据格式的方式。如果您减小一个项的大小，例如从`dd`（4字节）减小到`db`（1字节），任何额外的字节（本例中为3个字节）将变为未定义。如果您增加一个项的大小，IDA会抱怨后续的字节已经定义，并间接地询问您是否希望IDA取消定义下一个项以扩展当前项。在这种情况下遇到的提示信息是“直接转换为数据？”此消息通常意味着IDA将取消定义足够数量的后续项以满足您的请求。例如，当将字节数据（`db`）转换为双字数据（`dd`）时，必须消耗3个额外的字节来形成新的数据项。
- en: Datatypes and sizes can be specified for any location that describes data, including
    stack variables. To change the size of stack-allocated variables, open the detailed
    stack frame view by double-clicking the variable you wish to modify; then change
    the variable’s size as you would any other variable.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为描述数据的任何位置指定数据类型和大小，包括栈变量。要更改栈分配变量的大小，请通过双击要修改的变量打开详细栈帧视图；然后像任何其他变量一样更改变量的大小。
- en: Working with Strings
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作
- en: IDA recognizes a large number of string formats. By default, IDA searches for
    and formats C-style null-terminated strings. To force data to be converted to
    a string, utilize the options on the Edit ▸ Strings menu to select a specific
    string style. If the bytes beginning at the currently selected address form a
    string of the selected style, IDA groups those bytes together into a single-string
    variable. At any time, you can use the A hotkey to format the currently selected
    location in the default string style.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: IDA识别大量字符串格式。默认情况下，IDA搜索并格式化C风格的空终止字符串。要强制数据转换为字符串，请使用“编辑”▸“字符串”菜单上的选项来选择特定的字符串样式。如果从当前选定的地址开始的字节形成一个所选样式的字符串，IDA将这些字节组合成一个单字符串变量。在任何时候，您都可以使用A快捷键以默认字符串样式格式化当前选定的位置。
- en: Two dialogs are responsible for the configuration of string data. The first,
    shown in [Figure 7-9](ch07s04.html#string_data_configuration "Figure 7-9. String
    data configuration"), is accessed via Options ▸ ASCII String Style, though ASCII
    in this case is a bit of a misnomer, as a much wider variety of string styles
    are understood.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个对话框负责字符串数据的配置。第一个，如图7-9所示，通过“选项”▸“ASCII字符串样式”访问，尽管在这个例子中，ASCII有点名不副实，因为这里理解了更广泛的字符串样式。
- en: Similar to the datatype configuration dialog, the buttons on the left are used
    to create a string of the specified style at the currently selected location.
    A string is created only if the data at the current location conforms to the specified
    string format. For *Character terminated* strings, up to two termination characters
    can be specified toward the bottom of the dialog. The radio buttons on the right
    of the dialog are used to specify the default string style associated with the
    use of the strings hotkey (A).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据类型配置对话框类似，左侧的按钮用于在当前选定的位置创建指定样式的字符串。只有当当前位置的数据符合指定的字符串格式时，才会创建字符串。对于*字符终止*字符串，可以在对话框底部指定最多两个终止字符。对话框右侧的单选按钮用于指定与字符串快捷键（A）使用关联的默认字符串样式。
- en: '![String data configuration](httpatomoreillycomsourcenostarchimages854161.png.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![字符串数据配置](httpatomoreillycomsourcenostarchimages854161.png.jpg)'
- en: Figure 7-9. String data configuration
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-9. 字符串数据配置
- en: The second dialog used to configure string operations is the Options ▸ General
    dialog, shown in [Figure 7-10](ch07s04.html#ida_strings_options "Figure 7-10. IDA
    Strings options"), where the Strings tab allows configuration of additional strings-related
    options. While you can specify the default string type here as well using the
    available drop-down box, the majority of available options deal with the naming
    and display of string data, regardless of their type. The Name generation area
    on the right of the dialog is visible only when the Generate names option is selected.
    When name generation is turned off, string variables are given dummy names beginning
    with the `asc_` prefix.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 用于配置字符串操作的第二个对话框是“选项 ▸ 一般”对话框，如图 [7-10](ch07s04.html#ida_strings_options "图
    7-10. IDA 字符串选项") 所示，其中“字符串”选项卡允许配置额外的字符串相关选项。虽然您也可以使用可用的下拉框在此处指定默认字符串类型，但大多数可用选项都涉及字符串数据的命名和显示，而不管它们的类型如何。当选择“生成名称”选项时，对话框右侧的“名称生成”区域才会可见。当关闭名称生成时，字符串变量将以以
    `asc_` 前缀开始的虚拟名称命名。
- en: '![IDA Strings options](httpatomoreillycomsourcenostarchimages854163.png.jpg)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
  zh: '![IDA 字符串选项](httpatomoreillycomsourcenostarchimages854163.png.jpg)'
- en: Figure 7-10. IDA Strings options
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-10. IDA 字符串选项
- en: 'When name generation is enabled, the Name generation options control how IDA
    generates names for string variables. When Generate serial names is *not* selected
    (the default), the specified prefix is combined with characters taken from the
    string to generate a name that does not exceed the current maximum name length.
    An example of such a string appears here:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用名称生成时，名称生成选项控制 IDA 如何为字符串变量生成名称。当未选择“生成序列名称”（默认选项）时，指定的前缀将与从字符串中取出的字符结合，生成一个不超过当前最大名称长度的名称。此类字符串的示例如下：
- en: '[PRE38]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Title case is used in the name, and any characters that are not legal to use
    within names (such as spaces) are omitted when forming the name. The Mark as autogenerated
    option causes generated names to appear in a different color (dark blue by default)
    than user-specified names (blue by default). Preserve case forces the name to
    use characters as they appear within the string rather than converting them to
    title case. Finally, Generate serial names causes IDA to serialize names by appending
    numeric suffixes (beginning with Number). The number of digits in generated suffixes
    is controlled by the Width field. As configured in [Figure 7-10](ch07s04.html#ida_strings_options
    "Figure 7-10. IDA Strings options"), the first three names to be generated would
    be `a000`, `a001`, and `a002`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中使用首字母大写形式，并且在形成名称时省略了在名称中不合法的字符（如空格）。选择“标记为自动生成”选项会使生成的名称以不同的颜色（默认为深蓝色）显示，与用户指定的名称（默认为蓝色）不同。保留大小写强制名称使用字符串中出现的字符，而不是将它们转换为首字母大写形式。最后，生成序列名称会使
    IDA 通过附加数字后缀（从“Number”开始）来序列化名称。生成的后缀中数字的位数由“宽度”字段控制。如 [图 7-10](ch07s04.html#ida_strings_options
    "图 7-10. IDA 字符串选项") 所配置，将生成的第一个三个名称将是 `a000`、`a001` 和 `a002`。
- en: Specifying Arrays
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定数组
- en: One of the drawbacks to disassembly listings derived from higher-level languages
    is that they provide very few clues regarding the size of arrays. In a disassembly
    listing, specifying an array can require a tremendous amount of space if each
    item in the array is specified on its own disassembly line. The following listing
    shows data declarations that follow the named variable `unk_402060`. The fact
    that only the first item in the listing is referenced by any instructions suggests
    that it may be the first element in an array. Rather than being referenced directly,
    additional elements within arrays are often referenced using more complex index
    computations to offset from the beginning of the array.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 从高级语言生成的反汇编列表的一个缺点是它们提供的关于数组大小的线索非常少。在反汇编列表中，如果数组中的每个项目都在其自己的反汇编行中指定，则指定数组可能需要大量的空间。以下列表显示了跟随命名变量
    `unk_402060` 的数据声明。仅列表中的第一个项目被任何指令引用的事实表明，它可能是数组中的第一个元素。数组中的其他元素通常不是直接引用，而是通过更复杂的索引计算来偏移数组起始位置进行引用。
- en: '[PRE39]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: IDA provides facilities for grouping consecutive data definitions together into
    a single array definition. To create an array, select the first element of the
    array (we chose `unk_402060`) and use Edit ▸ Array to launch the array-creation
    dialog shown in [Figure 7-11](ch07s04.html#array-creation_dialog "Figure 7-11. Array-creation
    dialog"). If a data item has been defined at a given location, then an Array option
    will be available when you right-click the item. The type of array to be created
    is dictated by the datatype associated with the item selected as the first item
    in the array. In this case we are creating an array of bytes.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 提供了将连续的数据定义组合成单个数组定义的功能。要创建一个数组，选择数组的第一个元素（我们选择了`unk_402060`），然后使用“编辑”▸“数组”来启动显示在[图
    7-11](ch07s04.html#array-creation_dialog "图 7-11. 数组创建对话框")中的数组创建对话框。如果在给定位置已定义了数据项，则在右键单击该项目时将可用数组选项。要创建的数组类型由作为数组第一个元素选择的项目关联的数据类型决定。在这种情况下，我们正在创建一个字节数组。
- en: '![Array-creation dialog](httpatomoreillycomsourcenostarchimages854165.png.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![数组创建对话框](httpatomoreillycomsourcenostarchimages854165.png.jpg)'
- en: Figure 7-11. Array-creation dialog
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-11. 数组创建对话框
- en: Note
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to creating an array, make sure that you select the proper size for array
    elements by changing the size of the first item in the array to the appropriate
    value.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数组之前，请确保通过更改数组中第一个元素的尺寸来选择适当的数组元素大小。
- en: 'Following are descriptions of useful fields for array creation:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对创建数组时有用字段的描述：
- en: '**Array element width**'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组元素宽度**'
- en: This value indicates the size of an individual array element (1 byte in this
    case) and is dictated by the size of the data value that was selected when the
    dialog was launched.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 此值表示单个数组元素的大小（在这种情况下为 1 字节），并且由启动对话框时选择的数据值的大小决定。
- en: '**Maximum possible size**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大可能大小**'
- en: This value is automatically computed as the maximum number of elements (not
    bytes) that can be included in the array before another defined data item is encountered.
    Specifying a larger size may be possible but will require succeeding data items
    to be undefined in order to absorb them into the array.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 此值自动计算为在遇到另一个定义的数据项之前可以包含在数组中的最大元素数（不是字节）。指定更大的大小可能是可能的，但将需要后续的数据项未定义，以便将它们吸收到数组中。
- en: '**Number of elements**'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素数量**'
- en: This is where you specify the exact size of the array. The total number of bytes
    occupied by the array can be computed as Number of elements × Array element width.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您指定数组确切大小的位置。数组占用的总字节数可以计算为元素数量 × 数组元素宽度。
- en: '**Items on a line**'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**每行项目**'
- en: Specifies the number of elements to be displayed on each disassembly line. This
    can be used to reduce the amount of space required to display the array.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要在每条反汇编行上显示的元素数量。这可以用来减少显示数组所需的空间。
- en: '**Element width**'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素宽度**'
- en: This value is for formatting purposes only and controls the column width when
    multiple items are displayed on a single line.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 此值仅用于格式化目的，并控制当多个项目在同一行上显示时的列宽。
- en: '**Use “dup” construct**'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用“dup”构造**'
- en: This option causes identical data values to be grouped into a single item with
    a repetition specifier.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将使相同的数据值组合成单个项目，并带有重复指定符。
- en: '**Signed elements**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '**有符号元素**'
- en: Dictates whether data is displayed as signed or unsigned values.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 指定数据是以有符号或无符号值的形式显示。
- en: '**Display indexes**'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示索引**'
- en: Causes array indexes to be displayed as regular comments. This is useful if
    you need to locate specific data values within large arrays. Selecting this option
    also enables the Indexes radio buttons so you can choose the display format for
    each index value.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 使数组索引以常规注释的形式显示。如果您需要在大型数组中定位特定的数据值，这很有用。选择此选项还将启用“索引”单选按钮，以便您可以选择每个索引值的显示格式。
- en: '**Create as array**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建为数组**'
- en: Not checking this may seem to go against the purpose of the dialog, and it is
    usually left checked. Uncheck it if your goal is simply to specify some number
    of consecutive items without grouping them into an array.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 不检查这一点似乎与对话框的目的相悖，并且通常会被选中。如果您只是想指定一些连续的项目而不将它们组合成数组，请取消选中。
- en: Accepting the options specified in [Figure 7-11](ch07s04.html#array-creation_dialog
    "Figure 7-11. Array-creation dialog") results in the following compact array declaration,
    which can be read as an array of bytes (`db`) named `byte_402060` consisting of
    the value `0` repeated `416` (`1A0h`) times.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 接受[图7-11](ch07s04.html#array-creation_dialog "图7-11. 数组创建对话框")中指定的选项，将产生以下紧凑的数组声明，它可以被读取为一个名为`byte_402060`的字节(`db`)数组，包含重复`416`次(`1A0h`)的值`0`。
- en: '[PRE40]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The net effect is that 416 lines of disassembly have been condensed to a single
    line (largely due to the use of `dup`). In the next chapter we will discuss the
    creation of arrays within stack frames.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，416行的反汇编代码被压缩成了一行（很大程度上归功于`dup`的使用）。在下一章中，我们将讨论在栈帧内创建数组。
- en: Summary
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Together with the previous chapter, this chapter encompasses the most common
    operations that IDA users will ever need to perform. Through the use of database
    modifications, you will combine your own knowledge with the knowledge imparted
    by IDA during its analysis phase to produce much more useful databases. As with
    source code, the effective use of names, assignment of datatypes, and detailed
    comments will not only assist you in remembering what you have analyzed but will
    also greatly assist others who may be required to make use of your work. In the
    next chapter we continue to drill into IDA’s capabilities by taking a look at
    how to deal with more complex data structures, such as those represented by the
    C `struct`, and go on to examine some of the low-level details of compiled C++.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一起，本章涵盖了IDA用户可能需要执行的最常见操作。通过使用数据库修改，您可以将自己的知识与IDA在分析阶段传授的知识结合起来，生成更有用的数据库。与源代码一样，有效使用名称、分配数据类型和详细注释不仅可以帮助您记住您已分析的内容，而且将极大地帮助那些可能需要使用您的工作的其他人。在下一章中，我们将继续深入探讨IDA的功能，通过查看如何处理更复杂的数据结构，例如由C的`struct`表示的数据结构，并继续检查编译的C++的一些低级细节。
- en: Chapter 8. Datatypes and Data Structures
  id: totrans-661
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：数据类型和数据结构
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: The low-hanging fruit in understanding the behavior of binary programs lies
    in cataloging the library functions that the program calls. A C program that calls
    the `connect` function is creating a network connection. A Windows program that
    calls `RegOpenKey` is accessing the Windows registry. Additional analysis is required,
    however, to gain an understanding of how and why these functions are called.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 理解二进制程序行为的关键低垂之果在于对程序调用的库函数进行分类。调用`connect`函数的C程序正在创建网络连接。调用`RegOpenKey`的Windows程序正在访问Windows注册表。然而，为了理解这些函数是如何以及为什么被调用，还需要进行额外的分析。
- en: Discovering how a function is called requires learning what parameters are passed
    to the function. In the case of a `connect` call, beyond the simple fact that
    the function is being called, it is important to know exactly what network address
    the program is connecting to. Understanding the data that is being passed into
    functions is the key to reverse engineering a function’s signature (the number,
    type, and sequence of parameters required by the function) and, as such, points
    out the importance of understanding how datatypes and data structures are manipulated
    at the assembly language level.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 发现函数的调用方式需要学习传递给函数的参数。在`connect`调用的例子中，除了知道函数正在被调用这一简单事实之外，了解程序连接的确切网络地址非常重要。理解传递给函数的数据是逆向工程函数签名（函数所需的参数的数量、类型和顺序）的关键，因此指出了在汇编语言级别理解数据类型和数据结构操作的重要性。
- en: 'In this chapter we will examine how IDA conveys datatype information to the
    user, how data structures are stored in memory, and how data within those data
    structures is accessed. The simplest method for associating a specific datatype
    with a variable is to observe the use of the variable as a parameter to a function
    that we know something about. During its analysis phase, IDA makes every effort
    to annotate datatypes when they can be deduced based on a variable’s use with
    a function for which IDA possesses a prototype. When possible, IDA will go as
    far as using a formal parameter name lifted from a function prototype rather than
    generating a default dummy name for the variable. This can be seen in the following
    disassembly of a call to `connect`:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨IDA如何向用户传达数据类型信息，数据结构如何在内存中存储，以及如何访问这些数据结构中的数据。将特定数据类型与变量关联的最简单方法是通过观察变量作为我们了解其用途的函数的参数的使用。在分析阶段，IDA会尽最大努力根据变量与IDA具有原型的函数的使用来注释数据类型。当可能时，IDA会尽可能使用从函数原型提升的正式参数名称，而不是为变量生成默认的占位符名称。这可以在以下对`connect`函数调用的反汇编中看到：
- en: '[PRE41]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this listing we can see that each `push` has been commented with the name
    of the parameter that is being pushed (taken from IDA’s knowledge of the function
    prototype). In addition, two local stack variables ![](httpatomoreillycomsourcenostarchimages854061.png)
    have been named for the parameters that they correspond to. In most cases, these
    names will be far more informative than the dummy names that IDA would otherwise
    generate.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们可以看到每个`push`操作都附带了被推入的参数名称（来自IDA对函数原型的了解）。此外，为对应参数的两个局部栈变量![httpatomoreillycomsourcenostarchimages854061.png]命名。在大多数情况下，这些名称将比IDA可能生成的占位符名称提供更多信息。
- en: IDA’s ability to propagate type information from function prototypes is not
    limited to library functions contained in IDA’s type libraries. IDA can propagate
    formal parameter names and data types from any function in your database as long
    as you have explicitly set the function’s type information. Upon initial analysis,
    IDA assigns dummy names and the generic type `int` to all function arguments,
    unless through type propagation it has reason to do otherwise. In any case, you
    must set a function’s type by using the Edit ▸ Functions ▸ Set Function Type command,
    right-clicking on a function name, and choosing Set Function Type on the context
    menu or using the Y hotkey. For the function shown below, this results in the
    dialog shown in [Figure 8-1](ch08.html#setting_a_functionas_type "Figure 8-1. Setting
    a function’s type"), in which you may enter the function’s correct prototype.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: IDA从函数原型传播类型信息的能力不仅限于IDA类型库中包含的库函数。只要您已明确设置函数的类型信息，IDA就可以从数据库中的任何函数传播正式参数名称和数据类型。在初始分析时，IDA将占位符名称和通用类型`int`分配给所有函数参数，除非通过类型传播它有理由这样做。在任何情况下，您必须通过使用“编辑”▸“函数”▸“设置函数类型”命令、右键单击函数名称并在上下文菜单中选择“设置函数类型”或使用Y快捷键来设置函数的类型。对于下面的函数，这会导致显示[图8-1](ch08.html#setting_a_functionas_type
    "图8-1. 设置函数的类型")中的对话框，您可以在其中输入函数的正确原型。
- en: '[PRE42]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As shown below, IDA assumes an `int` return type, correctly deduces that the
    `cdecl` calling convention is used based on the type of `ret` instruction used,
    incorporates the name of the function as we have modified it, and assumes all
    parameters are of type `int`. Because we have not yet modified the argument names,
    IDA displays only their types.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，IDA假设返回类型为`int`，根据使用的`ret`指令类型正确地推断出使用了`cdecl`调用约定，结合我们修改后的函数名称，并假设所有参数类型为`int`。因为我们尚未修改参数名称，所以IDA只显示它们的类型。
- en: '![Setting a function’s type](httpatomoreillycomsourcenostarchimages854167.png.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
  zh: '![设置函数的类型](httpatomoreillycomsourcenostarchimages854167.png.jpg)'
- en: Figure 8-1. Setting a function’s type
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1. 设置函数的类型
- en: If we modify the prototype to read `int __cdecl foo(float f, char *ptr)`, IDA
    will automatically insert a prototype comment ![](httpatomoreillycomsourcenostarchimages854061.png)
    for the function and change the argument names ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the disassembly as shown below.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将原型修改为`int __cdecl foo(float f, char *ptr)`，IDA将自动为函数插入原型注释![httpatomoreillycomsourcenostarchimages854061.png]，并更改反汇编中的参数名称![httpatomoreillycomsourcenostarchimages854063.png]，如下所示。
- en: '[PRE43]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, IDA propagates this information to all callers of the newly modified
    function, resulting in improved annotation of all related function calls as shown
    here. Note that the argument names `f` and `ptr` have been propagated out as comments
    ![](httpatomoreillycomsourcenostarchimages854093.png) in the calling function
    and used to rename variables ![](httpatomoreillycomsourcenostarchimages854095.png)
    that formerly used dummy names.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，IDA将此信息传播到所有新修改函数的调用者，从而改进了所有相关函数调用的注释，如下所示。注意，参数名称 `f` 和 `ptr` 已经作为注释传播出去！![图片](http://atomoreilly.com/source/nostarch/images/854093.png)在调用函数中，并用于重命名之前使用虚拟名称的变量！![图片](http://atomoreilly.com/source/nostarch/images/854095.png)
- en: '[PRE44]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Returning to imported library functions, it is often the case that IDA will
    already know the prototype of the function. In such cases, you can easily view
    the prototype by holding the mouse over the function name.^([[44](#ftn.CHP-8-FN-1)])
    When IDA has no knowledge of a function’s parameter sequence, it should, at a
    minimum, know the name of the library from which the function was imported (see
    the Imports window). When this happens, your best resources for learning the behavior
    of the function are any associated man pages or other available API documentation
    (such as MSDN online^([[45](#ftn.CHP-8-FN-2)])). When all else fails, remember
    the adage: *Google is your friend*.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到导入的库函数，通常IDA已经知道函数的原型。在这种情况下，你可以通过将鼠标悬停在函数名称上轻松地查看原型。^([[44](#ftn.CHP-8-FN-1)])
    当IDA不知道函数的参数序列时，它至少应该知道函数是从哪个库导入的（参见导入窗口）。当这种情况发生时，你学习函数行为的最佳资源是任何相关的手册页或其他可用的API文档（如MSDN在线^([[45](#ftn.CHP-8-FN-2)])）。当所有其他方法都失败时，请记住这句谚语：*谷歌是你的朋友*。
- en: For the remainder of this chapter, we will be discussing how to recognize when
    data structures are being used in a program, how to decipher the organizational
    layout of such structures, and how to use IDA to improve the readability of a
    disassembly when such structures are in use. Since C++ classes are a complex extension
    of C structures, the chapter concludes with a discussion of reverse engineering
    compiled C++ programs.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分，我们将讨论如何在程序中识别数据结构的使用，如何解码这些结构的组织布局，以及如何使用IDA在数据结构使用时提高反汇编的可读性。由于C++类是C结构的复杂扩展，本章以对反汇编C++程序进行逆向工程讨论结束。
- en: Recognizing Data Structure Use
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别数据结构的使用
- en: While primitive datatypes are often a natural fit with the size of a CPU’s registers
    or instruction operands, composite datatypes such as arrays and structures typically
    require more complex instruction sequences in order to access the individual data
    items that they contain. Before we can discuss IDA’s feature for improving the
    readability of code that utilizes complex datatypes, we need to review what that
    code looks like.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原始数据类型通常与CPU寄存器或指令操作数的大小自然匹配，但如数组和解构等复合数据类型通常需要更复杂的指令序列来访问它们包含的各个数据项。在我们可以讨论IDA提高使用复杂数据类型代码可读性的功能之前，我们需要回顾一下这种代码的外观。
- en: Array Member Access
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组成员访问
- en: Arrays are the simplest composite data structure in terms of memory layout.
    Traditionally, arrays are contiguous blocks of memory that contain consecutive
    elements of the same datatype. The size of an array is easy to compute, as it
    is the product of the number of elements in the array and the size of each element.
    Using C notation, the minimum number of bytes consumed by the following array
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存布局方面，数组是最简单的复合数据结构。传统上，数组是包含相同数据类型连续元素的连续内存块。数组的大小很容易计算，因为它是由数组中元素的数量和每个元素的大小相乘得到的。使用C表示法，以下数组的最低字节消耗量
- en: '[PRE45]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: is computed as
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 计算如下
- en: '[PRE46]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Individual array elements are accessed by supplying an index value, which may
    be a variable or a constant, as shown in these array references:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个索引值来访问单个数组元素，这个索引值可以是变量或常量，如下所示，这些数组引用：
- en: '[PRE47]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Assuming, for the sake of example, that `sizeof(int)` is 4 bytes, then the first
    array access at ![](httpatomoreillycomsourcenostarchimages854061.png) accesses
    the integer value that lies 80 bytes into the array, while the second array access
    at ![](httpatomoreillycomsourcenostarchimages854063.png) accesses successive integers
    at offsets 0, 4, 8, .. 96 bytes into the array. The offset for the first array
    access can be computed at compile time as `20 * 4`. In most cases, the offset
    for the second array access must be computed at runtime because the value of the
    loop counter, `i`, is not fixed at compile time. Thus for each pass through the
    loop, the product `i * 4` must be computed to determine the exact offset into
    the array. Ultimately, the manner in which an array element is accessed depends
    not only on the type of index used but also on where the array happens to be allocated
    within the program’s memory space.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了举例，`sizeof(int)` 是 4 字节，那么在 ![](httpatomoreillycomsourcenostarchimages854061.png)
    的第一次数组访问中，访问了数组中位于 80 字节处的整数值，而第二次数组访问在 ![](httpatomoreillycomsourcenostarchimages854063.png)
    中访问了数组中偏移量为 0、4、8、... 96 字节的连续整数。第一次数组访问的偏移量可以在编译时计算为 `20 * 4`。在大多数情况下，第二次数组访问的偏移量必须在运行时计算，因为循环计数器
    `i` 的值在编译时是不固定的。因此，对于循环的每次迭代，都必须计算乘积 `i * 4` 以确定数组中的确切偏移量。最终，访问数组元素的方式不仅取决于所使用的索引类型，还取决于数组在程序内存空间中的分配位置。
- en: Globally Allocated Arrays
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局分配的数组
- en: 'When an array is allocated within the global data area of a program (within
    the `.data` or `.bss` section, for example), the base address of the array is
    known to the compiler at compile time. The fixed base address makes it possible
    for the compiler to compute fixed addresses for any array element that is accessed
    using a fixed index. Consider the following trivial program that accesses a global
    array using both fixed and variable offsets:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组在程序的全球数据区（例如 `.data` 或 `.bss` 部分）内分配时，编译器在编译时已知数组的基址。固定的基址使得编译器能够计算使用固定索引访问的任何数组元素的固定地址。考虑以下使用固定和可变偏移量访问全局数组的简单程序：
- en: '[PRE48]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This program disassembles to the following:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序反汇编为以下内容：
- en: '[PRE49]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: While this program has only one global variable, the disassembly lines at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png)
    seem to indicate that there are three global variables. The computation of an
    offset (`eax * 4`) at ![](httpatomoreillycomsourcenostarchimages854095.png) is
    the only thing that seems to hint at the presence of a global array named `dword_40B720`,
    yet this is the same name as the global variable found at ![](httpatomoreillycomsourcenostarchimages854061.png).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个程序只有一个全局变量，但 ![](httpatomoreillycomsourcenostarchimages854061.png)、![](httpatomoreillycomsourcenostarchimages854063.png)
    和 ![](httpatomoreillycomsourcenostarchimages854093.png) 中的反汇编行似乎表明存在三个全局变量。在 ![](httpatomoreillycomsourcenostarchimages854095.png)
    处计算偏移量（`eax * 4`）似乎是唯一暗示存在名为 `dword_40B720` 的全局数组的线索，而这个名称与在 ![](httpatomoreillycomsourcenostarchimages854061.png)
    处找到的全局变量相同。
- en: 'Based on the dummy names assigned by IDA, we know that the global array is
    made up of the 12 bytes beginning at address `0040B720`. During the compilation
    process, the compiler has used the fixed indexes (0, 1, 2) to compute the actual
    addresses of the corresponding elements in the array (`0040B720`, `0040B724`,
    and `0040B728`), which are referenced using the global variables at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png).
    Using IDA’s array-formatting operations discussed in the last chapter (Edit ▸
    Array), `dword_40B720` can be formatted as a three-element array yielding the
    alternate disassembly lines shown in the following listing. Note that this particular
    formatting highlights the use of offsets into the array:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IDA分配的虚拟名称，我们知道全局数组由从地址 `0040B720` 开始的 12 个字节组成。在编译过程中，编译器使用了固定的索引（0、1、2）来计算数组中相应元素的实际地址（`0040B720`、`0040B724`
    和 `0040B728`），这些地址通过全局变量在 ![](httpatomoreillycomsourcenostarchimages854061.png)、![](httpatomoreillycomsourcenostarchimages854063.png)
    和 ![](httpatomoreillycomsourcenostarchimages854093.png) 中引用。使用上一章中讨论的IDA的数组格式化操作（编辑
    ▸ 数组），可以将 `dword_40B720` 格式化为一个包含三个元素的数组，如下面的列表所示。请注意，这种特定的格式化突出了数组偏移量的使用：
- en: '[PRE50]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are two points to note in this example. First, when constant indexes are
    used to access global arrays, the corresponding array elements will appear as
    global variables in the corresponding disassembly. In other words, the disassembly
    will offer essentially no evidence that an array exists. The second point is that
    the use of variable index values leads us to the start of the array because the
    base address will be revealed (as in ![](httpatomoreillycomsourcenostarchimages854095.png))
    when the computed offset is added to it to compute the actual array location to
    be accessed. The computation at ![](httpatomoreillycomsourcenostarchimages854095.png)
    offers one additional piece of significant information about the array. By observing
    the amount by which the array index is multiplied (4 in this case), we learn the
    size (though not the type) of an individual element in the array.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中有两点需要注意。首先，当使用常量索引访问全局数组时，相应的数组元素将作为全局变量出现在相应的汇编中。换句话说，汇编将几乎不提供存在数组的证据。第二点是，使用变量索引值将我们引导到数组的起始位置，因为当计算偏移量加到它上面以计算要访问的实际数组位置时，基址将被揭示（如![httpatomoreillycomsourcenostarchimages854095.png](httpatomoreillycomsourcenostarchimages854095.png)所示）。在![httpatomoreillycomsourcenostarchimages854095.png](httpatomoreillycomsourcenostarchimages854095.png)的计算提供有关数组的一个额外重要信息。通过观察数组索引乘以的量（本例中为4），我们了解到数组中单个元素的大小（尽管不是类型）。
- en: Stack-Allocated Arrays
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈分配的数组
- en: How does array access differ if the array is allocated as a stack variable instead?
    Instinctively, we might think that it must be different since the compiler can’t
    know an absolute address at compile time, so surely even accesses that use constant
    indexes must require some computation at runtime. In practice, however, compilers
    treat stack-allocated arrays almost identically to globally allocated arrays.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组作为堆栈变量分配，数组访问会有何不同？直观上，我们可能会认为它必须不同，因为编译器在编译时无法知道绝对地址，因此肯定即使是使用常量索引的访问也必须在运行时进行一些计算。然而，在实践中，编译器几乎将堆栈分配的数组与全局分配的数组同等对待。
- en: 'Consider the following program that makes use of a small stack-allocated array:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用小型堆栈分配数组的程序：
- en: '[PRE51]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The address at which `stack_array` will be allocated is unknown at compile
    time, so it is not possible for the compiler to precompute the address of `stack_array[1]`
    at compile time as it did in the global array example. By examining the disassembly
    listing for this function, we gain insight into how stack-allocated arrays are
    accessed:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，`stack_array`的分配地址是未知的，因此编译器无法像全局数组示例中那样在编译时预先计算`stack_array[1]`的地址。通过检查此函数的汇编列表，我们可以了解堆栈分配的数组是如何被访问的：
- en: '[PRE52]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As with the global array example, this function appears to have three variables
    (`var_10`, `var_C`, and `var_8`) rather than an array of three integers. Based
    on the constant operands used at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png),
    we know that what appear to be local variable references are actually references
    to the three elements of `stack_array` whose first element must reside at `var_10`,
    the local variable with the lowest memory address.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局数组示例一样，此函数似乎有三个变量（`var_10`、`var_C`和`var_8`），而不是三个整数的数组。根据在![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)、![httpatomoreillycomsourcenostarchimages854063.png](httpatomoreillycomsourcenostarchimages854063.png)和![httpatomoreillycomsourcenostarchimages854093.png]使用的常量操作数，我们知道看似局部变量引用实际上是对`stack_array`的三个元素的引用，其中第一个元素必须位于内存地址最低的局部变量`var_10`处。
- en: To understand how the compiler resolved the references to the other elements
    of the array, consider what the compiler goes through when dealing with the reference
    to `stack_array[1]`, which lies 4 bytes into the array, or 4 bytes beyond the
    location of `var_10`. Within the stack frame, the compiler has elected to allocate
    `stack_array` at `ebp - 0x10`. The compiler understands that `stack_array[1]`
    lies at `ebp - 0x10 + 4`, which simplifies to `ebp - 0x0C`. The result is that
    IDA displays this as a local variable reference. The net effect is that, similar
    to globally allocated arrays, the use of constant index values tends to hide the
    presence of a stack-allocated array. Only the array access at ![](httpatomoreillycomsourcenostarchimages854095.png)
    hints at the fact that `var_10` is the first element in the array rather than
    a simple integer variable. In addition, the disassembly line at ![](httpatomoreillycomsourcenostarchimages854095.png)
    also helps us conclude that the size of individual elements in the array is 4
    bytes.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解编译器如何解析对数组其他元素的引用，可以考虑编译器在处理对`stack_array[1]`的引用时所经历的过程，该引用位于数组中4个字节的位置，或者位于`var_10`位置之后的4个字节。在栈帧中，编译器选择在`ebp
    - 0x10`处分配`stack_array`。编译器明白`stack_array[1]`位于`ebp - 0x10 + 4`，这简化为`ebp - 0x0C`。结果是IDA将其显示为局部变量引用。总体效果是，与全局分配的数组类似，使用常量索引值往往隐藏了栈分配数组的存在。只有数组访问处的![图片](httpatomoreillycomsourcenostarchimages854095.png)才暗示`var_10`是数组中的第一个元素，而不是一个简单的整数变量。此外，![图片](httpatomoreillycomsourcenostarchimages854095.png)处的反汇编行也有助于我们得出数组中单个元素大小为4个字节的结论。
- en: Stack-allocated arrays and globally allocated arrays are thus treated very similarly
    by compilers. However, there is an extra piece of information that we can attempt
    to extract from the disassembly of the stack example. Based on the location of
    `idx` within the stack, it is possible to conclude that the array that begins
    with `var_10` contains no more than three elements (otherwise, it would overwrite
    `idx`). If you are an exploit developer, this can be very useful in determining
    exactly how much data you can fit into an array before you overflow it and begin
    to corrupt the data that follows.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 栈分配数组和全局分配数组在编译器中处理得非常相似。然而，我们可以从栈示例的反汇编中提取一些额外信息。根据`idx`在栈中的位置，我们可以得出结论，以`var_10`开始的数组最多包含三个元素（否则会覆盖`idx`）。如果你是漏洞开发者，这可以在确定在溢出并开始损坏后续数据之前，你可以将多少数据放入数组中时非常有用。
- en: Heap-Allocated Arrays
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆分配数组
- en: 'Heap-allocated arrays are allocated using a dynamic memory allocation function
    such as `malloc` (C) or `new` (C++). From the compiler’s perspective, the primary
    difference in dealing with a heap-allocated array is that the compiler must generate
    all references into the array based on the address value returned from the memory
    allocation function. For the sake of comparison, we now take a look at the following
    function, which allocates a small array in the program heap:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配数组使用动态内存分配函数，如`malloc`（C）或`new`（C++）进行分配。从编译器的角度来看，处理堆分配数组的主要区别是编译器必须根据内存分配函数返回的地址值生成所有对数组的引用。为了进行比较，我们现在看一下以下函数，它在程序堆中分配了一个小数组：
- en: '[PRE53]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In studying the corresponding disassembly that follows, you should notice a
    few similarities and differences with the two previous disassemblies:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究后续的反汇编代码时，你应该注意到与前面两个反汇编代码的一些相似之处和不同之处：
- en: '[PRE54]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The starting address of the array (returned from `malloc` in the EAX register)
    is stored in the local variable `heap_array`. In this example, unlike the previous
    examples, every access to the array begins with reading the contents of `heap_array`
    to obtain the array’s base address before an offset value can be added to compute
    the address of the correct element within the array. The references to `heap_array[0]`,
    `heap_array[1]`, and `heap_array[2]` require offsets of 0, 4, and 8 bytes, respectively,
    as seen at ![](httpatomoreillycomsourcenostarchimages854061.png), ![](httpatomoreillycomsourcenostarchimages854063.png),
    and ![](httpatomoreillycomsourcenostarchimages854093.png). The operation that
    most closely resembles the previous examples is the reference to `heap_array[idx]`
    at ![](httpatomoreillycomsourcenostarchimages854095.png), in which the offset
    into the array continues to be computed by multiplying the array index by the
    size of an array element.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的起始地址（由`malloc`返回并存储在EAX寄存器中）被存储在局部变量`heap_array`中。在本例中，与先前的例子不同，每次访问数组时，都需要先读取`heap_array`的内容以获取数组的基址，然后才能将偏移量值添加到计算数组中正确元素的地址。`heap_array[0]`、`heap_array[1]`和`heap_array[2]`的引用分别需要0、4和8字节的偏移量，如![](httpatomoreillycomsourcenostarchimages854061.png)、![](httpatomoreillycomsourcenostarchimages854063.png)和![](httpatomoreillycomsourcenostarchimages854093.png)所示。与先前的例子最相似的操作是![](httpatomoreillycomsourcenostarchimages854095.png)中`heap_array[idx]`的引用，其中数组中的偏移量继续通过将数组索引乘以数组元素的大小来计算。
- en: Heap-allocated arrays have one particularly nice feature. When both the total
    size of the array and the size of each element can be determined, it is easy to
    compute the number of elements allocated to the array. For heap-allocated arrays,
    the parameter passed to the memory allocation function (`0x0C` passed to `malloc`
    at ![](httpatomoreillycomsourcenostarchimages854099.png)) represents the total
    number of bytes allocated to the array. Dividing this by the size of an element
    (4 bytes in this example, as observed from the offsets at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png))
    tells us the number of elements in the array. In the previous example, a three-element
    array was allocated.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配的数组有一个特别好的特性。当数组的总大小和每个元素的大小都可以确定时，计算分配给数组的元素数量就变得很容易。对于堆分配的数组，传递给内存分配函数的参数（在本例中是传递给`malloc`的`0x0C`）代表分配给数组的总字节数。将这个值除以元素的大小（在本例中为4字节，如从![](httpatomoreillycomsourcenostarchimages854061.png)、![](httpatomoreillycomsourcenostarchimages854063.png)和![](httpatomoreillycomsourcenostarchimages854093.png)中的偏移量观察到的）将告诉我们数组中的元素数量。在先前的例子中，分配了一个包含三个元素的数组。
- en: The only firm conclusion we can draw regarding the use of arrays is that they
    are easiest to recognize when a variable is used as an index into the array. The
    array-access operation requires the index to be scaled by the size of an array
    element before adding the resulting offset to the base address of the array. Unfortunately,
    as we will show in the next section, when constant index values are used to access
    array elements, they do little to suggest the presence of an array and look remarkably
    similar to code used to access structure members.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的使用的唯一确定结论是，当变量用作数组的索引时，数组最容易识别。数组访问操作需要将索引乘以数组元素的大小，然后将结果偏移量加到数组的基址上。不幸的是，正如我们将在下一节中展示的，当使用常量索引值来访问数组元素时，它们几乎不能表明数组的存在，并且看起来与用于访问结构成员的代码非常相似。
- en: Structure Member Access
  id: totrans-715
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构成员访问
- en: C-style structs, referred to here generically as *structures*, are heterogeneous
    collections of data that allow grouping of items of dissimilar datatypes into
    a single composite datatype. A major distinguishing feature of structures is that
    the data fields within a structure are accessed by name rather than by index,
    as is done with arrays. Unfortunately, field names are converted to numeric offsets
    by the compiler, so by the time you are looking at a disassembly, structure field
    access looks remarkably similar to accessing array elements using constant indexes.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里泛指为*结构*的C风格结构是异构数据集合，它允许将不同数据类型的项组合成一个单一复合数据类型。结构的一个主要特点是结构内的数据字段是通过名称而不是通过索引来访问的，就像数组一样。不幸的是，字段名称被编译器转换为数值偏移量，所以在查看反汇编代码时，结构字段访问看起来与使用常量索引访问数组元素非常相似。
- en: 'When a compiler encounters a structure definition, the compiler maintains a
    running total of the number of bytes consumed by the fields of the structure in
    order to determine the offset at which each field resides within the structure.
    The following structure definition will be used with the upcoming examples:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到结构定义时，编译器会维护一个字段消耗的字节数的累计总和，以确定每个字段在结构中的偏移量。以下结构定义将用于接下来的示例：
- en: '[PRE55]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The minimum required space to allocate a structure is determined by the sum
    of the space required to allocate each field within the structure. However, you
    should never assume that a compiler utilizes the minimum required space to allocate
    a structure. By default, compilers seek to align structure fields to memory addresses
    that allow for the most efficient reading and writing of those fields. For example,
    4-byte integer fields will be aligned to offsets that are divisible by 4, while
    8-byte doubles will be aligned to offsets that are divisible by 8\. Depending
    on the composition of the structure, meeting alignment requirements may require
    the insertion of padding bytes, causing the actual size of a structure to be larger
    than the sum of its component fields. The default offsets and resulting structure
    size for the example structure shown previously can be seen in the `Default offset`
    column.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 分配结构所需的最小空间由结构内部每个字段分配所需空间的总和决定。然而，你绝不应该假设编译器会使用分配结构所需的最小空间。默认情况下，编译器会尝试将结构字段对齐到允许最有效读写这些字段的内存地址。例如，4字节整数字段将对齐到4的倍数偏移量，而8字节双精度浮点数将对齐到8的倍数偏移量。根据结构的组成，满足对齐要求可能需要插入填充字节，导致结构的实际大小大于其组成部分字段的总和。之前显示的示例结构的默认偏移量和结果结构大小可以在“默认偏移”列中查看。
- en: Structures can be packed into the minimum required space by using compiler options
    to request specific member alignments. Microsoft Visual C/C++ and GNU gcc/g++
    both recognize the `pack` pragma as a means of controlling structure field alignment.
    The GNU compilers additionally recognize the `packed` attribute as a means of
    controlling structure alignment on a per-structure basis. Requesting 1-byte alignment
    for structure fields causes compilers to squeeze the structure into the minimum
    required space. For our example structure, this yields the offsets and structure
    size found in the `Minimum offset` column. Note that some CPUs perform better
    when data is aligned according to its type, while other CPUs may generate exceptions
    if data is *not* aligned on specific boundaries.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用编译器选项请求特定成员对齐来将结构压缩到所需的最小空间。Microsoft Visual C/C++ 和 GNU gcc/g++ 都将 `pack`
    预处理指令识别为控制结构字段对齐的一种方式。GNU 编译器还识别 `packed` 属性作为控制结构对齐的一种方式。请求结构字段为1字节对齐会导致编译器将结构压缩到所需的最小空间。对于我们的示例结构，这会产生“最小偏移”列中找到的偏移量和结构大小。请注意，某些CPU在数据根据其类型对齐时性能更好，而其他CPU如果数据没有对齐到特定边界可能会生成异常。
- en: With these facts in mind, we can begin our look at how structures are treated
    in compiled code. For the sake of comparison, it is worth observing that, as with
    arrays, access to structure members is performed by adding the base address of
    the structure to the offset of the desired member. However, while array offsets
    can be computed at runtime from a provided index value (because each item in an
    array has the same size), structure offsets must be precomputed and will turn
    up in compiled code as fixed offsets into the structure, looking nearly identical
    to array references that make use of constant indexes.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些事实，我们可以开始探讨编译代码中结构是如何处理的。为了进行比较，值得注意的是，与数组一样，结构成员的访问是通过将结构的基本地址加上所需成员的偏移量来完成的。然而，虽然数组偏移量可以在运行时从提供的索引值计算得出（因为数组中的每个项目都有相同的大小），结构偏移量必须预先计算，并且将在编译代码中以固定偏移量的形式出现在结构中，看起来几乎与使用常量索引的数组引用相同。
- en: Globally Allocated Structures
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局分配的结构
- en: 'As with globally allocated arrays, the address of globally allocated structures
    is known at compile time. This allows the compiler to compute the address of each
    member of the structure at compile time and eliminates the need to do any math
    at runtime. Consider the following program that accesses a globally allocated
    structure:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局分配的数组一样，全局分配的结构地址在编译时是已知的。这允许编译器在编译时计算结构每个成员的地址，从而消除了在运行时进行任何数学运算的需要。考虑以下访问全局分配结构的程序：
- en: '[PRE56]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If this program is compiled with default structure alignment options, we can
    expect to see something like the following when we disassemble it:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个程序使用默认的结构对齐选项进行编译，当我们反汇编它时，我们可以期待看到以下内容：
- en: '[PRE57]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This disassembly contains no math whatsoever to access the members of the structure,
    and, in the absence of source code, it would not be possible to state with any
    certainty that a structure is being used at all. Because the compiler has performed
    all of the offset computations at compile time, this program appears to reference
    five global variables rather than five fields within a single structure. You should
    be able to note the similarities with the previous example regarding globally
    allocated arrays using constant index values.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 此反汇编中没有进行任何数学运算来访问结构的成员，在没有源代码的情况下，不可能确定是否使用了结构。由于编译器在编译时已经完成了所有偏移量的计算，这个程序看起来引用了五个全局变量，而不是单个结构中的五个字段。你应该能够注意到与之前关于使用常量索引值的全局分配数组的例子之间的相似之处。
- en: Stack-Allocated Structures
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈分配的结构
- en: 'Like stack-allocated arrays (see [Stack-Allocated Arrays](ch08.html#stack-allocated_arrays
    "Stack-Allocated Arrays")), stack-allocated structures are equally difficult to
    recognize based on stack layout alone. Modifying the preceding program to use
    a stack-allocated structure, declared in `main`, yields the following disassembly:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 与栈分配的数组（见[栈分配的数组](ch08.html#stack-allocated_arrays "栈分配的数组"））一样，仅根据栈布局很难识别栈分配的结构。将前面的程序修改为使用在`main`中声明的栈分配结构，会产生以下反汇编：
- en: '[PRE58]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Again, no math is performed to access the structure’s fields since the compiler
    can determine the relative offsets for each field within the stack frame at compile
    time. In this case, we are left with the same, potentially misleading picture
    that five individual variables are being used rather than a single variable that
    happens to contain five distinct fields. In reality, `var_18` should be the start
    of a 24-byte structure, and each of the other variables should somehow be formatted
    to reflect the fact that they are fields within the structure.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，访问结构字段时没有进行任何数学运算，因为编译器可以在编译时确定栈帧中每个字段的相对偏移量。在这种情况下，我们面临的是相同的、可能具有误导性的图景，即使用五个单独的变量而不是一个恰好包含五个不同字段的单一变量。实际上，`var_18`应该是24字节结构的开头，而其他每个变量都应该以某种方式格式化，以反映它们是结构内的字段。
- en: Heap-Allocated Structures
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆分配的结构
- en: Heap-allocated structures turn out to be much more revealing regarding the size
    of the structure and the layout of its fields. When a structure is allocated in
    the program heap, the compiler has no choice but to generate code to compute the
    proper offset into the structure whenever a field is accessed. This is a result
    of the structure’s address being unknown at compile time. For globally allocated
    structures, the compiler is able to compute a fixed starting address. For stack-allocated
    structures, the compiler can compute a fixed relationship between the start of
    the structure and the frame pointer for the enclosing stack frame. When a structure
    has been allocated in the heap, the only reference to the structure available
    to the compiler is the pointer to the structure’s starting address.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配的结构在揭示结构的大小及其字段布局方面显得更为明显。当一个结构在程序堆中分配时，编译器别无选择，只能生成代码来计算访问字段时结构中的正确偏移量。这是由于结构地址在编译时是未知的。对于全局分配的结构，编译器能够计算一个固定的起始地址。对于栈分配的结构，编译器可以计算结构起始地址与包围栈帧的帧指针之间的固定关系。当一个结构在堆中分配时，编译器可用的唯一结构引用是该结构起始地址的指针。
- en: 'Modifying our structure example once again to make use of a heap-allocated
    structure results in the following disassembly. Similar to the heap-allocated
    array example from page 134, we declare a pointer within `main` and assign it
    the address of a block of memory large enough to hold our structure:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的结构示例再次修改为使用堆分配结构，结果如下所示。类似于第134页的堆分配数组示例，我们在`main`中声明一个指针，并将其分配给足够容纳我们的结构的大块内存：
- en: '[PRE59]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this example, unlike the global and stack-allocated structure examples,
    we are able to discern the exact size and layout of the structure. The structure
    size can be inferred to be 24 bytes based on the amount of memory requested from
    `malloc` ![](httpatomoreillycomsourcenostarchimages854101.png). The structure
    contains the following fields at the indicated offsets:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，与全局和栈分配的结构体示例不同，我们能够确定结构的精确大小和布局。结构体的大小可以根据从`malloc`请求的内存量推断为24字节 ![](httpatomoreillycomsourcenostarchimages854101.png)。结构体在指定的偏移量包含以下字段：
- en: A 4-byte (`dword`) field at offset 0 ![](httpatomoreillycomsourcenostarchimages854061.png)
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个位于偏移量0的4字节(`dword`)字段 ![](httpatomoreillycomsourcenostarchimages854061.png)
- en: A 2-byte (`word`) field at offset 4 ![](httpatomoreillycomsourcenostarchimages854063.png)
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个位于偏移量4的2字节(`word`)字段 ![](httpatomoreillycomsourcenostarchimages854063.png)
- en: A 1-byte field at offset 6 ![](httpatomoreillycomsourcenostarchimages854093.png)
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个位于偏移量6的1字节字段 ![](httpatomoreillycomsourcenostarchimages854093.png)
- en: A 4-byte (`dword`) field at offset 8 ![](httpatomoreillycomsourcenostarchimages854095.png)
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个位于偏移量8的4字节(`dword`)字段 ![](httpatomoreillycomsourcenostarchimages854095.png)
- en: An 8-byte (`qword`) field at offset 16 (10h) ![](httpatomoreillycomsourcenostarchimages854099.png)
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个位于偏移量16（10h）的8字节(`qword`)字段 ![](httpatomoreillycomsourcenostarchimages854099.png)
- en: 'Based on the use of floating point instructions, we can further deduce that
    the `qword` field is actually a `double`. The same program compiled to pack structures
    with a 1-byte alignment yields the following disassembly:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 根据浮点指令的使用，我们可以进一步推断出`qword`字段实际上是一个`double`。将相同的程序编译成使用1字节对齐的结构体，得到的反汇编如下：
- en: '[PRE60]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only changes to the program are the smaller size of the structure (now 19
    bytes) and the adjusted offsets to account for the realignment of each structure
    field.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的唯一变化是结构体的大小变小（现在为19字节）以及调整了偏移量以适应每个结构体字段的重新对齐。
- en: Regardless of the alignment used when compiling a program, finding structures
    allocated and manipulated in the program heap is the fastest way to determine
    the size and layout of a given data structure. However, keep in mind that many
    functions will not do you the favor of immediately accessing every member of a
    structure to help you understand the structure’s layout. Instead, you may need
    to follow the use of the pointer to the structure and make note of the offsets
    used whenever that pointer is dereferenced. In this manner, you will eventually
    be able to piece together the complete layout of the structure.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在编译程序时使用何种对齐方式，找到程序堆中分配和操作的结构体是确定给定数据结构大小和布局的最快方法。然而，请注意，许多函数不会立即访问结构体的每个成员来帮助你理解结构的布局。相反，你可能需要跟踪结构体指针的使用，并在指针解引用时记录使用的偏移量。这样，你最终能够拼凑出结构的完整布局。
- en: Arrays of Structures
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体数组
- en: 'Some programmers would say that the beauty of composite data structures is
    that they allow you to build arbitrarily complex structures by nesting smaller
    structures within larger structures. Among other possibilities, this capability
    allows for arrays of structures, structures within structures, and structures
    that contain arrays as members. The preceding discussions regarding arrays and
    structures apply just as well when dealing with nested types such as these. As
    an example, consider an array of structures like the following simple program
    in which `heap_struct` points to an array of five `ch8_struct` items:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员会说，复合数据结构的美丽之处在于它们允许你在较大的结构体内部嵌套较小的结构体，从而构建任意复杂的结构。在其他可能性中，这种能力允许有结构体数组、结构体嵌套以及作为成员的结构体包含数组。关于数组和结构体的先前的讨论，在处理这些嵌套类型时同样适用。例如，考虑以下简单程序中的结构体数组，其中`heap_struct`指向五个`ch8_struct`项的数组：
- en: '[PRE61]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The operations required to access `field1` at ![](httpatomoreillycomsourcenostarchimages854061.png)
    include multiplying the index value by the size of an array element, in this case
    the size of the structure, and then adding the offset to the desired field. The
    corresponding disassembly is shown here:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 访问位于 ![](httpatomoreillycomsourcenostarchimages854061.png) 的`field1`所需的操作包括将索引值乘以数组元素的大小，在这种情况下是结构体的大小，然后加上所需字段的偏移量。相应的反汇编在此处显示：
- en: '[PRE62]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The disassembly reveals 120 bytes (![](httpatomoreillycomsourcenostarchimages854063.png))
    being requested from the heap. The array index is multiplied by 24 at ![](httpatomoreillycomsourcenostarchimages854093.png)
    before being added to the start address for the array at ![](httpatomoreillycomsourcenostarchimages854095.png).
    No additional offset is required in order to generate the final address for the
    reference at ![](httpatomoreillycomsourcenostarchimages854095.png). From these
    facts we can deduce the size of an array item (24), the number of items in the
    array (`120 / 24 = 5`), and the fact that there is a 4-byte (`dword`) field at
    offset 0 within each array element. This short listing does not offer enough information
    to draw any conclusions about how the remaining 20 bytes within each structure
    are allocated to additional fields.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编显示从堆中请求了 120 字节 (![](httpatomoreillycomsourcenostarchimages854063.png))。在
    ![](httpatomoreillycomsourcenostarchimages854093.png) 处，数组索引乘以 24，然后加到 ![](httpatomoreillycomsourcenostarchimages854095.png)
    处数组的起始地址上。为了生成 ![](httpatomoreillycomsourcenostarchimages854095.png) 处引用的最终地址，不需要额外的偏移。从这些事实中，我们可以推断出数组项的大小（24），数组中的项目数（`120
    / 24 = 5`），以及每个数组元素中偏移量为 0 的 4 字节（`dword`）字段的事实。这个简短的列表没有提供足够的信息来得出关于每个结构中剩余 20
    字节如何分配给额外字段任何结论。
- en: '* * *'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[44](#CHP-8-FN-1)]) Holding the mouse over any name in the IDA display causes
    a tool tip–style pop-up window to be displayed that shows up to 10 lines of disassembly
    at the target location. In the case of library function names, this often includes
    the prototype for calling the library function.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[44](#CHP-8-FN-1)]) 将鼠标悬停在 IDA 显示中的任何名称上，会显示一个工具提示风格的弹出窗口，显示目标位置最多 10 行的反汇编代码。在库函数名称的情况下，这通常包括调用库函数的原型。
- en: ^([[45](#CHP-8-FN-2)]) Please see [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/).
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[45](#CHP-8-FN-2)]) 请参阅 [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)。
- en: Creating IDA Structures
  id: totrans-755
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 IDA 结构
- en: In the last chapter we saw how IDA’s array-aggregation capabilities allow disassembly
    listings to be simplified by collapsing long lists of data declarations into a
    single disassembly line. In the next few sections we take a look at IDA’s facilities
    for improving the readability of code that manipulates structures. Our goal is
    to move away from structure references such as `[edx + 10h]` and toward something
    more readable like `[edx + ch8_struct.field5]`.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 IDA 的数组聚合功能如何通过将长数据声明列表折叠成单行反汇编来简化反汇编列表。在接下来的几节中，我们将探讨 IDA 提高操作结构代码可读性的功能。我们的目标是远离如
    `[edx + 10h]` 这样的结构引用，转向更易读的如 `[edx + ch8_struct.field5]`。
- en: Whenever you discover that a program is manipulating a data structure, you need
    to decide whether you want to incorporate structure field names into your disassembly
    or whether you can make sense of all the numeric offsets sprinkled throughout
    the listing. In some cases, IDA may recognize the use of a structure defined as
    part of the C standard library or the Windows API. In such cases, IDA may have
    knowledge of the exact layout of the structure and be able to convert numeric
    offsets into more symbolic field names. This is the ideal case, as it leaves you
    with a lot less work to do. We will return to this scenario once we understand
    a little more about how IDA deals with structure definitions in general.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现程序正在操作一个数据结构时，你需要决定是否要将结构字段名称纳入你的反汇编中，或者你是否能够理解列表中散布的所有数字偏移。在某些情况下，IDA
    可能会识别出作为 C 标准库或 Windows API 部分定义的结构的使用。在这种情况下，IDA 可能了解结构的精确布局，并能将数字偏移转换为更符号化的字段名称。这是理想的情况，因为它让你有更少的工作要做。一旦我们更了解
    IDA 如何处理结构定义，我们就会回到这个场景。
- en: Creating a New Structure (or Union)
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的结构（或联合）
- en: When a program appears to be using a structure for which IDA has no layout knowledge,
    IDA offers facilities for specifying the composition of the structure and having
    the newly defined structure incorporated into the disassembly. Structure creation
    in IDA takes place within the Structures window (see [Figure 8-2](ch08s02.html#the_structures_window-id2
    "Figure 8-2. The Structures window")). No structure can be incorporated into a
    disassembly until it is first listed in the Structures window. Any structure that
    is known to IDA and that is recognized to be used by a program will automatically
    be listed in the Structures window.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序似乎使用IDA没有布局知识的结构时，IDA提供了指定结构组成并将新定义的结构纳入反汇编的功能。IDA中的结构创建发生在结构窗口内（见图[图8-2](ch08s02.html#the_structures_window-id2
    "图8-2. 结构窗口")）。任何结构都不能被纳入反汇编，直到它首先在结构窗口中列出。任何IDA已知且被程序识别为使用的结构将自动在结构窗口中列出。
- en: '![The Structures window](httpatomoreillycomsourcenostarchimages854169.png)'
  id: totrans-760
  prefs: []
  type: TYPE_IMG
  zh: '![结构窗口](httpatomoreillycomsourcenostarchimages854169.png)'
- en: Figure 8-2. The Structures window
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2. 结构窗口
- en: There are two reasons why the use of a structure may go unrecognized during
    the analysis phase. First, even though IDA may have knowledge of a particular
    structure’s layout, there may be insufficient information for IDA to conclude
    that the program utilizes the structure. Second, the structure may be a nonstandard
    structure that IDA knows nothing about. In both cases the problem can be overcome,
    and in both cases the solution begins with the Structures window.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析阶段，结构的使用可能未被识别的原因有两个。首先，尽管IDA可能了解特定结构的布局，但可能信息不足，无法使IDA得出程序使用该结构的结论。其次，该结构可能是一个IDA一无所知的非标准结构。在这两种情况下，问题都可以克服，并且在这两种情况下，解决方案都始于结构窗口。
- en: The first four lines of text in the Structures window serve as a constant reminder
    of the operations that are possible within the window. The principal operations
    we are concerned with involve adding, removing, and editing structures. Adding
    a structure is initiated using the insert key, which opens the Create Structure/Union
    dialog shown in [Figure 8-3](ch08s02.html#the_create_structure_solidus_union_dialo
    "Figure 8-3. The Create Structure/Union dialog").
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 结构窗口中的前四行文本作为对窗口内可能进行的操作的持续提醒。我们主要关心的操作包括添加、删除和编辑结构。使用插入键启动添加结构，这将打开如图[图8-3](ch08s02.html#the_create_structure_solidus_union_dialo
    "图8-3. 创建结构/联合对话框")所示的创建结构/联合对话框。
- en: '![The Create Structure/Union dialog](httpatomoreillycomsourcenostarchimages854171.png.jpg)'
  id: totrans-764
  prefs: []
  type: TYPE_IMG
  zh: '![创建结构/联合对话框](httpatomoreillycomsourcenostarchimages854171.png.jpg)'
- en: Figure 8-3. The Create Structure/Union dialog
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3. 创建结构/联合对话框
- en: In order to create a new structure, you must first specify the name in the Structure
    name field. The first two checkboxes determine where or whether the new structure
    will be displayed within the Structures window. The third checkbox, Create union,
    specifies whether you are defining a structure or a C-style union.^([[46](#ftn.CHP-8-FN-3)])
    For structures, the size is computed as the sum of the sizes of each component
    field, while for unions, the size is computed as the size of the largest component
    field. The Add standard structure button is used to access the list of all structure
    datatypes that IDA is currently aware of. The behavior of this button is discussed
    in [Using Standard Structures](ch08s05.html "Using Standard Structures") in [Using
    Standard Structures](ch08s05.html "Using Standard Structures"). Once you specify
    a structure name and click OK, an empty structure definition will be created in
    the Structures window, as shown in [Figure 8-4](ch08s02.html#an_empty_structure_definition
    "Figure 8-4. An empty structure definition").
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的结构，您必须首先在结构名称字段中指定名称。前两个复选框确定新结构将在结构窗口中显示的位置或是否显示。第三个复选框“创建联合”指定您是定义结构还是C样式联合^([[46](#ftn.CHP-8-FN-3)])。对于结构，大小是每个组件字段大小的总和，而对于联合，大小是最大组件字段的大小。添加标准结构按钮用于访问IDA当前所知的所有结构数据类型列表。此按钮的行为在[使用标准结构](ch08s05.html
    "使用标准结构")中进行了讨论。[使用标准结构](ch08s05.html "使用标准结构")。一旦指定了结构名称并点击“确定”，结构窗口中就会创建一个空的结构定义，如图[图8-4](ch08s02.html#an_empty_structure_definition
    "图8-4. 空结构定义")所示。
- en: '![An empty structure definition](httpatomoreillycomsourcenostarchimages854173.png)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
  zh: '![空结构定义](httpatomoreillycomsourcenostarchimages854173.png)'
- en: Figure 8-4. An empty structure definition
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4. 空结构定义
- en: This structure definition must be edited to complete the definition of the structure
    layout.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 必须编辑此结构定义以完成结构布局的定义。
- en: Editing Structure Members
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑结构成员
- en: In order to add fields to your new structure, you must make use of the field-creation
    commands D, A, and the asterisk key (*) on the numeric keypad. Initially, only
    the D command is useful, and unfortunately, its behavior is highly dependent on
    the location of the cursor. For that reason, the following steps are recommended
    for adding fields to a structure.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你的新结构中添加字段，你必须使用字段创建命令 D、A 以及数字键盘上的星号键 (*)。最初，只有 D 命令是有用的，而且不幸的是，它的行为高度依赖于光标的位置。因此，建议按照以下步骤向结构中添加字段。
- en: To add a new field to a structure, position the cursor on the last line of the
    structure definition (the one containing `ends`) and press **D**. This causes
    a new field to be added to the end of the structure. The size of the new field
    will be set according to the first size selected on the data carousel ([Chapter 7](ch07.html
    "Chapter 7. Disassembly Manipulation")). The name of the field will initially
    be `field_`*`N`*, where *`N`* is the numeric offset from the start of the structure
    to the start of the new field (`field_0`, for example).
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向结构中添加新字段，请将光标定位在结构定义的最后一行（包含 `ends` 的那一行）上，然后按 **D** 键。这将导致在结构末尾添加一个新字段。新字段的大小将根据数据轮盘上首先选择的大小设置（[第
    7 章](ch07.html "第 7 章。反汇编操作")）。字段的名称最初将是 `field_`*`N`*，其中 *`N`* 是从结构开始到新字段开始（例如
    `field_0`）的数字偏移量。
- en: Should you need to modify the size of the field, you may do so by first ensuring
    that the cursor is positioned on the new field name and then selecting the correct
    data size for the field by repeatedly pressing D in order to cycle through the
    datatypes on the data carousel. Alternatively, you may use Options ▸ Setup Data
    Types to specify a size that is not available on the data carousel. If the field
    is an array, right-click the name and select **Array** to open the array specification
    dialog ([Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation")).
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要修改字段的大小，你可以通过首先确保光标位于新字段名称上，然后通过重复按 D 键来循环通过数据轮盘上的数据类型，以选择字段的正确数据大小。或者，你可以使用选项
    ▸ 设置数据类型来指定数据轮盘上不可用的数据大小。如果字段是一个数组，右键单击名称并选择**数组**以打开数组指定对话框 ([第 7 章](ch07.html
    "第 7 章。反汇编操作")).
- en: To change the name of a structure field, click the field name and use the N
    hotkey, or right-click the name and select **Rename**; then provide a new name
    for the field.
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改结构字段的名称，请单击字段名称并使用 N 快捷键，或右键单击名称并选择**重命名**；然后为字段提供新名称。
- en: The following helpful hints may be of use as you define your own structures.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 以下有用的提示可能在你定义自己的结构时有所帮助。
- en: The byte offset to a field is displayed as an eight-digit hex value on the left
    side of the Structures window.
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段的字节偏移量在结构窗口的左侧以八位十六进制值显示。
- en: Every time you add or delete a structure field or change the size of an existing
    field, the new `sizeof` the structure will be reflected on the first line of the
    structure definition.
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次你添加或删除结构字段或更改现有字段的大小，结构的新 `sizeof` 将会在结构定义的第一行中反映出来。
- en: You can add comments to a structure field just as you can add comments to any
    disassembly line. Right-click (or use a hotkey) on the field you wish to add a
    comment to and select one of the available comment options.
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以向结构字段添加注释，就像你可以向任何反汇编行添加注释一样。右键单击（或使用快捷键）你想要添加注释的字段，然后选择可用的注释选项之一。
- en: Contrary to the instructions at the top of the Structures window, the U key
    will delete a structure field only if it is the last field in the structure. For
    all other fields, pressing U merely undefines the field, which removes the name
    but *does not* remove the bytes allocated to the field.
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与结构窗口顶部的说明相反，只有当 U 键是结构中的最后一个字段时，它才会删除结构字段。对于所有其他字段，按下 U 键仅取消定义字段，这会移除名称但*不会*移除分配给字段的字节。
- en: You are responsible for proper alignment of all fields within a structure definition.
    IDA makes no distinction between packed or unpacked structures. If you require
    padding bytes to properly align fields, then you are responsible for adding them.
    Padding bytes are best added as dummy fields of the proper size, which you may
    or may not choose to undefine once you have added additional fields.
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你负责在结构定义中正确对齐所有字段。IDA不会区分打包或未打包的结构体。如果你需要填充字节来正确对齐字段，那么你有责任添加它们。填充字节最好添加为适当大小的虚拟字段，一旦添加了额外的字段，你可以选择取消定义或不取消定义。
- en: Bytes allocated in the middle of a structure can be removed only by first undefining
    the associated field and then selecting Edit ▸ Shrink Struct Type to remove the
    undefined bytes.
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构体中间分配的字节只能通过首先取消定义相关的字段，然后选择编辑 ▸ 缩小结构类型来删除未定义的字节。
- en: Bytes may be inserted into the middle of a structure by selecting the field
    that will follow the new bytes and then using Edit ▸ Expand Struct Type to insert
    a specified number of bytes before the selected field.
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过选择将跟随新字节的字段，然后使用编辑 ▸ 扩展结构类型来在所选字段之前插入指定数量的字节，将字节插入到结构体的中间。
- en: If you know the size of a structure but not the layout, you need to create two
    fields. The first field should be an array of `size-1` bytes. The second field
    should be a 1-byte field. After you have created the second field, undefine the
    first (array) field. The size of the structure will be preserved, and you can
    easily come back later to define fields and their sizes as you learn more about
    the layout of the structure.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道结构体的大小但不知道布局，你需要创建两个字段。第一个字段应该是一个`size-1`字节的数组。第二个字段应该是一个1字节的字段。创建第二个字段后，取消定义第一个（数组）字段。结构体的大小将被保留，你可以在以后更容易地回来定义字段及其大小，当你对结构体的布局了解更多时。
- en: Through repeated application of these steps (add field, set field size, add
    padding, and so on), you can create an IDA representation of the `ch8_struct`
    (unpacked version), as shown in [Figure 8-5](ch08s02.html#manually_generated_definition_of_the_ch8
    "Figure 8-5. Manually generated definition of the ch8_struct").
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重复应用这些步骤（添加字段、设置字段大小、添加填充等），你可以创建`ch8_struct`（未打包版本）的IDA表示，如图8-5所示。
- en: '![Manually generated definition of the ch8_struct](httpatomoreillycomsourcenostarchimages854175.png)'
  id: totrans-785
  prefs: []
  type: TYPE_IMG
  zh: '![手动生成的ch8_struct定义](httpatomoreillycomsourcenostarchimages854175.png)'
- en: Figure 8-5. Manually generated definition of the `ch8_struct`
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5. 手动生成的`ch8_struct`定义
- en: In this example, padding bytes have been included to achieve proper field alignment,
    and fields have been renamed according to the names used in the preceding examples.
    Note that the offsets to each field and the overall size (24 bytes) of the structure
    match the values seen in the earlier examples.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，已经包含了填充字节以实现正确的字段对齐，并且字段已经被重命名为与前面例子中使用的一致。请注意，每个字段和结构体的整体大小（24字节）与前面例子中看到的值相匹配。
- en: If you ever feel that a structure definition is taking up too much space in
    your Structures window, you can collapse the definition into a one-line summary
    by choosing any field within the structure and pressing the minus key (–) on the
    numeric keypad. This is useful once a structure has been completely defined and
    requires little further editing. The collapsed version of `ch8_struct` is shown
    in [Figure 8-6](ch08s02.html#a_collapsed_structure_definition "Figure 8-6. A collapsed
    structure definition").
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得结构定义在你的结构体窗口中占用的空间太多，你可以通过选择结构体中的任何字段并按数字键盘上的减号键（–）来折叠定义成一个单行摘要。一旦结构体完全定义并且需要很少的进一步编辑，这很有用。`ch8_struct`的折叠版本如图8-6所示。
- en: The majority of structures that IDA is already aware of will be displayed in
    this one-line fashion since it is not expected that they will need to be edited.
    The collapsed display provides a reminder that you can use the plus key (+) on
    the numeric keypad to expand the definition. Alternatively, double-clicking the
    name of the structure will also expand the definition.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: IDA已经知道的大多数结构体将以单行方式显示，因为预计它们不需要被编辑。折叠显示提供了一个提示，你可以使用数字键盘上的加号键（+）来展开定义。或者，双击结构体的名称也会展开定义。
- en: '![A collapsed structure definition](httpatomoreillycomsourcenostarchimages854177.png.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
  zh: '![一个折叠的结构定义](httpatomoreillycomsourcenostarchimages854177.png.jpg)'
- en: Figure 8-6. A collapsed structure definition
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6. 一个折叠的结构定义
- en: Stack Frames as Specialized Structures
  id: totrans-792
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈帧作为特殊结构
- en: You may notice that structure definitions look somewhat similar to the detailed
    stack frame views associated with functions. This is no accident, as internally
    IDA treats both identically. Both represent contiguous blocks of bytes that can
    be subdivided into named component fields, each associated with a numeric offset
    into the structure. The minor difference is that stack frames utilize both positive
    and negative field offsets centered on a frame pointer or return address, while
    structures use positive offsets from the beginning of the structure.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到结构定义看起来与与函数相关联的详细栈帧视图有些相似。这不是偶然的，因为IDA在内部将两者同等对待。两者都代表可以细分为命名组件字段的连续字节块，每个字段都与结构中的数字偏移量相关联。微小的区别在于，栈帧使用基于帧指针或返回地址的正负字段偏移量，而结构使用从结构开始的正偏移量。
- en: '* * *'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[46](#CHP-8-FN-3)]) A *union* is similar to a struct in that it may consist
    of many named fields, each of differing type. The difference between the two lies
    in the fact that fields within a union directly overlap one another so that the
    size of a union is equal to the size of the largest field.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[46](#CHP-8-FN-3)]) 一个*联合体*与结构类似，因为它可能由许多命名字段组成，每个字段类型不同。两者之间的区别在于，联合体内的字段直接重叠，因此联合体的大小等于最大字段的大小。
- en: Using Structure Templates
  id: totrans-796
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构模板
- en: There are two ways to make use of structure definitions in your disassemblies.
    First, you can reformat memory references to make them more readable by converting
    numeric structure offsets such as `[ebx+8]` into symbolic references such as `[ebx+ch8_struct.field4]`.
    The latter form provides far more information about what is being referenced.
    Because IDA uses a hierarchical notation, it is clear exactly what type of structure,
    and exactly which field within that structure, is being accessed. This technique
    for applying structure templates is most often used when a structure is being
    referenced through a pointer. The second way to use structure templates is to
    provide additional datatypes that can be applied to stack and global variables.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的反汇编中，有几种方式可以利用结构定义。首先，你可以通过将数字结构偏移量，如`[ebx+8]`，转换为符号引用，如`[ebx+ch8_struct.field4]`，来重新格式化内存引用，使其更易读。后者提供了更多关于所引用内容的信息。由于IDA使用层次化表示法，可以清楚地知道正在访问的结构类型以及该结构中的哪个字段。这种应用结构模板的技术通常在结构通过指针引用时使用。第二种使用结构模板的方式是提供可以应用于栈和全局变量的额外数据类型。
- en: 'In order to understand how structure definitions can be applied to instruction
    operands, it is helpful to view each definition as something similar to set of
    enumerated constants. For example, the definition of `ch8_struct` in [Figure 8-5](ch08s02.html#manually_generated_definition_of_the_ch8
    "Figure 8-5. Manually generated definition of the ch8_struct") might be expressed
    in pseudo-C as the following:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解结构定义如何应用于指令操作数，将每个定义视为类似枚举常量的集合是很有帮助的。例如，[图8-5](ch08s02.html#manually_generated_definition_of_the_ch8
    "图8-5. 手动生成的ch8_struct定义")中的`ch8_struct`定义可以用伪C语言表示如下：
- en: '[PRE63]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Given such a definition, IDA allows you to reformat any constant value used
    in an operand into an equivalent symbolic representation. [Figure 8-7](ch08s03.html#applying_a_structure_offset
    "Figure 8-7. Applying a structure offset") shows just such an operation in progress.
    The memory reference `[ecx+10h]` may represent an access to `field5` within a
    `ch8_struct`.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这样的定义，IDA允许你将操作数中使用的任何常量值重新格式化为等效的符号表示。[图8-7](ch08s03.html#applying_a_structure_offset
    "图8-7. 应用结构偏移")展示了正在进行此类操作的示例。内存引用`[ecx+10h]`可能表示对`ch8_struct`中的`field5`的访问。
- en: '![Applying a structure offset](httpatomoreillycomsourcenostarchimages854179.png.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![应用结构偏移](httpatomoreillycomsourcenostarchimages854179.png.jpg)'
- en: Figure 8-7. Applying a structure offset
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7. 应用结构偏移
- en: The Structure offset option, available by right-clicking 10h in this case, offers
    three alternatives for formatting the instruction operand. The alternatives are
    pulled from the set of structures containing a field whose offset is 16.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，通过右键单击10h可用的结构偏移选项提供了三种格式化指令操作数的替代方案。这些替代方案来自包含偏移量为16的字段的结构的集合。
- en: As an alternative to formatting individual memory references, stack and global
    variables can be formatted as entire structures. To format a stack variable as
    a structure, open the detailed stack frame view by double-clicking the variable
    to be formatted as a structure and then use **Edit** ▸ **Struct Var** (alt-Q)
    to display a list of known structures similar to that shown in [Figure 8-8](ch08s03.html#the_structure_selection_dialog
    "Figure 8-8. The structure selection dialog").
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单独格式化内存引用的替代方案，栈和全局变量可以格式化为整个结构体。要将栈变量格式化为结构体，通过双击要格式化为结构体的变量打开详细栈帧视图，然后使用**编辑**
    ▸ **结构变量**（alt-Q）显示与[图8-8](ch08s03.html#the_structure_selection_dialog "图8-8.
    结构选择对话框")中所示类似的已知结构列表。
- en: '![The structure selection dialog](httpatomoreillycomsourcenostarchimages854181.png)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
  zh: '![结构选择对话框](httpatomoreillycomsourcenostarchimages854181.png)'
- en: Figure 8-8. The structure selection dialog
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-8. 结构选择对话框
- en: 'Selecting one of the available structures combines the corresponding number
    of bytes in the stack into the corresponding structure type and reformats all
    related memory references as structure references. The following code is an excerpt
    from the stack-allocated structure example we examined previously:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个可用的结构体会将栈中相应数量的字节组合成相应的结构类型，并将所有相关内存引用重新格式化为结构引用。以下代码是我们之前检查的栈分配结构示例的摘录：
- en: '[PRE64]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Recall that we concluded that `var_18` is actually the first field in a 24-byte
    structure. The detailed stack frame for this particular interpretation is shown
    in [Figure 8-9](ch08s03.html#stack_allocated_structure_prior_to_forma "Figure 8-9. Stack
    allocated structure prior to formatting").
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们得出结论，`var_18`实际上是24字节结构中的第一个字段。这个特定解释的详细栈帧如图[图8-9](ch08s03.html#stack_allocated_structure_prior_to_forma
    "图8-9. 格式化前的栈分配结构")所示。
- en: '![Stack allocated structure prior to formatting](httpatomoreillycomsourcenostarchimages854183.png)'
  id: totrans-810
  prefs: []
  type: TYPE_IMG
  zh: '![格式化前的栈分配结构](httpatomoreillycomsourcenostarchimages854183.png)'
- en: Figure 8-9. Stack allocated structure prior to formatting
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-9. 格式化前的栈分配结构
- en: Selecting `var_18` and formatting it as a `ch8_struct` (Edit ▸ Struct Var) collapses
    the 24 bytes (the size of `ch8_struct`) beginning at `var_18` into a single variable,
    resulting in the reformatted stack display shown in [Figure 8-10](ch08s03.html#stack_allocated_structure_after_formatti
    "Figure 8-10. Stack allocated structure after formatting"). In this case, applying
    the structure template to `var_18` will generate a warning message indicating
    that some variables will be destroyed in the process of converting `var_18` into
    a structure. Based on our earlier analysis, this is to be expected, so we simply
    acknowledge the warning to complete the operation.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`var_18`并将其格式化为`ch8_struct`（编辑 ▸ 结构变量），将`var_18`开始的24字节（`ch8_struct`的大小）合并成一个变量，从而得到[图8-10](ch08s03.html#stack_allocated_structure_after_formatti
    "图8-10. 格式化后的栈分配结构")中所示的重新格式化后的栈显示。在这种情况下，将结构模板应用到`var_18`将生成一个警告消息，表明在将`var_18`转换为结构体的过程中将销毁一些变量。根据我们之前的分析，这是可以预料的，所以我们只需确认警告以完成操作。
- en: '![Stack allocated structure after formatting](httpatomoreillycomsourcenostarchimages854185.png)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![格式化后的栈分配结构](httpatomoreillycomsourcenostarchimages854185.png)'
- en: Figure 8-10. Stack allocated structure after formatting
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-10. 格式化后的栈分配结构
- en: 'Following reformatting, IDA understands that any memory reference into the
    24-byte block allocated to `var_18` must refer to a field within the structure.
    When IDA encounters such a reference, it makes every effort to resolve the memory
    reference to one of the defined fields within the structure variable. In this
    case, the disassembly is automatically reformatted to incorporate the structure
    layout, as shown here:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 重新格式化后，IDA能够理解任何对分配给`var_18`的24字节块的内存引用都必须指向结构体内部的字段。当IDA遇到这样的引用时，它会尽力将内存引用解析为结构变量内定义的字段之一。在这种情况下，反汇编会自动重新格式化以包含结构布局，如下所示：
- en: '[PRE65]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The advantage to using structure notation within the disassembly is an overall
    improvement in the readability of the disassembly. The use of field names in the
    reformatted display provides a much more accurate reflection of how data was actually
    manipulated in the original source code.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编中使用结构符号的优势是提高了反汇编的可读性。在重新格式化后的显示中使用字段名提供了对原始源代码中实际数据操作方式的更准确反映。
- en: The procedure for formatting global variables as structures is nearly identical
    to that used for stack variables. To do so, select the variable or address that
    marks the beginning of the structure and use **Edit** ▸ **Struct Var** (alt-Q)
    to choose the appropriate structure type. As an alternative for undefined global
    data only (not stack data), you may use IDA’s context-sensitive menu, and select
    the structure option to view and select an available structure template to apply
    at the selected address.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化全局变量为结构体的过程几乎与用于堆变量的过程相同。为此，选择变量或标记结构体开始的地址，并使用**编辑** ▸ **结构变量**（alt-Q）来选择适当的结构类型。仅对于未定义的全局数据（不是堆数据）而言，你可以使用IDA的上下文相关菜单，并选择结构选项来查看和选择要应用于选定地址的可用结构模板。
- en: Importing New Structures
  id: totrans-819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入新结构
- en: After working with IDA’s structure-creation and editing features for a while,
    you may find yourself longing for an easier way to do things. Fortunately, IDA
    does offer some shortcuts concerning new structures. IDA is capable of parsing
    individual C (not C++) data declarations, as well as entire C header files, and
    automatically building IDA structure representations for any structures defined
    in those declarations or header files. If you happen to have the source code,
    or at least the header files, for the binary that you are reversing, then you
    can save a lot of time by having IDA extract related structures directly from
    the source code.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用了一段时间IDA的结构创建和编辑功能后，你可能可能会渴望一种更简单的方法来做事情。幸运的是，IDA确实提供了一些关于新结构的快捷方式。IDA能够解析单个C（不是C++）数据声明，以及整个C头文件，并自动为在那些声明或头文件中定义的任何结构体构建IDA结构表示。如果你恰好有你要反汇编的二进制文件的源代码，或者至少有头文件，那么通过让IDA直接从源代码中提取相关结构，你可以节省很多时间。
- en: Parsing C Structure Declarations
  id: totrans-821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析C结构声明
- en: A Local Types subview window is available by using the View ▸ OpenSubviews ▸
    Local Types command. The Local Types window displays a list of all types that
    have been parsed into the current database. For new databases, the Local Types
    window is initially empty, but the window offers the capability to parse new types
    via the `insert` key or the Insert option from the context menu. The resulting
    type entry dialog is shown in [Figure 8-11](ch08s04.html#the_local_types_entry_dialog
    "Figure 8-11. The Local Types entry dialog").
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用视图 ▸ 打开子视图 ▸ 本地类型命令，可以打开一个本地类型子视图窗口。本地类型窗口显示已解析到当前数据库中的所有类型的列表。对于新数据库，本地类型窗口最初为空，但窗口提供了通过`插入`键或从上下文菜单中选择插入选项来解析新类型的
    capability。结果类型条目对话框如图[8-11](ch08s04.html#the_local_types_entry_dialog "图8-11.
    本地类型条目对话框")所示。
- en: '![The Local Types entry dialog](httpatomoreillycomsourcenostarchimages854187.png.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![本地类型条目对话框](httpatomoreillycomsourcenostarchimages854187.png.jpg)'
- en: Figure 8-11. The Local Types entry dialog
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-11. 本地类型条目对话框
- en: Errors encountered while parsing the new type are displayed in the IDA output
    window. If the type declaration is successfully parsed, the type and its associated
    declaration are listed in the Local Types window, as shown in [Figure 8-12](ch08s04.html#the_local_types_window
    "Figure 8-12. The Local Types window").
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 解析新类型时遇到的错误将在IDA输出窗口中显示。如果类型声明成功解析，类型及其相关声明将列在本地类型窗口中，如图[8-12](ch08s04.html#the_local_types_window
    "图8-12. 本地类型窗口")所示。
- en: '![The Local Types window](httpatomoreillycomsourcenostarchimages854189.png.jpg)'
  id: totrans-826
  prefs: []
  type: TYPE_IMG
  zh: '![本地类型窗口](httpatomoreillycomsourcenostarchimages854189.png.jpg)'
- en: Figure 8-12. The Local Types window
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-12. 本地类型窗口
- en: Note that the IDA parser utilizes a default structure member alignment of 4
    bytes. If your structure requires an alternate alignment, you may include it,
    and IDA will recognize a `pragma pack` directive to specify the desired member
    alignment.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IDA解析器使用默认的结构成员对齐为4字节。如果你的结构需要不同的对齐方式，你可以包含它，并且IDA将识别`pragma pack`指令来指定所需的成员对齐。
- en: Datatypes added to the Local Types windows are not immediately available via
    the Structures window. There are two methods for adding local type declarations
    to the Structures window. The easiest method is to right-click on the desired
    local type and select **Synchronize to idb**. Alternatively, as each new type
    is added to a list of standard structures; the new type may be imported into the
    Structures window as described in [Using Standard Structures](ch08s05.html "Using
    Standard Structures") in [Using Standard Structures](ch08s05.html "Using Standard
    Structures").
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到本地类型窗口的数据类型不会立即通过结构窗口可用。有两种方法可以将本地类型声明添加到结构窗口。最简单的方法是在所需的本地类型上右键单击并选择**同步到idb**。或者，当每个新类型被添加到标准结构列表中时，新类型可以按照[使用标准结构](ch08s05.html
    "Using Standard Structures")中所述的方式导入到结构窗口。
- en: Parsing C Header Files
  id: totrans-830
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析C头文件
- en: 'To parse a header file, use **File** ▸ **Load File** ▸ **Parse C Header File**
    to choose the header you wish to parse. If all goes well, IDA returns the message:
    `Compilation successful`. If the parser encounters any problems, you are notified
    that there were errors. Any associated error messages are displayed in the IDA
    output window.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析头文件，使用**文件**▸**加载文件**▸**解析C头文件**来选择你想要解析的头文件。如果一切顺利，IDA会返回消息：“编译成功”。如果解析器遇到任何问题，你会收到错误通知。任何相关的错误消息都会在IDA输出窗口中显示。
- en: IDA adds all structures that were successfully parsed to both the list of local
    types and the list of standard structures (to the end of the list to be exact)
    available in the current database. When a new structure has the same name as an
    existing structure, the existing structure definition is overwritten with the
    new structure layout. None of the new structures appear in the Structures window
    until you elect to explicitly add them, as described above for local types or
    in [Using Standard Structures](ch08s05.html "Using Standard Structures") in [Using
    Standard Structures](ch08s05.html "Using Standard Structures").
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: IDA会将所有成功解析的结构添加到当前数据库中本地类型列表和标准结构列表的末尾。当新结构具有与现有结构相同的名称时，现有结构定义将被新结构布局覆盖。除非你选择显式添加，否则新结构不会出现在结构窗口中，正如上述关于本地类型的描述，或在[使用标准结构](ch08s05.html
    "Using Standard Structures")中所述。
- en: 'When parsing C header files, it is useful to keep the following points in mind:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析C头文件时，以下要点值得注意：
- en: The built-in parser does not necessarily use the same default structure member
    alignment as your compiler, though it does honor the `pack` pragma. By default,
    the parser creates structures that are 4-byte aligned.
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置解析器不一定使用与你的编译器相同的默认结构成员对齐方式，尽管它确实遵守`pack`指令。默认情况下，解析器创建4字节对齐的结构。
- en: The parser understands the C preprocessor `include` directive. To resolve `include`
    directives, the parser searches the directory containing the file being parsed
    as well as any directories listed as `Include` directories in the Options ▸ Compiler
    configuration dialog.
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器理解C预处理器`include`指令。为了解析`include`指令，解析器会搜索包含正在解析的文件的目录以及选项▸编译器配置对话框中列出的任何`Include`目录。
- en: The parser understands only C standard datatypes. However, the parser also understands
    the preprocessor `define` directive as well as the C `typedef` statement. Thus,
    types such as `uint32_t` will be correctly parsed if the parser has encountered
    an appropriate `typedef` prior to their use.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器只理解C标准数据类型。然而，解析器也理解预处理器`define`指令以及C的`typedef`语句。因此，如果解析器在使用之前遇到了适当的`typedef`，则`uint32_t`之类的类型将被正确解析。
- en: When you don’t have any source code, you may find it easier to quickly define
    a structure layout in C notation using a text editor and parse the resulting header
    file or paste the declaration as a new local type, rather than using IDA’s cumbersome
    manual structure-definition tools.
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你没有源代码时，你可能发现使用文本编辑器快速定义结构布局并解析生成的头文件或将其声明粘贴为新本地类型，比使用IDA繁琐的手动结构定义工具更容易。
- en: New structures are available only in the current database. You must repeat the
    structure-creation steps in each additional database for which you wish to use
    the structures. We will discuss some steps for simplifying this process when we
    discuss TIL files later in the chapter.
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新结构仅在当前数据库中可用。你必须为每个你希望使用结构的附加数据库重复结构创建步骤。我们将在本章后面讨论TIL文件时讨论简化此过程的某些步骤。
- en: In general, to maximize your chances of successfully parsing a header file,
    you will want to simplify your structure definitions as much as possible through
    the use of standard C datatypes and minimizing the use of `include` files. Remember,
    the most important thing about creating structures in IDA is to ensure that the
    layout is correct. Correct layout depends far more on the correct size of each
    field and the correct alignment of the structure than getting the exact type of
    each field just right. In other words, if you need to replace all occurrences
    of `uint32_t` with `int` in order to get a file to parse correctly, you should
    go right ahead and do it.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了最大限度地提高成功解析头文件的机会，您将希望尽可能通过使用标准C数据类型和最小化使用`include`文件来简化结构定义。记住，在IDA中创建结构最重要的东西是确保布局正确。正确的布局在很大程度上取决于每个字段的正确大小和结构的正确对齐，而不是每个字段的精确类型。换句话说，如果您需要将所有`uint32_t`替换为`int`以正确解析文件，您应该立即这样做。
- en: Using Standard Structures
  id: totrans-840
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准结构
- en: As mentioned previously, IDA recognizes a tremendous number of data structures
    associated with various library and API functions. When a database is initially
    created, IDA attempts to determine the compiler and platform associated with the
    binary and loads the structure templates derived from related library header files.
    As IDA encounters actual structure manipulations in the disassembly, it adds the
    appropriate structure definitions to the Structures window. Thus, the Structures
    window represents the subset of known structures that happen to apply to the current
    binary. In addition to creating your own custom structures, you can add additional
    standard structures to the Structures window by drawing from IDA’s list of known
    structure types.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，IDA识别与各种库和API函数相关的大量数据结构。当数据库最初创建时，IDA会尝试确定与二进制文件相关的编译器和平台，并加载从相关库头文件中派生的结构模板。当IDA在反汇编过程中遇到实际的结构操作时，它会将适当的结构定义添加到结构窗口中。因此，结构窗口表示适用于当前二进制文件的已知结构的子集。除了创建自己的自定义结构外，您还可以通过从IDA已知结构类型列表中选取，将额外的标准结构添加到结构窗口中。
- en: The process for adding a new structure begins by pressing the insert key inside
    the Structures window. [Figure 8-3](ch08s02.html#the_create_structure_solidus_union_dialo
    "Figure 8-3. The Create Structure/Union dialog") showed the Create Structure/Union
    dialog, one component of which is the Add standard structure button. Clicking
    this button grants access to the master list of structures pertaining to the current
    compiler (as detected during the analysis phase) and file format. This master
    list of structures also contains any structures that have been added to the database
    as a result of parsing C header files. The structure selection dialog shown in
    [Figure 8-13](ch08s05.html#standard_structure_selection "Figure 8-13. Standard
    structure selection") is used to choose a structure to add to the Structures window.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新结构的流程是从结构窗口内部按下插入键开始。[图8-3](ch08s02.html#the_create_structure_solidus_union_dialo
    "图8-3. 创建结构/联合对话框")展示了创建结构/联合对话框，其中之一是添加标准结构按钮。点击此按钮可以访问与当前编译器（在分析阶段检测到）和文件格式相关的结构主列表。这个结构主列表还包含任何由于解析C头文件而添加到数据库中的结构。[图8-13](ch08s05.html#standard_structure_selection
    "图8-13. 标准结构选择")中显示的结构选择对话框用于选择要添加到结构窗口中的结构。
- en: '![Standard structure selection](httpatomoreillycomsourcenostarchimages854191.png.jpg)'
  id: totrans-843
  prefs: []
  type: TYPE_IMG
  zh: '![标准结构选择](httpatomoreillycomsourcenostarchimages854191.png.jpg)'
- en: Figure 8-13. Standard structure selection
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-13. 标准结构选择
- en: You may utilize the search functionality to locate structures based on a partial
    text match. The dialog also allows for prefix matching. If you know the first
    few characters of the structure name, simply type them in (they will appear in
    the status bar at the bottom of the dialog), and the list display will jump to
    the first structure with a matching prefix. Choosing a structure adds the structure
    and any nested structures to the Structures window.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用搜索功能根据部分文本匹配来定位结构。对话框还允许前缀匹配。如果您知道结构名称的前几个字符，只需输入它们（它们将出现在对话框底部的状态栏中），列表显示将跳转到第一个具有匹配前缀的结构。选择一个结构会将该结构和任何嵌套结构添加到结构窗口中。
- en: As an example of using standard structures, consider a case in which you wish
    to examine the file headers associated with a Windows PE binary. By default, the
    file headers are not loaded into the database when it is first created; however,
    file headers can be loaded if you select the Manual load option during initial
    database creation. Loading the file headers ensures only that the data bytes associated
    with those headers will be present in the database. In most cases, the headers
    will not be formatted in any way because typical programs make no direct reference
    to their own file headers. Thus there is no reason for the analyzer to apply structure
    templates to the headers.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用标准结构的一个例子，考虑这样一个情况：你希望检查与Windows PE二进制文件关联的文件头。默认情况下，当数据库首次创建时，文件头不会被加载到数据库中；然而，如果你在初始数据库创建期间选择手动加载选项，文件头可以被加载。加载文件头确保只有与这些头关联的数据字节将存在于数据库中。在大多数情况下，头不会被以任何方式格式化，因为典型的程序不会直接引用它们自己的文件头。因此，分析器没有必要将结构模板应用到头中。
- en: After conducting some research on the format of a PE binary, you will learn
    that a PE file begins with an MS-DOS header structure named `IMAGE_DOS_HEADER`.
    Further, data contained within the `IMAGE_DOS_HEADER` points to the location of
    an `IMAGE_NT_HEADERS` structure, which details the memory layout of the PE binary.
    Choosing to load the PE headers, you might see something similar to the following
    unformatted data disassembly. Readers familiar with the PE file structure may
    recognize the familiar MS-DOS magic value `MZ` as the first two bytes in the file.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 在对PE二进制文件的格式进行了研究之后，你会了解到PE文件以一个名为`IMAGE_DOS_HEADER`的MS-DOS头结构开始。此外，`IMAGE_DOS_HEADER`中包含的数据指向`IMAGE_NT_HEADERS`结构的地址，该结构详细说明了PE二进制文件的内存布局。选择加载PE头，你可能会看到以下类似的不格式化数据反汇编。熟悉PE文件结构的读者可能会认出文件中的前两个字节是MS-DOS的魔数`MZ`。
- en: '[PRE66]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As this file is formatted here, you would need some PE file reference documentation
    to help you make sense of each of the data bytes. By using structure templates,
    IDA can format these bytes as an `IMAGE_DOS_HEADER`, making the data far more
    useful. The first step is to add the standard `IMAGE_DOS_HEADER` as detailed above
    (you could add the `IMAGE_NT_HEADERS` structure while you are at it). The second
    step is to convert the bytes beginning at `__ImageBase` into an `IMAGE_DOS_HEADER`
    structure using **Edit** ▸ **Struct Var** (alt-Q). This results in the reformatted
    display shown here:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此文件在此处进行了格式化，你需要一些PE文件参考文档来帮助你理解每个数据字节。通过使用结构模板，IDA可以将这些字节格式化为`IMAGE_DOS_HEADER`，使数据变得更有用。第一步是添加标准的`IMAGE_DOS_HEADER`，如上所述（你可以在此时添加`IMAGE_NT_HEADERS`结构）。第二步是将从`__ImageBase`开始的字节转换为`IMAGE_DOS_HEADER`结构，使用**编辑**
    ▸ **结构变量**（alt-Q）。这会导致以下显示的重新格式化：
- en: '[PRE67]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As you can see, the first 64 (0x40) bytes in the file have been collapsed into
    a single data structure, with the type noted in the disassembly. Unless you possess
    encyclopedic knowledge of this particular structure, though, the meaning of each
    field may remain somewhat cryptic. We can take this operation one step further,
    however, by expanding the structure. When a structured data item is expanded,
    each field is annotated with its corresponding field name from the structure definition.
    Collapsed structures can be expanded using the plus key (+) on the numeric keypad.
    The final version of the listing follows:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，文件中的前64（0x40）字节已被折叠成一个单一的数据结构，类型在反汇编中注明。然而，除非你拥有关于这个特定结构的百科全书式知识，否则每个字段的含义可能仍然有些晦涩。然而，我们可以通过扩展结构来进一步进行这个操作。当结构化数据项被展开时，每个字段都会用结构定义中相应的字段名进行标注。可以使用数字键盘上的加号键（+）展开折叠的结构。最终的列表版本如下：
- en: '[PRE68]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Unfortunately, the fields of `IMAGE_DOS_HEADER` do not possess particularly
    meaningful names, so we may need to consult a PE file reference to remind ourselves
    that the `e_lfanew` field ![](httpatomoreillycomsourcenostarchimages854061.png)
    indicates the file offset at which an `IMAGE_NT_HEADERS` structure can be found.
    Applying all of the previous steps to create an `IMAGE_NT_HEADER` at address `00400080`
    (0x80 bytes into the database) yields the nicely formatted structure shown in
    part here:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`IMAGE_DOS_HEADER`的字段并没有特别有意义的名称，因此我们可能需要查阅PE文件参考来提醒自己，`e_lfanew`字段![http://atomoreilly.com/source/no_starch/images/854061.png](http://atomoreilly.com/source/no_starch/images/854061.png)表示可以找到`IMAGE_NT_HEADERS`结构的文件偏移量。将所有之前的步骤应用到地址`00400080`（数据库中的0x80字节）以创建一个`IMAGE_NT_HEADER`，可以得到这里部分显示的格式化结构：
- en: '[PRE69]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Fortunately for us, the field names in this case are somewhat more meaningful.
    We quickly see that the file consists of five sections ![](httpatomoreillycomsourcenostarchimages854061.png)
    and should be loaded into memory at virtual address `00400000` ![](httpatomoreillycomsourcenostarchimages854063.png).
    Expanded structures can be returned to their collapsed state using the minus key
    (−) on the keypad.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在这种情况下，字段名称有某种程度的实际意义。我们很快就能看到该文件由五个部分组成 ![http://atomoreilly.com/source/no_starch_images/854061.png]
    并且应该加载到虚拟地址 `00400000` ![http://atomoreilly.com/source/no_starch_images/854063.png]。使用键盘上的减号键（−）可以将展开的结构返回到折叠状态。
- en: IDA TIL Files
  id: totrans-856
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA TIL 文件
- en: All datatype and function prototype information in IDA is stored in TIL files.
    IDA ships with type library information for many major compilers and APIs stored
    in the *<IDADIR>/til* directory. The Types window (View ▸ Open subview ▸ Type
    Libraries) lists currently loaded *.til* files and is used to load additional
    *.til* files that you may wish to use. Type libraries are loaded automatically
    based on attributes of the binary discovered during the analysis phase. Under
    ideal circumstances, most users will never need to deal with *.til* files directly.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 中的所有数据类型和函数原型信息都存储在 TIL 文件中。IDA 随带许多主要编译器和 API 的类型库信息，这些信息存储在 *<IDADIR>/til*
    目录下。类型窗口（视图 ▸ 打开子视图 ▸ 类型库）列出了当前加载的 *.til* 文件，并用于加载您可能希望使用的其他 *.til* 文件。类型库会根据分析阶段发现的二进制文件的属性自动加载。在理想情况下，大多数用户将永远不会需要直接处理
    *.til* 文件。
- en: Loading New TIL Files
  id: totrans-858
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载新的 TIL 文件
- en: In some cases, IDA may fail to detect that a specific compiler was used to build
    a binary, perhaps because the binary has undergone some form of obfuscation. When
    this happens, you may load additional *.til* files by pressing the insert key
    within the Types window and selecting the desired *.til* files. When a new *.til*
    file is loaded, all structure definitions contained in the file are added to the
    list of standard structures, and type information is applied for any functions
    within the binary that have matching prototypes in the newly loaded *.til* file.
    In other words, when IDA gains new knowledge about the nature of a function, it
    automatically applies that new knowledge.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，IDA 可能无法检测到用于构建二进制文件的具体编译器，这可能是由于二进制文件经历了某种形式的混淆。当这种情况发生时，您可以通过在类型窗口中按插入键并选择所需的
    *.til* 文件来加载额外的 *.til* 文件。当加载新的 *.til* 文件时，文件中包含的所有结构定义都将添加到标准结构列表中，并且类型信息将应用于二进制文件中具有匹配原型的任何函数。换句话说，当
    IDA 获得有关函数性质的新知识时，它会自动应用这一新知识。
- en: Sharing TIL Files
  id: totrans-860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分享 TIL 文件
- en: IDA also makes use of *.til* files to store any custom structure definitions
    that you create manually in the Structures window or through parsing C header
    files. Such structures are stored in a dedicated *.til* file associated with the
    database in which they were created. This file shares the base name of the database
    and has a *.til* extension. For a database named *some_file.idb*, the associated
    type library file would be *some_file.til*. Under normal circumstances you will
    never see this file unless you happen to have the database open in IDA. Recall
    that an *.idb* file is actually an archive file (similar to a *.tar* file) used
    to hold the components of a database when they are not in use. When a database
    is opened, the component files (the *.til* file being one of them) are extracted
    as working files for IDA.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 还使用 *.til* 文件来存储您在结构窗口中手动创建或通过解析 C 头文件创建的任何自定义结构定义。这些结构存储在与它们创建的数据库关联的专用
    *.til* 文件中。此文件与数据库的基名相同，并具有 *.til* 扩展名。对于名为 *some_file.idb* 的数据库，相关的类型库文件将是 *some_file.til*。在正常情况下，您将永远不会看到此文件，除非您偶然在
    IDA 中打开了数据库。回想一下，*.idb* 文件实际上是一个存档文件（类似于 *.tar* 文件），用于在组件未使用时保存数据库的组件。当数据库打开时，组件文件（*.til*
    文件是其中之一）将被提取为 IDA 的工作文件。
- en: A discussion regarding how to share *.til* files across databases can be found
    at [http://www.hex-rays.com/forum/viewtopic.php?f=6&t=986](http://www.hex-rays.com/forum/viewtopic.php?f=6&t=986).^([[47](#ftn.CHP-8-FN-4)])
    Two techniques are mentioned. The first technique is somewhat unofficial and involves
    copying the *.til* file from an open database into your IDA *til* directory from
    which it can be opened, in any other database, via the Types window. A more official
    way to extract the custom type information from a database is to generate an IDC
    script that can be used to re-create the custom structures in any other database.
    Such a script can be generated using the File ▸ Produce File ▸ Dump Typeinfo to
    IDC File command. However, unlike the first technique, this technique dumps only
    the structures listed in the Structures window, which may not include all structures
    parsed from C header files (whereas the *.til* file-copying technique will).
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何在数据库之间共享*.til*文件的讨论可以在[http://www.hex-rays.com/forum/viewtopic.php?f=6&t=986](http://www.hex-rays.com/forum/viewtopic.php?f=6&t=986)找到.^([[47](#ftn.CHP-8-FN-4)])
    提到了两种技术。第一种技术有些非官方，涉及将*.til*文件从公开数据库复制到您的IDA *til*目录中，然后可以在任何其他数据库中通过类型窗口打开它。从数据库中提取自定义类型信息的一种更官方的方法是生成一个IDC脚本，该脚本可以用于在任何其他数据库中重新创建自定义结构。可以使用“文件”▸“生成文件”▸“将类型信息导出到IDC文件”命令生成此类脚本。然而，与第一种技术不同，这种方法仅导出结构窗口中列出的结构，可能不包括从C头文件中解析的所有结构（而*.til*文件复制技术将包括）。
- en: 'Hex-Rays also provides a standalone tool, named `tilib`, for creating *.til*
    files outside of IDA. The utility is available as a *.zip* file for registered
    users via the Hex-Rays IDA download page. Installation is as simple as extracting
    the *.zip* file contents into *<IDADIR>*. The `tilib` utility may be used to list
    the contents of existing *.til* files or create new *.til* files by parsing C
    (not C++) header files. The following command would list the contents of the Visual
    Studio 6 type library:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: Hex-Rays还提供了一个名为`tilib`的独立工具，用于在IDA之外创建*.til*文件。该实用程序作为*.zip*文件提供给注册用户，可通过Hex-Rays
    IDA下载页面获取。安装过程简单，只需将*.zip*文件内容提取到*<IDADIR>*。`tilib`实用程序可以用来列出现有*.til*文件的内容或通过解析C（不是C++）头文件创建新的*.til*文件。以下命令将列出Visual
    Studio 6类型库的内容：
- en: '[PRE70]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Creating a new *.til* file involves naming the header file to be parsed and
    the *.til* file to be created. Command line options allow you to specify additional
    include file directories or, alternatively, previously parsed *.til* files in
    order to resolve any dependencies contained in your header file. The following
    command creates a new *.til* file containing the declaration of `ch8_struct`.
    The resulting *.til* file must be moved into *<IDADIR>/til* before IDA can make
    use of it.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的*.til*文件涉及命名要解析的头文件和要创建的*.til*文件。命令行选项允许您指定额外的包含文件目录，或者，作为替代，之前解析过的*.til*文件，以便解决头文件中包含的任何依赖。以下命令创建了一个包含`ch8_struct`声明的新的*.til*文件。生成的*.til*文件必须在将其移动到*<IDADIR>/til*之前，IDA才能使用它。
- en: '[PRE71]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `tilib` utility contains a substantial number of additional capabilities,
    some of which are detailed in the README file included with the `tilib` distribution,
    and others of which are briefly detailed by running `tilib` with no arguments.
    Prior to version 6.1, `tilib` is distributed only as a Windows executable; however,
    the *.til* files that it generates are compatible with all versions of IDA.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '`tilib`实用程序包含大量其他功能，其中一些在`tilib`发行版中包含的README文件中有详细说明，而其他一些则可以通过不带参数运行`tilib`来简要了解。在版本6.1之前，`tilib`仅作为Windows可执行文件分发；然而，它生成的*.til*文件与IDA的所有版本兼容。'
- en: '* * *'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[47](#CHP-8-FN-4)]) This link is accessible to registered users only.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#CHP-8-FN-4)]) 此链接仅对注册用户可用。
- en: C++ Reversing Primer
  id: totrans-870
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++逆向工程入门指南
- en: C++ classes are the object-oriented extensions of C structs, so it is somewhat
    logical to wrap up our discussion of data structures with a review of the features
    of compiled C++ code. C++ is sufficiently complex that detailed coverage of the
    topic is beyond the scope of this book. Here we attempt to cover the highlights
    and a few of the differences between Microsoft’s Visual C++ and GNU’s g++.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: C++类是C结构体的面向对象扩展，因此用编译后的C++代码的功能来总结我们对数据结构的讨论在逻辑上是合理的。C++的复杂性足够大，以至于对这一主题的详细覆盖超出了本书的范围。在这里，我们试图涵盖这一主题的要点以及微软的Visual
    C++和GNU的g++之间的一些差异。
- en: An important point to remember is that a solid, fundamental understanding of
    the C++ language will assist you greatly in understanding compiled C++. Object-oriented
    concepts such as inheritance and polymorphism are difficult enough to learn well
    at the source level. Attempting to dive into these concepts at the assembly level
    without understanding them at the source level will certainly be an exercise in
    frustration.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要观点是，对C++语言的扎实、基本理解将极大地帮助您理解编译后的C++。例如，继承和多态这样的面向对象概念在源级别就已经很难学好。在没有理解源级别的情况下尝试在汇编级别深入这些概念，肯定会是一次令人沮丧的练习。
- en: The this Pointer
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this指针
- en: 'The `this` pointer is a pointer available in all nonstatic C++ member functions.
    Whenever such a function is called, `this` is initialized to point to the object
    used to invoke the function. Consider the following functions calls:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`指针是在所有非静态C++成员函数中可用的一个指针。每当调用这样的函数时，`this`都会初始化为指向用于调用该函数的对象。考虑以下函数调用：'
- en: '[PRE72]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the three calls to `member_func`, `this` takes on the values `&object1`,
    `&object2`, and `p_obj`, respectively. It is easiest to view `this` as a hidden
    first parameter passed in to all nonstatic member functions. As discussed in [Chapter 6](ch06.html
    "Chapter 6. Disassembly Navigation"), Microsoft Visual C++ utilizes the `thiscall`
    calling convention and passes `this` in the ECX register. The GNU g++ compiler
    treats `this` exactly as if it was the first (leftmost) parameter to nonstatic
    member functions and pushes the address of the object used to invoke the function
    as the topmost item on the stack prior to calling the function.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`member_func`的三个调用中，`this`分别取值为`&object1`、`&object2`和`p_obj`。最容易将`this`视为传递给所有非静态成员函数的一个隐藏的第一个参数。如[第6章](ch06.html
    "第6章。反汇编导航")所述，Microsoft Visual C++使用`thiscall`调用约定，并将`this`传递到ECX寄存器。GNU g++编译器将`this`处理得就像它是非静态成员函数的第一个（最左边的）参数一样，并在调用函数之前将用于调用函数的对象的地址推送到栈顶。
- en: From a reverse engineering point of view, the moving of an address into the
    ECX register immediately prior to a function call is a probable indicator of two
    things. First, the file was compiled using Visual C++. Second, the function is
    a member function. When the same address is passed to two or more functions, we
    can conclude that those functions all belong to the same class hierarchy.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 从逆向工程的角度来看，在函数调用之前将地址移动到ECX寄存器可能是两个事物的指示。首先，文件是用Visual C++编译的。其次，该函数是成员函数。当相同的地址传递给两个或更多函数时，我们可以得出结论，这些函数都属于同一类层次结构。
- en: Within a function, the use of ECX prior to initializing it implies that the
    caller must have initialized ECX and is a possible sign that the function is a
    member function (though the function may simply use the `fastcall` calling convention).
    Further, when a member function is observed to pass `this` to additional functions,
    those functions can be inferred to be members of the same class as well.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，在初始化ECX之前使用ECX意味着调用者必须已经初始化了ECX，并且可能是函数是成员函数的迹象（尽管该函数可能简单地使用`fastcall`调用约定）。此外，当观察到成员函数将`this`传递给其他函数时，可以推断出这些函数也是同一类的成员。
- en: For code compiled using g++, calls to member functions stand out somewhat less.
    However, any function that does not take a pointer as its first argument can certainly
    be ruled out as a member function.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用g++编译的代码，对成员函数的调用不太明显。然而，任何不以指针作为其第一个参数的函数肯定可以排除是成员函数。
- en: Virtual Functions and Vtables
  id: totrans-880
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数和vtable
- en: Virtual functions provide the means for polymorphic behavior in C++ programs.
    For each class (or subclass through inheritance) that contains virtual functions,
    the compiler generates a table containing pointers to each virtual function in
    the class. Such tables are called *vtables*. Furthermore, every class that contains
    virtual functions is given an additional data member whose purpose is to point
    to the appropriate vtable at runtime. This member is typically referred to as
    a *vtable pointer* and is allocated as the first data member within the class.
    When an object is created at runtime, its vtable pointer is set to point at the
    appropriate vtable. When that object invokes a virtual function, the correct function
    is selected by performing a lookup in the object’s vtable. Thus, vtables are the
    underlying mechanism that facilitates runtime resolution of calls to virtual functions.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数提供了在C++程序中实现多态行为的手段。对于每个包含虚函数的类（或通过继承的子类），编译器生成一个包含指向该类中每个虚函数指针的表。这样的表被称为*vtables*。此外，每个包含虚函数的类都额外有一个数据成员，其目的是在运行时指向适当的vtable。这个成员通常被称为*vtable指针*，并在类内作为第一个数据成员分配。当在运行时创建对象时，其vtable指针被设置为指向适当的vtable。当该对象调用虚函数时，通过在对象的vtable中查找来选择正确的函数。因此，vtables是促进虚函数调用运行时解析的底层机制。
- en: 'A few examples may help to clarify the use of vtables. Consider the following
    C++ class definitions:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子可能有助于阐明vtables的使用。考虑以下C++类定义：
- en: '[PRE73]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this case, SubClass inherits from BaseClass. BaseClass contains four virtual
    functions, while SubClass contains five (four from BaseClass plus the new `vfunc5`).
    Within BaseClass, `vfunc1` is a *pure virtual function* by virtue of the use of
    `= 0` in its declaration. Pure virtual functions have no implementation in their
    declaring class and *must* be overridden in a subclass before the class is considered
    concrete. In other words, there is no function named `Base-Class::vfunc1`, and
    until a subclass provides an implementation, no objects can be instantiated. SubClass
    provides such an implementation, so SubClass objects can be created.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，SubClass从BaseClass继承。BaseClass包含四个虚函数，而SubClass包含五个（来自BaseClass的四个加上新的`vfunc5`）。在BaseClass中，`vfunc1`由于其声明中使用了`=
    0`而是一个*纯虚函数*。纯虚函数在其声明类中没有实现，*必须*在子类中重写，类才被认为是具体的。换句话说，没有名为`Base-Class::vfunc1`的函数，并且直到子类提供了实现，不能实例化对象。SubClass提供了这样的实现，因此可以创建SubClass对象。
- en: At first glance BaseClass appears to contain two data members and Sub Class
    three data members. Recall, however, that any class that contains virtual functions,
    either explicitly or because they are inherited, also contains a vtable pointer.
    As a result, instantiated BaseClass objects actually have three data members,
    while instantiated SubClass objects have four data members. In each case, the
    first data member is the vtable pointer. Within SubClass, the vtable pointer is
    actually inherited from BaseClass rather than being introduced specifically for
    SubClass. [Figure 8-14](ch08s07.html#a_simple_vtable_layout "Figure 8-14. A simple
    vtable layout") shows a simplified memory layout in which a single SubClass object
    has been dynamically allocated. During the creation of the object, the compiler
    ensures that the new object’s vtable pointer points to the correct vtable (SubClass’s
    in this case).
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，BaseClass似乎包含两个数据成员，而Sub Class有三个数据成员。然而，请记住，任何包含虚函数的类，无论是显式包含还是通过继承包含，也包含一个vtable指针。因此，实例化的BaseClass对象实际上有三个数据成员，而实例化的SubClass对象有四个数据成员。在每个情况下，第一个数据成员是vtable指针。在SubClass中，vtable指针实际上是继承自BaseClass，而不是专门为SubClass引入的。[图8-14](ch08s07.html#a_simple_vtable_layout
    "图8-14. 一个简单的vtable布局")显示了简化后的内存布局，其中动态分配了一个单个的SubClass对象。在对象的创建过程中，编译器确保新对象的vtable指针指向正确的vtable（在这种情况下是SubClass的）。
- en: '![A simple vtable layout](httpatomoreillycomsourcenostarchimages854193.png)'
  id: totrans-886
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的vtable布局](httpatomoreillycomsourcenostarchimages854193.png)'
- en: Figure 8-14. A simple vtable layout
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-14. 一个简单的vtable布局
- en: Note that the vtable for SubClass contains two pointers to functions belonging
    to BaseClass (`BaseClass::vfunc2` and `BaseClass::vfunc4`). This is because SubClass
    does not override either of these functions and instead inherits them from BaseClass.
    Also shown is the typical handling of pure virtual function entries. Because there
    is no implementation for the pure virtual function `BaseClass::vfunc1`, no address
    is available to store in the BaseClass vtable slot for `vfunc1`. In such cases,
    compilers insert the address of an error handling function, often dubbed `purecall`,
    which in theory should never be called but which will usually abort the program
    in the event that it somehow is called.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SubClass的vtable包含指向属于BaseClass的函数的两个指针（`BaseClass::vfunc2`和`BaseClass::vfunc4`）。这是因为SubClass没有重写这些函数，而是从BaseClass继承它们。同时展示了纯虚函数条目的典型处理。由于纯虚函数`BaseClass::vfunc1`没有实现，因此没有地址可以存储在BaseClass
    vtable槽中的`vfunc1`。在这种情况下，编译器会插入一个错误处理函数的地址，通常被称为`purecall`，理论上不应该被调用，但通常在它被意外调用时会终止程序。
- en: One consequence of the presence of a vtable pointer is that you must account
    for it when you manipulate the class within IDA. Recall that C++ classes are an
    extension of C structures. Therefore, you may choose to make use of IDA’s structure
    definition features to define the layout of C++ classes. In the case of classes
    that contain virtual functions, you must remember to include a vtable pointer
    as the first field within the class. Vtable pointers must also be accounted for
    in the total size of an object. This is most apparent when observing the dynamic
    allocation of an object using the `new`^([[48](#ftn.CHP-8-FN-5)]) operator, where
    the size value passed to `new` includes the space consumed by all explicitly declared
    fields in the class (and any superclasses) as well as any space required for a
    vtable pointer.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: vtable指针的存在的一个后果是，在ID中操作类时必须考虑它。回想一下，C++类是C结构的扩展。因此，可以选择使用ID的结构定义功能来定义C++类的布局。对于包含虚函数的类，必须记住在类中包含vtable指针作为第一个字段。vtable指针也必须在对象的总大小中考虑。这在使用`new`^([[48](#ftn.CHP-8-FN-5)])运算符动态分配对象时最为明显，其中传递给`new`的大小值包括类（以及任何超类）中显式声明的所有字段占用的空间，以及vtable指针所需的任何空间。
- en: In the following example a SubClass object is created dynamically, and its address
    saved in a BaseClass pointer. The pointer is then passed to a function (`call_vfunc`),
    which uses the pointer to call `vfunc3`.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，动态创建了一个SubClass对象，并将其地址保存在一个BaseClass指针中。然后将该指针传递给一个函数（`call_vfunc`），该函数使用该指针调用`vfunc3`。
- en: '[PRE74]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Since `vfunc3` is a virtual function, the compiler must ensure that `Sub-Class::vfunc3`
    is called in this case because the pointer points to a Sub-Class object. The following
    disassembled version of `call_vfunc` demonstrates how the virtual function call
    is resolved:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`vfunc3`是一个虚函数，编译器必须确保在这种情况下调用`Sub-Class::vfunc3`，因为指针指向一个Sub-Class对象。以下`call_vfunc`的反汇编版本演示了如何解析虚函数调用：
- en: '[PRE75]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The vtable pointer is read from the structure at ![](httpatomoreillycomsourcenostarchimages854061.png)
    and saved in the EDX register. Since the parameter `b` points to a SubClass object,
    this will be the address of SubClass’s vtable. At ![](httpatomoreillycomsourcenostarchimages854063.png),
    the vtable is indexed to read the third pointer (the address of `SubClass::vfunc3`
    in this case) into the EAX register. Finally, at ![](httpatomoreillycomsourcenostarchimages854093.png),
    the virtual function is called.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: vtable指针从![图片](httpatomoreillycomsourcenostarchimages854061.png)处的结构中读取并保存到EDX寄存器中。由于参数`b`指向一个SubClass对象，这将是指向SubClass
    vtable的地址。在![图片](httpatomoreillycomsourcenostarchimages854063.png)处，vtable被索引以将第三个指针（在这种情况下是`SubClass::vfunc3`的地址）读入EAX寄存器。最后，在![图片](httpatomoreillycomsourcenostarchimages854093.png)处调用虚函数。
- en: 'Note that the vtable indexing operation at ![](httpatomoreillycomsourcenostarchimages854063.png)
    looks very much like a structure reference operation. In fact, it is no different,
    and it is possible to define a structure to represent the layout of a class’s
    vtable and then use the defined structure to make the disassembly more readable,
    as shown here:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在![图片](httpatomoreillycomsourcenostarchimages854063.png)处的vtable索引操作看起来非常像结构引用操作。实际上，它们没有区别，可以定义一个结构来表示类的vtable布局，然后使用定义的结构使反汇编更易于阅读，如下所示：
- en: '[PRE76]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This structure allows the vtable reference operation to be reformatted as follows:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构允许将vtable引用操作重新格式化为以下形式：
- en: '[PRE77]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The Object Life Cycle
  id: totrans-899
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: An understanding of the mechanism by which objects are created and destroyed
    can help to reveal object hierarchies and nested object relationships as well
    as quickly identify class constructor and destructor functions.^([[49](#ftn.CHP-8-FN-6)])
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象创建和销毁的机制可以帮助揭示对象层次结构和嵌套对象关系，以及快速识别类的构造函数和析构函数函数。[^[[49](#ftn.CHP-8-FN-6])]
- en: For global and statically allocated objects, constructors are called during
    program startup and prior to entry into the `main` function. Constructors for
    stack-allocated objects are invoked at the point the object comes into scope within
    the function in which it is declared. In many cases, this will be immediately
    upon entry to the function in which it is declared. However, when an object is
    declared within a block statement, its constructor is not invoked until that block
    is entered, if it is entered at all. When an object is allocated dynamically in
    the program heap, its creation is a two-step process. In the first step, the `new`
    operator is invoked to allocate the object’s memory. In the second step, the constructor
    is invoked to initialize the object. A major difference between Microsoft’s Visual
    C++ and GNU’s g++ is that Visual C++ ensures that the result of `new` is not null
    prior to invoking the constructor.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全局和静态分配的对象，构造函数在程序启动期间以及在进入`main`函数之前被调用。栈分配对象的构造函数在其声明的函数中对象进入作用域时被调用。在许多情况下，这将是进入声明的函数时立即发生。然而，当一个对象在块语句中声明时，如果它被进入，其构造函数直到进入该块时才被调用。当程序在程序堆中动态分配对象时，其创建是一个两步过程。在第一步中，`new`运算符被调用以分配对象的内存。在第二步中，调用构造函数以初始化对象。Microsoft的Visual
    C++与GNU的g++之间一个主要的不同之处在于，Visual C++确保在调用构造函数之前`new`的结果不是null。
- en: 'When a constructor executes, the following sequence of actions takes place:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数执行时，以下序列的操作发生：
- en: If the class has a superclass, the superclass constructor is invoked.
  id: totrans-903
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有一个超类，则调用超类构造函数。
- en: If the class has any virtual functions, the vtable pointer is initialized to
    point to the class’s vtable. Note that this may overwrite a vtable pointer that
    was initialized in the superclass, which is exactly the desired behavior.
  id: totrans-904
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有任何虚函数，vtable指针被初始化为指向类的vtable。请注意，这可能会覆盖在超类中初始化的vtable指针，这正是期望的行为。
- en: If the class has any data members that are themselves objects, then the constructor
    for each such data member is invoked.
  id: totrans-905
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有任何自身是对象的数据成员，则调用每个此类数据成员的构造函数。
- en: Finally, the code-specific constructor is executed. This is the code representing
    the C++ behavior of the constructor specified by the programmer.
  id: totrans-906
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行了代码特定的构造函数。这是代表程序员指定的构造函数的C++行为的代码。
- en: Constructors do not specify a return type; however, constructors generated by
    Microsoft Visual C++ actually return `this` in the EAX register. Regardless, this
    is a Visual C++ implementation detail and does not permit C++ programmers to access
    the returned value.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不指定返回类型；然而，由Microsoft Visual C++生成的构造函数实际上在EAX寄存器中返回`this`。无论如何，这是一个Visual
    C++实现细节，并不允许C++程序员访问返回值。
- en: Destructors are called in essentially the reverse order. For global and static
    objects, destructors are called by cleanup code that is executed after the `main`
    function terminates. Destructors for stack-allocated objects are invoked as the
    objects go out of scope. Destructors for heap-allocated objects are invoked via
    the `delete` operator immediately before the memory allocated to the object is
    released.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数的调用基本上是相反的顺序。对于全局和静态对象，析构函数在`main`函数终止后由清理代码调用。栈分配对象的析构函数在对象超出作用域时被调用。堆分配对象的析构函数通过`delete`运算符在释放分配给对象的内存之前立即调用。
- en: The actions performed by destructors mimic those performed by constructors,
    with the exception that they are performed in roughly reverse order.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数执行的动作与构造函数执行的动作相似，只是它们按大致相反的顺序执行。
- en: If the class has any virtual functions, the vtable pointer for the object is
    restored to point to the vtable for the associated class. This is required in
    case a subclass had overwritten the vtable pointer as part of its creation process.
  id: totrans-910
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有任何虚函数，对象的vtable指针将恢复为指向相关类的vtable。如果子类在其创建过程中覆盖了vtable指针，则需要这样做。
- en: The programmer-specified code for the destructor executes.
  id: totrans-911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员指定的析构函数代码执行。
- en: If the class has any data members that are themselves objects, the destructor
    for each such member is executed.
  id: totrans-912
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有任何自身是对象的数据成员，则将执行每个此类成员的析构函数。
- en: Finally, if the object has a superclass, the superclass destructor is called.
  id: totrans-913
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果对象有一个超类，则会调用超类析构函数。
- en: By understanding when superclass constructors and destructors are called, it
    is possible to trace an object’s inheritance hierarchy through the chain of calls
    to its related superclass functions. A final point regarding vtables relates to
    how they are referenced within programs. There are only two circumstances in which
    a class’s vtable is referenced directly, within the class constructor(s) and destructor.
    When you locate a vtable, you can utilize IDA’s data cross-referencing capabilities
    (see [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing")) to quickly
    locate all constructors and destructors for the associated class.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解何时调用超类构造函数和析构函数，可以沿着调用其相关超类函数的链来追踪一个对象的继承层次结构。关于vtable的最后一个观点是它们在程序中的引用方式。只有在类构造函数(s)和析构函数中，才会直接引用类的vtable。当你定位到一个vtable时，可以利用IDA的数据交叉引用功能（见[第9章](ch09.html
    "第9章。交叉引用和绘图"））快速定位到相关类的所有构造函数和析构函数。
- en: Name Mangling
  id: totrans-915
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名改写
- en: Also called *name decoration*, *name mangling* is the mechanism C++ compilers
    use to distinguish among overloaded^([[50](#ftn.CHP-8-FN-7)]) versions of a function.
    In order to generate unique names for overloaded functions, compilers decorate
    the function name with additional characters used to encode various pieces of
    information about the function. Encoded information typically describes the return
    type of the function, the class to which the function belongs, and the parameter
    sequence (type and order) required to call the function.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为*名称装饰*，*命名改写*是C++编译器用来区分函数重载版本的一种机制。为了为重载函数生成唯一的名称，编译器会在函数名称上添加额外的字符，用于编码有关函数的各种信息。编码信息通常描述了函数的返回类型、函数所属的类以及调用函数所需的参数序列（类型和顺序）。
- en: Name mangling is a compiler implementation detail for C++ programs and as such
    is not part of the C++ language specification. Not unexpectedly, compiler vendors
    have developed their own, often-incompatible conventions for name mangling. Fortunately,
    IDA understands the name-mangling conventions employed by Microsoft Visual C++
    and GNU g++ as well as a few other compilers. By default, when a mangled name
    is encountered within a program, IDA displays the demangled equivalent as a comment
    anywhere the name appears in the disassembly. IDA’s name-demangling options are
    selected using the dialog shown in [Figure 8-15](ch08s07.html#demangled_name_display_options
    "Figure 8-15. Demangled name display options"), which is accessed using Options
    ▸ Demangled Names.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 命名改写是C++程序的编译器实现细节，因此它不是C++语言规范的一部分。不出所料，编译器供应商已经开发了他们自己的、通常不兼容的命名改写约定。幸运的是，IDA理解Microsoft
    Visual C++和GNU g++以及一些其他编译器使用的命名改写约定。默认情况下，当在程序中遇到改写名称时，IDA会将改写后的等效名称作为注释显示在名称出现的任何位置。IDA的名称改写选项是通过[图8-15](ch08s07.html#demangled_name_display_options
    "图8-15。改写名称显示选项")所示的对话框选择的，该对话框通过选项 ▸ 改写名称访问。
- en: '![Demangled name display options](httpatomoreillycomsourcenostarchimages854195.png.jpg)'
  id: totrans-918
  prefs: []
  type: TYPE_IMG
  zh: '![改写名称显示选项](httpatomoreillycomsourcenostarchimages854195.png.jpg)'
- en: Figure 8-15. Demangled name display options
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-15。改写名称显示选项
- en: 'The three principal options control whether demangled names are displayed as
    comments, whether the names themselves are demangled, or whether no demangling
    is performed at all. Displaying demangled names as comments results in a display
    similar to the following:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要选项控制是否将改写名称显示为注释、是否改写名称本身，或者根本不进行改写。将改写名称显示为注释会导致类似以下显示：
- en: '[PRE78]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Likewise, displaying demangled names as names results in the following:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将改写名称显示为名称会导致以下结果：
- en: '[PRE79]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: where ![](httpatomoreillycomsourcenostarchimages854061.png) is representative
    of the first line of a disassembled function and ![](httpatomoreillycomsourcenostarchimages854063.png)
    is representative of a call to that function.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![](httpatomoreillycomsourcenostarchimages854061.png) 代表了反汇编函数的第一行，而 ![](httpatomoreillycomsourcenostarchimages854063.png)
    代表了对该函数的调用。
- en: The Assume GCC v3.x names checkbox is used to distinguish between the mangling
    scheme used in g++ version 2.9.*x* and that used in g++ versions 3.*x* and later.
    Under normal circumstances, IDA should automatically detect the naming conventions
    in use in g++-compiled code. The Setup short names and Setup long names buttons
    offer fine-grained control over the formatting of demangled names with a substantial
    number of options that are documented in IDA’s help system.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“假定 GCC v3.x 命名”复选框来区分 g++ 版本 2.9.*x* 和 g++ 版本 3.*x* 及以后的混淆方案。在正常情况下，IDA 应该自动检测
    g++ 编译的代码中使用的命名约定。设置短名称和设置长名称按钮提供了对解混淆名称格式的精细控制，这些选项在 IDA 的帮助系统中都有文档说明。
- en: Because mangled names carry so much information regarding the signature of each
    function, they reduce the time required to understand the number and types of
    parameters passed into a function. When mangled names are available within a binary,
    IDA’s demangling capability instantly reveals the parameter types and return types
    for all functions whose names are mangled. In contrast, for any function that
    does not utilize a mangled name, you must conduct time-consuming analysis of the
    data flowing into and out of the function in order to determine the signature
    of the function.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 因为混淆名称包含了关于每个函数签名的很多信息，它们减少了理解传递给函数的参数数量和类型所需的时间。当在二进制文件中可用混淆名称时，IDA的解混淆能力可以立即揭示所有混淆名称的函数的参数类型和返回类型。相比之下，对于任何未使用混淆名称的函数，你必须进行耗时的分析，以确定函数的签名，分析函数的输入和输出数据。
- en: Runtime Type Identification
  id: totrans-927
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时类型识别
- en: C++ provides operators that allow for runtime determination (`typeid`) and checking
    (`dynamic_cast`) of an object’s datatype. To facilitate these operations, C++
    compilers must embed type information within a program binary and implement procedures
    whereby the type of a polymorphic object can be determined with certainty regardless
    of the type of the pointer that may be dereferenced to access the object. Unfortunately,
    as with name mangling, Runtime Type Identification (RTTI) is a compiler implementation
    detail rather than a language issue, and there is no standard means by which compilers
    implement RTTI capabilities.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了运算符，允许在运行时确定（`typeid`）和检查（`dynamic_cast`）对象的类型。为了便于这些操作，C++ 编译器必须在程序二进制中嵌入类型信息，并实现程序，以便可以确定多态对象的类型，无论可能解引用的指针类型如何。不幸的是，与名称混淆一样，运行时类型识别（RTTI）是编译器实现细节，而不是语言问题，并且没有标准的方法来让编译器实现
    RTTI 功能。
- en: We will take brief look at the similarities and differences between the RTTI
    implementations of Microsoft Visual C++ and GNU g++. Specifically, the only details
    presented here concern how to locate RTTI information and, from there, how to
    learn the name of class to which that information pertains. Readers desiring more
    detailed discussion of Microsoft’s RTTI implementation should consult the references
    listed at the end of this chapter. In particular, the references detail how to
    traverse a class’s inheritance hierarchy, including how to trace that hierarchy
    when multiple inheritance is being used.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要地看看 Microsoft Visual C++ 和 GNU g++ 的 RTTI 实现之间的相似之处和不同之处。具体来说，这里提供的唯一细节是关于如何定位
    RTTI 信息，以及如何从那里学习与该信息相关的类的名称。希望对 Microsoft 的 RTTI 实现有更详细讨论的读者应参考本章末尾列出的参考文献。特别是，这些参考文献详细说明了如何遍历类的继承层次结构，包括在多重继承中使用时如何追踪该层次结构。
- en: 'Consider the following simple program, which makes use of polymorphism:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的程序，它使用了多态性：
- en: '[PRE80]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `print_type` function must correctly print the type of the object being
    pointed to by the pointer `p`. In this case, it is trivial to realize that “concrete_class”
    must be printed based on the fact that a `concrete_class` object is created in
    the `main` function. The question we answer here is: How does `print_type`, and
    more specifically `typeid`, know what type of object `p` is pointing to?'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_type` 函数必须正确打印出指针 `p` 所指向的对象的类型。在这种情况下，根据在 `main` 函数中创建了一个 `concrete_class`
    对象的事实，可以轻易地意识到应该打印出“concrete_class”。我们在这里回答的问题是：`print_type`，更具体地说 `typeid`，是如何知道
    `p` 指向的对象的类型？'
- en: The answer is surprisingly simple. Since every polymorphic object contains a
    pointer to a vtable, compilers leverage that fact by co-locating class-type information
    with the class vtable. Specifically, the compiler places a pointer immediately
    prior to the class vtable. This pointer points to a structure that contains information
    used to determine the name of the class that owns the vtable. In g++ code, this
    pointer points to a `type_info` structure, which contains a pointer to the name
    of the class. In Visual C++, the pointer points to a Microsoft `RTTICompleteObjectLocator`
    structure, which in turn contains a pointer to a `TypeDescriptor` structure. The
    `TypeDescriptor` structure contains a character array that specifies the name
    of the polymorphic class.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 答案出奇地简单。由于每个多态对象都包含一个指向虚函数表的指针，编译器利用这一事实，通过将类类型信息与类虚函数表一起定位。具体来说，编译器将一个指针放置在类虚函数表之前。这个指针指向一个包含用于确定拥有虚函数表的类名称的信息的结构。在g++代码中，这个指针指向一个`type_info`结构，它包含指向类名称的指针。在Visual
    C++中，这个指针指向一个Microsoft `RTTICompleteObjectLocator`结构，它反过来又包含一个指向`TypeDescriptor`结构的指针。`TypeDescriptor`结构包含一个字符数组，指定了多态类的名称。
- en: It is important to realize that RTTI information is required only in C++ programs
    that use the `typeid` or `dynamic_cast` operator. Most compilers provide options
    to disable the generation of RTTI in binaries that do not require it; therefore,
    you should not be surprised if RTTI information ever happens to be missing.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，只有在使用`typeid`或`dynamic_cast`运算符的C++程序中才需要RTTI信息。大多数编译器提供选项来禁用在不需要RTTI的二进制文件中生成RTTI；因此，如果你发现RTTI信息缺失，请不要感到惊讶。
- en: Inheritance Relationships
  id: totrans-935
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承关系
- en: If you dig deep enough into some RTTI implementations, you will find that it
    is possible to unravel inheritance relationships, though you must understand the
    compiler’s particular implementation of RTTI in order to do so. Also, RTTI may
    not be present when a program does not utilize the `typeid` or `dynamic_cast`
    operators. Lacking RTTI information, what techniques can be employed to determine
    inheritance relationships among C++ classes?
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入探究一些RTTI实现，你会发现解开继承关系是可能的，尽管你必须理解编译器对RTTI的特殊实现才能做到这一点。此外，当程序没有使用`typeid`或`dynamic_cast`运算符时，RTTI可能不存在。在没有RTTI信息的情况下，可以采用哪些技术来确定C++类之间的继承关系？
- en: The simplest method of determining an inheritance hierarchy is to observe the
    chain of calls to superclass constructors that are called when an object is created.
    The single biggest hindrance to this technique is the use of inline^([[51](#ftn.CHP-8-FN-8)])
    constructors, the use of which makes it impossible to understand that a superclass
    constructor has in fact been called.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 确定继承层次结构的最简单方法是观察在创建对象时调用的超类构造函数的调用链。这种技术的最大障碍是内联构造函数的使用，其使用使得无法理解实际上已经调用了超类构造函数。
- en: An alternative means for determining inheritance relationships involves the
    analysis and comparison of vtables. For example, in comparing the vtables shown
    in [Figure 8-14](ch08s07.html#a_simple_vtable_layout "Figure 8-14. A simple vtable
    layout"), we note that the vtable for SubClass contains two of the same pointers
    that appear in the vtable for BaseClass. We can easily conclude that BaseClass
    and SubClass must be related in some way, but which one is the base class and
    which one is the subclass? In such cases we can apply the following guidelines,
    singly or in combination, in an attempt to understand the nature of their relationship.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 确定继承关系的另一种方法涉及分析和比较虚函数表。例如，在比较[图8-14](ch08s07.html#a_simple_vtable_layout "图8-14.
    简单的虚函数表布局")中显示的虚函数表时，我们注意到SubClass的虚函数表包含与BaseClass虚函数表中出现的两个相同的指针。我们可以很容易地得出结论，BaseClass和SubClass必须在某种程度上相关联，但哪个是基类，哪个是子类？在这种情况下，我们可以单独或组合应用以下指南，以尝试了解它们之间的关系。
- en: When two vtables contain the same number of entries, the two corresponding classes
    *may* be involved in an inheritance relationship.
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个虚函数表包含相同数量的条目时，这两个相应的类*可能*存在继承关系。
- en: When the vtable for class X contains more entries than the vtable for class
    Y, class X *may* be a subclass of class Y.
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类X的虚函数表包含的条目多于类Y的虚函数表时，类X*可能*是类Y的子类。
- en: 'When the vtable for class X contains entries that are also found in the vtable
    for class Y, then one of the following relationships must exist: X is a subclass
    of Y, Y is a subclass of X, or X and Y are both subclasses of a common superclass
    Z.'
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类X的虚表包含在类Y的虚表中也能找到的条目时，以下关系之一必须存在：X是Y的子类，Y是X的子类，或者X和Y都是共同超类Z的子类。
- en: When the vtable for class X contains entries that are also found in the vtable
    for class Y and the vtable for class X contains at least one `purecall` entry
    that is not also present in the corresponding vtable entry for class Y, then class
    Y is a subclass of class X.
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类X的虚表包含在类Y的虚表中也能找到的条目，并且类X的虚表至少包含一个不在类Y的相应虚表条目中出现的`purecall`条目时，则类Y是类X的子类。
- en: While the list above is by no means all-inclusive, we can use these guidelines
    to deduce the relationship between BaseClass and SubClass in [Figure 8-14](ch08s07.html#a_simple_vtable_layout
    "Figure 8-14. A simple vtable layout"). In this case, the last three rules all
    apply, but the last rule specifically leads us to conclude, based on vtable analysis
    alone, that SubClass inherits from BaseClass.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述列表远非详尽无遗，但我们可以使用这些指南来推断BaseClass和SubClass在[图8-14](ch08s07.html#a_simple_vtable_layout
    "图8-14. 简单的虚表布局")中的关系。在这种情况下，最后三条规则都适用，但最后一条规则特别引导我们仅根据虚表分析得出结论，即SubClass继承自BaseClass。
- en: C++ Reverse Engineering References
  id: totrans-944
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++逆向工程参考资料
- en: 'For further reading on the topic of reverse engineering compiled C++, check
    out these excellent references:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 关于逆向工程编译后的C++主题的进一步阅读，请参阅以下优秀参考资料：
- en: 'Igor Skochinsky’s article “Reversing Microsoft Visual C++ Part II: Classes,
    Methods and RTTI,” available at [http://www.openrce.org/articles/full_view/23](http://www.openrce.org/articles/full_view/23).'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Igor Skochinsky的文章“Reversing Microsoft Visual C++ Part II: Classes, Methods
    and RTTI”，可在[http://www.openrce.org/articles/full_view/23](http://www.openrce.org/articles/full_view/23)找到。'
- en: Paul Vincent Sabanal and Mark Vincent Yason’s paper “Reversing C++,” available
    at [http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf](http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf).
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paul Vincent Sabanal和Mark Vincent Yason的论文“Reversing C++”，可在[http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf](http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf)找到。
- en: While many of the details in each of these articles apply specifically to programs
    compiled using Microsoft Visual C++, many of the concepts apply equally to programs
    compiled using other C++ compilers.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些文章中的许多细节仅适用于使用Microsoft Visual C++编译的程序，但许多概念同样适用于使用其他C++编译器编译的程序。
- en: '* * *'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[48](#CHP-8-FN-5)]) The `new` operator is used for dynamic memory allocation
    in C++ in much the same way that `malloc` is used in C (though `new` is built
    into the C++ language, where `malloc` is merely a standard library function).
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[48](#CHP-8-FN-5)]) 在C++中，`new`运算符用于动态内存分配，这与C语言中使用`malloc`的方式类似（尽管`new`是C++语言的一部分，而`malloc`只是一个标准库函数）。
- en: ^([[49](#CHP-8-FN-6)]) A *class constructor* function is an initialization function
    that is invoked automatically when an object is created. A corresponding *destructor*
    is optional and would be called when an object is no longer in scope or similar.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#CHP-8-FN-6)]) *类构造函数*是一个在创建对象时自动调用的初始化函数。相应的*析构函数*是可选的，当对象不再在作用域内或类似情况下会被调用。
- en: ^([[50](#CHP-8-FN-7)]) In C++, *function overloading* allows programmers to
    use the same name for several functions. The only requirement is that each version
    of an overloaded function must differ from every other version in the sequence
    and/or quantity of parameter types that the function receives. In other words,
    each function prototype must be unique.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[50](#CHP-8-FN-7)]) 在C++中，*函数重载*允许程序员为几个函数使用相同的名称。唯一的要求是，每个重载函数的版本必须与每个其他版本在参数类型序列和/或数量上有所不同。换句话说，每个函数原型必须是唯一的。
- en: ^([[51](#CHP-8-FN-8)]) In C/C++ programs a function declared as `inline` is
    treated as a macro by the compiler, and the code for the function is expanded
    in place of an explicit function call. Since the presence of an assembly language
    call statement is a dead giveaway that a function is being called, the use of
    inline functions tends to hide the fact that a function is being used.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[51](#CHP-8-FN-8)]) 在C/C++程序中，被声明为`inline`的函数会被编译器当作宏处理，函数的代码会在显式函数调用处展开。由于汇编语言调用语句的存在是函数被调用的明显迹象，因此内联函数的使用往往隐藏了函数被使用的事实。
- en: Summary
  id: totrans-954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You can expect to encounter complex datatypes in all but the most trivial programs.
    Understanding how data within complex data structures is accessed and knowing
    how to recognize clues to the layout of those complex data structures is an essential
    reverse engineering skill. IDA provides a wide variety of features designed specifically
    to address the need to deal with complex data structures. Familiarity with these
    features will greatly enhance your ability to comprehend what data is being manipulated
    and spend more time understanding how and why that data is being manipulated.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以在所有非最简单程序中遇到复杂的数据类型。了解如何在复杂的数据结构中访问数据，以及如何识别指向这些复杂数据结构布局的线索，是逆向工程的基本技能。IDA提供了一系列专门针对处理复杂数据结构需求的功能。熟悉这些功能将大大提高你理解正在操作哪些数据以及花更多时间理解数据和为什么被操作的能力。
- en: In the next chapter, we round out our discussion of IDA’s basic capabilities
    with a discussion of cross-references and graphing before moving on to the more
    advanced aspects of IDA usage that set it apart from other reverse engineering
    tools.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们在讨论IDA的基本功能的基础上，讨论交叉引用和绘图，然后再继续探讨IDA使用的更高级功能，这些功能使它区别于其他逆向工程工具。
- en: Chapter 9. Cross-References and Graphing
  id: totrans-957
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。交叉引用和绘图
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-958
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: Some of the more common questions asked while reverse engineering a binary are
    along the lines of “Where is this function called from?” and “What functions access
    this data?” These and other similar questions seek to catalog the references to
    and from various resources in a program. Two examples serve to show the usefulness
    of such questions.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在逆向工程二进制文件时，人们通常会问一些更常见的问题，例如“这个函数是从哪里被调用的？”和“哪些函数访问了这些数据？”这些问题以及其他类似问题旨在对程序中各种资源的引用进行编目。以下两个例子有助于说明这类问题的有用性。
- en: Consider the case in which you have located a function containing a stack-allocated
    buffer that can be overflowed, possibly leading to exploitation of the program.
    Since the function may be buried deep within a complex application, your next
    step might be to determine exactly how the function can be reached. The function
    is useless to you unless you can get it to execute. This leads to the question
    “What functions call this vulnerable function?” as well as additional questions
    regarding the nature of the data that those functions may pass to the vulnerable
    function. This line of reasoning must continue as you work your way back up potential
    call chains to find one that you can influence to properly exploit the overflow
    that you have discovered.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：你发现了一个包含可溢出栈分配缓冲区的函数，这可能导致程序被利用。由于该函数可能深埋在一个复杂的应用程序中，你的下一步可能是确定如何精确地访问该函数。除非你能让它执行，否则该函数对你来说毫无用处。这引出了问题“哪些函数调用了这个有漏洞的函数？”以及关于那些函数可能传递给有漏洞函数的数据性质的其他问题。在回溯潜在的调用链以找到可以影响以正确利用你发现的溢出的问题时，这种推理必须继续。
- en: In another case, consider a binary that contains a large number of ASCII strings,
    at least one of which you find suspicious, such as “Executing Denial of Service
    attack!” Does the presence of this string indicate that the binary actually performs
    a Denial of Service attack? No, it simply indicates that the binary happens to
    contain that particular ASCII sequence. You might infer that the message is displayed
    somehow just prior to launching an attack; however, you need to find the related
    code in order to verify your suspicions. Here the answer to the question “Where
    is this string referenced?” would help you to quickly track down the program location(s)
    that make use of the string. From there, perhaps it can assist you in locating
    any actual Denial of Service attack code.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种情况下，考虑一个包含大量ASCII字符串的二进制文件，其中至少有一个字符串让你感到可疑，例如“执行拒绝服务攻击！”这个字符串的存在是否表明该二进制文件实际上执行了拒绝服务攻击？不，它仅仅表明该二进制文件恰好包含那个特定的ASCII序列。你可能推断出，在发起攻击之前，该消息以某种方式显示出来；然而，你需要找到相关的代码来验证你的怀疑。在这里，关于“这个字符串在哪里被引用？”的问题将帮助你快速追踪使用该字符串的程序位置。从那里，也许它能帮助你定位任何实际的拒绝服务攻击代码。
- en: IDA helps to answer these types of questions through its extensive cross-referencing
    features. IDA provides a number of mechanisms for displaying and accessing cross-reference
    data, including graph-generation capabilities that provide a highly visual representation
    of the relationships between code and data. In this chapter we discuss the types
    of cross-reference information that IDA makes available, the tools for accessing
    cross-reference data, and how to interpret that data.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 通过其广泛的交叉引用功能帮助回答这些类型的问题。IDA 提供了多种机制来显示和访问交叉引用数据，包括图形生成功能，它提供了代码与数据之间关系的直观表示。在本章中，我们将讨论
    IDA 提供的交叉引用信息类型、访问交叉引用数据的工具以及如何解释这些数据。
- en: Cross-References
  id: totrans-963
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉引用
- en: We begin our discussion by noting that cross-references within IDA are often
    referred to simply as *xrefs*. Within this text, we will use *xref* only where
    it is used to refer to the content of an IDA menu item or dialog. In all other
    cases we will stick to the term *cross-reference*.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指出，IDA 中的交叉引用通常简单地称为 *xrefs*。在本文本中，我们仅在它用于指代 IDA 菜单项或对话框的内容时使用 *xref*。在其他所有情况下，我们将坚持使用术语
    *交叉引用*。
- en: 'There are two basic categories of cross-references in IDA: code cross-references
    and data cross-references. Within each category, we will detail several different
    types of cross-references. Associated with each cross-reference is the notion
    of a direction. All cross-references are made from one address to another address.
    The *from* and *to* addresses may be either code or data addresses. If you are
    familiar with graph theory, you may choose to think of addresses as *nodes* in
    a directed graph and cross-references as the edges in that graph. [Figure 9-1](ch09.html#basic_graph_components
    "Figure 9-1. Basic graph components") provides a quick refresher on graph terminology.
    In this simple graph, three nodes ![](httpatomoreillycomsourcenostarchimages854061.png)
    are connected by two directed edges ![](httpatomoreillycomsourcenostarchimages854063.png).'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA 中，交叉引用分为两大类：代码交叉引用和数据交叉引用。在每个类别中，我们将详细说明几种不同类型的交叉引用。每个交叉引用都与方向的概念相关联。所有交叉引用都是从地址到地址的。*从*
    和 *到* 地址可以是代码地址或数据地址。如果你熟悉图论，你可以选择将地址视为有向图中的 *节点*，交叉引用为该图中的 *边*。[图 9-1](ch09.html#basic_graph_components
    "图 9-1. 基本图组件") 提供了关于图术语的快速复习。在这个简单的图中，三个节点 ![节点](httpatomoreillycomsourcenostarchimages854061.png)
    通过两条有向边 ![边](httpatomoreillycomsourcenostarchimages854063.png) 连接。
- en: '![Basic graph components](httpatomoreillycomsourcenostarchimages854197.png)'
  id: totrans-966
  prefs: []
  type: TYPE_IMG
  zh: '![基本图组件](httpatomoreillycomsourcenostarchimages854197.png)'
- en: Figure 9-1. Basic graph components
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1. 基本图组件
- en: Note that nodes may also be referred to as *vertices*. Directed edges are drawn
    using arrows to indicate the allowed direction of travel across the edge. In [Figure 9-1](ch09.html#basic_graph_components
    "Figure 9-1. Basic graph components"), it is possible to travel from the upper
    node to either of the lower nodes, but it is not possible to travel from either
    of the lower nodes to the upper node.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，节点也可以被称为 *顶点*。有向边使用箭头绘制，以指示允许穿越边的方向。在 [图 9-1](ch09.html#basic_graph_components
    "图 9-1. 基本图组件") 中，可以从上节点到下节点中的任何一个节点进行旅行，但不可能从下节点中的任何一个节点到上节点进行旅行。
- en: Code cross-references are a very important concept, as they facilitate IDA’s
    generation of *control flow graphs* and *function call graphs*, each of which
    we discuss later in the chapter.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 代码交叉引用是一个非常重要的概念，因为它们有助于 IDA 生成 *控制流图* 和 *函数调用图*，这些内容我们将在本章后面进行讨论。
- en: Before we dive into the details of cross-references, it is useful to understand
    how IDA displays cross-reference information in a disassembly listing. [Figure 9-2](ch09.html#a_basic_cross-reference
    "Figure 9-2. A basic cross-reference") shows the header line for a disassembled
    function (`sub_401000`) containing a cross-reference as a regular comment (right
    side of the figure).
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入交叉引用的细节之前，了解 IDA 在反汇编列表中如何显示交叉引用信息是有用的。[图 9-2](ch09.html#a_basic_cross-reference
    "图 9-2. 基本交叉引用") 显示了包含交叉引用作为常规注释（图右侧）的反汇编函数（`sub_401000`）的标题行。
- en: '![A basic cross-reference](httpatomoreillycomsourcenostarchimages854199.png)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![基本交叉引用](httpatomoreillycomsourcenostarchimages854199.png)'
- en: Figure 9-2. A basic cross-reference
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2. 基本交叉引用
- en: The text `CODE XREF` indicates that this is a code cross-reference rather than
    a data cross-reference (`DATA XREF`). An address follows, `_main+2A` in this case,
    indicating the address from which the cross-reference originates. Note that this
    is a more descriptive form of address than `.text:0040154A`, for example. While
    both forms represent the same program location, the format used in the cross-reference
    offers the additional information that the cross-reference is being made from
    within the function named `_main`, specifically 0x2A (42) bytes into the `_main`
    function. An up or down arrow will always follow the address, indicating the relative
    direction to the referencing location. In [Figure 9-2](ch09.html#a_basic_cross-reference
    "Figure 9-2. A basic cross-reference"), the down arrow indicates that `_main+2A`
    lies at a higher address than `sub_401000`, and thus you would need to scroll
    down to reach it. Similarly, an up arrow indicates that a referencing location
    lies at a lower memory address, requiring that you scroll up to reach it. Finally,
    every cross-reference comment contains a single-character suffix to identify the
    type of cross-reference that is being made. Each suffix is described later as
    we detail all of IDA’s cross-reference types.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 文本 `CODE XREF` 表示这是一个代码交叉引用，而不是数据交叉引用 (`DATA XREF`)。后面跟着一个地址，例如 `_main+2A`，表示交叉引用的起始地址。请注意，这比例如
    `.text:0040154A` 这样的地址形式更具描述性。虽然这两种形式表示的是相同的程序位置，但交叉引用中使用的格式提供了额外的信息，即交叉引用是从名为
    `_main` 的函数内部进行的，具体在 `_main` 函数的 0x2A（42）字节处。地址后面总是跟着一个上箭头或下箭头，表示相对于引用位置的方向。在
    [图 9-2](ch09.html#a_basic_cross-reference "图 9-2. 基本交叉引用") 中，下箭头表示 `_main+2A`
    的地址高于 `sub_401000`，因此你需要向下滚动才能到达它。同样，上箭头表示引用位置位于较低的内存地址，需要向上滚动才能到达它。最后，每个交叉引用注释都包含一个单字符后缀，用于标识正在进行的交叉引用类型。每个后缀将在我们详细说明
    IDA 的所有交叉引用类型时进行描述。
- en: Code Cross-References
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码交叉引用
- en: 'A code cross-reference is used to indicate that an instruction transfers or
    may transfer control to another instruction. The manner in which instructions
    transfer control is referred to as a *flow* within IDA. IDA distinguishes among
    three basic flow types: *ordinary*, *jump*, and *call*. Jump and call flows are
    further divided according to whether the target address is a near or far address.
    Far addresses are encountered only in binaries that make use of segmented addresses.
    In the discussion that follows, we make use of the disassembled version of the
    following program:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 代码交叉引用用于指示指令将控制权转移到另一条指令或可能转移到另一条指令。指令转移控制的方式在 IDA 中被称为 *流程*。IDA 区分三种基本流程类型：*普通*、*跳转*和*调用*。跳转和调用流程根据目标地址是近地址还是远地址进一步细分。远地址仅在使用分段地址的二进制文件中遇到。在下面的讨论中，我们将使用以下程序的反汇编版本：
- en: '[PRE81]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The program contains operations that will exercise all of IDA’s cross-referencing
    features, as noted in the comment text.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含将测试 IDA 所有交叉引用功能的操作，如注释文本所述。
- en: 'An *ordinary flow* is the simplest flow type, and it represents sequential
    flow from one instruction to another. This is the default execution flow for all
    nonbranching instructions such as `ADD`. There are no special display indicators
    for ordinary flows other than the order in which instructions are listed in the
    disassembly. If instruction A has an ordinary flow to instruction B, then instruction
    B will immediately follow instruction A in the disassembly listing. In the following
    listing, every instruction other than ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) has an associated ordinary
    flow to its immediate successor:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '*普通流程* 是最简单的流程类型，它表示从一条指令到另一条指令的顺序流程。这是所有非分支指令（如 `ADD`）的默认执行流程。除了指令在反汇编中的顺序外，普通流程没有特殊的显示指示符。如果指令
    A 有到指令 B 的普通流程，那么指令 B 将立即跟在指令 A 的反汇编列表中。在下面的列表中，除了 ![](httpatomoreillycomsourcenostarchimages854061.png)
    和 ![](httpatomoreillycomsourcenostarchimages854063.png) 之外的所有指令都有一个与其直接后继指令关联的普通流程：'
- en: Example 9-1. Cross-reference sources and targets
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1. 交叉引用源和目标
- en: '[PRE82]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Instructions used to invoke functions, such as the x86 `call` instructions
    at ![](httpatomoreillycomsourcenostarchimages854093.png), are assigned a *call
    flow*, indicating transfer of control to the target function. In most cases, an
    ordinary flow is also assigned to `call` instructions, as most functions return
    to the location that follows the `call`. If IDA believes that a function does
    not return (as determined during the analysis phase), then calls to that function
    will not have an ordinary flow assigned. Call flows are noted by the display of
    cross-references at the target function (the destination address of the flow).
    The resulting disassembly of the `callflow` function is shown here:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调用函数的指令，如![http://atomoreilly.com/source/nostarch/images/854093.png](http://atomoreilly.com/source/nostarch/images/854093.png)处的x86
    `call`指令，分配了一个*调用流程*，表示控制流转移到目标函数。在大多数情况下，也会为`call`指令分配普通流程，因为大多数函数会返回到`call`之后的地址。如果IDA认为函数不会返回（在分析阶段确定），则不会为该函数的调用分配普通流程。调用流程通过在目标函数（流程的目的地址）处显示交叉引用来标记。此处显示了`callflow`函数的相应反汇编代码：
- en: '[PRE83]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this example, two cross-references are displayed at the address of `callflow`
    to indicate that the function is called twice. The address displayed in the cross-references
    is displayed as an offset into the calling function unless the calling address
    has an associated name, in which case the name is used. Both forms of addresses
    are used in the cross-references shown here. Cross-references resulting from function
    calls are distinguished through use of the `p` suffix (think *P* for *Procedure*).
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，在`callflow`地址处显示了两个交叉引用，以指示该函数被调用两次。交叉引用中显示的地址显示为调用函数中的偏移量，除非调用地址有一个关联的名称，在这种情况下使用该名称。这两种地址形式都用于此处显示的交叉引用中。通过使用`p`后缀（想想*P*代表*Procedure*）来区分函数调用产生的交叉引用。
- en: A *jump flow* is assigned to each unconditional and conditional branch instruction.
    Conditional branches are also assigned ordinary flows to account for control flow
    when the branch is not taken. Unconditional branches have no associated ordinary
    flow because the branch is always taken in such cases. The dashed line break at
    ![](httpatomoreillycomsourcenostarchimages854099.png) is a display device used
    to indicate that an ordinary flow does not exist between two adjacent instructions.
    Jump flows are associated with jump-style cross-references displayed at the target
    of the jump, as shown at ![](httpatomoreillycomsourcenostarchimages854101.png).
    As with call-style cross-references, jump cross-references display the address
    of the referring location (the source of the jump). Jump cross-references are
    distinguished by the use of a `j` suffix (think *J* for *Jump*).
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 每个无条件和有条件分支指令都分配了一个*跳转流程*。有条件分支也分配了普通流程，以考虑分支不被采取时的控制流。无条件分支没有关联的普通流程，因为在这种情况下分支总是被采取。在![http://atomoreilly.com/source/nostarch/images/854099.png](http://atomoreilly.com/source/nostarch/images/854099.png)处的虚线线断是用于指示两个相邻指令之间不存在普通流程的显示设备。跳转流程与在跳转目标处显示的跳转样式交叉引用相关联，如图![http://atomoreilly.com/source/nostarch/images/854101.png](http://atomoreilly.com/source/nostarch/images/854101.png)所示。与调用样式交叉引用一样，跳转交叉引用显示引用位置（跳转的源）的地址。跳转交叉引用通过使用`j`后缀（想想*J*代表*Jump*）来区分。
- en: Data Cross-References
  id: totrans-985
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据交叉引用
- en: Data cross-references are used to track the manner in which data is accessed
    within a binary. Data cross-references can be associated with any byte in an IDA
    database that is associated with a virtual address (in other words, data cross-references
    are never associated with stack variables). The three most commonly encountered
    types of data cross-references are used to indicate when a location is being read,
    when a location is being written, and when the address of a location is being
    taken. The global variables associated with the previous example program are shown
    here, as they provide several examples of data cross-references.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 数据交叉引用用于跟踪数据在二进制文件中的访问方式。数据交叉引用可以与IDA数据库中与虚拟地址关联的任何字节相关联（换句话说，数据交叉引用永远不会与栈变量相关联）。最常遇到的三种数据交叉引用类型用于指示何时读取位置、何时写入位置以及何时获取位置地址。此处显示了与先前示例程序相关联的全局变量，因为它们提供了多个数据交叉引用的示例。
- en: '[PRE84]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: A *read cross-reference* is used to indicate that the contents of a memory location
    are being accessed. Read cross-references can originate only from an instruction
    address but may refer to any program location. The global variable `read_it` is
    read at locations marked ![](httpatomoreillycomsourcenostarchimages854103.png)
    in [Example 9-1](ch09.html#cross-reference_sources_and_targets "Example 9-1. Cross-reference
    sources and targets"). The associated cross-reference comments shown in this listing
    indicate exactly which locations in `main` are referencing `read_it` and are recognizable
    as read cross-references based on the use of the `r` suffix. The first read performed
    on `read_it` is a 32-bit read into the ECX register, which leads IDA to format
    `read_it` as a dword (`dd`). In general IDA takes as many cues as it possibly
    can in order to determine the size and/or type of variables based on how they
    are accessed and how they are used as parameters to functions.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '*读取交叉引用* 用于指示正在访问内存位置的 内容。读取交叉引用只能从指令地址起源，但可以引用任何程序位置。全局变量 `read_it` 在 [示例
    9-1](ch09.html#cross-reference_sources_and_targets "示例 9-1. 交叉引用来源和目标") 中标记的位置
    ![](httpatomoreillycomsourcenostarchimages854103.png) 被读取。此列表中显示的关联交叉引用注释确切地表明了
    `main` 中哪些位置引用了 `read_it`，并且根据使用 `r` 后缀可以识别为读取交叉引用。对 `read_it` 执行的第一个读取操作是将 32
    位读取到 ECX 寄存器中，这使得 IDA 将 `read_it` 格式化为 dword (`dd`)。一般来说，IDA 尽可能多地获取线索，以确定变量的大小和/或类型，这些线索基于它们如何被访问以及它们如何作为函数的参数使用。'
- en: The global variable `write_it` is referenced at the locations marked ![](httpatomoreillycomsourcenostarchimages854133.png)
    in [Example 9-1](ch09.html#cross-reference_sources_and_targets "Example 9-1. Cross-reference
    sources and targets"). Associated *write cross-references* are generated and displayed
    as comments for the `write_it` variable, indicating the program locations that
    modify the contents of the variable. Write cross-references utilize the `w` suffix.
    Here again, IDA has determined the size of the variable based on the fact that
    the 32-bit EAX register is copied into `write_it`. Note that the list of cross-references
    displayed at `write_it` terminates with an ellipsis (![](httpatomoreillycomsourcenostarchimages854201.png)
    above), indicating that the number of cross-references to `write_it` exceeds the
    current display limit for cross-references. This limit can be modified through
    the Number of displayed xrefs setting on the Cross-references tab in the Options
    ▸ General dialog. As with read cross-references, write cross-references can originate
    only from a program instruction but may reference any program location. Generally
    speaking, a write cross-reference that targets a program instruction byte is indicative
    of self-modifying code, which is usually considered bad form and is frequently
    encountered in the de-obfuscation routines used in malware.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `write_it` 在 [示例 9-1](ch09.html#cross-reference_sources_and_targets "示例
    9-1. 交叉引用来源和目标") 中标记的位置 ![](httpatomoreillycomsourcenostarchimages854133.png)
    被引用。相关的 *写入交叉引用* 被生成并显示为 `write_it` 变量的注释，指示修改变量内容的程序位置。写入交叉引用使用 `w` 后缀。同样，IDA
    根据事实，32 位 EAX 寄存器被复制到 `write_it` 中，确定了变量的大小。请注意，显示在 `write_it` 上的交叉引用列表以省略号 (![](httpatomoreillycomsourcenostarchimages854201.png)
    上方) 结尾，表示对 `write_it` 的交叉引用数量超过了当前显示的交叉引用限制。此限制可以通过在选项 ▸ 通用对话框的交叉引用选项卡上的“显示的 xrefs
    数量”设置中修改。与读取交叉引用一样，写入交叉引用只能从程序指令起源，但可以引用任何程序位置。一般来说，针对程序指令字节的写入交叉引用表明是自修改代码，这通常被认为是不良的编程习惯，并且在恶意软件中使用的去混淆例程中经常遇到。
- en: The third type of data cross-reference, an *offset cross-reference*, indicates
    that the address of a location is being used (rather than the content of the location).
    The address of global variable `ref_it` is taken at location ![](httpatomoreillycomsourcenostarchimages854135.png)
    in [Example 9-1](ch09.html#cross-reference_sources_and_targets "Example 9-1. Cross-reference
    sources and targets"), resulting in the offset cross-reference comment at `ref_it`
    in the previous listing (suffix `o`). Offset cross-references are commonly the
    result of pointer operations either in code or in data. Array access operations,
    for example, are typically implemented by adding an offset to the starting address
    of the array. As a result, the first address in most global arrays can often be
    recognized by the presence of an offset cross-reference. For this reason, most
    string data (strings being arrays of characters in C/C++) is the target of offset
    cross-references.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种数据交叉引用类型，即 *偏移量交叉引用*，表明正在使用位置的地址（而不是位置的 内容）。全局变量 `ref_it` 的地址在 [示例 9-1](ch09.html#cross-reference_sources_and_targets
    "示例 9-1。交叉引用的源和目标") 中的位置 ![](httpatomoreillycomsourcenostarchimages854135.png)
    被取用，导致在前面列表中的 `ref_it` 处出现偏移量交叉引用注释（后缀 `o`）。偏移量交叉引用通常是代码或数据中指针操作的结果。例如，数组访问操作通常通过向数组的起始地址添加偏移量来实现。因此，大多数全局数组中的第一个地址通常可以通过偏移量交叉引用的存在来识别。因此，大多数字符串数据（在
    C/C++ 中字符串是字符数组）是偏移量交叉引用的目标。
- en: 'Unlike read and write cross-references, which can originate only from instruction
    locations, offset cross-references can originate from either instruction locations
    or data locations. An example of an offset that can originate from a program’s
    data section is any table of pointers (such as a vtable) that results in the generation
    of an offset cross-reference from each location within the table to the location
    being pointed to by those locations. You can see this if you examine the vtable
    for class `SubClass` from [Chapter 8](ch08.html "Chapter 8. Datatypes and Data
    Structures"), whose disassembly is shown here:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 与只能从指令位置起源的读取和写入交叉引用不同，偏移量交叉引用可以来自指令位置或数据位置。一个可以从程序的数据部分起源的偏移量示例是任何指针表（如虚表），它从表中的每个位置生成到那些位置所指向位置的偏移量交叉引用。如果你检查来自
    [第 8 章](ch08.html "第 8 章。数据类型和数据结构") 的 `SubClass` 类的虚表，其反汇编代码如下所示，你可以看到这一点：
- en: '[PRE85]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here you see that the address of the vtable is used in the function `SubClass::SubClass(void)`,
    which is the class constructor. The header lines for function `SubClass::vfunc3(void)`,
    shown here, show the offset cross-reference that links the function to a vtable.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在函数 `SubClass::SubClass(void)` 中使用了虚表地址，该函数是类的构造函数。函数 `SubClass::vfunc3(void)`
    的头文件，如这里所示，显示了将函数与虚表链接的偏移量交叉引用。
- en: '[PRE86]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This example demonstrates one of the characteristics of C++ virtual functions
    that becomes quite obvious when combined with offset cross-references, namely
    that C++ virtual functions are never called directly and should never be the target
    of a call cross-reference. Instead, all C++ virtual functions should be referred
    to by at least one vtable entry and should always be the target of at least one
    offset cross-reference. Remember that overriding a virtual function is not mandatory.
    Therefore, a virtual function can appear in more than one vtable, as discussed
    in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures"). Backtracking
    offset cross-references is one technique for easily locating C++ vtables in a
    program’s data section.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了 C++ 虚拟函数的一个特性，当与偏移量交叉引用结合时变得非常明显，即 C++ 虚拟函数永远不会直接调用，也不应该是调用交叉引用的目标。相反，所有
    C++ 虚拟函数至少应该通过一个虚表条目来引用，并且始终应该是至少一个偏移量交叉引用的目标。记住，重写虚拟函数不是强制性的。因此，虚拟函数可以出现在多个虚表中，如
    [第 8 章](ch08.html "第 8 章。数据类型和数据结构") 中讨论的那样。回溯偏移量交叉引用是轻松定位程序数据部分中 C++ 虚表的技巧之一。
- en: Cross-Reference Lists
  id: totrans-996
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉引用列表
- en: With an understanding of what cross-references are, we can now discuss the manner
    in which you may access all of this data within IDA. As mentioned previously,
    the number of cross-reference comments that can be displayed at a given location
    is limited by a configuration setting that defaults to 2\. As long as the number
    of cross-references to a location does not exceed this limit, then working with
    those cross-references is fairly straightforward. Mousing over the cross-reference
    text displays the disassembly of the source region in a tool tip–style display,
    while double-clicking the cross-reference address jumps the disassembly window
    to the source of the cross-reference.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了什么是交叉引用之后，我们现在可以讨论如何在IDA中访问所有这些数据的方式。如前所述，在特定位置可以显示的交叉引用注释数量受配置设置的限制，默认值为2。只要对位置的交叉引用数量不超过此限制，那么处理这些交叉引用就相当直接。将鼠标悬停在交叉引用文本上会在工具提示样式中显示源区域的反汇编，而双击交叉引用地址会将反汇编窗口跳转到交叉引用的源。
- en: There are two methods for viewing the complete list of cross-references to a
    location. The first method is to open a cross-references subview associated with
    a specific address. By positioning the cursor on an address that is the target
    of one or more cross-references and selecting View ▸ Open Subviews ▸ Cross-References,
    you can open the complete list of cross-references to a given location, as shown
    in [Figure 9-3](ch09.html#cross-reference_display_window "Figure 9-3. Cross-reference
    display window"), which shows the complete list of cross-references to variable
    `write_it`.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位置所有交叉引用的完整列表有两种方法。第一种方法是打开与特定地址关联的交叉引用子视图。通过将光标定位在一个是或多个交叉引用的目标地址上，并选择“查看”▸“打开子视图”▸“交叉引用”，你可以打开给定位置的完整交叉引用列表，如图9-3所示，它显示了变量`write_it`的完整交叉引用列表。
- en: '![Cross-reference display window](httpatomoreillycomsourcenostarchimages854203.png.jpg)'
  id: totrans-999
  prefs: []
  type: TYPE_IMG
  zh: '![交叉引用显示窗口](httpatomoreillycomsourcenostarchimages854203.png.jpg)'
- en: Figure 9-3. Cross-reference display window
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3. 交叉引用显示窗口
- en: The columns of the window indicate the direction (Up or Down) to the source
    of the cross-reference, the type of cross-reference (using the type suffixes discussed
    previously), the source address of the cross-reference, and the corresponding
    disassembled text at the source address, including any comments that may exist
    at the source address. As with other windows that display lists of addresses,
    double-clicking any entry repositions the disassembly display to the corresponding
    source address. Once opened, the cross-reference display window remains open and
    accessible via a title tab displayed along with every other open subview’s title
    tab above the disassembly area.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的列表示交叉引用源的方向（向上或向下），交叉引用的类型（使用之前讨论的类型后缀），交叉引用的源地址，以及源地址处的相应反汇编文本，包括可能存在的任何注释。与其他显示地址列表的窗口一样，双击任何条目会将反汇编显示重新定位到相应的源地址。一旦打开，交叉引用显示窗口将保持打开状态，并且可以通过显示在反汇编区域上方每个其他打开子视图标题标签旁边的标题标签访问。
- en: The second way to access a list of cross-references is to highlight a name that
    you are interested in learning about and choose Jump ▸ Jump to xref (hotkey ctrl-X)
    to open a dialog that lists every location that references the selected symbol.
    The resulting dialog, shown in [Figure 9-4](ch09.html#jump_to_cross-reference_dialog
    "Figure 9-4. Jump to cross-reference dialog"), is nearly identical in appearance
    to the cross-reference subview shown in [Figure 9-3](ch09.html#cross-reference_display_window
    "Figure 9-3. Cross-reference display window"). In this case, the dialog was activated
    using the ctrl-X hotkey with the first instance of `write_it` (`.text:0040102B`)
    selected.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 访问交叉引用列表的第二种方式是突出显示你感兴趣了解的名称，并选择“跳转”▸“跳转到xref”（快捷键ctrl-X）以打开一个对话框，该对话框列出所有引用所选符号的位置。如图9-4所示的对话框在外观上几乎与图9-3中显示的交叉引用子视图相同。在这种情况下，对话框是通过使用ctrl-X快捷键并选择`write_it`（`.text:0040102B`）的第一个实例来激活的。
- en: '![Jump to cross-reference dialog](httpatomoreillycomsourcenostarchimages854205.png.jpg)'
  id: totrans-1003
  prefs: []
  type: TYPE_IMG
  zh: '![跳转到交叉引用对话框](httpatomoreillycomsourcenostarchimages854205.png.jpg)'
- en: Figure 9-4. Jump to cross-reference dialog
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4. 跳转到交叉引用对话框
- en: The primary difference in the two displays is behavioral. Being a modal dialog,^([[52](#ftn.CHP-9-FN-1)])
    the display in [Figure 9-4](ch09.html#jump_to_cross-reference_dialog "Figure 9-4. Jump
    to cross-reference dialog") has buttons to interact with and terminate the dialog.
    The primary purpose of this dialog is to select a referencing location and jump
    to it. Double-clicking one of the listed locations dismisses the dialog and repositions
    the disassembly window at the selected location. The second difference between
    the dialog and the cross-reference subview is that the former can be opened using
    a hotkey or context-sensitive menu from any instance of a symbol, while the latter
    can be opened only when you position the cursor on an address that is the target
    of a cross-reference and choose View ▸ Open Subviews ▸ Cross-References. Another
    way of thinking about it is that the dialog can be opened at the source of any
    cross-reference, while the subview can be opened only at the destination of the
    cross-reference.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个显示的主要区别在于行为。作为一个模态对话框，^([[52](#ftn.CHP-9-FN-1)]) 图9-4 [Figure 9-4](ch09.html#jump_to_cross-reference_dialog
    "Figure 9-4. 跳转到交叉引用对话框")中的显示有按钮可以与之交互并终止对话框。此对话框的主要目的是选择引用位置并跳转到该位置。双击列表中的任何一个位置将关闭对话框并将反汇编窗口重新定位到所选位置。对话框与交叉引用子视图之间的第二个区别是，前者可以通过热键或上下文相关菜单从任何符号实例打开，而后者只能在将光标定位在交叉引用的目标地址上并选择视图
    ▸ 打开子视图 ▸ 交叉引用时打开。另一种思考方式是，对话框可以在任何交叉引用的源处打开，而子视图只能在交叉引用的目的地打开。
- en: An example of the usefulness of cross-reference lists might be to rapidly locate
    every location from which a particular function is called. Many people consider
    the use of the C `strcpy`^([[53](#ftn.CHP-9-FN-2)]) function to be dangerous.
    Using cross-references, locating every call to `strcpy` is as simple as finding
    any one call to `strcpy`, using the ctrl-X hotkey to bring up the cross-reference
    dialog, and working your way through every call cross-reference. If you don’t
    want to take the time to find `strcpy` used somewhere in the binary, you can even
    get away with adding a comment with the text *strcpy* in it and activating the
    cross-reference dialog using the comment.^([[54](#ftn.CHP-9-FN-3)])
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用列表的有用性之一可能是快速定位调用特定函数的所有位置。许多人认为使用C语言的`strcpy`^([[53](#ftn.CHP-9-FN-2)])函数是危险的。使用交叉引用，找到对`strcpy`的所有调用就像找到对`strcpy`的任何一次调用一样简单，使用ctrl-X热键调出交叉引用对话框，然后逐个处理每个调用交叉引用。如果您不想花时间在二进制文件中找到使用`strcpy`的位置，甚至可以添加包含文本*strcpy*的注释并激活交叉引用对话框。^([[54](#ftn.CHP-9-FN-3)])
- en: Function Calls
  id: totrans-1007
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数调用
- en: A specialized cross-reference listing dealing exclusively with function calls
    is available by choosing View ▸ Open Subviews ▸ Function Calls. [Figure 9-5](ch09.html#function_calls_window
    "Figure 9-5. Function calls window") shows the resulting dialog, which lists all
    locations that call the current function (as defined by the cursor location at
    the time the view is opened) in the upper half of the window and all calls made
    by the current function in the lower half of the window.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择视图 ▸ 打开子视图 ▸ 函数调用，可以获得一个专门处理函数调用的交叉引用列表。图9-5 [Figure 9-5](ch09.html#function_calls_window
    "Figure 9-5. 函数调用窗口")显示了生成的对话框，该对话框在上半部分窗口中列出调用当前函数（在打开视图时由光标位置定义）的所有位置，在下半部分窗口中列出当前函数的所有调用。
- en: '![Function calls window](httpatomoreillycomsourcenostarchimages854207.png)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![函数调用窗口](httpatomoreillycomsourcenostarchimages854207.png)'
- en: Figure 9-5. Function calls window
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5. 函数调用窗口
- en: Here again, each listed cross-reference can be used to quickly reposition the
    disassembly listing to the corresponding cross-reference location. Restricting
    ourselves to considering function call cross-references allows us to think about
    more abstract relationships than simple mappings from one address to another and
    instead consider how functions relate to one another. In the next section, we
    show how IDA takes advantage of this by providing several types of graphs, all
    designed to assist you in interpreting a binary.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个列出的交叉引用都可以用来快速将反汇编列表重新定位到相应的交叉引用位置。仅考虑函数调用交叉引用，我们可以考虑比从地址到地址的简单映射更抽象的关系，并考虑函数之间的关系。在下一节中，我们将展示IDA如何利用这一点，通过提供几种类型的图表来帮助您解释二进制文件。
- en: '* * *'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[52](#CHP-9-FN-1)]) A modal dialog must be closed before you can continue
    normal interaction with the underlying application. Modeless dialogs can remain
    open while you continue normal interaction with the application.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[52](#CHP-9-FN-1)]) 在您继续与底层应用程序的正常交互之前，必须关闭模态对话框。无模式对话框可以在您继续与应用程序的正常交互时保持打开状态。
- en: ^([[53](#CHP-9-FN-2)]) The `C strcpy` function copies a source array of characters,
    up to and including the associated null termination character, to a destination
    array, with no checks whatsoever that the destination array is large enough to
    hold all of the characters from the source.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[53](#CHP-9-FN-2)]) `C strcpy` 函数将字符源数组（包括相关的空终止字符）复制到目标数组，而不会检查目标数组是否足够大以容纳所有来自源数组的字符。
- en: ^([[54](#CHP-9-FN-3)]) When a symbol name appears in a comment, IDA treats that
    symbol just as if it was an operand in a disassembled instruction. Double-clicking
    the symbol repositions the disassembly window, and the right-click context-sensitive
    menu becomes available.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[54](#CHP-9-FN-3)]) 当符号名称出现在注释中时，IDA 将该符号视为反汇编指令中的操作数。双击符号将重新定位反汇编窗口，并可用右键点击的上下文相关菜单。
- en: IDA Graphing
  id: totrans-1016
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA 图表功能
- en: 'Because cross-references relate one address to another, they are a natural
    place to begin if we want to make graphs of our binaries. By restricting ourselves
    to specific types of cross-references, we can derive a number of useful graphs
    for analyzing our binaries. For starters, cross-references serve as the edges
    (the lines that connect points) in our graphs. Depending on the type of graph
    we wish to generate, individual nodes (the points in the graph) can be individual
    instructions, groups of instructions called *basic blocks*, or entire functions.
    IDA has two distinct graphing capabilities: an external graphing capability utilizing
    a bundled graphing application and an integrated, interactive graphing capability.
    Both of these graphing capabilities are covered in the following sections.'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交叉引用关联一个地址到另一个地址，如果我们想为我们的二进制文件制作图表，它们是一个自然的选择点。通过限制自己到特定的交叉引用类型，我们可以推导出许多有用的图表来分析我们的二进制文件。首先，交叉引用作为我们图表中的边（连接点的线条）。根据我们希望生成的图表类型，单独的节点（图表中的点）可以是单个指令、称为
    *基本块* 的指令组，或整个函数。IDA有两个不同的图表功能：一个是利用捆绑的图表应用程序的外部图表功能，另一个是集成、交互式的图表功能。这两个图表功能将在以下章节中介绍。
- en: IDA External (Third-Party) Graphing
  id: totrans-1018
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA 外部（第三方）图表
- en: IDA’s external graphing capability utilizes third-party graphing applications
    to display IDA-generated graph files. For Windows versions prior to 6.1, IDA ships
    with a bundled graphing application named `wingraph32`.^([[55](#ftn.CHP-9-FN-4)])
    For IDA 6.0, non-Windows versions of IDA are configured to use the dotty^([[56](#ftn.CHP-9-FN-5)])
    graph viewer by default. Beginning with IDA 6.1, all versions of IDA ship with
    and are configured to use the `qwingraph`^([[57](#ftn.CHP-9-FN-6)]) graph viewer,
    which is a cross-platform Qt port of `wingraph32`. While the dotty configuration
    options remain visible for Linux users, they are commented out by default. The
    graph viewer used by IDA may be configured by editing the GRAPH_VISUALIZER variable
    in *<IDADIR>/cfg/ida.cfg*.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的外部图表功能利用第三方图表应用程序来显示 IDA 生成的图表文件。对于 6.1 版本之前的 Windows 版本，IDA 随附一个名为 `wingraph32`
    的捆绑图表应用程序。^([[55](#ftn.CHP-9-FN-4)]) 对于 IDA 6.0 版本，非 Windows 版本的 IDA 默认配置为使用 dotty^([[56](#ftn.CHP-9-FN-5)))
    图表查看器。从 IDA 6.1 版本开始，所有版本的 IDA 都随附并配置为使用 `qwingraph`^([[57](#ftn.CHP-9-FN-6)))
    图表查看器，这是一个 `wingraph32` 的跨平台 Qt 版本。虽然 Linux 用户仍然可以看到 dotty 配置选项，但它们默认被注释掉。IDA
    使用的图表查看器可以通过编辑 *<IDADIR>/cfg/ida.cfg* 中的 GRAPH_VISUALIZER 变量来配置。
- en: Whenever an external-style graph is requested, the source for the graph is generated
    and saved to a temporary file; then the designated third-party graph viewer is
    launched to display the graph. IDA supports two graph specification languages,
    Graph Description Language^([[58](#ftn.CHP-9-FN-7)]) (GDL) and the DOT^([[59](#ftn.CHP-9-FN-8)])
    language utilized by the graphviz^([[60](#ftn.CHP-9-FN-9)]) project. The graph
    specification language used by IDA may be configured by editing the `GRAPH_FORMAT`
    variable in *<IDADIR>/cfg/ida.cfg*. Legal values for this variable are `DOT` and
    `GDL`. You must ensure that the language you specify here is compatible with the
    viewer you have specified in `GRAPH_VISUALIZER`.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 每次请求外部样式图形时，都会生成图形的源并将其保存到临时文件中；然后启动指定的第三方图形查看器以显示图形。IDA 支持两种图形规范语言，即图描述语言^([[58](#ftn.CHP-9-FN-7)）(GDL)和由
    graphviz^([[59](#ftn.CHP-9-FN-8)）项目使用的 DOT^([[60](#ftn.CHP-9-FN-9)）语言。IDA 使用的图形规范语言可以通过编辑
    *<IDADIR>/cfg/ida.cfg* 中的 `GRAPH_FORMAT` 变量来配置。此变量的有效值是 `DOT` 和 `GDL`。您必须确保此处指定的语言与您在
    `GRAPH_VISUALIZER` 中指定的查看器兼容。
- en: 'Five types of graphs may be generated from the View ▸ Graphs submenu. Available
    external mode graphs include the following:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从“视图 ▸ 图形”子菜单生成五种类型的图形。可用的外部模式图形包括以下几种：
- en: Function flowchart
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数流程图
- en: Call graph for the entire binary
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个二进制的调用图
- en: Graph of cross-references to a symbol
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号交叉引用的图
- en: Graph of cross-references from a symbol
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从符号到交叉引用的图
- en: Customized cross-reference graph
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制的交叉引用图
- en: For two of these, the flowchart and the call graph, IDA is capable of generating
    and saving GDL (not DOT) files for use independently of IDA. These options may
    be found on the File ▸ Produce file submenu. Saving the specification file for
    other types of graphs may be possible if your configured graph viewer allows you
    to save the currently displayed graph. A number of limitations exist when dealing
    with any external graph. First and foremost is the fact that external graphs are
    not interactive. Manipulation of displayed external graphs is limited by the capabilities
    of your chosen external graph viewer (often only zooming and panning).
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其中的两种，流程图和调用图，IDA 能够生成并保存 GDL（非 DOT）文件，以便独立于 IDA 使用。这些选项可以在“文件 ▸ 生成文件”子菜单中找到。如果您的配置图形查看器允许您保存当前显示的图形，则可能可以保存其他类型图形的规范文件。处理任何外部图形时都存在一些限制。首先，外部图形不是交互式的。显示的外部图形的操纵受您选择的图形查看器功能限制（通常只有缩放和平移）。
- en: BASIC BLOCKS
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块
- en: In a computer program, a *basic block* is a grouping of one or more instructions
    with a single entry to the beginning of the block and a single exit from the end
    of the block. In general, other than the last instruction, every instruction within
    a basic block transfers control to exactly one *successor* instruction within
    the block. Similarly, other than the first instruction, every instruction in a
    basic block receives control from exactly one *predecessor* instruction within
    the block. For the purposes of basic block determination, the fact that function
    call instructions transfer control outside the current function is generally ignored
    unless it is known that the function being called fails to return normally. An
    important behavioral characteristic of basic blocks is that once the first instruction
    in a basic block is executed, the remainder of the block is guaranteed to execute
    to completion. This can factor significantly into runtime instrumentation of a
    program, since it is no longer necessary to set a breakpoint on every instruction
    in a program or even single-step the program in order to record which instructions
    have executed. Instead, breakpoints can be set on the first instruction of each
    basic block, and as each breakpoint is hit, every instruction in its associated
    block can be marked as executed. The Process Stalker component of Pedram Amini’s
    PaiMei^([[61](#ftn.CHP-9-FN-10)]) framework performs in exactly this manner.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序中，一个*基本块*是由一个或多个指令组成的集合，这些指令从块的开头有一个单一的入口，从块的末尾有一个单一的出口。一般来说，除了最后一个指令外，基本块内的每个指令都将控制权传递给块内的一个精确的*后继*指令。同样，除了第一个指令外，基本块内的每个指令都从块内的一个精确的*前驱*指令接收控制权。为了确定基本块的目的，通常忽略函数调用指令将控制权转移到当前函数之外的事实，除非已知被调用的函数无法正常返回。基本块的一个重要行为特征是，一旦基本块中的第一条指令被执行，该块剩余的部分将保证执行完成。这可以在程序的运行时仪器中起到重要作用，因为不再需要在程序中的每个指令上设置断点，甚至不需要单步执行程序以记录哪些指令已执行。相反，可以在每个基本块的第一条指令上设置断点，并且每当遇到一个断点时，其相关块中的每个指令都可以标记为已执行。Pedram
    Amini的PaiMei框架的Process Stalker组件正是以这种方式运行的。
- en: External Flowcharts
  id: totrans-1030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部流程图
- en: With the cursor positioned within a function, View ▸ Graphs ▸ Flow Chart (hotkey
    F12) generates and displays an external flowchart. The flowchart display is the
    external graph that most closely resembles IDA’s integrated graph-based disassembly
    view. These are not the flowcharts you may have been taught during an introductory
    programming class. Instead, these graphs might better be named “control flow graphs,”
    as they group a function’s instructions into basic blocks and use edges to indicate
    flow from one block to another.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标位于一个函数内时，选择“视图”▸“图形”▸“流程图”（快捷键F12）可以生成并显示一个外部流程图。流程图显示的是最接近IDA集成图形反汇编视图的外部图形。这些流程图并不是你在入门编程课程中学到的那些。相反，这些图可能更准确地被称为“控制流图”，因为它们将函数的指令分组到基本块中，并使用边来指示从一个块到另一个块的流动。
- en: '[Figure 9-6](ch09s02.html#external_flowchart_graph "Figure 9-6. External flowchart
    graph") shows a portion of the flowchart of a relatively simple function. As you
    can see, external flowcharts offer very little in the way of address information,
    which can make it difficult to correlate the flowchart view to its corresponding
    disassembly listing.'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-6](ch09s02.html#external_flowchart_graph "图9-6. 外部流程图")显示了相对简单函数的流程图的一部分。正如你所看到的，外部流程图在地址信息方面提供得非常少，这可能会使得将流程图视图与其对应的反汇编列表相关联变得困难。'
- en: '![External flowchart graph](httpatomoreillycomsourcenostarchimages854209.png)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![外部流程图](httpatomoreillycomsourcenostarchimages854209.png)'
- en: Figure 9-6. External flowchart graph
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6. 外部流程图
- en: Flowchart graphs are derived by following the ordinary and jump flows for each
    instruction in a function, beginning with the entry point to the function.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图图是通过跟踪函数中每个指令的常规和跳转流动得到的，从函数的入口点开始。
- en: External Call Graphs
  id: totrans-1036
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部调用图
- en: A function call graph is useful for gaining a quick understanding of the hierarchy
    of function calls made within a program. Call graphs are generated by creating
    a graph node for each function and then connecting function nodes based on the
    existence of a call cross-reference from one function to another. The process
    of generating a call graph for a single function can be viewed as a recursive
    descent through all of the functions that are called from the initial function.
    In many cases, it is sufficient to stop descending the call tree once a library
    function is reached, as it is easier to learn how the library function operates
    by reading documentation associated with the library rather than by attempting
    to reverse engineer the compiled version of the function. In fact, in the case
    of a dynamically linked binary it is not possible to descend into library functions,
    since the code for such functions is not present within the dynamically linked
    binary. Statically linked binaries present a different challenge when generating
    graphs. Since statically linked binaries contain all of the code for the libraries
    that have been linked to the program, related function call graphs can become
    extremely large.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用图对于快速了解程序内部函数调用的层次结构非常有用。调用图是通过为每个函数创建一个图节点，然后根据一个函数到另一个函数的调用交叉引用的存在来连接函数节点生成的。为单个函数生成调用图的过程可以看作是通过对从初始函数调用的所有函数进行递归下降来实现的。在许多情况下，一旦达到库函数，就可以停止向下遍历调用树，因为通过阅读与库相关的文档来了解库函数的操作比尝试逆向工程函数的编译版本要容易得多。实际上，在动态链接的二进制文件的情况下，由于这些函数的代码不包含在动态链接的二进制文件中，因此不可能向下遍历库函数。在生成图时，静态链接的二进制文件提出了不同的挑战。由于静态链接的二进制文件包含了已链接到程序的所有库的代码，相关的函数调用图可能会变得非常大。
- en: 'In order to discuss function call graphs, we make use of the following trivial
    program that does nothing other than create a simple hierarchy of function calls:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论函数调用图，我们使用以下简单的程序，该程序除了创建一个简单的函数调用层次结构外，不做任何其他事情：
- en: '[PRE87]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: After compiling a dynamically linked binary using GNU gcc, we can ask IDA to
    generate a function call graph using View ▸ Graphs ▸ Function Calls, which should
    yield a graph similar to that shown in [Figure 9-7](ch09s02.html#external_function_call_graph
    "Figure 9-7. External function call graph"). In this instance we have truncated
    the left side of the graph somewhat in order to offer a bit more detail. The call
    graph associated with the `main` function can be seen within the circled area
    in the figure.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用GNU gcc编译动态链接的二进制文件后，我们可以要求IDA通过“视图”>“图形”>“函数调用”生成函数调用图，这应该会产生与[图9-7](ch09s02.html#external_function_call_graph
    "图9-7. 外部函数调用图")中显示的图相似的图。在这种情况下，我们略微截断了图的左侧，以便提供更多细节。图中的圆形区域显示了与`main`函数相关的调用图。
- en: '![External function call graph](httpatomoreillycomsourcenostarchimages854211.png.jpg)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
  zh: '![外部函数调用图](httpatomoreillycomsourcenostarchimages854211.png.jpg)'
- en: Figure 9-7. External function call graph
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7. 外部函数调用图
- en: Alert readers may notice that the compiler has substituted calls to `puts` and
    `fwrite` for `printf` and `fprintf`, respectively, as they are more efficient
    when printing static strings. Note that IDA utilizes different colors to represent
    different types of nodes in the graph, though the colors are not configurable
    in any way.^([[62](#ftn.CHP-9-FN-11)])
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕的读者可能会注意到，编译器已经将`puts`和`fwrite`的调用分别替换为`printf`和`fprintf`，因为它们在打印静态字符串时更有效。请注意，IDA使用不同的颜色来表示图中不同类型的节点，尽管这些颜色不能以任何方式配置。^([[62](#ftn.CHP-9-FN-11)])
- en: Given the straightforward nature of the previous program listing, why does the
    graph appear to be twice as crowded as it should be? The answer is that the compiler,
    as virtually all compilers do, has inserted wrapper code responsible for library
    initialization and termination as well as for configuring parameters properly
    prior to transferring control to the `main` function.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前一个程序列表的简单性，为什么图看起来比应有的拥挤了两倍？答案是编译器，就像几乎所有编译器一样，已经插入了负责库初始化和终止以及正确配置参数以便将控制权传递给`main`函数的包装代码。
- en: Attempting to graph a statically linked version of the same program results
    in the nasty mess shown in [Figure 9-8](ch09s02.html#function_call_graph_in_a_statically_link
    "Figure 9-8. Function call graph in a statically linked binary").
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试为相同的程序生成静态链接版本的结果是[图9-8](ch09s02.html#function_call_graph_in_a_statically_link
    "图9-8. 静态链接二进制文件中的函数调用图")中显示的糟糕混乱。 '
- en: The graph in [Figure 9-8](ch09s02.html#function_call_graph_in_a_statically_link
    "Figure 9-8. Function call graph in a statically linked binary") demonstrate a
    behavior of external graphs in general, namely that they are always scaled initially
    to display the entire graph, which can result in very cluttered displays. For
    this particular graph, the status bar at the bottom of the WinGraph32 window indicates
    that there are 946 nodes and 10,125 edges that happen to cross over one another
    in 100,182 locations. Other than demonstrating the complexity of statically linked
    binaries, this graph is all but unusable. No amount of zooming and panning will
    simplify the graph, and beyond that, there is no way to easily locate a specific
    function such as `main` other than by reading the label on each node. By the time
    you have zoomed in enough to be able to read the labels associated with each node,
    only a few dozen nodes will fit within the display.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-8](ch09s02.html#function_call_graph_in_a_statically_link "图9-8. 静态链接二进制中的函数调用图")中的图演示了一般外部图的行为，即它们最初总是按比例缩放以显示整个图，这可能导致非常杂乱的显示。对于这个特定的图，WinGraph32窗口底部的状态栏指示有946个节点和10,125条边在100,182个位置交叉。除了演示静态链接二进制的复杂性之外，这个图几乎无法使用。无论怎样缩放和滚动，都无法简化这个图，而且除此之外，除了通过读取每个节点的标签外，没有简单的方法可以轻松定位到特定的函数，如`main`。在你足够放大以能够读取与每个节点关联的标签之前，只有几十个节点可以显示在屏幕上。'
- en: '![Function call graph in a statically linked binary](httpatomoreillycomsourcenostarchimages854213.png.jpg)'
  id: totrans-1047
  prefs: []
  type: TYPE_IMG
  zh: '![静态链接二进制中的函数调用图](httpatomoreillycomsourcenostarchimages854213.png.jpg)'
- en: Figure 9-8. Function call graph in a statically linked binary
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8. 静态链接二进制中的函数调用图
- en: External Cross-Reference Graphs
  id: totrans-1049
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部交叉引用图
- en: 'Two types of cross-reference graphs can be generated for global symbols (functions
    or global variables): cross-references to a symbol (View ▸ Graphs ▸ Xrefs To)
    and cross-references from a symbol (View ▸ Graphs ▸ Xrefs From). To generate an
    Xrefs To graph, a recursive ascent is performed by backtracking all cross-references
    to the selected symbol until a symbol to which no other symbols refer is reached.
    When analyzing a binary, you can use an Xrefs To graph to answer the question,
    “What sequence of calls must be made to reach this function?” [Figure 9-9](ch09s02.html#xrefs_to_graph
    "Figure 9-9. Xrefs To graph") shows the use of an Xrefs To graph to display the
    paths that can be followed to reach the `puts` function.'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全局符号（函数或全局变量），可以生成两种交叉引用图：符号的交叉引用（查看 ▸ 图表 ▸ 交叉引用到）和从符号的交叉引用（查看 ▸ 图表 ▸ 交叉引用从）。要生成交叉引用到图，通过回溯所有指向所选符号的交叉引用，执行递归上升，直到达到没有其他符号引用的符号。在分析二进制文件时，可以使用交叉引用到图来回答“必须调用哪些序列才能到达这个函数？”的问题。[图9-9](ch09s02.html#xrefs_to_graph
    "图9-9. 交叉引用到图")展示了使用交叉引用到图来显示到达`puts`函数的路径。
- en: '![Xrefs To graph](httpatomoreillycomsourcenostarchimages854215.png)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![交叉引用到图](httpatomoreillycomsourcenostarchimages854215.png)'
- en: Figure 9-9. Xrefs To graph
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9. 交叉引用到图
- en: Similarly, Xrefs To graphs can assist you in visualizing all of the locations
    that reference a global variable and the chain of function calls required to reach
    those locations. Cross-reference graphs are the only graphs capable of incorporating
    data cross-reference information.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，交叉引用到图可以帮助你可视化所有引用全局变量的位置以及到达这些位置所需的函数调用链。交叉引用图是唯一能够包含数据交叉引用信息的图。
- en: In order to create an Xrefs From graph, a recursive descent is performed by
    following cross-references from the selected symbol. If the symbol is a function
    name, only call references from the function are followed, so data references
    to global variables do not show up in the graph. If the symbol is an initialized
    global pointer variable (meaning that it actually points to something), then the
    corresponding data offset cross-reference is followed. When you graph cross-references
    from a function, the effective behavior is a function call graph rooted at the
    selected function, as shown in [Figure 9-10](ch09s02.html#xrefs_from_graph "Figure 9-10. Xrefs
    From graph").
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建交叉引用从图，通过跟随从所选符号的交叉引用执行递归下降。如果符号是函数名，则只跟随函数的调用引用，因此全局变量的数据引用不会显示在图中。如果符号是一个初始化的全局指针变量（意味着它实际上指向某个东西），则跟随相应的数据偏移交叉引用。当你从函数中绘制交叉引用时，有效行为是以所选函数为根的函数调用图，如[图9-10](ch09s02.html#xrefs_from_graph
    "图9-10. 交叉引用从图")所示。
- en: Unfortunately, the same cluttered graph problems exist when graphing functions
    with a complex call graph.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当使用复杂的调用图绘制函数时，同样存在杂乱的图形问题。
- en: '![Xrefs From graph](httpatomoreillycomsourcenostarchimages854217.png)'
  id: totrans-1056
  prefs: []
  type: TYPE_IMG
  zh: '![Xrefs From图](httpatomoreillycomsourcenostarchimages854217.png)'
- en: Figure 9-10. Xrefs From graph
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10. Xrefs From图
- en: Custom Cross-Reference Graphs
  id: totrans-1058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义交叉引用图
- en: Custom cross-reference graphs, called *User xref charts* in IDA, provide the
    maximum flexibility in generating cross-reference graphs to suit your needs. In
    addition to combining cross-references to a symbol and cross-references from a
    symbol into a single graph, custom cross-reference graphs allow you to specify
    a maximum recursion depth and the types of symbols that should be included or
    excluded from the resulting graph.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义交叉引用图，在IDA中称为*用户交叉引用图表*，在生成交叉引用图以满足您的需求方面提供了最大的灵活性。除了将符号的交叉引用和从符号的交叉引用组合到单个图中之外，自定义交叉引用图还允许您指定最大递归深度以及应包含或排除在结果图中的符号类型。
- en: View ▸ Graphs ▸ User Xrefs Chart opens the graph customization dialog shown
    in [Figure 9-11](ch09s02.html#user_cross-reference_graph_dialog "Figure 9-11. User
    cross-reference graph dialog"). Each global symbol that occurs within the specified
    address range appears as a node within the resulting graph, which is constructed
    according to the options specified in the dialog. In the most common case, generating
    cross-references from a single symbol, the start and end addresses are identical.
    If the start and end addresses differ, then the resulting graph is generated for
    all nonlocal symbols that occur within the specified range. In the extreme case
    where the start address is the lowest address in the database and the end address
    is the highest address in the database, the resulting graph degenerates to the
    function call graph for the entire binary.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 ▸ 图形 ▸ 用户交叉引用图表将打开显示在[图9-11](ch09s02.html#user_cross-reference_graph_dialog
    "图9-11. 用户交叉引用图对话框")中的图形自定义对话框。在指定的地址范围内出现的每个全局符号都作为结果图中的一个节点出现，该图是根据对话框中指定的选项构建的。在最常见的情况下，从单个符号生成交叉引用时，起始地址和结束地址是相同的。如果起始地址和结束地址不同，则生成的结果图将包括在指定范围内出现的所有非局部符号。在极端情况下，起始地址是数据库中的最低地址，而结束地址是数据库中的最高地址，结果图退化到整个二进制的函数调用图。
- en: '![User cross-reference graph dialog](httpatomoreillycomsourcenostarchimages854219.png.jpg)'
  id: totrans-1061
  prefs: []
  type: TYPE_IMG
  zh: '![用户交叉引用图对话框](httpatomoreillycomsourcenostarchimages854219.png.jpg)'
- en: Figure 9-11. User cross-reference graph dialog
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-11. 用户交叉引用图对话框
- en: 'The options that are selected in [Figure 9-11](ch09s02.html#user_cross-reference_graph_dialog
    "Figure 9-11. User cross-reference graph dialog") represent the default options
    for all custom cross-reference graphs. Following is a description of the purpose
    of each set of options:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9-11](ch09s02.html#user_cross-reference_graph_dialog "图9-11. 用户交叉引用图对话框")中选择的选项代表所有自定义交叉引用图的默认选项。以下是对每组选项目的的描述：
- en: '**Starting direction**'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '**起始方向**'
- en: Options allow you to decide whether to search for cross-references from the
    selected symbol, to the selected symbol, or both. If all other options are left
    at their default settings, restricting the starting direction to Cross references
    to results in an Xrefs To–style graph, while restricting direction to Cross references
    from generates an Xrefs From–style graph.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 选项允许您决定是否从所选符号搜索交叉引用，到所选符号，或两者都搜索。如果所有其他选项都保留在默认设置，将起始方向限制为交叉引用会导致Xrefs To风格的图形，而将方向限制为交叉引用则生成Xrefs
    From风格的图形。
- en: '**Parameters**'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**'
- en: The Recursive option enables recursive descent (Xrefs From) or ascent (Xrefs
    To) from the selected symbols. Follow only current direction forces any recursion
    to occur in only one direction. In other words, if this option is selected, and
    node B is discovered to be reachable from node A, the recursive descent into B
    adds additional nodes that can be reached only *from* node B. Newly discovered
    nodes that refer *to* node B will not be added to the graph. If you choose to
    deselect Follow only current direction, then when both starting directions are
    selected, each new node added to the graph is recursed in both the *to* and *from*
    directions.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 递归选项启用从所选符号的递归下降（Xrefs From）或上升（Xrefs To）。仅跟随当前方向强制任何递归只在一个方向上发生。换句话说，如果选择此选项，并且发现节点B可以从节点A访问，则递归下降到B会添加只能从节点B访问的附加节点。指向节点B的新发现的节点将不会添加到图中。如果您选择取消选择仅跟随当前方向，那么当选择两个起始方向时，每个添加到图中的新节点将在*到*和*从*两个方向上递归。
- en: '**Recursion depth**'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归深度**'
- en: This option sets the maximum recursion depth and is useful for limiting the
    size of generated graphs. A setting of −1 causes recursion to proceed as deep
    as possible and generates the largest possible graphs.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项设置最大递归深度，对于限制生成的图形大小很有用。设置为-1会导致递归尽可能深，并生成最大的图形。
- en: '**Ignore**'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '**忽略**'
- en: These options dictate what types of nodes will be excluded from the generated
    graph. This is another means of restricting the size of the resulting graph. In
    particular, ignoring cross-references from library functions can lead to drastic
    simplifications of graphs in statically linked binaries. The trick is to make
    sure that IDA recognizes as many library functions as possible. Library code recognition
    is the subject of [Chapter 12](ch12.html "Chapter 12. Library Recognition Using
    FLIRT Signatures").
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项指定将排除哪些类型的节点从生成的图形中。这是限制结果图形大小的另一种方法。特别是，忽略库函数的交叉引用可以导致静态链接二进制文件中的图形大大简化。关键是确保IDA尽可能多地识别库函数。库代码识别是[第12章](ch12.html
    "第12章。使用FLIRT签名进行库识别")的主题。
- en: '**Print options**'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '**打印选项**'
- en: These options control two aspects of graph formatting. Print comments causes
    any function comments to be included in a function’s graph node. If Print recursion
    dots is selected and recursion would continue beyond the specified recursion limit,
    a node containing an ellipsis is displayed to indicate that further recursion
    is possible.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项控制图形格式的两个方面。打印注释会导致任何函数注释包含在函数的图形节点中。如果选择打印递归点，并且递归会超过指定的递归限制，则显示包含省略号的节点，以指示可以进一步递归。
- en: '[Figure 9-12](ch09s02.html#user_xref_graph_for_function_depth_under "Figure 9-12. User
    xref graph for function depth_1") shows a custom cross-reference graph generated
    for function `depth_1` in our example program using default options and a recursion
    depth of 1.'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-12](ch09s02.html#user_xref_graph_for_function_depth_under "图9-12。用户函数`depth_1`的引用图")显示了在我们的示例程序中使用默认选项和递归深度为1为函数`depth_1`生成的自定义交叉引用图。'
- en: '![User xref graph for function depth_1](httpatomoreillycomsourcenostarchimages854221.png)'
  id: totrans-1075
  prefs: []
  type: TYPE_IMG
  zh: '![用户函数深度_1的引用图](httpatomoreillycomsourcenostarchimages854221.png)'
- en: Figure 9-12. User xref graph for function `depth_1`
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12。用户函数`depth_1`的引用图
- en: User-generated cross-reference graphs are the most powerful external-mode graphing
    capability available in IDA. External flowcharts have largely been superseded
    by IDA’s integrated graph-based disassembly view, and the remaining external graph
    types are simply canned versions of user-generated cross-reference graphs.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 用户生成的交叉引用图是IDA中可用的最强大的外部模式图形功能。外部流程图在很大程度上已被IDA的集成基于图形的反汇编视图所取代，而剩余的外部图形类型只是用户生成的交叉引用图的预定义版本。
- en: IDA’s Integrated Graph View
  id: totrans-1078
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA的集成图形视图
- en: With version 5.0, IDA introduced a long-awaited interactive, graph-based disassembly
    view that was tightly integrated into IDA. As mentioned previously, the integrated
    graphing mode provides an alternative interface to the standard text-style disassembly
    listing. While in graph mode, disassembled functions are displayed as control
    flow graphs similar to external-style flowchart graphs. Because a function-oriented
    control flow graph is used, only one function at a time can be displayed while
    in graph mode, and graph mode cannot be used for instructions that lie outside
    any function. For cases in which you wish to view several functions at once, or
    when you need to view instructions that are not part of a function, you must revert
    to the text-oriented disassembly listing.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.0版本中，IDA引入了一个长期期待的基于图形的交互式反汇编视图，该视图紧密集成到IDA中。如前所述，集成图形模式提供了对标准文本式反汇编列表的替代接口。在图形模式下，反汇编函数以类似于外部风格流程图的控制流图形式显示。由于使用了面向函数的控制流图，因此在图形模式下一次只能显示一个函数，并且图形模式不能用于任何函数之外的指令。对于需要同时查看多个函数或需要查看不属于函数的指令的情况，您必须回到基于文本的反汇编列表。
- en: We detailed basic manipulation of the graph view in [Chapter 5](ch05.html "Chapter 5. IDA
    Data Displays"), but we reiterate a few points here. Switching between text view
    and graph view is accomplished by pressing the spacebar or right-clicking anywhere
    in the disassembly window and selecting either Text View or Graph View as appropriate.
    The easiest way to pan around the graph is to click the background of the graph
    view and drag the graph in the appropriate direction. For large graphs, you may
    find it easier to pan using the Graph Overview window instead. The Graph Overview
    window always displays a dashed rectangle around the portion of the graph currently
    being displayed in the disassembly window. At any time, you can click and drag
    the dashed rectangle to reposition the graph display. Because the graph overview
    window displays a miniature version of the entire graph, using it for panning
    eliminates the need to constantly release the mouse button and reposition the
    mouse as required when panning across large graphs in the disassembly window.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](ch05.html "第5章. IDA数据显示")中详细介绍了图形视图的基本操作，但在此处我们重申几个要点。在文本视图和图形视图之间切换是通过按空格键或在反汇编窗口的任何位置右键单击并选择适当的文本视图或图形视图来完成的。在图形视图中平移的最简单方法是单击图形视图的背景并按适当方向拖动图形。对于大型图形，您可能会发现使用图形概览窗口平移更容易。图形概览窗口始终在反汇编窗口当前显示的图形部分周围显示一个虚线矩形。在任何时候，您都可以单击并拖动虚线矩形来重新定位图形显示。因为图形概览窗口显示整个图形的缩略图，所以使用它进行平移消除了在反汇编窗口中平移大型图形时需要不断释放鼠标按钮并重新定位鼠标的需求。
- en: There are no significant differences between manipulating a disassembly in graph
    mode and manipulating a disassembly in text mode. Double-click navigation continues
    to work as you would expect it to, as does the navigation history list. Any time
    you navigate to a location that does not lie within a function (such as a global
    variable), the display will automatically switch to text mode. Graph mode will
    automatically be restored once you navigate back to a function. Access to stack
    variables is identical to that of text mode, with the summary stack view being
    displayed in the root basic block of the displayed function. Detailed stack frame
    views are accessed by double-clicking any stack variable, just as in text mode.
    All options for formatting instruction operands in text mode remain available
    and are accessed in the same manner in graph mode.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形模式和文本模式下操作反汇编之间没有显著差异。双击导航继续按您预期的方式工作，导航历史记录列表也是如此。每次您导航到不在函数内（例如全局变量）的位置时，显示将自动切换到文本模式。一旦您导航回函数，图形模式将自动恢复。访问堆变量与文本模式相同，总结堆视图显示在显示函数的根基本块中。通过双击任何堆变量可以访问详细的堆栈帧视图，就像在文本模式中一样。所有在文本模式中格式化指令操作数的选项仍然可用，并且在图形模式中以相同的方式访问。
- en: The primary user interface change related to graph mode deals with the handing
    of individual graph nodes. [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node
    "Figure 9-13. Typical expanded graph view node") shows a simple graph node and
    its related title bar button controls.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 与图形模式相关的用户界面主要变化涉及处理单个图形节点。![图9-13](ch09s02.html#typical_expanded_graph_view_node
    "图9-13. 典型的扩展图形视图节点")显示了简单的图形节点及其相关的标题栏按钮控件。
- en: '![Typical expanded graph view node](httpatomoreillycomsourcenostarchimages854223.png)'
  id: totrans-1083
  prefs: []
  type: TYPE_IMG
  zh: '![典型的扩展图形视图节点](httpatomoreillycomsourcenostarchimages854223.png)'
- en: Figure 9-13. Typical expanded graph view node
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-13. 典型的扩展图形视图节点
- en: From left to right, the three buttons on the node’s title bar allow you to change
    the background color of the node, assign or change the name of the node, and access
    the list of cross-references to the node. Coloring nodes is a useful way to remind
    yourself that you have already analyzed a node or to simply make it stand out
    from others, perhaps because it contains code of particular interest. Once you
    assign a node a color, the color is also used as the background color for the
    corresponding instructions in text mode. To easily remove any coloring, right-click
    the node’s title bar and select **Set node color to default**.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，节点标题栏上的三个按钮允许您更改节点的背景颜色、分配或更改节点的名称，以及访问节点的交叉引用列表。给节点上色是一种有用的方式，可以提醒自己已经分析过该节点，或者简单地使其从其他节点中脱颖而出，可能是因为它包含特别感兴趣的代码。一旦您为节点分配了颜色，该颜色也将用作文本模式下相应指令的背景颜色。要轻松去除任何上色，右键单击节点标题栏并选择**将节点颜色设置为默认**。
- en: 'The middle button on the title bar in [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node
    "Figure 9-13. Typical expanded graph view node") is used to assign a name to the
    address of the first instruction of the node’s basic block. Since basic blocks
    are often the target of jump instructions, many nodes may already have a dummy
    name assigned as the result of being targeted by a jump cross-reference. However,
    it is possible for a basic block to begin without having a name assigned. Consider
    the following lines of code:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9-13](ch09s02.html#typical_expanded_graph_view_node "图9-13. 典型的展开图视图节点")的标题栏中间按钮用于为节点基本块的第一条指令的地址分配一个名称。由于基本块通常是跳转指令的目标，许多节点可能已经因为被跳转交叉引用而分配了一个虚拟名称。然而，基本块在未分配名称的情况下开始也是可能的。考虑以下代码行：
- en: '[PRE88]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The instruction at ![](httpatomoreillycomsourcenostarchimages854061.png) has
    two potential successors, `loc_401053` and the instruction at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Because it has two successors, ![](httpatomoreillycomsourcenostarchimages854061.png)
    must terminate a basic block, which results in ![](httpatomoreillycomsourcenostarchimages854063.png)
    becoming the first instruction in a new basic block, even though it is not targeted
    explicitly by a jump and thus has no dummy name assigned.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 在![图](httpatomoreillycomsourcenostarchimages854061.png)处的指令有两个潜在的后续指令，`loc_401053`和![图](httpatomoreillycomsourcenostarchimages854063.png)处的指令。因为它有两个后续指令，![图](httpatomoreillycomsourcenostarchimages854061.png)必须终止一个基本块，这导致![图](httpatomoreillycomsourcenostarchimages854063.png)成为新基本块中的第一条指令，即使它没有被显式地作为跳转的目标，因此没有分配虚拟名称。
- en: The rightmost button in [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node
    "Figure 9-13. Typical expanded graph view node") is used to access the list of
    cross-references that target the node. Since cross-reference comments are not
    displayed by default in graph mode, this is the easiest way to access and navigate
    to any location that references the node. Unlike the cross-reference lists we
    have discussed previously, the generated node cross-reference list also contains
    an entry for the ordinary flow into the node (designated by type `^`). This is
    required because it is not always obvious in graph view which node is the linear
    predecessor of a given node. If you wish to view normal cross-reference comments
    in graph mode, access the Cross-References tab under Options ▸ General and set
    the Number of displayed xrefs option to something other than zero.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9-13](ch09s02.html#typical_expanded_graph_view_node "图9-13. 典型的展开图视图节点")的标题栏最右侧按钮用于访问指向节点的交叉引用列表。由于在图形模式下默认不显示交叉引用注释，这是访问和导航到任何引用节点的最简单方式。与之前讨论的交叉引用列表不同，生成的节点交叉引用列表还包含一个普通流程进入节点的条目（由类型`^`指定）。这是必需的，因为在图形视图中，给定节点的前驱节点不总是显而易见的。如果您希望在图形模式下查看正常的交叉引用注释，请转到“选项”▸“常规”下的交叉引用标签，并将显示的xrefs选项设置为非零值。
- en: Nodes within a graph may be *grouped* either by themselves or with other nodes
    in order to reduce some of the clutter in a graph. To group multiple nodes, ctrl-click
    the title bar of each node to be grouped and then right-click the title bar of
    any selected node and select **Group nodes**. You will be prompted to enter some
    text (defaults to the first instruction in the group) to be displayed in the collapsed
    node. [Figure 9-14](ch09s02.html#typical_collapsed_open_parenthesis_group "Figure 9-14. Typical
    collapsed (grouped) graph view node") shows the result of grouping the node in
    [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node "Figure 9-13. Typical
    expanded graph view node") and changing the node text to *collapsed node demo*.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 图形中的节点可以自行或与其他节点一起**分组**，以减少图形中的部分杂乱。要分组多个节点，请按住Ctrl键点击要分组的每个节点的标题栏，然后右键点击任何选定节点的标题栏并选择**分组节点**。您将被提示输入一些文本（默认为组中的第一条指令）以在折叠节点中显示。[图9-14](ch09s02.html#typical_collapsed_open_parenthesis_group
    "图9-14. 典型的折叠（分组）图视图节点")显示了将[图9-13](ch09s02.html#typical_expanded_graph_view_node
    "图9-13. 典型的展开图视图节点")中的节点分组并更改节点文本为“折叠节点演示”的结果。
- en: '![Typical collapsed (grouped) graph view node](httpatomoreillycomsourcenostarchimages854225.png)'
  id: totrans-1091
  prefs: []
  type: TYPE_IMG
  zh: '![典型的折叠（分组）图视图节点](httpatomoreillycomsourcenostarchimages854225.png)'
- en: Figure 9-14. Typical collapsed (grouped) graph view node
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-14. 典型的折叠（分组）图视图节点
- en: Note that two additional buttons are now present in the title bar. In left-to-right
    order, these buttons allow you to uncollapse (expand) the grouped node and edit
    the node text. Uncollapsing a node merely expands the nodes within a group to
    their original form; it does not change the fact that the node or nodes now belong
    to a group. When a group is uncollapsed, the two new buttons just mentioned are
    removed and replaced with a single Collapse Group button. An expanded group can
    easily be collapsed again using the Collapse Group button or by right-clicking
    the title bar of any node in the group and selecting Hide Group. To completely
    remove a grouping applied to one or more nodes, you must right-click the title
    bar of the collapsed node or one of the participating uncollapsed nodes and select
    **Ungroup Nodes**. This action has the side effect of expanding the group if it
    was collapsed at the time.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标题栏现在有两个额外的按钮。从左到右顺序，这些按钮允许你展开（展开）分组节点并编辑节点文本。展开一个节点只是将组内的节点展开到其原始形式；它不会改变节点或节点现在属于一个组的事实。当组展开时，前面提到的两个新按钮被移除，并替换为单个“折叠组”按钮。可以使用“折叠组”按钮或通过右键单击组中任何节点的标题栏并选择“隐藏组”来轻松地再次折叠展开的组。要完全移除应用于一个或多个节点的分组，必须右键单击折叠节点的标题栏或参与未展开的节点之一，并选择**取消分组节点**。此操作的一个副作用是，如果组当时是折叠的，则会展开组。
- en: '* * *'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[55](#CHP-9-FN-4)]) Hex-Rays makes the source for `wingraph32` available
    at [http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip](http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip).
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[55](#CHP-9-FN-4)]) Hex-Rays 在 [http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip](http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip)
    提供了 `wingraph32` 的源代码。
- en: ^([[56](#CHP-9-FN-5)]) dotty is a graph viewing tool included as part of the
    graphviz project.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[56](#CHP-9-FN-5)]) dotty 是图形可视化工具，它是图形可视化项目的一部分。
- en: ^([[57](#CHP-9-FN-6)]) Hex-Rays makes the source for `qwingraph` available at
    [http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip](http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip).
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[57](#CHP-9-FN-6)]) Hex-Rays 在 [http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip](http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip)
    提供了 `qwingraph` 的源代码。
- en: ^([[58](#CHP-9-FN-7)]) A GDL reference can be found at [http://www.absint.com/aisee/manual/windows/node58.html](http://www.absint.com/aisee/manual/windows/node58.html).
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[58](#CHP-9-FN-7)]) GDL 参考信息可在 [http://www.absint.com/aisee/manual/windows/node58.html](http://www.absint.com/aisee/manual/windows/node58.html)
    找到。
- en: ^([[59](#CHP-9-FN-8)]) A DOT reference can be found at [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html).
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[59](#CHP-9-FN-8)]) DOT 参考信息可在 [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html)
    找到。
- en: ^([[60](#CHP-9-FN-9)]) See [http://www.graphviz.org/](http://www.graphviz.org/).
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[60](#CHP-9-FN-9)]) 请参阅 [http://www.graphviz.org/](http://www.graphviz.org/)。
- en: ^([[61](#CHP-9-FN-10)]) Please see [http://pedram.redhive.com/code/paimei/](http://pedram.redhive.com/code/paimei/).
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[61](#CHP-9-FN-10)]) 请参阅 [http://pedram.redhive.com/code/paimei/](http://pedram.redhive.com/code/paimei/)。
- en: ^([[62](#CHP-9-FN-11)]) The graphs depicted in this chapter have been edited
    outside of IDA to remove node coloring for the purposes of improving readability.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[62](#CHP-9-FN-11)]) 本章中展示的图形已在 IDA 之外进行编辑，以去除节点着色，以提高可读性。
- en: Summary
  id: totrans-1103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Graphs are a powerful tool available to assist you in analyzing any binary.
    If you are accustomed to viewing disassemblies in pure text format, it may take
    some time to adjust to using a graph-based display. In IDA, it is generally a
    matter of realizing that all of the information that was available in the text
    display remains available in the graph display; however, it may be formatted somewhat
    differently. Cross-references, for example, become the edges that connect the
    basic blocks in a graph display.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 图形是分析任何二进制文件的有力工具。如果你习惯于以纯文本格式查看反汇编代码，那么可能需要一些时间来适应使用基于图形的显示。在 IDA 中，通常只需要意识到在文本显示中可用的所有信息在图形显示中仍然可用；然而，格式可能有所不同。例如，交叉引用在图形显示中变成了连接基本块的边。
- en: Choosing the proper graph to view plays an important role in optimizing the
    use of graphs for analysis. If you want to know how a particular function is reached,
    then you are probably interested in a function call or cross-reference graph.
    If you want to know how a specific instruction is reached, then you are probably
    more interested in a control flow graph.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的图形来查看在优化图形分析的使用中起着重要作用。如果你想知道某个特定函数是如何被调用的，那么你可能对函数调用或交叉引用图感兴趣。如果你想知道某个特定指令是如何被到达的，那么你可能对控制流图更感兴趣。
- en: Some of the frustration that users have experienced in the past with IDA’s graphing
    capabilities is directly attributable to the inflexibility of the `wingraph32`
    application and its related graphs. These frustrations were addressed in part
    with the introduction of an integrated graph-based disassembly mode. IDA is primarily
    a disassembler, however, and graph generation is not its primary purpose. Readers
    interested in dedicated graph-based analysis tools may wish to investigate applications
    designed specifically for that purpose, such as BinNavi,^([[63](#ftn.CHP-9-FN-12)])
    produced by Halvar Flake’s company Zynamics.^([[64](#ftn.CHP-9-FN-13)])
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户过去在使用IDA的图形功能时遇到的某些挫败感，直接归因于`wingraph32`应用程序及其相关图形的不灵活性。这些问题部分通过引入基于图形的解汇编模式得到了解决。然而，IDA主要是一个解汇编器，图形生成并不是其主要目的。对专门基于图形分析工具感兴趣的读者可能希望调查专为该目的设计的应用程序，例如由Halvar
    Flake的公司Zynamics生产的BinNavi，^([[63](#ftn.CHP-9-FN-12)])，以及^([[64](#ftn.CHP-9-FN-13)])。
- en: '* * *'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[63](#CHP-9-FN-12)]) See [http://www.zynamics.com/binnavi.html](http://www.zynamics.com/binnavi.html).
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[63](#CHP-9-FN-12)]) 请参阅 [http://www.zynamics.com/binnavi.html](http://www.zynamics.com/binnavi.html)。
- en: ^([[64](#CHP-9-FN-13)]) Note that Zynamics was acquired by Google in March 2011.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[64](#CHP-9-FN-13)]) 注意，Zynamics于2011年3月被谷歌收购。
- en: Chapter 10. The Many Faces of IDA
  id: totrans-1110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 IDA的多面性
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-1111
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: For many years, the Windows GUI version was the superstar in the IDA stable.
    Since the release of IDA version 6.0 this is no longer the case, as Linux and
    OS X users can now enjoy GUI versions of IDA for their platforms. However, this
    new version in no way changes the fact that there are several alternative ways
    to use IDA. The original version of IDA was actually an MS-DOS console application,
    and the console version remains available on all platforms to this day. With built-in
    remote debugging capabilities, IDA is a powerful multiplatform analysis and debugging
    tool.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Windows GUI版本一直是IDA中的明星。自从IDA版本6.0发布以来，这种情况已经不再如此，因为Linux和OS X用户现在可以享受适用于其平台的IDA
    GUI版本。然而，这个新版本并没有改变这样一个事实：使用IDA有几种替代方法。IDA的原始版本实际上是一个MS-DOS控制台应用程序，而控制台版本至今仍可在所有平台上使用。凭借内置的远程调试功能，IDA是一个强大的多平台分析和调试工具。
- en: Beyond its interactive capabilities, IDA offers a batch-processing mode in all
    of its versions to facilitate automated processing of large numbers of files.
    The key to effective batch processing with IDA is to understand what each version
    can and cannot do and choose the appropriate version of IDA to suit your requirements.
    In this chapter we discuss IDA’s console version and how to make the most of IDA’s
    batch-processing facilities.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其交互式功能之外，IDA在其所有版本中都提供批量处理模式，以方便大量文件的自动化处理。有效使用IDA进行批量处理的关键是了解每个版本能做什么和不能做什么，并选择适合您需求的IDA版本。在本章中，我们将讨论IDA的控制台版本以及如何充分利用IDA的批量处理功能。
- en: Console Mode IDA
  id: totrans-1114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台模式下的IDA
- en: The heart of all console versions of IDA is a Borland-developed, console I/O
    library called *TVision* that has been ported to several platforms, including
    Windows, Linux, and Mac OS X, among others. Hex-Rays makes the source code for
    its current TVision port available to paying IDA customers on its IDA download
    page.^([[65](#ftn.CHP-10-FN-1)])
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有IDA控制台版本的核心是一个名为*TVision*的Borland开发的控制台I/O库，它已被移植到多个平台，包括Windows、Linux和Mac
    OS X等。Hex-Rays在其IDA下载页面上向付费IDA客户提供其当前TVision移植的源代码。^([[65](#ftn.CHP-10-FN-1)])
- en: The use of a common library across all platforms keeps the user interface consistent
    on all of the console versions. There are a few annoyances to deal with in moving
    from platform to platform, however, such as varying degrees of support for the
    mouse, resizing, and the ability to pass hotkeys to the IDA application. We discuss
    some of the problems and, when available, workarounds in the platform-specific
    sections that follow.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有平台上使用通用库可以保持控制台版本的用户界面一致。然而，在平台之间迁移时，有一些不便之处需要处理，例如鼠标支持程度、调整大小以及将快捷键传递给IDA应用程序的能力。我们将在以下针对特定平台的章节中讨论一些问题，并在可能的情况下提供解决方案。
- en: Common Features of Console Mode
  id: totrans-1117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台模式的共同特性
- en: As the term *console mode* implies, the text-based versions of IDA all run within
    a terminal or shell of some sort. These consoles may have varying degrees of support
    for resizing and the use of a mouse, resulting in limitations that you will need
    to learn to live with. The types of limitations depend on which platform and terminal
    program you are using.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 如“控制台模式”这个术语所暗示的，IDA 的基于文本版本都是在某种终端或壳中运行的。这些控制台对调整大小和使用鼠标的支持程度可能不同，这会导致你需要学会适应的限制。这些限制的类型取决于你使用的平台和终端程序。
- en: The console user interface consists of a menu bar across the top line of the
    display to show menu options and status and a common operations bar across the
    bottom line of the display that’s similar to a text-based toolbar. Available operations
    are activated using hotkeys or, when supported, by clicking the mouse. Virtually
    every command available in the GUI version is available in some form in the console
    version, and most of the hotkey associations are preserved as well.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台用户界面包括一条菜单栏，位于显示窗口的顶部行，用于显示菜单选项和状态，以及一条位于显示窗口底部行的常用操作栏，类似于基于文本的工具栏。可用的操作可以通过热键激活，或者当支持时，通过点击鼠标。几乎在
    GUI 版本中可用的每个命令在控制台版本中以某种形式可用，并且大多数热键关联也得到了保留。
- en: 'The IDA display windows consume the space between the upper menu bar and the
    lower command bar. However, a common limitation, regardless of which terminal
    program you happen to use, is that there is little display room when the screen
    is limited to roughly 80 by 25 characters and no graphics. Therefore, console
    versions of IDA typically open only two display windows by default: the disassembly
    window and the messages window. In order to approximate the tabbed display windows
    found in the GUI version, IDA uses the TVision library’s overlapping windowing
    capability for text windows and assigns the F6 key (in lieu of window title tabs)
    to cycle through available open windows. Each window is numbered sequentially,
    and the window ID is present in the upper left-hand corner.'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 显示窗口占据了上菜单栏和下命令栏之间的空间。然而，一个常见的限制，无论你使用的是哪种终端程序，当屏幕限制在约 80 x 25 个字符且没有图形时，显示空间就很小。因此，IDA
    的控制台版本默认只打开两个显示窗口：反汇编窗口和消息窗口。为了近似 GUI 版本中找到的标签显示窗口，IDA 使用 TVision 库的重叠窗口功能来处理文本窗口，并将
    F6 键（代替窗口标题标签）分配为在可用的打开窗口之间循环。每个窗口按顺序编号，窗口 ID 显示在窗口的左上角。
- en: When mouse support is available in your console, it is possible to resize an
    IDA display window by clicking and dragging the lower right corner of the display
    window to the desired size. To repositioxsn a display window, you click and drag
    the display’s top border. Lacking mouse support, you can move and resize individual
    displays via Window ▸ Resize/Move (ctrl-F5) and then use your arrow keys to move
    and shift-arrow keys to resize the active window. If your terminal program can
    be resized using the mouse, IDA recognizes the new terminal size and expands (or
    shrinks) to fill it as appropriate.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的控制台支持鼠标操作时，你可以通过点击并拖动显示窗口的右下角到期望的大小来调整 IDA 显示窗口的大小。要重新定位显示窗口，你点击并拖动显示窗口的顶部边框。如果没有鼠标支持，你可以通过
    Window ▸ Resize/Move (ctrl-F5) 来移动和调整单个显示窗口的大小，然后使用箭头键来移动，使用 shift-arrow 键来调整活动窗口的大小。如果你的终端程序可以使用鼠标调整大小，IDA
    会识别新的终端大小，并相应地扩展（或缩小）以填充它。
- en: Without graphics capability, the integrated graph-based disassembly mode is
    not available, and no control-flow arrows are displayed in the left margin of
    the disassembly listing window. However, all subviews available in the GUI version
    are available in the console versions. As in the GUI version, the majority of
    subviews are accessible via the View ▸ Open Subviews menu. The one major difference
    in available displays is that hex dumps are not available as a unique subview.
    Instead, you can toggle a disassembly to a hex dump and back using Options ▸ Dump/Normal
    View (ctrl-F4). In order to have both a disassembly and a hex view open simultaneously,
    you must open a second disassembly window (View ▸ Open Subviews ▸ Disassembly)
    and toggle the new view to a hex dump. Unfortunately, there is no way to synchronize
    the new hex dump to the existing disassembly view.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 没有图形功能时，集成基于图形的反汇编模式不可用，且在反汇编列表窗口的左侧边栏中不显示控制流箭头。然而，GUI版本中所有可用的子视图在控制台版本中也都可用。与GUI版本一样，大多数子视图可以通过视图
    ▸ 打开子视图菜单访问。可用的显示方式中一个主要区别是，没有作为独立子视图的十六进制转储。相反，您可以使用选项 ▸ 转储/正常视图（ctrl-F4）在反汇编和十六进制转储之间切换。为了同时打开反汇编和十六进制视图，您必须打开第二个反汇编窗口（视图
    ▸ 打开子视图 ▸ 反汇编）并将新视图切换为十六进制转储。不幸的是，没有方法将新的十六进制转储与现有的反汇编视图同步。
- en: With mouse support, navigating your way around the disassembly remains much
    the same as the GUI version, where double-clicking any name takes you to the corresponding
    address. Alternatively, positioning the cursor on a name and pressing enter causes
    the display to jump to the corresponding named location (this also happens to
    work in the GUI version). Pressing enter while the cursor is positioned on the
    name of a stack variable opens the detailed stack frame view for the associated
    function. Without mouse support, the menus work similarly to many other console
    applications, employing the alt-*x* method of menu navigation, where *x* is a
    highlighted character on the current screen.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 支持鼠标操作后，在反汇编中导航的方式与GUI版本基本相同，双击任何名称都会跳转到相应的地址。或者，将光标置于名称上并按回车键，显示会跳转到相应的命名位置（这在GUI版本中也同样适用）。当光标位于栈变量名称上时按回车键，会打开关联函数的详细栈帧视图。在没有鼠标支持的情况下，菜单的工作方式与许多其他控制台应用程序类似，采用alt-*x*的菜单导航方法，其中*x*是当前屏幕上高亮的字符。
- en: Windows Console Specifics
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows控制台特定内容
- en: The Windows *cmd.exe* (*command.exe* on the Windows 9*x* family) terminal is
    not terribly flexible, but it is fairly well supported by IDA’s console version.
    The Windows console version of IDA is named *idaw.exe*, while the GUI version
    is named *idag.exe*. The corresponding versions for 64-bit binaries (available
    with the advanced version of IDA) are named *idaw64.exe* and *idag64.exe*, respectively.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: Windows *cmd.exe*（Windows 9*x*系列的*command.exe*）终端并不非常灵活，但IDA的控制台版本对其支持相当好。IDA的Windows控制台版本命名为
    *idaw.exe*，而GUI版本命名为 *idag.exe*。64位二进制文件（通过IDA的高级版本提供）的相应版本分别命名为 *idaw64.exe*
    和 *idag64.exe*。
- en: In order for IDA’s mouse support to work in Windows, you must ensure that QuickEdit
    mode is disabled for the terminal in which you are running IDA. To configure QuickEdit
    mode as one of the terminal’s properties, right-click the terminal’s title bar
    and select **Properties**; then deselect **QuickEdit mode** on the Options tab.
    You must do this prior to launching IDA, as the change will not be recognized
    while IDA is running.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使IDA的鼠标支持在Windows中工作，您必须确保您运行IDA的终端中已禁用快速编辑模式。要将快速编辑模式配置为终端属性之一，右键单击终端的标题栏并选择**属性**；然后在选项选项卡上取消选择**快速编辑模式**。您必须在启动IDA之前完成此操作，因为当IDA运行时，该更改不会被识别。
- en: Unlike Linux terminals running under X Windows, *cmd.exe* cannot be expanded
    by using the mouse to enlarge the window. On Windows only, IDA’s console version
    offers the Window ▸ Set Video Mode menu option to resize *cmd.exe* to one of six
    fixed terminal sizes, up to a maximum of 255 by 100.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 与在X Windows下运行的Linux终端不同，*cmd.exe*不能通过鼠标放大窗口来扩展。仅在Windows中，IDA的控制台版本提供了窗口 ▸
    设置视频模式菜单选项，将*cmd.exe*调整到六种固定终端尺寸之一，最大为255 x 100。
- en: While no graph mode is available in the disassembly window, IDA’s external graphing
    options are available. Selections from the View ▸ Graphs menu will cause IDA to
    launch the configured graph viewer (such as `qwingraph`) to display the resulting
    graph. For Windows versions of IDA, it is possible to open several graphs at once
    and continue to use IDA while the graphs are open.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在反汇编窗口中没有提供图形模式，但IDA的外部图形选项是可用的。从视图 ▸ 图形菜单中选择将导致IDA启动配置的图形查看器（如`qwingraph`）以显示结果图形。对于IDA的Windows版本，可以同时打开多个图形，并在图形打开时继续使用IDA。
- en: Linux Console Specifics
  id: totrans-1129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux控制台特定内容
- en: The Linux console version of IDA is named *idal* (or *idal64* for analyzing
    64-bit binaries). Prior to IDA 6.0, Linux and OS X console versions were included
    as standard components of your IDA distribution. As such, when you copy these
    console versions to your Linux or OS X platform, you must also copy your IDA key
    file (*ida.key*) so that your console version will run properly. Note that this
    requires that you install IDA on a Windows machine at least once, even if you
    never intend to run the Windows version. On Unix-style systems you may alternatively
    copy your key file to *$HOME/.idapro/ida.key*. If you do not create it, IDA automatically
    creates the IDA personal settings directory (*$HOME/.idapro*) the first time you
    launch IDA.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: Linux版本的IDA控制台版本被称为*idal*（或分析64位二进制文件时使用的*idal64*）。在IDA 6.0之前，Linux和OS X的控制台版本被包含在您的IDA发行版的标准组件中。因此，当您将这些控制台版本复制到您的Linux或OS
    X平台时，您还必须复制您的IDA密钥文件（*ida.key*），以确保您的控制台版本能够正常运行。请注意，这要求您至少在Windows机器上安装一次IDA，即使您从未打算运行Windows版本。在类Unix系统中，您可以选择将您的密钥文件复制到*$HOME/.idapro/ida.key*。如果您不创建它，IDA将在您第一次启动IDA时自动创建IDA个人设置目录（*$HOME/.idapro*）。
- en: IDA 6.*x* installations are much simpler. Because IDA 6.*x* is purchased for
    a specific platform, the installation procedure on your platform takes care of
    installing the GUI version, the console version, and your IDA key file to suitable
    locations.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 6.*x*的安装过程要简单得多。因为IDA 6.*x*是为特定平台购买的，所以您平台上的安装程序会负责将GUI版本、控制台版本和您的IDA密钥文件安装到合适的位置。
- en: Basic navigation in the Linux version is similar to navigation in the Windows
    console version; several Linux specifics are addressed in this section. Users’
    tastes for Linux terminal programs are as varied as their tastes for Linux distributions
    in general. IDA includes a file named *tvtuning.txt* that offers some details
    on how to configure various terminal types, including remote Windows terminal
    clients such as SecureCRT and PuTTY.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: Linux版本的基本导航与Windows控制台版本中的导航相似；本节中讨论了几个Linux特有的问题。用户对Linux终端程序的选择与他们对Linux发行版的总体选择一样多样化。IDA包含一个名为*tvtuning.txt*的文件，其中提供了一些关于如何配置各种终端类型的详细信息，包括远程Windows终端客户端，如SecureCRT和PuTTY。
- en: One of the biggest challenges that you will face when using Linux terminal programs
    is making sure that your hotkey sequences are passed all the way to IDA and not
    captured by the terminal program itself. For example, will alt-F open IDA’s File
    menu or your console’s File menu? The two options for dealing with this problem
    are to find a terminal program whose hotkey sequences don’t overlap IDA’s (or
    that can be configured not to overlap) or to edit IDA’s configuration file to
    remap commands to hotkeys that are not used by your terminal. If you choose to
    remap the hotkeys, you may want to update the hotkey mappings on every computer
    on which you use IDA so that you don’t have to remember which mapping is in effect
    at each location. You may also find it difficult to interact with other IDA users
    who are using the default mappings.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Linux终端程序时，您将面临的最大挑战之一是确保您的快捷键序列能够完全传递到IDA，而不是被终端程序本身捕获。例如，alt-F会打开IDA的文件菜单还是您的控制台文件菜单？处理这个问题的两种选择是找到一种终端程序，其快捷键序列不会与IDA重叠（或者可以配置为不重叠），或者编辑IDA的配置文件以将命令重新映射到您的终端未使用的快捷键。如果您选择重新映射快捷键，您可能希望更新每台您使用IDA的计算机上的快捷键映射，这样您就不必记住每个位置上生效的是哪种映射。您还可能发现与使用默认映射的其他IDA用户交互很困难。
- en: 'If you choose to use the standard Linux text display, the dimensions of your
    IDA console will be fixed, and your mouse support will be dependent on your use
    of GPM (the Linux console mouse server). If you are not using GPM for mouse support,
    you should specify the `noGPM` option for TVision when you launch IDA, as shown
    here:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用标准的 Linux 文本显示，你的 IDA 控制台尺寸将是固定的，你的鼠标支持将取决于你使用 GPM（Linux 控制台鼠标服务器）。如果你没有使用
    GPM 进行鼠标支持，那么在启动 IDA 时，你应该指定 TVision 的 `noGPM` 选项，如下所示：
- en: '[PRE89]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Color choices are quite limited in console mode, and you may need to adjust
    your color settings (Options ▸ Colors) to ensure that all text is visible and
    does not blend into the background. Four predefined color palettes are available,
    with the option to customize the colors (a choice of 16) used for various parts
    of the disassembly.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台模式下，颜色选择相当有限，你可能需要调整你的颜色设置（选项 ▸ 颜色），以确保所有文本都可见，并且不会与背景混合。有四个预定义的颜色方案可供选择，你可以自定义用于反汇编各个部分的颜色（16
    种选择）。
- en: If you are running X, then you may be running KDE’s `konsole`, Gnome’s `gnome-terminal`,
    a straight `xterm`, or some other variation on a terminal. Other than `xterm`,
    most terminals offer their own menus and associated hotkeys that may or may not
    overlap IDA’s hotkey assignments. Consequently, `xterm` is not a bad choice for
    running IDA, although it is not necessarily the most visually appealing. KDE’s
    `konsole` is our preferred Linux console as it offers the best appearance, fewest
    hotkey collisions, and smoothest mouse performance.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 X，那么你可能在运行 KDE 的 `konsole`、Gnome 的 `gnome-terminal`、直接的 `xterm`，或者终端的其他变体。除了
    `xterm` 之外，大多数终端都提供自己的菜单和相关的快捷键，这些快捷键可能与 IDA 的快捷键分配重叠或不重叠。因此，`xterm` 对于运行 IDA
    来说不是一个坏的选择，尽管它可能不是最视觉上吸引人的。KDE 的 `konsole` 是我们首选的 Linux 控制台，因为它提供了最佳的外观、最少的快捷键冲突和最平滑的鼠标性能。
- en: In order to address some of the problems surrounding keyboard and mouse use
    within various X Windows consoles, Jeremy Cooper developed a native X11 port^([[66](#ftn.CHP-10-FN-2)])
    of the TVision libraries. Using this modified version of TVision allows you to
    launch IDA in its own X window rather than consume an entire console. Compiling
    Cooper’s TVision port yields a drop in replacement for libtvision.so, the shared
    TVision library used by `idal`. After installing the new library, you may receive
    an error message stating that a VGA font can’t be loaded when you attempt to run
    IDA. If this happens, you will need to install a VGA font and let your X server
    know where to find it. A suitable VGA font is available at [http://gilesorr.com/bashprompt/xfonts/](http://gilesorr.com/bashprompt/xfonts/)
    (download both `vga` and `sabvga`). Another interesting feature of using the native
    X11 port is that you can forward the X11 window to another machine. Thus, you
    can run IDA on Linux but forward the X11 window (over `ssh` of course) to a Mac.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决围绕各种 X Windows 控制台中键盘和鼠标使用的一些问题，Jeremy Cooper 开发了 TVision 库的本地 X11 端口^([[66](#ftn.CHP-10-FN-2)])。使用这个修改后的
    TVision 版本，你可以在一个自己的 X 窗口中启动 IDA，而不是消耗整个控制台。编译 Cooper 的 TVision 端口会产生一个用于 `idal`
    的共享 TVision 库 libtvision.so 的替代品。在安装新库后，当你尝试运行 IDA 时，可能会收到一个错误消息，表明无法加载 VGA 字体。如果发生这种情况，你需要安装一个
    VGA 字体，并让 X 服务器知道它在哪。一个合适的 VGA 字体可以在 [http://gilesorr.com/bashprompt/xfonts/](http://gilesorr.com/bashprompt/xfonts/)（下载
    `vga` 和 `sabvga`）找到。使用本地 X11 端口的另一个有趣特性是，你可以将 X11 窗口转发到另一台机器。因此，你可以在 Linux 上运行
    IDA，但将 X11 窗口（当然是通过 `ssh`）转发到 Mac。
- en: For remote access to your Linux-based IDA installation using the Hex-Rays–supplied
    TVision libraries, we recommend that you configure your terminal software to emulate
    an xterm (consult *tvtuning.txt* and your terminal emulator’s documentation for
    more information) and then launch IDA according to the instructions contained
    in *tvtuning.txt*. For example, you must specify `TVOPT=xtrack` in order for the
    mouse to work with IDA when using SecureCRT as your terminal emulator.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 Hex-Rays 提供的 TVision 库远程访问基于 Linux 的 IDA 安装，我们建议你配置你的终端软件以模拟 xterm（有关更多信息，请参阅
    *tvtuning.txt* 和你的终端仿真器的文档）然后根据 *tvtuning.txt* 中的说明启动 IDA。例如，你必须指定 `TVOPT=xtrack`，以便在使用
    SecureCRT 作为终端仿真器时，鼠标可以与 IDA 一起工作。
- en: You can, of course, choose to export your `TVOPT` settings, eliminating the
    need to specify them every time you launch IDA. For a full overview of available
    TVision options, refer to *linux.cpp* in the TVision source distribution.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以选择导出你的 `TVOPT` 设置，从而消除每次启动 IDA 时都需要指定它们的需要。有关 TVision 可用选项的完整概述，请参阅 TVision
    源分布中的 *linux.cpp*。
- en: 'External graph views on Linux are available from the console version only if
    you happen to be running IDA in a windowing environment, and you have configured
    the `GRAPH_VISUALIZER` variable in *ida.cfg* to point to a suitable graph rendering
    program.^([[67](#ftn.CHP-10-FN-3)]) IDA versions prior to 6.0 are only capable
    of generating graphs using GDL. You may install a GDL viewer such as aiSee^([[68](#ftn.CHP-10-FN-4)])
    and configure IDA to launch the new application by editing IDA’s main configuration
    file, *<IDADIR>/cfg/ida.cfg*. The configuration option `GRAPH_VISUALIZER` specifies
    the command to be used to view IDA’s GDL graphs (all legacy mode graphs). The
    default setting looks something like this:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，只有在您在窗口环境中运行IDA并且已将`GRAPH_VISUALIZER`变量在*ida.cfg*中配置为指向合适的图形渲染程序时，才能从控制台版本访问外部图形视图^([[67](#ftn.CHP-10-FN-3)])。IDA
    6.0之前的版本只能使用GDL生成图形。您可以安装一个GDL查看器，如aiSee^([[68](#ftn.CHP-10-FN-4)))，并通过编辑IDA的主配置文件*<IDADIR>/cfg/ida.cfg*来配置IDA以启动新应用程序。配置选项`GRAPH_VISUALIZER`指定用于查看IDA的GDL图形（所有传统模式图形）的命令。默认设置可能如下所示：
- en: '[PRE90]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `remove` option asks `qwingraph` to delete the input file, which is useful
    when you are displaying temporary files. The `timelimit` option specifies the
    number of seconds to spend attempting to generate a pretty graph. If the graph
    cannot be laid out neatly within this time, `qwingraph` switches to a “fast and
    ugly”^([[69](#ftn.CHP-10-FN-5)]) layout algorithm. Beginning with IDA 6.0, the
    `GRAPH_VISUALIZER` option is enclosed in a conditional block to provide separate
    settings for Windows and non-Windows platforms. If you are editing *ida.cfg* on
    a non-Windows platform, make sure that you are editing the correct portion of
    the file. If you have installed a GDL viewer such as aiSee, then you need to edit
    `GRAPH_VISUALIZER` to point to your viewer of choice. For a typical installation
    of aiSee, this might result in the following:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`选项请求`qwingraph`删除输入文件，这在显示临时文件时很有用。`timelimit`选项指定尝试生成美观图形所需的时间（秒数）。如果在此时间内无法整齐地布局图形，`qwingraph`将切换到“快速且丑陋”^([[69](#ftn.CHP-10-FN-5)])布局算法。从IDA
    6.0开始，`GRAPH_VISUALIZER`选项被包含在一个条件块中，为Windows和非Windows平台提供单独的设置。如果您在非Windows平台上编辑*ida.cfg*，请确保您正在编辑文件的正确部分。如果您已安装了aiSee之类的GDL查看器，则需要编辑`GRAPH_VISUALIZER`以指向您选择的查看器。对于aiSee的典型安装，这可能会导致以下结果：'
- en: '[PRE91]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that it is always best to specify the full path to your GDL viewer to ensure
    that it is found when IDA attempts to launch it. Finally, since `qwingraph` is
    open source software, users of older versions of IDA are free to download the
    source for `qwingraph` from Hex-Rays (see [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing")), build it, and integrate `qwingraph` into their IDA installations.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，始终最好指定GDL查看器的完整路径，以确保当IDA尝试启动它时能够找到。最后，由于`qwingraph`是开源软件，因此IDA旧版本的用户可以自由地从Hex-Rays下载`qwingraph`的源代码（见[第9章](ch09.html
    "第9章。交叉引用和图形"))，构建它，并将其集成到他们的IDA安装中。
- en: OS X Console Specifics
  id: totrans-1146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OS X控制台特定信息
- en: IDA’s console versions for OS X are named the same as the Linux versions (*idal*
    and *idal64*). As with the Linux and Windows console versions, the OS X versions
    rely on the TVision library to support console I/O.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的OS X控制台版本与Linux版本同名（*idal*和*idal64*）。与Linux和Windows控制台版本一样，OS X版本依赖于TVision库来支持控制台I/O。
- en: The fact that the Mac keyboard has a different layout than a PC keyboard presents
    a few challenges when running the Mac version of IDA, primarily because the Mac’s
    option/alt key does not behave like the PC’s alt key where application menus are
    concerned.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: Mac键盘的布局与PC键盘不同，这在运行IDA的Mac版本时带来了一些挑战，主要是因为Mac的option/alt键在处理应用程序菜单时不像PC的alt键那样工作。
- en: The obvious choice for attempting to run IDA is the Mac’s Terminal application.
    When launching IDA using Terminal, be sure to configure the option key as an alt
    key for use within IDA. Doing so allows keyboard access to IDA alt key shortcuts,
    such as all of the main IDA menus (alt-F for the File menu, for example). If you
    don’t select this option, you’ll have to use the esc key in lieu of alt; thus,
    esc-F brings up the File menu. Since esc has back or close-window functionality
    in IDA, this approach is not recommended. [Figure 10-1](ch10.html#mac_os_x_terminal_keyboard_settings_dial
    "Figure 10-1. Mac OS X Terminal keyboard settings dialog") shows the Terminal
    Inspector dialog, which is accessed via Terminal ▸ Preferences when Terminal is
    active. Select the **Use option key as meta key** checkbox to make the option
    key behave as an alt key.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行 IDA 的明显选择是 Mac 的终端应用程序。当使用终端启动 IDA 时，请确保将选项键配置为 IDA 中的 alt 键。这样做允许键盘访问
    IDA 的 alt 键快捷方式，例如所有主要的 IDA 菜单（例如，alt-F 用于文件菜单）。如果您不选择此选项，您将不得不使用 esc 键代替 alt；因此，esc-F
    会弹出文件菜单。由于 esc 在 IDA 中具有后退或关闭窗口的功能，这种方法不推荐使用。[图 10-1](ch10.html#mac_os_x_terminal_keyboard_settings_dial
    "图 10-1. Mac OS X 终端键盘设置对话框") 显示了终端检查器对话框，该对话框通过在终端活动时选择 Terminal ▸ Preferences
    访问。选择 **使用选项键作为 meta 键** 复选框，使选项键的行为类似于 alt 键。
- en: One potential alternative to Terminal is iTERM,^([[70](#ftn.CHP-10-FN-6)]) which
    allows the alt functionality of the option key and enables mouse sup-port as well.
    Another terminal that many developers seem to like is the gnome terminal, which
    has been ported^([[71](#ftn.CHP-10-FN-7)]) to X11 on OS X. Since this requires
    the installation of XCODE and X11, we won’t do more than mention the existence
    of the port. Using the default Terminal or iTERM should be sufficient for most
    users.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: Terminal 的一个潜在替代方案是 iTERM，^([[70](#ftn.CHP-10-FN-6)])，它允许选项键的 alt 功能并启用鼠标支持。另一个许多开发者似乎喜欢的终端是
    gnome 终端，它已被移植^([[71](#ftn.CHP-10-FN-7)]) 到 OS X 上的 X11。由于这需要安装 XCODE 和 X11，我们不会更多地提及其存在。使用默认的
    Terminal 或 iTERM 应该对大多数用户来说足够了。
- en: An alternative way to run IDA on OS X is to install X11 (available on your OS
    X installation disks as an optional package) and Jeremy Cooper’s modified TVision
    library (libtvision.dylib for OS X) to run IDA as a native X11 application. You
    may wish to add */usr/X11R6/bin* to your system PATH (edit PATH in */etc/profile*)
    for easier access to X11-related binaries.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 上运行 IDA 的另一种方法是安装 X11（作为可选包包含在您的 OS X 安装盘中）和 Jeremy Cooper 修改的 TVision
    库（libtvision.dylib for OS X），以便将 IDA 作为原生 X11 应用程序运行。您可能希望将 */usr/X11R6/bin* 添加到您的系统
    PATH 中（在 */etc/profile* 中编辑 PATH），以便更容易访问与 X11 相关的二进制文件。
- en: '![Mac OS X Terminal keyboard settings dialog](httpatomoreillycomsourcenostarchimages854227.png.jpg)'
  id: totrans-1152
  prefs: []
  type: TYPE_IMG
  zh: '![Mac OS X 终端键盘设置对话框](httpatomoreillycomsourcenostarchimages854227.png.jpg)'
- en: Figure 10-1. Mac OS X Terminal keyboard settings dialog
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1. Mac OS X 终端键盘设置对话框
- en: 'In this configuration, IDA may be launched from an xterm, and it will execute
    in its own window with full mouse functionality. The problem with the option/alt
    key will remain, however, as X11 views this key as *Mode_switch* and fails to
    pass the key to IDA. Fortunately, X11 allows you to remap keys through the use
    of the `xmodmap` utility. One solution is to create (or edit) a file named *.Xmodmap*
    in your home directory (something like */Users/idabook/.Xmodmap*) containing the
    following commands:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，可以从 xterm 启动 IDA，并且它将在自己的窗口中执行，具有完整的鼠标功能。然而，选项/alt 键的问题仍然存在，因为 X11 将此键视为
    *Mode_switch* 并未能将键传递给 IDA。幸运的是，X11 允许您通过使用 `xmodmap` 工具来重新映射键。一个解决方案是在您的家目录中创建（或编辑）一个名为
    *.Xmodmap* 的文件（例如 */Users/idabook/.Xmodmap*），包含以下命令：
- en: '[PRE92]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The default X11 startup script (*/etc/X11/xinit/xinitrc*) contains commands
    to read *.Xmodmap* whenever you launch X11\. If you have created your own *.xinitrc*
    file, which overrides the default *xinitrc*, you should make sure that it contains
    a command such as the following; otherwise your *.Xmodmap* file will not be processed.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 X11 启动脚本（*/etc/X11/xinit/xinitrc*）包含在每次启动 X11 时读取 *.Xmodmap* 的命令。如果您已经创建了您自己的
    *.xinitrc* 文件，该文件覆盖了默认的 *xinitrc*，您应该确保它包含以下命令之类的命令；否则，您的 *.Xmodmap* 文件将不会被处理。
- en: '[PRE93]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Finally, you need to modify the default settings for X11 to prevent the system
    from overriding your modified key map. [Figure 10-2](ch10.html#x11_preferences_on_os_x
    "Figure 10-2. X11 Preferences on OS X") shows the X11 Preferences dialog.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要修改 X11 的默认设置，以防止系统覆盖您修改的键映射。[图 10-2](ch10.html#x11_preferences_on_os_x
    "图 10-2. OS X 上的 X11 首选项") 显示了 X11 首选项对话框。
- en: '![X11 Preferences on OS X](httpatomoreillycomsourcenostarchimages854229.png.jpg)'
  id: totrans-1159
  prefs: []
  type: TYPE_IMG
  zh: '![X11 Preferences on OS X](httpatomoreillycomsourcenostarchimages854229.png.jpg)'
- en: Figure 10-2. X11 Preferences on OS X
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2. X11 Preferences on OS X
- en: 'To prevent the system from overriding your keyboard mappings, you must deselect
    the middle option: **Follow system keyboard layout**. Once you have made this
    change, restart X11, and your modified keyboard settings should take effect, making
    the alt key available to access IDA’s menus. You can verify that X11 recognizes
    the alt key by using `xmodmap` to print the current list of keyboard modifiers,
    as follows:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止系统覆盖您的键盘映射，您必须取消选中中间选项：**跟随系统键盘布局**。一旦您做出此更改，重新启动 X11，您的修改后的键盘设置应生效，使 alt
    键可用于访问 IDA 的菜单。您可以通过使用 `xmodmap` 打印当前键盘修饰符列表来验证 X11 是否识别 alt 键，如下所示：
- en: '[PRE94]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If `mod1` does not list `Alt_L` and `Alt_R`, as shown at ![](httpatomoreillycomsourcenostarchimages854063.png),
    then your key map has not been updated, in which case you should rerun the `xmodmap`
    command listed at ![](httpatomoreillycomsourcenostarchimages854061.png) in the
    previous code.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `mod1` 没有列出 `Alt_L` 和 `Alt_R`，如图所示 ![X11 Preferences on OS X](httpatomoreillycomsourcenostarchimages854063.png)，则您的键盘映射尚未更新，在这种情况下，您应重新运行前面代码中列出的
    `xmodmap` 命令 ![X11 Preferences on OS X](httpatomoreillycomsourcenostarchimages854061.png)。
- en: '* * *'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[65](#CHP-10-FN-1)]) See [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[65](#CHP-10-FN-1)]) 请参阅 [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
- en: ^([[66](#CHP-10-FN-2)]) See [http://simon.baymoo.org/universe/ida/tvision/](http://simon.baymoo.org/universe/ida/tvision/).
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[66](#CHP-10-FN-2)]) 请参阅 [http://simon.baymoo.org/universe/ida/tvision/](http://simon.baymoo.org/universe/ida/tvision/).
- en: ^([[67](#CHP-10-FN-3)]) Refer to [IDA Graphing](ch09s02.html "IDA Graphing")
    in [IDA Graphing](ch09s02.html "IDA Graphing").
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[67](#CHP-10-FN-3)]) 请参阅 [IDA Graphing](ch09s02.html "IDA Graphing")。
- en: ^([[68](#CHP-10-FN-4)]) The GDL viewer aiSee is available for many platforms
    and is free for noncommercial use. It can be found at [http://www.aisee.de/](http://www.aisee.de/).
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[68](#CHP-10-FN-4)]) GDL 查看器 aiSee 可用于许多平台，并且对非商业用途免费。您可以在 [http://www.aisee.de/](http://www.aisee.de/)
    找到它。
- en: ^([[69](#CHP-10-FN-5)]) See `timelm.c` in the `wingraph32` or `qwingraph` source
    distribution.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[69](#CHP-10-FN-5)]) 请参阅 `wingraph32` 或 `qwingraph` 源分布中的 `timelm.c`。
- en: ^([[70](#CHP-10-FN-6)]) See [http://iterm.sourceforge.net/](http://iterm.sourceforge.net/).
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[70](#CHP-10-FN-6)]) 请参阅 [http://iterm.sourceforge.net/](http://iterm.sourceforge.net/).
- en: ^([[71](#CHP-10-FN-7)]) See [http://www.macports.org/](http://www.macports.org/).
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[71](#CHP-10-FN-7)]) 请参阅 [http://www.macports.org/](http://www.macports.org/).
- en: Using IDA’s Batch Mode
  id: totrans-1172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IDA 的批处理模式
- en: All versions of IDA can be executed in batch mode to facilitate automated processing
    tasks. The primary purpose of using batch mode is to launch IDA, have it run a
    specific IDC script, and have it terminate once the script completes. Several
    command-line options are available to control the processing performed during
    batch mode execution.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的所有版本都可以以批处理模式执行，以便方便自动化处理任务。使用批处理模式的主要目的是启动 IDA，运行特定的 IDC 脚本，并在脚本完成后终止。在批处理模式执行期间，有多个命令行选项可用于控制执行的处理。
- en: 'GUI versions of IDA do not require a console in order to execute, making them
    very easy to incorporate into virtually any type of automation script or wrapper
    program. When run in batch mode, the GUI versions of IDA do not display any graphical
    components. Running the Windows console versions (*idaw.exe* and *idaw64.exe*)
    generates a full console display that closes automatically when the batch processing
    is complete. The console display can be suppressed by redirecting output to a
    null device (NUL for *cmd.exe*, */dev/null* in cygwin), as shown here:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的 GUI 版本在执行时不需要控制台，这使得它们很容易集成到几乎任何类型的自动化脚本或包装程序中。在批处理模式下运行时，IDA 的 GUI 版本不会显示任何图形组件。运行
    Windows 控制台版本 (*idaw.exe* 和 *idaw64.exe*) 会生成完整的控制台显示，批处理完成后会自动关闭。可以通过将输出重定向到空设备（*cmd.exe*
    中的 NUL，cygwin 中的 */dev/null*）来抑制控制台显示，如下所示：
- en: '[PRE95]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'IDA’s batch mode is controlled by the command-line parameters listed here:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的批处理模式由以下列出的命令行参数控制：
- en: The `-A` option causes IDA to run in autonomous mode, which means that no dialogs
    requiring user interaction will be displayed. (If you have never clicked through
    IDA’s license agreement, then the license agreement dialog will be displayed in
    spite of the presence of this switch.)
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-A` 选项使 IDA 以自主模式运行，这意味着不会显示需要用户交互的对话框。（如果您从未点击过 IDA 的许可协议，则尽管有此开关，许可协议对话框仍会显示。）'
- en: The `-c` option causes IDA to delete any existing database associated with the
    file specified on the command line and generate an entirely new database.
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c` 选项会导致 IDA 删除与命令行上指定的文件关联的任何现有数据库，并生成一个全新的数据库。'
- en: The `-S` option is used to specify which IDC script IDA should execute on startup.
    To execute *myscript.idc*, the syntax is `-Smyscript.idc` (no space between `S`
    and the script name). IDA searches for the named script in the *<IDADIR>/idc*
    directory. If you have IDAPython properly installed, you may also specify a python
    script here.
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-S` 选项用于指定 IDA 在启动时应该执行哪个 IDC 脚本。要执行 *myscript.idc*，语法是 `-Smyscript.idc`（`S`
    和脚本名称之间没有空格）。IDA 在 *<IDADIR>/idc* 目录中搜索命名的脚本。如果您已正确安装 IDAPython，您也可以在这里指定一个 Python
    脚本。'
- en: The `-B` option invokes batch mode and is equivalent to supplying IDA with `-A
    -c -Sanalysis.idc` at execution. The *analysis.idc* script that ships with IDA
    simply waits for IDA to analyze the file named on the command line before dumping
    an assembly listing (*.asm* file) of the disassembly and closing IDA in order
    to save and close the newly generated database.
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-B` 选项调用批处理模式，相当于在执行时向 IDA 提供了 `-A -c -Sanalysis.idc`。随 IDA 一起提供的 *analysis.idc*
    脚本简单地等待 IDA 分析命令行上指定的文件，然后输出反汇编的汇编列表（*.asm 文件），并关闭 IDA 以保存和关闭新创建的数据库。'
- en: The `-S` option is the key to batch mode, as IDA will terminate only if the
    designated script causes IDA to terminate. If the script does not shut down IDA,
    then all of the options simply combine to automate the IDA startup process. Scripting
    with IDC is discussed in [Chapter 15](ch15.html "Chapter 15. IDA Scripting").
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '`-S` 选项是批处理模式的关键，因为只有当指定的脚本导致 IDA 终止时，IDA 才会终止。如果脚本没有关闭 IDA，则所有选项简单地组合起来以自动化
    IDA 启动过程。有关 IDC 脚本编写的讨论请见 [第 15 章](ch15.html "第 15 章。IDA 脚本")。'
- en: 'Because of limitations with the TVision library used by the Linux and OS X
    versions of IDA, batch execution must be performed within a TTY console. This
    makes simple things such as output redirection and background processing impossible.
    Fortunately, the latest version of TVision recognizes the `TVHEADLESS` environment
    variable, which allows console output (`stdout`) to be redirected, as shown here:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IDA 的 Linux 和 OS X 版本使用的 TVision 库存在限制，批处理执行必须在 TTY 控制台中完成。这使得输出重定向和后台处理等简单操作变得不可能。幸运的是，TVision
    的最新版本识别 `TVHEADLESS` 环境变量，允许控制台输出（`stdout`）被重定向，如下所示：
- en: '[PRE96]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Fully detaching from the console for background execution requires the additional
    redirection of both `stdin` and `stderr`.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在后台执行完全脱离控制台，需要额外重定向 `stdin` 和 `stderr`。
- en: 'Ilfak discusses batch mode in one of his blog posts here: [http://hexblog.com/2007/03/on_batch_analysis.html](http://hexblog.com/2007/03/on_batch_analysis.html).
    Among other things, he details how to move beyond invoking a single script and
    discusses how to execute an IDA plug-in from batch mode.'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: Ilfak 在他的一篇博客文章中讨论了批处理模式：[http://hexblog.com/2007/03/on_batch_analysis.html](http://hexblog.com/2007/03/on_batch_analysis.html)。在众多内容中，他详细介绍了如何超越调用单个脚本，并讨论了如何在批处理模式下执行
    IDA 插件。
- en: Summary
  id: totrans-1186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While GUI versions of IDA remain the most fully featured versions available,
    console mode alternatives and batch-processing capabilities offer IDA users tremendous
    flexibility in creating complex analysis solutions built around IDA’s automated
    analysis capabilities.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 IDA 的 GUI 版本仍然是功能最全面的版本，但控制台模式替代方案和批处理功能为 IDA 用户提供了在 IDA 的自动化分析能力周围创建复杂分析解决方案的巨大灵活性。
- en: At this point we have covered all of IDA’s basic capabilities, and it is time
    to move on to more advanced features. Over the course of the next few chapters
    we will cover some of IDA’s more useful configuration options and present some
    additional utilities designed to improve IDA’s binary analysis capabilities.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了 IDA 的所有基本功能，现在是时候转向更高级的功能了。在接下来的几章中，我们将介绍一些 IDA 更有用的配置选项，并展示一些旨在提高
    IDA 二进制分析能力的附加实用程序。
