- en: Part II. Basic IDA Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 4. Getting Started with IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s about time we got down to actually using IDA. The remainder of this book
    is dedicated to various features of IDA and how you can leverage them to best
    suit your reverse engineering needs. In this chapter we begin by covering the
    options you are presented with when you launch IDA, and then we describe just
    what is happening when you open a binary file for analysis. Finally, we’ll present
    a quick overview of the user interface to lay the groundwork for the remaining
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of standardization, examples in both this chapter and the remainder
    of the book will be presented with the Windows Qt GUI interface unless an example
    requires a specific, different version of IDA (such as an example of Linux debugging).
  prefs: []
  type: TYPE_NORMAL
- en: Launching IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any time you launch IDA, you will be greeted briefly by a splash screen that
    displays a summary of your license information. Once the splash screen clears,
    IDA displays another dialog offering three ways to proceed to its desktop environment,
    as shown in [Figure 4-1](ch04.html#launching_ida-id1 "Figure 4-1. Launching IDA").
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching IDA](httpatomoreillycomsourcenostarchimages854073.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. Launching IDA
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer not to see the welcome message, feel free to uncheck the Display
    at startup checkbox at the bottom of the dialog. If you check the box, future
    sessions will begin as if you had clicked the Go button, and you will be taken
    directly to an empty IDA workspace. If at some point you find yourself longing
    for the Welcome dialog (after all, it conveniently allows you to return to recently
    used files), you will need to edit IDA’s registry key to set the `DisplayWelcome`
    value back to *`1`*. Alternatively, selecting Windows ▸ Reset hidden messages
    will restore *all* previously hidden messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When installed on Windows, IDA creates the following registry key: `HKEY_CURRENT_USER\Software\Hex-Rays\IDA`.^([[29](#ftn.CHP-4-FN-1)])
    Many options that can be configured within IDA itself (as opposed to editing one
    of the configuration files) are stored within this registry key. However, on other
    platforms, IDA stores such values in a binary data file *($HOME/.idapro/ida.reg)*
    that is not easily edited.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the three options shown in [Figure 4-1](ch04.html#launching_ida-id1
    "Figure 4-1. Launching IDA") offers a slightly different method to proceed to
    the IDA desktop. These three launch options are reviewed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New**'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing New opens a standard File Open dialog to select the file to be analyzed.
    Following file selection, one or more additional dialogs are displayed that allow
    you to choose specific file-analysis options before the file is loaded, analyzed,
    and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Go**'
  prefs: []
  type: TYPE_NORMAL
- en: The Go button terminates the load process and causes IDA to open with an empty
    workspace. At this point, if you want to open a file, you may drag and drop a
    binary file onto your IDA desktop, or you may use one of the options from the
    File menu to open a file. The File ▸ Open command results in a File Open dialog,
    as described previously. By default, IDA utilizes a *known extensions* filter
    to limit the view of the File dialog. Make sure that you modify or clear the filter
    (such as choosing All Files) so that the File dialog correctly displays the file
    you are interested in opening.^([[30](#ftn.CHP-4-FN-2)]) When you open a file
    this way, IDA attempts to automatically identify the selected file’s type; however,
    you should pay careful attention to the Loading dialog to see which loaders have
    been selected to process the file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Previous**'
  prefs: []
  type: TYPE_NORMAL
- en: You should utilize the Previous button when you wish to open one of the files
    in the list of recent files that is directly below the Previous button. The list
    of recently used files is populated with values from the `History` subkey of IDA’s
    Windows registry key (or *ida.reg* on non-Windows platforms). The maximum length
    of the history list is initially set to 10, but this limit may be raised as high
    as 100 by editing the appropriate entry in *idagui.cfg* or *idatui.cfg* (see [Chapter 11](ch11.html
    "Chapter 11. Customizing IDA")). Utilizing the history list is the most convenient
    option for resuming work on recently used database files.
  prefs: []
  type: TYPE_NORMAL
- en: IDA File Loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When choosing to open a new file using the File ▸ Open command, you will be
    presented with the loading dialog shown in [Figure 4-2](ch04.html#the_ida_load_a_new_file_dialog
    "Figure 4-2. The IDA Load a New File dialog"). IDA generates a list of potential
    file types and displays that list at the top of the dialog. This list represents
    the IDA loaders that are best suited for dealing with the selected file. The list
    is created by executing each of the file loaders in IDA’s *loaders* directory
    in order to find any loaders^([[31](#ftn.CHP-4-FN-3)]) that recognize the new
    file. Note that in [Figure 4-2](ch04.html#the_ida_load_a_new_file_dialog "Figure 4-2. The
    IDA Load a New File dialog"), both the Windows PE loader (*pe.ldw*) and the MS-DOS
    EXE loader (*dos.ldw*) claim to recognize the selected file. Readers familiar
    with the PE file format will not be surprised by this, as the PE file format is
    an extended form of the MS-DOS EXE file format. The last entry in the list, Binary
    File, will always be present since it is IDA’s default for loading files that
    it does not recognize, and this provides the lowest-level method for loading any
    file. When offered the choice of several loaders, it is not a bad initial strategy
    to simply accept the default selection unless you possess specific information
    that contradicts IDA’s determination.
  prefs: []
  type: TYPE_NORMAL
- en: '![The IDA Load a New File dialog](httpatomoreillycomsourcenostarchimages854075.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. The IDA Load a New File dialog
  prefs: []
  type: TYPE_NORMAL
- en: At times, Binary File will be the only entry that appears in the loader list.
    In such cases, the implied message is that none of the loaders recognize the chosen
    file. If you opt to continue the loading process, make sure that you select the
    processor type in accordance with your understanding of the file contents.
  prefs: []
  type: TYPE_NORMAL
- en: The Processor Type drop-down menu allows you to specify which processor module
    (from IDA’s *procs* directory) should be used during the disassembly process.
    In most cases, IDA will choose the proper processor based on information that
    it reads from the executable file’s headers. When IDA can’t properly determine
    the processor type associated with the file being opened, you will need to manually
    select a processor type before continuing with the file-loading operation.
  prefs: []
  type: TYPE_NORMAL
- en: The Loading Segment and Loading Offset fields are active only when the Binary
    File input format is chosen in conjunction with an x86 family processor. Since
    the binary loader is unable to extract any memory layout information, the segment
    and offset values entered here are combined to form the base address for the loaded
    file content. Should you forget to specify a base address during the initial loading
    process, the base address of the IDA image can be modified at any time using the
    Edit ▸ Segments ▸ Rebase Program command.
  prefs: []
  type: TYPE_NORMAL
- en: The Kernel Options buttons provide access to configure the specific disassembly
    analysis options that IDA will utilize to enhance the recursive-descent process.
    In the overwhelming majority of cases, the default options provide the best possible
    disassembly. The IDA help files provide additional information on available kernel
    options.
  prefs: []
  type: TYPE_NORMAL
- en: The Processor Options button provides access to configuration options that apply
    to the selected processor module. However, processor options are not necessarily
    available for every processor module. Limited help is available for processor
    options as these options are very highly dependent on the selected processor module
    and the programming proficiency of the module’s author.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining Options checkboxes are used to gain finer control over the file-loading
    process. Each of the options is described further in IDA’s help file. The options
    are not applicable to all input file types, and in most cases, you can rely on
    the default selections. Specific cases when you may need to modify these options
    will be covered in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis").
  prefs: []
  type: TYPE_NORMAL
- en: Using the Binary File Loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you opt to utilize the binary loader, you need to be prepared to do more
    than your usual share of the processing work. With no file header information
    to guide the analysis process, it is up to you to step in and perform tasks that
    more capable loaders often do automatically. Examples of situations that may call
    for the use of the binary loader include the analysis of ROM images and exploit
    payloads that may have been extracted from network packet captures or log files.
  prefs: []
  type: TYPE_NORMAL
- en: When the x86 processor module is paired with the binary loader, the dialog shown
    in [Figure 4-3](ch04.html#x86_mode_selection "Figure 4-3. x86 mode selection")
    will be displayed. With no recognizable file headers available to assist IDA,
    it is up to the user to specify whether code should be treated as 16-bit or 32-bit
    mode code. Other processors for which IDA can distinguish between 16- and 32-bit
    modes include ARM and MIPS.
  prefs: []
  type: TYPE_NORMAL
- en: '![x86 mode selection](httpatomoreillycomsourcenostarchimages854077.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. x86 mode selection
  prefs: []
  type: TYPE_NORMAL
- en: Binary files contain no information concerning their memory layout (at least
    no information that IDA knows how to recognize). When an x86 processor type has
    been selected, base address information must be specified in the loader dialog’s
    Loading Segment and Loading Offset fields, as mentioned earlier. For all other
    processor types, IDA displays the memory layout dialog shown in [Figure 4-4](ch04.html#the_memory_organization_dialog
    "Figure 4-4. The Memory Organization dialog"). As a convenience, you may create
    a RAM section, a ROM section, or both and designate the address range of each.
    The Input File options are used to specify which portion of the input file (the
    default is the entire file) should be loaded and to which address the file content
    should be mapped.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Memory Organization dialog](httpatomoreillycomsourcenostarchimages854079.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. The Memory Organization dialog
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-5](ch04.html#binary_file_loading "Figure 4-5. Binary file loading")
    shows the last step of a binary load—a gentle reminder that you need to do some
    work. The message highlights the fact that IDA has no header information available
    to help it distinguish code bytes from data bytes in the binary file. At this
    point, you are reminded to designate one of the addresses in the file as an entry
    point by telling IDA to turn the byte(s) at that address into code (C is the hotkey
    used to force IDA to treat a byte as code). For binary files, IDA will not perform
    any initial disassembly until you take the time to identify at least one byte
    as code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary file loading](httpatomoreillycomsourcenostarchimages854081.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5. Binary file loading
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[29](#CHP-4-FN-1)]) Older versions of IDA used `HKEY_CURRENT_USER\Software\Datarescue\IDA`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#CHP-4-FN-2)]) On non-Windows systems, it is not uncommon for executable
    files to have no file extension at all.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[31](#CHP-4-FN-3)]) IDA loaders will be discussed further in [Chapter 18](ch18.html
    "Chapter 18. Binary Files and IDA Loader Modules").
  prefs: []
  type: TYPE_NORMAL
- en: IDA Database Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are happy with your loading options and click OK to close the dialog,
    the real work of loading the file begins. At this point, IDA’s goal is to load
    the selected executable file into memory and to analyze the relevant portions.
    This results in the creation of an IDA database whose components are stored in
    four files, each with a base name matching the selected executable and whose extensions
    are .*id0*, .*id1*, .*nam*, and .*til*. The .*id0* file contains the content of
    a B-tree–style database, while the *.id1* file contains flags that describe each
    program byte. The .*nam* file contains index information related to named program
    locations as displayed in IDA’s Names window (discussed further in [Chapter 5](ch05.html
    "Chapter 5. IDA Data Displays")). Finally, the .*til* file is used to store information
    concerning local type definitions specific to a given database. The formats of
    each of these files are proprietary to IDA, and they are not easily edited outside
    of the IDA environment.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, these four files are archived, and optionally compressed, into
    a single IDB file whenever you close your current project. When people refer to
    an IDA database, they are typically referring to the IDB file. An uncompressed
    database file is usually 10 times the size of the original input binary file.
    When the database is closed properly, you should never see files with *.id0*,
    *.id1*, *.nam*, or *.til* extensions in your working directories. Their presence
    often indicates that a database was not closed properly (for example, when IDA
    crashes) and that the database may be corrupt.
  prefs: []
  type: TYPE_NORMAL
- en: LOADER WARNINGS
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a loader begins to analyze a file, it may encounter circumstances that
    require additional user input in order to complete the loading process. One example
    of this occurs with PE files that have been created with PDB debugging information.
    If IDA determines that a *Program Database (PDB)* file may exist, you will be
    asked whether you want IDA to locate and to process the corresponding PDB file
    as shown in this message:'
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro has determined that the input file was linked with debug information.
    Do you want to look for the corresponding PDB file at the local symbol store and
    the Microsoft Symbol Server?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A second example of a loader-generated informational message occurs with obfuscated
    programs such as malware. Obfuscation techniques often play fast and loose with
    file format specifications, which can cause problems for loaders expecting well-structured
    files. Knowing this, the PE loader performs some validation on import tables,
    and if the import tables do not seem to be formatted according to convention,
    IDA will display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: The imports segment seems to be destroyed. This MAY mean that the file was packed
    or otherwise modified in order to make it more difficult to analyze. If you want
    to see the imports segment in the original form, please reload it with the ‘make
    imports section’ checkbox cleared.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples of this error and how to deal with it will be covered in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis").
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that once a database has been created for a given
    executable, IDA no longer requires access to that executable unless you intend
    to use IDA’s integrated debugger to debug the executable itself. From a security
    standpoint, this is a nice feature. For instance, when you are analyzing a malware
    sample, you can pass the associated database among analysts without passing along
    the malicious executable itself. There are no known cases in which an IDA database
    has been used as an attack vector for malicious software.
  prefs: []
  type: TYPE_NORMAL
- en: At its heart, IDA is nothing more than a database application. New databases
    are created and populated automatically from executable files. The various displays
    that IDA offers are simply views into the database that reveal information in
    a format useful to the software reverse engineer. Any modifications that users
    make to the database are reflected in the views and saved with the database, but
    these changes have no effect on the original executable file. The power of IDA
    lies in the tools it contains to analyze and manipulate the data within the database.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Database Creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have chosen a file to analyze and specified your options, IDA initiates
    the creation of a database. For this process, IDA turns control over to the selected
    loader module, whose job it is to load the file from disk, parse any file-header
    information that it may recognize, create various program sections containing
    either code or data as specified in the file’s headers, and, finally, identify
    specific entry points into the code before returning control to IDA. In this regard,
    IDA loader modules behave much as operating system loaders behave. The IDA loader
    will determine a virtual memory layout based on information contained in the program
    file headers and configure the database accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Once the loader has finished, the disassembly engine within IDA takes over and
    begins passing one address at a time to the selected processor module. The processor
    module’s job is to determine the type of instruction located at that address,
    the length of the instruction at that address, and the location(s) at which execution
    can continue from that address (e.g., is the current instruction sequential or
    branching?). When IDA is comfortable that it has found all of the instructions
    in the file, it makes a second pass through the list of instruction addresses
    and asks the processor module to generate the assembly language version of each
    instruction for display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this disassembly, IDA automatically conducts additional analysis
    of the binary file to extract additional information likely to be useful to the
    analyst. Users can expect to find some or all of the following information incorporated
    into the database once IDA completes its initial analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiler identification**'
  prefs: []
  type: TYPE_NORMAL
- en: It is often useful to know what compiler was used to build a piece of software.
    Identifying the compiler that was used can help us understand function-calling
    conventions used in a binary as well as determine what libraries the binary may
    be linked with. When a file is loaded, IDA attempts to identify the compiler that
    was used to create the input file. If the compiler can be identified, the input
    file is scanned for sequences of boilerplate code known to be used by that compiler.
    Such functions are color coded in an effort to reduce the amount of code that
    needs to be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function argument and local variable identification**'
  prefs: []
  type: TYPE_NORMAL
- en: Within each identified function (addresses that are targets of call instructions),
    IDA performs a detailed analysis of the behavior of the stack pointer register
    in order to both recognize accesses to variables located within the stack and
    understand the layout of the function’s stack frame.^([[32](#ftn.CHP-4-FN-4)])
    Names are automatically generated for such variables based on their use as either
    local variables within the function or as arguments passed into the function as
    part of the function call process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Datatype information**'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing knowledge of common library functions and their required parameters,
    IDA adds comments to the database to indicate the locations at which parameters
    are passed into these functions. These comments save the analyst a tremendous
    amount of time by providing information that would otherwise need to be retrieved
    from various application programming interface (API) references.
  prefs: []
  type: TYPE_NORMAL
- en: Closing IDA Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any time you close a database, whether you are closing IDA altogether or simply
    switching to a different database, you are presented with the Save Database dialog,
    as shown in [Figure 4-6](ch04s02.html#the_save_database_dialog "Figure 4-6. The
    Save Database dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Save Database dialog](httpatomoreillycomsourcenostarchimages854083.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6. The Save Database dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the initial save of a newly created database, the new database filename
    is derived from the input filename by replacing the input extension with the *.idb*
    extension (e.g., *example.exe* yields a database named *example.idb*). When the
    input file has no extension, *.idb* is appended to form the name of the database
    (e.g., *httpd* yields *httpd.idb*). The available save options and their associated
    implications are summarized in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t pack database**'
  prefs: []
  type: TYPE_NORMAL
- en: This option simply flushes changes to the four database component files and
    closes the desktop *without* creating an IDB file. This option is *not recommended*
    when closing your databases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pack database (Store)**'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the Store option results in the four database component files being
    archived into a single IDB file. Any previous IDB will be overwritten without
    confirmation. No compression is used with the Store option. Once the IDB file
    has been created, the four database component files are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pack database (Deflate)**'
  prefs: []
  type: TYPE_NORMAL
- en: The Deflate option is identical to the Store option, with the exception that
    the database component files are compressed within the IDB archive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collect garbage**'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting garbage collection causes IDA to delete any unused memory pages from
    the database prior to closing it. Select this option in conjunction with Deflate
    in order to create the smallest possible IDB file. This option is not generally
    required unless disk space is at a premium.
  prefs: []
  type: TYPE_NORMAL
- en: '**DON’T SAVE the database**'
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why anyone would choose not to save his work. It turns out that
    this option is the only way to discard changes that you have made to a database
    since the last time it was saved. When this option is selected, IDA simply deletes
    the four database component files and leaves any existing IDB file untouched.
    Using this option is as close as you will get to an undo or revert capability
    while using IDA.
  prefs: []
  type: TYPE_NORMAL
- en: Reopening a Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Granted, reopening an existing database doesn’t involve rocket science,^([[33](#ftn.CHP-4-FN-5)])
    so you may be wondering why this topic is covered at all. Under ordinary circumstances,
    returning to work on an existing database is as simple as selecting the database
    using one of IDA’s file-opening methods. Database files open much faster the second
    (and subsequent) time around because there is no analysis to perform. As an added
    bonus, IDA restores your IDA desktop to the same state it was in at the time it
    was closed.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the bad news. Believe or not, IDA crashes on occasion. Whether because
    of a bug in IDA itself or because of a bug in some bleeding-edge plug-in you have
    installed, crashes leave open databases in a potentially corrupt state. Once you
    restart IDA and attempt to reopen the affected database, you are likely to see
    one of the dialogs shown in [Figure 4-7](ch04s02.html#database_restore_dialog
    "Figure 4-7. Database Restore dialog") and [Figure 4-8](ch04s02.html#database_repair_dialog
    "Figure 4-8. Database Repair dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![Database Restore dialog](httpatomoreillycomsourcenostarchimages854085.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7. Database Restore dialog
  prefs: []
  type: TYPE_NORMAL
- en: When IDA crashes, there is no opportunity for IDA to close the active database,
    and the intermediate database files do not get deleted. If this was not the first
    time that you were working with a particular database, you may have a situation
    in which both an IDB file and potentially corrupt intermediate files are present
    at the same time. The IDB file represents the last-known good state of the database,
    while the intermediate files contain any changes that may have been made since
    the last save operation. In this case, you will be offered the choice to revert
    to the saved version or resume use of the open, potentially corrupt version, as
    shown in [Figure 4-7](ch04s02.html#database_restore_dialog "Figure 4-7. Database
    Restore dialog"). Choosing Continue with Unpacked Base by no means guarantees
    that you will recover your work. The unpacked database is probably in an inconsistent
    state, which will prompt IDA to offer the dialog shown in [Figure 4-8](ch04s02.html#database_repair_dialog
    "Figure 4-8. Database Repair dialog"). In this case, IDA itself recommends that
    you consider restoring from the packed data, so consider yourself warned if you
    opt to go with a repaired database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Database Repair dialog](httpatomoreillycomsourcenostarchimages854087.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8. Database Repair dialog
  prefs: []
  type: TYPE_NORMAL
- en: When an active database has never been saved, thus leaving only intermediate
    files present at the time of the crash, IDA offers the repair option in [Figure 4-8](ch04s02.html#database_repair_dialog
    "Figure 4-8. Database Repair dialog") as soon as you try to open the original
    executable file again.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#CHP-4-FN-4)]) Stack frames are discussed further in [Chapter 6](ch06.html
    "Chapter 6. Disassembly Navigation").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[33](#CHP-4-FN-5)]) Unless you happen to be opening *rocket_science.idb*.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the IDA Desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the amount of time you are likely to spend staring at your IDA desktop,
    you will want to spend some time familiarizing yourself with its various components.
    [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The IDA desktop") shows
    an overview of a default IDA desktop. The behavior of the desktop during file
    analysis is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Areas of interest in this introductory view include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The *toolbar area* ![](httpatomoreillycomsourcenostarchimages854061.png) contains
    tools corresponding to the most commonly used IDA operations. Toolbars are added
    to and removed from the desktop using the View ▸ Toolbars command. Using drag-and-drop,
    you can reposition each of the toolbars to suit your needs. [Figure 4-9](ch04s03.html#the_ida_desktop
    "Figure 4-9. The IDA desktop") shows IDA’s basic mode toolbar with a single row
    of tool buttons. An advanced mode toolbar is available using View ▸ Toolbars ▸
    Advanced mode. The Advanced mode toolbars contain three full rows of tool buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![The IDA desktop](httpatomoreillycomsourcenostarchimages854089.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4-9. The IDA desktop
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The horizontal color band is IDA’s *overview navigator* ![](httpatomoreillycomsourcenostarchimages854063.png),
    also called the *navigation band*. The navigation band presents a linear view
    of the address space of the loaded file. By default, the entire address range
    of the binary is represented. You can zoom in and out of the address range by
    right-clicking anywhere within the navigation band and selecting one of the available
    zoom options. Different colors represent different types of file content, such
    as data or code. A small *current position indicator* (yellow by default) points
    at the navigation band address that corresponds to the current address range being
    displayed in the disassembly window. Hovering the mouse cursor over any portion
    of the navigation band yields a tool tip that describes that location in the binary.
    Clicking the navigation band jumps the disassembly view to the selected location
    within the binary. The colors used in the navigation band can be customized using
    the Options ▸ Colors command. Dragging the navigation band away from the IDA desktop
    yields a detached Overview Navigator, as shown in [Figure 4-10](ch04s03.html#the_overview_navigator
    "Figure 4-10. The Overview Navigator"). Also shown in [Figure 4-10](ch04s03.html#the_overview_navigator
    "Figure 4-10. The Overview Navigator") is the current position indicator (the
    half-length, downward-facing arrow to the left of location ![](httpatomoreillycomsourcenostarchimages854061.png))
    and a *color key* identifying the file content by functional groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![The Overview Navigator](httpatomoreillycomsourcenostarchimages854091.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4-10. The Overview Navigator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Coming back to [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The IDA
    desktop"), *tabs* ![](httpatomoreillycomsourcenostarchimages854093.png) are provided
    for each of the currently open data displays. Data displays contain information
    extracted from the binary and represent the various views into the database. The
    majority of your analysis work is likely to take place through interaction with
    the available data displays. [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The
    IDA desktop") shows three of the available data displays: IDA-View, Functions,
    and Graph Overview. Additional data displays are available via the View ▸ Open
    Subviews menu, and this menu is also used to restore any displays that have been
    closed, whether on purpose or inadvertently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *disassembly view* ![](httpatomoreillycomsourcenostarchimages854095.png)
    is the primary data display. Two display styles are available for the disassembly
    view: graph view (default) and listing view. In graph view, IDA displays a flowchart-style
    graph of a single function at any given time. When this is combined with the *graph
    overview*, you can gain an understanding of the flow of the function using a visual
    breakdown of the function’s structure. When the IDA-View window is active, the
    spacebar toggles between graph view–style and listing-style displays. If you wish
    to make listing view your default, you must uncheck Use graph view by default
    on the Graph tab via the Options ▸ General menu, as shown in [Figure 4-11](ch04s03.html#ida_graph_options
    "Figure 4-11. IDA graph options").'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![IDA graph options](httpatomoreillycomsourcenostarchimages854097.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4-11. IDA graph options
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In graph view, it is seldom possible to fit the entire graph of a function into
    the display area at one time. The *graph overview* ![](httpatomoreillycomsourcenostarchimages854099.png),
    present only when graph view is active, provides a zoomed-out snapshot of the
    basic graph structure. A dotted rectangle indicates the current display within
    the graph view. Clicking within the graph overview repositions the graph view
    accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *Output window* ![](httpatomoreillycomsourcenostarchimages854101.png) is
    where you can expect to find any informational messages generated by IDA. Here
    you will find status messages concerning the progress of the file-analysis phase,
    along with any error messages resulting from user-requested operations. The Output
    window roughly equates to a console output device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *Functions window* ![](httpatomoreillycomsourcenostarchimages854103.png)
    rounds out the default IDA display windows and will be discussed further in [Chapter 5](ch05.html
    "Chapter 5. IDA Data Displays").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Desktop Behavior During Initial Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tremendous amount of activity takes place within the IDA desktop during the
    initial autoanalysis of a newly opened file. You can gain an understanding of
    this analysis by observing various desktop displays during the analysis process.
    Desktop activity you may observe includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Progress messages printed to the Output window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial location and disassembly output generated for the disassembly window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial population of the Functions window, followed by periodic updates as
    the analysis progresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation of the navigation band as new areas of the binary are recognized
    as code and data, blocks of code are further recognized as functions, and, finally,
    functions are recognized specifically as library code using IDA’s pattern-matching
    techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current position indicator traversing the navigation band to show the regions
    currently being analyzed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following output is representative of messages generated by IDA during the
    initial analysis of a newly opened binary file. Notice that the messages form
    a narrative of the analysis process and offer insight into the sequence of operations
    performed by IDA during that analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Two particularly helpful progress messages are `You may start to explore the
    input file right now` ![](httpatomoreillycomsourcenostarchimages854061.png) and
    `The initial autoanalysis has been finished` ![](httpatomoreillycomsourcenostarchimages854063.png).
    The first message informs you that IDA has made enough progress with its analysis
    that you can begin navigating through the various data displays. Navigating does
    not imply changing, however, and you should wait to make any changes to the database
    until the analysis phase has been completed. If you attempt to change the database
    prior to completion of the analysis phase, the analysis engine may come along
    later and modify your changes further, or you may even prevent the analysis engine
    from doing its job correctly. The second of these messages, which is fairly self-explanatory,
    indicates that you can expect no more automatic changes to take place in the desktop
    data displays. At this point it is safe to make any changes you like to the database.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Desktop Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IDA offers a tremendous amount of information, and its desktop can become cluttered.
    Here are some tips for making the best use of your desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: The more screen real estate you dedicate to IDA, the happier you will be. Use
    this fact to justify the purchase of a king-size monitor (or two)!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t forget the View ▸ Open Subviews command as a means of restoring data displays
    that you have inadvertently closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows ▸ Reset Desktop command offers a useful way to quickly restore your
    desktop to its original layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the Windows ▸ Save Desktop command to save a current layout of desktop
    configurations that you find particularly useful. The Windows ▸ Load Desktop command
    is used to quickly revert to a saved layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only window for which the display font can be changed is the Disassembly
    window (either graph or listing view). Fonts are set using the Options ▸ Font
    command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting Bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any piece of software, IDA has been known to contain an occasional bug,
    so what can you expect from Hex-Rays if you think you have found a bug in IDA
    itself? First, Hex-Rays has one of the most responsive support systems you can
    will ever deal with. Second, don’t be surprised if you hear back from Ilfak himself
    within a day of submitting a support request.
  prefs: []
  type: TYPE_NORMAL
- en: Two methods are available for submitting bug reports. You can send email to
    [support@hex-rays.com](mailto:support@hex-rays.com), or if you prefer not to use
    email, you may post to the Bug Reports forum on the Hex-Rays bulletin boards.
    In either case, you should both verify that you can reproduce your bug and be
    prepared to provide Hex-Rays with a copy of the database file involved with the
    problem. Recall that Hex-Rays only provides SDK support for an additional fee.
    For bugs related to a plug-in that you have installed, you will need to contact
    the plug-in’s author. For bugs related to a plug-in that you are developing, you
    will need to take advantage of the support forums available for IDA users and
    hope for a helpful response from a fellow user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Familiarity with the IDA workspace will greatly enhance your experience with
    IDA. Reverse engineering binary code is difficult enough without having to struggle
    with your tools. The options that you choose during the initial loading phase
    and the subsequent autoanalysis performed by IDA set the stage for all of the
    analysis that you will do later. At this point you may be content with the work
    that IDA has accomplished on your behalf, and for simple binaries, autoanalysis
    may be all that you need. On the other hand, if you wonder what puts the *interactive*
    in IDA, you are now ready to dive deeper into the functionality of IDA’s many
    data displays. In the coming chapters you will be introduced to each of the primary
    displays, the circumstances under which you will find each one useful, and how
    to utilize these displays to enhance and update your databases.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. IDA Data Displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point you should have some confidence loading binaries into IDA and
    letting IDA work its magic while you sip your favorite beverage. Once IDA’s initial
    analysis phase is complete, it is time for you to take control. One of the best
    ways for you to familiarize yourself with IDA’s displays is simply to browse around
    the various tabbed subwindows that IDA populates with data about your binary.
    The efficiency and effectiveness of your reverse engineering sessions will improve
    as your comfort level with IDA increases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the major IDA subdisplays, it is useful to cover a few
    basic rules concerning IDA’s user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '**There is no undo in IDA**.'
  prefs: []
  type: TYPE_NORMAL
- en: If something unexpected happens to your database as a result of an inadvertent
    keypress, you are on your own to restore your displays to their previous states.
  prefs: []
  type: TYPE_NORMAL
- en: '**Almost all actions have an associated menu item, hotkey, and toolbar button**.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the IDA toolbar is highly configurable, as is the mapping of hotkeys
    to menu actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**IDA offers good, context-sensitive menu actions in response to right mouse
    clicks**.'
  prefs: []
  type: TYPE_NORMAL
- en: While these menus do not offer an exhaustive list of permissible actions at
    a given location, they do serve as good reminders for the most common actions
    you will be performing.
  prefs: []
  type: TYPE_NORMAL
- en: With these facts in mind, let’s begin our coverage of the principal IDA data
    displays.
  prefs: []
  type: TYPE_NORMAL
- en: The Principal IDA Displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its default configuration, IDA creates seven (as of version 6.1) display
    windows during the initial loading-and-analysis phase for a new binary. Each of
    these display windows is accessible via a set of title tabs displayed immediately
    beneath the navigation band (shown previously in [Figure 4-9](ch04s03.html#the_ida_desktop
    "Figure 4-9. The IDA desktop")). The three immediately visible windows are the
    IDA-View window, the Functions window, and the Output window. Whether or not they
    are open by default, all of the windows discussed in this chapter can be opened
    via the View ▸ Open Subviews menu. Keep this fact in mind, as it is fairly easy
    to inadvertently close the display windows.
  prefs: []
  type: TYPE_NORMAL
- en: The esc key is one of the more useful hotkeys in all of IDA. When the disassembly
    window is active, the esc key functions in a manner similar to a web browser’s
    back button and is therefore very useful in navigating the disassembly display
    (navigation is covered in detail in [Chapter 6](ch06.html "Chapter 6. Disassembly
    Navigation")). Unfortunately, when any other window is active, the esc key serves
    to close the window. Occasionally, this is exactly what you want. At other times,
    you will immediately wish you had that closed window back.
  prefs: []
  type: TYPE_NORMAL
- en: The Disassembly Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also known as the IDA-View window, the disassembly window will be your primary
    tool for manipulating and analyzing binaries. Accordingly, it is important that
    you become intimately familiar with the manner in which information is presented
    in the disassembly window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two display formats are available for the disassembly window: the default graph-based
    view and a text-oriented listing view. Most IDA users tend to prefer one view
    over the other, and the view that better suits your needs is often determined
    by how you prefer to visualize a program’s flow. If you prefer to use the text
    listing view as your default disassembly view, you can change the default by using
    the Options ▸ General dialog to turn off Use graph view by default on the Graph
    tab. Whenever the disassembly view is active, you can easily switch between graph
    and listing views at any time by using the spacebar.'
  prefs: []
  type: TYPE_NORMAL
- en: IDA Graph View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.html#ida_graph_view-id1 "Figure 5-1. IDA graph view") shows
    a very simple function displayed in graph view. Graph views are somewhat reminiscent
    of program flowcharts in that a function is broken up into basic blocks^([[34](#ftn.CHP-5-FN-1)])
    so you can visualize the function’s control flow from one block to another.'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDA graph view](httpatomoreillycomsourcenostarchimages854105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1. IDA graph view
  prefs: []
  type: TYPE_NORMAL
- en: 'Onscreen, you’ll notice IDA uses different colored arrows to distinguish various
    types of flows^([[35](#ftn.CHP-5-FN-2)]) between the blocks of a function. Basic
    blocks that terminate with a conditional jump generate two possible flows depending
    on the condition being tested: the *Yes edge* arrow (yes, the branch is taken)
    is green by default, and the *No edge* arrow (no, the branch is not taken) is
    red by default. Basic blocks that terminate with only one potential successor
    block utilize a *Normal edge* (blue by default) to point to the next block to
    be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: In graph mode, IDA displays one function at a time. For users with a wheel mouse,
    graph zooming is possible using the ctrl- wheel combination. Keyboard zoom control
    requires ctrl-+ to zoom in or ctrl- − to zoom out (using the + and − keys on the
    numeric keypad). Large or complex functions may cause the graph view to become
    extremely cluttered, making the graph difficult to navigate. In such cases, the
    Graph Overview window (see [Figure 5-2](ch05.html#the_graph_overview_window "Figure 5-2. The
    Graph Overview window")) is available to provide some situational awareness. The
    overview window always displays the complete block structure of the graph along
    with a dashed frame that indicates the region of the graph currently being viewed
    in the disassembly window. The dashed frame can be dragged across the overview
    window to rapidly reposition the graph view to any desired location on the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Graph Overview window](httpatomoreillycomsourcenostarchimages854107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. The Graph Overview window
  prefs: []
  type: TYPE_NORMAL
- en: 'With the graph display, there are several ways that you can manipulate the
    view to suit your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Panning**'
  prefs: []
  type: TYPE_NORMAL
- en: First, in addition the using the Graph Overview window to rapidly reposition
    the graph, you can also reposition the graph by clicking and dragging the background
    of the graph view.
  prefs: []
  type: TYPE_NORMAL
- en: HEY, ISN’T SOMETHING MISSING HERE?
  prefs: []
  type: TYPE_NORMAL
- en: When using graph view, it may seem as if less information is available to you
    about each line of the disassembly. The reason for this is that IDA chooses to
    hide many of the more traditional pieces of information about each disassembled
    line (such as virtual address information) in order to minimize the amount of
    space required to display each basic block. You can choose to display additional
    information with each disassembly line by choosing among the available *disassembly
    line parts* accessible via the *Disassembly* tab from Options ▸ General. For example,
    to add virtual addresses to each disassembly line, we enable *line prefixes*,
    transforming the graph from [Figure 5-1](ch05.html#ida_graph_view-id1 "Figure 5-1. IDA
    graph view") into the graph shown in [Figure 5-3](ch05.html#graph_view_with_line_prefixes_enabled
    "Figure 5-3. Graph view with line prefixes enabled").
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph view with line prefixes enabled](httpatomoreillycomsourcenostarchimages854109.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3. Graph view with line prefixes enabled
  prefs: []
  type: TYPE_NORMAL
- en: '**Rearranging blocks**'
  prefs: []
  type: TYPE_NORMAL
- en: Individual blocks within the graph can be dragged to new positions by clicking
    the title bar for the desired block and dragging it to a new position. Beware
    that IDA performs only minimal rerouting of any edges associated with a moved
    block. You can manually reroute edges by dragging vertices to new locations. New
    vertices can be introduced into an edge by double-clicking the desired location
    within an edge while holding the shift key. If at any point you find yourself
    wishing to revert to the default layout for your graph, you can do so by right-clicking
    the graph and choosing Layout Graph.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grouping and collapsing blocks**'
  prefs: []
  type: TYPE_NORMAL
- en: Blocks can be grouped, either individually or together with other blocks, and
    collapsed to reduce the clutter in the display. Collapsing blocks is a particularly
    useful technique for keeping track of blocks that you have already analyzed. You
    can collapse any block by right-clicking the block’s title bar and selecting Group
    Nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating additional disassembly windows**'
  prefs: []
  type: TYPE_NORMAL
- en: If you ever find yourself wanting to view graphs of two functions simultaneously,
    all you need to do is open another disassembly window using Views ▸ Open Subviews
    ▸ Disassembly. The first disassembly window opened is titled *IDA View-A*. Subsequent
    disassembly windows are titled *IDA View-B*, *IDA View-C*, and so on. Each disassembly
    is independent of the other, and it is perfectly acceptable to view a graph in
    one window while viewing a text listing in another or to view three different
    graphs in three different windows.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that your control over the view extends beyond just these examples.
    Additional IDA graphing capabilities are covered in [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing"), while more information on the manipulation of IDA’s graph view
    is available in the IDA help file.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Text View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The text-oriented disassembly window is the traditional display used for viewing
    and manipulating IDA-generated disassemblies. The text display presents the entire
    disassembly listing of a program (as opposed to a single function at a time in
    graph mode) and provides the only means for viewing the data regions of a binary.
    All of the information available in the graph display is available in the text
    display in one form or another.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](ch05.html#the_ida_text_view "Figure 5-4. The IDA text view") shows
    the text view listing of the same function shown in [Figure 5-1](ch05.html#ida_graph_view-id1
    "Figure 5-1. IDA graph view") and [Figure 5-3](ch05.html#graph_view_with_line_prefixes_enabled
    "Figure 5-3. Graph view with line prefixes enabled"). The disassembly is presented
    in linear fashion, with virtual addresses displayed by default. Virtual addresses
    are typically displayed in a `[SECTION NAME]:[VIRTUAL ADDRESS]` format such as
    `.text:004011C1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The IDA text view](httpatomoreillycomsourcenostarchimages854111.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4. The IDA text view
  prefs: []
  type: TYPE_NORMAL
- en: The left portion of the display, seen at ![](httpatomoreillycomsourcenostarchimages854061.png),
    is called the *arrows window* and is used to depict nonlinear flow within a function.
    Solid arrows represent unconditional jumps, while dashed arrows represent conditional
    jumps. When a jump (conditional or unconditional) transfers control to an earlier
    address in the program, a heavy weighted line (solid or dashed) is used. Such
    reverse flow in a program often indicates the presence of a loop. In [Figure 5-4](ch05.html#the_ida_text_view
    "Figure 5-4. The IDA text view"), a loop arrow flows from address `004011CF` to
    `004011C5`.
  prefs: []
  type: TYPE_NORMAL
- en: The declarations at ![](httpatomoreillycomsourcenostarchimages854063.png) (also
    present in graph view) represent IDA’s best estimate concerning the layout of
    the function’s stack frame.^([[36](#ftn.CHP-5-FN-3)]) IDA computes the structure
    of a function’s stack frame by performing detailed analysis of the behavior of
    the stack pointer and any stack frame pointer used within a function. Stack displays
    are discussed further in [Chapter 6](ch06.html "Chapter 6. Disassembly Navigation").
  prefs: []
  type: TYPE_NORMAL
- en: The comments (a semicolon introduces a comment) at ![](httpatomoreillycomsourcenostarchimages854093.png)
    are *cross-references*. In this case we see code cross-references (as opposed
    to data cross-references), which indicate that another program instruction transfers
    control to the location containing the cross-reference comment. Cross-references
    are the subject of [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing").
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of the book we will primarily utilize the text display for
    examples. We’ll use the graph display only in cases where it may provide significantly
    more clarity. In [Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation")
    we will cover the specifics of manipulating the text display in order to clean
    up and annotate a disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: The Functions Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Functions window is used to list every function that IDA has recognized
    in the database. A Functions window entry might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This particular line indicates that the `malloc` function can be found in the
    `.text` section of the binary at virtual address `00BDC260`, is 384 bytes (hex
    180) long, returns to the caller (`R`), and uses the EBP register (`B`) to reference
    its local variables. Flags used to describe a function (such as `R` and `B` above)
    are described in IDA’s built-in help file (or by right-clicking a function and
    choosing Properties. The flags are shown as editable checkboxes in the resulting
    Properties dialog).
  prefs: []
  type: TYPE_NORMAL
- en: As with other display windows, double-clicking an entry in the Functions window
    causes the disassembly window to jump to the location of the selected function.
  prefs: []
  type: TYPE_NORMAL
- en: The Output Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Output window at the bottom of the IDA workspace rounds out the default
    set of windows that are visible when a new file is opened. The Ouput window serves
    as IDA’s output console and is the place to look for information on tasks IDA
    is performing. When a binary is first opened, for example, messages are generated
    to indicate both what phase of analysis IDA is in at any given time and what actions
    IDA is carrying out to create the new database. As you work with a database, the
    Output window is used to output the status of various operations that you perform.
    The contents of the Output window can be copied to the system clipboard or cleared
    entirely by right-clicking anywhere in the window and selecting the appropriate
    operation. The Output window will often be the primary means by which you display
    output from any scripts and plug-ins that you develop for IDA.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#CHP-5-FN-1)]) A *basic block* is a maximal sequence of instructions
    that executes, without branching, from beginning to end. Each basic block therefore
    has a single entry point (the first instruction in the block) and a single exit
    point (the last instruction in the block). The first instruction in a basic block
    is often the target of a branching instruction, while the last instruction in
    a basic block is often a branch instruction.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[35](#CHP-5-FN-2)]) IDA uses the term *flow* to indicate how execution can
    continue from a given instruction. A *normal* (also called *ordinary*) flow indicates
    default sequential execution of instructions. A *jump* flow indicates that the
    current instruction jumps (or may jump) to a nonsequential location. A *call*
    flow indicates that the current instruction calls a subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[36](#CHP-5-FN-3)]) A *stack frame* (or *activation record*) is a block of
    memory, allocated in a program’s runtime stack, that contains both the parameters
    passed into a function and the local variables declared within the function. Stack
    frames are allocated upon entry into a function and released as the function exits.
    Stack frames are discussed in more detail in [Chapter 6](ch06.html "Chapter 6. Disassembly
    Navigation").
  prefs: []
  type: TYPE_NORMAL
- en: Secondary IDA Displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the disassembly, Functions, and Output windows, IDA opens a number
    of other tabbed windows on your IDA desktop. These tabs are present just under
    the navigation band (see ![](httpatomoreillycomsourcenostarchimages854093.png)
    in [Figure 4-9](ch04s03.html#the_ida_desktop "Figure 4-9. The IDA desktop")).
    These windows are used to provide alternate or specialized views into the database.
    The utility of these displays depends on both the characteristics of the binary
    you are analyzing and your skill with IDA. Several of these windows are sufficiently
    specialized to require more detailed coverage in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The Hex View Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hex View is something of a misnomer in this case, as the IDA Hex View window
    can be configured to display a variety of formats and doubles as a hex editor.
    By default, the Hex View window provides a standard hex dump of the program content
    with 16 bytes per line and ASCII equivalents displayed alongside. As with the
    disassembly window, several hex views can be opened simultaneously. The first
    Hex window is titled *Hex View-A*, the second *Hex View-B*, the next *Hex View-C*,
    and so on. By default, the first Hex window is synchronized with the first disassembly
    window. When a disassembly view is synchronized with a hex view, scrolling in
    one window causes the other window to scroll to the same location (same virtual
    address). In addition, when an item is selected in disassembly view, the corresponding
    bytes are highlighted in hex view. In [Figure 5-5](ch05s02.html#synchronized_hex_and_disassembly_views
    "Figure 5-5. Synchronized hex and disassembly views"), the disassembly view cursor
    is positioned at address `0040108C`, a call instruction, causing the five bytes
    that make up the instruction to be highlighted in the Hex window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Synchronized hex and disassembly views](httpatomoreillycomsourcenostarchimages854113.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5. Synchronized hex and disassembly views
  prefs: []
  type: TYPE_NORMAL
- en: Also shown in [Figure 5-5](ch05s02.html#synchronized_hex_and_disassembly_views
    "Figure 5-5. Synchronized hex and disassembly views") is the hex display context
    menu, available when you right-click anywhere within the hex display. This context
    menu is where you may specify with which, if any, disassembly view you would like
    to synchronize a particular hex display. Deselecting the synchronization option
    allows a Hex window to be scrolled independently of any disassembly window. Selecting
    the Edit menu option turns the Hex View into a hex editor. Once you are finished
    editing, you must either commit or cancel your changes in order to return to view
    mode. The Data Format menu item allows you to select from a variety of display
    formats such as 1-, 2-, 4-, or 8-byte hexadecimal; signed decimal; or unsigned
    decimal integers and various floating point formats. The Columns menu option allows
    you to change the number of columns used in the display, and the Text option allows
    you to turn the text dump on and off.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases you may find that the Hex window shows nothing but question marks.
    This is IDA’s way of telling you that it has no idea what values might occupy
    a given virtual address range. Such is the case when a program contains a bss^([[37](#ftn.CHP-5-FN-4)])
    section, which typically occupies no space within a file but is expanded by the
    loader to accommodate the program’s static storage requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The Exports Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Exports window lists the entry points into a file. These include the program’s
    execution entry point, as specified in its header section, along with any functions
    and variables that the file exports for use by other files. Exported functions
    are commonly found in shared libraries such as Windows DLL files. Exported entries
    are listed by name, virtual address, and, if applicable, by ordinal number.^([[38](#ftn.CHP-5-FN-5)])
    For executable files, the Exports window always contains at least one entry: the
    program’s execution entry point. IDA names this entry point `start`. A typical
    Exports window entry follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As with many of the other IDA windows, double-clicking an entry in the Exports
    window will jump the disassembly window to the address associated with that entry.
    The Exports window offers functionality available in command-line tools such as
    `objdump` (`-T`), `readelf (-s`), and `dumpbin` (`/EXPORTS`).
  prefs: []
  type: TYPE_NORMAL
- en: The Imports Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Imports window is a counterpart to the Exports window. It lists all functions
    that are imported by the binary being analyzed. The Imports window is relevant
    only when a binary makes use of shared libraries. Statically linked binaries have
    no external dependencies and therefore no imports. Each entry in the Imports window
    lists the name of an imported item (function or data) and the name of the library
    that contains that item. Since the code for an imported function resides in a
    shared library, the addresses listed with each entry refer to the virtual address
    of the associated import table entry.^([[39](#ftn.CHP-5-FN-6)]) An example of
    an Import window entry is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Double-clicking this import would jump the disassembly window to address `0040E108`.
    The contents of this memory location in hex view would be `?? ?? ?? ??`. IDA is
    a static analysis tool, and it has no way to know what address will be entered
    into this memory location when the program is executed. The Imports window also
    offers functionality available in command-line tools such as `objdump` (`-T`),
    `readelf` (`-s`), and `dumpbin` (`/IMPORTS`).
  prefs: []
  type: TYPE_NORMAL
- en: An important point to remember about the Imports window is that it displays
    only the symbols that a binary wants handled automatically by the dynamic loader.
    Symbols that a binary chooses to load on its own using a mechanism such as `dlopen/dlsym`
    or `LoadLibrary/GetProcAddress` will not be listed in the Imports window.
  prefs: []
  type: TYPE_NORMAL
- en: The Structures Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Structures window is used to display the layout of any complex data structures,
    such as C structs or unions, that IDA determines are in use within a binary. During
    the analysis phase, IDA consults its extensive library of function-type signatures
    in an attempt to match function parameter types to memory used within the program.
    The Structures window shown in [Figure 5-6](ch05s02.html#the_structures_window-id1
    "Figure 5-6. The Structures window") indicates that IDA believes the program uses
    the `sockaddr`^([[40](#ftn.CHP-5-FN-7)]) data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Structures window](httpatomoreillycomsourcenostarchimages854115.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6. The Structures window
  prefs: []
  type: TYPE_NORMAL
- en: There are many possible reasons why IDA may have arrived at this conclusion.
    One such reason might be that IDA has observed a call to the C library `connect`^([[41](#ftn.CHP-5-FN-8)])
    function to establish a new network connection. Double-clicking the name of a
    data structure (`sockaddr` in this case) causes IDA to expand the structure, and
    this allows you to see the detailed layout of the structure, including individual
    field names and sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The two primary uses for the Structures window are (1) to provide a ready reference
    for the layout of standard data structures and (2) to provide you with a means
    to create your own data structures for use as memory layout templates when you
    discover custom data structures within a program. Structure definition and the
    application of structures within disassemblies are covered in more detail in [Chapter 8](ch08.html
    "Chapter 8. Datatypes and Data Structures").
  prefs: []
  type: TYPE_NORMAL
- en: The Enums Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Enums window is somewhat similar to the Structures window. When IDA detects
    the use of a standard enumerated datatype (C `enum`), that datatype will be listed
    in the Enums window. You can make your disassemblies far more readable by using
    enums in place of integer constants. Like the Structures window, the Enums window
    offers facilities for defining your own enumerated types that you can use with
    your disassembled binaries.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[37](#CHP-5-FN-4)]) A *bss* section is created by a compiler to house all
    of a program’s uninitialized, static variables. Since no initial value is assigned
    to these variables, there is no need to allocate space for them in the program’s
    file image, so the section’s size is noted in one of the program’s headers. When
    the program is executed, the loader allocates the required space and initializes
    the entire block to zero.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#CHP-5-FN-5)]) An export ordinal number may be used in a shared library
    to make a function accessible by number rather than name. The use of ordinals
    can speed the address lookup process and allow programmers to hide the names of
    their functions. Export ordinals are used in Windows DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[39](#CHP-5-FN-6)]) An import table provides space for a loader to store
    addresses of imported functions once the required libraries have been loaded and
    the addresses of those functions are known. A single import table entry holds
    the address of one imported function.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[40](#CHP-5-FN-7)]) A `sockaddr` structure is a datatype in the C standard
    library often used to represent an endpoint in a network connection. A `sockaddr`
    variable can be used to hold an IP address and port number as part of the process
    of establishing a TCP connection to a remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[41](#CHP-5-FN-8)]) `int connect(int sockfd, const struct sockaddr *serv_addr,
    socklen_t addrlen);`
  prefs: []
  type: TYPE_NORMAL
- en: Tertiary IDA Displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last windows that we will discuss are those that IDA does not open by default.
    Each of these windows is available via View ▸ Open Subviews, but they tend to
    provide information to which you may not require immediate access and are thus
    initially kept out of the way.
  prefs: []
  type: TYPE_NORMAL
- en: The Strings Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strings window is the built-in IDA equivalent of the `strings` utility and
    then some. In IDA versions 5.1 and earlier, the Strings window was open as part
    of the default desktop; however, with version 5.2, the Strings window is no longer
    open by default, though it remains available via View ▸ Open Subviews ▸ Strings.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the Strings window is to display a list of strings extracted
    from a binary along with the address at which each string resides. Like double-clicking
    names in the Names window, double-clicking any string listed in the Strings window
    causes the disassembly window to jump to the address of the selected string. When
    used with cross-references ([Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing")), the Strings window provides the means to rapidly spot an interesting
    string and to track back to any location in the program that references that string.
    For example, you might see the string *SOFTWARE\Microsoft\Windows\Current Version\Run*
    listed and wonder why an application is referencing this particular key within
    the Windows registry. As you will see in the following chapter, navigating to
    the program location that references this string takes only four clicks. Understanding
    the operation of the Strings window is essential to using it effectively. IDA
    does not permanently store the strings it extracts from a binary. Therefore, every
    time the Strings window is opened, the entire database must be scanned or rescanned
    for string content. String scanning is performed in accordance with the settings
    of the Strings window, and you can access these settings by right-clicking within
    the Strings window and selecting Setup. As shown in [Figure 5-7](ch05s03.html#the_setup_strings_window
    "Figure 5-7. The Setup Strings window"), the Setup Strings window is used to specify
    the types of strings that IDA should scan for. The default string type that IDA
    scans for is a C-style, null-terminated, 7-bit, ASCII string of at least five
    characters in length.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Setup Strings window](httpatomoreillycomsourcenostarchimages854117.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7. The Setup Strings window
  prefs: []
  type: TYPE_NORMAL
- en: 'If you expect to encounter anything other than C-style strings, you should
    reconfigure the Setup Strings window to choose the appropriate string type to
    search for. For example, Windows programs often make use of Unicode strings, while
    Borland Delphi binaries use Pascal-style strings with a 2-byte length. Every time
    you close the Setup Strings window by clicking OK, IDA will rescan the database
    for strings in accordance with the new settings. Two setup options deserve special
    mention:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Display only defined strings**'
  prefs: []
  type: TYPE_NORMAL
- en: This option restricts the Strings window to displaying only named string data
    items that have been automatically created by IDA or manually created by the user.
    With this option selected, all other options are disabled, and IDA will not automatically
    scan for additional string content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore instructions/data definitions**'
  prefs: []
  type: TYPE_NORMAL
- en: This option causes IDA to scan for strings across instruction and existing data
    definitions. Using this option allows IDA to (1) see strings that may be embedded
    in the code portion of a binary and have been mistakenly converted into instructions
    or (2) to see strings within data that may be formatted as something other than
    a string (such as an array of bytes or integers). This option will also lead to
    the generation of many *junk* strings, which are sequences that happen to consist
    of five or more ASCII characters whether or not they are legible. The effect of
    using this option is similar to using the `strings` command with the `-a` switch.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-8](ch05s03.html#example_of_undetected_string_data "Figure 5-8. Example
    of undetected string data") demonstrates that IDA does not necessarily show all
    strings within a binary if the strings setup is not configured properly. In this
    case, Ignore instructions/data definitions has not been selected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of undetected string data](httpatomoreillycomsourcenostarchimages854119.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8. Example of undetected string data
  prefs: []
  type: TYPE_NORMAL
- en: The result is that the string at location `.rdata:0040C19C` (“Please guess a
    number between 1 and %d.”) remains undetected. The moral here is to make sure
    that you are looking for all of the types of strings you expect to encounter in
    all of the places you might find them.
  prefs: []
  type: TYPE_NORMAL
- en: The Names Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Names window, shown in [Figure 5-9](ch05s03.html#the_names_window-id1 "Figure 5-9. The
    Names window"), provides a summary listing of all of the global names within a
    binary. A *name* is nothing more than a symbolic description given to a program
    virtual address. IDA initially derives the list of names from symbol-table and
    signature analysis during the initial loading of a file. Names can be sorted alphabetically
    or in virtual address order (either ascending or descending). The Names window
    is useful for rapidly navigating to known locations within a program listing.
    Double-clicking any Names window entry will immediately jump the disassembly view
    to display the selected name.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Names window](httpatomoreillycomsourcenostarchimages854121.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9. The Names window
  prefs: []
  type: TYPE_NORMAL
- en: 'Displayed names are both color and letter coded. The coding scheme is summarized
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **F** | A regular function. These are functions that IDA does not recognize
    as library functions. |'
  prefs: []
  type: TYPE_TB
- en: '| **L** | A library function. IDA recognizes library functions through the
    use of signature-matching algorithms. If a signature does not exist for a given
    library function, the function will be labeled as a regular function instead.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I** | An imported name, most commonly a function name imported from a shared
    library. The difference between this and a library function is that no code is
    present for an imported name, while the body of a library function will be present
    in the disassembly. |'
  prefs: []
  type: TYPE_TB
- en: '| **C** | Named code. These are named program instruction locations that IDA
    does not consider to be part of any function. This is possible when IDA finds
    a name in a program’s symbol table but never sees a `call` to the corresponding
    program location. |'
  prefs: []
  type: TYPE_TB
- en: '| **D** | Data. Named data locations typically represent global variables.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | String data. This is a referenced data location containing a sequence
    of characters that conform to one of IDA’s known string data types, such as a
    null-terminated ASCII C string. |'
  prefs: []
  type: TYPE_TB
- en: 'As you browse through disassemblies, you will notice that there are many named
    locations for which no name is listed in the Names window. In the process of disassembling
    a program, IDA generates names for all locations that are referenced directly
    either as code (a branch or call target) or as data (read, written, or address
    taken). If a location is named in the program’s symbol table, IDA adopts the name
    from the symbol table. If no symbol table entry is available for a given program
    location, IDA generates a default name for use in the disassembly. When IDA chooses
    to name a location, the virtual address of the location is combined with a prefix
    that indicates what type of location is being named. Incorporating the virtual
    address into a generated name ensures that all generated names will be unique,
    as no two locations can share the same virtual address. Autogenerated names of
    this type are not displayed in the Names window. Some of the more common prefixes
    used for autogenerated names include these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`sub_`****``*`xxxxxx`*``** | A subroutine at address *`xxxxxx`* |'
  prefs: []
  type: TYPE_TB
- en: '| **`loc_`****``*`xxxxxx`*``** | An instruction location at address *`xxxxxx`*
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`byte_`****``*`xxxxxx`*``** | 8-bit data at location *`xxxxxx`* |'
  prefs: []
  type: TYPE_TB
- en: '| **`word_`****``*`xxxxxx`*``** | 16-bit data at location *`xxxxxx`* |'
  prefs: []
  type: TYPE_TB
- en: '| **`dword_`****``*`xxxxxx`*``** | 32-bit data at location *`xxxxxx`* |'
  prefs: []
  type: TYPE_TB
- en: '| **`unk_`****``*`xxxxxx`*``** | Data of unknown size at location *`xxxxxx`*
    |'
  prefs: []
  type: TYPE_TB
- en: Throughout the course of the book we will show additional algorithms that IDA
    applies in choosing names for program data locations.
  prefs: []
  type: TYPE_NORMAL
- en: The Segments Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Segments window displays a summary listing of the segments present in the
    binary file. Note that what IDA terms *segments* are most often called *sections*
    when discussing the structure of binary files. Do not confuse the use of the term
    *segments* in this manner with the memory segments associated with CPUs that implement
    a segmented memory architecture. Information presented in the window includes
    the segment name, start and end addresses, and permission flags. The start and
    end addresses represent the virtual address range to which the program sections
    will be mapped at runtime. The following listing is an example of Segments window
    content from a Windows binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we might quickly suspect that something is funny with this particular
    binary since it uses nonstandard segment names and has two executable segments
    that are writable, thus indicating the possibility of self-modifying code (more
    on this in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis")). The
    fact that IDA knows the size of a segment does not indicate that IDA knows the
    contents of the segment. For a variety of reasons, segments often occupy less
    space on disk than they do in memory. In such cases, IDA displays values for the
    portions of the segment that IDA has determined it could fill from the disk file.
    For the remainder of the segment, IDA displays question marks.
  prefs: []
  type: TYPE_NORMAL
- en: Double-clicking any entry in the window jumps the disassembly view to the start
    of the selected segment. Right-clicking an entry provides a context menu from
    which you can add new segments, delete existing segments, or edit the properties
    of existing segments. These features are particularly useful when reverse engineering
    files with nonstandard formats, as the binary’s segment structure may not have
    been detected by the IDA loader.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line counterparts to the Segments window include `objdump` (`-h`), `readelf`
    (`-S`), and `dumpbin` (`/HEADERS`).
  prefs: []
  type: TYPE_NORMAL
- en: The Signatures Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA makes use of an extensive library of signatures for identifying known blocks
    of code. Signatures are used to identify common compiler-generated startup sequences
    in an attempt to determine the compiler that may have been used to build a given
    binary. Signatures are also used to categorize functions as known library functions
    inserted by a compiler or as functions added to the binary as a result of static
    linking. When IDA identifies library functions for you, you can focus more of
    your effort on the code that IDA did not recognize (which is probably far more
    interesting to you than reverse engineering the inner workings of `printf`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Signatures window is used to list the signatures that IDA has already matched
    against the open binary file. An example from a Windows PE file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example indicates that IDA has applied the `vc32rtf` signatures (from *<IDADIR>/sigs*)
    against the binary and, in doing so, has been able to recognize 501 functions
    as library functions. That’s 501 functions that you will not need to reverse engineer!
  prefs: []
  type: TYPE_NORMAL
- en: In at least two cases, you will want to know how to apply additional signatures
    against your binaries. In the first case, IDA may fail to recognize the compiler
    that was used to build a binary, with a resulting inability to select appropriate
    signatures to apply. In this case, you may wish to force IDA to apply one or more
    signatures that your preliminary analysis has led you to believe IDA should try.
    The second situation involves creating your own signatures for libraries that
    may not have existing signatures included with IDA. An example might be the creation
    of signatures for the static version of the OpenSSL libraries that ship with FreeBSD
    8.0\. DataRescue makes a toolkit available for generating custom signatures that
    can be used by IDA’s signature-matching engine. We’ll cover the generation of
    custom signatures in [Chapter 12](ch12.html "Chapter 12. Library Recognition Using
    FLIRT Signatures"). Regardless of why you want to apply new signatures, either
    pressing the insert key or right-clicking the Signatures window will offer you
    the Apply new signature option, at which time you can choose from a list of all
    signatures known to your installation of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: The Type Libraries Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar in concept to the Signatures window is the Type Libraries window. Type
    libraries represent IDA’s accumulated knowledge of predefined datatypes and function
    prototypes gleaned from header files included with most popular compilers. By
    processing header files, IDA understands the datatypes that are expected by common
    library functions and can annotate your disassemblies accordingly. Similarly,
    from these header files IDA understands both the size and layout of complex data
    structures. All of this type information is collected into TIL files (*<IDADIR>/til*)
    and applied any time a binary is analyzed. As with signatures, IDA must first
    be able to deduce the libraries that a program uses before it can select an appropriate
    set of TIL files to load. You can request that IDA load additional type libraries
    by pressing the insert key or by right-clicking within the Type Libraries window
    and choosing Load type library. Type libraries are covered in more detail in [Chapter 13](ch13.html
    "Chapter 13. Extending IDA’s Knowledge").
  prefs: []
  type: TYPE_NORMAL
- en: The Function Calls Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any program, a function can both call and be called by other functions. In
    fact, it is a fairly simple task to construct a graph that displays the relationships
    between callers and callees. Such a graph is called a *function call graph* or
    *function call tree* (we will demonstrate how to have IDA generate such graphs
    in [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing")). On occasion,
    we may not be interested in seeing the entire call graph of a program; instead,
    we may be interested only in knowing the immediate neighbors of a given function.
    For our purposes, we will call Y a neighbor of X if Y directly calls X or X directly
    calls Y.
  prefs: []
  type: TYPE_NORMAL
- en: The Function Calls window provides the answer to this neighbor question. When
    you open the Function Calls window, IDA determines the neighbors of the function
    in which the cursor is positioned and generates a display such as that shown in
    [Figure 5-10](ch05s03.html#the_function_calls_window-id1 "Figure 5-10. The Function
    Calls window").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Function Calls window](httpatomoreillycomsourcenostarchimages854123.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10. The Function Calls window
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we see that the function named `sub_40182C` is called from
    six different locations in `_main` and `_main` in turn makes 15 other function
    calls. Double-clicking any line within the Function Calls window immediately jumps
    the disassembly window to the selected calling or called function (or caller and
    callee). IDA cross-references (xrefs) are the mechanisms that underlie the generation
    of the Function Calls windows. Xrefs will be covered in more detail in [Chapter 9](ch09.html
    "Chapter 9. Cross-References and Graphing").
  prefs: []
  type: TYPE_NORMAL
- en: The Problems Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Problems window is IDA’s way of informing you of any difficulties that
    it has encountered in disassembling a binary and how it has chosen to deal with
    those difficulties. In some instances, you may be able to manipulate the disassembly
    to help IDA overcome a problem, and in other instances you may not. You can expect
    to encounter problems in even the simplest of binaries. In many cases, simply
    choosing to ignore the problems is not a bad strategy. In order to correct many
    of the problems, you need to have a better understanding of the binary than IDA
    has, which for most of us is probably not going to happen. A sample set of problems
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each problem is characterized by (1) the address at which the problem occurs,
    (2) the type of problem encountered, and (3) the instruction present at the problem
    location. In this example, we see a `BOUNDS` problem and a `DECISION` problem.
    A `BOUNDS` problem occurs when the destination of a `call` or `jump` either can’t
    be determined (as in this example, since the value of `eax` is unknown to IDA)
    or appears to lie outside the range of virtual addresses in a program. A `DECISION`
    problem is most often not a problem at all. A `DECISION` usually represents an
    address at which IDA has chosen to disassemble bytes as instructions rather than
    data even though the address has never been referenced during the recursive descent
    instruction traversal (see [Chapter 1](ch01.html "Chapter 1. Introduction to Disassembly")).
    A complete list of problem types and suggestions for how to deal with them is
    available in the built-in IDA help file (see topic *Problems List*).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, the number of displays that IDA offers can seem overwhelming.
    You may find it easiest to stick with the primary displays until you are comfortable
    enough to begin exploring the additional display offerings. In any case, you should
    certainly not feel obligated to use everything that IDA throws at you. Not every
    window will be useful in every reverse engineering scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the windows covered in this chapter, you will be confronted by
    a tremendous number of dialogs as you endeavor to master IDA. We will introduce
    key dialogs as they become relevant in the remainder of the book. Finally, other
    than the default disassembly view graph, we have elected not to cover graphs in
    this chapter. The IDA menu system distinguishes graphs as a separate category
    of display from the subviews discussed in this chapter. We will cover the reasons
    behind this in [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing"),
    which deals exclusively with graphs.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be starting to get comfortable with the IDA user interface.
    In the next chapter, we begin to focus on the many ways that you can manipulate
    a disassembly to enhance your understanding of its behavior and to generally make
    your life easier with IDA.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Disassembly Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this and the following chapter we cover the heart of what puts the *Interactive*
    in *IDA Pro*, which is, in a nutshell, ease of navigation and ease of manipulation.
    The focus of this chapter is navigation; specifically, we show how IDA facilitates
    moving around a disassembly in a logical manner. So far, we have shown that at
    a basic level IDA simply combines the features of many common reverse engineering
    tools into an integrated disassembly display. Navigating around the display is
    one of the essential skills required in order to master IDA. Static disassembly
    listings offer no inherent navigational capability other than scrolling up and
    down the listing. Even with the best text editors, such *dead listings* are very
    difficult to navigate, as the best they have to offer is generally nothing more
    than an integrated, `grep`-style search. As you shall see, IDA’s database underpinnings
    provide for exceptional navigational features.
  prefs: []
  type: TYPE_NORMAL
- en: Basic IDA Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your initial experience with IDA, you may be happy to make use of nothing
    more than the navigational features that IDA has to offer. In addition to offering
    fairly standard search features that you are accustomed to from your use of text
    editors or word processors, IDA develops and displays a comprehensive list of
    cross-references that behave in a manner similar to hyperlinks on a web page.
    The end result is that, in most cases, navigating to locations of interest requires
    nothing more than a double-click.
  prefs: []
  type: TYPE_NORMAL
- en: Double-Click Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a program is disassembled, every location in the program is assigned a
    virtual address. As a result, we can navigate anywhere within a program by providing
    the virtual address of the location we are interested in visiting. Unfortunately
    for us, maintaining a catalog of addresses in our head is not a trivial task.
    This fact motivated early programmers to assign symbolic names to program locations
    that they wished to reference, making things a whole lot easier on themselves.
    The assignment of symbolic names to program addresses was not unlike the assignment
    of mnemonic instruction names to program opcodes; programs became easier to read
    and write by making them easier to remember.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed previously, IDA generates symbolic names during the analysis
    phase by examining a binary’s symbol table or by automatically generating a name
    based on how a location is referenced within the binary. In addition to its symbolic
    purpose, any name displayed in the disassembly window is a potential navigation
    target similar to a hyperlink on a web page. The two differences between these
    names and standard hyperlinks are (1) that the names are never highlighted in
    any way to indicate that they can be followed and (2) that IDA requires a double-click
    to follow rather than the single-click required by a hyperlink. We have already
    seen the use of names in various subwindows such as the Functions, Imports, and
    Exports windows. Recall that for each of these windows, double-clicking a name
    caused the disassembly view to jump to the referenced location. This is one example
    of the double-click navigation at work. In the following listing, each of the
    symbols labeled ![](httpatomoreillycomsourcenostarchimages854061.png) represents
    a named navigational target. Double-clicking any of them will cause IDA to relocate
    the display to the selected location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For navigational purposes, IDA treats two additional display entities as navigational
    targets. First, cross-references (shown at ![](httpatomoreillycomsourcenostarchimages854063.png)
    here) are treated as navigational targets. Cross-references are generally formated
    as a name and a hex offset. The cross-reference at the right of `loc_40134E` in
    the previous listing refers to a location that is `4D[16]` or `77[10]` bytes beyond
    the start of `sub_4012E4`. Double-clicking the cross-reference text will jump
    the display to the referencing location (`00401331` in this case). Cross-references
    are covered in more detail in [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing").
  prefs: []
  type: TYPE_NORMAL
- en: The second type of display entity afforded special treatment in a navigational
    sense is one that uses hexadecimal values. If a displayed hexadecimal value represents
    a valid virtual address within the binary, then double-clicking the value will
    reposition the disassembly window to display the selected virtual address. In
    the listing that follows, double-clicking any of the values indicated by ![](httpatomoreillycomsourcenostarchimages854093.png)
    will jump the display, because each is a valid virtual address within the given
    binary, while double-clicking any of the values indicated by ![](httpatomoreillycomsourcenostarchimages854095.png)
    will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A final note about double-click navigation concerns the IDA Output window, which
    is most often used to display informational messages. When a navigational target,
    as previously described, appears as the first item in a message, double-clicking
    the message will jump the display to the indicated target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the Output window excerpt just shown, the two messages indicated by ![](httpatomoreillycomsourcenostarchimages854099.png)
    can be used to navigate to the addresses indicated at the start of the respective
    messages. Double-clicking any of the other messages, including those at ![](httpatomoreillycomsourcenostarchimages854101.png),
    will result in no action at all.
  prefs: []
  type: TYPE_NORMAL
- en: Jump to Address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, you will know exactly what address you would like to navigate
    to, yet no name will be handy in the disassembly window to offer simple double-click
    navigation. In such a case, you have a few options. The first, and most primitive,
    option is to use the disassembly window scroll bar to scroll the display up or
    down until the desired location comes into view. This is usually feasible only
    when the location you are navigating to is known by its virtual address, since
    the disassembly window is organized linearly by virtual address. If all you know
    is a named location such as a subroutine named `foobar`, then navigating via the
    scroll bar becomes something of a needle-in-a-haystack search. At that point,
    you might choose to sort the Functions window alphabetically, scroll to the desired
    name, and double-click the name. A third option is to use one of IDA’s search
    features available via the Search menu, which typically involves specifying some
    search criteria before asking IDA to perform a search. In the case of searching
    for a known location, this is usually overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the easiest way to get to a known disassembly location is to make
    use of the Jump to Address dialog shown in [Figure 6-1](ch06.html#the_jump_to_address_dialog
    "Figure 6-1. The Jump to Address dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Jump to Address dialog](httpatomoreillycomsourcenostarchimages854125.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. The Jump to Address dialog
  prefs: []
  type: TYPE_NORMAL
- en: The Jump to Address dialog is accessed via Jump ▸ Jump to Address, or by using
    the G hotkey while the disassembly window is active. Thinking of this dialog as
    the *Go* dialog may help you remember the associated hotkey. Navigating to any
    location in the binary is as simple as specifying the address (a name or hex value
    will do) and clicking OK, which will immediately jump the display to the desired
    location. Values entered into the dialog are remembered and made available on
    subsequent use via a drop-down list. This history feature makes returning to previously
    requested locations somewhat easier.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation History
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we compare IDA’s document-navigation functions to those of a web browser,
    we might equate names and addresses to hyperlinks, as each can be followed relatively
    easily to view a new location. Another feature IDA shares with traditional web
    browsers is the concept of forward and backward navigation based on the order
    in which you navigate the disassembly. Each time you navigate to a new location
    within a disassembly, your current location is appended to a history list. Two
    menu operations are available for traversing this list. First, Jump ▸ Jump to
    Previous Position repositions the disassembly to the most recent entry in the
    history list. The behavior is conceptually identical to a web browser’s *back*
    button. The associated hotkey is esc, and it is one of the most useful hotkeys
    that you can commit to memory. Be forewarned, however, that using esc when any
    window other than the disassembly window is active causes the active window to
    be closed. (You can always reopen windows that you closed accidentally via View
    ▸ Open Subviews.) Backward navigation is extremely handy when you have followed
    a chain of function calls several levels deep and you decide that you want to
    navigate back to your original position within the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: Jump ▸ Jump to Next Position is the counterpart operation that moves the disassembly
    window forward in the history list in a manner similar to a web browser’s *forward*
    button. For the sake of completeness, the associated hotkey for this operation
    is ctrl-enter, though it tends to be less useful than using esc for backward navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, two of the more useful toolbar buttons, shown in [Figure 6-2](ch06.html#forward_and_backward_navigation_buttons
    "Figure 6-2. Forward and backward navigation buttons"), provide the familiar browser-style
    forward and backward behavior. Each of the buttons is associated with a drop-down
    history list that offers you instant access to any location in the navigation
    history without having to trace your steps through the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Forward and backward navigation buttons](httpatomoreillycomsourcenostarchimages854127.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2. Forward and backward navigation buttons
  prefs: []
  type: TYPE_NORMAL
- en: Stack Frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because IDA Pro is such a low-level analysis tool, many of its features and
    displays expect the user to be somewhat familiar with the low-level details of
    compiled languages, many of which center on the specifics of generating machine
    language and managing the memory used by a high-level program. Therefore, from
    time to time this book covers some of the theory of compiled programs in order
    to make sense of the related IDA displays.
  prefs: []
  type: TYPE_NORMAL
- en: One such low-level concept is that of the stack frame. *Stack frames* are blocks
    of memory allocated within a program’s runtime stack and dedicated to a specific
    invocation of a function. Programmers typically group executable statements into
    units called *functions* (also called *procedures*, *subroutines*, or *methods*).
    In some cases this may be a requirement of the language being used. In most cases
    it is considered good programming practice to build programs from such functional
    units.
  prefs: []
  type: TYPE_NORMAL
- en: When a function is not executing, it typically requires little to no memory.
    When a function is called, however, it may require memory for several reasons.
    First, the caller of a function may wish to pass information into the function
    in the form of parameters (arguments), and these parameters need to be stored
    somewhere the function can find them. Second, the function may need temporary
    storage space while performing its task. This temporary space is often allocated
    by a programmer through the declaration of local variables, which can be used
    within the function but cannot be accessed once the function has completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compilers utilize stack frames (also called *activation records*) to make the
    allocation and deallocation of function parameters and local variables transparent
    to the programmer. A compiler inserts code to place a function’s parameters into
    the stack frame prior to transferring control to the function itself, at which
    point the compiler inserts code to allocate enough memory to hold the function’s
    local variables. As a consequence of the way stack frames are constructed, the
    address to which the function should return is also stored within the new stack
    frame. A pleasant result of the use of stack frames is that recursion becomes
    possible, as each recursive call to a function is given its own stack frame, neatly
    segregating each call from its predecessor. The following steps detail the operations
    that take place when a function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: The caller places any parameters required by the function being called into
    locations as dictated by the calling convention (see [Calling Conventions](ch06s02.html#calling_conventions
    "Calling Conventions") in [Calling Conventions](ch06s02.html#calling_conventions
    "Calling Conventions")) employed by the called function. This operation may result
    in a change to the program stack pointer if parameters are placed on the runtime
    stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The caller transfers control to the function being called. This is usually performed
    with an instruction such as the x86 `CALL` or the MIPS `JAL`. A return address
    is typically saved onto the program stack or in a CPU register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, the called function takes steps to configure a frame pointer^([[42](#ftn.CHP-6-FN-1)])
    and saves any register values that the caller expects to remain unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The called function allocates space for any local variables that it may require.
    This is often done by adjusting the program stack pointer to reserve space on
    the runtime stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The called function performs its operations, potentially generating a result.
    In the course of performing its operations, the called function may access the
    parameters passed to it by the calling function. If the function returns a result,
    the result is often placed into a specific register or registers that the caller
    can examine once the function returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the function has completed its operations, any stack space reserved for
    local variables is released. This is often done by reversing the actions performed
    in step 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any registers whose values were saved (in step 3) on behalf of the caller are
    restored to their original values. This includes the restoration of the caller’s
    frame pointer register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The called function returns control to the caller. Typical instructions for
    this include the x86 `RET` and the MIPS `JR` instructions. Depending on the calling
    convention in use, this operation may also serve to clear one or more parameters
    from the program stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the caller regains control, it may need to remove parameters from the program
    stack. In such cases a stack adjustment may be required to restore the program
    stack pointer to the value that it held prior to step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 3 and 4 are so commonly performed upon entry to a function that together
    they are called the function’s *prologue*. Similarly, steps 6 through 8 are so
    frequently performed at the end of a function that together they make up the function’s
    *epilogue*. With the exception of step 5, which represents the body of the function,
    all of these operations constitute the overhead associated with calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a basic understanding of what stack frames are, we can take a closer look
    at exactly how they are structured. The examples that follow reference the x86
    architecture and the behavior associated with common x86 compilers such as Microsoft
    Visual C/C++ or GNU’s gcc/g++. One of the most important steps in the creation
    of a stack frame involves the placement of function parameters onto the stack
    by the calling function. The calling function must store parameters exactly as
    the function being called expects to find them; otherwise, serious problems can
    arise. Functions advertise the manner in which they expect to receive their arguments
    by selecting and adhering to a specific calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: A *calling convention* dictates exactly where a caller should place any parameters
    that a function requires. Calling conventions may require parameters to be placed
    in specific registers, on the program stack, or in both registers and on the stack.
    Equally important to when parameters are passed on the program stack is determining
    who is responsible for removing them from the stack once the called function has
    completed. Some calling conventions dictate that the caller is responsible for
    removing parameters that it placed on the stack, while other calling conventions
    dictate that the called function will take care of removing the parameters from
    the stack. Adherence to publicized calling conventions is essential in maintaining
    the integrity of the program stack pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The C Calling Convention
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default calling convention used by most C compilers for the x86 architecture
    is called the *C calling convention*. The `_cdecl` modifier may be used by C/C++
    programs to force compilers to utilize the C calling convention when the default
    calling convention may have been overridden. We will refer to this calling convention
    as the `cdecl` calling convention from here on. The `cdecl` calling convention
    specifies that the caller place parameters to a function on the stack in right-to-left
    order and that the caller (as opposed to the callee) remove the parameters from
    the stack after the called function completes.
  prefs: []
  type: TYPE_NORMAL
- en: One result of placing parameters on the stack in right-to-left order is that
    the leftmost (first) parameter of the function will always be on the top of the
    stack when the function is called. This makes the first parameter easy to find
    regardless of the number of parameters the function expects, and it makes the
    `cdecl` calling convention ideally suited for use with functions that can take
    a variable number of arguments (such as `printf`).
  prefs: []
  type: TYPE_NORMAL
- en: Requiring the calling function to remove parameters from the stack means that
    you will often see instructions that make an adjustment to the program stack pointer
    immediately following the return from a called function. In the case of functions
    that can accept a variable number of arguments, the caller is ideally suited to
    make this adjustment, as the caller knows exactly how many arguments it has chosen
    to pass to the function and can easily make the correct adjustment, whereas the
    called function never knows ahead of time how many parameters it may receive and
    would have a difficult time making the necessary stack adjustment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples we consider calls to a function having the following
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this function will use the `cdecl` calling convention, expecting
    the four parameters to be pushed in right-to-left order and requiring the caller
    to clean the parameters off the stack. A compiler might generate code for a call
    to this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The four `push` operations beginning at ![](httpatomoreillycomsourcenostarchimages854061.png)
    result in a net change to the program stack pointer (ESP) of 16 bytes (`4 * sizeof(int)`
    on a 32-bit architecture), which is undone at ![](httpatomoreillycomsourcenostarchimages854063.png)
    following the return from `demo_cdecl`. If `demo_cdecl` is called 50 times, each
    call will be followed by an adjustment similar to that at ![](httpatomoreillycomsourcenostarchimages854063.png).
    The following example also adheres to the `cdecl` calling convention while eliminating
    the need for the caller to explicitly clean parameters off the stack following
    each call to `demo_cdecl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the compiler has preallocated storage space for the parameters
    to `demo_cdecl` at the top of the stack during the function prologue. When the
    parameters for `demo_cdecl` are placed on the stack, there is no change to the
    program stack pointer, which eliminates the need to adjust the stack pointer when
    the call to `demo_cdecl` completes. The GNU compilers (gcc and g++) utilize this
    technique to place function parameters onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note that either method results in the stack pointer pointing to the leftmost
    argument when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Calling Convention
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Standard* in this case is a bit of a misnomer as it is a name that Microsoft
    created for its own calling convention marked by the use of the `_stdcall` modifier
    in a function declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In order to avoid any confusion surrounding the word *standard*, we will refer
    to this calling convention as the `stdcall` calling convention for the remainder
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `cdecl` calling convention, `stdcall` requires that function parameters
    be placed on the program stack in right-to-left order. The difference when using
    `stdcall` is that the called function is responsible for clearing the function
    parameters from the stack when the function has finished. In order for a function
    to do this, the function must know exactly how many parameters are on the stack.
    This is possible only for functions that accept a fixed number of parameters.
    As a result, variable argument functions such as `printf` cannot make use of the
    `stdcall` calling convention. The `demo_stdcall` function, for example, expects
    three integer parameters, occupying a total of 12 bytes on the stack (`3 * sizeof(int)`
    on a 32-bit architecture). An x86 compiler can use a special form of the `RET`
    instruction to simultaneously pop the return address from the top of the stack
    and add 12 to the stack pointer to clear the function parameters. In the case
    of `demo_stdcall`, we might see the following instruction used to return to the
    caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The primary advantage to the use of `stdcall` is the elimination of code to
    clean parameters off the stack following every function call, which results in
    slightly smaller, slightly faster programs. By convention Microsoft utilizes the
    `stdcall` convention for all fixed-argument functions exported from shared library
    (DLL) files. This is an important point to remember if you are attempting to generate
    function prototypes or binary-compatible replacements for any shared library components.
  prefs: []
  type: TYPE_NORMAL
- en: The fastcall Convention for x86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variation on the `stdcall` convention, the `fastcall` calling convention passes
    up to two parameters in CPU registers rather than on the program stack. The Microsoft
    Visual C/C++ and GNU gcc/g++ (version 3.4 and later) compilers recognize the `fastcall`
    modifier in function declarations. When `fastcall` is specified, the first two
    parameters passed to a function will be placed in the ECX and EDX registers, respectively.
    Any remaining parameters are placed on the stack in right-to-left order similar
    to `stdcall`. Also similar to `stdcall`, `fastcall` functions are responsible
    for removing parameters from the stack when they return to their caller. The following
    declaration demonstrates the use of the `fastcall` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A compiler might generate the following code in order to call `demo_fastcall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that no stack adjustment is required upon return from the call to `demo_fastcall`,
    as `demo_fastcall` is responsible for clearing parameters `y` and `z` from the
    stack as it returns to the caller. It is important to understand that because
    two arguments are passed in registers, the called function needs to clear only
    8 bytes from the stack even though there are four arguments to the function.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Calling Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nonstatic member functions in C++ classes differ from standard functions in
    that they must make available the `this` pointer, which points to the object used
    to invoke the function. The address of the object used to invoke the function
    must be supplied by the caller and is therefore provided as a parameter when calling
    nonstatic member functions. The C++ language standard does not specify how `this`
    should be passed to nonstatic member functions, so it should come as no surprise
    that different compilers use different techniques when passing `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual C++ offers the `thiscall` calling convention, which passes
    `this` in the ECX register and requires the nonstatic member function to clean
    parameters off the stack as in `stdcall`. The GNU `g++` compiler treats `this`
    as the implied first parameter to any nonstatic member function and behaves in
    all other respects as if the `cdecl` convention is being used. Thus, for `g++-`compiled
    code, `this` is placed on top of the stack prior to calling the nonstatic member
    function, and the caller is responsible for removing parameters (there will always
    be at least one) from the stack once the function returns. Additional features
    of compiled C++ are discussed in [Chapter 8](ch08.html "Chapter 8. Datatypes and
    Data Structures").
  prefs: []
  type: TYPE_NORMAL
- en: Other Calling Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Complete coverage of every existing calling convention would require a book
    in its own right. Calling conventions are often language-, compiler-, and CPU-specific,
    and some research on your part may be required as you encounter code generated
    by less-common compilers. A few situations deserve special mention, however: optimized
    code, custom assembly language code, and system calls.'
  prefs: []
  type: TYPE_NORMAL
- en: When functions are exported for use by other programmers (such as library functions),
    it is important that they adhere to well-known calling conventions so that programmers
    can easily interface to those functions. On the other hand, if a function is intended
    for internal program use only, then the calling convention used by that function
    need be known only within that function’s program. In such cases, optimizing compilers
    may choose to use alternate calling conventions in order to generate faster code.
    Instances in which this may occur include the use of the `/GL` option with Microsoft
    Visual C++ and the use of the `regparm` keyword with GNU gcc/g++.
  prefs: []
  type: TYPE_NORMAL
- en: When programmers go to the trouble of using assembly language, they gain complete
    control over how parameters will be passed to any functions that they happen to
    create. Unless they wish to make their functions available to other programmers,
    assembly language programmers are free to pass parameters in any way they see
    fit. As a result, you may need to take extra care when analyzing custom assembly
    code. Custom assembly code is often encountered in obfuscation routines and shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: A *system call* is a special type of function call used to request an operating
    system service. System calls usually effect a state transition from user mode
    to kernel mode in order for the operating system kernel to service the user’s
    request. The manner in which system calls are initiated varies across operating
    systems and CPUs. For example, Linux x86 system calls may be initiated using the
    `int 0x80` instruction or the `sysenter` instruction, while other x86 operating
    systems may use only the `sysenter` instruction or alternate interrupt numbers.
    On many x86 systems (Linux being an exception) parameters for system calls are
    placed on the runtime stack, and a system call number is placed in the EAX register
    immediately prior to initiating the system call. Linux system calls accept their
    parameters in specific registers and occasionally in memory when there are more
    parameters than available registers.
  prefs: []
  type: TYPE_NORMAL
- en: Local Variable Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the calling conventions that dictate the manner in which parameters are
    passed into a function, there are no conventions that mandate the layout of a
    function’s local variables. When compiling a function, one task a compiler is
    faced with is to compute the amount of space required by a function’s local variables.
    Another task is to determine whether those variables can be allocated in CPU registers
    or whether they must be allocated on the program stack. The exact manner in which
    these allocations are made is irrelevant to both the caller of a function and
    to any functions that may, in turn, be called. Most notably, it is typically impossible
    to determine a function’s local variable layout based on examination of the function’s
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Frame Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following function compiled on a 32-bit x86-based computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We compute the minimum amount of stack space required for local variables as
    76 bytes (three 4-byte integers and a 64-byte buffer). This function could use
    either `stdcall` or `cdecl`, and the stack frame will look the same. [Figure 6-3](ch06s02.html#an_esp-based_stack_frame
    "Figure 6-3. An ESP-based stack frame") shows one possible implementation of a
    stack frame for an invocation of `demo_stackframe`, assuming that no frame pointer
    register is used (thus the stack pointer, ESP, serves as the frame pointer). This
    frame would be set up on entry to `demo_stackframe` with the one-line prologue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Offset column indicates the base+displacement address required to reference
    any of the local variables or parameters in the stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![An ESP-based stack frame](httpatomoreillycomsourcenostarchimages854129.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3. An ESP-based stack frame
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating functions that utilize the stack pointer to compute all variable
    references requires a little more effort on the part of the compiler, as the stack
    pointer changes frequently and the compiler must make sure that proper offsets
    are used at all times when referencing any variables within the stack frame. Consider
    the call made to `bar` in function `demo_stackframe`, the code for which is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `push` at ![](httpatomoreillycomsourcenostarchimages854061.png) correctly
    pushes local variable `y` per the offset in [Figure 6-3](ch06s02.html#an_esp-based_stack_frame
    "Figure 6-3. An ESP-based stack frame"). At first glance it might appear that
    the `push` at ![](httpatomoreillycomsourcenostarchimages854063.png) incorrectly
    references local variable `y` a second time. However, because we are dealing with
    an ESP-based frame and the `push` at ![](httpatomoreillycomsourcenostarchimages854061.png)
    modifies ESP, all of the offsets in [Figure 6-3](ch06s02.html#an_esp-based_stack_frame
    "Figure 6-3. An ESP-based stack frame") must be temporarily adjusted each time
    ESP changes. Following ![](httpatomoreillycomsourcenostarchimages854061.png),
    the new offset for local variable `z` becomes `[esp+4]` as correctly referenced
    in the `push` at ![](httpatomoreillycomsourcenostarchimages854063.png). When examining
    functions that reference stack frame variables using the stack pointer, you must
    be careful to note any changes to the stack pointer and adjust all future variable
    offsets accordingly. One advantage of using the stack pointer to reference all
    stack frame variables is that all other registers remain available for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Once `demo_stackframe` has completed, it needs to return to the caller. Ultimately
    a `ret` instruction will be used to pop the desired return address off the top
    of the stack into the instruction pointer register (EIP in this case). Before
    the return address can be popped, the local variables need to be removed from
    the top of the stack so that the stack pointer correctly points to the saved return
    address when the `ret` instruction is executed. For this particular function the
    resulting epilogue becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At the expense of dedicating a register for use as a frame pointer and some
    code to configure the frame pointer on entry to the function, the job of computing
    local variable offsets can be made easier. In x86 programs, the EBP (*extended
    base pointer*) register is typically dedicated for use as a stack frame pointer.
    By default, most compilers generate code to use a frame pointer, though options
    typically exist for specifying that the stack pointer should be used instead.
    GNU gcc/g++, for example, offers the `-fomit-frame-pointer` compiler option, which
    generates functions that do not rely on a fixed-frame pointer register.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see what the stack frame for `demo_stackframe` will look like using
    a dedicated frame pointer, we need to consider this new prologue code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `push` instruction at ![](httpatomoreillycomsourcenostarchimages854093.png)
    saves the value of EBP currently being used by the caller. Functions that adhere
    to the System V Application Binary Interface for Intel 32-bit Processors^([[43](#ftn.CHP-6-FN-2)])
    are allowed to modify the EAX, ECX, and EDX registers but are required to preserve
    the caller’s values for all other registers. Therefore, if we wish to use EBP
    as a frame pointer, we must save the current value of EBP before we change it,
    and we must restore the value of EBP before we return to the caller. If any other
    registers need to be saved on behalf of the caller (ESI or EDI, for example),
    compilers may choose to save them at the same time EBP is saved, or they may defer
    saving them until local variables have been allocated. Thus, there is no standard
    location within a stack frame for the storage of saved registers.
  prefs: []
  type: TYPE_NORMAL
- en: Once EBP has been saved, it can be changed to point to the current stack location.
    This is accomplished by the `mov` instruction at ![](httpatomoreillycomsourcenostarchimages854095.png),
    which copies the current value of the stack pointer into EBP. Finally, as in the
    non-EBP-based stack frame, space for local variables is allocated at ![](httpatomoreillycomsourcenostarchimages854099.png).
    The resulting stack frame layout is shown in [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame").
  prefs: []
  type: TYPE_NORMAL
- en: '![An EBP-based stack frame](httpatomoreillycomsourcenostarchimages854131.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4. An EBP-based stack frame
  prefs: []
  type: TYPE_NORMAL
- en: 'With a dedicated frame pointer, all variable offsets are computed relative
    to the frame pointer register. It is most often (though not necessarily) the case
    that positive offsets are used to access function parameters, while negative offsets
    are required to access local variables. With a dedicated frame pointer in use,
    the stack pointer may be freely changed without affecting the offset to any variables
    within the frame. The call to function `bar` can now be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the stack pointer has changed following the `push` at ![](httpatomoreillycomsourcenostarchimages854101.png)
    has no effect on the access to local variable `z` in the succeeding `push`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the use of a frame pointer necessitates a slightly different epilogue
    once the function completes, as the caller’s frame pointer must be restored prior
    to returning. Local variables must be cleared from the stack before the old value
    of the frame pointer can be retrieved, but this is made easy by the fact that
    the current frame pointer points to the old frame pointer. In x86 programs utilizing
    EBP as a frame pointer, the following code represents a typical epilogue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This operation is so common that the x86 architecture offers the `leave` instruction
    as an abbreviated means of accomplishing the same task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While the names of registers and instructions used will certainly differ for
    other processor architectures, the basic process of building stack frames will
    remain the same. Regardless of the architecture, you will want to familiarize
    yourself with typical prologue and epilogue sequences so that you can quickly
    move on to analyzing more interesting code within functions.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Stack Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stack frames are clearly a runtime concept; a stack frame can’t exist without
    a stack and without a running program. While this is true, it doesn’t mean that
    you should ignore the concept of a stack frame when you are performing static
    analysis with tools such as IDA. All of the code required to set up stack frames
    for each function is present within a binary. Through careful analysis of this
    code, we can gain a detailed understanding of the structure of any function’s
    stack frame even when the function is not running. In fact, some of IDA’s most
    sophisticated analysis is performed specifically to determine the layout of stack
    frames for every function that IDA disassembles. During initial analysis, IDA
    goes to great lengths to monitor the behavior of the the stack pointer over the
    course of a function by making note of every `push` or `pop` operation along with
    any arithmetic operations that may change the stack pointer, such as adding or
    subtracting constant values. The first goal of this analysis is to determine the
    exact size of the local variable area allocated to a function’s stack frame. Additional
    goals include determining whether a dedicated frame pointer is in use in a given
    function (by recognizing a `push ebp/mov ebp, esp` sequence, for example) and
    recognizing all memory references to variables within a function’s stack frame.
    For example, if IDA noted the following instruction in the body of `demo_stackframe`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: it would understand that the first argument to the function (`a` in this case)
    is being loaded into the EAX register (refer to [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame")). Through careful analysis of the stack
    frame structure, IDA can distinguish between memory references that access function
    arguments (those that lie below the saved return address) and references that
    access local variables (those that lie above the saved return address). IDA takes
    the additional step of determining which memory locations within a stack frame
    are directly referenced. For example, while the stack frame in [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame") is 96 bytes in size, there are only seven
    variables that we are likely to see referenced (four locals and three parameters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the behavior of a function often comes down to understanding
    the types of data that the function manipulates. When reading a disassembly listing,
    one of the first opportunities that you will have to understand the data a function
    manipulates is to view the breakdown of the function’s stack frame. IDA offers
    two views into any function’s stack frame: a summary view and a detail view. In
    order to understand these two views, we will refer to the following version of
    `demo_stackframe`, which we have compiled using gcc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, local variables `x` and `y` are initialized from parameters
    `c` and `b`, respectively. Local variable `z` is initialized with the constant
    value 10, and the first character in the 64-byte local array, named `buffer`,
    is initialized to the letter `'A'`. The corresponding IDA disassembly of this
    function appears here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are many points to cover in this listing as we begin to acquaint ourselves
    with IDA’s disassembly notation. We begin at ![](httpatomoreillycomsourcenostarchimages854061.png)
    by noting that IDA believes this function uses the EBP register as a frame pointer
    based on analysis of the function prologue. At ![](httpatomoreillycomsourcenostarchimages854063.png)
    we learn that gcc has allocated 120 bytes (78h equates to 120) of local variable
    space in the stack frame. This includes 8 bytes for passing the two parameters
    to `bar` at ![](httpatomoreillycomsourcenostarchimages854093.png), but it is still
    far greater than the 76 bytes we had estimated previously and demonstrates that
    compilers occasionally pad the local variable space with extra bytes in order
    to ensure a particular alignment within the stack frame. Beginning at ![](httpatomoreillycomsourcenostarchimages854095.png),
    IDA provides a summary stack view that lists every variable that is directly referenced
    within the stack frame, along with the variable’s size and offset distance from
    the frame pointer.
  prefs: []
  type: TYPE_NORMAL
- en: IDA assigns names to variables based on their location relative to the saved
    return address. Local variables lie above the saved return address, while function
    parameters lie below the saved return address. Local variable names are derived
    using the `var_` prefix joined with a hexadecimal suffix that indicates the distance,
    in bytes, that the variable lies above the saved frame pointer. Local variable
    `var_C`, in this case, is a 4-byte (dword) variable that lies 12 bytes above the
    saved frame pointer (`[ebp-0Ch]`). Function parameter names are generated using
    the `arg_` prefix combined with a hexadecimal suffix that represents the relative
    distance from the topmost parameter. Thus the topmost 4-byte parameter would be
    named `arg_0`, while successive parameters would be named `arg_4`, `arg_8`, `arg_C`,
    and so on. In this particular example `arg_0` is not listed because the function
    makes no use of parameter `a`. Because IDA fails to locate any memory reference
    to `[ebp+8]` (the location of the first parameter), `arg_0` is not listed in the
    summary stack view. A quick scan of the summary stack view reveals that there
    are many stack locations that IDA has failed to name because no direct references
    to those locations exist in the program code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only stack variables that IDA will automatically generate names for are
    those that are directly referenced within a function.
  prefs: []
  type: TYPE_NORMAL
- en: An important difference between IDA’s disassembly listing and the stack frame
    analysis that we performed earlier is the fact that nowhere in the disassembly
    listing do we see memory references similar to `[ebp-12]`. Instead, IDA has replaced
    all constant offsets with symbolic names corresponding to the symbols in the stack
    view and their relative offsets from the stack frame pointer. This is in keeping
    with IDA’s goal of generating a higher-level disassembly. It is simply easier
    to deal with symbolic names than numeric constants. In fact, as we will see later,
    IDA allows us to change the names of any stack variable to whatever we wish, making
    the names that much easier for us to remember. The summary stack view serves as
    a map from IDA-generated names to their corresponding stack frame offsets. For
    example, where the memory reference `[ebp+arg_8]` appears in the disassembly,
    `[ebp+10h]` or `[ebp+16]` could be used instead. If you prefer numeric offsets,
    IDA will happily show them to you. Right-clicking `arg_8` at ![](httpatomoreillycomsourcenostarchimages854099.png)
    yields the context-sensitive menu shown in [Figure 6-5](ch06s02.html#selecting_an_alternate_display_format
    "Figure 6-5. Selecting an alternate display format"), which contains several options
    to change the display format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting an alternate display format](httpatomoreillycomsourcenostarchimages854137.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5. Selecting an alternate display format
  prefs: []
  type: TYPE_NORMAL
- en: In this example, since we have source code available for comparison, we can
    map the IDA-generated variable names back to the names used in the original source
    using a variety of clues available in the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `demo_stackframe` takes three parameters: `a`, `b`, and `c`. These correspond
    to variables `arg_0`, `arg_4`, and `arg_8` respectively (though `arg_0` is missing
    in the disassembly because it is never referenced).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variable `x` is initialized from parameter `c`. Thus `var_C` corresponds
    to `x` since it is initialized from `arg_8` at ![](httpatomoreillycomsourcenostarchimages854101.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, local variable `y` is initialized from parameter `b`. Thus, `var_5C`
    corresponds to `y` since it is initialized from `arg_4` at ![](httpatomoreillycomsourcenostarchimages854103.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variable `z` corresponds to `var_60` since it is initialized with the
    value 10 at ![](httpatomoreillycomsourcenostarchimages854133.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 64-byte character array `buffer` begins at `var_58` since `buffer[0]` is
    initialized with *A* (ASCII 0x41) at ![](httpatomoreillycomsourcenostarchimages854135.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two arguments for the call to `bar` are moved into the stack at ![](httpatomoreillycomsourcenostarchimages854093.png)
    rather than being pushed onto the stack. This is typical of current versions of
    gcc (versions 3.4 and later). IDA recognizes this convention and elects not to
    create local variable references for the two items at the top of the stack frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to the summary stack view, IDA offers a detailed stack frame view
    in which every byte allocated to a stack frame is accounted for. The detailed
    view is accessed by double-clicking any variable name associated with a given
    stack frame. Double-clicking `var_C` in the previous listing would bring up the
    stack frame view shown in [Figure 6-6](ch06s02.html#ida_stack_frame_view "Figure 6-6. IDA
    stack frame view") (esc closes the window).
  prefs: []
  type: TYPE_NORMAL
- en: '![IDA stack frame view](httpatomoreillycomsourcenostarchimages854139.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6. IDA stack frame view
  prefs: []
  type: TYPE_NORMAL
- en: Because the detailed view accounts for every byte in the stack frame, it occupies
    significantly more space than the summary view, which lists only referenced variables.
    The portion of the stack frame shown in [Figure 6-6](ch06s02.html#ida_stack_frame_view
    "Figure 6-6. IDA stack frame view") spans a total of 32 bytes, which represents
    only a small portion of the entire stack frame. Note that no names are assigned
    to bytes that are not referenced directly within the function. For example, parameter
    `a`, corresponding to `arg_0`, was never referenced within `demo_stackframe`.
    With no memory reference to analyze, IDA opts to do nothing with the corresponding
    bytes in the stack frame, which occupy offsets `+00000008` through `+0000000B`.
    On the other hand, `arg_4` was directly referenced at ![](httpatomoreillycomsourcenostarchimages854103.png)
    in the disassembly listing, where its contents were loaded into the 32-bit EAX
    register. Based on the fact that 32 bits of data were moved, IDA is able to infer
    that the `arg_4` is a 4-byte quantity and labels it as such (`db` defines 1 byte
    of storage; `dw` defines 2 bytes of storage, also called a *word*; and `dd` defines
    4 bytes of storage, also called a *double word*).
  prefs: []
  type: TYPE_NORMAL
- en: Two special values shown in [Figure 6-6](ch06s02.html#ida_stack_frame_view "Figure 6-6. IDA
    stack frame view") are “ `s`” and “ `r`” (each starts with a leading space). These
    pseudo variables are IDA’s special representation of the saved return address
    (“ `r`”) and the saved register value(s) (“ `s`” representing only EBP in this
    example). These values are included in the stack frame view for completeness,
    as every byte in the stack frame is accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: Stack frame view offers a detailed look at the inner workings of compilers.
    In [Figure 6-6](ch06s02.html#ida_stack_frame_view "Figure 6-6. IDA stack frame
    view") it is clear that the compiler has inserted 8 extra bytes between the saved
    frame pointer “ `s`” and the local variable `x` (`var_C`). These bytes occupy
    offsets `−00000001` through `−00000008` in the stack frame. Further, a little
    math performed on the offset associated with each variable listed in the summary
    view reveals that the compiler has allocated 76 (rather than 64 per the source
    code) bytes to the character buffer at `var_58`. Unless you happen to be a compiler
    writer yourself or are willing to dig deep into the source code for gcc, all you
    can do is speculate as to why these extra bytes are allocated in this manner.
    In most cases we can chalk up the extra bytes to padding for alignment, and usually
    the presence of these extra bytes has no impact on a program’s behavior. After
    all, if a programmer asks for 64 bytes and is given 76, the program should behave
    no differently, especially since the programmer shouldn’t be using more than the
    64 bytes requested. On the other hand, if you happen to be an exploit developer
    and learn that it is possible to overflow this particular buffer, then you might
    be very interested in the fact that nothing interesting can even begin to happen
    until you have supplied at least 76 bytes, which is the effective size of the
    buffer as far as the compiler is concerned. In [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures") we will return to the stack frame view and its uses in dealing
    with more complex datatypes such as arrays and structures.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[42](#CHP-6-FN-1)]) A *frame pointer* is a register that points to a location
    inside a stack frame. Variables within the stack frame are typically referenced
    by their relative distance from the location to which the frame pointer points.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[43](#CHP-6-FN-2)]) See [http://www.sco.com/developers/devspecs/abi386-4.pdf](http://www.sco.com/developers/devspecs/abi386-4.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Searching the Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IDA makes it easy to navigate to things that you know about and designs many
    of its data displays to summarize specific types of information (names, strings,
    imports, and so on), making them easy to find as well. However, what features
    are offered to help you conduct more general searches through your databases?
    If you take time to review the contents of the Search menu, you will find a long
    list of options, the majority of which take you to the next item in some category.
    For example, Search ▸ Next Code moves the cursor to the next location containing
    an instruction. You may also wish to familiarize yourself with the options available
    on the Jump menu. For many of these, you are presented with a list of locations
    to choose from. Jump ▸ Jump to Function, for example, brings up a list of all
    functions, allowing you to quickly choose one and navigate to it. While these
    canned search features may often be useful, two types of general-purpose searches
    are worth more detailed discussion: text searches and binary searches.'
  prefs: []
  type: TYPE_NORMAL
- en: Text Searches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IDA text searches amount to substring searches through the disassembly listing
    view. Text searches are initiated via Search ▸ Text (hotkey: alt-T), which opens
    the dialog shown in [Figure 6-7](ch06s03.html#text_search_dialog "Figure 6-7. Text
    Search dialog"). A number of self-explanatory options dictate specific details
    concerning the search to be performed. As shown, POSIX-style regular expressions
    are permitted. The *Identifier* search is somewhat misnamed. In reality it restricts
    the search to find whole words only and can match any whole word on an assembly
    line, including opcode mnemonics or constant values. An Identifier search for
    `401116` would fail to find a symbol named `loc_401116`.'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting *Find all occurences* causes the search results to be opened in a
    new window, allowing easy navigation to any single match of the search criteria.
    Finally, the previous search can be repeated to locate the next match using ctrl-T
    or Search ▸ Next Text.
  prefs: []
  type: TYPE_NORMAL
- en: '![Text Search dialog](httpatomoreillycomsourcenostarchimages854141.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7. Text Search dialog
  prefs: []
  type: TYPE_NORMAL
- en: Binary Searches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to search for specific binary content such as a known sequence of
    bytes, then text searches are not the answer. Instead, you need to use IDA’s binary
    search facilities. While the text search searches the disassembly window, the
    binary search will search only the content portion of the Hex View window. Either
    the hex dump or the ASCII dump can be searched, depending on how the search string
    is specified. A binary search is initiated using Search ▸ Sequence of Bytes, or
    alt-B. [Figure 6-8](ch06s03.html#binary_search_dialog "Figure 6-8. Binary Search
    dialog") shows the Binary Search dialog. To search for a sequence of hex bytes,
    the search string should be specified as a space-separated list of two-digit hex
    values such as `CA FE BA BE`, which offers identical behavior as a search for
    `ca fe ba be`, despite the availability of a Case-sensitive option.
  prefs: []
  type: TYPE_NORMAL
- en: To alternatively search for embedded string data (effectively searching the
    ASCII dump portion of the Hex View window), you must surround the search strings
    with quotes. Use the Unicode strings option to search for the Unicode version
    of your search string.
  prefs: []
  type: TYPE_NORMAL
- en: The Case-sensitive option can be a cause of confusion. For string searches it
    is fairly straightforward; a search for “hello” will successfully find “HELLO”
    if Case-sensitive is not selected. Things get a little interesting if you perform
    a hex search and leave Case-sensitive unchecked. If you conduct a case-insensitive
    search for `E9 41 C3`, you may be surprised when your search matches `E9 61 C3`.
    The two strings are considered to match because 0x41 corresponds to the character
    *A* while 0x61 corresponds to *a*. So, even though you have specified a hex search,
    0x41 is considered equivalent to 0x61 because you failed to specify a case-sensitive
    search.
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary Search dialog](httpatomoreillycomsourcenostarchimages854143.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8. Binary Search dialog
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When conducting hex searches, make sure that you specify Case-sensitive if you
    want to restrict the search to exact matches. This is important if you are searching
    for specific opcode sequences rather than ASCII text.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for subsequent matches for binary data is done using ctrl-B or Search
    ▸ Next Sequence of Bytes. Finally, it is not necessary to conduct your binary
    searches from within the Hex View window. IDA allows you to specify binary search
    criteria while the disassembly view is active, in which case a successful search
    will jump the disassembly window to the location whose underlying bytes match
    the specified search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intent of this chapter was to provide you with the minimum essential skills
    for effectively making your way around a disassembly. The overwhelming majority
    of your interactions with IDA will involve the operations that we have discussed
    so far. With navigation safely under your belt, the logical next step is learning
    how to modify IDA databases to suit your particular needs. In the next chapter
    we begin to look at how to make the most basic changes to a disassembly as a means
    of adding new knowledge based on our understanding of a binary’s content and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Disassembly Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After navigation, the next most significant features of IDA are designed to
    allow you to modify the disassembly to suit your needs. In this chapter we will
    show that because of IDA’s underlying database nature, changes that you make to
    a disassembly are easily propagated to all IDA subviews to maintain a consistent
    picture of your disassembly. One of the most powerful features that IDA offers
    is the ability to easily manipulate disassemblies to add new information or reformat
    a listing to suit your particular needs. IDA automatically handles operations
    such as global search and replace when it makes sense to do so and makes trivial
    work of reformatting instructions and data and vice versa, features not available
    in other disassembly tools.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember: There is no undo in IDA. Keep this in mind as you start manipulating
    the database. The closest you’re going to get is saving the database often and
    reverting to a recently saved version of the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Names and Naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have encountered two categories of names in IDA disassemblies:
    names associated with virtual addresses (named locations) and names associated
    with stack frame variables. In the majority of cases IDA will automatically generate
    all of these names according to the guidelines previously discussed. IDA refers
    to such automatically generated names as *dummy names*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, these names seldom hint at the intended purpose of a location
    or variable and therefore don’t generally add to our understanding of a program’s
    behavior. As you begin to analyze any program, one of the first and most common
    ways that you will want to manipulate a disassembly listing is to change default
    names into more meaningful names. Fortunately, IDA allows you to easily change
    any name and handles all of the details of propagating all name changes throughout
    the entire disassembly. In most cases, changing a name is as simple as clicking
    the name you wish to change (this highlights the name) and using the N hotkey
    to open a name-change dialog. Alternatively, right-clicking the name to be changed
    generally presents a context-sensitive menu that contains a Rename option, as
    shown in [Figure 6-5](ch06s02.html#selecting_an_alternate_display_format "Figure 6-5. Selecting
    an alternate display format"). The name-change process does differ somewhat between
    stack variables and named locations, and these differences are detailed in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters and Local Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Names associated with stack variables are the simplest form of name in a disassembly
    listing, primarily because they are not associated with a specific virtual address
    and thus can never appear in the Names window. As in most programming languages,
    such names are considered to be restricted in scope based on the function to which
    a given stack frame belongs. Thus, every function in a program might have its
    own stack variable named `arg_0`, but no function may have more than one variable
    named `arg_0`. The dialog shown in [Figure 7-1](ch07.html#renaming_a_stack_variable
    "Figure 7-1. Renaming a stack variable") is used to rename a stack variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Renaming a stack variable](httpatomoreillycomsourcenostarchimages854145.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1. Renaming a stack variable
  prefs: []
  type: TYPE_NORMAL
- en: Once a new name is supplied, IDA takes care of changing every occurrence of
    the old name in the context of the current function. Changing the name of `var_5C`
    to `y` for `demo_stackframe` would result in the new listing shown here, with
    changes at ![](httpatomoreillycomsourcenostarchimages854061.png).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Should you ever wish to revert to the default name for a given variable, open
    the renaming dialog and enter a blank name, and IDA will regenerate the default
    name for you.
  prefs: []
  type: TYPE_NORMAL
- en: Named Locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Renaming a named location or adding a name to an unnamed location is slightly
    different from changing the name of a stack variable. The process for accessing
    the name-change dialog is identical (hotkey N), but things quickly change. [Figure 7-2](ch07.html#renaming_a_location
    "Figure 7-2. Renaming a location") shows the renaming dialog associated with named
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: This dialog informs you exactly what address you are naming along with a list
    of attributes that can be associated with the name. The maximum name length merely
    echoes a value from one of IDA’s configuration files (*<IDADIR>/cfg/ida.cfg*).
    You are free to use names longer than this value, which will cause IDA to complain
    weakly by informing you that you have exceeded the maximum name length and offering
    to increase the maximum name length for you. Should you choose to do so, the new
    maximum name length value will be enforced (weakly) only in the current database.
    Any new databases that you create will continue to be governed by the maximum
    name length contained in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Renaming a location](httpatomoreillycomsourcenostarchimages854147.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2. Renaming a location
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attributes can be associated with any named location:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local name**'
  prefs: []
  type: TYPE_NORMAL
- en: A local name is restricted in scope to the current function, so the uniqueness
    of local names is enforced only within a given function. Like local variables,
    two different functions may contain identical local names, but a single function
    cannot contain two local names that are identical. Named locations that exist
    outside function boundaries cannot be designated as local names. These include
    names that represent function names as well as global variables. The most common
    use for local names is to provide symbolic names for the targets of jumps within
    a function, such as those associated with branching control structures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Include in names list**'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting this option causes a name to be added to the Names window, which can
    make the name easier to find when you wish to return to it. Autogenerated (dummy)
    names are never included in the Names window by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public name**'
  prefs: []
  type: TYPE_NORMAL
- en: A public name is typically a name that is being exported by a binary such as
    a shared library. IDA’s parsers typically discover public names while parsing
    file headers during initial loading into the database. You can force a symbol
    to be treated as public by selecting this attribute. In general, this has very
    little effect on the disassembly other than to cause public annotations to be
    added to the name in the disassembly listing and in the Names window.
  prefs: []
  type: TYPE_NORMAL
- en: '**Autogenerated name**'
  prefs: []
  type: TYPE_NORMAL
- en: This attribute appears to have no discernible effect on disassemblies. Selecting
    it does not cause IDA to automatically generate a name.
  prefs: []
  type: TYPE_NORMAL
- en: '**Weak name**'
  prefs: []
  type: TYPE_NORMAL
- en: A weak symbol is a specialized form of public symbol utilized only when no public
    symbol of the same name is found to override it. Marking a symbol as weak has
    some significance to an assembler but little significance in an IDA disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Create name anyway**'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed previously, no two locations within a function may be given the
    same name. Similarly, no two locations outside any function (in the global scope)
    may be given the same name. This option is somewhat confusing, as it behaves differently
    depending on the type of name you are attempting to create.
  prefs: []
  type: TYPE_NORMAL
- en: If you are editing a name at the global scope (such as a function name or global
    variable) and you attempt to assign a name that is already in use in the database,
    IDA will display the conflicting name dialog, shown in [Figure 7-3](ch07.html#name_conflict_dialog
    "Figure 7-3. Name conflict dialog"), offering to automatically generate a unique
    numeric suffix to resolve the conflict. This dialog is presented regardless of
    whether you have selected the Create name anyway option or not.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you are editing a local name within a function and you attempt
    to assign a name that is already in use, the default behavior is simply to reject
    the attempt. If you are determined to use the given name, you must select Create
    name anyway in order to force IDA to generate a unique numeric suffix for the
    local name. Of course, the simplest way to resolve any name conflict is to choose
    a name that is not already in use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Name conflict dialog](httpatomoreillycomsourcenostarchimages854149.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3. Name conflict dialog
  prefs: []
  type: TYPE_NORMAL
- en: Register Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A third type of name that is often overlooked is the register name. Within the
    boundaries of a function, IDA allows registers to be renamed. It may be useful
    to rename a register when a compiler has elected to allocate a variable in a register
    rather than on the program stack, and you wish to refer to the variable using
    a name more suited to its purpose than *EDX*, for example. Register renaming works
    much the same as renaming in any other location. Use the N hotkey, or right-click
    the register name and select **Rename** to open the register-renaming dialog.
    When you rename a register you are, in effect, providing an alias with which to
    refer to the register for the duration of the current function (IDA even denotes
    this alias with an `alias = register` syntax at the beginning of the function).
    IDA takes care of replacing all instances of the register name with the alias
    that you provide. It is not possible to rename a register used in code that does
    not belong to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting in IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful feature in IDA is the ability to embed comments in your databases.
    Comments are a particularly useful way to leave notes for yourself regarding your
    progress as you analyze a program. In particular, comments are helpful for describing
    sequences of assembly language instructions in a higher-level fashion. For example,
    you might opt to write comments using C language statements to summarize the behavior
    of a particular function. On subsequent analysis of the function, the comments
    would serve to refresh your memory faster than reanalyzing the assembly language
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'IDA offers several styles of comments, each suited for a different purpose.
    Comments may be associated with any line of the disassembly listing using options
    available from Edit ▸ Comments. Hotkeys or context menus offer alternate access
    to IDA’s commenting features. To help you understand IDA’s commenting features,
    we refer to the following disassembly of the function `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The majority of IDA comments are prefixed with a semicolon to indicate that
    the remainder of the line is to be considered a comment. This is similar to commenting
    styles used by many assemblers and equates to #-style comments in many scripting
    languages or //-style comments in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most straightforward comment is the *regular comment*. Regular comments
    are placed at the end of existing assembly lines, as at ![](httpatomoreillycomsourcenostarchimages854061.png)
    in the preceding listing. Right-click in the right margin of the disassembly or
    use the colon (:) hotkey to activate the comment entry dialog. Regular comments
    will span multiple lines if you enter multiple lines in the comment entry dialog.
    Each of the lines will be indented to line up on the right side of the disassembly.
    To edit or delete a comment, you must reopen the comment entry dialog and edit
    or delete all of the comment text as appropriate. By default, regular comments
    are displayed as blue text.
  prefs: []
  type: TYPE_NORMAL
- en: IDA itself makes extensive use of regular comments. During the analysis phase,
    IDA inserts regular comments to describe parameters that are being pushed for
    function calls. This occurs only when IDA has parameter name or type information
    for the function being called. This information is typically contained within
    type libraries, which are discussed in [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures") and [Chapter 13](ch13.html "Chapter 13. Extending IDA’s
    Knowledge"), but also may be entered manually.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *repeatable comment* is a comment that is entered once but that may appear
    automatically in many locations throughout the disassembly. Location ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the previous listing shows a repeatable comment. In a disassembly listing the
    default color for repeatable comments is blue, making them indistinguishable from
    regular comments. It is the behavior rather than the appearance that matters in
    this case. The behavior of repeatable comments is tied to the concept of cross-references.
    When one program location refers to a second location that contains a repeatable
    comment, the comment associated with the second location is echoed at the first
    location. By default, the echoed comment appears as gray text, making the repeated
    comment distinguishable from other comments. The hotkey for repeatable comments
    is the semicolon (;), making it very easy to confuse repeatable comments and regular
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous listing, note that the comment at ![](httpatomoreillycomsourcenostarchimages854093.png)
    is identical to the comment at ![](httpatomoreillycomsourcenostarchimages854063.png).
    The comment at ![](httpatomoreillycomsourcenostarchimages854063.png) has been
    repeated because the instruction at ![](httpatomoreillycomsourcenostarchimages854093.png)
    (`jge short loc_40106C`) refers to the address of ![](httpatomoreillycomsourcenostarchimages854063.png)
    (`0040106C`).
  prefs: []
  type: TYPE_NORMAL
- en: A regular comment added at a location that is displaying a repeated comment
    overrides the repeated comment so that only the regular comment will be displayed.
    If you entered a regular comment at ![](httpatomoreillycomsourcenostarchimages854093.png),
    the repeatable comment inherited from ![](httpatomoreillycomsourcenostarchimages854063.png)
    would no longer be displayed at ![](httpatomoreillycomsourcenostarchimages854093.png).
    If you then deleted the regular comment at ![](httpatomoreillycomsourcenostarchimages854093.png),
    the repeatable comment would once again be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: A variant form of repeatable comment is associated with strings. Whenever IDA
    automatically creates a string variable, a virtual repeatable comment is added
    at all locations referencing the string variable. We say *virtual* because the
    comment cannot be edited by the user. The content of the virtual comment is set
    to the content of the string variable and displayed throughout the database just
    as a repeatable comment would be. As a result, any program locations that refer
    to the string variable will display the contents of the string variable as a repeated
    comment. The three comments annotated ![](httpatomoreillycomsourcenostarchimages854095.png)
    demonstrate such comments displayed as a result of references to string variables.
  prefs: []
  type: TYPE_NORMAL
- en: Anterior and Posterior Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Anterior and posterior lines* are full-line comments that appear either immediately
    before (anterior) or after (posterior) a given disassembly line. These comments
    are the only IDA comments that are *not* prefixed with the semicolon character.
    An example of an anterior line comment appears at ![](httpatomoreillycomsourcenostarchimages854099.png)
    in the previous listing. You can distinguish an anterior line from a posterior
    line by comparing the address associated with the line to the address associated
    with the instruction immediately preceding or following the line.'
  prefs: []
  type: TYPE_NORMAL
- en: Function Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Function comments* allow you to group comments for display at the top of a
    function’s disassembly listing. An example of a function comment is shown at ![](httpatomoreillycomsourcenostarchimages854101.png),
    where the function prototype has been entered. You enter function comments by
    first highlighting the function name at the top of the function (![](httpatomoreillycomsourcenostarchimages854103.png))
    and then adding either a regular or repeatable comment. Repeatable function comments
    are echoed at any locations that call the commented function. IDA will automatically
    generate function prototype-style comments when you use the Set Function Type
    command discussed in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures").'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Code Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases you will be perfectly content with the disassembly listings that
    IDA generates. In some cases you won’t. As the types of files that you analyze
    diverge farther and farther from ordinary executables generated with common compilers,
    you may find that you need to take more control of the disassembly analysis and
    display processes. This will be especially true if you find yourself performing
    analysis of obfuscated code or files that utilize a custom (unknown to IDA) file
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code transformations facilitated by IDA include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting data into code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting code into data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designating a sequence of instructions as a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the starting or ending address of an existing function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the display format for instruction operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The degree to which you utilize these operations depends on a wide variety of
    factors and personal preferences. In general, if a binary is very complex, or
    if IDA is not familiar with the code sequences generated by the compiler used
    to build the binary, then IDA will encounter more problems during the analysis
    phase, and you will need to make manual adjustments to the disassembled code.
  prefs: []
  type: TYPE_NORMAL
- en: Code Display Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest transformations that you can make to a disassembly listing involve
    customizing the amount of information that IDA generates for each disassembly
    line. Each disassembled line can be considered as a collection of parts that IDA
    refers to, not surprisingly, as *disassembly line parts*. Labels, mnemonics, and
    operands are always present in a disassembly line. You can select additional parts
    for each disassembly line via Options ▸ General on the Disassembly tab, as shown
    in [Figure 7-4](ch07s03.html#disassembly_line_display_options "Figure 7-4. Disassembly
    line display options").
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembly line display options](httpatomoreillycomsourcenostarchimages854151.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4. Disassembly line display options
  prefs: []
  type: TYPE_NORMAL
- en: The *Display Disassembly Line Parts* section in the upper right offers several
    options for customizing disassembly lines. For IDA’s text disassembly view, line
    prefixes, comments, and repeatable comments are selected by default. Each item
    is described here and shown in the listing that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Line prefixes**'
  prefs: []
  type: TYPE_NORMAL
- en: A line prefix is the `section:address` portion of each disassembly line. Deselecting
    this option causes the line prefix to be removed from each disassembly line (the
    default in graph view). To illustrate this option, we have disabled line prefixes
    in the next listing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack pointer**'
  prefs: []
  type: TYPE_NORMAL
- en: IDA performs extensive analysis on each function in order to track changes to
    the program stack pointer. This analysis is essential in understanding the layout
    of each function’s stack frame. Selecting the Stack pointer option causes IDA
    to display the relative change to the stack pointer throughout the course of each
    function. This may be useful in recognizing discrepancies in calling conventions
    (IDA may not understand that a particular function uses `stdcall`, for example)
    or unusual manipulations of the stack pointer. Stack pointer tracking is shown
    in the column under ![](httpatomoreillycomsourcenostarchimages854061.png). In
    this example, the stack pointer has changed by four bytes following the first
    instruction and a total of 0x7C bytes following the third instruction. By the
    time the function completes, the stack pointer is restored to its original value
    (a relative change of zero bytes). Whenever IDA encounters a function return statement
    and detects that the stack pointer value is not zero, an error condition is flagged
    and the instruction line highlighted in red. In some cases, this might be a deliberate
    attempt to frustrate automated analysis. In other cases, it may be that a compiler
    utilizes prologues and epilogues that IDA can’t accurately analyze.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments and repeatable comments**'
  prefs: []
  type: TYPE_NORMAL
- en: Deselecting either of these options inhibits the display of the respective comment
    type. This may be useful if you wish to declutter a disassembly listing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto comments**'
  prefs: []
  type: TYPE_NORMAL
- en: IDA can automatically comment some instruction types. This can serve as a reminder
    as to how particular instructions behave. No comments are added for trivial instructions
    such as the x86 `mov`. The comments at ![](httpatomoreillycomsourcenostarchimages854063.png)
    are examples of auto comments. User comments take precedence over auto comments;
    in this case if you want to see IDA’s automatic comment for a line, you’ll have
    to remove any comments you’ve added (regular or repeatable).
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad instruction** **`<BAD>`** **marks**'
  prefs: []
  type: TYPE_NORMAL
- en: IDA can mark instructions that are legal for the processor but that may not
    be recognized by some assemblers. Undocumented (as opposed to illegal) CPU instructions
    may fall in this category. In such cases IDA will disassemble the instruction
    as a sequence of data bytes and display the undocumented instruction as a comment
    prefaced with `<BAD>`. The intent is to generate a disassembly that most assemblers
    can handle. Refer to the IDA help file for more information on the use of `<BAD>`
    marks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of opcode bytes**'
  prefs: []
  type: TYPE_NORMAL
- en: Most disassemblers are capable of generating listing files that display the
    generated machine language bytes side by side with the assembly language instructions
    from which they are derived. IDA allows you to view the machine language bytes
    associated with each instruction by synchronizing a hex display to the disassembly
    listing display. You can optionally view machine language bytes mixed with assembly
    language instructions by specifying the number of machine language bytes that
    IDA should display for each instruction.
  prefs: []
  type: TYPE_NORMAL
- en: This is fairly straightforward when you are disassembling code for processors
    that have a fixed instruction size, but it is somewhat more difficult for variable-length
    instruction processors such as the x86, for which instructions may range from
    one to more than a dozen bytes in size. Regardless of the instruction length,
    IDA reserves display space in the disassembly listing for the number of bytes
    that you specify here, pushing the remaining portions of the disassembly line
    to the right to accommodate the specified number of opcode bytes. Number of opcode
    bytes has been set to 5 in the following disassembly and can be seen in the columns
    under ![](httpatomoreillycomsourcenostarchimages854093.png). The + symbol at ![](httpatomoreillycomsourcenostarchimages854095.png)
    indicates that the specified instruction is too long to be fully displayed given
    the current settings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can further customize the disassembly display by adjusting the indentation
    values and margins shown in the lower right of [Figure 7-4](ch07s03.html#disassembly_line_display_options
    "Figure 7-4. Disassembly line display options"). Any changes to these options
    affect only the current database. Global settings for each of these options are
    stored in the main configuration file, *<IDADIR>/cfg/ida.cfg*.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Instruction Operands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the disassembly process, IDA makes many decisions regarding how to format
    operands associated with each instruction. The biggest decisions generally revolve
    around how to format various integer constants used by the wide variety of instruction
    types. Among other things, these constants can represent relative offsets in jump
    or call instructions, absolute addresses of global variables, values to be used
    in arithmetic operations, or programmer-defined constants. In order to make a
    disassembly more readable, IDA attempts to use symbolic names rather than numbers
    whenever possible. In some cases, formatting decisions are made based on the context
    of the instruction being disassembled (such as a call instruction); in other cases,
    the decision is based on the data being used (such as access to a global variable
    or an offset into a stack frame). In many other cases, the exact context in which
    a constant is being used may not be clear. When this happens, the associated constant
    is typically formatted as a hexadecimal constant.
  prefs: []
  type: TYPE_NORMAL
- en: If you happen not to be one of the few people in the world who eat, sleep, and
    breathe hex, then you will welcome IDA’s operand formatting features. Right-clicking
    any constant in a disassembly opens a context-sensitive menu similar to that shown
    in [Figure 7-5](ch07s03.html#formatting_options_for_constants "Figure 7-5. Formatting
    options for constants").
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting options for constants](httpatomoreillycomsourcenostarchimages854153.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5. Formatting options for constants
  prefs: []
  type: TYPE_NORMAL
- en: In this case, menu options are offered enabling the constant (`41h`) to be reformatted
    as decimal, octal, or binary values. Since the constant in this example falls
    within the ASCII printable range, an option is also presented to format the value
    as a character constant. In all cases, the menu displays the exact text that will
    replace the operand text should a particular option be selected.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, programmers use named constants in their source code. Such constants
    may be the result of `#define` statements (or their equivalent), or they may belong
    to a set of enumerated constants. Unfortunately, by the time a compiler is finished
    with the source code, it is no longer possible to determine whether the source
    used a symbolic constant or a literal, numeric constant. IDA maintains a large
    catalog of named constants associated with many common libraries such as the C
    standard library or the Windows API. This catalog is accessible via the Use standard
    symbolic constant option on the context-sensitive menu associated with any constant
    value. Selecting this option for the constant `0Ah` in [Figure 7-5](ch07s03.html#formatting_options_for_constants
    "Figure 7-5. Formatting options for constants") opens the symbol-selection dialog
    shown in [Figure 7-6](ch07s03.html#symbol-selection_dialog "Figure 7-6. Symbol-selection
    dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbol-selection dialog](httpatomoreillycomsourcenostarchimages854155.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6. Symbol-selection dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialog is populated from IDA’s internal list of constants after filtering
    according to the value of the constant we are attempting to format. In this case
    we see all of the constants that IDA knows to be equated with the value `0Ah`.
    If we determined that the value was being used in conjunction with the creation
    of an X.25-style network connection, then we might select AF_CCITT and end up
    with the following disassembly line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The list of standard constants is a useful way to determine whether a particular
    constant may be associated with a known name and can save a lot of time reading
    through API documentation in search of potential matches.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of reasons that you may wish to manipulate functions after
    the initial autoanalysis has been completed. In some cases, such as when IDA fails
    to locate a call to a function, functions may not be recognized, as there may
    be no obvious way to reach them. In other cases, IDA may fail to properly locate
    the end of a function, requiring some manual intervention on your part to correct
    the disassembly. IDA may have trouble locating the end of a function if a compiler
    has split the function across several address ranges or when, in the process of
    optimizing code, a compiler merges common end sequences of two or more functions
    in order to save space.
  prefs: []
  type: TYPE_NORMAL
- en: Creating New Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under certain circumstances, new functions can be created where no function
    exists. New functions can be created from existing instructions that do not already
    belong to a function, or they can be created from raw data bytes that have not
    been defined by IDA in any other manner (such as double words or strings). You
    create functions by placing the cursor on the first byte or instruction to be
    included in the new function and selecting Edit ▸ Functions ▸ Create Function.
    IDA attempts to convert data to code if necessary. Then it scans forward to analyze
    the structure of the function and search for a return statement. If IDA can locate
    a suitable end of the function, it generates a new function name, analyzes the
    stack frame, and restructures the code in the form of a function. If it can’t
    locate the end of the function or encounters any illegal instructions, then the
    operation fails.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can delete existing functions using Edit ▸ Functions ▸ Delete Function.
    You may wish to delete a function if you believe that IDA has erred in its autoanalysis.
  prefs: []
  type: TYPE_NORMAL
- en: Function Chunks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function chunks are commonly found in code generated by the Microsoft Visual
    C++ compiler. Chunks are the result of the compiler moving blocks of code that
    are less frequently executed in order to squeeze frequently executed blocks into
    memory pages that are less likely to be swapped out.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is split in such a manner, IDA attempts to locate all of the
    associated chunks by following the jumps that lead to each chunk. In most cases
    IDA does a good job of locating all of the chunks and listing each chunk in the
    function’s header, as shown in the following partial function disassembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Function chunks are easily reached by double-clicking the address associated
    with the chunk, as at ![](httpatomoreillycomsourcenostarchimages854061.png). Within
    the disassembly listing, function chunks are denoted by comments that delimit
    their instructions and that refer to the owning function, as shown in this listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In some cases IDA may fail to locate every chunk associated with a function,
    or functions may be misidentified as chunks rather than as functions in their
    own right. In such cases, you may find that you need to create your own function
    chunks or delete existing function chunks.
  prefs: []
  type: TYPE_NORMAL
- en: You create new function chunks by selecting the range of addresses that belong
    to the chunk, which must not be part of any existing function, and selecting Edit
    ▸ Functions ▸ Append Function Tail. At this point you will be asked to select
    the parent function from a list of all defined functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In disassembly listings, function chunks are referred to as just that: function
    chunks. In the IDA menu system, functions chunks are instead referred to as function
    tails.'
  prefs: []
  type: TYPE_NORMAL
- en: You can delete existing function chunks by positioning the cursor on any line
    within the chunk to be deleted and selecting Edit ▸ Functions ▸ Remove Function
    Tail. At this point you will be asked to confirm your action prior to deleting
    the selected chunk.
  prefs: []
  type: TYPE_NORMAL
- en: If function chunks are turning out to be more trouble than they are worth, you
    can ask IDA not to create function chunks by deselecting the Create function tails
    loader option when you first load a file into IDA. This option is one of the loader
    options accessible via Kernel Options (see [Chapter 4](ch04.html "Chapter 4. Getting
    Started with IDA")) in the initial file-load dialog. If you disable function tails,
    the primary difference that you may notice is that functions that would otherwise
    have contained tails contain jumps to regions outside the function boundaries.
    IDA high-lights such jumps using red lines and arrows in the arrow windows on
    the left side of the disassembly. In the graph view for the corresponding function,
    the targets of such jumps are not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Function Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IDA associates a number of attributes with each function that it recognizes.
    The function properties dialog shown in [Figure 7-7](ch07s03.html#function_editing_dialog
    "Figure 7-7. Function editing dialog") can be used to edit many of these attributes.
    Each attribute that can be modified is explained here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Name of function**'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative means for changing the name of a function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Start address**'
  prefs: []
  type: TYPE_NORMAL
- en: The address of the first instruction in the function. IDA most often determines
    this automatically, either during analysis or from the address used during the
    create function operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Function editing dialog](httpatomoreillycomsourcenostarchimages854157.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7. Function editing dialog
  prefs: []
  type: TYPE_NORMAL
- en: '**End address**'
  prefs: []
  type: TYPE_NORMAL
- en: The address following the last instruction in the function. Most frequently,
    this is the address of the location that follows the function’s return instruction.
    In most cases, this address is determined automatically during the analysis phase
    or as part of function creation. In cases where IDA has trouble determining the
    true end of a function, you may need to edit this value manually. Remember, this
    address is not actually part of the function but follows the last instruction
    in the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Local variables area**'
  prefs: []
  type: TYPE_NORMAL
- en: This represents the number of stack bytes dedicated to local variables (see
    [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame "Figure 6-4. An EBP-based stack
    frame")) for the function. In most cases, this value is computed automatically
    based on analysis of stack pointer behavior within the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saved registers**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the number of bytes used to save registers (see [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame")) on behalf of the caller. IDA considers
    the saved register region to lie on top of the saved return address and below
    any local variables associated with the function. Some compilers choose to save
    registers on top of a function’s local variables. IDA considers the space required
    to save such registers as belonging to the local variable area rather than a dedicated
    saved registers area.
  prefs: []
  type: TYPE_NORMAL
- en: '**Purged bytes**'
  prefs: []
  type: TYPE_NORMAL
- en: Purged bytes shows the number of bytes of parameters that a function removes
    from the stack when it returns to its caller. For `cdecl` functions, this value
    is always zero. For `stdcall` functions, this value represents the amount of space
    consumed by any parameters that are passed on the stack (see [Figure 6-4](ch06s02.html#an_ebp-based_stack_frame
    "Figure 6-4. An EBP-based stack frame")). In x86 programs, IDA can automatically
    determine this value when it observes the use of the `RET N` variant of the return
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Frame pointer delta**'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, compilers may adjust a function’s frame pointer to point somewhere
    into the middle of the local variable area rather than at the saved frame pointer
    at the bottom of the local variable area. This distance from the adjusted frame
    pointer to the saved frame pointer is termed the *frame pointer delta*. In most
    cases any frame pointer delta will be computed automatically when the function
    is analyzed. Compilers utilize a stack frame delta as a speed optimization. The
    purpose of the delta is to keep as many stack frame variables as possible within
    reach of a 1-byte signed offset (−128..+127) from the frame pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Additional attribute checkboxes are available to further characterize the function.
    As with other fields within the dialog, these checkboxes generally reflect the
    results of IDA’s automatic analysis. The following attributes can be toggled on
    and off.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does not return**'
  prefs: []
  type: TYPE_NORMAL
- en: The function does not return to its caller. When such a function is called,
    IDA does not assume that execution continues following the associated call instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Far function**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to mark a function as a far function on segmented architectures. Callers
    of the function would need to specify both a segment and an offset value when
    calling the function. The need to use far calls is typically dictated by the memory
    model in use within a program rather than by the fact that the architecture supports
    segmentation, for example, the use of the *large* (as opposed to *flat*) memory
    model on an x86.
  prefs: []
  type: TYPE_NORMAL
- en: '**Library func**'
  prefs: []
  type: TYPE_NORMAL
- en: Flags a function as library code. Library code might include support routines
    included by a compiler or functions that are part of a statically linked library.
    Marking a function as a library function causes the function to be displayed using
    the assigned library function coloring to distinguish it from nonlibrary code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static func**'
  prefs: []
  type: TYPE_NORMAL
- en: Does nothing other than display the static modifier in the function’s attribute
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '**BP based frame**'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates that the function utilizes a frame pointer. In most cases you determine
    this automatically by analyzing the function’s prologue. If analysis fails to
    recognize that a frame pointer is used in the given function, you can manually
    select this attribute. If you do manually select this attribute, make sure that
    you adjust the saved register size (usually increased by the size of the saved
    frame pointer) and local variable size (usually decreased by the size of the saved
    frame pointer) accordingly. For frame pointer–based frames, memory references
    that make use of the frame pointer are formatted to make use of symbolic stack
    variable names rather than numeric offsets. If this attribute is not set, then
    stack frame references are assumed to be relative to the stack pointer register.
  prefs: []
  type: TYPE_NORMAL
- en: '**BP equals to SP**'
  prefs: []
  type: TYPE_NORMAL
- en: Some functions configure the frame pointer to point to the top of the stack
    frame (along with the stack pointer) upon entering a function. This attribute
    should be set in such cases. This is essentially the same as having a frame pointer
    delta equal in size to the local variable area.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Pointer Adjustments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned previously, IDA makes every effort to track changes to the stack
    pointer at each instruction within a function. The accuracy that IDA manages to
    achieve in doing so significantly impacts the accuracy of the function’s stack
    frame layout. When IDA is unable to determine whether an instruction alters the
    stack pointer, you may find that you need to specify a manual stack pointer adjustment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward example of such a case occurs when one function calls
    another function that makes use of the `stdcall` calling convention. If the function
    being called resides in a shared library that IDA does not have knowledge of (IDA
    ships with knowledge of the signatures and calling conventions of many common
    library functions), then IDA will be unaware that the function utilizes `stdcall`
    and will fail to account for the fact that the stack pointer will have been modified
    by the called function prior to returning. Thus, IDA will reflect an inaccurate
    value for the stack pointer for the remainder of the function. The following function
    call sequence, in which `some_imported_func` resides in a shared library, demonstrates
    this problem (note that the stack pointer line part option has been turned on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since `some_imported_func` uses `stdcall`, it cleans the three parameters from
    the stack as it returns, and the correct stack pointer value at ![](httpatomoreillycomsourcenostarchimages854061.png)
    should be `01C`. One way to fix this problem is to associate a manual stack adjustment
    with the instruction at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Stack adjustments can be added by highlighting the address to which the adjustment
    applies, selecting Edit ▸ Functions ▸ Change Stack Pointer (hotkey alt-K), and
    specifying the number of bytes by which the stack pointer changes, in this case
    12.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the previous example serves to illustrate a point, there is a better
    solution to this particular problem. Consider the case in which `some_imported_func`
    is called many different times. In that case, we would need to make the stack
    adjustment we just made at each location from which `some_imported_func` is called.
    Clearly this could be very tedious, and we might miss something. The better solution
    is to educate IDA regarding the behavior of `some_imported_func`. Because we are
    dealing with an imported function, when we attempt to navigate to it, we eventually
    end up at the import table entry for that function, which looks something like
    the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though this is an imported function, IDA allows you to edit one piece
    of information concerning its behavior: the number of purged bytes associated
    with the function. By editing this function, you can specify the number of bytes
    that it clears off the stack when it returns, and IDA will propagate the information
    that you supply to every location that calls the function, instantly correcting
    the stack pointer computations at each of those locations.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to improve its automated analysis, IDA incorporates advanced techniques
    that attempt to resolve stack pointer discrepancies by solving a system of linear
    equations related to the behavior of the stack pointer. As a result, you may not
    even realize that IDA has no prior knowledge of the details of functions such
    as `some_imported_func`. For more information on these techniques, refer to Ilfak’s
    blog post titled “Simplex method in IDA Pro” at [http://hexblog.com/2006/06/](http://hexblog.com/2006/06/).
  prefs: []
  type: TYPE_NORMAL
- en: Converting Data to Code (and Vice Versa)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the automatic analysis phase, bytes are occasionally categorized incorrectly.
    Data bytes may be incorrectly classified as code bytes and disassembled into instructions,
    or code bytes may be incorrectly classified as data bytes and formatted as data
    values. This happens for many reasons, including the fact that some compilers
    embed data into the code section of programs or the fact that some code bytes
    are never directly referenced as code and IDA opts not to disassemble them. Obfuscated
    programs in particular tend to blur the distinction between code sections and
    data sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the reason that you wish to reformat your disassembly, doing
    so is fairly easy. The first option for reformatting anything is to remove its
    current formatting (code or data). It is possible to undefine functions, code,
    or data by right-clicking the item that you wish to undefine and selecting Undefine
    (also Edit ▸ Undefine or hotkey U) from the resulting context-sensitive menu.
    Undefining an item causes the underlying bytes to be reformatted as a list of
    raw byte values. Large regions can be undefined by using a click-and-drag operation
    to select a range of addresses prior to performing the undefine operation. As
    an example, consider the simple function listing that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Undefining this function would yield the series of uncategorized bytes shown
    here, which we could choose to reformat in virtually any manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To disassemble a sequence of undefined bytes, right-click the first byte to
    be disassembled and select Code (also Edit ▸ Code or hotkey C). This causes IDA
    to disassemble all bytes until it encounters a defined item or an illegal instruction.
    Large regions can be converted to code by using a click-and-drag operation to
    select a range of addresses prior to performing the code-conversion operation.
  prefs: []
  type: TYPE_NORMAL
- en: The complementary operation of converting code to data is a little more complex.
    First, it is not possible to convert code to data using the context menu. Available
    alternatives include Edit ▸ Data and the D hotkey. Bulk conversions of instructions
    to data are easiest to accomplish by first undefining all of the instructions
    that you wish to convert to data and then formatting the data appropriately. Basic
    data formatting is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Data Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Properly formatted data can be as important in developing an understanding of
    a program’s behavior as properly formatted code. IDA takes information from a
    variety of sources and uses many algorithms in order to determine the most appropriate
    way to format data within a disassembly. A few examples serve to illustrate how
    data formats are selected.
  prefs: []
  type: TYPE_NORMAL
- en: Datatypes and/or sizes can be inferred from the manner in which registers are
    used. An instruction observed to load a 32-bit register from memory implies that
    the associated memory location holds a 4-byte datatype (though we may not be able
    to distinguish between a 4-byte integer and a 4-byte pointer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function prototypes can be used to assign datatypes to function parameters.
    IDA maintains a large library of function prototypes for exactly this purpose.
    Analysis is performed on the parameters passed to functions in an attempt to tie
    a parameter to a memory location. If such a relationship can be uncovered, then
    a datatype can be applied to the associated memory location. Consider a function
    whose single parameter is a pointer to a CRITICAL_SECTION (a Windows API datatype).
    If IDA can determine the address passed in a call to this function, then IDA can
    flag that address as a CRITICAL_SECTION object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analysis of a sequence of bytes can reveal likely datatypes. This is precisely
    what happens when a binary is scanned for string content. When long sequences
    of ASCII characters are encountered, it is not unreasonable to assume that they
    represent character arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next few sections we discuss some basic transformations that you can
    perform on data within your disassemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Data Sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to modify a piece of data is to adjust its size. IDA offers
    a number of data size/type specifiers. The most commonly encountered specifiers
    are `db`, `dw`, and `dd`, representing 1-, 2-, and 4-byte data, respectively.
    The first way to change a data item’s size is via the Options ▸ Setup Data Types
    dialog shown in [Figure 7-8](ch07s04.html#the_datatype_setup_dialog "Figure 7-8. The
    datatype setup dialog").
  prefs: []
  type: TYPE_NORMAL
- en: There are two parts to this dialog. The left side of the dialog contains a column
    of buttons used to immediately change the data size of the currently selected
    item. The right side of the dialog contains a column of checkboxes used to configure
    what IDA terms the *data carousel*. Note that for each button on the left, there
    is a corresponding checkbox on the right. The data carousel is a revolving list
    of datatypes that contains only those types whose checkboxes are selected. Modifying
    the contents of the data carousel has no immediate impact on the IDA display.
    Instead, each type on the data carousel is listed on the context-sensitive menu
    that appears when you right-click a data item. Thus, it is easier to reformat
    data to a type listed in the data carousel than to a type not listed in the data
    carousel. Given the datatypes selected in [Figure 7-8](ch07s04.html#the_datatype_setup_dialog
    "Figure 7-8. The datatype setup dialog"), right-clicking a data item would offer
    you the opportunity to reformat that item as byte, word, or double-word data.
  prefs: []
  type: TYPE_NORMAL
- en: '![The datatype setup dialog](httpatomoreillycomsourcenostarchimages854159.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8. The datatype setup dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'The name for the data carousel derives from the behavior of the associated
    data formatting hotkey: D. When you press D, the item at the currently selected
    address is reformatted to the next type in the data carousel list. With the three-item
    list specified previously, an item currently formatted as `db` toggles to `dw`,
    an item formatted as `dw` toggles to `dd`, and an item formatted as `dd` toggles
    back to `db` to complete the circuit around the carousel. Using the data hotkey
    on a nondata item such as code causes the item to be formatted as the first datatype
    in the carousel list (`db` in this case).'
  prefs: []
  type: TYPE_NORMAL
- en: Toggling through datatypes causes data items to grow, shrink, or remain the
    same size. If an item’s size remains the same, then the only observable change
    is in the way the data is formatted. If you reduce an item’s size, from `dd` (4
    bytes) to `db` (1 byte) for example, any extra bytes (3 in this case) become undefined.
    If you increase the size of an item, IDA complains if the bytes following the
    item are already defined and asks you, in a roundabout way, if you want IDA to
    undefine the next item in order to expand the current item. The message you encounter
    in such cases is “Directly convert to data?” This message generally means that
    IDA will undefine a sufficient number of succeeding items to satisfy your request.
    For example, when converting byte data (`db`) to double-word data (`dd`), 3 additional
    bytes must be consumed to form the new data item.
  prefs: []
  type: TYPE_NORMAL
- en: Datatypes and sizes can be specified for any location that describes data, including
    stack variables. To change the size of stack-allocated variables, open the detailed
    stack frame view by double-clicking the variable you wish to modify; then change
    the variable’s size as you would any other variable.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA recognizes a large number of string formats. By default, IDA searches for
    and formats C-style null-terminated strings. To force data to be converted to
    a string, utilize the options on the Edit ▸ Strings menu to select a specific
    string style. If the bytes beginning at the currently selected address form a
    string of the selected style, IDA groups those bytes together into a single-string
    variable. At any time, you can use the A hotkey to format the currently selected
    location in the default string style.
  prefs: []
  type: TYPE_NORMAL
- en: Two dialogs are responsible for the configuration of string data. The first,
    shown in [Figure 7-9](ch07s04.html#string_data_configuration "Figure 7-9. String
    data configuration"), is accessed via Options ▸ ASCII String Style, though ASCII
    in this case is a bit of a misnomer, as a much wider variety of string styles
    are understood.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the datatype configuration dialog, the buttons on the left are used
    to create a string of the specified style at the currently selected location.
    A string is created only if the data at the current location conforms to the specified
    string format. For *Character terminated* strings, up to two termination characters
    can be specified toward the bottom of the dialog. The radio buttons on the right
    of the dialog are used to specify the default string style associated with the
    use of the strings hotkey (A).
  prefs: []
  type: TYPE_NORMAL
- en: '![String data configuration](httpatomoreillycomsourcenostarchimages854161.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9. String data configuration
  prefs: []
  type: TYPE_NORMAL
- en: The second dialog used to configure string operations is the Options ▸ General
    dialog, shown in [Figure 7-10](ch07s04.html#ida_strings_options "Figure 7-10. IDA
    Strings options"), where the Strings tab allows configuration of additional strings-related
    options. While you can specify the default string type here as well using the
    available drop-down box, the majority of available options deal with the naming
    and display of string data, regardless of their type. The Name generation area
    on the right of the dialog is visible only when the Generate names option is selected.
    When name generation is turned off, string variables are given dummy names beginning
    with the `asc_` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '![IDA Strings options](httpatomoreillycomsourcenostarchimages854163.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10. IDA Strings options
  prefs: []
  type: TYPE_NORMAL
- en: 'When name generation is enabled, the Name generation options control how IDA
    generates names for string variables. When Generate serial names is *not* selected
    (the default), the specified prefix is combined with characters taken from the
    string to generate a name that does not exceed the current maximum name length.
    An example of such a string appears here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Title case is used in the name, and any characters that are not legal to use
    within names (such as spaces) are omitted when forming the name. The Mark as autogenerated
    option causes generated names to appear in a different color (dark blue by default)
    than user-specified names (blue by default). Preserve case forces the name to
    use characters as they appear within the string rather than converting them to
    title case. Finally, Generate serial names causes IDA to serialize names by appending
    numeric suffixes (beginning with Number). The number of digits in generated suffixes
    is controlled by the Width field. As configured in [Figure 7-10](ch07s04.html#ida_strings_options
    "Figure 7-10. IDA Strings options"), the first three names to be generated would
    be `a000`, `a001`, and `a002`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the drawbacks to disassembly listings derived from higher-level languages
    is that they provide very few clues regarding the size of arrays. In a disassembly
    listing, specifying an array can require a tremendous amount of space if each
    item in the array is specified on its own disassembly line. The following listing
    shows data declarations that follow the named variable `unk_402060`. The fact
    that only the first item in the listing is referenced by any instructions suggests
    that it may be the first element in an array. Rather than being referenced directly,
    additional elements within arrays are often referenced using more complex index
    computations to offset from the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: IDA provides facilities for grouping consecutive data definitions together into
    a single array definition. To create an array, select the first element of the
    array (we chose `unk_402060`) and use Edit ▸ Array to launch the array-creation
    dialog shown in [Figure 7-11](ch07s04.html#array-creation_dialog "Figure 7-11. Array-creation
    dialog"). If a data item has been defined at a given location, then an Array option
    will be available when you right-click the item. The type of array to be created
    is dictated by the datatype associated with the item selected as the first item
    in the array. In this case we are creating an array of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Array-creation dialog](httpatomoreillycomsourcenostarchimages854165.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11. Array-creation dialog
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to creating an array, make sure that you select the proper size for array
    elements by changing the size of the first item in the array to the appropriate
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are descriptions of useful fields for array creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Array element width**'
  prefs: []
  type: TYPE_NORMAL
- en: This value indicates the size of an individual array element (1 byte in this
    case) and is dictated by the size of the data value that was selected when the
    dialog was launched.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maximum possible size**'
  prefs: []
  type: TYPE_NORMAL
- en: This value is automatically computed as the maximum number of elements (not
    bytes) that can be included in the array before another defined data item is encountered.
    Specifying a larger size may be possible but will require succeeding data items
    to be undefined in order to absorb them into the array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of elements**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where you specify the exact size of the array. The total number of bytes
    occupied by the array can be computed as Number of elements × Array element width.
  prefs: []
  type: TYPE_NORMAL
- en: '**Items on a line**'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the number of elements to be displayed on each disassembly line. This
    can be used to reduce the amount of space required to display the array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Element width**'
  prefs: []
  type: TYPE_NORMAL
- en: This value is for formatting purposes only and controls the column width when
    multiple items are displayed on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use “dup” construct**'
  prefs: []
  type: TYPE_NORMAL
- en: This option causes identical data values to be grouped into a single item with
    a repetition specifier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signed elements**'
  prefs: []
  type: TYPE_NORMAL
- en: Dictates whether data is displayed as signed or unsigned values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Display indexes**'
  prefs: []
  type: TYPE_NORMAL
- en: Causes array indexes to be displayed as regular comments. This is useful if
    you need to locate specific data values within large arrays. Selecting this option
    also enables the Indexes radio buttons so you can choose the display format for
    each index value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Create as array**'
  prefs: []
  type: TYPE_NORMAL
- en: Not checking this may seem to go against the purpose of the dialog, and it is
    usually left checked. Uncheck it if your goal is simply to specify some number
    of consecutive items without grouping them into an array.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting the options specified in [Figure 7-11](ch07s04.html#array-creation_dialog
    "Figure 7-11. Array-creation dialog") results in the following compact array declaration,
    which can be read as an array of bytes (`db`) named `byte_402060` consisting of
    the value `0` repeated `416` (`1A0h`) times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The net effect is that 416 lines of disassembly have been condensed to a single
    line (largely due to the use of `dup`). In the next chapter we will discuss the
    creation of arrays within stack frames.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Together with the previous chapter, this chapter encompasses the most common
    operations that IDA users will ever need to perform. Through the use of database
    modifications, you will combine your own knowledge with the knowledge imparted
    by IDA during its analysis phase to produce much more useful databases. As with
    source code, the effective use of names, assignment of datatypes, and detailed
    comments will not only assist you in remembering what you have analyzed but will
    also greatly assist others who may be required to make use of your work. In the
    next chapter we continue to drill into IDA’s capabilities by taking a look at
    how to deal with more complex data structures, such as those represented by the
    C `struct`, and go on to examine some of the low-level details of compiled C++.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Datatypes and Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The low-hanging fruit in understanding the behavior of binary programs lies
    in cataloging the library functions that the program calls. A C program that calls
    the `connect` function is creating a network connection. A Windows program that
    calls `RegOpenKey` is accessing the Windows registry. Additional analysis is required,
    however, to gain an understanding of how and why these functions are called.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering how a function is called requires learning what parameters are passed
    to the function. In the case of a `connect` call, beyond the simple fact that
    the function is being called, it is important to know exactly what network address
    the program is connecting to. Understanding the data that is being passed into
    functions is the key to reverse engineering a function’s signature (the number,
    type, and sequence of parameters required by the function) and, as such, points
    out the importance of understanding how datatypes and data structures are manipulated
    at the assembly language level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will examine how IDA conveys datatype information to the
    user, how data structures are stored in memory, and how data within those data
    structures is accessed. The simplest method for associating a specific datatype
    with a variable is to observe the use of the variable as a parameter to a function
    that we know something about. During its analysis phase, IDA makes every effort
    to annotate datatypes when they can be deduced based on a variable’s use with
    a function for which IDA possesses a prototype. When possible, IDA will go as
    far as using a formal parameter name lifted from a function prototype rather than
    generating a default dummy name for the variable. This can be seen in the following
    disassembly of a call to `connect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this listing we can see that each `push` has been commented with the name
    of the parameter that is being pushed (taken from IDA’s knowledge of the function
    prototype). In addition, two local stack variables ![](httpatomoreillycomsourcenostarchimages854061.png)
    have been named for the parameters that they correspond to. In most cases, these
    names will be far more informative than the dummy names that IDA would otherwise
    generate.
  prefs: []
  type: TYPE_NORMAL
- en: IDA’s ability to propagate type information from function prototypes is not
    limited to library functions contained in IDA’s type libraries. IDA can propagate
    formal parameter names and data types from any function in your database as long
    as you have explicitly set the function’s type information. Upon initial analysis,
    IDA assigns dummy names and the generic type `int` to all function arguments,
    unless through type propagation it has reason to do otherwise. In any case, you
    must set a function’s type by using the Edit ▸ Functions ▸ Set Function Type command,
    right-clicking on a function name, and choosing Set Function Type on the context
    menu or using the Y hotkey. For the function shown below, this results in the
    dialog shown in [Figure 8-1](ch08.html#setting_a_functionas_type "Figure 8-1. Setting
    a function’s type"), in which you may enter the function’s correct prototype.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As shown below, IDA assumes an `int` return type, correctly deduces that the
    `cdecl` calling convention is used based on the type of `ret` instruction used,
    incorporates the name of the function as we have modified it, and assumes all
    parameters are of type `int`. Because we have not yet modified the argument names,
    IDA displays only their types.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting a function’s type](httpatomoreillycomsourcenostarchimages854167.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. Setting a function’s type
  prefs: []
  type: TYPE_NORMAL
- en: If we modify the prototype to read `int __cdecl foo(float f, char *ptr)`, IDA
    will automatically insert a prototype comment ![](httpatomoreillycomsourcenostarchimages854061.png)
    for the function and change the argument names ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the disassembly as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Finally, IDA propagates this information to all callers of the newly modified
    function, resulting in improved annotation of all related function calls as shown
    here. Note that the argument names `f` and `ptr` have been propagated out as comments
    ![](httpatomoreillycomsourcenostarchimages854093.png) in the calling function
    and used to rename variables ![](httpatomoreillycomsourcenostarchimages854095.png)
    that formerly used dummy names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to imported library functions, it is often the case that IDA will
    already know the prototype of the function. In such cases, you can easily view
    the prototype by holding the mouse over the function name.^([[44](#ftn.CHP-8-FN-1)])
    When IDA has no knowledge of a function’s parameter sequence, it should, at a
    minimum, know the name of the library from which the function was imported (see
    the Imports window). When this happens, your best resources for learning the behavior
    of the function are any associated man pages or other available API documentation
    (such as MSDN online^([[45](#ftn.CHP-8-FN-2)])). When all else fails, remember
    the adage: *Google is your friend*.'
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this chapter, we will be discussing how to recognize when
    data structures are being used in a program, how to decipher the organizational
    layout of such structures, and how to use IDA to improve the readability of a
    disassembly when such structures are in use. Since C++ classes are a complex extension
    of C structures, the chapter concludes with a discussion of reverse engineering
    compiled C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing Data Structure Use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While primitive datatypes are often a natural fit with the size of a CPU’s registers
    or instruction operands, composite datatypes such as arrays and structures typically
    require more complex instruction sequences in order to access the individual data
    items that they contain. Before we can discuss IDA’s feature for improving the
    readability of code that utilizes complex datatypes, we need to review what that
    code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Array Member Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are the simplest composite data structure in terms of memory layout.
    Traditionally, arrays are contiguous blocks of memory that contain consecutive
    elements of the same datatype. The size of an array is easy to compute, as it
    is the product of the number of elements in the array and the size of each element.
    Using C notation, the minimum number of bytes consumed by the following array
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: is computed as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Individual array elements are accessed by supplying an index value, which may
    be a variable or a constant, as shown in these array references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Assuming, for the sake of example, that `sizeof(int)` is 4 bytes, then the first
    array access at ![](httpatomoreillycomsourcenostarchimages854061.png) accesses
    the integer value that lies 80 bytes into the array, while the second array access
    at ![](httpatomoreillycomsourcenostarchimages854063.png) accesses successive integers
    at offsets 0, 4, 8, .. 96 bytes into the array. The offset for the first array
    access can be computed at compile time as `20 * 4`. In most cases, the offset
    for the second array access must be computed at runtime because the value of the
    loop counter, `i`, is not fixed at compile time. Thus for each pass through the
    loop, the product `i * 4` must be computed to determine the exact offset into
    the array. Ultimately, the manner in which an array element is accessed depends
    not only on the type of index used but also on where the array happens to be allocated
    within the program’s memory space.
  prefs: []
  type: TYPE_NORMAL
- en: Globally Allocated Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When an array is allocated within the global data area of a program (within
    the `.data` or `.bss` section, for example), the base address of the array is
    known to the compiler at compile time. The fixed base address makes it possible
    for the compiler to compute fixed addresses for any array element that is accessed
    using a fixed index. Consider the following trivial program that accesses a global
    array using both fixed and variable offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This program disassembles to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: While this program has only one global variable, the disassembly lines at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png)
    seem to indicate that there are three global variables. The computation of an
    offset (`eax * 4`) at ![](httpatomoreillycomsourcenostarchimages854095.png) is
    the only thing that seems to hint at the presence of a global array named `dword_40B720`,
    yet this is the same name as the global variable found at ![](httpatomoreillycomsourcenostarchimages854061.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the dummy names assigned by IDA, we know that the global array is
    made up of the 12 bytes beginning at address `0040B720`. During the compilation
    process, the compiler has used the fixed indexes (0, 1, 2) to compute the actual
    addresses of the corresponding elements in the array (`0040B720`, `0040B724`,
    and `0040B728`), which are referenced using the global variables at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png).
    Using IDA’s array-formatting operations discussed in the last chapter (Edit ▸
    Array), `dword_40B720` can be formatted as a three-element array yielding the
    alternate disassembly lines shown in the following listing. Note that this particular
    formatting highlights the use of offsets into the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are two points to note in this example. First, when constant indexes are
    used to access global arrays, the corresponding array elements will appear as
    global variables in the corresponding disassembly. In other words, the disassembly
    will offer essentially no evidence that an array exists. The second point is that
    the use of variable index values leads us to the start of the array because the
    base address will be revealed (as in ![](httpatomoreillycomsourcenostarchimages854095.png))
    when the computed offset is added to it to compute the actual array location to
    be accessed. The computation at ![](httpatomoreillycomsourcenostarchimages854095.png)
    offers one additional piece of significant information about the array. By observing
    the amount by which the array index is multiplied (4 in this case), we learn the
    size (though not the type) of an individual element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-Allocated Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How does array access differ if the array is allocated as a stack variable instead?
    Instinctively, we might think that it must be different since the compiler can’t
    know an absolute address at compile time, so surely even accesses that use constant
    indexes must require some computation at runtime. In practice, however, compilers
    treat stack-allocated arrays almost identically to globally allocated arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following program that makes use of a small stack-allocated array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The address at which `stack_array` will be allocated is unknown at compile
    time, so it is not possible for the compiler to precompute the address of `stack_array[1]`
    at compile time as it did in the global array example. By examining the disassembly
    listing for this function, we gain insight into how stack-allocated arrays are
    accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As with the global array example, this function appears to have three variables
    (`var_10`, `var_C`, and `var_8`) rather than an array of three integers. Based
    on the constant operands used at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png),
    we know that what appear to be local variable references are actually references
    to the three elements of `stack_array` whose first element must reside at `var_10`,
    the local variable with the lowest memory address.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how the compiler resolved the references to the other elements
    of the array, consider what the compiler goes through when dealing with the reference
    to `stack_array[1]`, which lies 4 bytes into the array, or 4 bytes beyond the
    location of `var_10`. Within the stack frame, the compiler has elected to allocate
    `stack_array` at `ebp - 0x10`. The compiler understands that `stack_array[1]`
    lies at `ebp - 0x10 + 4`, which simplifies to `ebp - 0x0C`. The result is that
    IDA displays this as a local variable reference. The net effect is that, similar
    to globally allocated arrays, the use of constant index values tends to hide the
    presence of a stack-allocated array. Only the array access at ![](httpatomoreillycomsourcenostarchimages854095.png)
    hints at the fact that `var_10` is the first element in the array rather than
    a simple integer variable. In addition, the disassembly line at ![](httpatomoreillycomsourcenostarchimages854095.png)
    also helps us conclude that the size of individual elements in the array is 4
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-allocated arrays and globally allocated arrays are thus treated very similarly
    by compilers. However, there is an extra piece of information that we can attempt
    to extract from the disassembly of the stack example. Based on the location of
    `idx` within the stack, it is possible to conclude that the array that begins
    with `var_10` contains no more than three elements (otherwise, it would overwrite
    `idx`). If you are an exploit developer, this can be very useful in determining
    exactly how much data you can fit into an array before you overflow it and begin
    to corrupt the data that follows.
  prefs: []
  type: TYPE_NORMAL
- en: Heap-Allocated Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Heap-allocated arrays are allocated using a dynamic memory allocation function
    such as `malloc` (C) or `new` (C++). From the compiler’s perspective, the primary
    difference in dealing with a heap-allocated array is that the compiler must generate
    all references into the array based on the address value returned from the memory
    allocation function. For the sake of comparison, we now take a look at the following
    function, which allocates a small array in the program heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In studying the corresponding disassembly that follows, you should notice a
    few similarities and differences with the two previous disassemblies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The starting address of the array (returned from `malloc` in the EAX register)
    is stored in the local variable `heap_array`. In this example, unlike the previous
    examples, every access to the array begins with reading the contents of `heap_array`
    to obtain the array’s base address before an offset value can be added to compute
    the address of the correct element within the array. The references to `heap_array[0]`,
    `heap_array[1]`, and `heap_array[2]` require offsets of 0, 4, and 8 bytes, respectively,
    as seen at ![](httpatomoreillycomsourcenostarchimages854061.png), ![](httpatomoreillycomsourcenostarchimages854063.png),
    and ![](httpatomoreillycomsourcenostarchimages854093.png). The operation that
    most closely resembles the previous examples is the reference to `heap_array[idx]`
    at ![](httpatomoreillycomsourcenostarchimages854095.png), in which the offset
    into the array continues to be computed by multiplying the array index by the
    size of an array element.
  prefs: []
  type: TYPE_NORMAL
- en: Heap-allocated arrays have one particularly nice feature. When both the total
    size of the array and the size of each element can be determined, it is easy to
    compute the number of elements allocated to the array. For heap-allocated arrays,
    the parameter passed to the memory allocation function (`0x0C` passed to `malloc`
    at ![](httpatomoreillycomsourcenostarchimages854099.png)) represents the total
    number of bytes allocated to the array. Dividing this by the size of an element
    (4 bytes in this example, as observed from the offsets at ![](httpatomoreillycomsourcenostarchimages854061.png),
    ![](httpatomoreillycomsourcenostarchimages854063.png), and ![](httpatomoreillycomsourcenostarchimages854093.png))
    tells us the number of elements in the array. In the previous example, a three-element
    array was allocated.
  prefs: []
  type: TYPE_NORMAL
- en: The only firm conclusion we can draw regarding the use of arrays is that they
    are easiest to recognize when a variable is used as an index into the array. The
    array-access operation requires the index to be scaled by the size of an array
    element before adding the resulting offset to the base address of the array. Unfortunately,
    as we will show in the next section, when constant index values are used to access
    array elements, they do little to suggest the presence of an array and look remarkably
    similar to code used to access structure members.
  prefs: []
  type: TYPE_NORMAL
- en: Structure Member Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C-style structs, referred to here generically as *structures*, are heterogeneous
    collections of data that allow grouping of items of dissimilar datatypes into
    a single composite datatype. A major distinguishing feature of structures is that
    the data fields within a structure are accessed by name rather than by index,
    as is done with arrays. Unfortunately, field names are converted to numeric offsets
    by the compiler, so by the time you are looking at a disassembly, structure field
    access looks remarkably similar to accessing array elements using constant indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a compiler encounters a structure definition, the compiler maintains a
    running total of the number of bytes consumed by the fields of the structure in
    order to determine the offset at which each field resides within the structure.
    The following structure definition will be used with the upcoming examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The minimum required space to allocate a structure is determined by the sum
    of the space required to allocate each field within the structure. However, you
    should never assume that a compiler utilizes the minimum required space to allocate
    a structure. By default, compilers seek to align structure fields to memory addresses
    that allow for the most efficient reading and writing of those fields. For example,
    4-byte integer fields will be aligned to offsets that are divisible by 4, while
    8-byte doubles will be aligned to offsets that are divisible by 8\. Depending
    on the composition of the structure, meeting alignment requirements may require
    the insertion of padding bytes, causing the actual size of a structure to be larger
    than the sum of its component fields. The default offsets and resulting structure
    size for the example structure shown previously can be seen in the `Default offset`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Structures can be packed into the minimum required space by using compiler options
    to request specific member alignments. Microsoft Visual C/C++ and GNU gcc/g++
    both recognize the `pack` pragma as a means of controlling structure field alignment.
    The GNU compilers additionally recognize the `packed` attribute as a means of
    controlling structure alignment on a per-structure basis. Requesting 1-byte alignment
    for structure fields causes compilers to squeeze the structure into the minimum
    required space. For our example structure, this yields the offsets and structure
    size found in the `Minimum offset` column. Note that some CPUs perform better
    when data is aligned according to its type, while other CPUs may generate exceptions
    if data is *not* aligned on specific boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: With these facts in mind, we can begin our look at how structures are treated
    in compiled code. For the sake of comparison, it is worth observing that, as with
    arrays, access to structure members is performed by adding the base address of
    the structure to the offset of the desired member. However, while array offsets
    can be computed at runtime from a provided index value (because each item in an
    array has the same size), structure offsets must be precomputed and will turn
    up in compiled code as fixed offsets into the structure, looking nearly identical
    to array references that make use of constant indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Globally Allocated Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with globally allocated arrays, the address of globally allocated structures
    is known at compile time. This allows the compiler to compute the address of each
    member of the structure at compile time and eliminates the need to do any math
    at runtime. Consider the following program that accesses a globally allocated
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If this program is compiled with default structure alignment options, we can
    expect to see something like the following when we disassemble it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This disassembly contains no math whatsoever to access the members of the structure,
    and, in the absence of source code, it would not be possible to state with any
    certainty that a structure is being used at all. Because the compiler has performed
    all of the offset computations at compile time, this program appears to reference
    five global variables rather than five fields within a single structure. You should
    be able to note the similarities with the previous example regarding globally
    allocated arrays using constant index values.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-Allocated Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like stack-allocated arrays (see [Stack-Allocated Arrays](ch08.html#stack-allocated_arrays
    "Stack-Allocated Arrays")), stack-allocated structures are equally difficult to
    recognize based on stack layout alone. Modifying the preceding program to use
    a stack-allocated structure, declared in `main`, yields the following disassembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Again, no math is performed to access the structure’s fields since the compiler
    can determine the relative offsets for each field within the stack frame at compile
    time. In this case, we are left with the same, potentially misleading picture
    that five individual variables are being used rather than a single variable that
    happens to contain five distinct fields. In reality, `var_18` should be the start
    of a 24-byte structure, and each of the other variables should somehow be formatted
    to reflect the fact that they are fields within the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Heap-Allocated Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Heap-allocated structures turn out to be much more revealing regarding the size
    of the structure and the layout of its fields. When a structure is allocated in
    the program heap, the compiler has no choice but to generate code to compute the
    proper offset into the structure whenever a field is accessed. This is a result
    of the structure’s address being unknown at compile time. For globally allocated
    structures, the compiler is able to compute a fixed starting address. For stack-allocated
    structures, the compiler can compute a fixed relationship between the start of
    the structure and the frame pointer for the enclosing stack frame. When a structure
    has been allocated in the heap, the only reference to the structure available
    to the compiler is the pointer to the structure’s starting address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying our structure example once again to make use of a heap-allocated
    structure results in the following disassembly. Similar to the heap-allocated
    array example from page 134, we declare a pointer within `main` and assign it
    the address of a block of memory large enough to hold our structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, unlike the global and stack-allocated structure examples,
    we are able to discern the exact size and layout of the structure. The structure
    size can be inferred to be 24 bytes based on the amount of memory requested from
    `malloc` ![](httpatomoreillycomsourcenostarchimages854101.png). The structure
    contains the following fields at the indicated offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: A 4-byte (`dword`) field at offset 0 ![](httpatomoreillycomsourcenostarchimages854061.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2-byte (`word`) field at offset 4 ![](httpatomoreillycomsourcenostarchimages854063.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 1-byte field at offset 6 ![](httpatomoreillycomsourcenostarchimages854093.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 4-byte (`dword`) field at offset 8 ![](httpatomoreillycomsourcenostarchimages854095.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An 8-byte (`qword`) field at offset 16 (10h) ![](httpatomoreillycomsourcenostarchimages854099.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on the use of floating point instructions, we can further deduce that
    the `qword` field is actually a `double`. The same program compiled to pack structures
    with a 1-byte alignment yields the following disassembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The only changes to the program are the smaller size of the structure (now 19
    bytes) and the adjusted offsets to account for the realignment of each structure
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the alignment used when compiling a program, finding structures
    allocated and manipulated in the program heap is the fastest way to determine
    the size and layout of a given data structure. However, keep in mind that many
    functions will not do you the favor of immediately accessing every member of a
    structure to help you understand the structure’s layout. Instead, you may need
    to follow the use of the pointer to the structure and make note of the offsets
    used whenever that pointer is dereferenced. In this manner, you will eventually
    be able to piece together the complete layout of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays of Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some programmers would say that the beauty of composite data structures is
    that they allow you to build arbitrarily complex structures by nesting smaller
    structures within larger structures. Among other possibilities, this capability
    allows for arrays of structures, structures within structures, and structures
    that contain arrays as members. The preceding discussions regarding arrays and
    structures apply just as well when dealing with nested types such as these. As
    an example, consider an array of structures like the following simple program
    in which `heap_struct` points to an array of five `ch8_struct` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The operations required to access `field1` at ![](httpatomoreillycomsourcenostarchimages854061.png)
    include multiplying the index value by the size of an array element, in this case
    the size of the structure, and then adding the offset to the desired field. The
    corresponding disassembly is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The disassembly reveals 120 bytes (![](httpatomoreillycomsourcenostarchimages854063.png))
    being requested from the heap. The array index is multiplied by 24 at ![](httpatomoreillycomsourcenostarchimages854093.png)
    before being added to the start address for the array at ![](httpatomoreillycomsourcenostarchimages854095.png).
    No additional offset is required in order to generate the final address for the
    reference at ![](httpatomoreillycomsourcenostarchimages854095.png). From these
    facts we can deduce the size of an array item (24), the number of items in the
    array (`120 / 24 = 5`), and the fact that there is a 4-byte (`dword`) field at
    offset 0 within each array element. This short listing does not offer enough information
    to draw any conclusions about how the remaining 20 bytes within each structure
    are allocated to additional fields.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[44](#CHP-8-FN-1)]) Holding the mouse over any name in the IDA display causes
    a tool tip–style pop-up window to be displayed that shows up to 10 lines of disassembly
    at the target location. In the case of library function names, this often includes
    the prototype for calling the library function.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[45](#CHP-8-FN-2)]) Please see [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating IDA Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we saw how IDA’s array-aggregation capabilities allow disassembly
    listings to be simplified by collapsing long lists of data declarations into a
    single disassembly line. In the next few sections we take a look at IDA’s facilities
    for improving the readability of code that manipulates structures. Our goal is
    to move away from structure references such as `[edx + 10h]` and toward something
    more readable like `[edx + ch8_struct.field5]`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you discover that a program is manipulating a data structure, you need
    to decide whether you want to incorporate structure field names into your disassembly
    or whether you can make sense of all the numeric offsets sprinkled throughout
    the listing. In some cases, IDA may recognize the use of a structure defined as
    part of the C standard library or the Windows API. In such cases, IDA may have
    knowledge of the exact layout of the structure and be able to convert numeric
    offsets into more symbolic field names. This is the ideal case, as it leaves you
    with a lot less work to do. We will return to this scenario once we understand
    a little more about how IDA deals with structure definitions in general.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New Structure (or Union)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a program appears to be using a structure for which IDA has no layout knowledge,
    IDA offers facilities for specifying the composition of the structure and having
    the newly defined structure incorporated into the disassembly. Structure creation
    in IDA takes place within the Structures window (see [Figure 8-2](ch08s02.html#the_structures_window-id2
    "Figure 8-2. The Structures window")). No structure can be incorporated into a
    disassembly until it is first listed in the Structures window. Any structure that
    is known to IDA and that is recognized to be used by a program will automatically
    be listed in the Structures window.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Structures window](httpatomoreillycomsourcenostarchimages854169.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. The Structures window
  prefs: []
  type: TYPE_NORMAL
- en: There are two reasons why the use of a structure may go unrecognized during
    the analysis phase. First, even though IDA may have knowledge of a particular
    structure’s layout, there may be insufficient information for IDA to conclude
    that the program utilizes the structure. Second, the structure may be a nonstandard
    structure that IDA knows nothing about. In both cases the problem can be overcome,
    and in both cases the solution begins with the Structures window.
  prefs: []
  type: TYPE_NORMAL
- en: The first four lines of text in the Structures window serve as a constant reminder
    of the operations that are possible within the window. The principal operations
    we are concerned with involve adding, removing, and editing structures. Adding
    a structure is initiated using the insert key, which opens the Create Structure/Union
    dialog shown in [Figure 8-3](ch08s02.html#the_create_structure_solidus_union_dialo
    "Figure 8-3. The Create Structure/Union dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Create Structure/Union dialog](httpatomoreillycomsourcenostarchimages854171.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3. The Create Structure/Union dialog
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a new structure, you must first specify the name in the Structure
    name field. The first two checkboxes determine where or whether the new structure
    will be displayed within the Structures window. The third checkbox, Create union,
    specifies whether you are defining a structure or a C-style union.^([[46](#ftn.CHP-8-FN-3)])
    For structures, the size is computed as the sum of the sizes of each component
    field, while for unions, the size is computed as the size of the largest component
    field. The Add standard structure button is used to access the list of all structure
    datatypes that IDA is currently aware of. The behavior of this button is discussed
    in [Using Standard Structures](ch08s05.html "Using Standard Structures") in [Using
    Standard Structures](ch08s05.html "Using Standard Structures"). Once you specify
    a structure name and click OK, an empty structure definition will be created in
    the Structures window, as shown in [Figure 8-4](ch08s02.html#an_empty_structure_definition
    "Figure 8-4. An empty structure definition").
  prefs: []
  type: TYPE_NORMAL
- en: '![An empty structure definition](httpatomoreillycomsourcenostarchimages854173.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4. An empty structure definition
  prefs: []
  type: TYPE_NORMAL
- en: This structure definition must be edited to complete the definition of the structure
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Editing Structure Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to add fields to your new structure, you must make use of the field-creation
    commands D, A, and the asterisk key (*) on the numeric keypad. Initially, only
    the D command is useful, and unfortunately, its behavior is highly dependent on
    the location of the cursor. For that reason, the following steps are recommended
    for adding fields to a structure.
  prefs: []
  type: TYPE_NORMAL
- en: To add a new field to a structure, position the cursor on the last line of the
    structure definition (the one containing `ends`) and press **D**. This causes
    a new field to be added to the end of the structure. The size of the new field
    will be set according to the first size selected on the data carousel ([Chapter 7](ch07.html
    "Chapter 7. Disassembly Manipulation")). The name of the field will initially
    be `field_`*`N`*, where *`N`* is the numeric offset from the start of the structure
    to the start of the new field (`field_0`, for example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you need to modify the size of the field, you may do so by first ensuring
    that the cursor is positioned on the new field name and then selecting the correct
    data size for the field by repeatedly pressing D in order to cycle through the
    datatypes on the data carousel. Alternatively, you may use Options ▸ Setup Data
    Types to specify a size that is not available on the data carousel. If the field
    is an array, right-click the name and select **Array** to open the array specification
    dialog ([Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation")).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change the name of a structure field, click the field name and use the N
    hotkey, or right-click the name and select **Rename**; then provide a new name
    for the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following helpful hints may be of use as you define your own structures.
  prefs: []
  type: TYPE_NORMAL
- en: The byte offset to a field is displayed as an eight-digit hex value on the left
    side of the Structures window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time you add or delete a structure field or change the size of an existing
    field, the new `sizeof` the structure will be reflected on the first line of the
    structure definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add comments to a structure field just as you can add comments to any
    disassembly line. Right-click (or use a hotkey) on the field you wish to add a
    comment to and select one of the available comment options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrary to the instructions at the top of the Structures window, the U key
    will delete a structure field only if it is the last field in the structure. For
    all other fields, pressing U merely undefines the field, which removes the name
    but *does not* remove the bytes allocated to the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are responsible for proper alignment of all fields within a structure definition.
    IDA makes no distinction between packed or unpacked structures. If you require
    padding bytes to properly align fields, then you are responsible for adding them.
    Padding bytes are best added as dummy fields of the proper size, which you may
    or may not choose to undefine once you have added additional fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bytes allocated in the middle of a structure can be removed only by first undefining
    the associated field and then selecting Edit ▸ Shrink Struct Type to remove the
    undefined bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bytes may be inserted into the middle of a structure by selecting the field
    that will follow the new bytes and then using Edit ▸ Expand Struct Type to insert
    a specified number of bytes before the selected field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you know the size of a structure but not the layout, you need to create two
    fields. The first field should be an array of `size-1` bytes. The second field
    should be a 1-byte field. After you have created the second field, undefine the
    first (array) field. The size of the structure will be preserved, and you can
    easily come back later to define fields and their sizes as you learn more about
    the layout of the structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through repeated application of these steps (add field, set field size, add
    padding, and so on), you can create an IDA representation of the `ch8_struct`
    (unpacked version), as shown in [Figure 8-5](ch08s02.html#manually_generated_definition_of_the_ch8
    "Figure 8-5. Manually generated definition of the ch8_struct").
  prefs: []
  type: TYPE_NORMAL
- en: '![Manually generated definition of the ch8_struct](httpatomoreillycomsourcenostarchimages854175.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5. Manually generated definition of the `ch8_struct`
  prefs: []
  type: TYPE_NORMAL
- en: In this example, padding bytes have been included to achieve proper field alignment,
    and fields have been renamed according to the names used in the preceding examples.
    Note that the offsets to each field and the overall size (24 bytes) of the structure
    match the values seen in the earlier examples.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever feel that a structure definition is taking up too much space in
    your Structures window, you can collapse the definition into a one-line summary
    by choosing any field within the structure and pressing the minus key (–) on the
    numeric keypad. This is useful once a structure has been completely defined and
    requires little further editing. The collapsed version of `ch8_struct` is shown
    in [Figure 8-6](ch08s02.html#a_collapsed_structure_definition "Figure 8-6. A collapsed
    structure definition").
  prefs: []
  type: TYPE_NORMAL
- en: The majority of structures that IDA is already aware of will be displayed in
    this one-line fashion since it is not expected that they will need to be edited.
    The collapsed display provides a reminder that you can use the plus key (+) on
    the numeric keypad to expand the definition. Alternatively, double-clicking the
    name of the structure will also expand the definition.
  prefs: []
  type: TYPE_NORMAL
- en: '![A collapsed structure definition](httpatomoreillycomsourcenostarchimages854177.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6. A collapsed structure definition
  prefs: []
  type: TYPE_NORMAL
- en: Stack Frames as Specialized Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may notice that structure definitions look somewhat similar to the detailed
    stack frame views associated with functions. This is no accident, as internally
    IDA treats both identically. Both represent contiguous blocks of bytes that can
    be subdivided into named component fields, each associated with a numeric offset
    into the structure. The minor difference is that stack frames utilize both positive
    and negative field offsets centered on a frame pointer or return address, while
    structures use positive offsets from the beginning of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[46](#CHP-8-FN-3)]) A *union* is similar to a struct in that it may consist
    of many named fields, each of differing type. The difference between the two lies
    in the fact that fields within a union directly overlap one another so that the
    size of a union is equal to the size of the largest field.
  prefs: []
  type: TYPE_NORMAL
- en: Using Structure Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to make use of structure definitions in your disassemblies.
    First, you can reformat memory references to make them more readable by converting
    numeric structure offsets such as `[ebx+8]` into symbolic references such as `[ebx+ch8_struct.field4]`.
    The latter form provides far more information about what is being referenced.
    Because IDA uses a hierarchical notation, it is clear exactly what type of structure,
    and exactly which field within that structure, is being accessed. This technique
    for applying structure templates is most often used when a structure is being
    referenced through a pointer. The second way to use structure templates is to
    provide additional datatypes that can be applied to stack and global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand how structure definitions can be applied to instruction
    operands, it is helpful to view each definition as something similar to set of
    enumerated constants. For example, the definition of `ch8_struct` in [Figure 8-5](ch08s02.html#manually_generated_definition_of_the_ch8
    "Figure 8-5. Manually generated definition of the ch8_struct") might be expressed
    in pseudo-C as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Given such a definition, IDA allows you to reformat any constant value used
    in an operand into an equivalent symbolic representation. [Figure 8-7](ch08s03.html#applying_a_structure_offset
    "Figure 8-7. Applying a structure offset") shows just such an operation in progress.
    The memory reference `[ecx+10h]` may represent an access to `field5` within a
    `ch8_struct`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a structure offset](httpatomoreillycomsourcenostarchimages854179.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7. Applying a structure offset
  prefs: []
  type: TYPE_NORMAL
- en: The Structure offset option, available by right-clicking 10h in this case, offers
    three alternatives for formatting the instruction operand. The alternatives are
    pulled from the set of structures containing a field whose offset is 16.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to formatting individual memory references, stack and global
    variables can be formatted as entire structures. To format a stack variable as
    a structure, open the detailed stack frame view by double-clicking the variable
    to be formatted as a structure and then use **Edit** ▸ **Struct Var** (alt-Q)
    to display a list of known structures similar to that shown in [Figure 8-8](ch08s03.html#the_structure_selection_dialog
    "Figure 8-8. The structure selection dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The structure selection dialog](httpatomoreillycomsourcenostarchimages854181.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8. The structure selection dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting one of the available structures combines the corresponding number
    of bytes in the stack into the corresponding structure type and reformats all
    related memory references as structure references. The following code is an excerpt
    from the stack-allocated structure example we examined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Recall that we concluded that `var_18` is actually the first field in a 24-byte
    structure. The detailed stack frame for this particular interpretation is shown
    in [Figure 8-9](ch08s03.html#stack_allocated_structure_prior_to_forma "Figure 8-9. Stack
    allocated structure prior to formatting").
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack allocated structure prior to formatting](httpatomoreillycomsourcenostarchimages854183.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9. Stack allocated structure prior to formatting
  prefs: []
  type: TYPE_NORMAL
- en: Selecting `var_18` and formatting it as a `ch8_struct` (Edit ▸ Struct Var) collapses
    the 24 bytes (the size of `ch8_struct`) beginning at `var_18` into a single variable,
    resulting in the reformatted stack display shown in [Figure 8-10](ch08s03.html#stack_allocated_structure_after_formatti
    "Figure 8-10. Stack allocated structure after formatting"). In this case, applying
    the structure template to `var_18` will generate a warning message indicating
    that some variables will be destroyed in the process of converting `var_18` into
    a structure. Based on our earlier analysis, this is to be expected, so we simply
    acknowledge the warning to complete the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack allocated structure after formatting](httpatomoreillycomsourcenostarchimages854185.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10. Stack allocated structure after formatting
  prefs: []
  type: TYPE_NORMAL
- en: 'Following reformatting, IDA understands that any memory reference into the
    24-byte block allocated to `var_18` must refer to a field within the structure.
    When IDA encounters such a reference, it makes every effort to resolve the memory
    reference to one of the defined fields within the structure variable. In this
    case, the disassembly is automatically reformatted to incorporate the structure
    layout, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The advantage to using structure notation within the disassembly is an overall
    improvement in the readability of the disassembly. The use of field names in the
    reformatted display provides a much more accurate reflection of how data was actually
    manipulated in the original source code.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure for formatting global variables as structures is nearly identical
    to that used for stack variables. To do so, select the variable or address that
    marks the beginning of the structure and use **Edit** ▸ **Struct Var** (alt-Q)
    to choose the appropriate structure type. As an alternative for undefined global
    data only (not stack data), you may use IDA’s context-sensitive menu, and select
    the structure option to view and select an available structure template to apply
    at the selected address.
  prefs: []
  type: TYPE_NORMAL
- en: Importing New Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After working with IDA’s structure-creation and editing features for a while,
    you may find yourself longing for an easier way to do things. Fortunately, IDA
    does offer some shortcuts concerning new structures. IDA is capable of parsing
    individual C (not C++) data declarations, as well as entire C header files, and
    automatically building IDA structure representations for any structures defined
    in those declarations or header files. If you happen to have the source code,
    or at least the header files, for the binary that you are reversing, then you
    can save a lot of time by having IDA extract related structures directly from
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing C Structure Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Local Types subview window is available by using the View ▸ OpenSubviews ▸
    Local Types command. The Local Types window displays a list of all types that
    have been parsed into the current database. For new databases, the Local Types
    window is initially empty, but the window offers the capability to parse new types
    via the `insert` key or the Insert option from the context menu. The resulting
    type entry dialog is shown in [Figure 8-11](ch08s04.html#the_local_types_entry_dialog
    "Figure 8-11. The Local Types entry dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Local Types entry dialog](httpatomoreillycomsourcenostarchimages854187.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11. The Local Types entry dialog
  prefs: []
  type: TYPE_NORMAL
- en: Errors encountered while parsing the new type are displayed in the IDA output
    window. If the type declaration is successfully parsed, the type and its associated
    declaration are listed in the Local Types window, as shown in [Figure 8-12](ch08s04.html#the_local_types_window
    "Figure 8-12. The Local Types window").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Local Types window](httpatomoreillycomsourcenostarchimages854189.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12. The Local Types window
  prefs: []
  type: TYPE_NORMAL
- en: Note that the IDA parser utilizes a default structure member alignment of 4
    bytes. If your structure requires an alternate alignment, you may include it,
    and IDA will recognize a `pragma pack` directive to specify the desired member
    alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Datatypes added to the Local Types windows are not immediately available via
    the Structures window. There are two methods for adding local type declarations
    to the Structures window. The easiest method is to right-click on the desired
    local type and select **Synchronize to idb**. Alternatively, as each new type
    is added to a list of standard structures; the new type may be imported into the
    Structures window as described in [Using Standard Structures](ch08s05.html "Using
    Standard Structures") in [Using Standard Structures](ch08s05.html "Using Standard
    Structures").
  prefs: []
  type: TYPE_NORMAL
- en: Parsing C Header Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To parse a header file, use **File** ▸ **Load File** ▸ **Parse C Header File**
    to choose the header you wish to parse. If all goes well, IDA returns the message:
    `Compilation successful`. If the parser encounters any problems, you are notified
    that there were errors. Any associated error messages are displayed in the IDA
    output window.'
  prefs: []
  type: TYPE_NORMAL
- en: IDA adds all structures that were successfully parsed to both the list of local
    types and the list of standard structures (to the end of the list to be exact)
    available in the current database. When a new structure has the same name as an
    existing structure, the existing structure definition is overwritten with the
    new structure layout. None of the new structures appear in the Structures window
    until you elect to explicitly add them, as described above for local types or
    in [Using Standard Structures](ch08s05.html "Using Standard Structures") in [Using
    Standard Structures](ch08s05.html "Using Standard Structures").
  prefs: []
  type: TYPE_NORMAL
- en: 'When parsing C header files, it is useful to keep the following points in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in parser does not necessarily use the same default structure member
    alignment as your compiler, though it does honor the `pack` pragma. By default,
    the parser creates structures that are 4-byte aligned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parser understands the C preprocessor `include` directive. To resolve `include`
    directives, the parser searches the directory containing the file being parsed
    as well as any directories listed as `Include` directories in the Options ▸ Compiler
    configuration dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parser understands only C standard datatypes. However, the parser also understands
    the preprocessor `define` directive as well as the C `typedef` statement. Thus,
    types such as `uint32_t` will be correctly parsed if the parser has encountered
    an appropriate `typedef` prior to their use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you don’t have any source code, you may find it easier to quickly define
    a structure layout in C notation using a text editor and parse the resulting header
    file or paste the declaration as a new local type, rather than using IDA’s cumbersome
    manual structure-definition tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New structures are available only in the current database. You must repeat the
    structure-creation steps in each additional database for which you wish to use
    the structures. We will discuss some steps for simplifying this process when we
    discuss TIL files later in the chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, to maximize your chances of successfully parsing a header file,
    you will want to simplify your structure definitions as much as possible through
    the use of standard C datatypes and minimizing the use of `include` files. Remember,
    the most important thing about creating structures in IDA is to ensure that the
    layout is correct. Correct layout depends far more on the correct size of each
    field and the correct alignment of the structure than getting the exact type of
    each field just right. In other words, if you need to replace all occurrences
    of `uint32_t` with `int` in order to get a file to parse correctly, you should
    go right ahead and do it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Standard Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, IDA recognizes a tremendous number of data structures
    associated with various library and API functions. When a database is initially
    created, IDA attempts to determine the compiler and platform associated with the
    binary and loads the structure templates derived from related library header files.
    As IDA encounters actual structure manipulations in the disassembly, it adds the
    appropriate structure definitions to the Structures window. Thus, the Structures
    window represents the subset of known structures that happen to apply to the current
    binary. In addition to creating your own custom structures, you can add additional
    standard structures to the Structures window by drawing from IDA’s list of known
    structure types.
  prefs: []
  type: TYPE_NORMAL
- en: The process for adding a new structure begins by pressing the insert key inside
    the Structures window. [Figure 8-3](ch08s02.html#the_create_structure_solidus_union_dialo
    "Figure 8-3. The Create Structure/Union dialog") showed the Create Structure/Union
    dialog, one component of which is the Add standard structure button. Clicking
    this button grants access to the master list of structures pertaining to the current
    compiler (as detected during the analysis phase) and file format. This master
    list of structures also contains any structures that have been added to the database
    as a result of parsing C header files. The structure selection dialog shown in
    [Figure 8-13](ch08s05.html#standard_structure_selection "Figure 8-13. Standard
    structure selection") is used to choose a structure to add to the Structures window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Standard structure selection](httpatomoreillycomsourcenostarchimages854191.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13. Standard structure selection
  prefs: []
  type: TYPE_NORMAL
- en: You may utilize the search functionality to locate structures based on a partial
    text match. The dialog also allows for prefix matching. If you know the first
    few characters of the structure name, simply type them in (they will appear in
    the status bar at the bottom of the dialog), and the list display will jump to
    the first structure with a matching prefix. Choosing a structure adds the structure
    and any nested structures to the Structures window.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of using standard structures, consider a case in which you wish
    to examine the file headers associated with a Windows PE binary. By default, the
    file headers are not loaded into the database when it is first created; however,
    file headers can be loaded if you select the Manual load option during initial
    database creation. Loading the file headers ensures only that the data bytes associated
    with those headers will be present in the database. In most cases, the headers
    will not be formatted in any way because typical programs make no direct reference
    to their own file headers. Thus there is no reason for the analyzer to apply structure
    templates to the headers.
  prefs: []
  type: TYPE_NORMAL
- en: After conducting some research on the format of a PE binary, you will learn
    that a PE file begins with an MS-DOS header structure named `IMAGE_DOS_HEADER`.
    Further, data contained within the `IMAGE_DOS_HEADER` points to the location of
    an `IMAGE_NT_HEADERS` structure, which details the memory layout of the PE binary.
    Choosing to load the PE headers, you might see something similar to the following
    unformatted data disassembly. Readers familiar with the PE file structure may
    recognize the familiar MS-DOS magic value `MZ` as the first two bytes in the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As this file is formatted here, you would need some PE file reference documentation
    to help you make sense of each of the data bytes. By using structure templates,
    IDA can format these bytes as an `IMAGE_DOS_HEADER`, making the data far more
    useful. The first step is to add the standard `IMAGE_DOS_HEADER` as detailed above
    (you could add the `IMAGE_NT_HEADERS` structure while you are at it). The second
    step is to convert the bytes beginning at `__ImageBase` into an `IMAGE_DOS_HEADER`
    structure using **Edit** ▸ **Struct Var** (alt-Q). This results in the reformatted
    display shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the first 64 (0x40) bytes in the file have been collapsed into
    a single data structure, with the type noted in the disassembly. Unless you possess
    encyclopedic knowledge of this particular structure, though, the meaning of each
    field may remain somewhat cryptic. We can take this operation one step further,
    however, by expanding the structure. When a structured data item is expanded,
    each field is annotated with its corresponding field name from the structure definition.
    Collapsed structures can be expanded using the plus key (+) on the numeric keypad.
    The final version of the listing follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the fields of `IMAGE_DOS_HEADER` do not possess particularly
    meaningful names, so we may need to consult a PE file reference to remind ourselves
    that the `e_lfanew` field ![](httpatomoreillycomsourcenostarchimages854061.png)
    indicates the file offset at which an `IMAGE_NT_HEADERS` structure can be found.
    Applying all of the previous steps to create an `IMAGE_NT_HEADER` at address `00400080`
    (0x80 bytes into the database) yields the nicely formatted structure shown in
    part here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately for us, the field names in this case are somewhat more meaningful.
    We quickly see that the file consists of five sections ![](httpatomoreillycomsourcenostarchimages854061.png)
    and should be loaded into memory at virtual address `00400000` ![](httpatomoreillycomsourcenostarchimages854063.png).
    Expanded structures can be returned to their collapsed state using the minus key
    (−) on the keypad.
  prefs: []
  type: TYPE_NORMAL
- en: IDA TIL Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All datatype and function prototype information in IDA is stored in TIL files.
    IDA ships with type library information for many major compilers and APIs stored
    in the *<IDADIR>/til* directory. The Types window (View ▸ Open subview ▸ Type
    Libraries) lists currently loaded *.til* files and is used to load additional
    *.til* files that you may wish to use. Type libraries are loaded automatically
    based on attributes of the binary discovered during the analysis phase. Under
    ideal circumstances, most users will never need to deal with *.til* files directly.
  prefs: []
  type: TYPE_NORMAL
- en: Loading New TIL Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, IDA may fail to detect that a specific compiler was used to build
    a binary, perhaps because the binary has undergone some form of obfuscation. When
    this happens, you may load additional *.til* files by pressing the insert key
    within the Types window and selecting the desired *.til* files. When a new *.til*
    file is loaded, all structure definitions contained in the file are added to the
    list of standard structures, and type information is applied for any functions
    within the binary that have matching prototypes in the newly loaded *.til* file.
    In other words, when IDA gains new knowledge about the nature of a function, it
    automatically applies that new knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing TIL Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA also makes use of *.til* files to store any custom structure definitions
    that you create manually in the Structures window or through parsing C header
    files. Such structures are stored in a dedicated *.til* file associated with the
    database in which they were created. This file shares the base name of the database
    and has a *.til* extension. For a database named *some_file.idb*, the associated
    type library file would be *some_file.til*. Under normal circumstances you will
    never see this file unless you happen to have the database open in IDA. Recall
    that an *.idb* file is actually an archive file (similar to a *.tar* file) used
    to hold the components of a database when they are not in use. When a database
    is opened, the component files (the *.til* file being one of them) are extracted
    as working files for IDA.
  prefs: []
  type: TYPE_NORMAL
- en: A discussion regarding how to share *.til* files across databases can be found
    at [http://www.hex-rays.com/forum/viewtopic.php?f=6&t=986](http://www.hex-rays.com/forum/viewtopic.php?f=6&t=986).^([[47](#ftn.CHP-8-FN-4)])
    Two techniques are mentioned. The first technique is somewhat unofficial and involves
    copying the *.til* file from an open database into your IDA *til* directory from
    which it can be opened, in any other database, via the Types window. A more official
    way to extract the custom type information from a database is to generate an IDC
    script that can be used to re-create the custom structures in any other database.
    Such a script can be generated using the File ▸ Produce File ▸ Dump Typeinfo to
    IDC File command. However, unlike the first technique, this technique dumps only
    the structures listed in the Structures window, which may not include all structures
    parsed from C header files (whereas the *.til* file-copying technique will).
  prefs: []
  type: TYPE_NORMAL
- en: 'Hex-Rays also provides a standalone tool, named `tilib`, for creating *.til*
    files outside of IDA. The utility is available as a *.zip* file for registered
    users via the Hex-Rays IDA download page. Installation is as simple as extracting
    the *.zip* file contents into *<IDADIR>*. The `tilib` utility may be used to list
    the contents of existing *.til* files or create new *.til* files by parsing C
    (not C++) header files. The following command would list the contents of the Visual
    Studio 6 type library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new *.til* file involves naming the header file to be parsed and
    the *.til* file to be created. Command line options allow you to specify additional
    include file directories or, alternatively, previously parsed *.til* files in
    order to resolve any dependencies contained in your header file. The following
    command creates a new *.til* file containing the declaration of `ch8_struct`.
    The resulting *.til* file must be moved into *<IDADIR>/til* before IDA can make
    use of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `tilib` utility contains a substantial number of additional capabilities,
    some of which are detailed in the README file included with the `tilib` distribution,
    and others of which are briefly detailed by running `tilib` with no arguments.
    Prior to version 6.1, `tilib` is distributed only as a Windows executable; however,
    the *.til* files that it generates are compatible with all versions of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[47](#CHP-8-FN-4)]) This link is accessible to registered users only.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Reversing Primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ classes are the object-oriented extensions of C structs, so it is somewhat
    logical to wrap up our discussion of data structures with a review of the features
    of compiled C++ code. C++ is sufficiently complex that detailed coverage of the
    topic is beyond the scope of this book. Here we attempt to cover the highlights
    and a few of the differences between Microsoft’s Visual C++ and GNU’s g++.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to remember is that a solid, fundamental understanding of
    the C++ language will assist you greatly in understanding compiled C++. Object-oriented
    concepts such as inheritance and polymorphism are difficult enough to learn well
    at the source level. Attempting to dive into these concepts at the assembly level
    without understanding them at the source level will certainly be an exercise in
    frustration.
  prefs: []
  type: TYPE_NORMAL
- en: The this Pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `this` pointer is a pointer available in all nonstatic C++ member functions.
    Whenever such a function is called, `this` is initialized to point to the object
    used to invoke the function. Consider the following functions calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the three calls to `member_func`, `this` takes on the values `&object1`,
    `&object2`, and `p_obj`, respectively. It is easiest to view `this` as a hidden
    first parameter passed in to all nonstatic member functions. As discussed in [Chapter 6](ch06.html
    "Chapter 6. Disassembly Navigation"), Microsoft Visual C++ utilizes the `thiscall`
    calling convention and passes `this` in the ECX register. The GNU g++ compiler
    treats `this` exactly as if it was the first (leftmost) parameter to nonstatic
    member functions and pushes the address of the object used to invoke the function
    as the topmost item on the stack prior to calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: From a reverse engineering point of view, the moving of an address into the
    ECX register immediately prior to a function call is a probable indicator of two
    things. First, the file was compiled using Visual C++. Second, the function is
    a member function. When the same address is passed to two or more functions, we
    can conclude that those functions all belong to the same class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Within a function, the use of ECX prior to initializing it implies that the
    caller must have initialized ECX and is a possible sign that the function is a
    member function (though the function may simply use the `fastcall` calling convention).
    Further, when a member function is observed to pass `this` to additional functions,
    those functions can be inferred to be members of the same class as well.
  prefs: []
  type: TYPE_NORMAL
- en: For code compiled using g++, calls to member functions stand out somewhat less.
    However, any function that does not take a pointer as its first argument can certainly
    be ruled out as a member function.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Functions and Vtables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtual functions provide the means for polymorphic behavior in C++ programs.
    For each class (or subclass through inheritance) that contains virtual functions,
    the compiler generates a table containing pointers to each virtual function in
    the class. Such tables are called *vtables*. Furthermore, every class that contains
    virtual functions is given an additional data member whose purpose is to point
    to the appropriate vtable at runtime. This member is typically referred to as
    a *vtable pointer* and is allocated as the first data member within the class.
    When an object is created at runtime, its vtable pointer is set to point at the
    appropriate vtable. When that object invokes a virtual function, the correct function
    is selected by performing a lookup in the object’s vtable. Thus, vtables are the
    underlying mechanism that facilitates runtime resolution of calls to virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few examples may help to clarify the use of vtables. Consider the following
    C++ class definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this case, SubClass inherits from BaseClass. BaseClass contains four virtual
    functions, while SubClass contains five (four from BaseClass plus the new `vfunc5`).
    Within BaseClass, `vfunc1` is a *pure virtual function* by virtue of the use of
    `= 0` in its declaration. Pure virtual functions have no implementation in their
    declaring class and *must* be overridden in a subclass before the class is considered
    concrete. In other words, there is no function named `Base-Class::vfunc1`, and
    until a subclass provides an implementation, no objects can be instantiated. SubClass
    provides such an implementation, so SubClass objects can be created.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance BaseClass appears to contain two data members and Sub Class
    three data members. Recall, however, that any class that contains virtual functions,
    either explicitly or because they are inherited, also contains a vtable pointer.
    As a result, instantiated BaseClass objects actually have three data members,
    while instantiated SubClass objects have four data members. In each case, the
    first data member is the vtable pointer. Within SubClass, the vtable pointer is
    actually inherited from BaseClass rather than being introduced specifically for
    SubClass. [Figure 8-14](ch08s07.html#a_simple_vtable_layout "Figure 8-14. A simple
    vtable layout") shows a simplified memory layout in which a single SubClass object
    has been dynamically allocated. During the creation of the object, the compiler
    ensures that the new object’s vtable pointer points to the correct vtable (SubClass’s
    in this case).
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple vtable layout](httpatomoreillycomsourcenostarchimages854193.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-14. A simple vtable layout
  prefs: []
  type: TYPE_NORMAL
- en: Note that the vtable for SubClass contains two pointers to functions belonging
    to BaseClass (`BaseClass::vfunc2` and `BaseClass::vfunc4`). This is because SubClass
    does not override either of these functions and instead inherits them from BaseClass.
    Also shown is the typical handling of pure virtual function entries. Because there
    is no implementation for the pure virtual function `BaseClass::vfunc1`, no address
    is available to store in the BaseClass vtable slot for `vfunc1`. In such cases,
    compilers insert the address of an error handling function, often dubbed `purecall`,
    which in theory should never be called but which will usually abort the program
    in the event that it somehow is called.
  prefs: []
  type: TYPE_NORMAL
- en: One consequence of the presence of a vtable pointer is that you must account
    for it when you manipulate the class within IDA. Recall that C++ classes are an
    extension of C structures. Therefore, you may choose to make use of IDA’s structure
    definition features to define the layout of C++ classes. In the case of classes
    that contain virtual functions, you must remember to include a vtable pointer
    as the first field within the class. Vtable pointers must also be accounted for
    in the total size of an object. This is most apparent when observing the dynamic
    allocation of an object using the `new`^([[48](#ftn.CHP-8-FN-5)]) operator, where
    the size value passed to `new` includes the space consumed by all explicitly declared
    fields in the class (and any superclasses) as well as any space required for a
    vtable pointer.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example a SubClass object is created dynamically, and its address
    saved in a BaseClass pointer. The pointer is then passed to a function (`call_vfunc`),
    which uses the pointer to call `vfunc3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `vfunc3` is a virtual function, the compiler must ensure that `Sub-Class::vfunc3`
    is called in this case because the pointer points to a Sub-Class object. The following
    disassembled version of `call_vfunc` demonstrates how the virtual function call
    is resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The vtable pointer is read from the structure at ![](httpatomoreillycomsourcenostarchimages854061.png)
    and saved in the EDX register. Since the parameter `b` points to a SubClass object,
    this will be the address of SubClass’s vtable. At ![](httpatomoreillycomsourcenostarchimages854063.png),
    the vtable is indexed to read the third pointer (the address of `SubClass::vfunc3`
    in this case) into the EAX register. Finally, at ![](httpatomoreillycomsourcenostarchimages854093.png),
    the virtual function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the vtable indexing operation at ![](httpatomoreillycomsourcenostarchimages854063.png)
    looks very much like a structure reference operation. In fact, it is no different,
    and it is possible to define a structure to represent the layout of a class’s
    vtable and then use the defined structure to make the disassembly more readable,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure allows the vtable reference operation to be reformatted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The Object Life Cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An understanding of the mechanism by which objects are created and destroyed
    can help to reveal object hierarchies and nested object relationships as well
    as quickly identify class constructor and destructor functions.^([[49](#ftn.CHP-8-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: For global and statically allocated objects, constructors are called during
    program startup and prior to entry into the `main` function. Constructors for
    stack-allocated objects are invoked at the point the object comes into scope within
    the function in which it is declared. In many cases, this will be immediately
    upon entry to the function in which it is declared. However, when an object is
    declared within a block statement, its constructor is not invoked until that block
    is entered, if it is entered at all. When an object is allocated dynamically in
    the program heap, its creation is a two-step process. In the first step, the `new`
    operator is invoked to allocate the object’s memory. In the second step, the constructor
    is invoked to initialize the object. A major difference between Microsoft’s Visual
    C++ and GNU’s g++ is that Visual C++ ensures that the result of `new` is not null
    prior to invoking the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a constructor executes, the following sequence of actions takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: If the class has a superclass, the superclass constructor is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the class has any virtual functions, the vtable pointer is initialized to
    point to the class’s vtable. Note that this may overwrite a vtable pointer that
    was initialized in the superclass, which is exactly the desired behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the class has any data members that are themselves objects, then the constructor
    for each such data member is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the code-specific constructor is executed. This is the code representing
    the C++ behavior of the constructor specified by the programmer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructors do not specify a return type; however, constructors generated by
    Microsoft Visual C++ actually return `this` in the EAX register. Regardless, this
    is a Visual C++ implementation detail and does not permit C++ programmers to access
    the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: Destructors are called in essentially the reverse order. For global and static
    objects, destructors are called by cleanup code that is executed after the `main`
    function terminates. Destructors for stack-allocated objects are invoked as the
    objects go out of scope. Destructors for heap-allocated objects are invoked via
    the `delete` operator immediately before the memory allocated to the object is
    released.
  prefs: []
  type: TYPE_NORMAL
- en: The actions performed by destructors mimic those performed by constructors,
    with the exception that they are performed in roughly reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: If the class has any virtual functions, the vtable pointer for the object is
    restored to point to the vtable for the associated class. This is required in
    case a subclass had overwritten the vtable pointer as part of its creation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The programmer-specified code for the destructor executes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the class has any data members that are themselves objects, the destructor
    for each such member is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if the object has a superclass, the superclass destructor is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By understanding when superclass constructors and destructors are called, it
    is possible to trace an object’s inheritance hierarchy through the chain of calls
    to its related superclass functions. A final point regarding vtables relates to
    how they are referenced within programs. There are only two circumstances in which
    a class’s vtable is referenced directly, within the class constructor(s) and destructor.
    When you locate a vtable, you can utilize IDA’s data cross-referencing capabilities
    (see [Chapter 9](ch09.html "Chapter 9. Cross-References and Graphing")) to quickly
    locate all constructors and destructors for the associated class.
  prefs: []
  type: TYPE_NORMAL
- en: Name Mangling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also called *name decoration*, *name mangling* is the mechanism C++ compilers
    use to distinguish among overloaded^([[50](#ftn.CHP-8-FN-7)]) versions of a function.
    In order to generate unique names for overloaded functions, compilers decorate
    the function name with additional characters used to encode various pieces of
    information about the function. Encoded information typically describes the return
    type of the function, the class to which the function belongs, and the parameter
    sequence (type and order) required to call the function.
  prefs: []
  type: TYPE_NORMAL
- en: Name mangling is a compiler implementation detail for C++ programs and as such
    is not part of the C++ language specification. Not unexpectedly, compiler vendors
    have developed their own, often-incompatible conventions for name mangling. Fortunately,
    IDA understands the name-mangling conventions employed by Microsoft Visual C++
    and GNU g++ as well as a few other compilers. By default, when a mangled name
    is encountered within a program, IDA displays the demangled equivalent as a comment
    anywhere the name appears in the disassembly. IDA’s name-demangling options are
    selected using the dialog shown in [Figure 8-15](ch08s07.html#demangled_name_display_options
    "Figure 8-15. Demangled name display options"), which is accessed using Options
    ▸ Demangled Names.
  prefs: []
  type: TYPE_NORMAL
- en: '![Demangled name display options](httpatomoreillycomsourcenostarchimages854195.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15. Demangled name display options
  prefs: []
  type: TYPE_NORMAL
- en: 'The three principal options control whether demangled names are displayed as
    comments, whether the names themselves are demangled, or whether no demangling
    is performed at all. Displaying demangled names as comments results in a display
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, displaying demangled names as names results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: where ![](httpatomoreillycomsourcenostarchimages854061.png) is representative
    of the first line of a disassembled function and ![](httpatomoreillycomsourcenostarchimages854063.png)
    is representative of a call to that function.
  prefs: []
  type: TYPE_NORMAL
- en: The Assume GCC v3.x names checkbox is used to distinguish between the mangling
    scheme used in g++ version 2.9.*x* and that used in g++ versions 3.*x* and later.
    Under normal circumstances, IDA should automatically detect the naming conventions
    in use in g++-compiled code. The Setup short names and Setup long names buttons
    offer fine-grained control over the formatting of demangled names with a substantial
    number of options that are documented in IDA’s help system.
  prefs: []
  type: TYPE_NORMAL
- en: Because mangled names carry so much information regarding the signature of each
    function, they reduce the time required to understand the number and types of
    parameters passed into a function. When mangled names are available within a binary,
    IDA’s demangling capability instantly reveals the parameter types and return types
    for all functions whose names are mangled. In contrast, for any function that
    does not utilize a mangled name, you must conduct time-consuming analysis of the
    data flowing into and out of the function in order to determine the signature
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Type Identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ provides operators that allow for runtime determination (`typeid`) and checking
    (`dynamic_cast`) of an object’s datatype. To facilitate these operations, C++
    compilers must embed type information within a program binary and implement procedures
    whereby the type of a polymorphic object can be determined with certainty regardless
    of the type of the pointer that may be dereferenced to access the object. Unfortunately,
    as with name mangling, Runtime Type Identification (RTTI) is a compiler implementation
    detail rather than a language issue, and there is no standard means by which compilers
    implement RTTI capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We will take brief look at the similarities and differences between the RTTI
    implementations of Microsoft Visual C++ and GNU g++. Specifically, the only details
    presented here concern how to locate RTTI information and, from there, how to
    learn the name of class to which that information pertains. Readers desiring more
    detailed discussion of Microsoft’s RTTI implementation should consult the references
    listed at the end of this chapter. In particular, the references detail how to
    traverse a class’s inheritance hierarchy, including how to trace that hierarchy
    when multiple inheritance is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple program, which makes use of polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_type` function must correctly print the type of the object being
    pointed to by the pointer `p`. In this case, it is trivial to realize that “concrete_class”
    must be printed based on the fact that a `concrete_class` object is created in
    the `main` function. The question we answer here is: How does `print_type`, and
    more specifically `typeid`, know what type of object `p` is pointing to?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is surprisingly simple. Since every polymorphic object contains a
    pointer to a vtable, compilers leverage that fact by co-locating class-type information
    with the class vtable. Specifically, the compiler places a pointer immediately
    prior to the class vtable. This pointer points to a structure that contains information
    used to determine the name of the class that owns the vtable. In g++ code, this
    pointer points to a `type_info` structure, which contains a pointer to the name
    of the class. In Visual C++, the pointer points to a Microsoft `RTTICompleteObjectLocator`
    structure, which in turn contains a pointer to a `TypeDescriptor` structure. The
    `TypeDescriptor` structure contains a character array that specifies the name
    of the polymorphic class.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that RTTI information is required only in C++ programs
    that use the `typeid` or `dynamic_cast` operator. Most compilers provide options
    to disable the generation of RTTI in binaries that do not require it; therefore,
    you should not be surprised if RTTI information ever happens to be missing.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you dig deep enough into some RTTI implementations, you will find that it
    is possible to unravel inheritance relationships, though you must understand the
    compiler’s particular implementation of RTTI in order to do so. Also, RTTI may
    not be present when a program does not utilize the `typeid` or `dynamic_cast`
    operators. Lacking RTTI information, what techniques can be employed to determine
    inheritance relationships among C++ classes?
  prefs: []
  type: TYPE_NORMAL
- en: The simplest method of determining an inheritance hierarchy is to observe the
    chain of calls to superclass constructors that are called when an object is created.
    The single biggest hindrance to this technique is the use of inline^([[51](#ftn.CHP-8-FN-8)])
    constructors, the use of which makes it impossible to understand that a superclass
    constructor has in fact been called.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative means for determining inheritance relationships involves the
    analysis and comparison of vtables. For example, in comparing the vtables shown
    in [Figure 8-14](ch08s07.html#a_simple_vtable_layout "Figure 8-14. A simple vtable
    layout"), we note that the vtable for SubClass contains two of the same pointers
    that appear in the vtable for BaseClass. We can easily conclude that BaseClass
    and SubClass must be related in some way, but which one is the base class and
    which one is the subclass? In such cases we can apply the following guidelines,
    singly or in combination, in an attempt to understand the nature of their relationship.
  prefs: []
  type: TYPE_NORMAL
- en: When two vtables contain the same number of entries, the two corresponding classes
    *may* be involved in an inheritance relationship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the vtable for class X contains more entries than the vtable for class
    Y, class X *may* be a subclass of class Y.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the vtable for class X contains entries that are also found in the vtable
    for class Y, then one of the following relationships must exist: X is a subclass
    of Y, Y is a subclass of X, or X and Y are both subclasses of a common superclass
    Z.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the vtable for class X contains entries that are also found in the vtable
    for class Y and the vtable for class X contains at least one `purecall` entry
    that is not also present in the corresponding vtable entry for class Y, then class
    Y is a subclass of class X.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the list above is by no means all-inclusive, we can use these guidelines
    to deduce the relationship between BaseClass and SubClass in [Figure 8-14](ch08s07.html#a_simple_vtable_layout
    "Figure 8-14. A simple vtable layout"). In this case, the last three rules all
    apply, but the last rule specifically leads us to conclude, based on vtable analysis
    alone, that SubClass inherits from BaseClass.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Reverse Engineering References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For further reading on the topic of reverse engineering compiled C++, check
    out these excellent references:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Igor Skochinsky’s article “Reversing Microsoft Visual C++ Part II: Classes,
    Methods and RTTI,” available at [http://www.openrce.org/articles/full_view/23](http://www.openrce.org/articles/full_view/23).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paul Vincent Sabanal and Mark Vincent Yason’s paper “Reversing C++,” available
    at [http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf](http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While many of the details in each of these articles apply specifically to programs
    compiled using Microsoft Visual C++, many of the concepts apply equally to programs
    compiled using other C++ compilers.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[48](#CHP-8-FN-5)]) The `new` operator is used for dynamic memory allocation
    in C++ in much the same way that `malloc` is used in C (though `new` is built
    into the C++ language, where `malloc` is merely a standard library function).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[49](#CHP-8-FN-6)]) A *class constructor* function is an initialization function
    that is invoked automatically when an object is created. A corresponding *destructor*
    is optional and would be called when an object is no longer in scope or similar.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[50](#CHP-8-FN-7)]) In C++, *function overloading* allows programmers to
    use the same name for several functions. The only requirement is that each version
    of an overloaded function must differ from every other version in the sequence
    and/or quantity of parameter types that the function receives. In other words,
    each function prototype must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[51](#CHP-8-FN-8)]) In C/C++ programs a function declared as `inline` is
    treated as a macro by the compiler, and the code for the function is expanded
    in place of an explicit function call. Since the presence of an assembly language
    call statement is a dead giveaway that a function is being called, the use of
    inline functions tends to hide the fact that a function is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can expect to encounter complex datatypes in all but the most trivial programs.
    Understanding how data within complex data structures is accessed and knowing
    how to recognize clues to the layout of those complex data structures is an essential
    reverse engineering skill. IDA provides a wide variety of features designed specifically
    to address the need to deal with complex data structures. Familiarity with these
    features will greatly enhance your ability to comprehend what data is being manipulated
    and spend more time understanding how and why that data is being manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we round out our discussion of IDA’s basic capabilities
    with a discussion of cross-references and graphing before moving on to the more
    advanced aspects of IDA usage that set it apart from other reverse engineering
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Cross-References and Graphing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some of the more common questions asked while reverse engineering a binary are
    along the lines of “Where is this function called from?” and “What functions access
    this data?” These and other similar questions seek to catalog the references to
    and from various resources in a program. Two examples serve to show the usefulness
    of such questions.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the case in which you have located a function containing a stack-allocated
    buffer that can be overflowed, possibly leading to exploitation of the program.
    Since the function may be buried deep within a complex application, your next
    step might be to determine exactly how the function can be reached. The function
    is useless to you unless you can get it to execute. This leads to the question
    “What functions call this vulnerable function?” as well as additional questions
    regarding the nature of the data that those functions may pass to the vulnerable
    function. This line of reasoning must continue as you work your way back up potential
    call chains to find one that you can influence to properly exploit the overflow
    that you have discovered.
  prefs: []
  type: TYPE_NORMAL
- en: In another case, consider a binary that contains a large number of ASCII strings,
    at least one of which you find suspicious, such as “Executing Denial of Service
    attack!” Does the presence of this string indicate that the binary actually performs
    a Denial of Service attack? No, it simply indicates that the binary happens to
    contain that particular ASCII sequence. You might infer that the message is displayed
    somehow just prior to launching an attack; however, you need to find the related
    code in order to verify your suspicions. Here the answer to the question “Where
    is this string referenced?” would help you to quickly track down the program location(s)
    that make use of the string. From there, perhaps it can assist you in locating
    any actual Denial of Service attack code.
  prefs: []
  type: TYPE_NORMAL
- en: IDA helps to answer these types of questions through its extensive cross-referencing
    features. IDA provides a number of mechanisms for displaying and accessing cross-reference
    data, including graph-generation capabilities that provide a highly visual representation
    of the relationships between code and data. In this chapter we discuss the types
    of cross-reference information that IDA makes available, the tools for accessing
    cross-reference data, and how to interpret that data.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin our discussion by noting that cross-references within IDA are often
    referred to simply as *xrefs*. Within this text, we will use *xref* only where
    it is used to refer to the content of an IDA menu item or dialog. In all other
    cases we will stick to the term *cross-reference*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic categories of cross-references in IDA: code cross-references
    and data cross-references. Within each category, we will detail several different
    types of cross-references. Associated with each cross-reference is the notion
    of a direction. All cross-references are made from one address to another address.
    The *from* and *to* addresses may be either code or data addresses. If you are
    familiar with graph theory, you may choose to think of addresses as *nodes* in
    a directed graph and cross-references as the edges in that graph. [Figure 9-1](ch09.html#basic_graph_components
    "Figure 9-1. Basic graph components") provides a quick refresher on graph terminology.
    In this simple graph, three nodes ![](httpatomoreillycomsourcenostarchimages854061.png)
    are connected by two directed edges ![](httpatomoreillycomsourcenostarchimages854063.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic graph components](httpatomoreillycomsourcenostarchimages854197.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1. Basic graph components
  prefs: []
  type: TYPE_NORMAL
- en: Note that nodes may also be referred to as *vertices*. Directed edges are drawn
    using arrows to indicate the allowed direction of travel across the edge. In [Figure 9-1](ch09.html#basic_graph_components
    "Figure 9-1. Basic graph components"), it is possible to travel from the upper
    node to either of the lower nodes, but it is not possible to travel from either
    of the lower nodes to the upper node.
  prefs: []
  type: TYPE_NORMAL
- en: Code cross-references are a very important concept, as they facilitate IDA’s
    generation of *control flow graphs* and *function call graphs*, each of which
    we discuss later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the details of cross-references, it is useful to understand
    how IDA displays cross-reference information in a disassembly listing. [Figure 9-2](ch09.html#a_basic_cross-reference
    "Figure 9-2. A basic cross-reference") shows the header line for a disassembled
    function (`sub_401000`) containing a cross-reference as a regular comment (right
    side of the figure).
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic cross-reference](httpatomoreillycomsourcenostarchimages854199.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2. A basic cross-reference
  prefs: []
  type: TYPE_NORMAL
- en: The text `CODE XREF` indicates that this is a code cross-reference rather than
    a data cross-reference (`DATA XREF`). An address follows, `_main+2A` in this case,
    indicating the address from which the cross-reference originates. Note that this
    is a more descriptive form of address than `.text:0040154A`, for example. While
    both forms represent the same program location, the format used in the cross-reference
    offers the additional information that the cross-reference is being made from
    within the function named `_main`, specifically 0x2A (42) bytes into the `_main`
    function. An up or down arrow will always follow the address, indicating the relative
    direction to the referencing location. In [Figure 9-2](ch09.html#a_basic_cross-reference
    "Figure 9-2. A basic cross-reference"), the down arrow indicates that `_main+2A`
    lies at a higher address than `sub_401000`, and thus you would need to scroll
    down to reach it. Similarly, an up arrow indicates that a referencing location
    lies at a lower memory address, requiring that you scroll up to reach it. Finally,
    every cross-reference comment contains a single-character suffix to identify the
    type of cross-reference that is being made. Each suffix is described later as
    we detail all of IDA’s cross-reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Code Cross-References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A code cross-reference is used to indicate that an instruction transfers or
    may transfer control to another instruction. The manner in which instructions
    transfer control is referred to as a *flow* within IDA. IDA distinguishes among
    three basic flow types: *ordinary*, *jump*, and *call*. Jump and call flows are
    further divided according to whether the target address is a near or far address.
    Far addresses are encountered only in binaries that make use of segmented addresses.
    In the discussion that follows, we make use of the disassembled version of the
    following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The program contains operations that will exercise all of IDA’s cross-referencing
    features, as noted in the comment text.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *ordinary flow* is the simplest flow type, and it represents sequential
    flow from one instruction to another. This is the default execution flow for all
    nonbranching instructions such as `ADD`. There are no special display indicators
    for ordinary flows other than the order in which instructions are listed in the
    disassembly. If instruction A has an ordinary flow to instruction B, then instruction
    B will immediately follow instruction A in the disassembly listing. In the following
    listing, every instruction other than ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) has an associated ordinary
    flow to its immediate successor:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1. Cross-reference sources and targets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Instructions used to invoke functions, such as the x86 `call` instructions
    at ![](httpatomoreillycomsourcenostarchimages854093.png), are assigned a *call
    flow*, indicating transfer of control to the target function. In most cases, an
    ordinary flow is also assigned to `call` instructions, as most functions return
    to the location that follows the `call`. If IDA believes that a function does
    not return (as determined during the analysis phase), then calls to that function
    will not have an ordinary flow assigned. Call flows are noted by the display of
    cross-references at the target function (the destination address of the flow).
    The resulting disassembly of the `callflow` function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In this example, two cross-references are displayed at the address of `callflow`
    to indicate that the function is called twice. The address displayed in the cross-references
    is displayed as an offset into the calling function unless the calling address
    has an associated name, in which case the name is used. Both forms of addresses
    are used in the cross-references shown here. Cross-references resulting from function
    calls are distinguished through use of the `p` suffix (think *P* for *Procedure*).
  prefs: []
  type: TYPE_NORMAL
- en: A *jump flow* is assigned to each unconditional and conditional branch instruction.
    Conditional branches are also assigned ordinary flows to account for control flow
    when the branch is not taken. Unconditional branches have no associated ordinary
    flow because the branch is always taken in such cases. The dashed line break at
    ![](httpatomoreillycomsourcenostarchimages854099.png) is a display device used
    to indicate that an ordinary flow does not exist between two adjacent instructions.
    Jump flows are associated with jump-style cross-references displayed at the target
    of the jump, as shown at ![](httpatomoreillycomsourcenostarchimages854101.png).
    As with call-style cross-references, jump cross-references display the address
    of the referring location (the source of the jump). Jump cross-references are
    distinguished by the use of a `j` suffix (think *J* for *Jump*).
  prefs: []
  type: TYPE_NORMAL
- en: Data Cross-References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data cross-references are used to track the manner in which data is accessed
    within a binary. Data cross-references can be associated with any byte in an IDA
    database that is associated with a virtual address (in other words, data cross-references
    are never associated with stack variables). The three most commonly encountered
    types of data cross-references are used to indicate when a location is being read,
    when a location is being written, and when the address of a location is being
    taken. The global variables associated with the previous example program are shown
    here, as they provide several examples of data cross-references.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: A *read cross-reference* is used to indicate that the contents of a memory location
    are being accessed. Read cross-references can originate only from an instruction
    address but may refer to any program location. The global variable `read_it` is
    read at locations marked ![](httpatomoreillycomsourcenostarchimages854103.png)
    in [Example 9-1](ch09.html#cross-reference_sources_and_targets "Example 9-1. Cross-reference
    sources and targets"). The associated cross-reference comments shown in this listing
    indicate exactly which locations in `main` are referencing `read_it` and are recognizable
    as read cross-references based on the use of the `r` suffix. The first read performed
    on `read_it` is a 32-bit read into the ECX register, which leads IDA to format
    `read_it` as a dword (`dd`). In general IDA takes as many cues as it possibly
    can in order to determine the size and/or type of variables based on how they
    are accessed and how they are used as parameters to functions.
  prefs: []
  type: TYPE_NORMAL
- en: The global variable `write_it` is referenced at the locations marked ![](httpatomoreillycomsourcenostarchimages854133.png)
    in [Example 9-1](ch09.html#cross-reference_sources_and_targets "Example 9-1. Cross-reference
    sources and targets"). Associated *write cross-references* are generated and displayed
    as comments for the `write_it` variable, indicating the program locations that
    modify the contents of the variable. Write cross-references utilize the `w` suffix.
    Here again, IDA has determined the size of the variable based on the fact that
    the 32-bit EAX register is copied into `write_it`. Note that the list of cross-references
    displayed at `write_it` terminates with an ellipsis (![](httpatomoreillycomsourcenostarchimages854201.png)
    above), indicating that the number of cross-references to `write_it` exceeds the
    current display limit for cross-references. This limit can be modified through
    the Number of displayed xrefs setting on the Cross-references tab in the Options
    ▸ General dialog. As with read cross-references, write cross-references can originate
    only from a program instruction but may reference any program location. Generally
    speaking, a write cross-reference that targets a program instruction byte is indicative
    of self-modifying code, which is usually considered bad form and is frequently
    encountered in the de-obfuscation routines used in malware.
  prefs: []
  type: TYPE_NORMAL
- en: The third type of data cross-reference, an *offset cross-reference*, indicates
    that the address of a location is being used (rather than the content of the location).
    The address of global variable `ref_it` is taken at location ![](httpatomoreillycomsourcenostarchimages854135.png)
    in [Example 9-1](ch09.html#cross-reference_sources_and_targets "Example 9-1. Cross-reference
    sources and targets"), resulting in the offset cross-reference comment at `ref_it`
    in the previous listing (suffix `o`). Offset cross-references are commonly the
    result of pointer operations either in code or in data. Array access operations,
    for example, are typically implemented by adding an offset to the starting address
    of the array. As a result, the first address in most global arrays can often be
    recognized by the presence of an offset cross-reference. For this reason, most
    string data (strings being arrays of characters in C/C++) is the target of offset
    cross-references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike read and write cross-references, which can originate only from instruction
    locations, offset cross-references can originate from either instruction locations
    or data locations. An example of an offset that can originate from a program’s
    data section is any table of pointers (such as a vtable) that results in the generation
    of an offset cross-reference from each location within the table to the location
    being pointed to by those locations. You can see this if you examine the vtable
    for class `SubClass` from [Chapter 8](ch08.html "Chapter 8. Datatypes and Data
    Structures"), whose disassembly is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here you see that the address of the vtable is used in the function `SubClass::SubClass(void)`,
    which is the class constructor. The header lines for function `SubClass::vfunc3(void)`,
    shown here, show the offset cross-reference that links the function to a vtable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates one of the characteristics of C++ virtual functions
    that becomes quite obvious when combined with offset cross-references, namely
    that C++ virtual functions are never called directly and should never be the target
    of a call cross-reference. Instead, all C++ virtual functions should be referred
    to by at least one vtable entry and should always be the target of at least one
    offset cross-reference. Remember that overriding a virtual function is not mandatory.
    Therefore, a virtual function can appear in more than one vtable, as discussed
    in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures"). Backtracking
    offset cross-references is one technique for easily locating C++ vtables in a
    program’s data section.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Reference Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With an understanding of what cross-references are, we can now discuss the manner
    in which you may access all of this data within IDA. As mentioned previously,
    the number of cross-reference comments that can be displayed at a given location
    is limited by a configuration setting that defaults to 2\. As long as the number
    of cross-references to a location does not exceed this limit, then working with
    those cross-references is fairly straightforward. Mousing over the cross-reference
    text displays the disassembly of the source region in a tool tip–style display,
    while double-clicking the cross-reference address jumps the disassembly window
    to the source of the cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods for viewing the complete list of cross-references to a
    location. The first method is to open a cross-references subview associated with
    a specific address. By positioning the cursor on an address that is the target
    of one or more cross-references and selecting View ▸ Open Subviews ▸ Cross-References,
    you can open the complete list of cross-references to a given location, as shown
    in [Figure 9-3](ch09.html#cross-reference_display_window "Figure 9-3. Cross-reference
    display window"), which shows the complete list of cross-references to variable
    `write_it`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-reference display window](httpatomoreillycomsourcenostarchimages854203.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3. Cross-reference display window
  prefs: []
  type: TYPE_NORMAL
- en: The columns of the window indicate the direction (Up or Down) to the source
    of the cross-reference, the type of cross-reference (using the type suffixes discussed
    previously), the source address of the cross-reference, and the corresponding
    disassembled text at the source address, including any comments that may exist
    at the source address. As with other windows that display lists of addresses,
    double-clicking any entry repositions the disassembly display to the corresponding
    source address. Once opened, the cross-reference display window remains open and
    accessible via a title tab displayed along with every other open subview’s title
    tab above the disassembly area.
  prefs: []
  type: TYPE_NORMAL
- en: The second way to access a list of cross-references is to highlight a name that
    you are interested in learning about and choose Jump ▸ Jump to xref (hotkey ctrl-X)
    to open a dialog that lists every location that references the selected symbol.
    The resulting dialog, shown in [Figure 9-4](ch09.html#jump_to_cross-reference_dialog
    "Figure 9-4. Jump to cross-reference dialog"), is nearly identical in appearance
    to the cross-reference subview shown in [Figure 9-3](ch09.html#cross-reference_display_window
    "Figure 9-3. Cross-reference display window"). In this case, the dialog was activated
    using the ctrl-X hotkey with the first instance of `write_it` (`.text:0040102B`)
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Jump to cross-reference dialog](httpatomoreillycomsourcenostarchimages854205.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4. Jump to cross-reference dialog
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference in the two displays is behavioral. Being a modal dialog,^([[52](#ftn.CHP-9-FN-1)])
    the display in [Figure 9-4](ch09.html#jump_to_cross-reference_dialog "Figure 9-4. Jump
    to cross-reference dialog") has buttons to interact with and terminate the dialog.
    The primary purpose of this dialog is to select a referencing location and jump
    to it. Double-clicking one of the listed locations dismisses the dialog and repositions
    the disassembly window at the selected location. The second difference between
    the dialog and the cross-reference subview is that the former can be opened using
    a hotkey or context-sensitive menu from any instance of a symbol, while the latter
    can be opened only when you position the cursor on an address that is the target
    of a cross-reference and choose View ▸ Open Subviews ▸ Cross-References. Another
    way of thinking about it is that the dialog can be opened at the source of any
    cross-reference, while the subview can be opened only at the destination of the
    cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the usefulness of cross-reference lists might be to rapidly locate
    every location from which a particular function is called. Many people consider
    the use of the C `strcpy`^([[53](#ftn.CHP-9-FN-2)]) function to be dangerous.
    Using cross-references, locating every call to `strcpy` is as simple as finding
    any one call to `strcpy`, using the ctrl-X hotkey to bring up the cross-reference
    dialog, and working your way through every call cross-reference. If you don’t
    want to take the time to find `strcpy` used somewhere in the binary, you can even
    get away with adding a comment with the text *strcpy* in it and activating the
    cross-reference dialog using the comment.^([[54](#ftn.CHP-9-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: Function Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A specialized cross-reference listing dealing exclusively with function calls
    is available by choosing View ▸ Open Subviews ▸ Function Calls. [Figure 9-5](ch09.html#function_calls_window
    "Figure 9-5. Function calls window") shows the resulting dialog, which lists all
    locations that call the current function (as defined by the cursor location at
    the time the view is opened) in the upper half of the window and all calls made
    by the current function in the lower half of the window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Function calls window](httpatomoreillycomsourcenostarchimages854207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5. Function calls window
  prefs: []
  type: TYPE_NORMAL
- en: Here again, each listed cross-reference can be used to quickly reposition the
    disassembly listing to the corresponding cross-reference location. Restricting
    ourselves to considering function call cross-references allows us to think about
    more abstract relationships than simple mappings from one address to another and
    instead consider how functions relate to one another. In the next section, we
    show how IDA takes advantage of this by providing several types of graphs, all
    designed to assist you in interpreting a binary.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[52](#CHP-9-FN-1)]) A modal dialog must be closed before you can continue
    normal interaction with the underlying application. Modeless dialogs can remain
    open while you continue normal interaction with the application.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[53](#CHP-9-FN-2)]) The `C strcpy` function copies a source array of characters,
    up to and including the associated null termination character, to a destination
    array, with no checks whatsoever that the destination array is large enough to
    hold all of the characters from the source.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[54](#CHP-9-FN-3)]) When a symbol name appears in a comment, IDA treats that
    symbol just as if it was an operand in a disassembled instruction. Double-clicking
    the symbol repositions the disassembly window, and the right-click context-sensitive
    menu becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Graphing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because cross-references relate one address to another, they are a natural
    place to begin if we want to make graphs of our binaries. By restricting ourselves
    to specific types of cross-references, we can derive a number of useful graphs
    for analyzing our binaries. For starters, cross-references serve as the edges
    (the lines that connect points) in our graphs. Depending on the type of graph
    we wish to generate, individual nodes (the points in the graph) can be individual
    instructions, groups of instructions called *basic blocks*, or entire functions.
    IDA has two distinct graphing capabilities: an external graphing capability utilizing
    a bundled graphing application and an integrated, interactive graphing capability.
    Both of these graphing capabilities are covered in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: IDA External (Third-Party) Graphing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA’s external graphing capability utilizes third-party graphing applications
    to display IDA-generated graph files. For Windows versions prior to 6.1, IDA ships
    with a bundled graphing application named `wingraph32`.^([[55](#ftn.CHP-9-FN-4)])
    For IDA 6.0, non-Windows versions of IDA are configured to use the dotty^([[56](#ftn.CHP-9-FN-5)])
    graph viewer by default. Beginning with IDA 6.1, all versions of IDA ship with
    and are configured to use the `qwingraph`^([[57](#ftn.CHP-9-FN-6)]) graph viewer,
    which is a cross-platform Qt port of `wingraph32`. While the dotty configuration
    options remain visible for Linux users, they are commented out by default. The
    graph viewer used by IDA may be configured by editing the GRAPH_VISUALIZER variable
    in *<IDADIR>/cfg/ida.cfg*.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an external-style graph is requested, the source for the graph is generated
    and saved to a temporary file; then the designated third-party graph viewer is
    launched to display the graph. IDA supports two graph specification languages,
    Graph Description Language^([[58](#ftn.CHP-9-FN-7)]) (GDL) and the DOT^([[59](#ftn.CHP-9-FN-8)])
    language utilized by the graphviz^([[60](#ftn.CHP-9-FN-9)]) project. The graph
    specification language used by IDA may be configured by editing the `GRAPH_FORMAT`
    variable in *<IDADIR>/cfg/ida.cfg*. Legal values for this variable are `DOT` and
    `GDL`. You must ensure that the language you specify here is compatible with the
    viewer you have specified in `GRAPH_VISUALIZER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Five types of graphs may be generated from the View ▸ Graphs submenu. Available
    external mode graphs include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Function flowchart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call graph for the entire binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph of cross-references to a symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph of cross-references from a symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customized cross-reference graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For two of these, the flowchart and the call graph, IDA is capable of generating
    and saving GDL (not DOT) files for use independently of IDA. These options may
    be found on the File ▸ Produce file submenu. Saving the specification file for
    other types of graphs may be possible if your configured graph viewer allows you
    to save the currently displayed graph. A number of limitations exist when dealing
    with any external graph. First and foremost is the fact that external graphs are
    not interactive. Manipulation of displayed external graphs is limited by the capabilities
    of your chosen external graph viewer (often only zooming and panning).
  prefs: []
  type: TYPE_NORMAL
- en: BASIC BLOCKS
  prefs: []
  type: TYPE_NORMAL
- en: In a computer program, a *basic block* is a grouping of one or more instructions
    with a single entry to the beginning of the block and a single exit from the end
    of the block. In general, other than the last instruction, every instruction within
    a basic block transfers control to exactly one *successor* instruction within
    the block. Similarly, other than the first instruction, every instruction in a
    basic block receives control from exactly one *predecessor* instruction within
    the block. For the purposes of basic block determination, the fact that function
    call instructions transfer control outside the current function is generally ignored
    unless it is known that the function being called fails to return normally. An
    important behavioral characteristic of basic blocks is that once the first instruction
    in a basic block is executed, the remainder of the block is guaranteed to execute
    to completion. This can factor significantly into runtime instrumentation of a
    program, since it is no longer necessary to set a breakpoint on every instruction
    in a program or even single-step the program in order to record which instructions
    have executed. Instead, breakpoints can be set on the first instruction of each
    basic block, and as each breakpoint is hit, every instruction in its associated
    block can be marked as executed. The Process Stalker component of Pedram Amini’s
    PaiMei^([[61](#ftn.CHP-9-FN-10)]) framework performs in exactly this manner.
  prefs: []
  type: TYPE_NORMAL
- en: External Flowcharts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the cursor positioned within a function, View ▸ Graphs ▸ Flow Chart (hotkey
    F12) generates and displays an external flowchart. The flowchart display is the
    external graph that most closely resembles IDA’s integrated graph-based disassembly
    view. These are not the flowcharts you may have been taught during an introductory
    programming class. Instead, these graphs might better be named “control flow graphs,”
    as they group a function’s instructions into basic blocks and use edges to indicate
    flow from one block to another.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-6](ch09s02.html#external_flowchart_graph "Figure 9-6. External flowchart
    graph") shows a portion of the flowchart of a relatively simple function. As you
    can see, external flowcharts offer very little in the way of address information,
    which can make it difficult to correlate the flowchart view to its corresponding
    disassembly listing.'
  prefs: []
  type: TYPE_NORMAL
- en: '![External flowchart graph](httpatomoreillycomsourcenostarchimages854209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6. External flowchart graph
  prefs: []
  type: TYPE_NORMAL
- en: Flowchart graphs are derived by following the ordinary and jump flows for each
    instruction in a function, beginning with the entry point to the function.
  prefs: []
  type: TYPE_NORMAL
- en: External Call Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function call graph is useful for gaining a quick understanding of the hierarchy
    of function calls made within a program. Call graphs are generated by creating
    a graph node for each function and then connecting function nodes based on the
    existence of a call cross-reference from one function to another. The process
    of generating a call graph for a single function can be viewed as a recursive
    descent through all of the functions that are called from the initial function.
    In many cases, it is sufficient to stop descending the call tree once a library
    function is reached, as it is easier to learn how the library function operates
    by reading documentation associated with the library rather than by attempting
    to reverse engineer the compiled version of the function. In fact, in the case
    of a dynamically linked binary it is not possible to descend into library functions,
    since the code for such functions is not present within the dynamically linked
    binary. Statically linked binaries present a different challenge when generating
    graphs. Since statically linked binaries contain all of the code for the libraries
    that have been linked to the program, related function call graphs can become
    extremely large.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to discuss function call graphs, we make use of the following trivial
    program that does nothing other than create a simple hierarchy of function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: After compiling a dynamically linked binary using GNU gcc, we can ask IDA to
    generate a function call graph using View ▸ Graphs ▸ Function Calls, which should
    yield a graph similar to that shown in [Figure 9-7](ch09s02.html#external_function_call_graph
    "Figure 9-7. External function call graph"). In this instance we have truncated
    the left side of the graph somewhat in order to offer a bit more detail. The call
    graph associated with the `main` function can be seen within the circled area
    in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![External function call graph](httpatomoreillycomsourcenostarchimages854211.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7. External function call graph
  prefs: []
  type: TYPE_NORMAL
- en: Alert readers may notice that the compiler has substituted calls to `puts` and
    `fwrite` for `printf` and `fprintf`, respectively, as they are more efficient
    when printing static strings. Note that IDA utilizes different colors to represent
    different types of nodes in the graph, though the colors are not configurable
    in any way.^([[62](#ftn.CHP-9-FN-11)])
  prefs: []
  type: TYPE_NORMAL
- en: Given the straightforward nature of the previous program listing, why does the
    graph appear to be twice as crowded as it should be? The answer is that the compiler,
    as virtually all compilers do, has inserted wrapper code responsible for library
    initialization and termination as well as for configuring parameters properly
    prior to transferring control to the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to graph a statically linked version of the same program results
    in the nasty mess shown in [Figure 9-8](ch09s02.html#function_call_graph_in_a_statically_link
    "Figure 9-8. Function call graph in a statically linked binary").
  prefs: []
  type: TYPE_NORMAL
- en: The graph in [Figure 9-8](ch09s02.html#function_call_graph_in_a_statically_link
    "Figure 9-8. Function call graph in a statically linked binary") demonstrate a
    behavior of external graphs in general, namely that they are always scaled initially
    to display the entire graph, which can result in very cluttered displays. For
    this particular graph, the status bar at the bottom of the WinGraph32 window indicates
    that there are 946 nodes and 10,125 edges that happen to cross over one another
    in 100,182 locations. Other than demonstrating the complexity of statically linked
    binaries, this graph is all but unusable. No amount of zooming and panning will
    simplify the graph, and beyond that, there is no way to easily locate a specific
    function such as `main` other than by reading the label on each node. By the time
    you have zoomed in enough to be able to read the labels associated with each node,
    only a few dozen nodes will fit within the display.
  prefs: []
  type: TYPE_NORMAL
- en: '![Function call graph in a statically linked binary](httpatomoreillycomsourcenostarchimages854213.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8. Function call graph in a statically linked binary
  prefs: []
  type: TYPE_NORMAL
- en: External Cross-Reference Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two types of cross-reference graphs can be generated for global symbols (functions
    or global variables): cross-references to a symbol (View ▸ Graphs ▸ Xrefs To)
    and cross-references from a symbol (View ▸ Graphs ▸ Xrefs From). To generate an
    Xrefs To graph, a recursive ascent is performed by backtracking all cross-references
    to the selected symbol until a symbol to which no other symbols refer is reached.
    When analyzing a binary, you can use an Xrefs To graph to answer the question,
    “What sequence of calls must be made to reach this function?” [Figure 9-9](ch09s02.html#xrefs_to_graph
    "Figure 9-9. Xrefs To graph") shows the use of an Xrefs To graph to display the
    paths that can be followed to reach the `puts` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Xrefs To graph](httpatomoreillycomsourcenostarchimages854215.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9. Xrefs To graph
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, Xrefs To graphs can assist you in visualizing all of the locations
    that reference a global variable and the chain of function calls required to reach
    those locations. Cross-reference graphs are the only graphs capable of incorporating
    data cross-reference information.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create an Xrefs From graph, a recursive descent is performed by
    following cross-references from the selected symbol. If the symbol is a function
    name, only call references from the function are followed, so data references
    to global variables do not show up in the graph. If the symbol is an initialized
    global pointer variable (meaning that it actually points to something), then the
    corresponding data offset cross-reference is followed. When you graph cross-references
    from a function, the effective behavior is a function call graph rooted at the
    selected function, as shown in [Figure 9-10](ch09s02.html#xrefs_from_graph "Figure 9-10. Xrefs
    From graph").
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the same cluttered graph problems exist when graphing functions
    with a complex call graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xrefs From graph](httpatomoreillycomsourcenostarchimages854217.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-10. Xrefs From graph
  prefs: []
  type: TYPE_NORMAL
- en: Custom Cross-Reference Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom cross-reference graphs, called *User xref charts* in IDA, provide the
    maximum flexibility in generating cross-reference graphs to suit your needs. In
    addition to combining cross-references to a symbol and cross-references from a
    symbol into a single graph, custom cross-reference graphs allow you to specify
    a maximum recursion depth and the types of symbols that should be included or
    excluded from the resulting graph.
  prefs: []
  type: TYPE_NORMAL
- en: View ▸ Graphs ▸ User Xrefs Chart opens the graph customization dialog shown
    in [Figure 9-11](ch09s02.html#user_cross-reference_graph_dialog "Figure 9-11. User
    cross-reference graph dialog"). Each global symbol that occurs within the specified
    address range appears as a node within the resulting graph, which is constructed
    according to the options specified in the dialog. In the most common case, generating
    cross-references from a single symbol, the start and end addresses are identical.
    If the start and end addresses differ, then the resulting graph is generated for
    all nonlocal symbols that occur within the specified range. In the extreme case
    where the start address is the lowest address in the database and the end address
    is the highest address in the database, the resulting graph degenerates to the
    function call graph for the entire binary.
  prefs: []
  type: TYPE_NORMAL
- en: '![User cross-reference graph dialog](httpatomoreillycomsourcenostarchimages854219.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-11. User cross-reference graph dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'The options that are selected in [Figure 9-11](ch09s02.html#user_cross-reference_graph_dialog
    "Figure 9-11. User cross-reference graph dialog") represent the default options
    for all custom cross-reference graphs. Following is a description of the purpose
    of each set of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Starting direction**'
  prefs: []
  type: TYPE_NORMAL
- en: Options allow you to decide whether to search for cross-references from the
    selected symbol, to the selected symbol, or both. If all other options are left
    at their default settings, restricting the starting direction to Cross references
    to results in an Xrefs To–style graph, while restricting direction to Cross references
    from generates an Xrefs From–style graph.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: The Recursive option enables recursive descent (Xrefs From) or ascent (Xrefs
    To) from the selected symbols. Follow only current direction forces any recursion
    to occur in only one direction. In other words, if this option is selected, and
    node B is discovered to be reachable from node A, the recursive descent into B
    adds additional nodes that can be reached only *from* node B. Newly discovered
    nodes that refer *to* node B will not be added to the graph. If you choose to
    deselect Follow only current direction, then when both starting directions are
    selected, each new node added to the graph is recursed in both the *to* and *from*
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recursion depth**'
  prefs: []
  type: TYPE_NORMAL
- en: This option sets the maximum recursion depth and is useful for limiting the
    size of generated graphs. A setting of −1 causes recursion to proceed as deep
    as possible and generates the largest possible graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore**'
  prefs: []
  type: TYPE_NORMAL
- en: These options dictate what types of nodes will be excluded from the generated
    graph. This is another means of restricting the size of the resulting graph. In
    particular, ignoring cross-references from library functions can lead to drastic
    simplifications of graphs in statically linked binaries. The trick is to make
    sure that IDA recognizes as many library functions as possible. Library code recognition
    is the subject of [Chapter 12](ch12.html "Chapter 12. Library Recognition Using
    FLIRT Signatures").
  prefs: []
  type: TYPE_NORMAL
- en: '**Print options**'
  prefs: []
  type: TYPE_NORMAL
- en: These options control two aspects of graph formatting. Print comments causes
    any function comments to be included in a function’s graph node. If Print recursion
    dots is selected and recursion would continue beyond the specified recursion limit,
    a node containing an ellipsis is displayed to indicate that further recursion
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-12](ch09s02.html#user_xref_graph_for_function_depth_under "Figure 9-12. User
    xref graph for function depth_1") shows a custom cross-reference graph generated
    for function `depth_1` in our example program using default options and a recursion
    depth of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![User xref graph for function depth_1](httpatomoreillycomsourcenostarchimages854221.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-12. User xref graph for function `depth_1`
  prefs: []
  type: TYPE_NORMAL
- en: User-generated cross-reference graphs are the most powerful external-mode graphing
    capability available in IDA. External flowcharts have largely been superseded
    by IDA’s integrated graph-based disassembly view, and the remaining external graph
    types are simply canned versions of user-generated cross-reference graphs.
  prefs: []
  type: TYPE_NORMAL
- en: IDA’s Integrated Graph View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With version 5.0, IDA introduced a long-awaited interactive, graph-based disassembly
    view that was tightly integrated into IDA. As mentioned previously, the integrated
    graphing mode provides an alternative interface to the standard text-style disassembly
    listing. While in graph mode, disassembled functions are displayed as control
    flow graphs similar to external-style flowchart graphs. Because a function-oriented
    control flow graph is used, only one function at a time can be displayed while
    in graph mode, and graph mode cannot be used for instructions that lie outside
    any function. For cases in which you wish to view several functions at once, or
    when you need to view instructions that are not part of a function, you must revert
    to the text-oriented disassembly listing.
  prefs: []
  type: TYPE_NORMAL
- en: We detailed basic manipulation of the graph view in [Chapter 5](ch05.html "Chapter 5. IDA
    Data Displays"), but we reiterate a few points here. Switching between text view
    and graph view is accomplished by pressing the spacebar or right-clicking anywhere
    in the disassembly window and selecting either Text View or Graph View as appropriate.
    The easiest way to pan around the graph is to click the background of the graph
    view and drag the graph in the appropriate direction. For large graphs, you may
    find it easier to pan using the Graph Overview window instead. The Graph Overview
    window always displays a dashed rectangle around the portion of the graph currently
    being displayed in the disassembly window. At any time, you can click and drag
    the dashed rectangle to reposition the graph display. Because the graph overview
    window displays a miniature version of the entire graph, using it for panning
    eliminates the need to constantly release the mouse button and reposition the
    mouse as required when panning across large graphs in the disassembly window.
  prefs: []
  type: TYPE_NORMAL
- en: There are no significant differences between manipulating a disassembly in graph
    mode and manipulating a disassembly in text mode. Double-click navigation continues
    to work as you would expect it to, as does the navigation history list. Any time
    you navigate to a location that does not lie within a function (such as a global
    variable), the display will automatically switch to text mode. Graph mode will
    automatically be restored once you navigate back to a function. Access to stack
    variables is identical to that of text mode, with the summary stack view being
    displayed in the root basic block of the displayed function. Detailed stack frame
    views are accessed by double-clicking any stack variable, just as in text mode.
    All options for formatting instruction operands in text mode remain available
    and are accessed in the same manner in graph mode.
  prefs: []
  type: TYPE_NORMAL
- en: The primary user interface change related to graph mode deals with the handing
    of individual graph nodes. [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node
    "Figure 9-13. Typical expanded graph view node") shows a simple graph node and
    its related title bar button controls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Typical expanded graph view node](httpatomoreillycomsourcenostarchimages854223.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-13. Typical expanded graph view node
  prefs: []
  type: TYPE_NORMAL
- en: From left to right, the three buttons on the node’s title bar allow you to change
    the background color of the node, assign or change the name of the node, and access
    the list of cross-references to the node. Coloring nodes is a useful way to remind
    yourself that you have already analyzed a node or to simply make it stand out
    from others, perhaps because it contains code of particular interest. Once you
    assign a node a color, the color is also used as the background color for the
    corresponding instructions in text mode. To easily remove any coloring, right-click
    the node’s title bar and select **Set node color to default**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The middle button on the title bar in [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node
    "Figure 9-13. Typical expanded graph view node") is used to assign a name to the
    address of the first instruction of the node’s basic block. Since basic blocks
    are often the target of jump instructions, many nodes may already have a dummy
    name assigned as the result of being targeted by a jump cross-reference. However,
    it is possible for a basic block to begin without having a name assigned. Consider
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The instruction at ![](httpatomoreillycomsourcenostarchimages854061.png) has
    two potential successors, `loc_401053` and the instruction at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Because it has two successors, ![](httpatomoreillycomsourcenostarchimages854061.png)
    must terminate a basic block, which results in ![](httpatomoreillycomsourcenostarchimages854063.png)
    becoming the first instruction in a new basic block, even though it is not targeted
    explicitly by a jump and thus has no dummy name assigned.
  prefs: []
  type: TYPE_NORMAL
- en: The rightmost button in [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node
    "Figure 9-13. Typical expanded graph view node") is used to access the list of
    cross-references that target the node. Since cross-reference comments are not
    displayed by default in graph mode, this is the easiest way to access and navigate
    to any location that references the node. Unlike the cross-reference lists we
    have discussed previously, the generated node cross-reference list also contains
    an entry for the ordinary flow into the node (designated by type `^`). This is
    required because it is not always obvious in graph view which node is the linear
    predecessor of a given node. If you wish to view normal cross-reference comments
    in graph mode, access the Cross-References tab under Options ▸ General and set
    the Number of displayed xrefs option to something other than zero.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes within a graph may be *grouped* either by themselves or with other nodes
    in order to reduce some of the clutter in a graph. To group multiple nodes, ctrl-click
    the title bar of each node to be grouped and then right-click the title bar of
    any selected node and select **Group nodes**. You will be prompted to enter some
    text (defaults to the first instruction in the group) to be displayed in the collapsed
    node. [Figure 9-14](ch09s02.html#typical_collapsed_open_parenthesis_group "Figure 9-14. Typical
    collapsed (grouped) graph view node") shows the result of grouping the node in
    [Figure 9-13](ch09s02.html#typical_expanded_graph_view_node "Figure 9-13. Typical
    expanded graph view node") and changing the node text to *collapsed node demo*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Typical collapsed (grouped) graph view node](httpatomoreillycomsourcenostarchimages854225.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-14. Typical collapsed (grouped) graph view node
  prefs: []
  type: TYPE_NORMAL
- en: Note that two additional buttons are now present in the title bar. In left-to-right
    order, these buttons allow you to uncollapse (expand) the grouped node and edit
    the node text. Uncollapsing a node merely expands the nodes within a group to
    their original form; it does not change the fact that the node or nodes now belong
    to a group. When a group is uncollapsed, the two new buttons just mentioned are
    removed and replaced with a single Collapse Group button. An expanded group can
    easily be collapsed again using the Collapse Group button or by right-clicking
    the title bar of any node in the group and selecting Hide Group. To completely
    remove a grouping applied to one or more nodes, you must right-click the title
    bar of the collapsed node or one of the participating uncollapsed nodes and select
    **Ungroup Nodes**. This action has the side effect of expanding the group if it
    was collapsed at the time.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[55](#CHP-9-FN-4)]) Hex-Rays makes the source for `wingraph32` available
    at [http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip](http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[56](#CHP-9-FN-5)]) dotty is a graph viewing tool included as part of the
    graphviz project.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[57](#CHP-9-FN-6)]) Hex-Rays makes the source for `qwingraph` available at
    [http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip](http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[58](#CHP-9-FN-7)]) A GDL reference can be found at [http://www.absint.com/aisee/manual/windows/node58.html](http://www.absint.com/aisee/manual/windows/node58.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[59](#CHP-9-FN-8)]) A DOT reference can be found at [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[60](#CHP-9-FN-9)]) See [http://www.graphviz.org/](http://www.graphviz.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[61](#CHP-9-FN-10)]) Please see [http://pedram.redhive.com/code/paimei/](http://pedram.redhive.com/code/paimei/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[62](#CHP-9-FN-11)]) The graphs depicted in this chapter have been edited
    outside of IDA to remove node coloring for the purposes of improving readability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are a powerful tool available to assist you in analyzing any binary.
    If you are accustomed to viewing disassemblies in pure text format, it may take
    some time to adjust to using a graph-based display. In IDA, it is generally a
    matter of realizing that all of the information that was available in the text
    display remains available in the graph display; however, it may be formatted somewhat
    differently. Cross-references, for example, become the edges that connect the
    basic blocks in a graph display.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the proper graph to view plays an important role in optimizing the
    use of graphs for analysis. If you want to know how a particular function is reached,
    then you are probably interested in a function call or cross-reference graph.
    If you want to know how a specific instruction is reached, then you are probably
    more interested in a control flow graph.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the frustration that users have experienced in the past with IDA’s graphing
    capabilities is directly attributable to the inflexibility of the `wingraph32`
    application and its related graphs. These frustrations were addressed in part
    with the introduction of an integrated graph-based disassembly mode. IDA is primarily
    a disassembler, however, and graph generation is not its primary purpose. Readers
    interested in dedicated graph-based analysis tools may wish to investigate applications
    designed specifically for that purpose, such as BinNavi,^([[63](#ftn.CHP-9-FN-12)])
    produced by Halvar Flake’s company Zynamics.^([[64](#ftn.CHP-9-FN-13)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[63](#CHP-9-FN-12)]) See [http://www.zynamics.com/binnavi.html](http://www.zynamics.com/binnavi.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[64](#CHP-9-FN-13)]) Note that Zynamics was acquired by Google in March 2011.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10. The Many Faces of IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For many years, the Windows GUI version was the superstar in the IDA stable.
    Since the release of IDA version 6.0 this is no longer the case, as Linux and
    OS X users can now enjoy GUI versions of IDA for their platforms. However, this
    new version in no way changes the fact that there are several alternative ways
    to use IDA. The original version of IDA was actually an MS-DOS console application,
    and the console version remains available on all platforms to this day. With built-in
    remote debugging capabilities, IDA is a powerful multiplatform analysis and debugging
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond its interactive capabilities, IDA offers a batch-processing mode in all
    of its versions to facilitate automated processing of large numbers of files.
    The key to effective batch processing with IDA is to understand what each version
    can and cannot do and choose the appropriate version of IDA to suit your requirements.
    In this chapter we discuss IDA’s console version and how to make the most of IDA’s
    batch-processing facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Console Mode IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of all console versions of IDA is a Borland-developed, console I/O
    library called *TVision* that has been ported to several platforms, including
    Windows, Linux, and Mac OS X, among others. Hex-Rays makes the source code for
    its current TVision port available to paying IDA customers on its IDA download
    page.^([[65](#ftn.CHP-10-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: The use of a common library across all platforms keeps the user interface consistent
    on all of the console versions. There are a few annoyances to deal with in moving
    from platform to platform, however, such as varying degrees of support for the
    mouse, resizing, and the ability to pass hotkeys to the IDA application. We discuss
    some of the problems and, when available, workarounds in the platform-specific
    sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Common Features of Console Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the term *console mode* implies, the text-based versions of IDA all run within
    a terminal or shell of some sort. These consoles may have varying degrees of support
    for resizing and the use of a mouse, resulting in limitations that you will need
    to learn to live with. The types of limitations depend on which platform and terminal
    program you are using.
  prefs: []
  type: TYPE_NORMAL
- en: The console user interface consists of a menu bar across the top line of the
    display to show menu options and status and a common operations bar across the
    bottom line of the display that’s similar to a text-based toolbar. Available operations
    are activated using hotkeys or, when supported, by clicking the mouse. Virtually
    every command available in the GUI version is available in some form in the console
    version, and most of the hotkey associations are preserved as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IDA display windows consume the space between the upper menu bar and the
    lower command bar. However, a common limitation, regardless of which terminal
    program you happen to use, is that there is little display room when the screen
    is limited to roughly 80 by 25 characters and no graphics. Therefore, console
    versions of IDA typically open only two display windows by default: the disassembly
    window and the messages window. In order to approximate the tabbed display windows
    found in the GUI version, IDA uses the TVision library’s overlapping windowing
    capability for text windows and assigns the F6 key (in lieu of window title tabs)
    to cycle through available open windows. Each window is numbered sequentially,
    and the window ID is present in the upper left-hand corner.'
  prefs: []
  type: TYPE_NORMAL
- en: When mouse support is available in your console, it is possible to resize an
    IDA display window by clicking and dragging the lower right corner of the display
    window to the desired size. To repositioxsn a display window, you click and drag
    the display’s top border. Lacking mouse support, you can move and resize individual
    displays via Window ▸ Resize/Move (ctrl-F5) and then use your arrow keys to move
    and shift-arrow keys to resize the active window. If your terminal program can
    be resized using the mouse, IDA recognizes the new terminal size and expands (or
    shrinks) to fill it as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Without graphics capability, the integrated graph-based disassembly mode is
    not available, and no control-flow arrows are displayed in the left margin of
    the disassembly listing window. However, all subviews available in the GUI version
    are available in the console versions. As in the GUI version, the majority of
    subviews are accessible via the View ▸ Open Subviews menu. The one major difference
    in available displays is that hex dumps are not available as a unique subview.
    Instead, you can toggle a disassembly to a hex dump and back using Options ▸ Dump/Normal
    View (ctrl-F4). In order to have both a disassembly and a hex view open simultaneously,
    you must open a second disassembly window (View ▸ Open Subviews ▸ Disassembly)
    and toggle the new view to a hex dump. Unfortunately, there is no way to synchronize
    the new hex dump to the existing disassembly view.
  prefs: []
  type: TYPE_NORMAL
- en: With mouse support, navigating your way around the disassembly remains much
    the same as the GUI version, where double-clicking any name takes you to the corresponding
    address. Alternatively, positioning the cursor on a name and pressing enter causes
    the display to jump to the corresponding named location (this also happens to
    work in the GUI version). Pressing enter while the cursor is positioned on the
    name of a stack variable opens the detailed stack frame view for the associated
    function. Without mouse support, the menus work similarly to many other console
    applications, employing the alt-*x* method of menu navigation, where *x* is a
    highlighted character on the current screen.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Console Specifics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Windows *cmd.exe* (*command.exe* on the Windows 9*x* family) terminal is
    not terribly flexible, but it is fairly well supported by IDA’s console version.
    The Windows console version of IDA is named *idaw.exe*, while the GUI version
    is named *idag.exe*. The corresponding versions for 64-bit binaries (available
    with the advanced version of IDA) are named *idaw64.exe* and *idag64.exe*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In order for IDA’s mouse support to work in Windows, you must ensure that QuickEdit
    mode is disabled for the terminal in which you are running IDA. To configure QuickEdit
    mode as one of the terminal’s properties, right-click the terminal’s title bar
    and select **Properties**; then deselect **QuickEdit mode** on the Options tab.
    You must do this prior to launching IDA, as the change will not be recognized
    while IDA is running.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Linux terminals running under X Windows, *cmd.exe* cannot be expanded
    by using the mouse to enlarge the window. On Windows only, IDA’s console version
    offers the Window ▸ Set Video Mode menu option to resize *cmd.exe* to one of six
    fixed terminal sizes, up to a maximum of 255 by 100.
  prefs: []
  type: TYPE_NORMAL
- en: While no graph mode is available in the disassembly window, IDA’s external graphing
    options are available. Selections from the View ▸ Graphs menu will cause IDA to
    launch the configured graph viewer (such as `qwingraph`) to display the resulting
    graph. For Windows versions of IDA, it is possible to open several graphs at once
    and continue to use IDA while the graphs are open.
  prefs: []
  type: TYPE_NORMAL
- en: Linux Console Specifics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux console version of IDA is named *idal* (or *idal64* for analyzing
    64-bit binaries). Prior to IDA 6.0, Linux and OS X console versions were included
    as standard components of your IDA distribution. As such, when you copy these
    console versions to your Linux or OS X platform, you must also copy your IDA key
    file (*ida.key*) so that your console version will run properly. Note that this
    requires that you install IDA on a Windows machine at least once, even if you
    never intend to run the Windows version. On Unix-style systems you may alternatively
    copy your key file to *$HOME/.idapro/ida.key*. If you do not create it, IDA automatically
    creates the IDA personal settings directory (*$HOME/.idapro*) the first time you
    launch IDA.
  prefs: []
  type: TYPE_NORMAL
- en: IDA 6.*x* installations are much simpler. Because IDA 6.*x* is purchased for
    a specific platform, the installation procedure on your platform takes care of
    installing the GUI version, the console version, and your IDA key file to suitable
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic navigation in the Linux version is similar to navigation in the Windows
    console version; several Linux specifics are addressed in this section. Users’
    tastes for Linux terminal programs are as varied as their tastes for Linux distributions
    in general. IDA includes a file named *tvtuning.txt* that offers some details
    on how to configure various terminal types, including remote Windows terminal
    clients such as SecureCRT and PuTTY.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest challenges that you will face when using Linux terminal programs
    is making sure that your hotkey sequences are passed all the way to IDA and not
    captured by the terminal program itself. For example, will alt-F open IDA’s File
    menu or your console’s File menu? The two options for dealing with this problem
    are to find a terminal program whose hotkey sequences don’t overlap IDA’s (or
    that can be configured not to overlap) or to edit IDA’s configuration file to
    remap commands to hotkeys that are not used by your terminal. If you choose to
    remap the hotkeys, you may want to update the hotkey mappings on every computer
    on which you use IDA so that you don’t have to remember which mapping is in effect
    at each location. You may also find it difficult to interact with other IDA users
    who are using the default mappings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to use the standard Linux text display, the dimensions of your
    IDA console will be fixed, and your mouse support will be dependent on your use
    of GPM (the Linux console mouse server). If you are not using GPM for mouse support,
    you should specify the `noGPM` option for TVision when you launch IDA, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Color choices are quite limited in console mode, and you may need to adjust
    your color settings (Options ▸ Colors) to ensure that all text is visible and
    does not blend into the background. Four predefined color palettes are available,
    with the option to customize the colors (a choice of 16) used for various parts
    of the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: If you are running X, then you may be running KDE’s `konsole`, Gnome’s `gnome-terminal`,
    a straight `xterm`, or some other variation on a terminal. Other than `xterm`,
    most terminals offer their own menus and associated hotkeys that may or may not
    overlap IDA’s hotkey assignments. Consequently, `xterm` is not a bad choice for
    running IDA, although it is not necessarily the most visually appealing. KDE’s
    `konsole` is our preferred Linux console as it offers the best appearance, fewest
    hotkey collisions, and smoothest mouse performance.
  prefs: []
  type: TYPE_NORMAL
- en: In order to address some of the problems surrounding keyboard and mouse use
    within various X Windows consoles, Jeremy Cooper developed a native X11 port^([[66](#ftn.CHP-10-FN-2)])
    of the TVision libraries. Using this modified version of TVision allows you to
    launch IDA in its own X window rather than consume an entire console. Compiling
    Cooper’s TVision port yields a drop in replacement for libtvision.so, the shared
    TVision library used by `idal`. After installing the new library, you may receive
    an error message stating that a VGA font can’t be loaded when you attempt to run
    IDA. If this happens, you will need to install a VGA font and let your X server
    know where to find it. A suitable VGA font is available at [http://gilesorr.com/bashprompt/xfonts/](http://gilesorr.com/bashprompt/xfonts/)
    (download both `vga` and `sabvga`). Another interesting feature of using the native
    X11 port is that you can forward the X11 window to another machine. Thus, you
    can run IDA on Linux but forward the X11 window (over `ssh` of course) to a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: For remote access to your Linux-based IDA installation using the Hex-Rays–supplied
    TVision libraries, we recommend that you configure your terminal software to emulate
    an xterm (consult *tvtuning.txt* and your terminal emulator’s documentation for
    more information) and then launch IDA according to the instructions contained
    in *tvtuning.txt*. For example, you must specify `TVOPT=xtrack` in order for the
    mouse to work with IDA when using SecureCRT as your terminal emulator.
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, choose to export your `TVOPT` settings, eliminating the
    need to specify them every time you launch IDA. For a full overview of available
    TVision options, refer to *linux.cpp* in the TVision source distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'External graph views on Linux are available from the console version only if
    you happen to be running IDA in a windowing environment, and you have configured
    the `GRAPH_VISUALIZER` variable in *ida.cfg* to point to a suitable graph rendering
    program.^([[67](#ftn.CHP-10-FN-3)]) IDA versions prior to 6.0 are only capable
    of generating graphs using GDL. You may install a GDL viewer such as aiSee^([[68](#ftn.CHP-10-FN-4)])
    and configure IDA to launch the new application by editing IDA’s main configuration
    file, *<IDADIR>/cfg/ida.cfg*. The configuration option `GRAPH_VISUALIZER` specifies
    the command to be used to view IDA’s GDL graphs (all legacy mode graphs). The
    default setting looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove` option asks `qwingraph` to delete the input file, which is useful
    when you are displaying temporary files. The `timelimit` option specifies the
    number of seconds to spend attempting to generate a pretty graph. If the graph
    cannot be laid out neatly within this time, `qwingraph` switches to a “fast and
    ugly”^([[69](#ftn.CHP-10-FN-5)]) layout algorithm. Beginning with IDA 6.0, the
    `GRAPH_VISUALIZER` option is enclosed in a conditional block to provide separate
    settings for Windows and non-Windows platforms. If you are editing *ida.cfg* on
    a non-Windows platform, make sure that you are editing the correct portion of
    the file. If you have installed a GDL viewer such as aiSee, then you need to edit
    `GRAPH_VISUALIZER` to point to your viewer of choice. For a typical installation
    of aiSee, this might result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is always best to specify the full path to your GDL viewer to ensure
    that it is found when IDA attempts to launch it. Finally, since `qwingraph` is
    open source software, users of older versions of IDA are free to download the
    source for `qwingraph` from Hex-Rays (see [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing")), build it, and integrate `qwingraph` into their IDA installations.
  prefs: []
  type: TYPE_NORMAL
- en: OS X Console Specifics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA’s console versions for OS X are named the same as the Linux versions (*idal*
    and *idal64*). As with the Linux and Windows console versions, the OS X versions
    rely on the TVision library to support console I/O.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the Mac keyboard has a different layout than a PC keyboard presents
    a few challenges when running the Mac version of IDA, primarily because the Mac’s
    option/alt key does not behave like the PC’s alt key where application menus are
    concerned.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious choice for attempting to run IDA is the Mac’s Terminal application.
    When launching IDA using Terminal, be sure to configure the option key as an alt
    key for use within IDA. Doing so allows keyboard access to IDA alt key shortcuts,
    such as all of the main IDA menus (alt-F for the File menu, for example). If you
    don’t select this option, you’ll have to use the esc key in lieu of alt; thus,
    esc-F brings up the File menu. Since esc has back or close-window functionality
    in IDA, this approach is not recommended. [Figure 10-1](ch10.html#mac_os_x_terminal_keyboard_settings_dial
    "Figure 10-1. Mac OS X Terminal keyboard settings dialog") shows the Terminal
    Inspector dialog, which is accessed via Terminal ▸ Preferences when Terminal is
    active. Select the **Use option key as meta key** checkbox to make the option
    key behave as an alt key.
  prefs: []
  type: TYPE_NORMAL
- en: One potential alternative to Terminal is iTERM,^([[70](#ftn.CHP-10-FN-6)]) which
    allows the alt functionality of the option key and enables mouse sup-port as well.
    Another terminal that many developers seem to like is the gnome terminal, which
    has been ported^([[71](#ftn.CHP-10-FN-7)]) to X11 on OS X. Since this requires
    the installation of XCODE and X11, we won’t do more than mention the existence
    of the port. Using the default Terminal or iTERM should be sufficient for most
    users.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way to run IDA on OS X is to install X11 (available on your OS
    X installation disks as an optional package) and Jeremy Cooper’s modified TVision
    library (libtvision.dylib for OS X) to run IDA as a native X11 application. You
    may wish to add */usr/X11R6/bin* to your system PATH (edit PATH in */etc/profile*)
    for easier access to X11-related binaries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mac OS X Terminal keyboard settings dialog](httpatomoreillycomsourcenostarchimages854227.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. Mac OS X Terminal keyboard settings dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'In this configuration, IDA may be launched from an xterm, and it will execute
    in its own window with full mouse functionality. The problem with the option/alt
    key will remain, however, as X11 views this key as *Mode_switch* and fails to
    pass the key to IDA. Fortunately, X11 allows you to remap keys through the use
    of the `xmodmap` utility. One solution is to create (or edit) a file named *.Xmodmap*
    in your home directory (something like */Users/idabook/.Xmodmap*) containing the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The default X11 startup script (*/etc/X11/xinit/xinitrc*) contains commands
    to read *.Xmodmap* whenever you launch X11\. If you have created your own *.xinitrc*
    file, which overrides the default *xinitrc*, you should make sure that it contains
    a command such as the following; otherwise your *.Xmodmap* file will not be processed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you need to modify the default settings for X11 to prevent the system
    from overriding your modified key map. [Figure 10-2](ch10.html#x11_preferences_on_os_x
    "Figure 10-2. X11 Preferences on OS X") shows the X11 Preferences dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![X11 Preferences on OS X](httpatomoreillycomsourcenostarchimages854229.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2. X11 Preferences on OS X
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent the system from overriding your keyboard mappings, you must deselect
    the middle option: **Follow system keyboard layout**. Once you have made this
    change, restart X11, and your modified keyboard settings should take effect, making
    the alt key available to access IDA’s menus. You can verify that X11 recognizes
    the alt key by using `xmodmap` to print the current list of keyboard modifiers,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If `mod1` does not list `Alt_L` and `Alt_R`, as shown at ![](httpatomoreillycomsourcenostarchimages854063.png),
    then your key map has not been updated, in which case you should rerun the `xmodmap`
    command listed at ![](httpatomoreillycomsourcenostarchimages854061.png) in the
    previous code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[65](#CHP-10-FN-1)]) See [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[66](#CHP-10-FN-2)]) See [http://simon.baymoo.org/universe/ida/tvision/](http://simon.baymoo.org/universe/ida/tvision/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[67](#CHP-10-FN-3)]) Refer to [IDA Graphing](ch09s02.html "IDA Graphing")
    in [IDA Graphing](ch09s02.html "IDA Graphing").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[68](#CHP-10-FN-4)]) The GDL viewer aiSee is available for many platforms
    and is free for noncommercial use. It can be found at [http://www.aisee.de/](http://www.aisee.de/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[69](#CHP-10-FN-5)]) See `timelm.c` in the `wingraph32` or `qwingraph` source
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[70](#CHP-10-FN-6)]) See [http://iterm.sourceforge.net/](http://iterm.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[71](#CHP-10-FN-7)]) See [http://www.macports.org/](http://www.macports.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Using IDA’s Batch Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All versions of IDA can be executed in batch mode to facilitate automated processing
    tasks. The primary purpose of using batch mode is to launch IDA, have it run a
    specific IDC script, and have it terminate once the script completes. Several
    command-line options are available to control the processing performed during
    batch mode execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'GUI versions of IDA do not require a console in order to execute, making them
    very easy to incorporate into virtually any type of automation script or wrapper
    program. When run in batch mode, the GUI versions of IDA do not display any graphical
    components. Running the Windows console versions (*idaw.exe* and *idaw64.exe*)
    generates a full console display that closes automatically when the batch processing
    is complete. The console display can be suppressed by redirecting output to a
    null device (NUL for *cmd.exe*, */dev/null* in cygwin), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'IDA’s batch mode is controlled by the command-line parameters listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-A` option causes IDA to run in autonomous mode, which means that no dialogs
    requiring user interaction will be displayed. (If you have never clicked through
    IDA’s license agreement, then the license agreement dialog will be displayed in
    spite of the presence of this switch.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-c` option causes IDA to delete any existing database associated with the
    file specified on the command line and generate an entirely new database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-S` option is used to specify which IDC script IDA should execute on startup.
    To execute *myscript.idc*, the syntax is `-Smyscript.idc` (no space between `S`
    and the script name). IDA searches for the named script in the *<IDADIR>/idc*
    directory. If you have IDAPython properly installed, you may also specify a python
    script here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-B` option invokes batch mode and is equivalent to supplying IDA with `-A
    -c -Sanalysis.idc` at execution. The *analysis.idc* script that ships with IDA
    simply waits for IDA to analyze the file named on the command line before dumping
    an assembly listing (*.asm* file) of the disassembly and closing IDA in order
    to save and close the newly generated database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-S` option is the key to batch mode, as IDA will terminate only if the
    designated script causes IDA to terminate. If the script does not shut down IDA,
    then all of the options simply combine to automate the IDA startup process. Scripting
    with IDC is discussed in [Chapter 15](ch15.html "Chapter 15. IDA Scripting").
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of limitations with the TVision library used by the Linux and OS X
    versions of IDA, batch execution must be performed within a TTY console. This
    makes simple things such as output redirection and background processing impossible.
    Fortunately, the latest version of TVision recognizes the `TVHEADLESS` environment
    variable, which allows console output (`stdout`) to be redirected, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Fully detaching from the console for background execution requires the additional
    redirection of both `stdin` and `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ilfak discusses batch mode in one of his blog posts here: [http://hexblog.com/2007/03/on_batch_analysis.html](http://hexblog.com/2007/03/on_batch_analysis.html).
    Among other things, he details how to move beyond invoking a single script and
    discusses how to execute an IDA plug-in from batch mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While GUI versions of IDA remain the most fully featured versions available,
    console mode alternatives and batch-processing capabilities offer IDA users tremendous
    flexibility in creating complex analysis solutions built around IDA’s automated
    analysis capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we have covered all of IDA’s basic capabilities, and it is time
    to move on to more advanced features. Over the course of the next few chapters
    we will cover some of IDA’s more useful configuration options and present some
    additional utilities designed to improve IDA’s binary analysis capabilities.
  prefs: []
  type: TYPE_NORMAL
