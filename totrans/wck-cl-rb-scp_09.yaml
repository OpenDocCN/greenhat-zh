- en: Chapter 9. SORTING ALGORITHMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![SORTING ALGORITHMS](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ruby is a wonderful language for many reasons, but even the best programming
    languages can be stifled by poor algorithms, improper data structures, or logic
    errors. Sorting is a fundamental programming skill you should definitely master.
    Whether you're sorting numbers, letters, or names, sorting algorithms can make
    or break your program's efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The performance of sorting algorithms is frequently measured using the *Big
    O notation* (pronounced "Big Oh"), a concept that comes from computational complexity
    theory. You can relax; we won't be going into computational complexity theory
    or proofs. Suffice it to say, Big O notation abstracts an algorithm's consumption
    of resources—specifically, time. A simple example to illustrate Big O notation
    is to think about the efficiency of accessing every element in an array. The Big
    O notation for this situation would be O(*n*), where *n* represents the number
    of elements, and each element in the array is accessed once. I don't intend to
    go into the details of Big O; for our purposes, it is simply a way to describe
    the efficiency of an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: For a controlled comparison of the various sorting methods, I created a harness
    that will handle a specific test case. The harness will set up the test cases,
    initialize the timer, and finally, call the sorting algorithm. Every algorithm
    has the same goal and produces the same output; they are presented in loosely
    ascending order by efficiency. Remember that each of the following algorithms
    is written as its own method for easy integration into other scripts. The first
    controlled element of the comparison is the numbers that will be sorted. I had
    another Ruby script generate 1,000 random numbers and store them in a text document.
    The importance of sorting the same data for each algorithm is that some randomizations
    can help the performance of one algorithm over another, if the data is sorted
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the results of each sorting method, I''m using the benchmark library.
    This will allow me to know exactly when the algorithm starts sorting and stops
    sorting. The output format will look something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 0.406000   0.015000   0.421000 (  0.437000)`'
  prefs: []
  type: TYPE_NORMAL
- en: The benchmark output will display the users CPU time, system's CPU time, the
    total amount of CPU time consumed, and finally, the elapsed real time. The unit
    of time is seconds, and the main value we're interested in is the real time.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*There is always the built-in Ruby sort method, `quicksort`, but the following
    sorts will give you other options if you don''t use Ruby''s.*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Bubble Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bubble Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: bubbleSort.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bubble sort uses an easy exchange method. This algorithm is perhaps the simplest
    method of sorting to understand. As you will see in the explanation, the algorithm
    looks at the first two elements in a data set and compares them. If the first
    element is larger than the second, the algorithm swaps them. This process continues
    for each pair of elements in the data set. At the end of the data set, the comparison
    starts again and continues until no swaps are made.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''benchmark''   def bubble_sort(a)      i = 0 ![](../Images/00002.jpg)  
      while i<a.size          j = a.size - 1 ![](../Images/00003.jpg)         while
    (i < j) ![](../Images/00004.jpg)              if a[j] < a[j - 1]             
         temp = a[j]                   a[j] = a[j - 1]                   a[j - 1]
    = temp                   end               j-=1               end           i+=1
              end       return a  end  ![](../Images/00005.jpg) big_array = Array.new
     big_array_sorted = Array.new ![](../Images/00006.jpg)  IO.foreach("1000RanNum.txt",
    $\ = '' '') {|num| big_array.push num.to_i } ![](../Images/00007.jpg) puts Benchmark.measure
    {big_array_sorted = bubble_sort(big_array)}   File.open("output_bubble_sort.txt","w")
    do |out| ![](../Images/00008.jpg)     out.puts big_array_sorted  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby bubbleSort.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script will sort 1,000 random numbers and will output the ordered pair to
    a file called *output_bubble_sort.txt*. Additionally, the script outputs the amount
    of time required to execute the script using the benchmark library.
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 2.125000   0.000000   2.125000 (  2.140000)`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script is broken up into three main areas: the required libraries, the
    actual sorting algorithm, and finally, the harness—which will supply the list
    of random numbers to be sorted. I want to talk about the harness first, so we''ll
    begin with the lower half of the script and then jump back up to the top.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to speed up the process of generating a random number data set, I used
    another script to create 1,000 random numbers and write them to *1000RanNum.txt*.^([[1](#filepos710525)])
    The first instruction in this script is to create an array (called `big_array`)
    that will hold those numbers ![](../Images/00005.jpg). Another array is created
    to hold the sorted values; this one is called `big_array_sorted`. Next, the file
    containing 1,000 random numbers is opened. The file has one number per line, so
    after having opened the file successfully, each number is pushed onto the array
    ![](../Images/00007.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Once all the numbers have been added to `big_array`, the script is ready to
    begin sorting. In order to make this timed trial as controlled as possible (and
    without using my stopwatch), I'm using the `measure` method from the benchmark
    library ![](../Images/00007.jpg). Essentially, `measure` will start the timer
    once the script has begun sorting the numbers and then stop the timer when the
    sort has finished. The results are then displayed in the form of `user, system,
    total`, and `real times`. I'll come back to the sorting algorithm, but we need
    to see where the data is stored. Once the numbers have been sorted, the results
    are saved to `big_array_sorted` and output to a text file, *output_<sort name>.txt*.
    The text file can be used for further analysis and to ensure the numbers were
    actually sorted ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Within the `measure` method, the script calls `bubble_sort(a)`. As mentioned
    previously, bubble sort is a quick, simple, and generic sorting algorithm that
    has no regard for efficiency. You can think of this algorithm as being almost
    a brute force attack. As you experiment with other algorithms, you'll begin to
    appreciate the elegance and beauty of how the best algorithms are written. But
    first, we start with the basics!
  prefs: []
  type: TYPE_NORMAL
- en: An array is passed to the `bubble_sort` method. The variable `i` is initialized
    and will serve as a counter. A while loop is started, which will isolate one element
    of the data set ![](../Images/00002.jpg). Next, a second while loop is nested
    within the first. The second while loop contains the meat of the sort ![](../Images/00003.jpg).
    Bubble sort compares the first two elements, and if the first is greater than
    the second, the values are exchanged. This process is used for each pair of elements
    in the data set ![](../Images/00004.jpg). Once the end of the list is reached,
    the process starts over until no further exchanges occur. If you visualize a vertical
    tower of random numbers sorted using the bubble sort, you can understand where
    the algorithm gets its name.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#filepos706211)]) To avoid influencing the test, I've used the same test
    file for all the scripts in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selection Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selection Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: selectionSort.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selection sort improves on the bubble sort algorithm, but it still isn't the
    pinnacle of efficiency. However, selection sort has its place in our coding tool
    bag because it can be used to quickly sort small lists. The algorithm isn't complicated,
    so implementing it in code can swiftly take care of a sorting need. Instead of
    comparing two elements within a data set, selection sort will search for the smallest
    element of the data set and move it to the beginning of the list. The same process
    is repeated for the second element and so on. It's interesting to observe that
    this algorithm also uses exchanges to sort. Other algorithms' efficiencies may
    be dependent on the starting order of a data set. That is to say, if some lists
    are partially ordered, some algorithms will gain a performance advantage and not
    have to move as many elements. The difference with selection sort is that this
    algorithm doesn't care. It always has *n* swaps, where *n* is the number of elements
    in the data set, which is great for the worst-case scenarios. Going back to the
    Big O notation, this would be O(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''benchmark''   def selection_sort(a)  ![](../Images/00002.jpg)  
    a.each_index do |i|        min_index = min(a, i)  ![](../Images/00003.jpg)    
    a[i], a[min_index] = a[min_index], a[i]      end      a  end  ![](../Images/00004.jpg)  
      def min(subset, from) ![](../Images/00005.jpg)     min_value = subset[from..-1].min
    ![](../Images/00006.jpg)     min_index = subset[from..-1].index(min_value) + from
         return min_index  end   big_array = Array.new  big_array_sorted = Array.new
     IO.foreach("1000RanNum.txt", $\ = '' '') {|num| big_array.push num.to_i }  puts
    Benchmark.measure {big_array_sorted = selection_sort(big_array)}   File.open("output_selectionSort.txt","w")
    do |out|      out.puts big_array_sorted  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby selectionSort.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script will sort our 1,000 random numbers and output the ordered pair to
    a file called *output_selection_sort.txt*. Additionally, the script outputs to
    $stdout the amount of time used to execute the script, calculated using the benchmark
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 0.406000   0.015000   0.421000 (  0.437000)`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have already discussed the surrounding parts of the sorting scripts in the
    previous example. If you have any questions, refer to "#52 Bubble Sort" on [Bubble
    Sort](../Text/dummy_split_358.html#filepos700370). I will focus on the individual
    sorting algorithms for the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort is another classic sorting algorithm, but it is slightly more
    efficient than the bubble sort. It also has fewer lines of code. Unlike other
    algorithms seen in this chapter, selection sort immediately goes after the minimum
    value of the data set without any type of pre-processing. Once the smallest element
    is found, the element swaps its position with the first position of the data set.
    Then the algorithm looks for the second lowest value in a data set and repeats
    this until all elements have been used.
  prefs: []
  type: TYPE_NORMAL
- en: The first big difference in this script is the creation of another method, called
    `min`, which `selectionSort` will use to find the minimum value from a subset
    of the original data set ![](../Images/00004.jpg). Keep this method in the back
    of your mind, and we'll come back to it. `selectionSort` starts with a loop that
    will iterate through each element in the data set. The loop relies on the method
    `each_index` to do this
  prefs: []
  type: TYPE_NORMAL
- en: '![How It Works](../Images/00002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: . After the index of an element has been retrieved, `min` is immediately called
    to pass the index value. While in `min`, the script searches for the smallest
    element in a subset ![](../Images/00005.jpg). Once the smallest value has been
    found, its index is retrieved and returned to the calling method ![](../Images/00006.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the sort uses the typical Ruby swap routine to make a quick swap between
    the smallest element and the element that is currently in its new place ![](../Images/00003.jpg).
    This process is repeated until all the values have been accessed. For a data set
    of size *n*, the script will perform *n* iterations, making this algorithm's performance
    predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Shell Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: shellSort.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shell sort is an *insertion sorting* algorithm: A value is stored to a temporary
    value, then inserted into its appropriate place. One difference between this algorithm
    and the traditional insertion sort is that a shell sort compares two elements
    that are separated by a gap of several positions—in essence, making bigger jumps.
    This slight change results in greater efficiency in the worst-case scenario. Remember,
    worst-case scenarios are when a list of elements are in complete disarray and
    cannot be disordered any more than they currently are.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''benchmark''   def shell_sort(a)      i = 0      j = 0      size
    = a.length ![](../Images/00002.jpg)     increment = size / 2      temp = 0  ![](../Images/00003.jpg)  
      while increment > 0          i = increment ![](../Images/00004.jpg)        
    while i<size              j = i ![](../Images/00005.jpg)             temp = a[i]
    ![](../Images/00006.jpg)             while j>=increment and a[j-increment]>temp
                     a[j] = a[j-increment]                  j = j-increment       
          end ![](../Images/00007.jpg)             a[j] = temp              i+=1   
          end          if increment == 2              increment = 1          else
    ![](../Images/00008.jpg)             increment = (increment/2).to_i          end
         end      return a  end   big_array = Array.new  big_array_sorted = Array.new
     IO.foreach("1000RanNum.txt", $\ = '' '') {|num| big_array.push num.to_i }  puts
    Benchmark.measure {big_array_sorted = shell_sort(big_array)}   File.open("output_shell_sort.txt","w")
    do |out|      out.puts big_array_sorted  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby shellSort.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the others, this script sorts the 1,000 random numbers and outputs the
    ordered set to a file called *output_shell_sort.txt*. Additionally, the script
    outputs the amount of time used to execute the script using the benchmark library.
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 0.047000   0.000000   0.047000 (  0.047000)`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shell sort improves on the insertion sort algorithm by using a gap sequence,
    which enables the sorting algorithm to make bigger improvements on the list's
    final ordering. This creates fewer write operations, resulting in a shorter runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm begins with an array being passed as the only argument. Next,
    several variables are initialized to help track the sorting process. The important
    variable to watch is `increment` ![](../Images/00002.jpg). This variable will
    dictate the gap sequence mentioned previously. You may have noticed that the structure
    closely resembles bubble sort, but there are slight differences which have an
    impact during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The first of the three while loops states, "as long as the increment that we
    are moving is more than zero, there is still work left to be done" ![](../Images/00003.jpg).
    The second while loop ensures the value of `i` stays within the bounds of the
    array's length ![](../Images/00004.jpg). Next, the value located at position `i`
    in array `a` is stored in a temporary variable so that we don't lose the element
    during later moves ![](../Images/00005.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike bubble sort, shell sort adds a third while loop ![](../Images/00006.jpg).
    As long as the variable `j` is greater than `increment` and the value of the array
    position `j-increment` is larger than the `temp` variable, then values at `j-increment`
    are inserted into the array. After the third while loop is broken, the `temp`
    value is placed back in the array, and the process continues for each element
    ![](../Images/00007.jpg). Once the end of the data set is reached, the process
    starts over again, and `increment` is recalculated ![](../Images/00008.jpg). The
    process continues until `increment` is equal to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: mergeSort.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This sorting algorithm does exactly what the name describes: It merges two
    sort elements. The algorithm splits the main data set into smaller subsets of
    one element. It then takes the first and second elements and sorts them, creating
    a subset. The result of the initial subset is merged and sorted with the next
    element. This process is done recursively until all elements have been merged
    back into the main data set. Interestingly, this algorithm is the first to address
    performance in significantly large data sets.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''benchmark''   def merge(a1, a2)      ret = []       while (true)
             if a1.empty?              return ret.concat(a2)          end         
    if a2.empty?              return ret.concat(a1)          end  ![](../Images/00002.jpg)  
              if a1[0] < a2[0]              ret << a1[0]              a1 = a1[1...a1.size]
             else              ret << a2[0]              a2 = a2[1...a2.size]     
        end      end  end   def merge_sort(a) ![](../Images/00003.jpg)     if a.size
    == 1          return a ![](../Images/00004.jpg)     elsif a.size == 2         
    if a[0] > a[1]              a[0], a[1] = a[1], a[0]          end          return
    a      end  ![](../Images/00005.jpg)     size1 = (a.size / 2).to_i      size2
    = a.size - size1       a1 = a[0...size1]      a2 = a[size1...a.size]  ![](../Images/00006.jpg)  
      a1 = merge_sort(a1)      a2 = merge_sort(a2)  ![](../Images/00007.jpg)     return
    merge(a1, a2)  end    big_array = Array.new  big_array_sorted = Array.new  IO.foreach("1000RanNum.txt",
    $\ = '' '') {|num| big_array.push num.to_i }  puts Benchmark.measure {big_array_sorted
    = merge_sort(big_array)}   File.open("output_merge_sort.txt","w") do |out|   
      out.puts big_array_sorted  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby mergeSort.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script sorts the 1,000 random numbers and outputs the ordered set to *output_merge_sort.txt*.
    Additionally, the script prints the amount of time used to execute the script,
    again relying on the benchmark library.
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 0.109000   0.000000   0.109000 (  0.109000)`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The merge sort consists of two methods: `merge_sort` and `merge`. The `merge_sort`
    method is responsible for controlling the recursive splitting and returning the
    final product. The only mission for `merge` is to merge two arrays together. There
    is heavy usage of recursive method calls, so follow along and note where the method
    calls itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The `merge_sort` method begins with a check to see if the array being passed
    to the method has a size equal to one ![](../Images/00003.jpg). This is the condition
    where the recursion will stop, so it will only happen when the data set has been
    split into smaller one-element data sets. Next, `merge_sort` looks for an array
    with two elements, and if found, the script will sort it and return the sorted
    two-element data set ![](../Images/00004.jpg). If neither of the two previous
    conditions is met, the script will proceed to break the array into two even smaller
    arrays ![](../Images/00005.jpg). These smaller arrays are then passed back into
    another recursive `merge_sort` call ![](../Images/00006.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: After the `merge_sort` call is returned for both halves, the `merge` method
    is used to merge those data sets together ![](../Images/00007.jpg). While in `merge`,
    the arrays are compared and sorted appropriately ![](../Images/00002.jpg). Sorting
    arrays that have some order is much easier than sorting totally random numbers.
    This enables the merge sort to remain efficient through each recursive call. Compared
    to the Big O notation of bubble sort, which was O(*n*²), merge sort is O(*n* log
    *n*). You can see that merge sort is much more efficient by comparing the sorting
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Heap Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heap Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: heapSort.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building on the selection sort, heap sort uses the selections much more efficiently,
    as can be seen in a comparison of the two execution times. Heap sort is comparable
    to the quick sort algorithm shown in the next section, but typically, quick sort
    will have a faster execution time. The difference in the two sorting routines
    is in the worst-case Big O scenario, where heap sort edges out quick sort. In
    most implementations, the worst case is not the normal case, so it is up to you
    to consider the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''benchmark''   def heap_sort(a)      size = a.length      temp =
    0      i = (size/2)-1  ![](../Images/00002.jpg)     while i >= 0          sift_down(a,i,size)
             i-=1      end       i=siz e-1 ![](../Images/00003.jpg)     while i >=
    1          a[0], a[1] = a[1], a[0] ![](../Images/00004.jpg)         sift_down(a,
    0, i-1)          i-=1      end      return a  end   def sift_down(num, root, bottom)
         done = false      max_child = 0      temp  = 0       while root*2 <= bottom
    and !done ![](../Images/00005.jpg)         if root*2 == bottom              max_child
    = root * 2 ![](../Images/00006.jpg)         elsif num[root*2].to_i > num[root*2+1].to_i
                 max_child = root * 2 ![](../Images/00007.jpg)         else       
          max_child = root * 2 + 1          end  ![](../Images/00008.jpg)        
    if num[root] < num[max_child]              num[root], num[max_child] = num[max_child],
    num[root]              root = max_child          else              done = true
             end      end  end    big_array = Array.new  big_array_sorted = Array.new
     IO.foreach("1000RanNum.txt", $\ = '' '') {|num| big_array.push num.to_i }  puts
    Benchmark.measure {big_array_sorted = heap_sort(big_array)}   File.open("output_heap_sort.txt","w")
    do |out|      out.puts big_array_sorted  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby heapSort.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script will sort the random number data set and output the ordered set
    to a file called *output_heap_sort.txt*. The script also prints the amount of
    time used to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 0.078000   0.000000   0.078000 (  0.078000)`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the structure of heap sort closely resembles merge sort, with two methods
    used to sort the elements, heap sort does not use recursion to achieve a sorted
    data set. The first method, `heapSort`, starts with a while loop that calls `sift_down`
    ![](../Images/00002.jpg). This call effectively builds the heap for sorting. The
    `sift_down` method is used to create and manipulate the heap for sorting the array.
    A heap is a tree-type data structure. If you're not familiar with a heap, think
    of a family tree with one node at the top and parents and children below, representing
    elements. The heap must have a *root*, or top-most element, and two optional *leaves*,
    or children. The script also passes the array as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `sift_down` method uses three conditional statements to determine the placement
    of an element within the heap. The first statement looks to see if the element
    is at the bottom of the heap ![](../Images/00007.jpg). If it is not, then the
    two children of the node are compared. If the elements are already ordered as
    children, then the order is maintained ![](../Images/00006.jpg). If neither of
    the first two conditions is met, then the element must be a child and is not in
    the proper order ![](../Images/00007.jpg). The location where the element should
    be placed is stored in `max_child`. With this information, another conditional
    statement moves the elements into their correct order using the `temp` variable
    as the elements are shifted ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Jumping back to the `heapSort` method, the initial heap has been created. So,
    the algorithm begins to move the elements into their final place within the data
    set. The second while loop places the root node of the tree in the last place
    of the data set ![](../Images/00003.jpg). It then calls `sift_down` to reconstruct
    the tree with a new root node and repeats the process for each element ![](../Images/00004.jpg).
    Think of the second while loop as popping off the root node of the tree, then
    rebuilding it until all elements have been popped off. Using the heap data structure
    enables this algorithm to produce large, sorted data sets in a short period of
    time. The performance follows a logarithmic line, as opposed to a linear line
    like the previous sorting algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quick Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: quickSort.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quick sort is speedy in its execution; it is one of the fastest algorithms presented
    so far, and happens to be the default sort method contained within many programming
    languages. The basic logic behind this algorithm is in ordering every element
    based on a *pivot element*. The script picks an initial element to be used as
    the pivot element. Then the list is reordered based on the pivot element, placing
    every element less than the pivot in one list and every element higher in another
    list. The median is the final spot for the pivot element. Once all elements have
    been ordered on this pivot, the process is repeated for each sublist. The algorithm
    is considered a divide-and-conquer sort.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''benchmark''   def quick_sort(f, aArray) ![](../Images/00002.jpg)  
      return [] if aArray.empty? ![](../Images/00003.jpg)     pivot  = aArray[0] ![](../Images/00004.jpg)
         before = quick_sort(f, aArray[1..-1].delete_if { |x| not f.call(x, pivot)
    })      after  = quick_sort(f, aArray[1..-1].delete_if { |x| f.call(x, pivot)
    }) ![](../Images/00005.jpg)     return (before << pivot).concat(after)  end    big_array
    = Array.new  big_array_sorted = Array.new  IO.foreach("1000RanNum.txt", $\ = ''
    '') {|num| big_array.push num.to_i }  ![](../Images/00006.jpg)  puts Benchmark.measure
    {big_array_sorted = quick_sort(Proc.new { |x, pivot| x <  pivot }, big_array)}   File.open("output_quick_sort.txt","w")
    do |out|      out.puts big_array_sorted  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby quickSort.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script will sort the data set and output the ordered results to *output_quick_sort.txt*,
    then report the amount of time used to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 0.094000   0.000000   0.094000 (  0.094000)`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quick sort is another algorithm that uses recursion to accomplish the sort.
    The sorting begins by checking if the array is empty ![](../Images/00002.jpg).
    With recursion, you must have a condition to return to the calling method, and
    an empty array is just that condition. Next, a pivot is chosen—in this case, the
    first element of the passed array ![](../Images/00003.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines have a lot going on, so I'll break them down. The `before`
    and `after` variables will contain the elements in relation to the current pivot
    element. Looking at the variable `before`, you can see that `quick_sort` is recursively
    called ![](../Images/00004.jpg). The `quick_sort` method takes two arguments.
    The first is a `proc` object, and the second is an array. `proc` objects are unique
    because the local variables within the blocks of code are bound to the object,
    and the code can be called in multiple contexts to retrieve the bound variables.
    The `proc` is initially created in the first `quick_sort` call within the harness
    ![](../Images/00006.jpg). It is used to compare an element with the chosen pivot
    element.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument passed to `quick_sort` is the data set array. In the recursive
    calls, the second argument is actually an array that contains a subset of the
    original data set. The sort uses a range within the array and calls the `delete_if`
    method. This method does exactly what the name implies. In this case, values in
    the array are deleted if they are larger than the pivot value. The `call` method
    invokes the `proc` object defined earlier and actually carries out the comparison.
    The final array passed will contain every value less than the pivot value. The
    opposite is true for the `after` variable. The `proc` object and every variable
    in the list smaller than the pivot element are passed. The halves are broken down
    until the pivot value is the only remaining element. With each return, the pivot
    value is added to the `before` array, and the `after` array is concatenated. After
    breaking the array down to one element and sorting them on the way up, the array
    is completely sorted on the final `before`/`pivot`/`after` concatenation ![](../Images/00005.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Shear Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shear Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: shearSort.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shear sort is extremely efficient, but only on a parallel processor. When you
    see the benchmark output, you'll notice a higher time than the other sorts. However,
    when operating with more than one processor, a *2D mesh* is created. The advantage
    of the 2D mesh is that sorts can be made concurrently on the rows and columns—you
    get two sorts for each clock cycle! This algorithm is a perfect example of divide-and-conquer.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) class Shear_sort      def sort(a)          div =
    1          i   = 1  ![](../Images/00003.jpg)         while i * i <= a.length   
              if a.length % i == 0                  div = i              end     
        i += 1      end       @rows = div          @cols = a.length/div  ![](../Images/00004.jpg)  
          @log = Math.log(@rows).to_i  ![](../Images/00005.jpg)             @log.times
    do              (@cols / 2).times do              @rows.times do |i|         
        part1_sort(a, i*@cols, (i+1)*@cols, 1, i % 2 == 0)          end          
    @rows.times do |i|              part2_sort(a, i*@cols, (i+1)*@cols, 1, i % 2 ==
    0)          end      end       (@rows / 2).times do          @cols.times do |i|
                 part1_sort(a, i, @rows*@cols+i, @cols, true)          end        
      @cols.times do |i|              part2_sort(a, i, @rows*@cols+i, @cols, true)
             end      end  end  ![](../Images/00006.jpg)     (@cols / 2).times do
             @rows.times do |i|              part1_sort(a, i*@cols, (i+1)*@cols, 1,
    true)          end           @rows.times do |i|              part2_sort(a, i*@cols,
    (i+1)*@cols, 1, true)          end      end      return a  end  ![](../Images/00007.jpg) def
    part1_sort(ap_array, a_low, a_hi, a_nx, a_up)        part_sort(ap_array, a_low,
    a_hi, a_nx, a_up)    end     def part2_sort(ap_array, a_low, a_hi, a_nx, a_up)
           part_sort(ap_array, a_low + a_nx, a_hi, a_nx, a_up)    end     def part_sort(ap_array,
    j, a_hi, a_nx, a_up) ![](../Images/00008.jpg)         while (j + a_nx) < a_hi
    ![](../Images/00009.jpg)           if((a_up && ap_array[j] > ap_array[j+a_nx])
    || !a_up && ap_array[j] <  ap_array[j+a_nx])                ap_array[j], ap_array[j
    + a_nx] = ap_array[j+a_nx], ap_array[j]            end            j += a_nx *
    2          end      end  end   big_array = Array.new  big_array_sorted = Array.new   IO.foreach("1000RanNum.txt",
    $\ = '' '') {|num| big_array.push num.to_i }   puts Benchmark.measure {big_array_sorted
    = Shear_sort.new.sort(big_array)}   File.open("output_shear_sort.txt","w") do
    |out|      out.puts big_array_sorted  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby shearSort.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script will sort the random numbers and output the ordered data to *output_shear_sort.txt*,
    then output the amount of time used to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user       system     total    real 4.875000   0.000000   4.875000 (  4.875000)`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until this point, each of the sorts has been optimized for a single-processor
    architecture. Shear sort leverages the efficiencies of multiple processors. As
    mentioned above, a 2D mesh is created, and the variables `@rows` and `@cols` track
    the mesh. The sort methods are grouped together in a class called `Shear_sort`
    ![](../Images/00002.jpg). The class is composed of four methods, but two of the
    methods (`part1_sort` and `part2_sort`) are nearly identical. The first method
    we will analyze is `sort`. This method is responsible for calling the two other
    sorting methods, as well as maintaining control over all of the sorted parts,
    like a manager. The method begins by defining a few variables used to hold information
    when creating the 2D mesh.
  prefs: []
  type: TYPE_NORMAL
- en: The first while loop is used to make some calculations need to design the 2D
    mesh ![](../Images/00003.jpg). The operations tell the script how many rows there
    will be in the mesh. Using the number of rows divided by the length of the data
    set will yield how many columns are needed to create the 2D mesh. The dimensions
    of the 2D mesh are stored in `@rows` and `@cols`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `@log` is calculated. This calculation is a `logarithmic` method of the
    data set length (this method is found in the Math library) ![](../Images/00004.jpg).
    `@log` will be used to limit the amount of times we loop through the first of
    two sorting iterations. This `@log` loop begins the sorting process, and it is
    also the first time we call `part1_sort` and `part2_sort` ![](../Images/00005.jpg).
    There are a lot of nested loops in here, so note that the order of sorts is rows
    first, followed by columns. The sorting of rows is actually done in alternating
    directions, and that is where the last argument of `part1_sort` comes into play.
    Even-numbered rows are sorted from left to right, and odd-numbered rows are sorted
    the other way. Don't worry though, the last while loop we'll look at corrects
    this alternating sort. The columns are also sorted in the third while loop, but
    they are sorted in the same direction every time. This process is performed log(*n*)
    times, or `@log`.
  prefs: []
  type: TYPE_NORMAL
- en: After the `@log` loop has terminated, another round of looping is required to
    complete the sorting of the data set ![](../Images/00006.jpg). Remember that the
    row sorting was done using alternating sorts; this time, the sorting is performed
    in the same direction. The final sort is a copy from the row sorting loop above.
    The only difference is that the last argument passed to `part1_sort` and `part2_sort`
    is specified to `true`. Once again, this loop sorts the data set further and,
    more importantly, finalizes the positions of all the elements within the original
    data set.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll only describe `part1_sort` because, as I mentioned earlier, it''s nearly
    identical to `part2_sort`. Don''t worry—I''ll point out the differences for you
    just in case you missed them. If multiple processors were available, the sorting
    of parts one and two would occur simultaneously, giving shear sort a very short
    execution time for large data sets. The `part1_sort` method takes five arguments:
    an array, a low number, a high number, a column, and a Boolean value ![](../Images/00007.jpg).
    The difference between these two `part` sorts is the calculation of the second
    argument. If you trace the method of `part_sort`, you will see the variable `j`.
    This variable relates to which part of the data set is being manipulated, and
    therein lies the difference between the two `part` sorts ![](../Images/00008.jpg).
    If you were to view the data set in the middle of the algorithm, you wouldn''t
    see a 2D array. Instead, the 2D mesh is all based on element positions. If the
    mesh had five columns and five rows, then every fifth element would be the start
    of a column, and the elements in between would represent pieces of a row. Now
    if you see the element comparisons and wonder why the algorithm is comparing elements''
    distances from each other, you''ll know why!'
  prefs: []
  type: TYPE_NORMAL
- en: If the Boolean argument is `true` and the lower indexed element is greater than
    the higher indexed element, then the values are swapped. The same is true if the
    Boolean argument is `false` and the lower indexed element is less than the higher
    indexed element. If neither of the conditions is valid, the while loop moves on
    ![](../Images/00009.jpg). By using the `if` statement, alternating sorts are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the loops have finished running, the array will be sorted. The array,
    stored in the variable `a`, is returned to the calling function. Overall, this
    sort has a lot of code, but the efficiencies are truly remarkable.
  prefs: []
  type: TYPE_NORMAL
- en: A Note About Efficiencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficiency may or may not be something you have thought about as you've scripted
    or written applications. However, I bet if you were to write anything that scaled,
    or could be expanded, efficiency would become important. Honestly, you could use
    any of the algorithms presented in this chapter to sort an array of 10 elements,
    and you wouldn't notice a bit of performance difference. What about if you start
    sorting arrays of 10,000 elements? 100,000 elements? The performance issue will
    become a bit more noticeable. The situation and context of the script you're writing
    should determine the best sorting algorithm to use. Experience will give you more
    insight into the best tool to accomplish the job.
  prefs: []
  type: TYPE_NORMAL
- en: While on the topic of efficiency, sorting algorithms aren't the only place to
    improve efficiencies within a script. Searching algorithms, processing vectors,
    logical checks, or conditional loops can all be scrutinized for ways to improve
    efficiency. There is usually more than one way to solve a problem; if you don't
    know the best way to accomplish a specific task, experiment with several methods,
    and use the benchmarking library to help you compare the results of the different
    approaches. Don't just stop with sorting algorithms, think about the code you're
    writing holistically, and see if there are ways to accomplish your objective more
    efficiently.
  prefs: []
  type: TYPE_NORMAL
