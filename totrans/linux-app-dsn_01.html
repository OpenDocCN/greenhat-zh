<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page1"/><img src="../images/25-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter1"/><a href="toc.html#chapter1"><b>APPLIANCE ARCHITECTURE</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">We’ll begin our adventure with a high-level look at the architecture of a Linux appliance. We’ll then drop a little lower in altitude and look at a Linux appliance from the perspective of processes. As you’ll soon see, the view from this lower altitude matches the organization and chapters used throughout this book.</p>&#13;
<p class="indent">In this chapter, we will cover the following:</p>&#13;
<p class="bul">• UIs and daemons</p>&#13;
<p class="bul">• The architecture of the Laddie appliance</p>&#13;
<p class="indent1">We have worked on Linux appliances that range from small, handheld devices to large, multi-gigabyte, multi-processor network servers. Most of these appliances have a strikingly similar software architecture.</p>&#13;
<p class="indent">Figure 1-1 shows the software stack we typically see in a Linux appliance. At the bottom of this stack is an embedded Linux kernel. Above the kernel are the various user interfaces and common services such as network management and logging, and at the top is the particular function that defines the appliance.</p>&#13;
<p class="noindent1">Where appliances are concerned, the term <i>user interface (UI)</i> refers to an interface through which the user manages the appliance configuration and views its status and statistics. The lack of a screen and keyboard are hallmarks of an appliance, but do not let that fool you—all appliances have UIs. To be sure, the more invisible the UI the better the appliance, but the UI is always there nonetheless. Also, network appliances often have web, SNMP, and command line interfaces, while consumer appliances have framebuffers and small, alphanumeric LCD interfaces.</p>&#13;
<p class="imgc"><a id="page2"/><img src="../images/26-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 1-1: Linux appliance software stack</i></p>&#13;
<p class="secl"><a id="chapter1.1"/><a href="toc.html#chapter1.1"><b>UIs and Daemons</b></a></p>&#13;
<p class="noindent">Assuming that our Linux appliance will have multiple, simultaneous UIs, when we look at the appliance from the point of view of running processes we get an architecture something like that shown in Figure 1-2. The UI programs interact with the users to accept commands and configuration and to display status and statistics. Daemons, on the other hand, interact with the hardware, other daemons, and the UIs to provide the appliance’s defining service as well as status and statistics.</p>&#13;
<p class="imgc"><img src="../images/26-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 1-2: A common appliance architecture</i></p>&#13;
<p class="secs"><a id="chapter1.2"/><a href="toc.html#chapter1.2"><b><i>Daemons</i></b></a></p>&#13;
<p class="noindent">Daemons are background programs that are most often started just after booting Linux. Daemons distinguish themselves in that they don’t have a controlling terminal like programs started from the bash command line. Let’s look at the kinds of daemons found on a typical appliance.</p>&#13;
<p class="secls"><b>Defining Application</b></p>&#13;
<p class="noindent"><a id="page3"/>The <i>defining application</i> in the diagram refers to the daemon that provides the unique function offered by the appliance. For example, the defining application for an advanced telephone answering machine is the daemon that actually answers the phone and records the call.</p>&#13;
<p class="secls"><b>Logging Daemon</b></p>&#13;
<p class="noindent">The <i>logging daemon </i>shown in Figure 1-2 collects log messages and either saves them to disk or routes them to another host on the network. The syslog daemon is the default logging daemon on most Linux systems.</p>&#13;
<p class="secls"><b>Event Handler</b></p>&#13;
<p class="noindent">The <i>event handler</i> provides a local, active response to events. Often the logging daemon and the event-handling daemon are one in the same, as they are in the logmuxd daemon that runs on our sample appliance.</p>&#13;
<p class="secls"><b>Security Monitor</b></p>&#13;
<p class="noindent">The <i>security monitor</i> controls access to critical configuration or resources, such as identification and authentication credentials. The security monitor should also respond to Mandatory Access Control (MAC) violations.</p>&#13;
<p class="secls"><b>Hardware Monitor</b></p>&#13;
<p class="noindent">The <i>hardware monitor</i> watches for temperature alarms and disk drive problems. Most PC-based Linux appliances will use the lm_sensors package to monitor CPU and motherboard sensors and the smartd daemon to monitor the temperature and error statistics on hard disks. A hardware monitor might combine the information from these and other sources into a comprehensive report of the health of the appliance.</p>&#13;
<p class="secs"><a id="chapter1.3"/><a href="toc.html#chapter1.3"><b><i>User Interfaces</i></b></a></p>&#13;
<p class="noindent">When we first started building Linux appliances we thought that the nature of the appliance defined the type of UI it would have. Boy, were we wrong. Customers always ask for more than one way to manage the device. Smart-phones need a framebuffer interface <i>and</i> a web interface over Bluetooth. Network appliances need a web interface <i>and</i> an SNMP interface. When you look at Figure 1-2, don’t think “Which one?” Think “How many?”</p>&#13;
<p class="indent">The UIs depicted in Figure 1-2 are not the only possible choices. For example, you might want an interface that runs natively on a Windows PC, or if you’re building a network appliance, you may want to add interfaces to an LDAP or RADIUS authentication server or to the network’s billing system and database. Figure 1-2 shows the most common UIs and the ones described in the book.</p>&#13;
<p class="secls"><b>Web Interface</b></p>&#13;
<p class="noindent"><a id="page4"/>A <i>web interface</i> is mandatory if your appliance has a network interface. You’ll have a lot to decide here: Do you use JavaScript or not? Is the back end written in Perl, PHP, C, or Java? Which do you use? Do you presume that all browsers support cascading style sheets? Chapter 8 on web UIs will help you evaluate the trade-offs for all these issues.</p>&#13;
<p class="secls"><b>Framebuffer Interface</b></p>&#13;
<p class="noindent"><i>Framebuffer interfaces </i>are popular for television set-top boxes, such as TiVo or a PVR, stand-alone kiosks, and some handheld devices. The hardware in a framebuffer gives you direct control over each pixel on the screen. This gives you great flexibility in what your interface looks like, but at the cost of burdening you with <i>managing</i> every pixel on the screen. Some libraries and graphics toolsets, such as the Simple DirectMedia Layer (SDL) can help. The art in building a framebuffer interface is in choosing the right toolset.</p>&#13;
<p class="secls"><b>Front Panel</b></p>&#13;
<p class="noindent"><i>Front panel interfaces</i>, whether simple or complex, appear on almost all Linux appliances. A simple front panel might have only a few lights and buttons, while a more complex one might have an alphanumeric liquid crystal display (LCD) or a vacuum florescent display. Even a simple front panel may require a deep understanding of the underlying hardware.</p>&#13;
<p class="secls"><b>SNMP Interface</b></p>&#13;
<p class="noindent">We have heard it said that an <i>SNMP interface</i> makes the difference between a commercially viable network appliance and a hobby. From our experience we’d have to agree. SNMP is not too difficult if you break it into pieces. First, you need to familiarize yourself with the concepts used in SNMP and with the SNMP commands available in Linux. Then, you need to design a Management Information Base (MIB), or schema, for the data made visible by your SNMP interface. Finally, you need to write the software that makes the MIB available to the SNMP commands.</p>&#13;
<p class="secls"><b>Command Line Interfaces</b></p>&#13;
<p class="noindent"><i>Command line interfaces</i> (CLIs) are often used as the control interface of last resort for network appliances. A CLI on a serial port remains available even when the entire network is down. CLIs also find use as an appliance-specific scripting language.</p>&#13;
<p class="secs"><a id="chapter1.4"/><a href="toc.html#chapter1.4"><b><i>Interprocess Communication</i></b></a></p>&#13;
<p class="noindent">Finally, you may have noticed the full-mesh interconnect of lines in Figure 1-2. Don’t let it intimidate you. Our point is that any UI should be able to connect to any daemon. This requirement dictates a lot of the features to look for in the interprocess communication (IPC) mechanism used between the UIs and the daemons. (We’ll have more to say about this in Chapter 2.)</p>&#13;
<p class="secl"><a id="chapter1.5"/><a href="toc.html#chapter1.5"><b>The Architecture of the Laddie Appliance</b></a></p>&#13;
<p class="noindent"><a id="page5"/>This book’s sample appliance is an alarm system that uses the input pins on a parallel port for input from the alarm sensors. The UIs include web, command line, LCD with a keypad, framebuffer with IR remote control, and SNMP.</p>&#13;
<p class="indent">The daemons on our appliance include the alarm system daemon and one to respond to appliance events. We chose not to implement all of the daemons shown in Figure 1-2 so that we could focus on describing how to build and secure daemons in general.</p>&#13;
<p class="indent">Of course, our sample appliance includes ladd (the defining application), an event handler, and a utility to make common Linux configuration files visible using a protocol common to all the UIs.</p>&#13;
<p class="indent">Figure 1-3 shows the architecture of the Laddie appliance and maps the UI, feature, or daemon to a chapter number or appendix so that you can see how things will come together throughout the book.</p>&#13;
<p class="imgc"><img src="../images/29-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 1-3: A chapter map of the Laddie appliance</i></p>&#13;
<p class="indent">We’ve limited the functionality of our UIs to make them more useful as tutorials. Only the web interface is full featured and representative of what a real appliance might have.</p>&#13;
<p class="secl"><a id="chapter1.6"/><a href="toc.html#chapter1.6"><b>Summary</b></a></p>&#13;
<p class="noindent">Most Linux appliances have a common architecture: Linux on the bottom, the defining application on top, and common services and UIs in the middle. We discussed some of the reasons to include various daemons and UIs and mapped this book’s chapters into an architecture diagram.</p>&#13;
<p class="indent">The next chapter looks at the API between the UIs and daemons, since the chosen API impacts both UIs and daemons.<a id="page6"/></p>&#13;
</div>&#13;
</body></html>