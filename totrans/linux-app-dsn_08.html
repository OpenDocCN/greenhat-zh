<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page105"/><img src="../images/129-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter8"/><a href="toc.html#chapter8"><b>DESIGNING A WEB INTERFACE</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">The web browser has become the user interface of choice for configuring networked appliances, particularly home-based routers from companies like Linksys and Netgear. The driving force behind the popularity of web interfaces is that they are easy to use and don’t require specialized client software. Customers now expect to be able to access web interfaces for their devices, and so it is no surprise that leading manufacturers of home-based networked appliances provide them.</p>&#13;
<p class="indent">This is the first of several chapters devoted to user interface (UI) design. This chapter covers web UIs in general, and the development of Laddie’s web UI in particular. In the chapters that follow, we’ll look at Laddie’s other UIs: the CLI interface in Chapter 9, the front panel LCD interface in Chapter 10, the framebuffer interface in Chapter 11, and the infrared remote control interface in Chapter 12. All of these UIs communicate with the back-end daemons via the PostgreSQL protocol.</p>&#13;
<p class="indent"><a id="page106"/>This chapter covers the following topics:</p>&#13;
<ul>&#13;
<li>An overview of web technology</li>&#13;
<li>Establishing requirements for your appliance’s web interface</li>&#13;
<li>Choosing a webserver</li>&#13;
<li>Designing the look and feel of the web interface</li>&#13;
<li>Highlights of our implementation</li>&#13;
<li>Lessons learned and future improvements</li>&#13;
</ul>&#13;
<p class="secl"><a id="chapter8.1"/><a href="toc.html#chapter8.1"><b>Web Basics</b></a></p>&#13;
<p class="noindent">Web browsers communicate with webservers using the <i>HyperText Transfer Protocol (HTTP),</i> a client-server protocol. The communication is initiated from the web browser (the client) when it requests a web page via a particular Uniform Resource Locator (URL), for example, <a href="http://www.google.com/">http://www.google.com</a>. When the webserver receives this request, it checks that the requested page is available, and if it is, it sends the page to the web browser.</p>&#13;
<p class="indent">Because the HTTP protocol is text based, you can use telnet to imitate the browser request as follows:</p>&#13;
<p class="ex">telnet <a href="http://www.google.com/">www.google.com</a> 80</p>&#13;
<p class="indent">Once the telnet session has connected, enter the following:</p>&#13;
<p class="ex">GET / HTTP/1.0</p>&#13;
<p class="indent">Then press enter twice (the empty line created by the second enter causes the webserver to respond to the GET request). The page returned is formatted using HTML; an example page appears below. (Obviously, this page would look different if you opened it in a browser, because the browser would interpret the HTML markup and present it in a human-readable way.) Note that the middle portion of the page has been replaced by ellipses (. . .) to reduce its size.</p>&#13;
<p class="imgl"><img src="../images/130-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter8.2"/><a href="toc.html#chapter8.2"><i><b>DNS and TCP</b></i></a></p>&#13;
<p class="noindent"><a id="page107"/>The network protocols DNS (Domain Name System) and TCP (Transmission Control Protocol) make this client-server exchange possible. Given the URL (e.g., <a href="http://www.google.com/">http://www.google.com</a>), the client uses DNS to determine the IP address of the server. HTTP uses TCP for error-free data transmission between client and server.</p>&#13;
<p class="indent">These protocols are defined by the Internet Engineering Task Force (IETF), the authoritative Internet standards body. (For more information on IETF standards, see <a href="http://www.ietf.org/">http://www.ietf.org</a>; for more information on TCP/IP, see <i>The TCP/IP Guide</i> by Charles M. Kozierok, No Starch Press, 2005.)</p>&#13;
<p class="secs"><a id="chapter8.3"/><a href="toc.html#chapter8.3"><i><b>The Webserver</b></i></a></p>&#13;
<p class="noindent">The webserver finds and returns the web page for the given URL. This page may reside in the server’s filesystem or in memory, or it may be generated dynamically at the time of the request.</p>&#13;
<p class="secs"><a id="chapter8.4"/><a href="toc.html#chapter8.4"><i><b>CGI</b></i></a></p>&#13;
<p class="noindent">The <i>Common Gateway Interface (CGI)</i> emerged as a way for a webserver to communicate with a purpose-built program, which would in turn generate the web page on behalf of the webserver. In the Unix world, the early CGI programs were written in languages like bash, Perl, and C. Today, web-specific scripting languages like PHP are more common. Furthermore, modern webservers like Apache can be configured to run PHP scripts within the same process as the Apache webserver, thereby avoiding the CGI communication mechanism.</p>&#13;
<p class="secs"><a id="chapter8.5"/><a href="toc.html#chapter8.5"><i><b>JavaScript</b></i></a></p>&#13;
<p class="noindent">JavaScript has become accepted as the client-side programming language for web pages. JavaScript code is embedded in the HTML page, and tags in the web page tell the web browser when to execute the JavaScript functions. One of JavaScript’s main advantages is that it provides a more responsive user experience. One of JavaScript’s main disadvantages is that not all browsers support it, and those that do don’t necessarily support it in a standard way.</p>&#13;
<p class="secs"><a id="chapter8.6"/><a href="toc.html#chapter8.6"><i><b>Evolving Technologies</b></i></a></p>&#13;
<p class="noindent">Coupled with developments on the client side and server side, the HTML protocol has undergone many revisions and has expanded to include XHTML, CSS, XSL, and XPath.</p>&#13;
<p class="indent">The bottom line is that web technology is still evolving. This evolution introduces challenges for developers striving for interoperability and longevity for their web pages. Therefore, as a web developer, it is prudent to plan ahead for changes in web technology.</p>&#13;
<p class="secl"><a id="chapter8.7"/><a href="toc.html#chapter8.7"><b>Establishing Requirements</b></a></p>&#13;
<p class="noindent"><a id="page108"/>Before developing a web UI for the Laddie alarm appliance, we established the following requirements to guide us with its design:</p>&#13;
<ul>&#13;
<li>The web interface should be easy to use.</li>&#13;
<li>The web interface should support a wide variety of browsers, including text-based ones.</li>&#13;
<li>The web pages should update automatically as the state on the appliance changes.</li>&#13;
<li>The web pages should adhere to Internet standards, avoiding proprietary features.</li>&#13;
<li>The implementation should work with various webservers so that the appliance webserver can be replaced should a better one become available.</li>&#13;
<li>The implementation should be simple so that it can be easily maintained.</li>&#13;
</ul>&#13;
<p class="secl"><a id="chapter8.8"/><a href="toc.html#chapter8.8"><b>Choosing a Webserver</b></a></p>&#13;
<p class="noindent">Which webserver should you use when building your appliance? In this section we’ll review several webservers suitable for Linux appliances.</p>&#13;
<p class="secs"><a id="chapter8.9"/><a href="toc.html#chapter8.9"><i><b>Choices</b></i></a></p>&#13;
<p class="noindent">Webservers come in several different flavors. Many support the CGI interface, which allows the webserver to spawn an arbitrary process to generate the web page content on behalf of the webserver.</p>&#13;
<ul>&#13;
<li>The Apache webserver can be compiled with a PHP interpreter so that PHP scripts are interpreted within the Apache process. This approach reduces inter-process communication and improves response time.</li>&#13;
<li>The lighttpd webserver supports the FastCGI interface. The FastCGI mechanism spawns multiple PHP interpreters and load balances requests for PHP web pages between them. For more information, see <a href="http://www.fastcgi.com/">http://www.fastcgi.com</a>.</li>&#13;
<li>The GoAhead webserver allows the webserver and all web pages to be packaged into a single executable, which allows the webserver to run without a filesystem.</li>&#13;
<li>The webserver in the Linksys WRT54G wireless router is written entirely in C and includes handcrafted functions for each web page.</li>&#13;
<li>The TUX webserver runs in the Linux kernel.</li>&#13;
</ul>&#13;
<p class="indent">Perhaps the first thing to consider when choosing a webserver is the license. If you don’t want to release your source code modifications, then you should avoid webservers with GPL and Apache licenses. On the other hand, if you do select a mature webserver like Apache, it is unlikely that you will have to modify it, and consequently, you won’t have to worry about having to release source code.</p>&#13;
<p class="indent">We suggest that you resist developing your own webserver. It is cheaper to select an existing one and to develop the web pages in a server-agnostic way. The advantage to this approach is that you don’t have to spend your development resources maintaining a webserver, and you can replace the webserver should a better one become available.</p>&#13;
<p class="secs"><a id="chapter8.10"/><a href="toc.html#chapter8.10"><i><b>Use PHP</b></i></a></p>&#13;
<p class="noindent"><a id="page109"/>We suggest using PHP as the language to generate dynamic web pages. Though you can write smaller CGI programs in C, if you use a compiled language and need to modify a web page once the appliance has been deployed, you will need a compile environment, which would typically not be available on the deployed appliance.</p>&#13;
<p class="indent">When you use an interpreted language like PHP, you can easily modify and test the web pages on the deployed appliance.</p>&#13;
<p class="indent">PHP is a good language for generating web content because it is popular, mature, has an active developer community, and is well integrated into open source webservers such as Apache, thttpd, and lighttpd. Even for webservers that don’t support PHP, you can still write CGI programs <i>using PHP.</i> Thus, you can use PHP with just about any webserver. It is for these reasons that we selected PHP to develop the Laddie web UI.</p>&#13;
<p class="secs"><a id="chapter8.11"/><a href="toc.html#chapter8.11"><i><b>Case Study: Linksys WRT54G Wireless Router</b></i></a></p>&#13;
<p class="noindent">Let’s examine the approach taken by the Linksys WRT54G wireless router. The webserver in this router is a handcrafted combination of both the micro_httpd and mini_httpd webservers, enhanced with specialized C functions that generate the dynamic content of the web pages. The code is GPL licensed and is available from <a href="http://www.linksys.com/">http://www.linksys.com</a> under the GPL Code Center. (Both micro_httpd and mini_httpd were written by Jef Poskanzer and are available at <a href="http://www.acme.com/">http://www.acme.com</a>.)</p>&#13;
<p class="indent">The specialized C functions are responsible for generating dynamic content for the web pages. Because these functions are compiled into the webserver, there is no need for a script interpreter like PHP.</p>&#13;
<p class="indent">For example, the C function dump_route_table() is invoked from a web page by placing the function name between a matching pair of tags, as follows:</p>&#13;
<p class="ex">&lt;% dump_route_table(""); %&gt;</p>&#13;
<p class="indent">This tag mechanism is similar to the approach taken by PHP, except that here, the function is implemented in C and compiled into the webserver.</p>&#13;
<p class="indent">The advantage of this approach is that it has smaller memory requirements. However, as mentioned earlier, the problem with this approach is that the development cycle is extended because any change to a specialized C function requires a recompile.</p>&#13;
<p class="secs"><a id="chapter8.12"/><a href="toc.html#chapter8.12"><i><b>Case Study: The TUX Webserver</b></i></a></p>&#13;
<p class="noindent"><a id="page110"/>Unlike most other webservers, which run in user space, the TUX webserver runs in the Linux kernel. Running in kernel space allows TUX to avoid communication between kernel space and user space; therefore, TUX offers better server response time than other webservers.</p>&#13;
<p class="indent">TUX supports both static and dynamic web page content, but for it to support dynamic content, another webserver must be running in user space. TUX operates by responding to requests for static web pages itself and forwarding requests for dynamic content to a user space webserver like Apache. As you might imagine, TUX doesn’t offer speed advantages when it comes to support for dynamic web pages. Thus, for websites that have mostly dynamically generated content, the extra TUX configuration might not be worth the trouble.</p>&#13;
<p class="secs"><a id="chapter8.13"/><a href="toc.html#chapter8.13"><i><b>Comparison of Webservers</b></i></a></p>&#13;
<p class="noindent">In the previous section, we listed a range of webservers from Apache to TUX. In this section, we’ll narrow our focus to comparing only webservers that support PHP as the scripting language. For space reasons, we’ve limited the set of webservers to Apache, Boa, BusyBox’s httpd, Cherokee, GoAhead, lighttpd, and thttpd. These webservers have been selected because they are either used in commercial products or they are tailored for embedded applications.</p>&#13;
<p class="indent">Possible criteria for comparing webservers include:</p>&#13;
<ul>&#13;
<li>Memory footprint</li>&#13;
<li>Size of executable file</li>&#13;
<li>Performance</li>&#13;
<li>Security support</li>&#13;
<li>Ongoing maintenance and development</li>&#13;
<li>Debugging support</li>&#13;
<li>Documentation</li>&#13;
<li>Cost</li>&#13;
</ul>&#13;
<p class="indent">Regardless of how you weigh the different criteria, choosing a webserver will require a compromise. For example, the memory footprint may be critical for some appliances, but not for others.</p>&#13;
<p class="indent">Rather than advocating one webserver for your appliance, we’ve compiled Table 8-1, which shows how the various webservers in our limited set compare in each area. You can use this table as a starting point when selecting a webserver.</p>&#13;
<p class="indent">You can use different webservers for different stages of development. For example, you could use one webserver that has good debugging support in the development phase, and then switch to another one with a small memory footprint during testing and deployment. If you choose to use different webservers, plan ahead to ensure that you use features supported by all of them.</p>&#13;
<p class="tcap"><b>Table 8-1:</b> Comparison of Various Webservers</p>&#13;
<p class="imgl"><a id="page111"/><img src="../images/135-1.jpg" alt=""/></p>&#13;
<p class="secls"><b>About the Tabular Data</b></p>&#13;
<p class="noindent">Let’s look at Table 8-1 in more detail.</p>&#13;
<p class="bl1"><b>Version tested</b> This is the software version of the webserver that we tested.</p>&#13;
<p class="bl1"><b>Virtual memory</b> This is the virtual memory (in kilobytes) that the running webserver consumed. The virtual memory was measured using the Unix top command, which displays virtual memory under the SIZE column. For webservers that spawn multiple processes, we recorded the maximum value. In each case, the virtual memory was recorded during the performance test. (See <i>Response time</i> on the next page.)</p>&#13;
<p class="bl1"><b>Executable size</b> This is the size (in kilobytes) of the executable file after compiling it with mostly default options and then manually stripping it with the strip command. This metric is not as good of an indication of required memory as virtual memory is because libraries are sometimes linked dynamically and sometimes linked statically.</p>&#13;
<p class="bli">When programs are linked dynamically, much of the code can be in dynamically linked libraries. When you view the size of the executable, the code in these libraries will not be factored in. So the size of a dynamically linked executable is not a good indication of how much memory will be required when the executable is run (when all the libraries are linked-in at load-time). Typically, what’s important is how much memory a program requires to run, because memory is the precious resource.</p>&#13;
<p class="bl1"><a id="page112"/><b>Response time</b> This is the average response time (in milliseconds) to access Laddie’s status.php page, as recorded by the httperf utility (available at <a href="http://www.hpl.hp.com/research/linux/httperf">http://www.hpl.hp.com/research/linux/httperf</a>). The motivation for this performance test is to measure how quickly the webserver responds to requests for the status web page. The following steps were taken for each webserver:</p>&#13;
<p class="blh">a. The webserver’s software was compiled with default options, except for those options necessary to make it work correctly. Detailed instructions on how each webserver was configured is available in /Code/src/web/INSTALL_WEB_SERVER.txt on this book’s companion CD. We used PHP version 5.0.3.</p>&#13;
<p class="blh">b. The resulting webserver executable was stripped with the strip command.</p>&#13;
<p class="blh">c. The back-end Laddie process, ladd, was run.</p>&#13;
<p class="blh">d. The following command was used to measure the response time:</p>&#13;
<p class="ex">httperf --hog --server 192.168.1.11 --uri=/cgi-bin/status.php --num-conn 200 --rate 1</p>&#13;
<p class="bli">The resultant dynamically generated status.php page was 4546 bytes. The server we used for testing consisted of an Intel Celeron 2.4 GHz processor running Linux Red Hat 9 with otherwise idle processes. The client consisted of an AMD Duron 1 GHz processor running Linux Red Hat 9. The server and client had 10 MHz NICs with a Linksys switch/ router between them.</p>&#13;
<p class="bl1"><b>Supports CGI</b> This denotes whether or not the webserver supports the Common Gateway Interface (CGI).</p>&#13;
<p class="bl1"><b>Supports FastCGI</b> This denotes whether or not the webserver supports FastCGI, a performance enhancement to CGI. Documentation about FastCGI may be found at <a href="http://www.fastcgi.com/">http://www.fastcgi.com</a>.</p>&#13;
<p class="bl1"><b>Supports in-process scripting</b> This denotes whether the webserver supports a built-in PHP interpreter (or some other script interpreter). This functionality provides faster performance because it avoids interprocess-communication in the CGI interface.</p>&#13;
<p class="bl1"><b>Server API used</b> This is the Server API interface used during the response time performance test. The Server API is the communication mechanism between the webserver and the scripts, for example, Apache, CGI, and FastCGI. As you can see from the table, some webservers support only one Server API, while others support more than one.</p>&#13;
<p class="bl1"><b>Last release</b> This is the last time the software was released at the time of writing. This value is an indication of whether the software is actively maintained. In most cases, the version we tested was the last version released. However, there is one exception—the last version of thttpd released as of this writing was 2.25b, but we tested version 2.21b, because 2.21b was the last version that supported in-process scripting.</p>&#13;
<p class="bl1"><a id="page113"/><b>Debugging</b> This denotes whether or not you can debug scripts with the webserver. In the case of Apache and PHP, there is a commercial development environment called Zend Studio that allows you to debug PHP scripts using Internet Explorer. Using Zend, you can step though PHP scripts one line at a time and view PHP variables.</p>&#13;
<p class="bl1"><b>Documentation</b> This is a rough measure of whether or not the documentation specifies clearly which features the webserver supports and whether it provides instructions on how to use each feature.</p>&#13;
<p class="bl1"><b>Cost</b> This is the monetary cost of distributing the webserver in an appliance. Note that we have not included any webservers for which there is a monetary cost.</p>&#13;
<p class="bl1"><b>Security</b> These are the security features that prevent users from accessing files that they shouldn’t be able to access. The most secure webservers are those that enforce access through a configuration file.</p>&#13;
<p class="bl1"><b>License</b> This is the type of software license the webserver has. The Apache, BSD, and GPL licenses are well known. The GoAhead license requires that you notify GoAhead prior to shipping your product and that you display a GoAhead logo on your initial web page.</p>&#13;
<p class="secls"><b>Considering Memory Requirements</b></p>&#13;
<p class="noindent">If memory is not a factor in your appliance, the Apache webserver would be a good choice. The advantage of Apache is its mature feature set, good development tools (like Zend Studio), and an active development community.</p>&#13;
<p class="indent">If memory is at a premium, then the BusyBox webserver might be a good choice; it has the smallest virtual memory requirements of the webservers we tested. The GoAhead webserver has the next smallest memory requirements; however, the disadvantage of GoAhead is that it uses Active Server Pages, a Microsoft technology, rather than PHP, an open source technology. (You can still run PHP scripts in GoAhead using the CGI mechanism, but it isn’t as seamless as using a webserver with a built-in PHP interpreter.)</p>&#13;
<p class="secls"><b>Considering Response Time</b></p>&#13;
<p class="noindent">The top three webservers in terms of response time are thttpd, Apache, and lighttpd. Both thttpd and Apache get their speed from running PHP scripts in the same process as the webserver itself, which avoids the inter-process communication used by the other webservers. The thttpd webserver has the disadvantage that it only services one request at a time, so it will block subsequent requests until previous requests have been completed. This behavior may be fine for some web pages, but it will be a problem if the web page is written to block requests for a certain length of time, or to block until a state change. One of the Laddie web pages does block for a state change, and so this web page behavior rules out using thttpd webserver for the Laddie appliance. (We’ll discuss this particular web page in the section “Asynchronous Updates Using Ajax” on page 125.)</p>&#13;
<p class="secls"><b>Our Choice</b></p>&#13;
<p class="noindent"><a id="page114"/>When we were developing Laddie, we used the Apache webserver because of its debugging support, while for the production appliance, we selected lighttpd because of its smaller memory requirement and its speed. We chose which webserver to use in the production appliance rather late in the development cycle. We were able to make this decision later because we had written our PHP scripts to work under Apache, CGI, and FastCGI.</p>&#13;
<p class="indent">In his book about embedded Linux, Yaghmour advises against using Apache because it is difficult to cross-compile (<i>Building Embedded Linux Systems</i>, by Karim Yaghmour, O’Reilly, 2003). There was no need to cross-compile for our appliance, but if your appliance’s CPU differs from your development machine’s CPU, you should keep this in mind.</p>&#13;
<p class="secl"><a id="chapter8.14"/><a href="toc.html#chapter8.14"><b>UI Design</b></a></p>&#13;
<p class="noindent">In this section, we’ll review various approaches to designing the UI look and feel, and the trade-offs they require. We will weigh these trade-offs when making implementation decisions in the “Implementation” section on page 118.</p>&#13;
<p class="secs"><a id="chapter8.15"/><a href="toc.html#chapter8.15"><i><b>Menu System</b></i></a></p>&#13;
<p class="noindent">One of the most important functions of a menu system is that it allows users to quickly grasp the system’s capabilities. A menu with lots of top-level options can make it difficult for the user to choose an action, because there are so many choices. On the other hand, a menu with lots of nesting, though reducing the crowding on the top-level menu, tends to increase the time it takes to find an action.</p>&#13;
<p class="indent">Menu systems can be divided into those in which the top-level menu runs vertically down the left side of the window (see Figure 8-1), and those in which the top-level menu runs horizontally, near the top of the window (see Figure 8-2). While the vertical menu can be useful, it can quickly become difficult to navigate as the number of menu items increases (note the scrollbars in Figure 8-1). The horizontal menu is usually superior because it can be more compact because the second-level menus share the same real estate.</p>&#13;
<p class="imgc"><img src="../images/138-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-1: A vertical menu</i></p>&#13;
<p class="imgc"><a id="page115"/><img src="../images/139-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-2: A horizontal menu</i></p>&#13;
<p class="indent1">One disadvantage to the vertical MyFaces menu in Figure 8-2 is that it is not visually clear that the second-level menus (e.g., <i>Tomahawk</i>, <i>Documentation</i>, and <i>Components</i>) are not selectable; they look like the third-level menus, but they behave differently. The MyFaces menu could be improved by making the non-selectable menu items more distinct. For example, see the menus shown in Figure 8-3.</p>&#13;
<p class="imgc"><img src="../images/139-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-3: A menu with distinct non-selectable items</i></p>&#13;
<p class="secs"><a id="chapter8.16"/><a href="toc.html#chapter8.16"><i><b>Dialog Boxes</b></i></a></p>&#13;
<p class="noindent">Our advice on dialog boxes is simple: Avoid them. Dialog boxes halt proceedings because the user cannot continue until he or she clicks a button to close the box. Alan Cooper argues against dialog boxes because they break the flow of the user experience and don’t move users closer to their goal <i>(About Face 2.0: The Essentials of User Interaction Design</i> by Alan Cooper and Robert Reimann, Wiley, 2003).</p>&#13;
<p class="indent">An alternative to dialog boxes is to place informational messages into the web page itself. We’ll demonstrate this in the next section.</p>&#13;
<p class="secs"><a id="chapter8.17"/><a href="toc.html#chapter8.17"><i><b>Error Messages</b></i></a></p>&#13;
<p class="noindent">Good error messages can greatly improve the usability of your web UI. Experts generally agree on the following guidelines:</p>&#13;
<ul>&#13;
<li>If possible, make the program smarter to either avoid the particular error condition or recover from it.</li>&#13;
<li>If an unrecoverable error has been detected, provide an explicit error message—that is, don’t suppress the error.</li>&#13;
<li>The error message should be human readable.</li>&#13;
<li><a id="page116"/>The error message should be detailed.</li>&#13;
<li>The error message should advise how to fix the problem.</li>&#13;
<li>The error message should be close to the field with the error.</li>&#13;
<li>The fields with errors should be clearly identified.</li>&#13;
</ul>&#13;
<p class="indent1">Some error conditions are caused by the user (when the user enters a bad value in a web form), while others are caused by external events (when the appliance disk becomes full). When designing your appliance’s web pages, think about how these different errors will be handled.</p>&#13;
<p class="indent">One way to present error messages is to use dialog boxes (see Figure 8-4), but as we mentioned before, we discourage this approach. A second approach is to insert the error message into the refreshed web page (see Figure 8-5). The salient feature with this approach is that the error message is displayed in the form field, so that users can immediately re-enter their data.</p>&#13;
<p class="imgc"><img src="../images/140-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-4: An error dialog box</i></p>&#13;
<p class="imgc"><img src="../images/140-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-5: An in-line error message</i></p>&#13;
<p class="indent"><a id="page117"/>A third approach is to annotate the labels where an error has occurred, as shown in Figure 8-6. In this example, errors are shown by displaying the labels in another color. In this figure, all of the field labels are in black, except for <i>Lan IP</i> and <i>Control IP</i>, which are in red (they’re circled here because they appear gray); this tells you that there is a problem with those fields. One problem with this approach is that it fails to provide a detailed message. While some systems provide a tooltip with a message, such a mechanism is usually not explicit enough, and the user must mouse over the label to see more detail, which makes the user do unnecessary work.</p>&#13;
<p class="imgc"><img src="../images/141-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-6: An annotated error message</i></p>&#13;
<p class="secs"><a id="chapter8.18"/><a href="toc.html#chapter8.18"><i><b>Improving Responsiveness with Ajax</b></i></a></p>&#13;
<p class="noindent"><i>Ajax (Asynchronous JavaScript and XML)</i> is a set of technologies that enables partial updates of web pages. Because only parts of a web page are refreshed, the update occurs more quickly than it would if the entire web page was refreshed. Furthermore, the partial update may be triggered by user events like mouse clicks and key presses. This behavior makes the UI more responsive than that of a traditional web page.</p>&#13;
<p class="indent">For example, Gmail, Google’s email service, uses Ajax. When you compose an email and start typing the name of a contact, the browser responds to every key, reducing the list of matches as you type. The responsiveness is impressive.</p>&#13;
<p class="indent"><a id="page118"/>Figure 8-7 shows an example of how the Ajax communication mechanism works. The exchange in this figure is initiated when the user mouses over an active element on the web page at event <img src="../images/1a.jpg" alt=""/>. An onmouseover action is triggered and JavaScript code is executed in the web browser at event <img src="../images/2a.jpg" alt=""/>. The JavaScript code creates an XMLHttpRequest object with the URL of the server-side script and a JavaScript callback function, and the web browser then sends the XMLHttpRequest object to the server at event <img src="../images/3a.jpg" alt=""/>. On the server side, the particular script identified by the URL responds with XML data at event <img src="../images/4a.jpg" alt=""/>.</p>&#13;
<p class="imgc"><img src="../images/142-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-7: Typical Ajax sequence.</i></p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>The format of the XML is known by the client and the server, so that when the server sends the XML data, the client understands its format. Typically, the XML data will contain the updated information to be displayed on some portion of the web page in the browser.</i></p>&#13;
<p class="indent1">Back on the client side, the web browser receives the XML data and invokes the JavaScript callback function. This callback function extracts the data from the XML message and modifies some portion of the web page using the XML Document Object Model (DOM) API at event <img src="../images/5a.jpg" alt=""/>.</p>&#13;
<p class="indent">Mouse movements are not the only events that are supported by Ajax, but they are the most popular, along with mouse button clicks, key presses, text selections, and keyboard focuses on editable fields—and more events are made available with each browser upgrade.</p>&#13;
<p class="secl"><a id="chapter8.19"/><a href="toc.html#chapter8.19"><b>Implementation</b></a></p>&#13;
<p class="noindent">In this section, we’ll discuss the implementation of Laddie’s web UI. We’ll show some screenshots of the web UI and discuss how it works.</p>&#13;
<p class="indent">The web UI supports at least the following web browsers: Internet Explorer (version 5.0 and later), Netscape Navigator (version 4.72 and later), Firefox (version 1.0 and later), Safari (version 1.0 and later), Opera (version 5.0 and later), and Lynx (version 2.8.2 and later). These versions were determined through direct testing with archived browsers available from <a href="http://browsers.evolt.org/">http://browsers.evolt.org</a>.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>Unlike the other graphical browsers, the Lynx browser is text-based.</i></p>&#13;
<p class="secs"><a id="chapter8.20"/><a href="toc.html#chapter8.20"><i><b>Interfacing with the Daemons</b></i></a></p>&#13;
<p class="noindent"><a id="page119"/>The Laddie web UI presents information from several running daemons. As you know, each of these daemons communicates using the PostgreSQL protocol. In this section, we’ll discuss how the web UI interacts with ladd, the Laddie alarm daemon. Once you understand this interaction, you’ll understand how the web UI interacts with the other daemons as well. Figure 8-8 shows a typical sequence where a user requests a web page and the web page is generated dynamically, based on the state of a daemon.</p>&#13;
<p class="indent">The figure shows the Linux appliance with the webserver and the ladd alarm daemon running on it. For simplicity, we’ve shown the PHP interpreter running in the same process as the webserver, as in the case of Apache, but it could be running as a different process if you’re using CGI scripts.</p>&#13;
<p class="indent">As mentioned, the figure shows a typical request-response sequence for a web page. First, the user requests a particular page at event <img src="../images/1a.jpg" alt=""/>. The webserver locates the web page from the filesystem, and because the webserver finds PHP tags in the page, it invokes the PHP interpreter, which interprets the PHP code. In our case, the particular PHP code includes PHP functions pg_connect() and pg_exec(), which are invoked by the PHP interpreter at events <img src="../images/2a.jpg" alt=""/> and <img src="../images/3a.jpg" alt=""/>. The PHP code generates the web page at event <img src="../images/4a.jpg" alt=""/>, and this new page is then sent back to the browser at event <img src="../images/5a.jpg" alt=""/>.</p>&#13;
<p class="imgc"><img src="../images/143-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-8: Interfacing with a daemon</i></p>&#13;
<p class="secls"><b>Connecting to the Daemon</b></p>&#13;
<p class="noindent">As you can see in the illustration, before you can read and write to the ladd daemon, you must establish a connection using the pg_connect() function, which is built into the PHP interpreter when you configure PHP with the --with-pgsql option. The pg_connect() function takes a string argument that specifies the hostname (or IP address) of the server and the port. In our case, the server is on the same machine as the webserver, and the ladd daemon is listening on port 8888. More information on pg_connect() can be found by searching for <i>PostgreSQL Functions</i> in the PHP manual at http://us2.php.net/pgsql.</p>&#13;
<p class="indent"><a id="page120"/>The following code fragment shows how to open a connection to the daemon:</p>&#13;
<p class="imgl"><img src="../images/144-1.jpg" alt=""/></p>&#13;
<p class="secls"><b>Reading from the Daemon</b></p>&#13;
<p class="noindent">Once a connection has been established, you can read from and write to the ladd daemon. We use the pg_exec() function to do this. This function requests that a given statement be executed, in our case a SELECT statement. For more details on pg_exec(), see the PostgreSQL Functions at <a href="http://us2.php.net/pgsql">http://us2.php.net/pgsql</a>.</p>&#13;
<p class="indent">The following PHP code fragment shows how to read the alarm status:</p>&#13;
<p class="imgl"><img src="../images/144-2.jpg" alt=""/></p>&#13;
<p class="indent">In this example, the names id, name, enabled, and alarm in the SELECT command are the column names in the Zone RTA table in the ladd daemon. Generally, the SELECT command will have the same form for different daemons, but the number of columns and their names may differ. The value returned by the pg_exec() function is an object handle, which is then used to extract the number of rows with pg_NumRows() and each row’s contents with pg_result().</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>All the functions with names that start with pg are part of the PostgreSQL PHP library and are not unique to our daemon.</i></p>&#13;
<p class="indent1">Once the information has been read from the daemon, you can use this information to generate an HTML page. For example, we would use the results in $id, $name, $enabled, and $alarm to generate an HTML table.</p>&#13;
<p class="secls"><b>Writing to the Daemon</b></p>&#13;
<p class="noindent"><a id="page121"/>To write to the ladd daemon and set alarm zone 3 into the alarm state, you could use the following code:</p>&#13;
<p class="imgl"><img src="../images/145-1.jpg" alt=""/></p>&#13;
<p class="indent">Note that you use the same pg_exec() function call as when reading information from the daemon; the difference is that the SQL command is UPDATE rather than SELECT. The SQL command in the preceding code snippet specifies to update the alarm column in the Zone table to the value $value, but only in the case where the id column matches $id.</p>&#13;
<p class="indent">In the preceding code snippet we’ve set the $value and $id variables to arbitrary values, but typically the $id and $value variables would be extracted from an HTML form.</p>&#13;
<p class="indent">The interaction between the web UI and the ladd daemon is straightforward enough. The web UI can read information from the ladd daemon and it can write information to the ladd daemon. The web UI interacts with the other daemons in the same way, so there is nothing new to learn about those interactions. (The interaction is straightforward because we are using an established protocol, PostgreSQL, and the function bindings to this protocol are readily available to PHP programs.)</p>&#13;
<p class="secs"><a id="chapter8.21"/><a href="toc.html#chapter8.21"><i><b>Alarm Status Page</b></i></a></p>&#13;
<p class="noindent">Figure 8-9 shows Laddie’s alarm status page. This page allows you to view the status of each alarm zone, clear alarm conditions, and set an alarm condition (for testing purposes).</p>&#13;
<p class="imgc"><img src="../images/145-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-9: Laddie status page</i></p>&#13;
<p class="indent"><a id="page122"/>An alarm condition can be shown either as a gray horizontal bar or with the label <i>Alarm</i> under the <i>Status</i> column. If you were to actually use this interface, you would probably find that the horizontal bar is much easier to read than the label because it offers a quick visual cue. When designing your web interface, think about how you might augment your interface with similar visual cues to convey information quickly.</p>&#13;
<p class="indent">Unlike traditional web pages, which require a user to refresh the page to update status, this status page automatically updates when an alarm condition changes. To observe this automatic update behavior, start two browsers and point them to the alarm status page. In one browser, modify the alarm condition by clicking the Clear and Set buttons. If JavaScript is enabled in your two browsers, you should see a page update on both browsers.</p>&#13;
<p class="indent">You can find the PHP code that generates this web page on this book’s companion CD in the file /opt/laddie/htdocs/web/cgi-bin/status.php.</p>&#13;
<p class="secs"><a id="chapter8.22"/><a href="toc.html#chapter8.22"><i><b>Alarm Setup Page</b></i></a></p>&#13;
<p class="noindent">The alarm setup page, shown in Figure 8-10, allows you to configure the names of the alarm zones. When designing this page, we considered two UI design approaches: an Update button for each zone and a single Update button for all zones. We chose the single button because it reduces the navigation required to configure all the zones; you simply modify the parameters of several zones and click Update.</p>&#13;
<p class="imgc"><img src="../images/146-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-10: Laddie alarm setup page</i></p>&#13;
<p class="indent">This web page allows the user to enter the names of each alarm zone. We’ll now describe how the web page works and in particular how to work with the tabular data shown there. On the browser side, the web page includes an HTML form, which is a mechanism for accepting input from a user and sending it to the webserver when the user presses a Submit button. If you take a look at the web page’s HTML source, you will see the following line:</p>&#13;
<p class="ex">&lt;td&gt; &lt;input type=text name=Name_1 value="Garage Door" /&gt; &lt;/td&gt;</p>&#13;
<p class="indent"><a id="page123"/>The input tag tells the browser to display a field for textual input. The name tag tells the browser how to name the field, and the value tag tells the browser how to populate the initial value for the field. When the user hits the Submit button, the names and values of all form fields are sent to the server. When the server receives this request, our PHP code will extract the zone names from the request and update the Laddie daemon.</p>&#13;
<p class="indent">PHP provides a simple mechanism to extract the field values. For example, to extract the value for the field with name <i>Name_1,</i> you would use the following PHP code:</p>&#13;
<p class="ex">$name = $_REQUEST["Name_1"];</p>&#13;
<p class="indent">The _REQUEST variable is a global variable that is populated by the PHP interpreter, while the <i>Name_1</i> string corresponds to the name of the field in the HMTL form. Once this statement is executed on the server, the $name variable will contain the text that the user entered in the browser.</p>&#13;
<p class="indent">For tabular forms we need to be careful about field naming because the HTML specification requires that all fields in a form must have a unique name. One common approach to naming such form fields in HTML is to append a row number to the column name. For example, we append the row number <i>1</i> to <i>Name</i> (using underscore as a separation character) to get <i>Name_1</i> for the Name column for Zone 1.</p>&#13;
<p class="indent">The PHP code to generate this web page can be found on this book’s companion CD in the file /opt/laddie/htdocs/web/cgi-bin/setup_alarm.php. Take a look at the function displayZoneForm. The PHP code that handles the web form updates is in the same file.</p>&#13;
<p class="secs"><a id="chapter8.23"/><a href="toc.html#chapter8.23"><i><b>Page Layout and Menu System</b></i></a></p>&#13;
<p class="noindent">In this section, we’ll describe Laddie’s web page layout and menu system. This simple scheme is handled by two PHP files. The first file, layout.php, defines Laddie’s two-level menu system as a two-dimensional array (see the global variable $menu_system on this book’s companion CD in /opt/laddie/ htdocs/web/cgi-bin/layout.php) and it defines the function display_page(). This function refreshes the page whenever the user navigates the menu. The second file, alarmstyle.css, controls color, fonts, and indentation (see /opt/laddie/htdocs/web/alarmstyle.css on the CD). Figure 8-11 shows an example web page; the PHP code that generated this web page follows.</p>&#13;
<p class="imgc"><img src="../images/147-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-11: Laddie’s “Hello, world!” example</i></p>&#13;
<p class="imgl"><a id="page124"/><img src="../images/148-1.jpg" alt=""/></p>&#13;
<p class="indent">The first two parameters in the call to display_page() are indices into the menu structure (defined by the global variable $menu_system in layout.php). The first parameter, "Setup" in this example, is the top-level index, while the second parameter is the second-level index. The third parameter is an HTML-formatted string, which is displayed in the main window. In this example, the main window consists of the heading Hello, world! and two lines. It is the main window that is different for each web page, and typically this content is generated dynamically, depending on the state of the system.</p>&#13;
<p class="indent">In summary, the presentation logic for page layout is encapsulated by the function display_page(). For another example of how to use display_page(), see /opt/laddie/htdocs/web/cgi-bin/help_contact_us.php on the CD.</p>&#13;
<p class="secs"><a id="chapter8.24"/><a href="toc.html#chapter8.24"><i><b>Webserver Independence</b></i></a></p>&#13;
<p class="noindent">PHP works with many different webservers, each having a slightly different way of interacting with the PHP interpreter. The API with which PHP interacts with the webserver is called the Server API. The Server API used by PHP is determined when compiling PHP, so as a developer you probably know this before writing the PHP scripts. But what if you decided to use another webserver? If you didn’t plan ahead, you would have to modify a lot of code to get it to work with the new webserver.</p>&#13;
<p class="indent">As an aside, PHP provides the function php_sapi_name() to programmati-cally determine which API is currently in use. This function returns one of many possible strings, three of which are <i>apache, cgi,</i> and <i>cgi-fcgi,</i> corresponding to Apache, CGI, and FastCGI. There’s not too much documentation on the Server API, but try searching for it on Google.</p>&#13;
<p class="indent">Early in the design phase, we decided to write our PHP scripts so that they would work with these three Server APIs, because the webservers that we investigated supported at least one of them. This would mean that our PHP scripts would work without modification under any webserver that supported one of these APIs. This server-independent approach offers two advantages: It avoids locking you in with a particular webserver (should a better one become available) and it allows you to develop scripts using a different webserver than the one deployed in your appliance.</p>&#13;
<p class="indent">Script input parameters are defined by name-value strings. For example, an input parameter might have the name <i>disp_id</i> and a value of 51. The script’s input parameters are provided by the HTTP request that invokes the script; for example, the following request will set the input parameter <i>disp_id</i> for the script wait_for_status.php:</p>&#13;
<p class="ex"><a href="http://127.0.0.1/wait_for_status.php?disp_id=51">http://127.0.0.1/wait_for_status.php?disp_id=51</a></p>&#13;
<p class="indent"><a id="page125"/>The trick to supporting Apache, CGI, and FastCGI lies in handling the script’s input parameters the same way, regardless of which environment the script is running in. (There is no problem with the output because these three Server APIs handle output the same way.)</p>&#13;
<p class="indent">For CGI scripts, the script’s input parameters are extracted from STDIN, whereas for Apache and FastCGI scripts, they are extracted from PHP global variables. Actually, the Apache and FastCGI cases are identical, so there are only two cases, CGI and Apache. We chose to abstract these two cases with a function called read_params(). The implementation of read_params() handles the details of both cases, but from the caller’s perspective, it provides a uniform way to extract the input parameters.</p>&#13;
<p class="indent">The PHP code fragment below shows how the function is used:</p>&#13;
<p class="imgl"><img src="../images/149-1.jpg" alt=""/></p>&#13;
<p class="indent">The read_params() function returns an array containing all the script’s input parameters. The calling script can then retrieve a particular parameter value using the parameter’s name (which is known at design time). Note that the function array_key_exists is a PHP built-in function that determines whether or not a given index exists in a given array.</p>&#13;
<p class="indent">The implementation of the read_params() function can be found in the file /opt/laddie/htdocs/web/cgi-bin/php_params.php on the CD. You’ll find another example of its use in /opt/laddie/htdocs/web/cgi-bin/ setup_snmp.php.</p>&#13;
<p class="secs"><a id="chapter8.25"/><a href="toc.html#chapter8.25"><i><b>Asynchronous Updates Using Ajax</b></i></a></p>&#13;
<p class="noindent">Consider the status web page shown in Figure 8-9. How should the web page react to changes in the state of an alarm?</p>&#13;
<p class="indent">Preferably, the web page should be updated automatically, rather than requiring the user to repeatedly click the browser’s Refresh button. One approach is to poll the server at a fixed frequency, for example, using the Refresh HTML meta tag as follows:</p>&#13;
<p class="ex">&lt;META HTTP-EQUIV="Refresh" CONTENT="5;URL=refreshed-page.html"&gt;</p>&#13;
<p class="indent"><a id="page126"/>Another approach is to use Ajax so that the web page updates only when there is a state change on the server. The disadvantage with Ajax is that it requires JavaScript to be enabled in the web browser; if the user disables JavaScript, the update mechanism breaks. On the other hand, when Ajax is used, the web page updates quickly in response to state changes on the server.</p>&#13;
<p class="indent">In the section “Improving Responsiveness with Ajax” on page 117, we described how a typical Ajax exchange works. However, note that this typical exchange is initiated by the client, rather than the server. We need a way to modify Ajax so that the browser responds to state changes on the server.</p>&#13;
<p class="indent">It turns out that we can modify the Ajax exchange so that the system behaves as if the webserver initiates the exchange. The trick is twofold. First, replace the onmouseover event with the onload event, so that the XMLHttpRequest is sent as soon as the web page is loaded. Second, write the webserver script so that it blocks while waiting for an event. By implementing this modified Ajax exchange, the web page will update whenever the particular event occurs on the server. The experienced Ajax programmer will note that there is another mechanism that achieves a similar result, notably the <i>HTTP Streaming pattern</i> documented at <a href="http://www.ajaxpatterns.org/">http://www.ajaxpatterns.org</a> (and in the associated book, <i>Ajax Design Patterns</i>, by Michael Mahemoff, O’Reilly, 2006). Both our approach and the HTTP Streaming pattern have the disadvantage of using a long-lived TCP connection, which may be a problem for webservers that allow only a finite number of concurrent connections. However, for our approach we can control how long the request waits for a server event, thereby limiting the number of concurrent connections.</p>&#13;
<p class="indent">Before we describe the details of this modified Ajax exchange, let’s review the big picture. Figure 8-12 shows the sequence for a user requesting a new web page, with the first full page update and subsequent partial page updates. In terms of timing, events <img src="../images/1a.jpg" alt=""/> through <img src="../images/10a.jpg" alt=""/> occur in quick succession after the user requests the particular web page. At this point, the web page is loaded with the latest alarm state. When some alarm state changes at event <img src="../images/11a.jpg" alt=""/>, it triggers events <img src="../images/12a.jpg" alt=""/> through <img src="../images/19a.jpg" alt=""/> in quick succession, at which point the web page is refreshed with the new alarm state. This latter sequence repeats until the user navigates away from the web page.</p>&#13;
<p class="secls"><b>Browser Sends First HTTP Request</b></p>&#13;
<p class="noindent">The sequence from events <img src="../images/1a.jpg" alt=""/> through <img src="../images/7a.jpg" alt=""/> is the standard HTML request response exchange. In step <img src="../images/1a.jpg" alt=""/>, the user requests a web page, the server responds by sending the web page and, in step <img src="../images/7a.jpg" alt=""/>, the browser displays the page. These steps are performed for all web requests regardless of whether the web page includes JavaScript. The remaining sequence from event <img src="../images/8a.jpg" alt=""/> through <img src="../images/19a.jpg" alt=""/> is more interesting, and it is this sequence that we’ll describe in more detail.</p>&#13;
<p class="imgc"><a id="page127"/><img src="../images/151-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 8-12: The Ajax sequence for an external event</i></p>&#13;
<p class="secls"><b>Browser Sends Second HTTP Request</b></p>&#13;
<p class="noindent"><a id="page128"/>On the client side, event <img src="../images/8a.jpg" alt=""/> is triggered as soon as the web page is loaded for the first time at event <img src="../images/7a.jpg" alt=""/>. In particular, the function GetCurrentStatus() is invoked. Take a look at the HTML source for the Zone Status web page by booting up this book’s companion CD and using a browser to visit 192.168.1.11.</p>&#13;
<p class="indent">The default IP address of the Laddie alarm appliance is 192.168.1.11 (and the default netmask is 255.255.0.0). When you insert this book’s CD into your computer and reboot it, you will then be able to connect to the web UI by typing the URL <a href="http://192.168.1.11/">http://192.168.1.11</a> in any web browser on another computer. If the default IP address conflicts with an existing node on your network, you can change the IP address for Laddie with the following steps. Quit the framebuffer interface (press Q for quit), then at the shell prompt, enter <b>root</b> for the user and press <small>ENTER</small> for the password (there is no password). Then enter <b>lynx</b> at the command prompt. From lynx you can navigate to the Network Setup page and modify the IP address of the network interfaces. Once you have changed the IP address with lynx, you can re-type the URL (with your new IP address) in a browser on another computer.</p>&#13;
<p class="indent">If you view the source for this web page, you will see the following line:</p>&#13;
<p class="ex">&lt;body onload="GetCurrentStatus()"&gt;</p>&#13;
<p class="indent">The GetCurrentStatus() function then makes an XMLHttpRequest with the URL wait_for_status.php (at event  <img src="../images/9a.jpg" alt=""/>). You’ll see the following code in the file /opt/laddie/web/cgi-bin/status.php on this book’s companion CD:</p>&#13;
<p class="imgl"><img src="../images/152-1.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page129"/>This code snippet instructs the browser to send a HTTP GET request with the URL wait_for_status.php. It also instructs the browser to invoke the callback function GotStatus() when a response is received from the server.</p>&#13;
<p class="secls"><b>Server Blocks Waiting for Alarm State Change</b></p>&#13;
<p class="noindent">On the server side, the script wait_for_status.php is invoked. This script does a blocking read on port 4444 at event <img src="../images/10a.jpg" alt=""/>. Whenever there is a change in alarm state in the ladd daemon at event <img src="../images/11a.jpg" alt=""/>, the logmuxd daemon writes a message to port 4444 at event <img src="../images/13a.jpg" alt=""/>. The contents of what is written to the port are unimportant; what is important is that the message unblocks the PHP thread at event <img src="../images/14a.jpg" alt=""/>.</p>&#13;
<p class="indent">Notice in the code above that curr_id is sent with the URL. This variable prevents the browser from losing log events when the events come too quickly. This variable is passed like a token between the server and the browser, and it increases in lock-step with the number of log events. If the curr_id value from the browser does not match the number of log events on the server, the PHP thread skips blocking on port 4444. This way, if there are new log events during the time interval that the PHP thread is not blocking on port 4444, the PHP thread will continue.</p>&#13;
<p class="secls"><b>Server Sends Alarm State as XML</b></p>&#13;
<p class="noindent">Once the blocking read returns, the PHP script reads the alarm status from the ladd alarm daemon (at event <img src="../images/15a.jpg" alt=""/>), and combines the data into an XML document (at event <img src="../images/16a.jpg" alt=""/>). The webserver then passes this XML document to the browser (at event <img src="../images/17a.jpg" alt=""/>). An example XML document looks like this:</p>&#13;
<p class="imgl"><img src="../images/153-1.jpg" alt=""/></p>&#13;
<p class="secls"><b>Browser Updates Portion of Web Page</b></p>&#13;
<p class="noindent">Back on the client side, the browser receives the XML document, and generates an HTML fragment from it; it uses this fragment to update the web page (event <img src="../images/18a.jpg" alt=""/>). The function GotStatus() in status.php has the following code.</p>&#13;
<p class="imgl"><a id="page130"/><img src="../images/154-1.jpg" alt=""/></p>&#13;
<p class="indent">The first line extracts the zone data from the XML response, the second line generates an HTML fragment specifically for the Laddie status page, and the last line inserts the HTML fragment into the displayed page.</p>&#13;
<p class="secls"><b>Browser Repeats by Sending Another HTTP Request</b></p>&#13;
<p class="noindent">The browser then invokes another XMLHttpRequest and the process repeats (at event <img src="../images/19a.jpg" alt=""/>). After a small delay, the GotStatus() function invokes GetCurrentStatus() with the following line:</p>&#13;
<p class="ex">setTimeout("GetCurrentStatus()", 2000);</p>&#13;
<p class="indent">You can see how this behavior works by opening two web browsers to the status page at <a href="http://192.168.1.11/">http://192.168.1.11</a>. If you change the state of an alarm zone in one of the browsers, you should see this state change on the other web browser, as well.</p>&#13;
<p class="indent">To summarize, we have shown a technique for using Ajax to update web pages where the update is triggered by events on the server rather than by events on the client.</p>&#13;
<p class="secls"><b>Graceful Degradation Without JavaScript</b></p>&#13;
<p class="noindent">When designing a web-based appliance, you must decide which web browsers you will support. Do you support non-graphical browsers like Lynx, or do you only support fully featured browsers? By reducing the level of required browser functionality, you can support a wide variety of browsers, but it will be at the expense of an increased effort in development. At the other extreme, you could dictate that a specific browser be used, with the advantage of using proprietary features, but with the risk of some customers disliking your browser selection. Customer input would be invaluable in helping you to make this decision.</p>&#13;
<p class="indent">We chose to support a wide variety of browsers, then sought to reduce the developmental effort by avoiding browser-specific code. That is, we avoided code that didn’t work the same way on all major browsers.</p>&#13;
<p class="indent">Of particular concern was the ability to support browsers without JavaScript. One of the difficulties with JavaScript is that it can be disabled by the user, and even worse, the user may not know that it is disabled.</p>&#13;
<p class="indent">One approach for supporting browsers with and without JavaScript is to structure the website as two “universes”—one universe in which JavaScript is used and another in which it isn’t. The home page is written to detect whether JavaScript is enabled on the browser and to then redirect the browser to the appropriate universe. Unfortunately, this solution does not work if the user disables JavaScript and then reloads a particular page. The work-around is for the user to turn on JavaScript and then revisit the home page.</p>&#13;
<p class="indent"><a id="page131"/>We took another approach, one which allows the user to enable or disable JavaScript and then simply reload the particular page. This means that each web page must support a JavaScript version and a non-JavaScript version. In the past, this problem might have been tricky to solve because browsers that didn’t support JavaScript were confused by JavaScript code. But this problem is easily solved today, because the majority of browsers (even those like Lynx that don’t support JavaScript) understand the HTML &lt;SCRIPT&gt; tag. When a modern browser has JavaScript disabled, it ignores all HTML code between the pair of tags &lt;SCRIPT&gt; and &lt;/SCRIPT&gt;.</p>&#13;
<p class="secls"><b>Hiding JavaScript</b></p>&#13;
<p class="noindent">The following pattern for hiding JavaScript content from browsers is known to work for Internet Explorer (version 5.0 and later), Netscape Navigator (version 4.72 and later), Firefox (version 1.0 and later), Safari (version 1.0 and later), Opera (version 5.0 and later), and Lynx (version 2.8.2 and later).</p>&#13;
<p class="imgl"><img src="../images/155-1.jpg" alt=""/></p>&#13;
<p class="indent">The HTML comments &lt;!-- and --&gt; are included as a fail-safe mechanism for those old browsers that don’t understand the &lt;SCRIPT&gt; tags. Similarly, you can use &lt;NOSCRIPT&gt; and &lt;/NOSCRIPT&gt; tags to provide alternate content when JavaScript is not enabled.</p>&#13;
<p class="indent">Using these patterns, each web page can support both JavaScript and non-JavaScript versions, and consequently, the user can change the browser’s JavaScript setting and reload the page. Because the user doesn’t have to find and reload some site-wide redirection page, the user’s experience is greatly simplified.</p>&#13;
<p class="secl"><a id="chapter8.26"/><a href="toc.html#chapter8.26"><b>Improving Our Design</b></a></p>&#13;
<p class="noindent">Having implemented the web UI, we are in a better position to review and improve our design. What are some areas that could use improvement?</p>&#13;
<p class="indent">One problem with the current design is that the logic for configuring network interfaces is contained in setup_network.php, and unfortunately, this logic is not available to other UIs, like the command line interface (CLI). When we first implemented the network setup page, we did not foresee how complex this configuration logic would be, and so we decided that all UIs would duplicate this “simple” logic. In hindsight, we feel that the design would be improved by subsuming the network configuration logic into a single manager, notably the networkd daemon. That way, the CLI user interface could provide the same functionality as the network setup web page, without duplicating much of the logic in setup_network.php.</p>&#13;
<p class="indent"><a id="page132"/>We could improve the web UI’s usability by clarifying the relationship between the second-level and top-level menus. This might be done using different colors for the top-level and second-level menus, as shown in Figure 8-2. Note in this figure that it is easy to see that the second-level item <i>Components</i> falls under the first-level menu <i>Tomahawk</i>.</p>&#13;
<p class="indent">Another improvement would be to add error-checking functionality on the client side. This improvement would be achieved by adding JavaScript functions to check the validity of form fields, resulting in a more responsive UI.</p>&#13;
<p class="indent">We could enhance functionality by adding a web page that would provide diagnostics functions for network connectivity and hardware health, such as temperature and fan speed. This functionality would allow management software to remotely monitor the appliance for degrading performance.</p>&#13;
<p class="secl"><a id="chapter8.27"/><a href="toc.html#chapter8.27"><b>Resources</b></a></p>&#13;
<p class="noindent">The following resources will be useful for further study of web page design, Ajax, debugging, and testing.</p>&#13;
<p class="bl"><b>UI design</b> The book <i>About Face 2.0: The Essentials of User Interaction Design</i> by Alan Cooper and Robert Reimann (Wiley, 2003) is a good book about UI design.</p>&#13;
<p class="bl"><b>JavaScript</b> A good reference book on JavaScript is the <i>JavaScript Bible, 5th Edition</i> by Danny Goodman and Michael Morrison (Wiley, 2004).</p>&#13;
<p class="bl"><b>Ajax</b> The Wikipedia web page on Ajax programming is a starting point for learning about the technique and includes the history of Ajax. See <a href="http://en.wikipedia.org/wiki/Ajax_(programming">http://en.wikipedia.org/wiki/Ajax_(programming</a>).</p>&#13;
<p class="bl"><b>HTML validation</b> The World Wide Web Consortium (W3C) provides a free HTML validation service at <a href="http://validator.w3.org/">http://validator.w3.org</a>. A CSS validation service is also available.</p>&#13;
<p class="bl"><b>Web browsers</b> Older web browsers, useful for testing your web pages, are archived at <a href="http://browsers.evolt.org/">http://browsers.evolt.org</a>.</p>&#13;
<p class="bl"><b>Debuggers</b> The Zend Studio debugger allows you to debug PHP code using Microsoft’s Internet Explorer and the Apache webserver. Using this browser, you can step through PHP code that is executing under Apache. It is a commercial software package, available at <a href="http://www.zend.com/">http://www.zend.com</a>.</p>&#13;
<p class="secl"><a id="chapter8.28"/><a href="toc.html#chapter8.28"><b>Summary</b></a></p>&#13;
<p class="noindent"><a id="page133"/>In this chapter, we have discussed the development of web UIs for Linux-based appliances, in particular, the web UI for Laddie. It has not been our goal to discuss all of web technology—you will find entire books on that subject.</p>&#13;
<p class="indent">This chapter highlighted the pertinent features of Laddie’s web UI:</p>&#13;
<ul>&#13;
<li>The web UI degrades gracefully for browsers that don’t support JavaScript so that the web UI functionality is accessible to a wide variety of browsers.</li>&#13;
<li>The alarm status page updates automatically whenever there is a change in the alarm state on the appliance:&#13;
<ul>&#13;
<li>When an alarm is triggered, each browser viewing the status web page is refreshed automatically.</li>&#13;
<li>When any browser is used to clear an alarm, the change is reflected on all other browsers.</li>&#13;
</ul></li>&#13;
</ul>&#13;
<p class="indent1">After implementing the web UI, we looked back at our design and suggested some future improvements. In particular, we suggested that the logic for configuring network interfaces should be moved from PHP into the network daemon, networkd. This restructuring would have the advantage that other UIs, for example the CLI, could configure network interfaces without duplicating the complex logic in PHP. Other improvements include restructuring the menu system and adding JavaScript error-checking functions.<a id="page134"/></p>&#13;
</div>&#13;
</body></html>