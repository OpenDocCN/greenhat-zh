- en: 'Chapter 6. Case Study: Virtual Null Modem'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is the first of several case studies that’ll guide you through
    a real-world device driver. The purpose of these case studies is to expose you
    to genuine driver code—warts and all—and to consolidate the information presented
    in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll go through `nmdm(4)`, the virtual null modem terminal
    driver. This driver creates two `tty(4)` devices that are connected by a virtual
    null modem cable. In other words, the output of one `tty(4)` device is the input
    for the other `tty(4)` device, and vice versa. I chose to profile `nmdm(4)` because
    it uses event handlers, callouts, and taskqueues, all of which were described,
    but not demonstrated, in [Chapter 5](ch05.html "Chapter 5. Delaying Execution").
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before I can walk you through `nmdm(4)`, you’ll need to grok the following
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `tty_alloc_mutex` function creates a TTY device. The `tsw` argument expects
    a pointer to a TTY device switch table, which is like a character device switch
    table, but for TTY devices. The `softc` argument is the software context (or instance
    variables) for the TTY device. The `mtx` argument specifies the mutex that’ll
    protect the TTY device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At some point in the near future, the `tty_alloc_mutex` function is supposed
    to be deprecated and removed.
  prefs: []
  type: TYPE_NORMAL
- en: The `tty_makedev` function creates a TTY device node under */dev*. The `tp`
    argument expects a pointer to a TTY device (for example, the return value from
    `tty_alloc_mutex`). The cred argument is the credentials for the device node.
    If `cred` is `NULL`, `UID_ROOT` and `GID_WHEEL` are used. The `fmt` argument specifies
    the name for the device node.
  prefs: []
  type: TYPE_NORMAL
- en: The `tty_softc` function returns the software context of the TTY device `tp`.
  prefs: []
  type: TYPE_NORMAL
- en: Code Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Example 6-1](ch06s02.html#nmdm.c "Example 6-1. nmdm.c") provides a terse,
    source-level overview of `nmdm(4)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1. nmdm.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 6-1](ch06s02.html#nmdm.c "Example 6-1. nmdm.c") is provided as a convenience;
    as I go through the code for `nmdm(4)` you can refer to it to see how `nmdm(4)`’s
    functions and structures are laid out.'
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier to understand, I’ll detail the functions and structures
    in `nmdm(4)` in the order I would’ve written them (instead of in the order they
    appear). To that end, we’ll begin with the module event handler.
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_modevent Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nmdm_modevent` function is the module event handler for `nmdm(4)`. Here
    is its function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On module load, this function ![](httpatomoreillycomsourcenostarchimages1137499.png)
    registers the function ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `nmdm_clone` with the event handler ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `dev_clone`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dev_clone` event handler was described in [Table 5-1](ch05s03.html#kernel_event_handlers-id1
    "Table 5-1. Kernel Event Handlers") in [Don’t Panic](ch05s02.html#donat_panic-id4
    "Don’t Panic").
  prefs: []
  type: TYPE_NORMAL
- en: Recall that functions registered with `dev_clone` are called when a solicited
    item under `/dev` does not exist. So when a `nmdm(4)` device node is accessed
    for the first time, `nmdm_clone` will be called to create the device node on the
    fly. Interestingly, this on-the-fly device creation lets one create an unlimited
    number of `nmdm(4)` device nodes.
  prefs: []
  type: TYPE_NORMAL
- en: On module unload, this function begins by ![](httpatomoreillycomsourcenostarchimages1137505.png)
    checking the value of `nmdm_count`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variable `nmdm_count` is declared near the beginning of [Example 6-1](ch06s02.html#nmdm.c
    "Example 6-1. nmdm.c") as an integer initialized to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '`nmdm_count` counts the number of active `nmdm(4)` device nodes. If it equals
    `0`, `nmdm_clone` is ![](httpatomoreillycomsourcenostarchimages1137509.png) removed
    from the event handler `dev_clone`; otherwise, `EBUSY` (which stands for *error:
    device busy*) is ![](httpatomoreillycomsourcenostarchimages1137507.png) returned.'
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_clone Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, `nmdm_clone` creates `nmdm(4)` device
    nodes on the fly. Note that all `nmdm(4)` device nodes are created in pairs named
    `nmdm%lu%c`, where `%lu` is the unit number and `%c` is either `A` or `B`. Here
    is the function definition for `nmdm_clone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) checks
    the value of `*dev` (which is a character device pointer). If `*dev` does not
    equal `NULL`, which implies that a device node already exists, `nmdm_clone` exits
    (because no nodes need to be created). Next, `nmdm_clone` ![](httpatomoreillycomsourcenostarchimages1137501.png)
    ensures that the first four characters in `name` are equal to `nmdm`; otherwise
    it exits (because the solicited device node is for another driver). Then the fifth
    character in `name`, which should be a unit number, is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    converted to an unsigned long and stored in `unit`. The following ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `if` statement checks that the conversion was a success. Afterward, `nmdm_clone`
    ![](httpatomoreillycomsourcenostarchimages1137507.png) ensures that following
    the unit number (in `name`) is the letter `A` or `B`; otherwise it exits. Now,
    having confirmed that the solicited device node is indeed for this driver, ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `nmdm_alloc` is called to actually create the device nodes. Finally, `*dev` is
    set to the solicited device node (either ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `nmdm%luA` or ![](httpatomoreillycomsourcenostarchimages1137513.png) `nmdm%luB`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that since `nmdm_clone` is registered with `dev_clone`, its function prototype
    must conform to the type expected by `dev_clone`, which is defined in `<sys/conf.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_alloc Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous section, `nmdm_alloc` actually creates `nmdm(4)`’s
    device nodes. Before I describe this function, an explanation of `nmdm_class`
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data structure `nmdm_class` is declared near the beginning of [Example 6-1](ch06s02.html#nmdm.c
    "Example 6-1. nmdm.c") as a TTY device switch table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The flag ![](httpatomoreillycomsourcenostarchimages1137499.png) `TF_NOPREFIX`
    means `don’t prefix tty to the device name`. The other definitions are the operations
    that `nmdm_class` supports. These operations will be described as we encounter
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with `nmdm_class`, let’s walk through `nmdm_alloc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function can be split into four parts. The first ![](httpatomoreillycomsourcenostarchimages1137499.png)
    increments `nmdm_count` by one via the `atomic_add_int` function. As its name
    implies, `atomic_add_int` is atomic. Consequently, we don’t need a lock to protect
    `nmdm_count` when we increment it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part ![](httpatomoreillycomsourcenostarchimages1137501.png) allocates
    memory for a new `nmdm_softc` structure. After that, its mutex is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    initialized. Besides a mutex, `nmdm_softc` contains two additional member variables:
    `ns_partA` and `ns_partB`. These variables are `nmdm_part` structures and will
    maintain data relating to `nmdm%luA` or `nmdm%luB`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`st`ruct `nmdm_softc` is defined near the beginning of [Example 6-1](ch06s02.html#nmdm.c
    "Example 6-1. nmdm.c").'
  prefs: []
  type: TYPE_NORMAL
- en: The third part ![](httpatomoreillycomsourcenostarchimages1137505.png) ![](httpatomoreillycomsourcenostarchimages1137511.png)
    connects the member variables `ns_partA` and `ns_partB`, so that given `ns_partA`
    we can find `ns_partB`, and vice versa. The third part also initializes `ns_partA`’s
    and `ns_partB`’s ![](httpatomoreillycomsourcenostarchimages1137507.png) ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `task` and ![](httpatomoreillycomsourcenostarchimages1137509.png) ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `callout` structures.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the fourth part creates `nmdm(4)`’s device nodes (that is, `nmdm%luA`
    and `nmdm%luB`).
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_outwakeup Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nmdm_outwakeup` function is defined in `nmdm_class` as the `tsw_outwakeup`
    operation. It is executed when output from `nmdm%luA` or `nmdm%luB` is available.
    Here is its function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function ![](httpatomoreillycomsourcenostarchimages1137499.png) queues
    `ns_partA`’s or `ns_partB`’s ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `task` structure on ![](httpatomoreillycomsourcenostarchimages1137501.png) `taskqueue_swi`
    (that is to say, it defers processing the output from `nmdm%luA` and `nmdm%luB`).
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_task_tty Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nmdm_task_tty` function transfers data from `nmdm%luA` to `nmdm%luB`,
    and vice versa. This function is queued on `taskqueue_swi` by `nmdm_outwakeup`
    (for verification, see the third argument to `TASK_INIT` in `nmdm_alloc`). Here
    is its function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this function’s explanation, “our TTY” refers to the TTY device (that is,
    `nmdm%luA` or `nmdm%luB`) that queued this function on `taskqueue_swi`.
  prefs: []
  type: TYPE_NORMAL
- en: This function is composed of two parts. The first changes the connection state
    between the two TTYs to match the status of our TTY. If our TTY is ![](httpatomoreillycomsourcenostarchimages1137501.png)
    closed and the other TTY’s Data Carrier Detect (DCD) flag is ![](httpatomoreillycomsourcenostarchimages1137499.png)
    on, we ![](httpatomoreillycomsourcenostarchimages1137503.png) turn off that flag
    and ![](httpatomoreillycomsourcenostarchimages1137505.png) switch off their carrier
    signal. On the other hand, if our TTY has been ![](httpatomoreillycomsourcenostarchimages1137509.png)
    opened and the other TTY’s DCD flag is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    off, we turn on that flag and switch on their carrier signal. In short, this part
    ensures that if our TTY is closed (that is, there is no data to transfer), the
    other TTY will not have a carrier signal, and if our TTY has been opened (that
    is, there is data to transfer), the other TTY will have a carrier signal. A carrier
    signal indicates a connection. In other words, loss of the carrier equates to
    termination of the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The second part transfers data from our TTY’s output queue to the other TTY’s
    input queue. This part first ![](httpatomoreillycomsourcenostarchimages1137511.png)
    polls the other TTY to determine whether it can accept data. Then one character
    is ![](httpatomoreillycomsourcenostarchimages1137513.png) removed from our TTY’s
    output queue and ![](httpatomoreillycomsourcenostarchimages1137515.png) placed
    in the other TTY’s input queue. These steps are repeated until the transfer is
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_inwakeup Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nmdm_inwakeup` function is defined in `nmdm_class` as the `tsw_inwakeup`
    operation. It is called when input for `nmdm%luA` or `nmdm%luB` can be received
    again. That is, when `nmdm%luA`’s or `nmdm%luB`’s input queue is full and then
    space becomes available, this function is executed. Here is its function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this function’s explanation, “our TTY” refers to the TTY device (that is,
    `nmdm%luA` or `nmdm%luB`) that executed this function.
  prefs: []
  type: TYPE_NORMAL
- en: This function ![](httpatomoreillycomsourcenostarchimages1137499.png) queues
    the other TTY’s ![](httpatomoreillycomsourcenostarchimages1137503.png) task structure
    on ![](httpatomoreillycomsourcenostarchimages1137501.png) `taskqueue_swi`. In
    other words, when input for our TTY can be received again, our TTY tells the other
    TTY to transfer data to it.
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_modem Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nmdm_modem` function is defined in `nmdm_class` as the `tsw_modem` operation.
    This function sets or gets the modem control line state. Here is its function
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this function’s explanation, “our TTY” refers to the TTY device (that is,
    `nmdm%luA` or `nmdm%luB`) that executed this function.
  prefs: []
  type: TYPE_NORMAL
- en: This function sets the modem control lines when the `sigon` (signal on) or the
    `sigoff` (signal off) argument is ![](httpatomoreillycomsourcenostarchimages1137499.png)
    nonzero. If `sigon` ![](httpatomoreillycomsourcenostarchimages1137501.png) contains
    the Data Terminal Ready (DTR) flag, the other TTY’s DCD flag is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    turned on. If `sigoff` ![](httpatomoreillycomsourcenostarchimages1137505.png)
    contains the DTR flag, the other TTY’s DCD flag is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    turned off. The other TTY’s carrier signal is ![](httpatomoreillycomsourcenostarchimages1137509.png)
    turned on or off alongside its DCD flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the preceding discussion didn’t make any sense to you, this should help:
    A null modem connects the DTR output of each serial port to the DCD input of the
    other. The DTR output is kept off until a program accesses the serial port and
    turns it on; the other serial port will sense this as its DCD input turning on.
    Thus, the DCD input is used to detect the readiness of the other side. This is
    why when our TTY’s DTR is sigon’d or `sigoff`’d, the other TTY’s DCD flag and
    carrier signal are also turned on or off.'
  prefs: []
  type: TYPE_NORMAL
- en: This function gets the modem control line state when sigon and sigoff are 0\.
    If our TTY’s DCD flag is ![](httpatomoreillycomsourcenostarchimages1137511.png)
    on, `SER_DCD` is ![](httpatomoreillycomsourcenostarchimages1137513.png) returned.
    If the other TTY’s DCD flag is ![](httpatomoreillycomsourcenostarchimages1137515.png)
    on, indicating that our TTY’s DTR flag is on, `SER_DTR` is ![](httpatomoreillycomsourcenostarchimages1137517.png)
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_param Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nmdm_param` function is defined in `nmdm_class` as the `tsw_param` operation.
    This function sets up `nmdm_task_tty` to be executed at regular intervals. That
    is, it sets `nmdm%luA` to periodically transfer data to `nmdm%luB`, and vice versa.
    This periodic data transfer requires flow control to prevent one side from overrunning
    the other with data. Flow control works by halting the sender when the receiver
    can’t keep up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function definition for `nmdm_param`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function can be split into three parts. The first ![](httpatomoreillycomsourcenostarchimages1137499.png)
    determines whether flow control is disabled. If it is, `ns_partA`’s and `ns_partB`’s
    `np_rate` variable is zeroed and `nmdm_param` exits. The `np_rate` variable is
    the rate at which `nmdm_task_tty` will be executed. This rate can differ for `nmdm%luA`
    and `nmdm%luB`.
  prefs: []
  type: TYPE_NORMAL
- en: The second part calculates the ![](httpatomoreillycomsourcenostarchimages1137507.png)
    value for `np_rate`. This calculation takes into consideration the ![](httpatomoreillycomsourcenostarchimages1137503.png)
    speed of `nmdm%luA` and `nmdm%luB` and the ![](httpatomoreillycomsourcenostarchimages1137501.png)
    number of bits per character. The second part also determines the ![](httpatomoreillycomsourcenostarchimages1137505.png)
    maximum number of characters to transfer per execution of `nmdm_task_tty`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the third part causes ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `nmdm_timeout` to execute one time after ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `rate` / `hz` seconds. The `nmdm_timeout` function queues `nmdm_task_tty` on `taskqueue_swi`.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third parts are executed twice, once for `nmdm%luA` and once
    for `nmdm%luB`.
  prefs: []
  type: TYPE_NORMAL
- en: nmdm_timeout Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As indicated in the previous section, the `nmdm_timeout` function queues `nmdm_task_tty`
    on `taskqueue_swi` at regular intervals. Here is its function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) checks
    the value of `np_rate`. If it equals 0, `nmdm_timeout` exits. Next, `ns_partA`’s
    or `ns_partB`’s `np_quota` variable is assigned the ![](httpatomoreillycomsourcenostarchimages1137501.png)
    maximum number of characters to transfer (if you return to [nmdm_task_tty Function](ch06s02.html#nmdm_underscore_task_underscore_tty_func
    "nmdm_task_tty Function") in [nmdm_outwakeup Function](ch06s02.html#nmdm_underscore_outwakeup_function
    "nmdm_outwakeup Function"), it should be obvious how `np_quota` is used). Once
    this is done, `nmdm_task_tty` is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    queued on ![](httpatomoreillycomsourcenostarchimages1137505.png) `taskqueue_swi`
    and ![](httpatomoreillycomsourcenostarchimages1137511.png) `nmdm_timeout` is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    rescheduled to execute after ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `np_rate` / `hz` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `nmdm_param` and `nmdm_timeout` functions are used to emulate the TTYs’
    baud rate. Without these two functions, data transfers would be slower.
  prefs: []
  type: TYPE_NORMAL
- en: bits_per_char Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bits_per_char` function returns the number of bits used to represent a
    single character for a given TTY. This function is used only in `nmdm_param`.
    Here is its function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the ![](httpatomoreillycomsourcenostarchimages1137509.png) return
    value takes into account the ![](httpatomoreillycomsourcenostarchimages1137501.png)
    variable character size, ![](httpatomoreillycomsourcenostarchimages1137499.png)
    start bit, ![](httpatomoreillycomsourcenostarchimages1137503.png) stop bit, ![](httpatomoreillycomsourcenostarchimages1137505.png)
    parity enabled bit, and ![](httpatomoreillycomsourcenostarchimages1137507.png)
    second stop bit.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve walked through `nmdm(4)`, let’s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Excellent. We’re able to connect to `nmdm0A`, which is running `getty(8)`, from
    `nmdm0B`.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described the entire code base of `nmdm(4)`, the virtual null modem
    terminal driver. If you noticed the complete lack of locking in this driver and
    are alarmed, don’t be. The `ns_mtx` mutex, which gets initialized in `nmdm_alloc`,
    is implicitly acquired by the TTY subsystem before `nmdm_outwakeup`, `nmdm_inwakeup`,
    `nmdm_modem`, and `nmdm_param` are called. In short, every operation between `nmdm%luA`
    and `nmdm%luB` is serialized.
  prefs: []
  type: TYPE_NORMAL
