<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Applicative Functors"><div class="titlepage"><div><div><h1 class="title"><a id="applicative_functors"/>Chapter 11. Applicative Functors</h1></div></div></div><p>Haskell’s combination of purity, higher-order functions, parameterized algebraic data types, and type classes makes implementing polymorphism much easier than in other languages. We don’t need to think about types belonging to a big hierarchy. Instead, we consider what the types can act like and then connect them with the appropriate type classes. An <code class="literal">Int</code> can act like a lot of things—an equatable thing, an ordered thing, an enumerable thing, and so on.<a id="IDX-CHP-11-0001" class="indexterm"/></p><p>Type classes are open, which means that we can define our own data type, think about what it can act like, and connect it with the type classes that define its behaviors. We can also introduce a new type class and then make already existing types instances of it. Because of that, and because Haskell’s type system allows us to know a lot about a function just by its type declaration, we can define type classes that define very general and abstract behavior.</p><p>We’ve talked about type classes that define operations for seeing if two things are equal and comparing two things by some ordering. Those are very abstract and elegant behaviors, although we don’t think of them as very special, since we’ve been dealing with them for most of our lives. <a class="xref" href="ch07.html" title="Chapter 7. Making Our Own Types and Type Classes">Chapter 7</a> introduced functors, which are types whose values can be mapped over. That’s an example of a useful and yet still pretty abstract property that type classes can describe. In this chapter, we’ll take a closer look at functors, along with slightly stronger and more useful versions of functors called <span class="emphasis"><em>applicative functors</em></span>.<a id="IDX-CHP-11-0002" class="indexterm"/><a id="IDX-CHP-11-0003" class="indexterm"/><a id="IDX-CHP-11-0004" class="indexterm"/><a id="IDX-CHP-11-0005" class="indexterm"/></p><div class="sect1" title="Functors Redux"><div class="titlepage"><div><div><h1 class="title"><a id="functors_redux"/>Functors Redux</h1></div></div></div><p>As you learned in <a class="xref" href="ch07.html" title="Chapter 7. Making Our Own Types and Type Classes">Chapter 7</a>, functors are things that can be mapped over, like lists, <code class="literal">Maybe</code>s, and trees. In Haskell, they’re described by the type class <code class="literal">Functor</code>, which has only one type class method: <code class="literal">fmap</code>. <code class="literal">fmap</code> has a type of <code class="literal">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, which says, “Give me a function that takes an <code class="literal">a</code> and returns a <code class="literal">b</code> and a box with an <code class="literal">a</code> (or several of them) inside it, and I’ll give you a box with a <code class="literal">b</code> (or several of them) inside it.” It applies the function to the element inside the box.</p><p>We can also look at functor values as values with an added <span class="emphasis"><em>context</em></span>. For instance, <code class="literal">Maybe</code> values have the extra context that they might have failed. With lists, the context is that the value can actually be several values at once or none. <code class="literal">fmap</code> applies a function to the value while preserving its context.</p><p>If we want to make a type constructor an instance of <code class="literal">Functor</code>, it must have a kind of <code class="literal">* -&gt; *</code>, which means that it takes exactly one concrete type as a type parameter. For example, <code class="literal">Maybe</code> can be made an instance because it takes one type parameter to produce a concrete type, like <code class="literal">Maybe Int</code> or <code class="literal">Maybe String</code>. If a type constructor takes two parameters, like <code class="literal">Either</code>, we need to partially apply the type constructor until it takes only one type parameter. So we can’t write <code class="literal">instance Functor Either where</code>, but we <span class="emphasis"><em>can</em></span> write <code class="literal">instance Functor (Either a) where</code>. Then if we imagine that <code class="literal">fmap</code> is only for <code class="literal">Either a</code>, it would have this type declaration:</p><a id="I_programlisting11_d1e19017"/><pre class="programlisting">fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c</pre><p>As you can see, the <code class="literal">Either a</code> part is fixed, because <code class="literal">Either a</code> takes only one type parameter.</p><div class="sect2" title="I/O Actions As Functors"><div class="titlepage"><div><div><h2 class="title"><a id="i_solidus_o_actions_as_functors"/>I/O Actions As Functors</h2></div></div></div><p>You’ve learned how a lot of types (well, type constructors really) are instances of <code class="literal">Functor</code>: <code class="literal">[]</code>, and <code class="literal">Maybe</code>, <code class="literal">Either a</code>, as well as a <code class="literal">Tree</code> type that we created in <a class="xref" href="ch07.html" title="Chapter 7. Making Our Own Types and Type Classes">Chapter 7</a>. You saw how you can map functions over them for great good. Now, let’s take a look at the <code class="literal">IO</code> instance.</p><p>If some value has a type of, say, <code class="literal">IO String</code>, that means it’s an I/O action that will go out into the real world and get some string for us, which it will then yield as a result. We can use <code class="literal">&lt;-</code> in <code class="literal">do</code> syntax to bind that result to a name. In <a class="xref" href="ch08.html" title="Chapter 8. Input and Output">Chapter 8</a>, we talked about how I/O actions are like boxes with little feet that go out and fetch some value from the outside world for us. We can inspect what they fetched, but after inspecting, we need to wrap the value back in <code class="literal">IO</code>. Considering this box with feet analogy, you can see how <code class="literal">IO</code> acts like a functor.<a id="IDX-CHP-11-0006" class="indexterm"/><a id="IDX-CHP-11-0007" class="indexterm"/><a id="IDX-CHP-11-0008" class="indexterm"/><a id="IDX-CHP-11-0009" class="indexterm"/></p><p>Let’s see how <code class="literal">IO</code> is an instance of <code class="literal">Functor</code>. When we <code class="literal">fmap</code> a function over an I/O action, we want to get back an I/O action that does the same thing but has our function applied over its result value. Here’s the code:</p><a id="I_programlisting11_d1e19100"/><pre class="programlisting">instance Functor IO where
    fmap f action = do
        result &lt;- action
        return (f result)</pre><p>The result of mapping something over an I/O action will be an I/O action, so right off the bat, we use the <code class="literal">do</code> syntax to glue two actions and make a new one. In the implementation for <code class="literal">fmap</code>, we make a new I/O action that first performs the original I/O action and calls its result <code class="literal">result</code>. Then we do <code class="literal">return (f result)</code>. Recall that <code class="literal">return</code> is a function that makes an I/O action that doesn’t do anything but only yields something as its result.</p><p>The action that a <code class="literal">do</code> block produces will always yield the result value of its last action. That’s why we use <code class="literal">return</code> to make an I/O action that doesn’t really do anything; it just yields <code class="literal">f result</code> as the result of the new I/O action. Check out this piece of code:</p><a id="I_programlisting11_d1e19130"/><pre class="programlisting">main = do line &lt;- getLine
          let line' = reverse line
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"</pre><p>The user is prompted for a line, which we give back, but reversed. Here’s how to rewrite this by using <code class="literal">fmap</code>:</p><a id="I_programlisting11_d1e19137"/><pre class="programlisting">main = do line &lt;- fmap reverse getLine
          putStrLn $ "You said " ++ line ++ " backwards!"
          putStrLn $ "Yes, you really said " ++ line ++ " backwards!"</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e19140"/><img src="httpatomoreillycomsourcenostarchimages802644.png.jpg" alt="image with no caption"/></div></div><p>Just as we can <code class="literal">fmap reverse</code> over <code class="literal">Just "blah"</code> to get <code class="literal">Just "halb"</code>, we can <code class="literal">fmap reverse</code> over <code class="literal">getLine</code>. <code class="literal">getLine</code> is an I/O action that has a type of <code class="literal">IO String</code>, and mapping <code class="literal">reverse</code> over it gives us an I/O action that will go out into the real world and get a line and then apply <code class="literal">reverse</code> to its result. In the same way that we can apply a function to something that’s inside a <code class="literal">Maybe</code> box, we can apply a function to what’s inside an <code class="literal">IO</code> box, but it must go out into the real world to get something. Then when we bind it to a name using <code class="literal">&lt;-</code>. The name will reflect the result that already has <code class="literal">reverse</code> applied to it.</p><p>The I/O action <code class="literal">fmap (++"!") getLine</code> behaves just like <code class="literal">getLine</code>, except that its result always has <code class="literal">"!"</code> appended to it!<a id="IDX-CHP-11-0010" class="indexterm"/><a id="IDX-CHP-11-0011" class="indexterm"/></p><p>If <code class="literal">fmap</code> were limited to <code class="literal">IO</code>, its type would be <code class="literal">fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b</code>. <code class="literal">fmap</code> takes a function and an I/O action and returns a new I/O action that’s like the old one, except that the function is applied to its contained result.</p><p>If you ever find yourself binding the result of an I/O action to a name, only to apply a function to that and call that something else, consider using <code class="literal">fmap</code>. If you want to apply multiple functions to some data inside a functor, you can declare your own function at the top level, make a lambda function, or, ideally, use function composition:</p><a id="I_programlisting11_d1e19229"/><pre class="programlisting">import Data.Char
import Data.List

main = do line &lt;- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line</pre><p>Here’s what happens if we run this with the input <code class="literal">hello there</code>:</p><a id="I_programlisting11_d1e19236"/><pre class="programlisting">$ ./fmapping_io
hello there
E-R-E-H-T- -O-L-L-E-H</pre><p>The <code class="literal">intersperse '-' . reverse . map toUpper</code> function takes a string, maps <code class="literal">toUpper</code> over it, applies <code class="literal">reverse</code> to that result, and then applies <code class="literal">intersperse '-'</code> to that result. It’s a prettier way of writing the following:</p><a id="I_programlisting11_d1e19252"/><pre class="programlisting">(\xs -&gt; intersperse '-' (reverse (map toUpper xs)))</pre></div><div class="sect2" title="Functions As Functors"><div class="titlepage"><div><div><h2 class="title"><a id="functions_as_functors"/>Functions As Functors</h2></div></div></div><p>Another instance of <code class="literal">Functor</code> that we’ve been dealing with all along is <code class="literal">(-&gt;) r</code>. But wait! What the heck does <code class="literal">(-&gt;) r</code> mean? The function type <code class="literal">r -&gt; a</code> can be rewritten as <code class="literal">(-&gt;) r a</code>, much like we can write <code class="literal">2 + 3</code> as <code class="literal">(+) 2 3</code>. When we look at it as <code class="literal">(-&gt;) r a</code>, we can see <code class="literal">(-&gt;)</code> in a slightly different light. It’s just a type constructor that takes two type parameters, like <code class="literal">Either</code>.</p><p>But remember that a type constructor must take exactly one type parameter so it can be made an instance of <code class="literal">Functor</code>. That’s why we can’t make <code class="literal">(-&gt;)</code> an instance of <code class="literal">Functor</code>; however, if we partially apply it to <code class="literal">(-&gt;) r</code>, it doesn’t pose any problems. If the syntax allowed for type constructors to be partially applied with sections (like we can partially apply <code class="literal">+</code> by doing <code class="literal">(2+)</code>, which is the same as <code class="literal">(+) 2</code>), we could write <code class="literal">(-&gt;) r</code> as <code class="literal">(r -&gt;)</code>.</p><p>How are functions functors? Let’s take a look at the implementation, which lies in <code class="literal">Control.Monad.Instances</code>:</p><a id="I_programlisting11_d1e19325"/><pre class="programlisting">instance Functor ((-&gt;) r) where
    fmap f g = (\x -&gt; f (g x))</pre><p>First, let’s think about <code class="literal">fmap</code>’s type:<a id="IDX-CHP-11-0012" class="indexterm"/><a id="IDX-CHP-11-0013" class="indexterm"/></p><a id="I_programlisting11_d1e19342"/><pre class="programlisting">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</pre><p>Next, let’s mentally replace each <code class="literal">f</code>, which is the role that our functor instance plays, with <code class="literal">(-&gt;) r</code>. This will let us see how <code class="literal">fmap</code> should behave for this particular instance. Here’s the result:</p><a id="I_programlisting11_d1e19355"/><pre class="programlisting">fmap :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)</pre><p>Now we can write the <code class="literal">(-&gt;) r a</code> and <code class="literal">(-&gt;) r b</code> types as infix <code class="literal">r -&gt; a</code> and <code class="literal">r -&gt; b</code>, as we normally do with functions:</p><a id="I_programlisting11_d1e19371"/><pre class="programlisting">fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</pre><p>Okay, mapping a function over a function must produce a function, just like mapping a function over a <code class="literal">Maybe</code> must produce a <code class="literal">Maybe</code>, and mapping a function over a list must produce a list. What does the preceding type tell us? We see that it takes a function from <code class="literal">a</code> to <code class="literal">b</code> and a function from <code class="literal">r</code> to <code class="literal">a</code> and returns a function from <code class="literal">r</code> to <code class="literal">b</code>. Does this remind you of anything? Yes, function composition! We pipe the output of <code class="literal">r -&gt; a</code> into the input of <code class="literal">a -&gt; b</code> to get a function <code class="literal">r -&gt; b</code>, which is exactly what function composition is all about. Here’s another way to write this instance:</p><a id="I_programlisting11_d1e19410"/><pre class="programlisting">instance Functor ((-&gt;) r) where
    fmap = (.)</pre><p>This makes it clear that using <code class="literal">fmap</code> over functions is just function composition. In a script, import <code class="literal">Control.Monad.Instances</code>, since that’s where the instance is defined, and then load the script and try playing with mapping over functions:</p><a id="I_programlisting11_d1e19420"/><pre class="programlisting">ghci&gt; :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a
ghci&gt; fmap (*3) (+100) 1
303
ghci&gt; (*3) `fmap` (+100) $ 1
303
ghci&gt; (*3) . (+100) $ 1
303
ghci&gt; fmap (show . (*3)) (+100) 1
"303"</pre><p>We can call <code class="literal">fmap</code> as an infix function so that the resemblance to <code class="literal">.</code> is clear. In the second input line, we’re mapping <code class="literal">(*3)</code> over <code class="literal">(+100)</code>, which results in a function that will take an input, apply <code class="literal">(+100)</code> to that, and then apply <code class="literal">(*3)</code> to that result. We then apply that function to <code class="literal">1</code>.</p><p>Just like all functors, functions can be thought of as values with contexts. When we have a function like <code class="literal">(+3)</code>, we can view the value as the eventual result of the function, and the context is that we need to apply the function to something to get to the result. Using <code class="literal">fmap (*3)</code> on <code class="literal">(+100)</code> will create another function that acts like <code class="literal">(+100)</code>, but before producing a result, <code class="literal">(*3)</code> will be applied to that result.<a id="IDX-CHP-11-0014" class="indexterm"/><a id="IDX-CHP-11-0015" class="indexterm"/></p><p>The fact that <code class="literal">fmap</code> is function composition when used on functions isn’t so terribly useful right now, but at least it’s very interesting. It also bends our minds a bit and lets us see how things that act more like computations than boxes (<code class="literal">IO</code> and <code class="literal">(-&gt;) r</code>) can be functors. The function being mapped over a computation results in the same sort of computation, but the result of that computation is modified with the function.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e19486"/><img src="httpatomoreillycomsourcenostarchimages802646.png.jpg" alt="image with no caption"/></div></div><p>Before we go on to the rules that <code class="literal">fmap</code> should follow, let’s think about the type of <code class="literal">fmap</code> once more:</p><a id="I_programlisting11_d1e19499"/><pre class="programlisting">fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</pre><p>The introduction of curried functions in <a class="xref" href="ch05.html" title="Chapter 5. Higher-Order Functions">Chapter 5</a> began by stating that all Haskell functions actually take one parameter. A function <code class="literal">a -&gt; b -&gt; c</code> takes just one parameter of type <code class="literal">a</code> and returns a function <code class="literal">b -&gt; c</code>, which takes one parameter and returns <code class="literal">c</code>. That’s why calling a function with too few parameters (partially applying it) gives us back a function that takes the number of parameters that we left out (if we’re thinking about functions as taking several parameters again). So <code class="literal">a -&gt; b -&gt; c</code> can be written as <code class="literal">a -&gt; (b -&gt; c)</code>, to make the currying more apparent.<a id="IDX-CHP-11-0016" class="indexterm"/></p><p>In the same vein, if we write <code class="literal">fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code>, we can think of <code class="literal">fmap</code> not as a function that takes one function and a functor value and returns a functor value, but as a function that takes a function and returns a new function that’s just like the old one, except that it takes a functor value as a parameter and returns a functor value as the result. It takes an <code class="literal">a -&gt; b</code> function and returns a function <code class="literal">f a -&gt; f b</code>. This is called <span class="emphasis"><em>lifting</em></span> a function. Let’s play around with that idea using GHCi’s <code class="literal">:t</code> command:<a id="IDX-CHP-11-0017" class="indexterm"/></p><a id="I_programlisting11_d1e19554"/><pre class="programlisting">ghci&gt; :t fmap (*2)
fmap (*2) :: (Num a, Functor f) =&gt; f a -&gt; f a
ghci&gt; :t fmap (replicate 3)
fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]</pre><p>The expression <code class="literal">fmap (*2)</code> is a function that takes a functor <code class="literal">f</code> over numbers and returns a functor over numbers. That functor can be a list, a <code class="literal">Maybe</code>, an <code class="literal">Either String</code>, or anything else. The expression <code class="literal">fmap (replicate 3)</code> will take a functor over any type and return a functor over a list of elements of that type. This is even more apparent if we partially apply, say, <code class="literal">fmap (++"!")</code> and then bind it to a name in GHCi.</p><p>You can think of <code class="literal">fmap</code> in two ways:<a id="IDX-CHP-11-0018" class="indexterm"/><a id="IDX-CHP-11-0019" class="indexterm"/><a id="IDX-CHP-11-0020" class="indexterm"/><a id="IDX-CHP-11-0021" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>As a function that takes a function and a functor value and then maps that function over the functor value</p></li><li class="listitem"><p>As a function that takes a function and lifts that function so it operates on functor values</p></li></ul></div><p>Both views are correct.</p><p>The type <code class="literal">fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]</code> means that the function will work on any functor. What it will do depends on the functor. If we use <code class="literal">fmap (replicate 3)</code> on a list, the list’s implementation for <code class="literal">fmap</code> will be chosen, which is just <code class="literal">map</code>. If we use it on <code class="literal">Maybe a</code>, it will apply <code class="literal">replicate 3</code> to the value inside the <code class="literal">Just</code>. If it’s <code class="literal">Nothing</code>, it stays <code class="literal">Nothing</code>. Here are some examples:</p><a id="I_programlisting11_d1e19637"/><pre class="programlisting">ghci&gt; fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
ghci&gt; fmap (replicate 3) (Just 4)
Just [4,4,4]
ghci&gt; fmap (replicate 3) (Right "blah")
Right ["blah","blah","blah"]
ghci&gt; fmap (replicate 3) Nothing
Nothing
ghci&gt; fmap (replicate 3) (Left "foo")
Left "foo"</pre></div></div></div>
<div class="sect1" title="Functor Laws"><div class="titlepage"><div><div><h1 class="title"><a id="functor_laws"/>Functor Laws</h1></div></div></div><p>All functors are expected to exhibit certain kinds of properties and behaviors. They should reliably behave as things that can be mapped over. Calling <code class="literal">fmap</code> on a functor should just map a function over the functor—nothing more. This behavior is described in the <span class="emphasis"><em>functor laws</em></span>. All instances of <code class="literal">Functor</code> should abide by these two laws. They aren’t enforced by Haskell automatically, so you need to test them yourself when you make a functor. All the <code class="literal">Functor</code> instances in the standard library obey these laws.<a id="IDX-CHP-11-0022" class="indexterm"/></p><div class="sect2" title="Law 1"><div class="titlepage"><div><div><h2 class="title"><a id="law_1"/>Law 1</h2></div></div></div><p>The first functor law states that if we map the <code class="literal">id</code> function over a functor value, the functor value that we get back should be the same as the original functor value. Written a bit more formally, it means that <code class="literal">fmap id = id</code>. So essentially, this says that if we do <code class="literal">fmap id</code> over a functor value, it should be the same as just applying <code class="literal">id</code> to the value. Remember that <code class="literal">id</code> is the identity function, which just returns its parameter unmodified. It can also be written as <code class="literal">\x -&gt; x</code>. If we view the functor value as something that can be mapped over, the <code class="literal">fmap id = id</code> law seems kind of trivial or obvious.</p><p>Let’s see if this law holds for a few values of functors.</p><a id="I_programlisting11_d1e19688"/><pre class="programlisting">ghci&gt; fmap id (Just 3)
Just 3
ghci&gt; id (Just 3)
Just 3
ghci&gt; fmap id [1..5]
[1,2,3,4,5]
ghci&gt; id [1..5]
[1,2,3,4,5]
ghci&gt; fmap id []
[]
ghci&gt; fmap id Nothing
Nothing</pre><p>Looking at the implementation of <code class="literal">fmap</code> for <code class="literal">Maybe</code>, for example, we can figure out why the first functor law holds:</p><a id="I_programlisting11_d1e19698"/><pre class="programlisting">instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing</pre><p>We imagine that <code class="literal">id</code> plays the role of the <code class="literal">f</code> parameter in the implementation. We see that if we <code class="literal">fmap id</code> over <code class="literal">Just x</code>, the result will be <code class="literal">Just (id x)</code>, and because <code class="literal">id</code> just returns its parameter, we can deduce that <code class="literal">Just (id x)</code> equals <code class="literal">Just x</code>. So now we know that if we map <code class="literal">id</code> over a <code class="literal">Maybe</code> value with a <code class="literal">Just</code> value constructor, we get that same value back.</p><p>Seeing that mapping <code class="literal">id</code> over a <code class="literal">Nothing</code> value returns the same value is trivial. So from these two equations in the implementation for <code class="literal">fmap</code>, we find that the law <code class="literal">fmap id = id</code> holds.</p></div><div class="sect2" title="Law 2"><div class="titlepage"><div><div><h2 class="title"><a id="law_2"/>Law 2</h2></div></div></div><p>The second law says that composing two functions and then mapping the resulting function over a functor should be the same as first mapping one function over the functor and then mapping the other one. Formally written, that means <code class="literal">fmap (f . g) = fmap f . fmap g</code>. Or to write it in another way, for any functor value <code class="literal">x</code>, the following should hold: <code class="literal">fmap (f . g) x = fmap f (fmap g x)</code>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e19765"/><img src="httpatomoreillycomsourcenostarchimages802648.png.jpg" alt="image with no caption"/></div></div><p>If we can show that some type obeys both functor laws, we can rely on it having the same fundamental behaviors as other functors when it comes to mapping. We can know that when we use <code class="literal">fmap</code> on it, there won’t be anything other than mapping going on behind the scenes and that it will act like a thing that can be mapped over—that is, a functor.<a id="IDX-CHP-11-0023" class="indexterm"/><a id="IDX-CHP-11-0024" class="indexterm"/></p><p>We figure out how the second law holds for some type by looking at the implementation of <code class="literal">fmap</code> for that type and then using the method that we used to check if <code class="literal">Maybe</code> obeys the first law. So, to check out how the second functor law holds for <code class="literal">Maybe</code>, if we use <code class="literal">fmap (f . g)</code> over <code class="literal">Nothing</code>, we get <code class="literal">Nothing</code>, because calling <code class="literal">fmap</code> with any function over <code class="literal">Nothing</code> returns <code class="literal">Nothing</code>. If we call <code class="literal">fmap f (fmap g Nothing)</code>, we get <code class="literal">Nothing</code>, for the same reason.</p><p>Seeing how the second law holds for <code class="literal">Maybe</code> if it’s a <code class="literal">Nothing</code> value is pretty easy. But how about if it’s a <code class="literal">Just</code> value? Well, if we use <code class="literal">fmap (f . g) (Just x)</code>, we see from the implementation that it’s implemented as <code class="literal">Just ((f . g) x)</code>, which is <code class="literal">Just (f (g x))</code>. If we use <code class="literal">fmap f (fmap g (Just x))</code>, we see from the implementation that <code class="literal">fmap g (Just x)</code> is <code class="literal">Just (g x)</code>. Ergo, <code class="literal">fmap f (fmap g (Just x))</code> equals <code class="literal">fmap f (Just (g x))</code>, and from the implementation, we see that this equals <code class="literal">Just (f (g x))</code>.</p><p>If you’re a bit confused by this proof, don’t worry. Be sure that you understand how function composition works. Many times, you can intuitively see how these laws hold because the types act like containers or functions. You can also just try them on a bunch of different values of a type and be able to say with some certainty that a type does indeed obey the laws.</p></div><div class="sect2" title="Breaking the Law"><div class="titlepage"><div><div><h2 class="title"><a id="breaking_the_law"/>Breaking the Law</h2></div></div></div><p>Let’s take a look at a pathological example of a type constructor being an instance of the <code class="literal">Functor</code> type class but not really being a functor, because it doesn’t satisfy the laws. Let’s say that we have the following type:</p><a id="I_programlisting11_d1e19871"/><pre class="programlisting">data CMaybe a = CNothing | CJust Int a deriving (Show)</pre><p>The <code class="literal">C</code> here stands for counter. It’s a data type that looks much like <code class="literal">Maybe a</code>, but the <code class="literal">Just</code> part holds two fields instead of one. The first field in the <code class="literal">CJust</code> value constructor will always have a type of <code class="literal">Int</code>, and it will be some sort of counter. The second field is of type <code class="literal">a</code>, which comes from the type parameter, and its type will depend on the concrete type that we choose for <code class="literal">CMaybe a</code>. Let’s play with our new type:</p><a id="I_programlisting11_d1e19897"/><pre class="programlisting">ghci&gt; CNothing
CNothing
ghci&gt; CJust 0 "haha"
CJust 0 "haha"
ghci&gt; :t CNothing
CNothing :: CMaybe a
ghci&gt; :t CJust 0 "haha"
CJust 0 "haha" :: CMaybe [Char]
ghci&gt; CJust 100 [1,2,3]
CJust 100 [1,2,3]</pre><p>If we use the <code class="literal">CNothing</code> constructor, there are no fields. If we use the <code class="literal">CJust</code> constructor, the first field is an integer and the second field can be any type. Let’s make this an instance of <code class="literal">Functor</code> so that each time we use <code class="literal">fmap</code>, the function is applied to the second field, whereas the first field is increased by 1.</p><a id="I_programlisting11_d1e19913"/><pre class="programlisting">instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)</pre><p>This is kind of like the instance implementation for <code class="literal">Maybe</code>, except that when we do <code class="literal">fmap</code> over a value that doesn’t represent an empty box (a <code class="literal">CJust</code> value), we don’t just apply the function to the contents; we also increase the counter by 1. Everything seems cool so far. We can even play with this a bit:</p><a id="I_programlisting11_d1e19926"/><pre class="programlisting">ghci&gt; fmap (++"ha") (CJust 0 "ho")
CJust 1 "hoha"
ghci&gt; fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
CJust 2 "hohahe"
ghci&gt; fmap (++"blah") CNothing
CNothing</pre><p>Does this obey the functor laws? In order to see that something doesn’t obey a law, it’s enough to find just one counterexample:</p><a id="I_programlisting11_d1e19930"/><pre class="programlisting">ghci&gt; fmap id (CJust 0 "haha")
CJust 1 "haha"
ghci&gt; id (CJust 0 "haha")
CJust 0 "haha"</pre><p>As the first functor law states, if we map <code class="literal">id</code> over a functor value, it should be the same as just calling <code class="literal">id</code> with the same functor value. Our example demonstrates that this is not true for our <code class="literal">CMaybe</code> functor. Even though it’s part of the <code class="literal">Functor</code> type class, it doesn’t obey this functor law and is therefore not a functor.</p><p>Since <code class="literal">CMaybe</code> fails at being a functor even though it pretends to be one, using it as a functor might lead to some faulty code. When we use a functor, it shouldn’t matter if we first compose a few functions and then map them over the functor value or we just map each function over a functor value in succession. But with <code class="literal">CMaybe</code> it matters, because it keeps track of how many times it has been mapped over. Not cool! If we want <code class="literal">CMaybe</code> to obey the functor laws, we need to make it so that the <code class="literal">Int</code> field stays the same when we use <code class="literal">fmap</code>.</p><p>At first, the functor laws might seem a bit confusing and unnecessary. But if we know that a type obeys both laws, we can make certain assumptions about how it will act. If a type obeys the functor laws, we know that calling <code class="literal">fmap</code> on a value of that type will only map the function over it—nothing more. This leads to code that is more abstract and extensible, because we can use laws to reason about behaviors that any functor should have and make functions that operate reliably on any functor.<a id="IDX-CHP-11-0025" class="indexterm"/><a id="IDX-CHP-11-0026" class="indexterm"/></p><p>The next time you make a type an instance of <code class="literal">Functor</code>, take a minute to make sure that it obeys the functor laws. You can go over the implementation line by line and see if the laws hold or try to find a counterexample. Once you’ve dealt with enough functors, you will begin to recognize the properties and behaviors that they have in common, and begin to intuitively see if a type obeys the functor laws.</p></div></div>
<div class="sect1" title="Using Applicative Functors"><div class="titlepage"><div><div><h1 class="title"><a id="using_applicative_functors"/>Using Applicative Functors</h1></div></div></div><p>In this section, we’ll take a look at applicative functors, which are beefed-up functors.<a id="IDX-CHP-11-0027" class="indexterm"/></p><p>So far, we have focused on mapping functions that take only one parameter over functors. But what happens when we map a function that takes two parameters over a functor? Let’s take a look at a couple of concrete examples of this.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e19991"/><img src="httpatomoreillycomsourcenostarchimages802650.png.jpg" alt="image with no caption"/></div></div><p>If we have <code class="literal">Just 3</code> and we call <code class="literal">fmap (*) (Just 3)</code>, what do we get? From the instance implementation of <code class="literal">Maybe</code> for <code class="literal">Functor</code>, we know that if it’s a <code class="literal">Just</code> value, it will apply the function to the value inside the <code class="literal">Just</code>. Therefore, doing <code class="literal">fmap (*) (Just 3)</code> results in <code class="literal">Just ((*) 3)</code>, which can also be written as <code class="literal">Just (3 *)</code> if we use sections. Interesting! We get a function wrapped in a <code class="literal">Just</code>!</p><p>Here are some more functions inside functor values:</p><a id="I_programlisting11_d1e20031"/><pre class="programlisting">ghci&gt; :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -&gt; [Char])
ghci&gt; :t fmap compare (Just 'a')
fmap compare (Just 'a') :: Maybe (Char -&gt; Ordering)
ghci&gt; :t fmap compare "A LIST OF CHARS"
fmap compare "A LIST OF CHARS" :: [Char -&gt; Ordering]
ghci&gt; :t fmap (\x y z -&gt; x + y / z) [3,4,5,6]
fmap (\x y z -&gt; x + y / z) [3,4,5,6] :: (Fractional a) =&gt; [a -&gt; a -&gt; a]</pre><p>If we map <code class="literal">compare</code>, which has a type of <code class="literal">(Ord a) =&gt; a -&gt; a -&gt; Ordering</code>, over a list of characters, we get a list of functions of type <code class="literal">Char -&gt; Ordering</code>, because the function <code class="literal">compare</code> gets partially applied with the characters in the list. It’s not a list of <code class="literal">(Ord a) =&gt; a -&gt; Ordering</code> function, because the first <code class="literal">a</code> applied was a <code class="literal">Char</code>, and so the second <code class="literal">a</code> must decide to be of type <code class="literal">Char</code>.</p><p>We see how by mapping “multiparameter” functions over functor values, we get functor values that contain functions inside them. So now what can we do with them? For one, we can map functions that take these functions as parameters over them, because whatever is inside a functor value will be given to the function that we’re mapping over it as a parameter:<a id="IDX-CHP-11-0028" class="indexterm"/><a id="IDX-CHP-11-0029" class="indexterm"/><a id="IDX-CHP-11-0030" class="indexterm"/><a id="IDX-CHP-11-0031" class="indexterm"/></p><a id="I_programlisting11_d1e20081"/><pre class="programlisting">ghci&gt; let a = fmap (*) [1,2,3,4]
ghci&gt; :t a
a :: [Integer -&gt; Integer]
ghci&gt; fmap (\f -&gt; f 9) a
[9,18,27,36]</pre><p>But what if we have a functor value of <code class="literal">Just (3 *)</code> and a functor value of <code class="literal">Just 5</code>, and we want to take out the function from <code class="literal">Just (3 *)</code> and map it over <code class="literal">Just 5</code>? With normal functors, we’re out of luck, because they support only mapping normal functions over existing functors. Even when we mapped <code class="literal">\f -&gt; f 9</code> over a functor that contained functions, we were just mapping a normal function over it. But we can’t map a function that’s inside a functor value over another functor value with what <code class="literal">fmap</code> offers us. We could pattern match against the <code class="literal">Just</code> constructor to get the function out of it and then map it over <code class="literal">Just 5</code>, but we’re looking for a more general and abstract approach that works across functors.</p><div class="sect2" title="Say Hello to Applicative"><div class="titlepage"><div><div><h2 class="title"><a id="say_hello_to_applicative"/>Say Hello to Applicative</h2></div></div></div><p>Meet the <code class="literal">Applicative</code> type class, in the <code class="literal">Control.Applicative</code> module. It defines two functions: <code class="literal">pure</code> and <code class="literal">&lt;*&gt;</code>. It doesn’t provide a default implementation for either of them, so we need to define them both if we want something to be an applicative functor. The class is defined like so:</p><a id="I_programlisting11_d1e20128"/><pre class="programlisting">class (Functor f) =&gt; Applicative f where
    pure :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</pre><p>This simple three-line class definition tells us a lot! The first line starts the definition of the <code class="literal">Applicative</code> class, and it also introduces a class constraint. The constraint says that if we want to make a type constructor part of the <code class="literal">Applicative</code> type class, it must be in <code class="literal">Functor</code> first. That’s why if we know that a type constructor is part of the <code class="literal">Applicative</code> type class, it’s also in <code class="literal">Functor</code>, so we can use <code class="literal">fmap</code> on it.</p><p>The first method it defines is called <code class="literal">pure</code>. Its type declaration is <code class="literal">pure :: a -&gt; f a</code>. <code class="literal">f</code> plays the role of our applicative functor instance here. Because Haskell has a very good type system, and because all a function can do is take some parameters and return some value, we can tell a lot from a type declaration, and this is no exception.</p><p><code class="literal">pure</code> should take a value of any type and return an applicative value with that value inside it. “Inside it” refers to our box analogy again, even though we’ve seen that it doesn’t always stand up to scrutiny. But the <code class="literal">a -&gt; f a</code> type declaration is still pretty descriptive. We take a value and we wrap it in an applicative value that has that value as the result inside it. A better way of thinking about <code class="literal">pure</code> would be to say that it takes a value and puts it in some sort of default (or pure) context—a minimal context that still yields that value.<a id="IDX-CHP-11-0032" class="indexterm"/><a id="IDX-CHP-11-0033" class="indexterm"/></p><p>The <code class="literal">&lt;*&gt;</code> function is really interesting. It has this type declaration:</p><a id="I_programlisting11_d1e20187"/><pre class="programlisting">f (a -&gt; b) -&gt; f a -&gt; f b</pre><p>Does this remind you of anything? It’s like <code class="literal">fmap :: (a -&gt; b) -&gt; f a-&gt; f b</code>. You can think of the <code class="literal">&lt;*&gt;</code> function as sort of a beefed-up <code class="literal">fmap</code>. Whereas <code class="literal">fmap</code> takes a function and a functor value and applies the function inside the functor value, <code class="literal">&lt;*&gt;</code> takes a functor value that has a function in it and another functor, and extracts that function from the first functor and then maps it over the second one.</p></div><div class="sect2" title="Maybe the Applicative Functor"><div class="titlepage"><div><div><h2 class="title"><a id="maybe_the_applicative_functor"/>Maybe the Applicative Functor</h2></div></div></div><p>Let’s take a look at the <code class="literal">Applicative</code> instance implementation for <code class="literal">Maybe</code>:</p><a id="I_programlisting11_d1e20217"/><pre class="programlisting">instance Applicative Maybe where
    pure = Just
    Nothing &lt;*&gt; _ = Nothing
    (Just f) &lt;*&gt; something = fmap f something</pre><p>Again, from the class definition, we see that the <code class="literal">f</code> that plays the role of the applicative functor should take one concrete type as a parameter, so we write <code class="literal">instance Applicative Maybe where</code> instead of <code class="literal">instance Applicative (Maybe a) where</code>.</p><p>Next, we have <code class="literal">pure</code>. Remember that it’s supposed to take something and wrap it in an applicative value. We wrote <code class="literal">pure = Just</code>, because value constructors like <code class="literal">Just</code> are normal functions. We could have also written <code class="literal">pure x = Just x</code>.</p><p>Finally, we have the definition for <code class="literal">&lt;*&gt;</code>. We can’t extract a function out of a <code class="literal">Nothing</code>, because it has no function inside it. So we say that if we try to extract a function from a <code class="literal">Nothing</code>, the result is a <code class="literal">Nothing</code>.</p><p>In the class definition for <code class="literal">Applicative</code>, there’s a <code class="literal">Functor</code> class constraint, which means that we can assume that both of the <code class="literal">&lt;*&gt;</code> function’s parameters are functor values. If the first parameter is not a <code class="literal">Nothing</code>, but a <code class="literal">Just</code> with some function inside it, we say that we then want to map that function over the second parameter. This also takes care of the case where the second parameter is <code class="literal">Nothing</code>, because doing <code class="literal">fmap</code> with any function over a <code class="literal">Nothing</code> will re turn a <code class="literal">Nothing</code>. So for <code class="literal">Maybe</code>, <code class="literal">&lt;*&gt;</code> extracts the function from the left value if it’s a <code class="literal">Just</code> and maps it over the right value. If any of the parameters is <code class="literal">Nothing</code>, <code class="literal">Nothing</code> is the result.</p><p>Now let’s give this a whirl:</p><a id="I_programlisting11_d1e20306"/><pre class="programlisting">ghci&gt; Just (+3) &lt;*&gt; Just 9
Just 12

ghci&gt; pure (+3) &lt;*&gt; Just 10
Just 13
ghci&gt; pure (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; Just (++"hahah") &lt;*&gt; Nothing
Nothing
ghci&gt; Nothing &lt;*&gt; Just "woot"
Nothing</pre><p>You see how doing <code class="literal">pure (+3)</code> and <code class="literal">Just (+3)</code> is the same in this case. Use <code class="literal">pure</code> if you’re dealing with <code class="literal">Maybe</code> values in an applicative context (using them with <code class="literal">&lt;*&gt;</code>); otherwise, stick to <code class="literal">Just</code>.<a id="IDX-CHP-11-0034" class="indexterm"/></p><p>The first four input lines demonstrate how the function is extracted and then mapped, but in this case, they could have been achieved by just mapping unwrapped functions over functors. The last line is interesting, because we try to extract a function from a <code class="literal">Nothing</code> and then map it over something, which results in <code class="literal">Nothing</code>.</p><p>With normal functors, when you map a function over a functor, you can’t get the result out in any general way, even if the result is a partially applied function. Applicative functors, on the other hand, allow you to operate on several functors with a single function.</p></div><div class="sect2" title="The Applicative Style"><div class="titlepage"><div><div><h2 class="title"><a id="the_applicative_style"/>The Applicative Style</h2></div></div></div><p>With the <code class="literal">Applicative</code> type class, we can chain the use of the <code class="literal">&lt;*&gt;</code> function, thus enabling us to seamlessly operate on several applicative values instead of just one. For instance, check this out:</p><a id="I_programlisting11_d1e20356"/><pre class="programlisting">ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5
Just 8
ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Nothing
Nothing
ghci&gt; pure (+) &lt;*&gt; Nothing &lt;*&gt; Just 5
Nothing</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e20359"/><img src="httpatomoreillycomsourcenostarchimages802652.png.jpg" alt="image with no caption"/></div></div><p>We wrapped the <code class="literal">+</code> function inside an applicative value and then used <code class="literal">&lt;*&gt;</code> to call it with two parameters, both applicative values.</p><p>Let’s take a look at how this happens, step by step. <code class="literal">&lt;*&gt;</code> is left-associative, which means that this:</p><a id="I_programlisting11_d1e20377"/><pre class="programlisting">pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5</pre><p>is the same as this:</p><a id="I_programlisting11_d1e20381"/><pre class="programlisting">(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 5</pre><p>First, the <code class="literal">+</code> function is put in an applicative value—in this case, a <code class="literal">Maybe</code> value that contains the function. So we have <code class="literal">pure (+)</code>, which is <code class="literal">Just (+)</code>. Next, <code class="literal">Just (+) &lt;*&gt; Just 3</code> happens. The result of this is <code class="literal">Just (3+)</code>. This is because of partial application. Only applying the <code class="literal">+</code> function to <code class="literal">3</code> results in a function that takes one parameter and adds 3 to it. Finally, <code class="literal">Just (3+) &lt;*&gt; Just 5</code> is carried out, which results in a <code class="literal">Just 8</code>.<a id="IDX-CHP-11-0035" class="indexterm"/></p><p>Isn’t this awesome? Applicative functors and the applicative style of <code class="literal">pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code> allow us to take a function that expects parameters that aren’t applicative values and use that function to operate on several applicative values. The function can take as many parameters as we want, because it’s always partially applied step by step between occurrences of <code class="literal">&lt;*&gt;</code>.</p><p>This becomes even more handy and apparent if we consider the fact that <code class="literal">pure f &lt;*&gt; x</code> equals <code class="literal">fmap f x</code>. This is one of the applicative laws. We’ll take a closer look at the applicative laws later in the chapter, but let’s think about how it applies here. <code class="literal">pure</code> puts a value in a default context. If we just put a function in a default context and then extract and apply it to a value inside another applicative functor, that’s the same as just mapping that function over that applicative functor. Instead of writing <code class="literal">pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code>, we can write <code class="literal">fmap f x &lt;*&gt; y &lt;*&gt; ...</code>. This is why <code class="literal">Control.Applicative</code> exports a function called <code class="literal">&lt;$&gt;</code>, which is just <code class="literal">fmap</code> as an infix operator. Here’s how it’s defined:</p><a id="I_programlisting11_d1e20455"/><pre class="programlisting">(&lt;$&gt;) :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b
f &lt;$&gt; x = fmap f x</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember that type variables are independent of parameter names or other value names. The <code class="literal">f</code> in the function declaration here is a type variable with a class constraint saying that any type constructor that replaces <code class="literal">f</code> should be in the <code class="literal">Functor</code> type class. The <code class="literal">f</code> in the function body denotes a function that we map over <code class="literal">x</code>. The fact that we used <code class="literal">f</code> to represent both of those doesn’t mean that they represent the same thing.<a id="IDX-CHP-11-0036" class="indexterm"/></p></div><p>By using <code class="literal">&lt;$&gt;</code>, the applicative style really shines, because now if we want to apply a function <code class="literal">f</code> between three applicative values, we can write <code class="literal">f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>. If the parameters were normal values rather than applicative functors, we would write <code class="literal">f x y z</code>.</p><p>Let’s take a closer look at how this works. Suppose we want to join the values <code class="literal">Just "johntra"</code> and <code class="literal">Just "volta"</code> into one <code class="literal">String</code> inside a <code class="literal">Maybe</code> functor. We can do this:</p><a id="I_programlisting11_d1e20510"/><pre class="programlisting">ghci&gt; (++) &lt;$&gt; Just "johntra" &lt;*&gt; Just "volta"
Just "johntravolta"</pre><p>Before we see how this happens, compare the preceding line with this:</p><a id="I_programlisting11_d1e20514"/><pre class="programlisting">ghci&gt; (++) "johntra" "volta"
"johntravolta"</pre><p>To use a normal function on applicative functors, just sprinkle some <code class="literal">&lt;$&gt;</code> and <code class="literal">&lt;*&gt;</code> about, and the function will operate on applicatives and return an applicative. How cool is that?<a id="IDX-CHP-11-0037" class="indexterm"/><a id="IDX-CHP-11-0038" class="indexterm"/><a id="IDX-CHP-11-0039" class="indexterm"/><a id="IDX-CHP-11-0040" class="indexterm"/><a id="IDX-CHP-11-0041" class="indexterm"/></p><p>Back to our <code class="literal">(++) &lt;$&gt; Just "johntra" &lt;*&gt; Just "volta"</code>: First <code class="literal">(++)</code>, which has a type of <code class="literal">(++) :: [a] -&gt; [a] -&gt; [a]</code>, is mapped over <code class="literal">Just "johntra"</code>. This results in a value that’s the same as <code class="literal">Just ("johntra"++)</code> and has a type of <code class="literal">Maybe ([Char] -&gt; [Char])</code>. Notice how the first parameter of <code class="literal">(++)</code> got eaten up and how the <code class="literal">a</code>s turned into <code class="literal">Char</code> values. And now <code class="literal">Just ("johntra"++) &lt;*&gt; Just "volta"</code> happens, which takes the function out of the <code class="literal">Just</code> and maps it over <code class="literal">Just "volta"</code>, resulting in <code class="literal">Just "johntravolta"</code>. Had either of the two values been <code class="literal">Nothing</code>, the result would have also been <code class="literal">Nothing</code>.</p><p>So far, we’ve used only <code class="literal">Maybe</code> in our examples, and you might be thinking that applicative functors are all about <code class="literal">Maybe</code>. There are loads of other instances of <code class="literal">Applicative</code>, so let’s meet them!</p></div><div class="sect2" title="Lists"><div class="titlepage"><div><div><h2 class="title"><a id="lists"/>Lists</h2></div></div></div><p>Lists (actually the list type constructor, <code class="literal">[]</code>) are applicative functors. What a surprise! Here’s how <code class="literal">[]</code> is an instance of <code class="literal">Applicative</code>:</p><a id="I_programlisting11_d1e20621"/><pre class="programlisting">instance Applicative [] where
    pure x = [x]
    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</pre><p>Remember that <code class="literal">pure</code> takes a value and puts it in a default context. In other words, it puts it in a minimal context that still yields that value. The minimal context for lists would be the empty list, but the empty list represents the lack of a value, so it can’t hold in itself the value on which we used <code class="literal">pure</code>. That’s why <code class="literal">pure</code> takes a value and puts it in a singleton list. Similarly, the minimal context for the <code class="literal">Maybe</code> applicative functor would be a <code class="literal">Nothing</code>, but it represents the lack of a value instead of a value, so <code class="literal">pure</code> is implemented as <code class="literal">Just</code> in the instance implementation for <code class="literal">Maybe</code>.</p><p>Here’s <code class="literal">pure</code> in action:</p><a id="I_programlisting11_d1e20655"/><pre class="programlisting">ghci&gt; pure "Hey" :: [String]
["Hey"]
ghci&gt; pure "Hey" :: Maybe String
Just "Hey"</pre><p>What about <code class="literal">&lt;*&gt;</code>? If the <code class="literal">&lt;*&gt;</code> function’s type were limited to only lists, we would get <code class="literal">(&lt;*&gt;) :: [a -&gt; b] -&gt; [a] -&gt; [b]</code>. It’s implemented with a list comprehension. <code class="literal">&lt;*&gt;</code> must somehow extract the function out of its left parameter and then map it over the right parameter. But the left list can have zero functions, one function, or several functions inside it, and the right list can also hold several values. That’s why we use a list comprehension to draw from both lists. We apply every possible function from the left list to every possible value from the right list. The resulting list has every possible combination of applying a function from the left list to a value in the right one.</p><p>We can use <code class="literal">&lt;*&gt;</code> with lists like this:<a id="IDX-CHP-11-0042" class="indexterm"/><a id="IDX-CHP-11-0043" class="indexterm"/></p><a id="I_programlisting11_d1e20684"/><pre class="programlisting">ghci&gt; [(*0),(+100),(^2)] &lt;*&gt; [1,2,3]
[0,0,0,101,102,103,1,4,9]</pre><p>The left list has three functions, and the right list has three values, so the resulting list will have nine elements. Every function in the left list is applied to every function in the right one. If we have a list of functions that take two parameters, we can apply those functions between two lists.</p><p>In the following example, we apply two function between two lists:</p><a id="I_programlisting11_d1e20691"/><pre class="programlisting">ghci&gt; [(+),(*)] &lt;*&gt; [1,2] &lt;*&gt; [3,4]
[4,5,5,6,3,4,6,8]</pre><p><code class="literal">&lt;*&gt;</code> is left-associative, so <code class="literal">[(+),(*)] &lt;*&gt; [1,2]</code> happens first, resulting in a list that’s the same as <code class="literal">[(1+),(2+),(1*),(2*)]</code>, because every function on the left gets applied to every value on the right. Then <code class="literal">[(1+),(2+),(1*),(2*)] &lt;*&gt; [3,4]</code> happens, which produces the final result.<a id="IDX-CHP-11-0044" class="indexterm"/></p><p>Using the applicative style with lists is fun!</p><a id="I_programlisting11_d1e20713"/><pre class="programlisting">ghci&gt; (++) &lt;$&gt; ["ha","heh","hmm"] &lt;*&gt; ["?","!","."]
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]</pre><p>Again, we used a normal function that takes two strings between two lists of strings just by inserting the appropriate applicative operators.</p><p>You can view lists as nondeterministic computations. A value like <code class="literal">100</code> or <code class="literal">"what"</code> can be viewed as a deterministic computation that has only one result, whereas a list like <code class="literal">[1,2,3]</code> can be viewed as a computation that can’t decide on which result it wants to have, so it presents us with all of the possible results. So when you write something like <code class="literal">(+) &lt;$&gt; [1,2,3] &lt;*&gt; [4,5,6]</code>, you can think of it as adding together two nondeterministic computations with <code class="literal">+</code>, only to produce another nondeterministic computation that’s even less sure about its result.<a id="IDX-CHP-11-0045" class="indexterm"/></p><p>Using the applicative style on lists is often a good replacement for list comprehensions. In <a class="xref" href="ch01.html" title="Chapter 1. Starting Out">Chapter 1</a>, we wanted to see all the possible products of <code class="literal">[2,5,10]</code> and <code class="literal">[8,10,11]</code>, so we did this:</p><a id="I_programlisting11_d1e20750"/><pre class="programlisting">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110]</pre><p>We’re just drawing from two lists and applying a function between every combination of elements. This can be done in the applicative style as well:</p><a id="I_programlisting11_d1e20754"/><pre class="programlisting">ghci&gt; (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[16,20,22,40,50,55,80,100,110]</pre><p>This seems clearer to me, because it’s easier to see that we’re just calling <code class="literal">*</code> between two nondeterministic computations. If we wanted all possible products of those two lists that are more than 50, we would use the following:<a id="IDX-CHP-11-0046" class="indexterm"/><a id="IDX-CHP-11-0047" class="indexterm"/></p><a id="I_programlisting11_d1e20770"/><pre class="programlisting">ghci&gt; filter (&gt;50) $ (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[55,80,100,110]</pre><p>It’s easy to see how <code class="literal">pure f &lt;*&gt; xs</code> equals <code class="literal">fmap f xs</code> with lists. <code class="literal">pure f</code> is just <code class="literal">[f]</code>, and <code class="literal">[f] &lt;*&gt; xs</code> will apply every function in the left list to every value in the right one, but there’s just one function in the left list, so it’s like mapping.</p></div><div class="sect2" title="IO Is An Applicative Functor, Too"><div class="titlepage"><div><div><h2 class="title"><a id="io_is_an_applicative_functor_comma_too"/>IO Is An Applicative Functor, Too</h2></div></div></div><p>Another instance of <code class="literal">Applicative</code> that we’ve already encountered is <code class="literal">IO</code>. This is how the instance is implemented:</p><a id="I_programlisting11_d1e20800"/><pre class="programlisting">instance Applicative IO where
    pure = return
    a &lt;*&gt; b = do
        f &lt;- a
        x &lt;- b
        return (f x)</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e20803"/><img src="httpatomoreillycomsourcenostarchimages802654.png.jpg" alt="image with no caption"/></div></div><p>Since <code class="literal">pure</code> is all about putting a value in a minimal context that still holds the value as the result, it makes sense that <code class="literal">pure</code> is just <code class="literal">return</code>. <code class="literal">return</code> makes an I/O action that doesn’t do anything. It just yields some value as its result, without performing any I/O operations like printing to the terminal or reading from a file.</p><p>If <code class="literal">&lt;*&gt;</code> were specialized for <code class="literal">IO</code>, it would have a type of <code class="literal">(&lt;*&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</code>. In the case of <code class="literal">IO</code>, it takes the I/O action <code class="literal">a</code>, which yields a function, performs the function, and binds that function to <code class="literal">f</code>. Then it performs <code class="literal">b</code> and binds its result to <code class="literal">x</code>. Finally, it applies the function <code class="literal">f</code> to <code class="literal">x</code> and yields that as the result. We used <code class="literal">do</code> syntax to implement it here. (Remember that <code class="literal">do</code> syntax is about taking several I/O actions and gluing them into one.)</p><p>With <code class="literal">Maybe</code> and <code class="literal">[]</code>, we could think of <code class="literal">&lt;*&gt;</code> as simply extracting a function from its left parameter and then applying it over the right one. With <code class="literal">IO</code>, extracting is still in the game, but now we also have a notion of <span class="emphasis"><em>sequencing</em></span>, because we’re taking two I/O actions and gluing them into one. We need to extract the function from the first I/O action, but to extract a result from an I/O action, it must be performed. Consider this:</p><a id="I_programlisting11_d1e20879"/><pre class="programlisting">myAction :: IO String
myAction = do
    a &lt;- getLine
    b &lt;- getLine
    return $ a ++ b</pre><p>This is an I/O action that will prompt the user for two lines and yield as its result those two lines concatenated. We achieved it by gluing together two <code class="literal">getLine</code> I/O actions and a <code class="literal">return</code>, because we wanted our new glued I/O action to hold the result of <code class="literal">a ++ b</code>. Another way of writing this is to use the applicative style:</p><a id="I_programlisting11_d1e20892"/><pre class="programlisting">myAction :: IO String
myAction = (++) &lt;$&gt; getLine &lt;*&gt; getLine</pre><p>This is the same thing we did earlier when we were making an I/O action that applied a function between the results of two other I/O actions. Remember that <code class="literal">getLine</code> is an I/O action with the type <code class="literal">getLine :: IO String</code>. When we use <code class="literal">&lt;*&gt;</code> between two applicative values, the result is an applicative value, so this all makes sense.</p><p>If we return to the box analogy, we can imagine <code class="literal">getLine</code> as a box that will go out into the real world and fetch us a string. Calling <code class="literal">(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> makes a new, bigger box that sends those two boxes out to fetch lines from the terminal and then presents the concatenation of those two lines as its result.</p><p>The type of the expression <code class="literal">(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> is <code class="literal">IO String</code>. This means that the expression is a completely normal I/O action like any other, which also yields a result value, just like other I/O actions. That’s why we can do stuff like this:</p><a id="I_programlisting11_d1e20922"/><pre class="programlisting">main = do
    a &lt;- (++) &lt;$&gt; getLine &lt;*&gt; getLine
    putStrLn $ "The two lines concatenated turn out to be: " ++ a</pre></div><div class="sect2" title="Functions As Applicatives"><div class="titlepage"><div><div><h2 class="title"><a id="functions_as_applicatives"/>Functions As Applicatives</h2></div></div></div><p>Another instance of <code class="literal">Applicative</code> is <code class="literal">(-&gt;) r</code>, or functions. We don’t often use functions as applicatives, but the concept is still really interesting, so let’s take a look at how the function instance is implemented.<a id="IDX-CHP-11-0048" class="indexterm"/><a id="IDX-CHP-11-0049" class="indexterm"/></p><a id="I_programlisting11_d1e20945"/><pre class="programlisting">instance Applicative ((-&gt;) r) where
    pure x = (\_ -&gt; x)
    f &lt;*&gt; g = \x -&gt; f x (g x)</pre><p>When we wrap a value into an applicative value with <code class="literal">pure</code>, the result it yields must be that value. A minimal default context still yields that value as a result. That’s why in the function instance implementation, <code class="literal">pure</code> takes a value and creates a function that ignores its parameter and always returns that value. The type for <code class="literal">pure</code> specialized for the <code class="literal">(-&gt;) r</code> instance is <code class="literal">pure :: a -&gt; (r -&gt; a)</code>.<a id="IDX-CHP-11-0050" class="indexterm"/><a id="IDX-CHP-11-0051" class="indexterm"/></p><a id="I_programlisting11_d1e20973"/><pre class="programlisting">ghci&gt; (pure 3) "blah"
3</pre><p>Because of currying, function application is left-associative, so we can omit the parentheses.</p><a id="I_programlisting11_d1e20977"/><pre class="programlisting">ghci&gt; pure 3 "blah"
3</pre><p>The instance implementation for <code class="literal">&lt;*&gt;</code> is a bit cryptic, so let’s just take a look at how to use functions as applicative functors in the applicative style:</p><a id="I_programlisting11_d1e20984"/><pre class="programlisting">ghci&gt; :t (+) &lt;$&gt; (+3) &lt;*&gt; (*100)
(+) &lt;$&gt; (+3) &lt;*&gt; (*100) :: (Num a) =&gt; a -&gt; a
ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5
508</pre><p>Calling <code class="literal">&lt;*&gt;</code> with two applicative values results in an applicative value, so if we use it on two functions, we get back a function. So what goes on here? When we do <code class="literal">(+) &lt;$&gt; (+3) &lt;*&gt; (*100)</code>, we’re making a function that will use <code class="literal">+</code> on the results of <code class="literal">(+3)</code> and <code class="literal">(*100)</code> and return that. With <code class="literal">(+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5</code>, <code class="literal">(+3)</code> and <code class="literal">(*100)</code> are first applied to <code class="literal">5</code>, resulting in <code class="literal">8</code> and <code class="literal">500</code>. Then <code class="literal">+</code> is called with <code class="literal">8</code> and <code class="literal">500</code>, resulting in <code class="literal">508</code>.</p><p>The following code is similar:</p><a id="I_programlisting11_d1e21038"/><pre class="programlisting">ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5
[8.0,10.0,2.5]</pre><p>We create a function that will call the function <code class="literal">\x y z -&gt; [x,y,z]</code> with the eventual results from <code class="literal">(+3)</code>, <code class="literal">(*2)</code> and <code class="literal">(/2)</code>. The <code class="literal">5</code> is fed to each of the three functions, and then <code class="literal">\x y z -&gt; [x, y, z]</code> is called with those results.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject11_d1e21062"/><img src="httpatomoreillycomsourcenostarchimages802656.png.jpg" alt="image with no caption"/></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>It’s not very important that you get how the <code class="literal">(-&gt;) r</code> instance for <code class="literal">Applicative</code> works, so don’t despair if you don’t understand this all right now. Try playing with the applicative style and functions to get some insight into using functions as applicatives.</p></div></div><div class="sect2" title="Zip Lists"><div class="titlepage"><div><div><h2 class="title"><a id="zip_lists"/>Zip Lists</h2></div></div></div><p>It turns out there are actually more ways for lists to be applicative functors. We’ve already covered one way: calling <code class="literal">&lt;*&gt;</code> with a list of functions and a list of values, which results in a list containing all the possible combinations of applying functions from the left list to the values in the right list.<a id="IDX-CHP-11-0052" class="indexterm"/><a id="IDX-CHP-11-0053" class="indexterm"/><a id="IDX-CHP-11-0054" class="indexterm"/><a id="IDX-CHP-11-0055" class="indexterm"/><a id="IDX-CHP-11-0056" class="indexterm"/><a id="IDX-CHP-11-0057" class="indexterm"/></p><p>For example, if we write <code class="literal">[(+3),(*2)] &lt;*&gt; [1,2]</code>, <code class="literal">(+3)</code> will be applied to both <code class="literal">1</code> and <code class="literal">2</code>, and <code class="literal">(*2)</code> will also be applied to both <code class="literal">1</code> and <code class="literal">2</code>, resulting in a list that has four elements: <code class="literal">[4,5,2,4]</code>. However, <code class="literal">[(+3),(*2)] &lt;*&gt; [1,2]</code> could also work in such a way that the first function in the left list is applied to the first value in the right one, the second function is applied to the second value, and so on. That would result in a list with two values: <code class="literal">[4,4]</code>. You could look at it as <code class="literal">[1 + 3, 2 * 2]</code>.</p><p>An instance of <code class="literal">Applicative</code> that we haven’t encountered yet is <code class="literal">ZipList</code>, and it lives in <code class="literal">Control.Applicative</code>.</p><p>Because one type can’t have two instances for the same type class, the <code class="literal">ZipList a</code> type was introduced, which has one constructor (<code class="literal">ZipList</code>) with just one field (a list). Here’s the instance:</p><a id="I_programlisting11_d1e21165"/><pre class="programlisting">instance Applicative ZipList where
        pure x = ZipList (repeat x)
        ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith (\f x -&gt; f x) fs xs)</pre><p><code class="literal">&lt;*&gt;</code> applies the first function to the first value, the second function to the second value, and so on. This is done with <code class="literal">zipWith (\f x -&gt; f x) fs xs</code>. Because of how <code class="literal">zipWith</code> works, the resulting list will be as long as the shorter of the two lists.</p><p><code class="literal">pure</code> is also interesting here. It takes a value and puts it in a list that just has that value repeating indefinitely. <code class="literal">pure "haha"</code> results in <code class="literal">ZipList (["haha", "haha","haha"...</code>. This might be a bit confusing, since you’ve learned that <code class="literal">pure</code> should put a value in a minimal context that still yields that value. And you might be thinking that an infinite list of something is hardly minimal. But it makes sense with zip lists, because it must produce the value on every position. This also satisfies the law that <code class="literal">pure f &lt;*&gt; xs</code> should equal <code class="literal">fmap f xs</code>. If <code class="literal">pure 3</code> just returned <code class="literal">ZipList [3]</code>, <code class="literal">pure (*2) &lt;*&gt; ZipList [1,5,10]</code> would result in <code class="literal">ZipList [2]</code>, because the resulting list of two zipped lists has the length of the shorter of the two. If we zip a finite list with an infinite list, the length of the resulting list will always be equal to the length of the finite list.</p><p>So how do zip lists work in an applicative style? Well, the <code class="literal">ZipList a</code> type doesn’t have a <code class="literal">Show</code> instance, so we need to use the <code class="literal">getZipList</code> function to extract a raw list from a zip list:</p><a id="I_programlisting11_d1e21220"/><pre class="programlisting">ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100,100]
[101,102,103]
ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..]
[101,102,103]
ghci&gt; getZipList $ max &lt;$&gt; ZipList [1,2,3,4,5,3] &lt;*&gt; ZipList [5,3,1,2]
[5,3,3,4]
ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList "dog" &lt;*&gt; ZipList "cat" &lt;*&gt; ZipList "rat"
[('d','c','r'),('o','a','a'),('g','t','t')]</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">(,,)</code> function is the same as <code class="literal">\x y z -&gt; (x,y,z)</code>. Also, the <code class="literal">(,)</code> function is the same as <code class="literal">\x y -&gt; (x,y)</code>.<a id="IDX-CHP-11-0058" class="indexterm"/><a id="IDX-CHP-11-0059" class="indexterm"/><a id="IDX-CHP-11-0060" class="indexterm"/><a id="IDX-CHP-11-0061" class="indexterm"/><a id="IDX-CHP-11-0062" class="indexterm"/></p></div><p>Aside from <code class="literal">zipWith</code>, the standard library has functions such as <code class="literal">zipWith3</code> and <code class="literal">zipWith4</code>, all the way up to <code class="literal">zipWith7</code>. <code class="literal">zipWith</code> takes a function that takes two parameters and zips two lists with it. <code class="literal">zipWith3</code> takes a function that takes three parameters and zips three lists with it, and so on. By using zip lists with an applicative style, we don’t need to have a separate zip function for each number of lists that we want to zip together. We just use the applicative style to zip together an arbitrary amount of lists with a function, and that’s pretty handy.</p></div><div class="sect2" title="Applicative Laws"><div class="titlepage"><div><div><h2 class="title"><a id="applicative_laws"/>Applicative Laws</h2></div></div></div><p>Like normal functors, applicative functors come with a few laws. The most important law is the one that <code class="literal">pure f &lt;*&gt; x = fmap f x</code> holds. As an exercise, you can prove this law for some of the applicative functors that we’ve met in this chapter. The following are the other applicative laws:<a id="IDX-CHP-11-0063" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">pure id &lt;*&gt; v = v</code></p></li><li class="listitem"><p><code class="literal">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></p></li><li class="listitem"><p><code class="literal">pure f &lt;*&gt; pure x = pure (f x)</code></p></li><li class="listitem"><p><code class="literal">u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></p></li></ul></div><p>We won’t go over them in detail because that would take up a lot of pages and be kind of boring. If you’re interested, you can take a closer look at them and see if they hold for some of the instances.</p></div></div>
<div class="sect1" title="Useful Functions for Applicatives"><div class="titlepage"><div><div><h1 class="title"><a id="useful_functions_for_applicatives"/>Useful Functions for Applicatives</h1></div></div></div><p><code class="literal">Control.Applicative</code> defines a function that’s called <code class="literal">liftA2</code>, which has the following type:</p><a id="I_programlisting11_d1e21325"/><pre class="programlisting">liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</pre><p>It’s defined like this:</p><a id="I_programlisting11_d1e21329"/><pre class="programlisting">liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b</pre><p>It just applies a function between two applicatives, hiding the applicative style that we’ve discussed. However, it clearly showcases why applicative functors are more powerful than ordinary functors.</p><p>With ordinary functors, we can just map functions over one functor value. With applicative functors, we can apply a function between several functor values. It’s also interesting to look at this function’s type as <code class="literal">(a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)</code>. When we look at it like this, we can say that <code class="literal">liftA2</code> takes a normal binary function and promotes it to a function that operates on two applicatives.<a id="IDX-CHP-11-0064" class="indexterm"/><a id="IDX-CHP-11-0065" class="indexterm"/><a id="IDX-CHP-11-0066" class="indexterm"/></p><p>Here’s an interesting concept: We can take two applicative values and combine them into one applicative value that has inside it the results of those two applicative values in a list. For instance, we have <code class="literal">Just 3</code> and <code class="literal">Just 4</code>. Let’s assume that the second one contains a singleton list, because that’s really easy to achieve:</p><a id="I_programlisting11_d1e21362"/><pre class="programlisting">ghci&gt; fmap (\x -&gt; [x]) (Just 4)
Just [4]</pre><p>Okay, so let’s say we have <code class="literal">Just 3</code> and <code class="literal">Just [4]</code>. How do we get <code class="literal">Just [3,4]</code>? That’s easy:</p><a id="I_programlisting11_d1e21375"/><pre class="programlisting">ghci&gt; liftA2 (:) (Just 3) (Just [4])
Just [3,4]
ghci&gt; (:) &lt;$&gt; Just 3 &lt;*&gt; Just [4]
Just [3,4]</pre><p>Remember that <code class="literal">:</code> is a function that takes an element and a list and returns a new list with that element at the beginning. Now that we have <code class="literal">Just [3,4]</code>, could we combine that with <code class="literal">Just 2</code> to produce <code class="literal">Just [2,3,4]</code>? Yes, we could. It seems that we can combine any amount of applicative values into one applicative value that has a list of the results of those applicative values inside it.</p><p>Let’s try implementing a function that takes a list of applicative values and returns an applicative value that has a list as its result value. We’ll call it <code class="literal">sequenceA</code>.</p><a id="I_programlisting11_d1e21397"/><pre class="programlisting">sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]
sequenceA [] = pure []
sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs</pre><p>Ah, recursion! First, we look at the type. It will transform a list of applicative values into an applicative value with a list. From that, we can lay some groundwork for a base case. If we want to turn an empty list into an applicative value with a list of results, we just put an empty list in a default context. Now comes the recursion. If we have a list with a head and a tail (remember that <code class="literal">x</code> is an applicative value and <code class="literal">xs</code> is a list of them), we call <code class="literal">sequenceA</code> on the tail, which results in an applicative value with a list inside. Then we just prepend the value inside the applicative <code class="literal">x</code> into that applicative with a list, and that’s it!</p><p>Suppose we do this:</p><a id="I_programlisting11_d1e21415"/><pre class="programlisting">sequenceA [Just 1, Just 2]}</pre><p>By definition, that’s equal to the following:</p><a id="I_programlisting11_d1e21419"/><pre class="programlisting">(:) &lt;$&gt; Just 1 &lt;*&gt; sequenceA [Just 2]</pre><p>Breaking this down further, we get this:</p><a id="I_programlisting11_d1e21423"/><pre class="programlisting">(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; sequenceA [])</pre><p>We know that <code class="literal">sequenceA []</code> ends up as being <code class="literal">Just []</code>, so this expression is now as follows:</p><a id="I_programlisting11_d1e21434"/><pre class="programlisting">(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; Just [])</pre><p>which is this:</p><a id="I_programlisting11_d1e21438"/><pre class="programlisting">(:) &lt;$&gt; Just 1 &lt;*&gt; Just [2]</pre><p>This equals <code class="literal">Just [1,2]</code>!</p><p>Another way to implement <code class="literal">sequenceA</code> is with a fold. Remember that pretty much any function where we go over a list element by element and accumulate a result along the way can be implemented with a fold:</p><a id="I_programlisting11_d1e21450"/><pre class="programlisting">sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]
sequenceA = foldr (liftA2 (:)) (pure [])</pre><p>We approach the list from the right and start off with an accumulator value of <code class="literal">pure []</code>. We put <code class="literal">liftA2 (:)</code> between the accumulator and the last element of the list, which results in an applicative that has a singleton in it. Then we call <code class="literal">liftA2 (:)</code> with the now last element and the current accumulator and so on, until we’re left with just the accumulator, which holds a list of the results of all the applicatives.</p><p>Let’s give our function a whirl on some applicatives:</p><a id="I_programlisting11_d1e21465"/><pre class="programlisting">ghci&gt; sequenceA [Just 3, Just 2, Just 1]
Just [3,2,1]
ghci&gt; sequenceA [Just 3, Nothing, Just 1]
Nothing
ghci&gt; sequenceA [(+3),(+2),(+1)] 3
[6,5,4]
ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
[]</pre><p>When used on <code class="literal">Maybe</code> values, <code class="literal">sequenceA</code> creates a <code class="literal">Maybe</code> value with all the results inside it as a list. If one of the values is <code class="literal">Nothing</code>, then the result is also a <code class="literal">Nothing</code>. This is cool when you have a list of <code class="literal">Maybe</code> values, and you’re interested in the values only if none of them is a <code class="literal">Nothing</code>.<a id="IDX-CHP-11-0067" class="indexterm"/><a id="IDX-CHP-11-0068" class="indexterm"/></p><p>When used with functions, <code class="literal">sequenceA</code> takes a list of functions and returns a function that returns a list. In our example, we made a function that took a number as a parameter and applied it to each function in the list and then returned a list of results. <code class="literal">sequenceA [(+3),(+2),(+1)] 3</code> will call <code class="literal">(+3)</code> with <code class="literal">3</code>, <code class="literal">(+2)</code> with <code class="literal">3</code>, and <code class="literal">(+1)</code> with <code class="literal">3</code>, and present all those results as a list.</p><p>Doing <code class="literal">(+) &lt;$&gt; (+3) &lt;*&gt; (*2)</code> will create a function that takes a parameter, feeds it to both <code class="literal">(+3)</code> and <code class="literal">(*2)</code>, and then calls <code class="literal">+</code> with those two results. In the same vein, it makes sense that <code class="literal">sequenceA [(+3),(*2)]</code> makes a function that takes a parameter and feeds it to all of the functions in the list. Instead of calling <code class="literal">+</code> with the results of the functions, a combination of <code class="literal">:</code> and <code class="literal">pure []</code> is used to gather those results in a list, which is the result of that function.</p><p>Using <code class="literal">sequenceA</code> is useful when we have a list of functions and we want to feed the same input to all of them and then view the list of results. For instance, suppose that we have a number and we’re wondering whether it satisfies all of the predicates in a list. Here’s one way to do that:</p><a id="I_programlisting11_d1e21559"/><pre class="programlisting">ghci&gt; map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
[True,True,True]
ghci&gt; and $ map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
True</pre><p>Remember that <code class="literal">and</code> takes a list of Booleans and returns <code class="literal">True</code> if they’re all <code class="literal">True</code>. Another way to achieve the same thing is with <code class="literal">sequenceA</code>:</p><a id="I_programlisting11_d1e21575"/><pre class="programlisting">ghci&gt; sequenceA [(&gt;4),(&lt;10),odd] 7
[True,True,True]
ghci&gt; and $ sequenceA [(&gt;4),(&lt;10),odd] 7
True</pre><p><code class="literal">sequenceA [(&gt;4),(&lt;10),odd]</code> creates a function that will take a number and feed it to all of the predicates in <code class="literal">[(&gt;4),(&lt;10),odd]</code> and return a list of Booleans. It turns a list with the type <code class="literal">(Num a) =&gt; [a -&gt; Bool]</code> into a function with the type <code class="literal">(Num a) =&gt; a -&gt; [Bool]</code>. Pretty neat, huh?</p><p>Because lists are homogenous, all the functions in the list must be functions of the same type. You can’t have a list like <code class="literal">[ord, (+3)]</code>, because <code class="literal">ord</code> takes a character and returns a number, whereas <code class="literal">(+3)</code> takes a number and returns a number.</p><p>When used with <code class="literal">[]</code>, <code class="literal">sequenceA</code> takes a list of lists and returns a list of lists. It actually creates lists that have all possible combinations of their elements. For illustration, here’s the preceding example done with <code class="literal">sequenceA</code> and then done with a list comprehension:</p><a id="I_programlisting11_d1e21612"/><pre class="programlisting">ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; [[x,y] | x &lt;- [1,2,3], y &lt;- [4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; [[x,y] | x &lt;- [1,2], y &lt;- [3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; sequenceA [[1,2],[3,4],[5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
ghci&gt; [[x,y,z] | x &lt;- [1,2], y &lt;- [3,4], z &lt;- [5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]</pre><p><code class="literal">(+) &lt;$&gt; [1,2] &lt;*&gt; [4,5,6]</code> results in a nondeterministic computation <code class="literal">x + y</code>, where <code class="literal">x</code> takes on every value from <code class="literal">[1,2]</code> and <code class="literal">y</code> takes on every value from <code class="literal">[4,5,6]</code>. We represent that as a list that holds all of the possible results. Similarly, when we call <code class="literal">sequenceA [[1,2],[3,4],[5,6]]</code>, the result is a nondeterministic computation <code class="literal">[x,y,z]</code>, where <code class="literal">x</code> takes on every value from <code class="literal">[1,2]</code>, <code class="literal">y</code> takes on every value from <code class="literal">[3,4]</code> and so on. To represent the result of that nondeterministic computation, we use a list, where each element in the list is one possible list. That’s why the result is a list of lists.<a id="IDX-CHP-11-0069" class="indexterm"/></p><p>When used with I/O actions, <code class="literal">sequenceA</code> is the same thing as <code class="literal">sequence</code>! It takes a list of I/O actions and returns an I/O action that will perform each of those actions and have as its result a list of the results of those I/O actions. That’s because to turn an <code class="literal">[IO a]</code> value into an <code class="literal">IO [a]</code> value, to make an I/O action that yields a list of results when performed, all those I/O actions must be sequenced so that they’re then performed one after the other when evaluation is forced. You can’t get the result of an I/O action without performing it.</p><p>Let’s sequence three <code class="literal">getLine</code> I/O actions:</p><a id="I_programlisting11_d1e21678"/><pre class="programlisting">ghci&gt; sequenceA [getLine, getLine, getLine]
heyh
ho
woo
["heyh","ho","woo"]</pre><p>In conclusion, applicative functors aren’t just interesting, they’re also useful. They allow us to combine different computations—such as I/O computations, nondeterministic computations, computations that might have failed, and so on—by using the applicative style. Just by using <code class="literal">&lt;$&gt;</code> and <code class="literal">&lt;*&gt;</code>, we can employ normal functions to uniformly operate on any number of applicative functors and take advantage of the semantics of each one.</p></div></body></html>