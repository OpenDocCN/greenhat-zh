- en: Part II-7. TCP/IP ROUTING PROTOCOLS (GATEWAY PROTOCOLS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2,
    AND RIPNG)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 39](ch39.html "Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 40](ch40.html "Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 41](ch41.html "Chapter 41. OTHER ROUTING PROTOCOLS")'
  prefs: []
  type: TYPE_NORMAL
- en: Routing is not just one of the most important activities that take place at
    the network layer; it is also the function that really *defines* layer 3 of the
    OSI Reference Model. Routing is what enables small local networks to be linked
    together to form potentially huge internetworks that can span cities, countries,
    or even the entire globe. The job of routing is done by special devices called
    *routers*, which forward datagrams from network to network, allowing any device
    to send to any other device, even if the source has no idea where the destination
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, an argument could be made that some routing protocols don't
    belong in layer 3\. For example, many of these protocols send messages using the
    Transmission Control Protocol (TCP) or User Datagram Protocol (UDP) at layer 4\.
    Despite this, routing is inherently a layer 3 activity, and for this reason, it
    is traditional to consider routing protocols part of layer 3.
  prefs: []
  type: TYPE_NORMAL
- en: Routing is a complicated subject. The short summary of the process is that routers
    decide how to forward a datagram based on its destination address, which is compared
    to information the router keeps in special routing tables. These tables contain
    entries for each of the networks the router knows about, telling the router which
    adjacent router the datagram should be sent to in order for it to reach its eventual
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, routing tables are critically important to the routing process.
    It is possible for these tables to be manually maintained by network administrators,
    but this is tedious and time-consuming and doesn't allow routers to deal with
    changes or problems in the internetwork. Instead, most modern routers are designed
    with functionality that lets them share route information with other routers,
    so they can keep their routing tables up-to-date automatically. This information
    exchange is accomplished through the use of *routing protocols*.
  prefs: []
  type: TYPE_NORMAL
- en: This part contains five chapters that provide a description of the most common
    routing (or *gateway*) protocols used in TCP/IP. The first chapter provides an
    overview of various concepts that are important to know in order to understand
    how routing protocols work, including an explanation of the difference between
    interior and exterior routing protocols. This sets the stage for the chapters
    that follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second and third chapters, I thoroughly explain the two most commonly
    used interior routing protocols in TCP/IP: the Routing Information Protocol (RIP)
    and the Open Shortest Path First (OSPF) protocol. In the fourth chapter, I describe
    the Border Gateway Protocol (BGP), which is the exterior routing protocol used
    today on the Internet. The fifth chapter briefly discussing five historical, proprietary,
    or less commonly used routing protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the title of this part refers to both *routing protocols*
    and *gateway protocols*. These terms are interchangeable, and the word *gateway*
    appears in the name of several of the protocols. This is an artifact of the historical
    use of the term *gateway* in early TCP/IP standards to refer to the devices we
    now call routers. Today, the term *gateway* normally refers not to a router, but
    to a different type of network interconnection device, so this can be particularly
    confusing. The term *routing protocol* is now preferred, and it is the one I use.
  prefs: []
  type: TYPE_NORMAL
- en: Like all topics related to routing, routing protocols are generally quite complex.
    I cover the major ones here in more detail than most general networking references,
    but even so, I am only scratching the surface, especially of the more complicated
    ones like OSPF. You can check out the referenced Internet standards (RFCs) for
    more details if you desire. Also note that there are some routing protocols in
    use on IP networks that I do not cover here, such as IS-IS (which is actually
    an OSI protocol and not formally part of TCP/IP).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Routing protocols play an important part in the overall process of routing in
    an internetwork. It is therefore easiest to understand them in the scope of an
    overall discussion of routing. It's difficult to describe the individual TCP/IP
    routing protocols without some background information on how routing protocols
    work. For this reason, I feel it is worth taking a brief look at key routing protocol
    concepts so that you will have more luck making sense of the routing protocols
    described in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will provide an overview of the routing protocol architectures,
    protocol types, algorithms, and metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Routing Protocol Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a look at routing protocol architectures. In this context,
    the word *architecture* refers to the way that an internetwork is structured.
    Once you have some networks and routers that you wish to connect together, there
    are any number of ways that you can do this. The architecture you choose is based
    on the way that routers are linked, and this has an impact on the way that routing
    is done and how routing protocols operate.
  prefs: []
  type: TYPE_NORMAL
- en: Core Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TCP/IP and the Internet were developed simultaneously, so TCP/IP routing protocols
    evolved as the Internet itself did. Early architecture of the Internet consisted
    of a small number of *core* routers that contained comprehensive information about
    the internetwork. When the Internet was very small, adding more routers to this
    core expanded it. However, each time the core was expanded, the amount of routing
    information that needed to be maintained grew.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, the core became too large, so a two-level hierarchy was formed to
    allow further expansion. *Noncore* routers were located on the periphery of the
    core and contained only partial routing information; they relied on the core routers
    for transmissions that went across the internetwork. A special routing protocol
    called the *Gateway-to-Gateway Protocol (GGP)* was used within the core of the
    internetwork, while another protocol called the *Exterior Gateway Protocol (EGP)*
    was used between noncore and core routers. The noncore routers were sometimes
    single, stand-alone routers that connected a single network to the core, or they
    could be sets of routers for an organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'This architecture served for a while, but it did not scale very well as the
    Internet grew. The problem was mainly due to the fact that there was only a single
    level to the architecture: Every router in the core had to communicate with every
    other router. Even with peripheral routers being kept outside the core, the amount
    of traffic in the core kept growing.'
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous System (AS) Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To resolve the scaling problem, a new architecture was created that moved away
    from the centralized concept of a core toward an architecture that was better
    suited to a larger and growing internetwork. This decentralized architecture treats
    the internetwork as a set of independent groups, with each group called an *autonomous
    system (AS)*. An AS consists of a set of routers and networks controlled by a
    particular organization or administrative entity, which uses a single consistent
    policy for internal routing.
  prefs: []
  type: TYPE_NORMAL
- en: The power of this system is that routing on the internetwork as a whole occurs
    between ASes and not individual routers. Information is shared between one and
    maybe a couple of routers in each AS, not every router in each AS. The details
    of routing within an AS are also hidden from the rest of the internetwork. This
    provides both flexibility for each AS to do routing as it sees fit (thus the name
    *autonomous*) and efficiency for the overall internetwork. Each AS has its own
    number, and the numbers are globally managed to make sure that they are unique
    across an internetwork (such as the Internet).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Large, modern TCP/IP internetworks can contain thousands of
    routers. To better manage routing in such an environment, routers are grouped
    into constructs called *autonomous systems (ASes)*, each of which consists of
    a group of routers managed independently by a particular organization or entity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern Protocol Types: Interior and Exterior Routing Protocols'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The different nature of routing within an AS and between ASes can be seen in
    the fact that the following distinct sets of TCP/IP routing protocols are used
    for each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interior Routing Protocols** These protocols are used to exchange routing
    information between routers within an AS. Interior routing protocols are not used
    between ASes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exterior Routing Protocols** These protocols are used to exchange routing
    information between ASes. They may in some cases be used between routers within
    an AS, but they primarily deal with exchanging information between ASes.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Interior routing protocols are used to share routing information
    within an autonomous system; each AS may use a different interior routing protocol
    because the system is, as the name says, autonomous. Exterior routing protocols
    convey routing data between ASes; each AS must use the same exterior protocol
    to ensure that it can communicate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since ASes are just sets of routers, you connect ASes by linking a router in
    one AS to a router in another AS. Architecturally, an AS consists of a set of
    routers with two different types of connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal Routers** Some routers in an AS connect only to other routers in
    the same AS. These run interior routing protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Border Routers** Some routers in an AS connect both to routers within the
    AS and to routers in one or more other ASes. These devices are responsible for
    passing traffic between the AS and the rest of the internetwork. They run both
    interior and exterior routing protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Due to its advantages, the AS architecture, an example of which can be seen
    in [Figure 37-1](ch37.html#tcpip_autonomous_system_as_routing_archi "Figure 37-1. TCP/IP
    autonomous system (AS) routing architecture This diagram shows a simplified Internet
    organized into three ASes, each of which is managed independently from the others.
    Communication within each AS is done using an interior routing protocol chosen
    by that AS's administrators (thin links). Communication between ASes must be done
    using a common exterior routing protocol (thick links). Internal routers are shown
    in lighter text, and border routers are shown in black text."), has become the
    standard for TCP/IP networks, most notably the Internet. The division of routing
    protocols into the interior and exterior classifications has thus also become
    standard, and all modern TCP/IP routing protocols are first subdivided by type
    in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: '![TCP/IP autonomous system (AS) routing architecture This diagram shows a simplified
    Internet organized into three ASes, each of which is managed independently from
    the others. Communication within each AS is done using an interior routing protocol
    chosen by that AS''s administrators (thin links). Communication between ASes must
    be done using a common exterior routing protocol (thick links). Internal routers
    are shown in lighter text, and border routers are shown in black text.](httpatomoreillycomsourcenostarchimages288027.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 37-1. TCP/IP autonomous system (AS) routing architecture This diagram
    shows a simplified Internet organized into three ASes, each of which is managed
    independently from the others. Communication within each AS is done using an interior
    routing protocol chosen by that AS's administrators (thin links). Communication
    between ASes must be done using a common exterior routing protocol (thick links).
    Internal routers are shown in lighter text, and border routers are shown in black
    text.
  prefs: []
  type: TYPE_NORMAL
- en: Routing Protocol Algorithms and Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another key differentiation of routing protocols is on the basis of the *algorithms*
    and *metrics* they use. An algorithm refers to a method that the protocol uses
    for determining the best route between any pair of networks, and for sharing routing
    information between routers. A metric is a measure of "cost" that is used to assess
    the efficiency of a particular route. Since internetworks can be quite complex,
    the algorithms and metrics of a protocol are very important, and they can be the
    determining factor in deciding that one protocol is superior to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two routing protocol algorithms that are most commonly encountered:
    distance vector and link state. There are also protocols that use a combination
    of these methods or other methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Distance-Vector (Bellman-Ford) Routing Protocol Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *distance-vector* routing algorithm, also called a *Bellman-Ford* algorithm
    after two of its inventors, is one where routes are selected based on the distance
    between networks. The distance metric is something simple—usually the number of
    *hops*, or routers, between them.
  prefs: []
  type: TYPE_NORMAL
- en: Routers using this type of protocol maintain information about the distance
    to all known networks in a table. They regularly send that table to each router
    they immediately connect with (their *neighbors* or *peers*). These routers then
    update their tables and send those tables to their neighbors. This causes distance
    information to propagate across the internetwork, so that eventually, each router
    obtains distance information about all networks on the internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: Distance-vector routing protocols are somewhat limited in their ability to choose
    the best route. They also are subject to certain problems in their operation that
    must be worked around through the addition of special heuristics and features.
    Their chief advantages are simplicity and history (they have been used for a long
    time).
  prefs: []
  type: TYPE_NORMAL
- en: Link-State (Shortest-Path First) Routing Protocol Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *link-state* algorithm selects routes based on a dynamic assessment of the
    shortest path between any two networks. For that reason, it's also called a *shortest-path
    first* method.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, each router maintains a map describing the current topology
    of the internetwork. This map is updated regularly by testing reachability of
    different parts of the Internet, and by exchanging link-state information with
    other routers. The determination of the best route (or shortest path) can be made
    based on a variety of metrics that indicate the true cost of sending a datagram
    over a particular route.
  prefs: []
  type: TYPE_NORMAL
- en: Link-state algorithms are much more powerful than distance-vector algorithms.
    They adapt dynamically to changing internetwork conditions, and they also allow
    routes to be selected based on more realistic metrics of cost than simply the
    number of hops between networks. However, they are more complicated to set up
    and use more computer processing resources than distance-vector algorithms, and
    they aren't as well established.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid Routing Protocol Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also hybrid protocols that combine features from both types of algorithms,
    and other protocols that use completely different algorithms. For example, the
    *Border Gateway Protocol (BGP)* is a path-vector algorithm, which is somewhat
    similar to the distance-vector algorithm, but communicates much more detailed
    route information. It includes some of the attributes of distance-vector and link-state
    protocols, but is more than just a combination of the two.
  prefs: []
  type: TYPE_NORMAL
- en: Static and Dynamic Routing Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, you may also occasionally see routing protocols categorized by type
    as *static* and *dynamic*. This terminology is somewhat misleading.
  prefs: []
  type: TYPE_NORMAL
- en: The term *static routing* simply refers to a situation where the routing tables
    are manually set up so that they remain static. In contrast, *dynamic routing*
    is the use of routing protocols to dynamically update routing tables. Thus, all
    routing protocols are dynamic. There is no such thing as a static routing protocol
    (unless you consider a network administrator who is editing a routing table a
    protocol).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The most popular of the TCP/IP interior routing protocols is the *Routing Information
    Protocol (RIP)*. The simplicity of the name matches the simplicity of the protocol.
    Of all the routing protocols, RIP is one of the easiest to configure and least
    demanding of resources. Its popularity is due both to this simplicity and its
    long history. In fact, support for RIP has been built into operating systems for
    as long as TCP/IP itself has existed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three versions of RIP: RIP versions 1 and 2 for IP version 4 (IPv4)
    and RIPng for IP version 6 (IPv6). The basic operation of the protocol is mostly
    the same for all three versions, but there are also some notable differences between
    them, especially in terms of the format of messages sent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RIP was one of the first interior routing protocols used in TCP/IP. More than
    20 years later, it continues to be widely used. Even though RIP has important
    limitations, it continues to have an important place in TCP/IP routing to this
    day. Evidence that RIP has a future can be seen in the creation of an IPv6 version
    of the protocol: RIPng.'
  prefs: []
  type: TYPE_NORMAL
- en: I will open the examination of RIP with an overall description of its characteristics
    and how it works in general terms. I start with an overview and history of the
    protocol, including a brief discussion of its different versions and the standards
    that define them. I describe the method that RIP uses to determine routes and
    the metric used to assess route cost. I describe the general operation of the
    protocol including message types and when they are sent. I then describe the most
    important limitations and issues with RIP, and the special features that have
    been added to the protocol to resolve several problems with the basic RIP algorithm.
    Finally, I take a closer look at each version, showing the message format used
    for each and discussing version-specific features as well.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RIP has been the most popular interior routing protocol in the TCP/IP protocol
    suite for many years. The history of the protocol and how it came to achieve prominence
    is a rather interesting one. Unlike many of the other important protocols in the
    TCP/IP suite, RIP was not first developed formally using the RFC standardization
    process (see [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS
    ORGANIZATIONS")). Rather, it evolved as a de facto industry standard and became
    an Internet standard later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The history of RIP has something in common with another networking heavyweight:
    Ethernet. Like that formidable local area network (LAN) technology, RIP''s roots
    go back to that computing pioneer, Xerox''s Palo Alto Research Center (PARC).
    At the same time that Ethernet was being developed for tying together LANs, PARC
    created a higher-layer protocol to run on Ethernet called the Xerox PARC Universal
    Protocol (PUP). PUP required a routing protocol, so Xerox created a protocol called
    the Gateway Information Protocol (GWINFO). This was later renamed the Routing
    Information Protocol and used as part of the Xerox Network System (XNS) protocol
    suite.'
  prefs: []
  type: TYPE_NORMAL
- en: RIP entered the mainstream when developers at the University of California at
    Berkeley adapted it for use in the Berkeley Standard Distribution (BSD) of the
    UNIX operating system. RIP first appeared in BSD version 4.2 in 1982, where it
    was implemented as the UNIX program *routed* (pronounced "route-dee," not "rout-ed"—the
    "d" stands for "daemon," a common UNIX term for a server process).
  prefs: []
  type: TYPE_NORMAL
- en: BSD was (and still is) a very popular operating system, especially for machines
    connected to the early Internet. As a result, RIP was widely deployed and became
    the industry standard for internal routing protocols. It was used both for TCP/IP
    and other protocol suites. In fact, a number of other routing protocols, such
    as the RTP protocol in the AppleTalk suite, were based on this early version of
    RIP.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Standardization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a while, the BSD implementation of routed was actually considered the standard
    for the protocol itself. However, this was not a formally defined standard, and
    this meant that there was no formal definition of exactly how it functioned. This
    led to slight differences in various implementations of the protocol over time.
    To resolve potential interoperability issues between implementations, the Internet
    Engineering Task Force (IETF) formally specified RIP in the Internet standard
    RFC 1058, "Routing Information Protocol," which was published in June 1988\. This
    RFC was based directly on the BSD routed program. This original version of RIP
    is now also sometimes called RIP version 1 or RIP-1 to differentiate it from later
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: RIP's popularity was due in large part to its inclusion in BSD, and it was included
    in BSD because of the relative simplicity of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Operational Overview, Advantages, and Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RIP uses the distance-vector algorithm to determine routes, as described in
    [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS").
    Each router maintains a routing table containing entries for various networks
    or hosts in the internetwork. Each entry contains two primary pieces of information:
    the address of the network or host and the distance to it, measured in hops, which
    is simply the number of routers that a datagram must pass through to get to its
    destination.'
  prefs: []
  type: TYPE_NORMAL
- en: On a regular basis, each router in the internetwork sends out its routing table
    in a special message on each of the networks to which it is connected, using the
    User Datagram Protocol (UDP). Other routers receive these tables and use them
    to update their own tables. This is done by taking each of the routes they receive
    and adding an extra hop. For example, if Router A receives an indication from
    Router B that Network N1 is four hops away, since Router A and Router B are adjacent,
    the distance from Router A to Network N1 is five. After a router updates its tables,
    it sends out this information to other routers on its local networks. Over time,
    routing distance information for all networks propagates over the entire internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: RIP is straightforward in operation, easy to implement, and undemanding of router
    processing power, which makes it especially attractive in smaller autonomous systems
    (ASes). There are, however, some important limitations that arise due to the simplicity
    of the protocol. For starters, hops are often not the best metric to use in selecting
    routes. There are also a number of problems that arise with the algorithm itself.
    These include slow convergence (delays in having all routers agree on the same
    routing information) and problems dealing with network link failures. RIP includes
    several special features to resolve some of these issues, but others are inherent
    limitations of the protocol. For example, RIP supports a maximum of only 15 hops
    between destinations, making it unsuitable for very large ASes, and this cannot
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: More than two decades after it was first created, RIP continues to be a popular
    interior routing protocol. Its limitations have led to many internetworking experts
    hoping that the protocol would eventually be replaced by newer protocols such
    as Open Shortest Path First (OSPF) that are superior on a strictly technical basis.
    Some have gone so far as to sarcastically suggest that maybe it would be best
    if RIP would R. I. P. Once a protocol becomes popular, however, it's hard to resist
    momentum, and RIP is likely to continue to be used for many years to come.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *Routing Information Protocol (RIP)* is one of the oldest
    and most popular interior routing protocols. With each router, it uses a distance-vector
    algorithm that maintains a table, which indicates how to reach various networks
    in the AS and the distance to it in hops. RIP is popular because it is well established
    and simple, but it has a number of important limitations.'
  prefs: []
  type: TYPE_NORMAL
- en: Development of RIP Version 2 (RIP-2) and RIPng for IPv6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some other issues with RIP came about as a result of the protocol having been
    developed in the early 1980s, when TCP/IP was still in its infancy. Over time,
    as the use of TCP/IP protocols changed, RIP became outdated. In response, *RIP
    version 2*, or *RIP-2* was created in the early 1990s.
  prefs: []
  type: TYPE_NORMAL
- en: RIP-2 defines a new message format for RIP and includes a number of new features,
    including support for classless addressing, authentication, and the use of multicasting
    instead of broadcasting, which improves network performance. It was first defined
    in RFC 1388, "RIP Version 2 Carrying Additional Information," published in January
    1993\. This RFC was revised in RFC 1723 and finalized in RFC 2453, "RIP Version
    2," published in November 1998.
  prefs: []
  type: TYPE_NORMAL
- en: In order to ensure that RIP can work with TCP/IP in the future, it was necessary
    to define a version that would work with the IPv6\. In 1997, RFC 2080 was published,
    titled "RIPng for IPv6." The *ng* stands for *next generation*; you'll recall
    that IPv6 is also sometimes called *IPng*.
  prefs: []
  type: TYPE_NORMAL
- en: '*RIPng* is not just a new version of RIP, like RIP-2, but is defined as a new
    stand-alone protocol. It is, however, based closely on the original RIP and RIP-2
    standards. A distinct protocol (as opposed to a revision of the original) was
    needed due to the changes made between IPv4 and IPv6, though RIP and RIPng work
    in the same basic way. RIPng is sometimes also called *RIPv6*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The original version of RIP has the fewest features and is
    now called *RIP-1*. *RIP-2* was created to add support for classless addressing
    and other capabilities. *RIPng* is the version created for compatibility with
    IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: RIP Route Determination Algorithm and Metric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the previous chapter, one of the defining characteristics
    of any routing protocol is the algorithm it uses for determining routes. RIP falls
    into the class of protocols that use a distance-vector, or Bellman-Ford, routing
    algorithm. To help you understand exactly how RIP determines routes, this section
    presents the specific implementation of the algorithm for RIP and provides an
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the description presented here is the basic algorithm used by RIP.
    This is modified in certain ways to address some of the problems that can occur
    in special circumstances due to how the algorithm works. Later in this chapter,
    we will explore these problems and the special features RIP includes to address
    them.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Routing Information and Route Distance Metric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The job of RIP, like any routing protocol, is to provide a mechanism for exchanging
    information about routes so routers can keep their routing tables up-to-date.
    Each router in an RIP internetwork keeps track in its routing table of all networks
    (and possibly individual hosts) in the internetwork. For each network or host,
    the device includes a variety of information, of which the following is the most
    important:'
  prefs: []
  type: TYPE_NORMAL
- en: The address of the network or host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance from that router to the network or host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first hop for the route: the device to which datagrams must first be sent
    to eventually get to the network or host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In theory, the distance metric can be any assessment of cost, but in RIP, distance
    is measured in hops. As you probably already know, in TCP/IP vernacular, a datagram
    makes a *hop* when it passes through a router. Thus, the RIP distance between
    a router and a network measures the number of routers that the datagram must pass
    through to get to the network. If a router connects to a network directly, then
    the distance is 1 hop. If it goes through a single router, the distance is 2 hops,
    and so on. In RIP, a maximum of 15 hops are allowed for any network or host. The
    value 16 is defined as infinity, so an entry with 16 in it means "this network
    or host is not reachable."
  prefs: []
  type: TYPE_NORMAL
- en: RIP Route Determination Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On a regular basis, each router running RIP will send out its routing table
    entries to provide information to other routers about the networks and hosts it
    knows how to reach. Any routers on the same network as the one sending out this
    information will be able to update their own tables based on the information they
    receive.
  prefs: []
  type: TYPE_NORMAL
- en: Any router that receives a message from another router on the same network saying
    it can reach Network X at a cost of *N* knows it can reach Network X at a cost
    of *N*+1 by sending to the router it received the message from.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Route Determination and Information Propagation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a specific example to help you understand how routes are determined
    and how route information is propagated using RIP. Consider a relatively simple
    internetwork with four individual networks, connected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Router RA connects Network N1 to Network N2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router RB and Router RC connect Network N2 to Network N3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router RD connects Network N3 to Network N4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sample AS is illustrated in [Figure 38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si
    "Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four
    physical networks and four routers.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample RIP AS This is an example of a simple AS that contains four physical
    networks and four routers.](httpatomoreillycomsourcenostarchimages288029.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four
    physical networks and four routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s suppose that we just turned on Router RA. It sees that it is directly
    connected to Network N1 and Network N2, so it will have an entry in its routing
    table indicating that it can reach Network N1 at a cost of 1, which we can represent
    as {N1,1}. Information about Network N1 will propagate from Router RA across the
    internetwork in the following sequence of steps (which are illustrated in [Figure 38-2](ch38s02.html#propagation_of_network_routing_informati
    "Figure 38-2. Propagation of network routing information using RIP This composite
    diagram illustrates the five steps in propagating route information about Network
    N1 from Router RA to the rest of the AS. In step 1, the information is sent from
    Router RA to both of its connected networks. In step 2, it reaches Routers RB
    and RC, which then know they can reach Network N1 through Router RA at a cost
    of one additional hop. In step 3, these two routers send this information on their
    networks, and in step 4, it reaches Router RD. In step 5, Router RD sends out
    the information, but no other routers are around to receive it.")):'
  prefs: []
  type: TYPE_NORMAL
- en: Router RA sends out an RIP message containing the entry {N1,1} on each of the
    networks to which it is connected. There are no other routers on Network N1, so
    nothing happens there. But Routers RB and RC are on Network N2, so they receive
    the information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routers RB and RC will look in their routing tables to see if they already have
    entries for Network N1\. Assuming neither does, they will each create a routing
    table entry {N1,2} for Router RA. This means, "I can reach Network N1 at a cost
    of 2 hops by sending to Router RA."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Routers RB and RC will each send their own routing tables out over the networks
    to which they are connected: Networks N2 and N3\. This will contain the entry
    {N1,2}. Router RA will receive that message on Network N2 but will ignore it,
    since it knows it can reach Network N1 directly (cost of 1, which is less than
    2). But Router RD will receive the message on Network N3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Router RD will examine its routing table, and seeing no entry for Network N1,
    it will add the entry {N1,3} for Routers RB or RC. Either one will work, so whichever
    is chosen depends entirely on whether Router RD received information about Network
    N1 first from Router RB or Router RC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Router RD will send the entry {N1,3} on Network N4, but there are no other routers
    there to hear it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that RIP is designed so that a routing entry is replaced only if information
    is received about a *shorter* route; ties go to the incumbent, if you will. This
    means that once Router RD creates an entry for Network N1 with a cost of 3 going
    through Router RB, if it receives information that it can reach Network N1 at
    the same cost of 3 through Router RC, it will ignore it. Similarly, if it gets
    Router RC's information first, it will ignore the information from Router RB.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, this same propagation scheme will occur for all the other networks
    as well. I have shown only how information about Network N1 moves from router
    to router. For example, Router RA will eventually install an entry for Network
    N4 saying that it is reachable at a cost of 3 going through either Router RB or
    RC; this will be either {N4,RB,3} or {N4,RC,3}.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Routing information is propagated between routers in RIP using
    a simple algorithm. On a regular basis, each router sends out RIP messages that
    specify which networks it can reach and how many hops it takes to reach them.
    Other routers directly connected to that one know that they can then reach those
    networks through that router at a cost of one additional hop. So if Router A sends
    a message saying it can reach Network X for a cost of *N* hops, every other router
    that connects directly to Router A can reach Network X for a cost of *N*+1 hops.
    It will put that information into its routing table, unless it knows of an alternate
    route through another router that has a lower cost.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Propagation of network routing information using RIP This composite diagram
    illustrates the five steps in propagating route information about Network N1 from
    Router RA to the rest of the AS. In step 1, the information is sent from Router
    RA to both of its connected networks. In step 2, it reaches Routers RB and RC,
    which then know they can reach Network N1 through Router RA at a cost of one additional
    hop. In step 3, these two routers send this information on their networks, and
    in step 4, it reaches Router RD. In step 5, Router RD sends out the information,
    but no other routers are around to receive it.](httpatomoreillycomsourcenostarchimages288031.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-2. Propagation of network routing information using RIP This composite
    diagram illustrates the five steps in propagating route information about Network
    N1 from Router RA to the rest of the AS. In step 1, the information is sent from
    Router RA to both of its connected networks. In step 2, it reaches Routers RB
    and RC, which then know they can reach Network N1 through Router RA at a cost
    of one additional hop. In step 3, these two routers send this information on their
    networks, and in step 4, it reaches Router RD. In step 5, Router RD sends out
    the information, but no other routers are around to receive it.
  prefs: []
  type: TYPE_NORMAL
- en: This propagation of network routing information occurs on a regular basis, and
    also when the structure of the network changes (due to intentional changes in
    topography or failure of links or routers). When this happens, the change information
    will move through the internetwork so that all routers are eventually updated.
    For example, suppose a connection were added from Router RC to Network N1\. If
    Router RD previously had the entry {N1,RB,3}, it would eventually change this
    to {N1,RC,2}, since it could now reach Network N1 more quickly by going through
    Router RC.
  prefs: []
  type: TYPE_NORMAL
- en: Default Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, it is not convenient for every network or host in a large internetwork
    to be fully specified with its own routing entry. Then it may be advantageous
    to specify a default route for the network to use in reaching hosts or networks
    for which they have no information. The most common example of this is when an
    AS connects to the public Internet through a single router. Except for that router,
    the rest of the local network doesn't need to know how to access the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: In RIP, information about a default route is communicated by having routers
    that are intended to handle such traffic send information about a "dummy" network
    with the address 0.0.0.0\. This is treated as if it were a regular network when
    information about routes is propagated on the internetwork using RIP messages,
    but other devices recognize this special address and understand that it means
    a default route.
  prefs: []
  type: TYPE_NORMAL
- en: RIP General Operation, Messaging, and Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RIP is a protocol for exchanging routing information, so its operation can best
    be described in terms of the messages used to exchange this information and the
    rules for when messages are sent. The RIP software in each router sends messages
    and takes other actions both in reaction to certain events and in response to
    triggers set off by timers. Timers are also used to determine when routing information
    should be discarded if it is not updated.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Messages and Basic Message Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Communication between RIP software elements in routers on an internetwork is
    accomplished through the use of *RIP messages*. These messages are sent using
    the UDP, with the UDP port number 520 reserved for RIP-1 and RIP-2, and 521 for
    RIPng. Thus, even though RIP is considered part of layer 3 like other routing
    protocols, it behaves more like an application in terms of how it sends messages.
    The exact format of the message is version-dependent, and all three formats (RIP,
    RIP-2, and RIPng) are described in detail later in this chapter. RIP messages
    can be either sent to a specific device or sent out for multiple devices to receive.
    If directed to one device, they are sent unicast; otherwise, they are either broadcast
    (in RIP) or multicast (RIP-2 and RIPng).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two basic message types for all three versions of RIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RIP Request** A message sent by a router to another router asking it to send
    back all or part of its routing table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RIP Response** A message sent by a router containing all or part of its routing
    table. Note that despite the name, this message is *not* sent just in response
    to an RIP Request message, as you will see.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The original RIP also defined a few other message types: Traceon, Traceoff,
    and a special message type reserved for use by Sun Microsystems. These are obsolete
    and no longer used. They were removed from the RIP-2 and RIPng standards*.'
  prefs: []
  type: TYPE_NORMAL
- en: RIP Update Messaging and the 30-Second Timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RIP Request messages are sent under special circumstances when a router requires
    that it be provided with immediate routing information. The most common example
    of this is when a router is first powered on. After initializing, the router will
    typically send an RIP Request message on its attached networks to ask for the
    latest information about routes from any neighboring routers. It is also possible
    for RIP Request messages to be used for diagnostic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: A router receiving an RIP Request message will process it and send an RIP Response
    message containing either all of its routing table or just the entries the Request
    message asked for, as appropriate. Under normal circumstances, however, routers
    do not usually send RIP Request messages asking specifically for routing information.
    Instead, each RIP router has a special timer that goes off every 30 seconds. (This
    timer is not given a specific name in the RIP standards; it is just the 30-second
    timer.)
  prefs: []
  type: TYPE_NORMAL
- en: Each time the timer expires, an unsolicited (unrequested) broadcast or multicast
    is made of an RIP Response message containing the router's entire routing table.
    The timer is then reset, and 30 seconds later, it goes off again, causing another
    routine RIP Response message to be sent. This process ensures that route information
    is regularly sent around the Internet, so routers are always kept up-to-date about
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** RIP uses two basic message types: the RIP Request and RIP Response.
    Both are sent using the User Datagram Protocol (UDP). RIP Response messages, despite
    their name, are used both for routine periodic routing table updates as well as
    to reply to RIP Request messages. Requests are sent only in special circumstances,
    such as when a router first joins a network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Preventing Stale Information: The Timeout Timer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a router receives routing information and enters it into its routing table,
    that information cannot be considerd valid indefinitely. In the example presented
    earlier in the "RIP Route Determination and Information Propagation" section,
    suppose that after Router RB installs a route to Network N1 through Router RA,
    the link between Router RA and Network N2 fails. Once this happens, Network N1
    is no longer reachable from Router RB, but Router RB has a route indicating that
    it can reach Network N1.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this problem, routes are kept in the routing table for only a limited
    amount of time. A special Timeout timer is started whenever a route is installed
    in the routing table. Whenever the router receives another RIP Response message
    with information about that route, the route is considered refreshed, and its
    Timeout timer is reset. As long as the route continues to be refreshed, the timer
    will never expire.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, RIP Response messages containing that route stop arriving, the
    timer will eventually expire. When this happens, the route is marked for deletion
    by setting the distance for the route to 16 (which you may recall is RIP infinity
    and indicates an unreachable network). The default value for the Timeout timer
    is usually 180 seconds. This allows several periodic updates of a route to be
    missed before a router will conclude that the route is no longer reachable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing Stale Information: The Garbage-Collection Timer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a route is marked for deletion, a new Garbage-Collection timer is also
    started. *Garbage collection* is a computer-industry phrase for a task that looks
    for deleted or invalid information and cleans it up. Thus, this is a timer that
    counts a number of seconds before the newly invalid route will be actually removed
    from the table. The default value for this timer is 120 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using this two-stage removal method is to give the router that
    declared the route that's no longer reachable a chance to propagate this information
    to other routers. Until the Garbage-Collection timer expires, the router will
    include that route, with the unreachable metric of 16 hops, in its own RIP Response
    messages, so that the problem with that route is conveyed to the other routers.
    When the timer expires, the route is deleted. If during the garbage collection
    period a new RIP Response message for the route is received, then the deletion
    process is aborted. In this case, the Garbage-Collection timer is cleared, the
    route is marked as valid again, and a new Timeout timer starts.
  prefs: []
  type: TYPE_NORMAL
- en: Triggered Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the two situations already described where an RIP Response is
    sent—in reply to an RIP Request message and on expiration of the 30-second timer—an
    RIP Response message is also sent out when a route changes.
  prefs: []
  type: TYPE_NORMAL
- en: This action, an enhancement to a basic RIP operation, called a *triggered update*,
    is intended to ensure that information about route changes is propagated as fast
    as possible across the internetwork. This will help reduce the slow convergence
    problem in RIP. For example, in the case of a route timing out and the Garbage-Collection
    timer starting, a triggered update would be sent out about the now-invalid route
    immediately. This is described in more detail later in the chapter, in the "RIP
    Special Features for Resolving RIP Algorithm Problems" section.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Problems and Some Resolutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplicity of RIP is often given as the main reason for its popularity.
    Simplicity is great most of the time, but an unfortunate price of simplicity in
    too many cases is that problems crop up, usually in unusual cases or special situations,
    and so it is with RIP. The straightforward distance-vector algorithm and operation
    mechanism work well most of the time, but they have some important weaknesses.
    We need to examine these problems to understand both the limitations of RIP and
    some of the complexities that have been added to the protocol to resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with RIP's Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important area where we find serious issues with RIP is with the basic
    function of the distance-vector algorithm described earlier in this section and
    the way that messages are used to implement it, as described in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Slow Convergence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The distance-vector algorithm is designed so that all routers share all their
    routing information regularly. Over time, all routers eventually end up with the
    same information about the location of networks and which are the best routes
    to use to reach them. This is called *convergence*. Unfortunately, the basic RIP
    algorithm is rather slow to achieve convergence. It takes a long time for all
    routers to get the same information, and in particular, it takes a long time for
    information about topology changes to propagate.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the worst-case situation of two networks separated by 15 routers. Since
    routers normally send RIP Response messages only every 30 seconds, a change to
    one of this pair of networks might not be seen by the router nearest to the other
    one until many minutes have elapsed—an eternity in networking terms.
  prefs: []
  type: TYPE_NORMAL
- en: The slow convergence problem is even more pronounced when it comes to the propagation
    of route failures. Failure of a route is detected only through the expiration
    of the 180-second Timeout timer, so that adds up to three minutes more delay before
    convergence can even begin.
  prefs: []
  type: TYPE_NORMAL
- en: Routing Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A routing loop occurs when Router A has an entry telling it to send datagrams
    for Network 1 to Router B, and Router B has an entry saying that datagrams for
    Network 1 should be sent to Router A. Larger loops can also exist: Router A says
    to send to B, which says to send to Router C, which says to send to Router A.
    Under normal circumstances, these loops should not occur, but they can happen
    in special situations.'
  prefs: []
  type: TYPE_NORMAL
- en: RIP does not include any specific mechanism to detect or prevent routing loops.
    The best it can do is try to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Counting to Infinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A special case of slow convergence can lead to a routing loop situation where
    one router passes bad information to another router, which sends more bad information
    to another router, and so on. This causes a situation where the protocol is sometimes
    described as unstable. The problem is called *counting to infinity*, for reasons
    you will soon see.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this happens, let's modify the example presented earlier in
    the "RIP Route Determination and Information Propagation" section, as shown in
    [Figure 38-3](ch38s04.html#the_rip_counting_to_infinity_problem_thi "Figure 38-3. The
    RIP counting to infinity problem This composite diagram shows part of the AS illustrated
    previously in Figure 38-1\. The top panel (1) shows the normal state of the network,
    with Router RB able to reach Network N1 through Router RA at a cost of 2\. In
    panel 2, the link between Router RA and Network N1 is broken. Router RA changes
    its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before Router RA
    can send out this update to Router RB, it receives a routine RIP message from
    Router RB indicating that Network N1 can be reached for a cost of 2\. Router RA
    is then fooled into thinking that it can use Router RB as an alternate route to
    Network N1, even though Router RB's information originally came from Router RA
    in the first place. In panel 4, Router RA then sends this bogus information out,
    which is received by Router RB in panel 5\. Router RB then increases its cost
    to 4, and on its next cycle will send this to Router RA, which will increase its
    cost to 5, and so on. This cycle will continue, with both routers "counting to
    infinity" (cost of 16)."). Suppose that the internetwork is operating properly
    for a while. Router RB has an entry indicating it can reach Network N1 through
    Router RA at a cost of 2\. But let's say the link from Network N1 to Router RA
    fails. After the Timeout timer for Network N1 expires on Router RA, that router
    will change the metric for Network N1 to 16 to indicate that it is unreachable.
    In the absence of any mechanism to force Router RA to immediately inform other
    routers of this failure, those routers will not know about the change. Router
    RB will continue to think it can reach Network N1 through Router RA.
  prefs: []
  type: TYPE_NORMAL
- en: '![The RIP counting to infinity problem This composite diagram shows part of
    the AS illustrated previously in . The top panel (1) shows the normal state of
    the network, with Router RB able to reach Network N1 through Router RA at a cost
    of 2\. In panel 2, the link between Router RA and Network N1 is broken. Router
    RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before
    Router RA can send out this update to Router RB, it receives a routine RIP message
    from Router RB indicating that Network N1 can be reached for a cost of 2\. Router
    RA is then fooled into thinking that it can use Router RB as an alternate route
    to Network N1, even though Router RB''s information originally came from Router
    RA in the first place. In panel 4, Router RA then sends this bogus information
    out, which is received by Router RB in panel 5\. Router RB then increases its
    cost to 4, and on its next cycle will send this to Router RA, which will increase
    its cost to 5, and so on. This cycle will continue, with both routers "counting
    to infinity" (cost of 16).](httpatomoreillycomsourcenostarchimages288033.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-3. The RIP counting to infinity problem This composite diagram shows
    part of the AS illustrated previously in [Figure 38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si
    "Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four
    physical networks and four routers."). The top panel (1) shows the normal state
    of the network, with Router RB able to reach Network N1 through Router RA at a
    cost of 2\. In panel 2, the link between Router RA and Network N1 is broken. Router
    RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before
    Router RA can send out this update to Router RB, it receives a routine RIP message
    from Router RB indicating that Network N1 can be reached for a cost of 2\. Router
    RA is then fooled into thinking that it can use Router RB as an alternate route
    to Network N1, even though Router RB's information originally came from Router
    RA in the first place. In panel 4, Router RA then sends this bogus information
    out, which is received by Router RB in panel 5\. Router RB then increases its
    cost to 4, and on its next cycle will send this to Router RA, which will increase
    its cost to 5, and so on. This cycle will continue, with both routers "counting
    to infinity" (cost of 16).
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose Router RB's regular 30-second timer goes off before Router RA's
    next broadcast. Router RB will send its normal routing table, *which contains
    a route to Network N1 at a cost of 2*. Router RA will see this and say, "Hey look,
    Router RB has a route to Network N1 with a cost of 2! That means I can get there
    with a cost of 3, which sure beats my current cost of 16\. Let's use that!" So
    Router RA installs this route and cancels its Timeout timer. Of course, this is
    bogus information—Router RA doesn't realize that Router RB's claim of being able
    to reach Network N1 was based on old information from Router RA itself!
  prefs: []
  type: TYPE_NORMAL
- en: It only gets worse from there. When it is time for Router RA's regular routing
    table update, it will broadcast a route to Network N1 with a cost of 3\. Now Router
    RB will see this and say, "Well, my route to Network N1 is through Router RA.
    Router RA was saying before that its cost was 1; but now it says the cost is 3\.
    That means I have to change my cost to 4."
  prefs: []
  type: TYPE_NORMAL
- en: Router RB will later send back to Router RA, and back and forth they will go,
    each incrementing the cost two at a time. This won't stop until the value of infinity
    cost of 16 is hit—thus the name counting to infinity. At this point, both routers
    will finally agree that Network N1 is unreachable, but as you can see, it takes
    a long time for it to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Small Infinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of a relatively small value for the infinity cost limits the slow convergence
    problem. Even in a situation where we count to infinity, the total amount of time
    elapsed is at least manageable. (Imagine if infinity were defined as say, 1,000!)
    Unfortunately, the drawback of this is that it limits the size of the internetwork
    that can be used for RIP.
  prefs: []
  type: TYPE_NORMAL
- en: Many people balk at the limit of a span of 15 routers in RIP, but to be honest
    I think it is much ado about, well, if not nothing, then nothing much. The 15
    value is not a limit on the total number of routers you can use, but rather a
    limit on the number of routers between any two networks. Consider that most internetworks
    are set up hierarchically. Even if you have a rather complex four-level hierarchy,
    you wouldn't be close to the 15-router limit. In fact, you could create a huge
    AS with thousands of routers, without having more than 15 routers between any
    two devices. So this is a limitation for only the very largest of ASes.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, RIP's need to send out its entire routing table many times
    each hour makes it a potentially poor choice for a large internetwork regardless
    of the infinity=16 issue. In an internetwork with many routers, the amount of
    traffic RIP generates can become excessive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the most important problems with the operation of RIP
    is slow convergence, which describes the fact that it can take a long time for
    information about changes to a network to propagate between routers. One specific
    instance of this problem is the counting to infinity problem, in which out-of-date
    information causes many bogus RIP messages to be exchanged between routers about
    an unreachable network.'
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, these problems are mostly general to distance-vector routing algorithms
    and not RIP in particular. Some of them are corrected through the implementation
    of specific changes to the algorithm or the rules under which RIP messages are
    sent, as described in the next section. According to RFC 2453, there was actually
    a proposal to increase RIP's infinity cost to a number larger than 16, but this
    would have caused compatibility problems with older devices (which would view
    any route with a metric of 16 or higher as unreachable), so it was rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with RIP's Metric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to these concerns with the algorithm itself, RIP is also often criticized
    because of its choice of metric. The first issue here is RIP's use of hop count
    as a distance metric. Simply put, hop count is a poor metric of the cost of sending
    a datagram between two networks. I believe the use of hop count as the metric
    in RIP is partially due to the desire for simplicity (it's easy to make the protocol
    work when hop count is all the routers need to consider). But the use of hop count
    is also partially an artifact of RIP being around for more than 20 years.
  prefs: []
  type: TYPE_NORMAL
- en: Decades ago, computers were slow, so each time a datagram passed through a router
    there was probably a significant delay. Hop count was not a perfect metric even
    then, but I think it had more correspondence with how long it took to move a datagram
    across an internetwork than it does today.
  prefs: []
  type: TYPE_NORMAL
- en: Modern routers are lightning fast, making hop count a flawed way of measuring
    network distance. The number of hops taken often has no correlation with the actual
    amount of time it takes to move data across a route. To take an extreme case,
    consider two networks that are connected by a direct dial-up telephone networking
    link using 56K modems. Let's say they are also connected by a sequence of three
    routers using high-speed DS-3 lines. RIP would consider the 56K link a better
    route because it has fewer hops, even though it clearly is much slower.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is RIP's lack of support for dynamic (real-time) metrics. Even
    if RIP were to use a more meaningful metric than hop count, the algorithm requires
    that the metric should be fixed for each link. There is no way to have RIP calculate
    the best route based on real-time data about various links the way protocols like
    OSPF do (see [Chapter 39](ch39.html "Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)")).
  prefs: []
  type: TYPE_NORMAL
- en: Most of these problems are built into RIP and cannot be resolved. Interestingly,
    some RIP implementations apparently do let administrators "fudge" certain routes
    to compensate for the limitations of the hop count metric. For example, the routers
    on either end of the 56K link mentioned earlier could be configured so that they
    considered the 56K link to have a hop count of ten instead of one. This would
    cause any routes using the link to be more expensive than the DS-3 path. This
    is clever, but hardly an elegant or general solution.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in addition to the rather long list of problems that I've mentioned,
    there were also some specific issues with the first version of RIP. Some of the
    more important of these include lack of support for Classless Inter-Domain Routing
    (CIDR), lack of authentication, and a performance reduction caused by the use
    of broadcasts for messaging. These were mostly addressed through extensions in
    RIP-2.
  prefs: []
  type: TYPE_NORMAL
- en: RIP Special Features for Resolving RIP Algorithm Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplicity of RIP is its most attractive quality, but as you just saw, this
    leads to certain problems with how it operates. Most of these limitations are
    related to the basic algorithm used for determining routes, and the method of
    message passing that's being used to implement the algorithm. In order for RIP
    to be a useful protocol, some of these issues needed to be addressed, in the form
    of changes to the basic RIP algorithm and operational scheme we explored earlier
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to problems that arise due to RIP being too simple is to add complexity
    in the form of features that add more intelligence to the way that RIP operates.
    In the following sections, we''ll take a look at four of these: *split horizon*,
    *split horizon with poisoned reverse*, *triggered updates*, and *hold down*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while I describe these as "features," at least some of them are really
    necessary to ensure the proper RIP functionality. Therefore, they are generally
    considered standard parts of RIP, and most were described even in the earliest
    RIP documents. However, sometimes performance or stability issues may arise when
    these techniques are used, especially in combination. For this reason different
    RIP implementations may omit some features. For example, hold down slows down
    route recovery and may not be needed when other features such as split horizon
    are used. As always, care must be taken to ensure that all routers are using the
    same features, or even greater problems may arise.
  prefs: []
  type: TYPE_NORMAL
- en: Also, see the upcoming section on RIP-2's specific features, later in this chapter,
    for a description of the Next Hop feature, which helps reduce convergence and
    routing problems when RIP is used.
  prefs: []
  type: TYPE_NORMAL
- en: Split Horizon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The counting to infinity problem is one of the most serious issues with the
    basic RIP algorithm. In the example in the previous section, the cause of the
    problem is immediately obvious: After Network N1 fails and Router RA notices it
    go down, Router RB "tricks" Router RA into thinking it has an alternate path to
    Network N1 by sending Router RA a route advertisement to Network N1.'
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, it doesn't really make sense under *any* circumstances
    to have Router RB send an advertisement to Router RA about a network that Router
    RB can access only through Router RA in the first place. In the case where the
    route fails, it causes this problem, which is obviously a good reason not do it.
    But even when the route is operational, what is the point of Router RB telling
    Router RA about it? Router RA already has a shorter connection to the network
    and will therefore never send traffic intended for Network N1 to Router RB anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, the best solution is simply to have Router RB not include any mention
    of the route to Network N1 in any RIP Response messages it sends to Router RA.
    We can generalize this by adding a new rule to RIP operation: When a router sends
    out an RIP Response message on any of the networks to which it is connected, it
    omits any route information that it originally learned from that network. This
    feature is called *split horizon*, because the router effectively splits its view
    of the internetwork, sending different information on certain links than on others.'
  prefs: []
  type: TYPE_NORMAL
- en: With this new rule, let's consider the behavior of Router RB. It has an interface
    on Network N2, which it shares with Router RA. It will therefore not include any
    information on routes it originally obtained from Router RA when sending on Network
    N2\. This will prevent the counting to infinity loop you saw in the previous section.
    Similarly, because Router RD is on Network N3, Router RB will not send any information
    about routes it got from Router RD when sending on Network N3.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that split horizon may not always solve the counting to infinity
    problem, especially in the case where multiple routers are connected indirectly.
    The classic example would be three routers configured in a triangle. In this situation,
    problems may still result due to data that is propagated in two directions between
    any two routers. In this case, the hold down feature, described shortly, may be
    of assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Split Horizon with Poisoned Reverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding "poisoned reverse" provides an enhancement of the basic split horizon
    feature. Instead of omitting routes learned from a particular interface when sending
    RIP Response messages on that interface, we include those routes but set their
    metric to RIP infinity, or 16\. So in the previous example, Router RB *would*
    include the route to Network N1 in its transmissions on Network N2, but it would
    say the cost to reach Network N1 was 16 instead of its real cost (which is 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *poisoned reverse* refers to the fact that we are poisoning the routes
    that we want to make sure routers on that interface don''t use. Router RA will
    see Router RB advertise Network N1 but with a cost of 16, which serves as an explicit
    message to Router RA: "There is absolutely no way for you to get to Network N1
    through Router RB." This provides more insurance than the regular split horizon
    feature, because if the link from Router RA to Network N1 is broken, Router RA
    will know for certain that it can''t try to get a new route through Router RB.
    [Figure 38-4](ch38s04.html#rip_problem_solving_using_split_horizon_ "Figure 38-4. RIP
    problem solving using split horizon with poisoned reverse The top panel in this
    diagram (1) shows the same example as in Figure 38-3\. In panel 2, as before,
    the link between Router RA and Network N1 is broken, just as Router RB is ready
    to send out its routine update. However, the split horizon with poisoned reverse
    feature means it sends different messages on its two links. On the network that
    connects it to Router RA, it sends a route advertisement with a cost of 16\. In
    panel 3, Router RA receives this, which it will discard, ensuring no counting
    to infinity problem occurs. On Router RA''s next cycle, it will update Router
    RB to tell it that Network N1 is no longer reachable.") shows how split horizon
    with poisoned reverse works.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique also works in normal circumstances (meaning when there is no
    issue such as a broken link to a network). In that case, Router RA will receive
    updates from Router RB with a cost of 16 on a periodic basis, but Router RA will
    never try to reach Network N1 through Router RB anyway, since it is directly connected
    to Network N1 (cost of 1).
  prefs: []
  type: TYPE_NORMAL
- en: Triggered Updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The routing loop problem we looked at earlier in this chapter occurred because
    Router RB advertised Router RA''s route back to Router RA. There''s another aspect
    of the problem that is also significant: After Router RA discovered that the link
    to Network N1 failed, it had to wait up to 30 seconds until its next scheduled
    transmission time to tell other routers about the failure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For RIP to work well, when something significant happens, we want to tell other
    routers on the internetwork immediately. For this reason, a new rule should be
    added to the basic RIP router operation: Whenever a router changes the metric
    for a route it is required to (almost) immediately send out an RIP Response message
    to tell its immediate neighbor routers about the change. If these routers, seeing
    this change, update their routing information, they are in turn required to send
    out updates. Thus, the change of any network route information causes cascading
    updates to be sent throughout the internetwork, significantly reducing the slow
    convergence problem. Note that this includes the removal of a route due to expiration
    of its Timeout timer, since the first step in route removal is setting the route''s
    metric to 16, which triggers an update.'
  prefs: []
  type: TYPE_NORMAL
- en: '![RIP problem solving using split horizon with poisoned reverse The top panel
    in this diagram (1) shows the same example as in . In panel 2, as before, the
    link between Router RA and Network N1 is broken, just as Router RB is ready to
    send out its routine update. However, the split horizon with poisoned reverse
    feature means it sends different messages on its two links. On the network that
    connects it to Router RA, it sends a route advertisement with a cost of 16\. In
    panel 3, Router RA receives this, which it will discard, ensuring no counting
    to infinity problem occurs. On Router RA''s next cycle, it will update Router
    RB to tell it that Network N1 is no longer reachable.](httpatomoreillycomsourcenostarchimages288035.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-4. RIP problem solving using split horizon with poisoned reverse The
    top panel in this diagram (1) shows the same example as in [Figure 38-3](ch38s04.html#the_rip_counting_to_infinity_problem_thi
    "Figure 38-3. The RIP counting to infinity problem This composite diagram shows
    part of the AS illustrated previously in Figure 38-1\. The top panel (1) shows
    the normal state of the network, with Router RB able to reach Network N1 through
    Router RA at a cost of 2\. In panel 2, the link between Router RA and Network
    N1 is broken. Router RA changes its cost to reach Network N1 to 16 (RIP infinity).
    In panel 3, before Router RA can send out this update to Router RB, it receives
    a routine RIP message from Router RB indicating that Network N1 can be reached
    for a cost of 2\. Router RA is then fooled into thinking that it can use Router
    RB as an alternate route to Network N1, even though Router RB's information originally
    came from Router RA in the first place. In panel 4, Router RA then sends this
    bogus information out, which is received by Router RB in panel 5\. Router RB then
    increases its cost to 4, and on its next cycle will send this to Router RA, which
    will increase its cost to 5, and so on. This cycle will continue, with both routers
    "counting to infinity" (cost of 16)."). In panel 2, as before, the link between
    Router RA and Network N1 is broken, just as Router RB is ready to send out its
    routine update. However, the split horizon with poisoned reverse feature means
    it sends different messages on its two links. On the network that connects it
    to Router RA, it sends a route advertisement with a cost of 16\. In panel 3, Router
    RA receives this, which it will discard, ensuring no counting to infinity problem
    occurs. On Router RA's next cycle, it will update Router RB to tell it that Network
    N1 is no longer reachable.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed that I said that triggered updates were sent "almost" immediately.
    In fact, before sending a triggered update a route waits a random amount of time,
    from 1 to 5 seconds. This is done to reduce the load on the internetwork that
    would result from many routers sending update messages nearly simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Hold Down
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Split horizon tries to solve the counting to infinity problem by suppressing
    the transmission of invalid information about routes that fail. For extra insurance,
    we can implement a feature that changes how devices receiving route information
    process it in the case of a failed route. The *hold down* feature works by having
    each router start a timer when it first receives information about a network that
    is unreachable. Until the timer expires, the router will discard any subsequent
    route messages that indicate that the route is in fact reachable. A typical Hold
    Down timer runs for 60 or 120 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this technique is that a router won't be confused by receiving
    spurious information about a route being accessible when it was just recently
    told that the route was no longer valid. It provides a period of time for out-of-date
    information to be flushed from the system, which is valuable especially on complex
    internetworks. Adding hold down to split horizon can also help in situations where
    split horizon alone is insufficient for preventing counting to infinity, such
    as when a trio of routers are linked in a triangle, as discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The main disadvantage of hold down is that it forces a delay in a router responding
    to a route once it is fixed. Suppose that a route went down for just five seconds
    for some reason. After the network is up again, routers will want to again know
    about this. However, the Hold Down timer must expire before the router will try
    to use that network again. This makes internetworks using hold down relatively
    slow to respond to corrected routes, and it could lead to delays in accessing
    networks that fail intermittently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Four special features represent changes to RIP operation that
    ameliorate or eliminate the problems with the operation of the basic protocol.
    *Split horizon* and *split horizon with poisoned reverse* prevent a router from
    sending invalid route information back to the router from which it originally
    learned the route. *Triggered updates* reduce the slow convergence problem by
    causing the immediate propagation of changed route information. Finally, the *hold
    down* feature may be used to provide robustness when information about a failed
    route is received.'
  prefs: []
  type: TYPE_NORMAL
- en: RIP Version-Specific Message Formats and Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I've noted, RIP has been in widespread use for more than two decades. During
    that time, internetworks and internetworking technologies have changed. To keep
    up with the times, RIP has also evolved and today has three different versions.
    The basic operation of all three is fairly similar, and it was described in the
    previous sections of this chapter. As you might expect, there are also some differences
    between the versions. One of the more important of these is the format used for
    RIP messages in each version, and the meaning and use of the fields within that
    format.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to take a look at the message format used by each of the three
    versions of RIP as well as certain specific features not common to all versions.
    I begin with the original RIP, now also known as *RIP version 1*. I then describe
    the updated version of RIP called *RIP version 2* or *RIP-2*. Finally, I discuss
    *RIPng*, also sometimes called *RIPv6*; it's the version of RIP used for IPv6\.
    (Note that this is not technically a new version of the original RIP but a new
    protocol closely based on the earlier RIP versions.)
  prefs: []
  type: TYPE_NORMAL
- en: RIP Version 1 (RIP-1) Message Format and Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RIP evolved as an industry standard and was popularized by its inclusion in
    the Berkeley Standard Distribution of UNIX (BSD UNIX). This first version of RIP
    (now sometimes called RIP-1 to differentiate it from later versions) was eventually
    standardized in RFC 1058\. As part of this standard, the original RIP-1 message
    format was defined, which of course serves *RIP-1* itself, and is also the basis
    for the format used in later versions.
  prefs: []
  type: TYPE_NORMAL
- en: RIP-1 Messaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As explained in the general discussion on RIP operation in the previous sections,
    route information is exchanged in RIP through the sending of two different types
    of RIP messages: RIP Request and the RIP Response. These are transmitted as regular
    TCP/IP messages using UDP, which uses the UDP reserved port number 520\. This
    port number is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RIP Request messages are sent to UDP destination port 520\. They may have a
    source port of 520 or may use an ephemeral port number (see [Chapter 43](ch43.html
    "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS") for an explanation of
    ephemeral ports).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RIP Response messages sent in reply to an RIP Request are sent with a source
    port of 520 and a destination port equal to whatever source port the RIP Request
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsolicited RIP Response messages (sent on a routine basis and not in response
    to a request) are sent with both the source and destination ports, which are set
    to 520.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RIP-1 Message Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic message format for RIP-1 is described in [Table 38-1](ch38s05.html#rip-_message_format
    "Table 38-1. RIP-1 Message Format") and illustrated [Figure 38-5](ch38s05.html#rip-1_message_format_the_rip-1_message_f
    "Figure 38-5. RIP-1 message format The RIP-1 message format can contain up to
    25 RIP entries. Here, RIP entry 1 is shown with each of its constituent subfields.").
  prefs: []
  type: TYPE_NORMAL
- en: Table 38-1. RIP-1 Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Command | 1 | Command Type: Identifies the type of RIP message being sent.
    A value of 1 indicates an RIP Request, while 2 means an RIP Response. Originally,
    three other values and commands were also defined: 3 and 4 for the Traceon and
    Traceoff commands, and 5, which was reserved for use by Sun Microsystems. These
    are obsolete and no longer used. |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 | Version Number: Set to 1 for RIP version 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| RIP Entries | 20 to 500, in increments of 20 | The body of an RIP message
    consists of 1 to 25 sets of RIP entries. These entries contain the actual route
    information that the message is conveying. Each entry is 20 bytes long and has
    the subfields shown in [Table 38-2](ch38s05.html#rip-_rip_entries "Table 38-2. RIP-1
    RIP Entries"). |'
  prefs: []
  type: TYPE_TB
- en: Table 38-2. RIP-1 RIP Entries
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Address Family Identifier | 2 | A fancy name for a field that identifies
    the type of address in the entry. The routers are using IP addresses, for which
    this field value is 2. |'
  prefs: []
  type: TYPE_TB
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| IP Address | 4 | The address of the route the routers are sending information
    about. No distinction is made between addresses of different types of devices
    in RIP, so the address can be for a network, a subnet, or a single host. It is
    also possible to send an address of all zeros, which is interpreted as the default
    route for other devices on the network to use for reaching routes with no specified
    routing entries. This is commonly used to allow a network to access the Internet.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Must Be Zero | 4 | Field reserved; value must be set to all zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| Must Be Zero | 4 | Field reserved; value must be set to all zeros. (Yes,
    two of them in a row.) |'
  prefs: []
  type: TYPE_TB
- en: '| Metric | 4 | The distance for the network indicated by the IP address in
    the IP Address field. Values of 1 to 15 indicate the number of hops to reach the
    network, while a value of 16 represents infinity (an unreachable destination).
    See the general discussion of the RIP algorithm earlier in this chapter for more
    information about the use of metrics. |'
  prefs: []
  type: TYPE_TB
- en: '![RIP-1 message format The RIP-1 message format can contain up to 25 RIP entries.
    Here, RIP entry 1 is shown with each of its constituent subfields.](httpatomoreillycomsourcenostarchimages288037.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-5. RIP-1 message format The RIP-1 message format can contain up to
    25 RIP entries. Here, RIP entry 1 is shown with each of its constituent subfields.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re like me, the first thing that comes to mind after looking at this
    message format is this: What''s with all the extra space? I mean, we have four
    different fields that are reserved (must be zero), and even most of the other
    fields are larger than they need to be (a metric of 1 to 16 needs only 4 bits,
    not 32). The command type and version number could also easily have been made
    only 4 bits each, if not less. And why bother having a 2-byte field to identify
    the address type when we are only going to deal with IP addresses anyway?'
  prefs: []
  type: TYPE_NORMAL
- en: This seeming wastefulness is actually an artifact of the generality of the original
    RIP design. The protocol was intended to be able to support routing for a variety
    of different internetworking protocols, not just Internet Protocol (IP). Remember
    that it wasn't even originally developed with IP in mind. So, the Address Family
    Identifier was included to specify address type, and RIP entries were made large
    enough to handle large addresses. IP requires only 4 bytes per address, so some
    of the space is not used.
  prefs: []
  type: TYPE_NORMAL
- en: RIP-1 Version-Specific Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since RIP-1 was the first version of the protocol, its features formed the basis
    for future RIP versions; it doesn't really have any version-specific features.
    What RIP-1 has is a number of limitations, such as a lack of support for specifying
    classless addresses and no means for authentication. RIP-2 was created to address
    some of RIP-1 shortcomings. As you will see in the next section, RIP-2's features
    put to good use those "Must Be Zero" bytes in the RIP-1 format!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** RIP-1 was the first version of RIP and is the simplest in terms
    of operation and features. The bulk of an RIP-1 message consists of sets of RIP
    entries that specify route addresses and the distance to the route in hops.'
  prefs: []
  type: TYPE_NORMAL
- en: RIP Version 2 (RIP-2) Message Format and Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original RIP (RIP-1) has a number of problems and limitations. As the TCP/IP
    protocol suite evolved and changed, RIP-1's problems were compounded by it becoming
    somewhat out of date. It was unable to handle newer IP features. There were some
    who felt that the existence of newer and better interior routing protocols meant
    that it would be best to just give up on RIP entirely and move over to something
    like OSPF.
  prefs: []
  type: TYPE_NORMAL
- en: However, RIP's appeal was never its technical superiority, but its simplicity
    and ubiquity in the industry. By the early 1990s, RIP was already in use in many
    thousands of networks. For those who liked RIP, it made more sense to migrate
    to a newer version that addressed some of RIP-1's shortcomings than to go to an
    entirely different protocol. To this end, a new version of the protocol, RIP-2
    was developed. It was initially published in RFC 1388 in 1993\. It is now defined
    in RFC 2453, "RIP Version 2," which was published in November 1998.
  prefs: []
  type: TYPE_NORMAL
- en: RIP-2 Version-Specific Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RIP-2 represents a very modest change to the basic RIP. RIP-2 works in the
    same basic way as RIP-1\. In fact, the new features introduced in RIP-2 are described
    as *extensions* to the basic protocol, thereby conveying the fact that they are
    layered upon regular RIP-1 functionality. The five key RIP-2 extensions are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classless Addressing Support and Subnet Mask Specification** When RIP-1 was
    developed, the use of subnets in IP (as described in RFC 950) had not yet been
    formally defined. It was still possible to use RIP-1 with subnets through the
    use of a heuristic to determine if the destination is a network, subnet, or host.
    However, there was no way to clearly specify the subnet mask for an address using
    RIP-1 messages. RIP-2 adds explicit support for subnets by allowing a subnet mask
    within the route entry for each network address. It also provides support for
    Variable Length Subnet Masking (VLSM; see [Chapter 18](ch18.html "Chapter 18. IP
    SUBNET ADDRESSING (SUBNETTING) CONCEPTS")) and CIDR.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next Hop Specification** In RIP-2, each RIP entry includes a space where
    an explicit IP address can be entered as the next-hop router for datagrams that
    are intended for the network in that entry. This feature can help improve efficiency
    of routing by eliminating unnecessary extra hops for datagrams sent to certain
    destinations. One common use of this field is when the most efficient route to
    a network is through a router that is not running RIP. Such a router will not
    exchange RIP messages and would therefore not normally be selected by RIP routers
    as a next hop for any network. The explicit Next Hop field allows the router to
    be selected as the next hop, regardless of this situation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** RIP-1 included no authentication mechanism, which is a problem
    because it could potentially allow a malicious host to attack an internetwork
    by sending bogus RIP messages. RIP-2 provides a basic authentication scheme that
    allows routers to ascertain the identity of a router before it will accept RIP
    messages from it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Tag** Each RIP-2 entry includes a Route Tag field where additional
    information about a route can be stored. This information is propagated along
    with other data about the route as RIP entries are sent around the internetwork.
    A common use of this field is when a route is learned from a different AS in order
    to identify the AS from which the route was obtained.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use of Multicasting** To help reduce network load, RIP-2 allows routers to
    be configured to use multicasts instead of broadcasts for sending out unsolicited
    RIP Response messages. These datagrams are sent out using the special reserved
    multicast address 224.0.0.9\. All routers on an internetwork must use multicast
    if this is to work properly.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, many of these extensions require more information to be included
    with each advertised route. This is where all that extra space in the message
    format of RIP-1 routing entries comes in handy, as you will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** RIP-2 is the most recent version of RIP used in IPv4\. It includes
    a number of enhancements over the original RIP-1, including support for subnet
    masks and classless addressing, explicit next-hop specification, route tagging,
    authentication, and multicast. For compatibility, it uses the same basic message
    format as RIP-1, putting the extra information required for its new features into
    some of the unused fields of the RIP-1 message format.'
  prefs: []
  type: TYPE_NORMAL
- en: RIP-2 Messaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RIP-2 messages are exchanged using the same basic mechanism as RIP-1 messages.
    Two different message types exist: RIP Request and RIP Response. They are sent
    using UDP, which uses the reserved port number 520\. The semantics for the use
    of this port are the same as for RIP-1\. For convenience, I''ll repeat the description
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: RIP Request messages are sent to UDP destination port 520\. They may have a
    source port of 520 or may use an ephemeral port number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RIP Response messages sent in reply to an RIP Request message are sent with
    a source port of 520 and a destination port equal to whatever source port the
    RIP Request message used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsolicited RIP Response messages (sent on a routine basis and not in response
    to a request) are sent with both the source and destination ports set to 520.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RIP-2 Message Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic message format for RIP-2 is also pretty much the same as it was for
    RIP-1, with the Version field set to 2 in order to clearly identify the message
    as being RIP-2\. [Table 38-3](ch38s05.html#rip-_message_format-id001 "Table 38-3. RIP-2
    Message Format") and [Figure 38-6](ch38s05.html#rip-2_message_format_the_rip_entries_of_
    "Figure 38-6. RIP-2 message format The RIP entries of RIP-1 are called Route Table
    Entries (RTEs) in RIP-2; the message format can contain up to 25\. The format
    of RTE 1 is shown here with each of its subfields (the others are summarized to
    save space).") illustrate the RIP-2 message format. The real differences are in
    the individual RIP entries, as you can see in [Table 38-4](ch38s05.html#rip-_route_table_entries_rtes
    "Table 38-4. RIP-2 Route Table Entries (RTEs)").
  prefs: []
  type: TYPE_NORMAL
- en: Table 38-3. RIP-2 Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Command | 1 | Command Type: Identifies the type of RIP message being sent.
    A value of 1 indicates an RIP Request, while 2 means an RIP Response. |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 | Version Number: Set to 2 for RIP version 2. |'
  prefs: []
  type: TYPE_TB
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| Route Table Entries (RTEs) | 20 to 500, in increments of 20 | As with RIP-1,
    the body of an RIP-2 message consists of 1 to 25 sets of route information. In
    RIP-2 these are labeled Route Table Entries, or RTEs. Each RTE is 20 bytes long
    and has the subfields shown in [Table 38-4](ch38s05.html#rip-_route_table_entries_rtes
    "Table 38-4. RIP-2 Route Table Entries (RTEs)"). |'
  prefs: []
  type: TYPE_TB
- en: Table 38-4. RIP-2 Route Table Entries (RTEs)
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Address Family Identifier | 2 | Same meaning as for RIP-1; value is 2 to
    identify IP addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| Route Tag | 2 | Additional information to be carried with this route. |'
  prefs: []
  type: TYPE_TB
- en: '| IP Address | 4 | Same as in RIP-1: the address of the route the router is
    sending information about. No distinction is made between the address of different
    types of devices in RIP, so the address can be for a network, a subnet, or a single
    host. It is also possible to send an address of all zeros, which is interpreted
    as the default route, as in RIP-1. |'
  prefs: []
  type: TYPE_TB
- en: '| Subnet Mask | 4 | The subnet mask associated with this address. |'
  prefs: []
  type: TYPE_TB
- en: '| Next Hop | 4 | Address of the device to use as the next hop for the network
    advertised in this entry. |'
  prefs: []
  type: TYPE_TB
- en: '| Metric | 4 | The distance for the network indicated by the IP address, as
    in RIP-1\. Values of 1 to 15 indicate the number of hops to reach the network
    (as described in the discussion of the RIP algorithm earlier in this chapter),
    while a value of 16 represents infinity (an unreachable destination). |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the unused fields allow the new RIP-2 features to be implemented
    without changing the basic structure of the RIP entry format. This allows RIP-1
    and RIP-2 messages and devices to coexist in the same network. An RIP-2 device
    can handle both RIP-1 and RIP-2 messages, and will look at the version number
    to see which version the message is. An RIP-1 device should handle both RIP-2
    and RIP-1 messages the same way, simply ignoring the extra RIP-2 fields it doesn't
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If authentication is used, one of the RTEs contains authentication information,
    thus limiting the message to 24 "real" RTEs*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![RIP-2 message format The RIP entries of RIP-1 are called Route Table Entries
    (RTEs) in RIP-2; the message format can contain up to 25\. The format of RTE 1
    is shown here with each of its subfields (the others are summarized to save space).](httpatomoreillycomsourcenostarchimages288039.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-6. RIP-2 message format The RIP entries of RIP-1 are called Route
    Table Entries (RTEs) in RIP-2; the message format can contain up to 25\. The format
    of RTE 1 is shown here with each of its subfields (the others are summarized to
    save space).
  prefs: []
  type: TYPE_NORMAL
- en: RIPng (RIPv6) Message Format and Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The future of TCP/IP is IPv6, which makes some very important changes to IP,
    especially with regard to addressing. Since IPv6 addresses are different than
    IPv4 addresses, everything that works with IP addresses must change to function
    under IPv6\. This includes routing protocols, which exchange addressing information.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure a future for the RIP, a new IPv6-compatible version had to be developed.
    This new version was published in 1997 in RFC 2080, *RIPng for IPv6*, where the
    *ng* stands for next generation (IPv6 is also sometimes called *IP next generation*).
  prefs: []
  type: TYPE_NORMAL
- en: RIPng, which is also occasionally seen as RIPv6 for obvious reasons, was designed
    to be as similar as possible to the current version of RIP for IPv4, which is
    RIP-2\. In fact, RFC 2080 describes RIPng as the minimum change possible to RIP
    to allow it to work on IPv6\. Despite this effort, it was not possible to define
    RIPng as just a new version of the older RIP, as RIP-2 was defined. RIPng is a
    new protocol, which was necessary because of the significance of the changes between
    IPv4 and IPv6—especially the change from 32-bit to 128-bit addresses in IPv6,
    which necessitated a new message format.
  prefs: []
  type: TYPE_NORMAL
- en: RIPng Version-Specific Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though RIPng is a new protocol, a specific effort was made to make RIPng
    like its predecessors. Its basic operation is almost entirely the same, and it
    uses the same overall algorithm and operation, as you saw earlier in this chapter.
    RIPng also does not introduce any specific new features compared to RIP-2, except
    those needed to implement RIP on IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: 'RIPng maintains most of the enhancements introduced in RIP-2; some are implemented
    as they were in RIP-2, while others appear in a modified form. Here''s specifically
    how the five extensions in RIP-2 are implemented in RIPng:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classless Addressing Support and Subnet Mask Specification** In IPv6 all,
    addresses are classless and specified using an address and a prefix length, instead
    of a subnet mask. Thus, a field for the prefix length is provided for each entry
    instead of a subnet mask field.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next Hop Specification** This feature is maintained in RIPng, but implemented
    differently. Due to the large size of IPv6 addresses, if you include a Next Hop
    field in the format of RIPng, the RTEs would almost double the size of every entry.
    Since Next Hop is an optional feature, this would be wasteful. Instead, when a
    Next Hop is needed, it is specified in a separate routing entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** RIPng does not include its own authentication mechanism.
    It is assumed that if authentication and/or encryption are needed, they will be
    provided using the standard IPsec features, which are defined for IPv6 at the
    IP layer. This is more efficient than having individual protocols like RIPng perform
    authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Tag** This field is implemented in the same way as it is in RIP-2.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use of Multicasting** RIPng uses multicasts for transmissions, specifically
    the reserved IPv6 multicast address FF02::9.'
  prefs: []
  type: TYPE_NORMAL
- en: RIPng Messaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two basic RIPng message types, RIP Request and RIP Response, which
    are exchanged using the UDP as with RIP-1 and RIP-2\. Since RIPng is a new protocol,
    it cannot use the same UDP reserved port number 520, which is used for RIP-1/RIP-2\.
    Instead, RIPng uses well-known port number 521\. The semantics for the use of
    this port are the same as those used for port 520 in RIP-1 and RIP-2\. For convenience,
    here are the rules again:'
  prefs: []
  type: TYPE_NORMAL
- en: RIP Request messages are sent to UDP destination port 521\. They may have a
    source port of 521 or may use an ephemeral port number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RIP Response messages sent in reply to an RIP Request message are sent with
    a source port of 521 and a destination port equal to whatever source port the
    RIP Request message used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsolicited RIP Response messages (sent on a routine basis and not in response
    to a request) are sent with both the source and destination ports set to 521.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RIPng Message Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The message format for RIPng is similar to that of RIP-1 and RIP-2, except for
    the format of the RTEs. It is shown in [Table 38-5](ch38s05.html#ripng_message_format-id001
    "Table 38-5. RIPng Message Format") and illustrated in [Figure 38-7](ch38s05.html#ripng_message_format_ripng_retains_the_u
    "Figure 38-7. RIPng message format RIPng retains the use of RTEs from RIP-2, but
    their format has been changed to accommodate the much larger IPv6 address size.
    The limit of 25 entries per message has also been eliminated.").
  prefs: []
  type: TYPE_NORMAL
- en: Table 38-5. RIPng Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Command | 1 | Command Type: Identifies the type of RIPng message being sent.
    A value of 1 indicates an RIPng Request, while 2 means an RIPng Response. |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 | Version Number: Set to 1 (not 6, since this is the first version
    of the new protocol RIPng). |'
  prefs: []
  type: TYPE_TB
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| Route Table Entries (RTEs) | Variable | The body of an RIPng message consists
    of a variable number of Route Table Entries (RTEs) that contain information about
    routes. Each entry is 20 bytes long and has the subfields shown in [Table 38-6](ch38s05.html#ripng_rtes
    "Table 38-6. RIPng RTEs"). |'
  prefs: []
  type: TYPE_TB
- en: Table 38-6. RIPng RTEs
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| IPv6 Prefix | 16 | The 128-bit IPv6 address of the network whose information
    is contained in this RTE. |'
  prefs: []
  type: TYPE_TB
- en: '| Route Tag | 2 | Additional information to be carried with this route, as
    defined in RIP-2. |'
  prefs: []
  type: TYPE_TB
- en: '| Prefix Len | 1 | The number of bits of the IPv6 address that is the network
    portion (the remainder being the host portion). This is the number that normally
    would appear after the slash when specifying an IPv6 network address. It is analogous
    to an IPv4 subnet mask. See the description of IPv6 prefix notation in [Chapter 25](ch25.html
    "Chapter 25. IPV6 ADDRESSING") for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| Metric | 1 | The distance for the network indicated by the IP address, as
    in RIP-1\. Values of 1 to 15 indicate the number of hops to reach the network
    (as described in the general discussion of the RIP algorithm earlier in this chapter)
    while a value of 16 represents infinity (an unreachable destination). |'
  prefs: []
  type: TYPE_TB
- en: '![RIPng message format RIPng retains the use of RTEs from RIP-2, but their
    format has been changed to accommodate the much larger IPv6 address size. The
    limit of 25 entries per message has also been eliminated.](httpatomoreillycomsourcenostarchimages288041.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38-7. RIPng message format RIPng retains the use of RTEs from RIP-2,
    but their format has been changed to accommodate the much larger IPv6 address
    size. The limit of 25 entries per message has also been eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of RTEs in RIPng is not restricted to 25 as it is in RIP-1
    and RIP-2\. It is limited only by the maximum transmission unit (MTU) of the network
    over which the message is being sent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** RIPng is the version of RIP that was developed for use on IPv6
    internetworks. It is technically a distinct protocol from RIP-1 and RIP-2, but
    is very similar to both. It retains the enhancements to RIP made in RIP-2, making
    changes to these features and to the RIP message format wherever needed for compatibility
    with IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: When a Next Hop field needs to be specified, a special RTE is included, as I
    mentioned earlier. This RTE is included before all the RTEs to which it applies.
    It has the same basic structure as shown for regular RTEs in [Table 38-6](ch38s05.html#ripng_rtes
    "Table 38-6. RIPng RTEs"), with the IPv6 Prefix subfield containing the next hop
    address, the Route Tag and Prefix Len fields set to 0, and the Metric field set
    to 255 (0xFF).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interior routing protocols using a distance-vector routing algorithm, such as
    the Routing Information Protocol (RIP) we explored last chapter, have a long history
    and work well in a small group of routers. However, they also have some serious
    limitations in both scalability and performance that make them poorly suited to
    larger autonomous systems (ASes) or those with specific performance issues. Many
    organizations that start out using RIP quickly find that its restrictions and
    issues make it less than ideal.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, a new routing protocol was developed in the late 1980s.
    This protocol, called *Open Shortest Path First (OSPF)*, uses the more capable
    (and more complex) link-state or *shortest-path first* routing algorithm. It fixes
    many of the issues with RIP and allows routes to be selected dynamically based
    on the current state of the network, not just a static picture of how routers
    are connected. It also has numerous advanced features, including support for a
    hierarchical topology and automatic load sharing among routes. On the downside,
    it is a complicated protocol, which means it is often not used unless it is really
    needed. This makes it the complement of RIP and is the reason they both have a
    place in the spectrum of TCP/IP routing protocols.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide a condensed explanation of the concepts and operation
    behind OSPF. As usual, I begin with an overview of the protocol, discussing how
    it was developed, its versions, and the standards that define them. I describe
    the concepts behind OSPF, including basic topology and the link-state database.
    I then discuss the more complex optional hierarchical topology of routers and
    the roles routers play when this topology is used. I briefly explain the method
    used for determining routes in OSPF, and the general operation and messaging used
    in the protocol, including a description of the five OSPF message types. I conclude
    with descriptions of the formats used for OSPF messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The difficult thing about networking is that so many protocols and technologies
    are so involved that each deserves its own book. This is certainly the case with
    OSPF itself, which is sufficiently complex that the RFC defining OSPF version
    2 is more than 240 pages long! Thus, this chapter, despite being fairly comprehensive,
    is only a high-level description of OSPF*.'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the early days of TCP/IP, RIP became the standard protocol for routing within
    an autonomous system (AS), almost by default. RIP had two big things going for
    it: It was simple and easy to use, and it was included in the popular Berkeley
    Standard Distribution (BSD) of UNIX starting in 1982\. Most organizations using
    TCP/IP started out with relatively small networks and were able to use RIP with
    some degree of success.'
  prefs: []
  type: TYPE_NORMAL
- en: However, as I discussed in [Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION
    PROTOCOL (RIP, RIP-2, AND RIPNG)"), that protocol has some serious technical issues,
    and they are exacerbated when RIP is used on a larger AS. Many of RIP's problems
    are due to it being a distance-vector protocol, because the algorithm itself simply
    limits the ability of RIP to choose the best route and adapt to changing network
    conditions. Other problems with RIP were based on its implementation, such as
    the selection of a cost value of 16 for infinity, which makes it impossible to
    use RIP in a situation where more than 15 hops might occur between devices. Problems
    such as the lack of classless addressing support were addressed in version 2 of
    RIP, but the basic difficulties with the protocol as a whole persist.
  prefs: []
  type: TYPE_NORMAL
- en: Development and Standardization of OSPF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Internet Engineering Task Force (IETF) recognized that RIP by itself simply
    would not meet the needs of all ASes on the Internet. It formed a working group
    in 1988 to develop a new routing protocol based on the more capable link-state
    algorithm, also called shortest path first (SPF). Research into this type of protocol
    had already begun as early as the 1970s, with some of it conducted on the ARPAnet,
    the predecessor of the Internet, upon which much of TCP/IP was developed.
  prefs: []
  type: TYPE_NORMAL
- en: This new protocol's name conveys two of its most important characteristics.
    The first word refers to the fact that the protocol, like all TCP/IP standards,
    was developed using the open and public RFC process, so it is not proprietary,
    and no license is required to use it. The SPF portion of the name refers to the
    type of algorithm it uses, which is designed to allow routers to dynamically determine
    the shortest path between any two networks.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of OSPF was described in RFC 1131, which was published in
    October 1989\. This was quickly replaced by OSPF version 2 in July 1991, which
    is described in RFC 1247\. Since then, there have been several revisions to the
    OSPF version 2 standard, in RFCs 1583, 2178, and 2328, with the last of these
    now the current standard. OSPF version 2 is the only version in use today, so
    it is usually what is meant when people (including myself) refer to OSPF.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of OSPF Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fundamental concept behind OSPF is a data structure called the *link-state
    database (LSDB)*. Each router in an AS maintains a copy of this database, which
    contains information in the form of a directed graph that describes the current
    state of the AS. Each link to a network or another router is represented by an
    entry in the database, and each has an associated cost (or metric). The metric
    can be made to include many different aspects of route performance, not just a
    simple hop count, as is used in RIP.
  prefs: []
  type: TYPE_NORMAL
- en: Information about the AS moves around the AS in the form of *link-state advertisements
    (LSAs)*, which are messages that let each router tell the others what it currently
    knows about the state of the AS. Over time, the information that each router has
    about the AS converges with that of the others, and they all have the same data.
    When changes occur to the internetwork, routers send updates to ensure that all
    the routers are kept up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: To determine actual routes, each router uses its LSDB to construct a shortest-path
    tree. This tree shows the links from the router to each other router and network
    and allows the lowest-cost route to any location to be determined. As new information
    about the state of the internetwork arrives, this tree can be recalculated, so
    the best route is dynamically adjusted based on network conditions. When more
    than one route with an equal cost exists, traffic can be shared among the routes.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Features and Drawbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the obvious benefits of the link-state algorithm, OSPF includes
    several other features of value, especially to larger organizations. It supports
    authentication for security and all three major types of IP addressing (classful,
    subnetted classful, and classless). For very large ASes, OSPF also allows routers
    to be grouped and arranged into a hierarchical topology. This allows for better
    organization and improved performance through reduced LSA traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the superior functionality and many features of OSPF do not come
    without a cost. In this case, the primary cost is that of complexity. Where RIP
    is a simple and easy-to-use protocol, OSPF requires more work and more expertise
    to properly configure and maintain. This means that even though OSPF is widely
    considered better than RIP, technically, it's not for everyone. The obvious role
    for OSPF is as a routing protocol for larger or higher-performance ASes, leaving
    RIP to cover the smaller and simpler internetworks.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *Open Shortest Path First (OSPF)* was developed in the late
    1980s to provide a more capable interior routing protocol for larger or more complex
    ASes that were not being served well by RIP. It uses the dynamic shortest path
    first, or link-state, routing algorithm, with each router maintaining a database
    containing information about the state and topology of the internetwork. As changes
    to the internetwork occur, routers send out updated state information, which allows
    each router to dynamically calculate the best route to any network at any point
    in time. OSPF is a complement to RIP in that RIP is simple but limited, whereas
    OSPF is more capable but more complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Basic Topology and the Link-State Database (LSDB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OSPF is designed to facilitate routing in both smaller and larger ASes. To this
    end, the protocol supports two topologies. When there is only a small number of
    routers, the entire AS is managed as a single entity. This doesn't have a specific
    name, but I call it *OSPF basic topology* to convey the simple nature of the topology
    and to contrast it with the hierarchical topology you will explore in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When OSPF basic topology is used, all the routers in the AS function as peers.
    Each router communicates routing information with each other one, and each maintains
    a copy of the key OSPF data structure: the LSDB, which is essentially a computerized
    representation of the topology of the AS. It is the method by which routers see
    the state of the links in the AS—thus the name *link-state database* (and for
    that matter, the name of the entire class of link-state algorithms of which OSPF
    is a part).'
  prefs: []
  type: TYPE_NORMAL
- en: The LSDB is a bit hard to visualize, but is best viewed as a set of data that
    is equivalent to a graphical picture that shows the topology of an AS. In such
    a diagram, we typically show routers and networks as nodes, and connections between
    routers and networks as lines that connect them. The OSPF LSDB takes that information
    and puts it into a table to allow a router to maintain a virtual picture of all
    the connections between routers and networks in the AS.
  prefs: []
  type: TYPE_NORMAL
- en: The LSDB therefore indicates which routers can directly reach which other routers
    and which networks each router can reach. Furthermore, it stores for each of these
    links a *cost* to reach the network. This cost is an arbitrary metric that can
    be set up based on any criteria important to the administrator. OSPF is not restricted
    to the overly simple hop-count metric used in RIP.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Basic Topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For example, let''s consider the same AS that you looked at in the examination
    of the RIP route determination algorithm in [Chapter 38](ch38.html "Chapter 38. ROUTING
    INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)"). This internetwork has four individual
    networks, connected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Router RA connects Network N1 to Network N2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routers RB and RC connect Network N2 to Network N3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router RD connects Network N3 to Network N4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make this example more interesting, I added a direct link between Routers
    RB and RC.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting AS is shown in [Figure 39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_
    "Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as
    shown in Figure 38-1 in Chapter 38), but with the addition of a link between the
    two Routers RB and RC."). [Table 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb
    "Table 39-1. Sample OSPF Link-State Database (LSDB)") shows what the LSDB for
    this AS might look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample OSPF AS This is the same AS that you looked at in RIP (as shown in
    in ), but with the addition of a link between the two Routers RB and RC.](httpatomoreillycomsourcenostarchimages288043.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as
    shown in [Figure 38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si "Figure 38-1. Sample
    RIP AS This is an example of a simple AS that contains four physical networks
    and four routers.") in [Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION
    PROTOCOL (RIP, RIP-2, AND RIPNG)")), but with the addition of a link between the
    two Routers RB and RC.
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-1. Sample OSPF Link-State Database (LSDB)
  prefs: []
  type: TYPE_NORMAL
- en: '| To Router/Network | From Router | From Network |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | RA | RB | RC | RD | N1 | N2 | N3 | N4 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **RA** |   |   |   |   | 0 | 0 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **RB** |   |   | • |   |   | 0 | 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| **RC** |   | • |   |   |   | 0 | 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| **RD** |   |   |   |   |   |   | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| **N1** | • |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **N2** | • | • | • |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **N3** |   | • | • | • |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **N4** |   |   |   | • |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: In practice, each of the bullets (•) in [Table 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb
    "Table 39-1. Sample OSPF Link-State Database (LSDB)") would be replaced by a metric
    value indicating the cost to send a datagram from the particular router to another
    router or network. Note that the chart is symmetric, because if Router RB can
    reach Router RC, Router RC can reach Router RB. However, the *costs* do not have
    to be symmetric. It is possible for Router RB to have a metric that is higher
    for it to send to Router RC than for Router RC to send to Router RB.
  prefs: []
  type: TYPE_NORMAL
- en: Note too that there is no cost to reach a router *from* a network. This ensures
    that only one cost is applied for a router to send to another router over a network.
    The cost is to reach the network from the router. This makes sense, since each
    router is a member of the network on which it is connected.
  prefs: []
  type: TYPE_NORMAL
- en: LSDB Information Storage and Propagation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important thing to remember about the LSDB is that even though each router
    maintains it, the database isn't constructed from the perspective of the individual
    router. A router's LSDB represents the topology of the entire AS, including links
    between routers that may be rather distant from it. So, for example, Router RA
    would keep the entire database in its storage area, including information about
    Router RC and Router RD, to which it does not connect directly.
  prefs: []
  type: TYPE_NORMAL
- en: Since in the basic topology, all the routers are peers and maintain information
    for the entire AS, in theory, they should have the exact same LSDB contents. When
    a router is first turned on, it may have different LSDB information than its neighbors,
    but this will be corrected through the exchange of update messages containing
    LSAs. Eventually, all routers should converge to the same information. You will
    see how this works in the section about OSPF messaging later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF, as an interior routing protocol, is used only within the AS. In most cases,
    the AS will be connected to other ASes through one or more of its routers. The
    routers that connect the AS to other ASes are often called *boundary routers*.
    These devices will use OSPF to communicate within the AS, and an exterior routing
    protocol (typically BGP) to talk to routers outside the AS. The word *boundary*
    in its name refers to the fact that these devices are usually located on the periphery
    of the AS.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In basic OSPF topology, each of the routers running OSPF is
    considered a peer of the others. Each maintains a *link-state database (LSDB)*
    that contains information about the topology of the entire AS. Each link between
    a router and network or between two routers is represented by an entry in the
    LSDB that indicates the cost to send data over the link. The LSDB is updated regularly
    through the exchange of OSPF *link-state advertisements (LSAs)*.'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Hierarchical Topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the number of routers in an AS is relatively small, using the previously
    described basic topology works well. Each router maintains a common picture of
    the network topology in the form of an identical LSDB. The routers communicate
    as peers using LSAs. While changes in the AS may cause a router to temporarily
    have different information than its peers, routine exchanges of data will keep
    all the LSDBs synchronized and up-to-date, and not that much information needs
    to be sent around because the AS is small.
  prefs: []
  type: TYPE_NORMAL
- en: This simpler topology does scale reasonably well, and it can support many smaller
    and even moderate-sized ASes. However, as the number of routers increases, the
    amount of communication required to update LSDBs increases as well. In a very
    large internetwork with dozens or even hundreds of routers, having all the routers
    be OSPF peers using the basic topology can result in performance degradation.
    This problem occurs due to the amount of routing information that needs to be
    passed around and to the need for each router to maintain a large LSDB containing
    every router and network in the entire AS.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To provide better support for these larger internetworks, OSPF supports the
    use of a more advanced, hierarchical topology. In this technique, the AS is no
    longer considered a single, flat structure of interconnected routers all of which
    are peers. Instead, a two-level hierarchical topology is constructed. The AS is
    divided into constructs called *areas*, each of which contains a number of contiguous
    routers and networks. These areas are numbered and managed independently by the
    routers within them, so each area is almost as if it were an AS unto itself. The
    areas are interconnected so that routing information can be shared among areas
    across the entire AS.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to understand this hierarchical topology is to consider each
    area like a sub-AS within the AS as a whole. The routers within any area maintain
    an LSDB that contains information about the routers and networks within that area.
    Routers within more than one area maintain LSDBs about each area that they are
    a part of, and they also link the areas together to share routing information
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** To allow for better control and management over larger internetworks,
    OSPF allows a large AS to be structured into a hierarchical form. Contiguous routers
    and networks are grouped into areas that connect together using a logical backbone.
    These areas act as the equivalent of smaller ASes within the larger AS, yielding
    the same benefits of localized control and traffic management that ASes provide
    for a large internetwork between organizations.'
  prefs: []
  type: TYPE_NORMAL
- en: Router Roles in OSPF Hierarchical Topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The topology just described is hierarchical because the routers in the AS are
    no longer all peers in a single group. The two-level hierarchy consists of the
    lower level, which contains individual areas, and the higher level that connects
    them together, which is called the *backbone* and is designated as Area 0\. The
    routers play different roles, depending on where they are located and how they
    are connected. There are three different labels applied to routers in this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal Routers** These are routers that are connected only to other routers
    or networks within a single area. They maintain an LSDB for only that area and
    have no knowledge of the topology of other areas.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Area Border Routers** These are routers that connect to routers or networks
    in more than one area. They maintain an LSDB for each area of which they are a
    part. They also participate in the backbone.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Backbone Routers** These are routers that are a part of the OSPF backbone.
    By definition, these include all area border routers, since those routers pass
    routing information between areas. However, a backbone router may also be a router
    that connects only to other backbone (or area border) routers and is therefore
    not part of any area (other than Area 0).'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, an *area border router* is also always a *backbone router*, but
    a backbone router is not necessarily an area border router.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The classifications that I just mentioned are independent of the designation
    of a router as being a* boundary router, *as described in the previous section.
    A boundary router is one that talks to routers or networks outside the AS. A boundary
    router will also often be an area border router or a backbone router, but this
    is not necessarily the case. A boundary router could be an internal router in
    one area*.'
  prefs: []
  type: TYPE_NORMAL
- en: The point of all this is the same as the point of using AS architecture in the
    first place. The topology of each area matters only to the devices in that area.
    This means that changes in that topology need to be propagated only within the
    area. It also means that internal routers within Area 1 don't need to know about
    anything that goes on within Area 2 and don't need to maintain information about
    any area other than their own. Only the backbone routers (which include at least
    one area border router within each area) need to know the details of the entire
    AS. These backbone routers condense information about the areas so that only a
    summary of each area's topology needs to be advertised on the backbone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Routing in a hierarchical topology AS is performed in one of two ways, depending
    on the location of the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: If the source and destination are in the same area, routing occurs only over
    networks and routers in that area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the source and destination are in different areas, the datagram is routed
    from the source to an area border router in the source's area, over the backbone
    to an area border router in the destination's area, and then finally delivered
    to the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this is analogous to how routing works between ASes in the big-picture
    internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example to help make things more concrete. We can use the AS
    in the preceding example. This AS is really small enough that it''s unlikely we
    would use hierarchical topology, but it will suffice for sake of illustration.
    Let''s divide this AS into two areas, as follows (see [Figure 39-2](ch39s03.html#sample_ospf_hierarchical_topology_as_thi
    "Figure 39-2. Sample OSPF hierarchical topology AS This is the same AS you saw
    in Figure 39-1, but it''s arranged into OSPF hierarchical topology. The AS has
    been split evenly into Area 1 and Area 2\. Area 0 contains Routers RB and RC,
    which are area border routers for both Area 1 and Area 2 in this very simple example.")):'
  prefs: []
  type: TYPE_NORMAL
- en: Area 1 contains Network N1, Router RA, Network N2, Router RB, and Router RC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area 2 contains Router RB, Router RC, Network N3, Router RD, and Network N4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Sample OSPF hierarchical topology AS This is the same AS you saw in , but
    it''s arranged into OSPF hierarchical topology. The AS has been split evenly into
    Area 1 and Area 2\. Area 0 contains Routers RB and RC, which are area border routers
    for both Area 1 and Area 2 in this very simple example.](httpatomoreillycomsourcenostarchimages288045.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-2. Sample OSPF hierarchical topology AS This is the same AS you saw
    in [Figure 39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_ "Figure 39-1. Sample
    OSPF AS This is the same AS that you looked at in RIP (as shown in Figure 38-1
    in Chapter 38), but with the addition of a link between the two Routers RB and
    RC."), but it's arranged into OSPF hierarchical topology. The AS has been split
    evenly into Area 1 and Area 2\. Area 0 contains Routers RB and RC, which are area
    border routers for both Area 1 and Area 2 in this very simple example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, Router RA and Router RD are internal routers. Router RB and
    Router RC are area border routers that make up the backbone (Area 0) of the internetwork.
    Routers RA, RB, and RC will maintain an LSDB describing Area 1, while Routers
    RB, RC, and RD will maintain an LSDB describing Area 2\. Routers RB and RC maintain
    a separate LSDB for the backbone. There is no backbone router other than the area
    border routers RB and RC. However, suppose we had a Router RE that had only direct
    connections to Routers RB and RC. This would be a backbone router only.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has illustrated the chief drawback to hierarchical topology mentioned
    earlier in this chapter: complexity. For large ASes, however, it has significant
    advantages over making every router a peer. At the same time, the conceptual complexity
    is made worse by the need for very careful design, especially of the backbone.
    If the hierarchy is not set up properly, a single failure of a link between routers
    could disrupt the backbone and isolate one or more of the areas (including all
    the devices on all networks within the area!).'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Route Determination Using SPF Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key data structure maintained by each router in an OSPF AS is the LSDB,
    which contains a representation of the topology of either the entire AS (in the
    basic topology) or a single area (in the hierarchical topology). As you have seen,
    each router in the AS or area has the same LSDB, so it represents a neutral view
    of the connections between routers and networks.
  prefs: []
  type: TYPE_NORMAL
- en: The SPF Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each router needs to participate in keeping the LSDB up-to-date, but it also
    has its own concerns. It needs to be able to determine what routes it should use
    for datagrams it receives from its connected networks—this is, after all, the
    entire point of a routing protocol. To find the best route, it must determine
    the shortest path between itself and each router or network in the AS or area.
    For this, it needs not a neutral view of the internetwork but a view of it from
    its own perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The router creates this perspective by taking the information in the LSDB and
    transforming it into an *SPF tree*. The term *tree* refers to a data structure
    with a root that has branches coming out that go to other nodes, which also have
    branches. The structure as a whole looks like an upside-down tree. In this case,
    the SPF tree shows the topology information of the AS or area with the router
    that constructs the tree at the top. Each directly connected router or network
    is one step down in the tree; each router or network connected to these first-level
    routers or networks is then connected, and so on, until the entire AS or area
    has been represented.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the router doesn't really *make* the tree; it is just an algorithmic
    calculation performed by the computer within the router. Once this is done, however,
    this logical construct can be used to calculate the cost for that router to reach
    any router or network in the AS (or area). In some cases, there may be more than
    one way to reach a router or network, so the tree is constructed to show only
    the shortest (lowest-cost) path to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Each router is responsible only for sending a datagram on the next leg of its
    journey, and not for what happens to the journey as a whole. After the SPF tree
    is created, the router will create a routing table with an entry for each network,
    showing the cost to reach it, and also the next-hop router to use to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: The SPF tree is created dynamically based on the current state of the LSDB.
    If the LSDB ever changes, the SPF tree and the routing information are recalculated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** To determine what routes it should use to reach networks in
    its AS, a router generates a *shortest-path first tree (SPF tree)* from its LSDB.
    This tree contains the same basic information as the LSDB, but presents it from
    the point of view of the router doing the calculation, so that router can see
    the costs of various paths to different networks.'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Route Determination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I can almost see your eyes glazing over, so let's go back to the example we
    have been using in this chapter. Let's assume that we are looking at the AS as
    a whole in basic topology, for simplicity. [Table 39-2](ch39s04.html#sample_ospf_lsdb_with_costs
    "Table 39-2. Sample OSPF LSDB with Costs") repeats the LSDB for this AS shown
    earlier in [Table 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb "Table 39-1. Sample
    OSPF Link-State Database (LSDB)"), but I have taken the liberty of replacing the
    bullets with cost metrics; these are shown in [Figure 39-3](ch39s04.html#sample_ospf_as_with_costs_this_is_the_sa
    "Figure 39-3. Sample OSPF AS with Costs This is the same sample AS that is shown
    in Figure 39-1, but with costs assigned to each of the links between routers and
    networks. Costs between routers and networks are applied only in the direction
    from the router to the network.") as well. Again, remember that there is no cost
    to reach a router from a network, so those links have a nonzero cost only going
    from the router to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-2. Sample OSPF LSDB with Costs
  prefs: []
  type: TYPE_NORMAL
- en: '| To Router/Network | From Router | From Network |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | RA | RB | RC | RD | N1 | N2 | N3 | N4 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **RA** |   |   |   |   | 0 | 0 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **RB** |   |   | 5 |   |   | 0 | 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| **RC** |   | 5 |   |   |   | 0 | 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| **RD** |   |   |   |   |   |   | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| **N1** | 2 |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **N2** | 3 | 4 | 3 |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **N3** |   | 5 | 6 | 1 |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **N4** |   |   |   | 4 |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '![Sample OSPF AS with Costs This is the same sample AS that is shown in , but
    with costs assigned to each of the links between routers and networks. Costs between
    routers and networks are applied only in the direction from the router to the
    network.](httpatomoreillycomsourcenostarchimages288047.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-3. Sample OSPF AS with Costs This is the same sample AS that is shown
    in [Figure 39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_ "Figure 39-1. Sample
    OSPF AS This is the same AS that you looked at in RIP (as shown in Figure 38-1
    in Chapter 38), but with the addition of a link between the two Routers RB and
    RC."), but with costs assigned to each of the links between routers and networks.
    Costs between routers and networks are applied only in the direction from the
    router to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's construct the SPF tree for RC. We can do this in iterations, as follows
    (see [Figure 39-4](ch39s04.html#ospf_route_determination_using_the_spf_a "Figure 39-4. OSPF
    route determination using the SPF algorithm This diagram shows graphically how
    a router, in this case Router RC, determines the best path to various networks.
    The arrows here represent not the transfer of data, but rather the examination
    of various links from a router to other routers or networks. In panel 1, Router
    RC examines its LSDB and determines the cost for each of its directly linked devices.
    In panel 2, the second level of the SPF tree is constructed by adding to those
    numbers the costs of all routers/networks that connect to the routers/networks
    found in panel 1\. (The black arrows represent looking back in the direction we
    came from in the prior step, which we don't pursue.) In panel 3 the process continues,
    resulting in the determination of a cost of 5 for Router RC to reach Network N1
    and 10 to reach Network N4.")).
  prefs: []
  type: TYPE_NORMAL
- en: '![OSPF route determination using the SPF algorithm This diagram shows graphically
    how a router, in this case Router RC, determines the best path to various networks.
    The arrows here represent not the transfer of data, but rather the examination
    of various links from a router to other routers or networks. In panel 1, Router
    RC examines its LSDB and determines the cost for each of its directly linked devices.
    In panel 2, the second level of the SPF tree is constructed by adding to those
    numbers the costs of all routers/networks that connect to the routers/networks
    found in panel 1\. (The black arrows represent looking back in the direction we
    came from in the prior step, which we don''t pursue.) In panel 3 the process continues,
    resulting in the determination of a cost of 5 for Router RC to reach Network N1
    and 10 to reach Network N4.](httpatomoreillycomsourcenostarchimages288049.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-4. OSPF route determination using the SPF algorithm This diagram shows
    graphically how a router, in this case Router RC, determines the best path to
    various networks. The arrows here represent not the transfer of data, but rather
    the examination of various links from a router to other routers or networks. In
    panel 1, Router RC examines its LSDB and determines the cost for each of its directly
    linked devices. In panel 2, the second level of the SPF tree is constructed by
    adding to those numbers the costs of all routers/networks that connect to the
    routers/networks found in panel 1\. (The black arrows represent looking back in
    the direction we came from in the prior step, which we don't pursue.) In panel
    3 the process continues, resulting in the determination of a cost of 5 for Router
    RC to reach Network N1 and 10 to reach Network N4.
  prefs: []
  type: TYPE_NORMAL
- en: First Level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To construct the first level of the tree, we look for all devices that Router
    RC can reach directly. We find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Router RB, with a cost of 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network N2, with a cost of 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network N3, with a cost of 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second Level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To construct the second level, we look for all devices that the devices on the
    first level can reach directly. We then add the cost to reach each device on the
    first level to the cost of each device at the second level.
  prefs: []
  type: TYPE_NORMAL
- en: '**RB**: Router RB has a cost of 5 and can reach the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Router RC, with a cost of 5, total cost of 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network N2, with a cost of 4, total cost of 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network N3, with a cost of 5, total cost of 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**N2**: Network N2 has a cost of 3 and can reach the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Router RA, with a cost of 0, total cost of 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router RB, with a cost of 0, total cost of 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router RC, with a cost of 0, total cost of 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**N3**: Network N3 has a cost of 6 and can reach the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Router RB, with a cost of 0, total cost of 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router RC, with a cost of 0, total cost of 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router RD, with a cost of 0, total cost of 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You probably can see immediately that we ended up with a number of different
    paths to the same devices or networks, some of which make no sense. For example,
    we don''t really care about any path that goes to Router RC, since we *are* Router
    RC! Similarly, we can weed out certain paths immediately because we already have
    a shorter path to them. Taking a path through Router RB to Network N3 with a cost
    of 10 makes no sense when we can go directly at the first level for a cost of
    6\. So, after separating out the chaff, we end up with the following wheat at
    the second level:'
  prefs: []
  type: TYPE_NORMAL
- en: Network N2 to Router RA, with a cost of 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network N3 to Router RD, with a cost of 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third Level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We continue the process by looking for devices that connect to the weeded-out
    devices that we found on the second level (this time I am only showing the meaningful
    ones):'
  prefs: []
  type: TYPE_NORMAL
- en: '**RA**: Router RA connects to Network N1, with a cost of 2, total cost of 5.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RD**: Router RD connects to Network N4, with a cost of 4, total cost of 10.'
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, we only need three levels to construct the tree for
    Router RC. (We would need more for Router RA or RD.) The final results would be
    the tree shown in [Figure 39-5](ch39s04.html#ospf_calculated_spf_tree_this_is_a_graph
    "Figure 39-5. OSPF calculated SPF tree This is a graphical representation of the
    SPF tree calculated in Figure 39-4, showing only the final results of the calculation
    process.") and the routing information for RC to the four networks that is shown
    in [Table 39-3](ch39s04.html#example_of_calculated_ospf_routes "Table 39-3. Example
    of Calculated OSPF Routes").
  prefs: []
  type: TYPE_NORMAL
- en: '![OSPF calculated SPF tree This is a graphical representation of the SPF tree
    calculated in , showing only the final results of the calculation process.](httpatomoreillycomsourcenostarchimages288051.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-5. OSPF calculated SPF tree This is a graphical representation of
    the SPF tree calculated in [Figure 39-4](ch39s04.html#ospf_route_determination_using_the_spf_a
    "Figure 39-4. OSPF route determination using the SPF algorithm This diagram shows
    graphically how a router, in this case Router RC, determines the best path to
    various networks. The arrows here represent not the transfer of data, but rather
    the examination of various links from a router to other routers or networks. In
    panel 1, Router RC examines its LSDB and determines the cost for each of its directly
    linked devices. In panel 2, the second level of the SPF tree is constructed by
    adding to those numbers the costs of all routers/networks that connect to the
    routers/networks found in panel 1\. (The black arrows represent looking back in
    the direction we came from in the prior step, which we don't pursue.) In panel
    3 the process continues, resulting in the determination of a cost of 5 for Router
    RC to reach Network N1 and 10 to reach Network N4."), showing only the final results
    of the calculation process.
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-3. Example of Calculated OSPF Routes
  prefs: []
  type: TYPE_NORMAL
- en: '| Destination Network | Cost | Next Hop |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **N1** | 5 | RA |'
  prefs: []
  type: TYPE_TB
- en: '| **N2** | 3 | (local) |'
  prefs: []
  type: TYPE_TB
- en: '| **N3** | 6 | (local) |'
  prefs: []
  type: TYPE_TB
- en: '| **N4** | 10 | RD |'
  prefs: []
  type: TYPE_TB
- en: This is what you would expect in this very simple example. Note that there are
    no specific entries for other routers, since they are the means to the end of
    reaching networks. However, if one of the other routers were a boundary router
    that connected the AS to the outside world, there would be entries for the networks
    to which the boundary router connected, so Router RC knew to send traffic for
    those networks to that boundary router.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF General Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a routing protocol, the main job of OSPF is to facilitate the exchange of
    routing information between routers. Each router in an OSPF AS that runs OSPF
    software is responsible for various tasks, such as setting timers to control certain
    activities that must occur on a regular basis, and the maintenance of important
    data structures, such as the LSDB. Most important, each OSPF router must both
    generate and respond to OSPF messages. It is this messaging system that allows
    important routing information to be shared within an AS or area, which makes it
    crucial to understanding how OSPF works. So it's worth starting a discussion of
    OSPF operation by taking a look at the message types and how they are used.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Message Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike RIP, OSPF does not send its information using the User Datagram Protocol
    (UDP). Instead, OSPF forms IP datagrams directly, packaging them using protocol
    number 89 for the Internet Protocol (IP) Protocol field. OSPF defines five different
    message types, for various types of communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello** As the name suggests, these messages are used as a form of greeting
    to allow a router to discover other adjacent routers on its local links and networks.
    The messages establish relationships between neighboring devices (called *adjacencies*)
    and communicate key parameters about how OSPF is to be used in the AS or area.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database Description** These messages contain descriptions of the topology
    of the AS or area; that is, they convey the contents of the LSDB for the AS or
    area from one router to another. Communicating a large LSDB may require several
    messages to be sent; this is done by designating the sending device as a master
    device and sending messages in sequence, with the slave (recipient of the LSDB
    information) responding with acknowledgments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link State Request** These messages are used by one router to request updated
    information about a portion of the LSDB from another router. The message specifies
    the link(s) about which the requesting device wants more current information.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link State Update** These messages contain updated information about the
    state of certain links on the LSDB. They are sent in response to a Link State
    Request message, and they are also broadcast or multicast by routers on a regular
    basis. Their contents are used to update the information in the LSDBs of routers
    that receive them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link State Acknowledgment** These messages provide reliability to the link-state
    exchange process by explicitly acknowledging receipt of a Link State Update message.'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of these messages is approximately as follows. When a router first starts
    up it will send out a Hello message to see if any neighboring routers are around
    running OSPF, and it will also send them out periodically to discover any new
    neighbors that may show up. When an adjacency is set up with a new router, Database
    Description messages will then be sent to initialize the router's LSDB.
  prefs: []
  type: TYPE_NORMAL
- en: Routers that have been initialized enter a steady state mode. They will each
    routinely flood their local networks with Link State Update messages, advertising
    the state of their links. They will also send out updates when they detect a change
    in topology that needs to be communicated. They will receive Link State Update
    messages sent by other devices, and respond with Link State Acknowledgments accordingly.
    Routers may also request updates using Link State Request messages.
  prefs: []
  type: TYPE_NORMAL
- en: When the hierarchical topology is used, internal routers maintain a single LSDB
    and perform messaging only within an area. Area border routers have multiple LSDBs
    and perform messaging in more than one area. They, along with any other OSPF backbone
    routers, also exchange messaging information on the backbone, including summarized
    link-state information for the areas they border.
  prefs: []
  type: TYPE_NORMAL
- en: Again, all of this is highly simplified; the OSPF standard contains pages and
    pages of detailed rules and procedures governing the exact timing for sending
    and receiving messages.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The operation of OSPF involves five message types. Hello messages
    establish contact between routers. Database Description messages initialize a
    router''s LSDB. Routine LSDB updates are sent using Link State Update messages,
    which are acknowledged using Link State Acknowledgments. A device may also request
    a specific update using a Link State Request message.'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Message Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OSPF standard specifies that all OSPF messages are authenticated for security.
    This is a bit misleading, however, since one of the authentication methods supported
    is null authentication, meaning no authentication is used. More security is provided
    by using the optional simple password authentication method, and the most security
    is available through the use of cryptographic authentication. These methods are
    described in Appendix D of RFC 2328.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Hello messages used in OSPF are also sometimes called the* Hello Protocol.
    *This is especially poor terminology, because there is an actual routing protocol
    called the* HELLO Protocol. *The two protocols are not related. However, I suspect
    that the OSPF Hello messages may have been so named because they serve a similar
    purpose to the messages used in the independent HELLO Protocol*.'
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Message Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in the previous section, OSPF uses five different types of messages
    to communicate both link-state and general information between routers within
    an AS or area. To help illustrate how the OSPF messages are used, it's worth taking
    a look at the format of each of these messages.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Common Header Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naturally, each type of OSPF message includes a slightly different set of information;
    otherwise, there wouldn't be different message types. However, all message types
    share a similar message structure, beginning with a shared 24-byte header. This
    common header allows certain standard information to be conveyed in a consistent
    manner, such as the number of the version of OSPF that generated the message.
    It also allows a device receiving an OSPF message to quickly determine which type
    of message it has received, so it knows whether or not it needs to bother examining
    the rest of the message. [Table 39-4](ch39s06.html#ospf_common_header_format-id001
    "Table 39-4. OSPF Common Header Format") and [Figure 39-6](ch39s06.html#ospf_common_header_format_following_this
    "Figure 39-6. OSPF common header format Following this header, the body of the
    message includes a variable number of fields that depend on the message type.
    Each of the message formats is described in detail in RFC 2328\. Since some are
    quite long, I will describe their fields only briefly here.") show the common
    OSPF header format.
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-4. OSPF Common Header Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Version # | 1 | Set to 2 for OSPF version 2. |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Indicates the type of OSPF message:1 = Hello2 = Database Description3
    = Link State Request4 = Link State Update5 = Link State Acknowledgment |'
  prefs: []
  type: TYPE_TB
- en: '| Packet Length | 2 | The length of the message, in bytes, including the 24
    bytes of this header. |'
  prefs: []
  type: TYPE_TB
- en: '| Router ID | 4 | The ID of the router that generated this message (generally
    its IP address on the interface over which the message was sent). |'
  prefs: []
  type: TYPE_TB
- en: '| Area ID | 4 | An identification of the OSPF area to which this message belongs,
    when areas are used. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum computed in a manner similar to a standard
    IP checksum. The entire message is included in the calculation except for the
    Authentication field. |'
  prefs: []
  type: TYPE_TB
- en: '| AuType | 2 | Indicates the type of authentication used for this message:0
    = No Authentication1 = Simple Password Authentication2 = Cryptographic Authentication
    |'
  prefs: []
  type: TYPE_TB
- en: '| Authentication | 8 | A 64-bit field used for authentication of the message,
    as needed. |'
  prefs: []
  type: TYPE_TB
- en: '![OSPF common header format Following this header, the body of the message
    includes a variable number of fields that depend on the message type. Each of
    the message formats is described in detail in RFC 2328\. Since some are quite
    long, I will describe their fields only briefly here.](httpatomoreillycomsourcenostarchimages288053.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-6. OSPF common header format Following this header, the body of the
    message includes a variable number of fields that depend on the message type.
    Each of the message formats is described in detail in RFC 2328\. Since some are
    quite long, I will describe their fields only briefly here.
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Hello Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hello messages have a Type value of 1 in the header, and the field structure
    shown in [Table 39-5](ch39s06.html#ospf_hello_message_format-id001 "Table 39-5. OSPF
    Hello Message Format") and [Figure 39-7](ch39s06.html#ospf_hello_message_format-id002
    "Figure 39-7. OSPF Hello message format") in the body of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-5. OSPF Hello Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Network Mask | 4 | The subnet mask of the network the router is sending to.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Hello Interval | 2 | The number of seconds this router waits between sending
    Hello messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | 1 | Indicates which optional OSPF capabilities the router supports.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Rtr Pri | 1 | Indicates the router''s priority, when electing a backup designated
    router. |'
  prefs: []
  type: TYPE_TB
- en: '| Router Dead Interval | 4 | The number of seconds a router can be silent before
    it is considered to have failed. |'
  prefs: []
  type: TYPE_TB
- en: '| Designated Router | 4 | The address of a router designated for certain special
    functions on some networks. Set to zeros if there is no designated router. |'
  prefs: []
  type: TYPE_TB
- en: '| Backup Designated Router | 4 | The address of a backup designated router.
    Set to all zeros if there is no backup designated router. |'
  prefs: []
  type: TYPE_TB
- en: '| Neighbors | Multiple of 4 | The addresses of each router from which this
    router has received Hello messages recently. |'
  prefs: []
  type: TYPE_TB
- en: '![OSPF Hello message format](httpatomoreillycomsourcenostarchimages288055.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-7. OSPF Hello message format
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Database Description Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database Description messages have a Type value of 2 in the header and the body
    structure depicted in [Table 39-6](ch39s06.html#ospf_database_description_message_-id001
    "Table 39-6. OSPF Database Description Message Format") and [Figure 39-8](ch39s06.html#ospf_database_description_message_-id002
    "Figure 39-8. OSPF Database Description message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-6. OSPF Database Description Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Interface MTU | 2 | The size of the largest IP message that can be sent on
    this router''s interface without fragmentation. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | 1 | Indicates which of several optional OSPF capabilities the router
    supports. |'
  prefs: []
  type: TYPE_TB
- en: '| Flags | 1 | Special flags used to indicate information about the exchange
    of Database Description messages, as shown in [Table 39-7](ch39s06.html#ospf_database_description_message_flags
    "Table 39-7. OSPF Database Description Message Flags"). |'
  prefs: []
  type: TYPE_TB
- en: '| DD Sequence Number | 4 | Used to number a sequence of Database Description
    messages so that they are kept in order. |'
  prefs: []
  type: TYPE_TB
- en: '| LSA Headers | Variable | Contains LSA headers, which carry information about
    the LSDB. See the "OSPF Link State Advertisements and the LSA Header Format" section
    later in this chapter for more information about LSAs. Please add correct cross-ref
    info. |'
  prefs: []
  type: TYPE_TB
- en: Table 39-7. OSPF Database Description Message Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 5/8 (5 bits) | Reserved: Sent and received as zero. |'
  prefs: []
  type: TYPE_TB
- en: '| I | 1/8 (1 bit) | I-Bit: Set to 1 to indicate that this is the first (initial)
    in a sequence of Database Description messages. |'
  prefs: []
  type: TYPE_TB
- en: '| M | 1/8 (1 bit) | M-Bit: Set to 1 to indicate that more Database Description
    messages follow this one. |'
  prefs: []
  type: TYPE_TB
- en: '| MS | 1/8 (1 bit) | MS-Bit: Set to 1 if the router sending this message is
    the master in the communication, or 0 if it is the slave. |'
  prefs: []
  type: TYPE_TB
- en: '![OSPF Database Description message format](httpatomoreillycomsourcenostarchimages288057.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-8. OSPF Database Description message format
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Link State Request Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Link State Request messages have a Type value of 3 in the header. Following
    the header comes one or more sets of three fields, each of which identify an LSA
    for which the router is requesting an update, as shown in [Figure 39-9](ch39s06.html#ospf_link_state_request_message_-id002
    "Figure 39-9. OSPF Link State Request Message format"). Each LSA identification
    has the format described in [Table 39-8](ch39s06.html#ospf_link_state_request_message_-id001
    "Table 39-8. OSPF Link State Request Message Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-8. OSPF Link State Request Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LS Type | 4 | The type of LSA being sought. |'
  prefs: []
  type: TYPE_TB
- en: '| Link State ID | 4 | The identifier of the LSA, usually the IP address of
    either the router or network linked. |'
  prefs: []
  type: TYPE_TB
- en: '| Advertising Router | 4 | The ID of the router that created the LSA whose
    update is being sought. |'
  prefs: []
  type: TYPE_TB
- en: '![OSPF Link State Request Message format](httpatomoreillycomsourcenostarchimages288059.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-9. OSPF Link State Request Message format
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Link State Update Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Link State Update messages have a Type value of 4 in the header and the fields
    illustrated in [Table 39-9](ch39s06.html#ospf_link_state_update_message_for-id001
    "Table 39-9. OSPF Link State Update Message Format") and [Figure 39-10](ch39s06.html#ospf_link_state_update_message_for-id002
    "Figure 39-10. OSPF Link State Update message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-9. OSPF Link State Update Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| # LSAs | 4 | The number of LSAs included in this message. |'
  prefs: []
  type: TYPE_TB
- en: '| LSAs | Variable | One or more LSAs. See the "OSPF Link State Advertisements
    and the LSA Header Format" section later in this chapter for more details. |'
  prefs: []
  type: TYPE_TB
- en: '![OSPF Link State Update message format](httpatomoreillycomsourcenostarchimages288061.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-10. OSPF Link State Update message format
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Link State Acknowledgment Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Link State Acknowledgment messages have a Type value of 5 in the header. They
    then contain a list of LSA headers corresponding to the LSAs being acknowledged,
    as shown in [Table 39-10](ch39s06.html#ospf_link_state_acknowledgment_mes-id001
    "Table 39-10. OSPF Link State Acknowledgment Message Format") and [Figure 39-11](ch39s06.html#ospf_link_state_acknowledgment_mes-id002
    "Figure 39-11. OSPF Link State Acknowledgment message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-10. OSPF Link State Acknowledgment Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LSA Headers | Variable | Contains LSA headers that identify the LSAs acknowledged.
    |'
  prefs: []
  type: TYPE_TB
- en: '![OSPF Link State Acknowledgment message format](httpatomoreillycomsourcenostarchimages288063.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-11. OSPF Link State Acknowledgment message format
  prefs: []
  type: TYPE_NORMAL
- en: OSPF Link State Advertisements and the LSA Header Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several of the previous message types include LSAs, which are the fields that
    actually carry topological information about the LSDB. There are several types
    of LSAs, which are used to convey information about different types of links.
    Like the OSPF messages themselves, each LSA has a common header with 20 bytes
    and then a number of additional fields that describe the link.
  prefs: []
  type: TYPE_NORMAL
- en: The LSA header contains sufficient information to identify the link. It uses
    the subfield structure shown in [Table 39-11](ch39s06.html#ospf_link_state_advertisement_header_for
    "Table 39-11. OSPF Link State Advertisement Header Format") and [Figure 39-12](ch39s06.html#ospf_link_state_advertisement_head-id001
    "Figure 39-12. OSPF Link State Advertisement header format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-11. OSPF Link State Advertisement Header Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LS Age | 2 | The number of seconds elapsed since the LSA was created. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | 1 | Indicates which of several optional OSPF capabilities the router
    supports. |'
  prefs: []
  type: TYPE_TB
- en: '| LS Type | 1 | Indicates the type of link this LSA describes, as shown in
    [Table 39-12](ch39s06.html#ospf_link_state_advertisement_header_ls_ "Table 39-12. OSPF
    Link State Advertisement Header LS Types"). |'
  prefs: []
  type: TYPE_TB
- en: '| Link State ID | 4 | Identifies the link. This usually is the IP address of
    either the router or the network the link represents. |'
  prefs: []
  type: TYPE_TB
- en: '| Advertising Router | 4 | The ID of the router originating the LSA. |'
  prefs: []
  type: TYPE_TB
- en: '| LS Sequence Number | 4 | A sequence number used to detect old or duplicate
    LSAs. |'
  prefs: []
  type: TYPE_TB
- en: '| LS Checksum | 2 | A checksum of the LSA for data corruption protection. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 2 | The length of the LSA, including the 20 bytes of the header.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 39-12. OSPF Link State Advertisement Header LS Types
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Link Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Router-LSA | Link to a router. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Network-LSA | Link to a network. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Summary-LSA (IP Network) | When areas are used, summary information is
    generated about a network. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Summary-LSA (ASBR) | When areas are used, summary information is generated
    about a link to an AS boundary router. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | AS-External-LSA | An external link outside the AS. |'
  prefs: []
  type: TYPE_TB
- en: '![OSPF Link State Advertisement header format](httpatomoreillycomsourcenostarchimages288065.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 39-12. OSPF Link State Advertisement header format
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the LSA header comes the body of the LSA. The specific fields in
    the body depend on the value of the LS Type field (see [Table 39-12](ch39s06.html#ospf_link_state_advertisement_header_ls_
    "Table 39-12. OSPF Link State Advertisement Header LS Types")). Here is a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: For normal links to a router, the LSA includes an identification of the router
    and the metric to reach it, as well as details about the router such as whether
    it is a boundary or area border router.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LSAs for networks include a subnet mask and information about other routers
    on the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary LSAs include a metric and a summarized address as well as a subnet mask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External LSAs include a number of additional fields that allow the external
    router to be communicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to Appendix A of RFC 2328 if you want all the details about the fields
    in the LSA body.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modern TCP/IP internetworks are composed of autonomous systems (ASes) that are
    run independently. Each may use an interior routing protocol such as Routing Information
    Protocol (RIP), Open Shortest Path First (OSPF), Interior Gateway Routing Protocol
    (IGRP), or Enhanced Interior Gateway Routing Protocol (EIGRP) to select routes
    between networks within the AS. To form larger internetworks, and especially the
    "mother of all internetworks," the Internet, these ASes must be connected together.
    This requires use of a consistent exterior routing protocol that all ASes can
    agree upon, and in today's TCP/IP, that protocol is the *Border Gateway Protocol
    (BGP)*.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to ask the average Internet user, or even the typical network administrator,
    to make a list of the ten most important TCP/IP protocols, BGP probably wouldn't
    show up frequently. Routing protocols are worker bees of the TCP/IP protocol suite,
    and they just are not very exciting. The reality, however, is that BGP is a critically
    important protocol to the operation of larger internetworks and the Internet itself.
    It is the glue that binds smaller internetworks (ASes) together, and it ensures
    that every organization is able to share routing information. It is this function
    that lets us take disparate networks and internetworks and find efficient routes
    from any host to any other host, regardless of location.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe the characteristics, general operation, and detailed
    operation of BGP. I start, as usual, with an overview of the protocol and discuss
    its history, standards, and versions, including a discussion of its key features
    and characteristics. I then cover basic operational concepts, including topology,
    the notion of BGP speakers, and neighbor relationships. I discuss BGP traffic
    types and how policies can be used to control traffic flows on the internetwork.
    I explain how BGP routers store and advertise routes and how Routing Information
    Bases function. I describe the basic algorithm used by BGP and how path attributes
    describe routes. I provide a summary of how the BGP route selection process operates.
    I then give a general description of BGP's operation and its high-level use of
    various messages. Finally, I present a more detailed analysis of the different
    message types, how they are used, and their format.
  prefs: []
  type: TYPE_NORMAL
- en: BGP is another in the rather large group of protocols and technologies that
    is so complex it would take dozens of chapters to do justice. Therefore, I include
    here my somewhat standard disclaimer that you will find in this chapter only a
    relatively high-level look at BGP. You will need to refer to the BGP standards
    (described in the section on BGP standards and versions) if you need more details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The current version of BGP is version 4, also called* BGP-4\. *This is the
    only version widely used today, so unless otherwise indicated, assume that I''m
    talking about BGP-4 wherever you see* BGP.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I described briefly in the overview of routing protocol concepts in [Chapter 37](ch37.html
    "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS"), the way that routers
    were connected in the early Internet was quite different than it is today. The
    early Internet had a set of centralized routers functioning as a core AS. These
    routers used the Gateway-to-Gateway Protocol (GGP) for communication between them
    within the AS and the aptly named Exterior Gateway Protocol (EGP) to talk to routers
    outside the core. GGP and EGP are discussed in [Chapter 41](ch41.html "Chapter 41. OTHER
    ROUTING PROTOCOLS").
  prefs: []
  type: TYPE_NORMAL
- en: When the Internet grew and moved to AS architecture, EGP was still able to function
    as the exterior routing protocol for the Internet. However, as the number of ASes
    in an internetwork grew, the importance of communication between them grew as
    well. EGP was functional but had several weaknesses that became more problematic
    as the Internet expanded. It was necessary to define a new exterior routing protocol
    that would provide enhanced capabilities for use on the growing Internet.
  prefs: []
  type: TYPE_NORMAL
- en: In June 1989, the first version of this new routing protocol was formalized,
    with the publishing of RFC 1105, "A Border Gateway Protocol (BGP)." This initial
    version of the BGP standard defined most of the concepts behind the protocol,
    as well as key fundamentals such as messaging, message formats, and how devices
    operate in general terms. It established BGP as the Internet's exterior routing
    protocol of the future.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Versions and Defining Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the importance of a protocol that spans the Internet, work continued
    on BGP for many years after the initial standard was published. The developers
    of BGP needed to correct problems with the initial protocol, refine BGP's operation,
    improve efficiency, and add features. It was also necessary to make adjustments
    to allow BGP to keep pace with other changes in the TCP/IP protocol suite, such
    as the invention of classless addressing and routing.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this ongoing work is that BGP has evolved through several versions
    and standards. These are sometimes called BGP-*N*, where *N* is the version number.
    [Table 40-1](ch40.html#border_gateway_protocol_bgp_versions_and "Table 40-1. Border
    Gateway Protocol (BGP) Versions and Defining Standards") shows the history of
    BGP standards, providing the RFC numbers and names, and a brief summary of the
    changes made in each version.
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-1. Border Gateway Protocol (BGP) Versions and Defining Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| RFC Number | Date | Name | BGP Version | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1105 | June 1989 | A Border Gateway Protocol (BGP) | BGP-1 | Initial definition
    of the BGP. |'
  prefs: []
  type: TYPE_TB
- en: '| 1163 | June 1990 | A Border Gateway Protocol (BGP) | BGP-2 | This version
    cleaned up several issues with BGP-1 and refined the meaning and use of several
    of the message types. It also added the important concept of path attributes,
    which communicate information about routes. BGP-1 was designed around the notion
    of a directional topology, with certain routers being up, down, or horizontal
    relative to each other; BGP-2 removed this concept, making BGP better suited to
    an arbitrary AS topology. (Note that the RFC title is not a typo; they didn''t
    put "version 2" in the title.) |'
  prefs: []
  type: TYPE_TB
- en: '| 1267 | October 1991 | Border Gateway Protocol 3 (BGP-3) | BGP-3 | This version
    optimized and simplified route information exchange, adding an identification
    capability to the messages used to establish BGP communications, and incorporating
    several other improvements and corrections. (They left the "A" off the title of
    this one for some reason.) |'
  prefs: []
  type: TYPE_TB
- en: '| 1654 | July 1994 | A Border Gateway Protocol 4 (BGP-4) | BGP-4 | Initial
    standard for BGP-4, revised in RFC 1771. |'
  prefs: []
  type: TYPE_TB
- en: '| 1771 | March 1995 | A Border Gateway Protocol 4 (BGP-4) | BGP-4 | Current
    standard for BGP-4\. The primary change in BGP-4 is support for Classless Inter-Domain
    Routing (CIDR). The protocol was changed to allow prefixes to be specified that
    represent a set of aggregated networks. Other minor improvements were also made
    to the protocol. |'
  prefs: []
  type: TYPE_TB
- en: As you might imagine, changing the version of a protocol like BGP is not an
    easy undertaking. Any modification of the protocol would require the coordination
    of many different organizations. The larger the Internet grows, the more difficult
    this would be. As a result, despite frequent version changes in the early 1990s,
    BGP-4 remains today the current version of the standard and is the one that is
    widely used. Unless otherwise specified, any mention of BGP in this book refers
    to BGP-4.
  prefs: []
  type: TYPE_NORMAL
- en: Supplementing RFC 1771 are three other consecutively numbered RFCs published
    simultaneously with it, which provide supporting information about BGP's functions
    and use, as shown in [Table 40-2](ch40.html#additional_defining_standards_for_bgp-
    "Table 40-2. Additional Defining Standards for BGP-4").
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-2. Additional Defining Standards for BGP-4
  prefs: []
  type: TYPE_NORMAL
- en: '| RFC Number | Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1772 | Application of the Border Gateway Protocol in the Internet | Provides
    additional conceptual information on the operation of BGP and how it is applied
    to and used on the Internet. This document is sometimes considered a companion
    of RFC 1771 with the pair defining BGP-4. |'
  prefs: []
  type: TYPE_TB
- en: '| 1773 | Experience with the BGP-4 Protocol | Describes the experiences of
    those testing and using BGP-4 and provides information that justified its acceptance
    as a standard. |'
  prefs: []
  type: TYPE_TB
- en: '| 1774 | BGP-4 Protocol Analysis | Provides more detailed technical information
    about the operation of BGP-4. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The exterior routing protocol used in modern TCP/IP internetworks
    is the *Border Gateway Protocol (BGP)*. Initially developed in the late 1980s
    as a successor to the Exterior Gateway Protocol (EGP), BGP has been revised many
    times; the current version is 4, so BGP is also commonly called BGP-4\. BGP''s
    primary function is the exchange of network reachability information between ASes
    to allow each AS on an internetwork to send messages efficiently to every other
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of BGP Functions and Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If I were to summarize the job of BGP in one phrase, it would be to exchange
    network reachability information between ASes and from this information determine
    routes to networks. In a typical internetwork (and in the Internet), each AS designates
    one or more routers that run BGP software. BGP routers in each AS are linked to
    those in one or more other ASes. Each BGP stores information about networks and
    the routes to them in a set of Routing Information Bases (RIBs). This route information
    is exchanged between BGP routers and propagated throughout the entire internetwork,
    allowing each AS to find paths to each other AS, and thereby enabling routing
    across the entire internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: BGP supports an arbitrary topology of ASes, meaning that they can be connected
    in any manner. An AS must have a minimum of one router running BGP, but can have
    more than one. It is also possible to use BGP to communicate between BGP routers
    within the same AS.
  prefs: []
  type: TYPE_NORMAL
- en: BGP uses a fairly complex system for route determination. The protocol goes
    beyond the limited notion of considering only the next hop to a network the way
    distance-vector algorithms like RIP function. Instead, the BGP router stores more
    complete information about the path (sequence of ASes) from itself to a network.
    Special path attributes describe the characteristics of paths and are used in
    the process of route selection. Because of its storage of path information, BGP
    is sometimes called a *path-vector* protocol.
  prefs: []
  type: TYPE_NORMAL
- en: BGP chooses routes using a deterministic algorithm that assesses path attributes
    and chooses an efficient route, while avoiding router loops and other problem
    conditions. The selection of routes by a BGP router can also be controlled through
    a set of BGP policies that specify, for example, whether an AS is willing to carry
    traffic from other ASes. However, BGP cannot guarantee the most efficient route
    to any destination, because it cannot know what happens within each AS and therefore
    what the cost is to traverse each AS.
  prefs: []
  type: TYPE_NORMAL
- en: BGP's operation is based on the exchange of messages that perform different
    functions. BGP routers use Open messages to contact neighboring routers and establish
    BGP sessions. They exchange Update messages to communicate information about reachable
    networks, sending only partial information as needed. They also use Keepalive
    and Notification messages to maintain sessions and inform peers of error conditions.
    The use of these messages is explained thoroughly later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** BGP supports an arbitrary topology of ASes. Each AS using BGP
    assigns one or more routers to implement the protocol. These devices then exchange
    messages to establish contact with each other and share information about rates
    through the internetwork using the Transmission Control Protocol (TCP). BGP employs
    a sophisticated path vector route calculation algorithm that determines routes
    from path attributes that describe how different networks can be reached.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP uses the Transmission Control Protocol (TCP) as a reliable transport protocol
    so that it can take advantage of the many connection setup and maintenance features
    of that protocol. This also means that BGP doesn't need to worry about issues
    such as message sequencing, acknowledgments, or lost transmissions. Since unauthorized
    BGP messages could wreak havoc with the operation of the Internet, BGP includes
    an authentication scheme for security.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*BGP maintains backward compatibility with the older exterior routing protocol,
    EGP*.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, I boiled down the function of BGP into this summary:
    the exchange of network reachability information between ASes of routers and networks,
    and the determination of routes from this information. The actual method that
    BGP uses to accomplish this, however, is fairly complex.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important characteristics of BGP is its flexibility. The protocol
    can connect together any internetwork of ASes using an arbitrary topology. The
    only requirement is that each AS have at least one router that is able to run
    BGP and that this router connect to at least one other AS's BGP router. Beyond
    that, "the sky is the limit," as they say. BGP can handle a set of ASes connected
    in a full mesh topology (each AS to each other AS), a partial mesh, a chain of
    ASes linked one to the next, or any other configuration. It also handles changes
    to topology that may occur over time.
  prefs: []
  type: TYPE_NORMAL
- en: Another important assumption that BGP makes is that it doesn't know anything
    about what happens within the AS. This is an important prerequisite to the notion
    of an AS being autonomous—it has its own internal topology and uses its own choice
    of routing protocols to determine routes. BGP just takes the information conveyed
    to it from the AS and shares it with other ASes.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Speakers, Router Roles, Neighbors, and Peers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a BGP internetwork begins with the designation of certain routers in
    each AS as ones that will run the protocol. In BGP parlance, these are called
    *BGP speakers*, since they speak the BGP language. A protocol can reasonably be
    called a language, but I have not encountered this notion of a speaker in any
    other protocol, so it's somewhat interesting terminology.
  prefs: []
  type: TYPE_NORMAL
- en: An AS can contain many routers that are connected in an arbitrary topology.
    We can draw a distinction between routers in an AS that are connected only to
    other routers within the AS versus those that connect to other ASes. Routers in
    the former group are usually called *internal routers*, while those in the latter
    group are called *border routers* in BGP (as well as similar names in other protocols;
    for example, in OSPF they are called *boundary routers*).
  prefs: []
  type: TYPE_NORMAL
- en: The notion of a border is the basis for the name of the BGP itself. To actually
    create the BGP internetwork, the BGP speakers bordering each AS are physically
    connected to one or more BGP speakers in other ASes, in whatever topology the
    internetwork designer decrees. When a BGP speaker in one AS is linked to a BGP
    speaker in another AS, they are deemed *neighbors*. The direct connection between
    them allows them to exchange information about the ASes of which they are a part.
  prefs: []
  type: TYPE_NORMAL
- en: Most BGP speakers will be connected to more than one other speaker. This provides
    both greater efficiency in the form of more direct paths to different networks
    and redundancy to allow the internetwork to cope with either device or connection
    failures. It is possible (and in many cases, likely) for a BGP speaker to have
    neighbor relationships with other BGP speakers both within its own AS and outside
    its AS. A neighbor within the AS is called an *internal peer*, while a neighbor
    outside the AS is an *external peer*. BGP between internal peers is sometimes
    called *Internal BGP (IBGP);* use of the protocol between external peers is *External
    BGP (EBGP)*. The two are similar, but differ in certain areas, especially path
    attributes and route selection. You can see an example of BGP topology and the
    designation of internal and external peers in [Figure 40-1](ch40s02.html#sample_bgp_topology_and_designations
    "Figure 40-1. Sample BGP topology and designations").
  prefs: []
  type: TYPE_NORMAL
- en: This diagram is a variation on [Figure 37-1](ch37.html#tcpip_autonomous_system_as_routing_archi
    "Figure 37-1. TCP/IP autonomous system (AS) routing architecture This diagram
    shows a simplified Internet organized into three ASes, each of which is managed
    independently from the others. Communication within each AS is done using an interior
    routing protocol chosen by that AS's administrators (thin links). Communication
    between ASes must be done using a common exterior routing protocol (thick links).
    Internal routers are shown in lighter text, and border routers are shown in black
    text.") in [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL
    CONCEPTS"). It shows the names used by BGP to refer to different types of routers
    and ASes. Internal routers are shown in faint type, while border routers are in
    bold type. BGP speakers that communicate within an AS are internal peers, while
    those that communicate between ASes are external peers. This highly simplified
    internetwork shows two stub ASes, both of which only connect to the multihomed
    AS 2\. A peer connection between BGP speakers can be either a direct link using
    some form of layer 2 technology or an indirect link using TCP. This allows the
    BGP speakers to establish BGP sessions and then exchange routing information,
    using the messaging system you will see later in this chapter. It also is the
    means by which actual end-user traffic moves between ASes. External peers are
    normally connected directly, while internal peers are often linked indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: You will see in a moment that the method in which ASes are connected has an
    important impact on the overall function of the internetwork and how traffic is
    carried on it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample BGP topology and designations](httpatomoreillycomsourcenostarchimages288067.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 40-1. Sample BGP topology and designations
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each router configured to use BGP is called a BGP *speaker*;
    these devices exchange route information using the BGP *messaging system*. Routers
    that connect only to other routers in the same AS are called *internal routers*,
    while those that connect to other ASes are *border routers*. Neighboring BGP speakers
    in the same AS are called *internal peers*, while those in different ASes are
    *external peers*.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP AS Types, Traffic Flows, and Routing Policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we connect ASes together to form an internetwork, the paths between AS
    border routers form the conduit by which messages move from one AS to another.
    It is very important that the flow of messages between ASes be carefully controlled.
    Depending on circumstances, we may wish to limit or even prohibit certain types
    of messages from going to or from a certain AS. These decisions in turn have a
    direct impact on BGP route determination.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Traffic Flow and Traffic Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow of messages in an internetwork is sometimes collectively called *traffic*.
    This term presents a good analogy, because we can consider the matter of traffic
    flow control in a BGP internetwork in much the same way that we do the streets
    of a city. You have probably seen signs on residential streets that say "No Through
    Traffic" or "Local Traffic Only." These are attempts to control the flow of traffic
    over those streets. A more extreme example of this would be a street in the neighborhood
    where I used to live, where a barricade was intentionally erected in the middle
    to turn a busy through street into a pair of dead ends. Again, the goal was traffic
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'These measures highlight a key distinction between local traffic and through
    traffic in a neighborhood. The very same categorization is important in BGP, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Traffic** Traffic carried within an AS that either originated in that
    same AS *or* is intended to be delivered within that AS. This is like local traffic
    on a street.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transit Traffic** Traffic that was generated outside that AS and is intended
    to be delivered outside the AS. This is like through traffic on streets.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP AS Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, I discussed the distinction between internal routers
    and border (or boundary) routers in an AS. We can make a similar distinction between
    different types of ASes, based on how they are interconnected in the overall BGP
    topology. There are two main types of ASes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stub AS** This is an AS that is connected to only one other AS. It is comparable
    to a cul-de-sac (dead-end street) in a road analogy; usually, only vehicles coming
    from or going to houses on the street will be found on that street.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multihomed AS** This is an AS that is connected to two or more other ASes.
    It is comparable to a through street in the road analogy, because it is possible
    that vehicles may enter the street and pass through it, without stopping at any
    of the street''s houses.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example BGP internetwork in [Figure 40-1](ch40s02.html#sample_bgp_topology_and_designations
    "Figure 40-1. Sample BGP topology and designations"), I have linked border routers
    in AS 2 to both AS 1 and AS 3\. While traffic from AS 2 can flow both to and from
    AS 1 and AS 3, it is possible that traffic from AS 1 may also flow to AS 3 and
    vice versa. AS 2 acts as the "through street" for these datagrams.
  prefs: []
  type: TYPE_NORMAL
- en: BGP AS Routing Policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The reason why BGP makes a distinction between traffic types and AS types is
    the same reason why it is done on the streets: Many folks have a dim view of through
    traffic. In a neighborhood, everyone wants to be able to get from their homes
    to anywhere they need to go in the city, but they don''t want a lot of other people
    using their streets. Similarly, every AS must use at least one other AS to communicate
    with distant ASes, but many are less than enthusiastic about being a conduit for
    a lot of external traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This reluctance really does make sense in many cases, either in the case of
    a neighborhood or in the case of BGP. Having many cars and trucks on a residential
    street can be a problem in a number of ways: safety issues, wear and tear on the
    road, pollution, and so forth. Similarly, if a multihomed AS was forced to carry
    all transit traffic that other ASes want to send to it, it might become overloaded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide control over the carrying of transit traffic, BGP allows an AS to
    set up and use routing policies. These are sets of rules that govern how an AS
    will handle transit traffic. A great deal of flexibility exists in how an AS decides
    to handle transit traffic. Some of the many options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Transit Policy** An AS can have a policy that it will not handle transit
    traffic at all.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restricted AS Transit Policy** An AS may allow for the handling of traffic
    from certain ASes but not others. In this case, it tells the ASes it will handle
    that they may send it traffic, but does not say this to the others.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Criteria-Based Transit Policy** An AS may use a number of different criteria
    to decide whether to allow transit traffic. For example, it might allow transit
    traffic only during certain times or only when it has enough spare capacity.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*An AS that is willing to carry transit traffic is sometimes called a* transit
    AS.'
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, policies can be set that control how an AS will have its
    own traffic handled by other ASes. A stub AS will always connect to the internetwork
    as a whole using the single AS to which it connects. A multihomed AS, however,
    may have policies that influence route selection by specifying the conditions
    under which one AS should be used over another. These policies may be based on
    considerations of security (if one connecting AS is deemed more secure than another),
    performance (if one AS is faster than another), reliability, or other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One important issue in BGP is how to handle the flow of traffic
    between ASes. Each AS in a BGP internetwork is either a *stub AS* if it connects
    to only one other AS, or a *multihomed AS* if it connects to two or more others.
    BGP allows the administrators of a multihomed AS to establish routing policies
    that specify under what conditions the AS is willing to handle transit traffic
    (messages sent over the AS whose source and destination are both external to that
    AS).'
  prefs: []
  type: TYPE_NORMAL
- en: Issues with Routing Policies and Internetwork Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What would happen to a city if every street only allowed local traffic? It would
    be pretty hard to get around. Of course this problem never occurs in well-designed
    cities, because traffic planners understand the dual need for connectivity and
    through-traffic avoidance in residential areas. Cities are laid out in a somewhat
    hierarchical fashion, so local traffic funnels to thoroughfares intended specifically
    to carry nonlocal traffic.
  prefs: []
  type: TYPE_NORMAL
- en: The same basic situation exists in an internetwork. It wouldn't work very well
    if every AS declared that it was not interested in carrying transit traffic! Usually,
    internetworks are designed so that certain ASes are intended to carry large amounts
    of transit traffic. This is typically the function of high-speed, high-capacity
    backbone connections that serve other ASes as customers. An AS will usually carry
    another AS's traffic only if arrangements have been made to allow this.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Route Storage and Advertisement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The job of the BGP is to facilitate the exchange of route information between
    BGP devices so that each router can determine efficient routes to each of the
    networks on an IP internetwork. This means that descriptions of routes are the
    key data that BGP devices work with. Every BGP speaker is responsible for managing
    route descriptions according to specific guidelines established in the BGP standards.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Route Information Management Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conceptually, the overall activity of route information management can be considered
    to encompass four main tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Storage** Each BGP stores information about how to reach networks in
    a set of special databases. It also uses databases to hold routing information
    received from other devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Update** When a BGP device receives an Update message from one of its
    peers, it must decide how to use this information. Special techniques are applied
    to determine when and how to use the information received from peers to properly
    update the device''s knowledge of routes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Selection** Each BGP uses the information in its route databases to
    select good routes to each network on the internetwork.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Advertisement** Each BGP speaker regularly tells its peers what it
    knows about various networks and methods to reach them. This is called *route
    advertisement* and is accomplished using BGP Update messages. You''ll learn more
    about these messages later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Routing Information Bases (RIBs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The heart of BGP's system of routing information management and handling is
    the database where routes are stored. This database is collectively called the
    *Routing Information Base (RIB)*, but it is not actually a monolithic entity.
    It is composed of three separate sections that are used by a BGP speaker to handle
    the input and output of routing information. Two of these sections consist of
    several individual parts, or copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three RIB sections (using the cryptic names given them by the BGP standards)
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adj-RIBs-In** A set of input database parts that holds information about
    routes received from peer BGP speakers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loc-RIB** The local RIB. This is the core database that stores routes that
    have been selected by this BGP device and are considered valid to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adj-RIBs-Out** A set of output database parts that holds information about
    routes that this BGP device has selected to be disseminated to its peers.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the RIB can be considered either a single database or a set of related
    databases, depending on how you look at it. (The previous divisions are conceptual
    in nature; the entire RIB can be implemented as a single database with an internal
    structure representing the different components, or implemented as separate databases.)
  prefs: []
  type: TYPE_NORMAL
- en: The RIB is a fairly complex data structure, not just because of this multisection
    structure, but also because BGP devices store considerably more information about
    routes than simpler routing protocols. Routes are also called *paths* in BGP,
    and the detailed descriptions of them are stored in the form of special BGP path
    attributes, which we will examine shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The three sections of the RIB are the mechanism by which information flow is
    managed in a BGP speaker. Data received from Update messages transmitted by peer
    BGP speakers is held in the Adj-RIBs-In, with each Adj-RIB-In holding input from
    one peer. This data is then analyzed and appropriate portions of it are selected
    to update the Loc-RIB, which is the main database of routes this BGP speaker is
    using. On a regular basis, information from the Loc-RIB is placed into the Adj-RIBs-Out
    to be sent to other peers using Update messages. This information flow is accomplished
    as part of the system of route update, selection, and advertisement known as the
    BGP decision process, which I'll discuss in the "BGP Route Determination and the
    BGP Decision Process" section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The routine operation of BGP requires BGP speakers to store,
    update, select, and advertise routing information. The central data structure
    used for this purpose is the *BGP Routing Information Base (RIB)*. The RIB actually
    consists of three sections: a set of input databases *(Adj-RIBs-In)* that hold
    routing information received from peers; a local database *(Loc-RIB)* that contains
    the router''s current routes; and a set of output databases *(Adj-RIBs-Out)* used
    by the router to send its routing information to other routers.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Path Attributes and Algorithm Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing protocols that use a distance-vector algorithm, such as RIP, are relatively
    simple in large part because the information each device stores about each route
    is itself simple. Each router only knows that it can reach a network at a specific
    cost through a particular next-hop router. It doesn't have knowledge of the route
    that datagrams will take to reach any of these networks. This level of knowledge
    is simply insufficient for the needs of a protocol like BGP.
  prefs: []
  type: TYPE_NORMAL
- en: In order to handle the calculation of efficient, nonlooping routes in an arbitrary
    topology of ASes, we need to know not just that we must get Network N7 to send
    to Router R4, but also the characteristics of the entire path between ourselves
    and Network N7\. By storing this additional information, it is possible to make
    decisions about how to compute and change routes, using knowledge of the entire
    path between a router and a network. Thus, instead of advertising networks in
    terms of a destination and the distance to that destination, BGP devices advertise
    networks as destination addresses and path descriptions to reach those destinations.
    This means BGP uses, instead of a distance-vector algorithm, a *path-vector algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each communication of a reachable network provides considerable information
    about the entire sequence of routers to a destination. Due to this inclusion of
    topology information, path-vector protocols are sometimes described as a combination
    of distance-vector and link-state algorithms. This doesn''t really do them justice,
    however, since they do not function in the same way as either of those algorithm
    types. (If you are interested in additional general information about path-vector
    algorithms, you can find some in RFC 1322, "A Unified Approach to Inter-Domain
    Routing." (Warning: do not read before operating heavy machinery.)'
  prefs: []
  type: TYPE_NORMAL
- en: The information about the path to each route is stored in the RIB of each BGP
    speaker in the form of BGP path attributes. These attributes are used to advertise
    routes to networks when BGP devices send out Update messages. The storing, processing,
    sending, and receiving of path attributes is the method by which routers decide
    how to create routes, so understanding them is obviously quite important.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different path attributes, each of which describes a particular
    characteristic of a route. Attributes are divided into different categories based
    on their level of importance and specific rules designed to manage their propagation.
    The most important path attributes are called *well-known attributes*; every BGP
    speaker must recognize and process these, but only some are required to be sent
    with every route. Other attributes are optional and may or not be implemented.
    These are further differentiated based on how they are handled when received by
    a device that does not recognize them.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Path Attribute Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The four formal classifications of path attributes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well-Known Mandatory** These are the most important path attributes. They
    must be included in every route description in Update messages, and must be processed
    by each BGP device receiving them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well-Known Discretionary** A BGP device, if received, must recognize these
    path attributes, but they may or may not be included in an Update message. Thus,
    they are optional for a sender of information, but mandatory for a receiver to
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Transitive** These path attributes may be recognized by a BGP router
    and may be included in an Update message. They must be passed on to other BGP
    speakers when the route is advertised, even if received by a device that does
    not recognize the attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Nontransitive** Optional attributes that may be recognized by a
    BGP device and may be included in an Update message. If received by a device that
    does not recognize the attribute, it is dropped and not passed on to the next
    router.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Unlike simpler routing protocols that store only limited information
    about how to reach a network, BGP stores detailed information about complete routes
    to various networks. This information takes the form of *path attributes* that
    describe various characteristics of a path (route) through the ASes that connect
    a router to a destination network.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As you might imagine, all well-known attributes are by definition transitive—they
    must be passed on from one BGP speaker to the next*.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Path Attribute Characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 40-3](ch40s04.html#summary_of_bgp_path_attributes "Table 40-3. Summary
    of BGP Path Attributes") provides a summary of the characteristics of each of
    the most common BGP path attributes used to describe the route to a destination.
    It also provides a summary of the Attribute Type code assigned to each characteristic
    in BGP Update messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-3. Summary of BGP Path Attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| BGP Path Attribute | Classification | Attribute Type Value | Description
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Origin | Well-Known Mandatory | 1 | Specifies the origin of the path information.
    This attribute indicates whether the path came originally from an interior routing
    protocol, the older exterior routing protocol, or some other source. |'
  prefs: []
  type: TYPE_TB
- en: '| AS_Path | Well-Known Mandatory | 2 | A list of AS numbers that describes
    the sequence of ASes through which this route description has passed. This is
    a critically important attribute, since it contains the actual path of ASes to
    the network. It is used to calculate routes and to detect routing loops. |'
  prefs: []
  type: TYPE_TB
- en: '| Next_Hop | Well-Known Mandatory | 3 | The next-hop router to be used to reach
    this destination. |'
  prefs: []
  type: TYPE_TB
- en: '| Multi_Exit_Disc (MED) | Optional Non-Transitive | 4 | When a path includes
    multiple exit or entry points to an AS, this value may be used as a metric to
    discriminate between them (that is, choose one exit or entry point over the others).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Local_Pref | Well-Known Discretionary | 5 | Used in communication between
    BGP speakers in the same AS to indicate the level of preference for a particular
    route. |'
  prefs: []
  type: TYPE_TB
- en: '| Atomic_Aggregate | Well-Known Discretionary | 6 | In certain circumstances,
    a BGP speaker may receive a set of overlapping routes whereby one is more specific
    than the other. For example, consider a route to the network 34.15.67.0/24 and
    to the network 34.15.67.0/26\. The latter network is a subset of the former, which
    makes it more specific. If the BGP speaker uses the less-specific route (in this
    case, 34.15.67.0/24), it sets this path attribute to a value of 1 to indicate
    that this was done. |'
  prefs: []
  type: TYPE_TB
- en: '| Aggregator | Optional Transitive | 7 | Contains the AS number and BGP ID
    of the router that performed route aggregation; used for troubleshooting. |'
  prefs: []
  type: TYPE_TB
- en: Some of these path attributes are straightforward; others are fairly cryptic
    and probably confusing. Delving into any more detail on the path attributes leads
    us into a full-blown description of detailed inter-AS route calculations. We'll
    look at that to some degree in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Route Determination and the BGP Decision Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have now looked at the fundamentals of how BGP devices store and manage
    information about routes to networks. This included an overview of the four route
    information management activities performed by BGP speakers: route storage, update,
    selection, and advertisement. Route storage is the function of the RIB in each
    BGP speaker. Path attributes are the mechanism by which BGP stores details about
    routes and also describes those details to BGP peers.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Decision Process Phases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have seen, the RIB also contains sections for holding input information
    received from BGP peers and for holding output information that each BGP device
    wants to send to those peers. The functions of route update, selection, and advertisement
    are concerned with analyzing this input information. They also decide what to
    include in the local database, update that database, and then choose what routes
    to send from it to peer devices. In BGP, a mechanism called the *decision process*
    is responsible for these tasks. It consists of three overall phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 1** Each route received from a BGP speaker in a neighboring AS is analyzed
    and assigned a preference level. The routes are then ranked according to preference
    and the best one for each network advertised to other BGP speakers within the
    AS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 2** The best route for each destination is selected from the incoming
    data based on preference levels, and it''s used to update the local routing information
    base (the Loc-RIB).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 3** Routes in the Loc-RIB are selected to be sent to neighboring BGP
    speakers in other ASes.'
  prefs: []
  type: TYPE_NORMAL
- en: Criteria for Assigning Preferences to Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Obviously, if a BGP speaker only knows of a single route to a network, it will
    install and use that route (assuming there are no problems with it). The assigning
    of preferences among routes becomes important only when more than one route has
    been received by a BGP speaker for a particular network. Preferences can be determined
    based on a number of different criteria. The following are a few typical ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of ASes between the router and the network (fewer generally being
    better).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existence of certain policies that may make certain routes unusable; for
    example, a route may pass through an AS that as the BGP speaker is not willing
    to trust with its data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The origin of the path—that is, where it came from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case where a set of routes to the same network are all calculated to
    have the same preference, a tie-breaking scheme is used to select from among them.
    Additional logic is used to handle special circumstances, such as the case of
    overlapping networks (see the description of the Atomic_Aggregate path attribute
    in [Table 40-3](ch40s04.html#summary_of_bgp_path_attributes "Table 40-3. Summary
    of BGP Path Attributes") for an example of this).
  prefs: []
  type: TYPE_NORMAL
- en: The selection of routes for dissemination to other routers in phase 3 is based
    on a rather complex algorithm that I cannot explain adequately here. Route advertisement
    is guided by the routing policies I discussed earlier in this chapter. Different
    rules are used to select routes for advertising to internal peers compared to
    external peers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The method used by a BGP speaker to determine what new routes
    to accept from its peers and what routes to advertise back them is called the
    *BGP decision process*. It is a complex algorithm in three phases that involves
    the computation of the best route based on both preexisting and incoming path
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations on BGP's Ability to Select Efficient Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When considering route selection, it's very important to remember that BGP is
    a routing protocol that operates at the inter-AS level. Thus, routes are chosen
    between ASes, not at the level of individual routers within an AS. So, for example,
    when BGP stores information about the path to a network, it stores it as a sequence
    of ASes, not a sequence of specific routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'BGP cannot deal with individual routers in an AS because, by definition, the
    details of what happens within an AS are supposed to be hidden from the outside
    world. It doesn''t know the structure of ASes outside its own. This has an important
    implication for how BGP selects routes: BGP cannot guarantee that it will pick
    the fastest, lowest-cost route to every network. It can select a route that minimizes
    the number of ASes that lie between itself and a particular network, but, of course,
    ASes are not all the same. Some ASes are large and consist of many slow links;
    others are small and fast. Choosing a route through two of the latter types of
    AS will be better than choosing a route through one of the former, but BGP can''t
    know that. Policies can be used to influence AS selection to some extent, but
    in general, since BGP doesn''t know what happens in an AS, it cannot guarantee
    the efficiency of a route overall. (Incidentally, this is the reason why there
    is no general cost or distance path attribute in BGP.)'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** As an exterior routing protocol, BGP operates at the AS level.
    Its routes are calculated based on paths between ASes, not individual routers.
    Since BGP, by definition, does not know the internal structure of routers within
    an AS, it cannot know for certain the cost to send a datagram across a given AS.
    This means that BGP cannot always guarantee that it will select the absolute lowest-cost
    route between any two networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Originating New Routes and Withdrawing Unreachable Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naturally, a facility exists to allow BGP speakers to originate new routes to
    networks. A BGP speaker may obtain knowledge about a new route from an interior
    routing protocol on an AS to which it is directly attached, and then it may choose
    to share this information with other ASes. It will create a new entry in its RIB
    for this network and then send information about it out to other BGP peers.
  prefs: []
  type: TYPE_NORMAL
- en: BGP also includes a mechanism for advertising routes it cannot reach. These
    are called unfeasible or withdrawn routes and are mentioned in Update messages
    to indicate that a router can no longer reach the specific network.
  prefs: []
  type: TYPE_NORMAL
- en: BGP General Operation and Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you have seen how BGP stores information about routes
    and uses it to determine paths to various networks. Let's now take a high-level
    look at how BGP operates in general terms. Like many other protocols covered in
    this book, BGP's operation can be described primarily in the form of messaging.
    The use of messages is the means by which route information is communicated between
    BGP peers. This eventually allows the knowledge of how to reach networks to spread
    throughout the entire internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: Speaker Designation and Connection Establishment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before messaging can begin, BGP speakers must be designated and then linked
    together. The BGP standard does not specify how neighboring speakers are determined;
    this must be done outside the protocol. Once accomplished, ASes are connected
    into a BGP-enabled internetwork. Topological linking provides the physical connection
    and the means for datagrams to flow between ASes. At this point, the dance floor
    is prepared, but nobody is dancing; BGP can function but isn't yet in operation.
  prefs: []
  type: TYPE_NORMAL
- en: BGP operation begins with BGP peers forming a transport protocol connection.
    BGP uses TCP for its reliable transport layer, so the two BGP speakers establish
    a TCP session that remains in place during the course of the subsequent message
    exchange. When this is done, each BGP speaker sends a BGP Open message. This message
    is like an invitation to dance, and it begins the process of setting up the BGP
    link between the devices. In this message, each router identifies itself and its
    AS, and also tells its peer what parameters it would like to use for the link.
    This includes an exchange of authentication parameters. Assuming that each device
    finds the contents of its peer's Open message acceptable, it acknowledges it with
    a Keepalive message, and the BGP session begins.
  prefs: []
  type: TYPE_NORMAL
- en: Under normal circumstances, most BGP speakers will maintain simultaneous sessions
    with more than one other BGP speaker, both within the speaker's own AS and outside
    its AS. Links between ASes are what enable BGP routers to learn how to route through
    the internetwork. Links within the AS are important to ensure that each BGP speaker
    in the AS maintains consistent information.
  prefs: []
  type: TYPE_NORMAL
- en: Route Information Exchange
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming the link is initialized, the two peers begin an ongoing process of
    telling each other what they know about networks and how to reach them. Each BGP
    speaker encodes information from its RIBs into BGP Update messages. These messages
    contain lists of known network addresses, as well as information about paths to
    various networks, as described in the form of path attributes, as you have already
    seen. This information is then used for the route determination, as described
    in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: When a link is first set up between two peers, those peers ensure that each
    router holds complete information by exchanging their complete routing tables.
    Subsequently, Update messages are sent. They contain only incremental updates
    about routes that have changed. Exchanging only updated information as needed
    reduces unnecessary bandwidth on the network, thereby making BGP more efficient
    than it would be if it sent full routing table information on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: Connectivity Maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TCP session between BGP speakers can be kept open for a very long time.
    Update messages need to be sent only when changes occur to routes, which are usually
    infrequent. This means many seconds may elapse between the transmission of Update
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the peers maintain contact with each other, they both send Keepalive
    messages on a regular basis when they don't have other information to send. These
    are null messages that contain no data and just tell the peer device "I'm still
    here." These messages are sent infrequently—no more often than one per second—but
    regularly enough that the peers won't think the session was interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Error Reporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last type of BGP message is the BGP Notification message. This is an error
    message; it tells a peer that a problem occurred and describes the nature of the
    error condition. After sending a BGP Notification message, the device that sent
    it will terminate the BGP connection between the peers. A new connection will
    then need to be negotiated, possibly after the problem that led to the Notification
    message has been corrected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** BGP is implemented through the exchange of four different message
    types between BGP speakers. A BGP session begins with a TCP connection being established
    between two routers and each sending an Open message to the other. BGP Update
    messages are the primary mechanism by which routing information is exchanged between
    devices. Small BGP Keepalive messages are used to maintain communication between
    devices between periods when they need to exchange information. Finally, Notification
    messages are used for problem reporting.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Detailed Messaging, Operation, and Message Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, I have discussed the concepts and general operation of the BGP. To get
    a better understanding of exactly how BGP works, it is helpful to take a detailed
    look at its four different message types—Open, Update, Keepalive, and Notification—and
    how they are used. As we do this, we can examine the fields in each message type,
    so that you can comprehend not just the way that messaging is accomplished, but
    the way that routing data is actually communicated. Let's begin with a description
    of common attributes of BGP message generation and transport, and the general
    format used for all BGP messages.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Message Generation and Transport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each router running BGP generates messages to implement the various functions
    of the protocol. Some of these messages are created on a regular basis by the
    BGP software during the course of its normal operation. These are generally controlled
    by timers that are set and counted down to cause them to be sent. Other messages
    are sent in response to messages received from BGP peers, possibly after a processing
    step.
  prefs: []
  type: TYPE_NORMAL
- en: BGP is different from most other routing protocols in that it was designed from
    the start to operate using a reliable method of message delivery. TCP is present
    in the software of every Internet Protocol (IP) router, thereby making it the
    obvious choice for reliable data communication in a TCP/IP Internet, and that's
    what BGP uses. Routing protocols are usually considered part of layer 3, but this
    one runs over a layer 4 protocol, thereby making BGP a good example of why architectural
    models are best used only as a guideline.
  prefs: []
  type: TYPE_NORMAL
- en: TCP provides numerous advantages to BGP by taking care of most of the details
    of session setup and management, thereby allowing BGP to focus on the data it
    needs to send. TCP takes care of session setup and negotiation, flow control,
    congestion handling, and any necessary retransmissions of lost messages, thereby
    ensuring that messages are received and acknowledged. BGP uses well-known TCP
    port 179 for connections.
  prefs: []
  type: TYPE_NORMAL
- en: BGP General Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of TCP also has an interesting impact on the way BGP messages are structured.
    One thing that stands out when you look at the BGP message format (as you will
    see shortly) is that a BGP message can have an odd number of bytes. Most routing
    protocols are sized in units of 4 or 8 bytes, but since TCP sends data as a stream
    of octets, there is no need for BGP messages to break on a 32-bit or 64-bit boundary.
    The other impact is the need of a special Marker field to help ensure that BGP
    messages can be differentiated from each other in the TCP stream (more about this
    in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: Like most messaging protocols, BGP uses a common message format for each of
    its four message types. Each BGP message is conceptually divided into a header
    and a body (called the *data portion* in the BGP standard). The header has three
    fields and is fixed in length at 19 bytes. The body is variable in length and
    is omitted entirely in Keepalive messages, since it is not needed for them.
  prefs: []
  type: TYPE_NORMAL
- en: The general format for all BGP message types is shown in [Table 40-4](ch40s07.html#bgp_general_message_format-id001
    "Table 40-4. BGP General Message Format") and illustrated in [Figure 40-2](ch40s07.html#bgp_general_message_format-id002
    "Figure 40-2. BGP general message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-4. BGP General Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. The minimum value of this field is 19 for a Keepalive message;
    it may be as high as 4096. |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Indicates the BGP message type:1 = Open2 = Update3 = Notification4
    = Keepalive |'
  prefs: []
  type: TYPE_TB
- en: '| Message Body/Data Portion | Variable | Contains the specific fields used
    to implement each message type for Open, Update, and Notification messages. |'
  prefs: []
  type: TYPE_TB
- en: '![BGP general message format](httpatomoreillycomsourcenostarchimages288069.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 40-2. BGP general message format
  prefs: []
  type: TYPE_NORMAL
- en: The Marker field is the most interesting one in the BGP message format. It is
    used for both synchronization and authentication. BGP uses a single TCP session
    to send many messages in a row. TCP is a stream-oriented transport protocol that
    sends bytes across the link without any knowledge of what the bytes represent.
    This means that the protocol using TCP is responsible for deciding where the line
    is drawn between data units—in this case, BGP messages.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the Length field tells each BGP device where to draw the line between
    the end of one message and the start of the next. However, it is possible that,
    due to various conditions, a device might lose track of where the message boundary
    is. The Marker field is filled with a recognizable pattern that clearly marks
    the start of each message; BGP peers keep synchronized by looking for that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Before a BGP connection is established, the Marker field is filled with all
    ones. Thus, this is the pattern used for Open messages. Once a BGP session is
    negotiated, if agreement is reached on an authentication method between the two
    devices, the Marker field takes on the additional role of authentication. Instead
    of looking for a Marker field containing all ones, BGP devices look for a pattern
    generated using the agreed-upon authentication method. Detection of this pattern
    simultaneously synchronizes the devices and ensures that messages are authentic.
  prefs: []
  type: TYPE_NORMAL
- en: In extreme cases, BGP peers may be unable to maintain synchronization, and if
    so, a Notification message is generated and the session is closed. This will also
    happen if the Marker field contains the wrong data when authentication is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** All four BGP message types use a general message format that
    contains three fixed header fields—Marker, Length, and Type—and room for a message
    body that differs for each message type. The large Marker field is used to denote
    the start of a new BGP message, and it is also used to facilitate the BGP authentication
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'BGP Connection Establishment: Open Messages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before a BGP session can be used to exchange routing information, a connection
    must first be established between BGP peers. This process begins with the creation
    of a TCP connection between the devices. Once this is done, the BGP devices will
    attempt to create a BGP session by exchanging BGP Open messages.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Open Message Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Open message has two main purposes. The first is identification and initiation
    of a link between the two devices; it allows one peer to tell the other, "I am
    a BGP speaker named X on AS Y, and I want to start exchanging BGP information
    with you." The second is the negotiation of session parameters. These are the
    terms by which the BGP session will be conducted. One important parameter negotiated
    using Open messages is the method that each device wants to use for authentication.
    The importance of BGP means that authentication is essential in order to prevent
    bad information or a malicious person from disrupting routes.
  prefs: []
  type: TYPE_NORMAL
- en: Each BGP receiving an Open message processes it. If the message's contents are
    acceptable, including the parameters the other device wants to use, it responds
    with a Keepalive message as an acknowledgment. Each peer must send an Open message
    and receive a Keepalive acknowledgment for the BGP link to be initialized. If
    either is not willing to accept the terms of the Open message, the link is not
    established. In that case, a Notification message may be sent to convey the nature
    of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Open Message Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specific format for BGP Open messages is shown in [Table 40-5](ch40s07.html#bgp_open_message_format-id001
    "Table 40-5. BGP Open Message Format") and [Figure 40-3](ch40s07.html#bgp_open_message_format-id002
    "Figure 40-3. BGP Open message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-5. BGP Open Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Open messages are variable in length. |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | BGP message type; value is 1 for Open messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 | Indicates the BGP version the sender of the Open message is
    using. This field allows devices to reject connections with devices using versions
    that they may not be capable of understanding. The current value is 4, for BGP-4,
    and is used by most, if not all, current BGP implementations. |'
  prefs: []
  type: TYPE_TB
- en: '| My Autonomous System | 2 | Identifies the AS number of the sender of the
    Open message. AS numbers are centrally managed across the Internet in a manner
    similar to how IP addresses are administered. |'
  prefs: []
  type: TYPE_TB
- en: '| Hold Time | 2 | The number of seconds that this device proposes to use for
    the BGP hold timer, which specifies how long a BGP peer will allow the connection
    to be left silent between receipt of BGP messages. A BGP device may refuse a connection
    if it doesn''t like the value that its peer is suggesting; usually, however, the
    two devices agree to use the smaller of the values suggested by each device. The
    value must be at least 3 seconds, or 0\. If 0, this specifies that the hold timer
    is not used. See the Keepalive message discussion later in this chapter for more
    on how the hold timer is used. |'
  prefs: []
  type: TYPE_TB
- en: '| BGP Identifier | 4 | Identifies the specific BGP speaker. You''ll recall
    that IP addresses are associated with interfaces, not devices, so each router
    will have at least two IP addresses. Normally, the BGP identifier is chosen as
    one of these addresses. Once chosen, this identifier is used for all BGP communications
    with BGP peers. This includes BGP peers on the interface from which the identifier
    was chosen, and also BGP peers on other interfaces as well. So, if a BGP speaker
    with two interfaces has addresses IP1 and IP2, it will choose one as its identifier
    and use it on both of its interfaces. |'
  prefs: []
  type: TYPE_TB
- en: '| Opt Parm Len | 1 | The number of bytes used for Optional Parameters (see
    the following entry). If 0, no optional parameters are in this message. |'
  prefs: []
  type: TYPE_TB
- en: '| Optional Parameters | Variable | Allows the Open message to communicate any
    number of extra parameters during BGP session setup. Each parameter is encoded
    using a rather standard type/length/value triple, as shown in [Table 40-6](ch40s07.html#bgp_open_message_optional_parameters
    "Table 40-6. BGP Open Message Optional Parameters"). |'
  prefs: []
  type: TYPE_TB
- en: Table 40-6. BGP Open Message Optional Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Parm Type | 1 | Parameter Type: The type of the optional parameter. At present,
    only one value is defined, 1, for Authentication Information. |'
  prefs: []
  type: TYPE_TB
- en: '| Parm Length | 1 | Parameter Length: Specifies the length of the Parameter
    Value subfield (thus, this value is the length of the entire parameter, less 2).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Parm Value | Variable | Parameter Value: The value of the parameter being
    communicated. |'
  prefs: []
  type: TYPE_TB
- en: 'BGP Open messages currently use only one optional parameter: Authentication
    Information. Its Parameter Value subfield contains a one-byte Authentication Code
    sub-subfield, which specifies the type of authentication a device wishes to use.
    Following this is a variable-length Authentication Data sub-subfield. The Authentication
    Code specifies how authentication is to be performed, including the meaning of
    the Authentication Data field, and the manner in which Marker fields are to be
    calculated.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** BGP sessions begin with each peer in a connection sending the
    other a BGP Open message. The purpose of this message is to establish contact
    between devices, identify the sender of the message and its AS, and negotiate
    important parameters that dictate how the session will be conducted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'BGP Route Information Exchange: Update Messages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once BGP speakers have made contact and a link has been established using Open
    messages, the devices begin the actual process of exchanging routing information.
    Each BGP router uses the BGP decision process described earlier in this chapter
    to select certain routes to be advertised to its peer. This information is then
    placed into BGP Update messages, which are sent to every BGP device for which
    a session has been established. These messages are the way that network reachability
    knowledge is propagated around the internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: '![BGP Open message format](httpatomoreillycomsourcenostarchimages288071.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 40-3. BGP Open message format
  prefs: []
  type: TYPE_NORMAL
- en: BGP Update Message Contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each Update message contains either one or both of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Advertisement** The characteristics of a single route.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route Withdrawal** A list of networks that are no longer reachable.'
  prefs: []
  type: TYPE_NORMAL
- en: Only one route can be advertised in an Update message, but several can be withdrawn.
    This is because withdrawing a route is simple; it requires just the address of
    the network for which the route is being removed. In contrast, a route advertisement
    requires a fairly complex set of path attributes to be described, which takes
    up a significant amount of space. (Note that it is possible for an Update message
    to specify only withdrawn routes and not advertise a route at all.)
  prefs: []
  type: TYPE_NORMAL
- en: BGP Update Message Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the amount of information it contains and the complexity of that
    information, BGP Update messages use one of the most complicated structures in
    TCP/IP. The basic structure of the message is described in [Table 40-7](ch40s07.html#bgp_update_message_format-id001
    "Table 40-7. BGP Update Message Format") and illustrated in [Figure 40-4](ch40s07.html#bgp_update_message_format_this_diagram_s
    "Figure 40-4. BGP Update message format This diagram shows the complete BGP Update
    message format, including a set of withdrawn routes, path attributes, and NLRI
    entries. The exploded view shows the substructure of the Attribute Type subfield
    of the Path Attributes, as described in Tables Table 40-9 and Table 40-10.").
    As you can see in that table, several of the fields have their own substructure.
    The Path Attributes field has a complex substructure, which I have shown separately
    in other tables.
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-7. BGP Update Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Update messages are variable in length. |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | BGP message type; value is 2 for Update messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Unfeasible Routes Length | 2 | The length of the Withdrawn Routes field,
    in bytes. If 0, no routes are being withdrawn and the Withdrawn Routes field is
    omitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Withdrawn Routes | Variable | Specifies the addresses of networks for which
    routes are being withdrawn from use. Each address is specified using the two subfields.
    The 1-byte Length field is the number of bits in the IP address Prefix subfield
    that are significant. The variable-length Prefix subfield is the IP address prefix
    of the network whose route is being withdrawn. If the number of bits in the prefix
    is not a multiple of 8, this field is padded with zeros so that it falls on a
    byte boundary. The length of this field is 1 byte if the preceding Length field
    is 8 or less; 2 bytes if it is 9 to 16; 3 bytes if it is 17 to 24; and 4 bytes
    if it is 25 or greater. |'
  prefs: []
  type: TYPE_TB
- en: '| Total Path Attribute Length | 2 | The length of the Path Attributes field,
    in bytes. If 0, indicates no route is being advertised in this message, so Path
    Attributes and Network Layer Reachability Information are omitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Path Attributes | Variable | Describes the path attributes of the route advertised.
    Since some attributes require more information than others, attributes are described
    using a flexible structure that minimizes message size compared to using fixed
    fields that would often be empty. Unfortunately, it also makes the field structure
    confusing. Each attribute has the subfields shown in [Table 40-8](ch40s07.html#bgp_update_message_path_attributes
    "Table 40-8. BGP Update Message Path Attributes"). |'
  prefs: []
  type: TYPE_TB
- en: '| Network Layer Reachability Information (NLRI) | Variable | Contains a list
    of IP address prefixes for the route being advertised. Each address is specified
    using the same general structure as the one used for Withdrawn Routes. The 1-byte
    Length subfield is the number of bits in the Prefix subfield that are significant.
    The variable-length Prefix subfield is the IP address prefix of the network whose
    route is being advertised. If the number of bits in the prefix is not a multiple
    of 8, this field is padded with zeros so that it falls on a byte boundary. The
    length of this field is 1 byte if the preceding Length field is 8 or less; 2 bytes
    if it is 9 to 16; 3 bytes if it is 17 to 24; and 4 bytes if it is25 or greater.
    Unlike most of the other fields in the Update message, the length of the NLRI
    field is not explicitly stated. It is computed from the overall message Length
    field, minus the lengths of the other fields that are explicitly specified. |'
  prefs: []
  type: TYPE_TB
- en: Table 40-8. BGP Update Message Path Attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute Type | 2 | Defines the type of attribute and describes it. This
    subfield itself has a two-level substructure, with Attribute Type flags and Attribute
    Type codes, so it won''t even fit it here! See Tables [Table 40-9](ch40s07.html#bgp_update_message_attribute_flags
    "Table 40-9. BGP Update Message Attribute Flags") and [Table 40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "Table 40-10. BGP Update Message Attribute Type Codes") for details. |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute Length | 1 or 2 | The length of the attribute in bytes. This field
    is normally 1 byte, thereby allowing for fields with a length up to 255 bytes.
    For longer attributes, the Extended Length flag is set (see [Table 40-9](ch40s07.html#bgp_update_message_attribute_flags
    "Table 40-9. BGP Update Message Attribute Flags")), indicating that this Attribute
    Length field is 2 bytes, for attributes up to 65,535 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute Value | Variable | The value of the attribute. The size and meaning
    of this field depends on the type of path attribute. For example, for an Origin
    attribute, it is a single integer value indicating the origin of the route; for
    an AS_Path attribute, this field contains a variable-length list of the ASes in
    the path to the network. |'
  prefs: []
  type: TYPE_TB
- en: '![BGP Update message format This diagram shows the complete BGP Update message
    format, including a set of withdrawn routes, path attributes, and NLRI entries.
    The exploded view shows the substructure of the Attribute Type subfield of the
    Path Attributes, as described in Tables and .](httpatomoreillycomsourcenostarchimages288073.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 40-4. BGP Update message format This diagram shows the complete BGP Update
    message format, including a set of withdrawn routes, path attributes, and NLRI
    entries. The exploded view shows the substructure of the Attribute Type subfield
    of the Path Attributes, as described in Tables [Table 40-9](ch40s07.html#bgp_update_message_attribute_flags
    "Table 40-9. BGP Update Message Attribute Flags") and [Table 40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "Table 40-10. BGP Update Message Attribute Type Codes").
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 40-9](ch40s07.html#bgp_update_message_attribute_flags "Table 40-9. BGP
    Update Message Attribute Flags") shows the structure of the Attribute Flags sub-subfield
    of the Attribute Type subfield of the Path Attributes field. This subfield contains
    a set of flags that describe the nature of the attribute and how to process it.
    You may need to refer to the path attributes description in the "BGP Path Attributes
    and Algorithm Overview" section earlier in this chapter to make sense of these
    flags.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-9. BGP Update Message Attribute Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Sub-Sub-Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Optional | 1/8 (1 bit) | Set to 1 for optional attributes; 0 for well-known
    attributes. |'
  prefs: []
  type: TYPE_TB
- en: '| Transitive | 1/8 (1 bit) | Set to 1 for optional transitive attributes; 0
    for optional nontransitive attributes. Always set to 1 for well-known attributes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Partial | 1/8 (1 bit) | When 1, indicates that information about an optional
    transitive attribute is partial. This means that since it was optional and transitive,
    one or more of the routers that passed the path along did not implement that attribute
    but was forced to pass it along, so information about it may be missing (not supplied
    by the routers that didn''t recognize it but just passed along). If 0, it means
    information is complete. This bit has meaning only for optional transitive attributes;
    for well-known or nontransitive attributes, it is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Extended Length | 1/8 (1 bit) | Set to 1 for long attributes to indicate
    that the Attribute Length field is 2 bytes in size. Normally 0, meaning the Attribute
    Length field is a single byte. |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4/8 (4 bits) | Set to 0 and ignored. |'
  prefs: []
  type: TYPE_TB
- en: The Attribute Type Code sub-subfield of the Attribute Type subfield of the Path
    Attributes field contains a number that identifies the attribute type. [Table 40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "Table 40-10. BGP Update Message Attribute Type Codes") shows the current values.
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-10. BGP Update Message Attribute Type Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Attribute Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Origin |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | AS_Path |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Next_Hop |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Multi_Exit_Disc (MED) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Local_Pref |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Atomic_Aggregate |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Aggregator |'
  prefs: []
  type: TYPE_TB
- en: It may seem confusing that there can be more than one prefix in the Network
    Layer Reachability Information (NLRI) field, even though I said earlier that an
    Update message advertises only one route. There is, in fact, no inconsistency
    here. A single route may be associated with more than one networks; to put it
    another way, multiple networks may have the same path and path attributes. In
    that case, specifying multiple network prefixes in the same Update message is
    more efficient than generating a new one for each network.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The most important message type in BGP is the Update message,
    which is used to send detailed information about routes between BGP devices. It
    uses a complex structure that allows a BGP speaker to efficiently specify new
    routes, update existing ones, and withdraw routes that are no longer valid. Each
    message may include the full description of one existing route and may also withdraw
    from use a list of multiple routes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'BGP Connectivity Maintenance: Keepalive Messages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a BGP connection is established using Open messages, BGP peers will initially
    use Update messages to send each other a large amount of routing information.
    They will then settle into a routine in which the BGP session is maintained, but
    Update messages are sent only when needed. Since these updates correspond to route
    changes, and route changes are normally infrequent, this means many seconds may
    elapse between the receipt of consecutive Update messages.
  prefs: []
  type: TYPE_NORMAL
- en: The BGP Keepalive Message Interval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hold Timer and While a BGP peer is waiting to hear the next Update message,
    it remains sort of like a person who has been put on hold on the telephone. Now
    seconds may not seem like much to us, but to a computer, they are a very long
    time. Like you, a BGP speaker that is put on hold for too long might become impatient
    and might start to wonder if maybe the other guy hung up. Computers don't get
    offended at being put on hold, but they might wonder if perhaps a problem arose
    that led to the connection being interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of how long it has been on hold, each BGP device maintains a special
    *hold timer*. This hold timer is set to an initial value each time its peer sends
    a BGP message. The timer then counts down until the next message is received,
    and then it is reset. If the hold timer ever expires, the connection is assumed
    to have been interrupted and the BGP session is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: The length of the hold timer is negotiated as part of session setup using Open
    messages. It must be at least three seconds long, or may be negotiated as a value
    of zero. If zero, the hold timer is not used; this means the devices are infinitely
    patient and don't care how much time elapses between messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the timer doesn''t expire even when no Update messages need
    to be sent for a long while, each peer periodically sends a BGP Keepalive message.
    The name says it all: The message just keeps the BGP connection alive. The rate
    at which Keepalive messages is sent depends on the implementation, but the standard
    recommends that they be sent with an interval of one-third the value of the hold
    timer. So if the hold timer has a value of three seconds, each peer sends a Keepalive
    message every second (unless it needs to send some other message type in that
    second). To prevent excess bandwidth use, Keepalive messages must be sent no more
    often than once per second, so that is the minimum interval, even if the hold
    timer is shorter than three seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: BGP Keepalive Message Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The point of a Keepalive message is the message itself; there's no data to be
    communicated. In fact, we want to keep the message short and sweet. Thus, it is
    really a dummy message that contains only a BGP header—a nice change after that
    incredibly long Update message format! The format of the Keepalive message is
    shown in [Table 40-11](ch40s07.html#bgp_keepalive_message_format-id001 "Table 40-11. BGP
    Keepalive Message Format") and [Figure 40-5](ch40s07.html#bgp_keepalive_message_format-id002
    "Figure 40-5. BGP Keepalive message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-11. BGP Keepalive Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Keepalive messages are fixed in length at 19 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | BGP message type; value is 4 for Keepalive messages. |'
  prefs: []
  type: TYPE_TB
- en: '![BGP Keepalive message format](httpatomoreillycomsourcenostarchimages288075.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 40-5. BGP Keepalive message format
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a special use for Keepalive messages: They acknowledge the receipt
    of a valid Open message during the initial BGP session setup.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** BGP Keepalive messages are sent periodically during idle periods
    when no real information needs to be sent between connected BGP speakers. They
    serve only to keep the session alive, and thus contain only a BGP header and no
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'BGP Error Reporting: Notification Messages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once established, a BGP session will remain open for a considerable period of
    time, allowing routing information to be exchanged between devices on a regular
    basis. During the course of operation, certain error conditions may crop up that
    may interfere with normal communication between BGP peers.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Notification Message Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the error conditions that arise are serious enough that the BGP session
    must be terminated. When this occurs, the device detecting the error will inform
    its peer of the nature of the problem by sending it a BGP Notification message,
    and then it will close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, having someone tell you, "I found an error, so I quit" is not of
    much value. Therefore, the BGP Notification message contains a number of fields
    that provide information about the nature of the error that caused the message
    to be sent. This includes a set of primary error codes as well as subcodes within
    some of these error codes. Depending on the nature of the error, an additional
    data field may also be included to aid in diagnosing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the use of Notification messages to convey the occurrence of
    an error, this message type is also used for other purposes. For example, one
    may be sent if two devices cannot agree on how to negotiate a session, which isn't,
    strictly speaking, an error. A Notification message is also used to allow a device
    to tear down a BGP session for reasons that have nothing to do with an error.
  prefs: []
  type: TYPE_NORMAL
- en: BGP Notification Message Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The format for the BGP Notification messages is detailed in [Table 40-12](ch40s07.html#bgp_notification_message_format-id001
    "Table 40-12. BGP Notification Message Format") and illustrated in [Figure 40-6](ch40s07.html#bgp_notification_message_format-id002
    "Figure 40-6. BGP Notification message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-12. BGP Notification Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Notification messages are variable in length. |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | BGP message type; value is 3 for Notification messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Error Code | 1 | Specifies the general class of the error. [Table 40-13](ch40s07.html#bgp_notification_message_error_codes
    "Table 40-13. BGP Notification Message Error Codes") shows the possible error
    types with a brief description of each. |'
  prefs: []
  type: TYPE_TB
- en: '| Error Subcode | 1 | Provides a more specific indication of the cause of the
    error for three of the Error Code values. The possible values of this field for
    each Error Code value are shown in [Table 40-14](ch40s07.html#bgp_notification_message_error_subcodes
    "Table 40-14. BGP Notification Message Error Subcodes"). |'
  prefs: []
  type: TYPE_TB
- en: '| Data | Variable | Contains additional information to help diagnose the error.
    Its meaning depends on the type of error specified in the Error Code and Error
    Subcode fields. In most cases, this field is filled in with whatever bad value
    caused the error to occur. For example, for "Message Header Error / Bad Message
    Type," the value of the bad Type field is placed here. |'
  prefs: []
  type: TYPE_TB
- en: '![BGP Notification message format](httpatomoreillycomsourcenostarchimages288077.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 40-6. BGP Notification message format
  prefs: []
  type: TYPE_NORMAL
- en: Tables [Table 40-13](ch40s07.html#bgp_notification_message_error_codes "Table 40-13. BGP
    Notification Message Error Codes") and [Table 40-14](ch40s07.html#bgp_notification_message_error_subcodes
    "Table 40-14. BGP Notification Message Error Subcodes") show the values permitted
    for the Error Code and Error Subcode fields, respectively, and thus provide a
    good summary of the types of errors that Notification messages can report. They
    also demonstrate the other nonerror uses of the message type.
  prefs: []
  type: TYPE_NORMAL
- en: Table 40-13. BGP Notification Message Error Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Error Code Value | Code Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Message Header Error | A problem was detected either with the contents
    or length of the BGP header. The Error Subcode field provides more details on
    the nature of the problem. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Open Message Error | A problem was found in the body of an Open message.
    The Error Subcode field describes the problem in more detail. Note that authentication
    failures or the inability to agree on a parameter such as hold time are included
    here. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Update Message Error | A problem was found in the body of an Update message.
    Again, the Error Subcode field provides more information. Many of the problems
    that fall under this code are related to issues detected in the routing data or
    path attributes sent in the Update message, so these messages provide feedback
    about such problems to the device sending the erroneous data. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Hold Timer Expired | A message was not received before the hold time
    expired. See the description of the Keepalive message earlier in this chapter
    for details on this timer. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Finite State Machine Error | The BGP finite state machine refers to the
    mechanism by which the BGP software on a peer moves from one operating state to
    another based on events (see the TCP finite state machine description in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION")
    for some background on this concept). If an event occurs that is unexpected for
    the state the peer is currently in, it will generate this error. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Cease | Used when a BGP device wants to break the connection to a peer
    for a reason not related to any of the error conditions described by the other
    codes. |'
  prefs: []
  type: TYPE_TB
- en: Table 40-14. BGP Notification Message Error Subcodes
  prefs: []
  type: TYPE_NORMAL
- en: '| Error Type | Error Subcode Value | Subcode Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Message Header Error (Error Code 1) | 1 | Connection Not Synchronized | The
    expected value in the Marker field was not found, indicating that the connection
    has become unsynchronized. See the description of the Marker field in [BGP Notification
    Message Format](ch40s07.html#bgp_notification_message_format "BGP Notification
    Message Format"). |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2 | Bad Message Length | The message was less than 19 bytes, greater
    than 4096 bytes, or not consistent with what was expected for the message type.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | Bad Message Type | The Type field of the message contains an invalid
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| Open Message Error (Error Code 2) | 1 | Unsupported Version Number | The
    device does not "speak" the version number its peer is trying to use. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2 | Bad Peer AS | The router doesn''t recognize the peer''s AS number
    or is not willing to communicate with it. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | Bad BGP Identifier | The BGP Identifier field is invalid. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 4 | Unsupported Optional Parameter | The Open message contains an optional
    parameter that the recipient of the message doesn''t understand. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 5 | Authentication Failure | The data in the Authentication Information
    optional parameter could not be authenticated. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 6 | Unacceptable Hold Time | The router refuses to open a session because
    the proposed hold time its peer specified in its Open message is unacceptable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Update Message Error (Error Code 3) | 1 | Malformed Attribute List | The
    overall structure of the message''s path attributes is incorrect, or an attribute
    has appeared twice. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2 | Unrecognized Well-Known Attribute | One of the mandatory well-known
    attributes was not recognized. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | Missing Well-Known Attribute | One of the mandatory well-known attributes
    was not specified. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 4 | Attribute Flags Error | An attribute has a flag set to a value that
    conflicts with the attribute''s type code. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 5 | Attribute Length Error | The length of an attribute is incorrect.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 6 | Invalid Origin Attribute | The Origin attribute has an undefined
    value. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 7 | AS Routing Loop | A routing loop was detected. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 8 | Invalid Next_Hop Attribute | The Next_Hop attribute is invalid. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 9 | Optional Attribute Error | An error was detected in an optional attribute.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 10 | Invalid Network Field | The Network Layer Reachability Information
    field is incorrect. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 11 | Malformed AS_Path | The AS_Path attribute is incorrect. |'
  prefs: []
  type: TYPE_TB
- en: Note that, perhaps ironically, no mechanism exists to report an error in a Notification
    message itself. This is likely because the connection is normally terminated after
    such a message is sent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** BGP Notification messages are used for error reporting between
    BGP peers. Each message contains an Error Code field that indicates what type
    of problem occurred. For certain Error Code fields, an Error Subcode field provides
    additional details about the specific nature of the problem. Despite these field
    names, Notification messages are also used for other types of special nonerror
    communication, such as terminating a BGP connection.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 41. OTHER ROUTING PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Routing Information Protocol (RIP), Open Shortest Path First (OSPF), and
    Border Gateway Protocol (BGP)—detailed in the preceding chapters—are the three
    most well-known routing protocols used in the TCP/IP protocol suite. But there
    are several other TCP/IP routing protocols, and they fall into one of two categories.
    Some protocols are no longer in use today but are nevertheless interesting from
    a historical perspective. Others are proprietary RIP and OSPF alternatives that
    you may occasionally encounter in today's networking world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I provide a brief description of five additional TCP/IP routing
    protocols. I begin with a look at two obsolete interior routing protocols that
    played an important role in the early Internet: the Gateway-to-Gateway Protocol
    (GGP) and the HELLO Protocol. I then describe two interior routing protocols (developed
    by Cisco Systems) that are sometimes seen in the industry today as alternatives
    to RIP and OSPF: the Interior Gateway Routing Protocol (IGRP) and the Enhanced
    Interior Gateway Routing Protocol (EIGRP). I conclude with a discussion of the
    Exterior Gateway Protocol (EGP), the exterior routing protocol that preceded BGP.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Gateway-to-Gateway Protocol (GGP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS"),
    I described the evolution of TCP/IP routing architectures. The modern Internet
    is based on the concept of independent autonomous systems (ASes), which run interior
    routing protocols within them and exterior routing protocols between them. The
    early Internet, however, was somewhat simpler. It consisted of a relatively small
    number of core routers that carried detailed information about the Internet as
    a whole, as well as noncore routers that knew only partial information about the
    whole internetwork and were located around the core.
  prefs: []
  type: TYPE_NORMAL
- en: These core routers used a special routing protocol to communicate called the
    *Gateway-to-Gateway Protocol (GGP)*. Bolt, Beranek, and Newman, one of the pioneers
    of the Internet and TCP/IP, originally developed GGP in the early 1980s. It was
    documented in RFC 823, "The DARPA Internet Gateway," published September 1982\.
    This protocol is now obsolete, but it played an important role in the early Internet
    by introducing certain concepts that developers used in later routing protocols.
  prefs: []
  type: TYPE_NORMAL
- en: GGP is similar in general operation to RIP (described in [Chapter 38](ch38.html
    "Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)")) in that it
    uses a distance-vector algorithm to determine the best routes between devices.
    Like RIP, the metric is a simple hop count, so GGP will select a route with the
    shortest number of hops. Although you have seen that hop count is not always the
    best metric of cost for a router in RIP, it was actually a pretty good method
    of route determination back then. This is because the early Internet used both
    computers and links that would be considered glacially slow by today's standards,
    thereby making each hop fairly expensive (in terms of the time required to send
    data) compared to modern routing.
  prefs: []
  type: TYPE_NORMAL
- en: A router using GGP initially starts out in a null state. It then tests the status
    of its local networks by seeing if it can send and receive messages on the network.
    Every 15 seconds, the router sends a GGP Echo message to each of its neighbors.
    If the neighbor receives the message, it responds with a GGP Echo Reply message.
    The router sending the Echo messages considers the neighbor up if it receives
    replies to a certain percentage of messages (the default is 50 percent).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*These messages serve a similar function to the Internet Control Message Protocol
    version 4 (ICMPv4) Echo and Echo Reply messages (described in [Chapter 33](ch33.html
    "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS")), but are not the
    same.*'
  prefs: []
  type: TYPE_NORMAL
- en: Actual routing information is communicated by sending GGP Routing Update messages.
    These are similar in nature to RIP Response messages used in RIP. Each Routing
    Update message contains the information in the sending router's routing table,
    which specifies the networks the router can reach and what the cost (in hops)
    will be for each.
  prefs: []
  type: TYPE_NORMAL
- en: A router that receives a Routing Update message knows that it can reach the
    router that sent the update. Because of that, it can reach all of the other routers'
    reachable networks at the cost of an additional hop. The router uses the information
    to update its own internal tables of destinations and metrics, and then it sends
    out its own Routing Update on its own attached networks. This way, it can propagate
    the information it acquired from other routers on its own networks. This process
    continues until eventually, routes to all GGP routers spreads across the internetwork,
    just as this process occurs in RIP.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting difference between GGP and RIP is that in GGP networks and costs
    aren't sent in pairs. Instead, a GGP router sends its routing table in groups.
    If it has three networks it can communicate with directly at a cost of 1, it sends
    those in a group with a distance value of 1\. Next, if the GGP router has a few
    networks it can reach at a cost of 2, it sends those in a group with a distance
    value of 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that GGP Routing Update messages are acknowledged. Each
    Routing Update message is sent with a sequence number, which ensures that out-of-date
    information is not propagated. If the Routing Update is received and it has a
    new sequence number (indicating that it contains recent information), the router
    processing returns a GGP Acknowledgment message to the originator. If the sequence
    number indicates the message is stale, a Negative Acknowledgment is sent instead
    and the message is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: As a distance-vector algorithm using hop count as a metric, GGP shared most
    of the same pros and cons as RIP. It had simplicity on its side, but it had numerous
    problems such as slow convergence and the counting to infinity issue. GGP was
    a much more rudimentary protocol than RIP, however, and did not include many of
    the features included in RIP to handle such issues, such as split horizon. GGP
    was also limited to unsubnetted classful networks, due to its age.
  prefs: []
  type: TYPE_NORMAL
- en: When Internet architecture moved to the use of ASes, GGP was obsoleted. While
    it was an important part of TCP/IP history, it is today not formally considered
    a part of the TCP/IP protocol suite.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *Gateway-to-Gateway Protocol (GGP)* was used to communicate
    route information between core routers on the early Internet. It is a distance-vector
    protocol that operates in a manner that''s very similar to RIP. Each router periodically
    sends out its routing table to neighboring routers so that each router can learn
    the cost, in hops, to reach every network in the AS. GGP is now considered a historical
    protocol and is no longer part of TCP/IP.'
  prefs: []
  type: TYPE_NORMAL
- en: The HELLO Protocol (HELLO)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP/IP Internet as we know it today evolved over the course of decades.
    It began as an experimental research project started by the United States Defense
    Advanced Research Projects Agency (DARPA or ARPA). Called the ARPAnet, the project
    grew through the addition of other networks, such as the important NSFnet developed
    by the National Science Foundation (NSF). The NSFnet backbone grew over the course
    of many years and was instrumental to the eventual creation of the modern Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The original NSFnet backbone consisted of six Digital Equipment Corporation
    (absorbed by Compaq years ago) LSI-11 computers located across the United States.
    These computers ran special software that was colloquially called "fuzzball."
    This software enabled the computers to function as routers. These fuzzball routers
    connected various networks to the NSFnet and the ARPAnet.
  prefs: []
  type: TYPE_NORMAL
- en: The six NSFnet routers worked as an AS, and like any AS, used an interior routing
    protocol to exchange routing information. The routing protocol used in these early
    routers was called the *HELLO Protocol*. Developed in the early 1980s, it was
    documented in RFC 891, "DCN Local-Network Protocols," which was published in December
    1983\. The name *HELLO* is capitalized, but it is not an acronym; it simply refers
    to the word *hello*, because the protocol uses messages that are sort of analogous
    to the routers greeting each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The OSPF routing protocol has a message type called* Hello. *The use of these
    messages is sometimes referred to as the* Hello protocol. *OSPF is not directly
    related to the HELLO Protocol described in this section, other than the fact that
    an AS could use both protocols for routing. OSPF may have borrowed the name Hello
    from the HELLO Protocol.*'
  prefs: []
  type: TYPE_NORMAL
- en: The HELLO Protocol uses a distance-vector algorithm, like RIP and GGP. What's
    interesting about it, however, is that unlike RIP and GGP, HELLO does not use
    hop count as a metric. Instead, it attempts to select the best route by assessing
    network delays and choosing the path with the shortest delay.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key jobs of routers that use HELLO is to compute the time delay required
    to send and receive datagrams to and from its neighbors. On a regular basis, routers
    exchange HELLO messages that contain clock and timestamp information. By using
    a special algorithm to compare the clock value and timestamp in the message to
    its own clock, a receiving device can compute an estimate for the amount of time
    it takes to send a datagram over the link.
  prefs: []
  type: TYPE_NORMAL
- en: Like RIP and GGP messages, HELLO messages also contain routing information in
    the form of pairs of destinations and metrics. These represent places that the
    sending router is able to reach and a cost to communicate with each one. However,
    in HELLO, the metric is an estimate of the round-trip delay cost for each destination.
    This information is added to the computed round-trip delay time for the link over
    which the message was received, and it is used to update the receiving router's
    own routing table.
  prefs: []
  type: TYPE_NORMAL
- en: This seems a bit confusing, but is really similar to the way a hop-count distance-vector
    protocol like RIP works. Router A, which is using RIP to receive an RIP Response
    message from Router B, knows it can reach every destination Router B can, but
    at a cost of one extra hop (the hop from Router A to Router B). Similarly, Router
    A, which receives a HELLO message from Router B, knows it can reach every destination
    that Router B can, but at an additional cost of the computed delay for the link
    between Router A and Router B.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, using delay calculations should result in more efficient route selection
    than simply using a hop-count algorithm, but this comes at the cost of more complexity.
    This makes HELLO very interesting indeed, especially for a protocol that is more
    than 20 years old. However, since the latency of a link is often unrelated to
    its bandwidth, using time delay as a link metric may lead to spurious results.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is normal for the delay on any link to vary over time; for example,
    if two routes are similar in cost, fluctuations in the delay for each route could
    result in rapid changes between routes (a phenomenon sometimes called *route flapping*).
    Adjustments are needed to the basic overview of the operation of the HELLO Protocol
    in order to avoid these sorts of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Like other early routing protocols, HELLO does not include anything fancy like
    authentication. Such features were not needed in the early days of the Internet,
    when the internetworks were small and could easily be controlled. As the Internet
    grew, newer routing protocols such as RIP eventually replaced HELLO. It is now
    considered a historical protocol (in other words, obsolete) and is no longer used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *HELLO Protocol* was used on very early routers on the
    precursors of the Internet to exchange routing information. It is a distance-vector
    protocol like RIP and GGP, but differs because it uses calculated delay instead
    of hop count as a metric. Like GGP, it is now considered a historical protocol
    and is no longer part of TCP/IP.'
  prefs: []
  type: TYPE_NORMAL
- en: Interior Gateway Routing Protocol (IGRP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I greatly prefer universal, open standards to proprietary standards. I explain
    the reasons why in [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS
    ORGANIZATIONS"), which discusses networking standards. I am not alone in this
    view, and it's no exaggeration to say that much of the success of TCP/IP and the
    Internet is tied to the fact that they were both developed, and still are being
    developed, with the open RFC process.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, in certain situations, a proprietary protocol can be a benefit and
    can even achieve considerable success if a minimum of two factors is true:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a lack of a suitable open protocol or a gap in the feature coverage
    of existing open protocols, creating an opportunity for a proprietary protocol
    to succeed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proprietary protocol must be either initiated or strongly supported by a
    big player in the industry. This helps to ensure that other companies will take
    notice and give the protocol a chance to become a standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This situation arose in the 1980s in the world of routing protocols. At that
    time, the most popular interior routing protocol was RIP, which does a basically
    good job, but has a number of limitations and problems that are inherent to the
    protocol and are not easily resolved. In the mid-1980s, open alternatives like
    OSPF did not yet exist; even if they had, OSPF is much more complex than RIP and
    therefore sometimes not a good alternative to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cisco Systems—definitely one of the big names in networking, internetworking,
    and routing—decided to develop a new routing protocol that would be similar to
    RIP but would provide greater functionality and solve some of RIP''s inherent
    problems. Called the *Interior Gateway Routing Protocol (IGRP)*, it conveniently
    uses the words *gateway* and *routing* in its name, illustrating that these two
    words are used interchangeably in internetworking standards. Cisco designed it
    as a replacement for RIP. It is similar in many ways and keeps RIP''s simplicity,
    one of its key strengths. At the same time, IGRP overcomes two key limitations
    of RIP: the use of hop count solely as a routing metric and the hop count limit
    of 15.'
  prefs: []
  type: TYPE_NORMAL
- en: Like RIP, IGRP is a distance-vector routing protocol designed for use with an
    AS, and thus uses the same basic mechanism for route determination. Each router
    routinely sends out a message on each attached local network that contains a copy
    of its routing table. This message contains pairs of reachable networks and costs
    (metrics) to reach each network. A router receiving this message knows it can
    reach all the networks in the message as long as it can reach the router that
    sent the message. It computes the cost to reach those networks by adding what
    it costs to reach the router that sent the message to the networks' costs. The
    routers update their tables accordingly and send this information out in their
    next routine update. Eventually, each router in the AS will have information about
    the cost to reach each network in it.
  prefs: []
  type: TYPE_NORMAL
- en: There's an important difference between RIP and IGRP, however. RIP allows the
    cost to reach a network to be expressed only in terms of hop count; IGRP provides
    a much more sophisticated metric. In IGRP, the overall cost to reach a network
    is computed based on several individual metrics, including internetwork delay,
    bandwidth, reliability, and load. An administrator can customize the calculation
    of cost by setting relative weightings to the component metrics that reflect the
    priorities of that AS. So, if a particular administrator feels that emphasizing
    reliability over bandwidth would best minimize route cost, he can do this. Such
    a system provides tremendous flexibility over the rigid hop-count system of RIP.
    Unlike RIP, IGRP also does not have an inherent limit of 15 hops between networks.
  prefs: []
  type: TYPE_NORMAL
- en: To this basic algorithm, IGRP adds a feature called *multipath routing*. This
    allows multiple paths between routes to be used automatically, with traffic shared
    between them. The traffic can either be shared evenly or apportioned unevenly
    based on the relative cost metric of each path. This provides improved performance
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Since IGRP is a distance-vector protocol like RIP, it shares many of RIP's algorithmic
    issues. Unsurprisingly, then, IGRP must incorporate many of the same stability
    features as RIP, including the use of split horizon, split horizon with poisoned
    reverse (in certain circumstances), and the employment of hold-down timers. Like
    RIP, IGRP also uses timers to control how often updates are sent, how long routers
    are held down, and how long routes are held in the routing table before they expire.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco originally developed IGRP for Internet Protocol (IP) networks, and since
    IP is predominant in the industry, these networks are where it is most often seen.
    IGRP is not specific to IP, however, and can be used with other internetworking
    protocols if implemented for them. As you will see, Cisco also used IGRP as the
    basis for an improved routing protocol called EIGRP, which it developed several
    years after the original.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In the 1980s, Cisco Systems created the *Interior Gateway Routing
    Protocol (IGRP)* as an improvement over the industry standard protocol, RIP. Like
    RIP, IGRP is a distance-vector protocol, but it includes several enhancements.
    Most important, it eliminates the 15-hop limit between routers and provides the
    ability to use metrics other than hop count to determine optimal routes.'
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Interior Gateway Routing Protocol (EIGRP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous section, IGRP represented a substantial improvement
    over RIP, but like any successful company, Cisco was not content to rest on its
    laurels. Cisco developers knew that IGRP had significant room for improvement,
    so they set to work on creating a better version of IGRP in the early 1990s. The
    result was the *Enhanced Interior Gateway Routing Protocol (EIGRP)*.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the original protocol, EIGRP is more of an evolution than a revolution.
    EIGRP is still a distance-vector protocol, but it is more sophisticated than other
    distance-vector protocols like IGRP or RIP, and it includes certain features that
    are more often associated with link-state routing protocols like OSPF than distance-vector
    algorithms. Also, since the Cisco developers realized that many of the organizations
    that had decided to use EIGRP would be migrating to it from IGRP, they took special
    steps to ensure compatibility between the two.
  prefs: []
  type: TYPE_NORMAL
- en: The chief differences between IGRP and EIGRP are not in what they do, but how
    they do it. In an effort to improve the efficiency and speed of route convergence
    (that is, to improve the agreement between different routers in the internetwork),
    EIGRP changes the way that routes are calculated. EIGRP is based on a new route
    calculation algorithm called the *Diffusing Update Algorithm (DUAL)*, developed
    at SRI International by Dr. J. J. Garcia-Luna-Aceves.
  prefs: []
  type: TYPE_NORMAL
- en: DUAL differs from a typical distance-vector algorithm primarily in that it maintains
    more topology information about the internetwork than RIP or IGRP do. It uses
    this information to automatically select least-cost, loop-free routes between
    networks. EIGRP uses a metric that combines an assessment of the bandwidth of
    a link with the total delay to send over the link. (Other metrics are configurable
    as well, though not recommended.) When a neighboring router sends changed metric
    information, routes are recalculated and updates sent as needed. DUAL will query
    neighboring routers for reachability information if needed (for example, if an
    existing route fails).
  prefs: []
  type: TYPE_NORMAL
- en: This "as needed" aspect of operation highlights an important way that EIGRP
    improves performance over IGRP. EIGRP does not send routine route updates, but
    instead sends only partial updates as required, thereby reducing the amount of
    traffic generated between routers. Furthermore, these updates are designed so
    that only the routers that need the updated information receive them.
  prefs: []
  type: TYPE_NORMAL
- en: In order to build the tables of information that it needs to calculate routes,
    EIGRP requires routers to make and maintain contact with other routers on their
    local networks. To facilitate this, EIGRP incorporates a neighbor discovery and
    recovery process. This system involves the exchange of small Hello messages that
    let routers discover the other routers on the local network and periodically check
    to see whether they're reachable. This is very similar to the way the identically
    named Hello messages are used in OSPF (as described in [Chapter 39](ch39.html
    "Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)")) and has a low impact on bandwidth
    use because the messages are small and infrequently sent.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the features in IGRP carry through to its successor, such as the use
    of split horizon with poisoned reverse for improved stability. In addition to
    the basic improvements of efficiency and route convergence that accrue from the
    algorithm itself, EIGRP includes some other features. These include support for
    Variable Length Subnet Masks (VLSM) as well as support for multiple network-layer
    protocols. This means that EIGRP could be configured to function on a network
    that is running IP as well as another layer 3 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Developed in the 1990s, the *Enhanced Interior Gateway Routing
    Protocol (EIGRP)* is an improved version of Cisco''s IGRP. It is similar to IGRP
    in many respects, but it uses a more sophisticated route calculation method called
    the *Diffusing Update Algorithm (DUAL)*. EIGRP also includes several features
    that make it more intelligent with regard to how it computes routes; it borrows
    concepts from link-state routing protocols and uses more efficient partial updates,
    rather than sending out entire routing tables.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Exterior Gateway Protocol (EGP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the days of the early Internet, a small number of centralized core routers
    that maintained complete information about network reachability did the routing.
    These core routers exchanged information using the historical interior routing
    protocol, GGP, which we examined earlier in this chapter. Other noncore routers
    located around the periphery of this core, both stand-alone and in groups, exchanged
    network reachability information with the core routers using the first TCP/IP
    exterior routing protocol: the *Exterior Gateway Protocol (EGP)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Internet pioneers Bolt, Beranek, and Newman developed EGP in the early 1980s.
    It was first formally described in an Internet standard in RFC 827, "Exterior
    Gateway Protocol (EGP)," published in October 1982, which was later superseded
    by RFC 904, "Exterior Gateway Protocol Formal Specification," in April 1984\.
    Like GGP, EGP is now considered obsolete, having been replaced by BGP. However,
    like GGP, it is an important part of the history of TCP/IP routing, so it is worth
    examining briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As I explained in [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING
    PROTOCOL CONCEPTS"), routers were in the past often called gateways. As such,
    exterior routing protocols were exterior gateway protocols. The EGP protocol discussed
    here is a specific instance of an exterior gateway protocol (also known as EGP).
    Thus, you may occasionally see BGP also called an* exterior gateway protocol *or
    an EGP, which is the generic use of the term*.'
  prefs: []
  type: TYPE_NORMAL
- en: EGP is responsible for the communication of network reachability information
    between neighboring routers that may or may not be in different ASes. The operation
    of EGP is somewhat similar to that of BGP (discussed in [Chapter 40](ch40.html
    "Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)")). Each EGP router maintains
    a database of information about which networks it can reach and how to reach them.
    It sends this information out on a regular basis to each router to which it is
    directly connected. Routers receive these messages and update their routing tables,
    and then use this new information to update other routers. Information about how
    to reach each network propagates across the entire internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual process of exchanging routing information involves several steps
    that discover neighbors and then set up and maintain communications. The steps
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Neighbor Acquisition** Each router attempts to establish a connection to
    each of its neighboring routers by sending Neighbor Acquisition Request messages.
    A neighbor hearing a request can respond with a Neighbor Acquisition Confirm message,
    which says that it recognized the request and wishes to connect. It may reject
    the acquisition by replying with a Neighbor Acquisition Refuse message. For an
    EGP connection to be established between a pair of neighbors, each message must
    first successfully acquire the other with a Confirm message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Neighbor Reachability** After acquiring a neighbor, a router checks to make
    sure the neighbor is reachable and functioning properly on a regular basis. This
    is done by sending an EGP Hello message to each neighbor for which a connection
    has been established. The neighbor replies with an I Heard You (IHU) message.
    These messages are somewhat analogous to the BGP Keepalive message, but they are
    used in matched pairs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Network Reachability Update** A router sends Poll messages on a regular basis
    to each of its neighbors. The neighbor responds with an Update message, which
    contains details about the networks that it is able to reach. This information
    is used to update the routing tables of the device that sent the Poll message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A neighbor can decide to terminate a connection (called *neighbor deacquisition*)
    by sending a Cease message; the neighbor responds with a Cease-ack (acknowledge)
    message.
  prefs: []
  type: TYPE_NORMAL
- en: An Error message, similar to the BGP Notification message in role and structure
    (see [Chapter 40](ch40.html "Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)")),
    is also defined. A neighbor may send this message in response to the receipt of
    an EGP message either when the message itself has a problem (such as a bad message
    length or unrecognized data in a field) or to indicate a problem with how the
    message is being used (such as receipt of Hello or Poll messages at a rate deemed
    excessive). Unlike with the BGP Notification message, an EGP router does not necessarily
    close the connection when sending an Error message.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *Exterior Gateway Protocol (EGP)* was the first TCP/IP
    exterior routing protocol and was used with GGP on the early Internet. It functions
    in a manner similar to BGP. For example, an EGP router makes contact with neighboring
    routers and exchanges routing information with them. A mechanism is also provided
    to maintain a session and report errors. EGP is more limited than BGP in capability
    and is now considered a historical protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: The early Internet was designed to connect peripheral routers or groups of routers
    to the Internet core. It was therefore designed under the assumption that the
    internetwork was connected as a hierarchical tree, with the core as the root.
    EGP was designed based on this assumption of a tree structure and, for that reason,
    cannot handle an arbitrary topology of ASes like BGP. It likewise cannot guarantee
    the absence of routing loops if such loops exist in the interconnection of neighboring
    routers. This is part of why BGP needed to be developed as the Internet moved
    to a more arbitrary structure of AS connections, where loops would be possible
    if steps weren't taken to avoid them.
  prefs: []
  type: TYPE_NORMAL
