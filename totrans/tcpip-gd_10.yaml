- en: Part II-7. TCP/IP ROUTING PROTOCOLS (GATEWAY PROTOCOLS)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分-7. TCP/IP 路由协议（网关协议）
- en: '[Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第37章](ch37.html "第37章。关键路由协议概念的概述")'
- en: '[Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2,
    AND RIPNG)")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第38章](ch38.html "第38章。路由信息协议 (RIP, RIP-2, AND RIPNG)")'
- en: '[Chapter 39](ch39.html "Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第39章](ch39.html "第39章。开放最短路径优先 (OSPF)")'
- en: '[Chapter 40](ch40.html "Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第40章](ch40.html "第40章。边界网关协议 (BGP/BGP-4)")'
- en: '[Chapter 41](ch41.html "Chapter 41. OTHER ROUTING PROTOCOLS")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第41章](ch41.html "第41章。其他路由协议")'
- en: Routing is not just one of the most important activities that take place at
    the network layer; it is also the function that really *defines* layer 3 of the
    OSI Reference Model. Routing is what enables small local networks to be linked
    together to form potentially huge internetworks that can span cities, countries,
    or even the entire globe. The job of routing is done by special devices called
    *routers*, which forward datagrams from network to network, allowing any device
    to send to any other device, even if the source has no idea where the destination
    is.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 路由不仅仅是网络层发生的最重要的活动之一；它还是真正*定义*OSI参考模型第3层的功能。路由是使小型本地网络能够连接起来形成可能巨大的互联网的功能，这些互联网可以跨越城市、国家，甚至整个地球。路由的工作由称为*路由器*的特殊设备完成，它们将数据报从网络转发到网络，允许任何设备向任何其他设备发送信息，即使源设备不知道目的地在哪里。
- en: Strictly speaking, an argument could be made that some routing protocols don't
    belong in layer 3\. For example, many of these protocols send messages using the
    Transmission Control Protocol (TCP) or User Datagram Protocol (UDP) at layer 4\.
    Despite this, routing is inherently a layer 3 activity, and for this reason, it
    is traditional to consider routing protocols part of layer 3.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，可以争论一些路由协议不属于第3层。例如，许多这些协议在第四层使用传输控制协议（TCP）或用户数据报协议（UDP）发送消息。尽管如此，路由本质上是一种第3层活动，因此，传统上认为路由协议是第3层的一部分。
- en: Routing is a complicated subject. The short summary of the process is that routers
    decide how to forward a datagram based on its destination address, which is compared
    to information the router keeps in special routing tables. These tables contain
    entries for each of the networks the router knows about, telling the router which
    adjacent router the datagram should be sent to in order for it to reach its eventual
    destination.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是一个复杂的话题。简而言之，这个过程是路由器根据数据报的目的地址来决定如何转发数据报，这个地址与路由器在特殊路由表中保存的信息进行比较。这些表包含了路由器所知的每个网络条目，告诉路由器数据报应该发送到哪个相邻路由器，以便最终到达目的地。
- en: As you can imagine, routing tables are critically important to the routing process.
    It is possible for these tables to be manually maintained by network administrators,
    but this is tedious and time-consuming and doesn't allow routers to deal with
    changes or problems in the internetwork. Instead, most modern routers are designed
    with functionality that lets them share route information with other routers,
    so they can keep their routing tables up-to-date automatically. This information
    exchange is accomplished through the use of *routing protocols*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，路由表对于路由过程至关重要。这些表可以由网络管理员手动维护，但这既繁琐又耗时，而且不允许路由器处理互联网中的变化或问题。相反，大多数现代路由器都设计有功能，允许它们与其他路由器共享路由信息，从而使它们能够自动更新其路由表。这种信息交换是通过使用*路由协议*来完成的。
- en: This part contains five chapters that provide a description of the most common
    routing (or *gateway*) protocols used in TCP/IP. The first chapter provides an
    overview of various concepts that are important to know in order to understand
    how routing protocols work, including an explanation of the difference between
    interior and exterior routing protocols. This sets the stage for the chapters
    that follow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含五章，描述了在TCP/IP中使用的最常见路由（或*网关*）协议。第一章提供了各种重要概念的概述，这些概念对于理解路由协议的工作方式至关重要，包括对内部和外部路由协议之间差异的解释。这为后续章节奠定了基础。
- en: 'In the second and third chapters, I thoroughly explain the two most commonly
    used interior routing protocols in TCP/IP: the Routing Information Protocol (RIP)
    and the Open Shortest Path First (OSPF) protocol. In the fourth chapter, I describe
    the Border Gateway Protocol (BGP), which is the exterior routing protocol used
    today on the Internet. The fifth chapter briefly discussing five historical, proprietary,
    or less commonly used routing protocols.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二和第三章中，我详细解释了TCP/IP中最常用的两种内部路由协议：路由信息协议（RIP）和开放最短路径优先（OSPF）协议。在第四章中，我描述了边界网关协议（BGP），这是今天互联网上使用的外部路由协议。第五章简要讨论了五种历史、专有或较少使用的路由协议。
- en: You may notice that the title of this part refers to both *routing protocols*
    and *gateway protocols*. These terms are interchangeable, and the word *gateway*
    appears in the name of several of the protocols. This is an artifact of the historical
    use of the term *gateway* in early TCP/IP standards to refer to the devices we
    now call routers. Today, the term *gateway* normally refers not to a router, but
    to a different type of network interconnection device, so this can be particularly
    confusing. The term *routing protocol* is now preferred, and it is the one I use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这一部分的标题同时提到了*路由协议*和*网关协议*。这两个术语可以互换使用，而且*网关*这个词出现在几个协议的名称中。这是由于在早期的TCP/IP标准中，*网关*一词的历史用法是指我们现在称之为路由器的设备。今天，*网关*一词通常不指路由器，而是指不同类型的网络互连设备，这可能会特别令人困惑。现在更倾向于使用*路由协议*这个术语，这也是我使用的术语。
- en: Like all topics related to routing, routing protocols are generally quite complex.
    I cover the major ones here in more detail than most general networking references,
    but even so, I am only scratching the surface, especially of the more complicated
    ones like OSPF. You can check out the referenced Internet standards (RFCs) for
    more details if you desire. Also note that there are some routing protocols in
    use on IP networks that I do not cover here, such as IS-IS (which is actually
    an OSI protocol and not formally part of TCP/IP).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有与路由相关的主题一样，路由协议通常相当复杂。我在这里详细介绍了主要的路由协议，比大多数一般性的网络参考资料都要详细，但即便如此，我也只是触及了表面，尤其是像OSPF这样的更复杂的协议。如果您想了解更多细节，可以查看所引用的互联网标准（RFC）。此外，请注意，这里没有涵盖IP网络上使用的某些路由协议，例如IS-IS（实际上是一个OSI协议，并不是TCP/IP的正式部分）。
- en: Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第37章 概述关键路由协议概念
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Routing protocols play an important part in the overall process of routing in
    an internetwork. It is therefore easiest to understand them in the scope of an
    overall discussion of routing. It's difficult to describe the individual TCP/IP
    routing protocols without some background information on how routing protocols
    work. For this reason, I feel it is worth taking a brief look at key routing protocol
    concepts so that you will have more luck making sense of the routing protocols
    described in the next few chapters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 路由协议在互联网的路由整体过程中扮演着重要的角色。因此，在讨论路由的总体框架中理解它们是最容易的。在没有一些关于路由协议如何工作的背景信息的情况下，很难描述单个TCP/IP路由协议。因此，我认为简要地查看一些关键的路由协议概念是有价值的，这样您在理解下一章中描述的路由协议时就会更有运气。
- en: In this chapter, I will provide an overview of the routing protocol architectures,
    protocol types, algorithms, and metrics.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将概述路由协议架构、协议类型、算法和度量标准。
- en: Routing Protocol Architectures
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由协议架构
- en: Let's start with a look at routing protocol architectures. In this context,
    the word *architecture* refers to the way that an internetwork is structured.
    Once you have some networks and routers that you wish to connect together, there
    are any number of ways that you can do this. The architecture you choose is based
    on the way that routers are linked, and this has an impact on the way that routing
    is done and how routing protocols operate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从路由协议架构开始探讨。在这个语境中，*架构*一词指的是互联网的结构方式。一旦您有一些想要连接起来的网络和路由器，您有无数种方法可以做到这一点。您选择的架构基于路由器之间的连接方式，这会影响路由的执行方式和路由协议的操作。
- en: Core Architecture
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心架构
- en: TCP/IP and the Internet were developed simultaneously, so TCP/IP routing protocols
    evolved as the Internet itself did. Early architecture of the Internet consisted
    of a small number of *core* routers that contained comprehensive information about
    the internetwork. When the Internet was very small, adding more routers to this
    core expanded it. However, each time the core was expanded, the amount of routing
    information that needed to be maintained grew.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP和互联网是同时开发的，因此TCP/IP路由协议随着互联网本身的发展而发展。互联网的早期架构由少量包含关于互联网的全面信息的*核心*路由器组成。当互联网非常小的时候，向这个核心添加更多路由器可以扩展它。然而，每次核心扩展时，需要维护的路由信息量都会增加。
- en: Eventually, the core became too large, so a two-level hierarchy was formed to
    allow further expansion. *Noncore* routers were located on the periphery of the
    core and contained only partial routing information; they relied on the core routers
    for transmissions that went across the internetwork. A special routing protocol
    called the *Gateway-to-Gateway Protocol (GGP)* was used within the core of the
    internetwork, while another protocol called the *Exterior Gateway Protocol (EGP)*
    was used between noncore and core routers. The noncore routers were sometimes
    single, stand-alone routers that connected a single network to the core, or they
    could be sets of routers for an organization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，核心变得太大，因此形成了一个两级层次结构，以允许进一步扩展。*非核心*路由器位于核心的边缘，只包含部分路由信息；它们依赖于核心路由器进行跨互联网的传输。在互联网的核心内部使用了名为*网关到网关协议（GGP）*的特殊路由协议，而在非核心路由器和核心路由器之间使用了另一个名为*外部网关协议（EGP）*的协议。非核心路由器有时是单个独立路由器，将单个网络连接到核心，或者它们可以是组织的一组路由器。
- en: 'This architecture served for a while, but it did not scale very well as the
    Internet grew. The problem was mainly due to the fact that there was only a single
    level to the architecture: Every router in the core had to communicate with every
    other router. Even with peripheral routers being kept outside the core, the amount
    of traffic in the core kept growing.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构在一段时间内有效，但随着互联网的增长，它并没有很好地扩展。问题主要在于该架构只有一个级别：核心中的每个路由器都必须与其他每个路由器通信。即使外围路由器被保持在核心之外，核心中的流量量仍在不断增加。
- en: Autonomous System (AS) Architecture
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自治系统（AS）架构
- en: To resolve the scaling problem, a new architecture was created that moved away
    from the centralized concept of a core toward an architecture that was better
    suited to a larger and growing internetwork. This decentralized architecture treats
    the internetwork as a set of independent groups, with each group called an *autonomous
    system (AS)*. An AS consists of a set of routers and networks controlled by a
    particular organization or administrative entity, which uses a single consistent
    policy for internal routing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决缩放问题，创建了一种新的架构，该架构从核心集中式概念转向更适合更大和不断增长的互联网架构。这种去中心化架构将互联网视为一组独立的组，每个组被称为*自治系统（AS）*。一个AS由一组由特定组织或管理实体控制的路由器和网络组成，该实体使用单一一致的政策进行内部路由。
- en: The power of this system is that routing on the internetwork as a whole occurs
    between ASes and not individual routers. Information is shared between one and
    maybe a couple of routers in each AS, not every router in each AS. The details
    of routing within an AS are also hidden from the rest of the internetwork. This
    provides both flexibility for each AS to do routing as it sees fit (thus the name
    *autonomous*) and efficiency for the overall internetwork. Each AS has its own
    number, and the numbers are globally managed to make sure that they are unique
    across an internetwork (such as the Internet).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的优势在于，整个互联网上的路由发生在AS之间，而不是单个路由器之间。信息在AS中的每个路由器之间共享，而不是每个AS中的每个路由器。AS内部的路由细节也隐藏在互联网的其他部分。这既为每个AS提供了灵活性，使其能够根据需要执行路由（因此得名*自治*），又为整体互联网提供了效率。每个AS都有自己的编号，这些编号在全球范围内管理，以确保它们在互联网（如互联网）中是唯一的。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Large, modern TCP/IP internetworks can contain thousands of
    routers. To better manage routing in such an environment, routers are grouped
    into constructs called *autonomous systems (ASes)*, each of which consists of
    a group of routers managed independently by a particular organization or entity.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 大型现代TCP/IP互联网可以包含数千个路由器。为了更好地管理这种环境中的路由，路由器被分组到称为*自治系统（ASes）*的结构中，每个自治系统由特定组织或实体独立管理的一组路由器组成。'
- en: 'Modern Protocol Types: Interior and Exterior Routing Protocols'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代协议类型：内部和外部路由协议
- en: 'The different nature of routing within an AS and between ASes can be seen in
    the fact that the following distinct sets of TCP/IP routing protocols are used
    for each type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: AS内部和AS之间的路由性质的不同可以从以下事实中看出：每种类型都使用以下不同的TCP/IP路由协议集：
- en: '**Interior Routing Protocols** These protocols are used to exchange routing
    information between routers within an AS. Interior routing protocols are not used
    between ASes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部路由协议** 这些协议用于在AS内部的路由器之间交换路由信息。内部路由协议不用于AS之间。'
- en: '**Exterior Routing Protocols** These protocols are used to exchange routing
    information between ASes. They may in some cases be used between routers within
    an AS, but they primarily deal with exchanging information between ASes.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部路由协议** 这些协议用于在AS之间交换路由信息。在某些情况下，它们也可能用于AS内部的路由器之间，但它们主要处理在AS之间交换信息。'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Interior routing protocols are used to share routing information
    within an autonomous system; each AS may use a different interior routing protocol
    because the system is, as the name says, autonomous. Exterior routing protocols
    convey routing data between ASes; each AS must use the same exterior protocol
    to ensure that it can communicate.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 内部路由协议用于在自治系统内部共享路由信息；由于系统是自主的，因此每个AS可能使用不同的内部路由协议。外部路由协议在AS之间传递路由数据；每个AS必须使用相同的协议来确保其能够通信。'
- en: 'Since ASes are just sets of routers, you connect ASes by linking a router in
    one AS to a router in another AS. Architecturally, an AS consists of a set of
    routers with two different types of connectivity:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AS（自治系统）只是一组路由器的集合，你通过将一个AS中的路由器连接到另一个AS中的路由器来连接AS。在架构上，一个AS由一组具有两种不同连接类型的路由器组成：
- en: '**Internal Routers** Some routers in an AS connect only to other routers in
    the same AS. These run interior routing protocols.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部路由器** AS中的某些路由器仅连接到同一AS中的其他路由器。这些运行内部路由协议。'
- en: '**Border Routers** Some routers in an AS connect both to routers within the
    AS and to routers in one or more other ASes. These devices are responsible for
    passing traffic between the AS and the rest of the internetwork. They run both
    interior and exterior routing protocols.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界路由器** AS中的某些路由器既连接到AS内部的路由器，也连接到一个或多个其他AS中的路由器。这些设备负责在AS和互联网的其余部分之间传递流量。它们运行内部和外部路由协议。'
- en: Due to its advantages, the AS architecture, an example of which can be seen
    in [Figure 37-1](ch37.html#tcpip_autonomous_system_as_routing_archi "Figure 37-1. TCP/IP
    autonomous system (AS) routing architecture This diagram shows a simplified Internet
    organized into three ASes, each of which is managed independently from the others.
    Communication within each AS is done using an interior routing protocol chosen
    by that AS's administrators (thin links). Communication between ASes must be done
    using a common exterior routing protocol (thick links). Internal routers are shown
    in lighter text, and border routers are shown in black text."), has become the
    standard for TCP/IP networks, most notably the Internet. The division of routing
    protocols into the interior and exterior classifications has thus also become
    standard, and all modern TCP/IP routing protocols are first subdivided by type
    in this manner.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其优势，AS架构（例如，[图37-1](ch37.html#tcpip_autonomous_system_as_routing_archi "图37-1.
    TCP/IP自治系统（AS）路由架构 此图显示了一个简化的由三个AS组成的互联网，每个AS都独立于其他AS进行管理。每个AS内部的通信使用该AS管理员选择的内部路由协议（细线）。AS之间的通信必须使用一个通用的外部路由协议（粗线）。内部路由器以较浅的文本显示，边界路由器以黑色文本显示。"），已成为TCP/IP网络的标准，尤其是互联网。因此，将路由协议分为内部和外部分类也已成为标准，所有现代TCP/IP路由协议首先按这种方式按类型细分。
- en: '![TCP/IP autonomous system (AS) routing architecture This diagram shows a simplified
    Internet organized into three ASes, each of which is managed independently from
    the others. Communication within each AS is done using an interior routing protocol
    chosen by that AS''s administrators (thin links). Communication between ASes must
    be done using a common exterior routing protocol (thick links). Internal routers
    are shown in lighter text, and border routers are shown in black text.](httpatomoreillycomsourcenostarchimages288027.png.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![TCP/IP自治系统（AS）路由架构 此图显示了由三个AS组成的简化互联网，每个AS都独立于其他AS进行管理。每个AS内的通信使用该AS管理员选择的内部路由协议（细线）。AS之间的通信必须使用通用的外部路由协议（粗线）。内部路由器以浅色文字显示，边界路由器以黑色文字显示。](httpatomoreillycomsourcenostarchimages288027.png.jpg)'
- en: Figure 37-1. TCP/IP autonomous system (AS) routing architecture This diagram
    shows a simplified Internet organized into three ASes, each of which is managed
    independently from the others. Communication within each AS is done using an interior
    routing protocol chosen by that AS's administrators (thin links). Communication
    between ASes must be done using a common exterior routing protocol (thick links).
    Internal routers are shown in lighter text, and border routers are shown in black
    text.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图37-1. TCP/IP自治系统（AS）路由架构 此图显示了由三个AS组成的简化互联网，每个AS都独立于其他AS进行管理。每个AS内的通信使用该AS管理员选择的内部路由协议（细线）。AS之间的通信必须使用通用的外部路由协议（粗线）。内部路由器以浅色文字显示，边界路由器以黑色文字显示。
- en: Routing Protocol Algorithms and Metrics
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由协议算法和度量
- en: Another key differentiation of routing protocols is on the basis of the *algorithms*
    and *metrics* they use. An algorithm refers to a method that the protocol uses
    for determining the best route between any pair of networks, and for sharing routing
    information between routers. A metric is a measure of "cost" that is used to assess
    the efficiency of a particular route. Since internetworks can be quite complex,
    the algorithms and metrics of a protocol are very important, and they can be the
    determining factor in deciding that one protocol is superior to another.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 路由协议的另一个关键区别在于它们所使用的**算法**和**度量**。算法指的是协议用于确定任意一对网络之间最佳路由以及路由器之间共享路由信息的方法。度量是一种衡量“成本”的指标，用于评估特定路由的效率。由于互联网可能非常复杂，因此协议的算法和度量非常重要，它们可能是决定一个协议优于另一个协议的决定性因素。
- en: 'There are two routing protocol algorithms that are most commonly encountered:
    distance vector and link state. There are also protocols that use a combination
    of these methods or other methods.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的两种路由协议算法是距离矢量算法和链路状态算法。还有一些协议结合了这些方法或其他方法。
- en: Distance-Vector (Bellman-Ford) Routing Protocol Algorithm
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 距离矢量（Bellman-Ford）路由协议算法
- en: A *distance-vector* routing algorithm, also called a *Bellman-Ford* algorithm
    after two of its inventors, is one where routes are selected based on the distance
    between networks. The distance metric is something simple—usually the number of
    *hops*, or routers, between them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一种**距离矢量**路由算法，也称为以两位发明者命名的**Bellman-Ford**算法，是根据网络之间的距离来选择路由的。距离度量很简单——通常是它们之间的**跳数**或路由器的数量。
- en: Routers using this type of protocol maintain information about the distance
    to all known networks in a table. They regularly send that table to each router
    they immediately connect with (their *neighbors* or *peers*). These routers then
    update their tables and send those tables to their neighbors. This causes distance
    information to propagate across the internetwork, so that eventually, each router
    obtains distance information about all networks on the internetwork.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类协议的路由器在表中维护有关所有已知网络的距离信息。它们会定期将此表发送给它们直接连接的每个路由器（它们的**邻居**或**对等方**）。然后这些路由器更新它们的表并将这些表发送给它们的邻居。这导致距离信息在互联网中传播，因此最终每个路由器都能获得互联网上所有网络的距离信息。
- en: Distance-vector routing protocols are somewhat limited in their ability to choose
    the best route. They also are subject to certain problems in their operation that
    must be worked around through the addition of special heuristics and features.
    Their chief advantages are simplicity and history (they have been used for a long
    time).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 距离矢量路由协议在选择最佳路由方面能力有限。它们在操作中也存在某些问题，必须通过添加特殊启发式和功能来解决。它们的主要优点是简单性和历史（它们已经使用了很长时间）。
- en: Link-State (Shortest-Path First) Routing Protocol Algorithm
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链路状态（最短路径优先）路由协议算法
- en: A *link-state* algorithm selects routes based on a dynamic assessment of the
    shortest path between any two networks. For that reason, it's also called a *shortest-path
    first* method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*链路状态*算法根据任何两个网络之间最短路径的动态评估来选择路由。因此，它也被称为*最短路径优先*方法。'
- en: Using this method, each router maintains a map describing the current topology
    of the internetwork. This map is updated regularly by testing reachability of
    different parts of the Internet, and by exchanging link-state information with
    other routers. The determination of the best route (or shortest path) can be made
    based on a variety of metrics that indicate the true cost of sending a datagram
    over a particular route.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，每个路由器都维护一张描述互联网当前拓扑结构的地图。这张地图通过测试互联网不同部分的可达性，以及与其他路由器交换链路状态信息来定期更新。最佳路由（或最短路径）的确定可以根据多种指标进行，这些指标表示通过特定路由发送数据报的真实成本。
- en: Link-state algorithms are much more powerful than distance-vector algorithms.
    They adapt dynamically to changing internetwork conditions, and they also allow
    routes to be selected based on more realistic metrics of cost than simply the
    number of hops between networks. However, they are more complicated to set up
    and use more computer processing resources than distance-vector algorithms, and
    they aren't as well established.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态算法比距离矢量算法更强大。它们可以动态适应互联网条件的变化，并且还允许根据比网络间跳数更现实的成本指标来选择路由。然而，它们设置和使用起来更复杂，比距离矢量算法消耗更多的计算机处理资源，并且还没有那么成熟。
- en: Hybrid Routing Protocol Algorithms
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合路由协议算法
- en: There are also hybrid protocols that combine features from both types of algorithms,
    and other protocols that use completely different algorithms. For example, the
    *Border Gateway Protocol (BGP)* is a path-vector algorithm, which is somewhat
    similar to the distance-vector algorithm, but communicates much more detailed
    route information. It includes some of the attributes of distance-vector and link-state
    protocols, but is more than just a combination of the two.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些混合协议结合了两种算法的特征，以及其他使用完全不同算法的协议。例如，*边界网关协议（BGP）*是一种路径矢量算法，它在某种程度上类似于距离矢量算法，但交换的路线信息更加详细。它包含了一些距离矢量和链路状态协议的属性，但不仅仅是两者的组合。
- en: Static and Dynamic Routing Protocols
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和动态路由协议
- en: Finally, you may also occasionally see routing protocols categorized by type
    as *static* and *dynamic*. This terminology is somewhat misleading.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可能偶尔看到将路由协议按类型分为*静态*和*动态*。这个术语有些误导。
- en: The term *static routing* simply refers to a situation where the routing tables
    are manually set up so that they remain static. In contrast, *dynamic routing*
    is the use of routing protocols to dynamically update routing tables. Thus, all
    routing protocols are dynamic. There is no such thing as a static routing protocol
    (unless you consider a network administrator who is editing a routing table a
    protocol).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态路由*这个术语仅仅是指路由表是手动设置的，因此保持静态。相比之下，*动态路由*是使用路由协议动态更新路由表。因此，所有路由协议都是动态的。不存在静态路由协议（除非你将编辑路由表的网络管理员视为协议）。'
- en: Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第38章. 路由信息协议（RIP、RIP-2和RIPNG）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The most popular of the TCP/IP interior routing protocols is the *Routing Information
    Protocol (RIP)*. The simplicity of the name matches the simplicity of the protocol.
    Of all the routing protocols, RIP is one of the easiest to configure and least
    demanding of resources. Its popularity is due both to this simplicity and its
    long history. In fact, support for RIP has been built into operating systems for
    as long as TCP/IP itself has existed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP内部路由协议中最受欢迎的是*路由信息协议（RIP）*。名称的简单性符合协议的简单性。在所有路由协议中，RIP是最容易配置的之一，对资源的需求也最少。它的流行既归因于这种简单性，也归因于其悠久的历史。事实上，RIP的支持已经集成到操作系统中，与TCP/IP本身存在的时间一样长。
- en: 'There are three versions of RIP: RIP versions 1 and 2 for IP version 4 (IPv4)
    and RIPng for IP version 6 (IPv6). The basic operation of the protocol is mostly
    the same for all three versions, but there are also some notable differences between
    them, especially in terms of the format of messages sent.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: RIP有三个版本：RIP版本1和2用于IP版本4（IPv4），以及RIPng用于IP版本6（IPv6）。这三个版本的基本操作大致相同，但它们之间也有一些明显的差异，尤其是在发送消息的格式方面。
- en: 'RIP was one of the first interior routing protocols used in TCP/IP. More than
    20 years later, it continues to be widely used. Even though RIP has important
    limitations, it continues to have an important place in TCP/IP routing to this
    day. Evidence that RIP has a future can be seen in the creation of an IPv6 version
    of the protocol: RIPng.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RIP是TCP/IP中最早使用的内部路由协议之一。20多年后，它仍然被广泛使用。尽管RIP存在重要的局限性，但它至今在TCP/IP路由中仍然占有重要位置。RIP有未来的证据可以在创建协议的IPv6版本RIPng中看到。
- en: I will open the examination of RIP with an overall description of its characteristics
    and how it works in general terms. I start with an overview and history of the
    protocol, including a brief discussion of its different versions and the standards
    that define them. I describe the method that RIP uses to determine routes and
    the metric used to assess route cost. I describe the general operation of the
    protocol including message types and when they are sent. I then describe the most
    important limitations and issues with RIP, and the special features that have
    been added to the protocol to resolve several problems with the basic RIP algorithm.
    Finally, I take a closer look at each version, showing the message format used
    for each and discussing version-specific features as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以对RIP特性的整体描述和它在一般意义上的工作原理来开启RIP的考试。我首先概述了该协议的历史，包括对其不同版本和定义它们的标准的简要讨论。我描述了RIP用来确定路由的方法以及用于评估路由成本的度量标准。我还描述了该协议的一般操作，包括消息类型和发送时间。然后，我描述了RIP最重要的局限性和问题，以及为解决基本RIP算法中的几个问题而添加到协议中的特殊功能。最后，我更详细地查看每个版本，展示每个版本使用的消息格式，并讨论版本特定的功能。
- en: RIP Overview
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RIP概述
- en: RIP has been the most popular interior routing protocol in the TCP/IP protocol
    suite for many years. The history of the protocol and how it came to achieve prominence
    is a rather interesting one. Unlike many of the other important protocols in the
    TCP/IP suite, RIP was not first developed formally using the RFC standardization
    process (see [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS
    ORGANIZATIONS")). Rather, it evolved as a de facto industry standard and became
    an Internet standard later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，RIP一直是TCP/IP协议套件中最受欢迎的内部路由协议。该协议的历史以及它是如何获得显著地位的是一个相当有趣的故事。与TCP/IP套件中的许多其他重要协议不同，RIP并不是首先通过RFC标准化过程正式开发的（参见第3章）。相反，它作为一个事实上的行业标准而演变，后来成为互联网标准。
- en: 'The history of RIP has something in common with another networking heavyweight:
    Ethernet. Like that formidable local area network (LAN) technology, RIP''s roots
    go back to that computing pioneer, Xerox''s Palo Alto Research Center (PARC).
    At the same time that Ethernet was being developed for tying together LANs, PARC
    created a higher-layer protocol to run on Ethernet called the Xerox PARC Universal
    Protocol (PUP). PUP required a routing protocol, so Xerox created a protocol called
    the Gateway Information Protocol (GWINFO). This was later renamed the Routing
    Information Protocol and used as part of the Xerox Network System (XNS) protocol
    suite.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: RIP的历史与另一个网络巨头——以太网——有着某种共同之处。就像那个强大的局域网技术一样，RIP的根源可以追溯到那个计算先驱——施乐帕洛阿托研究中心（PARC）。在以太网被开发用于连接局域网的同时，PARC创建了一个在以太网上运行的更高层协议，称为施乐帕洛阿托通用协议（PUP）。PUP需要一个路由协议，因此施乐创建了一个名为网关信息协议（GWINFO）的协议。后来，该协议被更名为路由信息协议，并作为施乐网络系统（XNS）协议套件的一部分使用。
- en: RIP entered the mainstream when developers at the University of California at
    Berkeley adapted it for use in the Berkeley Standard Distribution (BSD) of the
    UNIX operating system. RIP first appeared in BSD version 4.2 in 1982, where it
    was implemented as the UNIX program *routed* (pronounced "route-dee," not "rout-ed"—the
    "d" stands for "daemon," a common UNIX term for a server process).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当加州大学伯克利分校的开发者将其用于UNIX操作系统的伯克利标准分布（BSD）时，RIP进入了主流。RIP首次出现在1982年的BSD版本4.2中，当时它被实现为UNIX程序*routed*（发音为"route-dee"，不是"rout-ed"—其中的"d"代表"daemon"，是UNIX中用于服务器进程的常见术语）。
- en: BSD was (and still is) a very popular operating system, especially for machines
    connected to the early Internet. As a result, RIP was widely deployed and became
    the industry standard for internal routing protocols. It was used both for TCP/IP
    and other protocol suites. In fact, a number of other routing protocols, such
    as the RTP protocol in the AppleTalk suite, were based on this early version of
    RIP.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: BSD曾经（并且现在仍然是）一个非常流行的操作系统，尤其是对于连接到早期互联网的机器。因此，RIP被广泛部署，并成为了内部路由协议的行业标准。它被用于TCP/IP和其他协议套件。实际上，许多其他路由协议，如AppleTalk套件中的RTP协议，都是基于这种早期的RIP版本。
- en: RIP Standardization
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP标准化
- en: For a while, the BSD implementation of routed was actually considered the standard
    for the protocol itself. However, this was not a formally defined standard, and
    this meant that there was no formal definition of exactly how it functioned. This
    led to slight differences in various implementations of the protocol over time.
    To resolve potential interoperability issues between implementations, the Internet
    Engineering Task Force (IETF) formally specified RIP in the Internet standard
    RFC 1058, "Routing Information Protocol," which was published in June 1988\. This
    RFC was based directly on the BSD routed program. This original version of RIP
    is now also sometimes called RIP version 1 or RIP-1 to differentiate it from later
    versions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间内，BSD实现的routed实际上被认为是该协议的标准。然而，这并不是一个正式定义的标准，这意味着没有正式的定义来确切说明它是如何工作的。这导致了该协议在不同实现之间的细微差异。为了解决实现之间的潜在互操作性问题，互联网工程任务组（IETF）在1988年6月发布的互联网标准RFC
    1058，“路由信息协议”（Routing Information Protocol）中正式指定了RIP。这个RFC直接基于BSD的routed程序。这个原始版本的RIP现在有时也被称为RIP版本1或RIP-1，以区分后来的版本。
- en: RIP's popularity was due in large part to its inclusion in BSD, and it was included
    in BSD because of the relative simplicity of the protocol.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: RIP的流行很大程度上归因于它被包含在BSD中，而它之所以被包含在BSD中，是因为该协议相对简单。
- en: RIP Operational Overview, Advantages, and Limitations
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP操作概述、优势与局限性
- en: 'RIP uses the distance-vector algorithm to determine routes, as described in
    [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS").
    Each router maintains a routing table containing entries for various networks
    or hosts in the internetwork. Each entry contains two primary pieces of information:
    the address of the network or host and the distance to it, measured in hops, which
    is simply the number of routers that a datagram must pass through to get to its
    destination.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: RIP使用距离矢量算法来确定路由，如[第37章](ch37.html "第37章. 关键路由协议概念概述")所述。每个路由器维护一个路由表，包含互联网中各种网络或主机的条目。每个条目包含两个主要信息：网络或主机的地址以及到它的距离，以跳数衡量，这仅仅是数据报必须通过的路由器的数量以到达其目的地。
- en: On a regular basis, each router in the internetwork sends out its routing table
    in a special message on each of the networks to which it is connected, using the
    User Datagram Protocol (UDP). Other routers receive these tables and use them
    to update their own tables. This is done by taking each of the routes they receive
    and adding an extra hop. For example, if Router A receives an indication from
    Router B that Network N1 is four hops away, since Router A and Router B are adjacent,
    the distance from Router A to Network N1 is five. After a router updates its tables,
    it sends out this information to other routers on its local networks. Over time,
    routing distance information for all networks propagates over the entire internetwork.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定期地，互联网中的每个路由器都会在其连接的每个网络上发送一个特殊消息，其中包含其路由表，使用的是用户数据报协议（UDP）。其他路由器接收这些表，并使用它们来更新自己的表。这是通过将它们接收到的每个路由增加一个额外的跳数来完成的。例如，如果路由器A从路由器B收到指示，表示网络N1距离四跳，由于路由器A和路由器B是相邻的，因此从路由器A到网络N1的距离是五跳。在路由器更新其表后，它会将此信息发送到其本地网络上的其他路由器。随着时间的推移，所有网络的路由距离信息在整个互联网中传播。
- en: RIP is straightforward in operation, easy to implement, and undemanding of router
    processing power, which makes it especially attractive in smaller autonomous systems
    (ASes). There are, however, some important limitations that arise due to the simplicity
    of the protocol. For starters, hops are often not the best metric to use in selecting
    routes. There are also a number of problems that arise with the algorithm itself.
    These include slow convergence (delays in having all routers agree on the same
    routing information) and problems dealing with network link failures. RIP includes
    several special features to resolve some of these issues, but others are inherent
    limitations of the protocol. For example, RIP supports a maximum of only 15 hops
    between destinations, making it unsuitable for very large ASes, and this cannot
    be changed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: RIP 在操作上简单明了，易于实现，对路由器处理能力的要求不高，这使得它在较小的自治系统 (AS) 中特别有吸引力。然而，由于协议的简单性，也出现了一些重要的限制。首先，跳数往往不是选择路由的最佳度量标准。还有许多与算法本身相关的问题。这些问题包括收敛缓慢（所有路由器就相同的路由信息达成一致时的延迟）以及处理网络链路故障的问题。RIP
    包含了几个特殊功能来解决这些问题中的某些问题，但其他问题是协议的固有限制。例如，RIP 只支持目的地之间最多 15 跳，这使得它不适用于非常大的 AS，并且这一点无法更改。
- en: More than two decades after it was first created, RIP continues to be a popular
    interior routing protocol. Its limitations have led to many internetworking experts
    hoping that the protocol would eventually be replaced by newer protocols such
    as Open Shortest Path First (OSPF) that are superior on a strictly technical basis.
    Some have gone so far as to sarcastically suggest that maybe it would be best
    if RIP would R. I. P. Once a protocol becomes popular, however, it's hard to resist
    momentum, and RIP is likely to continue to be used for many years to come.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次创建二十多年后，RIP 仍然是一种流行的内部路由协议。其限制导致许多互联网专家希望该协议最终会被技术上更优越的新协议，如开放式最短路径优先 (OSPF)
    所取代。有些人甚至讽刺地建议，也许 RIP R. I. P. 会是最好的。然而，一旦一个协议变得流行，就很难抵挡其势头，RIP 很可能在未来许多年里继续被使用。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The *Routing Information Protocol (RIP)* is one of the oldest
    and most popular interior routing protocols. With each router, it uses a distance-vector
    algorithm that maintains a table, which indicates how to reach various networks
    in the AS and the distance to it in hops. RIP is popular because it is well established
    and simple, but it has a number of important limitations.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 路由信息协议 (RIP) 是最古老且最受欢迎的内部路由协议之一。每个路由器使用距离矢量算法来维护一个表，该表指示如何到达 AS 中的各种网络以及到达该网络的跳数。RIP
    流行是因为它已经建立并且简单，但它有许多重要的限制。'
- en: Development of RIP Version 2 (RIP-2) and RIPng for IPv6
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP 版本 2 (RIP-2) 和 RIPng for IPv6 的开发
- en: Some other issues with RIP came about as a result of the protocol having been
    developed in the early 1980s, when TCP/IP was still in its infancy. Over time,
    as the use of TCP/IP protocols changed, RIP became outdated. In response, *RIP
    version 2*, or *RIP-2* was created in the early 1990s.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该协议是在 20 世纪 80 年代初期开发的，当时 TCP/IP 还处于初级阶段，RIP 出现了一些其他问题。随着时间的推移，随着 TCP/IP 协议的使用发生变化，RIP
    变得过时。作为回应，在 20 世纪 90 年代初期创建了 *RIP 版本 2* 或 *RIP-2*。
- en: RIP-2 defines a new message format for RIP and includes a number of new features,
    including support for classless addressing, authentication, and the use of multicasting
    instead of broadcasting, which improves network performance. It was first defined
    in RFC 1388, "RIP Version 2 Carrying Additional Information," published in January
    1993\. This RFC was revised in RFC 1723 and finalized in RFC 2453, "RIP Version
    2," published in November 1998.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RIP-2 为 RIP 定义了新的消息格式，并包括许多新特性，包括对无类别寻址、身份验证以及使用多播而非广播的支持，这些特性提高了网络性能。它首次在 1993
    年 1 月发布的 RFC 1388，“RIP 版本 2 带有附加信息”中被定义。该 RFC 在 RFC 1723 中进行了修订，并在 1998 年 11 月发布的
    RFC 2453，“RIP 版本 2”中最终确定。
- en: In order to ensure that RIP can work with TCP/IP in the future, it was necessary
    to define a version that would work with the IPv6\. In 1997, RFC 2080 was published,
    titled "RIPng for IPv6." The *ng* stands for *next generation*; you'll recall
    that IPv6 is also sometimes called *IPng*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 RIP 能够与 TCP/IP 在未来一起工作，有必要定义一个与 IPv6 兼容的版本。1997 年，发布了 RFC 2080，标题为“RIPng
    for IPv6”。*ng* 代表 *下一代*；你可能会记得 IPv6 也被称为 *IPng*。
- en: '*RIPng* is not just a new version of RIP, like RIP-2, but is defined as a new
    stand-alone protocol. It is, however, based closely on the original RIP and RIP-2
    standards. A distinct protocol (as opposed to a revision of the original) was
    needed due to the changes made between IPv4 and IPv6, though RIP and RIPng work
    in the same basic way. RIPng is sometimes also called *RIPv6*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*RIPng*不仅仅是一个新的RIP版本，就像RIP-2一样，但它被定义为一个新的独立协议。然而，它却紧密基于原始的RIP和RIP-2标准。由于IPv4和IPv6之间的变化，需要一个独立的协议（而不是原始协议的修订），尽管RIP和RIPng以相同的基本方式工作。RIPng有时也被称为*RIPv6*。'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The original version of RIP has the fewest features and is
    now called *RIP-1*. *RIP-2* was created to add support for classless addressing
    and other capabilities. *RIPng* is the version created for compatibility with
    IPv6.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 原始版本的RIP功能最少，现在被称为*RIP-1*。*RIP-2*是为了添加对无类别寻址和其他功能的支持而创建的。*RIPng*是为与IPv6兼容而创建的版本。'
- en: RIP Route Determination Algorithm and Metric
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RIP 路由确定算法和度量
- en: As I mentioned in the previous chapter, one of the defining characteristics
    of any routing protocol is the algorithm it uses for determining routes. RIP falls
    into the class of protocols that use a distance-vector, or Bellman-Ford, routing
    algorithm. To help you understand exactly how RIP determines routes, this section
    presents the specific implementation of the algorithm for RIP and provides an
    example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一章提到的，任何路由协议的一个定义特征就是它用于确定路由的算法。RIP 属于使用距离矢量或贝尔曼-福特路由算法的协议类别。为了帮助您理解RIP如何确定路由，本节将介绍RIP算法的具体实现并提供一个示例。
- en: Note that the description presented here is the basic algorithm used by RIP.
    This is modified in certain ways to address some of the problems that can occur
    in special circumstances due to how the algorithm works. Later in this chapter,
    we will explore these problems and the special features RIP includes to address
    them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里提供的描述是RIP使用的基算法。这个算法在特定情况下会进行一些修改，以解决由于算法工作方式而产生的某些问题。在本章的后面部分，我们将探讨这些问题以及RIP包含的用于解决这些问题的特殊功能。
- en: RIP Routing Information and Route Distance Metric
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP 路由信息与路由距离度量
- en: 'The job of RIP, like any routing protocol, is to provide a mechanism for exchanging
    information about routes so routers can keep their routing tables up-to-date.
    Each router in an RIP internetwork keeps track in its routing table of all networks
    (and possibly individual hosts) in the internetwork. For each network or host,
    the device includes a variety of information, of which the following is the most
    important:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: RIP的任务，就像任何路由协议一样，是提供一个机制来交换路由信息，以便路由器可以保持它们的路由表是最新的。RIP互联网中的每个路由器都在其路由表中跟踪互联网中的所有网络（以及可能个别的主机）。对于每个网络或主机，设备包括各种信息，其中以下信息是最重要的：
- en: The address of the network or host
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络或主机的地址
- en: The distance from that router to the network or host
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从该路由器到网络或主机的距离
- en: 'The first hop for the route: the device to which datagrams must first be sent
    to eventually get to the network or host'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由的第一个跳：数据报必须首先发送到的设备，以便最终到达网络或主机
- en: In theory, the distance metric can be any assessment of cost, but in RIP, distance
    is measured in hops. As you probably already know, in TCP/IP vernacular, a datagram
    makes a *hop* when it passes through a router. Thus, the RIP distance between
    a router and a network measures the number of routers that the datagram must pass
    through to get to the network. If a router connects to a network directly, then
    the distance is 1 hop. If it goes through a single router, the distance is 2 hops,
    and so on. In RIP, a maximum of 15 hops are allowed for any network or host. The
    value 16 is defined as infinity, so an entry with 16 in it means "this network
    or host is not reachable."
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，距离度量可以是任何成本评估，但在RIP中，距离是以跳数来衡量的。您可能已经知道，在TCP/IP术语中，数据报通过路由器时进行一次*跳*。因此，RIP中路由器与网络之间的距离衡量的是数据报必须通过多少个路由器才能到达网络。如果一个路由器直接连接到网络，那么距离是1跳。如果它通过一个路由器，距离是2跳，依此类推。在RIP中，任何网络或主机的最大跳数限制为15跳。值16被定义为无穷大，所以其中包含16的条目意味着“此网络或主机不可达。”
- en: RIP Route Determination Algorithm
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP 路由确定算法
- en: On a regular basis, each router running RIP will send out its routing table
    entries to provide information to other routers about the networks and hosts it
    knows how to reach. Any routers on the same network as the one sending out this
    information will be able to update their own tables based on the information they
    receive.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 定期地，每个运行 RIP 的路由器都会发送其路由表条目，以向其他路由器提供有关它知道如何到达的网络和主机的信息。与发送此信息的同一网络上的任何路由器都能够根据接收到的信息更新自己的表。
- en: Any router that receives a message from another router on the same network saying
    it can reach Network X at a cost of *N* knows it can reach Network X at a cost
    of *N*+1 by sending to the router it received the message from.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 任何从同一网络上的另一个路由器收到消息，表明它可以以 *N* 的成本到达网络 X 的路由器都知道，通过向它收到消息的路由器发送，它可以以 *N*+1 的成本到达网络
    X。
- en: RIP Route Determination and Information Propagation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP 路由确定和信息传播
- en: 'Let''s take a specific example to help you understand how routes are determined
    and how route information is propagated using RIP. Consider a relatively simple
    internetwork with four individual networks, connected as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来帮助你理解路由是如何确定的，以及如何使用 RIP 传播路由信息。考虑一个相对简单的互联网，包含四个单独的网络，如下所示连接：
- en: Router RA connects Network N1 to Network N2.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RA 将网络 N1 连接到网络 N2。
- en: Router RB and Router RC connect Network N2 to Network N3.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RB 和路由器 RC 将网络 N2 连接到网络 N3。
- en: Router RD connects Network N3 to Network N4.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RD 将网络 N3 连接到网络 N4。
- en: This sample AS is illustrated in [Figure 38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si
    "Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four
    physical networks and four routers.").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例 AS 在 [图 38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si "图 38-1.
    示例 RIP AS 这是一个包含四个物理网络和四个路由器的简单 AS 的示例。") 中说明。
- en: '![Sample RIP AS This is an example of a simple AS that contains four physical
    networks and four routers.](httpatomoreillycomsourcenostarchimages288029.png.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![示例 RIP AS 这是一个包含四个物理网络和四个路由器的简单 AS 的示例。](httpatomoreillycomsourcenostarchimages288029.png.jpg)'
- en: Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four
    physical networks and four routers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 38-1. 示例 RIP AS 这是一个包含四个物理网络和四个路由器的简单 AS 的示例。
- en: 'Now let''s suppose that we just turned on Router RA. It sees that it is directly
    connected to Network N1 and Network N2, so it will have an entry in its routing
    table indicating that it can reach Network N1 at a cost of 1, which we can represent
    as {N1,1}. Information about Network N1 will propagate from Router RA across the
    internetwork in the following sequence of steps (which are illustrated in [Figure 38-2](ch38s02.html#propagation_of_network_routing_informati
    "Figure 38-2. Propagation of network routing information using RIP This composite
    diagram illustrates the five steps in propagating route information about Network
    N1 from Router RA to the rest of the AS. In step 1, the information is sent from
    Router RA to both of its connected networks. In step 2, it reaches Routers RB
    and RC, which then know they can reach Network N1 through Router RA at a cost
    of one additional hop. In step 3, these two routers send this information on their
    networks, and in step 4, it reaches Router RD. In step 5, Router RD sends out
    the information, but no other routers are around to receive it.")):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们刚刚开启了路由器 RA。它看到它直接连接到网络 N1 和网络 N2，因此在其路由表中将有一个条目，表明它可以以 1 的成本到达网络 N1，我们可以将其表示为
    {N1,1}。关于网络 N1 的信息将通过以下步骤（如图 38-2 所示）在互联网中传播（这些步骤在 [图 38-2](ch38s02.html#propagation_of_network_routing_informati
    "图 38-2. 使用 RIP 传播网络路由信息。此复合图说明了从路由器 RA 向 AS 中其他部分传播关于网络 N1 的路由信息的五个步骤。在第 1 步中，信息从路由器
    RA 发送到其连接的两个网络。在第 2 步中，它到达路由器 RB 和 RC，然后它们知道它们可以通过路由器 RA 以额外跳数 1 的成本到达网络 N1。在第
    3 步中，这两个路由器在其网络上发送此信息，在第 4 步中，它到达路由器 RD。在第 5 步中，路由器 RD 发送信息，但没有其他路由器在附近接收它。"）：
- en: Router RA sends out an RIP message containing the entry {N1,1} on each of the
    networks to which it is connected. There are no other routers on Network N1, so
    nothing happens there. But Routers RB and RC are on Network N2, so they receive
    the information.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器 RA 向其连接的每个网络发送包含条目 {N1,1} 的 RIP 消息。在 N1 网络上没有其他路由器，所以那里没有发生任何事情。但是路由器 RB
    和 RC 在 N2 网络上，因此它们接收到了信息。
- en: Routers RB and RC will look in their routing tables to see if they already have
    entries for Network N1\. Assuming neither does, they will each create a routing
    table entry {N1,2} for Router RA. This means, "I can reach Network N1 at a cost
    of 2 hops by sending to Router RA."
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器 RB 和 RC 将会检查它们的路由表，看看是否已经为网络 N1 有条目。假设它们都没有，它们各自将为路由器 RA 创建一个路由表条目 {N1,2}。这意味着，“通过发送到路由器
    RA，我可以以 2 个跳数的价格到达网络 N1。”
- en: 'Routers RB and RC will each send their own routing tables out over the networks
    to which they are connected: Networks N2 and N3\. This will contain the entry
    {N1,2}. Router RA will receive that message on Network N2 but will ignore it,
    since it knows it can reach Network N1 directly (cost of 1, which is less than
    2). But Router RD will receive the message on Network N3.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器 RB 和 RC 将各自将它们的路由表发送到它们连接的网络：网络 N2 和 N3。这将包含条目 {N1,2}。路由器 RA 将在 Network
    N2 上收到这条消息，但它将忽略它，因为它知道它可以直接到达网络 N1（成本为 1，小于 2）。但路由器 RD 将在 Network N3 上收到这条消息。
- en: Router RD will examine its routing table, and seeing no entry for Network N1,
    it will add the entry {N1,3} for Routers RB or RC. Either one will work, so whichever
    is chosen depends entirely on whether Router RD received information about Network
    N1 first from Router RB or Router RC.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器 RD 将检查它的路由表，看到没有关于网络 N1 的条目，它将为路由器 RB 或 RC 添加条目 {N1,3}。任何一个都可以工作，所以选择哪个完全取决于路由器
    RD 是否首先从路由器 RB 或路由器 RC 收到关于网络 N1 的信息。
- en: Router RD will send the entry {N1,3} on Network N4, but there are no other routers
    there to hear it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器 RD 将在 Network N4 上发送条目 {N1,3}，但那里没有其他路由器来接收它。
- en: Note that RIP is designed so that a routing entry is replaced only if information
    is received about a *shorter* route; ties go to the incumbent, if you will. This
    means that once Router RD creates an entry for Network N1 with a cost of 3 going
    through Router RB, if it receives information that it can reach Network N1 at
    the same cost of 3 through Router RC, it will ignore it. Similarly, if it gets
    Router RC's information first, it will ignore the information from Router RB.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，RIP 是设计成只有当收到关于 *更短* 路由的信息时才会替换路由条目；如果有平局，则保留现有的路由。这意味着一旦路由器 RD 为网络 N1 创建了一个通过路由器
    RB 以 3 个跳数的价格到达的条目，如果它收到信息说它可以通过路由器 RC 以相同的价格 3 到达网络 N1，它将忽略它。同样，如果它首先收到路由器 RC
    的信息，它将忽略路由器 RB 的信息。
- en: Naturally, this same propagation scheme will occur for all the other networks
    as well. I have shown only how information about Network N1 moves from router
    to router. For example, Router RA will eventually install an entry for Network
    N4 saying that it is reachable at a cost of 3 going through either Router RB or
    RC; this will be either {N4,RB,3} or {N4,RC,3}.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这个相同的传播方案也会发生在所有其他网络上。我只展示了关于网络 N1 的信息是如何从路由器到路由器移动的。例如，路由器 RA 最终会安装一个关于网络
    N4 的条目，说明它可以通过路由器 RB 或 RC 以 3 个跳数的价格到达；这将要么是 {N4,RB,3}，要么是 {N4,RC,3}。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Routing information is propagated between routers in RIP using
    a simple algorithm. On a regular basis, each router sends out RIP messages that
    specify which networks it can reach and how many hops it takes to reach them.
    Other routers directly connected to that one know that they can then reach those
    networks through that router at a cost of one additional hop. So if Router A sends
    a message saying it can reach Network X for a cost of *N* hops, every other router
    that connects directly to Router A can reach Network X for a cost of *N*+1 hops.
    It will put that information into its routing table, unless it knows of an alternate
    route through another router that has a lower cost.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在 RIP 中，路由信息是通过一个简单的算法在路由器之间传播的。定期地，每个路由器发送 RIP 消息，指定它可以到达哪些网络以及到达它们需要多少跳数。与该路由器直接相连的其他路由器知道，它们可以通过该路由器以额外一个跳数的价格到达那些网络。所以如果路由器
    A 发送一条消息说它可以以 *N* 个跳数的价格到达网络 X，那么连接到路由器 A 的每个其他路由器都可以以 *N*+1 个跳数的价格到达网络 X。它将把这个信息放入它的路由表中，除非它知道有通过另一个路由器到达的替代路线，并且该路线的成本更低。'
- en: '![Propagation of network routing information using RIP This composite diagram
    illustrates the five steps in propagating route information about Network N1 from
    Router RA to the rest of the AS. In step 1, the information is sent from Router
    RA to both of its connected networks. In step 2, it reaches Routers RB and RC,
    which then know they can reach Network N1 through Router RA at a cost of one additional
    hop. In step 3, these two routers send this information on their networks, and
    in step 4, it reaches Router RD. In step 5, Router RD sends out the information,
    but no other routers are around to receive it.](httpatomoreillycomsourcenostarchimages288031.png.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![使用RIP传播网络路由信息。此复合图说明了从路由器RA传播关于网络N1路由信息的五个步骤。在第1步，信息从路由器RA发送到其连接的两个网络。在第2步，它到达路由器RB和RC，然后它们知道它们可以通过路由器RA以额外跳数1到达网络N1。在第3步，这两个路由器将此信息发送到它们的网络，在第4步，它到达路由器RD。在第5步，路由器RD发送出信息，但没有其他路由器在附近接收它。](http://atomoreilly.com/source/nostarch/images/288031.png.jpg)'
- en: Figure 38-2. Propagation of network routing information using RIP This composite
    diagram illustrates the five steps in propagating route information about Network
    N1 from Router RA to the rest of the AS. In step 1, the information is sent from
    Router RA to both of its connected networks. In step 2, it reaches Routers RB
    and RC, which then know they can reach Network N1 through Router RA at a cost
    of one additional hop. In step 3, these two routers send this information on their
    networks, and in step 4, it reaches Router RD. In step 5, Router RD sends out
    the information, but no other routers are around to receive it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-2。使用RIP传播网络路由信息。此复合图说明了从路由器RA传播关于网络N1路由信息的五个步骤。在第1步，信息从路由器RA发送到其连接的两个网络。在第2步，它到达路由器RB和RC，然后它们知道它们可以通过路由器RA以额外跳数1到达网络N1。在第3步，这两个路由器将此信息发送到它们的网络，在第4步，它到达路由器RD。在第5步，路由器RD发送出信息，但没有其他路由器在附近接收它。
- en: This propagation of network routing information occurs on a regular basis, and
    also when the structure of the network changes (due to intentional changes in
    topography or failure of links or routers). When this happens, the change information
    will move through the internetwork so that all routers are eventually updated.
    For example, suppose a connection were added from Router RC to Network N1\. If
    Router RD previously had the entry {N1,RB,3}, it would eventually change this
    to {N1,RC,2}, since it could now reach Network N1 more quickly by going through
    Router RC.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种网络路由信息的传播是定期发生的，也发生在网络结构发生变化（由于地形的有意变化或链路或路由器的故障）时。当这种情况发生时，更改信息将通过互联网传播，以便最终更新所有路由器。例如，假设从路由器RC到网络N1添加了一个连接。如果路由器RD之前有{N1,RB,3}条目，它最终会将其更改为{N1,RC,2}，因为它现在可以通过路由器RC更快地到达网络N1。
- en: Default Routes
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认路由
- en: In some cases, it is not convenient for every network or host in a large internetwork
    to be fully specified with its own routing entry. Then it may be advantageous
    to specify a default route for the network to use in reaching hosts or networks
    for which they have no information. The most common example of this is when an
    AS connects to the public Internet through a single router. Except for that router,
    the rest of the local network doesn't need to know how to access the Internet.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，对于大型互联网中的每个网络或主机来说，使用自己的路由条目进行完全指定可能不方便。那么，为网络指定一个默认路由，以便在它们没有信息的情况下访问主机或网络，可能是有益的。最常见的例子是当一个自治系统（AS）通过单个路由器连接到公共互联网时。除了那个路由器之外，本地网络的其他部分不需要知道如何访问互联网。
- en: In RIP, information about a default route is communicated by having routers
    that are intended to handle such traffic send information about a "dummy" network
    with the address 0.0.0.0\. This is treated as if it were a regular network when
    information about routes is propagated on the internetwork using RIP messages,
    but other devices recognize this special address and understand that it means
    a default route.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在RIP中，默认路由的信息是通过打算处理此类流量的路由器发送关于一个地址为0.0.0.0的“虚拟”网络的信息来传递的。当在互联网上使用RIP消息传播路由信息时，这被视为一个常规网络，但其他设备识别这个特殊地址并理解它意味着默认路由。
- en: RIP General Operation, Messaging, and Timers
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 悼念通用操作、消息和定时器
- en: RIP is a protocol for exchanging routing information, so its operation can best
    be described in terms of the messages used to exchange this information and the
    rules for when messages are sent. The RIP software in each router sends messages
    and takes other actions both in reaction to certain events and in response to
    triggers set off by timers. Timers are also used to determine when routing information
    should be discarded if it is not updated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: RIP 是一种交换路由信息的协议，因此其操作最好用用于交换这些信息的消息以及发送消息的规则来描述。每个路由器中的 RIP 软件在响应某些事件以及由计时器触发的触发器时，都会发送消息并采取其他行动。计时器还用于确定当路由信息未更新时应该丢弃路由信息的时间。
- en: RIP Messages and Basic Message Types
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP 消息和基本消息类型
- en: Communication between RIP software elements in routers on an internetwork is
    accomplished through the use of *RIP messages*. These messages are sent using
    the UDP, with the UDP port number 520 reserved for RIP-1 and RIP-2, and 521 for
    RIPng. Thus, even though RIP is considered part of layer 3 like other routing
    protocols, it behaves more like an application in terms of how it sends messages.
    The exact format of the message is version-dependent, and all three formats (RIP,
    RIP-2, and RIPng) are described in detail later in this chapter. RIP messages
    can be either sent to a specific device or sent out for multiple devices to receive.
    If directed to one device, they are sent unicast; otherwise, they are either broadcast
    (in RIP) or multicast (RIP-2 and RIPng).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网中路由器上的 RIP 软件元素之间的通信是通过使用 *RIP 消息* 完成的。这些消息使用 UDP 发送，UDP 端口号 520 保留给 RIP-1
    和 RIP-2，521 保留给 RIPng。因此，尽管 RIP 被视为与其他路由协议一样属于第 3 层，但在发送消息方面它更像是一个应用程序。消息的确切格式取决于版本，本章后面将详细描述所有三种格式（RIP、RIP-2
    和 RIPng）。RIP 消息可以发送到特定设备，也可以发送给多个设备接收。如果指向一个设备，它们是单播发送；否则，它们在 RIP 中是广播，在 RIP-2
    和 RIPng 中是组播。
- en: 'There are only two basic message types for all three versions of RIP:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 RIP 的所有三个版本，只有两种基本消息类型：
- en: '**RIP Request** A message sent by a router to another router asking it to send
    back all or part of its routing table.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**RIP 请求** 路由器发送给另一个路由器的消息，要求它发送其路由表的全部或部分。'
- en: '**RIP Response** A message sent by a router containing all or part of its routing
    table. Note that despite the name, this message is *not* sent just in response
    to an RIP Request message, as you will see.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**RIP 响应** 包含路由器路由表全部或部分的消息。请注意，尽管名称如此，此消息并非仅作为对 RIP 请求消息的响应发送，正如您将看到的。'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The original RIP also defined a few other message types: Traceon, Traceoff,
    and a special message type reserved for use by Sun Microsystems. These are obsolete
    and no longer used. They were removed from the RIP-2 and RIPng standards*.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始的 RIP 还定义了几种其他消息类型：Traceon、Traceoff 和为 Sun Microsystems 保留的特殊消息类型。这些已经过时，不再使用。它们已被从
    RIP-2 和 RIPng 标准中删除*。'
- en: RIP Update Messaging and the 30-Second Timer
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP 更新消息和 30 秒计时器
- en: RIP Request messages are sent under special circumstances when a router requires
    that it be provided with immediate routing information. The most common example
    of this is when a router is first powered on. After initializing, the router will
    typically send an RIP Request message on its attached networks to ask for the
    latest information about routes from any neighboring routers. It is also possible
    for RIP Request messages to be used for diagnostic purposes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器需要立即提供路由信息时，会在特殊情况下发送 RIP 请求消息。最常见的例子是当路由器首次开机时。初始化后，路由器通常会在其连接的网络中发送一个
    RIP 请求消息，以请求从任何相邻路由器获取的最新路由信息。RIP 请求消息也可以用于诊断目的。
- en: A router receiving an RIP Request message will process it and send an RIP Response
    message containing either all of its routing table or just the entries the Request
    message asked for, as appropriate. Under normal circumstances, however, routers
    do not usually send RIP Request messages asking specifically for routing information.
    Instead, each RIP router has a special timer that goes off every 30 seconds. (This
    timer is not given a specific name in the RIP standards; it is just the 30-second
    timer.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到 RIP 请求消息的路由器将处理该消息，并发送一个 RIP 响应消息，其中包含其路由表的全部或仅请求的消息条目，根据情况而定。然而，在正常情况下，路由器通常不会发送特定的
    RIP 请求消息来请求路由信息。相反，每个 RIP 路由器都有一个特殊的计时器，每 30 秒触发一次。（在 RIP 标准中，此计时器没有特定的名称；它只是
    30 秒的计时器。）
- en: Each time the timer expires, an unsolicited (unrequested) broadcast or multicast
    is made of an RIP Response message containing the router's entire routing table.
    The timer is then reset, and 30 seconds later, it goes off again, causing another
    routine RIP Response message to be sent. This process ensures that route information
    is regularly sent around the Internet, so routers are always kept up-to-date about
    routes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每当计时器到期时，都会发出一个包含路由器整个路由表的RIP响应消息的无请求（未请求）广播或多播。然后重置计时器，30秒后再次启动，导致发送另一个常规的RIP响应消息。这个过程确保路由信息定期在互联网上发送，因此路由器始终能够了解路由信息。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** RIP uses two basic message types: the RIP Request and RIP Response.
    Both are sent using the User Datagram Protocol (UDP). RIP Response messages, despite
    their name, are used both for routine periodic routing table updates as well as
    to reply to RIP Request messages. Requests are sent only in special circumstances,
    such as when a router first joins a network.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** RIP使用两种基本消息类型：RIP请求和RIP响应。两者都使用用户数据报协议（UDP）发送。尽管名为RIP响应消息，但它们既用于常规周期性路由表更新，也用于响应RIP请求消息。请求仅在特殊情况下发送，例如当路由器首次加入网络时。'
- en: 'Preventing Stale Information: The Timeout Timer'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止过时信息：超时计时器
- en: When a router receives routing information and enters it into its routing table,
    that information cannot be considerd valid indefinitely. In the example presented
    earlier in the "RIP Route Determination and Information Propagation" section,
    suppose that after Router RB installs a route to Network N1 through Router RA,
    the link between Router RA and Network N2 fails. Once this happens, Network N1
    is no longer reachable from Router RB, but Router RB has a route indicating that
    it can reach Network N1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器接收到路由信息并将其输入其路由表时，该信息不能无限期地被认为是有效的。在“RIP路由确定和信息传播”部分前面给出的示例中，假设在路由器RB通过路由器RA安装到网络N1的路由后，路由器RA和网络N2之间的链路失败。一旦发生这种情况，网络N1就无法从路由器RB访问，但路由器RB有一个指示它可以访问网络N1的路由。
- en: To prevent this problem, routes are kept in the routing table for only a limited
    amount of time. A special Timeout timer is started whenever a route is installed
    in the routing table. Whenever the router receives another RIP Response message
    with information about that route, the route is considered refreshed, and its
    Timeout timer is reset. As long as the route continues to be refreshed, the timer
    will never expire.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，路由仅在路由表中保留有限的时间。每当在路由表中安装路由时，就会启动一个特殊的超时计时器。每当路由器收到包含该路由信息的另一个RIP响应消息时，该路由被认为是刷新的，并且其超时计时器被重置。只要路由继续刷新，计时器就不会到期。
- en: If, however, RIP Response messages containing that route stop arriving, the
    timer will eventually expire. When this happens, the route is marked for deletion
    by setting the distance for the route to 16 (which you may recall is RIP infinity
    and indicates an unreachable network). The default value for the Timeout timer
    is usually 180 seconds. This allows several periodic updates of a route to be
    missed before a router will conclude that the route is no longer reachable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果包含该路由的RIP响应消息停止到达，计时器最终会到期。当发生这种情况时，通过将路由的距离设置为16（你可能记得这是RIP无穷大，表示不可达的网络）来标记路由为删除。超时计时器的默认值通常是180秒。这允许在路由器得出路由不可达的结论之前，错过几个路由的周期性更新。
- en: 'Removing Stale Information: The Garbage-Collection Timer'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除过时信息：垃圾收集计时器
- en: When a route is marked for deletion, a new Garbage-Collection timer is also
    started. *Garbage collection* is a computer-industry phrase for a task that looks
    for deleted or invalid information and cleans it up. Thus, this is a timer that
    counts a number of seconds before the newly invalid route will be actually removed
    from the table. The default value for this timer is 120 seconds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个路由被标记为删除时，也会启动一个新的垃圾收集计时器。“垃圾收集”是计算机行业术语，指查找已删除或无效信息并将其清理的任务。因此，这是一个在从表中实际删除新无效路由之前计算秒数的计时器。此计时器的默认值为120秒。
- en: The reason for using this two-stage removal method is to give the router that
    declared the route that's no longer reachable a chance to propagate this information
    to other routers. Until the Garbage-Collection timer expires, the router will
    include that route, with the unreachable metric of 16 hops, in its own RIP Response
    messages, so that the problem with that route is conveyed to the other routers.
    When the timer expires, the route is deleted. If during the garbage collection
    period a new RIP Response message for the route is received, then the deletion
    process is aborted. In this case, the Garbage-Collection timer is cleared, the
    route is marked as valid again, and a new Timeout timer starts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种两阶段删除方法的原因是给声明了不再可达的路由的路由器一个机会，让它将此信息传播给其他路由器。在垃圾收集计时器到期之前，该路由器将包括该路由，其不可达度量值为16跳，在其自己的RIP响应消息中，以便将该路由的问题传达给其他路由器。当计时器到期时，该路由被删除。如果在垃圾收集期间收到该路由的新RIP响应消息，则删除过程被中止。在这种情况下，垃圾收集计时器被清除，该路由再次标记为有效，并启动一个新的超时计时器。
- en: Triggered Updates
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发更新
- en: In addition to the two situations already described where an RIP Response is
    sent—in reply to an RIP Request message and on expiration of the 30-second timer—an
    RIP Response message is also sent out when a route changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经描述的两种情况下发送RIP响应——回复RIP请求消息和在30秒计时器到期时——当路由发生变化时，也会发送RIP响应消息。
- en: This action, an enhancement to a basic RIP operation, called a *triggered update*,
    is intended to ensure that information about route changes is propagated as fast
    as possible across the internetwork. This will help reduce the slow convergence
    problem in RIP. For example, in the case of a route timing out and the Garbage-Collection
    timer starting, a triggered update would be sent out about the now-invalid route
    immediately. This is described in more detail later in the chapter, in the "RIP
    Special Features for Resolving RIP Algorithm Problems" section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作，对基本RIP操作的一种增强，称为*触发更新*，旨在确保路由变化的信息尽可能快地在互联网中传播。这将有助于减少RIP中的缓慢汇聚问题。例如，在路由超时和垃圾收集计时器启动的情况下，会立即发送关于现在无效路由的触发更新。这将在本章后面的“RIP解决RIP算法问题的特殊功能”部分中更详细地描述。
- en: RIP Problems and Some Resolutions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RIP问题及其解决方案
- en: The simplicity of RIP is often given as the main reason for its popularity.
    Simplicity is great most of the time, but an unfortunate price of simplicity in
    too many cases is that problems crop up, usually in unusual cases or special situations,
    and so it is with RIP. The straightforward distance-vector algorithm and operation
    mechanism work well most of the time, but they have some important weaknesses.
    We need to examine these problems to understand both the limitations of RIP and
    some of the complexities that have been added to the protocol to resolve them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: RIP的简单性经常被列为它受欢迎的主要原因。简单性大多数时候都是好的，但在很多情况下，简单性的不幸代价是问题会出现，通常是在不寻常的情况或特殊情况下，RIP也是如此。直接的距离矢量算法和操作机制在大多数情况下工作得很好，但它们有一些重要的弱点。我们需要检查这些问题，以了解RIP的限制以及为解决这些问题而添加到协议中的一些复杂性。
- en: Issues with RIP's Algorithm
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP算法的问题
- en: The most important area where we find serious issues with RIP is with the basic
    function of the distance-vector algorithm described earlier in this section and
    the way that messages are used to implement it, as described in the following
    sections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在RIP中遇到严重问题的最重要领域是本节前面描述的基本距离矢量算法的基本功能以及用于实现它的消息的使用方式，如以下各节所述。
- en: Slow Convergence
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇聚缓慢
- en: The distance-vector algorithm is designed so that all routers share all their
    routing information regularly. Over time, all routers eventually end up with the
    same information about the location of networks and which are the best routes
    to use to reach them. This is called *convergence*. Unfortunately, the basic RIP
    algorithm is rather slow to achieve convergence. It takes a long time for all
    routers to get the same information, and in particular, it takes a long time for
    information about topology changes to propagate.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 距离矢量算法被设计成所有路由器定期共享它们的所有路由信息。随着时间的推移，所有路由器最终都会拥有关于网络位置和到达它们最佳路由的相同信息。这被称为*汇聚*。不幸的是，基本的RIP算法在实现汇聚方面相当慢。所有路由器获取相同信息需要很长时间，特别是拓扑变化信息传播需要很长时间。
- en: Consider the worst-case situation of two networks separated by 15 routers. Since
    routers normally send RIP Response messages only every 30 seconds, a change to
    one of this pair of networks might not be seen by the router nearest to the other
    one until many minutes have elapsed—an eternity in networking terms.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个由15个路由器分隔的网络的最坏情况。由于路由器通常每30秒才发送一次RIP响应消息，因此这对网络中一个网络的变化可能要过好几分钟才会被另一个网络最近的路由器看到——在网络术语中这是一个漫长的等待。
- en: The slow convergence problem is even more pronounced when it comes to the propagation
    of route failures. Failure of a route is detected only through the expiration
    of the 180-second Timeout timer, so that adds up to three minutes more delay before
    convergence can even begin.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到路由故障的传播时，收敛缓慢的问题更为明显。路由故障的检测仅通过180秒超时计时器的到期来完成，这导致在收敛甚至开始之前还要额外增加三分钟的延迟。
- en: Routing Loops
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由环路
- en: 'A routing loop occurs when Router A has an entry telling it to send datagrams
    for Network 1 to Router B, and Router B has an entry saying that datagrams for
    Network 1 should be sent to Router A. Larger loops can also exist: Router A says
    to send to B, which says to send to Router C, which says to send to Router A.
    Under normal circumstances, these loops should not occur, but they can happen
    in special situations.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器A有一个条目指示它将网络1的数据报发送到路由器B，而路由器B有一个条目表示网络1的数据报应该发送到路由器A时，就会发生路由环路。更大的环路也可能存在：路由器A指示发送到B，B指示发送到C，C又指示发送到A。在正常情况下，这些环路不应该发生，但在特殊情况下它们可能会发生。
- en: RIP does not include any specific mechanism to detect or prevent routing loops.
    The best it can do is try to avoid them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: RIP没有包括任何特定的机制来检测或防止路由环路。它所能做的最好的事情就是试图避免它们。
- en: Counting to Infinity
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无限计数
- en: A special case of slow convergence can lead to a routing loop situation where
    one router passes bad information to another router, which sends more bad information
    to another router, and so on. This causes a situation where the protocol is sometimes
    described as unstable. The problem is called *counting to infinity*, for reasons
    you will soon see.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛缓慢的特殊情况可能导致路由环路情况，其中一个路由器向另一个路由器传递错误信息，该路由器又向另一个路由器发送更多错误信息，如此循环。这种情况有时被描述为协议不稳定。这个问题被称为*无限计数*，原因你很快就会看到。
- en: To understand how this happens, let's modify the example presented earlier in
    the "RIP Route Determination and Information Propagation" section, as shown in
    [Figure 38-3](ch38s04.html#the_rip_counting_to_infinity_problem_thi "Figure 38-3. The
    RIP counting to infinity problem This composite diagram shows part of the AS illustrated
    previously in Figure 38-1\. The top panel (1) shows the normal state of the network,
    with Router RB able to reach Network N1 through Router RA at a cost of 2\. In
    panel 2, the link between Router RA and Network N1 is broken. Router RA changes
    its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before Router RA
    can send out this update to Router RB, it receives a routine RIP message from
    Router RB indicating that Network N1 can be reached for a cost of 2\. Router RA
    is then fooled into thinking that it can use Router RB as an alternate route to
    Network N1, even though Router RB's information originally came from Router RA
    in the first place. In panel 4, Router RA then sends this bogus information out,
    which is received by Router RB in panel 5\. Router RB then increases its cost
    to 4, and on its next cycle will send this to Router RA, which will increase its
    cost to 5, and so on. This cycle will continue, with both routers "counting to
    infinity" (cost of 16)."). Suppose that the internetwork is operating properly
    for a while. Router RB has an entry indicating it can reach Network N1 through
    Router RA at a cost of 2\. But let's say the link from Network N1 to Router RA
    fails. After the Timeout timer for Network N1 expires on Router RA, that router
    will change the metric for Network N1 to 16 to indicate that it is unreachable.
    In the absence of any mechanism to force Router RA to immediately inform other
    routers of this failure, those routers will not know about the change. Router
    RB will continue to think it can reach Network N1 through Router RA.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何发生的，让我们修改“RIP路由确定和信息传播”部分中前面提到的示例，如图[图38-3](ch38s04.html#the_rip_counting_to_infinity_problem_thi
    "图38-3. RIP计数到无穷大问题 此复合图显示了之前在图38-1中展示的部分AS。顶部面板（1）显示了网络的正常状态，路由器RB能够以2的成本通过路由器RA到达网络N1。在面板2中，路由器RA和网络N1之间的链路中断。路由器RA将其到达网络N1的成本更改为16（RIP无穷大）。在面板3中，在路由器RA可以将此更新发送给路由器RB之前，它收到了来自路由器RB的常规RIP消息，表明可以通过2的成本到达网络N1。然后路由器RA被误导，认为它可以使用路由器RB作为到达网络N1的备用路由，尽管路由器RB的信息最初是从路由器RA那里来的。在面板4中，路由器RA随后发送了这条虚假信息，该信息在面板5中被路由器RB接收。然后路由器RB将其成本增加到4，在其下一个周期将发送此信息给路由器RA，这将使路由器RA的成本增加到5，依此类推。这个循环将继续，两个路由器都将“计数到无穷大”（成本为16）。”假设互联网在一段时间内运行正常。路由器RB有一个条目表示它可以通过路由器RA以2的成本到达网络N1。但是，假设网络N1到路由器RA的链路失败。在网络N1的超时计时器在路由器RA上到期后，该路由器将把网络N1的度量更改为16，以表示它不可达。在没有任何机制强制路由器RA立即通知其他路由器此故障的情况下，那些路由器将不知道这一变化。路由器RB将继续认为它可以通过路由器RA到达网络N1。
- en: '![The RIP counting to infinity problem This composite diagram shows part of
    the AS illustrated previously in . The top panel (1) shows the normal state of
    the network, with Router RB able to reach Network N1 through Router RA at a cost
    of 2\. In panel 2, the link between Router RA and Network N1 is broken. Router
    RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before
    Router RA can send out this update to Router RB, it receives a routine RIP message
    from Router RB indicating that Network N1 can be reached for a cost of 2\. Router
    RA is then fooled into thinking that it can use Router RB as an alternate route
    to Network N1, even though Router RB''s information originally came from Router
    RA in the first place. In panel 4, Router RA then sends this bogus information
    out, which is received by Router RB in panel 5\. Router RB then increases its
    cost to 4, and on its next cycle will send this to Router RA, which will increase
    its cost to 5, and so on. This cycle will continue, with both routers "counting
    to infinity" (cost of 16).](httpatomoreillycomsourcenostarchimages288033.png.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![RIP计数到无穷大问题 这个复合图展示了之前在 . 的AS的一部分。顶部面板（1）显示了网络的正常状态，其中路由器RB能够以2的成本通过路由器RA到达网络N1。在面板2中，路由器RA和网络N1之间的链路中断。路由器RA将其到达网络N1的成本更改为16（RIP无穷大）。在面板3中，在路由器RA可以将此更新发送给路由器RB之前，它收到了来自路由器RB的常规RIP消息，表明可以通过2的成本到达网络N1。然后，路由器RA被误导，认为它可以使用路由器RB作为到达网络N1的备用路由，尽管路由器RB的信息最初是从路由器RA那里来的。在面板4中，路由器RA随后发送了这条虚假信息，该信息在面板5中被路由器RB接收。然后，路由器RB将其成本增加到4，在其下一个周期将发送此信息给路由器RA，路由器RA的成本将增加到5，依此类推。这个周期将持续下去，两个路由器都将“计数到无穷大”（成本为16）](httpatomoreillycomsourcenostarchimages288033.png.jpg)'
- en: Figure 38-3. The RIP counting to infinity problem This composite diagram shows
    part of the AS illustrated previously in [Figure 38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si
    "Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four
    physical networks and four routers."). The top panel (1) shows the normal state
    of the network, with Router RB able to reach Network N1 through Router RA at a
    cost of 2\. In panel 2, the link between Router RA and Network N1 is broken. Router
    RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before
    Router RA can send out this update to Router RB, it receives a routine RIP message
    from Router RB indicating that Network N1 can be reached for a cost of 2\. Router
    RA is then fooled into thinking that it can use Router RB as an alternate route
    to Network N1, even though Router RB's information originally came from Router
    RA in the first place. In panel 4, Router RA then sends this bogus information
    out, which is received by Router RB in panel 5\. Router RB then increases its
    cost to 4, and on its next cycle will send this to Router RA, which will increase
    its cost to 5, and so on. This cycle will continue, with both routers "counting
    to infinity" (cost of 16).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-3. RIP计数到无穷大问题 这个复合图展示了之前在[图38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si
    "图38-1. 示例RIP AS 这是一个包含四个物理网络和四个路由器的简单AS的例子")中提到的AS的一部分。顶部面板（1）显示了网络的正常状态，其中路由器RB能够以2的成本通过路由器RA到达网络N1。在面板2中，路由器RA和网络N1之间的链路中断。路由器RA将其到达网络N1的成本更改为16（RIP无穷大）。在面板3中，在路由器RA可以将此更新发送给路由器RB之前，它收到了来自路由器RB的常规RIP消息，表明可以通过2的成本到达网络N1。然后，路由器RA被误导，认为它可以使用路由器RB作为到达网络N1的备用路由，尽管路由器RB的信息最初是从路由器RA那里来的。在面板4中，路由器RA随后发送了这条虚假信息，该信息在面板5中被路由器RB接收。然后，路由器RB将其成本增加到4，在其下一个周期将发送此信息给路由器RA，路由器RA的成本将增加到5，依此类推。这个周期将持续下去，两个路由器都将“计数到无穷大”（成本为16）。
- en: Now suppose Router RB's regular 30-second timer goes off before Router RA's
    next broadcast. Router RB will send its normal routing table, *which contains
    a route to Network N1 at a cost of 2*. Router RA will see this and say, "Hey look,
    Router RB has a route to Network N1 with a cost of 2! That means I can get there
    with a cost of 3, which sure beats my current cost of 16\. Let's use that!" So
    Router RA installs this route and cancels its Timeout timer. Of course, this is
    bogus information—Router RA doesn't realize that Router RB's claim of being able
    to reach Network N1 was based on old information from Router RA itself!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设路由器RB的常规30秒计时器在路由器RA的下次广播之前触发。路由器RB将发送其正常的路由表，*其中包含一条到网络N1的路由，成本为2*。路由器RA会看到这一点，并说：“嘿，看，路由器RB有一条到网络N1的路由，成本为2！这意味着我可以以3的成本到达那里，这肯定比我目前的16成本低。让我们使用它！”因此，路由器RA安装了这条路由并取消了其超时计时器。当然，这是虚假信息——路由器RA没有意识到路由器RB能够到达网络N1的声明是基于来自路由器RA自己的旧信息！
- en: It only gets worse from there. When it is time for Router RA's regular routing
    table update, it will broadcast a route to Network N1 with a cost of 3\. Now Router
    RB will see this and say, "Well, my route to Network N1 is through Router RA.
    Router RA was saying before that its cost was 1; but now it says the cost is 3\.
    That means I have to change my cost to 4."
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，情况变得更糟。当路由器RA的常规路由表更新时间到来时，它将广播一条到网络N1的路由，成本为3。现在路由器RB会看到这一点，并说：“嗯，我的到网络N1的路由是通过路由器RA的。路由器RA之前说它的成本是1；但现在它说成本是3。这意味着我必须将我的成本改为4。”
- en: Router RB will later send back to Router RA, and back and forth they will go,
    each incrementing the cost two at a time. This won't stop until the value of infinity
    cost of 16 is hit—thus the name counting to infinity. At this point, both routers
    will finally agree that Network N1 is unreachable, but as you can see, it takes
    a long time for it to happen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器RB稍后会发送回路由器RA，他们就这样来回发送，每次增加2的成本。这不会停止，直到无限大成本的16值被触及——因此得名“无限计数”。在这种情况下，两个路由器最终会同意网络N1不可达，但如您所见，这需要很长时间才能发生。
- en: Small Infinity
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小无限
- en: The use of a relatively small value for the infinity cost limits the slow convergence
    problem. Even in a situation where we count to infinity, the total amount of time
    elapsed is at least manageable. (Imagine if infinity were defined as say, 1,000!)
    Unfortunately, the drawback of this is that it limits the size of the internetwork
    that can be used for RIP.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相对较小的无限大成本值限制了缓慢收敛问题。即使在计数到无限大的情况下，经过的总时间也是至少可以管理的。（想象一下，如果无限大被定义为比如说1,000！）不幸的是，这种做法的缺点是限制了可以使用RIP的互联网的大小。
- en: Many people balk at the limit of a span of 15 routers in RIP, but to be honest
    I think it is much ado about, well, if not nothing, then nothing much. The 15
    value is not a limit on the total number of routers you can use, but rather a
    limit on the number of routers between any two networks. Consider that most internetworks
    are set up hierarchically. Even if you have a rather complex four-level hierarchy,
    you wouldn't be close to the 15-router limit. In fact, you could create a huge
    AS with thousands of routers, without having more than 15 routers between any
    two devices. So this is a limitation for only the very largest of ASes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人对RIP中15个路由器的跨度限制感到犹豫，但说实话，我认为这不过是小题大做，好吧，如果不是无关紧要的话，那么就是无关紧要的。15个值并不是你总共可以使用路由器的数量限制，而是任何两个网络之间路由器的数量限制。考虑到大多数互联网都是按层次结构设置的。即使你有一个相当复杂的四级层次结构，你也不会接近15个路由器的限制。实际上，你可以创建一个拥有数千个路由器的大型自治系统，而任何两个设备之间都不会超过15个路由器。因此，这只是一个针对非常大AS的限制。
- en: On the other hand, RIP's need to send out its entire routing table many times
    each hour makes it a potentially poor choice for a large internetwork regardless
    of the infinity=16 issue. In an internetwork with many routers, the amount of
    traffic RIP generates can become excessive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，RIP每小时需要多次发送其整个路由表，这使得它无论无限大=16的问题如何，都可能是一个大型互联网的潜在较差选择。在一个拥有许多路由器的互联网中，RIP产生的流量可能会变得过多。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小提示
- en: '**KEY CONCEPT** One of the most important problems with the operation of RIP
    is slow convergence, which describes the fact that it can take a long time for
    information about changes to a network to propagate between routers. One specific
    instance of this problem is the counting to infinity problem, in which out-of-date
    information causes many bogus RIP messages to be exchanged between routers about
    an unreachable network.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** RIP操作中存在的一个最重要问题是收敛速度慢，这描述了网络变化信息在路由器之间传播可能需要很长时间的事实。这个问题的一个具体实例是无限计数问题，其中过时的信息导致许多虚假的RIP消息在路由器之间关于不可达网络的交换。'
- en: To be fair, these problems are mostly general to distance-vector routing algorithms
    and not RIP in particular. Some of them are corrected through the implementation
    of specific changes to the algorithm or the rules under which RIP messages are
    sent, as described in the next section. According to RFC 2453, there was actually
    a proposal to increase RIP's infinity cost to a number larger than 16, but this
    would have caused compatibility problems with older devices (which would view
    any route with a metric of 16 or higher as unreachable), so it was rejected.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这些问题主要是针对距离矢量路由算法的，而不是针对RIP本身。其中一些问题通过在算法或RIP消息发送的规则下实施具体更改得到纠正，如下一节所述。根据RFC
    2453，实际上有一个提议将RIP的无限成本增加到16以上的一个数字，但这会导致与旧设备（将任何度量值为16或更高的路由视为不可达）的兼容性问题，因此被拒绝了。
- en: Issues with RIP's Metric
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP度量的问题
- en: In addition to these concerns with the algorithm itself, RIP is also often criticized
    because of its choice of metric. The first issue here is RIP's use of hop count
    as a distance metric. Simply put, hop count is a poor metric of the cost of sending
    a datagram between two networks. I believe the use of hop count as the metric
    in RIP is partially due to the desire for simplicity (it's easy to make the protocol
    work when hop count is all the routers need to consider). But the use of hop count
    is also partially an artifact of RIP being around for more than 20 years.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对算法本身的这些担忧之外，RIP还经常因其度量选择而受到批评。这里的首要问题是RIP使用跳数作为距离度量。简单来说，跳数是发送数据报文在两个网络之间成本的一个糟糕度量。我相信RIP中将跳数作为度量部分是由于对简单性的渴望（当跳数是所有路由器需要考虑的时，使协议工作变得容易）。但使用跳数也是RIP存在超过20年的部分原因。
- en: Decades ago, computers were slow, so each time a datagram passed through a router
    there was probably a significant delay. Hop count was not a perfect metric even
    then, but I think it had more correspondence with how long it took to move a datagram
    across an internetwork than it does today.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，计算机速度慢，所以每次数据报通过路由器时，可能都会有一个显著的延迟。即使在那时，跳数也不是一个完美的度量，但我认为它比现在更符合数据报在互联网中传输所需的时间。
- en: Modern routers are lightning fast, making hop count a flawed way of measuring
    network distance. The number of hops taken often has no correlation with the actual
    amount of time it takes to move data across a route. To take an extreme case,
    consider two networks that are connected by a direct dial-up telephone networking
    link using 56K modems. Let's say they are also connected by a sequence of three
    routers using high-speed DS-3 lines. RIP would consider the 56K link a better
    route because it has fewer hops, even though it clearly is much slower.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现代路由器非常快速，使得跳数成为衡量网络距离的一个有缺陷的方法。跳数的数量通常与实际在路由上传输数据所需的时间没有关联。为了举一个极端的例子，考虑两个通过56K调制解调器直接拨号电话网络连接连接的网络。假设它们还通过使用高速DS-3线路的三个路由器序列连接。RIP会认为56K链路是一个更好的路由，因为它有更少的跳数，尽管它显然要慢得多。
- en: Another issue is RIP's lack of support for dynamic (real-time) metrics. Even
    if RIP were to use a more meaningful metric than hop count, the algorithm requires
    that the metric should be fixed for each link. There is no way to have RIP calculate
    the best route based on real-time data about various links the way protocols like
    OSPF do (see [Chapter 39](ch39.html "Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)")).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是没有支持RIP的动态（实时）度量。即使RIP使用比跳数更有意义的度量，算法也要求每个链路的度量应该是固定的。没有方法让RIP像OSPF这样的协议那样根据各种链路的实时数据计算最佳路由（见[第39章](ch39.html
    "第39章。开放最短路径优先（OSPF）")）。
- en: Most of these problems are built into RIP and cannot be resolved. Interestingly,
    some RIP implementations apparently do let administrators "fudge" certain routes
    to compensate for the limitations of the hop count metric. For example, the routers
    on either end of the 56K link mentioned earlier could be configured so that they
    considered the 56K link to have a hop count of ten instead of one. This would
    cause any routes using the link to be more expensive than the DS-3 path. This
    is clever, but hardly an elegant or general solution.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些问题都内置在RIP中，无法解决。有趣的是，一些RIP实现似乎允许管理员“调整”某些路由，以补偿跳数度量指标的局限性。例如，前面提到的56K链路两端的路由器可以被配置为将56K链路视为跳数为十而不是一。这将导致使用该链路的任何路由都比DS-3路径更昂贵。这是聪明的，但几乎不是一个优雅或通用的解决方案。
- en: Note that in addition to the rather long list of problems that I've mentioned,
    there were also some specific issues with the first version of RIP. Some of the
    more important of these include lack of support for Classless Inter-Domain Routing
    (CIDR), lack of authentication, and a performance reduction caused by the use
    of broadcasts for messaging. These were mostly addressed through extensions in
    RIP-2.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了我提到的相当长的问题列表之外，RIP的第一个版本还有一些具体问题。其中一些更重要的问题包括不支持无类别域间路由（CIDR）、缺乏认证以及由于使用广播进行消息传递而导致的性能下降。这些问题大部分通过RIP-2的扩展得到了解决。
- en: RIP Special Features for Resolving RIP Algorithm Problems
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决RIP算法问题的RIP特殊特性
- en: The simplicity of RIP is its most attractive quality, but as you just saw, this
    leads to certain problems with how it operates. Most of these limitations are
    related to the basic algorithm used for determining routes, and the method of
    message passing that's being used to implement the algorithm. In order for RIP
    to be a useful protocol, some of these issues needed to be addressed, in the form
    of changes to the basic RIP algorithm and operational scheme we explored earlier
    in this section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: RIP的简单性是其最吸引人的特性，但正如你所看到的，这导致了它在操作上的一些问题。这些限制中的大多数都与用于确定路由的基本算法以及实现该算法的消息传递方法有关。为了使RIP成为一个有用的协议，需要解决这些问题，形式上是对我们在本节
    earlier 探讨的基本RIP算法和操作方案的改变。
- en: 'The solution to problems that arise due to RIP being too simple is to add complexity
    in the form of features that add more intelligence to the way that RIP operates.
    In the following sections, we''ll take a look at four of these: *split horizon*,
    *split horizon with poisoned reverse*, *triggered updates*, and *hold down*.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RIP过于简单而产生的问题的解决方案是添加复杂性，以特征的形式增加RIP操作方式的智能。在接下来的几节中，我们将探讨其中的四个：*分割水平*、*分割水平带毒反转*、*触发更新*和*保持状态*。
- en: Note that while I describe these as "features," at least some of them are really
    necessary to ensure the proper RIP functionality. Therefore, they are generally
    considered standard parts of RIP, and most were described even in the earliest
    RIP documents. However, sometimes performance or stability issues may arise when
    these techniques are used, especially in combination. For this reason different
    RIP implementations may omit some features. For example, hold down slows down
    route recovery and may not be needed when other features such as split horizon
    are used. As always, care must be taken to ensure that all routers are using the
    same features, or even greater problems may arise.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我把这些描述为“特性”，但至少其中一些是确保RIP正确功能所必需的。因此，它们通常被认为是RIP的标准部分，甚至在最早的RIP文档中就有描述。然而，有时当使用这些技术时，尤其是在组合使用时，可能会出现性能或稳定性问题。因此，不同的RIP实现可能会省略一些特性。例如，保持状态会减慢路由恢复，当使用其他特性如分割水平时可能就不需要了。像往常一样，必须小心确保所有路由器都使用相同的特性，否则可能会出现更大的问题。
- en: Also, see the upcoming section on RIP-2's specific features, later in this chapter,
    for a description of the Next Hop feature, which helps reduce convergence and
    routing problems when RIP is used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请参阅本章后面的RIP-2特定特性的即将到来的部分，以了解下一跳特性的描述，该特性有助于在RIP使用时减少收敛和路由问题。
- en: Split Horizon
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割水平
- en: 'The counting to infinity problem is one of the most serious issues with the
    basic RIP algorithm. In the example in the previous section, the cause of the
    problem is immediately obvious: After Network N1 fails and Router RA notices it
    go down, Router RB "tricks" Router RA into thinking it has an alternate path to
    Network N1 by sending Router RA a route advertisement to Network N1.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 无限计数问题是基本RIP算法中最严重的问题之一。在前一个部分的例子中，问题的原因立即很明显：在N1网络失败并且路由器RA注意到它失败后，路由器RB通过向路由器RA发送到N1的路由广告来“欺骗”路由器RA，让它认为它有一个到达N1的替代路径。
- en: If you think about it, it doesn't really make sense under *any* circumstances
    to have Router RB send an advertisement to Router RA about a network that Router
    RB can access only through Router RA in the first place. In the case where the
    route fails, it causes this problem, which is obviously a good reason not do it.
    But even when the route is operational, what is the point of Router RB telling
    Router RA about it? Router RA already has a shorter connection to the network
    and will therefore never send traffic intended for Network N1 to Router RB anyway.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，在任何情况下，让路由器RB向路由器RA发送关于一个只能通过路由器RA访问的网络的路由广告，这实际上在**任何**情况下都没有意义。在路由失败的情况下，这会导致这个问题，这显然是一个很好的理由不这么做。但是即使路由是可操作的，路由器RB告诉路由器RA这个路由有什么意义呢？路由器RA已经有一个到网络的更短连接，因此它无论如何都不会将意图发送到网络N1的流量发送到路由器RB。
- en: 'Clearly, the best solution is simply to have Router RB not include any mention
    of the route to Network N1 in any RIP Response messages it sends to Router RA.
    We can generalize this by adding a new rule to RIP operation: When a router sends
    out an RIP Response message on any of the networks to which it is connected, it
    omits any route information that it originally learned from that network. This
    feature is called *split horizon*, because the router effectively splits its view
    of the internetwork, sending different information on certain links than on others.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最好的解决方案是让路由器RB在其发送给路由器RA的任何RIP响应消息中不提及到网络N1的路由。我们可以通过向RIP操作添加一条新规则来概括这一点：当路由器在它连接的任何网络上发送RIP响应消息时，它省略了从该网络最初学习到的任何路由信息。这个功能被称为**分割水平**，因为路由器实际上分割了其对互联网的看法，在某些链路上发送的信息与在其他链路上发送的信息不同。
- en: With this new rule, let's consider the behavior of Router RB. It has an interface
    on Network N2, which it shares with Router RA. It will therefore not include any
    information on routes it originally obtained from Router RA when sending on Network
    N2\. This will prevent the counting to infinity loop you saw in the previous section.
    Similarly, because Router RD is on Network N3, Router RB will not send any information
    about routes it got from Router RD when sending on Network N3.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新规则，让我们考虑路由器RB的行为。它有一个连接到网络N2的接口，它与路由器RA共享。因此，当它在网络N2上发送时，它将不会包含从路由器RA那里最初获得的路由信息。这将防止你在前一个部分中看到的无限计数循环。同样，因为路由器RD在网络N3上，路由器RB在发送到网络N3时，不会发送从路由器RD那里获得的任何路由信息。
- en: Note, however, that split horizon may not always solve the counting to infinity
    problem, especially in the case where multiple routers are connected indirectly.
    The classic example would be three routers configured in a triangle. In this situation,
    problems may still result due to data that is propagated in two directions between
    any two routers. In this case, the hold down feature, described shortly, may be
    of assistance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，分割水平（split horizon）并不总是能解决无限计数问题，尤其是在多个路由器间接连接的情况下。一个经典的例子是三个路由器配置成三角形。在这种情况下，由于任何两个路由器之间传播的数据是双向的，可能会出现问题。在这种情况下，稍后描述的保持下降（hold
    down）功能可能会有所帮助。
- en: Split Horizon with Poisoned Reverse
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割水平与中毒反转
- en: Adding "poisoned reverse" provides an enhancement of the basic split horizon
    feature. Instead of omitting routes learned from a particular interface when sending
    RIP Response messages on that interface, we include those routes but set their
    metric to RIP infinity, or 16\. So in the previous example, Router RB *would*
    include the route to Network N1 in its transmissions on Network N2, but it would
    say the cost to reach Network N1 was 16 instead of its real cost (which is 2).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 添加“中毒反转”（poisoned reverse）增强了基本的分割水平功能。在发送RIP响应消息时，不是从特定接口省略从该接口学习到的路由，而是包括这些路由，但将它们的度量设置为RIP无穷大，即16。所以，在先前的例子中，路由器RB会在其发送到网络N2的传输中包含到网络N1的路由，但它会说到达网络N1的成本是16，而不是其实际成本（即2）。
- en: 'The *poisoned reverse* refers to the fact that we are poisoning the routes
    that we want to make sure routers on that interface don''t use. Router RA will
    see Router RB advertise Network N1 but with a cost of 16, which serves as an explicit
    message to Router RA: "There is absolutely no way for you to get to Network N1
    through Router RB." This provides more insurance than the regular split horizon
    feature, because if the link from Router RA to Network N1 is broken, Router RA
    will know for certain that it can''t try to get a new route through Router RB.
    [Figure 38-4](ch38s04.html#rip_problem_solving_using_split_horizon_ "Figure 38-4. RIP
    problem solving using split horizon with poisoned reverse The top panel in this
    diagram (1) shows the same example as in Figure 38-3\. In panel 2, as before,
    the link between Router RA and Network N1 is broken, just as Router RB is ready
    to send out its routine update. However, the split horizon with poisoned reverse
    feature means it sends different messages on its two links. On the network that
    connects it to Router RA, it sends a route advertisement with a cost of 16\. In
    panel 3, Router RA receives this, which it will discard, ensuring no counting
    to infinity problem occurs. On Router RA''s next cycle, it will update Router
    RB to tell it that Network N1 is no longer reachable.") shows how split horizon
    with poisoned reverse works.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “中毒反转”指的是我们正在中毒那些我们想要确保接口上的路由器不使用的路由。路由器RA将看到路由器RB通告网络N1，但成本为16，这作为对路由器RA的一个明确信息：“你绝对不可能通过路由器RB到达网络N1。”这比常规的分割水平特性提供了更多的保险，因为如果路由器RA到网络N1的链路中断，路由器RA将确定它不能尝试通过路由器RB获取新的路由。[图38-4](ch38s04.html#rip_problem_solving_using_split_horizon_
    "图38-4. 使用中毒反转分割水平解决RIP问题。该图的上半部分（1）显示了与图38-3相同的示例。在面板2中，与之前一样，路由器RA和网络N1之间的链路中断，就像路由器RB准备发送其常规更新一样。然而，分割水平与中毒反转特性意味着它在两个链路上发送不同的信息。在连接到路由器RA的网络中，它发送一个成本为16的路由通告。在面板3中，路由器RA接收这个通告，它将丢弃，确保不会发生无限计数问题。在路由器RA的下一个周期，它将更新路由器RB，告诉它网络N1不再可达。")展示了分割水平与中毒反转是如何工作的。
- en: This technique also works in normal circumstances (meaning when there is no
    issue such as a broken link to a network). In that case, Router RA will receive
    updates from Router RB with a cost of 16 on a periodic basis, but Router RA will
    never try to reach Network N1 through Router RB anyway, since it is directly connected
    to Network N1 (cost of 1).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也在正常情况下（意味着没有像网络链路中断这样的问题）有效。在这种情况下，路由器RA将定期从路由器RB接收成本为16的更新，但路由器RA永远不会尝试通过路由器RB到达网络N1，因为它直接连接到网络N1（成本为1）。
- en: Triggered Updates
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发更新
- en: 'The routing loop problem we looked at earlier in this chapter occurred because
    Router RB advertised Router RA''s route back to Router RA. There''s another aspect
    of the problem that is also significant: After Router RA discovered that the link
    to Network N1 failed, it had to wait up to 30 seconds until its next scheduled
    transmission time to tell other routers about the failure.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们讨论的路由环路问题发生，是因为路由器RB向路由器RA通告了路由器RA的路由。这个问题还有一个重要的方面：当路由器RA发现连接到网络N1的链路失败后，它必须等待多达30秒，直到下一个预定传输时间才能通知其他路由器关于链路失败的情况。
- en: 'For RIP to work well, when something significant happens, we want to tell other
    routers on the internetwork immediately. For this reason, a new rule should be
    added to the basic RIP router operation: Whenever a router changes the metric
    for a route it is required to (almost) immediately send out an RIP Response message
    to tell its immediate neighbor routers about the change. If these routers, seeing
    this change, update their routing information, they are in turn required to send
    out updates. Thus, the change of any network route information causes cascading
    updates to be sent throughout the internetwork, significantly reducing the slow
    convergence problem. Note that this includes the removal of a route due to expiration
    of its Timeout timer, since the first step in route removal is setting the route''s
    metric to 16, which triggers an update.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使RIP工作良好，当发生重大事件时，我们希望立即通知互联网上的其他路由器。因此，应该向基本的RIP路由器操作中添加一条新规则：每当路由器更改其路由的度量值时，它必须（几乎）立即发送一个RIP响应消息，通知其直接相邻的路由器关于更改的情况。如果这些路由器看到这个更改，它们将更新它们的路由信息，然后它们反过来必须发送更新。因此，任何网络路由信息的变化都会导致整个互联网上发送级联更新，显著减少缓慢收敛问题。请注意，这包括由于超时定时器的到期而删除路由的情况，因为删除路由的第一步是将路由的度量值设置为16，这会触发一个更新。
- en: '![RIP problem solving using split horizon with poisoned reverse The top panel
    in this diagram (1) shows the same example as in . In panel 2, as before, the
    link between Router RA and Network N1 is broken, just as Router RB is ready to
    send out its routine update. However, the split horizon with poisoned reverse
    feature means it sends different messages on its two links. On the network that
    connects it to Router RA, it sends a route advertisement with a cost of 16\. In
    panel 3, Router RA receives this, which it will discard, ensuring no counting
    to infinity problem occurs. On Router RA''s next cycle, it will update Router
    RB to tell it that Network N1 is no longer reachable.](httpatomoreillycomsourcenostarchimages288035.png.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![RIP问题解决使用带毒回溯的分割视域 The 图表的上面板（1）显示了与图中的相同示例。在面板2中，与之前一样，RA路由器与网络N1之间的链路已断开，正如RB路由器准备发送其常规更新。然而，分割视域带毒回溯功能意味着它在两个链路上发送不同的消息。在连接到RA路由器的网络上，它发送一个成本为16的路由通告。在面板3中，RA路由器收到这个通告，它将丢弃这个通告，确保不会出现无限计数问题。在RA路由器的下一个周期，它将更新RB路由器，告诉它网络N1不再可达。](httpatomoreillycomsourcenostarchimages288035.png.jpg)'
- en: Figure 38-4. RIP problem solving using split horizon with poisoned reverse The
    top panel in this diagram (1) shows the same example as in [Figure 38-3](ch38s04.html#the_rip_counting_to_infinity_problem_thi
    "Figure 38-3. The RIP counting to infinity problem This composite diagram shows
    part of the AS illustrated previously in Figure 38-1\. The top panel (1) shows
    the normal state of the network, with Router RB able to reach Network N1 through
    Router RA at a cost of 2\. In panel 2, the link between Router RA and Network
    N1 is broken. Router RA changes its cost to reach Network N1 to 16 (RIP infinity).
    In panel 3, before Router RA can send out this update to Router RB, it receives
    a routine RIP message from Router RB indicating that Network N1 can be reached
    for a cost of 2\. Router RA is then fooled into thinking that it can use Router
    RB as an alternate route to Network N1, even though Router RB's information originally
    came from Router RA in the first place. In panel 4, Router RA then sends this
    bogus information out, which is received by Router RB in panel 5\. Router RB then
    increases its cost to 4, and on its next cycle will send this to Router RA, which
    will increase its cost to 5, and so on. This cycle will continue, with both routers
    "counting to infinity" (cost of 16)."). In panel 2, as before, the link between
    Router RA and Network N1 is broken, just as Router RB is ready to send out its
    routine update. However, the split horizon with poisoned reverse feature means
    it sends different messages on its two links. On the network that connects it
    to Router RA, it sends a route advertisement with a cost of 16\. In panel 3, Router
    RA receives this, which it will discard, ensuring no counting to infinity problem
    occurs. On Router RA's next cycle, it will update Router RB to tell it that Network
    N1 is no longer reachable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-4. 使用带毒回溯的分割视域解决RIP问题 图表的上面板（1）显示了与[图38-3](ch38s04.html#the_rip_counting_to_infinity_problem_thi
    "图38-3. RIP无限计数问题 此复合图显示了图38-1中先前展示的部分AS。上面板（1）显示了网络的正常状态，RB路由器可以通过RA路由器以2的成本到达网络N1。在面板2中，RA路由器与网络N1之间的链路已断开。RA路由器将其到达网络N1的成本更改为16（RIP无限）。在面板3中，在RA路由器向RB路由器发送此更新之前，它收到了RB路由器发送的常规RIP消息，表明网络N1可以通过2的成本到达。然后RA路由器被误导，认为它可以使用RB路由器作为到达网络N1的备用路由，尽管RB路由器的信息最初是从RA路由器那里来的。在面板4中，RA路由器随后发送了这些虚假信息，这些信息在面板5中被RB路由器接收。然后RB路由器将其成本增加到4，在其下一个周期将发送此信息给RA路由器，RA路由器的成本将增加到5，依此类推。这个过程将继续，两个路由器都将“无限计数”（成本为16）)。在面板2中，与之前一样，RA路由器与网络N1之间的链路已断开，正如RB路由器准备发送其常规更新。然而，分割视域带毒回溯功能意味着它在两个链路上发送不同的消息。在连接到RA路由器的网络上，它发送一个成本为16的路由通告。在面板3中，RA路由器收到这个通告，它将丢弃这个通告，确保不会出现无限计数问题。在RA路由器的下一个周期，它将更新RB路由器，告诉它网络N1不再可达。](httpatomoreillycomsourcenostarchimages288035.png.jpg)
- en: You probably noticed that I said that triggered updates were sent "almost" immediately.
    In fact, before sending a triggered update a route waits a random amount of time,
    from 1 to 5 seconds. This is done to reduce the load on the internetwork that
    would result from many routers sending update messages nearly simultaneously.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我说触发的更新是“几乎”立即发送的。事实上，在发送触发更新之前，路由等待一个随机的时长，从1到5秒。这样做是为了减少由许多路由器几乎同时发送更新消息而对互联网造成的负载。
- en: Hold Down
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按住
- en: Split horizon tries to solve the counting to infinity problem by suppressing
    the transmission of invalid information about routes that fail. For extra insurance,
    we can implement a feature that changes how devices receiving route information
    process it in the case of a failed route. The *hold down* feature works by having
    each router start a timer when it first receives information about a network that
    is unreachable. Until the timer expires, the router will discard any subsequent
    route messages that indicate that the route is in fact reachable. A typical Hold
    Down timer runs for 60 or 120 seconds.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔水平尝试通过抑制关于失败路由的无效信息传输来解决计数到无限问题。为了额外的保险，我们可以实现一个功能，该功能在收到失败路由信息时改变接收路由信息处理方式。*保持*功能通过让每个路由器在首次收到关于不可达网络的信息时启动计时器来实现。在计时器到期之前，路由器将丢弃任何后续的路由消息，这些消息表明该路由实际上是可达的。典型的保持计时器运行时间为60或120秒。
- en: The main advantage of this technique is that a router won't be confused by receiving
    spurious information about a route being accessible when it was just recently
    told that the route was no longer valid. It provides a period of time for out-of-date
    information to be flushed from the system, which is valuable especially on complex
    internetworks. Adding hold down to split horizon can also help in situations where
    split horizon alone is insufficient for preventing counting to infinity, such
    as when a trio of routers are linked in a triangle, as discussed earlier.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的优点是，路由器不会因为收到关于路由可访问的虚假信息而困惑，因为它刚刚被告知该路由不再有效。它提供了一个时间段，让过时的信息从系统中清除，这在复杂的互联网中尤其有价值。将保持功能添加到分隔水平也可以帮助在仅分隔水平不足以防止计数到无限的情况下的情况，例如，当三个路由器以三角形的形式相互连接时，如前所述。
- en: The main disadvantage of hold down is that it forces a delay in a router responding
    to a route once it is fixed. Suppose that a route went down for just five seconds
    for some reason. After the network is up again, routers will want to again know
    about this. However, the Hold Down timer must expire before the router will try
    to use that network again. This makes internetworks using hold down relatively
    slow to respond to corrected routes, and it could lead to delays in accessing
    networks that fail intermittently.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 保持的主要缺点是它迫使路由器在路由修复后延迟响应。假设由于某种原因，路由仅关闭了五秒钟。当网络再次上线后，路由器将再次想要了解这一点。然而，保持计时器必须到期，路由器才会再次尝试使用该网络。这使得使用保持功能的互联网响应修正路由相对较慢，并且可能导致间歇性失败的网络的访问延迟。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Four special features represent changes to RIP operation that
    ameliorate or eliminate the problems with the operation of the basic protocol.
    *Split horizon* and *split horizon with poisoned reverse* prevent a router from
    sending invalid route information back to the router from which it originally
    learned the route. *Triggered updates* reduce the slow convergence problem by
    causing the immediate propagation of changed route information. Finally, the *hold
    down* feature may be used to provide robustness when information about a failed
    route is received.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 四个特殊功能代表了RIP操作的变化，这些变化改善了或消除了基本协议操作中的问题。*分隔水平*和*分隔水平带毒反转*防止路由器将其从最初学习路由的路由器发送无效的路由信息。*触发更新*通过立即传播更改后的路由信息来减少缓慢收敛问题。最后，*保持*功能可以在收到失败路由信息时提供鲁棒性。'
- en: RIP Version-Specific Message Formats and Features
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RIP版本特定的消息格式和功能
- en: As I've noted, RIP has been in widespread use for more than two decades. During
    that time, internetworks and internetworking technologies have changed. To keep
    up with the times, RIP has also evolved and today has three different versions.
    The basic operation of all three is fairly similar, and it was described in the
    previous sections of this chapter. As you might expect, there are also some differences
    between the versions. One of the more important of these is the format used for
    RIP messages in each version, and the meaning and use of the fields within that
    format.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，RIP已经广泛使用超过二十年了。在这段时间里，互联网和互联网技术已经发生了变化。为了跟上时代的步伐，RIP也进行了演变，如今有三个不同的版本。这三个版本的基本操作相当相似，这在前面的章节中已经描述过。正如你所预期的，版本之间也有一些差异。其中之一是每个版本中RIP消息的格式，以及该格式中字段的含义和使用。
- en: It's now time to take a look at the message format used by each of the three
    versions of RIP as well as certain specific features not common to all versions.
    I begin with the original RIP, now also known as *RIP version 1*. I then describe
    the updated version of RIP called *RIP version 2* or *RIP-2*. Finally, I discuss
    *RIPng*, also sometimes called *RIPv6*; it's the version of RIP used for IPv6\.
    (Note that this is not technically a new version of the original RIP but a new
    protocol closely based on the earlier RIP versions.)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候查看RIP三个版本各自使用的消息格式，以及某些并非所有版本都有的特定功能了。我首先介绍原始的RIP，现在也被称为*RIP版本1*。然后，我描述RIP的更新版本，称为*RIP版本2*或*RIP-2*。最后，我讨论*RIPng*，有时也称为*RIPv6*；这是用于IPv6的RIP版本。（注意，这并不是原始RIP的新版本，而是一个基于早期RIP版本的新协议。）
- en: RIP Version 1 (RIP-1) Message Format and Features
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP版本1（RIP-1）消息格式和功能
- en: RIP evolved as an industry standard and was popularized by its inclusion in
    the Berkeley Standard Distribution of UNIX (BSD UNIX). This first version of RIP
    (now sometimes called RIP-1 to differentiate it from later versions) was eventually
    standardized in RFC 1058\. As part of this standard, the original RIP-1 message
    format was defined, which of course serves *RIP-1* itself, and is also the basis
    for the format used in later versions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: RIP作为一个行业标准而发展起来，并通过其包含在伯克利标准分布的UNIX（BSD UNIX）中而普及。RIP的第一个版本（现在有时称为RIP-1，以区分后续版本）最终在RFC
    1058中标准化。作为该标准的一部分，定义了原始的RIP-1消息格式，当然这服务于*RIP-1*本身，也是后续版本格式的基础。
- en: RIP-1 Messaging
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIP-1消息
- en: 'As explained in the general discussion on RIP operation in the previous sections,
    route information is exchanged in RIP through the sending of two different types
    of RIP messages: RIP Request and the RIP Response. These are transmitted as regular
    TCP/IP messages using UDP, which uses the UDP reserved port number 520\. This
    port number is used as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节中关于RIP操作的通用讨论所述，RIP通过发送两种不同类型的RIP消息来交换路由信息：RIP请求和RIP响应。这些消息作为常规TCP/IP消息通过UDP传输，UDP使用保留的端口号520。该端口号的使用如下：
- en: 'RIP Request messages are sent to UDP destination port 520\. They may have a
    source port of 520 or may use an ephemeral port number (see [Chapter 43](ch43.html
    "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS") for an explanation of
    ephemeral ports).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RIP请求消息发送到UDP目标端口520。它们可能具有源端口520或可能使用一个临时端口号（有关临时端口号的解释，请参阅[第43章](ch43.html
    "第43章. TCP和UDP寻址：端口和套接字")）。
- en: RIP Response messages sent in reply to an RIP Request are sent with a source
    port of 520 and a destination port equal to whatever source port the RIP Request
    used.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对RIP请求的回复发送的RIP响应消息使用源端口520和与RIP请求使用的源端口相等的目标端口。
- en: Unsolicited RIP Response messages (sent on a routine basis and not in response
    to a request) are sent with both the source and destination ports, which are set
    to 520.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无请求的RIP响应消息（定期发送，而不是响应请求）使用源端口和目标端口，这两个端口都设置为520。
- en: RIP-1 Message Format
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIP-1消息格式
- en: The basic message format for RIP-1 is described in [Table 38-1](ch38s05.html#rip-_message_format
    "Table 38-1. RIP-1 Message Format") and illustrated [Figure 38-5](ch38s05.html#rip-1_message_format_the_rip-1_message_f
    "Figure 38-5. RIP-1 message format The RIP-1 message format can contain up to
    25 RIP entries. Here, RIP entry 1 is shown with each of its constituent subfields.").
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: RIP-1的基本消息格式在[表38-1](ch38s05.html#rip-_message_format "表38-1. RIP-1消息格式")中描述，并在[图38-5](ch38s05.html#rip-1_message_format_the_rip-1_message_f
    "图38-5. RIP-1消息格式 RIP-1消息格式可以包含多达25个RIP条目。在这里，展示了RIP条目1及其各个组成部分子字段。")中展示。
- en: Table 38-1. RIP-1 Message Format
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表38-1. RIP-1消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Command | 1 | Command Type: Identifies the type of RIP message being sent.
    A value of 1 indicates an RIP Request, while 2 means an RIP Response. Originally,
    three other values and commands were also defined: 3 and 4 for the Traceon and
    Traceoff commands, and 5, which was reserved for use by Sun Microsystems. These
    are obsolete and no longer used. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 1 | 命令类型：标识发送的RIP消息类型。值为1表示RIP请求，而2表示RIP响应。最初，还定义了三种其他值和命令：3和4用于Traceon和Traceoff命令，5为Sun
    Microsystems保留。这些已过时，不再使用。 |'
- en: '| Version | 1 | Version Number: Set to 1 for RIP version 1. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 | 版本号：对于RIP版本1设置为1。 |'
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 必须为零 | 2 | 字段保留；值必须设置为全零。 |'
- en: '| RIP Entries | 20 to 500, in increments of 20 | The body of an RIP message
    consists of 1 to 25 sets of RIP entries. These entries contain the actual route
    information that the message is conveying. Each entry is 20 bytes long and has
    the subfields shown in [Table 38-2](ch38s05.html#rip-_rip_entries "Table 38-2. RIP-1
    RIP Entries"). |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| RIP条目 | 20至500，以20为增量 | RIP消息的主体由1至25组RIP条目组成。这些条目包含消息传达的实际路由信息。每个条目长20字节，并具有[表38-2](ch38s05.html#rip-_rip_entries
    "表38-2. RIP-1 RIP条目")中显示的子字段。 |'
- en: Table 38-2. RIP-1 RIP Entries
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 表38-2. RIP-1 RIP条目
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Address Family Identifier | 2 | A fancy name for a field that identifies
    the type of address in the entry. The routers are using IP addresses, for which
    this field value is 2. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 地址族标识符 | 2 | 这是一个用于标识条目中地址类型的字段的别称。路由器使用IP地址，该字段的值为2。 |'
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 必须为零 | 2 | 字段保留；值必须设置为全零。 |'
- en: '| IP Address | 4 | The address of the route the routers are sending information
    about. No distinction is made between addresses of different types of devices
    in RIP, so the address can be for a network, a subnet, or a single host. It is
    also possible to send an address of all zeros, which is interpreted as the default
    route for other devices on the network to use for reaching routes with no specified
    routing entries. This is commonly used to allow a network to access the Internet.
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| IP地址 | 4 | 路由器发送信息关于的路由地址。在RIP中，不对不同类型设备的地址进行区分，因此地址可以是网络、子网或单个主机。也可以发送全零的地址，这被解释为网络中其他设备用于到达没有指定路由条目的路由的默认路由。这通常用于允许网络访问互联网。
    |'
- en: '| Must Be Zero | 4 | Field reserved; value must be set to all zeros. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 必须为零 | 4 | 字段保留；值必须设置为全零。 |'
- en: '| Must Be Zero | 4 | Field reserved; value must be set to all zeros. (Yes,
    two of them in a row.) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 必须为零 | 4 | 字段保留；值必须设置为全零。（是的，连续两个都是。） |'
- en: '| Metric | 4 | The distance for the network indicated by the IP address in
    the IP Address field. Values of 1 to 15 indicate the number of hops to reach the
    network, while a value of 16 represents infinity (an unreachable destination).
    See the general discussion of the RIP algorithm earlier in this chapter for more
    information about the use of metrics. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 度量值 | 4 | 由IP地址字段中指示的网络的距离。1到15的值表示到达网络的跳数，而16的值表示无穷大（不可达的目的地）。有关度量值的使用，请参阅本章前面关于RIP算法的一般讨论。
    |'
- en: '![RIP-1 message format The RIP-1 message format can contain up to 25 RIP entries.
    Here, RIP entry 1 is shown with each of its constituent subfields.](httpatomoreillycomsourcenostarchimages288037.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![RIP-1消息格式 The RIP-1 message format can contain up to 25 RIP entries. Here,
    RIP entry 1 is shown with each of its constituent subfields.](httpatomoreillycomsourcenostarchimages288037.png)'
- en: Figure 38-5. RIP-1 message format The RIP-1 message format can contain up to
    25 RIP entries. Here, RIP entry 1 is shown with each of its constituent subfields.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-5. RIP-1消息格式 RIP-1消息格式可以包含多达25个RIP条目。在此，展示了RIP条目1及其所有构成子字段。
- en: 'If you''re like me, the first thing that comes to mind after looking at this
    message format is this: What''s with all the extra space? I mean, we have four
    different fields that are reserved (must be zero), and even most of the other
    fields are larger than they need to be (a metric of 1 to 16 needs only 4 bits,
    not 32). The command type and version number could also easily have been made
    only 4 bits each, if not less. And why bother having a 2-byte field to identify
    the address type when we are only going to deal with IP addresses anyway?'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，看到这个消息格式后首先想到的是：所有这些额外的空间是干什么的？我的意思是，我们有四个不同的保留字段（必须为零），甚至大多数其他字段都比所需的要大（一个1到16的度量值只需要4位，而不是32位）。如果不需要，命令类型和版本号也可以很容易地只占用4位，甚至更少。而且，既然我们只处理IP地址，为什么还要有一个2字节的字段来标识地址类型呢？
- en: This seeming wastefulness is actually an artifact of the generality of the original
    RIP design. The protocol was intended to be able to support routing for a variety
    of different internetworking protocols, not just Internet Protocol (IP). Remember
    that it wasn't even originally developed with IP in mind. So, the Address Family
    Identifier was included to specify address type, and RIP entries were made large
    enough to handle large addresses. IP requires only 4 bytes per address, so some
    of the space is not used.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看似浪费的做法实际上是原始RIP设计通用性的产物。该协议旨在能够支持各种不同互连协议的路由，而不仅仅是互联网协议（IP）。记住，它最初甚至没有考虑到IP。因此，地址族标识符被包括在内以指定地址类型，并且RIP条目被设计得足够大，可以处理大型地址。IP只需要每个地址4个字节，所以一些空间没有被使用。
- en: RIP-1 Version-Specific Features
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIP-1版本特定功能
- en: Since RIP-1 was the first version of the protocol, its features formed the basis
    for future RIP versions; it doesn't really have any version-specific features.
    What RIP-1 has is a number of limitations, such as a lack of support for specifying
    classless addresses and no means for authentication. RIP-2 was created to address
    some of RIP-1 shortcomings. As you will see in the next section, RIP-2's features
    put to good use those "Must Be Zero" bytes in the RIP-1 format!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RIP-1是协议的第一个版本，其特性构成了未来RIP版本的基础；它实际上并没有任何版本特定功能。RIP-1所具有的是一些限制，例如不支持指定无类别地址以及没有认证手段。RIP-2的创建是为了解决RIP-1的一些不足。正如你将在下一节中看到的那样，RIP-2的功能充分利用了RIP-1格式中的“必须为零”字节！
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** RIP-1 was the first version of RIP and is the simplest in terms
    of operation and features. The bulk of an RIP-1 message consists of sets of RIP
    entries that specify route addresses and the distance to the route in hops.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** RIP-1是RIP的第一个版本，在操作和功能方面是最简单的。一个RIP-1消息的大部分由一组RIP条目组成，这些条目指定路由地址和到达该路由的跳数。'
- en: RIP Version 2 (RIP-2) Message Format and Features
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIP版本2（RIP-2）消息格式和功能
- en: The original RIP (RIP-1) has a number of problems and limitations. As the TCP/IP
    protocol suite evolved and changed, RIP-1's problems were compounded by it becoming
    somewhat out of date. It was unable to handle newer IP features. There were some
    who felt that the existence of newer and better interior routing protocols meant
    that it would be best to just give up on RIP entirely and move over to something
    like OSPF.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的RIP（RIP-1）存在许多问题和限制。随着TCP/IP协议套件的演变和变化，RIP-1的问题由于变得有些过时而加剧。它无法处理新的IP功能。有些人认为，存在更新、更好的内部路由协议意味着最好是完全放弃RIP，转而使用类似OSPF的协议。
- en: However, RIP's appeal was never its technical superiority, but its simplicity
    and ubiquity in the industry. By the early 1990s, RIP was already in use in many
    thousands of networks. For those who liked RIP, it made more sense to migrate
    to a newer version that addressed some of RIP-1's shortcomings than to go to an
    entirely different protocol. To this end, a new version of the protocol, RIP-2
    was developed. It was initially published in RFC 1388 in 1993\. It is now defined
    in RFC 2453, "RIP Version 2," which was published in November 1998.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，RIP的吸引力从未在于其技术优势，而在于其简单性和在行业中的普遍性。到20世纪90年代初，RIP已经在成千上万的网络中使用。对于那些喜欢RIP的人来说，迁移到一个新版本，该版本解决了RIP-1的一些不足，比转向一个完全不同的协议更有意义。为此，开发了一个新的协议版本，即RIP-2。它最初于1993年在RFC
    1388中发布。现在，它在1998年11月发布的RFC 2453，“RIP版本2”中定义。
- en: RIP-2 Version-Specific Features
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIP-2版本特定功能
- en: 'RIP-2 represents a very modest change to the basic RIP. RIP-2 works in the
    same basic way as RIP-1\. In fact, the new features introduced in RIP-2 are described
    as *extensions* to the basic protocol, thereby conveying the fact that they are
    layered upon regular RIP-1 functionality. The five key RIP-2 extensions are as
    follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: RIP-2对基本的RIP进行了非常小的改动。RIP-2与RIP-1以相同的基本方式工作。实际上，RIP-2中引入的新特性被描述为对基本协议的**扩展**，从而传达了它们是建立在常规RIP-1功能之上的这一事实。五个关键的RIP-2扩展如下：
- en: '**Classless Addressing Support and Subnet Mask Specification** When RIP-1 was
    developed, the use of subnets in IP (as described in RFC 950) had not yet been
    formally defined. It was still possible to use RIP-1 with subnets through the
    use of a heuristic to determine if the destination is a network, subnet, or host.
    However, there was no way to clearly specify the subnet mask for an address using
    RIP-1 messages. RIP-2 adds explicit support for subnets by allowing a subnet mask
    within the route entry for each network address. It also provides support for
    Variable Length Subnet Masking (VLSM; see [Chapter 18](ch18.html "Chapter 18. IP
    SUBNET ADDRESSING (SUBNETTING) CONCEPTS")) and CIDR.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**无类别地址支持及子网掩码指定** 当RIP-1开发时，IP中的子网使用（如RFC 950中所述）尚未正式定义。仍然可以通过使用启发式方法来确定目的地是网络、子网还是主机来使用RIP-1与子网。然而，使用RIP-1消息无法明确指定地址的子网掩码。RIP-2通过允许每个网络地址的路由条目中包含子网掩码来显式支持子网。它还提供了对可变长度子网掩码（VLSM；见[第18章](ch18.html
    "第18章. IP子网地址（子网划分）概念"))和CIDR的支持。'
- en: '**Next Hop Specification** In RIP-2, each RIP entry includes a space where
    an explicit IP address can be entered as the next-hop router for datagrams that
    are intended for the network in that entry. This feature can help improve efficiency
    of routing by eliminating unnecessary extra hops for datagrams sent to certain
    destinations. One common use of this field is when the most efficient route to
    a network is through a router that is not running RIP. Such a router will not
    exchange RIP messages and would therefore not normally be selected by RIP routers
    as a next hop for any network. The explicit Next Hop field allows the router to
    be selected as the next hop, regardless of this situation.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一跳指定** 在RIP-2中，每个RIP条目都包含一个空间，可以输入一个显式的IP地址作为该条目网络的数据报的下一跳路由器。这个特性可以通过消除发送到某些目的地的数据报的不必要额外跳数来帮助提高路由效率。这个字段的常见用途是当到达网络的最有效路由是通过不运行RIP的路由器时。这样的路由器不会交换RIP消息，因此通常不会被RIP路由器选为任何网络的下一跳。显式的下一跳字段允许路由器在这种情况下被选为下一跳。'
- en: '**Authentication** RIP-1 included no authentication mechanism, which is a problem
    because it could potentially allow a malicious host to attack an internetwork
    by sending bogus RIP messages. RIP-2 provides a basic authentication scheme that
    allows routers to ascertain the identity of a router before it will accept RIP
    messages from it.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证** RIP-1没有包含认证机制，这是一个问题，因为它可能允许恶意主机通过发送虚假的RIP消息来攻击互联网。RIP-2提供了一个基本的认证方案，允许路由器在它接受来自该路由器的RIP消息之前确定该路由器的身份。'
- en: '**Route Tag** Each RIP-2 entry includes a Route Tag field where additional
    information about a route can be stored. This information is propagated along
    with other data about the route as RIP entries are sent around the internetwork.
    A common use of this field is when a route is learned from a different AS in order
    to identify the AS from which the route was obtained.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由标记** 每个RIP-2条目都包含一个路由标记字段，可以存储关于路由的附加信息。这些信息会随着路由的其他数据一起在互联网中传播，当RIP条目在互联网中发送时。这个字段的常见用途是在从不同的AS学习路由时，以便识别获取路由的AS。'
- en: '**Use of Multicasting** To help reduce network load, RIP-2 allows routers to
    be configured to use multicasts instead of broadcasts for sending out unsolicited
    RIP Response messages. These datagrams are sent out using the special reserved
    multicast address 224.0.0.9\. All routers on an internetwork must use multicast
    if this is to work properly.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播的使用** 为了帮助减少网络负载，RIP-2允许路由器配置为使用多播而不是广播来发送未经请求的RIP响应消息。这些数据报使用特殊的保留多播地址224.0.0.9发送。如果要让这正常工作，互联网上的所有路由器都必须使用多播。'
- en: As you can see, many of these extensions require more information to be included
    with each advertised route. This is where all that extra space in the message
    format of RIP-1 routing entries comes in handy, as you will see shortly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，许多这些扩展都需要在每个广告路由中包含更多信息。这就是RIP-1路由条目消息格式中所有额外空间派上用场的地方，你很快就会看到。
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** RIP-2 is the most recent version of RIP used in IPv4\. It includes
    a number of enhancements over the original RIP-1, including support for subnet
    masks and classless addressing, explicit next-hop specification, route tagging,
    authentication, and multicast. For compatibility, it uses the same basic message
    format as RIP-1, putting the extra information required for its new features into
    some of the unused fields of the RIP-1 message format.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** RIP-2是IPv4中使用的最新版本的RIP。它包括对原始RIP-1的许多改进，包括对子网掩码和无类别寻址的支持、显式下一跳指定、路由标记、身份验证和组播。为了兼容性，它使用与RIP-1相同的消息格式，将所需的新功能信息放入RIP-1消息格式的某些未使用字段中。'
- en: RIP-2 Messaging
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIP-2消息传递
- en: 'RIP-2 messages are exchanged using the same basic mechanism as RIP-1 messages.
    Two different message types exist: RIP Request and RIP Response. They are sent
    using UDP, which uses the reserved port number 520\. The semantics for the use
    of this port are the same as for RIP-1\. For convenience, I''ll repeat the description
    here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: RIP-2消息的交换使用与RIP-1消息相同的基本机制。存在两种不同的消息类型：RIP请求和RIP响应。它们使用UDP发送，UDP使用保留端口号520。此端口的用法语义与RIP-1相同。为了方便，我在此处重复描述：
- en: RIP Request messages are sent to UDP destination port 520\. They may have a
    source port of 520 or may use an ephemeral port number.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RIP请求消息发送到UDP目的端口520。它们可能具有源端口520或可能使用一个临时端口号。
- en: RIP Response messages sent in reply to an RIP Request message are sent with
    a source port of 520 and a destination port equal to whatever source port the
    RIP Request message used.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应RIP请求消息的RIP响应消息的源端口为520，目的端口等于RIP请求消息使用的源端口。
- en: Unsolicited RIP Response messages (sent on a routine basis and not in response
    to a request) are sent with both the source and destination ports set to 520.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非请求的RIP响应消息（定期发送，而不是响应请求）的源端口和目的端口都设置为520。
- en: RIP-2 Message Format
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIP-2消息格式
- en: The basic message format for RIP-2 is also pretty much the same as it was for
    RIP-1, with the Version field set to 2 in order to clearly identify the message
    as being RIP-2\. [Table 38-3](ch38s05.html#rip-_message_format-id001 "Table 38-3. RIP-2
    Message Format") and [Figure 38-6](ch38s05.html#rip-2_message_format_the_rip_entries_of_
    "Figure 38-6. RIP-2 message format The RIP entries of RIP-1 are called Route Table
    Entries (RTEs) in RIP-2; the message format can contain up to 25\. The format
    of RTE 1 is shown here with each of its subfields (the others are summarized to
    save space).") illustrate the RIP-2 message format. The real differences are in
    the individual RIP entries, as you can see in [Table 38-4](ch38s05.html#rip-_route_table_entries_rtes
    "Table 38-4. RIP-2 Route Table Entries (RTEs)").
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: RIP-2的基本消息格式与RIP-1基本相同，版本字段设置为2，以便清楚地识别该消息为RIP-2。[表38-3](ch38s05.html#rip-_message_format-id001
    "表38-3. RIP-2消息格式")和[图38-6](ch38s05.html#rip-2_message_format_the_rip_entries_of_
    "图38-6. RIP-2消息格式 RIP-1中的条目在RIP-2中称为路由表条目（RTEs）；消息格式最多可包含25个。RTE 1的格式在此处显示，其中每个子字段（其他字段已汇总以节省空间）")说明了RIP-2的消息格式。真正的区别在于单个RIP条目，如[表38-4](ch38s05.html#rip-_route_table_entries_rtes
    "表38-4. RIP-2路由表条目（RTEs）")所示。
- en: Table 38-3. RIP-2 Message Format
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表38-3. RIP-2消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Command | 1 | Command Type: Identifies the type of RIP message being sent.
    A value of 1 indicates an RIP Request, while 2 means an RIP Response. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 1 | 命令类型：标识发送的RIP消息类型。值为1表示RIP请求，而2表示RIP响应。|'
- en: '| Version | 1 | Version Number: Set to 2 for RIP version 2. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 | 版本号：设置为2表示RIP版本2。|'
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 必须为零 | 2 | 字段保留；值必须设置为全零。|'
- en: '| Route Table Entries (RTEs) | 20 to 500, in increments of 20 | As with RIP-1,
    the body of an RIP-2 message consists of 1 to 25 sets of route information. In
    RIP-2 these are labeled Route Table Entries, or RTEs. Each RTE is 20 bytes long
    and has the subfields shown in [Table 38-4](ch38s05.html#rip-_route_table_entries_rtes
    "Table 38-4. RIP-2 Route Table Entries (RTEs)"). |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 路由表条目（RTEs） | 20至500，以20为增量 | 与RIP-1一样，RIP-2消息的主体由1至25组路由信息组成。在RIP-2中，这些被标记为路由表条目，或RTEs。每个RTE长度为20字节，并具有[表38-4](ch38s05.html#rip-_route_table_entries_rtes
    "表38-4. RIP-2路由表条目（RTEs）")中显示的子字段（其他字段已汇总以节省空间）。|'
- en: Table 38-4. RIP-2 Route Table Entries (RTEs)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表38-4. RIP-2路由表条目（RTEs）
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Address Family Identifier | 2 | Same meaning as for RIP-1; value is 2 to
    identify IP addresses. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 地址族标识符 | 2 | 与RIP-1相同，值为2用于标识IP地址。 |'
- en: '| Route Tag | 2 | Additional information to be carried with this route. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 路由标记 | 2 | 需要与此路由一起携带的附加信息。 |'
- en: '| IP Address | 4 | Same as in RIP-1: the address of the route the router is
    sending information about. No distinction is made between the address of different
    types of devices in RIP, so the address can be for a network, a subnet, or a single
    host. It is also possible to send an address of all zeros, which is interpreted
    as the default route, as in RIP-1. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| IP地址 | 4 | 与RIP-1相同：路由器发送信息关于的路由地址。在RIP中不区分不同类型设备的地址，因此地址可以是网络、子网或单个主机。也可以发送全零地址，这被解释为默认路由，如在RIP-1中。
    |'
- en: '| Subnet Mask | 4 | The subnet mask associated with this address. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 子网掩码 | 4 | 与此地址关联的子网掩码。 |'
- en: '| Next Hop | 4 | Address of the device to use as the next hop for the network
    advertised in this entry. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 下一个跃点 | 4 | 作为此条目中广告的网络的下一个跃点的设备地址。 |'
- en: '| Metric | 4 | The distance for the network indicated by the IP address, as
    in RIP-1\. Values of 1 to 15 indicate the number of hops to reach the network
    (as described in the discussion of the RIP algorithm earlier in this chapter),
    while a value of 16 represents infinity (an unreachable destination). |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 距离度量 | 4 | 由IP地址指示的网络距离，如在RIP-1中。值1到15表示到达网络所需的跳数（如本章前面关于RIP算法的讨论所述），而值为16表示无穷大（不可达的目的地）。
    |'
- en: As you can see, the unused fields allow the new RIP-2 features to be implemented
    without changing the basic structure of the RIP entry format. This allows RIP-1
    and RIP-2 messages and devices to coexist in the same network. An RIP-2 device
    can handle both RIP-1 and RIP-2 messages, and will look at the version number
    to see which version the message is. An RIP-1 device should handle both RIP-2
    and RIP-1 messages the same way, simply ignoring the extra RIP-2 fields it doesn't
    understand.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，未使用的字段允许在不改变RIP条目基本结构的情况下实现新的RIP-2功能。这允许RIP-1和RIP-2消息和设备在同一网络中共存。一个RIP-2设备可以处理RIP-1和RIP-2消息，并且会查看版本号以确定消息的版本。一个RIP-1设备应以相同的方式处理RIP-2和RIP-1消息，简单地忽略它不理解的多余的RIP-2字段。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If authentication is used, one of the RTEs contains authentication information,
    thus limiting the message to 24 "real" RTEs*.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果使用身份验证，其中一个RTE包含身份验证信息，因此将消息限制为24个“真实”RTE*。'
- en: '![RIP-2 message format The RIP entries of RIP-1 are called Route Table Entries
    (RTEs) in RIP-2; the message format can contain up to 25\. The format of RTE 1
    is shown here with each of its subfields (the others are summarized to save space).](httpatomoreillycomsourcenostarchimages288039.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![RIP-2消息格式 The RIP entries of RIP-1 are called Route Table Entries (RTEs)
    in RIP-2; the message format can contain up to 25\. The format of RTE 1 is shown
    here with each of its subfields (the others are summarized to save space).](httpatomoreillycomsourcenostarchimages288039.png)'
- en: Figure 38-6. RIP-2 message format The RIP entries of RIP-1 are called Route
    Table Entries (RTEs) in RIP-2; the message format can contain up to 25\. The format
    of RTE 1 is shown here with each of its subfields (the others are summarized to
    save space).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-6. RIP-2消息格式 RIP-1中的RIP条目在RIP-2中称为路由表条目（RTEs）；消息格式可以包含多达25个。这里显示了RTE 1的格式，以及它的各个子字段（其他字段为了节省空间进行了总结）。
- en: RIPng (RIPv6) Message Format and Features
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIPng（RIPv6）消息格式和功能
- en: The future of TCP/IP is IPv6, which makes some very important changes to IP,
    especially with regard to addressing. Since IPv6 addresses are different than
    IPv4 addresses, everything that works with IP addresses must change to function
    under IPv6\. This includes routing protocols, which exchange addressing information.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP的未来是IPv6，这给IP带来了非常重要的变化，特别是在地址方面。由于IPv6地址与IPv4地址不同，与IP地址一起工作的所有内容都必须更改才能在IPv6下运行。这包括路由协议，它们交换地址信息。
- en: To ensure a future for the RIP, a new IPv6-compatible version had to be developed.
    This new version was published in 1997 in RFC 2080, *RIPng for IPv6*, where the
    *ng* stands for next generation (IPv6 is also sometimes called *IP next generation*).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保RIP的未来，必须开发一个与IPv6兼容的新版本。这个新版本于1997年在RFC 2080中发布，名为*RIPng for IPv6*，其中*ng*代表下一代（IPv6有时也称为*IP
    next generation*）。
- en: RIPng, which is also occasionally seen as RIPv6 for obvious reasons, was designed
    to be as similar as possible to the current version of RIP for IPv4, which is
    RIP-2\. In fact, RFC 2080 describes RIPng as the minimum change possible to RIP
    to allow it to work on IPv6\. Despite this effort, it was not possible to define
    RIPng as just a new version of the older RIP, as RIP-2 was defined. RIPng is a
    new protocol, which was necessary because of the significance of the changes between
    IPv4 and IPv6—especially the change from 32-bit to 128-bit addresses in IPv6,
    which necessitated a new message format.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显而易见的原因，RIPng 有时也被称为 RIPv6，它被设计成尽可能类似于当前版本的 IPv4 RIP，即 RIP-2。实际上，RFC 2080
    将 RIPng 描述为对 RIP 进行最小更改，以便使其能够在 IPv6 上工作。尽管做出了这些努力，但无法将 RIPng 定义为仅是较老 RIP 的新版本，就像
    RIP-2 一样。RIPng 是一种新的协议，这是由于 IPv4 和 IPv6 之间变化的重大意义所必需的——特别是 IPv6 中从 32 位到 128 位的地址变化，这需要新的消息格式。
- en: RIPng Version-Specific Features
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIPng 版本特定功能
- en: Even though RIPng is a new protocol, a specific effort was made to make RIPng
    like its predecessors. Its basic operation is almost entirely the same, and it
    uses the same overall algorithm and operation, as you saw earlier in this chapter.
    RIPng also does not introduce any specific new features compared to RIP-2, except
    those needed to implement RIP on IPv6.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 RIPng 是一种新的协议，但仍然做出了特定的努力使其类似于其前辈。其基本操作几乎完全相同，它使用与本章前面看到的相同的整体算法和操作。与 RIP-2
    相比，RIPng 也没有引入任何特定的新功能，除了在 IPv6 上实现 RIP 所必需的功能。
- en: 'RIPng maintains most of the enhancements introduced in RIP-2; some are implemented
    as they were in RIP-2, while others appear in a modified form. Here''s specifically
    how the five extensions in RIP-2 are implemented in RIPng:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: RIPng 保留了 RIP-2 中引入的大多数增强功能；一些按 RIP-2 中的方式实现，而其他则以修改后的形式出现。以下是 RIP-2 中的五个扩展如何在
    RIPng 中实现的具体说明：
- en: '**Classless Addressing Support and Subnet Mask Specification** In IPv6 all,
    addresses are classless and specified using an address and a prefix length, instead
    of a subnet mask. Thus, a field for the prefix length is provided for each entry
    instead of a subnet mask field.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**无类别地址支持和子网掩码指定** 在 IPv6 中，所有地址都是无类别的，并使用地址和前缀长度指定，而不是子网掩码。因此，为每个条目提供了一个前缀长度字段，而不是子网掩码字段。'
- en: '**Next Hop Specification** This feature is maintained in RIPng, but implemented
    differently. Due to the large size of IPv6 addresses, if you include a Next Hop
    field in the format of RIPng, the RTEs would almost double the size of every entry.
    Since Next Hop is an optional feature, this would be wasteful. Instead, when a
    Next Hop is needed, it is specified in a separate routing entry.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一跳指定** 该功能在 RIPng 中得到保留，但实现方式不同。由于 IPv6 地址的长度较大，如果在 RIPng 格式中包含下一跳字段，RTEs
    的每个条目的大小几乎会翻倍。由于下一跳是一个可选功能，这将是一种浪费。相反，当需要下一跳时，它将在单独的路由条目中指定。'
- en: '**Authentication** RIPng does not include its own authentication mechanism.
    It is assumed that if authentication and/or encryption are needed, they will be
    provided using the standard IPsec features, which are defined for IPv6 at the
    IP layer. This is more efficient than having individual protocols like RIPng perform
    authentication.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证** RIPng 不包括自己的认证机制。假设如果需要认证和/或加密，它们将通过标准 IPsec 功能提供，这些功能在 IPv6 的 IP 层中定义。这比让像
    RIPng 这样的单个协议执行认证更有效。'
- en: '**Route Tag** This field is implemented in the same way as it is in RIP-2.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由标记** 该字段与 RIP-2 中的实现方式相同。'
- en: '**Use of Multicasting** RIPng uses multicasts for transmissions, specifically
    the reserved IPv6 multicast address FF02::9.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播的使用** RIPng 使用多播进行传输，具体使用保留的 IPv6 多播地址 FF02::9。'
- en: RIPng Messaging
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIPng 消息
- en: 'There are two basic RIPng message types, RIP Request and RIP Response, which
    are exchanged using the UDP as with RIP-1 and RIP-2\. Since RIPng is a new protocol,
    it cannot use the same UDP reserved port number 520, which is used for RIP-1/RIP-2\.
    Instead, RIPng uses well-known port number 521\. The semantics for the use of
    this port are the same as those used for port 520 in RIP-1 and RIP-2\. For convenience,
    here are the rules again:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: RIPng 有两种基本的消息类型，即 RIP 请求和 RIP 响应，它们使用 UDP 进行交换，就像 RIP-1 和 RIP-2 一样。由于 RIPng
    是一种新的协议，它不能使用与 RIP-1/RIP-2 相同的保留 UDP 端口号 520，该端口号用于 RIP-1/RIP-2。相反，RIPng 使用已知的端口号
    521。该端口号的使用语义与 RIP-1 和 RIP-2 中使用的端口号 520 的语义相同。为了方便，这里再次列出规则：
- en: RIP Request messages are sent to UDP destination port 521\. They may have a
    source port of 521 or may use an ephemeral port number.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RIP请求消息发送到UDP目的端口521。它们可能具有源端口521或可能使用一个临时端口号。
- en: RIP Response messages sent in reply to an RIP Request message are sent with
    a source port of 521 and a destination port equal to whatever source port the
    RIP Request message used.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应RIP请求消息发送的RIP响应消息使用源端口521，目的端口等于RIP请求消息使用的源端口。
- en: Unsolicited RIP Response messages (sent on a routine basis and not in response
    to a request) are sent with both the source and destination ports set to 521.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无请求的RIP响应消息（定期发送，而不是响应请求）的源端口和目的端口都设置为521。
- en: RIPng Message Format
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIPng消息格式
- en: The message format for RIPng is similar to that of RIP-1 and RIP-2, except for
    the format of the RTEs. It is shown in [Table 38-5](ch38s05.html#ripng_message_format-id001
    "Table 38-5. RIPng Message Format") and illustrated in [Figure 38-7](ch38s05.html#ripng_message_format_ripng_retains_the_u
    "Figure 38-7. RIPng message format RIPng retains the use of RTEs from RIP-2, but
    their format has been changed to accommodate the much larger IPv6 address size.
    The limit of 25 entries per message has also been eliminated.").
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: RIPng的消息格式与RIP-1和RIP-2类似，除了RTEs的格式。它显示在[表38-5](ch38s05.html#ripng_message_format-id001
    "表38-5. RIPng消息格式")中，并在[图38-7](ch38s05.html#ripng_message_format_ripng_retains_the_u
    "图38-7. RIPng消息格式 RIPng保留了RIP-2中RTEs的使用，但它们的格式已更改以适应更大的IPv6地址大小。每条消息的条目限制也已取消。")中说明。
- en: Table 38-5. RIPng Message Format
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 表38-5. RIPng消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Command | 1 | Command Type: Identifies the type of RIPng message being sent.
    A value of 1 indicates an RIPng Request, while 2 means an RIPng Response. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| Command | 1 | 命令类型：标识发送的RIPng消息类型。值为1表示RIPng请求，而值为2表示RIPng响应。 |'
- en: '| Version | 1 | Version Number: Set to 1 (not 6, since this is the first version
    of the new protocol RIPng). |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 | 版本号：设置为1（不是6，因为这是新协议RIPng的第一个版本）。 |'
- en: '| Must Be Zero | 2 | Field reserved; value must be set to all zeros. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 必须为零 | 2 | 保留字段；值必须设置为全零。 |'
- en: '| Route Table Entries (RTEs) | Variable | The body of an RIPng message consists
    of a variable number of Route Table Entries (RTEs) that contain information about
    routes. Each entry is 20 bytes long and has the subfields shown in [Table 38-6](ch38s05.html#ripng_rtes
    "Table 38-6. RIPng RTEs"). |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 路由表条目（RTEs） | 可变 | RIPng消息的主体由一个可变数量的路由表条目（RTEs）组成，这些条目包含有关路由的信息。每个条目长度为20字节，并具有[表38-6](ch38s05.html#ripng_rtes
    "表38-6. RIPng RTEs")中显示的子字段。 |'
- en: Table 38-6. RIPng RTEs
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表38-6. RIPng RTEs
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| IPv6 Prefix | 16 | The 128-bit IPv6 address of the network whose information
    is contained in this RTE. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| IPv6前缀 | 16 | 包含在此RTE中的网络信息的128位IPv6地址。 |'
- en: '| Route Tag | 2 | Additional information to be carried with this route, as
    defined in RIP-2. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| Route Tag | 2 | 与此路由一起携带的附加信息，如RIP-2中定义。 |'
- en: '| Prefix Len | 1 | The number of bits of the IPv6 address that is the network
    portion (the remainder being the host portion). This is the number that normally
    would appear after the slash when specifying an IPv6 network address. It is analogous
    to an IPv4 subnet mask. See the description of IPv6 prefix notation in [Chapter 25](ch25.html
    "Chapter 25. IPV6 ADDRESSING") for more details. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 前缀长度 | 1 | IPv6地址中网络部分（其余为主机部分）的位数。这是在指定IPv6网络地址时通常出现在斜杠后面的数字。它类似于IPv4子网掩码。有关IPv6前缀记法的更多详细信息，请参阅[第25章](ch25.html
    "第25章. IPv6寻址")中的描述。 |'
- en: '| Metric | 1 | The distance for the network indicated by the IP address, as
    in RIP-1\. Values of 1 to 15 indicate the number of hops to reach the network
    (as described in the general discussion of the RIP algorithm earlier in this chapter)
    while a value of 16 represents infinity (an unreachable destination). |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| Metric | 1 | 由IP地址指示的网络距离，如RIP-1中所述。值为1到15表示到达网络的路由跳数（如本章前面关于RIP算法的一般讨论中所述），而值为16表示无穷大（不可达的目的地）。
    |'
- en: '![RIPng message format RIPng retains the use of RTEs from RIP-2, but their
    format has been changed to accommodate the much larger IPv6 address size. The
    limit of 25 entries per message has also been eliminated.](httpatomoreillycomsourcenostarchimages288041.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![RIPng消息格式 RIPng保留了RIP-2中RTEs的使用，但它们的格式已更改以适应更大的IPv6地址大小。每条消息的条目限制也已取消。](httpatomoreillycomsourcenostarchimages288041.png)'
- en: Figure 38-7. RIPng message format RIPng retains the use of RTEs from RIP-2,
    but their format has been changed to accommodate the much larger IPv6 address
    size. The limit of 25 entries per message has also been eliminated.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图38-7。RIPng消息格式 RIPng保留了RIP-2中使用的RTEs，但它们的格式已经改变，以适应更大的IPv6地址大小。每条消息的条目限制也已被消除。
- en: The maximum number of RTEs in RIPng is not restricted to 25 as it is in RIP-1
    and RIP-2\. It is limited only by the maximum transmission unit (MTU) of the network
    over which the message is being sent.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: RIPng中的RTE最大数量不受RIP-1和RIP-2中25个的限制。它仅受发送消息的网络最大传输单元（MTU）的限制。
- en: Tip
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** RIPng is the version of RIP that was developed for use on IPv6
    internetworks. It is technically a distinct protocol from RIP-1 and RIP-2, but
    is very similar to both. It retains the enhancements to RIP made in RIP-2, making
    changes to these features and to the RIP message format wherever needed for compatibility
    with IPv6.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** RIPng是为在IPv6互联网上使用而开发的RIP版本。从技术上讲，它与RIP-1和RIP-2是不同的协议，但与两者非常相似。它保留了RIP-2中对RIP所做的增强，并在需要与IPv6兼容的地方对这些特性和RIP消息格式进行了修改。'
- en: When a Next Hop field needs to be specified, a special RTE is included, as I
    mentioned earlier. This RTE is included before all the RTEs to which it applies.
    It has the same basic structure as shown for regular RTEs in [Table 38-6](ch38s05.html#ripng_rtes
    "Table 38-6. RIPng RTEs"), with the IPv6 Prefix subfield containing the next hop
    address, the Route Tag and Prefix Len fields set to 0, and the Metric field set
    to 255 (0xFF).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要指定下一跳字段时，会包含一个特殊的路由条目（RTE），正如我之前提到的。这个RTE包含在所有它适用的RTE之前。它具有与[表38-6](ch38s05.html#ripng_rtes
    "表38-6. RIPng RTEs")中显示的常规RTE相同的基本结构，IPv6前缀子字段包含下一跳地址，路由标记和前缀长度字段设置为0，度量字段设置为255（0xFF）。
- en: Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第39章。开放最短路径优先（OSPF）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Interior routing protocols using a distance-vector routing algorithm, such as
    the Routing Information Protocol (RIP) we explored last chapter, have a long history
    and work well in a small group of routers. However, they also have some serious
    limitations in both scalability and performance that make them poorly suited to
    larger autonomous systems (ASes) or those with specific performance issues. Many
    organizations that start out using RIP quickly find that its restrictions and
    issues make it less than ideal.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用距离矢量路由算法的内部路由协议，例如我们在上一章中探讨的路由信息协议（RIP），有着悠久的历史，在小型路由器组中运行良好。然而，它们在可扩展性和性能方面也存在一些严重的限制，这使得它们不适合较大的自治系统（AS）或具有特定性能问题的系统。许多最初使用RIP的组织很快就会发现自己遇到的限制和问题使其远非理想。
- en: To solve this problem, a new routing protocol was developed in the late 1980s.
    This protocol, called *Open Shortest Path First (OSPF)*, uses the more capable
    (and more complex) link-state or *shortest-path first* routing algorithm. It fixes
    many of the issues with RIP and allows routes to be selected dynamically based
    on the current state of the network, not just a static picture of how routers
    are connected. It also has numerous advanced features, including support for a
    hierarchical topology and automatic load sharing among routes. On the downside,
    it is a complicated protocol, which means it is often not used unless it is really
    needed. This makes it the complement of RIP and is the reason they both have a
    place in the spectrum of TCP/IP routing protocols.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在20世纪80年代末开发了一种新的路由协议。这个协议被称为*开放最短路径优先（OSPF）*，它使用更强大（也更复杂）的链路状态或*最短路径优先*路由算法。它解决了RIP的许多问题，并允许根据网络当前状态动态选择路由，而不仅仅是静态的连接图。它还具有许多高级功能，包括支持分层拓扑和路由之间的自动负载均衡。然而，它是一个复杂的协议，这意味着除非真的需要，否则通常不会使用。这使得它成为RIP的补充，也是它们两者都在TCP/IP路由协议谱系中有位置的原因。
- en: In this chapter, I provide a condensed explanation of the concepts and operation
    behind OSPF. As usual, I begin with an overview of the protocol, discussing how
    it was developed, its versions, and the standards that define them. I describe
    the concepts behind OSPF, including basic topology and the link-state database.
    I then discuss the more complex optional hierarchical topology of routers and
    the roles routers play when this topology is used. I briefly explain the method
    used for determining routes in OSPF, and the general operation and messaging used
    in the protocol, including a description of the five OSPF message types. I conclude
    with descriptions of the formats used for OSPF messages.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提供了对OSPF背后概念和操作的浓缩解释。像往常一样，我首先概述了该协议，讨论了其发展、版本以及定义它们的标准。我描述了OSPF背后的概念，包括基本拓扑和链路状态数据库。然后，我讨论了更复杂的可选分层拓扑以及在此拓扑下路由器扮演的角色。我简要解释了在OSPF中确定路由的方法，以及该协议中使用的通用操作和消息，包括对五种OSPF消息类型的描述。最后，我描述了用于OSPF消息的格式。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The difficult thing about networking is that so many protocols and technologies
    are so involved that each deserves its own book. This is certainly the case with
    OSPF itself, which is sufficiently complex that the RFC defining OSPF version
    2 is more than 240 pages long! Thus, this chapter, despite being fairly comprehensive,
    is only a high-level description of OSPF*.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络技术的难点在于，有如此多的协议和技术如此复杂，每个都值得一本自己的书。OSPF本身就是一个很好的例子，它足够复杂，以至于定义OSPF版本2的RFC文档有超过240页！因此，尽管本章相当全面，但只是对OSPF的高层次描述*。'
- en: OSPF Overview
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSPF概述
- en: 'In the early days of TCP/IP, RIP became the standard protocol for routing within
    an autonomous system (AS), almost by default. RIP had two big things going for
    it: It was simple and easy to use, and it was included in the popular Berkeley
    Standard Distribution (BSD) of UNIX starting in 1982\. Most organizations using
    TCP/IP started out with relatively small networks and were able to use RIP with
    some degree of success.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP/IP的早期，RIP几乎默认成为了自治系统（AS）内部路由的标准协议。RIP有两个很大的优势：它简单易用，并且从1982年开始就被包含在流行的伯克利标准分布（BSD）UNIX中。大多数使用TCP/IP的组织最初使用的是相对较小的网络，并且能够以某种程度成功使用RIP。
- en: However, as I discussed in [Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION
    PROTOCOL (RIP, RIP-2, AND RIPNG)"), that protocol has some serious technical issues,
    and they are exacerbated when RIP is used on a larger AS. Many of RIP's problems
    are due to it being a distance-vector protocol, because the algorithm itself simply
    limits the ability of RIP to choose the best route and adapt to changing network
    conditions. Other problems with RIP were based on its implementation, such as
    the selection of a cost value of 16 for infinity, which makes it impossible to
    use RIP in a situation where more than 15 hops might occur between devices. Problems
    such as the lack of classless addressing support were addressed in version 2 of
    RIP, but the basic difficulties with the protocol as a whole persist.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我在[第38章](ch38.html "第38章. 路由信息协议 (RIP, RIP-2, 和 RIPNG)")中讨论的那样，该协议存在一些严重的技术问题，并且在RIP在较大的自治系统（AS）中使用时这些问题会加剧。RIP的许多问题都源于它是一个距离矢量协议，因为该算法本身仅仅限制了RIP选择最佳路由和适应网络变化的能力。RIP的其他问题基于其实现，例如选择16作为无穷大的成本值，这使得在设备之间可能发生超过15跳的情况下无法使用RIP。RIP版本2解决了诸如不支持无类别寻址等问题，但作为整体协议的基本困难仍然存在。
- en: Development and Standardization of OSPF
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF的发展和标准化
- en: The Internet Engineering Task Force (IETF) recognized that RIP by itself simply
    would not meet the needs of all ASes on the Internet. It formed a working group
    in 1988 to develop a new routing protocol based on the more capable link-state
    algorithm, also called shortest path first (SPF). Research into this type of protocol
    had already begun as early as the 1970s, with some of it conducted on the ARPAnet,
    the predecessor of the Internet, upon which much of TCP/IP was developed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网工程任务组（IETF）认识到，仅凭RIP本身无法满足互联网上所有AS的需求。它在1988年成立了一个工作组，以开发一种基于更强大的链路状态算法的新路由协议，也称为最短路径优先（SPF）。对这类协议的研究早在20世纪70年代就已经开始，其中一些研究是在互联网的前身ARPAnet上进行的，TCP/IP的大部分内容都是在那里开发的。
- en: This new protocol's name conveys two of its most important characteristics.
    The first word refers to the fact that the protocol, like all TCP/IP standards,
    was developed using the open and public RFC process, so it is not proprietary,
    and no license is required to use it. The SPF portion of the name refers to the
    type of algorithm it uses, which is designed to allow routers to dynamically determine
    the shortest path between any two networks.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新协议的名称传达了其两个最重要的特性。第一个词指的是该协议，像所有 TCP/IP 标准，是使用开放和公共的 RFC 流程开发的，因此它不是专有的，并且不需要许可证来使用它。名称中的
    SPF 部分指的是它使用的算法类型，该算法旨在允许路由器动态确定任何两个网络之间的最短路径。
- en: The first version of OSPF was described in RFC 1131, which was published in
    October 1989\. This was quickly replaced by OSPF version 2 in July 1991, which
    is described in RFC 1247\. Since then, there have been several revisions to the
    OSPF version 2 standard, in RFCs 1583, 2178, and 2328, with the last of these
    now the current standard. OSPF version 2 is the only version in use today, so
    it is usually what is meant when people (including myself) refer to OSPF.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF 的第一个版本在 1989 年 10 月发布的 RFC 1131 中进行了描述。这很快被 1991 年 7 月发布的 OSPF 版本 2 所取代，该版本在
    RFC 1247 中进行了描述。从那时起，OSPF 版本 2 标准已经进行了几次修订，包括 RFC 1583、2178 和 2328，其中最后一个是现在的标准。OSPF
    版本 2 是今天使用的唯一版本，因此当人们（包括我自己）提到 OSPF 时，通常是指这个版本。
- en: Overview of OSPF Operation
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 运作概述
- en: The fundamental concept behind OSPF is a data structure called the *link-state
    database (LSDB)*. Each router in an AS maintains a copy of this database, which
    contains information in the form of a directed graph that describes the current
    state of the AS. Each link to a network or another router is represented by an
    entry in the database, and each has an associated cost (or metric). The metric
    can be made to include many different aspects of route performance, not just a
    simple hop count, as is used in RIP.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF 背后的基本概念是一个称为 *链路状态数据库 (LSDB)* 的数据结构。一个自治系统 (AS) 中的每个路由器都维护这个数据库的一个副本，其中包含以有向图形式的信息，描述了
    AS 的当前状态。每个网络或另一个路由器的链路都由数据库中的一个条目表示，并且每个条目都有一个相关的成本（或度量）。度量可以包括许多不同的路由性能方面，而不仅仅是像
    RIP 中使用的简单跳数。
- en: Information about the AS moves around the AS in the form of *link-state advertisements
    (LSAs)*, which are messages that let each router tell the others what it currently
    knows about the state of the AS. Over time, the information that each router has
    about the AS converges with that of the others, and they all have the same data.
    When changes occur to the internetwork, routers send updates to ensure that all
    the routers are kept up-to-date.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 AS 的信息以 *链路状态通告 (LSA)* 的形式在 AS 中传播，这些是让每个路由器告诉其他路由器它目前对 AS 状态了解的消息。随着时间的推移，每个路由器关于
    AS 的信息与其他路由器收敛，并且它们都有相同的数据。当互联网状态发生变化时，路由器发送更新以确保所有路由器都保持最新。
- en: To determine actual routes, each router uses its LSDB to construct a shortest-path
    tree. This tree shows the links from the router to each other router and network
    and allows the lowest-cost route to any location to be determined. As new information
    about the state of the internetwork arrives, this tree can be recalculated, so
    the best route is dynamically adjusted based on network conditions. When more
    than one route with an equal cost exists, traffic can be shared among the routes.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定实际路由，每个路由器使用其 LSDB 构建一个最短路径树。这棵树显示了从路由器到每个其他路由器和网络的链路，并允许确定到任何位置的最低成本路由。当关于互联网状态的新信息到达时，这棵树可以重新计算，因此根据网络条件动态调整最佳路由。当存在多个具有相同成本的路径时，流量可以在这些路径之间共享。
- en: OSPF Features and Drawbacks
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 特点和缺点
- en: In addition to the obvious benefits of the link-state algorithm, OSPF includes
    several other features of value, especially to larger organizations. It supports
    authentication for security and all three major types of IP addressing (classful,
    subnetted classful, and classless). For very large ASes, OSPF also allows routers
    to be grouped and arranged into a hierarchical topology. This allows for better
    organization and improved performance through reduced LSA traffic.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 除了链路状态算法的明显好处之外，OSPF 还包括其他一些有价值的特性，特别是对大型组织来说。它支持用于安全性的身份验证和所有三种主要的 IP 地址类型（类别、子网类别和类别无类）。对于非常大的
    AS，OSPF 还允许将路由器分组并安排成层次拓扑。这有助于更好的组织和通过减少 LSA 流量来提高性能。
- en: Naturally, the superior functionality and many features of OSPF do not come
    without a cost. In this case, the primary cost is that of complexity. Where RIP
    is a simple and easy-to-use protocol, OSPF requires more work and more expertise
    to properly configure and maintain. This means that even though OSPF is widely
    considered better than RIP, technically, it's not for everyone. The obvious role
    for OSPF is as a routing protocol for larger or higher-performance ASes, leaving
    RIP to cover the smaller and simpler internetworks.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，OSPF的优越功能和许多特性并非没有代价。在这种情况下，主要的代价是复杂性。与RIP简单易用相比，OSPF需要更多的工作和专业知识来正确配置和维护。这意味着尽管OSPF通常被认为比RIP更好，但从技术上讲，它并不适合每个人。OSPF的明显角色是作为大型或高性能AS的路由协议，而将RIP留给覆盖较小和较简单的互联网。
- en: Tip
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *Open Shortest Path First (OSPF)* was developed in the late
    1980s to provide a more capable interior routing protocol for larger or more complex
    ASes that were not being served well by RIP. It uses the dynamic shortest path
    first, or link-state, routing algorithm, with each router maintaining a database
    containing information about the state and topology of the internetwork. As changes
    to the internetwork occur, routers send out updated state information, which allows
    each router to dynamically calculate the best route to any network at any point
    in time. OSPF is a complement to RIP in that RIP is simple but limited, whereas
    OSPF is more capable but more complicated.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *开放最短路径优先（OSPF）*是在20世纪80年代末开发的，旨在为那些RIP服务不佳的大型或更复杂的AS提供更强大的内部路由协议。它使用动态最短路径优先或链路状态路由算法，每个路由器维护一个包含关于互联网状态和拓扑信息的数据库。随着互联网的变化，路由器会发送更新的状态信息，这使得每个路由器可以动态地计算出在任何时间点到达任何网络的最佳路由。OSPF是RIP的补充，因为RIP简单但有限，而OSPF功能更强大但更复杂。'
- en: OSPF Basic Topology and the Link-State Database (LSDB)
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSPF基本拓扑和链路状态数据库（LSDB）
- en: OSPF is designed to facilitate routing in both smaller and larger ASes. To this
    end, the protocol supports two topologies. When there is only a small number of
    routers, the entire AS is managed as a single entity. This doesn't have a specific
    name, but I call it *OSPF basic topology* to convey the simple nature of the topology
    and to contrast it with the hierarchical topology you will explore in the next
    section.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF旨在促进较小和较大AS的路由。为此，该协议支持两种拓扑。当只有少量路由器时，整个AS被视为一个单一实体。这没有特定的名称，但我将其称为*OSPF基本拓扑*，以传达拓扑的简单性，并与下一节中将要探索的分层拓扑进行对比。
- en: 'When OSPF basic topology is used, all the routers in the AS function as peers.
    Each router communicates routing information with each other one, and each maintains
    a copy of the key OSPF data structure: the LSDB, which is essentially a computerized
    representation of the topology of the AS. It is the method by which routers see
    the state of the links in the AS—thus the name *link-state database* (and for
    that matter, the name of the entire class of link-state algorithms of which OSPF
    is a part).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用OSPF基本拓扑时，AS中的所有路由器都作为对等体工作。每个路由器与其他每个路由器通信路由信息，并且每个路由器都维护一个关键OSPF数据结构的副本：链路状态数据库（LSDB），这本质上是对AS拓扑的计算机化表示。它是路由器查看AS中链路状态的方法——因此得名*链路状态数据库*（并且就OSPF而言，整个链路状态算法类别的名称，其中OSPF是其中之一）。
- en: The LSDB is a bit hard to visualize, but is best viewed as a set of data that
    is equivalent to a graphical picture that shows the topology of an AS. In such
    a diagram, we typically show routers and networks as nodes, and connections between
    routers and networks as lines that connect them. The OSPF LSDB takes that information
    and puts it into a table to allow a router to maintain a virtual picture of all
    the connections between routers and networks in the AS.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态数据库（LSDB）有点难以可视化，但最好将其视为一组数据，相当于一个图形化图片，展示了AS的拓扑结构。在这样的图中，我们通常将路由器和网络作为节点显示，将路由器与网络之间的连接作为连接它们的线条。OSPF链路状态数据库将那些信息放入表中，以便路由器可以维护AS中所有路由器与网络之间连接的虚拟图像。
- en: The LSDB therefore indicates which routers can directly reach which other routers
    and which networks each router can reach. Furthermore, it stores for each of these
    links a *cost* to reach the network. This cost is an arbitrary metric that can
    be set up based on any criteria important to the administrator. OSPF is not restricted
    to the overly simple hop-count metric used in RIP.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，链路状态数据库（LSDB）指示哪些路由器可以直接到达哪些其他路由器，以及每个路由器可以到达哪些网络。此外，它为这些链接中的每一个存储一个到达网络的*成本*。这个成本是一个任意度量，可以根据管理员认为重要的任何标准设置。OSPF
    不限于在 RIP 中使用的过于简单的跳数度量。
- en: OSPF Basic Topology
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 基本拓扑
- en: 'For example, let''s consider the same AS that you looked at in the examination
    of the RIP route determination algorithm in [Chapter 38](ch38.html "Chapter 38. ROUTING
    INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)"). This internetwork has four individual
    networks, connected as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑你在第 38 章中检查的 RIP 路由确定算法相同的 AS。这个互联网有四个独立网络，如下所示连接：
- en: Router RA connects Network N1 to Network N2.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RA 将网络 N1 连接到网络 N2。
- en: Routers RB and RC connect Network N2 to Network N3.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RB 和 RC 将网络 N2 连接到网络 N3。
- en: Router RD connects Network N3 to Network N4.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RD 将网络 N3 连接到网络 N4。
- en: To make this example more interesting, I added a direct link between Routers
    RB and RC.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更有趣，我在路由器 RB 和 RC 之间添加了一个直接链接。
- en: The resulting AS is shown in [Figure 39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_
    "Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as
    shown in Figure 38-1 in Chapter 38), but with the addition of a link between the
    two Routers RB and RC."). [Table 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb
    "Table 39-1. Sample OSPF Link-State Database (LSDB)") shows what the LSDB for
    this AS might look like.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 AS 如 [图 39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_ "图 39-1.
    示例 OSPF AS 这是你在第 38 章中查看的相同 AS，但增加了路由器 RB 和 RC 之间的链接") 所示。[表 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb
    "表 39-1. 示例 OSPF 链路状态数据库（LSDB)”) 显示了该 AS 的 LSDB 可能看起来是什么样子。
- en: '![Sample OSPF AS This is the same AS that you looked at in RIP (as shown in
    in ), but with the addition of a link between the two Routers RB and RC.](httpatomoreillycomsourcenostarchimages288043.png.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![示例 OSPF AS 这是你在第 38 章中查看的相同 AS，但增加了路由器 RB 和 RC 之间的链接](httpatomoreillycomsourcenostarchimages288043.png.jpg)'
- en: Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as
    shown in [Figure 38-1](ch38s02.html#sample_rip_as_this_is_an_example_of_a_si "Figure 38-1. Sample
    RIP AS This is an example of a simple AS that contains four physical networks
    and four routers.") in [Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION
    PROTOCOL (RIP, RIP-2, AND RIPNG)")), but with the addition of a link between the
    two Routers RB and RC.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 39-1. 示例 OSPF AS 这是你在第 38 章中查看的相同 AS，但增加了路由器 RB 和 RC 之间的链接（如图 38-1 所示）。
- en: Table 39-1. Sample OSPF Link-State Database (LSDB)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-1. 示例 OSPF 链路状态数据库（LSDB）
- en: '| To Router/Network | From Router | From Network |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 到路由器/网络 | 从路由器 | 从网络 |'
- en: '| --- | --- | --- |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   | RA | RB | RC | RD | N1 | N2 | N3 | N4 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|   | RA | RB | RC | RD | N1 | N2 | N3 | N4 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **RA** |   |   |   |   | 0 | 0 |   |   |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| **RA** |   |   |   |   | 0 | 0 |   |   |'
- en: '| **RB** |   |   | • |   |   | 0 | 0 |   |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **RB** |   |   | • |   |   | 0 | 0 |   |'
- en: '| **RC** |   | • |   |   |   | 0 | 0 |   |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **RC** |   | • |   |   |   | 0 | 0 |   |'
- en: '| **RD** |   |   |   |   |   |   | 0 | 0 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **RD** |   |   |   |   |   |   | 0 | 0 |'
- en: '| **N1** | • |   |   |   |   |   |   |   |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| **N1** | • |   |   |   |   |   |   |   |'
- en: '| **N2** | • | • | • |   |   |   |   |   |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **N2** | • | • | • |   |   |   |   |   |'
- en: '| **N3** |   | • | • | • |   |   |   |   |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **N3** |   | • | • | • |   |   |   |   |'
- en: '| **N4** |   |   |   | • |   |   |   |   |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **N4** |   |   |   | • |   |   |   |   |'
- en: In practice, each of the bullets (•) in [Table 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb
    "Table 39-1. Sample OSPF Link-State Database (LSDB)") would be replaced by a metric
    value indicating the cost to send a datagram from the particular router to another
    router or network. Note that the chart is symmetric, because if Router RB can
    reach Router RC, Router RC can reach Router RB. However, the *costs* do not have
    to be symmetric. It is possible for Router RB to have a metric that is higher
    for it to send to Router RC than for Router RC to send to Router RB.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，[表 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb "表 39-1. 样本
    OSPF 链路状态数据库 (LSDB)") 中的每个项目符号（•）将被一个表示从特定路由器发送数据报文到另一个路由器或网络的成本的度量值所取代。请注意，图表是对称的，因为如果路由器
    RB 可以到达路由器 RC，那么路由器 RC 也可以到达路由器 RB。然而，*成本* 不一定是对称的。可能存在路由器 RB 到路由器 RC 的度量值高于路由器
    RC 到路由器 RB 的情况。
- en: Note too that there is no cost to reach a router *from* a network. This ensures
    that only one cost is applied for a router to send to another router over a network.
    The cost is to reach the network from the router. This makes sense, since each
    router is a member of the network on which it is connected.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，从网络 *到达* 路由器没有成本。这确保了路由器在网络上发送到另一个路由器时只应用一个成本。成本是从路由器到达网络。这很有意义，因为每个路由器都是其连接的网络的一个成员。
- en: LSDB Information Storage and Propagation
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LSDB 信息存储和传播
- en: An important thing to remember about the LSDB is that even though each router
    maintains it, the database isn't constructed from the perspective of the individual
    router. A router's LSDB represents the topology of the entire AS, including links
    between routers that may be rather distant from it. So, for example, Router RA
    would keep the entire database in its storage area, including information about
    Router RC and Router RD, to which it does not connect directly.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 LSDB 的重要事项是，尽管每个路由器都维护它，但数据库并不是从单个路由器的视角构建的。一个路由器的 LSDB 代表整个 AS 的拓扑结构，包括与它可能相当遥远的路由器之间的链路。因此，例如，路由器
    RA 会将其存储区域中的整个数据库保持在其存储区域中，包括关于路由器 RC 和路由器 RD 的信息，而它与这些路由器没有直接连接。
- en: Since in the basic topology, all the routers are peers and maintain information
    for the entire AS, in theory, they should have the exact same LSDB contents. When
    a router is first turned on, it may have different LSDB information than its neighbors,
    but this will be corrected through the exchange of update messages containing
    LSAs. Eventually, all routers should converge to the same information. You will
    see how this works in the section about OSPF messaging later in this chapter.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在基本拓扑中，所有路由器都是对等的，并维护整个 AS 的信息，在理论上，它们应该具有完全相同的 LSDB 内容。当路由器首次启动时，它可能与其邻居有不同的
    LSDB 信息，但将通过包含 LSA 的更新消息的交换来纠正这一点。最终，所有路由器都应该收敛到相同的信息。你将在本章后面的关于 OSPF 消息传递的部分中看到这是如何工作的。
- en: OSPF, as an interior routing protocol, is used only within the AS. In most cases,
    the AS will be connected to other ASes through one or more of its routers. The
    routers that connect the AS to other ASes are often called *boundary routers*.
    These devices will use OSPF to communicate within the AS, and an exterior routing
    protocol (typically BGP) to talk to routers outside the AS. The word *boundary*
    in its name refers to the fact that these devices are usually located on the periphery
    of the AS.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF 作为一种内部路由协议，仅在 AS 内部使用。在大多数情况下，AS 将通过其一个或多个路由器连接到其他 AS。连接 AS 到其他 AS 的路由器通常被称为
    *边界路由器*。这些设备将使用 OSPF 在 AS 内部进行通信，并使用外部路由协议（通常是 BGP）与 AS 外部的路由器进行通信。其名称中的 *边界*
    一词指的是这些设备通常位于 AS 的外围。
- en: Tip
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In basic OSPF topology, each of the routers running OSPF is
    considered a peer of the others. Each maintains a *link-state database (LSDB)*
    that contains information about the topology of the entire AS. Each link between
    a router and network or between two routers is represented by an entry in the
    LSDB that indicates the cost to send data over the link. The LSDB is updated regularly
    through the exchange of OSPF *link-state advertisements (LSAs)*.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在基本的 OSPF 拓扑中，运行 OSPF 的每个路由器都被视为其他路由器的对等体。每个路由器维护一个 *链路状态数据库 (LSDB)*，其中包含整个
    AS 的拓扑信息。每个路由器与网络或两个路由器之间的链路都由 LSDB 中的一个条目表示，该条目指示通过链路发送数据的成本。LSDB 通过交换 OSPF *链路状态通告
    (LSA)* 定期更新。'
- en: OSPF Hierarchical Topology
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSPF 分层拓扑
- en: When the number of routers in an AS is relatively small, using the previously
    described basic topology works well. Each router maintains a common picture of
    the network topology in the form of an identical LSDB. The routers communicate
    as peers using LSAs. While changes in the AS may cause a router to temporarily
    have different information than its peers, routine exchanges of data will keep
    all the LSDBs synchronized and up-to-date, and not that much information needs
    to be sent around because the AS is small.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 AS 中的路由器数量相对较少时，使用之前描述的基本拓扑结构效果良好。每个路由器都维护一个网络拓扑的公共视图，形式为一个相同的链路状态数据库（LSDB）。路由器使用链路状态通告（LSA）作为对等体进行通信。尽管
    AS 中的变化可能导致路由器暂时拥有与其对等体不同的信息，但常规的数据交换将保持所有 LSDB 同步并更新，而且由于 AS 较小，不需要发送太多信息。
- en: This simpler topology does scale reasonably well, and it can support many smaller
    and even moderate-sized ASes. However, as the number of routers increases, the
    amount of communication required to update LSDBs increases as well. In a very
    large internetwork with dozens or even hundreds of routers, having all the routers
    be OSPF peers using the basic topology can result in performance degradation.
    This problem occurs due to the amount of routing information that needs to be
    passed around and to the need for each router to maintain a large LSDB containing
    every router and network in the entire AS.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更简单的拓扑结构可以合理地扩展，并且可以支持许多较小的甚至中等规模的 AS。然而，随着路由器数量的增加，更新链路状态数据库（LSDB）所需的通信量也会增加。在一个拥有数十个甚至数百个路由器的非常大的互联网中，使用基本拓扑结构让所有路由器都成为
    OSPF 对等体可能会导致性能下降。这个问题是由于需要传递的巨大路由信息量以及每个路由器都需要维护一个包含整个 AS 中每个路由器和网络的庞大 LSDB 而产生的。
- en: OSPF Areas
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 区域
- en: To provide better support for these larger internetworks, OSPF supports the
    use of a more advanced, hierarchical topology. In this technique, the AS is no
    longer considered a single, flat structure of interconnected routers all of which
    are peers. Instead, a two-level hierarchical topology is constructed. The AS is
    divided into constructs called *areas*, each of which contains a number of contiguous
    routers and networks. These areas are numbered and managed independently by the
    routers within them, so each area is almost as if it were an AS unto itself. The
    areas are interconnected so that routing information can be shared among areas
    across the entire AS.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地支持这些大型互联网，OSPF 支持使用更高级、分层的拓扑结构。在这种技术中，自治系统（AS）不再被视为一个由相互连接的路由器组成的单一、扁平的结构，其中所有路由器都是对等体。相反，构建了一个两级分层拓扑结构。AS
    被划分为称为 *区域* 的结构，每个区域包含一定数量的连续路由器和网络。这些区域被编号，并由其内部的路由器独立管理，因此每个区域几乎就像是一个独立的 AS。这些区域通过相互连接，以便在整个
    AS 中共享区域间的路由信息。
- en: The easiest way to understand this hierarchical topology is to consider each
    area like a sub-AS within the AS as a whole. The routers within any area maintain
    an LSDB that contains information about the routers and networks within that area.
    Routers within more than one area maintain LSDBs about each area that they are
    a part of, and they also link the areas together to share routing information
    between them.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种分层拓扑的最简单方法是将每个区域视为 AS 整体中的子 AS。任何区域内的路由器维护一个包含该区域内部路由器和网络信息的 LSDB。位于多个区域内的路由器维护关于它们所属的每个区域的
    LSDB，并且它们还连接这些区域以在它们之间共享路由信息。
- en: Tip
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To allow for better control and management over larger internetworks,
    OSPF allows a large AS to be structured into a hierarchical form. Contiguous routers
    and networks are grouped into areas that connect together using a logical backbone.
    These areas act as the equivalent of smaller ASes within the larger AS, yielding
    the same benefits of localized control and traffic management that ASes provide
    for a large internetwork between organizations.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了更好地控制和管理大型互联网，OSPF 允许将大型 AS 结构化为分层形式。连续的路由器和网络被分组到区域中，这些区域通过逻辑骨干连接在一起。这些区域在较大的
    AS 中充当较小 AS 的等效体，从而提供与 AS 为大型组织间互联网提供本地化控制和流量管理相同的益处。'
- en: Router Roles in OSPF Hierarchical Topology
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 分层拓扑中的路由器角色
- en: 'The topology just described is hierarchical because the routers in the AS are
    no longer all peers in a single group. The two-level hierarchy consists of the
    lower level, which contains individual areas, and the higher level that connects
    them together, which is called the *backbone* and is designated as Area 0\. The
    routers play different roles, depending on where they are located and how they
    are connected. There are three different labels applied to routers in this configuration:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的拓扑结构是分层的，因为 AS 中的路由器不再是单个组中的所有对等体。两级层次结构包括包含单个区域的较低级别，以及将它们连接在一起的高级别，这被称为*骨干*，并指定为
    Area 0。路由器根据它们的位置和连接方式扮演不同的角色。在此配置中，对路由器应用了三个不同的标签：
- en: '**Internal Routers** These are routers that are connected only to other routers
    or networks within a single area. They maintain an LSDB for only that area and
    have no knowledge of the topology of other areas.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部路由器** 这些是只连接到单个区域内的其他路由器或网络的路由器。它们只为该区域维护一个 LSDB，并且不知道其他区域的拓扑结构。'
- en: '**Area Border Routers** These are routers that connect to routers or networks
    in more than one area. They maintain an LSDB for each area of which they are a
    part. They also participate in the backbone.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**区域边界路由器** 这些是连接到多个区域内的路由器或网络的路由器。它们为它们所参与的每个区域维护一个 LSDB。它们还参与骨干。'
- en: '**Backbone Routers** These are routers that are a part of the OSPF backbone.
    By definition, these include all area border routers, since those routers pass
    routing information between areas. However, a backbone router may also be a router
    that connects only to other backbone (or area border) routers and is therefore
    not part of any area (other than Area 0).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**骨干路由器** 这些是 OSPF 骨干的一部分。根据定义，这些包括所有区域边界路由器，因为那些路由器在区域之间传递路由信息。然而，骨干路由器也可能是一个只连接到其他骨干（或区域边界）路由器的路由器，因此它不属于任何区域（除了
    Area 0）。'
- en: To summarize, an *area border router* is also always a *backbone router*, but
    a backbone router is not necessarily an area border router.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，*区域边界路由器*也总是*骨干路由器*，但骨干路由器不一定是区域边界路由器。
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The classifications that I just mentioned are independent of the designation
    of a router as being a* boundary router, *as described in the previous section.
    A boundary router is one that talks to routers or networks outside the AS. A boundary
    router will also often be an area border router or a backbone router, but this
    is not necessarily the case. A boundary router could be an internal router in
    one area*.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*我刚才提到的分类与将路由器指定为上一节中描述的*边界路由器*的指定无关。边界路由器是那些与 AS 外部的路由器或网络通信的路由器。边界路由器也经常是区域边界路由器或骨干路由器，但这并不一定。边界路由器可能是一个区域内的内部路由器*。'
- en: The point of all this is the same as the point of using AS architecture in the
    first place. The topology of each area matters only to the devices in that area.
    This means that changes in that topology need to be propagated only within the
    area. It also means that internal routers within Area 1 don't need to know about
    anything that goes on within Area 2 and don't need to maintain information about
    any area other than their own. Only the backbone routers (which include at least
    one area border router within each area) need to know the details of the entire
    AS. These backbone routers condense information about the areas so that only a
    summary of each area's topology needs to be advertised on the backbone.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的目的与最初使用 AS 架构的目的相同。每个区域的拓扑结构只对那个区域内的设备有意义。这意味着该拓扑结构的变化只需要在该区域内传播。这也意味着
    Area 1 内部的内部路由器不需要了解 Area 2 内部发生的事情，也不需要维护关于任何其他区域的信息。只有骨干路由器（每个区域至少包含一个区域边界路由器）需要了解整个
    AS 的详细信息。这些骨干路由器将区域的信息压缩，以便只在骨干上发布每个区域拓扑的摘要。
- en: 'Routing in a hierarchical topology AS is performed in one of two ways, depending
    on the location of the devices:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在分层拓扑结构的 AS 中执行路由的方式有两种，这取决于设备的位置：
- en: If the source and destination are in the same area, routing occurs only over
    networks and routers in that area.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果源和目的地在同一区域，则路由仅在該区域的网络和路由器上发生。
- en: If the source and destination are in different areas, the datagram is routed
    from the source to an area border router in the source's area, over the backbone
    to an area border router in the destination's area, and then finally delivered
    to the destination.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果源和目标在不同的区域，数据报将从源区域的路由器边界路由器路由，经过骨干到目标区域的路由器边界路由器，然后最终交付给目标。
- en: Again, this is analogous to how routing works between ASes in the big-picture
    internetwork.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与在大图景互联网中AS之间的路由工作方式类似。
- en: 'Let''s take an example to help make things more concrete. We can use the AS
    in the preceding example. This AS is really small enough that it''s unlikely we
    would use hierarchical topology, but it will suffice for sake of illustration.
    Let''s divide this AS into two areas, as follows (see [Figure 39-2](ch39s03.html#sample_ospf_hierarchical_topology_as_thi
    "Figure 39-2. Sample OSPF hierarchical topology AS This is the same AS you saw
    in Figure 39-1, but it''s arranged into OSPF hierarchical topology. The AS has
    been split evenly into Area 1 and Area 2\. Area 0 contains Routers RB and RC,
    which are area border routers for both Area 1 and Area 2 in this very simple example.")):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来帮助使事情更加具体。我们可以使用前面例子中的AS。这个AS足够小，以至于我们不太可能使用分层拓扑，但为了说明目的，它还是足够的。让我们将这个AS分为两个区域，如下（参见[图39-2](ch39s03.html#sample_ospf_hierarchical_topology_as_thi
    "图39-2. 示例OSPF分层拓扑AS 这是在图39-1中看到的相同的AS，但它被组织成OSPF分层拓扑。AS已经被均匀地分为区域1和区域2。区域0包含路由器RB和RC，它们是本例中区域1和区域2的区域边界路由器。")）：
- en: Area 1 contains Network N1, Router RA, Network N2, Router RB, and Router RC.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域1包含网络N1、路由器RA、网络N2、路由器RB和路由器RC。
- en: Area 2 contains Router RB, Router RC, Network N3, Router RD, and Network N4.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域2包含路由器RB、路由器RC、网络N3、路由器RD和网络N4。
- en: '![Sample OSPF hierarchical topology AS This is the same AS you saw in , but
    it''s arranged into OSPF hierarchical topology. The AS has been split evenly into
    Area 1 and Area 2\. Area 0 contains Routers RB and RC, which are area border routers
    for both Area 1 and Area 2 in this very simple example.](httpatomoreillycomsourcenostarchimages288045.png.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![示例OSPF分层拓扑AS 这是你在中看到的相同的AS，但它被组织成OSPF分层拓扑。AS已经被均匀地分为区域1和区域2。区域0包含路由器RB和RC，它们是本例中区域1和区域2的区域边界路由器。](httpatomoreillycomsourcenostarchimages288045.png.jpg)'
- en: Figure 39-2. Sample OSPF hierarchical topology AS This is the same AS you saw
    in [Figure 39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_ "Figure 39-1. Sample
    OSPF AS This is the same AS that you looked at in RIP (as shown in Figure 38-1
    in Chapter 38), but with the addition of a link between the two Routers RB and
    RC."), but it's arranged into OSPF hierarchical topology. The AS has been split
    evenly into Area 1 and Area 2\. Area 0 contains Routers RB and RC, which are area
    border routers for both Area 1 and Area 2 in this very simple example.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图39-2. 示例OSPF分层拓扑AS 这是你在[图39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_
    "图39-1. 示例OSPF AS 这是你在RIP中看到的相同的AS，如第38章中的图38-1所示)，但它被组织成OSPF分层拓扑。AS已经被均匀地分为区域1和区域2。区域0包含路由器RB和RC，它们是本例中区域1和区域2的区域边界路由器。")
- en: In this example, Router RA and Router RD are internal routers. Router RB and
    Router RC are area border routers that make up the backbone (Area 0) of the internetwork.
    Routers RA, RB, and RC will maintain an LSDB describing Area 1, while Routers
    RB, RC, and RD will maintain an LSDB describing Area 2\. Routers RB and RC maintain
    a separate LSDB for the backbone. There is no backbone router other than the area
    border routers RB and RC. However, suppose we had a Router RE that had only direct
    connections to Routers RB and RC. This would be a backbone router only.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，路由器RA和路由器RD是内部路由器。路由器RB和RC是构成互联网骨干（区域0）的区域边界路由器。RA、RB和RC路由器将维护描述区域1的LSDB，而RB、RC和RD路由器将维护描述区域2的LSDB。RB和RC路由器维护一个独立的LSDB用于骨干。除了区域边界路由器RB和RC之外，没有其他骨干路由器。然而，假设我们有一个只有直接连接到路由器RB和RC的路由器RE。这将是一个仅作为骨干的路由器。
- en: 'This example has illustrated the chief drawback to hierarchical topology mentioned
    earlier in this chapter: complexity. For large ASes, however, it has significant
    advantages over making every router a peer. At the same time, the conceptual complexity
    is made worse by the need for very careful design, especially of the backbone.
    If the hierarchy is not set up properly, a single failure of a link between routers
    could disrupt the backbone and isolate one or more of the areas (including all
    the devices on all networks within the area!).'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了本章前面提到的分层拓扑的主要缺点：复杂性。然而，对于大型AS来说，与将每个路由器都视为对等体相比，它具有显著的优势。同时，由于需要非常仔细的设计，特别是骨干的设计，概念复杂性变得更糟。如果层次结构设置不当，路由器之间链路的单个故障可能会破坏骨干并隔离一个或多个区域（包括该区域内所有网络上的所有设备！）。
- en: OSPF Route Determination Using SPF Trees
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPF树进行OSPF路由确定
- en: The key data structure maintained by each router in an OSPF AS is the LSDB,
    which contains a representation of the topology of either the entire AS (in the
    basic topology) or a single area (in the hierarchical topology). As you have seen,
    each router in the AS or area has the same LSDB, so it represents a neutral view
    of the connections between routers and networks.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 每个OSPF AS中的路由器维护的关键数据结构是LSDB，它包含整个AS（在基本拓扑中）或单个区域（在分层拓扑中）的拓扑表示。正如你所看到的，AS或区域中的每个路由器都有相同的LSDB，因此它代表了路由器与网络之间连接的中立视图。
- en: The SPF Tree
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPF树
- en: Each router needs to participate in keeping the LSDB up-to-date, but it also
    has its own concerns. It needs to be able to determine what routes it should use
    for datagrams it receives from its connected networks—this is, after all, the
    entire point of a routing protocol. To find the best route, it must determine
    the shortest path between itself and each router or network in the AS or area.
    For this, it needs not a neutral view of the internetwork but a view of it from
    its own perspective.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由器需要参与保持LSDB更新，但它也有自己的关注点。它需要能够确定它应该使用哪些路由来处理从其连接的网络接收到的数据报——毕竟，这就是路由协议的全部目的。为了找到最佳路由，它必须确定自己与AS或区域中每个路由器或网络之间的最短路径。为此，它需要的不是对互联网的中立视图，而是从其自身视角的视图。
- en: The router creates this perspective by taking the information in the LSDB and
    transforming it into an *SPF tree*. The term *tree* refers to a data structure
    with a root that has branches coming out that go to other nodes, which also have
    branches. The structure as a whole looks like an upside-down tree. In this case,
    the SPF tree shows the topology information of the AS or area with the router
    that constructs the tree at the top. Each directly connected router or network
    is one step down in the tree; each router or network connected to these first-level
    routers or networks is then connected, and so on, until the entire AS or area
    has been represented.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器通过将LSDB中的信息转换为**SPF树**来创建这种视角。术语**树**指的是一个具有根节点，从根节点延伸出分支指向其他节点，这些节点也有分支的数据结构。整体结构看起来像一棵倒置的树。在这种情况下，SPF树显示了AS或区域的拓扑信息，其中构建树的路由器位于顶部。每个直接连接的路由器或网络在树中向下一步；然后连接到这些第一级路由器或网络的每个路由器或网络，依此类推，直到整个AS或区域都被表示。
- en: Again, the router doesn't really *make* the tree; it is just an algorithmic
    calculation performed by the computer within the router. Once this is done, however,
    this logical construct can be used to calculate the cost for that router to reach
    any router or network in the AS (or area). In some cases, there may be more than
    one way to reach a router or network, so the tree is constructed to show only
    the shortest (lowest-cost) path to the network.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，路由器并不真正**制造**树；它只是路由器内部计算机执行的一种算法计算。然而，一旦完成这个计算，这个逻辑结构就可以用来计算该路由器到达AS（或区域）中任何路由器或网络的成本。在某些情况下，到达路由器或网络可能有多种方式，因此树被构建来显示到达网络的唯一最短（最低成本）路径。
- en: Each router is responsible only for sending a datagram on the next leg of its
    journey, and not for what happens to the journey as a whole. After the SPF tree
    is created, the router will create a routing table with an entry for each network,
    showing the cost to reach it, and also the next-hop router to use to reach it.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由器只负责在其旅程的下一阶段发送数据报，而不负责整个旅程的任何情况。一旦创建了SPF树，路由器将创建一个路由表，其中包含每个网络的条目，显示到达该网络的成本，以及用于到达该网络的下一条路由器。
- en: The SPF tree is created dynamically based on the current state of the LSDB.
    If the LSDB ever changes, the SPF tree and the routing information are recalculated.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: SPF树是根据LSDB的当前状态动态创建的。如果LSDB发生变化，则重新计算SPF树和路由信息。
- en: Tip
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To determine what routes it should use to reach networks in
    its AS, a router generates a *shortest-path first tree (SPF tree)* from its LSDB.
    This tree contains the same basic information as the LSDB, but presents it from
    the point of view of the router doing the calculation, so that router can see
    the costs of various paths to different networks.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 要确定它应该使用哪些路由来到达其AS中的网络，路由器从其LSDB生成一个 *最短路径优先树（SPF树）*。此树包含与LSDB相同的基本信息，但以进行计算的路由器的视角呈现，这样路由器就可以看到到达不同网络的各个路径的成本。'
- en: OSPF Route Determination
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF路由确定
- en: I can almost see your eyes glazing over, so let's go back to the example we
    have been using in this chapter. Let's assume that we are looking at the AS as
    a whole in basic topology, for simplicity. [Table 39-2](ch39s04.html#sample_ospf_lsdb_with_costs
    "Table 39-2. Sample OSPF LSDB with Costs") repeats the LSDB for this AS shown
    earlier in [Table 39-1](ch39s02.html#sample_ospf_link-state_database_lsdb "Table 39-1. Sample
    OSPF Link-State Database (LSDB)"), but I have taken the liberty of replacing the
    bullets with cost metrics; these are shown in [Figure 39-3](ch39s04.html#sample_ospf_as_with_costs_this_is_the_sa
    "Figure 39-3. Sample OSPF AS with Costs This is the same sample AS that is shown
    in Figure 39-1, but with costs assigned to each of the links between routers and
    networks. Costs between routers and networks are applied only in the direction
    from the router to the network.") as well. Again, remember that there is no cost
    to reach a router from a network, so those links have a nonzero cost only going
    from the router to the network.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎能看到你的眼睛开始发直，所以我们回到本章中一直在使用的例子。为了简单起见，我们假设我们正在查看基本拓扑中的整个AS。[表39-2](ch39s04.html#sample_ospf_lsdb_with_costs
    "表39-2. 带成本的样本OSPF LSDB")重复了之前在[表39-1](ch39s02.html#sample_ospf_link-state_database_lsdb
    "表39-1. 样本OSPF链路状态数据库（LSDB）")中显示的此AS的LSDB，但我已经自由地将项目符号替换为成本度量；这些在[图39-3](ch39s04.html#sample_ospf_as_with_costs_this_is_the_sa
    "图39-3. 带成本的样本OSPF AS 这是图39-1中显示的相同样本AS，但为路由器和网络之间的每个连接分配了成本。路由器和网络之间的成本仅在从路由器到网络的方向上应用。")中也有显示。再次提醒，从网络到达路由器没有成本，所以这些链接只有从路由器到网络的方向才有非零成本。
- en: Table 39-2. Sample OSPF LSDB with Costs
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 表39-2. 带成本的样本OSPF LSDB
- en: '| To Router/Network | From Router | From Network |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 到路由器/网络 | 从路由器 | 从网络 |'
- en: '| --- | --- | --- |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '|   | RA | RB | RC | RD | N1 | N2 | N3 | N4 |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|   | RA | RB | RC | RD | N1 | N2 | N3 | N4 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **RA** |   |   |   |   | 0 | 0 |   |   |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| **RA** |   |   |   |   | 0 | 0 |   |   |'
- en: '| **RB** |   |   | 5 |   |   | 0 | 0 |   |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| **RB** |   |   | 5 |   |   | 0 | 0 |   |'
- en: '| **RC** |   | 5 |   |   |   | 0 | 0 |   |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| **RC** |   | 5 |   |   |   | 0 | 0 |   |'
- en: '| **RD** |   |   |   |   |   |   | 0 | 0 |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| **RD** |   | --- | --- | --- | --- | --- | 0 | 0 |'
- en: '| **N1** | 2 |   |   |   |   |   |   |   |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| **N1** | 2 |   |   |   |   |   |   |   |'
- en: '| **N2** | 3 | 4 | 3 |   |   |   |   |   |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| **N2** | 3 | 4 | 3 |   |   |   |   |   |'
- en: '| **N3** |   | 5 | 6 | 1 |   |   |   |   |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| **N3** |   | 5 | 6 | 1 |   |   |   |   |'
- en: '| **N4** |   |   |   | 4 |   |   |   |   |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| **N4** |   |   |   | 4 |   |   |   |   |'
- en: '![Sample OSPF AS with Costs This is the same sample AS that is shown in , but
    with costs assigned to each of the links between routers and networks. Costs between
    routers and networks are applied only in the direction from the router to the
    network.](httpatomoreillycomsourcenostarchimages288047.png.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![带成本的样本OSPF AS 这是图39-1中显示的相同样本AS，但为路由器和网络之间的每个连接分配了成本。路由器和网络之间的成本仅在从路由器到网络的方向上应用。](httpatomoreillycomsourcenostarchimages288047.png.jpg)'
- en: Figure 39-3. Sample OSPF AS with Costs This is the same sample AS that is shown
    in [Figure 39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_ "Figure 39-1. Sample
    OSPF AS This is the same AS that you looked at in RIP (as shown in Figure 38-1
    in Chapter 38), but with the addition of a link between the two Routers RB and
    RC."), but with costs assigned to each of the links between routers and networks.
    Costs between routers and networks are applied only in the direction from the
    router to the network.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图39-3. 带成本的样本OSPF AS 这与[图39-1](ch39s02.html#sample_ospf_as_this_is_the_same_as_that_
    "图39-1. 样本OSPF AS 这是你在RIP中看到的相同AS（如第38章中的图38-1所示），但增加了两个路由器RB和RC之间的连接。"),是相同的样本AS，但为路由器和网络之间的每个连接分配了成本。路由器和网络之间的成本仅在从路由器到网络的方向上应用。
- en: Now let's construct the SPF tree for RC. We can do this in iterations, as follows
    (see [Figure 39-4](ch39s04.html#ospf_route_determination_using_the_spf_a "Figure 39-4. OSPF
    route determination using the SPF algorithm This diagram shows graphically how
    a router, in this case Router RC, determines the best path to various networks.
    The arrows here represent not the transfer of data, but rather the examination
    of various links from a router to other routers or networks. In panel 1, Router
    RC examines its LSDB and determines the cost for each of its directly linked devices.
    In panel 2, the second level of the SPF tree is constructed by adding to those
    numbers the costs of all routers/networks that connect to the routers/networks
    found in panel 1\. (The black arrows represent looking back in the direction we
    came from in the prior step, which we don't pursue.) In panel 3 the process continues,
    resulting in the determination of a cost of 5 for Router RC to reach Network N1
    and 10 to reach Network N4.")).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建RC的SPF树。我们可以通过迭代来完成，如下所示（参见[图39-4](ch39s04.html#ospf_route_determination_using_the_spf_a
    "图39-4. 使用SPF算法确定OSPF路由 此图图形化地展示了路由器（在本例中为路由器RC）如何确定到达各种网络的最佳路径。这里的箭头表示的不是数据的传输，而是从路由器到其他路由器或网络的链路检查。在面板1中，路由器RC检查其链路状态数据库（LSDB），并确定其直接连接的每个设备的成本。在面板2中，通过将这些数字与面板1中找到的路由器/网络连接的所有路由器/网络的成本相加，构建了SPF树的第二级。（黑色箭头表示在先前步骤中返回的方向，我们不继续追踪。）在面板3中，过程继续进行，最终确定路由器RC到达网络N1的成本为5，到达网络N4的成本为10。")）。
- en: '![OSPF route determination using the SPF algorithm This diagram shows graphically
    how a router, in this case Router RC, determines the best path to various networks.
    The arrows here represent not the transfer of data, but rather the examination
    of various links from a router to other routers or networks. In panel 1, Router
    RC examines its LSDB and determines the cost for each of its directly linked devices.
    In panel 2, the second level of the SPF tree is constructed by adding to those
    numbers the costs of all routers/networks that connect to the routers/networks
    found in panel 1\. (The black arrows represent looking back in the direction we
    came from in the prior step, which we don''t pursue.) In panel 3 the process continues,
    resulting in the determination of a cost of 5 for Router RC to reach Network N1
    and 10 to reach Network N4.](httpatomoreillycomsourcenostarchimages288049.png.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![使用SPF算法确定OSPF路由 此图图形化地展示了路由器（在本例中为路由器RC）如何确定到达各种网络的最佳路径。这里的箭头表示的不是数据的传输，而是从路由器到其他路由器或网络的链路检查。在面板1中，路由器RC检查其链路状态数据库（LSDB），并确定其直接连接的每个设备的成本。在面板2中，通过将这些数字与面板1中找到的路由器/网络连接的所有路由器/网络的成本相加，构建了SPF树的第二级。（黑色箭头表示在先前步骤中返回的方向，我们不继续追踪。）在面板3中，过程继续进行，最终确定路由器RC到达网络N1的成本为5，到达网络N4的成本为10。](httpatomoreillycomsourcenostarchimages288049.png.jpg)'
- en: Figure 39-4. OSPF route determination using the SPF algorithm This diagram shows
    graphically how a router, in this case Router RC, determines the best path to
    various networks. The arrows here represent not the transfer of data, but rather
    the examination of various links from a router to other routers or networks. In
    panel 1, Router RC examines its LSDB and determines the cost for each of its directly
    linked devices. In panel 2, the second level of the SPF tree is constructed by
    adding to those numbers the costs of all routers/networks that connect to the
    routers/networks found in panel 1\. (The black arrows represent looking back in
    the direction we came from in the prior step, which we don't pursue.) In panel
    3 the process continues, resulting in the determination of a cost of 5 for Router
    RC to reach Network N1 and 10 to reach Network N4.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图39-4. 使用SPF算法确定OSPF路由 此图图形化地展示了路由器（在本例中为路由器RC）如何确定到达各种网络的最佳路径。这里的箭头表示的不是数据的传输，而是从路由器到其他路由器或网络的链路检查。在面板1中，路由器RC检查其链路状态数据库（LSDB），并确定其直接连接的每个设备的成本。在面板2中，通过将这些数字与面板1中找到的路由器/网络连接的所有路由器/网络的成本相加，构建了SPF树的第二级。（黑色箭头表示在先前步骤中返回的方向，我们不继续追踪。）在面板3中，过程继续进行，最终确定路由器RC到达网络N1的成本为5，到达网络N4的成本为10。
- en: First Level
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一级
- en: 'To construct the first level of the tree, we look for all devices that Router
    RC can reach directly. We find the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建树的第一个级别，我们寻找所有路由器RC可以直接到达的设备。我们找到了以下设备：
- en: Router RB, with a cost of 5
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器RB，成本为5
- en: Network N2, with a cost of 3
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络N2，成本为3
- en: Network N3, with a cost of 6
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络N3，成本为6
- en: Second Level
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二级
- en: To construct the second level, we look for all devices that the devices on the
    first level can reach directly. We then add the cost to reach each device on the
    first level to the cost of each device at the second level.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建第二级，我们寻找第一级可以直接到达的所有设备。然后我们将到达第一级每个设备的成本加到第二级每个设备的成本上。
- en: '**RB**: Router RB has a cost of 5 and can reach the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**RB**: 路由器 RB 的成本为 5，可以到达以下：'
- en: Router RC, with a cost of 5, total cost of 10
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RC，成本为 5，总成本为 10
- en: Network N2, with a cost of 4, total cost of 9
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络 N2，成本为 4，总成本为 9
- en: Network N3, with a cost of 5, total cost of 10
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络 N3，成本为 5，总成本为 10
- en: '**N2**: Network N2 has a cost of 3 and can reach the following:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**N2**: 网络 N2 的成本为 3，可以到达以下：'
- en: Router RA, with a cost of 0, total cost of 3
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RA，成本为 0，总成本为 3
- en: Router RB, with a cost of 0, total cost of 3
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RB，成本为 0，总成本为 3
- en: Router RC, with a cost of 0, total cost of 3
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RC，成本为 0，总成本为 3
- en: '**N3**: Network N3 has a cost of 6 and can reach the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**N3**: 网络 N3 的成本为 6，可以到达以下：'
- en: Router RB, with a cost of 0, total cost of 6
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RB，成本为 0，总成本为 6
- en: Router RC, with a cost of 0, total cost of 6
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RC，成本为 0，总成本为 6
- en: Router RD, with a cost of 0, total cost of 6
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器 RD，成本为 0，总成本为 6
- en: 'You probably can see immediately that we ended up with a number of different
    paths to the same devices or networks, some of which make no sense. For example,
    we don''t really care about any path that goes to Router RC, since we *are* Router
    RC! Similarly, we can weed out certain paths immediately because we already have
    a shorter path to them. Taking a path through Router RB to Network N3 with a cost
    of 10 makes no sense when we can go directly at the first level for a cost of
    6\. So, after separating out the chaff, we end up with the following wheat at
    the second level:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能立即就能看出，我们最终得到了到达相同设备或网络的不同路径的数量，其中一些路径没有意义。例如，我们并不关心任何通往路由器 RC 的路径，因为我们就是路由器
    RC！同样，我们可以立即排除某些路径，因为我们已经找到了到达它们的更短路径。当我们可以在第一级直接以 6 的成本到达时，通过路由器 RB 到网络 N3 的路径成本为
    10 是没有意义的。因此，在分离出杂质后，我们在第二级得到了以下谷物：
- en: Network N2 to Router RA, with a cost of 3
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络 N2 到路由器 RA，成本为 3
- en: Network N3 to Router RD, with a cost of 6
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络 N3 到路由器 RD，成本为 6
- en: Third Level
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三级
- en: 'We continue the process by looking for devices that connect to the weeded-out
    devices that we found on the second level (this time I am only showing the meaningful
    ones):'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过寻找连接到我们在第二级找到的已筛选设备（这次我只显示有意义的设备）来继续这个过程：
- en: '**RA**: Router RA connects to Network N1, with a cost of 2, total cost of 5.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**RA**: 路由器 RA 连接到网络 N1，成本为 2，总成本为 5。'
- en: '**RD**: Router RD connects to Network N4, with a cost of 4, total cost of 10.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**RD**: 路由器 RD 连接到网络 N4，成本为 4，总成本为 10。'
- en: In this simple example, we only need three levels to construct the tree for
    Router RC. (We would need more for Router RA or RD.) The final results would be
    the tree shown in [Figure 39-5](ch39s04.html#ospf_calculated_spf_tree_this_is_a_graph
    "Figure 39-5. OSPF calculated SPF tree This is a graphical representation of the
    SPF tree calculated in Figure 39-4, showing only the final results of the calculation
    process.") and the routing information for RC to the four networks that is shown
    in [Table 39-3](ch39s04.html#example_of_calculated_ospf_routes "Table 39-3. Example
    of Calculated OSPF Routes").
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们只需要三个级别来构建路由器 RC 的树。（对于路由器 RA 或 RD，我们可能需要更多级别。）最终结果将是[图 39-5](ch39s04.html#ospf_calculated_spf_tree_this_is_a_graph
    "图 39-5. OSPF 计算的 SPF 树 这是图 39-4 中计算的 SPF 树的图形表示，仅显示计算过程的最终结果")中显示的树，以及 RC 到四个网络的路由信息，如[表
    39-3](ch39s04.html#example_of_calculated_ospf_routes "表 39-3. 计算的 OSPF 路由示例")所示。
- en: '![OSPF calculated SPF tree This is a graphical representation of the SPF tree
    calculated in , showing only the final results of the calculation process.](httpatomoreillycomsourcenostarchimages288051.png.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF 计算的 SPF 树 这是图 中的 SPF 树的图形表示，仅显示计算过程的最终结果](httpatomoreillycomsourcenostarchimages288051.png.jpg)'
- en: Figure 39-5. OSPF calculated SPF tree This is a graphical representation of
    the SPF tree calculated in [Figure 39-4](ch39s04.html#ospf_route_determination_using_the_spf_a
    "Figure 39-4. OSPF route determination using the SPF algorithm This diagram shows
    graphically how a router, in this case Router RC, determines the best path to
    various networks. The arrows here represent not the transfer of data, but rather
    the examination of various links from a router to other routers or networks. In
    panel 1, Router RC examines its LSDB and determines the cost for each of its directly
    linked devices. In panel 2, the second level of the SPF tree is constructed by
    adding to those numbers the costs of all routers/networks that connect to the
    routers/networks found in panel 1\. (The black arrows represent looking back in
    the direction we came from in the prior step, which we don't pursue.) In panel
    3 the process continues, resulting in the determination of a cost of 5 for Router
    RC to reach Network N1 and 10 to reach Network N4."), showing only the final results
    of the calculation process.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图 39-5. OSPF 计算的 SPF 树 这是对 [图 39-4](ch39s04.html#ospf_route_determination_using_the_spf_a
    "图 39-4. 使用 SPF 算法确定 OSPF 路由 This 图表直观地显示了路由器（本例中为路由器 RC）如何确定到达各种网络的最佳路径。这里的箭头表示的不是数据的传输，而是从路由器到其他路由器或网络的链接的检查。在面板
    1 中，路由器 RC 检查其 LSDB 并确定其直接连接的每个设备的成本。在面板 2 中，通过向这些数字添加连接到面板 1 中找到的路由器/网络的所有路由器/网络的成本，构建
    SPF 树的第二层。（黑色箭头表示在先前的步骤中返回的方向，我们不继续追踪。）在面板 3 中，过程继续，最终确定路由器 RC 到网络 N1 的成本为 5，到网络
    N4 的成本为 10。"），仅显示计算过程的最终结果。
- en: Table 39-3. Example of Calculated OSPF Routes
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-3. 计算的 OSPF 路由示例
- en: '| Destination Network | Cost | Next Hop |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 目的网络 | 成本 | 下一个跳转 |'
- en: '| --- | --- | --- |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **N1** | 5 | RA |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| **N1** | 5 | RA |'
- en: '| **N2** | 3 | (local) |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| **N2** | 3 | (本地) |'
- en: '| **N3** | 6 | (local) |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| **N3** | 6 | (本地) |'
- en: '| **N4** | 10 | RD |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| **N4** | 10 | RD |'
- en: This is what you would expect in this very simple example. Note that there are
    no specific entries for other routers, since they are the means to the end of
    reaching networks. However, if one of the other routers were a boundary router
    that connected the AS to the outside world, there would be entries for the networks
    to which the boundary router connected, so Router RC knew to send traffic for
    those networks to that boundary router.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的例子中，这正是你所期望的。请注意，没有为其他路由器指定特定的条目，因为它们是到达网络的手段。然而，如果其他路由器是连接 AS 和外部世界的边界路由器，那么将会有连接到这些网络的条目，这样路由器
    RC 就知道将那些网络的流量发送到该边界路由器。
- en: OSPF General Operation
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSPF 通用操作
- en: As a routing protocol, the main job of OSPF is to facilitate the exchange of
    routing information between routers. Each router in an OSPF AS that runs OSPF
    software is responsible for various tasks, such as setting timers to control certain
    activities that must occur on a regular basis, and the maintenance of important
    data structures, such as the LSDB. Most important, each OSPF router must both
    generate and respond to OSPF messages. It is this messaging system that allows
    important routing information to be shared within an AS or area, which makes it
    crucial to understanding how OSPF works. So it's worth starting a discussion of
    OSPF operation by taking a look at the message types and how they are used.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种路由协议，OSPF 的主要任务是促进路由器之间路由信息的交换。在一个运行 OSPF 软件的 OSPF AS 中，每个路由器都负责各种任务，例如设置计时器来控制必须定期发生的某些活动，以及维护重要的数据结构，如链路状态数据库
    (LSDB)。最重要的是，每个 OSPF 路由器都必须生成并响应 OSPF 消息。正是这种消息系统使得重要的路由信息能够在 AS 或区域内共享，这使得理解
    OSPF 的工作方式变得至关重要。因此，通过查看消息类型及其使用方式来讨论 OSPF 的操作是值得的。
- en: OSPF Message Types
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 消息类型
- en: 'Unlike RIP, OSPF does not send its information using the User Datagram Protocol
    (UDP). Instead, OSPF forms IP datagrams directly, packaging them using protocol
    number 89 for the Internet Protocol (IP) Protocol field. OSPF defines five different
    message types, for various types of communication:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 与 RIP 不同，OSPF 不使用用户数据报协议 (UDP) 来发送其信息。相反，OSPF 直接形成 IP 数据报，使用协议号 89 对 IP 协议字段进行打包。OSPF
    定义了五种不同的消息类型，用于各种类型的通信：
- en: '**Hello** As the name suggests, these messages are used as a form of greeting
    to allow a router to discover other adjacent routers on its local links and networks.
    The messages establish relationships between neighboring devices (called *adjacencies*)
    and communicate key parameters about how OSPF is to be used in the AS or area.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hello** 如其名所示，这些消息用作问候的形式，允许路由器发现其本地链路和网络上的其他相邻路由器。这些消息在相邻设备（称为*邻接*)之间建立关系，并传达有关如何在AS或区域中使用OSPF的关键参数。'
- en: '**Database Description** These messages contain descriptions of the topology
    of the AS or area; that is, they convey the contents of the LSDB for the AS or
    area from one router to another. Communicating a large LSDB may require several
    messages to be sent; this is done by designating the sending device as a master
    device and sending messages in sequence, with the slave (recipient of the LSDB
    information) responding with acknowledgments.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库描述** 这些消息包含AS或区域的拓扑描述；也就是说，它们将AS或区域的LSDB内容从一台路由器传递到另一台路由器。由于LSDB可能很大，可能需要发送多个消息；这是通过指定发送设备为主设备并按顺序发送消息来实现的，从设备（LSDB信息的接收者）则以确认的方式响应。'
- en: '**Link State Request** These messages are used by one router to request updated
    information about a portion of the LSDB from another router. The message specifies
    the link(s) about which the requesting device wants more current information.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**链路状态请求** 这些消息由一台路由器用于从另一台路由器请求LSDB某部分的更新信息。该消息指定了请求设备希望获取更多当前信息的链路。'
- en: '**Link State Update** These messages contain updated information about the
    state of certain links on the LSDB. They are sent in response to a Link State
    Request message, and they are also broadcast or multicast by routers on a regular
    basis. Their contents are used to update the information in the LSDBs of routers
    that receive them.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**链路状态更新** 这些消息包含关于LSDB中某些链路状态的更新信息。它们作为对链路状态请求消息的响应发送，并且路由器会定期广播或组播这些消息。它们的内含用于更新接收它们的路由器的LSDB中的信息。'
- en: '**Link State Acknowledgment** These messages provide reliability to the link-state
    exchange process by explicitly acknowledging receipt of a Link State Update message.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**链路状态确认** 这些消息通过明确确认接收链路状态更新消息来为链路状态交换过程提供可靠性。'
- en: OSPF Messaging
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF消息
- en: The use of these messages is approximately as follows. When a router first starts
    up it will send out a Hello message to see if any neighboring routers are around
    running OSPF, and it will also send them out periodically to discover any new
    neighbors that may show up. When an adjacency is set up with a new router, Database
    Description messages will then be sent to initialize the router's LSDB.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息的使用方法大致如下。当路由器首次启动时，它会发送一个Hello消息以查看是否有运行OSPF的相邻路由器，并且它还会定期发送这些消息以发现可能出现的任何新邻居。当与一个新路由器建立邻接关系时，随后会发送数据库描述消息以初始化路由器的LSDB。
- en: Routers that have been initialized enter a steady state mode. They will each
    routinely flood their local networks with Link State Update messages, advertising
    the state of their links. They will also send out updates when they detect a change
    in topology that needs to be communicated. They will receive Link State Update
    messages sent by other devices, and respond with Link State Acknowledgments accordingly.
    Routers may also request updates using Link State Request messages.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 已初始化的路由器进入稳定状态模式。它们将例行地向本地网络中洪泛链路状态更新消息，以通告其链路的状态。当它们检测到需要通告的拓扑结构变化时，它们也会发送更新。它们将接收来自其他设备的链路状态更新消息，并相应地发送链路状态确认。路由器还可以使用链路状态请求消息请求更新。
- en: When the hierarchical topology is used, internal routers maintain a single LSDB
    and perform messaging only within an area. Area border routers have multiple LSDBs
    and perform messaging in more than one area. They, along with any other OSPF backbone
    routers, also exchange messaging information on the backbone, including summarized
    link-state information for the areas they border.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用分层拓扑时，内部路由器维护单个LSDB，并在一个区域内执行消息传递。区域边界路由器有多个LSDB，并在多个区域内执行消息传递。它们以及任何其他OSPF骨干路由器，还在骨干上交换消息信息，包括它们边界的区域摘要链路状态信息。
- en: Again, all of this is highly simplified; the OSPF standard contains pages and
    pages of detailed rules and procedures governing the exact timing for sending
    and receiving messages.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这一切都高度简化了；OSPF标准包含大量详细规则和程序，规定了发送和接收消息的确切时间。
- en: Tip
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The operation of OSPF involves five message types. Hello messages
    establish contact between routers. Database Description messages initialize a
    router''s LSDB. Routine LSDB updates are sent using Link State Update messages,
    which are acknowledged using Link State Acknowledgments. A device may also request
    a specific update using a Link State Request message.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** OSPF的操作涉及五种消息类型。Hello消息在路由器之间建立联系。数据库描述消息初始化路由器的LSDB。通过链路状态更新消息发送常规LSDB更新，并使用链路状态确认进行确认。设备还可以使用链路状态请求消息请求特定的更新。'
- en: OSPF Message Authentication
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF消息认证
- en: The OSPF standard specifies that all OSPF messages are authenticated for security.
    This is a bit misleading, however, since one of the authentication methods supported
    is null authentication, meaning no authentication is used. More security is provided
    by using the optional simple password authentication method, and the most security
    is available through the use of cryptographic authentication. These methods are
    described in Appendix D of RFC 2328.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF标准规定，所有OSPF消息都必须进行身份验证以确保安全。然而，这有点误导，因为支持的认证方法之一是空认证，这意味着不使用任何认证。使用可选的简单密码认证方法可以提供更多的安全性，而使用加密认证则可以获得最高的安全性。这些方法在RFC
    2328的附录D中进行了描述。
- en: Note
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Hello messages used in OSPF are also sometimes called the* Hello Protocol.
    *This is especially poor terminology, because there is an actual routing protocol
    called the* HELLO Protocol. *The two protocols are not related. However, I suspect
    that the OSPF Hello messages may have been so named because they serve a similar
    purpose to the messages used in the independent HELLO Protocol*.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '*OSPF中使用的Hello消息有时也被称为* Hello协议。*这是一个特别糟糕的术语，因为实际上有一个名为HELLO协议的实际路由协议。*这两个协议没有关系。然而，我怀疑OSPF的Hello消息可能被这样命名是因为它们与独立HELLO协议中使用的消息具有类似的作用*。'
- en: OSPF Message Formats
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSPF消息格式
- en: As explained in the previous section, OSPF uses five different types of messages
    to communicate both link-state and general information between routers within
    an AS or area. To help illustrate how the OSPF messages are used, it's worth taking
    a look at the format of each of these messages.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OSPF使用五种不同类型的消息在AS或区域内的路由器之间通信链路状态和一般信息。为了帮助说明如何使用OSPF消息，查看这些消息的格式是值得的。
- en: OSPF Common Header Format
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF通用头部格式
- en: Naturally, each type of OSPF message includes a slightly different set of information;
    otherwise, there wouldn't be different message types. However, all message types
    share a similar message structure, beginning with a shared 24-byte header. This
    common header allows certain standard information to be conveyed in a consistent
    manner, such as the number of the version of OSPF that generated the message.
    It also allows a device receiving an OSPF message to quickly determine which type
    of message it has received, so it knows whether or not it needs to bother examining
    the rest of the message. [Table 39-4](ch39s06.html#ospf_common_header_format-id001
    "Table 39-4. OSPF Common Header Format") and [Figure 39-6](ch39s06.html#ospf_common_header_format_following_this
    "Figure 39-6. OSPF common header format Following this header, the body of the
    message includes a variable number of fields that depend on the message type.
    Each of the message formats is described in detail in RFC 2328\. Since some are
    quite long, I will describe their fields only briefly here.") show the common
    OSPF header format.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，每种类型的OSPF消息都包含一组略有不同的信息；否则，就不会有不同类型的消息。然而，所有消息类型都共享一个类似的消息结构，从共享的24字节头部开始。这个通用头部允许以一致的方式传达某些标准信息，例如生成消息的OSPF版本号。它还允许接收OSPF消息的设备快速确定它接收到的消息类型，从而知道是否需要检查消息的其余部分。[表39-4](ch39s06.html#ospf_common_header_format-id001
    "表39-4. OSPF通用头部格式")和[图39-6](ch39s06.html#ospf_common_header_format_following_this
    "图39-6. OSPF通用头部格式")显示了常见的OSPF头部格式。
- en: Table 39-4. OSPF Common Header Format
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 表39-4. OSPF通用头部格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Version # | 1 | Set to 2 for OSPF version 2. |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| 版本号 | 1 | 设置为2表示OSPF版本2。 |'
- en: '| Type | 1 | Indicates the type of OSPF message:1 = Hello2 = Database Description3
    = Link State Request4 = Link State Update5 = Link State Acknowledgment |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 表示OSPF消息的类型：1 = Hello2 = 数据库描述3 = 链路状态请求4 = 链路状态更新5 = 链路状态确认 |'
- en: '| Packet Length | 2 | The length of the message, in bytes, including the 24
    bytes of this header. |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| 数据包长度 | 2 | 消息的长度，以字节为单位，包括此头部的24字节。|'
- en: '| Router ID | 4 | The ID of the router that generated this message (generally
    its IP address on the interface over which the message was sent). |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| 路由器ID | 4 | 生成此消息的路由器ID（通常是发送消息的接口上的IP地址）。|'
- en: '| Area ID | 4 | An identification of the OSPF area to which this message belongs,
    when areas are used. |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| 区域ID | 4 | 当使用区域时，此消息所属的OSPF区域的标识。|'
- en: '| Checksum | 2 | A 16-bit checksum computed in a manner similar to a standard
    IP checksum. The entire message is included in the calculation except for the
    Authentication field. |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | 以类似于标准IP校验和的方式计算的一个16位校验和。整个消息包含在计算中，除了认证字段之外。|'
- en: '| AuType | 2 | Indicates the type of authentication used for this message:0
    = No Authentication1 = Simple Password Authentication2 = Cryptographic Authentication
    |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| 认证类型 | 2 | 指示用于此消息的认证类型：0 = 无认证1 = 简单密码认证2 = 密码学认证 |'
- en: '| Authentication | 8 | A 64-bit field used for authentication of the message,
    as needed. |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 认证 | 8 | 用于消息认证的64位字段，如有需要。|'
- en: '![OSPF common header format Following this header, the body of the message
    includes a variable number of fields that depend on the message type. Each of
    the message formats is described in detail in RFC 2328\. Since some are quite
    long, I will describe their fields only briefly here.](httpatomoreillycomsourcenostarchimages288053.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF通用头部格式](httpatomoreillycomsourcenostarchimages288053.png)'
- en: Figure 39-6. OSPF common header format Following this header, the body of the
    message includes a variable number of fields that depend on the message type.
    Each of the message formats is described in detail in RFC 2328\. Since some are
    quite long, I will describe their fields only briefly here.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 图39-6. OSPF通用头部格式 在此头部之后，消息体包括一个可变数量的字段，这些字段取决于消息类型。每种消息格式都在RFC 2328中详细描述。由于有些相当长，所以我将只简要描述它们的字段。
- en: OSPF Hello Message Format
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF Hello消息格式
- en: Hello messages have a Type value of 1 in the header, and the field structure
    shown in [Table 39-5](ch39s06.html#ospf_hello_message_format-id001 "Table 39-5. OSPF
    Hello Message Format") and [Figure 39-7](ch39s06.html#ospf_hello_message_format-id002
    "Figure 39-7. OSPF Hello message format") in the body of the message.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: Hello消息的头部Type值为1，消息体中的字段结构如[表39-5](ch39s06.html#ospf_hello_message_format-id001
    "表39-5. OSPF Hello消息格式")和[图39-7](ch39s06.html#ospf_hello_message_format-id002
    "图39-7. OSPF Hello消息格式")所示。
- en: Table 39-5. OSPF Hello Message Format
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 表39-5. OSPF Hello消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Network Mask | 4 | The subnet mask of the network the router is sending to.
    |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| 网络掩码 | 4 | 路由器发送到的网络的子网掩码。|'
- en: '| Hello Interval | 2 | The number of seconds this router waits between sending
    Hello messages. |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| Hello间隔 | 2 | 路由器在发送Hello消息之间等待的秒数。|'
- en: '| Options | 1 | Indicates which optional OSPF capabilities the router supports.
    |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 1 | 指示路由器支持哪些可选的OSPF功能。|'
- en: '| Rtr Pri | 1 | Indicates the router''s priority, when electing a backup designated
    router. |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| 路由器优先级 | 1 | 在选择备用指定路由器时，指示路由器的优先级。|'
- en: '| Router Dead Interval | 4 | The number of seconds a router can be silent before
    it is considered to have failed. |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 路由器死亡间隔 | 4 | 路由器在被认为是失败之前可以沉默的秒数。|'
- en: '| Designated Router | 4 | The address of a router designated for certain special
    functions on some networks. Set to zeros if there is no designated router. |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 指定路由器 | 4 | 在某些网络中指定用于特定特殊功能的路由器的地址。如果没有指定路由器，则设置为全零。|'
- en: '| Backup Designated Router | 4 | The address of a backup designated router.
    Set to all zeros if there is no backup designated router. |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 备用指定路由器地址 | 4 | 备用指定路由器的地址。如果没有备用指定路由器，则设置为全零。|'
- en: '| Neighbors | Multiple of 4 | The addresses of each router from which this
    router has received Hello messages recently. |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| 邻居 | 4的倍数 | 从最近接收到的Hello消息的每个路由器的地址。|'
- en: '![OSPF Hello message format](httpatomoreillycomsourcenostarchimages288055.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF Hello消息格式](httpatomoreillycomsourcenostarchimages288055.png)'
- en: Figure 39-7. OSPF Hello message format
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 图39-7. OSPF Hello消息格式
- en: OSPF Database Description Message Format
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF数据库描述消息格式
- en: Database Description messages have a Type value of 2 in the header and the body
    structure depicted in [Table 39-6](ch39s06.html#ospf_database_description_message_-id001
    "Table 39-6. OSPF Database Description Message Format") and [Figure 39-8](ch39s06.html#ospf_database_description_message_-id002
    "Figure 39-8. OSPF Database Description message format").
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库描述消息在头部中的类型值为2，其体结构如图[表39-6](ch39s06.html#ospf_database_description_message_-id001
    "表39-6. OSPF数据库描述消息格式")和[图39-8](ch39s06.html#ospf_database_description_message_-id002
    "图39-8. OSPF数据库描述消息格式")所示。
- en: Table 39-6. OSPF Database Description Message Format
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 表[表39-6](ch39s06.html#ospf_database_description_message_-id001 "表39-6. OSPF数据库描述消息格式")
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Interface MTU | 2 | The size of the largest IP message that can be sent on
    this router''s interface without fragmentation. |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| 接口MTU | 2 | 在此路由器接口上可以发送的最大IP消息的大小，无需分片。|'
- en: '| Options | 1 | Indicates which of several optional OSPF capabilities the router
    supports. |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 1 | 指示路由器支持几个可选的OSPF功能中的哪一个。|'
- en: '| Flags | 1 | Special flags used to indicate information about the exchange
    of Database Description messages, as shown in [Table 39-7](ch39s06.html#ospf_database_description_message_flags
    "Table 39-7. OSPF Database Description Message Flags"). |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 1 | 特殊标志，用于指示数据库描述消息交换的信息，如图[表39-7](ch39s06.html#ospf_database_description_message_flags
    "表39-7. OSPF数据库描述消息标志")所示。|'
- en: '| DD Sequence Number | 4 | Used to number a sequence of Database Description
    messages so that they are kept in order. |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| 数据库描述序列号 | 4 | 用于对数据库描述消息进行编号，以便保持它们的顺序。|'
- en: '| LSA Headers | Variable | Contains LSA headers, which carry information about
    the LSDB. See the "OSPF Link State Advertisements and the LSA Header Format" section
    later in this chapter for more information about LSAs. Please add correct cross-ref
    info. |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| LSA头部 | 可变 | 包含LSA头部，它们携带有关LSDB的信息。请参阅本章后面的“OSPF链路状态广告和LSA头部格式”部分以获取有关LSA的更多信息。请添加正确的交叉引用信息。|'
- en: Table 39-7. OSPF Database Description Message Flags
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 表[表39-7](ch39s06.html#ospf_database_description_message_flags "表39-7. OSPF数据库描述消息标志")
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Reserved | 5/8 (5 bits) | Reserved: Sent and received as zero. |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 5/8 (5位) | 保留：发送和接收时均为零。|'
- en: '| I | 1/8 (1 bit) | I-Bit: Set to 1 to indicate that this is the first (initial)
    in a sequence of Database Description messages. |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| I | 1/8 (1位) | I位：设置为1以指示这是数据库描述消息序列中的第一个（初始）消息。|'
- en: '| M | 1/8 (1 bit) | M-Bit: Set to 1 to indicate that more Database Description
    messages follow this one. |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| M | 1/8 (1位) | M位：设置为1以指示在此消息之后还有更多的数据库描述消息。|'
- en: '| MS | 1/8 (1 bit) | MS-Bit: Set to 1 if the router sending this message is
    the master in the communication, or 0 if it is the slave. |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| MS | 1/8 (1位) | MS位：如果发送此消息的路由器是通信中的主设备，则设置为1；如果是从设备，则设置为0。|'
- en: '![OSPF Database Description message format](httpatomoreillycomsourcenostarchimages288057.png.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF数据库描述消息格式](httpatomoreillycomsourcenostarchimages288057.png.jpg)'
- en: Figure 39-8. OSPF Database Description message format
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图[图39-8](ch39s06.html#ospf_database_description_message_-id002 "图39-8. OSPF数据库描述消息格式")
- en: OSPF Link State Request Message Format
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF链路状态请求消息格式
- en: Link State Request messages have a Type value of 3 in the header. Following
    the header comes one or more sets of three fields, each of which identify an LSA
    for which the router is requesting an update, as shown in [Figure 39-9](ch39s06.html#ospf_link_state_request_message_-id002
    "Figure 39-9. OSPF Link State Request Message format"). Each LSA identification
    has the format described in [Table 39-8](ch39s06.html#ospf_link_state_request_message_-id001
    "Table 39-8. OSPF Link State Request Message Format").
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态请求消息在头部中的类型值为3。在头部之后，跟随一个或多个由三个字段组成的集合，每个字段都标识一个路由器请求更新的LSA，如图[图39-9](ch39s06.html#ospf_link_state_request_message_-id002
    "图39-9. OSPF链路状态请求消息格式")所示。每个LSA标识的格式在[表39-8](ch39s06.html#ospf_link_state_request_message_-id001
    "表39-8. OSPF链路状态请求消息格式")中描述。
- en: Table 39-8. OSPF Link State Request Message Format
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 表[表39-8](ch39s06.html#ospf_link_state_request_message_-id001 "表39-8. OSPF链路状态请求消息格式")
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LS Type | 4 | The type of LSA being sought. |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| LS类型 | 4 | 正在寻找的LSA的类型。|'
- en: '| Link State ID | 4 | The identifier of the LSA, usually the IP address of
    either the router or network linked. |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 链路状态ID | 4 | LSA的标识符，通常是路由器或网络链接的IP地址。|'
- en: '| Advertising Router | 4 | The ID of the router that created the LSA whose
    update is being sought. |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 广播路由器 | 4 | 创建正在寻找更新的LSA的路由器的ID。|'
- en: '![OSPF Link State Request Message format](httpatomoreillycomsourcenostarchimages288059.png)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF 链路状态请求消息格式](httpatomoreillycomsourcenostarchimages288059.png)'
- en: Figure 39-9. OSPF Link State Request Message format
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 图 39-9. OSPF 链路状态请求消息格式
- en: OSPF Link State Update Message Format
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 链路状态更新消息格式
- en: Link State Update messages have a Type value of 4 in the header and the fields
    illustrated in [Table 39-9](ch39s06.html#ospf_link_state_update_message_for-id001
    "Table 39-9. OSPF Link State Update Message Format") and [Figure 39-10](ch39s06.html#ospf_link_state_update_message_for-id002
    "Figure 39-10. OSPF Link State Update message format").
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态更新消息在头部有一个类型值为 4，以及 [表 39-9](ch39s06.html#ospf_link_state_update_message_for-id001
    "表 39-9. OSPF 链路状态更新消息格式") 和 [图 39-10](ch39s06.html#ospf_link_state_update_message_for-id002
    "图 39-10. OSPF 链路状态更新消息格式") 中展示的字段。
- en: Table 39-9. OSPF Link State Update Message Format
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-9. OSPF 链路状态更新消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小 (字节) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| # LSAs | 4 | The number of LSAs included in this message. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| # LSAs | 4 | 此消息中包含的 LSA 数量。 |'
- en: '| LSAs | Variable | One or more LSAs. See the "OSPF Link State Advertisements
    and the LSA Header Format" section later in this chapter for more details. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| LSAs | 可变 | 包含一个或多个 LSA。有关更多详细信息，请参阅本章后面的“OSPF 链路状态通告和 LSA 头部格式”部分。 |'
- en: '![OSPF Link State Update message format](httpatomoreillycomsourcenostarchimages288061.png)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF 链路状态更新消息格式](httpatomoreillycomsourcenostarchimages288061.png)'
- en: Figure 39-10. OSPF Link State Update message format
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 图 39-10. OSPF 链路状态更新消息格式
- en: OSPF Link State Acknowledgment Message Format
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 链路状态确认消息格式
- en: Link State Acknowledgment messages have a Type value of 5 in the header. They
    then contain a list of LSA headers corresponding to the LSAs being acknowledged,
    as shown in [Table 39-10](ch39s06.html#ospf_link_state_acknowledgment_mes-id001
    "Table 39-10. OSPF Link State Acknowledgment Message Format") and [Figure 39-11](ch39s06.html#ospf_link_state_acknowledgment_mes-id002
    "Figure 39-11. OSPF Link State Acknowledgment message format").
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态确认消息在头部有一个类型值为 5。然后，它们包含一个与被确认的 LSA 对应的 LSA 头部列表，如 [表 39-10](ch39s06.html#ospf_link_state_acknowledgment_mes-id001
    "表 39-10. OSPF 链路状态确认消息格式") 和 [图 39-11](ch39s06.html#ospf_link_state_acknowledgment_mes-id002
    "图 39-11. OSPF 链路状态确认消息格式") 所示。
- en: Table 39-10. OSPF Link State Acknowledgment Message Format
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-10. OSPF 链路状态确认消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小 (字节) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LSA Headers | Variable | Contains LSA headers that identify the LSAs acknowledged.
    |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| LSA 头部 | 可变 | 包含标识被确认的 LSA 的 LSA 头部。 |'
- en: '![OSPF Link State Acknowledgment message format](httpatomoreillycomsourcenostarchimages288063.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF 链路状态确认消息格式](httpatomoreillycomsourcenostarchimages288063.png)'
- en: Figure 39-11. OSPF Link State Acknowledgment message format
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图 39-11. OSPF 链路状态确认消息格式
- en: OSPF Link State Advertisements and the LSA Header Format
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSPF 链路状态通告和 LSA 头部格式
- en: Several of the previous message types include LSAs, which are the fields that
    actually carry topological information about the LSDB. There are several types
    of LSAs, which are used to convey information about different types of links.
    Like the OSPF messages themselves, each LSA has a common header with 20 bytes
    and then a number of additional fields that describe the link.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个消息类型包括 LSA，这些字段实际上携带了关于 LSDB 的拓扑信息。有几种类型的 LSA，用于传达有关不同类型链路的信息。与 OSPF 消息本身一样，每个
    LSA 都有一个 20 字节的通用头部，然后是一系列描述链路的附加字段。
- en: The LSA header contains sufficient information to identify the link. It uses
    the subfield structure shown in [Table 39-11](ch39s06.html#ospf_link_state_advertisement_header_for
    "Table 39-11. OSPF Link State Advertisement Header Format") and [Figure 39-12](ch39s06.html#ospf_link_state_advertisement_head-id001
    "Figure 39-12. OSPF Link State Advertisement header format").
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: LSA 头部包含足够的信息来识别链路。它使用 [表 39-11](ch39s06.html#ospf_link_state_advertisement_header_for
    "表 39-11. OSPF 链路状态通告头部格式") 和 [图 39-12](ch39s06.html#ospf_link_state_advertisement_head-id001
    "图 39-12. OSPF 链路状态通告头部格式") 中所示的子字段结构。
- en: Table 39-11. OSPF Link State Advertisement Header Format
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-11. OSPF 链路状态通告头部格式
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小 (字节) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LS Age | 2 | The number of seconds elapsed since the LSA was created. |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '| LS 年龄 | 2 | 自 LSA 创建以来经过的秒数。 |'
- en: '| Options | 1 | Indicates which of several optional OSPF capabilities the router
    supports. |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 1 | 指示路由器支持几种可选的 OSPF 功能之一。 |'
- en: '| LS Type | 1 | Indicates the type of link this LSA describes, as shown in
    [Table 39-12](ch39s06.html#ospf_link_state_advertisement_header_ls_ "Table 39-12. OSPF
    Link State Advertisement Header LS Types"). |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| LS 类型 | 1 | 指示此 LSA 描述的链接类型，如 [表 39-12](ch39s06.html#ospf_link_state_advertisement_header_ls_
    "表 39-12. OSPF 链路状态通告头部 LS 类型") 所示。|'
- en: '| Link State ID | 4 | Identifies the link. This usually is the IP address of
    either the router or the network the link represents. |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| 链路状态 ID | 4 | 识别链接。这通常是路由器或该链接所代表的网络的 IP 地址。|'
- en: '| Advertising Router | 4 | The ID of the router originating the LSA. |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 广告路由器 | 4 | 发起 LSA 的路由器 ID。|'
- en: '| LS Sequence Number | 4 | A sequence number used to detect old or duplicate
    LSAs. |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| LS 序列号 | 4 | 用于检测旧或重复 LSA 的序列号。|'
- en: '| LS Checksum | 2 | A checksum of the LSA for data corruption protection. |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| LS 校验和 | 2 | 用于数据损坏保护的 LSA 校验和。|'
- en: '| Length | 2 | The length of the LSA, including the 20 bytes of the header.
    |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 2 | LSA 的长度，包括头部的 20 个字节。|'
- en: Table 39-12. OSPF Link State Advertisement Header LS Types
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-12. OSPF 链路状态通告头部 LS 类型
- en: '| Value | Link Type | Description |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 链接类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Router-LSA | Link to a router. |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 路由器-LSA | 连接到路由器的链路。|'
- en: '| 2 | Network-LSA | Link to a network. |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 网络-LSA | 连接到网络的链路。|'
- en: '| 3 | Summary-LSA (IP Network) | When areas are used, summary information is
    generated about a network. |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 摘要-LSA (IP 网络) | 当使用区域时，会生成关于网络的摘要信息。|'
- en: '| 4 | Summary-LSA (ASBR) | When areas are used, summary information is generated
    about a link to an AS boundary router. |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 摘要-LSA (ASBR) | 当使用区域时，会生成关于连接到 AS 边界路由器的链路摘要信息。|'
- en: '| 5 | AS-External-LSA | An external link outside the AS. |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| 5 | AS-外部-LSA | AS 外部的链路。|'
- en: '![OSPF Link State Advertisement header format](httpatomoreillycomsourcenostarchimages288065.png)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![OSPF 链路状态通告头部格式](httpatomoreillycomsourcenostarchimages288065.png)'
- en: Figure 39-12. OSPF Link State Advertisement header format
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 图 39-12. OSPF 链路状态通告头部格式
- en: 'Following the LSA header comes the body of the LSA. The specific fields in
    the body depend on the value of the LS Type field (see [Table 39-12](ch39s06.html#ospf_link_state_advertisement_header_ls_
    "Table 39-12. OSPF Link State Advertisement Header LS Types")). Here is a summary:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LSA 头部之后是 LSA 的主体。主体中的特定字段取决于 LS 类型字段的值（参见 [表 39-12](ch39s06.html#ospf_link_state_advertisement_header_ls_
    "表 39-12. OSPF 链路状态通告头部 LS 类型")）。以下是摘要：
- en: For normal links to a router, the LSA includes an identification of the router
    and the metric to reach it, as well as details about the router such as whether
    it is a boundary or area border router.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于到路由器的普通链接，LSA 包含了路由器的标识和到达它的度量，以及有关路由器的详细信息，例如它是否是边界或区域边界路由器。
- en: LSAs for networks include a subnet mask and information about other routers
    on the network.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络链路状态通告包括子网掩码以及关于网络中其他路由器的信息。
- en: Summary LSAs include a metric and a summarized address as well as a subnet mask.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要 LSA 包含度量、汇总地址以及子网掩码。
- en: External LSAs include a number of additional fields that allow the external
    router to be communicated.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部链路状态通告包含一些额外的字段，允许外部路由器进行通信。
- en: Refer to Appendix A of RFC 2328 if you want all the details about the fields
    in the LSA body.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解 LSA 主体中字段的详细信息，请参阅 RFC 2328 的附录 A。
- en: Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 40 章. 边界网关协议 (BGP/BGP-4)
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Modern TCP/IP internetworks are composed of autonomous systems (ASes) that are
    run independently. Each may use an interior routing protocol such as Routing Information
    Protocol (RIP), Open Shortest Path First (OSPF), Interior Gateway Routing Protocol
    (IGRP), or Enhanced Interior Gateway Routing Protocol (EIGRP) to select routes
    between networks within the AS. To form larger internetworks, and especially the
    "mother of all internetworks," the Internet, these ASes must be connected together.
    This requires use of a consistent exterior routing protocol that all ASes can
    agree upon, and in today's TCP/IP, that protocol is the *Border Gateway Protocol
    (BGP)*.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 现代TCP/IP互连网络由独立运行的自治系统（AS）组成。每个自治系统可能使用内部路由协议，如路由信息协议（RIP）、开放最短路径优先（OSPF）、内部网关路由协议（IGRP）或增强型内部网关路由协议（EIGRP）来选择
    AS 内网络之间的路由。为了形成更大的互连网络，特别是“所有互连网络之母”——互联网，这些自治系统必须连接在一起。这需要使用所有自治系统都能达成一致的统一外部路由协议，在今天的
    TCP/IP 中，该协议就是 *边界网关协议（BGP）*。
- en: If you were to ask the average Internet user, or even the typical network administrator,
    to make a list of the ten most important TCP/IP protocols, BGP probably wouldn't
    show up frequently. Routing protocols are worker bees of the TCP/IP protocol suite,
    and they just are not very exciting. The reality, however, is that BGP is a critically
    important protocol to the operation of larger internetworks and the Internet itself.
    It is the glue that binds smaller internetworks (ASes) together, and it ensures
    that every organization is able to share routing information. It is this function
    that lets us take disparate networks and internetworks and find efficient routes
    from any host to any other host, regardless of location.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求普通互联网用户，甚至典型的网络管理员列出十个最重要的TCP/IP协议，BGP可能不会频繁出现。路由协议是TCP/IP协议套件的工蜂，它们并不非常吸引人。然而，现实情况是，BGP对于大型互联网和互联网本身的运行至关重要。它是将较小的互联网（AS）粘合在一起的东西，并确保每个组织都能共享路由信息。正是这个功能使我们能够将不同的网络和互联网连接起来，并从任何主机找到到任何其他主机的有效路由，无论位置如何。
- en: In this chapter, I describe the characteristics, general operation, and detailed
    operation of BGP. I start, as usual, with an overview of the protocol and discuss
    its history, standards, and versions, including a discussion of its key features
    and characteristics. I then cover basic operational concepts, including topology,
    the notion of BGP speakers, and neighbor relationships. I discuss BGP traffic
    types and how policies can be used to control traffic flows on the internetwork.
    I explain how BGP routers store and advertise routes and how Routing Information
    Bases function. I describe the basic algorithm used by BGP and how path attributes
    describe routes. I provide a summary of how the BGP route selection process operates.
    I then give a general description of BGP's operation and its high-level use of
    various messages. Finally, I present a more detailed analysis of the different
    message types, how they are used, and their format.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了BGP（边界网关协议）的特点、一般操作和详细操作。我像往常一样，首先概述了该协议，并讨论了其历史、标准和版本，包括对其关键特性和特性的讨论。然后，我涵盖了基本操作概念，包括拓扑、BGP发言人概念和邻居关系。我讨论了BGP流量类型以及如何使用策略来控制互联网上的流量。我解释了BGP路由器如何存储和通告路由以及路由信息库如何工作。我描述了BGP使用的算法以及路径属性如何描述路由。我提供了BGP路由选择过程操作的总结。然后，我给出了BGP操作的一般描述及其对各种消息的高级使用。最后，我更详细地分析了不同消息类型、它们的使用方式和格式。
- en: BGP is another in the rather large group of protocols and technologies that
    is so complex it would take dozens of chapters to do justice. Therefore, I include
    here my somewhat standard disclaimer that you will find in this chapter only a
    relatively high-level look at BGP. You will need to refer to the BGP standards
    (described in the section on BGP standards and versions) if you need more details.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: BGP是庞大的一组协议和技术中的一个，其复杂性如此之大，以至于需要数十章才能公正地描述。因此，我在这里包含了一个相当标准的免责声明，你将在本章中只看到BGP的相对高级概述。如果你需要更多细节，你需要参考BGP标准（在BGP标准和版本部分描述）。
- en: Note
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The current version of BGP is version 4, also called* BGP-4\. *This is the
    only version widely used today, so unless otherwise indicated, assume that I''m
    talking about BGP-4 wherever you see* BGP.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '*当前BGP的版本是版本4，也称为* BGP-4。*这是今天广泛使用的唯一版本，所以除非另有说明，否则在你看到* BGP的地方，假设我在谈论BGP-4。*'
- en: BGP Overview
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP概述
- en: As I described briefly in the overview of routing protocol concepts in [Chapter 37](ch37.html
    "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS"), the way that routers
    were connected in the early Internet was quite different than it is today. The
    early Internet had a set of centralized routers functioning as a core AS. These
    routers used the Gateway-to-Gateway Protocol (GGP) for communication between them
    within the AS and the aptly named Exterior Gateway Protocol (EGP) to talk to routers
    outside the core. GGP and EGP are discussed in [Chapter 41](ch41.html "Chapter 41. OTHER
    ROUTING PROTOCOLS").
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第37章](ch37.html "第37章。路由协议概念概述")中简要描述的路由协议概念概述中所述，早期互联网中路由器之间的连接方式与今天大不相同。早期的互联网有一组作为核心自治系统（AS）的集中式路由器。这些路由器在AS内部使用网关到网关协议（GGP）进行通信，并使用恰如其分的称为外部网关协议（EGP）与核心外的路由器通信。GGP和EGP在[第41章](ch41.html
    "第41章。其他路由协议")中讨论。
- en: When the Internet grew and moved to AS architecture, EGP was still able to function
    as the exterior routing protocol for the Internet. However, as the number of ASes
    in an internetwork grew, the importance of communication between them grew as
    well. EGP was functional but had several weaknesses that became more problematic
    as the Internet expanded. It was necessary to define a new exterior routing protocol
    that would provide enhanced capabilities for use on the growing Internet.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 当互联网增长并转向AS架构时，EGP仍然能够作为互联网的外部路由协议运行。然而，随着互联网中AS数量的增加，它们之间通信的重要性也随之增长。EGP虽然功能齐全，但存在一些弱点，随着互联网的扩展，这些弱点变得更加突出。有必要定义一个新的外部路由协议，该协议将为日益增长的互联网提供增强的功能。
- en: In June 1989, the first version of this new routing protocol was formalized,
    with the publishing of RFC 1105, "A Border Gateway Protocol (BGP)." This initial
    version of the BGP standard defined most of the concepts behind the protocol,
    as well as key fundamentals such as messaging, message formats, and how devices
    operate in general terms. It established BGP as the Internet's exterior routing
    protocol of the future.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 1989年6月，本新路由协议的第一个版本通过发布RFC 1105，“一个边界网关协议（BGP）”而正式化。BGP标准的这个初始版本定义了协议背后的大多数概念，以及关键的基本要素，如消息、消息格式以及设备在一般意义上的操作。它确立了BGP作为互联网未来外部路由协议的地位。
- en: BGP Versions and Defining Standards
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP版本和定义标准
- en: Due to the importance of a protocol that spans the Internet, work continued
    on BGP for many years after the initial standard was published. The developers
    of BGP needed to correct problems with the initial protocol, refine BGP's operation,
    improve efficiency, and add features. It was also necessary to make adjustments
    to allow BGP to keep pace with other changes in the TCP/IP protocol suite, such
    as the invention of classless addressing and routing.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跨越互联网的协议的重要性，在最初标准发布后，对BGP的工作持续了许多年。BGP的开发者需要纠正初始协议的问题，细化BGP的操作，提高效率，并添加功能。还必须进行调整，以使BGP能够跟上TCP/IP协议套件中的其他变化，例如无类别地址和路由的发明。
- en: The result of this ongoing work is that BGP has evolved through several versions
    and standards. These are sometimes called BGP-*N*, where *N* is the version number.
    [Table 40-1](ch40.html#border_gateway_protocol_bgp_versions_and "Table 40-1. Border
    Gateway Protocol (BGP) Versions and Defining Standards") shows the history of
    BGP standards, providing the RFC numbers and names, and a brief summary of the
    changes made in each version.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这项持续工作的结果是，BGP经历了几个版本和标准的演变。这些有时被称为BGP-*N*，其中*N*是版本号。[表40-1](ch40.html#border_gateway_protocol_bgp_versions_and
    "表40-1. 边界网关协议（BGP）版本和定义标准")显示了BGP标准的历史，提供了RFC编号和名称，以及每个版本所做的简要更改。
- en: Table 40-1. Border Gateway Protocol (BGP) Versions and Defining Standards
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-1. 边界网关协议（BGP）版本和定义标准
- en: '| RFC Number | Date | Name | BGP Version | Description |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| RFC编号 | 日期 | 名称 | BGP版本 | 描述 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1105 | June 1989 | A Border Gateway Protocol (BGP) | BGP-1 | Initial definition
    of the BGP. |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| 1105 | 1989年6月 | 一个边界网关协议（BGP） | BGP-1 | BGP的初始定义。|'
- en: '| 1163 | June 1990 | A Border Gateway Protocol (BGP) | BGP-2 | This version
    cleaned up several issues with BGP-1 and refined the meaning and use of several
    of the message types. It also added the important concept of path attributes,
    which communicate information about routes. BGP-1 was designed around the notion
    of a directional topology, with certain routers being up, down, or horizontal
    relative to each other; BGP-2 removed this concept, making BGP better suited to
    an arbitrary AS topology. (Note that the RFC title is not a typo; they didn''t
    put "version 2" in the title.) |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| 1163 | 1990年6月 | 一个边界网关协议（BGP） | BGP-2 | 这个版本的BGP清理了BGP-1中的几个问题，并细化了某些消息类型的意义和使用。它还增加了重要的路径属性概念，用于传递有关路由的信息。BGP-1是基于方向拓扑的概念设计的，某些路由器相对于彼此是上升、下降或水平；BGP-2去除了这个概念，使BGP更适合任意AS拓扑。（注意，RFC标题没有打字错误；他们没有在标题中放入“版本2”。）|'
- en: '| 1267 | October 1991 | Border Gateway Protocol 3 (BGP-3) | BGP-3 | This version
    optimized and simplified route information exchange, adding an identification
    capability to the messages used to establish BGP communications, and incorporating
    several other improvements and corrections. (They left the "A" off the title of
    this one for some reason.) |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| 1267 | 十月 1991 | 边界网关协议 3 (BGP-3) | BGP-3 | 此版本优化并简化了路由信息交换，向用于建立 BGP 通信的消息中添加了标识能力，并纳入了其他一些改进和修正。（出于某种原因，他们从标题中省略了
    "A" 字母。）|'
- en: '| 1654 | July 1994 | A Border Gateway Protocol 4 (BGP-4) | BGP-4 | Initial
    standard for BGP-4, revised in RFC 1771. |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| 1654 | 七月 1994 | 边界网关协议 4 (BGP-4) | BGP-4 | BGP-4 的初始标准，在 RFC 1771 中进行了修订。|'
- en: '| 1771 | March 1995 | A Border Gateway Protocol 4 (BGP-4) | BGP-4 | Current
    standard for BGP-4\. The primary change in BGP-4 is support for Classless Inter-Domain
    Routing (CIDR). The protocol was changed to allow prefixes to be specified that
    represent a set of aggregated networks. Other minor improvements were also made
    to the protocol. |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| 1771 | 三月 1995 | 边界网关协议 4 (BGP-4) | BGP-4 | BGP-4 的当前标准。BGP-4 的主要变化是支持无类别域间路由
    (CIDR)。该协议被修改，允许指定表示一组聚合网络的前缀。还对协议进行了其他一些小的改进。|'
- en: As you might imagine, changing the version of a protocol like BGP is not an
    easy undertaking. Any modification of the protocol would require the coordination
    of many different organizations. The larger the Internet grows, the more difficult
    this would be. As a result, despite frequent version changes in the early 1990s,
    BGP-4 remains today the current version of the standard and is the one that is
    widely used. Unless otherwise specified, any mention of BGP in this book refers
    to BGP-4.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，更改像 BGP 这样的协议版本并不是一项容易的任务。对协议的任何修改都需要许多不同组织的协调。互联网规模越大，这越困难。因此，尽管在 20 世纪
    90 年代初期频繁进行版本更改，但 BGP-4 仍然是当前的标准版本，并且是广泛使用的版本。除非另有说明，本书中提到的任何 BGP 都指的是 BGP-4。
- en: Supplementing RFC 1771 are three other consecutively numbered RFCs published
    simultaneously with it, which provide supporting information about BGP's functions
    and use, as shown in [Table 40-2](ch40.html#additional_defining_standards_for_bgp-
    "Table 40-2. Additional Defining Standards for BGP-4").
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 补充 RFC 1771 的还有三个连续编号的 RFC，它们与 RFC 1771 同时发布，提供了关于 BGP 功能和使用的支持信息，如 [表 40-2](ch40.html#additional_defining_standards_for_bgp-
    "表 40-2. BGP-4 的附加定义标准") 所示。
- en: Table 40-2. Additional Defining Standards for BGP-4
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 表 40-2. BGP-4 的附加定义标准
- en: '| RFC Number | Name | Description |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| RFC 编号 | 名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1772 | Application of the Border Gateway Protocol in the Internet | Provides
    additional conceptual information on the operation of BGP and how it is applied
    to and used on the Internet. This document is sometimes considered a companion
    of RFC 1771 with the pair defining BGP-4. |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| 1772 | 互联网中边界网关协议的应用 | 提供了关于 BGP 运作以及如何在互联网上应用和使用的额外概念信息。这份文档有时被认为是 RFC 1771
    的配套文件，两者共同定义了 BGP-4。|'
- en: '| 1773 | Experience with the BGP-4 Protocol | Describes the experiences of
    those testing and using BGP-4 and provides information that justified its acceptance
    as a standard. |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 1773 | BGP-4 协议的经验 | 描述了测试和使用 BGP-4 的人的经验，并提供了证明其作为标准被接受的信息。|'
- en: '| 1774 | BGP-4 Protocol Analysis | Provides more detailed technical information
    about the operation of BGP-4. |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| 1774 | BGP-4 协议分析 | 提供了关于 BGP-4 运作的更详细的技术信息。|'
- en: Tip
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The exterior routing protocol used in modern TCP/IP internetworks
    is the *Border Gateway Protocol (BGP)*. Initially developed in the late 1980s
    as a successor to the Exterior Gateway Protocol (EGP), BGP has been revised many
    times; the current version is 4, so BGP is also commonly called BGP-4\. BGP''s
    primary function is the exchange of network reachability information between ASes
    to allow each AS on an internetwork to send messages efficiently to every other
    one.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 现代 TCP/IP 互联网中使用的边界路由协议是 *边界网关协议 (BGP)*。BGP 最初在 20 世纪 80 年代末期开发，作为外部网关协议
    (EGP) 的继任者，BGP 已多次修订；当前版本是 4，因此 BGP 也常被称为 BGP-4。BGP 的主要功能是在自治系统 (AS) 之间交换网络可达性信息，以便互联网上的每个
    AS 都能高效地向其他 AS 发送消息。'
- en: Overview of BGP Functions and Features
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP 功能和特性概述
- en: If I were to summarize the job of BGP in one phrase, it would be to exchange
    network reachability information between ASes and from this information determine
    routes to networks. In a typical internetwork (and in the Internet), each AS designates
    one or more routers that run BGP software. BGP routers in each AS are linked to
    those in one or more other ASes. Each BGP stores information about networks and
    the routes to them in a set of Routing Information Bases (RIBs). This route information
    is exchanged between BGP routers and propagated throughout the entire internetwork,
    allowing each AS to find paths to each other AS, and thereby enabling routing
    across the entire internetwork.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要用一个短语来总结 BGP 的工作，那将是交换 AS（自治系统）之间的网络可达性信息，并从这个信息中确定到达网络的路径。在一个典型的互联网（以及因特网）中，每个
    AS 指定一个或多个运行 BGP 软件的路由器。每个 AS 中的 BGP 路由器与一个或多个其他 AS 中的路由器相连。每个 BGP 路由器在一系列路由信息库（RIBs）中存储有关网络及其路径的信息。这种路由信息在
    BGP 路由器之间交换，并在整个互联网中传播，使得每个 AS 能够找到到达其他 AS 的路径，从而在整个互联网中实现路由。
- en: BGP supports an arbitrary topology of ASes, meaning that they can be connected
    in any manner. An AS must have a minimum of one router running BGP, but can have
    more than one. It is also possible to use BGP to communicate between BGP routers
    within the same AS.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: BGP 支持任意拓扑结构的 AS，这意味着它们可以以任何方式连接。一个 AS 至少必须有一个运行 BGP 的路由器，但可以有多个。也有可能使用 BGP
    在同一 AS 内部的 BGP 路由器之间进行通信。
- en: BGP uses a fairly complex system for route determination. The protocol goes
    beyond the limited notion of considering only the next hop to a network the way
    distance-vector algorithms like RIP function. Instead, the BGP router stores more
    complete information about the path (sequence of ASes) from itself to a network.
    Special path attributes describe the characteristics of paths and are used in
    the process of route selection. Because of its storage of path information, BGP
    is sometimes called a *path-vector* protocol.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: BGP 使用一个相当复杂的系统来确定路由。该协议超越了仅考虑网络下一跳的有限概念，就像 RIP 这样的距离矢量算法所做的那样。相反，BGP 路由器存储了从自身到网络的路由（AS
    序列）的更完整信息。特殊的路径属性描述了路径的特性，并在路由选择过程中使用。由于其存储路径信息，BGP 有时被称为 *路径向量* 协议。
- en: BGP chooses routes using a deterministic algorithm that assesses path attributes
    and chooses an efficient route, while avoiding router loops and other problem
    conditions. The selection of routes by a BGP router can also be controlled through
    a set of BGP policies that specify, for example, whether an AS is willing to carry
    traffic from other ASes. However, BGP cannot guarantee the most efficient route
    to any destination, because it cannot know what happens within each AS and therefore
    what the cost is to traverse each AS.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: BGP 使用一种确定性的算法来选择路由，该算法评估路径属性并选择一条高效的路由，同时避免路由器环路和其他问题条件。BGP 路由器选择路由的过程也可以通过一组
    BGP 策略来控制，这些策略可以指定，例如，AS 是否愿意承载来自其他 AS 的流量。然而，BGP 不能保证到达任何目的地的最有效路由，因为它无法知道每个
    AS 内部发生的情况以及穿越每个 AS 的成本。
- en: BGP's operation is based on the exchange of messages that perform different
    functions. BGP routers use Open messages to contact neighboring routers and establish
    BGP sessions. They exchange Update messages to communicate information about reachable
    networks, sending only partial information as needed. They also use Keepalive
    and Notification messages to maintain sessions and inform peers of error conditions.
    The use of these messages is explained thoroughly later in this chapter.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: BGP（边界网关协议）的操作基于执行不同功能的消息交换。BGP 路由器使用 Open 消息来联系相邻路由器并建立 BGP 会话。它们通过交换 Update
    消息来沟通关于可达网络的详细信息，根据需要只发送部分信息。它们还使用 Keepalive 和 Notification 消息来维护会话并通知对等体错误条件。这些消息的使用将在本章后面详细解释。
- en: Tip
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** BGP supports an arbitrary topology of ASes. Each AS using BGP
    assigns one or more routers to implement the protocol. These devices then exchange
    messages to establish contact with each other and share information about rates
    through the internetwork using the Transmission Control Protocol (TCP). BGP employs
    a sophisticated path vector route calculation algorithm that determines routes
    from path attributes that describe how different networks can be reached.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP 支持任意拓扑结构的 AS。每个使用 BGP 的 AS 分配一个或多个路由器来实现该协议。这些设备随后交换消息以相互建立联系，并通过传输控制协议（TCP）在互联网中共享关于速率的信息。BGP
    使用一种复杂的路径向量路由计算算法，该算法根据描述如何到达不同网络的路径属性来确定路由。'
- en: BGP uses the Transmission Control Protocol (TCP) as a reliable transport protocol
    so that it can take advantage of the many connection setup and maintenance features
    of that protocol. This also means that BGP doesn't need to worry about issues
    such as message sequencing, acknowledgments, or lost transmissions. Since unauthorized
    BGP messages could wreak havoc with the operation of the Internet, BGP includes
    an authentication scheme for security.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: BGP使用传输控制协议（TCP）作为可靠的传输协议，以便可以利用该协议的许多连接设置和维护功能。这也意味着BGP不需要担心诸如消息排序、确认或丢失传输等问题。由于未经授权的BGP消息可能会对互联网的运行造成破坏，因此BGP包括一个用于安全性的身份验证方案。
- en: Note
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*BGP maintains backward compatibility with the older exterior routing protocol,
    EGP*.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '*BGP与较老的外部路由协议EGP保持向后兼容*。'
- en: BGP Topology
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP拓扑
- en: 'In the preceding section, I boiled down the function of BGP into this summary:
    the exchange of network reachability information between ASes of routers and networks,
    and the determination of routes from this information. The actual method that
    BGP uses to accomplish this, however, is fairly complex.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我将BGP的功能总结如下：在路由器网络的AS之间交换网络可达性信息，并据此确定路由。然而，BGP实际用来完成这一任务的方法相当复杂。
- en: One of the most important characteristics of BGP is its flexibility. The protocol
    can connect together any internetwork of ASes using an arbitrary topology. The
    only requirement is that each AS have at least one router that is able to run
    BGP and that this router connect to at least one other AS's BGP router. Beyond
    that, "the sky is the limit," as they say. BGP can handle a set of ASes connected
    in a full mesh topology (each AS to each other AS), a partial mesh, a chain of
    ASes linked one to the next, or any other configuration. It also handles changes
    to topology that may occur over time.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: BGP最重要的特性之一是其灵活性。该协议可以使用任意拓扑连接任何AS的内部网络。唯一的要求是每个AS至少有一个能够运行BGP的路由器，并且该路由器至少连接到一个其他AS的BGP路由器。除此之外，“天高任鸟飞”，正如他们所说。BGP可以处理一组以全网状拓扑（每个AS连接到每个其他AS）、部分网状、AS链（一个AS链接到下一个AS）或其他任何配置连接的AS。它还可以处理随时间可能发生的拓扑变化。
- en: Another important assumption that BGP makes is that it doesn't know anything
    about what happens within the AS. This is an important prerequisite to the notion
    of an AS being autonomous—it has its own internal topology and uses its own choice
    of routing protocols to determine routes. BGP just takes the information conveyed
    to it from the AS and shares it with other ASes.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: BGP做出的另一个重要假设是它对AS内部发生的事情一无所知。这是AS自主性的一个重要前提——它有自己的内部拓扑并使用自己的选择的路由协议来确定路由。BGP只是从AS接收到的信息，并将其与其他AS共享。
- en: BGP Speakers, Router Roles, Neighbors, and Peers
  id: totrans-651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP发言人、路由器角色、邻居和对等体
- en: Creating a BGP internetwork begins with the designation of certain routers in
    each AS as ones that will run the protocol. In BGP parlance, these are called
    *BGP speakers*, since they speak the BGP language. A protocol can reasonably be
    called a language, but I have not encountered this notion of a speaker in any
    other protocol, so it's somewhat interesting terminology.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 创建BGP内部网络始于在每个AS中指定某些路由器作为将运行该协议的路由器。在BGP术语中，这些被称为*BGP发言人*，因为它们使用BGP语言。一个协议可以合理地被称为一种语言，但我还没有在其他任何协议中遇到过这种发言人的概念，所以这是一个相当有趣的术语。
- en: An AS can contain many routers that are connected in an arbitrary topology.
    We can draw a distinction between routers in an AS that are connected only to
    other routers within the AS versus those that connect to other ASes. Routers in
    the former group are usually called *internal routers*, while those in the latter
    group are called *border routers* in BGP (as well as similar names in other protocols;
    for example, in OSPF they are called *boundary routers*).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 一个AS可以包含许多以任意拓扑连接的路由器。我们可以区分AS中仅连接到AS内其他路由器的路由器与连接到其他AS的路由器。前者组中的路由器通常被称为*内部路由器*，而后者组中的路由器在BGP（以及其他协议中的类似名称；例如，在OSPF中它们被称为*边界路由器*）中被称为*边界路由器*。
- en: The notion of a border is the basis for the name of the BGP itself. To actually
    create the BGP internetwork, the BGP speakers bordering each AS are physically
    connected to one or more BGP speakers in other ASes, in whatever topology the
    internetwork designer decrees. When a BGP speaker in one AS is linked to a BGP
    speaker in another AS, they are deemed *neighbors*. The direct connection between
    them allows them to exchange information about the ASes of which they are a part.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 边界这个概念是BGP（边界网关协议）名称的基础。要实际创建BGP内部网，每个AS（自治系统）边界的BGP发言人需要物理连接到其他AS中的一个或多个BGP发言人，无论内部网设计者指定了何种拓扑结构。当一个AS中的BGP发言人与另一个AS中的BGP发言人生成连接时，它们被认为是*邻居*。它们之间的直接连接使得它们能够交换关于它们所属AS的信息。
- en: Most BGP speakers will be connected to more than one other speaker. This provides
    both greater efficiency in the form of more direct paths to different networks
    and redundancy to allow the internetwork to cope with either device or connection
    failures. It is possible (and in many cases, likely) for a BGP speaker to have
    neighbor relationships with other BGP speakers both within its own AS and outside
    its AS. A neighbor within the AS is called an *internal peer*, while a neighbor
    outside the AS is an *external peer*. BGP between internal peers is sometimes
    called *Internal BGP (IBGP);* use of the protocol between external peers is *External
    BGP (EBGP)*. The two are similar, but differ in certain areas, especially path
    attributes and route selection. You can see an example of BGP topology and the
    designation of internal and external peers in [Figure 40-1](ch40s02.html#sample_bgp_topology_and_designations
    "Figure 40-1. Sample BGP topology and designations").
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数BGP发言人将连接到多个其他发言人。这既提供了更多直接路径到不同网络的更高效率，也提供了冗余，以便内部网能够应对设备或连接故障。一个BGP发言人与其他BGP发言人建立邻居关系，既可能在其自己的AS内部，也可能在其AS外部。AS内部的邻居被称为*内部对等体*，而AS外部的邻居被称为*外部对等体*。内部对等体之间的BGP有时被称为*内部BGP
    (IBGP)*；外部对等体之间协议的使用被称为*外部BGP (EBGP)*。这两个协议相似，但在某些领域有所不同，尤其是在路径属性和路由选择方面。您可以在[图40-1](ch40s02.html#sample_bgp_topology_and_designations
    "图40-1. 样本BGP拓扑和指定")中看到一个BGP拓扑和内部与外部对等体的指定示例。
- en: This diagram is a variation on [Figure 37-1](ch37.html#tcpip_autonomous_system_as_routing_archi
    "Figure 37-1. TCP/IP autonomous system (AS) routing architecture This diagram
    shows a simplified Internet organized into three ASes, each of which is managed
    independently from the others. Communication within each AS is done using an interior
    routing protocol chosen by that AS's administrators (thin links). Communication
    between ASes must be done using a common exterior routing protocol (thick links).
    Internal routers are shown in lighter text, and border routers are shown in black
    text.") in [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL
    CONCEPTS"). It shows the names used by BGP to refer to different types of routers
    and ASes. Internal routers are shown in faint type, while border routers are in
    bold type. BGP speakers that communicate within an AS are internal peers, while
    those that communicate between ASes are external peers. This highly simplified
    internetwork shows two stub ASes, both of which only connect to the multihomed
    AS 2\. A peer connection between BGP speakers can be either a direct link using
    some form of layer 2 technology or an indirect link using TCP. This allows the
    BGP speakers to establish BGP sessions and then exchange routing information,
    using the messaging system you will see later in this chapter. It also is the
    means by which actual end-user traffic moves between ASes. External peers are
    normally connected directly, while internal peers are often linked indirectly.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是[第37章](ch37.html "第37章. 关键路由协议概念概述")中[图37-1](ch37.html#tcpip_autonomous_system_as_routing_archi
    "图37-1. TCP/IP自治系统（AS）路由架构 此图显示了一个简化的互联网，由三个AS组成，每个AS都独立于其他AS进行管理。每个AS内的通信使用该AS管理员选择的内部路由协议（细线）。AS之间的通信必须使用一个通用的外部路由协议（粗线）。内部路由器以较浅的文字显示，边界路由器以黑色文字显示。")的一个变体。它显示了BGP用于指代不同类型路由器和AS的名称。内部路由器以较淡的文字显示，而边界路由器以粗体显示。在一个AS内进行通信的BGP发言人是内部对等体，而在AS之间进行通信的是外部对等体。这个高度简化的内部网显示了两个只有连接到多宿主AS
    2的端点AS。BGP发言人之间的对等连接可以是使用某种形式的第2层技术的直接链路，也可以是使用TCP的间接链路。这允许BGP发言人在本章后面部分看到的报文系统中建立BGP会话并交换路由信息。它也是实际用户流量在AS之间移动的手段。外部对等体通常直接连接，而内部对等体通常间接连接。
- en: You will see in a moment that the method in which ASes are connected has an
    important impact on the overall function of the internetwork and how traffic is
    carried on it.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到AS连接的方式对互联网的整体功能和流量在其上的传输方式有重要影响。
- en: '![Sample BGP topology and designations](httpatomoreillycomsourcenostarchimages288067.png.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![样本BGP拓扑和命名](httpatomoreillycomsourcenostarchimages288067.png.jpg)'
- en: Figure 40-1. Sample BGP topology and designations
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 图40-1. 样本BGP拓扑和命名
- en: Tip
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Each router configured to use BGP is called a BGP *speaker*;
    these devices exchange route information using the BGP *messaging system*. Routers
    that connect only to other routers in the same AS are called *internal routers*,
    while those that connect to other ASes are *border routers*. Neighboring BGP speakers
    in the same AS are called *internal peers*, while those in different ASes are
    *external peers*.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 配置为使用BGP的每个路由器称为BGP **发言人**；这些设备使用BGP **消息系统**交换路由信息。仅连接到同一AS内其他路由器的路由器称为**内部路由器**，而连接到其他AS的路由器称为**边界路由器**。同一AS中的相邻BGP发言者称为**内部对等体**，而不同AS中的称为**外部对等体**。'
- en: BGP AS Types, Traffic Flows, and Routing Policies
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP AS类型、流量和路由策略
- en: When we connect ASes together to form an internetwork, the paths between AS
    border routers form the conduit by which messages move from one AS to another.
    It is very important that the flow of messages between ASes be carefully controlled.
    Depending on circumstances, we may wish to limit or even prohibit certain types
    of messages from going to or from a certain AS. These decisions in turn have a
    direct impact on BGP route determination.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将自治系统（AS）连接起来形成一个互联网时，AS边界路由器之间的路径形成了消息从一个AS移动到另一个AS的通道。仔细控制AS之间的消息流动非常重要。根据情况，我们可能希望限制或甚至禁止某些类型的消息进入或离开某个AS。这些决定反过来又直接影响BGP路由的确定。
- en: BGP Traffic Flow and Traffic Types
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP流量和流量类型
- en: The flow of messages in an internetwork is sometimes collectively called *traffic*.
    This term presents a good analogy, because we can consider the matter of traffic
    flow control in a BGP internetwork in much the same way that we do the streets
    of a city. You have probably seen signs on residential streets that say "No Through
    Traffic" or "Local Traffic Only." These are attempts to control the flow of traffic
    over those streets. A more extreme example of this would be a street in the neighborhood
    where I used to live, where a barricade was intentionally erected in the middle
    to turn a busy through street into a pair of dead ends. Again, the goal was traffic
    control.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网中的消息流动有时统称为**流量**。这个术语提供了一个很好的类比，因为我们可以以与城市街道相同的方式考虑BGP互联网中的流量控制问题。你可能见过住宅街道上的标志，上面写着“禁止通过交通”或“仅限本地交通”。这些都是试图控制那些街道上交通流动的尝试。一个更极端的例子是我以前住的那个社区中的一条街道，其中在中间故意设置了一个路障，将繁忙的通过街道变成一对死胡同。再次强调，目标是交通控制。
- en: 'These measures highlight a key distinction between local traffic and through
    traffic in a neighborhood. The very same categorization is important in BGP, as
    shown here:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这些措施突出了本地流量和邻域中通过流量之间的关键区别。正如这里所示，这种分类在BGP中同样重要：
- en: '**Local Traffic** Traffic carried within an AS that either originated in that
    same AS *or* is intended to be delivered within that AS. This is like local traffic
    on a street.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地流量** 在AS内部携带的流量，要么起源于该AS，要么打算在AS内部交付。这就像街道上的本地交通。'
- en: '**Transit Traffic** Traffic that was generated outside that AS and is intended
    to be delivered outside the AS. This is like through traffic on streets.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**转接流量** 在该AS外部生成并打算在AS外部交付的流量。这就像街道上的通过流量。'
- en: BGP AS Types
  id: totrans-669
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP AS类型
- en: 'In the previous section, I discussed the distinction between internal routers
    and border (or boundary) routers in an AS. We can make a similar distinction between
    different types of ASes, based on how they are interconnected in the overall BGP
    topology. There are two main types of ASes:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我讨论了AS内部路由器和边界（或边界）路由器之间的区别。我们可以根据它们在整体BGP拓扑中的互联方式，在AS的不同类型之间做出类似的区分。主要有两种类型的AS：
- en: '**Stub AS** This is an AS that is connected to only one other AS. It is comparable
    to a cul-de-sac (dead-end street) in a road analogy; usually, only vehicles coming
    from or going to houses on the street will be found on that street.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '**末端AS** 这是一个只连接到另一个AS的AS。在道路类比中，它相当于一个死胡同（死胡同街道）；通常，只有来自或前往该街道上房屋的车辆才会出现在那条街道上。'
- en: '**Multihomed AS** This is an AS that is connected to two or more other ASes.
    It is comparable to a through street in the road analogy, because it is possible
    that vehicles may enter the street and pass through it, without stopping at any
    of the street''s houses.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**多宿主 AS** 这是一个连接到两个或更多其他 AS 的 AS。在道路类比中，它相当于一条过境街道，因为车辆可能进入街道并穿过它，而不在任何街道房屋处停车。'
- en: In the example BGP internetwork in [Figure 40-1](ch40s02.html#sample_bgp_topology_and_designations
    "Figure 40-1. Sample BGP topology and designations"), I have linked border routers
    in AS 2 to both AS 1 and AS 3\. While traffic from AS 2 can flow both to and from
    AS 1 and AS 3, it is possible that traffic from AS 1 may also flow to AS 3 and
    vice versa. AS 2 acts as the "through street" for these datagrams.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例 BGP 内部网络 [图 40-1](ch40s02.html#sample_bgp_topology_and_designations "图 40-1.
    示例 BGP 拓扑和标识") 中，我已经将 AS 2 的边界路由器链接到 AS 1 和 AS 3。虽然 AS 2 的流量可以流向 AS 1 和 AS 3，但也可能存在
    AS 1 的流量流向 AS 3 以及相反的情况。AS 2 作为这些数据报的“过境街道”。
- en: BGP AS Routing Policies
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP AS 路由策略
- en: 'The reason why BGP makes a distinction between traffic types and AS types is
    the same reason why it is done on the streets: Many folks have a dim view of through
    traffic. In a neighborhood, everyone wants to be able to get from their homes
    to anywhere they need to go in the city, but they don''t want a lot of other people
    using their streets. Similarly, every AS must use at least one other AS to communicate
    with distant ASes, but many are less than enthusiastic about being a conduit for
    a lot of external traffic.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: BGP 区分流量类型和 AS 类型的原因与在街道上这样做的原因相同：许多人对外来交通持保留态度。在社区中，每个人都希望能够从家中到达城市中他们需要去的地方，但他们不希望很多人使用他们的街道。同样，每个
    AS 都必须至少使用另一个 AS 与远程 AS 进行通信，但许多人并不热衷于成为大量外部交通的通道。
- en: 'This reluctance really does make sense in many cases, either in the case of
    a neighborhood or in the case of BGP. Having many cars and trucks on a residential
    street can be a problem in a number of ways: safety issues, wear and tear on the
    road, pollution, and so forth. Similarly, if a multihomed AS was forced to carry
    all transit traffic that other ASes want to send to it, it might become overloaded.'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 这种犹豫在许多情况下确实是有道理的，无论是社区的情况还是 BGP 的情况。许多汽车和卡车在住宅街道上可能会带来多种问题：安全问题、道路磨损、污染等等。同样，如果一个多宿主
    AS 被迫携带其他 AS 想要发送给它的所有过境交通，它可能会过载。
- en: 'To provide control over the carrying of transit traffic, BGP allows an AS to
    set up and use routing policies. These are sets of rules that govern how an AS
    will handle transit traffic. A great deal of flexibility exists in how an AS decides
    to handle transit traffic. Some of the many options include the following:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制过境交通的携带，BGP 允许一个自治系统（AS）设置和使用路由策略。这些是一系列规则，用于规定一个 AS 如何处理过境交通。在 AS 如何处理过境交通方面存在很大的灵活性。许多选项中包括以下内容：
- en: '**No Transit Policy** An AS can have a policy that it will not handle transit
    traffic at all.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '**无过境策略** 一个 AS 可以有一个策略，即完全不处理过境交通。'
- en: '**Restricted AS Transit Policy** An AS may allow for the handling of traffic
    from certain ASes but not others. In this case, it tells the ASes it will handle
    that they may send it traffic, but does not say this to the others.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**受限 AS 过境策略** 一个 AS 可以允许处理来自某些 AS 的流量，但不允许处理其他 AS 的流量。在这种情况下，它告诉那些它将处理流量的
    AS，它们可以发送流量给它，但不对其他 AS 说同样的话。'
- en: '**Criteria-Based Transit Policy** An AS may use a number of different criteria
    to decide whether to allow transit traffic. For example, it might allow transit
    traffic only during certain times or only when it has enough spare capacity.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于标准的过境策略** 一个 AS 可以使用多个不同的标准来决定是否允许过境交通。例如，它可能只在特定时间或在其有足够的额外容量时允许过境交通。'
- en: Note
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*An AS that is willing to carry transit traffic is sometimes called a* transit
    AS.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '*愿意携带过境交通的 AS 有时被称为过境 AS*。'
- en: In a similar manner, policies can be set that control how an AS will have its
    own traffic handled by other ASes. A stub AS will always connect to the internetwork
    as a whole using the single AS to which it connects. A multihomed AS, however,
    may have policies that influence route selection by specifying the conditions
    under which one AS should be used over another. These policies may be based on
    considerations of security (if one connecting AS is deemed more secure than another),
    performance (if one AS is faster than another), reliability, or other factors.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，可以设置策略来控制一个AS如何由其他AS处理其自身的流量。一个末端AS将始终作为一个整体连接到互联网，使用它所连接的单个AS。然而，一个多宿主AS可能有政策，通过指定在什么条件下应该使用一个AS而不是另一个AS来影响路由选择。这些政策可能基于安全（如果一个连接的AS被认为比另一个更安全）、性能（如果一个AS比另一个更快）、可靠性或其他因素。
- en: Tip
  id: totrans-684
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** One important issue in BGP is how to handle the flow of traffic
    between ASes. Each AS in a BGP internetwork is either a *stub AS* if it connects
    to only one other AS, or a *multihomed AS* if it connects to two or more others.
    BGP allows the administrators of a multihomed AS to establish routing policies
    that specify under what conditions the AS is willing to handle transit traffic
    (messages sent over the AS whose source and destination are both external to that
    AS).'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在BGP中，一个重要的问题是处理AS之间的流量流动。在BGP互联网中的每个AS要么是只连接到另一个AS的*末端AS*，要么是连接到两个或更多其他AS的*多宿主AS*。BGP允许多宿主AS的管理员建立路由策略，这些策略指定在什么条件下AS愿意处理中继流量（源和目的地都位于该AS之外的消息）。'
- en: Issues with Routing Policies and Internetwork Design
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由策略和互联网设计问题
- en: What would happen to a city if every street only allowed local traffic? It would
    be pretty hard to get around. Of course this problem never occurs in well-designed
    cities, because traffic planners understand the dual need for connectivity and
    through-traffic avoidance in residential areas. Cities are laid out in a somewhat
    hierarchical fashion, so local traffic funnels to thoroughfares intended specifically
    to carry nonlocal traffic.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个街道只允许本地交通，一个城市会怎样？这将非常难以出行。当然，这个问题在精心设计的城市中永远不会发生，因为交通规划者理解了在住宅区连接性和避免中继交通的双重需求。城市以某种层次结构的方式布局，因此本地交通汇集到专门用于携带非本地交通的干道。
- en: The same basic situation exists in an internetwork. It wouldn't work very well
    if every AS declared that it was not interested in carrying transit traffic! Usually,
    internetworks are designed so that certain ASes are intended to carry large amounts
    of transit traffic. This is typically the function of high-speed, high-capacity
    backbone connections that serve other ASes as customers. An AS will usually carry
    another AS's traffic only if arrangements have been made to allow this.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网中存在相同的基本情况。如果每个自治系统（AS）都声明它不感兴趣于携带中继流量，那么这不会运作得很好！通常，互联网的设计是为了让某些AS有意承担大量中继流量。这通常是高速、高容量骨干连接的功能，这些连接作为其他AS的客户。一个AS通常只会在有安排允许这样做的情况下携带另一个AS的流量。
- en: BGP Route Storage and Advertisement
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP路由存储和公告
- en: The job of the BGP is to facilitate the exchange of route information between
    BGP devices so that each router can determine efficient routes to each of the
    networks on an IP internetwork. This means that descriptions of routes are the
    key data that BGP devices work with. Every BGP speaker is responsible for managing
    route descriptions according to specific guidelines established in the BGP standards.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: BGP（边界网关协议）的职责是促进BGP设备之间路由信息的交换，以便每个路由器都能确定到达IP互联网上每个网络的效率最高的路由。这意味着路由描述是BGP设备处理的关键数据。每个BGP发言人都有责任根据BGP标准中确立的具体指南管理路由描述。
- en: BGP Route Information Management Functions
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP路由信息管理功能
- en: 'Conceptually, the overall activity of route information management can be considered
    to encompass four main tasks:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，路由信息管理的整体活动可以被认为是包括四个主要任务：
- en: '**Route Storage** Each BGP stores information about how to reach networks in
    a set of special databases. It also uses databases to hold routing information
    received from other devices.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由存储** 每个BGP在一系列特殊数据库中存储如何到达网络的信息。它还使用数据库来保存从其他设备接收到的路由信息。'
- en: '**Route Update** When a BGP device receives an Update message from one of its
    peers, it must decide how to use this information. Special techniques are applied
    to determine when and how to use the information received from peers to properly
    update the device''s knowledge of routes.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由更新** 当BGP设备从其对等体之一接收到更新消息时，它必须决定如何使用这些信息。应用特殊技术来确定何时以及如何使用从对等体接收到的信息来正确更新设备对路由的了解。'
- en: '**Route Selection** Each BGP uses the information in its route databases to
    select good routes to each network on the internetwork.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由选择** 每个BGP使用其路由数据库中的信息来选择互联网上每个网络的良好路由。'
- en: '**Route Advertisement** Each BGP speaker regularly tells its peers what it
    knows about various networks and methods to reach them. This is called *route
    advertisement* and is accomplished using BGP Update messages. You''ll learn more
    about these messages later in the chapter.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由通告** 每个BGP发言人定期告诉其对等体它所了解的关于各种网络及其到达方法。这被称为*路由通告*，并使用BGP更新消息来完成。你将在本章后面了解更多关于这些消息的内容。'
- en: BGP Routing Information Bases (RIBs)
  id: totrans-697
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP路由信息库（RIBs）
- en: The heart of BGP's system of routing information management and handling is
    the database where routes are stored. This database is collectively called the
    *Routing Information Base (RIB)*, but it is not actually a monolithic entity.
    It is composed of three separate sections that are used by a BGP speaker to handle
    the input and output of routing information. Two of these sections consist of
    several individual parts, or copies.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: BGP路由信息管理和处理系统的核心是存储路由的数据库。这个数据库统称为*路由信息库（RIB）*，但实际上它不是一个单一的整体。它由三个独立的部分组成，这些部分被BGP发言人用来处理路由信息的输入和输出。其中两个部分由几个单独的部分或副本组成。
- en: 'The three RIB sections (using the cryptic names given them by the BGP standards)
    are as follows:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 三个RIB部分（使用BGP标准给它们起的神秘名称）如下：
- en: '**Adj-RIBs-In** A set of input database parts that holds information about
    routes received from peer BGP speakers.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adj-RIBs-In** 一组输入数据库部分，包含从对等BGP发言人接收到的路由信息。'
- en: '**Loc-RIB** The local RIB. This is the core database that stores routes that
    have been selected by this BGP device and are considered valid to it.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '**Loc-RIB** 本地RIB。这是核心数据库，存储了由该BGP设备选定的路由，并被认为是有效的。'
- en: '**Adj-RIBs-Out** A set of output database parts that holds information about
    routes that this BGP device has selected to be disseminated to its peers.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adj-RIBs-Out** 一组输出数据库部分，包含有关该BGP设备选定要传播给其对等体的路由的信息。'
- en: Thus, the RIB can be considered either a single database or a set of related
    databases, depending on how you look at it. (The previous divisions are conceptual
    in nature; the entire RIB can be implemented as a single database with an internal
    structure representing the different components, or implemented as separate databases.)
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据你的视角，RIB可以被视为一个单独的数据库或一系列相关数据库。（之前的划分是概念性的；整个RIB可以作为一个具有表示不同组件的内部结构的单一数据库实现，或者作为单独的数据库实现。）
- en: The RIB is a fairly complex data structure, not just because of this multisection
    structure, but also because BGP devices store considerably more information about
    routes than simpler routing protocols. Routes are also called *paths* in BGP,
    and the detailed descriptions of them are stored in the form of special BGP path
    attributes, which we will examine shortly.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: RIB是一个相当复杂的数据结构，不仅因为这种多部分结构，还因为BGP设备存储了比简单路由协议更多的路由信息。在BGP中，路由也称为*路径*，它们的详细描述以特殊BGP路径属性的形式存储，我们将在稍后进行考察。
- en: The three sections of the RIB are the mechanism by which information flow is
    managed in a BGP speaker. Data received from Update messages transmitted by peer
    BGP speakers is held in the Adj-RIBs-In, with each Adj-RIB-In holding input from
    one peer. This data is then analyzed and appropriate portions of it are selected
    to update the Loc-RIB, which is the main database of routes this BGP speaker is
    using. On a regular basis, information from the Loc-RIB is placed into the Adj-RIBs-Out
    to be sent to other peers using Update messages. This information flow is accomplished
    as part of the system of route update, selection, and advertisement known as the
    BGP decision process, which I'll discuss in the "BGP Route Determination and the
    BGP Decision Process" section later in this chapter.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: RIB的三个部分是BGP发言人管理信息流的方式。从对等BGP发言人通过更新消息传输的数据被保存在Adj-RIBs-In中，每个Adj-RIB-In保存来自一个对等体的输入。然后分析这些数据，并从中选择适当的部分来更新Loc-RIB，这是该BGP发言人正在使用的路由的主要数据库。定期地，Loc-RIB中的信息被放入Adj-RIBs-Out中，通过更新消息发送给其他对等体。这种信息流是通过称为BGP决策过程的系统的一部分来完成的，即路由更新、选择和广告，我将在本章后面的“BGP路由确定和BGP决策过程”部分中讨论。
- en: Tip
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The routine operation of BGP requires BGP speakers to store,
    update, select, and advertise routing information. The central data structure
    used for this purpose is the *BGP Routing Information Base (RIB)*. The RIB actually
    consists of three sections: a set of input databases *(Adj-RIBs-In)* that hold
    routing information received from peers; a local database *(Loc-RIB)* that contains
    the router''s current routes; and a set of output databases *(Adj-RIBs-Out)* used
    by the router to send its routing information to other routers.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP的常规操作需要BGP发言人存储、更新、选择和广告路由信息。用于此目的的中心数据结构是*BGP路由信息库（RIB）*。实际上，RIB由三个部分组成：一组输入数据库*(Adj-RIBs-In)*，它保存从对等体接收到的路由信息；一个本地数据库*(Loc-RIB)*，它包含路由器的当前路由；以及一组输出数据库*(Adj-RIBs-Out)*，路由器使用这些数据库将其路由信息发送到其他路由器。'
- en: BGP Path Attributes and Algorithm Overview
  id: totrans-708
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP路径属性和算法概述
- en: Routing protocols that use a distance-vector algorithm, such as RIP, are relatively
    simple in large part because the information each device stores about each route
    is itself simple. Each router only knows that it can reach a network at a specific
    cost through a particular next-hop router. It doesn't have knowledge of the route
    that datagrams will take to reach any of these networks. This level of knowledge
    is simply insufficient for the needs of a protocol like BGP.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 使用距离矢量算法的路由协议，如RIP，在很大一部分上相对简单，因为每个设备存储的关于每条路由的信息本身很简单。每个路由器只知道它可以通过特定的下一跳路由器以特定的成本到达一个网络。它没有关于数据报将如何到达这些网络的任何路由知识。这种知识水平对于像BGP这样的协议的需求来说是不够的。
- en: In order to handle the calculation of efficient, nonlooping routes in an arbitrary
    topology of ASes, we need to know not just that we must get Network N7 to send
    to Router R4, but also the characteristics of the entire path between ourselves
    and Network N7\. By storing this additional information, it is possible to make
    decisions about how to compute and change routes, using knowledge of the entire
    path between a router and a network. Thus, instead of advertising networks in
    terms of a destination and the distance to that destination, BGP devices advertise
    networks as destination addresses and path descriptions to reach those destinations.
    This means BGP uses, instead of a distance-vector algorithm, a *path-vector algorithm*.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理在AS的任意拓扑中计算有效、无环路由的计算，我们需要知道的不只是我们必须将网络N7发送到路由器R4，还包括从我们到网络N7的整个路径的特性。通过存储这些附加信息，我们可以根据路由器与网络之间的整个路径的知识来做出关于如何计算和更改路由的决定。因此，BGP设备不是以目的地和到达该目的地的距离来广告网络，而是广告网络作为目的地地址和到达这些目的地的路径描述。这意味着BGP使用的是*路径矢量算法*，而不是距离矢量算法。
- en: 'Each communication of a reachable network provides considerable information
    about the entire sequence of routers to a destination. Due to this inclusion of
    topology information, path-vector protocols are sometimes described as a combination
    of distance-vector and link-state algorithms. This doesn''t really do them justice,
    however, since they do not function in the same way as either of those algorithm
    types. (If you are interested in additional general information about path-vector
    algorithms, you can find some in RFC 1322, "A Unified Approach to Inter-Domain
    Routing." (Warning: do not read before operating heavy machinery.)'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 可达网络的每次通信都提供了关于到达目的地的整个路由器序列的大量信息。由于包含拓扑信息，路径向量协议有时被描述为距离向量算法和链路状态算法的组合。然而，这并不真正公正，因为它们并不像这两种算法类型那样工作。（如果你对路径向量算法的更多信息感兴趣，可以在RFC
    1322，“跨域路由的统一方法”中找到一些信息。（警告：在操作重型机械之前不要阅读。）
- en: The information about the path to each route is stored in the RIB of each BGP
    speaker in the form of BGP path attributes. These attributes are used to advertise
    routes to networks when BGP devices send out Update messages. The storing, processing,
    sending, and receiving of path attributes is the method by which routers decide
    how to create routes, so understanding them is obviously quite important.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 到每个路由的路径信息以BGP路径属性的形式存储在每个BGP发言人的RIB中。这些属性用于在BGP设备发送更新消息时向网络宣传路由。路径属性的存储、处理、发送和接收是路由器决定如何创建路由的方法，因此理解它们显然非常重要。
- en: There are several different path attributes, each of which describes a particular
    characteristic of a route. Attributes are divided into different categories based
    on their level of importance and specific rules designed to manage their propagation.
    The most important path attributes are called *well-known attributes*; every BGP
    speaker must recognize and process these, but only some are required to be sent
    with every route. Other attributes are optional and may or not be implemented.
    These are further differentiated based on how they are handled when received by
    a device that does not recognize them.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种不同的路径属性，每种属性都描述了路由的特定特征。根据其重要性和特定的管理规则，属性被分为不同的类别。最重要的路径属性被称为*已知属性*；每个BGP发言人都必须识别和处理这些属性，但只有一些需要在每个路由中发送。其他属性是可选的，可能或不实现。这些属性进一步根据它们在由不识别它们的设备接收时的处理方式来区分。
- en: BGP Path Attribute Classes
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP路径属性类别
- en: 'The four formal classifications of path attributes are as follows:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 路径属性的四种正式分类如下：
- en: '**Well-Known Mandatory** These are the most important path attributes. They
    must be included in every route description in Update messages, and must be processed
    by each BGP device receiving them.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**已知强制性** 这些是最重要的路径属性。它们必须包含在更新消息中的每个路由描述中，并且必须由接收它们的每个BGP设备进行处理。'
- en: '**Well-Known Discretionary** A BGP device, if received, must recognize these
    path attributes, but they may or may not be included in an Update message. Thus,
    they are optional for a sender of information, but mandatory for a receiver to
    process.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**已知任意性** 如果收到，BGP设备必须识别这些路径属性，但它们可能包含在更新消息中，也可能不包含。因此，对于信息发送者来说，它们是可选的，但对于信息接收者来说，它们是必须处理的。'
- en: '**Optional Transitive** These path attributes may be recognized by a BGP router
    and may be included in an Update message. They must be passed on to other BGP
    speakers when the route is advertised, even if received by a device that does
    not recognize the attribute.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选传递性** 这些路径属性可能被BGP路由器识别，并可能包含在更新消息中。在宣传路由时，即使由不识别该属性的设备接收，也必须传递给其他BGP发言者。'
- en: '**Optional Nontransitive** Optional attributes that may be recognized by a
    BGP device and may be included in an Update message. If received by a device that
    does not recognize the attribute, it is dropped and not passed on to the next
    router.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选非传递性** 可选属性可能被BGP设备识别，并可能包含在更新消息中。如果被不识别该属性的设备接收，则会被丢弃，不会传递给下一个路由器。'
- en: Tip
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Unlike simpler routing protocols that store only limited information
    about how to reach a network, BGP stores detailed information about complete routes
    to various networks. This information takes the form of *path attributes* that
    describe various characteristics of a path (route) through the ASes that connect
    a router to a destination network.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 与仅存储有限关于如何到达网络信息的简单路由协议不同，BGP存储了关于到达各种网络的完整路由的详细信息。这些信息以*路径属性*的形式存在，描述了通过连接路由器到目的网络连接的AS的各种特征。'
- en: Note
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As you might imagine, all well-known attributes are by definition transitive—they
    must be passed on from one BGP speaker to the next*.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如你可能想象的那样，所有已知的属性在定义上都是传递性的——它们必须从一台BGP发言人传递到下一台*。'
- en: BGP Path Attribute Characteristics
  id: totrans-724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP路径属性特征
- en: '[Table 40-3](ch40s04.html#summary_of_bgp_path_attributes "Table 40-3. Summary
    of BGP Path Attributes") provides a summary of the characteristics of each of
    the most common BGP path attributes used to describe the route to a destination.
    It also provides a summary of the Attribute Type code assigned to each characteristic
    in BGP Update messages.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '[表40-3](ch40s04.html#summary_of_bgp_path_attributes "表40-3. BGP路径属性摘要") 提供了描述到目的地路由的每个最常见BGP路径属性的特征摘要。它还提供了分配给BGP更新消息中每个特征的属性类型代码的摘要。'
- en: Table 40-3. Summary of BGP Path Attributes
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-3. BGP路径属性摘要
- en: '| BGP Path Attribute | Classification | Attribute Type Value | Description
    |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| BGP路径属性 | 分类 | 属性类型 值 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Origin | Well-Known Mandatory | 1 | Specifies the origin of the path information.
    This attribute indicates whether the path came originally from an interior routing
    protocol, the older exterior routing protocol, or some other source. |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '| 起源 | 已知强制 | 1 | 指定路径信息的来源。此属性指示路径最初是否来自内部路由协议、较老的外部路由协议或其他来源。|'
- en: '| AS_Path | Well-Known Mandatory | 2 | A list of AS numbers that describes
    the sequence of ASes through which this route description has passed. This is
    a critically important attribute, since it contains the actual path of ASes to
    the network. It is used to calculate routes and to detect routing loops. |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| AS路径 | 已知强制 | 2 | 描述通过该路由描述已通过的AS序列的AS号码列表。这是一个至关重要的属性，因为它包含到达网络的实际AS路径。它用于计算路由和检测路由循环。|'
- en: '| Next_Hop | Well-Known Mandatory | 3 | The next-hop router to be used to reach
    this destination. |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| 下一个跃点 | 已知强制 | 3 | 用于到达此目的地的下一个跃点路由器。|'
- en: '| Multi_Exit_Disc (MED) | Optional Non-Transitive | 4 | When a path includes
    multiple exit or entry points to an AS, this value may be used as a metric to
    discriminate between them (that is, choose one exit or entry point over the others).
    |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| 多出口度量（MED） | 可选非传递 | 4 | 当路径包含多个进入或离开AS的出口或入口点时，此值可以用作区分它们的度量（即，选择一个出口或入口点而不是其他）。|'
- en: '| Local_Pref | Well-Known Discretionary | 5 | Used in communication between
    BGP speakers in the same AS to indicate the level of preference for a particular
    route. |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| 本地优先级 | 已知任意 | 5 | 用于同一AS内BGP发言人间通信，以指示对特定路由的优先级水平。|'
- en: '| Atomic_Aggregate | Well-Known Discretionary | 6 | In certain circumstances,
    a BGP speaker may receive a set of overlapping routes whereby one is more specific
    than the other. For example, consider a route to the network 34.15.67.0/24 and
    to the network 34.15.67.0/26\. The latter network is a subset of the former, which
    makes it more specific. If the BGP speaker uses the less-specific route (in this
    case, 34.15.67.0/24), it sets this path attribute to a value of 1 to indicate
    that this was done. |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| 原子聚合 | 已知任意 | 6 | 在某些情况下，BGP发言人可能会接收到一组重叠的路由，其中一个是比另一个更具体的。例如，考虑一个到网络34.15.67.0/24和网络34.15.67.0/26的路由。后者是前者的子集，使其更具体。如果BGP发言人使用较不具体的路由（在这种情况下，34.15.67.0/24），它将此路径属性设置为1，以指示已这样做。|'
- en: '| Aggregator | Optional Transitive | 7 | Contains the AS number and BGP ID
    of the router that performed route aggregation; used for troubleshooting. |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| 聚合器 | 可选传递 | 7 | 包含执行路由聚合的路由器的AS号码和BGP ID；用于故障排除。|'
- en: Some of these path attributes are straightforward; others are fairly cryptic
    and probably confusing. Delving into any more detail on the path attributes leads
    us into a full-blown description of detailed inter-AS route calculations. We'll
    look at that to some degree in the next section.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径属性中的一些是直接的；其他则是相当晦涩难懂，可能令人困惑。深入探讨路径属性将引导我们进入详细描述跨AS路由计算的全面描述。我们将在下一节中在一定程度上探讨这一点。
- en: BGP Route Determination and the BGP Decision Process
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP路由确定和BGP决策过程
- en: 'You have now looked at the fundamentals of how BGP devices store and manage
    information about routes to networks. This included an overview of the four route
    information management activities performed by BGP speakers: route storage, update,
    selection, and advertisement. Route storage is the function of the RIB in each
    BGP speaker. Path attributes are the mechanism by which BGP stores details about
    routes and also describes those details to BGP peers.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了BGP设备如何存储和管理网络路由信息的基本原理。这包括了对BGP发言人执行的四个路由信息管理活动的概述：路由存储、更新、选择和公告。路由存储是每个BGP发言人的RIB的功能。路径属性是BGP存储关于路由的详细信息并描述这些细节给BGP对等体的机制。
- en: BGP Decision Process Phases
  id: totrans-739
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP决策过程阶段
- en: 'As you have seen, the RIB also contains sections for holding input information
    received from BGP peers and for holding output information that each BGP device
    wants to send to those peers. The functions of route update, selection, and advertisement
    are concerned with analyzing this input information. They also decide what to
    include in the local database, update that database, and then choose what routes
    to send from it to peer devices. In BGP, a mechanism called the *decision process*
    is responsible for these tasks. It consists of three overall phases:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，RIB还包含用于存储从BGP对等体接收到的输入信息的部分，以及用于存储每个BGP设备想要发送给这些对等体的输出信息。路由更新、选择和公告的功能涉及分析这些输入信息。它们还决定在本地数据库中包含什么，更新该数据库，然后从其中选择要发送给对等设备的路由。在BGP中，一个称为*决策过程*的机制负责这些任务。它包括三个总体阶段：
- en: '**Phase 1** Each route received from a BGP speaker in a neighboring AS is analyzed
    and assigned a preference level. The routes are then ranked according to preference
    and the best one for each network advertised to other BGP speakers within the
    AS.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一阶段** 从相邻AS中的BGP发言人所接收到的每个路由都会被分析并分配一个优先级。然后，根据优先级对这些路由进行排序，并选择每个AS内向其他BGP发言人公告的最佳路由。'
- en: '**Phase 2** The best route for each destination is selected from the incoming
    data based on preference levels, and it''s used to update the local routing information
    base (the Loc-RIB).'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二阶段** 根据优先级从传入数据中选择每个目的地的最佳路由，并使用它来更新本地路由信息库（Loc-RIB）。'
- en: '**Phase 3** Routes in the Loc-RIB are selected to be sent to neighboring BGP
    speakers in other ASes.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三阶段** 从Loc-RIB中选择路由发送到其他AS中的相邻BGP发言人。'
- en: Criteria for Assigning Preferences to Routes
  id: totrans-744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配路由优先级的标准
- en: 'Obviously, if a BGP speaker only knows of a single route to a network, it will
    install and use that route (assuming there are no problems with it). The assigning
    of preferences among routes becomes important only when more than one route has
    been received by a BGP speaker for a particular network. Preferences can be determined
    based on a number of different criteria. The following are a few typical ones:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果BGP发言人只知道一个网络的单一路由，它将安装并使用该路由（假设没有问题）。当BGP发言人收到特定网络的多条路由时，分配路由优先级才变得重要。优先级可以根据许多不同的标准确定。以下是一些典型的标准：
- en: The number of ASes between the router and the network (fewer generally being
    better).
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器与网络之间的AS数量（通常越少越好）。
- en: The existence of certain policies that may make certain routes unusable; for
    example, a route may pass through an AS that as the BGP speaker is not willing
    to trust with its data.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在某些可能使某些路由不可用的策略；例如，一个路由可能穿过一个BGP发言人不愿意与其数据信任的AS。
- en: The origin of the path—that is, where it came from.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径的起源——即它从何而来。
- en: In the case where a set of routes to the same network are all calculated to
    have the same preference, a tie-breaking scheme is used to select from among them.
    Additional logic is used to handle special circumstances, such as the case of
    overlapping networks (see the description of the Atomic_Aggregate path attribute
    in [Table 40-3](ch40s04.html#summary_of_bgp_path_attributes "Table 40-3. Summary
    of BGP Path Attributes") for an example of this).
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在一组到达同一网络的路由都被计算为具有相同优先级的情况下，将使用一种决断方案从中选择。额外的逻辑用于处理特殊情况，例如重叠网络的情况（例如，在[表40-3](ch40s04.html#summary_of_bgp_path_attributes
    "表40-3. BGP路径属性摘要")中对Atomic_Aggregate路径属性的描述中可以看到这种情况的例子）。
- en: The selection of routes for dissemination to other routers in phase 3 is based
    on a rather complex algorithm that I cannot explain adequately here. Route advertisement
    is guided by the routing policies I discussed earlier in this chapter. Different
    rules are used to select routes for advertising to internal peers compared to
    external peers.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3阶段向其他路由器传播路由的选择基于一个相当复杂的算法，我无法在这里充分解释。路由公告受到我在本章前面讨论的路由策略的指导。与外部对等体相比，用于向内部对等体公告路由的规则不同。
- en: Tip
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The method used by a BGP speaker to determine what new routes
    to accept from its peers and what routes to advertise back them is called the
    *BGP decision process*. It is a complex algorithm in three phases that involves
    the computation of the best route based on both preexisting and incoming path
    information.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP发言人用来确定从其对等体接受哪些新路由以及向其公告哪些路由的方法被称为*BGP决策过程*。这是一个涉及基于现有路径信息和传入路径信息计算最佳路由的复杂算法，分为三个阶段。'
- en: Limitations on BGP's Ability to Select Efficient Routes
  id: totrans-753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP选择高效路由的能力的限制
- en: When considering route selection, it's very important to remember that BGP is
    a routing protocol that operates at the inter-AS level. Thus, routes are chosen
    between ASes, not at the level of individual routers within an AS. So, for example,
    when BGP stores information about the path to a network, it stores it as a sequence
    of ASes, not a sequence of specific routers.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑路由选择时，非常重要的一点是要记住BGP是一种在AS（自治系统）之间运行的路由协议。因此，路由是在AS之间选择的，而不是在AS内部单个路由器级别上选择的。所以，例如，当BGP存储关于到达某个网络的路径信息时，它将其存储为一系列AS，而不是一系列特定的路由器。
- en: 'BGP cannot deal with individual routers in an AS because, by definition, the
    details of what happens within an AS are supposed to be hidden from the outside
    world. It doesn''t know the structure of ASes outside its own. This has an important
    implication for how BGP selects routes: BGP cannot guarantee that it will pick
    the fastest, lowest-cost route to every network. It can select a route that minimizes
    the number of ASes that lie between itself and a particular network, but, of course,
    ASes are not all the same. Some ASes are large and consist of many slow links;
    others are small and fast. Choosing a route through two of the latter types of
    AS will be better than choosing a route through one of the former, but BGP can''t
    know that. Policies can be used to influence AS selection to some extent, but
    in general, since BGP doesn''t know what happens in an AS, it cannot guarantee
    the efficiency of a route overall. (Incidentally, this is the reason why there
    is no general cost or distance path attribute in BGP.)'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: BGP无法处理AS内的单个路由器，因为根据定义，AS内部发生的事情的细节应该对外界保密。它不知道其自身之外AS的结构。这对BGP选择路由有重要影响：BGP不能保证它会为每个网络选择最快、成本最低的路由。它可以选择一个最小化其与特定网络之间AS数量的路由，但当然，AS并不都是一样的。一些AS很大，由许多慢速链路组成；而另一些AS则较小且速度快。选择通过两种后一种类型的AS的路由将比选择通过前一种类型的AS的路由更好，但BGP无法知道这一点。可以使用策略在一定程度上影响AS选择，但总的来说，由于BGP不知道AS内部发生的事情，它不能保证路由的整体效率。（顺便说一句，这也是为什么BGP中没有一般成本或距离路径属性的原因。）
- en: Tip
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** As an exterior routing protocol, BGP operates at the AS level.
    Its routes are calculated based on paths between ASes, not individual routers.
    Since BGP, by definition, does not know the internal structure of routers within
    an AS, it cannot know for certain the cost to send a datagram across a given AS.
    This means that BGP cannot always guarantee that it will select the absolute lowest-cost
    route between any two networks.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 作为一种外部路由协议，BGP在AS级别运行。它的路由是基于AS之间的路径计算的，而不是单个路由器。由于BGP，根据定义，不知道AS内路由器的内部结构，因此它不能确定在给定的AS中发送数据报的成本。这意味着BGP不能总是保证它将选择任何两个网络之间的绝对最低成本的路径。'
- en: Originating New Routes and Withdrawing Unreachable Routes
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发起新的路由和撤回不可达的路由
- en: Naturally, a facility exists to allow BGP speakers to originate new routes to
    networks. A BGP speaker may obtain knowledge about a new route from an interior
    routing protocol on an AS to which it is directly attached, and then it may choose
    to share this information with other ASes. It will create a new entry in its RIB
    for this network and then send information about it out to other BGP peers.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，存在一种设施，允许BGP发言人发起到达网络的新的路由。BGP发言人可以从直接连接的AS上的内部路由协议中获得有关新路由的知识，然后它可以选择与其他AS共享此信息。它将为该网络创建一个新的条目并将其发送给其他BGP对等体。
- en: BGP also includes a mechanism for advertising routes it cannot reach. These
    are called unfeasible or withdrawn routes and are mentioned in Update messages
    to indicate that a router can no longer reach the specific network.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: BGP还包括一种机制来宣传它无法到达的路由。这些被称为不可行或撤回的路由，并在Update消息中提及，以表明路由器无法再到达特定的网络。
- en: BGP General Operation and Messaging
  id: totrans-761
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP的一般操作和消息
- en: In the previous sections, you have seen how BGP stores information about routes
    and uses it to determine paths to various networks. Let's now take a high-level
    look at how BGP operates in general terms. Like many other protocols covered in
    this book, BGP's operation can be described primarily in the form of messaging.
    The use of messages is the means by which route information is communicated between
    BGP peers. This eventually allows the knowledge of how to reach networks to spread
    throughout the entire internetwork.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经看到了BGP如何存储有关路由的信息，以及它是如何使用这些信息来确定到达各种网络的路径。现在，让我们从一般的角度来了解一下BGP的操作。像本书中介绍的其他许多协议一样，BGP的操作主要可以通过消息的形式来描述。消息的使用是BGP对等体之间传递路由信息的手段。这最终使得如何到达网络的知识在整个互联网中传播开来。
- en: Speaker Designation and Connection Establishment
  id: totrans-763
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演讲者指定和连接建立
- en: Before messaging can begin, BGP speakers must be designated and then linked
    together. The BGP standard does not specify how neighboring speakers are determined;
    this must be done outside the protocol. Once accomplished, ASes are connected
    into a BGP-enabled internetwork. Topological linking provides the physical connection
    and the means for datagrams to flow between ASes. At this point, the dance floor
    is prepared, but nobody is dancing; BGP can function but isn't yet in operation.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始消息之前，BGP发言人必须被指定并连接在一起。BGP标准没有指定如何确定相邻发言人；这必须在协议之外完成。一旦完成，AS就被连接到一个启用了BGP的互联网中。拓扑链接提供了物理连接和使数据报在AS之间流动的手段。此时，舞池已经准备好了，但没有人跳舞；BGP可以工作，但尚未开始运行。
- en: BGP operation begins with BGP peers forming a transport protocol connection.
    BGP uses TCP for its reliable transport layer, so the two BGP speakers establish
    a TCP session that remains in place during the course of the subsequent message
    exchange. When this is done, each BGP speaker sends a BGP Open message. This message
    is like an invitation to dance, and it begins the process of setting up the BGP
    link between the devices. In this message, each router identifies itself and its
    AS, and also tells its peer what parameters it would like to use for the link.
    This includes an exchange of authentication parameters. Assuming that each device
    finds the contents of its peer's Open message acceptable, it acknowledges it with
    a Keepalive message, and the BGP session begins.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: BGP的操作从BGP对等体形成传输协议连接开始。BGP使用TCP作为其可靠的传输层，因此两个BGP发言人建立了一个在后续消息交换过程中保持的TCP会话。当这样做之后，每个BGP发言人发送一个BGP
    Open消息。这个消息就像一个舞会邀请，它开始了在设备之间设置BGP链接的过程。在这个消息中，每个路由器都标识了自己及其AS，并告诉其对等体它希望用于链接的参数。这包括认证参数的交换。假设每个设备都认为其对等体的Open消息内容是可以接受的，它将通过Keepalive消息进行确认，然后BGP会话开始。
- en: Under normal circumstances, most BGP speakers will maintain simultaneous sessions
    with more than one other BGP speaker, both within the speaker's own AS and outside
    its AS. Links between ASes are what enable BGP routers to learn how to route through
    the internetwork. Links within the AS are important to ensure that each BGP speaker
    in the AS maintains consistent information.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，大多数 BGP 发言者将与多个其他 BGP 发言者保持同时会话，这些会话既在发言者自己的 AS 内，也在其 AS 外。AS 之间的链接使得
    BGP 路由器能够学习如何在互联网中路由。AS 内部的链接对于确保 AS 中的每个 BGP 发言者保持一致的信息非常重要。
- en: Route Information Exchange
  id: totrans-767
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由信息交换
- en: Assuming the link is initialized, the two peers begin an ongoing process of
    telling each other what they know about networks and how to reach them. Each BGP
    speaker encodes information from its RIBs into BGP Update messages. These messages
    contain lists of known network addresses, as well as information about paths to
    various networks, as described in the form of path attributes, as you have already
    seen. This information is then used for the route determination, as described
    in the preceding section.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 假设链路已初始化，两个对等体开始一个持续的过程，告诉对方他们所了解的网络以及如何到达这些网络。每个 BGP 发言者将其 RIB 中的信息编码成 BGP
    更新消息。这些消息包含已知网络地址列表，以及关于到达各种网络路径的信息，正如您已经看到的，这些信息以路径属性的形式描述。然后，这些信息被用于路由确定，如前所述。
- en: When a link is first set up between two peers, those peers ensure that each
    router holds complete information by exchanging their complete routing tables.
    Subsequently, Update messages are sent. They contain only incremental updates
    about routes that have changed. Exchanging only updated information as needed
    reduces unnecessary bandwidth on the network, thereby making BGP more efficient
    than it would be if it sent full routing table information on a regular basis.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个对等体之间首次建立连接时，这些对等体会通过交换它们的完整路由表来确保每个路由器持有完整的信息。随后，会发送更新消息。这些消息只包含关于已更改路由的增量更新。根据需要仅交换更新信息可以减少网络上的不必要带宽，从而使
    BGP 比如果它定期发送完整的路由表信息更有效率。
- en: Connectivity Maintenance
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连通性维护
- en: The TCP session between BGP speakers can be kept open for a very long time.
    Update messages need to be sent only when changes occur to routes, which are usually
    infrequent. This means many seconds may elapse between the transmission of Update
    messages.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: BGP 之间的 TCP 会话可以保持很长时间开放。只有当路由发生变化时才需要发送更新消息，这些变化通常很少发生。这意味着更新消息的传输之间可能经过许多秒。
- en: To ensure that the peers maintain contact with each other, they both send Keepalive
    messages on a regular basis when they don't have other information to send. These
    are null messages that contain no data and just tell the peer device "I'm still
    here." These messages are sent infrequently—no more often than one per second—but
    regularly enough that the peers won't think the session was interrupted.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保对等体之间保持联系，当它们没有其他信息要发送时，它们都会定期发送 Keepalive 消息。这些是空消息，不包含数据，只是告诉对等设备“我还在这里。”这些消息发送得不太频繁——不超过每秒一次——但足够规律，以至于对等体不会认为会话被中断。
- en: Error Reporting
  id: totrans-773
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误报告
- en: The last type of BGP message is the BGP Notification message. This is an error
    message; it tells a peer that a problem occurred and describes the nature of the
    error condition. After sending a BGP Notification message, the device that sent
    it will terminate the BGP connection between the peers. A new connection will
    then need to be negotiated, possibly after the problem that led to the Notification
    message has been corrected.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种 BGP 消息是 BGP 通知消息。这是一个错误消息；它告诉对等体发生了问题，并描述了错误条件的性质。在发送 BGP 通知消息后，发送该消息的设备将终止对等体之间的
    BGP 连接。然后需要协商一个新的连接，可能是在导致通知消息的问题得到纠正之后。
- en: Tip
  id: totrans-775
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** BGP is implemented through the exchange of four different message
    types between BGP speakers. A BGP session begins with a TCP connection being established
    between two routers and each sending an Open message to the other. BGP Update
    messages are the primary mechanism by which routing information is exchanged between
    devices. Small BGP Keepalive messages are used to maintain communication between
    devices between periods when they need to exchange information. Finally, Notification
    messages are used for problem reporting.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP通过BGP发言人之间交换四种不同的消息类型来实现。BGP会话从两个路由器之间建立TCP连接并相互发送Open消息开始。BGP更新消息是设备之间交换路由信息的主要机制。小的BGP保活消息用于在需要交换信息期间保持设备之间的通信。最后，通知消息用于问题报告。'
- en: BGP Detailed Messaging, Operation, and Message Formats
  id: totrans-777
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP详细消息、操作和消息格式
- en: So far, I have discussed the concepts and general operation of the BGP. To get
    a better understanding of exactly how BGP works, it is helpful to take a detailed
    look at its four different message types—Open, Update, Keepalive, and Notification—and
    how they are used. As we do this, we can examine the fields in each message type,
    so that you can comprehend not just the way that messaging is accomplished, but
    the way that routing data is actually communicated. Let's begin with a description
    of common attributes of BGP message generation and transport, and the general
    format used for all BGP messages.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经讨论了BGP的概念和一般操作。为了更好地理解BGP的确切工作方式，详细查看其四种不同的消息类型——Open（打开）、Update（更新）、Keepalive（保活）和Notification（通知）——以及它们的使用方法是非常有帮助的。在这个过程中，我们可以检查每种消息类型中的字段，以便你不仅能理解消息是如何完成的，还能理解路由数据是如何实际传递的。让我们从描述BGP消息生成和传输的常见属性以及所有BGP消息使用的通用格式开始。
- en: BGP Message Generation and Transport
  id: totrans-779
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP消息生成和传输
- en: Each router running BGP generates messages to implement the various functions
    of the protocol. Some of these messages are created on a regular basis by the
    BGP software during the course of its normal operation. These are generally controlled
    by timers that are set and counted down to cause them to be sent. Other messages
    are sent in response to messages received from BGP peers, possibly after a processing
    step.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行BGP的路由器都会生成消息以实现协议的各种功能。其中一些消息在BGP软件的正常操作过程中定期创建。这些通常由设置和倒计时的计时器控制，以使它们被发送。其他消息是在接收到来自BGP对等体的消息后发送的，可能是在处理步骤之后。
- en: BGP is different from most other routing protocols in that it was designed from
    the start to operate using a reliable method of message delivery. TCP is present
    in the software of every Internet Protocol (IP) router, thereby making it the
    obvious choice for reliable data communication in a TCP/IP Internet, and that's
    what BGP uses. Routing protocols are usually considered part of layer 3, but this
    one runs over a layer 4 protocol, thereby making BGP a good example of why architectural
    models are best used only as a guideline.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他路由协议不同，BGP从一开始就被设计为使用可靠的消息传递方法。TCP存在于每个互联网协议（IP）路由器的软件中，因此在TCP/IP互联网中进行可靠的数据通信时，它显然是最佳选择，这也是BGP所使用的。路由协议通常被认为是第3层的一部分，但这个协议是在第4层协议上运行的，因此BGP是架构模型最好仅作为指南的绝佳例子。
- en: TCP provides numerous advantages to BGP by taking care of most of the details
    of session setup and management, thereby allowing BGP to focus on the data it
    needs to send. TCP takes care of session setup and negotiation, flow control,
    congestion handling, and any necessary retransmissions of lost messages, thereby
    ensuring that messages are received and acknowledged. BGP uses well-known TCP
    port 179 for connections.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: TCP通过处理会话设置和管理的大部分细节，为BGP提供了众多优势，从而使得BGP能够专注于需要发送的数据。TCP负责会话设置和协商、流量控制、拥塞处理以及丢失消息的必要重传，从而确保消息被接收并确认。BGP使用众所周知的TCP端口179进行连接。
- en: BGP General Message Format
  id: totrans-783
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP通用消息格式
- en: The use of TCP also has an interesting impact on the way BGP messages are structured.
    One thing that stands out when you look at the BGP message format (as you will
    see shortly) is that a BGP message can have an odd number of bytes. Most routing
    protocols are sized in units of 4 or 8 bytes, but since TCP sends data as a stream
    of octets, there is no need for BGP messages to break on a 32-bit or 64-bit boundary.
    The other impact is the need of a special Marker field to help ensure that BGP
    messages can be differentiated from each other in the TCP stream (more about this
    in a moment).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 的使用也对 BGP 消息的结构方式产生了有趣的影响。当你查看 BGP 消息格式（你很快就会看到）时，一个突出的问题是 BGP 消息可以具有奇数个字节。大多数路由协议以
    4 或 8 字节为单位进行尺寸划分，但由于 TCP 以八位组流的形式发送数据，因此 BGP 消息不需要在 32 位或 64 位边界上断开。另一个影响是需要一个特殊的标记字段来帮助确保
    BGP 消息可以在 TCP 流中区分开来（稍后将有更多关于这个问题的讨论）。
- en: Like most messaging protocols, BGP uses a common message format for each of
    its four message types. Each BGP message is conceptually divided into a header
    and a body (called the *data portion* in the BGP standard). The header has three
    fields and is fixed in length at 19 bytes. The body is variable in length and
    is omitted entirely in Keepalive messages, since it is not needed for them.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数消息协议一样，BGP 为其四种消息类型中的每一种都使用一个通用的消息格式。每个 BGP 消息在概念上分为一个头部和一个主体（在 BGP 标准中称为
    *数据部分*）。头部有三个字段，长度固定为 19 字节。主体长度可变，在 Keepalive 消息中完全省略，因为它们不需要它。
- en: The general format for all BGP message types is shown in [Table 40-4](ch40s07.html#bgp_general_message_format-id001
    "Table 40-4. BGP General Message Format") and illustrated in [Figure 40-2](ch40s07.html#bgp_general_message_format-id002
    "Figure 40-2. BGP general message format").
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 BGP 消息类型的通用格式显示在 [表 40-4](ch40s07.html#bgp_general_message_format-id001 "表
    40-4. BGP 通用消息格式") 中，并在 [图 40-2](ch40s07.html#bgp_general_message_format-id002
    "图 40-2. BGP 通用消息格式") 中说明。
- en: Table 40-4. BGP General Message Format
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 表 40-4. BGP 通用消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| 标记 | 16 | 每条 BGP 消息开始处的这个大字段用于同步和认证。|'
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. The minimum value of this field is 19 for a Keepalive message;
    it may be as high as 4096. |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 2 | 消息的总长度（以字节为单位），包括头部字段。此字段的最低值为 19（用于 Keepalive 消息）；可能高达 4096。|'
- en: '| Type | 1 | Indicates the BGP message type:1 = Open2 = Update3 = Notification4
    = Keepalive |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 表示 BGP 消息类型：1 = Open2 = Update3 = Notification4 = Keepalive |'
- en: '| Message Body/Data Portion | Variable | Contains the specific fields used
    to implement each message type for Open, Update, and Notification messages. |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| 消息体/数据部分 | 可变 | 包含用于实现每种消息类型（Open、Update 和 Notification）的具体字段。|'
- en: '![BGP general message format](httpatomoreillycomsourcenostarchimages288069.png)'
  id: totrans-794
  prefs: []
  type: TYPE_IMG
  zh: '![BGP 通用消息格式](httpatomoreillycomsourcenostarchimages288069.png)'
- en: Figure 40-2. BGP general message format
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 图 40-2. BGP 通用消息格式
- en: The Marker field is the most interesting one in the BGP message format. It is
    used for both synchronization and authentication. BGP uses a single TCP session
    to send many messages in a row. TCP is a stream-oriented transport protocol that
    sends bytes across the link without any knowledge of what the bytes represent.
    This means that the protocol using TCP is responsible for deciding where the line
    is drawn between data units—in this case, BGP messages.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 标记字段是 BGP 消息格式中最有趣的一个。它用于同步和认证。BGP 使用单个 TCP 会话连续发送多个消息。TCP 是一种面向流的传输协议，它发送字节穿越链路，而不了解这些字节代表什么。这意味着使用
    TCP 的协议负责决定数据单元之间的界限在哪里——在这种情况下，BGP 消息。
- en: Normally, the Length field tells each BGP device where to draw the line between
    the end of one message and the start of the next. However, it is possible that,
    due to various conditions, a device might lose track of where the message boundary
    is. The Marker field is filled with a recognizable pattern that clearly marks
    the start of each message; BGP peers keep synchronized by looking for that pattern.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，长度字段告诉每个 BGP 设备在哪里划分一条线，从一条消息的结束到下一条消息的开始。然而，由于各种条件，设备可能会失去对消息边界的跟踪。标记字段填充了一个可识别的模式，清楚地标记了每条消息的开始；BGP
    对等体通过寻找这个模式来保持同步。
- en: Before a BGP connection is established, the Marker field is filled with all
    ones. Thus, this is the pattern used for Open messages. Once a BGP session is
    negotiated, if agreement is reached on an authentication method between the two
    devices, the Marker field takes on the additional role of authentication. Instead
    of looking for a Marker field containing all ones, BGP devices look for a pattern
    generated using the agreed-upon authentication method. Detection of this pattern
    simultaneously synchronizes the devices and ensures that messages are authentic.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立 BGP 连接之前，标记字段被填充为全 1。因此，这是 Open 消息使用的模式。一旦协商了 BGP 会话，如果两台设备之间就认证方法达成一致，标记字段将承担额外的认证角色。BGP
    设备不再寻找包含全 1 的标记字段，而是寻找使用约定的认证方法生成的模式。检测到这个模式同时同步设备并确保消息是真实的。
- en: In extreme cases, BGP peers may be unable to maintain synchronization, and if
    so, a Notification message is generated and the session is closed. This will also
    happen if the Marker field contains the wrong data when authentication is enabled.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在极端情况下，BGP 对等体可能无法保持同步，如果是这样，将生成一个通知消息并关闭会话。如果启用认证时标记字段包含错误数据，也会发生这种情况。
- en: Tip
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** All four BGP message types use a general message format that
    contains three fixed header fields—Marker, Length, and Type—and room for a message
    body that differs for each message type. The large Marker field is used to denote
    the start of a new BGP message, and it is also used to facilitate the BGP authentication
    method.'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 所有四种 BGP 消息类型都使用一种通用的消息格式，该格式包含三个固定头部字段——标记、长度和类型——以及用于不同消息类型的不同消息体的空间。大的标记字段用于表示新
    BGP 消息的开始，并且它还用于简化 BGP 认证方法。'
- en: 'BGP Connection Establishment: Open Messages'
  id: totrans-802
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP 连接建立：Open 消息
- en: Before a BGP session can be used to exchange routing information, a connection
    must first be established between BGP peers. This process begins with the creation
    of a TCP connection between the devices. Once this is done, the BGP devices will
    attempt to create a BGP session by exchanging BGP Open messages.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以使用 BGP 会话交换路由信息之前，必须在 BGP 对等体之间建立连接。这个过程从设备之间创建 TCP 连接开始。一旦完成，BGP 设备将通过交换
    BGP Open 消息来尝试创建 BGP 会话。
- en: BGP Open Message Functions
  id: totrans-804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP 开放消息功能
- en: The Open message has two main purposes. The first is identification and initiation
    of a link between the two devices; it allows one peer to tell the other, "I am
    a BGP speaker named X on AS Y, and I want to start exchanging BGP information
    with you." The second is the negotiation of session parameters. These are the
    terms by which the BGP session will be conducted. One important parameter negotiated
    using Open messages is the method that each device wants to use for authentication.
    The importance of BGP means that authentication is essential in order to prevent
    bad information or a malicious person from disrupting routes.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: Open 消息有两个主要目的。第一个是识别和初始化两个设备之间的连接；它允许一个对等体告诉另一个，“我是一个名为 X 的 BGP 说话人，在 AS Y
    上，我想与你开始交换 BGP 信息。”第二个是协商会话参数。这些是 BGP 会话将如何进行的条款。使用 Open 消息协商的一个重要参数是每个设备想要用于认证的方法。BGP
    的重要性意味着为了防止不良信息或恶意人员破坏路由，认证是必不可少的。
- en: Each BGP receiving an Open message processes it. If the message's contents are
    acceptable, including the parameters the other device wants to use, it responds
    with a Keepalive message as an acknowledgment. Each peer must send an Open message
    and receive a Keepalive acknowledgment for the BGP link to be initialized. If
    either is not willing to accept the terms of the Open message, the link is not
    established. In that case, a Notification message may be sent to convey the nature
    of the problem.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接收 Open 消息的 BGP 都会处理它。如果消息的内容是可以接受的，包括其他设备想要使用的参数，它将以确认消息的形式响应。每个对等体必须发送一个
    Open 消息并接收一个 Keepalive 确认消息，以便初始化 BGP 连接。如果任一对等体不愿意接受 Open 消息的条款，则不会建立连接。在这种情况下，可能会发送一个通知消息来传达问题的性质。
- en: BGP Open Message Format
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP 开放消息格式
- en: The specific format for BGP Open messages is shown in [Table 40-5](ch40s07.html#bgp_open_message_format-id001
    "Table 40-5. BGP Open Message Format") and [Figure 40-3](ch40s07.html#bgp_open_message_format-id002
    "Figure 40-3. BGP Open message format").
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: BGP Open 消息的具体格式显示在[表 40-5](ch40s07.html#bgp_open_message_format-id001 "表 40-5.
    BGP Open 消息格式")和[图 40-3](ch40s07.html#bgp_open_message_format-id002 "图 40-3. BGP
    Open 消息格式")中。
- en: Table 40-5. BGP Open Message Format
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 表 40-5. BGP 开放消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '| Field Name | Size (Bytes) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '| Marker | 16 | 每个BGP消息开头的这个大字段用于同步和认证。|'
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Open messages are variable in length. |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '| Length | 2 | 消息的总长度（以字节为单位），包括头部字段。Open消息的长度是可变的。|'
- en: '| Type | 1 | BGP message type; value is 1 for Open messages. |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '| Type | 1 | BGP消息类型；值为1表示Open消息。|'
- en: '| Version | 1 | Indicates the BGP version the sender of the Open message is
    using. This field allows devices to reject connections with devices using versions
    that they may not be capable of understanding. The current value is 4, for BGP-4,
    and is used by most, if not all, current BGP implementations. |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '| Version | 1 | 表示发送Open消息的发送者使用的BGP版本。此字段允许设备拒绝与使用它们可能无法理解的版本的设备建立连接。当前值为4，用于BGP-4，并被大多数，如果不是所有，当前的BGP实现所使用。|'
- en: '| My Autonomous System | 2 | Identifies the AS number of the sender of the
    Open message. AS numbers are centrally managed across the Internet in a manner
    similar to how IP addresses are administered. |'
  id: totrans-816
  prefs: []
  type: TYPE_TB
  zh: '| My Autonomous System | 2 | 识别发送Open消息的发送者的AS号。AS号在互联网上以类似于IP地址管理的方式集中管理。|'
- en: '| Hold Time | 2 | The number of seconds that this device proposes to use for
    the BGP hold timer, which specifies how long a BGP peer will allow the connection
    to be left silent between receipt of BGP messages. A BGP device may refuse a connection
    if it doesn''t like the value that its peer is suggesting; usually, however, the
    two devices agree to use the smaller of the values suggested by each device. The
    value must be at least 3 seconds, or 0\. If 0, this specifies that the hold timer
    is not used. See the Keepalive message discussion later in this chapter for more
    on how the hold timer is used. |'
  id: totrans-817
  prefs: []
  type: TYPE_TB
  zh: '| Hold Time | 2 | 此设备提议用于BGP保持计时器的秒数，该计时器指定BGP对等体允许在接收到BGP消息后连接保持沉默的时间。如果BGP设备不喜欢其对等体建议的值，它可能会拒绝连接；然而，通常两个设备会同意使用每个设备建议的值中的较小者。该值必须至少为3秒，或0。如果为0，则指定不使用保持计时器。有关保持计时器的更多使用信息，请参阅本章后面的Keepalive消息讨论。|'
- en: '| BGP Identifier | 4 | Identifies the specific BGP speaker. You''ll recall
    that IP addresses are associated with interfaces, not devices, so each router
    will have at least two IP addresses. Normally, the BGP identifier is chosen as
    one of these addresses. Once chosen, this identifier is used for all BGP communications
    with BGP peers. This includes BGP peers on the interface from which the identifier
    was chosen, and also BGP peers on other interfaces as well. So, if a BGP speaker
    with two interfaces has addresses IP1 and IP2, it will choose one as its identifier
    and use it on both of its interfaces. |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '| BGP Identifier | 4 | 识别特定的BGP说话者。您会记得，IP地址与接口相关联，而不是与设备相关联，因此每个路由器至少有两个IP地址。通常，BGP标识符被选择为这些地址之一。一旦选择，此标识符就用于与BGP对等体的所有BGP通信。这包括从选择标识符的接口上的BGP对等体，以及其他接口上的BGP对等体。因此，如果一个具有两个接口的BGP说话者有IP1和IP2地址，它将选择其中一个作为其标识符，并在其两个接口上使用它。|'
- en: '| Opt Parm Len | 1 | The number of bytes used for Optional Parameters (see
    the following entry). If 0, no optional parameters are in this message. |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '| Opt Parm Len | 1 | 用于可选参数的字节数（见下一条记录）。如果为0，则此消息中没有可选参数。|'
- en: '| Optional Parameters | Variable | Allows the Open message to communicate any
    number of extra parameters during BGP session setup. Each parameter is encoded
    using a rather standard type/length/value triple, as shown in [Table 40-6](ch40s07.html#bgp_open_message_optional_parameters
    "Table 40-6. BGP Open Message Optional Parameters"). |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '| Optional Parameters | 可变 | 允许Open消息在BGP会话设置期间通信任意数量的额外参数。每个参数都使用一个相当标准的类型/长度/值三元组进行编码，如[表40-6](ch40s07.html#bgp_open_message_optional_parameters
    "表40-6. BGP Open消息可选参数")所示。|'
- en: Table 40-6. BGP Open Message Optional Parameters
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-6. BGP Open消息可选参数
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '| Subfield Name | Size (Bytes) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Parm Type | 1 | Parameter Type: The type of the optional parameter. At present,
    only one value is defined, 1, for Authentication Information. |'
  id: totrans-824
  prefs: []
  type: TYPE_TB
  zh: '| Parm Type | 1 | 参数类型：可选参数的类型。目前只定义了一个值，1，用于认证信息。|'
- en: '| Parm Length | 1 | Parameter Length: Specifies the length of the Parameter
    Value subfield (thus, this value is the length of the entire parameter, less 2).
    |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
  zh: '| Parm Length | 1 | 参数长度：指定参数值子字段的长度（因此，此值是整个参数的长度减去2）。|'
- en: '| Parm Value | Variable | Parameter Value: The value of the parameter being
    communicated. |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
  zh: '| 参数值 | 可变 | 参数值：正在通信的参数的值。 |'
- en: 'BGP Open messages currently use only one optional parameter: Authentication
    Information. Its Parameter Value subfield contains a one-byte Authentication Code
    sub-subfield, which specifies the type of authentication a device wishes to use.
    Following this is a variable-length Authentication Data sub-subfield. The Authentication
    Code specifies how authentication is to be performed, including the meaning of
    the Authentication Data field, and the manner in which Marker fields are to be
    calculated.'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: BGP 开放消息目前仅使用一个可选参数：认证信息。其参数值子字段包含一个字节的认证代码子子字段，指定设备希望使用的认证类型。随后是一个可变长度的认证数据子子字段。认证代码指定了如何执行认证，包括认证数据字段的含义，以及如何计算标记字段。
- en: Tip
  id: totrans-828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** BGP sessions begin with each peer in a connection sending the
    other a BGP Open message. The purpose of this message is to establish contact
    between devices, identify the sender of the message and its AS, and negotiate
    important parameters that dictate how the session will be conducted.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP 会话从连接中的每个对等体向另一个发送 BGP 开放消息开始。此消息的目的是在设备之间建立联系，识别消息的发送者和其 AS，并协商重要的参数，这些参数决定了会话的进行方式。'
- en: 'BGP Route Information Exchange: Update Messages'
  id: totrans-830
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP 路由信息交换：更新消息
- en: Once BGP speakers have made contact and a link has been established using Open
    messages, the devices begin the actual process of exchanging routing information.
    Each BGP router uses the BGP decision process described earlier in this chapter
    to select certain routes to be advertised to its peer. This information is then
    placed into BGP Update messages, which are sent to every BGP device for which
    a session has been established. These messages are the way that network reachability
    knowledge is propagated around the internetwork.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 BGP 说话者建立了联系并使用开放消息建立了链接，设备就开始实际交换路由信息的过程。每个 BGP 路由器使用本章前面描述的 BGP 决策过程来选择某些要通告给其对等体的路由。然后，这些信息被放入
    BGP 更新消息中，这些消息被发送到已建立会话的每个 BGP 设备。这些消息是网络可达性知识在互联网中传播的方式。
- en: '![BGP Open message format](httpatomoreillycomsourcenostarchimages288071.png)'
  id: totrans-832
  prefs: []
  type: TYPE_IMG
  zh: '![BGP 开放消息格式](httpatomoreillycomsourcenostarchimages288071.png)'
- en: Figure 40-3. BGP Open message format
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 图 40-3. BGP 开放消息格式
- en: BGP Update Message Contents
  id: totrans-834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP 更新消息内容
- en: 'Each Update message contains either one or both of the following:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 每个更新消息包含以下一个或两个：
- en: '**Route Advertisement** The characteristics of a single route.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由通告** 单个路由的特性。'
- en: '**Route Withdrawal** A list of networks that are no longer reachable.'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由撤销** 一系列不再可达的网络。'
- en: Only one route can be advertised in an Update message, but several can be withdrawn.
    This is because withdrawing a route is simple; it requires just the address of
    the network for which the route is being removed. In contrast, a route advertisement
    requires a fairly complex set of path attributes to be described, which takes
    up a significant amount of space. (Note that it is possible for an Update message
    to specify only withdrawn routes and not advertise a route at all.)
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 更新消息中只能通告一个路由，但可以撤销多个。这是因为撤销路由很简单；只需要移除路由的网络地址。相比之下，路由通告需要描述一组相当复杂的路径属性，这需要占用相当大的空间。（注意，更新消息可以仅指定撤销的路由，而不通告任何路由。）
- en: BGP Update Message Format
  id: totrans-839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP 更新消息格式
- en: Because of the amount of information it contains and the complexity of that
    information, BGP Update messages use one of the most complicated structures in
    TCP/IP. The basic structure of the message is described in [Table 40-7](ch40s07.html#bgp_update_message_format-id001
    "Table 40-7. BGP Update Message Format") and illustrated in [Figure 40-4](ch40s07.html#bgp_update_message_format_this_diagram_s
    "Figure 40-4. BGP Update message format This diagram shows the complete BGP Update
    message format, including a set of withdrawn routes, path attributes, and NLRI
    entries. The exploded view shows the substructure of the Attribute Type subfield
    of the Path Attributes, as described in Tables Table 40-9 and Table 40-10.").
    As you can see in that table, several of the fields have their own substructure.
    The Path Attributes field has a complex substructure, which I have shown separately
    in other tables.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它包含的信息量及其复杂性，BGP更新消息使用TCP/IP中最复杂的结构之一。消息的基本结构在[表40-7](ch40s07.html#bgp_update_message_format-id001
    "表40-7. BGP更新消息格式")中描述，并在[图40-4](ch40s07.html#bgp_update_message_format_this_diagram_s
    "图40-4. BGP更新消息格式 此图显示了完整的BGP更新消息格式，包括一组退回路由、路径属性和NLRI条目。分解视图显示了路径属性中属性类型子字段的子结构，如表表40-9和表40-10中所述。")中说明。正如您可以从表中看到的，几个字段有自己的子结构。路径属性字段具有复杂的子结构，我在其他表中单独展示了它。
- en: Table 40-7. BGP Update Message Format
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-7. BGP更新消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-842
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-843
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
  zh: '| 标记 | 16 | 每个BGP消息开头的这个大字段用于同步和认证。|'
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Update messages are variable in length. |'
  id: totrans-845
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 2 | 消息的总长度，以字节为单位，包括头部字段。更新消息的长度是可变的。|'
- en: '| Type | 1 | BGP message type; value is 2 for Update messages. |'
  id: totrans-846
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | BGP消息类型；值为2表示更新消息。|'
- en: '| Unfeasible Routes Length | 2 | The length of the Withdrawn Routes field,
    in bytes. If 0, no routes are being withdrawn and the Withdrawn Routes field is
    omitted. |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
  zh: '| 不可行路由长度 | 2 | 退回路由字段长度，以字节为单位。如果为0，则没有路由被退回，并且退回路由字段被省略。|'
- en: '| Withdrawn Routes | Variable | Specifies the addresses of networks for which
    routes are being withdrawn from use. Each address is specified using the two subfields.
    The 1-byte Length field is the number of bits in the IP address Prefix subfield
    that are significant. The variable-length Prefix subfield is the IP address prefix
    of the network whose route is being withdrawn. If the number of bits in the prefix
    is not a multiple of 8, this field is padded with zeros so that it falls on a
    byte boundary. The length of this field is 1 byte if the preceding Length field
    is 8 or less; 2 bytes if it is 9 to 16; 3 bytes if it is 17 to 24; and 4 bytes
    if it is 25 or greater. |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
  zh: '| 退回路由 | 可变 | 指定正在从使用中退回路由的网络地址。每个地址使用两个子字段指定。1字节长度的长度字段是IP地址前缀子字段中有效的位数。可变长度的前缀子字段是正在退回路由的网络的前缀IP地址。如果前缀中的位数不是8的倍数，则此字段用零填充，以便落在字节边界上。如果前一个长度字段为8或更少，则此字段长度为1字节；如果为9到16，则长度为2字节；如果为17到24，则长度为3字节；如果为25或更大，则长度为4字节。|'
- en: '| Total Path Attribute Length | 2 | The length of the Path Attributes field,
    in bytes. If 0, indicates no route is being advertised in this message, so Path
    Attributes and Network Layer Reachability Information are omitted. |'
  id: totrans-849
  prefs: []
  type: TYPE_TB
  zh: '| 总路径属性长度 | 2 | 路径属性字段的长度，以字节为单位。如果为0，表示在此消息中没有广告路由，因此省略路径属性和网络层可达性信息。|'
- en: '| Path Attributes | Variable | Describes the path attributes of the route advertised.
    Since some attributes require more information than others, attributes are described
    using a flexible structure that minimizes message size compared to using fixed
    fields that would often be empty. Unfortunately, it also makes the field structure
    confusing. Each attribute has the subfields shown in [Table 40-8](ch40s07.html#bgp_update_message_path_attributes
    "Table 40-8. BGP Update Message Path Attributes"). |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
  zh: '| 路径属性 | 可变 | 描述广告路由的路径属性。由于某些属性需要比其他属性更多的信息，因此使用灵活的结构来描述属性，以最小化与使用固定字段相比的消息大小，而固定字段通常为空。不幸的是，这也使得字段结构变得复杂。每个属性都有[表40-8](ch40s07.html#bgp_update_message_path_attributes
    "表40-8. BGP更新消息路径属性")中显示的子字段。|'
- en: '| Network Layer Reachability Information (NLRI) | Variable | Contains a list
    of IP address prefixes for the route being advertised. Each address is specified
    using the same general structure as the one used for Withdrawn Routes. The 1-byte
    Length subfield is the number of bits in the Prefix subfield that are significant.
    The variable-length Prefix subfield is the IP address prefix of the network whose
    route is being advertised. If the number of bits in the prefix is not a multiple
    of 8, this field is padded with zeros so that it falls on a byte boundary. The
    length of this field is 1 byte if the preceding Length field is 8 or less; 2 bytes
    if it is 9 to 16; 3 bytes if it is 17 to 24; and 4 bytes if it is25 or greater.
    Unlike most of the other fields in the Update message, the length of the NLRI
    field is not explicitly stated. It is computed from the overall message Length
    field, minus the lengths of the other fields that are explicitly specified. |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
  zh: '| 网络层可达信息 (NLRI) | 可变 | 包含正在宣布的路由的 IP 地址前缀列表。每个地址都使用与用于撤回路由相同的通用结构进行指定。1 字节长度子字段是前缀子字段中有效位数的数量。可变长度前缀子字段是正在宣布路由的网络的前缀
    IP 地址。如果前缀中的位数不是 8 的倍数，则在此字段中填充零，以便它落在字节边界上。如果前面的长度字段为 8 或更少，则此字段长度为 1 字节；如果为
    9 到 16，则长度为 2 字节；如果为 17 到 24，则长度为 3 字节；如果为 25 或更大，则长度为 4 字节。与更新消息中的大多数其他字段不同，NLRI
    字段的长度不是明确声明的。它是从整体消息长度字段中减去其他明确指定的字段长度计算得出的。|'
- en: Table 40-8. BGP Update Message Path Attributes
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 表 40-8. BGP 更新消息路径属性
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Attribute Type | 2 | Defines the type of attribute and describes it. This
    subfield itself has a two-level substructure, with Attribute Type flags and Attribute
    Type codes, so it won''t even fit it here! See Tables [Table 40-9](ch40s07.html#bgp_update_message_attribute_flags
    "Table 40-9. BGP Update Message Attribute Flags") and [Table 40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "Table 40-10. BGP Update Message Attribute Type Codes") for details. |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
  zh: '| 属性类型 | 2 | 定义属性类型并对其进行描述。此子字段本身具有两级子结构，包括属性类型标志和属性类型代码，因此甚至无法在这里全部展示！请参阅表格
    [表 40-9](ch40s07.html#bgp_update_message_attribute_flags "表 40-9. BGP 更新消息属性标志")
    和 [表 40-10](ch40s07.html#bgp_update_message_attribute_type_codes "表 40-10. BGP
    更新消息属性类型代码") 以获取详细信息。|'
- en: '| Attribute Length | 1 or 2 | The length of the attribute in bytes. This field
    is normally 1 byte, thereby allowing for fields with a length up to 255 bytes.
    For longer attributes, the Extended Length flag is set (see [Table 40-9](ch40s07.html#bgp_update_message_attribute_flags
    "Table 40-9. BGP Update Message Attribute Flags")), indicating that this Attribute
    Length field is 2 bytes, for attributes up to 65,535 bytes. |'
  id: totrans-856
  prefs: []
  type: TYPE_TB
  zh: '| 属性长度 | 1 或 2 | 属性的字节数。此字段通常为 1 字节，因此允许字段长度最多为 255 字节。对于更长的属性，设置扩展长度标志（见 [表
    40-9](ch40s07.html#bgp_update_message_attribute_flags "表 40-9. BGP 更新消息属性标志"))，表示此属性长度字段为
    2 字节，对于长度最多为 65,535 字节的属性。|'
- en: '| Attribute Value | Variable | The value of the attribute. The size and meaning
    of this field depends on the type of path attribute. For example, for an Origin
    attribute, it is a single integer value indicating the origin of the route; for
    an AS_Path attribute, this field contains a variable-length list of the ASes in
    the path to the network. |'
  id: totrans-857
  prefs: []
  type: TYPE_TB
  zh: '| 属性值 | 可变 | 属性的值。此字段的大小和含义取决于路径属性的类型。例如，对于起源属性，它是一个表示路由起源的单个整数值；对于 AS_Path
    属性，此字段包含到达网络的路径中 AS 的可变长度列表。|'
- en: '![BGP Update message format This diagram shows the complete BGP Update message
    format, including a set of withdrawn routes, path attributes, and NLRI entries.
    The exploded view shows the substructure of the Attribute Type subfield of the
    Path Attributes, as described in Tables and .](httpatomoreillycomsourcenostarchimages288073.png.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
  zh: '![BGP 更新消息格式 此图显示了完整的 BGP 更新消息格式，包括一组撤回路由、路径属性和 NLRI 条目。分解视图显示了路径属性中属性类型子字段的子结构，如表格和
    . 中所述。](httpatomoreillycomsourcenostarchimages288073.png.jpg)'
- en: Figure 40-4. BGP Update message format This diagram shows the complete BGP Update
    message format, including a set of withdrawn routes, path attributes, and NLRI
    entries. The exploded view shows the substructure of the Attribute Type subfield
    of the Path Attributes, as described in Tables [Table 40-9](ch40s07.html#bgp_update_message_attribute_flags
    "Table 40-9. BGP Update Message Attribute Flags") and [Table 40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "Table 40-10. BGP Update Message Attribute Type Codes").
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 图40-4. BGP更新消息格式此图显示了完整的BGP更新消息格式，包括一组已撤销的路由、路径属性和NLRI条目。分解视图显示了路径属性字段属性类型子字段的子结构，如[表40-9](ch40s07.html#bgp_update_message_attribute_flags
    "表40-9. BGP更新消息属性标志")和[表40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "表40-10. BGP更新消息属性类型代码")中所述。
- en: '[Table 40-9](ch40s07.html#bgp_update_message_attribute_flags "Table 40-9. BGP
    Update Message Attribute Flags") shows the structure of the Attribute Flags sub-subfield
    of the Attribute Type subfield of the Path Attributes field. This subfield contains
    a set of flags that describe the nature of the attribute and how to process it.
    You may need to refer to the path attributes description in the "BGP Path Attributes
    and Algorithm Overview" section earlier in this chapter to make sense of these
    flags.'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '[表40-9](ch40s07.html#bgp_update_message_attribute_flags "表40-9. BGP更新消息属性标志")显示了路径属性字段属性类型子字段的属性标志子子字段的结构。此子字段包含一组标志，用于描述属性的性质以及如何处理它。您可能需要参考本章前面“BGP路径属性和算法概述”部分中的路径属性描述来理解这些标志。'
- en: Table 40-9. BGP Update Message Attribute Flags
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-9. BGP更新消息属性标志
- en: '| Sub-Sub-Subfield Name | Size (Bytes) | Description |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
  zh: '| 子子子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Optional | 1/8 (1 bit) | Set to 1 for optional attributes; 0 for well-known
    attributes. |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '| 可选 | 1/8 (1 bit) | 对于可选属性设置为1；对于已知属性设置为0。 |'
- en: '| Transitive | 1/8 (1 bit) | Set to 1 for optional transitive attributes; 0
    for optional nontransitive attributes. Always set to 1 for well-known attributes.
    |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
  zh: '| 传递 | 1/8 (1 bit) | 对于可选传递属性设置为1；对于可选非传递属性设置为0。对于已知属性始终设置为1。 |'
- en: '| Partial | 1/8 (1 bit) | When 1, indicates that information about an optional
    transitive attribute is partial. This means that since it was optional and transitive,
    one or more of the routers that passed the path along did not implement that attribute
    but was forced to pass it along, so information about it may be missing (not supplied
    by the routers that didn''t recognize it but just passed along). If 0, it means
    information is complete. This bit has meaning only for optional transitive attributes;
    for well-known or nontransitive attributes, it is 0. |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
  zh: '| 部分信息 | 1/8 (1 bit) | 当为1时，表示有关可选传递属性的信息是部分信息。这意味着由于它是可选的且传递的，所以经过路径的其中一个或多个路由器没有实现该属性，但被迫传递它，因此关于它的信息可能缺失（未由未识别它的路由器提供，但只是传递）。如果为0，则表示信息是完整的。此位仅对可选传递属性有意义；对于已知或非传递属性，它为0。
    |'
- en: '| Extended Length | 1/8 (1 bit) | Set to 1 for long attributes to indicate
    that the Attribute Length field is 2 bytes in size. Normally 0, meaning the Attribute
    Length field is a single byte. |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
  zh: '| 扩展长度 | 1/8 (1 bit) | 对于长属性设置为1，以指示属性长度字段大小为2字节。通常为0，表示属性长度字段为单字节。 |'
- en: '| Reserved | 4/8 (4 bits) | Set to 0 and ignored. |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4/8 (4 bits) | 设置为0并忽略。 |'
- en: The Attribute Type Code sub-subfield of the Attribute Type subfield of the Path
    Attributes field contains a number that identifies the attribute type. [Table 40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "Table 40-10. BGP Update Message Attribute Type Codes") shows the current values.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 路径属性字段属性类型子字段的属性类型子子字段包含一个数字，用于标识属性类型。[表40-10](ch40s07.html#bgp_update_message_attribute_type_codes
    "表40-10. BGP更新消息属性类型代码")显示了当前值。
- en: Table 40-10. BGP Update Message Attribute Type Codes
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-10. BGP更新消息属性类型代码
- en: '| Value | Attribute Type |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 属性类型 |'
- en: '| --- | --- |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Origin |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Origin |'
- en: '| 2 | AS_Path |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '| 2 | AS_Path |'
- en: '| 3 | Next_Hop |'
  id: totrans-875
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Next_Hop |'
- en: '| 4 | Multi_Exit_Disc (MED) |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Multi_Exit_Disc (MED) |'
- en: '| 5 | Local_Pref |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Local_Pref |'
- en: '| 6 | Atomic_Aggregate |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Atomic_Aggregate |'
- en: '| 7 | Aggregator |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '| 7 | Aggregator |'
- en: It may seem confusing that there can be more than one prefix in the Network
    Layer Reachability Information (NLRI) field, even though I said earlier that an
    Update message advertises only one route. There is, in fact, no inconsistency
    here. A single route may be associated with more than one networks; to put it
    another way, multiple networks may have the same path and path attributes. In
    that case, specifying multiple network prefixes in the same Update message is
    more efficient than generating a new one for each network.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我之前说过更新消息只广告一条路由，但似乎在网络层可达信息（NLRI）字段中可以有多于一个前缀，这可能会让人感到困惑。实际上，这里并没有不一致之处。单条路由可能关联多个网络；换句话说，多个网络可能有相同的路径和路径属性。在这种情况下，在同一个更新消息中指定多个网络前缀比为每个网络生成一个新的更有效。
- en: Tip
  id: totrans-881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The most important message type in BGP is the Update message,
    which is used to send detailed information about routes between BGP devices. It
    uses a complex structure that allows a BGP speaker to efficiently specify new
    routes, update existing ones, and withdraw routes that are no longer valid. Each
    message may include the full description of one existing route and may also withdraw
    from use a list of multiple routes.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP 中最重要的消息类型是更新消息，它用于发送 BGP 设备之间路由的详细信息。它使用一种复杂的结构，允许 BGP 说话者有效地指定新路由、更新现有路由以及撤回不再有效的路由。每条消息可能包括一条现有路由的完整描述，也可能撤回多条路由的使用。'
- en: 'BGP Connectivity Maintenance: Keepalive Messages'
  id: totrans-883
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP 连通性维护：保活消息
- en: Once a BGP connection is established using Open messages, BGP peers will initially
    use Update messages to send each other a large amount of routing information.
    They will then settle into a routine in which the BGP session is maintained, but
    Update messages are sent only when needed. Since these updates correspond to route
    changes, and route changes are normally infrequent, this means many seconds may
    elapse between the receipt of consecutive Update messages.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用 Open 消息建立 BGP 连接，BGP 对等体最初将使用更新消息相互发送大量路由信息。然后，它们将进入一个常规流程，维护 BGP 会话，但仅在需要时发送更新消息。由于这些更新对应于路由变化，而路由变化通常是很少发生的，这意味着在连续的更新消息之间可能经过许多秒。
- en: The BGP Keepalive Message Interval
  id: totrans-885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP 保活消息间隔
- en: Hold Timer and While a BGP peer is waiting to hear the next Update message,
    it remains sort of like a person who has been put on hold on the telephone. Now
    seconds may not seem like much to us, but to a computer, they are a very long
    time. Like you, a BGP speaker that is put on hold for too long might become impatient
    and might start to wonder if maybe the other guy hung up. Computers don't get
    offended at being put on hold, but they might wonder if perhaps a problem arose
    that led to the connection being interrupted.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 保持计时器和当 BGP 对等体等待接收下一个更新消息时，它就像是被电话中的某人挂起一样。现在对我们来说，几秒钟可能不算什么，但对计算机来说，它们是非常长的时间。就像你一样，被挂起太久的
    BGP 说话者可能会变得不耐烦，并开始怀疑对方是否挂断了电话。计算机不会因为被挂起而生气，但它们可能会怀疑是否出现了导致连接中断的问题。
- en: To keep track of how long it has been on hold, each BGP device maintains a special
    *hold timer*. This hold timer is set to an initial value each time its peer sends
    a BGP message. The timer then counts down until the next message is received,
    and then it is reset. If the hold timer ever expires, the connection is assumed
    to have been interrupted and the BGP session is terminated.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪已保持多长时间，每个 BGP 设备维护一个特殊的 *保持计时器*。每次其对等体发送 BGP 消息时，都会将其设置为初始值。计时器随后倒计时，直到收到下一个消息，然后重置。如果保持计时器过期，则假定连接已被中断，BGP
    会话被终止。
- en: The length of the hold timer is negotiated as part of session setup using Open
    messages. It must be at least three seconds long, or may be negotiated as a value
    of zero. If zero, the hold timer is not used; this means the devices are infinitely
    patient and don't care how much time elapses between messages.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 保持计时器的长度作为会话设置的一部分通过 Open 消息协商。它必须至少为三秒长，或者可以协商为零的值。如果为零，则不使用保持计时器；这意味着设备有无限的耐心，不关心消息之间经过多少时间。
- en: 'To ensure that the timer doesn''t expire even when no Update messages need
    to be sent for a long while, each peer periodically sends a BGP Keepalive message.
    The name says it all: The message just keeps the BGP connection alive. The rate
    at which Keepalive messages is sent depends on the implementation, but the standard
    recommends that they be sent with an interval of one-third the value of the hold
    timer. So if the hold timer has a value of three seconds, each peer sends a Keepalive
    message every second (unless it needs to send some other message type in that
    second). To prevent excess bandwidth use, Keepalive messages must be sent no more
    often than once per second, so that is the minimum interval, even if the hold
    timer is shorter than three seconds.'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保计时器不会在长时间内不需要发送更新消息的情况下超时，每个对等方会定期发送BGP Keepalive消息。正如其名所示：该消息只是保持BGP连接活跃。Keepalive消息的发送速率取决于实现方式，但标准建议它们以保持计时器值的三分之一为间隔发送。因此，如果保持计时器的值为三秒，则每个对等方每秒发送一个Keepalive消息（除非在该秒需要发送其他类型的消息）。为了防止过度使用带宽，Keepalive消息必须每秒发送一次，因此这是最小间隔，即使保持计时器的值小于三秒。
- en: BGP Keepalive Message Format
  id: totrans-890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP Keepalive消息格式
- en: The point of a Keepalive message is the message itself; there's no data to be
    communicated. In fact, we want to keep the message short and sweet. Thus, it is
    really a dummy message that contains only a BGP header—a nice change after that
    incredibly long Update message format! The format of the Keepalive message is
    shown in [Table 40-11](ch40s07.html#bgp_keepalive_message_format-id001 "Table 40-11. BGP
    Keepalive Message Format") and [Figure 40-5](ch40s07.html#bgp_keepalive_message_format-id002
    "Figure 40-5. BGP Keepalive message format").
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: Keepalive消息的重点是消息本身；没有要传达的数据。实际上，我们希望消息简短明了。因此，它实际上是一个只包含BGP头部（在那么长的更新消息格式之后是一种很好的变化）的虚拟消息。Keepalive消息的格式在[表40-11](ch40s07.html#bgp_keepalive_message_format-id001
    "表40-11. BGP Keepalive消息格式")和[图40-5](ch40s07.html#bgp_keepalive_message_format-id002
    "图40-5. BGP Keepalive消息格式")中显示。
- en: Table 40-11. BGP Keepalive Message Format
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-11. BGP Keepalive消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '| 标记 | 16 | 每个BGP消息开头的这个大字段用于同步和认证。 |'
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Keepalive messages are fixed in length at 19 bytes. |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
  zh: '| Length | 2 | 消息的总长度（字节），包括头部字段。Keepalive消息的长度固定为19字节。 |'
- en: '| Type | 1 | BGP message type; value is 4 for Keepalive messages. |'
  id: totrans-897
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | BGP消息类型；对于Keepalive消息，值为4。 |'
- en: '![BGP Keepalive message format](httpatomoreillycomsourcenostarchimages288075.png)'
  id: totrans-898
  prefs: []
  type: TYPE_IMG
  zh: '![BGP Keepalive消息格式](httpatomoreillycomsourcenostarchimages288075.png)'
- en: Figure 40-5. BGP Keepalive message format
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 图40-5. BGP Keepalive消息格式
- en: 'There is also a special use for Keepalive messages: They acknowledge the receipt
    of a valid Open message during the initial BGP session setup.'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: Keepalive消息也有特殊用途：它们确认在初始BGP会话设置期间收到了有效的Open消息。
- en: Tip
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** BGP Keepalive messages are sent periodically during idle periods
    when no real information needs to be sent between connected BGP speakers. They
    serve only to keep the session alive, and thus contain only a BGP header and no
    data.'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP Keepalive消息在空闲期间定期发送，在这些期间不需要在连接的BGP发言人之间发送实际信息。它们仅用于保持会话活跃，因此只包含BGP头部而没有数据。'
- en: 'BGP Error Reporting: Notification Messages'
  id: totrans-903
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP错误报告：通知消息
- en: Once established, a BGP session will remain open for a considerable period of
    time, allowing routing information to be exchanged between devices on a regular
    basis. During the course of operation, certain error conditions may crop up that
    may interfere with normal communication between BGP peers.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立，BGP会话将保持开启状态一段时间，允许设备之间定期交换路由信息。在操作过程中，可能会出现某些错误条件，可能会干扰BGP对等方之间的正常通信。
- en: BGP Notification Message Functions
  id: totrans-905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP通知消息功能
- en: Some of the error conditions that arise are serious enough that the BGP session
    must be terminated. When this occurs, the device detecting the error will inform
    its peer of the nature of the problem by sending it a BGP Notification message,
    and then it will close the connection.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 出现的一些错误条件足够严重，以至于必须终止BGP会话。当这种情况发生时，检测到错误的设备将通过发送BGP通知消息来告知其对等方的错误性质，然后关闭连接。
- en: Of course, having someone tell you, "I found an error, so I quit" is not of
    much value. Therefore, the BGP Notification message contains a number of fields
    that provide information about the nature of the error that caused the message
    to be sent. This includes a set of primary error codes as well as subcodes within
    some of these error codes. Depending on the nature of the error, an additional
    data field may also be included to aid in diagnosing the problem.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有人告诉你“我发现了一个错误，所以我退出了”并没有太大的价值。因此，BGP 通知消息包含多个字段，提供有关导致消息发送的错误性质的信息。这包括一组主要错误代码以及一些错误代码中的子代码。根据错误的性质，还可能包含一个额外的数据字段，以帮助诊断问题。
- en: In addition to the use of Notification messages to convey the occurrence of
    an error, this message type is also used for other purposes. For example, one
    may be sent if two devices cannot agree on how to negotiate a session, which isn't,
    strictly speaking, an error. A Notification message is also used to allow a device
    to tear down a BGP session for reasons that have nothing to do with an error.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用通知消息来传达错误的发生之外，此消息类型还用于其他目的。例如，如果两个设备无法就如何协商会话达成一致，这严格来说并不是错误。通知消息还用于允许设备出于与错误无关的原因终止
    BGP 会话。
- en: BGP Notification Message Format
  id: totrans-909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BGP 通知消息格式
- en: The format for the BGP Notification messages is detailed in [Table 40-12](ch40s07.html#bgp_notification_message_format-id001
    "Table 40-12. BGP Notification Message Format") and illustrated in [Figure 40-6](ch40s07.html#bgp_notification_message_format-id002
    "Figure 40-6. BGP Notification message format").
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: BGP 通知消息的格式在[表 40-12](ch40s07.html#bgp_notification_message_format-id001 "表
    40-12. BGP 通知消息格式")中详细说明，并在[图 40-6](ch40s07.html#bgp_notification_message_format-id002
    "图 40-6. BGP 通知消息格式")中展示。 |
- en: Table 40-12. BGP Notification Message Format
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 表 40-12. BGP 通知消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Marker | 16 | This large field at the start of each BGP message is used for
    synchronization and authentication. |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
  zh: '| 标记 | 16 | 每个BGP消息开头的这个大字段用于同步和认证。 |'
- en: '| Length | 2 | The total length of the message in bytes, including the fields
    of the header. Notification messages are variable in length. |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 2 | 消息的总长度（字节），包括头部字段。通知消息的长度是可变的。 |'
- en: '| Type | 1 | BGP message type; value is 3 for Notification messages. |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | BGP 消息类型；对于通知消息，值为 3。 |'
- en: '| Error Code | 1 | Specifies the general class of the error. [Table 40-13](ch40s07.html#bgp_notification_message_error_codes
    "Table 40-13. BGP Notification Message Error Codes") shows the possible error
    types with a brief description of each. |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '| 错误代码 | 1 | 指定错误的通用类别。[表 40-13](ch40s07.html#bgp_notification_message_error_codes
    "表 40-13. BGP 通知消息错误代码")显示了可能的错误类型及其简要描述。 |'
- en: '| Error Subcode | 1 | Provides a more specific indication of the cause of the
    error for three of the Error Code values. The possible values of this field for
    each Error Code value are shown in [Table 40-14](ch40s07.html#bgp_notification_message_error_subcodes
    "Table 40-14. BGP Notification Message Error Subcodes"). |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '| 错误子代码 | 1 | 为三个错误代码值提供对错误原因的更具体指示。此字段对于每个错误代码值的可能值显示在[表 40-14](ch40s07.html#bgp_notification_message_error_subcodes
    "表 40-14. BGP 通知消息错误子代码")中。 |'
- en: '| Data | Variable | Contains additional information to help diagnose the error.
    Its meaning depends on the type of error specified in the Error Code and Error
    Subcode fields. In most cases, this field is filled in with whatever bad value
    caused the error to occur. For example, for "Message Header Error / Bad Message
    Type," the value of the bad Type field is placed here. |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 变量 | 包含帮助诊断错误的附加信息。其含义取决于错误代码和错误子代码字段中指定的错误类型。在大多数情况下，此字段填充了导致错误发生的任何不良值。例如，对于“消息头错误/错误消息类型”错误，错误的类型字段值被放置在这里。
    |'
- en: '![BGP Notification message format](httpatomoreillycomsourcenostarchimages288077.png)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![BGP 通知消息格式](httpatomoreillycomsourcenostarchimages288077.png)'
- en: Figure 40-6. BGP Notification message format
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 图 40-6. BGP 通知消息格式
- en: Tables [Table 40-13](ch40s07.html#bgp_notification_message_error_codes "Table 40-13. BGP
    Notification Message Error Codes") and [Table 40-14](ch40s07.html#bgp_notification_message_error_subcodes
    "Table 40-14. BGP Notification Message Error Subcodes") show the values permitted
    for the Error Code and Error Subcode fields, respectively, and thus provide a
    good summary of the types of errors that Notification messages can report. They
    also demonstrate the other nonerror uses of the message type.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 表[表40-13](ch40s07.html#bgp_notification_message_error_codes "表40-13. BGP通知消息错误代码")和[表40-14](ch40s07.html#bgp_notification_message_error_subcodes
    "表40-14. BGP通知消息错误子代码")显示了错误代码和错误子代码字段允许的值，从而提供了通知消息可以报告的错误类型的良好总结。它们还展示了消息类型的其他非错误用途。
- en: Table 40-13. BGP Notification Message Error Codes
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-13. BGP通知消息错误代码
- en: '| Error Code Value | Code Name | Description |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| 错误代码值 | 代码名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Message Header Error | A problem was detected either with the contents
    or length of the BGP header. The Error Subcode field provides more details on
    the nature of the problem. |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 消息头错误 | 检测到BGP头的内容或长度存在问题。错误子代码字段提供了关于问题性质的更多详细信息。|'
- en: '| 2 | Open Message Error | A problem was found in the body of an Open message.
    The Error Subcode field describes the problem in more detail. Note that authentication
    failures or the inability to agree on a parameter such as hold time are included
    here. |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 开启消息错误 | 在开启消息体中发现了问题。错误子代码字段详细描述了问题。注意，认证失败或无法就保持时间等参数达成一致的情况也包括在内。|'
- en: '| 3 | Update Message Error | A problem was found in the body of an Update message.
    Again, the Error Subcode field provides more information. Many of the problems
    that fall under this code are related to issues detected in the routing data or
    path attributes sent in the Update message, so these messages provide feedback
    about such problems to the device sending the erroneous data. |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 更新消息错误 | 在更新消息体中发现了问题。同样，错误子代码字段提供了更多信息。许多属于此代码的问题都与更新消息中检测到的路由数据或路径属性问题相关，因此这些消息向发送错误数据的设备提供了有关此类问题的反馈。|'
- en: '| 4 | Hold Timer Expired | A message was not received before the hold time
    expired. See the description of the Keepalive message earlier in this chapter
    for details on this timer. |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 保持计时器超时 | 在保持时间到期之前没有收到消息。有关此计时器的详细信息，请参阅本章前面关于保持消息的描述。|'
- en: '| 5 | Finite State Machine Error | The BGP finite state machine refers to the
    mechanism by which the BGP software on a peer moves from one operating state to
    another based on events (see the TCP finite state machine description in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION")
    for some background on this concept). If an event occurs that is unexpected for
    the state the peer is currently in, it will generate this error. |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 有限状态机错误 | BGP有限状态机指的是对等体上的BGP软件根据事件（有关此概念的一些背景信息，请参阅[第47章](ch47.html
    "第47章. TCP基本操作：连接建立、管理和终止")中关于TCP有限状态机的描述）从一个操作状态移动到另一个操作状态的机制。如果发生对当前状态的对等体来说意外的事件，它将生成此错误。|'
- en: '| 6 | Cease | Used when a BGP device wants to break the connection to a peer
    for a reason not related to any of the error conditions described by the other
    codes. |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 停止 | 当BGP设备因与错误代码中描述的其他错误条件无关的原因想要断开与对等体的连接时使用。|'
- en: Table 40-14. BGP Notification Message Error Subcodes
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 表40-14. BGP通知消息错误子代码
- en: '| Error Type | Error Subcode Value | Subcode Name | Description |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
  zh: '| 错误类型 | 错误子代码值 | 子代码名称 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Message Header Error (Error Code 1) | 1 | Connection Not Synchronized | The
    expected value in the Marker field was not found, indicating that the connection
    has become unsynchronized. See the description of the Marker field in [BGP Notification
    Message Format](ch40s07.html#bgp_notification_message_format "BGP Notification
    Message Format"). |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '| 消息头错误（错误代码1） | 1 | 连接未同步 | 标记字段中的预期值未找到，表明连接已不同步。请参阅[BGP通知消息格式](ch40s07.html#bgp_notification_message_format
    "BGP通知消息格式")中标记字段的描述。|'
- en: '|   | 2 | Bad Message Length | The message was less than 19 bytes, greater
    than 4096 bytes, or not consistent with what was expected for the message type.
    |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '|   | 2 | 消息长度错误 | 消息长度小于19字节，大于4096字节，或者与预期消息类型不一致。|'
- en: '|   | 3 | Bad Message Type | The Type field of the message contains an invalid
    value. |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '|   | 3 | 消息类型错误 | 消息的类型字段包含一个无效的值。|'
- en: '| Open Message Error (Error Code 2) | 1 | Unsupported Version Number | The
    device does not "speak" the version number its peer is trying to use. |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| 打开消息错误（错误代码2） | 1 | 不支持版本号 | 设备不支持其对等方试图使用的版本号。|'
- en: '|   | 2 | Bad Peer AS | The router doesn''t recognize the peer''s AS number
    or is not willing to communicate with it. |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '|   | 2 | 错误的Peer AS | 路由器不识别对等方的AS号或不愿意与其通信。|'
- en: '|   | 3 | Bad BGP Identifier | The BGP Identifier field is invalid. |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '|   | 3 | 错误的BGP标识符 | BGP标识符字段无效。|'
- en: '|   | 4 | Unsupported Optional Parameter | The Open message contains an optional
    parameter that the recipient of the message doesn''t understand. |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '|   | 4 | 不支持的可选参数 | 消息中的可选参数是接收者不理解的。|'
- en: '|   | 5 | Authentication Failure | The data in the Authentication Information
    optional parameter could not be authenticated. |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '|   | 5 | 认证失败 | 认证信息可选参数中的数据无法进行认证。|'
- en: '|   | 6 | Unacceptable Hold Time | The router refuses to open a session because
    the proposed hold time its peer specified in its Open message is unacceptable.
    |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '|   | 6 | 不可接受的保持时间 | 路由器拒绝打开会话，因为其对等方在其Open消息中指定的提议保持时间不可接受。|'
- en: '| Update Message Error (Error Code 3) | 1 | Malformed Attribute List | The
    overall structure of the message''s path attributes is incorrect, or an attribute
    has appeared twice. |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| 更新消息错误（错误代码3） | 1 | 属性列表格式错误 | 消息路径属性的总体结构不正确，或者属性出现了两次。|'
- en: '|   | 2 | Unrecognized Well-Known Attribute | One of the mandatory well-known
    attributes was not recognized. |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '|   | 2 | 不可识别的已知属性 | 必须的已知属性之一未被识别。|'
- en: '|   | 3 | Missing Well-Known Attribute | One of the mandatory well-known attributes
    was not specified. |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '|   | 3 | 缺少的已知属性 | 必须的已知属性之一未指定。|'
- en: '|   | 4 | Attribute Flags Error | An attribute has a flag set to a value that
    conflicts with the attribute''s type code. |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '|   | 4 | 属性标志错误 | 一个属性有一个设置为与属性类型代码冲突的标志。|'
- en: '|   | 5 | Attribute Length Error | The length of an attribute is incorrect.
    |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '|   | 5 | 属性长度错误 | 属性的长度不正确。|'
- en: '|   | 6 | Invalid Origin Attribute | The Origin attribute has an undefined
    value. |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '|   | 6 | 无效的起源属性 | Origin属性具有未定义的值。|'
- en: '|   | 7 | AS Routing Loop | A routing loop was detected. |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '|   | 7 | AS路由环路 | 检测到路由环路。|'
- en: '|   | 8 | Invalid Next_Hop Attribute | The Next_Hop attribute is invalid. |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '|   | 8 | 无效的Next_Hop属性 | Next_Hop属性无效。|'
- en: '|   | 9 | Optional Attribute Error | An error was detected in an optional attribute.
    |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '|   | 9 | 可选属性错误 | 在可选属性中检测到错误。|'
- en: '|   | 10 | Invalid Network Field | The Network Layer Reachability Information
    field is incorrect. |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '|   | 10 | 无效的网络字段 | 网络层可达信息字段不正确。|'
- en: '|   | 11 | Malformed AS_Path | The AS_Path attribute is incorrect. |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '|   | 11 | AS_PATH格式错误 | AS_Path属性不正确。|'
- en: Note that, perhaps ironically, no mechanism exists to report an error in a Notification
    message itself. This is likely because the connection is normally terminated after
    such a message is sent.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能具有讽刺意味的是，没有机制可以报告通知消息本身的错误。这可能是由于在发送此类消息后，通常终止了连接。
- en: Tip
  id: totrans-956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** BGP Notification messages are used for error reporting between
    BGP peers. Each message contains an Error Code field that indicates what type
    of problem occurred. For certain Error Code fields, an Error Subcode field provides
    additional details about the specific nature of the problem. Despite these field
    names, Notification messages are also used for other types of special nonerror
    communication, such as terminating a BGP connection.'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** BGP通知消息用于BGP对等体之间的错误报告。每个消息都包含一个错误代码字段，指示发生了哪种类型的问题。对于某些错误代码字段，错误子代码字段提供了有关问题具体性质的额外详细信息。尽管这些字段名称如此，通知消息也用于其他类型的特殊非错误通信，例如终止BGP连接。'
- en: Chapter 41. OTHER ROUTING PROTOCOLS
  id: totrans-958
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第41章。其他路由协议
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-959
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The Routing Information Protocol (RIP), Open Shortest Path First (OSPF), and
    Border Gateway Protocol (BGP)—detailed in the preceding chapters—are the three
    most well-known routing protocols used in the TCP/IP protocol suite. But there
    are several other TCP/IP routing protocols, and they fall into one of two categories.
    Some protocols are no longer in use today but are nevertheless interesting from
    a historical perspective. Others are proprietary RIP and OSPF alternatives that
    you may occasionally encounter in today's networking world.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 路由信息协议（RIP）、开放最短路径优先（OSPF）和边界网关协议（BGP）——如前几章所述——是TCP/IP协议族中最著名的三个路由协议。但还有几个其他的TCP/IP路由协议，它们可以分为两大类。一些协议现在不再使用，但从历史角度来看仍然有趣。其他是一些专有的RIP和OSPF替代品，你可能在今天的网络世界中偶尔会遇到。
- en: 'In this chapter, I provide a brief description of five additional TCP/IP routing
    protocols. I begin with a look at two obsolete interior routing protocols that
    played an important role in the early Internet: the Gateway-to-Gateway Protocol
    (GGP) and the HELLO Protocol. I then describe two interior routing protocols (developed
    by Cisco Systems) that are sometimes seen in the industry today as alternatives
    to RIP and OSPF: the Interior Gateway Routing Protocol (IGRP) and the Enhanced
    Interior Gateway Routing Protocol (EIGRP). I conclude with a discussion of the
    Exterior Gateway Protocol (EGP), the exterior routing protocol that preceded BGP.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我简要介绍了五种额外的TCP/IP路由协议。我首先回顾了两个在早期互联网中扮演重要角色的过时内部路由协议：网关到网关协议（GGP）和HELLO协议。然后，我描述了两个内部路由协议（由思科系统开发），这些协议有时在业界被视为RIP和OSPF的替代品：内部网关路由协议（IGRP）和增强型内部网关路由协议（EIGRP）。最后，我讨论了外部网关协议（EGP），这是在BGP之前的外部路由协议。
- en: TCP/IP Gateway-to-Gateway Protocol (GGP)
  id: totrans-962
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP网关到网关协议（GGP）
- en: In [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS"),
    I described the evolution of TCP/IP routing architectures. The modern Internet
    is based on the concept of independent autonomous systems (ASes), which run interior
    routing protocols within them and exterior routing protocols between them. The
    early Internet, however, was somewhat simpler. It consisted of a relatively small
    number of core routers that carried detailed information about the Internet as
    a whole, as well as noncore routers that knew only partial information about the
    whole internetwork and were located around the core.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第37章](ch37.html "第37章。关键路由协议概念概述")中，我描述了TCP/IP路由架构的演变。现代互联网基于独立自治系统（AS）的概念，这些系统在其内部运行内部路由协议，在其之间运行外部路由协议。然而，早期的互联网相对简单。它由相对较少的核心路由器组成，这些路由器携带有关整个互联网的详细信息，以及非核心路由器，它们只知道整个互联网的部分信息，并位于核心周围。
- en: These core routers used a special routing protocol to communicate called the
    *Gateway-to-Gateway Protocol (GGP)*. Bolt, Beranek, and Newman, one of the pioneers
    of the Internet and TCP/IP, originally developed GGP in the early 1980s. It was
    documented in RFC 823, "The DARPA Internet Gateway," published September 1982\.
    This protocol is now obsolete, but it played an important role in the early Internet
    by introducing certain concepts that developers used in later routing protocols.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心路由器使用一种特殊的路由协议进行通信，称为*网关到网关协议（GGP）*。Bolt、Beranek和Newman是互联网和TCP/IP的先驱之一，他们在20世纪80年代初最初开发了GGP。该协议在1982年9月发布的RFC
    823，“DARPA互联网网关”中进行了记录。这个协议现在已经过时，但它通过引入开发者在后来的路由协议中使用的某些概念，在早期互联网中发挥了重要作用。
- en: GGP is similar in general operation to RIP (described in [Chapter 38](ch38.html
    "Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)")) in that it
    uses a distance-vector algorithm to determine the best routes between devices.
    Like RIP, the metric is a simple hop count, so GGP will select a route with the
    shortest number of hops. Although you have seen that hop count is not always the
    best metric of cost for a router in RIP, it was actually a pretty good method
    of route determination back then. This is because the early Internet used both
    computers and links that would be considered glacially slow by today's standards,
    thereby making each hop fairly expensive (in terms of the time required to send
    data) compared to modern routing.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: GGP在一般操作上与RIP（在第38章中描述）相似，因为它使用距离矢量算法来确定设备之间的最佳路由。像RIP一样，度量是一个简单的跳数计数，所以GGP会选择跳数最少的路由。尽管你看到在RIP中跳数并不总是路由器成本的最佳度量标准，但当时它实际上是一个相当好的路由确定方法。这是因为早期的互联网使用了当时被认为是极其缓慢的计算机和链路，因此与现代路由相比，每个跳数在发送数据所需的时间上相当昂贵。
- en: A router using GGP initially starts out in a null state. It then tests the status
    of its local networks by seeing if it can send and receive messages on the network.
    Every 15 seconds, the router sends a GGP Echo message to each of its neighbors.
    If the neighbor receives the message, it responds with a GGP Echo Reply message.
    The router sending the Echo messages considers the neighbor up if it receives
    replies to a certain percentage of messages (the default is 50 percent).
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GGP的路由器最初处于空状态。然后，它通过查看是否可以在网络上发送和接收消息来测试其本地网络的状态。每15秒，路由器向其每个邻居发送一个GGP回显消息。如果邻居收到消息，它会用一个GGP回显应答消息进行响应。发送回显消息的路由器如果收到一定比例（默认为50%）的消息回复，就会认为邻居是可达的。
- en: Note
  id: totrans-967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*These messages serve a similar function to the Internet Control Message Protocol
    version 4 (ICMPv4) Echo and Echo Reply messages (described in [Chapter 33](ch33.html
    "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS")), but are not the
    same.*'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些消息在功能上与互联网控制消息协议版本4（ICMPv4）的回显和回显应答消息（在第33章中描述）类似，但并不相同。*'
- en: Actual routing information is communicated by sending GGP Routing Update messages.
    These are similar in nature to RIP Response messages used in RIP. Each Routing
    Update message contains the information in the sending router's routing table,
    which specifies the networks the router can reach and what the cost (in hops)
    will be for each.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的路由信息是通过发送GGP路由更新消息来传递的。这些消息在本质上类似于RIP中使用的RIP响应消息。每个路由更新消息都包含了发送路由器的路由表信息，它指定了路由器可以到达的网络以及每个网络的成本（以跳数表示）。
- en: A router that receives a Routing Update message knows that it can reach the
    router that sent the update. Because of that, it can reach all of the other routers'
    reachable networks at the cost of an additional hop. The router uses the information
    to update its own internal tables of destinations and metrics, and then it sends
    out its own Routing Update on its own attached networks. This way, it can propagate
    the information it acquired from other routers on its own networks. This process
    continues until eventually, routes to all GGP routers spreads across the internetwork,
    just as this process occurs in RIP.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到路由更新消息的路由器知道它可以到达发送更新的路由器。因此，它可以以额外跳数的成本到达其他路由器可达的所有网络。路由器使用这些信息来更新其内部的目的地表和度量表，然后在自己的连接网络上发送自己的路由更新。这样，它可以在自己的网络上传播从其他路由器获得的信息。这个过程会一直持续，直到最终，GGP路由器的路由信息在整个互联网中传播开来，就像RIP中的这个过程一样。
- en: One interesting difference between GGP and RIP is that in GGP networks and costs
    aren't sent in pairs. Instead, a GGP router sends its routing table in groups.
    If it has three networks it can communicate with directly at a cost of 1, it sends
    those in a group with a distance value of 1\. Next, if the GGP router has a few
    networks it can reach at a cost of 2, it sends those in a group with a distance
    value of 2, and so on.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: GGP与RIP之间一个有趣的不同之处在于，在GGP网络中，网络和成本不是成对发送的。相反，GGP路由器以组的形式发送其路由表。如果它可以直接与三个网络通信，成本为1，它就会将这些网络以距离值为1的组发送。接下来，如果GGP路由器可以以成本2到达一些网络，它就会将这些网络以距离值为2的组发送，依此类推。
- en: Another difference is that GGP Routing Update messages are acknowledged. Each
    Routing Update message is sent with a sequence number, which ensures that out-of-date
    information is not propagated. If the Routing Update is received and it has a
    new sequence number (indicating that it contains recent information), the router
    processing returns a GGP Acknowledgment message to the originator. If the sequence
    number indicates the message is stale, a Negative Acknowledgment is sent instead
    and the message is discarded.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不同之处在于GGP路由更新消息会被确认。每个路由更新消息都会附带一个序列号，这确保了过时信息不会被传播。如果收到路由更新并且它有一个新的序列号（表示它包含最新信息），处理该路由更新的路由器会向发送者返回一个GGP确认消息。如果序列号表明消息已过时，则会发送一个否定确认，并丢弃该消息。
- en: As a distance-vector algorithm using hop count as a metric, GGP shared most
    of the same pros and cons as RIP. It had simplicity on its side, but it had numerous
    problems such as slow convergence and the counting to infinity issue. GGP was
    a much more rudimentary protocol than RIP, however, and did not include many of
    the features included in RIP to handle such issues, such as split horizon. GGP
    was also limited to unsubnetted classful networks, due to its age.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用跳数作为度量标准距离矢量算法，GGP与RIP共享了大部分相同的优缺点。它在简单性方面占优势，但存在许多问题，如收敛速度慢和无限计数问题。然而，GGP比RIP更原始，并且不包括RIP中用于处理此类问题的许多功能，例如分割水平。由于GGP的年代久远，它也仅限于未子网化的类网络。
- en: When Internet architecture moved to the use of ASes, GGP was obsoleted. While
    it was an important part of TCP/IP history, it is today not formally considered
    a part of the TCP/IP protocol suite.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 当互联网架构转向使用自治系统（AS）时，GGP被淘汰。虽然它是TCP/IP历史的重要组成部分，但今天它并不正式被认为是TCP/IP协议套件的一部分。
- en: Tip
  id: totrans-975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The *Gateway-to-Gateway Protocol (GGP)* was used to communicate
    route information between core routers on the early Internet. It is a distance-vector
    protocol that operates in a manner that''s very similar to RIP. Each router periodically
    sends out its routing table to neighboring routers so that each router can learn
    the cost, in hops, to reach every network in the AS. GGP is now considered a historical
    protocol and is no longer part of TCP/IP.'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *网关到网关协议（GGP）*曾用于在早期互联网的核心路由器之间通信路由信息。它是一种距离矢量协议，其操作方式与RIP非常相似。每个路由器定期向相邻路由器发送其路由表，以便每个路由器都能学习到达AS中每个网络的跳数成本。GGP现在被认为是一个历史协议，不再是TCP/IP的一部分。'
- en: The HELLO Protocol (HELLO)
  id: totrans-977
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HELLO协议（HELLO）
- en: The TCP/IP Internet as we know it today evolved over the course of decades.
    It began as an experimental research project started by the United States Defense
    Advanced Research Projects Agency (DARPA or ARPA). Called the ARPAnet, the project
    grew through the addition of other networks, such as the important NSFnet developed
    by the National Science Foundation (NSF). The NSFnet backbone grew over the course
    of many years and was instrumental to the eventual creation of the modern Internet.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天所知道的TCP/IP互联网是在几十年的时间里逐步演变的。它始于由美国国防部高级研究计划局（DARPA或ARPA）发起的一个实验性研究项目。该项目被称为ARPAnet，通过添加其他网络（如国家科学基金会（NSF）开发的重要NSFnet）而逐渐发展壮大。NSFnet骨干网在多年的时间里不断扩展，对于最终创建现代互联网起到了关键作用。
- en: The original NSFnet backbone consisted of six Digital Equipment Corporation
    (absorbed by Compaq years ago) LSI-11 computers located across the United States.
    These computers ran special software that was colloquially called "fuzzball."
    This software enabled the computers to function as routers. These fuzzball routers
    connected various networks to the NSFnet and the ARPAnet.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的NSFnet骨干网由六台位于美国各地的数字设备公司（多年前被康柏公司收购）LSI-11计算机组成。这些计算机运行了被俗称为“fuzzball”的特殊软件。这种软件使计算机能够作为路由器运行。这些fuzzball路由器将各种网络连接到NSFnet和ARPAnet。
- en: The six NSFnet routers worked as an AS, and like any AS, used an interior routing
    protocol to exchange routing information. The routing protocol used in these early
    routers was called the *HELLO Protocol*. Developed in the early 1980s, it was
    documented in RFC 891, "DCN Local-Network Protocols," which was published in December
    1983\. The name *HELLO* is capitalized, but it is not an acronym; it simply refers
    to the word *hello*, because the protocol uses messages that are sort of analogous
    to the routers greeting each other.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 六个NSFnet路由器作为一个AS工作，就像任何AS一样，使用内部路由协议来交换路由信息。这些早期路由器使用的路由协议被称为*HELLO协议*。在20世纪80年代初开发，它记录在1983年12月发布的RFC
    891，“DCN Local-Network Protocols”中。*HELLO*这个名字首字母大写，但它不是一个缩写；它仅仅指的是单词*hello*，因为该协议使用的是类似于路由器相互问候的消息。
- en: Note
  id: totrans-981
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The OSPF routing protocol has a message type called* Hello. *The use of these
    messages is sometimes referred to as the* Hello protocol. *OSPF is not directly
    related to the HELLO Protocol described in this section, other than the fact that
    an AS could use both protocols for routing. OSPF may have borrowed the name Hello
    from the HELLO Protocol.*'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '*OSPF路由协议有一个名为* Hello 的消息类型。*这些消息的使用有时被称为* Hello 协议。*OSPF与本章中描述的HELLO协议没有直接关系，除了一个自治系统（AS）可以使用这两个协议进行路由的事实。OSPF可能从HELLO协议那里借用了Hello这个名字*。'
- en: The HELLO Protocol uses a distance-vector algorithm, like RIP and GGP. What's
    interesting about it, however, is that unlike RIP and GGP, HELLO does not use
    hop count as a metric. Instead, it attempts to select the best route by assessing
    network delays and choosing the path with the shortest delay.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: HELLO协议使用距离矢量算法，就像RIP和GGP一样。然而，有趣的是，与RIP和GGP不同，HELLO不使用跳数作为度量值。相反，它试图通过评估网络延迟并选择延迟最短的路径来选择最佳路由。
- en: One of the key jobs of routers that use HELLO is to compute the time delay required
    to send and receive datagrams to and from its neighbors. On a regular basis, routers
    exchange HELLO messages that contain clock and timestamp information. By using
    a special algorithm to compare the clock value and timestamp in the message to
    its own clock, a receiving device can compute an estimate for the amount of time
    it takes to send a datagram over the link.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HELLO的路由器的一项关键任务是计算向其邻居发送和接收数据报所需的时间延迟。定期地，路由器交换包含时钟和时间戳信息的HELLO消息。通过使用特殊的算法来比较消息中的时钟值和时间戳与其自己的时钟，接收设备可以计算发送数据报通过链路所需时间的估计值。
- en: Like RIP and GGP messages, HELLO messages also contain routing information in
    the form of pairs of destinations and metrics. These represent places that the
    sending router is able to reach and a cost to communicate with each one. However,
    in HELLO, the metric is an estimate of the round-trip delay cost for each destination.
    This information is added to the computed round-trip delay time for the link over
    which the message was received, and it is used to update the receiving router's
    own routing table.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 就像RIP和GGP消息一样，HELLO消息也包含以目的地和度量值对的形式的路由信息。这些表示发送路由器能够到达的地方以及与每个地方通信的成本。然而，在HELLO中，度量值是每个目的地的往返延迟成本的估计。这些信息被添加到接收路由器接收消息的链路的计算往返延迟时间中，并用于更新接收路由器自己的路由表。
- en: This seems a bit confusing, but is really similar to the way a hop-count distance-vector
    protocol like RIP works. Router A, which is using RIP to receive an RIP Response
    message from Router B, knows it can reach every destination Router B can, but
    at a cost of one extra hop (the hop from Router A to Router B). Similarly, Router
    A, which receives a HELLO message from Router B, knows it can reach every destination
    that Router B can, but at an additional cost of the computed delay for the link
    between Router A and Router B.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点令人困惑，但实际上与像RIP这样的跳数距离矢量协议的工作方式非常相似。路由器A使用RIP从路由器B接收RIP响应消息，知道它可以到达路由器B可以到达的每个目的地，但代价是额外一跳（从路由器A到路由器B的跳数）。同样，路由器A收到来自路由器B的HELLO消息，知道它可以到达路由器B可以到达的每个目的地，但代价是计算路由器A和路由器B之间链路的延迟。
- en: In theory, using delay calculations should result in more efficient route selection
    than simply using a hop-count algorithm, but this comes at the cost of more complexity.
    This makes HELLO very interesting indeed, especially for a protocol that is more
    than 20 years old. However, since the latency of a link is often unrelated to
    its bandwidth, using time delay as a link metric may lead to spurious results.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，使用延迟计算应该比简单地使用跳数算法选择路由更高效，但这会增加复杂性。这使得HELLO协议确实非常有趣，尤其是对于一个超过20年的协议来说。然而，由于链路的延迟通常与其带宽无关，使用时间延迟作为链路度量可能会导致虚假的结果。
- en: Furthermore, it is normal for the delay on any link to vary over time; for example,
    if two routes are similar in cost, fluctuations in the delay for each route could
    result in rapid changes between routes (a phenomenon sometimes called *route flapping*).
    Adjustments are needed to the basic overview of the operation of the HELLO Protocol
    in order to avoid these sorts of problems.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何链路上的延迟随时间变化是正常的；例如，如果两条路由的成本相似，每条路由的延迟波动可能会导致路由之间快速切换（这种现象有时被称为*路由波动*）。需要对HELLO协议的基本操作概述进行调整，以避免这类问题。
- en: Like other early routing protocols, HELLO does not include anything fancy like
    authentication. Such features were not needed in the early days of the Internet,
    when the internetworks were small and could easily be controlled. As the Internet
    grew, newer routing protocols such as RIP eventually replaced HELLO. It is now
    considered a historical protocol (in other words, obsolete) and is no longer used.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他早期的路由协议一样，HELLO协议不包括像认证这样的复杂功能。在互联网的早期，当互联网互连规模小且容易控制时，这些功能是不需要的。随着互联网的发展，像RIP这样的新路由协议最终取代了HELLO。现在它被认为是一个历史性的协议（换句话说，已经过时），并且不再被使用。
- en: Tip
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The *HELLO Protocol* was used on very early routers on the
    precursors of the Internet to exchange routing information. It is a distance-vector
    protocol like RIP and GGP, but differs because it uses calculated delay instead
    of hop count as a metric. Like GGP, it is now considered a historical protocol
    and is no longer part of TCP/IP.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HELLO协议在互联网的早期路由器及其前身上用于交换路由信息。它是一个距离矢量协议，类似于RIP和GGP，但它不同之处在于它使用计算出的延迟而不是跳数作为度量。就像GGP一样，它现在被认为是一个历史性协议，不再是TCP/IP的一部分。'
- en: Interior Gateway Routing Protocol (IGRP)
  id: totrans-992
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部网关路由协议（IGRP）
- en: I greatly prefer universal, open standards to proprietary standards. I explain
    the reasons why in [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS
    ORGANIZATIONS"), which discusses networking standards. I am not alone in this
    view, and it's no exaggeration to say that much of the success of TCP/IP and the
    Internet is tied to the fact that they were both developed, and still are being
    developed, with the open RFC process.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常偏好通用的开放标准而不是专有标准。我在[第3章](ch03.html "第3章。网络标准和标准组织")中解释了原因，该章节讨论了网络标准。我并不孤单在这个观点上，说TCP/IP和互联网的大部分成功与它们都是通过开放的RFC过程开发和仍在开发的事实紧密相关，并不夸张。
- en: 'That said, in certain situations, a proprietary protocol can be a benefit and
    can even achieve considerable success if a minimum of two factors is true:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在特定情况下，如果以下两个因素中的至少一个是真的，专有协议可以带来好处，甚至可以取得相当大的成功：
- en: There is a lack of a suitable open protocol or a gap in the feature coverage
    of existing open protocols, creating an opportunity for a proprietary protocol
    to succeed.
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的开放协议在功能覆盖上存在不足或空白，这为专有协议的成功提供了机会。
- en: The proprietary protocol must be either initiated or strongly supported by a
    big player in the industry. This helps to ensure that other companies will take
    notice and give the protocol a chance to become a standard.
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专有协议必须由行业中的大玩家发起或大力支持。这有助于确保其他公司会注意到并给这个协议一个成为标准的机会。
- en: This situation arose in the 1980s in the world of routing protocols. At that
    time, the most popular interior routing protocol was RIP, which does a basically
    good job, but has a number of limitations and problems that are inherent to the
    protocol and are not easily resolved. In the mid-1980s, open alternatives like
    OSPF did not yet exist; even if they had, OSPF is much more complex than RIP and
    therefore sometimes not a good alternative to it.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在20世纪80年代的路由协议世界中出现。当时，最受欢迎的内部路由协议是RIP，它基本上做得很好，但存在一些固有的限制和问题，这些问题是协议本身的，并且不容易解决。在20世纪80年代中期，像OSPF这样的开放替代品尚未存在；即使存在，OSPF也比RIP复杂得多，因此有时不是RIP的好替代品。
- en: 'Cisco Systems—definitely one of the big names in networking, internetworking,
    and routing—decided to develop a new routing protocol that would be similar to
    RIP but would provide greater functionality and solve some of RIP''s inherent
    problems. Called the *Interior Gateway Routing Protocol (IGRP)*, it conveniently
    uses the words *gateway* and *routing* in its name, illustrating that these two
    words are used interchangeably in internetworking standards. Cisco designed it
    as a replacement for RIP. It is similar in many ways and keeps RIP''s simplicity,
    one of its key strengths. At the same time, IGRP overcomes two key limitations
    of RIP: the use of hop count solely as a routing metric and the hop count limit
    of 15.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 思科系统——无疑是网络、互连和路由领域的知名企业——决定开发一种新的路由协议，该协议将与RIP相似，但将提供更强大的功能并解决RIP的一些固有问题。该协议被称为*内部网关路由协议（IGRP）*，其名称中方便地使用了*网关*和*路由*这两个词，说明了这两个词在互连标准中可以互换使用。思科将其设计为RIP的替代品。它在许多方面都很相似，并保留了RIP的简单性，这是其关键优势之一。同时，IGRP克服了RIP的两个关键限制：将跳数单纯作为路由度量以及15个跳数的限制。
- en: Like RIP, IGRP is a distance-vector routing protocol designed for use with an
    AS, and thus uses the same basic mechanism for route determination. Each router
    routinely sends out a message on each attached local network that contains a copy
    of its routing table. This message contains pairs of reachable networks and costs
    (metrics) to reach each network. A router receiving this message knows it can
    reach all the networks in the message as long as it can reach the router that
    sent the message. It computes the cost to reach those networks by adding what
    it costs to reach the router that sent the message to the networks' costs. The
    routers update their tables accordingly and send this information out in their
    next routine update. Eventually, each router in the AS will have information about
    the cost to reach each network in it.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 与RIP一样，IGRP是一种距离矢量路由协议，专为与自治系统（AS）一起使用而设计，因此使用相同的机制来确定路由。每个路由器定期在每个连接的本地网络上发送一条消息，该消息包含其路由表的一个副本。此消息包含可达网络及其到达每个网络的成本（度量标准）的成对信息。接收此消息的路由器知道只要它能到达发送消息的路由器，它就可以到达消息中的所有网络。它通过将到达发送消息的路由器的成本加到网络的成本上来计算到达这些网络的成本。路由器相应地更新它们的表，并在下一次常规更新中发送此信息。最终，AS中的每个路由器都将了解到达其内部每个网络的成本。
- en: There's an important difference between RIP and IGRP, however. RIP allows the
    cost to reach a network to be expressed only in terms of hop count; IGRP provides
    a much more sophisticated metric. In IGRP, the overall cost to reach a network
    is computed based on several individual metrics, including internetwork delay,
    bandwidth, reliability, and load. An administrator can customize the calculation
    of cost by setting relative weightings to the component metrics that reflect the
    priorities of that AS. So, if a particular administrator feels that emphasizing
    reliability over bandwidth would best minimize route cost, he can do this. Such
    a system provides tremendous flexibility over the rigid hop-count system of RIP.
    Unlike RIP, IGRP also does not have an inherent limit of 15 hops between networks.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，RIP和IGRP之间存在一个重要的区别。RIP只允许以跳数来表示到达网络的成本；IGRP提供了一个更为复杂的度量标准。在IGRP中，到达网络的总体成本是基于多个个别度量标准计算的，包括网络延迟、带宽、可靠性和负载。管理员可以通过设置反映该自治系统优先级的组件度量标准的相对权重来自定义成本的计算。因此，如果某个管理员认为强调可靠性而不是带宽将最好地最小化路由成本，他可以这样做。这样的系统在RIP的僵化跳数系统中提供了巨大的灵活性。与RIP不同，IGRP在网络之间也没有固有的15跳限制。
- en: To this basic algorithm, IGRP adds a feature called *multipath routing*. This
    allows multiple paths between routes to be used automatically, with traffic shared
    between them. The traffic can either be shared evenly or apportioned unevenly
    based on the relative cost metric of each path. This provides improved performance
    and flexibility.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本算法的基础上，IGRP增加了一个名为*多路径路由*的功能。这允许自动使用多个路由之间的路径，并在这之间共享流量。流量可以均匀共享，也可以根据每条路径的相对成本度量不均匀分配。这提供了改进的性能和灵活性。
- en: Since IGRP is a distance-vector protocol like RIP, it shares many of RIP's algorithmic
    issues. Unsurprisingly, then, IGRP must incorporate many of the same stability
    features as RIP, including the use of split horizon, split horizon with poisoned
    reverse (in certain circumstances), and the employment of hold-down timers. Like
    RIP, IGRP also uses timers to control how often updates are sent, how long routers
    are held down, and how long routes are held in the routing table before they expire.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IGRP与RIP一样是一个距离矢量协议，因此它共享许多RIP的算法问题。不出所料，因此IGRP必须包含与RIP相同的许多稳定性功能，包括使用分割水平、分割水平带毒反转（在特定情况下）以及使用保持时间计时器。与RIP一样，IGRP也使用计时器来控制更新发送的频率、路由器保持时间以及路由在路由表中过期之前保持的时间。
- en: Cisco originally developed IGRP for Internet Protocol (IP) networks, and since
    IP is predominant in the industry, these networks are where it is most often seen.
    IGRP is not specific to IP, however, and can be used with other internetworking
    protocols if implemented for them. As you will see, Cisco also used IGRP as the
    basis for an improved routing protocol called EIGRP, which it developed several
    years after the original.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 思科最初为互联网协议（IP）网络开发了IGRP，由于IP在行业中占主导地位，因此这些网络是最常看到IGRP的地方。然而，IGRP并不仅限于IP，如果为它们实现，也可以与其他互连网络协议一起使用。正如您将看到的，思科还使用IGRP作为改进路由协议EIGRP的基础，该协议是在原始协议几年后开发的。
- en: Tip
  id: totrans-1004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In the 1980s, Cisco Systems created the *Interior Gateway Routing
    Protocol (IGRP)* as an improvement over the industry standard protocol, RIP. Like
    RIP, IGRP is a distance-vector protocol, but it includes several enhancements.
    Most important, it eliminates the 15-hop limit between routers and provides the
    ability to use metrics other than hop count to determine optimal routes.'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在20世纪80年代，思科系统公司创建了*内部网关路由协议（IGRP）*，作为对行业标准协议RIP的改进。与RIP一样，IGRP是一个距离矢量协议，但它包括几个增强功能。最重要的是，它消除了路由器之间的15跳限制，并提供了使用除跳数之外的其他度量来确定最佳路由的能力。'
- en: Enhanced Interior Gateway Routing Protocol (EIGRP)
  id: totrans-1006
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强型内部网关路由协议（EIGRP）
- en: As discussed in the previous section, IGRP represented a substantial improvement
    over RIP, but like any successful company, Cisco was not content to rest on its
    laurels. Cisco developers knew that IGRP had significant room for improvement,
    so they set to work on creating a better version of IGRP in the early 1990s. The
    result was the *Enhanced Interior Gateway Routing Protocol (EIGRP)*.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，IGRP在RIP之上代表了一个重大的改进，但像任何成功的公司一样，思科并不满足于安于现状。思科的开发者知道IGRP有很大的改进空间，因此他们在20世纪90年代初着手创建一个更好的IGRP版本。结果是*增强型内部网关路由协议（EIGRP）*。
- en: Compared to the original protocol, EIGRP is more of an evolution than a revolution.
    EIGRP is still a distance-vector protocol, but it is more sophisticated than other
    distance-vector protocols like IGRP or RIP, and it includes certain features that
    are more often associated with link-state routing protocols like OSPF than distance-vector
    algorithms. Also, since the Cisco developers realized that many of the organizations
    that had decided to use EIGRP would be migrating to it from IGRP, they took special
    steps to ensure compatibility between the two.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始协议相比，EIGRP更像是一种演变而不是革命。EIGRP仍然是一个距离矢量协议，但它比IGRP或RIP等其他距离矢量协议更复杂，并且包括一些更常与链路状态路由协议（如OSPF）而不是距离矢量算法相关的功能。此外，由于思科开发者意识到许多决定使用EIGRP的组织将是从IGRP迁移过来，因此他们采取了特殊措施确保两者之间的兼容性。
- en: The chief differences between IGRP and EIGRP are not in what they do, but how
    they do it. In an effort to improve the efficiency and speed of route convergence
    (that is, to improve the agreement between different routers in the internetwork),
    EIGRP changes the way that routes are calculated. EIGRP is based on a new route
    calculation algorithm called the *Diffusing Update Algorithm (DUAL)*, developed
    at SRI International by Dr. J. J. Garcia-Luna-Aceves.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: IGRP和EIGRP之间的主要区别不在于它们做什么，而在于它们是如何做的。为了提高路由收敛的效率和速度（即提高互联网中不同路由器之间的协议一致性），EIGRP改变了路由计算的方式。EIGRP基于一种新的路由计算算法，称为*扩散更新算法（DUAL）*，由SRI国际的J.
    J. Garcia-Luna-Aceves博士开发。
- en: DUAL differs from a typical distance-vector algorithm primarily in that it maintains
    more topology information about the internetwork than RIP or IGRP do. It uses
    this information to automatically select least-cost, loop-free routes between
    networks. EIGRP uses a metric that combines an assessment of the bandwidth of
    a link with the total delay to send over the link. (Other metrics are configurable
    as well, though not recommended.) When a neighboring router sends changed metric
    information, routes are recalculated and updates sent as needed. DUAL will query
    neighboring routers for reachability information if needed (for example, if an
    existing route fails).
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: DUAL与典型的距离矢量算法的主要区别在于，它维护比RIP或IGRP更多的互联网拓扑信息。它使用这些信息自动选择网络之间的最低成本、无环路由。EIGRP使用一个度量值，该度量值结合了对链路带宽的评估以及通过该链路发送的总延迟。（其他度量值也可以配置，尽管不推荐。）当相邻路由器发送更改后的度量信息时，路由将被重新计算，并按需发送更新。如果需要（例如，如果现有路由失败），DUAL将查询相邻路由器以获取可达性信息。
- en: This "as needed" aspect of operation highlights an important way that EIGRP
    improves performance over IGRP. EIGRP does not send routine route updates, but
    instead sends only partial updates as required, thereby reducing the amount of
    traffic generated between routers. Furthermore, these updates are designed so
    that only the routers that need the updated information receive them.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“按需”的操作特性突出了EIGRP相对于IGRP在性能提升方面的一个重要方式。EIGRP不会发送常规的路由更新，而是根据需要只发送部分更新，从而减少了路由器之间产生的流量。此外，这些更新被设计成只有需要更新信息的路由器才会接收它们。
- en: In order to build the tables of information that it needs to calculate routes,
    EIGRP requires routers to make and maintain contact with other routers on their
    local networks. To facilitate this, EIGRP incorporates a neighbor discovery and
    recovery process. This system involves the exchange of small Hello messages that
    let routers discover the other routers on the local network and periodically check
    to see whether they're reachable. This is very similar to the way the identically
    named Hello messages are used in OSPF (as described in [Chapter 39](ch39.html
    "Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)")) and has a low impact on bandwidth
    use because the messages are small and infrequently sent.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建计算路由所需的信息表，EIGRP要求路由器与其本地网络中的其他路由器建立并保持联系。为此，EIGRP集成了邻居发现和恢复过程。该系统涉及交换小的Hello消息，让路由器发现本地网络中的其他路由器，并定期检查它们是否可达。这与OSPF中同名Hello消息的使用方式非常相似（如第39章所述），因为消息很小且发送频率低，所以对带宽的使用影响很小。
- en: Some of the features in IGRP carry through to its successor, such as the use
    of split horizon with poisoned reverse for improved stability. In addition to
    the basic improvements of efficiency and route convergence that accrue from the
    algorithm itself, EIGRP includes some other features. These include support for
    Variable Length Subnet Masks (VLSM) as well as support for multiple network-layer
    protocols. This means that EIGRP could be configured to function on a network
    that is running IP as well as another layer 3 protocol.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: IGRP中的一些特性延续到了其继任者中，例如使用带有中毒反转的分割水平以增强稳定性。除了算法本身带来的基本效率提升和路由收敛改进外，EIGRP还包括一些其他特性。这些特性包括对可变长度子网掩码（VLSM）的支持以及支持多个网络层协议。这意味着EIGRP可以被配置在运行IP协议以及另一个第3层协议的网络中工作。
- en: Tip
  id: totrans-1014
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Developed in the 1990s, the *Enhanced Interior Gateway Routing
    Protocol (EIGRP)* is an improved version of Cisco''s IGRP. It is similar to IGRP
    in many respects, but it uses a more sophisticated route calculation method called
    the *Diffusing Update Algorithm (DUAL)*. EIGRP also includes several features
    that make it more intelligent with regard to how it computes routes; it borrows
    concepts from link-state routing protocols and uses more efficient partial updates,
    rather than sending out entire routing tables.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 20世纪90年代开发的*增强型内部网关路由协议（EIGRP）*是Cisco的IGRP的改进版本。它在许多方面与IGRP相似，但它使用了一种更复杂的路由计算方法，称为*扩散更新算法（DUAL）*。EIGRP还包括一些使它在计算路由方面更加智能化的特性；它借鉴了链路状态路由协议的概念，并使用更有效的部分更新，而不是发送整个路由表。'
- en: TCP/IP Exterior Gateway Protocol (EGP)
  id: totrans-1016
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP外部网关协议（EGP）
- en: 'In the days of the early Internet, a small number of centralized core routers
    that maintained complete information about network reachability did the routing.
    These core routers exchanged information using the historical interior routing
    protocol, GGP, which we examined earlier in this chapter. Other noncore routers
    located around the periphery of this core, both stand-alone and in groups, exchanged
    network reachability information with the core routers using the first TCP/IP
    exterior routing protocol: the *Exterior Gateway Protocol (EGP)*.'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期互联网时代，一小部分集中式核心路由器维护有关网络可达性的完整信息，负责路由。这些核心路由器使用我们在本章前面考察的历史内部路由协议GGP交换信息。其他位于核心外围的非核心路由器，无论是独立的还是成组的，都使用第一个TCP/IP外部路由协议：*外部网关协议（EGP）*与核心路由器交换网络可达性信息。
- en: Internet pioneers Bolt, Beranek, and Newman developed EGP in the early 1980s.
    It was first formally described in an Internet standard in RFC 827, "Exterior
    Gateway Protocol (EGP)," published in October 1982, which was later superseded
    by RFC 904, "Exterior Gateway Protocol Formal Specification," in April 1984\.
    Like GGP, EGP is now considered obsolete, having been replaced by BGP. However,
    like GGP, it is an important part of the history of TCP/IP routing, so it is worth
    examining briefly.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网先驱Bolt、Beranek和Newman在20世纪80年代初开发了EGP。它首次在1982年10月发布的互联网标准RFC 827，“外部网关协议（EGP）”中正式描述，该文件后来被1984年4月发布的RFC
    904，“外部网关协议正式规范”所取代。像GGP一样，EGP现在被认为是过时的，因为它已被BGP所取代。然而，像GGP一样，它是TCP/IP路由历史的一个重要部分，因此简要考察它是值得的。
- en: Note
  id: totrans-1019
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As I explained in [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING
    PROTOCOL CONCEPTS"), routers were in the past often called gateways. As such,
    exterior routing protocols were exterior gateway protocols. The EGP protocol discussed
    here is a specific instance of an exterior gateway protocol (also known as EGP).
    Thus, you may occasionally see BGP also called an* exterior gateway protocol *or
    an EGP, which is the generic use of the term*.'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如我在[第37章](ch37.html "第37章. 关键路由协议概述")中解释的那样，路由器在过去常常被称为网关。因此，外部路由协议被称为外部网关协议。这里讨论的EGP协议是外部网关协议（也称为EGP）的一个具体实例。因此，你有时可能会看到BGP也被称作*外部网关协议*或*EGP*，这是该术语的通用用法*。'
- en: EGP is responsible for the communication of network reachability information
    between neighboring routers that may or may not be in different ASes. The operation
    of EGP is somewhat similar to that of BGP (discussed in [Chapter 40](ch40.html
    "Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)")). Each EGP router maintains
    a database of information about which networks it can reach and how to reach them.
    It sends this information out on a regular basis to each router to which it is
    directly connected. Routers receive these messages and update their routing tables,
    and then use this new information to update other routers. Information about how
    to reach each network propagates across the entire internetwork.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: EGP负责在可能或可能不在不同AS中的相邻路由器之间通信网络可达性信息。EGP的操作与BGP（在第40章中讨论）的操作有些相似。每个EGP路由器维护一个关于它可以到达哪些网络以及如何到达它们的数据库。它定期将此信息发送给它直接连接的每个路由器。路由器接收这些消息并更新它们的路由表，然后使用这些新信息更新其他路由器。关于如何到达每个网络的信息在整个互联网中传播。
- en: 'The actual process of exchanging routing information involves several steps
    that discover neighbors and then set up and maintain communications. The steps
    are as follows:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 交换路由信息的实际过程涉及几个步骤，这些步骤用于发现邻居并设置和维护通信。步骤如下：
- en: '**Neighbor Acquisition** Each router attempts to establish a connection to
    each of its neighboring routers by sending Neighbor Acquisition Request messages.
    A neighbor hearing a request can respond with a Neighbor Acquisition Confirm message,
    which says that it recognized the request and wishes to connect. It may reject
    the acquisition by replying with a Neighbor Acquisition Refuse message. For an
    EGP connection to be established between a pair of neighbors, each message must
    first successfully acquire the other with a Confirm message.'
  id: totrans-1023
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**邻居获取** 每个路由器通过发送邻居获取请求消息来尝试与每个相邻路由器建立连接。当一个邻居听到请求时，它可以回复一个邻居获取确认消息，表示它已识别请求并希望连接。它也可以通过回复一个邻居获取拒绝消息来拒绝获取。为了在两个邻居之间建立EGP连接，每个消息必须首先通过确认消息成功获取对方。'
- en: '**Neighbor Reachability** After acquiring a neighbor, a router checks to make
    sure the neighbor is reachable and functioning properly on a regular basis. This
    is done by sending an EGP Hello message to each neighbor for which a connection
    has been established. The neighbor replies with an I Heard You (IHU) message.
    These messages are somewhat analogous to the BGP Keepalive message, but they are
    used in matched pairs.'
  id: totrans-1024
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**邻居可达性** 在获取一个邻居之后，路由器会定期检查以确保邻居可达并且正常工作。这是通过向已建立连接的每个邻居发送EGP问候消息来完成的。邻居会回复一个我听到了你（IHU）消息。这些消息在某种程度上类似于BGP保持活动状态消息，但它们是成对使用的。'
- en: '**Network Reachability Update** A router sends Poll messages on a regular basis
    to each of its neighbors. The neighbor responds with an Update message, which
    contains details about the networks that it is able to reach. This information
    is used to update the routing tables of the device that sent the Poll message.'
  id: totrans-1025
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络可达性更新** 路由器定期向其每个邻居发送轮询消息。邻居会回复一个更新消息，其中包含它能够到达的网络详情。这些信息用于更新发送轮询消息的设备的路由表。'
- en: A neighbor can decide to terminate a connection (called *neighbor deacquisition*)
    by sending a Cease message; the neighbor responds with a Cease-ack (acknowledge)
    message.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 一个邻居可以通过发送停止消息（称为*邻居去获取*）来决定终止一个连接；邻居会回复一个停止-确认（确认）消息。
- en: An Error message, similar to the BGP Notification message in role and structure
    (see [Chapter 40](ch40.html "Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)")),
    is also defined. A neighbor may send this message in response to the receipt of
    an EGP message either when the message itself has a problem (such as a bad message
    length or unrecognized data in a field) or to indicate a problem with how the
    message is being used (such as receipt of Hello or Poll messages at a rate deemed
    excessive). Unlike with the BGP Notification message, an EGP router does not necessarily
    close the connection when sending an Error message.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个错误消息，它在角色和结构上类似于BGP通知消息（见[第40章](ch40.html "第40章。边界网关协议（BGP/BGP-4)"))。邻居可能会在收到EGP消息时发送此消息作为响应，无论是消息本身存在问题（例如消息长度不良或字段中的数据不可识别）还是表示消息使用方式存在问题（例如以被认为过高的速率接收问候或轮询消息）。与BGP通知消息不同，EGP路由器在发送错误消息时并不一定关闭连接。
- en: Tip
  id: totrans-1028
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The *Exterior Gateway Protocol (EGP)* was the first TCP/IP
    exterior routing protocol and was used with GGP on the early Internet. It functions
    in a manner similar to BGP. For example, an EGP router makes contact with neighboring
    routers and exchanges routing information with them. A mechanism is also provided
    to maintain a session and report errors. EGP is more limited than BGP in capability
    and is now considered a historical protocol.'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *外部网关协议（EGP）* 是第一个TCP/IP外部路由协议，在早期互联网上与GGP一起使用。它以类似于BGP的方式工作。例如，EGP路由器会与相邻路由器建立联系并与之交换路由信息。还提供了一个机制来维护会话并报告错误。EGP在功能上比BGP有限，现在被认为是一个历史协议。'
- en: The early Internet was designed to connect peripheral routers or groups of routers
    to the Internet core. It was therefore designed under the assumption that the
    internetwork was connected as a hierarchical tree, with the core as the root.
    EGP was designed based on this assumption of a tree structure and, for that reason,
    cannot handle an arbitrary topology of ASes like BGP. It likewise cannot guarantee
    the absence of routing loops if such loops exist in the interconnection of neighboring
    routers. This is part of why BGP needed to be developed as the Internet moved
    to a more arbitrary structure of AS connections, where loops would be possible
    if steps weren't taken to avoid them.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的互联网设计是为了将边缘路由器或路由器组连接到互联网核心。因此，它是在假设互联网以层次树状结构连接的情况下设计的，核心作为根节点。EGP就是基于这种树状结构的假设设计的，因此，它无法处理像BGP那样的任意拓扑结构的AS。同样，如果相邻路由器之间的互联中存在路由循环，它也无法保证不存在路由循环。这也是为什么随着互联网向更任意的AS连接结构发展，BGP需要被开发出来，在这种结构中，如果不采取措施避免，循环是可能出现的。
