<html><head></head><body><section class="preface" epub:type="preface" id="introduction" title="Introduction"><div class="titlepage"><div><div><h2 class="title">Introduction</h2></div></div></div><p><span class="inlinemediaobject"><a id="inline_id00001"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> I asked a psychiatric nurse practitioner about paranoia, and was told that “paranoiais the feeling that people are after you.” A medical dictionary would give you a slightly different definition, but this one is actually terribly useful for any system administrator. It’s not that everyone on the Internet is trying to attack you, but there’s always <span class="emphasis"><em>someone</em></span> who wants to break into your system. Even if you think you have nothing of value, someone wants to own your computer. And you won’t realize the value of what you have until someone else has it. That’s just human nature.</p><p>If you’re not paranoid on the Internet, you’re in trouble.</p><p>That’s where OpenBSD comes in.</p><p>This book is an introduction to the OpenBSD operating system. OpenBSD is a member of the BSD family of operating systems. It is widely regarded as the most secure operating system available anywhere, under any licensing terms. It’s widely used by Internet service providers, embedded systems manufacturers, and anyone who needs security and stability. If you’re an experienced Unix system administrator who wants to add OpenBSD to your repertoire, this book is for you.</p><p><a class="indexterm" id="idx0098"/><a class="indexterm" id="idx0280"/><a class="indexterm" id="idx1064"/><a class="indexterm" id="idx2061"/>When you finish this book, you should be comfortable working with OpenBSD. You will understand how to configure, troubleshoot, and upgrade computers running OpenBSD and have a basic understanding of OpenBSD’s software, security, and network management features.</p><div class="sect1" title="What Is Security?"><div class="titlepage"><div><div><h2 class="title" id="what_is_security" style="clear: both">What Is Security?</h2></div></div></div><p>We bandy the word <span class="emphasis"><em>security</em></span> around a whole lot, so it’s worth taking a moment to talk about security itself. We all have a vague idea of what it means. “Security” means your stuff is safe, and other folks can’t get it. That’s fine, as far as it goes, but it doesn’t go far enough. In information technology, security has three parts:</p><div class="blockquote" title="Confidentiality"><blockquote class="blockquote" title="Confidentiality"><div class="blockquote-title">Confidentiality</div><p>This means that secret data should remain secret. Your private information must not get into the public eye. That Eastern European kiddie porn syndicate should not get your credit card number.</p></blockquote></div><div class="blockquote" title="Integrity"><blockquote class="blockquote" title="Integrity"><div class="blockquote-title">Integrity</div><p>This means that data on the system should not be changed without authorization. Your records should remain intact. That intruder should not change the shipping address on an order, making your staff ship a crate of really expensive stuff to an abandoned warehouse in Detroit.</p></blockquote></div><div class="blockquote" title="Availability"><blockquote class="blockquote" title="Availability"><div class="blockquote-title">Availability</div><p>This means that the system keeps running. If your business depends on your website, losing the website means losing business. Someone who can take your website down can starve your company. And all kinds of people are willing to shut you down, either to compete or just for laughs.</p></blockquote></div><p>Having been a system administrator for longer than some of you have been alive, I have a less formal idea of security. Security means eliminating bad days caused by computer problems. Spending a day getting a piece of software to compile is not a bad day. Is it an annoying day? Sure, but it’s not <span class="emphasis"><em>bad</em></span>. A day when I need to get intruders out of my systems is bad. A day when I have a meeting due to computer intrusions is bad. A day when I realize that I cannot trust any computer on the network, and I must reinstall every blasted piece of gear I own, is really bad.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id311899" id="id311899">1</a>]</sup></p><p>While OpenBSD cannot change the fact that some of my servers are old enough to leave elementary school, it can fix the software aspects of security.</p></div><div class="sect1" title="What Is BSD?"><div class="titlepage"><div><div><h2 class="title" id="what_is_bsd" style="clear: both">What Is BSD?</h2></div></div></div><p><a class="indexterm" id="idx0079"/><a class="indexterm" id="idx0199"/><a class="indexterm" id="idx0200"/><a class="indexterm" id="idx0274"/><a class="indexterm" id="idx0314"/><a class="indexterm" id="idx1132"/><a class="indexterm" id="idx2491"/>In the 1970s, AT&amp;T needed a lot of specialized, custom-written computer software to run its business. The company was forbidden to compete in the computer industry, so it could not sell this software. Instead, AT&amp;T licensed its software and the related source code to universities for nominal sums. Universities saved money by using this software instead of commercial equivalents with pricey licenses, and university students got access to this nifty technology and could learn how everything worked. In return, AT&amp;T got exposure, some pocket change, and a generation of computer scientists who had cut their teeth on AT&amp;T technology. Everyone got something out of the deal.</p><p>The best-known software distributed under this plan was UNIX.</p><p>Compared with modern operating systems, the original UNIX had a lot of problems. Thousands of students had access to its source code, however, and hundreds of teachers needed interesting projects for their students. If a program behaved oddly, or the operating system itself had a problem, the people who lived with the system had the tools and the motivation to fix it. Their efforts quickly improved UNIX and created many features we now take for granted. Students added the ability to control running processes, also known as <span class="emphasis"><em>job control</em></span>. The UNIX S51K filesystem made system administrators wail and gnash their teeth, so they replaced it with the Fast File System (FFS), which introduced a whole host of features that have crept into every modern filesystem. Over the years, many small, useful programs were added to UNIX, and entire subsystems were replaced.</p><p>The Computer Science Research Group (CSRG) at the University of California, Berkeley, acted as a central clearinghouse for UNIX code improvements from 1979 to 1994. The group collected changes from other universities, evaluated them, packaged them, and distributed the compilation for free to anyone with a valid AT&amp;T UNIX license. The CSRG also contracted with the Defense Advanced Research Projects Agency (DARPA) to implement various features in UNIX, such as TCP/IP. The resulting software collection came to be known as the Berkeley Software Distribution, or BSD. Users took the CSRG’s software, improved it further, and fed their improvements back into the CSRG. Today, we consider this a fairly standard way to run an open source project, but in 1979, it was revolutionary.</p><p>Fifteen years of work is a lifetime in software development. For comparison, Microsoft went from Windows 95 to Windows 7 in 15 years. The CSRG members collected so many enhancements and improvements to UNIX that they replaced almost all of the original UNIX with code created by the CSRG and its contributors. You had to look hard to find any original AT&amp;T code.</p><p>Eventually, the CSRG’s funding ebbed, and it became clear that the BSD project would end. After some political wrangling within the University of California, in 1992, the BSD code was released to the general public under what became known as the <span class="emphasis"><em>BSD license</em></span>.</p><div class="sect2" title="The BSD License"><div class="titlepage"><div><div><h3 class="title" id="the_bsd_license">The BSD License</h3></div></div></div><p><a class="indexterm" id="idx0080"/><a class="indexterm" id="idx0201"/><a class="indexterm" id="idx0298"/><a class="indexterm" id="idx0301"/><a class="indexterm" id="idx2490"/><a class="indexterm" id="idx2492"/><a class="indexterm" id="idx2494"/><a class="indexterm" id="idx2556"/>BSD code is available for anyone to use under what is probably the most permissive license in the history of software development. The license can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don’t claim you wrote this.</p></li><li class="listitem"><p>Don’t blame us if it breaks.</p></li><li class="listitem"><p>Don’t use our name to promote your product.</p></li></ul></div><p>Taken as a whole, this means that you can do almost anything you want with BSD code. (The original BSD license did require that users be notified if a software product included BSD-licensed code, but that requirement was later dropped.) You don’t even need to share any changes with the original authors! People could take BSD and include it in proprietary, open source, or free products.</p><p>Instead of a restrictive <span class="emphasis"><em>copyright</em></span>, or the more permissive but still restricted <span class="emphasis"><em>copyleft</em></span>, the BSD license is sometimes referred to as <span class="emphasis"><em>copycenter</em></span>, as in “take this down to the copy center and run off a few for yourself.” Not surprisingly, companies such as Sun Microsystems jumped right on BSD. It was free, it worked, and plenty of new graduates had experience with the technology. One company, BSDi, was formed specifically to take advantage of BSD Unix.</p></div><div class="sect2" title="AT&amp;T vs. the World"><div class="titlepage"><div><div><h3 class="title" id="at_t_vs_the_world">AT&amp;T vs. the World</h3></div></div></div><p>Back in AT&amp;T-land, UNIX development continued. AT&amp;T took parts of the BSD Unix distribution and integrated them with official UNIX, and then relicensed the results back to the universities that provided those improvements. This worked well for everyone until the US government broke up AT&amp;T, and the resulting companies were permitted to compete in the computer software business.</p><p>AT&amp;T had one particularly valuable software property: a high-end operating system that had been extensively debugged by thousands of people and had powerful features, such as a variety of small but mighty commands, a modern filesystem, job control, and TCP/IP. AT&amp;T started a subsidiary, Unix Systems Laboratories (USL), which happily started selling UNIX to enterprises and charging very high fees for it, all the while maintaining the university relationship that had given it such an advanced operating system in the first place.</p><p>The University of California, Berkeley’s public release of the BSD code met with great displeasure from USL. Almost immediately, USL sued the university and the software companies that had taken advantage of BSD. The University of California claimed that the CSRG had compiled BSD from thousands of third-party contributors unrelated to AT&amp;T, and that it was the CSRG’s intellectual property to dispose of as it saw fit. Oddly enough, the lawsuit promoted BSD to thousands of people who never would have heard of it otherwise, spawning open source BSD variants such as 386BSD, FreeBSD, and NetBSD.</p><p><a class="indexterm" id="idx0377"/><a class="indexterm" id="idx1588"/>In 1994, after two years of legal wrangling, the University of California lawyers proved that the majority of AT&amp;T UNIX was actually taken from BSD, rather than the other way around. To add insult to injury, AT&amp;T had violated the BSD license by stripping the CSRG copyright from the files it had appropriated</p><p>Only about a half-dozen files remained as the source of contention. Bruised and broken in court, USL donated some of those files to BSD while retaining others as proprietary information. BSD 4.4-Lite was released, containing everything except the proprietary files. Due to those missing files, BSD 4.4-Lite was the only formal operating system release ever that was known to not be usable or even compilable as delivered. Everyone knew this, and bought it anyway—a historic feat that modern vendors probably wish they could replicate.</p><p>A subsequent update, BSD 4.4-Lite2, is the grandfather of OpenBSD, as well as all other BSD code in use today, such as that in FreeBSD, NetBSD, and Mac OS X.</p></div></div><div class="sect1" title="The Birth of OpenBSD"><div class="titlepage"><div><div><h2 class="title" id="the_birth_of_openbsd" style="clear: both">The Birth of OpenBSD</h2></div></div></div><p>Theo de Raadt was a NetBSD developer. After many strong, broad, and long-running disagreements with other NetBSD team members on how the project should be run, he went out on his own and founded the OpenBSD Project, attracting like-minded developers. The OpenBSD team quickly established an identity as a security-focused group, and it is now one of the best-known BSD descendants.</p><p>The OpenBSD team developers have introduced several ideas into the open source operating system world that are now taken for granted, such as public read-only access to the CVS repository and commit logs. They’ve also created several pieces of software that have become industry standards across many operating systems, such as <code class="literal">sudo</code> and the ubiquitous OpenSSH.</p><p>Today, many major companies rely on OpenBSD as a reliable, secure operating system with fanatical attention to security, correctness, usability, and freedom. OpenBSD runs on many different sorts of hardware, including the standard 32-bit and 64-bit “Intel PC” (i386 and amd64), Apple’s PowerPC Macintoshes (macppc), Sparc (sparc and sparc64), and obscure platforms such as the Sharp Zaurus PDA, the Lemote Yeeloong, and antediluvian VAXes. OpenBSD puts almost all of its effort into security features, security debugging, and code correctness, and has demonstrated in the process that correct code has a much lower failure rate, and hence greater security. OpenBSD strives to be the ultimate secure operating system.</p><p>The OpenBSD team continually improves the operating system. New features are added only once they meet the team’s code and documentation standards. Even if new software is added before it is feature-complete, it is expected to have full documentation and correct code.</p></div><div class="sect1" title="The OpenBSD Community"><div class="titlepage"><div><div><h2 class="title" id="the_openbsd_community" style="clear: both">The OpenBSD Community</h2></div></div></div><p><a class="indexterm" id="idx0293"/><a class="indexterm" id="idx1522"/><a class="indexterm" id="idx1592"/>OpenBSD is more than just a collection of bits. It’s a community of users, developers, and contributors, with a single central dictator—er, coordinator. And this community can be a bit of a shock for anyone who doesn’t know what to expect.</p><p>How can individuals scattered all over the world create, maintain, and develop an operating system, let alone build a community? Almost all discussion occurs through email and online chat. The process is slower than talking face-to-face, but it’s the only cost-effective way for a large group of people in every time zone to communicate in a reasonable fashion. Email and chat also offer written records of discussions. If you want to participate in OpenBSD development, you must be comfortable with email. (There are OpenBSD-dedicated web forums, but they’re outside the main community.)</p><p>The OpenBSD community has four tiers: users, contributors, committers, and the coordinator.</p><div class="sect2" title="OpenBSD Users"><div class="titlepage"><div><div><h3 class="title" id="openbsd_users">OpenBSD Users</h3></div></div></div><p>Many open source operating systems put a lot of effort into growing their user base, evangelizing, and bringing new people into the Unix fold. OpenBSD does not.</p><p>Most open source Unix-like operating system groups do a lot of pro-Unix advocacy. Again, OpenBSD does not.</p><p>The communities surrounding other operating systems actively encourage new users and try to make newbies feel welcome. OpenBSD specifically and deliberately does not.</p><p>The OpenBSD community is not trying to be the most popular operating system—just the best at it what it does. The developers know exactly who their target market is: themselves. If you can use their work, that’s great. If not, go away until you can.</p><p>The OpenBSD community generally expects newcomers to be advanced computer users. The members have written extensive OpenBSD documentation, and expect newcomers to be willing to read it. They’re not interested in coddling new Unix users and, if pressed, will say so—often bluntly and forcefully. They will not hold your hand. They will not develop new features to please users. OpenBSD exists to meet the needs of the developers, and while others are welcome to ride along, the needs of the passengers do not steer the project.</p></div><div class="sect2" title="OpenBSD Contributors"><div class="titlepage"><div><div><h3 class="title" id="openbsd_contributors">OpenBSD Contributors</h3></div></div></div><p>Contributors are OpenBSD users who have the skills necessary to add features to the operating system, fix problems, write documentation, or accurately report problems. Problems range from typographical errors in the documentation to system crashes. Almost anyone can be a contributor. In fact, the community has even accepted problem reports from me, and resolved them within hours.</p><p><a class="indexterm" id="idx0269"/><a class="indexterm" id="idx0297"/><a class="indexterm" id="idx0378"/><a class="indexterm" id="idx1618"/>Every OpenBSD feature is present because some contributor took the time to write the code for it. Contributors who submit careful, correct fixes, or who provide useful problem reports, are welcome in the OpenBSD community. And if a contributor submits enough fixes of sufficient quality, he might be offered the role of committer.</p></div><div class="sect2" title="OpenBSD Committers"><div class="titlepage"><div><div><h3 class="title" id="openbsd_committers">OpenBSD Committers</h3></div></div></div><p>Committers have write access to the main OpenBSD source code repository. They can make whatever changes they deem necessary for their OpenBSD projects, but are answerable to each other and to the project coordinator. Most committers are skilled programmers who work on OpenBSD during their own time.</p><p>While being a committer seems glamorous, the role carries a lot of responsibility. If a committer breaks the operating system or changes something so that it conflicts with OpenBSD’s driving “vision,” he must fix it. Committers try to avoid breaking things, and frequently make their work available on websites and mailing lists before it’s integrated into the main OpenBSD source code collection, allowing interested people to preview, test, and double-check their work.</p><p>Many committers have very specific coordination roles within OpenBSD. For example, quite a few hardware architectures have a point man for issues that affect that hardware, the compiler has a maintainer, and so on. These committers have earned that position of trust in the community.</p></div><div class="sect2" title="OpenBSD Coordinator"><div class="titlepage"><div><div><h3 class="title" id="openbsd_coordinator">OpenBSD Coordinator</h3></div></div></div><p>Theo de Raadt started OpenBSD in 1995 and still coordinates the project. He is the final word on how the system should work, what is included in the system, and who gets direct access to the repository. He resolves all disputes that contributors and committers cannot resolve among themselves. Theo takes whatever actions necessary to keep the OpenBSD Project running smoothly. If something should ever happen to Theo, the project does have plans for replacing him.</p><p>Building the OpenBSD organization around a central benevolent dictator avoids a lot of the management problems other large open source projects have.</p><p>If you decide to work on OpenBSD, you must accept Theo’s decisions as final. A contributor who doesn’t accept the project’s leader won’t remain with the community for long. Theo might have a big stick, but as he is the acknowledged project leader, he doesn’t need to use it nearly as often as you might think.</p></div></div><div class="sect1" title="OpenBSD’s Strengths"><div class="titlepage"><div><div><h2 class="title" id="openbsds_strengths" style="clear: both">OpenBSD’s Strengths</h2></div></div></div><p>What makes OpenBSD OpenBSD? Why bother with yet another Unix-like operating system when there are so many out there, several closely related to OpenBSD? What makes this operating system worth a computer, let alone worthy of protecting your company’s assets?</p><div class="sect2" title="Portability"><div class="titlepage"><div><div><h3 class="title" id="portability">Portability</h3></div></div></div><p><a class="indexterm" id="idx0511"/><a class="indexterm" id="idx1303"/><a class="indexterm" id="idx1305"/><a class="indexterm" id="idx1815"/><a class="indexterm" id="idx1854"/>OpenBSD is designed to run on a wide variety of popular processors and hardware platforms, including Intel-compatible (both 32-bit and 64-bit), Alpha, Macintosh (both PowerPC and Intel systems), and almost anything from Sun. It runs on tiny devices such as the Sharp Zaurus, hefty Hewlett-Packard HP 9000 systems, certain Silicon Graphics workstations, and whatever else grabs the developers’ attention. The OpenBSD team wants to support as many interesting hardware architectures as it has the hardware and skills to maintain, so more are added regularly, and chances are most computers you encounter can run OpenBSD.</p><p>That said, when a hardware platform becomes too obscure, OpenBSD stops supporting it. A few MIPS systems, 68K Macintosh hardware, and Amiga systems are examples of systems that run older versions of OpenBSD but are not supported by new releases.</p></div><div class="sect2" title="Power"><div class="titlepage"><div><div><h3 class="title" id="power">Power</h3></div></div></div><p>As a matter of legacy, OpenBSD will run on hardware that has been obsolete for decades because the hardware was in popular use when OpenBSD started, and the developers try to maintain compatibility and performance when possible. This includes platforms such as the VAX and Alpha, which were considered powerful in the 1980s and 1990s. While someone running OpenBSD on a dual-core 64-bit system might not notice a programming change in OpenBSD that increases the amount of CPU time needed to process network packets, people running OpenBSD on VAX systems will quickly notice that same change.</p><p>Of course, some performance-impacting changes cannot be avoided. For example, systems must support IPv6 in the very near future, and I suspect that decades-old hardware will struggle to keep up. OpenBSD cannot turn back the clock, but it will leave every scrap of computing power possible for your applications. And after all, that’s what’s important—people use applications, not operating systems. This focus on performance means that a system running OpenBSD with a 1GB disk and a 486 CPU can still support real applications, such as a DNS or web server.</p></div><div class="sect2" title="Documentation"><div class="titlepage"><div><div><h3 class="title" id="documentation">Documentation</h3></div></div></div><p>Many free software projects are satisfied when they release code. Some think that they go above and beyond by including a help function in the program itself, available by typing some command-line flag. Others really go wild and offer a grammatically incorrect and technically vague manual page.</p><p>The OpenBSD community expects the documentation to be both complete and accurate. The manual pages for system and library calls are extensive, even when compared to other BSDs, and include discussions on usage and security.</p><p>Documentation errors are considered serious bugs, and are treated as harshly as any other serious bug. This might sound extreme, but in its own internal audits, the OpenBSD team has found any number of instances where programmers used a library interface exactly as recommended in the manual page, but errors in the manual page made the usage dangerous or insecure. Documentation is important.</p></div><div class="sect2" title="Free"><div class="titlepage"><div><div><h3 class="title" id="free">Free</h3></div></div></div><p><a class="indexterm" id="idx0379"/><a class="indexterm" id="idx0887"/>In the spirit of the original BSD license, OpenBSD is free for use in any way, by anyone, for any purpose. You can use it with any tool you like, on any computer.</p><p>Most of today’s free software is licensed under terms that require software distributors to return any changes to the project’s owner, but OpenBSD doesn’t even carry that requirement. You can use OpenBSD in your proprietary system, ship that system everywhere in the world, and not pay the developers a dime.</p><p>OpenBSD is perhaps the freest of the free operating systems. Like every other free Unix-like operating system, the source code inherited from BSD originally contained a wide variety of programs that shipped under conditional licenses. Some were free for noncommercial use. Some were free if you changed the name once you changed the code. Others had a variety of obscure licensing terms, such as indemnifying a third party against lawsuits. These programs have either been relicensed (with the permission of the original author) or ripped out and replaced with free alternatives.</p><p>The word <span class="emphasis"><em>freedom</em></span> has been given a lot of different twists by people in the programming community. Some believe that software is free if you can download it and use it. Some believe that software is only free if the end user gets the source code. The OpenBSD idea of freedom is that its code can be used for any purpose, by anyone.</p><p>Consider this: During a discussion on an OpenBSD mailing list regarding licensing terms,<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id466399" id="id466399">2</a>]</sup> Theo de Raadt said:</p><div class="blockquote"><blockquote class="blockquote"><p>We know what a free license should say.</p><p>It should say</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p>Copyright foo</p></li><li class="listitem" style="list-style-type: none"><p>I give up my rights and permit others to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p>distribute</p></li><li class="listitem" style="list-style-type: none"><p>sell</p></li><li class="listitem" style="list-style-type: none"><p>give</p></li><li class="listitem" style="list-style-type: none"><p>modify</p></li><li class="listitem" style="list-style-type: none"><p>use</p></li></ul></div></li><li class="listitem" style="list-style-type: none"><p>I retain the right to be known as the author/owner</p></li></ul></div><p>When it says something else, ask this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p>- is it 100% guaranteed fluff which cannot ever affect anyone?</p></li><li class="listitem" style="list-style-type: none"><p>- is it giving away even more rights (the author right)?</p></li></ul></div><p>If not, then it must be giving someone more rights, or by the same token—taking more rights away from someone else!</p><p>Then it is _less_ free than our requirements state!</p></blockquote></div><p><a class="indexterm" id="idx2062"/>The OpenBSD team works hard to ensure that every line of code it supports is licensed in this manner.</p><div class="note" title="Note"><h3 class="title"><a id="prenote01"/>Note</h3><p>The source code tree does include code under different licenses, such as the GNU C compiler <code class="literal">gcc</code>, binutils, and so on. OpenBSD <span class="emphasis"><em>runs</em></span> fine without them—you just can’t <span class="emphasis"><em>compile</em></span> OpenBSD without them.</p></div><p>This is pretty straightforward. OpenBSD is a gift. You’re free to use it or not. As with any gift, you can do whatever you want with it. But you’re not free to bug the developers for features or support.</p></div><div class="sect2" title="Correctness"><div class="titlepage"><div><div><h3 class="title" id="correctness">Correctness</h3></div></div></div><p>Every skilled programmer knows that programs written correctly are more reliable, predictable, and secure. However, many free software producers are satisfied if their code compiles and simply seems to work, and quite a few commercial software companies don’t give their programmers time to write their code correctly.</p><p>OpenBSD developers strive to implement solutions correctly. They make it a strict rule to write programs in a reliable and secure manner, following best current programming practices. And exposing the code to “weird” environments such as ancient VAXes is part of the discipline; OpenBSD developers insist that some subtle bugs (and a few less subtle ones) have been pinpointed only during testing on one of OpenBSD’s less mainstream architectures. Fixing those bugs benefits all users, of course.</p><p>OpenBSD implementations follow UNIX standards, such as the Portable Operating System Interface (POSIX) and the American National Standards Institute (ANSI), but they are less concerned about extensions to these standards created by third parties. For example, many Linux extensions do not appear in OpenBSD. When those extensions are added to standards, the OpenBSD team will add them.</p><p>OpenBSD code has been repeatedly audited for correctness through a lot of hard work. Anyone who tries to introduce incorrect code will be turned away—generally politely, and often with constructive criticism, but turned away nonetheless. And that brings us to OpenBSD’s most well-known claim to fame.</p></div><div class="sect2" title="Security"><div class="titlepage"><div><div><h3 class="title" id="security">Security</h3></div></div></div><p>OpenBSD strives to be the most secure operating system in the world. While it can reasonably make that claim today, maintaining that position requires constant effort. Intruders constantly try new ways to penetrate computers, which means that today’s feature might be tomorrow’s security problem. As OpenBSD developers learn of new classes of programming errors and security holes, they scan the entire source tree for that type of problem and make fixes before anyone even knows how these issues <span class="emphasis"><em>might</em></span> be exploited.</p><p>Additionally, OpenBSD takes advantage of any security features offered by hardware. For example, AMD’s 64-bit Intel-compatible CPUs can mark a page of memory as either executable or writable, but not both. (Intel later copied this feature.) This alleviates many buffer overflow attacks, but the operating system must use this facility. OpenBSD supported this feature in 2003, shortly after the hardware was released. In fact, OpenBSD generally supports all hardware security features offered on a platform.</p><p>The history of computing shows that users cannot be expected to patch or maintain their own systems. Systems must be secure against existing and future attacks out of the box. OpenBSD’s goal is to eliminate problems before they exist.</p></div></div><div class="sect1" title="OpenBSD and Your Security"><div class="titlepage"><div><div><h2 class="title" id="openbsd_and_your_security" style="clear: both">OpenBSD and Your Security</h2></div></div></div><p>Even though OpenBSD is tightly secured, intruders still break into OpenBSD systems. This might seem contradictory, but in truth, it means that the person running the computer didn’t understand computer security.</p><p>OpenBSD has many integrated security features, but you cannot assume that these features secure everything running on the system. That’s just not possible. No operating system can defend itself against operator error. An operating system can protect itself from software problems to a limited extent, but ultimately, the responsibility for security is the administrator’s.</p><p>Consider a web server—even OpenBSD’s integrated Apache server—running on OpenBSD. OpenBSD provides the web server with a stable, reliable platform, and will provide services as the web server requests, within the limits assigned by the system administrator. If the system administrator has configured the web server correctly, a web server failure will not endanger the operating system. If the system administrator configures the web server to run with unlimited privileges, the web server can inflict almost unrestricted damage on the underlying system.</p><p>Or consider a less extreme case. The web server might be configured correctly, but suppose you install insecure forum software. An intruder can break into the forum and edit its data—maybe grab the username and password the forum software uses to access the local database. If that account information matches a system-level username and password, the intruder might be able to leverage them to gain access to the system. Or perhaps he can use that username and password to get administrator-level access to the database and penetrate other applications. What if those applications have elevated privileges?</p><p>Only careful, consistent, thoughtful work by a system administrator can prevent intrusions. Throughout this book, we’ll discuss some basic security precautions you should take when installing and running software. We’ll also discuss the advanced security features OpenBSD offers in order to protect itself.</p></div><div class="sect1" title="OpenBSD’s Uses"><div class="titlepage"><div><div><h2 class="title" id="openbsds_uses" style="clear: both">OpenBSD’s Uses</h2></div></div></div><p><a class="indexterm" id="idx1621"/>Where does OpenBSD fit into your computing strategy? That ultimately depends on your strategy and your needs. OpenBSD can be used anywhere you need a solid, reliable, and secure system. I recommend OpenBSD for any of three different roles: a desktop, a server, or network management.</p><div class="sect2" title="Desktop"><div class="titlepage"><div><div><h3 class="title" id="desktop">Desktop</h3></div></div></div><p>If you need a powerful desktop system with all the features you would expect from a complete Unix-like workstation, OpenBSD will do nicely. Graphic interfaces, office suites, web browsers, and other desktop software are available in the ports collection, OpenBSD also supports a variety of development tools, application environments, network servers, and other features that programmers and web developers need. If you’re a network administrator, you’ll find that OpenBSD supports packet sniffers, traffic analyzers, and all the other programs you rely on.</p></div><div class="sect2" title="Server"><div class="titlepage"><div><div><h3 class="title" id="server">Server</h3></div></div></div><p>If you’re serving web pages, handling email, providing Lightweight Directory Access Protocol (LDAP) or database services, or offering any other sort of network service to clients, OpenBSD can help you. It’s a cheap and reliable platform. Once it’s set up, it just works. And, of course, it’s secure, which you cannot underestimate on the Internet.</p></div><div class="sect2" title="Network Management"><div class="titlepage"><div><div><h3 class="title" id="network_management">Network Management</h3></div></div></div><p>OpenBSD makes an excellent firewall, bridge, or traffic shaper. You can use it to support intrusion detection software, web proxies, and traffic monitors. The integrated packet-filtering firewall and supporting software provides state-of-the-art network connection management and control, and can strip out many dangerous types of traffic before it reaches your servers. And its load-balancer features are competitive, with many commercial offerings that cost thousands of dollars more.</p></div></div><div class="sect1" title="About This Book"><div class="titlepage"><div><div><h2 class="title" id="about_this_book" style="clear: both">About This Book</h2></div></div></div><p>This book is written for experienced Unix users or system administrators who want to add OpenBSD to their repertoire. I assume you’re familiar with basic commands, such as <code class="literal">tail(1)</code>, <code class="literal">chmod(1)</code>, <code class="literal">ping(8)</code>, and so on, and that you know why each command in this list includes a number in parentheses after the name. We’ll discuss many programs that you might already be familiar with, but that might be slightly different in OpenBSD.</p><p>For maximum benefit, you should install OpenBSD on a dedicated machine. OpenBSD can coexist with other operating systems or run in a virtual machine, but if you’re going to use OpenBSD in a production environment, you should run it on its own.</p><p>Many people believe that OpenBSD is not the easiest Unix-like operating system, or the easiest version of BSD, or even the easiest open source BSD. OpenBSD doesn’t have handy wizards that walk you through each stage of the configuration process, although it does has a few menu-driven front ends. Once you’re familiar with how the system works, though, such wizards would only get in the way.</p><p>To truly understand OpenBSD, you must be willing to learn, experiment, and spend time accumulating understanding. Much of this knowledge can be directly applied to other versions of BSD, other Unix-like operating systems, and even completely foreign operating systems, such as Microsoft’s Windows.</p></div><div class="sect1" title="Contents Overview"><div class="titlepage"><div><div><h2 class="title" id="contents_overview" style="clear: both">Contents Overview</h2></div></div></div><p>While this book is designed to be read from front to back, here’s a brief description of each chapter, in case you would rather skip around randomly.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="Chapter 1"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch01.html" title="Chapter 1. Getting Additional Help">Chapter 1</a></strong></span></strong></span>. Discusses the OpenBSD documentation available both in the installed system and on the Web. You need to understand what you’re getting into before installing OpenBSD.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 2"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch02.html" title="Chapter 2. Installation Preparations">Chapter 2</a></strong></span></strong></span>. Discusses installation on a standard amd64 (also known as the 64-bit Intel-compatible) system. Making some decisions before you install OpenBSD will ensure that you don’t need to reinstall it later.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 3"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch03.html" title="Chapter 3. Installation Walk-Through">Chapter 3</a></strong></span></strong></span>. Carries you through every step of a real OpenBSD installation. The OpenBSD installer assumes a certain level of knowledge about computer hardware and OpenBSD that you might not yet possess. This walk-through will guide you through the rough spots.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 4"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch04.html" title="Chapter 4. Post-Install Setup">Chapter 4</a></strong></span></strong></span>. Discusses the basic steps you should take after installing OpenBSD to make your system secure, stable, and usable.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 5"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch05.html" title="Chapter 5. The Boot Process">Chapter 5</a></strong></span></strong></span>. Covers system startup. Different situations require different startup methods, and we’ll cover them all. We’ll also discuss how OpenBSD starts its component software.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 6"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch06.html" title="Chapter 6. User Management">Chapter 6</a></strong></span></strong></span>. Discusses how to add, remove, and restrict OpenBSD user accounts.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 7"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch07.html" title="Chapter 7. Root, and How to Avoid It">Chapter 7</a></strong></span></strong></span>. Discusses controlling user privileges and permissions. OpenBSD includes powerful tools such as classes and limits, as well as the privilege management tool <code class="literal">sudo(8)</code>.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 8"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch08.html" title="Chapter 8. Disks and Filesystems">Chapter 8</a></strong></span></strong></span>. Covers disk management with the standard OpenBSD filesystems.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 9"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch09.html" title="Chapter 9. More Filesystems">Chapter 9</a></strong></span></strong></span>. Covers advanced filesystem topics such as the Network File System (NFS), working with disk images, software RAID, and encrypted disks.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 10"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch10.html" title="Chapter 10. Securing Your System">Chapter 10</a></strong></span></strong></span>. Considers how to maintain security using tools such as file flags, securelevels, OpenBSD security announcements, and some basic cryptographic tools.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 11"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch11.html" title="Chapter 11. Overview of TCP/IP">Chapter 11</a></strong></span></strong></span>. Reviews the basics of TCP/IP versions 4 and 6, and covers some of OpenBSD’s tools for examining and troubleshooting the network.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 12"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch12.html" title="Chapter 12. Connecting to the Network">Chapter 12</a></strong></span></strong></span>. Takes you through configuring OpenBSD’s network stack for Ethernet, trunks, and virtual local area networks (VLANs).</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 13"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch13.html" title="Chapter 13. Software Management">Chapter 13</a></strong></span></strong></span>. Describes OpenBSD’s add-on software tools. You’ll learn how to install precompiled software, compile your own software, and verify and remove software.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 14"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch14.html" title="Chapter 14. Everything /etc">Chapter 14</a></strong></span></strong></span>. Describes each major file in <span class="emphasis"><em>/etc</em></span> that isn’t covered elsewhere, and discusses how you might want to use those files.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 15"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch15.html" title="Chapter 15. System Maintenance">Chapter 15</a></strong></span></strong></span>. Covers the various ways OpenBSD maintains itself and how you can make those processes fit your environment and workflow.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 16"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch16.html" title="Chapter 16. Network Servers">Chapter 16</a></strong></span></strong></span>. Covers configuring software integrated with OpenBSD. You’ll learn about the system logger and log file management, the DHCP server, the web server, and more.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 17"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch17.html" title="Chapter 17. Desktop OpenBSD">Chapter 17</a></strong></span></strong></span>. Covers software useful to OpenBSD as a desktop, such as the window manager <code class="literal">cwm(1)</code> and Xenocara. This chapter includes coverage of important software that makes using OpenBSD with a desktop easier, such as SSH keys and <code class="literal">tmux</code>.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 18"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch18.html" title="Chapter 18. Kernel Configuration">Chapter 18</a></strong></span></strong></span>. Discusses the various tools available to configure a standard kernel. Unlike many other free Unix-like operating systems, OpenBSD does not expect or require the system administrator to compile a kernel. You can tune the standard kernels without recompiling.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 19"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch19.html" title="Chapter 19. Building Custom Kernels">Chapter 19</a></strong></span></strong></span>. Discusses how to recompile a kernel in those rare instances when you must.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 20"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch20.html" title="Chapter 20. Upgrading">Chapter 20</a></strong></span></strong></span>. Covers how to upgrade OpenBSD, either from a snapshot or from source.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 21"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch21.html" title="Chapter 21. Packet Filtering">Chapter 21</a></strong></span></strong></span>. Documents OpenBSD’s integrated packet-filtering engine, PF. It includes discussions of real-world situations and how to handle them.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 22"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch22.html" title="Chapter 22. Advanced PF">Chapter 22</a></strong></span></strong></span>. Introduces things that the packet filter can do beyond just filtering packets.</p></li><li class="listitem" style="list-style-type: none"><p title="Chapter 23"><span class="title"><strong><span class="strong"><strong><a class="xref" href="ch23.html" title="Chapter 23. Customizing OpenBSD">Chapter 23</a></strong></span></strong></span>. Includes tidbits that didn’t fit anywhere else but are not large enough topics to merit their own chapters. This includes diskless OpenBSD, building bootable USB installation media, and making custom OpenBSD installation sets.</p></li></ul></div><p>This book won’t cover everything OpenBSD can do, but it will get your feet firmly under the table. To learn the rest, you’ll need to access OpenBSD’s information resources, which is the subject of the first chapter.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id311899"><p><sup>[<a class="para" href="#id311899">1</a>] </sup>I still have bad days due to people, mind you, but I largely solve them by other means. Don’t ask about the mounds of dirt in my backyard.</p></div><div class="footnote" epub:type="footnote" id="ftn.id466399"><p><sup>[<a class="para" href="#id466399">2</a>] </sup>This is from October 24, 2002, on the openbsd-misc mailing list. It’s more than a decade old, but still pretty much says it all.</p></div></div></section></body></html>