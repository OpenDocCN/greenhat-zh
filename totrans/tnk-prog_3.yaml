- en: Chapter 3. Solving Problems with Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we limited ourselves to *scalar variables*, that is,
    variables that can hold only one value at a time. In this chapter, we’ll look
    at problems using the most common aggregate data structure, the array. Although
    arrays are simple structures with fundamental limitations, their use greatly magnifies
    the power of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will primarily deal with actual arrays, that is, those
    declared with the built-in C++ syntax, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, the techniques we discuss apply just as well to data structures with
    similar attributes. The most common of these structures is a vector. The term
    *vector* is often used as a synonym for any array of a single dimension, but we’ll
    use it here in the more specific sense of a structure that has the attributes
    of an array without a specified maximum number of elements. So for our discussions,
    an array is of a fixed size, while a vector can grow or shrink automatically as
    needed. Each of the problems we discuss in this chapter includes some restriction
    that allows us to use a structure with a fixed number of elements. Problems without
    such restrictions, however, could be adapted to use a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the techniques used with arrays can often be used with data structures
    that do not have every attribute listed above. Some techniques, for example, don’t
    require random access, so they can be used with structures like linked lists.
    Because arrays are so common in programming, and because array techniques are
    frequently used in non-array contexts, arrays are a great training ground for
    the study of problem solving with data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Review of Array Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should already know what an array is, but let’s go over some of the attributes
    of arrays for clarity. An *array* is a collection of variables of the same type
    organized under one name, where the individual variables are denoted by a number.
    We call the individual variables the *elements* of the array. In C++ and most
    other languages, the first element has number 0, but in some languages, this will
    vary.
  prefs: []
  type: TYPE_NORMAL
- en: The primary attributes of the array follow directly from the definition. Every
    value stored in an array is of the same type, whereas other aggregate data structures
    can store values of mixed types. An individual element is referenced by a number
    called a *subscript*; in other data structures, individual elements might be referenced
    by name or by a key value.
  prefs: []
  type: TYPE_NORMAL
- en: From these primary attributes, we can derive several secondary attributes. Because
    each of the elements is designated by a number in a sequence starting from 0,
    we can easily examine every value in an array. In other data structures, this
    may be difficult, inefficient, or even impossible. Also, whereas some data structures,
    such as linked lists, can be accessed only sequentially, an array offers *random
    access*, meaning we can access any element of the array at any time.
  prefs: []
  type: TYPE_NORMAL
- en: These primary and secondary attributes determine how we can use arrays. When
    dealing with any aggregate data structure, it’s good to have a set of basic operations
    in mind as you consider problems. Think of these basic operations as common tools—the
    hammers, screwdrivers, and wrenches of the data structure. Not every mechanical
    problem can be solved with common tools, but you should always consider whether
    a problem can be solved with common tools before making a trip to the hardware
    store. Here’s my list of basic operations for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most basic of operations. An array is a collection of variables,
    and we can assign a value to each of those variables. To assign the integer 5
    to the first element (element 0) in the previously declared array, we just say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As with any variable, the values of the elements inside our array will be random
    “garbage” until particular values are assigned, so arrays should be initialized
    before they are used. In some cases, especially for testing, we will want to assign
    a particular value to every element in the array. We can do that with an initializer
    when the array is declared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll see a good use of an array initializer shortly. Sometimes, instead of
    assigning a different value to each element, we just want every element in the
    array to be initialized to the same value. There are some shortcuts for assigning
    a zero to every element in the array, depending on the situation or the compiler
    used (the C++ compiler in Microsoft Visual Studio, for example, initializes every
    value in any array to zero unless otherwise specified). At this stage, however,
    I would always explicitly initialize an array wherever initialization is required
    in order to enhance readability, as in this code, which sets every element in
    a 10-element array to −1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Copy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make a copy of the array. There are two common situations in which this
    might be useful. First, we might want to heavily manipulate the array but still
    require the array in its original form for later processing. Putting the array
    back in its original form after manipulation may be difficult, or even impossible,
    if we’ve changed any of the values. By copying the entire array, we can manipulate
    the copy without disturbing the original. All we need to copy an entire array
    is a loop and an assignment statement, just like the code for initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That operation is available to most aggregate data structures. The second situation
    is more specific to arrays. Sometimes we want to copy part of the data from one
    array to a second array, or we want to copy the elements from one array to a second
    array as a method of rearranging the order of the elements. If you have studied
    the merge-sort algorithm, you’ve seen this idea in action. We’ll see examples
    of copying later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieval and Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the ability to put values into the array, we also need the ability to
    get them out of the array. Retrieving the value from a particular location is
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Searching for a Specific Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually the situation isn’t that simple. Often we don’t know the location we
    need, and we instead have to *search* the array to find the location of a specific
    value. If the elements in the array are in no particular order, the best we can
    do is a sequential search, where we look at each element in the array from one
    end to the other until we find the desired value. Here’s a basic version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have a constant that stores the size of the array ![](httpatomoreillycomsourcenostarchimages1273182.png),
    the array itself ![](httpatomoreillycomsourcenostarchimages1273191.png), a variable
    to store the value we are looking for in the array ![](httpatomoreillycomsourcenostarchimages1273193.png),
    and a variable to store the location where the value is found ![](httpatomoreillycomsourcenostarchimages1273195.png).
    In this example, we use our `ARRAY_SIZE` constant to limit the number of iterations
    over our array ![](httpatomoreillycomsourcenostarchimages1273197.png), so that
    we won’t run past the end of the array when `targetValue` is not found among the
    array elements. You could “hard-wire” the number 10 in place of the constant,
    but using the constant makes the code more general, thus making it easy to modify
    and reuse. We’ll use an `ARRAY_SIZE` constant in most of the code in this chapter.
    Note that if `targetValue` is not found in `intArra``y`, then `targetPos` will
    be equal to `ARRAY_SIZE` after the loop. This is enough to signify the event because
    `ARRAY_SIZE` is not a valid element number. It will be up to the code that follows,
    however, to check that. Also note that the code makes no effort to handle the
    possibility that the target value appears more than once. The first time the target
    value appears, the loop is over.
  prefs: []
  type: TYPE_NORMAL
- en: Criterion-Based Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the value we are looking for isn’t a fixed value but a value based
    on the relationship with other values in the array. For example, we might want
    to find the highest value in the array. The mechanism to do that is what I call
    “King of the Hill,” in reference to the playground game. Have a variable that
    represents the highest value seen *so far* in the array. Run through all the elements
    in the array with a loop, and each time you encounter a value higher than the
    previous highest value, the new value knocks the previous king off the hill, taking
    his place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The variable `highestValue` stores the largest value found in the array so far.
    At its declaration, it is assigned the value of the first element in the array
    ![](httpatomoreillycomsourcenostarchimages1273182.png), which allows us to start
    the loop at the second element in the array (it allows us to start with `i` at
    1 instead of 0) ![](httpatomoreillycomsourcenostarchimages1273191.png). Inside
    the loop, we compare the value at the current position with `highestValue`, replacing
    `highestValue` if appropriate ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Note that finding the lowest value, instead of the highest, is just a matter of
    switching the “greater-than” comparison ![](httpatomoreillycomsourcenostarchimages1273195.png)
    to a “less-than” comparison (and changing the name of the variable so we don’t
    confuse ourselves). This basic structure can be applied to all sorts of situations
    in which we want to look at every element in the array to find the value that
    most exemplifies a particular quality.
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sorting* means putting data in a specified order. You have probably already
    encountered sorting algorithms for arrays. This is a classic area for performance
    analysis because there are so many competing sorting algorithms, each with performance
    characteristics that vary depending on features of the underlying data. The study
    of different sorting algorithms could be the subject of an entire book by itself,
    so we’re not going to explore this area in its full depth. Instead, we’re going
    to focus on what is practical. For most situations, you can make do with two sorts
    in your toolbox: a fast, easy-to-use sort and a decent, easy-to-understand sort
    that you can modify with confidence when the situation arises. For fast and easy,
    we’ll use the standard library function `qsort`, and when we need something to
    tweak, we’ll use an insertion sort.'
  prefs: []
  type: TYPE_NORMAL
- en: Fast-and-Easy Sorting with qsort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default fast sort for C/C++ programmers is the `qsort` function in the
    standard library (the name suggests that the underlying sort employs a quicksort,
    but the implementer of the library is not required to use that algorithm). To
    use `qsort`, we have to write a comparator function. This function will be called
    by `qsort` whatever it needs to compare two elements in the array to see which
    should appear earlier in sorted order. The function is passed two `void` pointers.
    We haven’t discussed pointers yet in this book, but all you need to know here
    is that you should cast those `void` pointers to pointers to the element type
    in your array. Then the function should return an `int`, either positive, negative,
    or zero, based on whether the first element is larger, smaller, or equal to the
    second element. The exact value returned doesn’t matter, only whether it is positive,
    negative, or zero. Let’s clear up this discussion with a quick example of sorting
    an array of 10 integers using `qsort`. Our comparator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The parameter list consists of two `const void` pointers ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Again, this is always the case for the comparator. The code inside the function
    begins by declaring two `int` pointers ![](httpatomoreillycomsourcenostarchimages1273191.png)
    and casting the two `void` pointers to the `int` pointer type. We could write
    the function without the two temporary variables; I’m including them here for
    clarity. The point is, once we are done with those declarations, `intA` and `intB`
    will point at two elements in our array, and `*intA` and `*intB` will be two integers
    that must be compared. Finally, we return the result of subtracting the second
    integer from the first ![](httpatomoreillycomsourcenostarchimages1273193.png).
    This produces the result we want. If `intA` > `intB`, for example, we want to
    return a positive number, and `intA` – `intB` will be positive if `intA` > `intB`.
    Likewise, `intA` – `intB` will be negative if `intB` > `intA` and will be zero
    when the two integers are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the comparator function in place, a sample use of `qsort` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the call to `qsort` takes four parameters: the array to be
    sorted ![](httpatomoreillycomsourcenostarchimages1273182.png); the number of elements
    in that array ![](httpatomoreillycomsourcenostarchimages1273191.png); the size
    of one element in the array, usually determined, as it is here, by the `sizeof`
    operator ![](httpatomoreillycomsourcenostarchimages1273193.png); and finally,
    the comparator function ![](httpatomoreillycomsourcenostarchimages1273195.png).
    If you haven’t had much experience passing functions as parameters to other functions,
    note the syntax used for the last parameter. We are passing the function itself,
    not calling the function and passing the result of the call. Therefore, we simply
    state the name of the function, with no parameter list or parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: Easy-to-Modify Sorting with Insertion Sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, you will need to write your own sorting code. Sometimes the
    built-in sort just won’t work for your situation. For example, suppose you had
    an array of data that you wanted to order based on the data in *another* array.
    When you have to write your own sort, you will want a straightforward sorting
    routine that you believe in and can crank out on demand. A reasonable suggestion
    for a go-to sort is an *insertion sort*. The insertion sort works the way many
    people would sort cards when playing bridge: They pick up the cards one at a time
    and insert them in the appropriate place in their hands to maintain the overall
    order, moving the other cards down to make room. Here’s a basic implementation
    for our integer array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We start by declaring two variables, `start` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and `end` ![](httpatomoreillycomsourcenostarchimages1273191.png), indicating the
    subscript of the first and last elements in the array. This improves the readability
    of the code and also allows the code to be easily modified to sort just a portion
    of the array, if desired. The outer loop selects the next “card” to be inserted
    into our ever-increasing sorted hand ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Notice that the loop initializes `i` to `start + 1`. Remember in the “find the
    largest value” code, we initialized our highest-value variable to the first element
    in the array and started our loop with the second element in the array. This is
    the same idea. If we have only one value (or “card”), then by definition it is
    “in order” and we can begin by considering whether the second value should come
    before or after the first. The inner loop puts the current value in its correct
    position by repeatedly swapping the current value with its predecessor until it
    reaches the correct location. The loop counter `j` starts at `i` ![](httpatomoreillycomsourcenostarchimages1273195.png),
    and the loop decrements `j` so long as we haven’t reached the lower end of the
    array ![](httpatomoreillycomsourcenostarchimages1273197.png) and haven’t yet found
    the right stopping point for this new value ![](httpatomoreillycomsourcenostarchimages1273199.png).
    Until then, we use three assignment statements to swap the current value down
    one position in the array ![](httpatomoreillycomsourcenostarchimages1273203.png).
    In other words, if you had a hand of 13 playing cards and had already sorted the
    leftmost 4 cards, you could put the 5th card from the left in the correct position
    by repeatedly moving it down one card until it was no longer of a lower value
    than the card to its left. That’s what the inner loop does. The outer loop does
    this for every card starting from the leftmost. So when we’re done, the entire
    array is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: An insertion sort is not the most efficient sort for most circumstances, and
    to tell the truth, the previous code is not even the most efficient way to perform
    an insertion sort. It is reasonably efficient for small to moderately sized arrays,
    however, and it is simple enough that it can be memorized—think of it as a mental
    macro. Whether you choose this sort or another, you should have one decent or
    better sorting routine that you can code yourself with confidence. It’s not enough
    to have access to someone else’s sorting code that you don’t fully understand.
    You don’t want to tinker with the machinery if you’re not sure how everything
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Compute Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final operation is similar to the retrieval operation, in that we need
    to look at every element in the array before returning a value. It is different
    from the retrieval operation, in that the value is not simply one of the elements
    in the array but some statistic computed from all the values in the array. For
    example, we might compute the average, median, or mode, and we will perform all
    of these computations later in this chapter. A basic statistic we might compute
    could be the average of a set of student grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As another simple example, consider data validation. Suppose an array of double
    values called `vendorPayments` represents payments to vendors. Only positive values
    are valid, and therefore negative values indicate data integrity problems. As
    part of a validation report, we might write a loop to count the number of negative
    values in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Solving Problems with Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have the common operations understood, solving an array problem is
    not much different than solving problems with simple data, as we did in the previous
    chapter. Let’s take one example and run all the way through it using the techniques
    of the previous chapter and any of the common operations for arrays that we might
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem: Finding the mode'
  prefs: []
  type: TYPE_NORMAL
- en: In statistics, the mode of a set of values is the value that appears most often.
    Write code that processes an array of survey data, where survey takers have responded
    to a question with a number in the range 1–10, to determine the mode of the data
    set. For our purpose, if multiple modes exist, any may be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this problem, we’re asked to retrieve one of the values from an array. Using
    the techniques of searching for analogies and starting with what we know, we might
    hope that we can apply some variation of the retrieval technique we have already
    seen: finding the largest value in an array. That code works by storing the largest
    value seen thus far in a variable. The code then compares each subsequent value
    to this variable, replacing it if necessary. The analogous method here would be
    to say we’d store the most frequently seen value thus far in a variable and then
    replace the value in the variable whenever we discovered a more common value in
    the array. When we say it like that, in English, it almost sounds as if it could
    work, but when we think about the actual code, we discover the problem. Let’s
    take a look at a sample array and size constant for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The mode of this data is 3 because 3 appears four times, which is more often
    than any other value. But if we’re processing this array sequentially, as we do
    for the “highest value” problem, at what point do we decide that 3 is our mode?
    How do we know, when we have encountered the fourth and final appearance of 3
    in the array, that it is indeed the fourth and final appearance? There doesn’t
    seem to be any way to discover this information with a single, sequential processing
    of the array data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s turn to one of our other techniques: simplifying the problem. What
    if we made things easier on ourselves by putting all occurrences of the same number
    together? So, for example, what if our sample array survey data looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now both of the 7s are together, the 9s are together, and the 3s are together.
    With the data grouped in this manner, it seems that we should be able to sequentially
    process the array to find the mode. Processing the array by hand, it’s easy to
    count the occurrences of each value, because you just keep counting down the array
    until you find the first number that’s different. Converting what we can do in
    our head into programming statements, however, can be tricky. So before we try
    writing the code for this simplified problem, let’s write some *pseudocode*, which
    is programming-like statements that are not entirely English or C++ but something
    in between. This will remind us what we’re trying to do with each statement we
    need to write.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is no right or wrong way to write pseudocode, and if you use this technique,
    you should adopt your own style. When I write pseudocode, I tend to write legal
    C++ for any statement I’m already confident about and then spell out in English
    the places where I still have thinking to do. Here, we know that we will need
    a variable (`mostFrequent`) to hold the most frequently found value so far, which
    at the end of the loop will be the mode once we’ve written everything correctly.
    We also need a variable to store how often that value occurs (`highestFrequency`)
    so we have something to compare against. Finally, we need a variable we can use
    to count the number of occurrences of the value we’re currently tracking as we
    sequentially process the array (`currentFrequency`). We know we need to initialize
    our variables. For `currentFrequency`, it logically has to start at 0, but it’s
    not clear how we need to initialize the other variables yet, without the other
    code in place. So let’s just drop in question marks ![](httpatomoreillycomsourcenostarchimages1273182.png)
    to remind us to look at that again later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop itself is the same array-processing loop we’ve already seen, so that’s
    already in final form ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Inside the loop, we increment the variable that counts the occurrences of the
    current value ![](httpatomoreillycomsourcenostarchimages1273193.png), and then
    we reach the pivotal statement. We know we need to check to see whether we’ve
    reached the last occurrence of a particular value ![](httpatomoreillycomsourcenostarchimages1273195.png).
    The pseudocode allows us to skip figuring out the logic for now and sketch out
    the rest of the code. If this *is* the last occurrence of the value, though, we
    know what to do because this is like the “highest value” code: We need to see
    whether this value’s count is higher than the highest seen so far. If it is, this
    value becomes the new most frequent value ![](httpatomoreillycomsourcenostarchimages1273197.png).
    Then, because the next value read will be the first occurrence of a new value,
    we reset our counter ![](httpatomoreillycomsourcenostarchimages1273199.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the `if` statement logic we skipped. How do we know whether
    this is the last occurrence of a value in the array? Because the values in the
    array are grouped, we know whether a value is the last occurrence when the next
    value in the array is something different: in C++ terms, when `surveyData[i]`
    and `surveyData[i + 1]` are not equal. Furthermore, the last value in the array
    is also the last occurrence of some value, even though there’s not a next value.
    We can check for this by checking to see whether `i == ARRAY_SIZE - 1`, in which
    case this is the last value in the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of that figured out, let’s think about those initial values for our
    variables. Remember with the “highest value” array-processing code, we initialized
    our “highest so far” variable to the first value in the array. Here, the “most
    frequently seen” value is represented by two variables, `mostFrequent` for the
    value itself and `highestFrequency` for the number of occurrences. It would be
    great if we could initialize `mostFrequent` to the first value that appears in
    the array and `highestFrequency` to its frequency count, but there’s no way to
    determine the first value’s frequency until we get into the loop and start counting.
    At this point, it might occur to us that the first value’s frequency, whatever
    it is, would be greater than zero. Therefore, if we set `highestFrequency` to
    zero, once we reach the last occurrence of the first value, our code will replace
    `mostFrequent` and `highestFrequency` with the numbers for the first value anyway.
    The completed code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this book, we won’t talk much about pure style issues, such as documentation
    (commenting) style, but since we are using pseudocode on this problem, I want
    to mention a tip. I’ve noticed that the lines I leave as “plain English” in the
    pseudocode are the lines that benefit most from a comment in the final code, and
    the plain English itself makes a great comment. I’ve demonstrated that in the
    code here. You might forget the exact meaning behind the conditional expression
    in the `if` statement ![](httpatomoreillycomsourcenostarchimages1273191.png),
    but the comment on the preceding line ![](httpatomoreillycomsourcenostarchimages1273182.png)
    clears things up nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the code itself, it does the job, but remember that it requires our
    survey data to be grouped. Grouping the data might be a job in itself, except—what
    if we *sorted* the array? We don’t actually need the data to be sorted, but sorting
    will accomplish the grouping we need. Because we don’t intend to do any special
    kind of sorting, let’s just add this call to `qsort` to the beginning of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re using the same `compareFunc` we wrote earlier for use with `qsort`.
    With the sorting step in place, we have a complete solution to the original problem.
    So our work is done. Or is it?
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some programmers talk about code that gives off “bad smells.” They are talking
    about working code that is free of bugs but still problematic in some way. Sometimes
    this means code that is too complicated or has too many special cases, making
    the program difficult for a programmer to modify and maintain. In other cases,
    the code isn’t as efficient as it could be, and while it works for test cases,
    the programmer worries that performance will break down with larger cases. That’s
    my concern here. The sorting step is nearly instantaneous for our tiny test case,
    but what if the array is huge? Also, I know that the quicksort algorithm, which
    `qsort` may be using, has its lowest performance when there are lots of duplicate
    values in the array, and the whole point of this problem is that all of our values
    are in the range 1–10\. I therefore propose to *refactor* the code. *Refactoring*
    means improving working code, not changing what it does but how it does it. I
    want a solution that is highly efficient for even huge arrays, assuming that the
    values are in the range of 1–10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think again about the operations we know how to do with arrays. We’ve
    already explored several versions of the “find the highest” code. We know that
    applying the “find the highest” code directly to our `surveyData` array won’t
    produce useful results. Is there an array to which we could apply the “stock”
    version of “find the highest” and get the mode of the survey data? The answer
    is yes. The array we need is the histogram of the `surveyData` array. A histogram
    is a graph showing how often different values appear in an underlying dataset;
    our array will be the data for such a histogram. In other words, we’ll store,
    in a 10-element array, how often each of the values 1 through 10 appears in `surveyData`.
    Here’s the code to create our histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we declare the array to hold our histogram data ![](httpatomoreillycomsourcenostarchimages1273182.png).
    You’ll note we declare the array with 10 elements, but the range of our survey
    responses is 1–10, and the range of subscripts for this array is 0–9\. Thus, we’ll
    have to make adjustments, putting the count of 1s in `histogram[0]` and so on.
    (Some programmers would choose to declare the array with 11 elements, leaving
    location `[0]` unused, to allow each count to go into its natural position.) We
    explicitly initialize the array values to zero with a loop ![](httpatomoreillycomsourcenostarchimages1273191.png),
    and then we are ready to count the occurrences of each value in `surveyData` with
    another loop ![](httpatomoreillycomsourcenostarchimages1273193.png). The statement
    inside the loop ![](httpatomoreillycomsourcenostarchimages1273195.png) has to
    be read carefully; we are using the value in the current location of `surveyData`
    to tell us which position in `histogram` to increment. To make this clear, let’s
    take an example. Suppose `i` is 42\. We inspect `surveyData[42]` and find (let’s
    say) the value 7\. So we need to increment our 7 counter. We subtract 1 from 7
    to get 6 because the counter for 7s is in position `[6]` in `histogram`, and `histogram[6]`
    is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the histogram data in place, we can write the rest of the code. Note that
    the histogram code was written separately so that it could be tested separately.
    No time is saved by writing all of the code at once in a situation where the problem
    is easily separated into parts that can be individually written and tested. Having
    tested the above code, we now search for the largest value in the `histogram`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although this is an adaptation of the “find the highest” code, there is a difference.
    Although we are searching for the highest value in the histogram array, ultimately,
    we don’t want the value itself, but the position. In other words, with our sample
    array, we want to know that 3 occurs more often than any other value in the survey
    data, but the actual number of times 3 occurs isn’t important. So `mostFrequent`
    will be the position of the highest value in `histogram`, not the highest value
    itself. Therefore, we initialize it to `0` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and not the value in `location[0]`. This also means that in the `if` statement,
    we compare against `histogram[mostFrequent]` ![](httpatomoreillycomsourcenostarchimages1273191.png)
    and not `mostFrequent` itself, and we assign `i`, not `histogram[i]`, to `mostFrequent`
    ![](httpatomoreillycomsourcenostarchimages1273193.png) when a larger value is
    found. Finally, we increment `mostFrequent` ![](httpatomoreillycomsourcenostarchimages1273195.png).
    This is the reverse of what we did in the earlier loop, subtracting 1 to get the
    right array position. If `mostFrequent` is telling us that the highest array position
    is 5, for example, it means that the most frequent entry in the survey data was
    6.
  prefs: []
  type: TYPE_NORMAL
- en: The histogram solution scales linearly with the number of elements in our `surveyData`
    array, which is as good as we could hope for. Therefore, it’s a better solution
    than our original approach. This doesn’t mean that the first approach was a mistake
    or a waste of time. It’s possible, of course, to have written this code without
    going through the previous version, and we can be forgiven for wishing that we
    had driven directly to our destination instead of taking the longer route. However,
    I would caution against slapping yourself on the forehead on those occasions when
    the first solution turns out not to be the final solution. Writing an original
    program (and remember this means *original for the programmer writing it*) is
    a learning process and can’t be expected to always progress in a straight line.
    Also, it’s often the case that taking a longer path on one problem helps us take
    a shorter path on a later problem. In this particular case, note that our original
    solution (while it doesn’t scale well for our particular problem) could be the
    right solution if the survey responses weren’t strictly limited to the small range
    of 1–10\. Or suppose that you are later asked to write code that finds the *median*
    of a set of integer values (the median is the value in the middle, such that half
    of the other values in the set are higher and half of the other values are lower).
    The histogram approach doesn’t get you anywhere with the median, but our first
    approach for the mode does.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that a long journey is not a waste of time if you learned
    something from it that you wouldn’t have learned by going the short way. This
    is another reason why it’s helpful to methodically store all of the code that
    you write so that you can easily find and reuse it later. Even the code that turns
    out to be a “dead end” can become a valuable resource.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays of Fixed Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most array problems, the array is a repository for data external to the program,
    such as user-entered data, data on a local disk, or data from a server. To get
    the most out of the array tool, however, you need to recognize other situations
    in which an array can be used. It’s often useful to create an array where the
    values never change after the initialization. Such an array can allow a simple
    loop or even a direct array lookup to replace a whole block of control statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final code for the [Problem: Decode a message](ch02.html#problem_colon_decode_a_message
    "Problem: Decode a message") problem in [Tracking State](ch02.html#tracking_state
    "Tracking State"), we used a `switch` statement to translate the decoded input
    number (in the range 1–8) to the appropriate character when in “punctuation mode”
    because the connection between the number and the character was arbitrary. Although
    this worked fine, it made that section of code longer than the equivalent code
    for the uppercase and lowercase modes, and the code would not scale well if the
    number of punctuation symbols increased. We can use an array to solve this problem
    instead of the `switch` statement. First, we need to permanently assign the punctuation
    symbols to an array in the same order they appear in the coding scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this array has been declared `const` because the values inside
    will never change. With that declaration in place, we can replace the entire switch
    statement with a single assignment statement that references the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the input number is in the range 1–8, but array elements are numbered
    starting from 0, we have to subtract 1 from the input number before referencing
    the array; this is the same adjustment we made in the histogram version of the
    “Finding the Mode” program. You can use the same array to go in the other direction.
    Suppose instead of decoding the message, we had to encode a message—that is, we
    were given a series of characters to convert into numbers that could be decoded
    using the rules of the original problem. To convert a punctuation symbol into
    its number, we have to locate the symbol in the array. This is a retrieval, performed
    using the sequential search technique. Assuming the character is to be converted
    and stored in the `char` variable `targetValue`, we could adapt the sequential
    search code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that just as we had to subtract 1 from `number` in the previous example
    to get the right array position, we have to add 1 to the array position in this
    example to get our punctuation code, converting from the array’s range of 0–7
    to our punctuation code range of 1–8\. Although this code is not as simple as
    a single line, it’s still much simpler than a series of `switch` statements, and
    it scales well. If we were to double the number of punctuation symbols in our
    coding scheme, it would double the number of elements in the array, but the length
    of the code would stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: In general, then, `const` arrays can be used as lookup tables, replacing a burdensome
    series of control statements. Suppose you are writing a program to compute the
    cost of a business license in a state where the license cost varies as the gross
    sales figures of the business vary.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1. Business License Costs
  prefs: []
  type: TYPE_NORMAL
- en: '| Business category | Sales threshold | License cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| I | $0 | $25 |'
  prefs: []
  type: TYPE_TB
- en: '| II | $50,000 | $200 |'
  prefs: []
  type: TYPE_TB
- en: '| III | $150,000 | $1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| IV | $500,000 | $5,000 |'
  prefs: []
  type: TYPE_TB
- en: 'With this problem, we could use arrays both to determine the business category
    based on the company’s gross sales and to assign the license cost based on the
    business category. Suppose a `double` variable, `grossSales`, stores the gross
    sales of a business, and based on the sales figure, we want to assign the proper
    values to `int category` and `double cost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code uses two arrays of fixed values. The first array stores the gross
    sales threshold for each business category ![](httpatomoreillycomsourcenostarchimages1273182.png).
    For example, a business with $65,000 in yearly gross sales is in category II because
    this amount exceeds the $50,000 threshold of category II but is less than the
    $150,000 threshold of category III. The second array stores the cost of a business
    license for each category ![](httpatomoreillycomsourcenostarchimages1273191.png).
    With the arrays in place, we initialize `category` to 0 ![](httpatomoreillycomsourcenostarchimages1273193.png)
    and search through the `categoryThresholds` array, stopping when the threshold
    exceeds the gross sales or when we run out of categories ![](httpatomoreillycomsourcenostarchimages1273195.png).
    In either case, when the loop is done, `category` will be correctly assigned 1–4
    based on the gross sales. The last step is to use `category` to reference the
    license cost from the `licenseCost` array ![](httpatomoreillycomsourcenostarchimages1273197.png).
    As before, we have to make a small adjustment from the 1–4 range of the business
    categories to the 0–3 range of our array.
  prefs: []
  type: TYPE_NORMAL
- en: Non-scalar Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve just worked with arrays of simple data types, such as `int` and
    -`double`. Often, however, programmers must deal with arrays of compound data,
    either structures or objects (struct or `class`). Although the use of compound
    data types necessarily complicates the code somewhat, it doesn’t have to complicate
    our thinking about array processing. Usually the array processing just involves
    one data member of the `struct` or `class`, and we can ignore the other parts
    of the data structure. Sometimes, though, the use of compound data types requires
    us to make some changes to our approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the problem of finding the highest of a set of student
    grades. Suppose that instead of an array of `int`, we have an array of data structures,
    each representing a student’s record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One nice thing about working with arrays is that it is easy to initialize a
    whole array with literal values for easy testing, even with an array of `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration means that `studentArray[0]` has an 87 for its `grade`, 10001
    for its `studentID`, and “Fred” for a `name`, and so on for the other nine elements
    in the array. As for the rest of the code, it could be as simple as copying the
    code from the beginning of this chapter, and then replacing every reference of
    the form `intArray[subscript]` with `studentArray[subscript].grade`. That would
    result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose instead that because we now have additional information for each student,
    we want to find the name of the student with the best grade, not the grade itself.
    This would require additional modification. When our loop is over, the only statistic
    we have is the best grade, and that does not allow us to directly determine the
    student to which it belongs. We’d have to run through the array again, searching
    for the `struct` with the matching `gra``de`, which seems like extra work we shouldn’t
    have to do. To avoid this issue, we should either additionally track the name
    of the student that matches the current value in `highest`, or, instead of tracking
    the highest grade, track the location in the array where the highest grade is
    found, much as we did with `histogram` earlier. The latter approach is the most
    general because tracking the array position allows us to retrieve *any* of the
    data for that student later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the variable `highPosition` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    takes the place of `highest`. Because we aren’t directly tracking the grade closest
    to the average, when it’s time to compare the closest grade against the current
    grade, we use `highPosition` as a reference into `studentArray` ![](httpatomoreillycomsourcenostarchimages1273191.png).
    If the grade in the current array position is higher, the current position in
    our processing loop is assigned to `highPosition` ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Once the loop is over, we can access the name of the student with the grade closest
    to the average using `studentArray[highPosition].name`, and we can also access
    any other data related to that student record.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve only discussed one-dimensional arrays because they are the most
    common. Two-dimensional arrays are uncommon, and arrays with three or more dimensions
    are rare. That’s because most data is one-dimensional by nature. Furthermore,
    data that is inherently multidimensional can be represented as multiple single-dimension
    arrays, so using a multidimensional array is always the choice of the programmer.
    Consider the business license data of [Table 3-1](ch03.html#business_license_costs
    "Table 3-1. Business License Costs"). That’s clearly multidimensional data. I
    mean, look at it—it’s a grid! I represented this multidimensional data, however,
    as two one-dimensional arrays, `categoryThresholds` and `licenseCost`. I could
    have represented the data table as a two-dimensional array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It’s difficult to discern any advantage from combining the two arrays into one.
    None of our code is simplified because there is no reason to process all of the
    data in the table at once. What is clear, though, is that we have lowered the
    readability and ease of use for our table data. In the original version, the names
    of the two separate arrays make it clear what data is stored in each. With the
    combined array, we programmers will have to remember that references of the form
    `licenseData[0][]` refer to the gross sales thresholds of the different business
    categories, while references of the form `licenseData[1][]` refer to business
    license costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it does make sense to use a multidimensional array, though. Suppose
    we are processing the monthly sales data for three sales agents, and one of the
    tasks is finding the highest monthly sales, from any agent. Having all of the
    data in one 3 × 12 array means we can process the entire array at once, using
    nested loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is a straightforward adaptation of the basic “find the largest
    number” code, there are a few wrinkles. When we declare our two-dimensional array,
    notice that the initializer is organized by agent, that is, as 3 groups of 12,
    not 12 groups of 3 ![](httpatomoreillycomsourcenostarchimages1273182.png). As
    you’ll see in the next problem, this decision can have consequences. We initialize
    `highestSales` to the first element in the array, as usual ![](httpatomoreillycomsourcenostarchimages1273191.png).
    It may occur to you that the first time through the nested loops, both of our
    loop counters will be 0, so we will be comparing this initial value of `highestSales`
    to itself. This doesn’t affect the outcome, but sometimes novice programmers will
    attempt to avoid this tiny inefficiency by putting in a second `if` statement
    in the inner loop body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This, however, is considerably *less* efficient than the previous version because
    we would be performing 50 extra comparisons while avoiding only one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that I have used meaningful names for the loop variables: `agent`
    for the outside loop ![](httpatomoreillycomsourcenostarchimages1273193.png) and
    `month` for the inside loop ![](httpatomoreillycomsourcenostarchimages1273195.png).
    In a single loop that processes a one-dimensional array, little is gained by a
    descriptive identifier. In a double loop that processes a two-dimensional array,
    however, the meaningful identifiers help me keep my dimensions and subscripts
    straight because I can look up and see that I am using `agent` in the same dimension
    where I used `numAgents` in the array declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: Even when we have a multidimensional array, sometimes the best approach is to
    deal with just one dimension at a time. Suppose, using the same `sales` array
    as the previous code, we wanted to display the highest agent monthly sales average.
    We could do this using a double loop, as we have previously, but the code would
    be clearer to read and easier to write if we treated the whole array as three
    individual arrays and processed them separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the code we’ve been repeatedly using to compute the average of an
    array of integers? Let’s make that into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the function in place, we can modify the basic “find the largest number”
    again to find the agent with the highest monthly sales average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The big new idea here is shown in the two calls to `arrayAverage`. The first
    parameter accepted by this function is a one-dimensional array of `int`. In the
    first call, we pass `sales[0]` for the first argument ![](httpatomoreillycomsourcenostarchimages1273182.png),
    and in the second call, we pass `sales[agent]` ![](httpatomoreillycomsourcenostarchimages1273191.png).
    So in both cases, we specify a subscript for the first dimension of our two-dimensional
    array `sales`, but not for the second dimension. Because of the direct relationship
    between arrays and addresses in C++, this reference indicates the address of the
    first element of the specified row, which can then be used by our function as
    the base address of a one-dimensional array consisting of just that row.
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds confusing, look again at the declaration of the `sales` array,
    and in particular, the initializer. The values are laid out in the initializer
    in the same order they will be laid out in memory when the program is executing.
    So `sales[0][0]`, which is 1856, will come first, followed by `sales[0][1]`, 498,
    and so on through the last month for the first agent, `sales[0][11]`, 32\. Then
    the values for the second agent will begin, starting with `sales[1][0]`, 5865\.
    Therefore, even though the array is conceptually 3 rows of 12 values, it’s laid
    out in memory as one big sequence of 36 values.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that this technique works because of the order we’ve
    placed the data into the array. If the array were organized along the other axis,
    that is, by month instead of by agent, we couldn’t do what we are doing here.
    The good news is that there is an easy way to make sure you have set up the array
    appropriately—just check the initializer. If the data you want to individually
    process isn’t contiguous in the array initializer, you’ve organized the data the
    wrong way.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to note about this code is the use of the temporary variable,
    `agentAverage`. Because the average monthly sales for the current agent is potentially
    referenced twice, once in the conditional expression of the `if` statement and
    then again in the assignment statement in the body, the temporary variable eliminates
    the possibility of calling `arrayAverage` twice for the same agent’s data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique of considering a multidimensional array as an array of arrays
    follows directly from our core principle of breaking problems up into simpler
    components and in general makes multidimensional array problems a lot easier to
    conceptualize. Even so, you may be thinking that the technique looks a little
    tricky to employ, and if you’re like most new C++ programmers, you are probably
    a little wary of addresses and behind-the-scenes address arithmetic. The best
    way around those feelings, I think, is to make the separation between the dimensions
    even stronger, by placing one level of array inside a `struct` or `class`. Suppose
    we made an `agentStruct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Having gone to the trouble of making a `struct`, we might think about adding
    other data, like an agent identification number, but this will get the job done
    in terms of simplifying our thought processes. With the `struct` in place, instead
    of creating a two-dimensional array of sales, we create a one-dimensional array
    of agents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we make our call to the array-averaging function, we aren’t employing
    a C++ specific trick; we’re just passing a one-dimensional array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Deciding When to Use Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is just a tool. As with any tool, an important part of learning *how*
    to use an array is learning *when* to use it—and when not to use it. The sample
    problems discussed so far assumed the use of arrays in their descriptions. In
    most situations, though, we won’t have this detail spelled out for us, and we
    must instead make our own determination on array use. The most common situations
    in which we must make this decision are those in which we are given aggregate
    data but not told how it must be stored internally. For example, in the problem
    where we found the mode, suppose the line that began *Write code that processes
    an array of survey data . . .*, had read *Write code that processes a collection
    of survey data . . .*. Now the choice of using an array or not would be ours.
    How would we make this decision?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we cannot change the size of an array after it has been created.
    If we ran out of space, our program would fail. So the first consideration is
    whether we will know, at the place in our program where we need an aggregate data
    structure, how many values we will store or at least a reliable estimate on the
    maximum size. This doesn’t mean we have to know the size of the array when we
    write the program. C++, as well as most other languages, allows us to create an
    array that is sized at runtime. Suppose the mode problem was modified so that
    we didn’t know ahead of time how many survey responses we would have, but that
    number came to the program as user input. Then we could dynamically declare an
    array to store the survey data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the array using pointer notation, initializing it through an invocation
    of the `new` operator ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Because of the fluidity between pointer and array types in C++, the elements can
    then be accessed using array notation ![](httpatomoreillycomsourcenostarchimages1273191.png),
    even though `surveyData` is declared as a pointer. Note that because this array
    is dynamically allocated, at the end of the program when we no longer need the
    array, we have to make sure to deallocate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `delete[]` operator, rather than the usual `delete` operator, is used for
    arrays. Although it won’t make any difference with an array of integers, if you
    create an array of objects, the `delete[]` operator ensures that the individual
    objects in the array are deleted before the array itself is deleted. So you should
    adopt the habit of always using `delete[]` with dynamically allocated arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Having the responsibility of cleaning up dynamic memory is the bane of the C++
    programmer, but if you program in the language, it is something you simply must
    do. Beginning programmers often shirk this responsibility because their programs
    are so small and execute for such short periods of time that they never see the
    harmful effects of memory leaks (memory that is no longer used by the program
    but never deallocated and therefore unavailable to the rest of the system). Don’t
    develop this bad habit.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can use the dynamic array only because the user tells us the number
    of survey responses beforehand. Consider another variant where the user begins
    by entering survey responses without telling us the number of responses, indicating
    that there are no more responses by entering a −1 (a data entry method known as
    a *sentinel*). Can we still use an array to solve this problem?
  prefs: []
  type: TYPE_NORMAL
- en: This is a gray area. We could still use an array if we had a guaranteed maximum
    number of responses. In such a case, we could declare an array of that size and
    assume that we are safe. We might still have concerns over the long term, though.
    What if the size of the survey pool increases in the future? What if we want to
    use the same program with a different survey taker? More generally, why build
    a program with a known limitation if we can avoid it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Better, then, to use a data collection without a fixed size. As discussed earlier,
    the vector class from the C++ standard template library acts like an array but
    grows as necessary. Once declared and initialized, the vector can be processed
    exactly the same way as an array. We can assign a value to a vector element or
    retrieve a value using standard array notation. If the vector has filled its initial
    size and we need to add another element, we can do so using the `push_back` method.
    Solving the modified problem with a vector looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first declare the vector ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and then reserve space for 30 survey responses ![](httpatomoreillycomsourcenostarchimages1273191.png).
    The second step is not strictly necessary, but reserving a small amount of space
    that is in excess of the likely number of elements prevents the vector from resizing
    itself frequently as we add values to it. We read the first grade before the data
    entry loop ![](httpatomoreillycomsourcenostarchimages1273193.png), a technique
    we first used in the previous chapter that allows us to check each entered value
    before processing. In this case, we want to avoid adding the sentinel value, −1,
    to our vector. The survey results are added to the vector using the `push_back`
    method ![](httpatomoreillycomsourcenostarchimages1273195.png). After the data
    entry loop is completed, we retrieve the size of the vector using the `size` method
    ![](httpatomoreillycomsourcenostarchimages1273197.png). We could also have counted
    the number of elements ourselves in the data entry loop, but since the vector
    is already tracking its size, this avoids duplicate effort. The rest of the code
    is the same as the previous version with the array and the fixed number of responses,
    except that we have changed the names of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this discussion of vectors, though, overlooks an important point. If we
    are reading the data directly from the user, rather than being told that we are
    starting with an array or other data collection, we may not need an array for
    the survey data, only one for the histogram. Instead, we can process the survey
    values as we read them. We need a data structure only when we need to read in
    all the values before processing or need to process the values more than once.
    In this case, we don’t need to do either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this code was easy to write, given the previous versions as a guide,
    it would have been even easier just to read the user data into an array and use
    the previous processing loop verbatim. The benefit to this process-as-you-go approach
    is efficiency. We avoid unnecessarily storing each of the survey responses, when
    we need to store just one response at a time. Our vector-based solution was *inefficient
    in space*: It took more space than required without providing a corresponding
    benefit. Furthermore, reading all of the grades into the vector required a loop
    on its own, separate from the loops to process all of the survey responses and
    find the highest value in the histogram. That means the vector version does more
    work than the version above. Therefore, the vector version is also *inefficient
    in time*: It does more work than required without providing a corresponding benefit.
    In some cases, different solutions offer trade-offs, and programmers must decide
    between space efficiency and time efficiency. In this case, however, the use of
    the vector makes the program inefficient all around.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we won’t spend a lot of time tracking down every inefficiency.
    Programmers must sometimes engage in *performance tuning*, which is the systematic
    analysis and improvement of a program’s efficiency in time and space. Performance
    tuning a program is a lot like performance tuning a race car: an exacting job,
    where small adjustments can have large effects and expert knowledge of how mechanisms
    work “under the hood” is required. Even if we don’t have the time, desire, or
    knowledge to fully tune a program’s performance, though, we should still avoid
    decisions that lead to gross inefficiencies. Using a vector or an array unnecessarily
    is not like an engine with a fuel-to-air mix that is too lean; it’s like driving
    a bus to the beach for vacation when you could have fit everything you were taking
    into a Honda Civic.'
  prefs: []
  type: TYPE_NORMAL
- en: If we’re sure we need to process the data multiple times, and we have a good
    handle on the maximum size of the data set, the last criterion for deciding whether
    to use an array is random access. Later on, we’ll discuss alternate data structures,
    such as lists, which like vectors can grow as needed but unlike vectors and arrays
    the elements can be accessed only sequentially. That is, if we want to access
    the 10th element in a list, we have to run through the first 9 items to get to
    it. By contrast, *random access* means that we can access any element in an array
    or vector at any time. So the last rule is that we should use an array when we
    need random access. If we need only sequential access, we might consider a different
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that many of the programs in this chapter fail on this last
    criterion; we access the data sequentially, not randomly, and yet we are using
    an array. This leads to the great, common-sense exception to all of these rules.
    If an array is small, then none of the previous objections holds much weight.
    What constitutes “small” may vary based on the platform or application. The point
    is, if your program needs a collection of as few as 1 or as many as 10 items,
    each of which requires 10 bytes, you have to consider whether the potential waste
    of 90 bytes that could result from allocating an array of the maximum required
    size is worth searching for a better solution. Use arrays wisely, but don’t let
    the perfect be the enemy of the good.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, I urge you to try as many exercises as you can stand.
  prefs: []
  type: TYPE_NORMAL
- en: Are you disappointed we didn’t do more with sorting? I’m here to help. To make
    sure you are comfortable with `qsort`, write code that uses the function to sort
    an array of our student `struct`. First have it sort by grade, and then try it
    again using the student ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite the code that finds the agent with the best monthly sales average so
    that it finds the agent with the highest *median* sales. As stated earlier, the
    median of a set of values is the “one in the middle,” such that half of the other
    values are higher and half of the other values are lower. If there is an even
    number of values, the median is the simple average of the two values in the middle.
    For example, in the set 10, 6, 2, 14, 7, 9, the values in the middle are 7 and
    9\. The average of 7 and 9 is 8, so 8 is the median.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `bool` function that is passed an array and the number of elements in
    that array and determines whether the data in the array is sorted. This should
    require only one pass!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here’s a variation on the array of `const` values. Write a program for creating
    a substitution cipher problem. In a substitution cipher problem, all messages
    are made of uppercase letters and punctuation. The original message is called
    the plaintext, and you create the ciphertext by substituting each letter with
    another letter (for example, each C could become an X). For this problem, hard-code
    a `const` array of 26 `char` elements for the cipher, and have your program read
    a plaintext message and output the equivalent ciphertext.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have the previous program convert the ciphertext back to the plaintext to verify
    the encoding and decoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the ciphertext problem even more challenging, have your program randomly
    generate the cipher array instead of a hard-coded `const` array. Effectively,
    this means placing a random character in each element of the array, but remember
    that you can’t substitute a letter for itself. So the first element can’t be A,
    and you can’t use the same letter for two substitutions—that is, if the first
    element is S, no other element can be S.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that is given an array of integers and determines the *mode*,
    which is the number that appears most frequently in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that processes an array of `student` objects and determines
    the grade quartiles—that is, the grade one would need to score as well as or better
    than 25% of the students, 50% of the students, and 75% of the students.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider this modification of the `sales` array: Because salespeople come and
    go throughout the year, we are now marking months prior to a sales agent’s hiring,
    or after a sales agent’s last month, with a −1\. Rewrite your highest sales average,
    or highest sales median, code to compensate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
