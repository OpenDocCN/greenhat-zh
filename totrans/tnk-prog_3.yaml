- en: Chapter 3. Solving Problems with Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用数组解决问题
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
- en: In the previous chapter, we limited ourselves to *scalar variables*, that is,
    variables that can hold only one value at a time. In this chapter, we’ll look
    at problems using the most common aggregate data structure, the array. Although
    arrays are simple structures with fundamental limitations, their use greatly magnifies
    the power of our programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们限制了自己只使用*标量变量*，即一次只能存储一个值的变量。在本章中，我们将探讨使用最常用的聚合数据结构——数组的问题。尽管数组是具有基本限制的简单结构，但它们的使用极大地增强了我们程序的功能。
- en: 'In this chapter, we will primarily deal with actual arrays, that is, those
    declared with the built-in C++ syntax, such as:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要处理实际的数组，即使用内置的C++语法声明的数组，例如：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the techniques we discuss apply just as well to data structures with
    similar attributes. The most common of these structures is a vector. The term
    *vector* is often used as a synonym for any array of a single dimension, but we’ll
    use it here in the more specific sense of a structure that has the attributes
    of an array without a specified maximum number of elements. So for our discussions,
    an array is of a fixed size, while a vector can grow or shrink automatically as
    needed. Each of the problems we discuss in this chapter includes some restriction
    that allows us to use a structure with a fixed number of elements. Problems without
    such restrictions, however, could be adapted to use a vector.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们讨论的技术同样适用于具有类似属性的数据结构。其中最常见的是向量。术语*向量*通常用作任何一维数组的同义词，但在这里我们将使用更具体的意义，即具有数组属性但没有指定最大元素数量的结构。因此，在我们的讨论中，数组是固定大小的，而向量可以自动根据需要增长或缩小。本章讨论的每个问题都包括一些限制，允许我们使用具有固定元素数量的结构。然而，没有这种限制的问题可以适应使用向量。
- en: Moreover, the techniques used with arrays can often be used with data structures
    that do not have every attribute listed above. Some techniques, for example, don’t
    require random access, so they can be used with structures like linked lists.
    Because arrays are so common in programming, and because array techniques are
    frequently used in non-array contexts, arrays are a great training ground for
    the study of problem solving with data structures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与数组一起使用的技巧通常也可以用于不具有上述所有属性的某些数据结构。例如，有些技巧不需要随机访问，因此它们可以与链表等结构一起使用。由于数组在编程中非常常见，并且数组技巧经常在非数组环境中使用，因此数组是研究使用数据结构解决问题的良好训练场。
- en: Review of Array Fundamentals
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组基础回顾
- en: You should already know what an array is, but let’s go over some of the attributes
    of arrays for clarity. An *array* is a collection of variables of the same type
    organized under one name, where the individual variables are denoted by a number.
    We call the individual variables the *elements* of the array. In C++ and most
    other languages, the first element has number 0, but in some languages, this will
    vary.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经知道数组是什么，但为了清晰起见，让我们回顾一下数组的属性。一个*数组*是由同一类型的变量组成的集合，这些变量在同一个名称下组织，其中各个变量由一个数字表示。我们称这些单个变量为数组的*元素*。在C++和大多数其他语言中，第一个元素的编号为0，但在某些语言中，这会有所不同。
- en: The primary attributes of the array follow directly from the definition. Every
    value stored in an array is of the same type, whereas other aggregate data structures
    can store values of mixed types. An individual element is referenced by a number
    called a *subscript*; in other data structures, individual elements might be referenced
    by name or by a key value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的主要属性直接来源于其定义。数组中存储的每个值都是同一类型的，而其他聚合数据结构可以存储混合类型的值。单个元素通过一个称为*下标*的数字来引用；在其他数据结构中，单个元素可能通过名称或键值来引用。
- en: From these primary attributes, we can derive several secondary attributes. Because
    each of the elements is designated by a number in a sequence starting from 0,
    we can easily examine every value in an array. In other data structures, this
    may be difficult, inefficient, or even impossible. Also, whereas some data structures,
    such as linked lists, can be accessed only sequentially, an array offers *random
    access*, meaning we can access any element of the array at any time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些基本属性中，我们可以推导出几个次要属性。因为每个元素都由从0开始的序列中的数字指定，所以我们很容易检查数组中的每个值。在其他数据结构中，这可能很困难、效率低下，甚至不可能。此外，与一些数据结构（如链表）只能按顺序访问不同，数组提供*随机访问*，这意味着我们可以在任何时间访问数组的任何元素。
- en: These primary and secondary attributes determine how we can use arrays. When
    dealing with any aggregate data structure, it’s good to have a set of basic operations
    in mind as you consider problems. Think of these basic operations as common tools—the
    hammers, screwdrivers, and wrenches of the data structure. Not every mechanical
    problem can be solved with common tools, but you should always consider whether
    a problem can be solved with common tools before making a trip to the hardware
    store. Here’s my list of basic operations for arrays.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本和次要属性决定了我们可以如何使用数组。在处理任何聚合数据结构时，考虑问题时最好有一个基本操作集。将这些基本操作视为常用工具——数据结构中的锤子、螺丝刀和扳手。并不是每个机械问题都可以用常用工具解决，但在去五金店之前，你应该考虑问题是否可以用常用工具解决。以下是我为数组列出的基本操作列表。
- en: Store
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: 'This is the most basic of operations. An array is a collection of variables,
    and we can assign a value to each of those variables. To assign the integer 5
    to the first element (element 0) in the previously declared array, we just say:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本的操作。数组是一组变量的集合，我们可以为这些变量中的每一个分配一个值。要将整数5分配给之前声明的数组中的第一个元素（元素0），我们只需说：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with any variable, the values of the elements inside our array will be random
    “garbage” until particular values are assigned, so arrays should be initialized
    before they are used. In some cases, especially for testing, we will want to assign
    a particular value to every element in the array. We can do that with an initializer
    when the array is declared.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何变量一样，我们数组内部元素的值在特定值被分配之前将是随机的“垃圾”数据，因此在使用数组之前应该对其进行初始化。在某些情况下，尤其是在测试时，我们可能希望将特定值分配给数组中的每个元素。我们可以在声明数组时使用初始化器来完成这个操作。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ll see a good use of an array initializer shortly. Sometimes, instead of
    assigning a different value to each element, we just want every element in the
    array to be initialized to the same value. There are some shortcuts for assigning
    a zero to every element in the array, depending on the situation or the compiler
    used (the C++ compiler in Microsoft Visual Studio, for example, initializes every
    value in any array to zero unless otherwise specified). At this stage, however,
    I would always explicitly initialize an array wherever initialization is required
    in order to enhance readability, as in this code, which sets every element in
    a 10-element array to −1:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到数组初始化器的良好应用。有时，我们不想为每个元素分配不同的值，而只想将数组中的每个元素初始化为相同的值。根据情况或使用的编译器（例如，Microsoft
    Visual Studio中的C++编译器），为数组中的每个元素分配零有一些快捷方式。然而，在这个阶段，我总是会在需要初始化的地方显式初始化数组，以提高可读性，就像以下代码所示，它将一个10元素数组中的每个元素设置为-1：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Copy
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: 'We can make a copy of the array. There are two common situations in which this
    might be useful. First, we might want to heavily manipulate the array but still
    require the array in its original form for later processing. Putting the array
    back in its original form after manipulation may be difficult, or even impossible,
    if we’ve changed any of the values. By copying the entire array, we can manipulate
    the copy without disturbing the original. All we need to copy an entire array
    is a loop and an assignment statement, just like the code for initialization:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以复制数组。有两种常见情况可能很有用。首先，我们可能想要对数组进行大量操作，但仍然需要保留数组原始形式以供后续处理。如果我们更改了任何值，将数组放回原始形式可能很困难，甚至不可能。通过复制整个数组，我们可以操作副本而不会干扰原始数组。我们只需要一个循环和一个赋值语句就可以复制整个数组，就像初始化的代码一样：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That operation is available to most aggregate data structures. The second situation
    is more specific to arrays. Sometimes we want to copy part of the data from one
    array to a second array, or we want to copy the elements from one array to a second
    array as a method of rearranging the order of the elements. If you have studied
    the merge-sort algorithm, you’ve seen this idea in action. We’ll see examples
    of copying later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作适用于大多数聚合数据结构。第二种情况更具体于数组。有时我们想要将部分数据从第一个数组复制到第二个数组，或者我们想要将元素从第一个数组复制到第二个数组，作为重新排列元素顺序的方法。如果你研究过归并排序算法，你已经在实际操作中看到了这个想法。我们将在本章后面看到复制的示例。
- en: Retrieval and Search
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索与搜索
- en: 'With the ability to put values into the array, we also need the ability to
    get them out of the array. Retrieving the value from a particular location is
    straightforward:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们能够将值放入数组，因此我们还需要能够从数组中取出它们。从特定位置检索值是直接的：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Searching for a Specific Value
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索特定值
- en: Usually the situation isn’t that simple. Often we don’t know the location we
    need, and we instead have to *search* the array to find the location of a specific
    value. If the elements in the array are in no particular order, the best we can
    do is a sequential search, where we look at each element in the array from one
    end to the other until we find the desired value. Here’s a basic version.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况并不那么简单。通常我们不知道需要的位置，而必须 *搜索* 数组以找到特定值的定位。如果数组中的元素没有特定的顺序，我们能做的最好的就是顺序搜索，即从数组的这一端看到另一端，直到找到所需值。这里有一个基本版本。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code, we have a constant that stores the size of the array ![](httpatomoreillycomsourcenostarchimages1273182.png),
    the array itself ![](httpatomoreillycomsourcenostarchimages1273191.png), a variable
    to store the value we are looking for in the array ![](httpatomoreillycomsourcenostarchimages1273193.png),
    and a variable to store the location where the value is found ![](httpatomoreillycomsourcenostarchimages1273195.png).
    In this example, we use our `ARRAY_SIZE` constant to limit the number of iterations
    over our array ![](httpatomoreillycomsourcenostarchimages1273197.png), so that
    we won’t run past the end of the array when `targetValue` is not found among the
    array elements. You could “hard-wire” the number 10 in place of the constant,
    but using the constant makes the code more general, thus making it easy to modify
    and reuse. We’ll use an `ARRAY_SIZE` constant in most of the code in this chapter.
    Note that if `targetValue` is not found in `intArra``y`, then `targetPos` will
    be equal to `ARRAY_SIZE` after the loop. This is enough to signify the event because
    `ARRAY_SIZE` is not a valid element number. It will be up to the code that follows,
    however, to check that. Also note that the code makes no effort to handle the
    possibility that the target value appears more than once. The first time the target
    value appears, the loop is over.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们有一个常量用于存储数组的大小 ![数组大小](http://atomoreilly.com/source/nostarch/images/1273182.png)，数组本身
    ![数组本身](http://atomoreilly.com/source/nostarch/images/1273191.png)，一个变量用于存储我们在数组中要查找的值
    ![查找值](http://atomoreilly.com/source/nostarch/images/1273193.png)，以及一个变量用于存储找到值的位置
    ![找到值的位置](http://atomoreilly.com/source/nostarch/images/1273195.png)。在此示例中，我们使用我们的
    `ARRAY_SIZE` 常量来限制对数组的迭代次数 ![迭代次数](http://atomoreilly.com/source/nostarch/images/1273197.png)，这样当
    `targetValue` 在数组元素中未找到时，我们不会超出数组的末尾。你可以将数字 10 “硬编码”到常量中，但使用常量可以使代码更通用，因此更容易修改和重用。在本章的大部分代码中，我们将使用
    `ARRAY_SIZE` 常量。请注意，如果 `targetValue` 在 `intArray` 中未找到，则循环结束后 `targetPos` 将等于
    `ARRAY_SIZE`。这足以表示该事件，因为 `ARRAY_SIZE` 不是一个有效的元素编号。然而，检查这一点将由后续的代码来完成。另外，请注意，代码没有努力处理目标值出现多次的可能性。目标值第一次出现时，循环就会结束。
- en: Criterion-Based Search
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于标准的搜索
- en: 'Sometimes the value we are looking for isn’t a fixed value but a value based
    on the relationship with other values in the array. For example, we might want
    to find the highest value in the array. The mechanism to do that is what I call
    “King of the Hill,” in reference to the playground game. Have a variable that
    represents the highest value seen *so far* in the array. Run through all the elements
    in the array with a loop, and each time you encounter a value higher than the
    previous highest value, the new value knocks the previous king off the hill, taking
    his place:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们寻找的值不是一个固定的值，而是基于数组中其他值的相对关系的值。例如，我们可能想要找到数组中的最大值。完成这个任务的机制就是我所说的“山丘之王”，这个名称来源于操场上的游戏。有一个变量代表数组中迄今为止看到的最高值。通过循环遍历数组中的所有元素，每次遇到一个比之前最高值更高的值时，新的值就会将之前的“国王”从山上赶下来，取而代之：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The variable `highestValue` stores the largest value found in the array so far.
    At its declaration, it is assigned the value of the first element in the array
    ![](httpatomoreillycomsourcenostarchimages1273182.png), which allows us to start
    the loop at the second element in the array (it allows us to start with `i` at
    1 instead of 0) ![](httpatomoreillycomsourcenostarchimages1273191.png). Inside
    the loop, we compare the value at the current position with `highestValue`, replacing
    `highestValue` if appropriate ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Note that finding the lowest value, instead of the highest, is just a matter of
    switching the “greater-than” comparison ![](httpatomoreillycomsourcenostarchimages1273195.png)
    to a “less-than” comparison (and changing the name of the variable so we don’t
    confuse ourselves). This basic structure can be applied to all sorts of situations
    in which we want to look at every element in the array to find the value that
    most exemplifies a particular quality.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `highestValue` 存储了迄今为止在数组中找到的最大值。在其声明时，它被分配为数组的第一个元素的值 ![http://atomoreilly.com/source/no_starch_images/1273182.png]，这允许我们从数组的第二个元素开始循环（它允许我们从
    `i` 为 1 而不是 0 开始）。在循环内部，我们比较当前位置的值与 `highestValue`，如果适当的话替换 `highestValue` ![http://atomoreilly.com/source/no_starch_images/1273191.png]。请注意，找到最小值而不是最大值，只需将“大于”比较
    ![http://atomoreilly.com/source/no_starch_images/1273195.png] 转换为“小于”比较（并更改变量的名称，以免混淆自己）。这种基本结构可以应用于所有各种情况，在这些情况下我们想要查看数组中的每个元素以找到最能体现特定质量的值。
- en: Sort
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: '*Sorting* means putting data in a specified order. You have probably already
    encountered sorting algorithms for arrays. This is a classic area for performance
    analysis because there are so many competing sorting algorithms, each with performance
    characteristics that vary depending on features of the underlying data. The study
    of different sorting algorithms could be the subject of an entire book by itself,
    so we’re not going to explore this area in its full depth. Instead, we’re going
    to focus on what is practical. For most situations, you can make do with two sorts
    in your toolbox: a fast, easy-to-use sort and a decent, easy-to-understand sort
    that you can modify with confidence when the situation arises. For fast and easy,
    we’ll use the standard library function `qsort`, and when we need something to
    tweak, we’ll use an insertion sort.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*排序*意味着将数据按照指定的顺序排列。你可能已经遇到了用于数组的排序算法。这是一个经典的分析性能的领域，因为存在如此多的竞争排序算法，每个算法的性能特征都取决于底层数据的特征。对不同排序算法的研究本身就可以成为一本书的主题，所以我们不会深入探讨这个领域。相反，我们将专注于实际应用。在大多数情况下，你可以使用工具箱中的两种排序方法：一种快速、易于使用的排序方法，以及一种相当好理解、易于修改的排序方法，当需要时你可以有信心进行修改。对于快速和简单，我们将使用标准库函数
    `qsort`，当我们需要调整时，我们将使用插入排序。'
- en: Fast-and-Easy Sorting with qsort
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 qsort 进行快速简单的排序
- en: 'The default fast sort for C/C++ programmers is the `qsort` function in the
    standard library (the name suggests that the underlying sort employs a quicksort,
    but the implementer of the library is not required to use that algorithm). To
    use `qsort`, we have to write a comparator function. This function will be called
    by `qsort` whatever it needs to compare two elements in the array to see which
    should appear earlier in sorted order. The function is passed two `void` pointers.
    We haven’t discussed pointers yet in this book, but all you need to know here
    is that you should cast those `void` pointers to pointers to the element type
    in your array. Then the function should return an `int`, either positive, negative,
    or zero, based on whether the first element is larger, smaller, or equal to the
    second element. The exact value returned doesn’t matter, only whether it is positive,
    negative, or zero. Let’s clear up this discussion with a quick example of sorting
    an array of 10 integers using `qsort`. Our comparator function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++程序员的默认快速排序是标准库中的`qsort`函数（名称暗示底层排序使用快速排序，但库的实现者并不需要使用该算法）。要使用`qsort`，我们必须编写一个比较函数。这个函数将由`qsort`在需要比较数组中的两个元素以确定哪个应该出现在排序顺序中时被调用。该函数接收两个`void`指针。我们在这本书中还没有讨论指针，但你需要知道的是，你应该将这些`void`指针转换为你的数组中元素类型的指针。然后该函数应该返回一个`int`，根据第一个元素是大于、小于还是等于第二个元素，返回正数、负数或零。返回的确切值并不重要，只有它是正数、负数还是零。让我们用一个快速示例来澄清这个讨论，即使用`qsort`对10个整数的数组进行排序。我们的比较函数：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The parameter list consists of two `const void` pointers ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Again, this is always the case for the comparator. The code inside the function
    begins by declaring two `int` pointers ![](httpatomoreillycomsourcenostarchimages1273191.png)
    and casting the two `void` pointers to the `int` pointer type. We could write
    the function without the two temporary variables; I’m including them here for
    clarity. The point is, once we are done with those declarations, `intA` and `intB`
    will point at two elements in our array, and `*intA` and `*intB` will be two integers
    that must be compared. Finally, we return the result of subtracting the second
    integer from the first ![](httpatomoreillycomsourcenostarchimages1273193.png).
    This produces the result we want. If `intA` > `intB`, for example, we want to
    return a positive number, and `intA` – `intB` will be positive if `intA` > `intB`.
    Likewise, `intA` – `intB` will be negative if `intB` > `intA` and will be zero
    when the two integers are equal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表由两个`const void`指针组成 ![图片](http://atomoreilly.com/source/nostarch/images/1273182.png)。同样，对于比较器来说，这始终是这种情况。函数内部的代码首先声明两个`int`指针
    ![图片](http://atomoreilly.com/source/nostarch/images/1273191.png) 并将两个`void`指针转换为`int`指针类型。我们可以不使用这两个临时变量来编写函数；我在这里包括它们是为了清晰。关键是，一旦我们完成了这些声明，`intA`和`intB`将指向我们的数组中的两个元素，而`*intA`和`*intB`将是必须比较的两个整数。最后，我们返回从第一个整数减去第二个整数的结果
    ![图片](http://atomoreilly.com/source/nostarch/images/1273193.png)。这将产生我们想要的结果。例如，如果`intA`
    > `intB`，我们希望返回一个正数，并且如果`intA` > `intB`，`intA` – `intB`将是正数。同样，如果`intB` > `intA`，`intA`
    – `intB`将是负数，当两个整数相等时，它将是零。
- en: 'With the comparator function in place, a sample use of `qsort` looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较函数就绪后，`qsort`的一个示例用法如下：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, the call to `qsort` takes four parameters: the array to be
    sorted ![](httpatomoreillycomsourcenostarchimages1273182.png); the number of elements
    in that array ![](httpatomoreillycomsourcenostarchimages1273191.png); the size
    of one element in the array, usually determined, as it is here, by the `sizeof`
    operator ![](httpatomoreillycomsourcenostarchimages1273193.png); and finally,
    the comparator function ![](httpatomoreillycomsourcenostarchimages1273195.png).
    If you haven’t had much experience passing functions as parameters to other functions,
    note the syntax used for the last parameter. We are passing the function itself,
    not calling the function and passing the result of the call. Therefore, we simply
    state the name of the function, with no parameter list or parentheses.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`qsort`的调用需要四个参数：要排序的数组 ![图片](http://atomoreilly.com/source/nostarch/images/1273182.png)；该数组中的元素数量
    ![图片](http://atomoreilly.com/source/nostarch/images/1273191.png)；数组中一个元素的大小，通常由`sizeof`运算符确定，就像这里一样
    ![图片](http://atomoreilly.com/source/nostarch/images/1273193.png)；最后，比较函数 ![图片](http://atomoreilly.com/source/nostarch/images/1273195.png)。如果你没有多少经验将函数作为参数传递给其他函数，请注意最后一个参数使用的语法。我们传递的是函数本身，而不是调用函数并传递调用结果。因此，我们只需声明函数名，不带参数列表或括号。
- en: Easy-to-Modify Sorting with Insertion Sort
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用插入排序进行易于修改的排序
- en: 'In some cases, you will need to write your own sorting code. Sometimes the
    built-in sort just won’t work for your situation. For example, suppose you had
    an array of data that you wanted to order based on the data in *another* array.
    When you have to write your own sort, you will want a straightforward sorting
    routine that you believe in and can crank out on demand. A reasonable suggestion
    for a go-to sort is an *insertion sort*. The insertion sort works the way many
    people would sort cards when playing bridge: They pick up the cards one at a time
    and insert them in the appropriate place in their hands to maintain the overall
    order, moving the other cards down to make room. Here’s a basic implementation
    for our integer array:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要编写自己的排序代码。有时内置的排序方法可能无法满足你的需求。例如，假设你有一个数据数组，你希望根据另一个数组中的数据对其进行排序。当你不得不自己编写排序代码时，你将希望有一个简单直接的排序程序，你相信它并且可以随时使用。一个合理的建议是使用*插入排序*。插入排序的工作方式类似于许多人打桥牌时排序卡片的方式：他们一次拿起一张卡片，将其插入到手中的适当位置以保持整体顺序，同时将其他卡片向下移动以腾出空间。以下是针对我们的整数数组的基本实现：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start by declaring two variables, `start` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and `end` ![](httpatomoreillycomsourcenostarchimages1273191.png), indicating the
    subscript of the first and last elements in the array. This improves the readability
    of the code and also allows the code to be easily modified to sort just a portion
    of the array, if desired. The outer loop selects the next “card” to be inserted
    into our ever-increasing sorted hand ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Notice that the loop initializes `i` to `start + 1`. Remember in the “find the
    largest value” code, we initialized our highest-value variable to the first element
    in the array and started our loop with the second element in the array. This is
    the same idea. If we have only one value (or “card”), then by definition it is
    “in order” and we can begin by considering whether the second value should come
    before or after the first. The inner loop puts the current value in its correct
    position by repeatedly swapping the current value with its predecessor until it
    reaches the correct location. The loop counter `j` starts at `i` ![](httpatomoreillycomsourcenostarchimages1273195.png),
    and the loop decrements `j` so long as we haven’t reached the lower end of the
    array ![](httpatomoreillycomsourcenostarchimages1273197.png) and haven’t yet found
    the right stopping point for this new value ![](httpatomoreillycomsourcenostarchimages1273199.png).
    Until then, we use three assignment statements to swap the current value down
    one position in the array ![](httpatomoreillycomsourcenostarchimages1273203.png).
    In other words, if you had a hand of 13 playing cards and had already sorted the
    leftmost 4 cards, you could put the 5th card from the left in the correct position
    by repeatedly moving it down one card until it was no longer of a lower value
    than the card to its left. That’s what the inner loop does. The outer loop does
    this for every card starting from the leftmost. So when we’re done, the entire
    array is sorted.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明两个变量，`start` 和 `end`，表示数组中第一个和最后一个元素的下标。这提高了代码的可读性，同时也允许代码容易地修改以仅对数组的部分进行排序，如果需要的话。外层循环选择下一个要插入到我们不断增长的有序手中的“卡片”。注意，循环将
    `i` 初始化为 `start + 1`。记得在“找到最大值”的代码中，我们将最高值变量初始化为数组的第一个元素，并从数组的第二个元素开始循环。这是同样的想法。如果我们只有一个值（或“卡片”），那么根据定义，它已经是“有序”的，我们可以从考虑第二个值是否应该在第一个值之前或之后开始。内层循环通过反复交换当前值与其前驱值，直到它到达正确的位置，将当前值放入其正确的位置。循环计数器
    `j` 从 `i` 开始，循环递减 `j`，直到我们没有达到数组的下限，并且还没有找到这个新值的正确停止点。在此之前，我们使用三个赋值语句将当前值在数组中向下移动一个位置。换句话说，如果你有一副13张的牌，并且已经排序了最左边的4张牌，你可以通过反复将第5张牌向下移动一张牌，直到它不再比其左侧的牌小，来将其放入正确的位置。这就是内层循环所做的。外层循环从最左边开始对每张牌做同样的事情。所以当我们完成时，整个数组就被排序了。
- en: An insertion sort is not the most efficient sort for most circumstances, and
    to tell the truth, the previous code is not even the most efficient way to perform
    an insertion sort. It is reasonably efficient for small to moderately sized arrays,
    however, and it is simple enough that it can be memorized—think of it as a mental
    macro. Whether you choose this sort or another, you should have one decent or
    better sorting routine that you can code yourself with confidence. It’s not enough
    to have access to someone else’s sorting code that you don’t fully understand.
    You don’t want to tinker with the machinery if you’re not sure how everything
    works.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序并不是在大多数情况下最有效的排序方法，说实话，之前的代码甚至都不是执行插入排序最有效的方法。然而，对于小到中等大小的数组来说，它是相当高效的，而且足够简单，以至于可以被记住——把它想象成一个心理宏。无论你选择这种排序还是其他排序，你应该有一个自己可以自信编码的
    decent 或更好的排序程序。仅仅能够访问你不完全理解的别人的排序代码是不够的。如果你不确定一切是如何工作的，你不想去摆弄这些机器。
- en: Compute Statistics
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算统计数据
- en: 'The final operation is similar to the retrieval operation, in that we need
    to look at every element in the array before returning a value. It is different
    from the retrieval operation, in that the value is not simply one of the elements
    in the array but some statistic computed from all the values in the array. For
    example, we might compute the average, median, or mode, and we will perform all
    of these computations later in this chapter. A basic statistic we might compute
    could be the average of a set of student grades:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最终操作与检索操作类似，因为我们需要在返回值之前查看数组中的每个元素。它与检索操作的不同之处在于，值不仅仅是数组中的一个元素，而是从数组中所有值计算出的某个统计量。例如，我们可能会计算平均值、中位数或众数，我们将在本章后面进行所有这些计算。我们可能计算的一个基本统计量可以是学生成绩的平均值：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As another simple example, consider data validation. Suppose an array of double
    values called `vendorPayments` represents payments to vendors. Only positive values
    are valid, and therefore negative values indicate data integrity problems. As
    part of a validation report, we might write a loop to count the number of negative
    values in the array:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个简单的例子，考虑数据验证。假设一个名为 `vendorPayments` 的双精度值数组代表了向供应商的付款。只有正值是有效的，因此负值表示数据完整性问题。作为验证报告的一部分，我们可能会写一个循环来计算数组中负值的数量：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Solving Problems with Arrays
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组解决问题
- en: Once you have the common operations understood, solving an array problem is
    not much different than solving problems with simple data, as we did in the previous
    chapter. Let’s take one example and run all the way through it using the techniques
    of the previous chapter and any of the common operations for arrays that we might
    need.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了常见的操作，解决数组问题与解决上一章中我们使用简单数据解决的问题并没有太大的不同。让我们拿一个例子，并使用上一章的技术以及我们可能需要的任何数组常见操作来运行它。
- en: 'Problem: Finding the mode'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：寻找众数
- en: In statistics, the mode of a set of values is the value that appears most often.
    Write code that processes an array of survey data, where survey takers have responded
    to a question with a number in the range 1–10, to determine the mode of the data
    set. For our purpose, if multiple modes exist, any may be chosen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，一组值的众数是出现次数最多的值。编写代码处理一个调查数据数组，其中调查者用一个1到10范围内的数字回答了一个问题，以确定数据集的众数。对于我们的目的，如果存在多个众数，可以选择任何一个。
- en: 'In this problem, we’re asked to retrieve one of the values from an array. Using
    the techniques of searching for analogies and starting with what we know, we might
    hope that we can apply some variation of the retrieval technique we have already
    seen: finding the largest value in an array. That code works by storing the largest
    value seen thus far in a variable. The code then compares each subsequent value
    to this variable, replacing it if necessary. The analogous method here would be
    to say we’d store the most frequently seen value thus far in a variable and then
    replace the value in the variable whenever we discovered a more common value in
    the array. When we say it like that, in English, it almost sounds as if it could
    work, but when we think about the actual code, we discover the problem. Let’s
    take a look at a sample array and size constant for this problem:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们被要求从一个数组中检索一个值。使用寻找类比和从已知信息开始的技术，我们可能希望应用我们已经看到的检索技术的某种变体：找到数组中的最大值。该代码通过将迄今为止看到的最大值存储在一个变量中来工作。然后代码将每个后续值与此变量进行比较，并在必要时替换它。这里类似的方法将是说我们将存储迄今为止出现频率最高的值在一个变量中，然后每当我们在数组中发现一个更常见的值时，就替换变量中的值。当我们这样用英语说出来时，这似乎可以工作，但当我们实际思考代码时，我们发现问题。让我们看看这个问题的示例数组和大小常量：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The mode of this data is 3 because 3 appears four times, which is more often
    than any other value. But if we’re processing this array sequentially, as we do
    for the “highest value” problem, at what point do we decide that 3 is our mode?
    How do we know, when we have encountered the fourth and final appearance of 3
    in the array, that it is indeed the fourth and final appearance? There doesn’t
    seem to be any way to discover this information with a single, sequential processing
    of the array data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据的模式是3，因为3出现了四次，比任何其他值出现的频率都要高。但是，如果我们像处理“最高值”问题那样按顺序处理这个数组，我们会在什么时候决定3是众数呢？当我们遇到数组中3的第四次也是最后一次出现时，我们如何知道这确实是第四次和最后一次出现呢？似乎没有一种方法可以通过单次顺序处理数组数据来发现这种信息。
- en: 'So let’s turn to one of our other techniques: simplifying the problem. What
    if we made things easier on ourselves by putting all occurrences of the same number
    together? So, for example, what if our sample array survey data looked like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们转向我们的另一种技术：简化问题。如果我们把相同数字的所有出现放在一起，事情会变得简单一些吗？例如，如果我们的样本数组调查数据看起来像这样：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now both of the 7s are together, the 9s are together, and the 3s are together.
    With the data grouped in this manner, it seems that we should be able to sequentially
    process the array to find the mode. Processing the array by hand, it’s easy to
    count the occurrences of each value, because you just keep counting down the array
    until you find the first number that’s different. Converting what we can do in
    our head into programming statements, however, can be tricky. So before we try
    writing the code for this simplified problem, let’s write some *pseudocode*, which
    is programming-like statements that are not entirely English or C++ but something
    in between. This will remind us what we’re trying to do with each statement we
    need to write.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有的7都在一起，所有的9都在一起，所有的3也都在一起。以这种方式将数据分组后，似乎我们可以按顺序处理数组来找到众数。手动处理数组时，很容易计算每个值的出现次数，因为你只需继续数下去，直到找到第一个不同的数字。然而，将我们可以在脑海中完成的事情转换为编程语句可能会很棘手。因此，在我们尝试编写这个简化问题的代码之前，让我们先写一些*伪代码*，这是一种类似编程的语句，它既不是完全的英语或C++，而是在两者之间。这将提醒我们，我们需要用每个语句尝试做什么。
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is no right or wrong way to write pseudocode, and if you use this technique,
    you should adopt your own style. When I write pseudocode, I tend to write legal
    C++ for any statement I’m already confident about and then spell out in English
    the places where I still have thinking to do. Here, we know that we will need
    a variable (`mostFrequent`) to hold the most frequently found value so far, which
    at the end of the loop will be the mode once we’ve written everything correctly.
    We also need a variable to store how often that value occurs (`highestFrequency`)
    so we have something to compare against. Finally, we need a variable we can use
    to count the number of occurrences of the value we’re currently tracking as we
    sequentially process the array (`currentFrequency`). We know we need to initialize
    our variables. For `currentFrequency`, it logically has to start at 0, but it’s
    not clear how we need to initialize the other variables yet, without the other
    code in place. So let’s just drop in question marks ![](httpatomoreillycomsourcenostarchimages1273182.png)
    to remind us to look at that again later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写伪代码没有对错之分，如果你使用这种技术，你应该采用自己的风格。当我写伪代码时，我倾向于写合法的C++语句，对于我已经有信心的地方，然后在英语中详细说明我还需要思考的地方。在这里，我们知道我们需要一个变量（`mostFrequent`）来保存迄今为止最频繁出现的值，在循环结束时，这将是我们正确写入后的众数。我们还需要一个变量来存储该值出现的频率（`highestFrequency`），以便进行比较。最后，我们需要一个变量，我们可以用它来计数我们正在跟踪的值的出现次数（`currentFrequency`），在我们顺序处理数组时。我们知道我们需要初始化我们的变量。对于`currentFrequency`，它逻辑上必须从0开始，但还没有其他代码的情况下，我们不清楚如何初始化其他变量。所以让我们简单地插入问号
    ![图片](http://atomoreilly.com/source/nostarch/images/1273182.png) 来提醒我们稍后再次查看这一点。
- en: 'The loop itself is the same array-processing loop we’ve already seen, so that’s
    already in final form ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Inside the loop, we increment the variable that counts the occurrences of the
    current value ![](httpatomoreillycomsourcenostarchimages1273193.png), and then
    we reach the pivotal statement. We know we need to check to see whether we’ve
    reached the last occurrence of a particular value ![](httpatomoreillycomsourcenostarchimages1273195.png).
    The pseudocode allows us to skip figuring out the logic for now and sketch out
    the rest of the code. If this *is* the last occurrence of the value, though, we
    know what to do because this is like the “highest value” code: We need to see
    whether this value’s count is higher than the highest seen so far. If it is, this
    value becomes the new most frequent value ![](httpatomoreillycomsourcenostarchimages1273197.png).
    Then, because the next value read will be the first occurrence of a new value,
    we reset our counter ![](httpatomoreillycomsourcenostarchimages1273199.png).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 循环本身是我们已经见过的相同数组处理循环，所以它已经处于最终形式 ![图片](http://atomoreilly.com/source/nostarch/images/1273191.png)。在循环内部，我们增加计数当前值出现的变量
    ![图片](http://atomoreilly.com/source/nostarch/images/1273193.png)，然后我们到达关键语句。我们知道我们需要检查是否达到了特定值的最后一个出现
    ![图片](http://atomoreilly.com/source/nostarch/images/1273195.png)。伪代码允许我们暂时跳过逻辑的推理，并勾勒出其余的代码。不过，如果这是值的最后一个出现，我们知道该怎么做，因为这就像“最高值”代码：我们需要查看这个值的计数是否高于迄今为止看到的最高值。如果是，这个值就变成了新的最频繁值
    ![图片](http://atomoreilly.com/source/nostarch/images/1273197.png)。然后，因为接下来读取的值将是新值的第一个出现，我们重置我们的计数器
    ![图片](http://atomoreilly.com/source/nostarch/images/1273199.png)。
- en: 'Let’s return to the `if` statement logic we skipped. How do we know whether
    this is the last occurrence of a value in the array? Because the values in the
    array are grouped, we know whether a value is the last occurrence when the next
    value in the array is something different: in C++ terms, when `surveyData[i]`
    and `surveyData[i + 1]` are not equal. Furthermore, the last value in the array
    is also the last occurrence of some value, even though there’s not a next value.
    We can check for this by checking to see whether `i == ARRAY_SIZE - 1`, in which
    case this is the last value in the array.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们跳过的`if`语句逻辑。我们如何知道这是数组中值的最后一个出现？因为数组中的值是分组的，所以当数组中的下一个值是不同的时候，我们知道一个值是最后一个出现：用C++的话说，当`surveyData[i]`和`surveyData[i
    + 1]`不相等时。此外，数组的最后一个值也是某个值的最后一个出现，即使没有下一个值。我们可以通过检查`i == ARRAY_SIZE - 1`来检查这一点，在这种情况下，这是数组的最后一个值。
- en: 'With all of that figured out, let’s think about those initial values for our
    variables. Remember with the “highest value” array-processing code, we initialized
    our “highest so far” variable to the first value in the array. Here, the “most
    frequently seen” value is represented by two variables, `mostFrequent` for the
    value itself and `highestFrequency` for the number of occurrences. It would be
    great if we could initialize `mostFrequent` to the first value that appears in
    the array and `highestFrequency` to its frequency count, but there’s no way to
    determine the first value’s frequency until we get into the loop and start counting.
    At this point, it might occur to us that the first value’s frequency, whatever
    it is, would be greater than zero. Therefore, if we set `highestFrequency` to
    zero, once we reach the last occurrence of the first value, our code will replace
    `mostFrequent` and `highestFrequency` with the numbers for the first value anyway.
    The completed code looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在弄清楚所有这些之后，让我们考虑一下我们变量的初始值。记得在使用“最高值”数组处理代码时，我们将“迄今为止最高”变量初始化为数组的第一个值。在这里，“最频繁出现的”值由两个变量表示，`mostFrequent`用于值本身，`highestFrequency`用于出现次数。如果能将`mostFrequent`初始化为数组中首次出现的值，将`highestFrequency`初始化为其频率计数，那就太好了，但在进入循环并开始计数之前，我们无法确定第一个值的频率。在这个时候，我们可能会想到，无论第一个值的频率是多少，它都将是大于零的。因此，如果我们把`highestFrequency`设为零，一旦我们到达第一个值最后一次出现的位置，我们的代码无论如何都会用第一个值的数字替换`mostFrequent`和`highestFrequency`。完整的代码看起来是这样的：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this book, we won’t talk much about pure style issues, such as documentation
    (commenting) style, but since we are using pseudocode on this problem, I want
    to mention a tip. I’ve noticed that the lines I leave as “plain English” in the
    pseudocode are the lines that benefit most from a comment in the final code, and
    the plain English itself makes a great comment. I’ve demonstrated that in the
    code here. You might forget the exact meaning behind the conditional expression
    in the `if` statement ![](httpatomoreillycomsourcenostarchimages1273191.png),
    but the comment on the preceding line ![](httpatomoreillycomsourcenostarchimages1273182.png)
    clears things up nicely.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会过多地讨论纯风格问题，例如文档（注释）风格，但既然我们在这个问题上使用伪代码，我想提一个建议。我注意到，我在伪代码中留下的“普通英语”行，在最终代码中受益最多的地方就是注释，而普通英语本身就是一个很好的注释。我在这里的代码中展示了这一点。你可能会忘记`if`语句中的条件表达式背后的确切含义![图片](httpatomoreillycomsourcenostarchimages1273191.png)，但前一行![图片](httpatomoreillycomsourcenostarchimages1273182.png)上的注释很好地澄清了这些问题。
- en: 'As for the code itself, it does the job, but remember that it requires our
    survey data to be grouped. Grouping the data might be a job in itself, except—what
    if we *sorted* the array? We don’t actually need the data to be sorted, but sorting
    will accomplish the grouping we need. Because we don’t intend to do any special
    kind of sorting, let’s just add this call to `qsort` to the beginning of our code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码本身，它完成了任务，但请记住，它需要我们的调查数据被分组。分组数据可能本身就是一项工作，除非——如果我们对数组进行*排序*会怎样？实际上我们并不需要数据被排序，但排序将完成我们需要的分组。因为我们不打算进行任何特殊的排序，所以让我们将这个`qsort`调用添加到我们代码的开头：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we’re using the same `compareFunc` we wrote earlier for use with `qsort`.
    With the sorting step in place, we have a complete solution to the original problem.
    So our work is done. Or is it?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用之前为`qsort`编写的相同的`compareFunc`。有了排序步骤，我们就有了解决原始问题的完整解决方案。所以我们的工作完成了。是吗？
- en: Refactoring
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: Some programmers talk about code that gives off “bad smells.” They are talking
    about working code that is free of bugs but still problematic in some way. Sometimes
    this means code that is too complicated or has too many special cases, making
    the program difficult for a programmer to modify and maintain. In other cases,
    the code isn’t as efficient as it could be, and while it works for test cases,
    the programmer worries that performance will break down with larger cases. That’s
    my concern here. The sorting step is nearly instantaneous for our tiny test case,
    but what if the array is huge? Also, I know that the quicksort algorithm, which
    `qsort` may be using, has its lowest performance when there are lots of duplicate
    values in the array, and the whole point of this problem is that all of our values
    are in the range 1–10\. I therefore propose to *refactor* the code. *Refactoring*
    means improving working code, not changing what it does but how it does it. I
    want a solution that is highly efficient for even huge arrays, assuming that the
    values are in the range of 1–10.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员谈论着“有坏味道”的代码。他们指的是那些没有错误但以某种方式仍然存在问题的可工作代码。有时这意味着代码过于复杂或包含过多的特殊情况，使得程序员难以修改和维护程序。在其他情况下，代码的效率不如预期，尽管它在测试用例中运行良好，但程序员担心性能会在更大的用例中崩溃。这就是我这里关心的问题。对于我们的小型测试用例，排序步骤几乎是瞬间的，但如果我们处理的数组非常大呢？此外，我知道快速排序算法（`qsort`可能正在使用）在数组中有大量重复值时性能最低，而这个问题的全部要点是所有我们的值都在1到10的范围内。因此，我建议对代码进行**重构**。**重构**意味着改进可工作代码，而不是改变它所做的事情，而是改变它执行的方式。我希望找到一个解决方案，即使对于非常大的数组也非常高效，假设值在1到10的范围内。
- en: 'Let’s think again about the operations we know how to do with arrays. We’ve
    already explored several versions of the “find the highest” code. We know that
    applying the “find the highest” code directly to our `surveyData` array won’t
    produce useful results. Is there an array to which we could apply the “stock”
    version of “find the highest” and get the mode of the survey data? The answer
    is yes. The array we need is the histogram of the `surveyData` array. A histogram
    is a graph showing how often different values appear in an underlying dataset;
    our array will be the data for such a histogram. In other words, we’ll store,
    in a 10-element array, how often each of the values 1 through 10 appears in `surveyData`.
    Here’s the code to create our histogram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次思考我们已知如何使用数组的操作。我们已经探索了“找到最高值”代码的几个版本。我们知道直接将“找到最高值”代码应用于我们的`surveyData`数组不会产生有用的结果。我们能否找到一个数组，可以应用“股票”版本的“找到最高值”并得到调查数据的众数？答案是肯定的。我们需要的是`surveyData`数组的直方图。直方图是一个显示不同值在基础数据集中出现频率的图表；我们的数组将是此类直方图的数据。换句话说，我们将在一个10个元素的数组中存储1到10每个值在`surveyData`中出现的频率。下面是创建我们直方图的代码：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On the first line, we declare the array to hold our histogram data ![](httpatomoreillycomsourcenostarchimages1273182.png).
    You’ll note we declare the array with 10 elements, but the range of our survey
    responses is 1–10, and the range of subscripts for this array is 0–9\. Thus, we’ll
    have to make adjustments, putting the count of 1s in `histogram[0]` and so on.
    (Some programmers would choose to declare the array with 11 elements, leaving
    location `[0]` unused, to allow each count to go into its natural position.) We
    explicitly initialize the array values to zero with a loop ![](httpatomoreillycomsourcenostarchimages1273191.png),
    and then we are ready to count the occurrences of each value in `surveyData` with
    another loop ![](httpatomoreillycomsourcenostarchimages1273193.png). The statement
    inside the loop ![](httpatomoreillycomsourcenostarchimages1273195.png) has to
    be read carefully; we are using the value in the current location of `surveyData`
    to tell us which position in `histogram` to increment. To make this clear, let’s
    take an example. Suppose `i` is 42\. We inspect `surveyData[42]` and find (let’s
    say) the value 7\. So we need to increment our 7 counter. We subtract 1 from 7
    to get 6 because the counter for 7s is in position `[6]` in `histogram`, and `histogram[6]`
    is incremented.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们声明数组来存储我们的直方图数据 ![数组声明](http://atomoreilly.com/source/nostarch/images/1273182.png)。你会注意到我们声明了一个包含10个元素的数组，但我们的调查响应范围是1–10，而这个数组的下标范围是0–9。因此，我们需要进行调整，将1的计数放在`histogram[0]`中，依此类推。（一些程序员会选择声明一个包含11个元素的数组，留出位置`[0]`未使用，以便每个计数都能进入其自然位置。）我们使用循环显式地将数组值初始化为零
    ![初始化数组](http://atomoreilly.com/source/nostarch/images/1273191.png)，然后我们就可以使用另一个循环来计数`surveyData`中每个值的出现次数
    ![计数循环](http://atomoreilly.com/source/nostarch/images/1273193.png)。循环内的语句 ![循环语句](http://atomoreilly.com/source/nostarch/images/1273195.png)
    需要仔细阅读；我们正在使用`surveyData`当前位置中的值来告诉我们应该增加`histogram`中的哪个位置。为了使这一点更清晰，让我们举一个例子。假设`i`是42。我们检查`surveyData[42]`并找到（比如说）值7。因此，我们需要增加我们的7计数器。我们从7中减去1得到6，因为7的计数器在`histogram`中的位置是`[6]`，并且`histogram[6]`被增加。
- en: 'With the histogram data in place, we can write the rest of the code. Note that
    the histogram code was written separately so that it could be tested separately.
    No time is saved by writing all of the code at once in a situation where the problem
    is easily separated into parts that can be individually written and tested. Having
    tested the above code, we now search for the largest value in the `histogram`
    array:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在直方图数据就绪后，我们可以编写其余的代码。请注意，直方图代码是单独编写的，以便可以单独测试。在问题可以轻松分解为可以单独编写和测试的部分的情况下，一次性编写所有代码并不会节省时间。在测试了上述代码后，我们现在在`histogram`数组中搜索最大值：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although this is an adaptation of the “find the highest” code, there is a difference.
    Although we are searching for the highest value in the histogram array, ultimately,
    we don’t want the value itself, but the position. In other words, with our sample
    array, we want to know that 3 occurs more often than any other value in the survey
    data, but the actual number of times 3 occurs isn’t important. So `mostFrequent`
    will be the position of the highest value in `histogram`, not the highest value
    itself. Therefore, we initialize it to `0` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and not the value in `location[0]`. This also means that in the `if` statement,
    we compare against `histogram[mostFrequent]` ![](httpatomoreillycomsourcenostarchimages1273191.png)
    and not `mostFrequent` itself, and we assign `i`, not `histogram[i]`, to `mostFrequent`
    ![](httpatomoreillycomsourcenostarchimages1273193.png) when a larger value is
    found. Finally, we increment `mostFrequent` ![](httpatomoreillycomsourcenostarchimages1273195.png).
    This is the reverse of what we did in the earlier loop, subtracting 1 to get the
    right array position. If `mostFrequent` is telling us that the highest array position
    is 5, for example, it means that the most frequent entry in the survey data was
    6.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个“查找最大值”代码的改编版本，但存在差异。虽然我们在直方图数组中寻找最大值，但最终我们并不想要这个值本身，而是它的位置。换句话说，使用我们的样本数组，我们想知道3在调查数据中出现的频率比任何其他值都要高，但实际上3出现的次数并不重要。因此，`mostFrequent`将是`histogram`中最高值的**位置**，而不是最高值本身。因此，我们将其初始化为`0`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png) 而不是`location[0]`中的值。这也意味着在`if`语句中，我们比较的是`histogram[mostFrequent]`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273191.png) 而不是`mostFrequent`本身，当我们找到一个更大的值时，我们将`i`而不是`histogram[i]`赋值给`mostFrequent`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273193.png)。最后，我们增加`mostFrequent`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273195.png)。这与我们在早期循环中所做的是相反的，通过减去1来获取正确的数组位置。如果`mostFrequent`告诉我们最高数组位置是5，例如，这意味着调查数据中出现频率最高的值是6。
- en: The histogram solution scales linearly with the number of elements in our `surveyData`
    array, which is as good as we could hope for. Therefore, it’s a better solution
    than our original approach. This doesn’t mean that the first approach was a mistake
    or a waste of time. It’s possible, of course, to have written this code without
    going through the previous version, and we can be forgiven for wishing that we
    had driven directly to our destination instead of taking the longer route. However,
    I would caution against slapping yourself on the forehead on those occasions when
    the first solution turns out not to be the final solution. Writing an original
    program (and remember this means *original for the programmer writing it*) is
    a learning process and can’t be expected to always progress in a straight line.
    Also, it’s often the case that taking a longer path on one problem helps us take
    a shorter path on a later problem. In this particular case, note that our original
    solution (while it doesn’t scale well for our particular problem) could be the
    right solution if the survey responses weren’t strictly limited to the small range
    of 1–10\. Or suppose that you are later asked to write code that finds the *median*
    of a set of integer values (the median is the value in the middle, such that half
    of the other values in the set are higher and half of the other values are lower).
    The histogram approach doesn’t get you anywhere with the median, but our first
    approach for the mode does.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图解决方案与我们的`surveyData`数组中的元素数量成线性比例，这是我们所能期望的最好的结果。因此，它比我们的原始方法更好。这并不意味着第一种方法是一个错误或浪费时间。当然，我们可以编写这个代码而不经过之前的版本，我们可以原谅我们希望我们能够直接到达目的地而不是走更长的路。然而，我警告你，当第一个解决方案最终不是最终解决方案时，不要拍打自己的额头。编写一个原始程序（记住，这意味着对于编写程序的程序员来说是**原始的**）是一个学习过程，不能期望它总是直线前进。此外，通常情况下，在一个问题上走更长的路可以帮助我们在后来的问题上走更短的路。在这个特定的情况下，请注意，我们的原始解决方案（虽然对于我们的特定问题扩展性不好）如果调查响应没有严格限制在1-10的小范围内，可能是正确的解决方案。或者假设你后来被要求编写一个查找一组整数值的**中位数**（中位数是中间的值，使得集合中一半的其他值更高，另一半的其他值更低）的代码。直方图方法对于中位数没有任何帮助，但我们的第一个方法对于众数是有帮助的。
- en: The lesson here is that a long journey is not a waste of time if you learned
    something from it that you wouldn’t have learned by going the short way. This
    is another reason why it’s helpful to methodically store all of the code that
    you write so that you can easily find and reuse it later. Even the code that turns
    out to be a “dead end” can become a valuable resource.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，如果你从漫长的旅程中学到了一些你通过短途旅行无法学到的东西，那么漫长的旅程并不是浪费时间。这也是为什么系统地存储你编写的所有代码很有帮助的原因，这样你可以轻松地找到并稍后重用它。即使是最终成为“死胡同”的代码也可以成为宝贵的资源。
- en: Arrays of Fixed Data
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定数据数组
- en: In most array problems, the array is a repository for data external to the program,
    such as user-entered data, data on a local disk, or data from a server. To get
    the most out of the array tool, however, you need to recognize other situations
    in which an array can be used. It’s often useful to create an array where the
    values never change after the initialization. Such an array can allow a simple
    loop or even a direct array lookup to replace a whole block of control statements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数数组问题中，数组是程序外部数据的存储库，例如用户输入的数据、本地磁盘上的数据或来自服务器的数据。然而，为了充分利用数组工具，你需要认识到其他可以使用数组的情况。通常，创建一个初始化后值永远不会改变的数组是有用的。这样的数组可以允许使用简单的循环，甚至直接使用数组查找来替换整个控制语句块。
- en: 'In the final code for the [Problem: Decode a message](ch02.html#problem_colon_decode_a_message
    "Problem: Decode a message") problem in [Tracking State](ch02.html#tracking_state
    "Tracking State"), we used a `switch` statement to translate the decoded input
    number (in the range 1–8) to the appropriate character when in “punctuation mode”
    because the connection between the number and the character was arbitrary. Although
    this worked fine, it made that section of code longer than the equivalent code
    for the uppercase and lowercase modes, and the code would not scale well if the
    number of punctuation symbols increased. We can use an array to solve this problem
    instead of the `switch` statement. First, we need to permanently assign the punctuation
    symbols to an array in the same order they appear in the coding scheme:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '在[跟踪状态](ch02.html#tracking_state "Tracking State")章节中，[问题：解码信息](ch02.html#problem_colon_decode_a_message
    "Problem: Decode a message")的最终代码中，我们使用了一个`switch`语句将解码后的输入数字（范围在1-8之间）在“标点符号模式”下转换为相应的字符，因为数字和字符之间的联系是任意的。尽管这样做效果不错，但它使得该段代码比大写和小写模式的等效代码更长，而且如果标点符号的数量增加，代码的可扩展性不会很好。我们可以使用一个数组来解决这个问题，而不是使用`switch`语句。首先，我们需要将标点符号永久地分配到一个数组中，其顺序与编码方案中出现的顺序相同：'
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that this array has been declared `const` because the values inside
    will never change. With that declaration in place, we can replace the entire switch
    statement with a single assignment statement that references the array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个数组已经被声明为`const`，因为其内部值永远不会改变。有了这个声明，我们可以用一个引用数组的单一赋值语句来替换整个`switch`语句：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Because the input number is in the range 1–8, but array elements are numbered
    starting from 0, we have to subtract 1 from the input number before referencing
    the array; this is the same adjustment we made in the histogram version of the
    “Finding the Mode” program. You can use the same array to go in the other direction.
    Suppose instead of decoding the message, we had to encode a message—that is, we
    were given a series of characters to convert into numbers that could be decoded
    using the rules of the original problem. To convert a punctuation symbol into
    its number, we have to locate the symbol in the array. This is a retrieval, performed
    using the sequential search technique. Assuming the character is to be converted
    and stored in the `char` variable `targetValue`, we could adapt the sequential
    search code as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输入数字的范围是1-8，但数组元素是从0开始编号的，所以在引用数组之前，我们必须从输入数字中减去1；这与我们在“寻找众数”程序的直方图版本中所做的调整相同。你可以使用相同的数组来反向操作。假设我们不是在解码信息，而是需要编码信息——也就是说，我们被给了一系列字符，需要将它们转换为可以使用原始问题规则解码的数字。要将一个标点符号转换为它的数字，我们必须在数组中定位该符号。这是一个检索操作，使用的是顺序搜索技术。假设要转换并存储在`char`变量`targetValue`中的字符，我们可以将顺序搜索代码调整为以下形式：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that just as we had to subtract 1 from `number` in the previous example
    to get the right array position, we have to add 1 to the array position in this
    example to get our punctuation code, converting from the array’s range of 0–7
    to our punctuation code range of 1–8\. Although this code is not as simple as
    a single line, it’s still much simpler than a series of `switch` statements, and
    it scales well. If we were to double the number of punctuation symbols in our
    coding scheme, it would double the number of elements in the array, but the length
    of the code would stay the same.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，就像我们在上一个例子中必须从`number`中减去1以获得正确的数组位置一样，在这个例子中我们必须将数组位置加1以获得我们的标点符号代码，从数组的0-7范围转换为我们的标点符号代码范围1-8。尽管这段代码不如单行简单，但它仍然比一系列`switch`语句简单得多，并且具有良好的可扩展性。如果我们想要将我们的编码方案中的标点符号数量加倍，那么数组中的元素数量也会加倍，但代码的长度将保持不变。
- en: In general, then, `const` arrays can be used as lookup tables, replacing a burdensome
    series of control statements. Suppose you are writing a program to compute the
    cost of a business license in a state where the license cost varies as the gross
    sales figures of the business vary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说，`const`数组可以用作查找表，取代一系列繁重的控制语句。假设你正在编写一个程序来计算一个州中商业许可证的费用，其中许可证费用随商业的毛销售额变化而变化。
- en: Table 3-1. Business License Costs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-1. 商业许可证费用
- en: '| Business category | Sales threshold | License cost |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 商业类别 | 销售门槛 | 许可费用 |'
- en: '| --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| I | $0 | $25 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| I | $0 | $25 |'
- en: '| II | $50,000 | $200 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| II | $50,000 | $200 |'
- en: '| III | $150,000 | $1,000 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| III | $150,000 | $1,000 |'
- en: '| IV | $500,000 | $5,000 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| IV | $500,000 | $5,000 |'
- en: 'With this problem, we could use arrays both to determine the business category
    based on the company’s gross sales and to assign the license cost based on the
    business category. Suppose a `double` variable, `grossSales`, stores the gross
    sales of a business, and based on the sales figure, we want to assign the proper
    values to `int category` and `double cost`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们可以使用数组来确定基于公司的毛销售额的商业类别，并根据商业类别分配许可证费用。假设一个`double`变量`grossSales`存储了商业的毛销售额，根据销售额，我们想要为`int
    category`和`double cost`分配适当的值：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code uses two arrays of fixed values. The first array stores the gross
    sales threshold for each business category ![](httpatomoreillycomsourcenostarchimages1273182.png).
    For example, a business with $65,000 in yearly gross sales is in category II because
    this amount exceeds the $50,000 threshold of category II but is less than the
    $150,000 threshold of category III. The second array stores the cost of a business
    license for each category ![](httpatomoreillycomsourcenostarchimages1273191.png).
    With the arrays in place, we initialize `category` to 0 ![](httpatomoreillycomsourcenostarchimages1273193.png)
    and search through the `categoryThresholds` array, stopping when the threshold
    exceeds the gross sales or when we run out of categories ![](httpatomoreillycomsourcenostarchimages1273195.png).
    In either case, when the loop is done, `category` will be correctly assigned 1–4
    based on the gross sales. The last step is to use `category` to reference the
    license cost from the `licenseCost` array ![](httpatomoreillycomsourcenostarchimages1273197.png).
    As before, we have to make a small adjustment from the 1–4 range of the business
    categories to the 0–3 range of our array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用两个固定值的数组。第一个数组存储每个商业类别的毛销售额门槛！[](httpatomoreillycomsourcenostarchimages1273182.png)。例如，年毛销售额为65,000美元的商业属于类别II，因为这个金额超过了类别II的50,000美元门槛，但低于类别III的150,000美元门槛。第二个数组存储每个类别的商业许可证费用！[](httpatomoreillycomsourcenostarchimages1273191.png)。有了这些数组，我们将`category`初始化为0！[](httpatomoreillycomsourcenostarchimages1273193.png)，并搜索`categoryThresholds`数组，直到门槛超过毛销售额或我们用完类别！[](httpatomoreillycomsourcenostarchimages1273195.png)。在两种情况下，当循环结束时，`category`将根据毛销售额正确分配为1-4。最后一步是使用`category`从`licenseCost`数组中引用许可证费用！[](httpatomoreillycomsourcenostarchimages1273197.png)。和之前一样，我们必须对商业类别的1-4范围和我们的数组0-3范围进行小的调整。
- en: Non-scalar Arrays
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非标量数组
- en: So far, we’ve just worked with arrays of simple data types, such as `int` and
    -`double`. Often, however, programmers must deal with arrays of compound data,
    either structures or objects (struct or `class`). Although the use of compound
    data types necessarily complicates the code somewhat, it doesn’t have to complicate
    our thinking about array processing. Usually the array processing just involves
    one data member of the `struct` or `class`, and we can ignore the other parts
    of the data structure. Sometimes, though, the use of compound data types requires
    us to make some changes to our approach.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是处理了简单数据类型的数组，如`int`和`double`。然而，程序员经常必须处理复合数据类型的数组，无论是结构体还是对象（struct或`class`）。尽管使用复合数据类型必然会使代码变得复杂一些，但这并不需要使我们对数组处理的思考变得复杂。通常，数组处理只涉及`struct`或`class`的一个数据成员，我们可以忽略数据结构的其他部分。有时，使用复合数据类型需要我们对方法进行一些调整。
- en: 'For example, consider the problem of finding the highest of a set of student
    grades. Suppose that instead of an array of `int`, we have an array of data structures,
    each representing a student’s record:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑寻找一组学生成绩中最高的成绩的问题。假设我们不是有一个`int`类型的数组，而是一个包含数据结构的数组，每个数据结构代表一个学生的记录：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One nice thing about working with arrays is that it is easy to initialize a
    whole array with literal values for easy testing, even with an array of `struct`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一起工作的一个好处是，可以轻松地使用字面值初始化整个数组，以便于测试，即使是`struct`数组：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This declaration means that `studentArray[0]` has an 87 for its `grade`, 10001
    for its `studentID`, and “Fred” for a `name`, and so on for the other nine elements
    in the array. As for the rest of the code, it could be as simple as copying the
    code from the beginning of this chapter, and then replacing every reference of
    the form `intArray[subscript]` with `studentArray[subscript].grade`. That would
    result in the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明意味着`studentArray[0]`的`grade`是87，`studentID`是10001，`name`是“Fred”，数组中的其他九个元素以此类推。至于代码的其他部分，可能就像复制本章开头的代码，然后将所有形式为`intArray[subscript]`的引用替换为`studentArray[subscript].grade`。这将导致以下结果：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Suppose instead that because we now have additional information for each student,
    we want to find the name of the student with the best grade, not the grade itself.
    This would require additional modification. When our loop is over, the only statistic
    we have is the best grade, and that does not allow us to directly determine the
    student to which it belongs. We’d have to run through the array again, searching
    for the `struct` with the matching `gra``de`, which seems like extra work we shouldn’t
    have to do. To avoid this issue, we should either additionally track the name
    of the student that matches the current value in `highest`, or, instead of tracking
    the highest grade, track the location in the array where the highest grade is
    found, much as we did with `histogram` earlier. The latter approach is the most
    general because tracking the array position allows us to retrieve *any* of the
    data for that student later:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们为每个学生有了额外的信息，我们想要找到成绩最好的学生的名字，而不是成绩本身。这将需要额外的修改。当循环结束时，我们唯一拥有的统计数据是最佳成绩，这并不允许我们直接确定它属于哪个学生。我们不得不再次遍历数组，寻找具有匹配`grade`的`struct`，这似乎是额外的、我们不应该做的额外工作。为了避免这个问题，我们应该额外跟踪与当前`highest`值匹配的学生名字，或者，而不是跟踪最高成绩，跟踪最高成绩在数组中的位置，就像我们在`histogram`中做的那样。后一种方法是最通用的，因为跟踪数组位置允许我们稍后检索该学生的任何数据：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the variable `highPosition` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    takes the place of `highest`. Because we aren’t directly tracking the grade closest
    to the average, when it’s time to compare the closest grade against the current
    grade, we use `highPosition` as a reference into `studentArray` ![](httpatomoreillycomsourcenostarchimages1273191.png).
    If the grade in the current array position is higher, the current position in
    our processing loop is assigned to `highPosition` ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Once the loop is over, we can access the name of the student with the grade closest
    to the average using `studentArray[highPosition].name`, and we can also access
    any other data related to that student record.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量`highPosition` ![](httpatomoreillycomsourcenostarchimages1273182.png)取代了`highest`。因为我们没有直接跟踪最接近平均分的成绩，所以在需要将最接近平均分的成绩与当前成绩进行比较时，我们使用`highPosition`作为`studentArray`
    ![](httpatomoreillycomsourcenostarchimages1273191.png)的引用。如果当前数组位置的成绩更高，则将当前处理循环的位置分配给`highPosition`
    ![](httpatomoreillycomsourcenostarchimages1273193.png)。一旦循环结束，我们可以使用`studentArray[highPosition].name`访问成绩最接近平均分的学生姓名，我们还可以访问与该学生记录相关的任何其他数据。
- en: Multidimensional Arrays
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'So far, we’ve only discussed one-dimensional arrays because they are the most
    common. Two-dimensional arrays are uncommon, and arrays with three or more dimensions
    are rare. That’s because most data is one-dimensional by nature. Furthermore,
    data that is inherently multidimensional can be represented as multiple single-dimension
    arrays, so using a multidimensional array is always the choice of the programmer.
    Consider the business license data of [Table 3-1](ch03.html#business_license_costs
    "Table 3-1. Business License Costs"). That’s clearly multidimensional data. I
    mean, look at it—it’s a grid! I represented this multidimensional data, however,
    as two one-dimensional arrays, `categoryThresholds` and `licenseCost`. I could
    have represented the data table as a two-dimensional array, like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了一维数组，因为它们是最常见的。二维数组不常见，三维或更多维度的数组更罕见。这是因为大多数数据在本质上是一维的。此外，本质上多维的数据可以表示为多个单维数组，因此使用多维数组始终是程序员的选项。考虑[表3-1](ch03.html#business_license_costs
    "表3-1. 商业许可费用")的商业许可数据，这显然是多维数据。我的意思是，看看它——它是一个网格！然而，我将这个多维数据表示为两个单维数组，`categoryThresholds`和`licenseCost`。我本可以将数据表表示为二维数组，如下所示：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It’s difficult to discern any advantage from combining the two arrays into one.
    None of our code is simplified because there is no reason to process all of the
    data in the table at once. What is clear, though, is that we have lowered the
    readability and ease of use for our table data. In the original version, the names
    of the two separate arrays make it clear what data is stored in each. With the
    combined array, we programmers will have to remember that references of the form
    `licenseData[0][]` refer to the gross sales thresholds of the different business
    categories, while references of the form `licenseData[1][]` refer to business
    license costs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个数组合并为一个很难看出任何优势。我们的代码并没有简化，因为没有理由一次性处理表格中的所有数据。然而，很明显，我们降低了表格数据的可读性和易用性。在原始版本中，两个单独数组的名称清楚地表明了存储在每个数组中的数据。而在合并后的数组中，我们程序员将不得不记住，形式为`licenseData[0][]`的引用指的是不同商业类别的总销售额阈值，而形式为`licenseData[1][]`的引用则指的是商业许可费用。
- en: 'Sometimes it does make sense to use a multidimensional array, though. Suppose
    we are processing the monthly sales data for three sales agents, and one of the
    tasks is finding the highest monthly sales, from any agent. Having all of the
    data in one 3 × 12 array means we can process the entire array at once, using
    nested loops:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时使用多维数组是有意义的。假设我们正在处理三位销售代理的月销售数据，其中一项任务是找出任何代理的最高月销售额。将所有数据放在一个3×12的数组中意味着我们可以一次性处理整个数组，使用嵌套循环：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Although this is a straightforward adaptation of the basic “find the largest
    number” code, there are a few wrinkles. When we declare our two-dimensional array,
    notice that the initializer is organized by agent, that is, as 3 groups of 12,
    not 12 groups of 3 ![](httpatomoreillycomsourcenostarchimages1273182.png). As
    you’ll see in the next problem, this decision can have consequences. We initialize
    `highestSales` to the first element in the array, as usual ![](httpatomoreillycomsourcenostarchimages1273191.png).
    It may occur to you that the first time through the nested loops, both of our
    loop counters will be 0, so we will be comparing this initial value of `highestSales`
    to itself. This doesn’t affect the outcome, but sometimes novice programmers will
    attempt to avoid this tiny inefficiency by putting in a second `if` statement
    in the inner loop body:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个基本的“找到最大数”代码的直接改编，但还有一些小问题。当我们声明二维数组时，请注意初始化器是按 `agent` 组织的，也就是说，是3组12个，而不是3组12个
    ![初始化器组织](http://atomoreilly.com/source/nostarch/images/1273182.png)。正如你将在下一个问题中看到的那样，这个决定可能会产生后果。我们像往常一样将
    `highestSales` 初始化为数组的第一个元素 ![初始化 highestSales](http://atomoreilly.com/source/nostarch/images/1273191.png)。你可能觉得在嵌套循环的第一次迭代中，我们的两个循环计数器都将为0，因此我们将比较
    `highestSales` 的初始值与自身。这不会影响结果，但有时新手程序员会试图通过在内部循环体中放入第二个 `if` 语句来避免这种微小的低效：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This, however, is considerably *less* efficient than the previous version because
    we would be performing 50 extra comparisons while avoiding only one.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这比之前的版本效率低得多，因为我们将进行50次额外的比较，而只避免了一次。
- en: 'Notice also that I have used meaningful names for the loop variables: `agent`
    for the outside loop ![](httpatomoreillycomsourcenostarchimages1273193.png) and
    `month` for the inside loop ![](httpatomoreillycomsourcenostarchimages1273195.png).
    In a single loop that processes a one-dimensional array, little is gained by a
    descriptive identifier. In a double loop that processes a two-dimensional array,
    however, the meaningful identifiers help me keep my dimensions and subscripts
    straight because I can look up and see that I am using `agent` in the same dimension
    where I used `numAgents` in the array declaration.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经为循环变量使用了有意义的名称：`agent` 用于外部循环 ![外部循环变量](http://atomoreilly.com/source/nostarch/images/1273193.png)
    和 `month` 用于内部循环 ![内部循环变量](http://atomoreilly.com/source/nostarch/images/1273195.png)。在处理一维数组的单循环中，描述性标识符带来的好处很小。然而，在处理二维数组的双循环中，有意义的标识符有助于我保持维度和下标的清晰，因为我可以查看并确认我在使用
    `agent` 的维度与在数组声明中使用 `numAgents` 的维度相同。
- en: Even when we have a multidimensional array, sometimes the best approach is to
    deal with just one dimension at a time. Suppose, using the same `sales` array
    as the previous code, we wanted to display the highest agent monthly sales average.
    We could do this using a double loop, as we have previously, but the code would
    be clearer to read and easier to write if we treated the whole array as three
    individual arrays and processed them separately.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们有多维数组，有时一次处理一个维度可能是最好的方法。假设，使用与之前代码相同的 `sales` 数组，我们想要显示每个 `agent` 的月销售平均最高值。我们可以像之前一样使用双循环，但如果我们将整个数组视为三个单独的数组并分别处理它们，代码将更容易阅读和编写。
- en: 'Remember the code we’ve been repeatedly using to compute the average of an
    array of integers? Let’s make that into a function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们反复使用的计算整数数组平均值的代码吗？让我们将其制作成一个函数：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the function in place, we can modify the basic “find the largest number”
    again to find the agent with the highest monthly sales average:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数就位后，我们可以再次修改基本的“找到最大数”代码，以找到月销售平均最高的 `agent`：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The big new idea here is shown in the two calls to `arrayAverage`. The first
    parameter accepted by this function is a one-dimensional array of `int`. In the
    first call, we pass `sales[0]` for the first argument ![](httpatomoreillycomsourcenostarchimages1273182.png),
    and in the second call, we pass `sales[agent]` ![](httpatomoreillycomsourcenostarchimages1273191.png).
    So in both cases, we specify a subscript for the first dimension of our two-dimensional
    array `sales`, but not for the second dimension. Because of the direct relationship
    between arrays and addresses in C++, this reference indicates the address of the
    first element of the specified row, which can then be used by our function as
    the base address of a one-dimensional array consisting of just that row.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大新观点体现在对`arrayAverage`函数的两次调用中。这个函数接受一个一维的`int`数组作为第一个参数。在第一次调用中，我们传递了`sales[0]`作为第一个参数
    ![http://atomoreilly.com/source/no_starch_images/1273182.png]，而在第二次调用中，我们传递了`sales[agent]`
    ![http://atomoreilly.com/source/no_starch_images/1273191.png]。因此，在这两种情况下，我们都为我们的二维数组`sales`的第一个维度指定了一个下标，但没有为第二个维度指定。由于C++中数组和地址之间的直接关系，这个引用表示了指定行的第一个元素的地址，然后我们可以将这个地址作为函数使用的一个只包含该行的单维数组的基址。
- en: If that sounds confusing, look again at the declaration of the `sales` array,
    and in particular, the initializer. The values are laid out in the initializer
    in the same order they will be laid out in memory when the program is executing.
    So `sales[0][0]`, which is 1856, will come first, followed by `sales[0][1]`, 498,
    and so on through the last month for the first agent, `sales[0][11]`, 32\. Then
    the values for the second agent will begin, starting with `sales[1][0]`, 5865\.
    Therefore, even though the array is conceptually 3 rows of 12 values, it’s laid
    out in memory as one big sequence of 36 values.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很困惑，请再次查看`sales`数组的声明，特别是初始化器。值按照程序执行时在内存中布局的相同顺序排列在初始化器中。因此，`sales[0][0]`，即1856，将首先出现，然后是`sales[0][1]`，498，以此类推，直到第一个代理的最后一个月，`sales[0][11]`，32。然后，第二个代理的值将从`sales[1][0]`，5865开始。因此，尽管数组在概念上是3行12个值，但在内存中它被布局为一个包含36个值的连续序列。
- en: It’s important to note that this technique works because of the order we’ve
    placed the data into the array. If the array were organized along the other axis,
    that is, by month instead of by agent, we couldn’t do what we are doing here.
    The good news is that there is an easy way to make sure you have set up the array
    appropriately—just check the initializer. If the data you want to individually
    process isn’t contiguous in the array initializer, you’ve organized the data the
    wrong way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这种技术之所以有效，是因为我们放置数据到数组中的顺序。如果数组是沿着另一个轴组织，即按月份而不是按代理组织，我们就无法做我们现在所做的事情。好消息是，有一个简单的方法可以确保你适当地设置了数组——只需检查初始化器。如果你想要单独处理的数据在数组初始化器中不是连续的，你就错误地组织了数据。
- en: The last thing to note about this code is the use of the temporary variable,
    `agentAverage`. Because the average monthly sales for the current agent is potentially
    referenced twice, once in the conditional expression of the `if` statement and
    then again in the assignment statement in the body, the temporary variable eliminates
    the possibility of calling `arrayAverage` twice for the same agent’s data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码的最后一点是临时变量`agentAverage`的使用。由于当前代理的平均月销售额可能被在`if`语句的条件表达式中和然后在语句体中的赋值语句中两次引用，临时变量消除了对同一代理数据调用`arrayAverage`两次的可能性。
- en: 'This technique of considering a multidimensional array as an array of arrays
    follows directly from our core principle of breaking problems up into simpler
    components and in general makes multidimensional array problems a lot easier to
    conceptualize. Even so, you may be thinking that the technique looks a little
    tricky to employ, and if you’re like most new C++ programmers, you are probably
    a little wary of addresses and behind-the-scenes address arithmetic. The best
    way around those feelings, I think, is to make the separation between the dimensions
    even stronger, by placing one level of array inside a `struct` or `class`. Suppose
    we made an `agentStruct`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将多维数组视为数组数组的这种技术直接源于我们分解问题为更简单组件的核心原则，并且通常使得多维数组问题更容易概念化。即便如此，你可能认为这种技术看起来有点难以应用，如果你像大多数新的C++程序员一样，你可能对地址和背后的地址运算有些谨慎。我认为，通过在一个`struct`或`class`中放置数组的一个级别，甚至可以更加强化维度的分离，这是克服这些感觉的最好方法。假设我们创建了一个`agentStruct`：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Having gone to the trouble of making a `struct`, we might think about adding
    other data, like an agent identification number, but this will get the job done
    in terms of simplifying our thought processes. With the `struct` in place, instead
    of creating a two-dimensional array of sales, we create a one-dimensional array
    of agents:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经费心创建了一个`struct`，我们可能会考虑添加其他数据，比如代理识别号，但这将有助于简化我们的思维过程。有了`struct`，我们不再创建一个二维销售数组，而是创建一个一维代理数组：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now when we make our call to the array-averaging function, we aren’t employing
    a C++ specific trick; we’re just passing a one-dimensional array. For example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们调用数组平均函数时，我们并没有使用C++特有的技巧；我们只是传递了一个一维数组。例如：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Deciding When to Use Arrays
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时使用数组
- en: An array is just a tool. As with any tool, an important part of learning *how*
    to use an array is learning *when* to use it—and when not to use it. The sample
    problems discussed so far assumed the use of arrays in their descriptions. In
    most situations, though, we won’t have this detail spelled out for us, and we
    must instead make our own determination on array use. The most common situations
    in which we must make this decision are those in which we are given aggregate
    data but not told how it must be stored internally. For example, in the problem
    where we found the mode, suppose the line that began *Write code that processes
    an array of survey data . . .*, had read *Write code that processes a collection
    of survey data . . .*. Now the choice of using an array or not would be ours.
    How would we make this decision?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数组只是一个工具。就像任何工具一样，学习如何使用数组的一个重要部分是学习何时使用它——以及何时不使用它。到目前为止讨论的示例问题假设了在描述中使用数组。然而，在大多数情况下，我们不会有人详细说明这一点，我们必须自己决定是否使用数组。我们必须做出这种决定的常见情况是我们被提供了聚合数据，但没有被告知如何内部存储。例如，在找到众数的问题中，假设开始于“编写代码处理调查数据数组……”的行被改为“编写代码处理调查数据集合……”。现在，是否使用数组的选择就取决于我们了。我们如何做出这个决定？
- en: Remember that we cannot change the size of an array after it has been created.
    If we ran out of space, our program would fail. So the first consideration is
    whether we will know, at the place in our program where we need an aggregate data
    structure, how many values we will store or at least a reliable estimate on the
    maximum size. This doesn’t mean we have to know the size of the array when we
    write the program. C++, as well as most other languages, allows us to create an
    array that is sized at runtime. Suppose the mode problem was modified so that
    we didn’t know ahead of time how many survey responses we would have, but that
    number came to the program as user input. Then we could dynamically declare an
    array to store the survey data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一旦数组被创建，我们无法改变其大小。如果我们空间不足，程序将会失败。因此，首要考虑的是，在我们程序中需要聚合数据结构的地方，我们是否知道将要存储多少值，或者至少对最大大小的可靠估计。这并不意味着我们在编写程序时必须知道数组的大小。C++，以及大多数其他语言，都允许我们在运行时创建大小可变的数组。假设模式问题被修改，以至于我们事先不知道会有多少调查响应，但这个数字作为用户输入传递给程序。然后我们可以动态声明一个数组来存储调查数据。
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We declare the array using pointer notation, initializing it through an invocation
    of the `new` operator ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Because of the fluidity between pointer and array types in C++, the elements can
    then be accessed using array notation ![](httpatomoreillycomsourcenostarchimages1273191.png),
    even though `surveyData` is declared as a pointer. Note that because this array
    is dynamically allocated, at the end of the program when we no longer need the
    array, we have to make sure to deallocate it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用指针表示法声明数组，并通过调用`new`运算符对其进行初始化 ![http://atomoreilly.com/source/no_starch_images/1273182.png]。由于C++中指针和数组类型之间的灵活性，元素可以通过数组表示法访问
    ![http://atomoreilly.com/source/no_starch_images/1273191.png]，即使`surveyData`被声明为指针。请注意，因为这个数组是动态分配的，所以在程序结束时，当我们不再需要数组时，我们必须确保释放它：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `delete[]` operator, rather than the usual `delete` operator, is used for
    arrays. Although it won’t make any difference with an array of integers, if you
    create an array of objects, the `delete[]` operator ensures that the individual
    objects in the array are deleted before the array itself is deleted. So you should
    adopt the habit of always using `delete[]` with dynamically allocated arrays.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，我们使用的是`delete[]`运算符，而不是通常的`delete`运算符。虽然对于整数数组来说这不会造成任何区别，但如果您创建了一个对象数组，`delete[]`运算符确保在删除数组本身之前删除数组中的各个对象。因此，您应该养成始终使用`delete[]`与动态分配的数组一起使用的习惯。
- en: Having the responsibility of cleaning up dynamic memory is the bane of the C++
    programmer, but if you program in the language, it is something you simply must
    do. Beginning programmers often shirk this responsibility because their programs
    are so small and execute for such short periods of time that they never see the
    harmful effects of memory leaks (memory that is no longer used by the program
    but never deallocated and therefore unavailable to the rest of the system). Don’t
    develop this bad habit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 承担清理动态内存的责任是C++程序员的噩梦，但如果你使用这种语言编程，这是一件你必须做的事情。初学者往往逃避这个责任，因为他们的程序很小，执行时间很短，所以他们从未看到内存泄漏（程序不再使用的内存但从未被释放，因此无法供系统其他部分使用）的有害影响。不要养成这种坏习惯。
- en: Note that we can use the dynamic array only because the user tells us the number
    of survey responses beforehand. Consider another variant where the user begins
    by entering survey responses without telling us the number of responses, indicating
    that there are no more responses by entering a −1 (a data entry method known as
    a *sentinel*). Can we still use an array to solve this problem?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之所以能够使用动态数组，仅仅是因为用户事先告诉我们调查响应的数量。考虑另一种情况，用户开始输入调查响应，但没有告诉我们响应的数量，通过输入-1（一种称为*哨兵*的数据输入方法）来表示没有更多的响应。我们还能使用数组来解决这个问题吗？
- en: This is a gray area. We could still use an array if we had a guaranteed maximum
    number of responses. In such a case, we could declare an array of that size and
    assume that we are safe. We might still have concerns over the long term, though.
    What if the size of the survey pool increases in the future? What if we want to
    use the same program with a different survey taker? More generally, why build
    a program with a known limitation if we can avoid it?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个灰色地带。如果我们有一个保证的最大响应数量，我们仍然可以使用数组。在这种情况下，我们可以声明一个该大小的数组，并假设我们是安全的。尽管如此，我们可能仍然会长期担忧。如果未来调查池的大小增加怎么办？如果我们想用不同的调查者使用相同的程序怎么办？更普遍地说，如果我们能避免，为什么还要构建一个具有已知限制的程序呢？
- en: 'Better, then, to use a data collection without a fixed size. As discussed earlier,
    the vector class from the C++ standard template library acts like an array but
    grows as necessary. Once declared and initialized, the vector can be processed
    exactly the same way as an array. We can assign a value to a vector element or
    retrieve a value using standard array notation. If the vector has filled its initial
    size and we need to add another element, we can do so using the `push_back` method.
    Solving the modified problem with a vector looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，最好使用一个没有固定大小的数据收集。如前所述，C++标准模板库中的向量类就像一个数组，但会根据需要增长。一旦声明和初始化，向量就可以像数组一样被处理。我们可以使用标准数组符号给向量元素赋值或检索值。如果向量已填满其初始大小，我们需要添加另一个元素，我们可以使用`push_back`方法来实现。使用向量解决修改后的问题看起来是这样的：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this code, we first declare the vector ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and then reserve space for 30 survey responses ![](httpatomoreillycomsourcenostarchimages1273191.png).
    The second step is not strictly necessary, but reserving a small amount of space
    that is in excess of the likely number of elements prevents the vector from resizing
    itself frequently as we add values to it. We read the first grade before the data
    entry loop ![](httpatomoreillycomsourcenostarchimages1273193.png), a technique
    we first used in the previous chapter that allows us to check each entered value
    before processing. In this case, we want to avoid adding the sentinel value, −1,
    to our vector. The survey results are added to the vector using the `push_back`
    method ![](httpatomoreillycomsourcenostarchimages1273195.png). After the data
    entry loop is completed, we retrieve the size of the vector using the `size` method
    ![](httpatomoreillycomsourcenostarchimages1273197.png). We could also have counted
    the number of elements ourselves in the data entry loop, but since the vector
    is already tracking its size, this avoids duplicate effort. The rest of the code
    is the same as the previous version with the array and the fixed number of responses,
    except that we have changed the names of the variables.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码中，我们首先声明了向量 ![http://atomoreilly.com/source/no_starch_images/1273182.png]
    并为30个调查响应预留了空间 ![http://atomoreilly.com/source/no_starch_images/1273191.png]。第二步不是严格必要的，但预留一小部分超出预期元素数量的空间可以防止向量在我们添加值时频繁调整大小。我们在数据输入循环之前读取了第一个成绩
    ![http://atomoreilly.com/source/no_starch_images/1273193.png]，这是一种我们在上一章中首次使用的技术，允许我们在处理之前检查每个输入的值。在这种情况下，我们想要避免将哨兵值-1添加到我们的向量中。调查结果使用`push_back`方法
    ![http://atomoreilly.com/source/no_starch_images/1273195.png] 添加到向量中。数据输入循环完成后，我们使用`size`方法
    ![http://atomoreilly.com/source/no_starch_images/1273197.png] 获取向量的大小。我们也可以在数据输入循环中自己计数元素数量，但由于向量已经跟踪其大小，这避免了重复的工作。其余的代码与使用数组和固定数量响应的上一版本相同，只是我们更改了变量的名称。
- en: 'All this discussion of vectors, though, overlooks an important point. If we
    are reading the data directly from the user, rather than being told that we are
    starting with an array or other data collection, we may not need an array for
    the survey data, only one for the histogram. Instead, we can process the survey
    values as we read them. We need a data structure only when we need to read in
    all the values before processing or need to process the values more than once.
    In this case, we don’t need to do either:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有关于向量的讨论都忽略了一个重要的观点。如果我们直接从用户那里读取数据，而不是被告知我们从一个数组或其他数据集合开始，我们可能不需要为调查数据使用数组，只需要为直方图使用一个。相反，我们可以在读取调查值时处理它们。我们只需要数据结构在我们需要读取所有值在处理之前或需要多次处理值时。在这种情况下，我们不需要做这两件事：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Although this code was easy to write, given the previous versions as a guide,
    it would have been even easier just to read the user data into an array and use
    the previous processing loop verbatim. The benefit to this process-as-you-go approach
    is efficiency. We avoid unnecessarily storing each of the survey responses, when
    we need to store just one response at a time. Our vector-based solution was *inefficient
    in space*: It took more space than required without providing a corresponding
    benefit. Furthermore, reading all of the grades into the vector required a loop
    on its own, separate from the loops to process all of the survey responses and
    find the highest value in the histogram. That means the vector version does more
    work than the version above. Therefore, the vector version is also *inefficient
    in time*: It does more work than required without providing a corresponding benefit.
    In some cases, different solutions offer trade-offs, and programmers must decide
    between space efficiency and time efficiency. In this case, however, the use of
    the vector makes the program inefficient all around.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个代码编写起来很简单，鉴于有之前的版本作为指导，只需将用户数据读入数组并直接使用之前的处理循环即可，这样做会更加简单。这种边做边走的过程的好处在于效率。我们避免了在只需要存储一个响应时，不必要地存储每个调查响应。我们的基于向量的解决方案在空间上效率低下：它占用的空间比所需的更多，而没有提供相应的利益。此外，将所有成绩读入向量需要单独的循环，这个循环与处理所有调查响应和找到直方图中的最大值的循环是分开的。这意味着向量版本做了比上面版本更多的工作。因此，向量版本在时间上也是低效的：它做了比所需更多的工作，而没有提供相应的利益。在某些情况下，不同的解决方案会提供权衡，程序员必须在空间效率和时间效率之间做出决定。然而，在这种情况下，使用向量使得程序在各方面都变得低效。
- en: 'In this book, we won’t spend a lot of time tracking down every inefficiency.
    Programmers must sometimes engage in *performance tuning*, which is the systematic
    analysis and improvement of a program’s efficiency in time and space. Performance
    tuning a program is a lot like performance tuning a race car: an exacting job,
    where small adjustments can have large effects and expert knowledge of how mechanisms
    work “under the hood” is required. Even if we don’t have the time, desire, or
    knowledge to fully tune a program’s performance, though, we should still avoid
    decisions that lead to gross inefficiencies. Using a vector or an array unnecessarily
    is not like an engine with a fuel-to-air mix that is too lean; it’s like driving
    a bus to the beach for vacation when you could have fit everything you were taking
    into a Honda Civic.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会花费大量时间去追踪每一个低效之处。程序员有时必须进行**性能调优**，这是对程序在时间和空间上的效率进行系统分析和改进的过程。对程序进行性能调优就像对赛车进行性能调优：这是一项精确的工作，其中微小的调整可以产生巨大的影响，并且需要了解“引擎盖下”机制如何工作的专业知识。即使我们没有时间、欲望或知识来完全调优程序的性能，我们仍然应该避免导致严重低效的决定。不必要地使用向量或数组，就像发动机燃料与空气混合比例过稀一样；这就像当你可以把所有东西都塞进一辆本田思域时，却开着公交车去海滩度假。
- en: If we’re sure we need to process the data multiple times, and we have a good
    handle on the maximum size of the data set, the last criterion for deciding whether
    to use an array is random access. Later on, we’ll discuss alternate data structures,
    such as lists, which like vectors can grow as needed but unlike vectors and arrays
    the elements can be accessed only sequentially. That is, if we want to access
    the 10th element in a list, we have to run through the first 9 items to get to
    it. By contrast, *random access* means that we can access any element in an array
    or vector at any time. So the last rule is that we should use an array when we
    need random access. If we need only sequential access, we might consider a different
    structure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定需要多次处理数据，并且我们对数据集的最大大小有很好的把握，那么决定是否使用数组的最后一个标准就是随机访问。稍后，我们将讨论其他数据结构，如列表，它们像向量一样可以按需增长，但与向量和数组不同，元素只能按顺序访问。也就是说，如果我们想访问列表中的第10个元素，我们必须运行前9个元素才能到达它。相比之下，**随机访问**意味着我们可以在任何时间访问数组或向量中的任何元素。所以最后一个规则是，当我们需要随机访问时应该使用数组。如果我们只需要顺序访问，我们可能需要考虑不同的结构。
- en: You might notice that many of the programs in this chapter fail on this last
    criterion; we access the data sequentially, not randomly, and yet we are using
    an array. This leads to the great, common-sense exception to all of these rules.
    If an array is small, then none of the previous objections holds much weight.
    What constitutes “small” may vary based on the platform or application. The point
    is, if your program needs a collection of as few as 1 or as many as 10 items,
    each of which requires 10 bytes, you have to consider whether the potential waste
    of 90 bytes that could result from allocating an array of the maximum required
    size is worth searching for a better solution. Use arrays wisely, but don’t let
    the perfect be the enemy of the good.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，本章中的许多程序都未能满足最后一个标准；我们按顺序访问数据，而不是随机访问，但我们却在使用数组。这导致了所有这些规则的一个伟大的、常识性的例外。如果数组很小，那么之前的所有反对意见都不会有很大的分量。“小”的定义可能因平台或应用程序而异。关键是，如果你的程序需要1个或10个物品的集合，每个物品需要10个字节，你必须考虑从分配最大所需大小的数组中可能产生的90个字节的潜在浪费是否值得寻找更好的解决方案。明智地使用数组，但不要让完美成为优秀的敌人。
- en: Exercises
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: As always, I urge you to try as many exercises as you can stand.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，我敦促你们尽可能多地尝试练习。
- en: Are you disappointed we didn’t do more with sorting? I’m here to help. To make
    sure you are comfortable with `qsort`, write code that uses the function to sort
    an array of our student `struct`. First have it sort by grade, and then try it
    again using the student ID.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你们对我们没有做更多关于排序的事情感到失望吗？我在这里就是为了帮助你们。为了确保你们对`qsort`函数感到舒适，编写使用该函数对学生的`struct`数组进行排序的代码。首先让它按成绩排序，然后再次尝试使用学生ID进行排序。
- en: Rewrite the code that finds the agent with the best monthly sales average so
    that it finds the agent with the highest *median* sales. As stated earlier, the
    median of a set of values is the “one in the middle,” such that half of the other
    values are higher and half of the other values are lower. If there is an even
    number of values, the median is the simple average of the two values in the middle.
    For example, in the set 10, 6, 2, 14, 7, 9, the values in the middle are 7 and
    9\. The average of 7 and 9 is 8, so 8 is the median.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编写查找具有最佳月销售平均值的代理的代码，使其查找具有最高**中位数**销售的代理。如前所述，一组值的中位数是“中间的值”，即其他一半的值更高，另一半的值更低。如果有偶数个值，中位数是中间两个值的简单平均值。例如，在集合10,
    6, 2, 14, 7, 9中，中间的值是7和9。7和9的平均值是8，所以8是中位数。
- en: Write a `bool` function that is passed an array and the number of elements in
    that array and determines whether the data in the array is sorted. This should
    require only one pass!
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`bool`函数，该函数接受一个数组和该数组中的元素数量，并确定数组中的数据是否已排序。这应该只需要一次遍历！
- en: Here’s a variation on the array of `const` values. Write a program for creating
    a substitution cipher problem. In a substitution cipher problem, all messages
    are made of uppercase letters and punctuation. The original message is called
    the plaintext, and you create the ciphertext by substituting each letter with
    another letter (for example, each C could become an X). For this problem, hard-code
    a `const` array of 26 `char` elements for the cipher, and have your program read
    a plaintext message and output the equivalent ciphertext.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是`const`值数组的另一种变体。编写一个程序来创建一个替换密码问题。在替换密码问题中，所有消息都由大写字母和标点符号组成。原始消息称为明文，你通过将每个字母替换为另一个字母（例如，每个C可以变成X）来创建密文。对于这个问题，硬编码一个包含26个`char`元素的`const`数组作为密码，并让程序读取明文消息并输出相应的密文。
- en: Have the previous program convert the ciphertext back to the plaintext to verify
    the encoding and decoding.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让前面的程序将密文转换回明文以验证编码和解码。
- en: To make the ciphertext problem even more challenging, have your program randomly
    generate the cipher array instead of a hard-coded `const` array. Effectively,
    this means placing a random character in each element of the array, but remember
    that you can’t substitute a letter for itself. So the first element can’t be A,
    and you can’t use the same letter for two substitutions—that is, if the first
    element is S, no other element can be S.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使密文问题更具挑战性，让程序随机生成密码数组而不是硬编码的`const`数组。实际上，这意味着在每个数组元素中放置一个随机字符，但请记住，你不能用字母替换自己。所以第一个元素不能是A，并且你不能为两次替换使用相同的字母——也就是说，如果第一个元素是S，则其他元素不能是S。
- en: Write a program that is given an array of integers and determines the *mode*,
    which is the number that appears most frequently in the array.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序接受一个整数数组，并确定其**众数**，即数组中出现频率最高的数字。
- en: Write a program that processes an array of `student` objects and determines
    the grade quartiles—that is, the grade one would need to score as well as or better
    than 25% of the students, 50% of the students, and 75% of the students.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序处理`student`对象数组，并确定成绩四分位数——也就是说，一个人需要达到或超过25%的学生、50%的学生和75%的学生的成绩。
- en: 'Consider this modification of the `sales` array: Because salespeople come and
    go throughout the year, we are now marking months prior to a sales agent’s hiring,
    or after a sales agent’s last month, with a −1\. Rewrite your highest sales average,
    or highest sales median, code to compensate.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑对`sales`数组的这种修改：由于销售人员一年中会有变动，我们现在用-1标记销售代理招聘前的月份，或销售代理最后一个月之后的月份。重新编写你的最高销售平均数或最高销售中位数代码以进行补偿。
