- en: 'Part III-7. TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND PROTOCOLS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 74](ch74.html "Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW
    AND CONCEPTS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 75](ch75.html "Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS
    AND MESSAGE PROCESSING: RFC 822 AND MIME")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 77](ch77.html "Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL:
    THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 78](ch78.html "Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL
    PROTOCOLS AND METHODS")'
  prefs: []
  type: TYPE_NORMAL
- en: It is common for human beings to create systems that are reminiscent of ones
    with which they are already familiar. We are all accustomed to using the regular
    mail system to send letters and other documents from our location to recipients
    anywhere that the postal system serves. Naturally, one of the first applications
    of internetworks was to create an electronic version of this conventional mail
    system that would allow messages to be sent in a similar manner, but more quickly
    and easily. Over the course of many years, an *electronic mail system* for TCP/IP
    was created and refined. It is now the most widely used means of electronic messaging
    in the world.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, I describe TCP/IP electronic mail (email) in detail, in five chapters
    that discuss electronic mail concepts and the various components and protocols
    that comprise the overall TCP/IP email system. The first chapter provides an overview
    of TCP/IP email and discusses the way that it is used and the different protocols
    and methods that make up the system. The second chapter discusses how email messages
    are addressed, and the third chapter covers standard and special formats for email
    messages. The fourth and fifth chapters describe the TCP/IP protocols that implement
    email functionality. These include the Simple Mail Transfer Protocol (SMTP), which
    is responsible for the delivery of email, and several protocols and methods used
    for mailbox access and mail retrieval, including the Post Office Protocol version
    3 (POP3) and the Internet Message Access Protocol (IMAP).
  prefs: []
  type: TYPE_NORMAL
- en: This discussion focuses primarily on the mechanisms used for email composition,
    delivery, and access in modern internetworks. In the email overview in [Chapter 74](ch74.html
    "Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS"), I mention
    some techniques used in the past for TCP/IP email, but only briefly for historical
    completeness and to contrast these methods to the ones presently used.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Electronic mail (email) in the TCP/IP protocol suite is not implemented as just
    a single protocol or technology. Rather, it is a complete system that contains
    a number of related components that work together. These include standards defining
    methods for addressing and message formatting and a number of protocols that play
    different functions in implementing email messaging. Before proceeding to examine
    each of these pieces, it makes sense to start with an overview of the system as
    a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide an introductory look at TCP/IP email to help you
    understand the system, how it works, and how different components fit into it.
    I begin with an overview and history of email and its implementation in TCP/IP.
    I provide a general overview of the steps involved in the email communication
    process, concluding with a more specific discussion of the communication model
    used in TCP/IP and the roles played by various TCP/IP devices and protocols in
    the sending and receiving of email.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Electronic Mail System Overview and History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The need to communicate is as old as humanity itself. Thousands of years ago,
    communication was of necessity almost exclusively local. Messages were primarily
    oral, and even when in writing, they were rarely delivered a great distance. Most
    people never traveled far from their homes and rarely communicated with those
    distant from themselves. But even in ancient times, leaders used messengers to
    send short pieces of critical information from place to place. It was slow and
    unreliable, but some messages were important enough that an effort to communicate
    often had to be made despite the difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: Advances in transportation led to advances in communication capability, eventually
    resulting in the creation of physical mail systems. Today, these systems have
    evolved to the point at which anyone in the developed world can send a letter
    or package to just about anyone else. Reliability has vastly improved, despite
    all the jokes people make about the postal service. Speed is also much better
    than it used to be, with messages now taking days to reach their destination instead
    of weeks or months.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting even days for a message to get from one place to another is pretty slow
    by the standards of our modern world. For this reason, one of the most natural
    applications of networks was to use them as a replacement for the physical transportation
    of messages from one place to another. Transforming mail from a physical process
    to an electronic one yields enormous benefits, including greatly increased communication
    speed, the ability to send one message to multiple recipients instantly, and the
    ability to get nearly instantaneous feedback upon receipt of a message.
  prefs: []
  type: TYPE_NORMAL
- en: The Early Days of Email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind email is not only as old as computer networks, but it actually
    predates internetworking. The first email systems were implemented on traditional
    mainframe computers. These were single large computers accessed by many users
    simultaneously through connected terminals. An email system on a mainframe consisted
    of a set of software running on the mainframe that implemented the entire email
    system. Each user simply had a mailbox that resided on this machine, and mail
    was delivered by moving messages from one mailbox to the next. Users sent and
    received mail through a user-interface program.
  prefs: []
  type: TYPE_NORMAL
- en: Such an early email system was useful for local communication but not for sending
    messages to a person in another organization. Mainframe email is somewhat analogous
    to local mail being sent by one resident of a town to another. There is no way
    to send mail to a person in a distant town without the infrastructure in place
    for delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The power of internetworking is what really enables email to become a universal
    method of communication. Internetworks link together systems the way the postal
    service's fleet of airplanes and vehicles link together post offices. Mail is
    sent from user to user over the underlying technology of the internetwork. Since
    TCP/IP is the most commonly used internetworking protocol suite, and the modern
    Internet uses TCP/IP to tie together systems across the globe, it is the vehicle
    used for sending email.
  prefs: []
  type: TYPE_NORMAL
- en: History of TCP/IP Email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with some other file and message transfer protocols, email on TCP/IP actually
    goes back to before TCP/IP and the Internet formally existed. The first protocols
    for email were developed during the days of the ARPAnet. Prior to the creation
    of email, several Internet RFCs, such as RFC 95 (yes 95, two digits—we are going
    back a long way here) and RFC 155, describe physical mailing lists that were used
    for distributing documents in the early 1970s. It was this need to send documents
    that likely made TCP/IP pioneers realize the usefulness of an electronic messaging
    system, using the technology they were themselves creating.
  prefs: []
  type: TYPE_NORMAL
- en: The first Internet document describing email was probably RFC 196, published
    in 1971\. It describes the *Mail Box Protocol*, a very rudimentary message transfer
    method using the predecessors of TCP/IP. This protocol was designed for the specific
    purpose of sending documents for remote printing. In those days, it was not as
    common for people to use computers at interactive terminals as it is today, but
    the idea of electronically mailing documents was the same. The Mail Box Protocol
    was revised several times in 1971.
  prefs: []
  type: TYPE_NORMAL
- en: In the mid-1970s, developers began working on a more comprehensive method of
    implementing email on the fledgling Internet. The technique was originally described
    using a number of existing application layer transfer protocols, including the
    File Transfer Protocol (FTP). In 1980 the "Mail Transfer Protocol (MTP)" was published
    in RFC 772\. This was the first precursor of today's TCP/IP email and was defined
    using principles from the Telnet Protocol as well as FTP.
  prefs: []
  type: TYPE_NORMAL
- en: During the time that email protocols were being developed in the 1970s, mail
    was being exchanged between host systems using a variety of techniques. One of
    the most common used was the *Unix-to-Unix Copy Protocol (UUCP)*, which was designed
    to allow files to be transferred between UNIX systems, moving them from one connected
    system to the next. UUCP was also used for communicating Usenet newsgroup articles
    and other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1981, the modern TCP/IP email era came into being with the definition of
    the *Simple Mail Transfer Protocol (SMTP)*. SMTP described in detail how mail
    could be moved directly or indirectly from one TCP/IP host to another without
    the need to use FTP or another file transfer method. (SMTP has its own detailed
    history and discussion in [Chapter 77](ch77.html "Chapter 77. TCP/IP ELECTRONIC
    MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)").) Other complementary
    specifications were created at around the same time, which formalized or defined
    other components and elements of the system. We''ll explore these pieces of the
    puzzle throughout the rest of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the TCP/IP Email System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important general concepts in the modern email system is that
    a distinction is made between protocols that deliver email between SMTP hosts
    on the internetwork and those that let users access received mail on their local
    hosts. To continue the postal mail analogy, different protocols are used for sending
    mail between post offices and for home delivery. As you'll see, this was done
    intentionally to make it possible to send mail to users, even if they are not
    connected to the Internet when the mail is sent. This decoupling is critical,
    as it enables delayed communication, where mail can be sent when the sender wants
    to transmit it and received when the recipient wants to read it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the most important TCP/IP applications is the internetworking
    equivalent of the real-world postal delivery system, commonly called *electronic
    mail* or *email*. The history of email goes back to the very earliest days of
    TCP/IP''s development. Today, it is used by millions of people every day to send
    both simple and complex messages around the world. TCP/IP email is not a single
    application, but rather a complete system that includes several protocols, software
    elements, and components.'
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, the basic components defined in the early 1980s have not changed
    substantially, but how they are used has evolved and improved. Early email delivery
    involved the use of route specifications by one SMTP host to dictate how mail
    was to be delivered through intermediate systems; today, the Domain Name System
    (DNS) makes much of that obsolete, facilitating nearly immediate direct mail delivery
    in most cases. Early email supported only simple text, but we can now send graphical
    images, programs, and other file attachments in email. Modern high-speed Internet
    connections and updated access protocols allow email to be the realization of
    the ultimate goal of nearly instantaneous communication, even across continents.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Email Communication Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've just seen that TCP/IP email is implemented as a complete system, with
    a number of elements that perform different portions of the complete job of email
    communication. These included a standard message format, a specific syntax for
    recipient addressing, and protocols to both deliver mail and allow access to mailboxes
    from intermittently connected TCP/IP clients.
  prefs: []
  type: TYPE_NORMAL
- en: To help set the groundwork for examining these components, here, I provide an
    overview of the complete end-to-end process of email communication, so you can
    see how everything works. I will show the basic steps in simplified form and continue
    the analogy to the regular mail system for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modern TCP/IP email communication process consists of five basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mail Composition** A user begins the email journey by creating an email message.
    The message contains two sections: the *body* and the *header*. The body of the
    message is the actual information to be communicated. The header contains data
    that describes the message and controls how it is delivered and processed. The
    message must be created so that it matches the standard message format for the
    email system so that it can be processed (see [Chapter 76](ch76.html "Chapter 76. TCP/IP
    ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME")). It
    must also specify the email addresses of the intended recipients for the message
    (see [Chapter 75](ch75.html "Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND
    ADDRESSING")). By way of analogy to "snail mail," the body of the message is like
    a letter, and the header is like the addressed and stamped envelope into which
    the letter is placed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mail Submission** Email is different from many other internetworking applications
    in that the sender and receiver of a message do not necessarily need to be connected
    to the network simultaneously, nor even continuously, to use it. The system is
    designed so that after composing the message, the user decides when to submit
    it to the email system so it can be delivered. This is done using SMTP (see [Chapter 77](ch77.html
    "Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER
    PROTOCOL (SMTP)")). This is analogous to dropping off an envelope at the post
    office or to a postal worker picking up an envelope from a mailbox and carrying
    it to the local post office to insert into the mail delivery stream.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mail Delivery** The email message is accepted by the sender''s local SMTP
    system for delivery through the mail system to the destination user. Today, this
    is accomplished by performing a DNS lookup of the intended recipient''s host system
    and establishing an SMTP connection to that system. SMTP also supports the ability
    to specify a sequence of SMTP servers through which a message must be passed to
    reach a destination. Eventually, the message arrives at the recipient''s local
    SMTP system. This is like the transportation of the envelope through the postal
    system''s internal "internetwork" of trucks, airplanes, and other equipment to
    the intended recipient''s local post office.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mail Receipt and Processing** The local SMTP server accepts the email message
    and processes it. It places the mail into the intended recipient''s mailbox, where
    it waits for the user to retrieve it. In our physical analogy, this is the step
    at which the recipient''s local post office sorts mail coming in from the postal
    delivery system and puts the mail into individual post office boxes or bins for
    delivery.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mail Access and Retrieval** The intended recipient periodically checks with
    its local SMTP server to determine whether any mail has arrived. If so, the recipient
    retrieves the mail, opens it, and reads its content. This is done using a special
    mail access protocol or method (see [Chapter 78](ch78.html "Chapter 78. TCP/IP
    ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS")). To save time, the
    access protocol and client email software may allow the user to scan the headers
    of received mail (such as the subject and sender''s identity) to decide which
    mail messages to download. This is analogous to the step where mail is physically
    picked up at the post office or delivered to the home.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** TCP/IP email communication normally involves a sequence of
    five steps, each of which is analogous to a portion of the journey taken by a
    regular letter through the postal system. First, email is *composed* (written);
    second, it is *submitted* to the email system; third, it is *delivered* to recipient''s
    server; fourth, it is *received and processed*; and fifth, it is *accessed and
    retrieved* by its recipient.'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, not all of these steps are performed. If a user is sending email
    from a device that is already an SMTP server, then step 2 can be omitted. If the
    recipient is logged in to a device that is also an SMTP server, step 5 will be
    skipped, as the user can read mail directly on the server. Thus, in the simplest
    case, all that occurs is composition, delivery, and receipt; this occurs when
    one user of a dial-up UNIX host sends mail to another. In most cases today, however,
    all five steps occur.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Email Message Communication Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of the email system as a whole is to accomplish the transmission
    of messages from a user of a TCP/IP internetwork to one or more recipients. To
    accomplish this, a special method of communication is required that makes the
    email system quite different from that used by most other protocols. To understand
    what I mean by this, just consider the difference in communication between sending
    a letter and making a phone call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most TCP/IP protocols are analogous to making a phone call in this respect:
    The sender and the receiver must both be on the network at the same time. You
    can''t call someone and talk to him if he isn''t around to answer the phone. (I''m
    ignoring answering machines and voice mail of course!) Most TCP/IP protocols are
    like this. To send a file using FTP, for example, you must make a direct connection
    from the sender''s machine to the recipient''s machine. If the recipient''s machine
    is not on the network at the exact time that the sender''s machine is, no communication
    is possible. For email, immediate communication of this sort is simply unacceptable.'
  prefs: []
  type: TYPE_NORMAL
- en: As with real-world snail mail, Joe wants to be able to put a message into the
    system at a time that is convenient for him, and Ellen wants to be able to receive
    Joe's mail at a time that works for her. For this to work, email must use a "send
    and forget" model, just like real mail, where Joe drops the "envelope" into the
    email system and it eventually arrives at its destination.
  prefs: []
  type: TYPE_NORMAL
- en: This *decoupling* of the sender and receiver is critical to the design of the
    email system. This is especially true because many of the users of Internet email
    are not on the Internet all the time. Just as you wouldn't want real mail to be
    rejected if it arrived when you are not home, you wouldn't want email to not be
    delivered if you are not on the Internet when it arrives. Similarly, you may not
    want to be connected to the Internet for the entire time it takes to write a message,
    especially if you have access to the Internet for only a limited amount of time
    each day.
  prefs: []
  type: TYPE_NORMAL
- en: Also critical to the entire email system is that idea that communication is
    between specific *users*, not between particular machines. This makes email inherently
    different from many other types of communication on TCP/IP internetworks. You'll
    see more of why this is important when we look at email addressing in [Chapter 75](ch75.html
    "Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING").
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the type of communication needed for email, the entire system is designed
    to facilitate the *delayed delivery* of email messages from one user to another.
    To see how this works, let''s look again at the example communication we discussed
    earlier—but this time, consider the roles of the different devices in the exchange
    (as shown in [Figure 74-1](ch74s03.html#email_communication_model_this_diagram_s
    "Figure 74-1. Email communication model This diagram shows the four devices that
    are involved in a typical email communication between two users. Each device consists
    of a number of different elements, which communicate as indicated by the black
    arrows. Note the inherent asymmetry, because the method used to send an email
    from a user is not the same as that used to retrieve it from the server. The large,
    shaded arrows show a typical transaction: the sender composes mail and it goes
    to her local email spool. It is sent to the sender''s local SMTP server using
    SMTP, and then to the recipient''s SMTP server, where it goes into that user''s
    inbox. It is then retrieved, usually using a protocol such as POP or IMAP.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sender''s Client Host** The sender composes an email message, generally using
    a mail client program on her local machine. The mail, once composed, is not immediately
    sent out over the Internet; it is held in a buffer area called a *spool*. This
    allows the user to be "unattached" for the entire time that a number of outgoing
    messages are created. When the user is done, all of the messages can be sent at
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sender''s Local SMTP Server** When the user''s mail is ready to be sent,
    she connects to the internetwork. The messages are then communicated to the user''s
    designated local SMTP server, normally run by the user''s Internet service provider
    (ISP). The mail is sent from the client machine to the local SMTP server using
    SMTP. (It is possible for the sender to be working directly on a device with a
    local SMTP server, in which case sending is simplified.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipient''s Local SMTP Server** The sender''s SMTP server sends the email
    using SMTP to the recipient''s local SMTP server over the internetwork. There,
    the email is placed into the recipient''s incoming mailbox (or inbox). This is
    comparable to the outgoing spool that existed on the sender''s client machine.
    It allows the recipient to accumulate mail from many sources over a period of
    time and retrieve them when it is convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipient''s Client Host** In certain cases, the recipient may access her
    mailbox directly on the local SMTP server. More often, however, a mail access
    and retrieval protocol, such as Post Office Protocol (POP3) or Internet Message
    Access Protocol (IMAP), is used to read the mail from the SMTP server and display
    it on the recipient''s local machine. There, it is displayed using an email client
    program, similar to the one the sender used to compose the message in the first
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Email communication model This diagram shows the four devices that are involved
    in a typical email communication between two users. Each device consists of a
    number of different elements, which communicate as indicated by the black arrows.
    Note the inherent asymmetry, because the method used to send an email from a user
    is not the same as that used to retrieve it from the server. The large, shaded
    arrows show a typical transaction: the sender composes mail and it goes to her
    local email spool. It is sent to the sender''s local SMTP server using SMTP, and
    then to the recipient''s SMTP server, where it goes into that user''s inbox. It
    is then retrieved, usually using a protocol such as POP or IMAP.](httpatomoreillycomsourcenostarchimages288287.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 74-1. Email communication model This diagram shows the four devices
    that are involved in a typical email communication between two users. Each device
    consists of a number of different elements, which communicate as indicated by
    the black arrows. Note the inherent asymmetry, because the method used to send
    an email from a user is not the same as that used to retrieve it from the server.
    The large, shaded arrows show a typical transaction: the sender composes mail
    and it goes to her local email spool. It is sent to the sender''s local SMTP server
    using SMTP, and then to the recipient''s SMTP server, where it goes into that
    user''s inbox. It is then retrieved, usually using a protocol such as POP or IMAP.'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Roles in Email Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that SMTP is used for most of this communication process.
    In fact, if the recipient uses a machine that runs SMTP software, which is common
    for those using dial-up UNIX shell Internet access, the process of sending email
    uses SMTP exclusively. SMTP servers must, however, always be available on the
    Internet and ready to accept mail. Most people access the Internet using devices
    that aren't always online or that don't run SMTP software. That is why the last
    step, email access and retrieval, is usually required.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might have been possible to define the email system so that this last step
    of communication was carried out using SMTP as well, which would mean the entire
    system used the same protocol. However, SMTP was tailored for the specific purpose
    of transporting and delivering email, not for remote mailbox access. It made more
    sense to leave the function of mailbox access to dedicated, separate protocols.
    This not only allows these protocols to be tailored to the needs of email recipients,
    but it also provides flexibility by giving users more than one option for how
    email is retrieved. I discuss email access protocols and methods in [Chapter 78](ch78.html
    "Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS"),
    highlighting the two most common protocols: POP and IMAP.'
  prefs: []
  type: TYPE_NORMAL
- en: The three protocols discussed here—SMTP, POP3, and IMAP—get lead billing on
    the TCP/IP email stage, but they rely on two other elements to play supporting
    roles. The first is a method of addressing email messages to ensure that they
    arrive at their destinations. The second is the set of message formats used to
    encode messages and control how they are delivered and used. These elements don't
    usually get as much attention as they deserve, but they do here, as I have devoted
    the next two chapters to them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the critical requirements of an email system is that
    the sender and receiver of a message are not required to be on the system at the
    time mail is sent. TCP/IP therefore uses a communication model with several devices
    that allow the sender and recipient to be *decoupled*. The sender''s client device
    spools mail and moves it to the sender''s local SMTP server when it is ready for
    transmission; the email is then transmitted to the receiver''s SMTP server using
    SMTP. The email can remain on the recipient''s server for an indefinite period
    of time. When the recipient is ready to read it, he retrieves it using one or
    more of a set of mail access protocols and methods, the two most popular of which
    are POP and IMAP.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The entire concept of electronic mail (email) is based on an analogy: sending
    electronic messages is like sending paper messages. The analogy works well, because
    email was indeed intended to be like regular mail, only with the advantages of
    the technological era: speed and flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the many similarities between email and regular mail is the need for
    *addressing*. For a message to be delivered, it is necessary for the sender to
    specify the recipient and provide a reasonable amount of information to indicate
    how and where the recipient can be reached. In TCP/IP email, a standard *electronic
    mail address* format is used for this, and support is also provided for alternative
    addressing schemes that may be used in special cases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe how email messages are addressed. I begin with a
    discussion of standard email addressing in TCP/IP and how those addresses are
    used to determine where email should be sent. I then provide a brief discussion
    of historical and special email addresses that you may encounter from time to
    time. I also discuss the use of email address books (aliases) and how multiple
    recipients may be addressed, and I provide an overview of electronic mailing lists,
    one of the earliest ways in which electronic group communication was implemented.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Email Addressing and Address Resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All communication on an internetwork requires some way of specifying the identity
    of the intended recipient of the communication. Most application protocols, such
    as the File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP), use
    conventional TCP/IP constructs—IP addresses and port numbers—to specify the destination
    of information to be sent. The IP address normally identifies a particular host
    computer, and the port number indicates a software process or application running
    on that computer.
  prefs: []
  type: TYPE_NORMAL
- en: Email, however, uses a model for communication that differs from most applications.
    As you saw in the discussion of the email model in the previous chapter, one element
    that sets email apart from many other systems is that communication is *user-oriented*.
    Email is not sent from one machine to another, as a file is transferred using
    FTP. Instead, it is sent from one user to another. This is critical to the operation
    of the entire system. For one thing, it allows someone to retrieve email that
    has been sent from any number of different client computers. This allows the recipient
    to receive email even when traveling, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since email messaging is user-based, the addressing scheme must also be user-based.
    We cannot use conventional IP addresses and ports, so we need a distinct system
    that specifies two primary pieces of information: who the user is and where the
    user is located. These are, of course, analogous to a name and address on a regular
    mail envelope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of a user name is relatively straightforward, but identifying the
    location of the user is not. In regular mail, an address refers to a physical
    place. It would have been possible to define email addresses in the same way;
    that is, to have an email address refer to the user''s client machine. However,
    recall the other important characteristic of email delivery: it is indirect and
    based on the concept of a user''s local Simple Mail Transfer Protocol (SMTP) server
    holding received messages until they can be retrieved. The machine that the user
    employs to access his email may not even routinely be connected to the Internet,
    and it may thus not be easy to identify. And we also want a user to be able to
    access email from multiple machines.'
  prefs: []
  type: TYPE_NORMAL
- en: For all of these reasons, we want addresses to identify not the user's specific
    location at any particular time, but the place where the user's permanent mailbox
    lives—on the user's SMTP server, which is permanently connected to the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Standard DNS-Based Email Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In TCP/IP, the system used for identifying servers (and other machines) is the
    *Domain Name System (DNS)*. DNS is a big system and is described in [Part III-1](pt12.html
    "Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION") of
    this book, which you should read if you want to learn more. For now, it is important
    that you realize that in DNS, all devices on the Internet are arranged into a
    device-naming hierarchy, and any device can be identified using a *domain name*
    consisting of a series of text labels separated by dots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete TCP/IP address consists of two components: a user name specification
    and a domain name specification. The two are connected together using the at symbol
    (@) to form the TCP/IP email address syntax that most of us are familiar with
    today: *<username>*@*<domainname>*.'
  prefs: []
  type: TYPE_NORMAL
- en: The format of *<domainname>* follows the syntax rules of DNS (see [Chapter 53](ch53.html
    "Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY")), which specify that
    it can contain only numbers and digits for each label, and periods to separate
    the labels. The format of *<username>* is slightly less restrictive, allowing
    special characters such as the underscore (_). Other special characters and spaces
    are also allowed in the *<username>* if they are surrounded by quotation marks
    (or otherwise marked as being part the name, such as through the use of an escape
    character). Domain names are case-insensitive; user names may be case-sensitive,
    depending on the system.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a valid email address is [cmk@athena.mit.edu](mailto:cmk@athena.mit.edu)
    (an address I used when I was in school many years ago). Here, *cmk* is my user
    name (my initials); *athena.mit.edu* is the name of the host where I was receiving
    mail; and *athena* is a particular system at Massachusetts Institute of Technology
    *(mit)*, an educational institution that uses the *.edu* top-level domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to specify an email address using an Internet-standard
    Uniform Resource Locator (URL). This allows a link to be embedded in a hypertext
    (Web) document; when clicked, it invokes an email client to send mail to a user.
    Email URLs are created by preceding the address by the special URL scheme string
    *mailto:*, like this: mailto:[cmk@athena.mit.edu](mailto:cmk@athena.mit.edu).'
  prefs: []
  type: TYPE_NORMAL
- en: Special Requirements of Email Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having an email address refer to a user''s local SMTP server provides a great
    deal of flexibility compared to having the address mention a specific client computer.
    But this doesn''t provide enough flexibility to handle the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: An organization may want to use generic addresses that do not specify the name
    of the SMTP server to handle email, to make it easier for senders or clients to
    remember an email address. For example, if someone knew my real name and that
    I was at MIT, it would be easier for him to remember my email address as [cmk@mit.edu](mailto:cmk@mit.edu)
    than to remember [cmk@athena.mit.edu](mailto:cmk@athena.mit.edu).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An administrator may change which machines handle mail over a period of time.
    This would mean all the users' email addresses would have to be changed, too—and
    most of us know what a pain that is. For example, if I moved from the athena machine
    to the jabberwocky machine, my old address would need to be changed to [cmk@jabberwocky.mit.edu](mailto:cmk@jabberwocky.mit.edu).
    But if the address were just [cmk@mit.edu](mailto:cmk@mit.edu), a server change
    would not affect the address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In larger organizations, it might be desirable to have multiple servers share
    the load of handling incoming email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To address all of these requirements, the DNS system includes a feature that
    was specifically designed to support email addressing. A special *mail exchange
    (MX)* record can be set up that specifies which SMTP server should be used for
    mail arriving at a particular domain name. If properly configured, this allows
    considerable flexibility to handle the cases described above, and more. For more
    details, please see the description of the MX record and DNS electronic mail support
    in [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Some form of addressing is required for all network communication;
    since email is *user-oriented*, email addresses are also based on users. In modern
    TCP/IP email, standard addresses consist of a *user name*, which specifies the
    recipient, and a *domain name*, which specifies the DNS domain where the user
    is located. A special DNS *mail exchange (MX)* record is set up for each domain
    that accepts email, so a sending SMTP server can determine what SMTP server it
    should use to send mail to a particular recipient.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, that I am the owner of the pcguide.com domain name. Email
    can be sent to me at pcguide.com, but the mail is not actually stored on any server
    by that name. Instead, it is redirected to the real server where my inbox is located.
    This allows me to handle all incoming mail to pcguide.com, regardless of where
    my mailbox is actually located.
  prefs: []
  type: TYPE_NORMAL
- en: DNS is also significant in that its MX resource records eliminate the need to
    relay email from one SMTP server to the next to deliver it. In modern TCP/IP,
    it is possible to send email directly from the sender's SMTP server to the recipient's
    server, making communication faster and more efficient. This is also discussed
    in [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS").
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Historical and Special Email Addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP/IP email has been so successful that it is arguably the most important worldwide
    standard for electronic messaging. The widespread acceptance of email is tied
    inextricably to that of TCP/IP and the Internet as a whole. Since most organizations
    want to be part of the Internet, they connect to it and use its technologies,
    including DNS, which is the basis for TCP/IP email addresses. In turn, the use
    of simple DNS-style email addresses (*user*@*domain*) encourages further use of
    email because people find it conceptually easy to decide how to send messages.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP is not, however, the only email system around. Over the years, several
    other networks have developed email systems. Due to the fact that the Internet
    is the largest internetwork in the world, TCP/IP email has often been used as
    a clearinghouse of sorts to link together some of these different email mechanisms.
    This is called *gatewaying*, and it allows someone using a non-SMTP email system
    to interact with someone using TCP/IP, and vice versa. Gatewaying is complex,
    in part because email systems use different ways of addressing mail. Let's take
    a look at a couple of these systems and how they interact with TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: FidoNet Addressing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the earliest independent email systems was the *FidoNet*, which has
    been around for a long time and is still in use today. FidoNet is a worldwide
    network connected using modems and proprietary protocols; it is, in essence, a
    "competitor" to the global TCP/IP Internet. I put *competitor* in quotes because
    FidoNet and the TCP/IP Internet are not really comparable in terms of number of
    users and the kinds of applications they support, but they are similar in overall
    objectives: worldwide electronic communication.'
  prefs: []
  type: TYPE_NORMAL
- en: FidoNet users are identified using four numbers that specify the FidoNet *zone,
    net, node*, and *point (connection point)*. These addressing elements are used
    for sending mail on this system, which again is completely distinct from TCP/IP.
    However, to allow communication between TCP/IP and FidoNet, the FidoNet administrators
    have set up a gateway system that allows mail to be sent to FidoNet using TCP/IP-style
    domain names. This style of mapping was also used by other systems with proprietary
    mail address formats to allow them to interface with the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a user was on machine 4, node 205, net 141, zone 1 (North America),
    the FidoNet address would be 1:141/205:4\. The equivalent domain name would be
    p4.f205.n141.z1.fidonet.org and could be used for TCP/IP-style *user*@*domain*
    addressing.
  prefs: []
  type: TYPE_NORMAL
- en: UUCP-Style Addressing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An older address style commonly associated with email was the UUCP-style address.
    The *Unix-to-Unix Copy Protocol (UUCP)* was commonly used years ago to route mail
    before SMTP became widely deployed (again, it is still used, just not as much
    as before). The addresses in this system are specified as a path of hosts separated
    by exclamation marks (!). The path dictates the route that mail takes to get to
    a particular user, passing through a series of intermediate machines running UUCP.
    For example, if mail to joe at the host joesplace had to go through three hosts—host1,
    host2, and host3, the address would be host1!host2!host3!joesplace!joe. Since
    the slang term for an exclamation mark is *bang*, this came to be called *bang
    path* notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of UUCP-style notation was sometimes mixed with TCP/IP-style domain
    name address notation when DNS came into use. So you might have seen something
    like host1!user@domain. There was some confusion in how exactly to interpret such
    an address: Does it mean to send mail first to host1 and then to user@domain?
    Or does it mean to first send it to the domain, which then goes to user at host1?
    There was no universal answer to this. The problem was mostly resolved both by
    the decrease in use of UUCP and the move on the part of UUCP systems to TCP/IP-style
    domain name addressing.'
  prefs: []
  type: TYPE_NORMAL
- en: Addressing for Gatewaying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may encounter email addresses that appear as if multiple TCP/IP addresses
    have been nested using unusual punctuation. For example, you may see something
    like this: user%domain1.com@subdomain.domain2.edu. This is a way of addressing
    sometimes seen when email gateways are used; it will cause the mail to be sent
    to user%domain1.com at subdomain.domain2.edu. The address then is interpreted
    as user@domain1.com. However, again, not all systems are guaranteed to interpret
    this the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Email gatewaying is not a simple matter in general, and as you can see, one
    reason is the use of different email address styles and the problems of consistency
    in how complex hybrid addresses are interpreted. However, as the Internet expands
    and TCP/IP becomes more widespread, it is becoming less and less common to see
    these older special address formats in use. They are becoming more and more a
    historical curiosity (unless you happen to use one of them).
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Email Aliases and Address Books
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Email is analogous to regular mail but superior to it due to two main advantages
    of digital and electronic communication. One advantage is *speed*, which is why
    modern Internet users have come up with the slang term *snail mail* to refer to
    the regular postal service. But the other advantage, *flexibility*, is also essential.
    Email allows you to send messages easily in ways that would be cumbersome with
    regular mail. And one of the ways this flexibility can be seen is in addressing.
  prefs: []
  type: TYPE_NORMAL
- en: The first way that email addressing is flexible is that most email clients support
    advanced features that allow users to specify the identity of recipients in convenient
    ways. While TCP/IP addressing is fairly straightforward, remembering the addresses
    of everyone you know is difficult. In the real world, we use address books to
    help us remember addresses. With email, we can do the same by allowing email software
    to associate a name with an email address.
  prefs: []
  type: TYPE_NORMAL
- en: This is usually done in one of two ways. In old-fashioned, text-based email
    such as that used on many UNIX systems, name and address association is performed
    using *aliases*. These are short forms for email addresses that save typing. For
    example, I often send email to my wife, Robyn, but I'm too lazy to type in her
    complete address all the time. So I have defined an alias for her in my email
    program called simply *r*. I enter the mail command and specify the alias *r*
    as the intended recipient, and it expands her email address for me.
  prefs: []
  type: TYPE_NORMAL
- en: In modern graphical email systems, aliases aren't used. Instead, an *electronic
    address book* is usually implemented, which is the equivalent of the paper address
    book. The difference is that there is no manual copying; you just choose the name
    from the list using your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Recipient Addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another advantage of email addressing is that it allows the easy specification
    of multiple recipients. With paper mail, sending a message to ten people means
    you need ten copies of the message, ten envelopes, and ten stamps. With email,
    you just list the recipient addresses separated by a comma in the recipient list:
    <user1@domain1>,<user2@domain2>,<user3@domain3>. A separate copy is mailed to
    each recipient. Of course, aliases and/or address books can be used to specify
    each recipient here as well, making this even simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: Since email makes it so easy for one person to send information to a set of
    others, so-called *one-to-many* messaging, it was also one of the first ways in
    which electronic group communication was implemented. Prior to email, sharing
    information in a group setting required either a face-to-face meeting or a telephone
    conference call. In both cases, all parties must be present simultaneously, and
    a cost is involved, especially when the parties are geographically distant.
  prefs: []
  type: TYPE_NORMAL
- en: 'With email, a group of individuals can share information without needing to
    meet or even be available at the same time. Suppose a group comprises four individuals:
    Ellen, Joe, Jane, and Tom. Ellen has a proposal that she wants to discuss. She
    sends it to Joe, Jane, and Tom. Each recipient will read it at a time convenient
    for him or her. Each person can then reply back to the group. For example, Tom
    might have a comment on the proposal, so he just sends it to Ellen, Joe, and Jane.
    Most email clients include a *group reply* feature for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Mailing Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In larger groups, communication by typing the addresses of each recipient becomes
    cumbersome. Instead, a *mailing list* is used. The list is created by an individual
    termed the *list owner* and contains the email addresses of all the members of
    the group. A special *list address* is created, which functions just like a regular
    email address. However, when anyone sends mail to this special address, it is
    not simply deposited into a mailbox. It is instead intercepted by special software
    that processes the message and sends it out automatically to all recipients on
    the list. Any recipient can reply to the list address, and all members will receive
    the reply.
  prefs: []
  type: TYPE_NORMAL
- en: Many other ways can be used by groups to share information today, such as using
    World Wide Web bulletin boards, Usenet newsgroups, Internet Relay Chat (IRC),
    and so forth. Some of these have a lot of features that make mailing lists seem
    unsophisticated by comparison. Despite this, electronic mailing lists are still
    very popular, largely because email is the most universal Internet communication
    method and one of the easiest methods to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many thousands of mailing lists are in use on the Internet, covering every
    subject imaginable. Each list differs in a number of regards, including the following
    five aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation** Usually, some sort of special software is used to allow
    the list owner to manage it, add and remove users, and set parameters that control
    how the list operates. These programs are commonly called *robots* or *listservs
    (list servers)*. One of the more common listservs is named *Majordomo*. Some mailing
    lists are actually implemented and managed using the Web. (The line between Internet
    applications continues to get more and more blurry.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subscription Rules and Technique** Some mailing lists are open to anyone
    who wishes to join; others are by invitation only. Most allow a new subscriber
    to join automatically using software; others require the list owner to add new
    members.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Management Method and Style** The list owner decides what is acceptable for
    discussion on the list. Some lists are *moderated*, meaning that all submissions
    to the list must be approved by the list owner before they are sent to list members.
    Some lists allow mail to the list from nonmembers, and some do not.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Culture** Like all groups, groups of people on mailing lists have their own
    culture, interesting personalities, and other unique traits. New members of a
    list are often encouraged to read the list and not send to it for a while until
    they become accustomed to it and how it works. This is similar to the acclimation
    process for Usenet newbies (Usenet is covered in [Chapter 85](ch85.html "Chapter 85. USENET
    (NETWORK NEWS) AND THE TCP/IP NETWORK NEWS TRANSFER PROTOCOL (NNTP)")).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Special Features** Some lists support special features, such as the ability
    to subscribe in *digest mode* (where messages are collected into large digests
    to reduce the number of individual messages sent) or to access messages on the
    Web.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the many benefits of email is that it is easy to send
    a message to many people at once, simply by specifying several recipient addresses.
    This permits easy and simple *group communication*, because each recipient can
    then send a group reply to respond to each of the people who were sent the original
    message. Electronic *mailing lists* provide a more formalized way for groups to
    exchange ideas and information; many thousands of such lists are in use on the
    Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING:
    RFC 822 AND MIME'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The advantages of using computers for communication are obvious, but some limitations
    are also imposed by the use of computer technology. When I compare electronic
    mail (email) to regular mail, I always point out that email is much faster and
    more flexible in how it can be delivered, and this is true. An email message can
    reach its destination in seconds, while a conventional letter can take days.
  prefs: []
  type: TYPE_NORMAL
- en: However, one significant drawback of using computers to communicate is that
    they are not very flexible in figuring out how to understand messages. Consider
    that anyone can put any type of letter, memorandum, or other communication in
    an envelope and send it to you, and assuming you know the language in which it
    is written, you can open the envelope and probably understand it. You can figure
    out how to deal with a date that appears in an unusual place in the letter, or
    your name appearing at the top compared to the bottom, or the body of the message
    being structured in different ways. You can read notes that are typed or handwritten
    in pen, pencil, or crayon—as long as the letters are decipherable, you can understand
    what is being said.
  prefs: []
  type: TYPE_NORMAL
- en: Computers are not good at deciphering such subtleties. It is for that reason
    that email systems must rely on standard message formats to ensure that all messages
    have the same form and structure. This then makes it possible for all devices
    in the email system to read and understand one another's messages, to enable TCP/IP
    email to work on many different types of computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I describe the two formats used for TCP/IP email messages:
    the main TCP/IP email standard, which is called the RFC 822 format after the standard
    that defines it, and the Multipurpose Internet Mail Extensions (MIME) standard,
    which greatly expands the ability of email to support the communication of different
    types of information by defining methods of encoding various media and non-English-language
    text into the standard RFC 822 format.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Email RFC 822 Standard Message Format Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most astute observations I have read about internetworking applications
    asserts that their usefulness is proportional to the number of people who use
    them. TCP/IP email is a great example. It is a powerful communication method in
    large part because almost everyone with a computer today participates in the system.
    The more people who sign on to use email, the more powerful it becomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creators of TCP/IP email realized that people who use the system would
    employ many different types of hardware and software. To ensure that everyone
    was able to understand all email messages, regardless of who sent them, they specified
    a common message format for email messages. This format doesn''t have an official
    fancy name; it is simply known by the name of the standard that defines it: the
    RFC 822 message format.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *This discussion will make certain references to the
    discussion of the Simple Mail Transfer Protocol (SMTP; see [Chapter 77](ch77.html
    "Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER
    PROTOCOL (SMTP)")) but was designed so that you could read it prior to learning
    about SMTP without getting confused*.'
  prefs: []
  type: TYPE_NORMAL
- en: The primary protocol for delivering email is Simple Mail Transfer Protocol (SMTP).
    For this reason, the message format used for TCP/IP email could be considered
    SMTP's protocol message format, not unlike the special message formats discussed
    for other protocols, such as the Internet Protocol (IP) and the Transmission Control
    Protocol (TCP). However, the TCP/IP email message format is used not only by SMTP,
    but by all protocols and applications that deal with email. This includes the
    mail-access protocols Post Office Protocol (POP3) and Internet Message Access
    Protocol (IMAP), as well as others. It was also intended to be potentially usable
    by other non-TCP/IP mail delivery protocols. Perhaps for this reason, the TCP/IP
    email format was not specified as part of the SMTP itself, RFC 821, but was specified
    in a companion document, RFC 822\. Both were published in 1982.
  prefs: []
  type: TYPE_NORMAL
- en: Development of the RFC 822 Message Format Standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history of the message format used in TCP/IP starts long before 1982\. It
    was originally defined as the format for passing text messages on the Internet's
    precursor, the ARPAnet, in the early 1970s. The format was refined several times,
    leading to the publication in 1977 of the important email standard RFC 733, "Standard
    for the Format of ARPA Network Text Messages." RFC 822 later streamlined the contents
    of RFC 733, removing some of the features described in the earlier standard that
    failed to gain acceptance and simplifying the specification.
  prefs: []
  type: TYPE_NORMAL
- en: In 2001, both SMTP and the RFC 822 message format were revised; SMTP is now
    described in RFC 2821 and the message format in RFC 2822\. This newer standard
    makes relatively small changes to the RFC 822 message format to reflect modern
    use of TCP/IP email. Even though RFC 2822 is the current standard, the original
    name is still the one most commonly used. I will respect that convention in this
    discussion, describing the message format based on RFC 2822 while still calling
    it the RFC 822 message format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RFC 822 format describes the form, structure, and content of TCP/IP email
    messages. It is, as I said, analogous to the message formats used for other protocols
    in TCP/IP. Like those other formats, the RFC 822 format can be logically divided
    into two main sections: the *message header*, which contains important control
    and descriptive information, and the *message body* or *payload*, which carries
    the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of RFC 822 Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where RFC 822 differs from the field formats of other protocols is in expression.
    Most TCP/IP protocols encode header information into a compact set of bytes that
    are read and understood based on their location in the message and the semantic
    meaning assigned to them. Consider IP, for example. The ninth byte of every IP
    datagram is the Time to Live (TTL) field, which is encoded as a value from 0 to
    255\. A device reading an IP datagram simply knows that byte number 9 contains
    the TTL value. If it sees the binary value 00010011 there, it knows the TTL value
    for this datagram is the decimal value 19.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, RFC 822 messages do not use a binary format. They are composed
    entirely of lines of regular ASCII text (as used in the United States, called
    *US-ASCII* by the standard), even the headers. Each line ends with an ASCII *carriage
    return (CR)* character, followed by a *line feed (LF)* character; the combination
    is collectively termed *CRLF*. Each line of text should be 78 or fewer characters
    (not including the terminating CRLF) and must not be more than 998 characters
    (again, excluding the CRLF). Also, the CR and LF characters must not appear by
    themselves within the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RFC 822 message begins with a set of lines of text that collectively make
    up the message header. Each *header field* is expressed in the following form,
    in text: *<header name>: <header value>*. So, for example, if a *TTL* field were
    in an RFC 822 message (which it isn''t, as that concept is not particular to email)
    and a value of 19 needed to be expressed, the header field would appear like this:
    *Time to Live: 19*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This expressing of all fields as simple text means each header takes up more
    space in each message; the string *Time To Live: 19* takes up 18 bytes including
    the terminating CRLF, whereas the binary-encoded TTL field in the IP header takes
    only a single byte. What we gain from this are two important benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Any user can easily check the headers and immediately understand what headers
    are present and what their values are, which makes RFC 822 messages very readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since each header is explicitly labeled, RFC 822 messages can vary in terms
    of the number of headers they contain and even in what order they appear, making
    them flexible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General RFC 822 Message Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RFC 822 message always starts with a set of header fields (as described
    in the next section). After all the headers, an empty line must occur. This consists
    simply of the characters CRLF alone, immediately following the CRLF at the end
    of the final header field line. Seeing two CRLF character pairs in sequence tells
    the device reading the message that the end of the headers has been reached. All
    the remaining lines are considered the body of the message. Like the header lines,
    body lines are composed of ASCII text and must be no more than 998 characters,
    with 78 characters or fewer recommended (for easier reading on standard 80-character
    terminal displays).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** To ensure that every device on a TCP/IP internetwork can read
    email sent by every other device, all messages are required to adhere to a specific
    structure. The standard that first specified the form of modern TCP/IP email messages
    was RFC 822, and as a result, this is now called the *RFC 822 message format*.
    An RFC 822 message consists of a set of *message headers* and a *message body*,
    which are separated by a blank line. RFC 822 messages must contain only plain
    ASCII text characters. Each line must be no more than 1,000 characters in length,
    and the last two characters must be the ASCII CR and LF characters to mark the
    end of the line.'
  prefs: []
  type: TYPE_NORMAL
- en: Since both the header and body of email messages are simply ASCII text, the
    entire message is just a text file, so these messages are very readable and also
    easy to create. You can use a simple text editor to create a complete email message,
    including headers, and it can be read with a simple text display utility. This
    contributes to email's universal appeal.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback is that the decision to make messages entirely ASCII means that
    no native support is available in RFC 822 messages for anything that requires
    more complex structuring or that cannot be expressed using the limited number
    of ASCII characters. So, you cannot express pictures, binary files, spreadsheets,
    sound clips, and similar types of files directly using ASCII. Also, the use of
    ASCII makes RFC 822 well suited to expressing messages in English but not in many
    other languages that use characters that ASCII cannot represent. All of these
    limitations eventually prompted the creation of the enhanced MIME message format,
    which we will explore in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP Email RFC 822 Standard Message Format Header Fields and Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RFC 822 message format describes the structure and content of TCP/IP email
    messages. The structure is intentionally designed to be simple and easy to create
    and understand. Each message begins with a set of headers that describe the message
    and its contents. An empty line marks the end of the headers, and then the message
    body follows.
  prefs: []
  type: TYPE_NORMAL
- en: The message body contains the actual text that the sender is communicating to
    the recipient(s), while the message header contains information that serves various
    purposes. The header helps control how the message is processed by specifying
    who the recipients are, describing the contents of the message, and providing
    information to a recipient of a message about processing that occurred on the
    message as it was delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Header Field Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the *<header name>* field is the name of the header,
    and the *<header value>* is the value associated with that header, which depends
    on the header type. Like all RFC 822 lines, headers must be no more than 998 characters
    long and are recommended to be no more than 78 characters in length, for easier
    readability. The RFC 822 and 2822 standards support a special syntax for allowing
    headers to be folded onto multiple lines if they are very lengthy. This is done
    by continuing a header value onto a new line, which must begin with at least one
    white-space character, such as white space or a tab character, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *<header name>: <header value part 1>* |'
  prefs: []
  type: TYPE_TB
- en: '| *<white space> <header value part 2>* |'
  prefs: []
  type: TYPE_TB
- en: '| *<white space> <header value part 3>* |'
  prefs: []
  type: TYPE_TB
- en: 'The tab character is most often used for this purpose. So, for example, if
    we wanted to specify a large number of recipients for a message, we could do it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| To:*<tab>person1@domain1.org, person2@domain2.com*, |'
  prefs: []
  type: TYPE_TB
- en: '| *<tab>person3@domain3.net, person4@domain4.edu* |'
  prefs: []
  type: TYPE_TB
- en: Header Field Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RFC 822 message format specifies many types of headers that can be included
    in email messages. A small number of headers are mandatory, meaning they must
    be included in all messages. Some are not mandatory but are usually present, because
    they are fundamental to describing the message. Other optional headers are included
    only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help organize the many headers, the RFC 2822 standard categorizes them into
    header field groups (as did RFC 822, though the groups are a little different
    in the older standard):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Origination Date Field** Specifies the date and time that the message was
    made ready for delivery; see the next section for details. (This field is in its
    own group for reasons that are unclear to me; perhaps just because it is so important.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Originator Fields** Contain information about the sender of the message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Destination Address Fields** Specify the recipient(s) of the message, which
    may be in one of three different recipient classes: the primary recipients ("To"),
    copied recipients ("Cc"), and blind-copied recipients ("Bcc").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identification Fields** Contain information to help identify the message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Informational Fields** Contain optional information to help make clear to
    the recipient what the message is about.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resent Fields** Preserve the original originator, destination, and other
    fields when a message is resent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace Fields** Show the path taken by mail as it was transported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the format allows other user-defined fields to be specified, as
    long as they correspond to the standard *<header name>: <header value>* syntax.
    This can be used to provide additional information of various sorts. For example,
    sometimes the email client software will include a header line indicating the
    name and version of the software used to compose and send the message. As you''ll
    see later in this chapter, MIME uses new header lines to encode information about
    MIME messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each RFC 822 message begins with a set of *headers* that carry
    essential information about the message. These headers are used to manage how
    the message is processed and interpreted, and they also describe the contents
    of the message body. Each header consists of a *header name* and a *header value*.
    More than a dozen different standard RFC 822 headers are available for use and
    organized into groups. It is also possible to define custom user headers.'
  prefs: []
  type: TYPE_NORMAL
- en: Common Header Field Groups and Header Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 76-1](ch76s02.html#rfc__email_header_field_groups_and_field "Table 76-1. RFC
    822 Email Header Field Groups and Fields") describes the header fields in TCP/IP
    email messages and how they are used.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 76-1. RFC 822 Email Header Field Groups and Fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Group | Field Name | Appearance | Number of Occurrences Per Message
    | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Origination Date | Date: | Mandatory | 1 | Indicates date and time that the
    message was made available for delivery by the mail transport system. This is
    commonly the date/time that the user tells her email client to send the message.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Originator Fields | From: | Mandatory | 1 | Email address of the user sending
    the message, who should be the person who is the source of the message. |'
  prefs: []
  type: TYPE_TB
- en: '|   | Sender: | Optional | 1 | Email address of the person sending the email,
    if different from the message originator. For example, if person B is sending
    an email containing a message from person A on A''s behalf, person A''s address
    goes in the From: header and person B''s in the Sender: header. If the originator
    and the sender are the same (commonly the case), this field is not present. |'
  prefs: []
  type: TYPE_TB
- en: '|   | Reply-To: | Optional | 1 | Tells the recipient of the message the address
    the originator would like the recipient to use for replies. If absent, replies
    are normally sent back to the From: address. |'
  prefs: []
  type: TYPE_TB
- en: '| Destination Address Field | To: | Normally present | 1 | A list of primary
    recipients of the message. |'
  prefs: []
  type: TYPE_TB
- en: '|   | Cc: | Optional | 1 | A list of recipients to receive a copy of the message
    (*cc* stands for carbon copy, as used in old typewriters). There is no technical
    difference between how a message is sent to someone listed in the Cc: header and
    someone in the To: header. The difference is only in how the recipient interprets
    the message. The person in the To: list is usually the main recipient of the message,
    while the person in the Cc: list is being copied on the message for informational
    purposes. |'
  prefs: []
  type: TYPE_TB
- en: '|   | Bcc: | Optional | 1 | Contains a list of recipients to receive a "blind"
    copy of the message without other recipients knowing they have received it. For
    example, if person X is specified in the *To*: line, person Y is in the *Cc*:
    line, and person Z is in the *Bcc*: line, all three would get a copy of the message,
    but X and Y would not know Z had received a copy. This is done by either removing
    the *Bcc*: line before message delivery or altering its contents. |'
  prefs: []
  type: TYPE_TB
- en: '| Identification Fields | Message-ID: | Should be present | 1 | Provides a
    unique code for identifying a message; normally generated when a message is sent.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | In-Reply-To: | Optional, normally present for replies | 1 | When a message
    is sent in reply to another, the Message-ID: field of the original message is
    specified in this field, to tell the recipient of the reply to what original message
    the reply pertains. |'
  prefs: []
  type: TYPE_TB
- en: '|   | References: | Optional | 1 | Identifies other documents related to this
    message, such as other email messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Informational Fields | Subject: | Normally present | 1 | Describes the subject
    or topic of the message. |'
  prefs: []
  type: TYPE_TB
- en: '|   | Comments: | Optional | Unlimited | Contains summarized comments about
    the message. |'
  prefs: []
  type: TYPE_TB
- en: '|   | Keywords: | Optional | Unlimited | Contains a list of comma-separated
    keywords that may be useful to the recipient. May be used optionally when searching
    for messages on a particular subject matter. |'
  prefs: []
  type: TYPE_TB
- en: '| Resent Fields | Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Bcc:Resent-Message-ID:
    | Each time a message is resent, a resent block is required | For each resent
    block, Resent-Date: and Resent-Sender: are required; others are optional | Special
    fields used only when a message is resent by the original recipient to someone
    else, called forwarding. For example, person X may send a message to Y, who forwards
    it to Z. In that case, the original Date:, From:, and other headers are as they
    were when person X sent the message. The Resent-Date:, Resent-From:, and other
    resent headers are used to indicate the date, originator, recipient, and other
    characteristics of the resent message. |'
  prefs: []
  type: TYPE_TB
- en: '| Trace Fields | Received: Return-Path: | Inserted by email system | Unlimited
    | Inserted by computers as they process a message and transport it from the originator
    to the recipient. Can be used to trace the path a message took through the email
    system. |'
  prefs: []
  type: TYPE_TB
- en: TCP/IP Email RFC 822 Standard Message Format Processing and Interpretation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standards that define SMTP describe the protocol as being responsible for
    transporting *mail objects*. A mail object is described as consisting of two components:
    a *message* and an *envelope*. The message is everything in the email message,
    including both message header and body; the envelope contains all the information
    necessary to accomplish transport of the message.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between these objects is important technically. Just as the
    postal service looks only at the envelope and not its contents in determining
    what to do with a letter, SMTP likewise looks only at the envelope in deciding
    how to send a message. It does not rely on the information in the actual message
    itself for basic transport purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the envelope is not the same as the message headers. However, as you can
    tell by looking at the list of email headers, each message includes the recipients
    and other information needed for mail transport. For this reason, it is typical
    for an email message to be specified with enough header information to accomplish
    its own delivery. Email software can process and interpret the message to construct
    the necessary envelope for SMTP to transport the message to its destination mailbox.
    The distinction between an email message and its envelope is discussed in more
    detail in the section describing SMTP mail transfers, in [Chapter 77](ch77.html
    "Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER
    PROTOCOL (SMTP)").'
  prefs: []
  type: TYPE_NORMAL
- en: The processing of RFC 822 messages is relatively straightforward, due again
    to the simple RFC 822 message format. The creation of the complete email message
    begins with the creation of a message body and certain headers by the user creating
    the message. Whenever a message is "handled" by a software program, the headers
    are examined so the program can determine what to do with it. Additional headers
    are also added and changed as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the sequence of events that occur during the lifetime of a
    message's headers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition** The human composer of the message writes the message body and
    tells the email client program the values to use for certain important header
    fields. These include the intended recipients, the message subject, other informational
    fields, and certain optional headers such as the Reply-To field.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sender Client Processing** The email client processes the message, puts the
    information the human provided into the appropriate header form, and creates the
    initial email message. At this time, it inserts certain headers into the message,
    such as the origination date. The client also parses the intended recipient list
    to create the envelope for transmission of the message using SMTP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SMTP Server Processing** SMTP servers do not pay attention to most of the
    fields in a message as they forward it. They will, however, add certain headers,
    especially trace headers such as Received and Return-Path, as they transport the
    message. These are generally prepended to the beginning of the message to ensure
    that existing headers are not rearranged or modified. Note, however, that when
    gatewaying occurs between email systems (as described in [Chapter 75](ch75.html
    "Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING")), certain headers
    must actually be changed to ensure that the message is compatible with non-TCP/IP
    email software.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipient Client Processing** When the message arrives at its destination,
    the recipient''s SMTP server may add headers to indicate the date and time the
    message was received.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipient Access** When the recipient of a message uses client software,
    optionally via an email access protocol such as POP3 or IMAP, the software analyzes
    each message in the mailbox. This enables the software to display the messages
    in a way that''s meaningful to the human user and may also permit the selection
    of particular messages to be retrieved. For example, most of us like to see a
    summary list of newly received mail, showing the originator, message subject,
    and the date and time the message was received, so we can decide what mail we
    want to read first, what mail to defer to a later time, and what to delete without
    reading (such as spam).'
  prefs: []
  type: TYPE_NORMAL
- en: MIME Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RFC 822 email message format is the standard for the exchange of email in
    TCP/IP internetworks. Its use of simple ASCII text makes it easy to create, process,
    and read email messages, which has contributed to the success of email as a worldwide
    communication method.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, while ASCII text is great for writing simple memorandums and
    other short messages, it provides no flexibility to support other types of communication.
    To allow email to carry multimedia information, arbitrary files, and messages
    in languages using character sets other than ASCII, the MIME standard was created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While MIME was developed specifically for email, its encoding and data representation
    methods have proven so useful that it has been adopted by other application protocols
    as well. One of the best known of these is the Hypertext Transfer Protocol (HTTP),
    which uses MIME headers for indicating the characteristics of data being transferred.
    Some elements of MIME were in fact developed not for email but for use by HTTP
    or other protocols, and I indicate this where appropriate. Be aware that HTTP
    only uses some elements of MIME; HTTP messages are not MIME-compliant*.'
  prefs: []
  type: TYPE_NORMAL
- en: Most protocols become successful specifically because they are based on open
    standards that are widely accepted. The RFC 822 email message format standard
    is an excellent example; it is used by millions of people every day to send and
    receive TCP/IP email.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, success of standards comes at a price: *reliance* on those standards.
    Once a standard is in wide use, it is very difficult to modify it, even when times
    change and the standard is no longer sufficient for the requirements of modern
    computing. Again, unfortunately, the RFC 822 email message format is an excellent
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: The Motivation for MIME
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Motivation for MIME
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TCP/IP email was developed in the 1960s and 1970s. Compared to the way the world
    of computers and networking is today, almost everything back then was *small*.
    The networks were small; the number of users was small; the computing capabilities
    of networked hosts was small; the capacity of network connections was small; the
    number of network applications was small. (The only thing that wasn't small back
    then was the size of the computers themselves!)
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this, the requirements for electronic mail messaging were also
    rather … small. Most computer input and output back then was text-based, and it
    was therefore natural that the creators of SMTP and the RFC 822 standard would
    have envisioned email as being strictly a text medium. Accordingly, they specified
    RFC 822 to carry text messages.
  prefs: []
  type: TYPE_NORMAL
- en: The fledgling Internet was also developed within the United States, and at first,
    the entire internetwork was within American borders. Most people in the United
    States speak English, a language that as you may know uses a relatively small
    number of characters that is well-represented using the ASCII character set. Defining
    the email message format to support United States ASCII (US-ASCII) also made sense
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as computers developed, they moved away from a strict text model toward
    graphical operating systems. And predictably, users became interested in sending
    more than just text. They wanted to be able to transmit diagrams, non-ASCII text
    documents (such as Microsoft Word files), binary program files, and eventually
    multimedia information: digital photographs, MP3 audio clips, slide presentations,
    movie files and much more. Also, as the Internet grew and became global, other
    countries came "online," some of which used languages that simply could not be
    expressed with the US-ASCII character set.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, by this point, the die was cast. RFC 822 was in wide use and
    changing it would have also meant changes to how protocols such as SMTP, POP and
    IMAP worked, protocols that ran on millions of machines. Yet by the late 1980s,
    it was quite clear that the limitations of plain ASCII email were a big problem
    that had to be resolved. A solution was needed, and it came in the form of the
    Multipurpose Internet Mail Extensions (MIME).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*MIME is usually referred to in the singular, as I will do from here forward,
    even though it is an abbreviation of a plural term*.'
  prefs: []
  type: TYPE_NORMAL
- en: MIME Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind MIME is both clever and elegant: RFC 822 restricts email messages
    to ASCII text, but that doesn''t mean that we can''t define a more specific structure
    for how that ASCII text is created. Instead of just letting the user type an ASCII
    text message, we can use ASCII text characters to encode nontext data parcels
    (commonly called *attachments*). Using this technique, MIME allows regular RFC
    822 email messages to carry the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nontext Information** Includes graphics files, multimedia clips, and all
    the other nontext data examples listed earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arbitrary Binary Files** Includes executable programs and files stored in
    proprietary formats (for example, AutoCAD files, Adobe Acrobat PDF files, and
    so forth).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Messages That Use Character Sets Other Than ASCII** Includes the ability
    to use non-ASCII characters in the headers of RFC 822 email messages.'
  prefs: []
  type: TYPE_NORMAL
- en: MIME even goes one step beyond this, by actually defining a structure that allows
    multiple files to be encoded into a single email message, including files of different
    types. For example, someone working on a budget analysis could send one email
    message that includes a text message, a PowerPoint presentation, and a spreadsheet
    containing the budget figures. This capability has greatly expanded email's usefulness
    in TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is accomplished through special encoding rules that transform non-ASCII
    files and information into an ASCII form. Headers are added to the message to
    indicate how the information is encoded. The encoded message can then be sent
    through the system like any other message. SMTP and the other protocols that handle
    mail pay no attention to the message body, so they don't even know MIME has been
    used.
  prefs: []
  type: TYPE_NORMAL
- en: The only change required to the email software is adding support for MIME to
    email client programs. Both the sender and receiver must support MIME to encode
    and decode the messages. Support for MIME was not widespread when MIME was first
    developed, but the value of the technique is so significant that it is present
    in nearly all email client software today. Furthermore, most clients today can
    also use the information in MIME headers to not only decode nontext information
    but pass it to the appropriate application for presentation to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The use of the RFC 822 message format ensures that all devices
    are able to read one another''s email messages, but it has a critical limitation:
    It supports only plain ASCII text. This is insufficient for the needs of modern
    internetworks, yet reliance on the RFC 822 standard would have made replacing
    it difficult. *MIME* specifies several methods that allow email messages to contain
    multimedia content, binary files, and text files using non-ASCII character sets,
    all while still adhering to the RFC 822 message format. MIME also further expands
    email''s flexibility by allowing multiple files or pieces of content to be sent
    in a single message.'
  prefs: []
  type: TYPE_NORMAL
- en: MIME Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MIME was first described in a set of two standards, RFC 1341 and RFC 1342, published
    in June 1992\. These were updated by RFCs 1521 and 1522 in September 1993\. In
    March 1994, a supplemental standard was published, RFC 1590, which specified the
    procedure for defining new MIME media types.
  prefs: []
  type: TYPE_NORMAL
- en: Work continued on MIME through the mid-1990s, and in November 1996, the standards
    were revised again. This time, the documents were completely restructured to improve
    the readability of the information and published as a set of five individual standards.
    These standards are shown in [Table 76-2](ch76s04.html#mime_standards-id001 "Table 76-2. MIME
    Standards").
  prefs: []
  type: TYPE_NORMAL
- en: Since the time that these five primary MIME standards were released, numerous
    additional RFCs have been published that have defined various extensions to MIME
    itself, including additional MIME header types and new media types. Notable examples
    are RFCs 2183 and 2557, which define the MIME Content-Disposition and Content-Location
    headers, respectively. Some other MIME capabilities are actually defined as part
    of other technologies that use MIME; for example, the first HTTP standard, RFC
    1945 defines the Content-Length header. Other RFCs define new media types and
    subtypes (too many to list here).
  prefs: []
  type: TYPE_NORMAL
- en: Table 76-2. MIME Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| RFC Number | RFC Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2045 | Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet
    Message Bodies | Describes the fundamental concepts behind MIME and the structure
    of MIME messages. |'
  prefs: []
  type: TYPE_TB
- en: '| 2046 | Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types
    | Explains the concept of MIME media types and subtypes and describes some of
    the kinds of media whose encoding is defined in the MIME standards. |'
  prefs: []
  type: TYPE_TB
- en: '| 2047 | MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header
    Extensions for Non-ASCII Text | Describes how RFC 822 headers can be modified
    to carry non-ASCII text. |'
  prefs: []
  type: TYPE_TB
- en: '| 2048 | Multipurpose Internet Mail Extensions (MIME) Part Four: Registration
    Procedures | Discusses how organizations can register additional media types for
    use with MIME. |'
  prefs: []
  type: TYPE_TB
- en: '| 2049 | Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance
    Criteria and Examples | Provides additional implementation information and examples
    of how MIME can be used. |'
  prefs: []
  type: TYPE_TB
- en: MIME Basic Structures and Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The creators of the MIME standard had a difficult challenge on their hands:
    how to bring flexibility in the types of data contained in email messages, when
    RFC 822 said that messages could contain only ASCII text. To accomplish this,
    MIME creators had to exploit the areas of flexibility that had already been put
    into the existing RFC 822.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two such opportunities were available: The first was the fact that RFC 822
    message bodies are allowed to contain any type of ASCII text, as long as lines
    don''t exceed 998 text characters and each line ends with a CRLF control code
    combination. Even though the creators of RFC 822 naturally assumed this ASCII
    text would be human-readable, there was nothing stopping it from being machine-readable
    code. The second opportunity was the facility built into RFC 822 (and the protocols
    that use it, such as SMTP) that allowed custom user-defined header fields to be
    added to any email message.'
  prefs: []
  type: TYPE_NORMAL
- en: The nonspecific nature of RFC 822 message bodies forms the basis for how MIME
    itself works. An email client that supports the MIME standard uses special encoding
    algorithms that transform non-ASCII information into ASCII form. It then places
    this set of encoded ASCII characters into the body of the message, as if it had
    been typed by a user, using one of two special structures.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to add new headers to RFC 822 is used to communicate information
    about the use of MIME from the sender to the recipient. The devices transporting
    a MIME message don't care that MIME was used, because they don't pay attention
    to the contents of the message body. However, when the message reaches its destination,
    the recipient's email client program must have some way of knowing that MIME was
    used and must also be told how the information in the message was encoded. Otherwise,
    it might just present the encoded non-ASCII data to the user as ASCII text (which
    would look like random gibberish).
  prefs: []
  type: TYPE_NORMAL
- en: Basic Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exact method by which data is encoded in the message body and MIME headers
    are included depends on the overall structure of the MIME message. Two basic structure
    types are described, based on the kind of media the message carries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Structure (Discrete Media)** MIME messages carrying a single discrete
    media type, such as a text message or a graphical image, use a simple structure.
    Only one encoding of information is present in the body of the message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex Structure (Composite Media)** Some MIME messages carry a composite
    media type, which allows multiple different media to be contained in a single
    message, such as a text message and a graphical image, or which allows the email
    to encapsulate another email message in its entirety. Many of these messages use
    a more complex structure, where the body of the message contains several MIME
    body parts.'
  prefs: []
  type: TYPE_NORMAL
- en: MIME Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collectively, both whole MIME messages and individual body parts are called
    *MIME entities*. Each set of MIME headers provides information about either type
    of MIME entity: a MIME message as a whole or a body part in a composite message.
    When a MIME message is received, the recipient first examines the headers in the
    message as a whole (the RFC 822 headers) to determine the overall message type.
    This then indicates whether the message uses a simple or complex structure. If
    the latter is used, the body of the message is parsed and each individual body
    part is individually interpreted, including its individualized headers. The section
    "MIME Composite Media Types," later in this chapter, provides more details on
    how these body parts are formatted.'
  prefs: []
  type: TYPE_NORMAL
- en: Primary MIME Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first of the five main MIME standards, RFC 2045, describes a set of five
    primary MIME headers that communicate basic information about the content of each
    MIME entity (message or body part).
  prefs: []
  type: TYPE_NORMAL
- en: '**MIME-Version** Each MIME message is required to have a MIME-Version header,
    which serves two purposes. First, it identifies the email message as being MIME-encoded.
    Second, even though only one version of MIME has been defined so far, having a
    version number header provides future proofing in case a new version is created
    later that may have some incompatibilities with the present one. Currently, all
    MIME messages use version 1.0\. This is the only MIME header that applies to an
    entire message; it is not used to label individual MIME body parts. This is easy
    to remember, as it is the only header whose name does not begin with Content-.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Type** Describes the nature of the data that is encoded in the MIME
    entity. This header specifies a content type and a content subtype, which are
    separated by a slash character. It may optionally also contain certain parameters
    that convey additional information about the type and subtype. In a message body,
    this header tells the recipient of the email message what sort of media it contains
    and whether the body uses a simple or complex structure. In a body part, it describes
    the media type the body part contains. For example, a message containing an HTML
    document might have a Content-Type header of `text/html`, where a message containing
    a JPEG graphical file might be specified as image/jpeg. For a composite MIME type,
    the Content-Type header of the whole message will contain something like `multipart/mixed`
    or `multipart/alternative`, and each body part will contain individual Content-Type
    headers such as `text/html` or `image/jpeg`. These are all discussed in detail
    in the next two sections. This header is optional. When not present, the default
    of a regular US-ASCII text message is assumed (the media type of regular RFC 822
    messages).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Transfer-Encoding** For a message using simple structure, specifies
    the method used to encode the data in the message body; for a composite message,
    identifies the encoding method for each MIME body part. For data that is already
    in ASCII form, no special encoding is needed, but other types of data must be
    converted to ASCII for transmission. This header tells the recipient how to decode
    the data back into its normal representation. (MIME encoding methods are described
    later in this chapter.) This header is optional; the default value, if it is not
    present, is 7-bit encoding, which again is the encoding of regular ASCII.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-ID** Allows the MIME content to be assigned a specific identification
    code. This header is analogous to the RFC 822 Message-ID header field but is specific
    to the MIME content itself. It is optional and is most often used for body parts
    in multipart MIME messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Description** This optional header allows an arbitrary additional
    text description to be associated with the MIME entity. In a multipart message,
    each body part might be given a description header to make clear to the recipient
    what the parts represent.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** MIME provides flexibility in the information that can be carried
    in email messages, by encoding non-ASCII data in ASCII form, and by adding special
    headers that describe this data and how it is to be interpreted. The most important
    MIME headers are *Content-Type*, which describes what sort of data is in the message,
    and *Content-Transfer-Encoding*, which specifies how the data is encoded. MIME
    supports two basic overall formats: *simple structure*, in which a single type
    of *discrete media* is encoded in a message, and *complex structure*, which encodes
    a *composite media* type that can carry multiple kinds of information.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional MIME Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the five basic headers, the MIME standard allows additional headers
    to be defined. The only restriction is that they all must start with the word
    *Content*-, which clearly labels them as describing content of a MIME entity (message
    or body part). Both the sender and recipient must support a custom header for
    it to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several new MIME headers have in fact been created and documented in various
    Internet RFCs. Some are actually designed not specifically for use by email messages,
    but for use by other protocols that make use of MIME technology, such as HTTP.
    Three are notable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Disposition** In multipart MIME messages, this header may be given
    to MIME body parts to control how information is presented to the user. The two
    most common values are *inline*, which says the content is intended to be displayed
    automatically along with other body parts, and *attachment*, which indicates that
    the content is separate from the main document. This header is defined in RFC
    2183.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Location** Allows the location of a MIME body part to be identified
    using a Uniform Resource Locator (URL). This is sometimes used when encoding HTML
    and other multimedia-enabled document formats into email using MIME multipart
    messages. It is defined in RFC 2557.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Length** Specifies the length of a MIME entity in bytes. This header
    is not commonly used in email applications of MIME but is an important header
    in HTTP. It is described in the HTTP standards, first appearing in RFC 1945.'
  prefs: []
  type: TYPE_NORMAL
- en: MIME Content-Type Header and Discrete Media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MIME uses special techniques to encode various kinds of information into ASCII
    text form, such as graphical images, sound files, video clips, application programs,
    compressed data files, and many others. We commonly refer to these as different
    types of *media*, and MIME uses the same term to describe them.
  prefs: []
  type: TYPE_NORMAL
- en: Since MIME supports so many kinds of media, it is necessary that each message
    contain information that describes what it contains to permit accurate decoding
    of message contents. This is the function of the important MIME Content-Type header.
  prefs: []
  type: TYPE_NORMAL
- en: Content-Type Header Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax of the Content-Type header is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *Content-Type: <type>/<subtype> [; parameter1 ; parameter2 .. ; parameterN
    ]* |'
  prefs: []
  type: TYPE_TB
- en: The purpose of these different elements is to describe the media in the MIME
    entity in a way that proceeds from the general to the specific. The first element,
    *<type>*, is called the *top-level media type* and describes the overall form
    of the data. For example, it indicates whether the MIME entity contains text,
    an image, audio, and so forth. The second element, *<subtype>*, provides specific
    information about the form or format of the data. For example, a JPEG image and
    a GIF image are both images, but they are in a different format. Both *<type>*
    and *<subtype>* are mandatory in the Content-Type header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following these elements may appear one or more *parameters*, which are usually
    optional but may be required for some media types. These provide still more details
    about the nature of the data, when it is required. Each parameter is preceded
    by a semicolon and is expressed as an attribute/value pair, separated by an equal
    (=) sign, like this: *; attribute=value*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of how parameters may be used is in specifying the character set
    in a text message. The representation of regular RFC 822 ASCII text is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level media type is `text`, and the subtype is `plain`, so this indicates
    a plain-text message. The parameter `charset` specifies that the message uses
    the US-ASCII character set. Another common use for parameters is to specify the
    name of an attached file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discrete Media Types and Subtypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, MIME supports two basic structures: simple and complex.
    A simple message carries only one media type, such as a piece of text, a picture,
    or an executable file. These are called *discrete media types* in MIME. A complex
    message carries a *composite media type*, which may incorporate multiple body
    parts. Each body part in turn carries data corresponding to one of the discrete
    media types. The top-level media type indicates whether the whole message carries
    a discrete media type or a composite type.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The MIME *Content-Type* header specifies what sort of data
    is encoded in a MIME message. The header indicates the general form of the message''s
    content through a *top-level media type*, and the more specific nature of the
    data through the specification of a *subtype*. It may also contain optional *parameters*
    that provide still more information about the content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The RFC 2046 standard (part two of the set of five standards that describes
    MIME) defines five discrete top-level media types: `text`, `image`, `audio`, `video`,
    and `application`. They each represent one of the major classes of data commonly
    transmitted over TCP/IP. Each of these has one or more subtypes, and some also
    have parameters that are used to provide more information about them.'
  prefs: []
  type: TYPE_NORMAL
- en: The creators of MIME recognized that the standard could not describe every media
    type and that new ones would be created in the future. RFC 2048 (part four of
    the MIME set) describes the process by which new media types, subtypes, and parameters
    can be described and registered with the Internet Assigned Numbers Authority (IANA).
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, only one new top-level media type has been created; this is the `model`
    top-level type, defined for CAD modeling files and similar uses, as described
    in RFC 2077\. However, many dozens of new subtypes have been created over the
    years, some specified in RFCs and others just registered directly with IANA. This
    includes many vendor-specific subtypes, which are usually identified by either
    the prefix *x-* or *vnd*. in the subtype name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Literally hundreds of type/subtype combinations now exist, and I will not list
    them all. You can find a complete list of MIME media organized by top-level media
    type on IANA''s website: [http://www.iana.org/assignments/media-types/index.html](http://www.iana.org/assignments/media-types/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I will briefly describe the six MIME discrete top-level media types. For
    each, I've provided a table showing some of the more commonly encountered MIME
    subtypes to give you an idea of what is out there.
  prefs: []
  type: TYPE_NORMAL
- en: Text Media Type (text)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `text` media type is used for sending data that is primarily in textual
    form. [Table 76-3](ch76s06.html#mime_text_media_type_subtypes "Table 76-3. MIME
    text Media Type Subtypes") describes shows the subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 76-3. MIME text Media Type Subtypes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type/Subtype | Description | Defining Source |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `text/plain` | Plain text, used for regular messages such as those corresponding
    to the initial RFC 822 standard | RFC 2046 |'
  prefs: []
  type: TYPE_TB
- en: '| `text/enriched` | Text that includes formatting information or other enrichment
    that makes it no longer plain | RFC 1896 |'
  prefs: []
  type: TYPE_TB
- en: '| `text/html` | A document expressed in HTML, commonly used for the World Wide
    Web | RFC 2854 |'
  prefs: []
  type: TYPE_TB
- en: '| `text/css` | Cascading style sheet information for the World Wide Web | RFC
    2318 |'
  prefs: []
  type: TYPE_TB
- en: Image Media Type (image)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `image` media type indicates graphical image files, such as pictures. The
    subtype normally indicates the specific format to allow the recipient to decode
    and present the file properly. Some of the more common subtypes are shown in [Table 76-4](ch76s06.html#mime_image_media_type_subtypes
    "Table 76-4. MIME image Media Type Subtypes").
  prefs: []
  type: TYPE_NORMAL
- en: Table 76-4. MIME image Media Type Subtypes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type/Subtype | Description | Defining Source |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `image/jpeg` | An image in JPEG format | RFC 2046 |'
  prefs: []
  type: TYPE_TB
- en: '| `image/gif` | A Graphical Interchange Format (GIF) image | IANA says RFC
    2046, but it''s not there. |'
  prefs: []
  type: TYPE_TB
- en: '| `image/tiff` | Tagged Image File Format (TIFF) image | RFC 2302 |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| Vector images used in AutoCAD | Registration with IANA |'
  prefs: []
  type: TYPE_TB
- en: Audio Media Type (audio)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio` media type is used for sending audio information. The subtype normally
    indicates the specific format. [Table 76-5](ch76s06.html#mime_audio_media_type_subtypes
    "Table 76-5. MIME audio Media Type Subtypes") shows a couple of common values.
  prefs: []
  type: TYPE_NORMAL
- en: Table 76-5. MIME audio Media Type Subtypes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type/Subtype | Description | Defining Source |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `audio/basic` | A basic audio type defined in the main MIME standards that
    describes single-channel audio encoded using 8-bit ISDN mu-law pulse code modulation
    at 8,000 Hz | RFC 2046 |'
  prefs: []
  type: TYPE_TB
- en: '| `audio/mpeg` | MPEG standard audio (including the popular MP3 file format)
    | RFC 3003 |'
  prefs: []
  type: TYPE_TB
- en: Video Media Type (video)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `video` media type is used for sending video information. Again, the subtype
    normally indicates the specific format, as shown in [Table 76-6](ch76s06.html#mime_video_media_type_subtypes
    "Table 76-6. MIME video Media Type Subtypes").
  prefs: []
  type: TYPE_NORMAL
- en: Table 76-6. MIME video Media Type Subtypes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type/Subtype | Description | Defining Source |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `video/mpeg` | Video encoded to the MPEG digital video standard | RFC 2046
    |'
  prefs: []
  type: TYPE_TB
- en: '| `video/dv` | Digital video corresponding to several popular standards including
    SD-VCR, HD-VCR, and DVB, as used by various types of video equipment | RFC 3189
    |'
  prefs: []
  type: TYPE_TB
- en: '| `video/quicktime` | Apple''s QuickTime movie format | Registration with IANA
    |'
  prefs: []
  type: TYPE_TB
- en: Model Media Type (model)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `model` media type describes a model representation, such as a two-dimensional
    or three-dimension physical model. Its subtypes are described in [Table 76-7](ch76s06.html#mime_model_media_type_subtypes
    "Table 76-7. MIME model Media Type Subtypes").
  prefs: []
  type: TYPE_NORMAL
- en: Table 76-7. MIME model Media Type Subtypes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type/Subtype | Description | Defining Source |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `model/mesh` | A mesh, as used in modeling | RFC 2077 |'
  prefs: []
  type: TYPE_TB
- en: '| `model/vrml` | A Virtual Reality Modeling Language (VRML) model | RFC 2077
    |'
  prefs: []
  type: TYPE_TB
- en: '| `model/iges` | A model file corresponding to the Initial Graphics Exchange
    Specification (IGES) | Registration with IANA |'
  prefs: []
  type: TYPE_TB
- en: Application Media Type (application)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `application` media type is a catchall for any kind of data that doesn't
    fit into one of the preceding categories or that is inherently application-specific.
    The subtype describes the data by indicating the kind of application that uses
    it. This can be used to guide the recipient's email program in choosing an appropriate
    application program to display it, just as a file extension in Windows tells the
    operating system how to open different kinds of files.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have Microsoft Excel installed on your PC, clicking a filename
    ending with .XLS will launch Excel automatically. Similarly, an Excel spreadsheet
    will normally be sent using MIME with a media type of `application/vnd.ms-excel`.
    This tells the recipient's email program to launch Excel to read this file.
  prefs: []
  type: TYPE_NORMAL
- en: '`Since so many applications are out there, more than 100 different subtypes
    exist within this top-level type. [Table 76-8](ch76s06.html#mime_application_media_type_subtypes
    "Table 76-8. MIME application Media Type Subtypes") contains a few representative
    samples.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Table 76-8. MIME application Media Type Subtypes`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type/Subtype | Description | Defining Source |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `application/octet-stream` | An arbitrary set of binary data octets (see
    the discussion following this table for more details) | RFC 2046 |'
  prefs: []
  type: TYPE_TB
- en: '| `application/postscript` | A PostScript file, used for printing and for generating
    Adobe Acrobat (PDF) files | RFC 2046 |'
  prefs: []
  type: TYPE_TB
- en: '| `application/applefile` | Resource file information for representing Apple
    Macintosh files | Registration with IANA |'
  prefs: []
  type: TYPE_TB
- en: '| `application/msword` | Microsoft Word document (note that this does not have
    the vnd prefix like most other Microsoft file types) | Registration with IANA
    |'
  prefs: []
  type: TYPE_TB
- en: '| `application/pdf` | A Portable Document Format (PDF) file, as created by
    Adobe Acrobat | Registration with IANA |'
  prefs: []
  type: TYPE_TB
- en: '| `application/vnd.framemaker` | An Adobe FrameMaker file | Registration with
    IANA |'
  prefs: []
  type: TYPE_TB
- en: '| `application/vnd.lotus-1-2-3` | A Lotus 1-2-3 file | Registration with IANA
    |'
  prefs: []
  type: TYPE_TB
- en: '| `application/vnd.lotus-notes` | A Lotus Notes file | Registration with IANA
    |'
  prefs: []
  type: TYPE_TB
- en: '| `application/vnd.ms-excel` | A Microsoft Excel spreadsheet file | Registration
    with IANA |'
  prefs: []
  type: TYPE_TB
- en: '| `application/vnd.ms-powerpoint` | A Microsoft PowerPoint presentation file
    | Registration with IANA |'
  prefs: []
  type: TYPE_TB
- en: '| `application/vnd.ms-project` | A Microsoft Project file | Registration with
    IANA |'
  prefs: []
  type: TYPE_TB
- en: '| `application/zip` | A compressed archive file containing one or more other
    files, using the ZIP/PKZIP compression format | Registration with IANA |'
  prefs: []
  type: TYPE_TB
- en: '``Of these application subtypes, a special one is worth further mention: the
    `application/octet-stream` subtype. This is the catchall within the catchall of
    the application type, which just means the file is a sequence of arbitrary binary
    data. It is usually used when the sender is unsure of what form the data takes
    or cannot identify it as belonging to a particular application. When this type
    is used, the recipient will usually be prompted to save the data to a file. He
    must then figure out what application to use to read it.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The `application/octet-stream` MIME type/subtype may even be used for images,
    audio, or video in unknown formats. If you try to send a multimedia document that
    your sending program does not understand, it will generally encode it as `application/octet-stream`
    for transmission. This is your email program''s way of saying to the recipient,
    "I am sending you this file as-is; you figure out what to do with it."``'
  prefs: []
  type: TYPE_NORMAL
- en: '``This `application/octet-stream` type is also often used for transmitting
    executable files (programs) especially on Windows systems. Unfortunately, while
    convenient, this can be a serious security hazard. In recent years, the Internet
    has been subject to a steady stream of viruses and worms that spread by sending
    themselves to other users through executable file attachments in email. This makes
    opening and running any unknown `application/octet-stream` attachment potentially
    dangerous.``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
