["```\nsegment_t s;\ns.startEA = startea;\ns.endEA = endEA;\ns.sel = setup_selector(base);\ns.bitness = use32;\ns.align = align;\ns.comb = comb;\nadd_segm_ex(&s, NULL, NULL, ADDSEG_NOSREG);\n```", "```\ntypeinfo_t mt;\n//calls an internal function to initialize mt using typeid\nadd_struc_member(get_struc(id), name, offset, flag, &mt, nbytes);\n```", "```\nget_forced_operand(ea, n, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\n//nargs is the number of arguments following type\n//args is idc_value_t[] of args following type\nidc_value_t result;\nif (type.vtype == VT_LONG && type.num == 0)\n   appcall(ea, 0, NULL, NULL, nargs, args, &result);\nelse\n   idc_value_t tval, fields;\n   internal_parse_type(&type, &tval, &fields);\n   appcall(ea, 0, &tval, &fields, nargs, args, &result);\n```", "```\nea_t addr = defval;\naskaddr(&addr, \"%s\", prompt):\nreturn addr;\n```", "```\nsval_t val = defval;\nasklong(&val, \"%s\", prompt):\nreturn val;\n```", "```\nsel_t seg = defval;\naskseg(&sel, \"%s\", prompt):\nreturn val;\n```", "```\n//*** undocumented function\nautoUnmark(start, end, type);\n```", "```\nget_cmt(ea, repeatable, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nif (isfile)\n   CompileEx(input, CPL_DEL_MACROS &#124; CPL_USE_LABELS,\n            errbuf, sizeof(errbuf));\nelse\n   CompileLineEx(input, errbuf, sizeof(errbuf));\n```", "```\nqsnprintf(buf, sizeof(buf), \"$ idc_array %s\", name);\nnetnode n(buf, 0, true);\nreturn (nodeidx_t)n;\n```", "```\nif (dbg && (dbg->may_disturb() &#124;&#124; get_process_state() < 0))\n   uint8_t b;\n   dbg->read_memory(ea, &b, sizeof(b));\n   return b;\n```", "```\nif (dbg && (dbg->may_disturb() &#124;&#124; get_process_state() < 0))\n   uint32_t d;\n   dbg->read_memory(ea, &d, sizeof(d));\n   return d;\n```", "```\nif (dbg && (dbg->may_disturb() &#124;&#124; get_process_state() < 0))\n   uint64_t q;\n   dbg->read_memory(ea, &q, sizeof(q));\n   return q;\n```", "```\nif (dbg && (dbg->may_disturb() &#124;&#124; get_process_state() < 0))\n   uint8_t *buf = (uint8_t*) qalloc(len);\n   dbg->read_memory(ea, buf, len);\n   return buf;\n```", "```\nif (dbg && (dbg->may_disturb() &#124;&#124; get_process_state() < 0))\n   uint16_t w;\n   dbg->read_memory(ea, &w, sizeof(w));\n   return w;\n```", "```\nif (dbg && (dbg->may_disturb() &#124;&#124; get_process_state() < 0))\n   dbg->write_memory(ea, data, length of data);\n```", "```\nua_ana0(ea);\nreturn cmd;\n```", "```\nnetnode n(id);\nn.hashdel(idx);\n```", "```\nwhile (get_segm_qty ())\n   del_segm(getnseg (0), 0);\nFlagsDisable(0, inf.ominEA);\nFlagsDisable(inf.omaxEA, 0xFFFFFFFF);\n```", "```\ndemangle_name(buf, sizeof(buf), name, disable_mask);\nreturn qstrdup(buf);\n```", "```\nif (trace_level == 0)\n   return enable_step_trace(enable);\nelse if (trace_level == 1)\n   return enable_insn_trace(enable);\nelse if (trace_level == 2)\n   return enable_func_trace(enable);\n```", "```\nchar fname[16];\nuint32_t fnum = globalCount++; //mutex around globalCount\nqsnprintf(fname, sizeof(fname), \"___idcexec%d\", fnum);\nuint32_t len;\nlen = qsnprintf(NULL, 0, \"static %s() {\\n%s\\n; }\", fname, input);\nchar *func = (char*)qalloc(len);\nqsnprintf(func, len, \"static %s() {\\n%s\\n; }\", fname, input);\nExecuteLine(func, fname, NULL, 0, NULL, NULL, err, sizeof(err));\nglobalCount--; //mutex around globalCount\nqfree(func);\n```", "```\nnetnode n(ea).supset(n + 1000, line);\nsetFlbits(ea, FF_LINE);\n```", "```\nnetnode n(ea).supset(n + 2000, line);\nsetFlbits(ea, FF_LINE);\n```", "```\nea_t endea = (flag & SEARCH_DOWN) ? inf.maxEA : inf.minEA;\nreturn find_binary(ea, endea, str, getDefaultRadix(), flag);\n```", "```\nfunc_t f;\nfind_func_bounds(ea, &f, FIND_FUNC_DEFINE);\nreturn f->endEA;\n```", "```\nexcvec_t *ev = retrieve_exceptions();\nfor (excvec_t::iterator i = ev->begin(); i != ev->end(); i++)\n   if ((*i).code == code)\n      ev->erase(i);\n      return store_exceptions();\nreturn 0;\n```", "```\nfunc_t *f = get_func(ea1);\ngen_flow_graph(outfile, title, f, ea1, ea2, flags);\n```", "```\nnetnode n(id);\nif (tag == 'A') return n.altval(idx);\nelse if (tag == 'S')\n   n.supstr(idx, buf, sizeof(buf));\n   return qstrdup(buf);\n```", "```\nqsnprintf(buf, sizeof(buf), \"$ idc_array %s\", name);\nnetnode n(buf);\nreturn (nodeidx_t)n;\n```", "```\nget_bmask_cmt(enum_id, bmask, repeatable, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_bmask_name(enum_id, bmask, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nbpt_t bpt;\nif (get_bpt(ea, &bpt) == 0) return −1;\nif (bpattr == BPTATTR_EA) return bpt.ea;\nelse if (bpattr == BPTATTR_SIZE) return bpt.size;\nelse if (bpattr ==BPTATTR_TYPE) return bpt.type;\nelse if (bpattr == BPTATTR_COUNT) return bpt.pass_count;\nelse if (bpattr == BPTATTR_FLAGS) return bpt.flags;\nelse if (bpattr == BPTATTR_COND) return qstrdup(bpt.condition);\n```", "```\nbpt_t bpt;\nreturn getn_bpt(n, &bpt) ? bpt.ea : −1;\n```", "```\nif (offset <= 191)\n   return *(unsigned char*)(offset + (char*)&inf);\n```", "```\nif (what == CIC_ITEM)\n   return get_color(ea);\nelse if (what == CIC_FUNC)\n   return get_func(ea)->color;\nelse if (what == CIC_SEGM)\n   return get_seg(ea)->color;\nreturn 0xFFFFFFFF;\n```", "```\nget_const_cmt(const_id, repeatable, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_const_name(const_id, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\ntag_remove(get_curline(), buf, sizeof(buf))\nreturn qstrdup(buf);\n```", "```\ngenerate_disasm_line(ea, buf, sizeof(buf));\ntag_remove(buf, buf, 0);\nreturn qstrdup(buf);\n```", "```\nget_entry_name(ordinal, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_enum_cmt(enum_id, repeatable, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_enum_name(enum_id, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nif (enum_id > 0xff000000)\n   netnode n(enum_id);\n   return (n.altval(0xfffffffb) >> 3) & 7;\nelse\n   return 0;\n```", "```\nexcvec_t *ev = retrieve_exceptions();\nreturn idx < ev->size() ? (*ev)[idx].code : 0;\n```", "```\nexcvec_t *ev = retrieve_exceptions();\nfor (excvec_t::iterator i = ev->begin(); i != ev->end(); i++)\n   if ((*i).code == code)\n      return (*i).flags;\nreturn −1;\n```", "```\nexcvec_t *ev = retrieve_exceptions();\nfor (excvec_t::iterator i = ev->begin(); i != ev->end(); i++)\n   if ((*i).code == code)\n      return new qstring((*i).name);\nreturn NULL;\n```", "```\nfunc_t *f = get_func(ea);\nreturn internal_get_attr(f, attr);\n```", "```\nfunc_t *f = get_fchunk(ea);\nfunc_parent_iterator_t fpi(f);\nreturn n < f->refqty ? f->referers[n] : BADADDR;\n```", "```\nnetnode n(id).hash1st(buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nmodule_info_t modinfo;\nget_first_module(&modinfo);\nreturn modinfo.base;\n```", "```\nfixup_data_t fd;\nget_fixup(ea, &fd);\nreturn fd.displacement;\n```", "```\nfixup_data_t fd;\nget_fixup(ea, &fd);\nreturn fd.off\n```", "```\nfixup_data_t fd;\nget_fixup(ea, &fd);\nreturn fd.sel;\n```", "```\nfixup_data_t fd;\nget_fixup(ea, &fd);\nreturn fd.type;\n```", "```\n//*** undocumented function\nchar buf[16];\nunion {float f; double d; long double ld} val;\nget_many_bytes(ea, buf, len > 16 ? 16 : len);\nph.realcvt(buf, &val, (len >> 1) - 1);\nreturn val;\n```", "```\nint flags =  GNCN_REQFUNC &#124; GNCN_NOCOLOR;\nget_nice_colored_name(ea, buf, sizeof(buf),flags);\nreturn qstrdup(buf);\n```", "```\nfunc_t *f = get_func(ea);\nreturn internal_get_attr(f, attr);\n```", "```\nget_func_name(ea, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nnetnode n(id).hashval(idx, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nqstrncpy(buf, idadir(NULL), sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nqstrncpy(buf, database_idb, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_root_filename(buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nRootNode.valstr(buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nuint8_t md5bin[16];\nchar out[1024];\nchar *outp = out;\nint len = sizeof(out);\nout[0] = 0;\nRootNode.supval(RIDX_MD5, md5bin, sizeof(md5bin));\nfor (int j = 0; j < sizeof(md5bin); j++) {\n   int nbytes = qsnprintf(out, len, \"%02X\", md5bin[j]);\n   outp += nbytes;\n   len -= nbytes;\n}\nreturn qstrdup(out);\n```", "```\nnetnode n(id).hashlast(buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nconst type_t *type;\nconst p_list *fields;\nget_numbered_type(idati, ordinal, &type, &fields,\n                  NULL, NULL, NULL);\nchar *name = get_numbered_type_name(idati, ordinal);\nqstring res;\nprint_type_to_qstring(&res, 0, 2, 40, flags, idati, type,\n                      name, NULL, fields, NULL);\nreturn qstrdup(res.c_str());\n```", "```\nif (offset <= 188)\n   return *(int*)(offset + (char*)&inf);\n```", "```\nget_manual_insn(ea, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nuint8_t *out = (uint8_t*)qalloc(size + 1);\nif (use_dbg)\n   if (dbg && (dbg->may_disturb() &#124;&#124; get_process_state() < 0))\n      dbg->read_memory(ea, out, size);\n   else\n      qfree(out);\n      out = NULL;\nelse\n   get_many_bytes(ea, out, size);\nreturn out;\n```", "```\ncurloc loc.markdesc(slot, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\ntid_t m = get_member(get_struc(id), offset)->id;\nnetnode n(m).supstr(repeatable ? 1 : 0, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\ntid_t m = get_member(get_struc(id), offset)->id;\nget_member_name(m, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nmember_t *m = get_member(get_struc(id), offset);\nreturn get_member_size(m);\n```", "```\ntid_t m = get_member(get_struc(id), offset)->id;\nreturn netnode n(m).altval(3) - 1;\n```", "```\nfunc_t *f = get_func(ea);\nreturn f ? get_min_spd_ea(f) : BADADDR;\n```", "```\nua_mnem(ea, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nmodule_info_t modinfo;\nif (base == 0)\n   get_first_module(&modinfo);\nelse\n   modinfo.base = base - 1;\n   get_next_module(&modinfo);\nreturn qstrdup(modinfo.name);\n```", "```\nmodule_info_t modinfo;\nif (base == 0)\n   get_first_module(&modinfo);\nelse\n   modinfo.base = base - 1;\n   get_next_module(&modinfo);\nreturn modinfo.size;\n```", "```\nnetnode n(id).hashnxt(idx, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nmodule_info_t modinfo;\nmodinfo.base = base;\nget_next_module(&modinfo);\nreturn modinfo.base;\n```", "```\n*buf = 0;\nif (isCode(get_flags_novalue(ea)))\n   ua_ana0(ea);\n   return cmd.Operands[n].type;\n```", "```\nUse ua_ana0 to fill command struct then return\nappropriate value based on cmd.Operands[n].type\n```", "```\n*buf = 0;\nif (isCode(get_flags_novalue(ea)))\n   ua_outop2(ea, buf, sizeof(buf), n);\ntag_remove(buf, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nnetnode n(id).hashprev(idx, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nprocess_info_t p;\npid_t pid = get_process_info(idx, &p);\nreturn qstrdup(p.name);\n```", "```\nregval_t r;\nget_reg_val(name, &r);\nif (is_reg_integer(name))\n   return (int)r.ival;\nelse\n   //memcpy(result, r.fval, 12);\n```", "```\nsegment_t *s = get_seg(segea);\nreturn internal_get_attr(s, attr);\n```", "```\nif (offset <= 190)\n   return *(unsigned short*)(offset + (char*)&inf);\n```", "```\nif (len == −1)\n   len = get_max_ascii_length(ea, type, true);\nget_ascii_contents(ea, len, type, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_struc_cmt(id, repeatable, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_struc_name(id, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nget_ti(ea, tbuf, sizeof(tbuf), plist, sizeof(plist));\nprint_type_to_one_line(buf, sizeof(buf), idati,\n                       tbuf, NULL, NULL, plist, NULL);\nreturn qstrdup(buf);\n```", "```\n//*** undocumented function\nget_vxd_func_name(vxdnum, funcnum, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nvalut_t res;\nget_xml(path, &res);\nreturn res;\n```", "```\nguess_type(ea, tbuf, sizeof(tbuf), plist, sizeof(plist));\nprint_type_to_one_line(buf, sizeof(buf), idati, tbuf,\n                       NULL, NULL, plist, NULL);\nreturn qstrdup(buf);\n```", "```\nnetnode n(ea).supstr(1000 + num, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nnetnode n(ea).supstr(2000 + num, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\ntypeinfo_t ti;\nflags_t f = get_flags_novalue(ea);\nget_typeinfo(ea, 0, f, &ti);\nasize_t sz = get_data_elsize(ea, f, &ti);\ndo_data_ex (ea, f, sz * nitems, ti.tid);\n```", "```\nfunc_t *f = get_func(ea);\nset_frame_size(f, lvsize, frregs, argsize);\nreturn f->frame;\n```", "```\nfunc_t *f = get_func(ea);\nif (*location != '[')\n   add_regvar(f, start, end, location, name, NULL);\nelse\n   struc_t *fr = get_frame(f);\n   int start = f->frsize + offset;\n   if (get_member(fr, start))\n      set_member_name(fr, start, name);\n   else\n      add_struc_member(fr, name, start,  0x400, 0, 1);\n```", "```\nint len = endea == −1 ? 0 : endea - ea;\nmake_ascii_string(ea, len, current_string_type);\n```", "```\nnetnode n(strname);\nnodeidx_t idx = (nodeidx_t)n;\nif (size != −1)\n   do_data_ex(ea, FF_STRU, size, idx);\nelse\n   size_t sz = get_struc_size(get_struc(idx));\n   do_data_ex(ea, FF_STRU, sz, idx);\n```", "```\ncurloc loc;\nloc.ea = ea; loc.lnnum = lnnum; loc.x = x; loc.y = y;\nloc.mark(slot, NULL, comment);\n```", "```\nint n = segs.get_next_area(ea);\nreturn getnseg (n)->startEA;\n```", "```\nif (base != 0xFFFFFFFF) set_offset(ea, n, base);\nelse noType(ea, n);\n```", "```\nqstring in(input);\nif (in.last() != ';') in += ';';\nflags &#124;= PT_TYP;\nif (flags & PT_NDC) flags &#124;= PT_SIL;\nelse flags &= ~PT_SIL;\nflags &= ~PT_NDC;\nqstring name, type, fields;\nparse_decl(idati, in.c_str(), &name, &type, &fields, flags);\ninternal_build_idc_typeinfo(&result, &type, &fields);\n```", "```\nint hti_flags = (flags & 0x70) << 8;\nif (flags & 1) hti_flags &#124;= HTI_FIL;\nparse_types2(input, (flags & 2) ? NULL : printer_func,\n             hti_flags);\n```", "```\nif (qthread_same(idc_debthread))\n   dbg->write_memory(ea, &value, 1);\nelse\n   put_dbg_byte(ea, value);\n```", "```\ninvalidate_dbgmem_config();\ninvalidate_dbgmem_contents(BADADDR, −1);\nif (dbg && dbg->stopped_at_debug_event)\n   dbg->stopped_at_debug_event(true);\n```", "```\nqsnprintf(buf, sizeof(buf), \"$ idc_array %s\", name);\nnetnode n(id).rename(newname);\n```", "```\nchar *fname = idbname ? idbname : database_idb;\nuint32_t tflags = database_flags;\ndatabase_flags = (flags & 4) &#124; (tflags & 0xfffffffb);\nbool res = save_database(fname, 0);\ndatabase_flags = tflags;\nreturn res;\n```", "```\nsel_t seg;\natos(segname, *seg);\nreturn seg;\n```", "```\nsegment_t *s = (segment_t*) get_seg(ea);\nget_true_segm_name(s, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nea_t ea1, ea2;\nread_selection(&ea1, &ea2);\nreturn ea2;\n```", "```\nea_t ea1, ea2;\nread_selection(&ea1, &ea2);\nreturn ea1;\n```", "```\nsegment_t *s = get_seg(ea);\nif (s)\n   uint32_t format[3];\n   netnode array(ea);\n   format[0] = flags;\n   format[1] = litems;\n   format[2] = align;\n   array.supset(5, format, sizeof(format));\n```", "```\nbpt_t bpt;\nif (get_bpt(ea, &bpt) == 0) return;\nif (bpattr == BPTATTR_SIZE) bpt.size = value;\nelse if (bpattr == BPTATTR_TYPE) bpt.type = value;\nelse if (bpattr == BPTATTR_COUNT) bpt.pass_count = value;\nelse if (bpattr == BPTATTR_FLAGS) bpt.flags = value;\nupdate_bpt(&bpt);\n```", "```\nbpt_t bpt;\nif (get_bpt(ea, &bpt) == 0) return;\nbpt. cndbody = cnd;\nif (is_lowcnd)\n   bpt.flags &#124;= BPT_LOWCND;\nelse\n   bpt.flags &= ~ BPT_LOWCND;\nupdate_bpt(&bpt);\n```", "```\nif (offset >= 13 && offset <= 191)\n   *(offset + (char*)&inf) = value;\n```", "```\nif (what == CIC_ITEM)\n   set_item_color(ea, color);\nelse if (what == CIC_FUNC)\n   func_t *f = get_func(ea);\n   f->color = color;\n   update_func(f);\nelse if (what == CIC_SEGM)\n   segment_t *s = get_seg(ea);\n   s->color = color;\n   s->update();\n```", "```\nexcvec_t *ev = retrieve_exceptions();\nfor (excvec_t::iterator i = ev->begin(); i != ev->end(); i++)\n   if ((*i).code == code)\n      if ((*i).flags == flags)\n         return true;\n      else\n         (*i).flags = flags;\n         return store_exceptions();\nreturn 0;\n```", "```\nfunc_t *f = get_func(ea);\ninternal_set_attr(f, attr, value);\nupdate_func(f);\n```", "```\nfixup_data_t f = {type, targetsel, targetoff, displ};\nset_fixup(ea, &f);\n```", "```\nfunc_t *f = get_func(ea);\ninternal_set_attr(f, attr, value);\n```", "```\nhidden_area_t *ha = get_hidden_area (ea);\nha->visible = visible;\nupdate_hidden_area(ha);\n```", "```\nif (strlen(path) == 0) RootNode.set(\"\");\nelse RootNode.set(path);\n```", "```\nif (input == NULL &#124;&#124; *input == 0)\n   del_numbered_type(idati, ordinal);\nelse\n   qstring name;\n   qtype type, fields;\n   parse_decl(idati, input, &name, &type, &fields, flags);\n   if (ordinal == 0)\n      if (!name.empty())\n         get_named_type(idati, name.c_str(),\n                        NTF_TYPE &#124; NTF_NOBASE, NULL, NULL,\n                        NULL, NULL, NULL, &ordinal);\n         if (!ordinal)\n            ordinal = alloc_type_ordinal(idati);\n   set_numbered_type(idati, value, 0, name.c_str(),\n                     type.c_str(), fields.c_str(),\n                     NULL, NULL, NULL);\n```", "```\nif (offset >= 13 && offset <= 188)\n   *(int*)(offset + (char*)&inf) = value;\n```", "```\nmember_t *m = get_member(get_struc(ea), member_offset);\nset_member_cmt(m, comment, repeatable);\n```", "```\ntypeinfo_t mt;\n//calls an internal function to initialize mt using typeid\nint size =  get_data_elsize(-1, flag, &mt) *  nitems;\nset_member_type(get_struc(id), member_offset, flag, &mt,size);\n```", "```\nregval_t r;\nif (is_reg_integer(name))\n   r.ival = (unsigned int)VarLong(value);\nelse\n   memcpy(r.fval, VarFloat(value), 12);\nset_reg_val(name, &r);\n```", "```\nif (get_seg(ea))\n   set_segm_end(ea, endea, flags);\n   set_segm_end(ea, startea, flags);\n```", "```\nsegment_t *s = get_seg(segea);\ninternal_set_attr(s, attr, value);\ns->update();\n```", "```\nif (offset >= 13 && offset <= 190)\n   *(short*)(offset + (char*)&inf) = value;\n```", "```\napply_cdecl(ea, type)\nif (get_aflags(ea) & AFL_TILCMT)\n   set_ti(ea, \"\", NULL);\n```", "```\n//*** undocumented function (four underscores)\n//returns database creation timestamp\nreturn RootNode.altval(RIDX_ALT_CTIME);\n```", "```\n//*** undocumented function\n//uint32_t _call(uint32_t (*f)())\n//f is a pointer in IDA's (NOT the database's) address space\nreturn (*f)();\n```", "```\n//*** undocumented function\n//uint32_t _lpoke(uint32_t *addr, uint32_t val)\n//addr is an address in IDA's (NOT the database's) address\n//space. This modifies IDA’s address space NOT the database’s\nuint32_t old = *addr;\n*addr = val;\nreturn old;\n```", "```\n//*** undocumented function\n//uint8_t *_peek(uint8_t *addr)\n//addr is in IDA's address space\nreturn *addr;\n```", "```\n//*** undocumented function\n//uint8_t _lpoke(uint8_t *addr, uint8_t val)\n//addr is an address in IDA's (NOT the database's) address\n//space. This modifies IDA's address space NOT the database's\nuint8_t old = *addr;\n*addr = val;\nreturn old;\n```", "```\n//*** undocumented function\nreturn _time64(NULL);\n```", "```\nea2str(ea, buf, sizeof(buf));\nreturn qstrdup(buf);\n```", "```\nidc_value_t res;\nVarGetAttr(self, attr, &res);\nreturn res;\n```", "```\nlinput_t *li = make_linput(handle);\nfile2base(li, pos, ea, ea + size, false);\nunmake_linput(li);\n```", "```\nqstring qs;\nVarPrint(&qs, arg);\nmsg(\"%s\\n\", qs.c_str());\n```", "```\nunsigned int res;\nfreadbytes(handle, &res, 4, mostfirst);\nreturn res;\n```", "```\nunsigned short res;\nfreadbytes(handle, &res, 2, mostfirst);\nreturn res;\n```", "```\nqfgets(buf, sizeof(buf), handle);\nreturn qstrdup(buf);\n```", "```\ntype_t *t = internal_type_from_idc_typeinfo(type);\nreturn get_type_size(idati, t);\n```", "```\nqstring buf;\nbuf.sprnt(format, ...);\nreturn qstrdup(buf.c_str());\n```", "```\nqstring s;\ns.resize(len + 1, &chr);\nreturn new qstring(s);\n```"]