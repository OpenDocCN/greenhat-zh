["```\nstruct disk {\n        /* GEOM Private Data */\n        struct g_geom          *d_geom;\n        struct devstat         *d_devstat;\n        int                     d_destroyed;\n\n        /* Shared Objects */\n        struct bio_queue_head  *d_queue;\n        struct mtx             *d_lock;\n\n        /* Descriptive Fields */\n        const char             *d_name;\n        u_int                   d_unit;\n        u_int                   d_flags;\n\n        /* Storage Device Methods */\n        disk_open_t            *d_open;\n        disk_close_t           *d_close;\n        disk_strategy_t        *d_strategy;\n        disk_ioctl_t           *d_ioctl;\n        dumper_t               *d_dump;\n\n        /* Mandatory Media Properties */\n        u_int                   d_sectorsize;\n        off_t                   d_mediasize;\n        u_int                   d_maxsize;\n\n        /* Optional Media Properties */\n        u_int                   d_fwsectors;\n        u_int                   d_fwheads;\n        u_int                   d_stripesize;\n        u_int                   d_stripeoffset;\n        char                    d_ident[DISK_IDENT_SIZE];\n\n        /* Driver Private Data */\n        void                   *d_drv1;\n};\n```", "```\n#include <geom/geom_disk.h>\n\nstruct disk *\ndisk_alloc(void);\n\nvoid\ndisk_create(struct disk *disk, int version);\n\nvoid\ndisk_destroy(struct disk *disk);\n```", "```\nstruct bio {\n        uint8_t bio_cmd;                /* I/O operation.               */\n        uint8_t bio_flags;              /* General flags.               */\n        uint8_t bio_cflags;             /* Private use by the consumer. */\n        uint8_t bio_pflags;             /* Private use by the provider. */\n\n        struct cdev *bio_dev;           /* Device to perform I/O on.    */\n        struct disk *bio_disk;          /* Disk structure.              */\n        off_t   bio_offset;             /* Requested position in file.  */\n        long    bio_bcount;             /* Number of (valid) bytes.     */\n        caddr_t bio_data;               /* Data.                        */\n        int     bio_error;              /* Error number for BIO_ERROR.  */\n        long    bio_resid;              /* Remaining I/O (in bytes).    */\n        void (*bio_done)(struct bio *); /* biodone() handler function.  */\n\n        void    *bio_driver1;           /* Private use by the provider. */\n        void    *bio_driver2;           /* Private use by the provider. */\n        void    *bio_caller1;           /* Private use by the consumer. */\n        void    *bio_caller2;           /* Private use by the consumer. */\n\n        TAILQ_ENTRY(bio) bio_queue;     /* bioq linkage.                */\n        const char *bio_attribute;      /* For BIO_[GS]ETATTR.          */\n        struct g_consumer *bio_from;    /* GEOM linkage.                */\n        struct g_provider *bio_to;      /* GEOM linkage.                */\n\n        off_t   bio_length;             /* Like bio_bcount.             */\n        off_t   bio_completed;          /* Opposite of bio_resid.       */\n        u_int   bio_children;           /* Number of spawned bios.      */\n        u_int   bio_inbed;              /* Number of children home.     */\n        struct bio *bio_parent;         /* Parent pointer.              */\n        struct bintime bio_t0;          /* Time I/O request started.    */\n\n        bio_task_t *bio_task;   /* bio_taskqueue() handler function.    */\n        void    *bio_task_arg;          /* bio_task's argument.         */\n        void    *bio_classifier1;       /* Classifier tag.              */\n        void    *bio_classifier2;       /* Classifier tag.              */\n\n        daddr_t bio_pblkno;             /* Physical block number.       */\n};\n\n/* Bits for bio_cmd.    */\n#define BIO_READ        0x01\n#define BIO_WRITE       0x02\n#define BIO_DELETE      0x04\n#define BIO_GETATTR     0x08\n#define BIO_FLUSH       0x10\n#define BIO_CMD0        0x20            /* For local hacks.             */\n#define BIO_CMD1        0x40            /* For local hacks.             */\n#define BIO_CMD2        0x80            /* For local hacks.             */\n\n/* Bits for bio_flags.  */\n#define BIO_ERROR       0x01\n#define BIO_DONE        0x02\n#define BIO_ONQUEUE     0x04\n```", "```\n#include <sys/bio.h>\n\nvoid\nbioq_init(struct bio_queue_head *head);\n\nvoid\nbioq_disksort(struct bio_queue_head *head, struct bio *bp);\n\nstruct bio *\nbioq_first(struct bio_queue_head *head);\n\nstruct bio *\nbioq_takefirst(struct bio_queue_head *head);\n\nvoid\nbioq_insert_head(struct bio_queue_head *head, struct bio *bp);\n\nvoid\nbioq_insert_tail(struct bio_queue_head *head, struct bio *bp);\n\nvoid\nbioq_remove(struct bio_queue_head *head, struct bio *bp);\n\nvoid\nbioq_flush(struct bio_queue_head *head, struct devstat *stp, int error);\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/bus.h>\n  #include <sys/conf.h>\n  #include <sys/bio.h>\n  #include <sys/kthread.h>\n  #include <sys/lock.h>\n  #include <sys/mutex.h>\n  #include <geom/geom_disk.h>\n\n  #include <dev/spibus/spi.h>\n  #include \"spibus_if.h\"\n\n  #define MANUFACTURER_ID                 0x9f\n  #define STATUS_REGISTER_READ            0xd7\n  #define CONTINUOUS_ARRAY_READ_HF        0x0b\n  #define PROGRAM_THROUGH_BUFFER          0x82\n\n  struct at45d_softc {\n          device_t                        at45d_dev;\n          struct mtx                      at45d_mtx;\n          struct intr_config_hook         at45d_ich;\n          struct disk                    *at45d_disk;\n          struct bio_queue_head           at45d_bioq;\n          struct proc                    *at45d_proc;\n  };\n\n  static devclass_t at45d_devclass;\n\n  static void                             at45d_delayed_attach(void *);\n  static void                             at45d_task(void *);\n  static void                             at45d_strategy(struct bio *);\n\n  static int\n at45d_probe(device_t dev)\n  {\n          device_set_desc(dev, \"AT45 flash family\");\n          return (BUS_PROBE_SPECIFIC);\n  }\n\n  static int\n  at45d_attach(device_t dev)\n  {\n          struct at45d_softc *sc = device_get_softc(dev);\n          int error;\n\n          sc->at45d_dev = dev;\n          mtx_init(&sc->at45d_mtx, device_get_nameunit(dev), \"at45d\", MTX_DEF);\n\n          sc->at45d_ich.ich_func = at45d_delayed_attach;\n          sc->at45d_ich.ich_arg = sc;\n          error = config_intrhook_establish(&sc->at45d_ich);\n          if (error)\n                  device_printf(dev, \"config_intrhook_establish() failed!\\n\");\n\n          return (0);\n  }\n\n  static int\n at45d_detach(device_t dev)\n  {\n          return (EIO);\n  }\n\n  static int\n  at45d_get_info(device_t dev, uint8_t *r)\n  {\n          struct spi_command cmd;\n          uint8_t tx_buf[8], rx_buf[8];\n          int error;\n\n          memset(&cmd, 0, sizeof(cmd));\n          memset(tx_buf, 0, sizeof(tx_buf));\n          memset(rx_buf, 0, sizeof(rx_buf));\n\n          tx_buf[0] = MANUFACTURER_ID;\n          cmd.tx_cmd = &tx_buf[0];\n          cmd.rx_cmd = &rx_buf[0];\n          cmd.tx_cmd_sz = 5;\n          cmd.rx_cmd_sz = 5;\n          error = SPIBUS_TRANSFER(device_get_parent(dev), dev, &cmd);\n          if (error)\n                  return (error);\n\n          memcpy(r, &rx_buf[1], 4);\n          return (0);\n  }\n\n  static uint8_t\n  at45d_get_status(device_t dev)\n  {\n          struct spi_command cmd;\n          uint8_t tx_buf[8], rx_buf[8];\n\n          memset(&cmd, 0, sizeof(cmd));\n          memset(tx_buf, 0, sizeof(tx_buf));\n          memset(rx_buf, 0, sizeof(rx_buf));\n\n          tx_buf[0] = STATUS_REGISTER_READ;\n          cmd.tx_cmd = &tx_buf[0];\n          cmd.rx_cmd = &rx_buf[0];\n          cmd.tx_cmd_sz = 2;\n          cmd.rx_cmd_sz = 2;\n          SPIBUS_TRANSFER(device_get_parent(dev), dev, &cmd);\n\n          return (rx_buf[1]);\n  }\n\n  static void\n  at45d_wait_for_device_ready(device_t dev)\n  {\n          while ((at45d_get_status(dev) & 0x80) == 0)\n                  continue;\n  }\n\n  static void\n  at45d_delayed_attach(void *arg)\n  {\n          struct at45d_softc *sc = arg;\n          uint8_t buf[4];\n\n          at45d_get_info(sc->at45d_dev, buf);\n          at45d_wait_for_device_ready(sc->at45d_dev);\n\n          sc->at45d_disk = disk_alloc();\n          sc->at45d_disk->d_name = \"at45d\";\n          sc->at45d_disk->d_unit = device_get_unit(sc->at45d_dev);\n          sc->at45d_disk->d_strategy = at45d_strategy;\n          sc->at45d_disk->d_sectorsize = 1056;\n          sc->at45d_disk->d_mediasize = 8192 * 1056;\n          sc->at45d_disk->d_maxsize = DFLTPHYS;\n          sc->at45d_disk->d_drv1 = sc;\n\n          bioq_init(&sc->at45d_bioq);\n          kproc_create(&at45d_task, sc, &sc->at45d_proc, 0, 0, \"at45d\");\n\n          disk_create(sc->at45d_disk, DISK_VERSION);\n          config_intrhook_disestablish(&sc->at45d_ich);\n  }\n\n  static void\n  at45d_strategy(struct bio *bp)\n  {\n          struct at45d_softc *sc = bp->bio_disk->d_drv1;\n\n          mtx_lock(&sc->at45d_mtx);\n          bioq_disksort(&sc->at45d_bioq, bp);\n          wakeup(sc);\n          mtx_unlock(&sc->at45d_mtx);\n  }\n\n  static void\n  at45d_task(void *arg)\n  {\n          struct at45d_softc *sc = arg;\n          struct bio *bp;\n          struct spi_command cmd;\n          uint8_t tx_buf[8], rx_buf[8];\n          int ss = sc->at45d_disk->d_sectorsize;\n          daddr_t block, end;\n          char *vaddr;\n\n          for (;;) {\n                  mtx_lock(&sc->at45d_mtx);\n                  do {\n                          bp = bioq_first(&sc->at45d_bioq);\n                          if (bp == NULL)\n                                  mtx_sleep(sc, &sc->at45d_mtx, PRIBIO,\n                                      \"at45d\", 0);\n                  } while (bp == NULL);\n                  bioq_remove(&sc->at45d_bioq, bp);\n                  mtx_unlock(&sc->at45d_mtx);\n\n                  end = bp->bio_pblkno + (bp->bio_bcount / ss);\n                  for (block = bp->bio_pblkno; block < end; block++) {\n                          vaddr = bp->bio_data + (block - bp->bio_pblkno) * ss;\n                          if (bp->bio_cmd == BIO_READ) {\n                                  tx_buf[0] = CONTINUOUS_ARRAY_READ_HF;\n                                  cmd.tx_cmd_sz = 5;\n                                  cmd.rx_cmd_sz = 5;\n                          } else {\n                                  tx_buf[0] = PROGRAM_THROUGH_BUFFER;\n                                  cmd.tx_cmd_sz = 4;\n                                  cmd.rx_cmd_sz = 4;\n                          }\n\n                          /* FIXME: This works only on certain devices. */\n                          tx_buf[1] = ((block >> 5) & 0xff);\n                          tx_buf[2] = ((block << 3) & 0xf8);\n                          tx_buf[3] = 0;\n                          tx_buf[4] = 0;\n                          cmd.tx_cmd = &tx_buf[0];\n                          cmd.rx_cmd = &rx_buf[0];\n                          cmd.tx_data = vaddr;\n                          cmd.rx_data = vaddr;\n                          cmd.tx_data_sz = ss;\n                          cmd.rx_data_sz = ss;\n                          SPIBUS_TRANSFER(device_get_parent(sc->at45d_dev),\n                              sc->at45d_dev, &cmd);\n                  }\n                  biodone(bp);\n          }\n  }\n\n  static device_method_t at45d_methods[] = {\n          /* Device interface. */\n          DEVMETHOD(device_probe,         at45d_probe),\n          DEVMETHOD(device_attach,        at45d_attach),\n          DEVMETHOD(device_detach,        at45d_detach),\n          { 0, 0 }\n  };\n\n  static driver_t at45d_driver = {\n          \"at45d\",\n          at45d_methods,\n          sizeof(struct at45d_softc)\n  };\n\n  DRIVER_MODULE(at45d, spibus, at45d_driver, at45d_devclass, 0, 0);\n```", "```\nstatic int\nat45d_attach(device_t dev)\n{\n        struct at45d_softc *sc = device_get_softc(dev);\n        int error;\n\n        sc->at45d_dev = dev;\n      mtx_init(&sc->at45d_mtx, device_get_nameunit(dev), \"at45d\",\n            MTX_DEF);\n\n        sc->at45d_ich.ich_func = at45d_delayed_attach;\n        sc->at45d_ich.ich_arg = sc;\n        error = config_intrhook_establish(&sc->at45d_ich);\n        if (error)\n                device_printf(dev, \"config_intrhook_establish() failed!\\n\");\n\n        return (0);\n}\n```", "```\nstatic void\nat45d_delayed_attach(void *arg)\n{\n        struct at45d_softc *sc = arg;\n        uint8_t buf[4];\n\n      at45d_get_info(sc->at45d_dev, buf);\n      at45d_wait_for_device_ready(sc->at45d_dev);\n\n        sc->at45d_disk = disk_alloc();\n        sc->at45d_disk->d_name = \"at45d\";\n        sc->at45d_disk->d_unit = device_get_unit(sc->at45d_dev);\n        sc->at45d_disk->d_strategy = at45d_strategy;\n        sc->at45d_disk->d_sectorsize = 1056;\n        sc->at45d_disk->d_mediasize = 8192 * 1056;\n        sc->at45d_disk->d_maxsize = DFLTPHYS;\n        sc->at45d_disk->d_drv1 = sc;\n\n      bioq_init(&sc->at45d_bioq);\n      kproc_create(&at45d_task, sc, &sc->at45d_proc, 0, 0, \"at45d\");\n\n      disk_create(sc->at45d_disk, DISK_VERSION);\n      config_intrhook_disestablish(&sc->at45d_ich);\n}\n```", "```\nstatic int\nat45d_get_info(device_t dev, uint8_t *r)\n{\n        struct spi_command cmd;\n        uint8_t tx_buf[8], rx_buf[8];\n        int error;\n\n        memset(&cmd, 0, sizeof(cmd));\n      memset(tx_buf, 0, sizeof(tx_buf));\n      memset(rx_buf, 0, sizeof(rx_buf));\n\n      tx_buf[0] = MANUFACTURER_ID;\n      cmd.tx_cmd = &tx_buf[0];\n      cmd.rx_cmd = &rx_buf[0];\n      cmd.tx_cmd_sz = 5;\n      cmd.rx_cmd_sz = 5;\n        error = SPIBUS_TRANSFER(device_get_parent(dev), dev, &cmd);\n        if (error)\n                return (error);\n\n      memcpy(r, &rx_buf[1], 4);\n        return (0);\n}\n```", "```\nstatic void\nat45d_wait_for_device_ready(device_t dev)\n{\n        while ((at45d_get_status(dev) & 0x80) == 0)\n                continue;\n}\n```", "```\nstatic uint8_t\nat45d_get_status(device_t dev)\n{\n        struct spi_command cmd;\n        uint8_t tx_buf[8], rx_buf[8];\n\n        memset(&cmd, 0, sizeof(cmd));\n        memset(tx_buf, 0, sizeof(tx_buf));\n        memset(rx_buf, 0, sizeof(rx_buf));\n\n      tx_buf[0] = STATUS_REGISTER_READ;\n        cmd.tx_cmd = &tx_buf[0];\n        cmd.rx_cmd = &rx_buf[0];\n        cmd.tx_cmd_sz = 2;\n        cmd.rx_cmd_sz = 2;\n        SPIBUS_TRANSFER(device_get_parent(dev), dev, &cmd);\n\n        return (rx_buf[1]);\n}\n```", "```\nstatic void\nat45d_strategy(struct bio *bp)\n{\n        struct at45d_softc *sc = bp->bio_disk->d_drv1;\n\n        mtx_lock(&sc->at45d_mtx);\n      bioq_disksort(&sc->at45d_bioq, bp);\n      wakeup(sc);\n        mtx_unlock(&sc->at45d_mtx);\n}\n```", "```\nstatic void\nat45d_task(void *arg)\n{\n        struct at45d_softc *sc = arg;\n        struct bio *bp;\n        struct spi_command cmd;\n        uint8_t tx_buf[8], rx_buf[8];\n        int ss = sc->at45d_disk->d_sectorsize;\n        daddr_t block, end;\n        char *vaddr;\n\n        for (;;) {\n                mtx_lock(&sc->at45d_mtx);\n                do {\n                        bp = bioq_first(&sc->at45d_bioq);\n                        if (bp == NULL)\n                              mtx_sleep(sc, &sc->at45d_mtx, PRIBIO,\n                                    \"at45d\", 0);\n                } while (bp == NULL);\n              bioq_remove(&sc->at45d_bioq, bp);\n                mtx_unlock(&sc->at45d_mtx);\n\n                end = bp->bio_pblkno + (bp->bio_bcount / ss);\n                for (block = bp->bio_pblkno; block < end; block++) {\n                      vaddr = bp->bio_data +\n                            (block - bp->bio_pblkno) * ss;\n                      if (bp->bio_cmd == BIO_READ) {\n                                tx_buf[0] = CONTINUOUS_ARRAY_READ_HF;\n                                cmd.tx_cmd_sz = 5;\n                                cmd.rx_cmd_sz = 5;\n                      } else {\n                                tx_buf[0] = PROGRAM_THROUGH_BUFFER;\n                                cmd.tx_cmd_sz = 4;\n                                cmd.rx_cmd_sz = 4;\n                        }\n\n                        /* FIXME: This works only on certain devices. */\n                        tx_buf[1] = ((block >> 5) & 0xff);\n                        tx_buf[2] = ((block << 3) & 0xf8);\n                        tx_buf[3] = 0;\n                        tx_buf[4] = 0;\n                        cmd.tx_cmd = &tx_buf[0];\n                        cmd.rx_cmd = &rx_buf[0];\n                        cmd.tx_data = vaddr;\n                        cmd.rx_data = vaddr;\n                        cmd.tx_data_sz = ss;\n                        cmd.rx_data_sz = ss;\n                      SPIBUS_TRANSFER(device_get_parent(sc->at45d_dev),\n                            sc->at45d_dev, &cmd);\n                }\n              biodone(bp);\n        }\n}\n```", "```\n#include <sys/bio.h>\n\nvoid\nbiodone(struct bio *bp);\n\nvoid\nbiofinish(struct bio *bp, struct devstat *stat, int error);\n```"]