- en: Chapter 3. VIEWING FLOWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。查看流
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages651574.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages651574.png.jpg)'
- en: You have sensors transmitting data, and your collector is writing that data
    to disk. Now what? Flow-tools provides several programs for viewing flow data,
    generating statistical analysis, and generating reports. You'll start by displaying
    the data in the flow files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你有传感器正在传输数据，你的收集器正在将数据写入磁盘。现在怎么办？Flow-tools 提供了几个程序来查看流数据、生成统计分析以及生成报告。你将从显示流文件中的数据开始。
- en: Using flow-print
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 flow-print
- en: Flow files contain tightly packed binary data, and viewing a flow file with
    `cat` or `more` will scramble your terminal. To view flow data, you should use
    `flow-print`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 流文件包含紧密打包的二进制数据，使用 `cat` 或 `more` 查看流文件会打乱你的终端。要查看流数据，你应该使用 `flow-print`。
- en: Each flow file contains header information that identifies the host that exported
    the data, the capture time, and so on. When you need to view multiple flow files,
    you should strip out these headers before feeding the data to `flow-print` so
    that they don't interfere with your viewing of the actual flow data. That's where
    `flow-cat` comes in. You'll use `flow-cat` to concatenate multiple flow files
    and present clean data to `flow-print`. Although using `flow-cat` is optional,
    I recommend that you always use it with `flow-print` unless you are specifically
    examining header data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个流文件都包含标识导出数据的宿主、捕获时间等信息。当你需要查看多个流文件时，你应该在将数据传递给 `flow-print` 之前删除这些标题，以免干扰你查看实际流数据。这就是
    `flow-cat` 的作用。你将使用 `flow-cat` 来连接多个流文件，并将干净的数据呈现给 `flow-print`。虽然使用 `flow-cat`
    是可选的，但我建议你始终与 `flow-print` 一起使用，除非你专门检查标题数据。
- en: To examine a flow file, use `flow-cat` to feed the data to `flow-print`, and
    then pipe the result to a pager so that you can view all of the results, as shown
    in [Example 3-1](ch03.html#sample_flow-print_output "Example 3-1. Sample flow-print
    output").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查流文件，使用 `flow-cat` 将数据传递给 `flow-print`，然后将结果传递给分页器，以便你可以查看所有结果，如 [示例 3-1](ch03.html#sample_flow-print_output
    "示例 3-1. 样本 flow-print 输出") 所示。
- en: Example 3-1. Sample flow-print output
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-1. 样本 flow-print 输出
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each line in [Example 3-1](ch03.html#sample_flow-print_output "Example 3-1. Sample
    flow-print output") represents one flow. The first column, `srcIP`, shows the
    source IP address of the flow, and the second (`dstIP`) shows the destination
    address.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](ch03.html#sample_flow-print_output "示例 3-1. 样本 flow-print 输出") 中的每一行代表一个流。第一列
    `srcIP` 显示流的源 IP 地址，第二列（`dstIP`）显示目标地址。'
- en: The `prot` column displays the protocol number for this flow. Protocol 17 is
    UDP, and protocol 6 is TCP. ([Table 3-1](ch03.html#common_protocol_numbers "Table 3-1. Common
    Protocol Numbers") in [Common Protocol and Port Number Assignments](ch03.html#common_protocol_and_port_number_assignme
    "Common Protocol and Port Number Assignments") describes the protocols most commonly
    seen on a network, and you'll find a mostly complete list of these protocols numbers
    in the */etc/protocols* file on your collector server.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`prot` 列显示此流的协议号。协议 17 是 UDP，协议 6 是 TCP。([表 3-1](ch03.html#common_protocol_numbers
    "表 3-1. 常见协议号") 在 [常见协议和端口号分配](ch03.html#common_protocol_and_port_number_assignme
    "常见协议和端口号分配") 中描述了网络上最常见的协议，你将在你的收集器服务器上的 */etc/protocols* 文件中找到这些协议号的完整列表。）'
- en: The `srcPort` column shows the source port of a TCP or UDP flow, and `dstPort`
    shows the destination port. Finally, the `octets` column shows the number of bytes
    in the flow, and `packets` shows the number of packets in the flow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`srcPort` 列显示 TCP 或 UDP 流的源端口，`dstPort` 显示目标端口。最后，`octets` 列显示流中的字节数，`packets`
    显示流中的数据包数。'
- en: The first flow in [Example 3-1](ch03.html#sample_flow-print_output "Example 3-1. Sample
    flow-print output") comes from the address 36.85.32.9\. This is an address on
    my network that's going to the IP 158.43.192.1\. Off the top of my head, I haven't
    the foggiest idea what this address is or why I'm communicating with it, but I
    do know that protocol 17 is UDP, the source port is 2325, and the destination
    port is 53\. Port 53 is the UDP port reserved for DNS transactions, so I know
    that this flow represents a DNS query, and I also know from the `octets` column
    that 59 bytes were sent in one packet.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](ch03.html#sample_flow-print_output "示例 3-1. 样例流量打印输出")中的第一个流量来自地址
    36.85.32.9。这是我的网络上的一个地址，它将数据发送到 IP 158.43.192.1。据我所知，我对这个地址一无所知，也不知道为什么我会与它通信，但我确实知道协议
    17 是 UDP，源端口是 2325，目标端口是 53。端口 53 是为 DNS 事务保留的 UDP 端口，所以我知道这个流量代表了一个 DNS 查询，而且我也知道从“八位字节”列中，一个数据包发送了
    59 字节。'
- en: 'Now look at the second flow in [Example 3-1](ch03.html#sample_flow-print_output
    "Example 3-1. Sample flow-print output"). Notice that the source and destination
    IP addresses are reversed from our first flow: The remote end sent data from port
    53 to port 2325 on my end, which is the reverse of the first flow. The response,
    134 bytes in one packet, is almost certainly a DNS response to the query sent
    in the first flow, but I''d need to view the timing information to be absolutely
    certain.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看[示例 3-1](ch03.html#sample_flow-print_output "示例 3-1. 样例流量打印输出")中的第二个流量。注意，源和目标
    IP 地址与我们的第一个流量相反：远程端从端口 53 发送数据到我的端口 2325，这与第一个流量相反。响应，一个数据包 134 字节，几乎肯定是对第一个流量中发送的查询的
    DNS 响应，但为了绝对确定，我需要查看时间信息。
- en: 'The third flow in [Example 3-1](ch03.html#sample_flow-print_output "Example 3-1. Sample
    flow-print output") originates from a different IP on my network and is going
    to a different remote IP than either of the IPs in the first two flows. This flow
    represents a TCP/IP transaction that is separate and different from the first
    two flows. This transaction runs over protocol 6 (or TCP) and has a source port
    of 25 and a destination port of 4115\. That''s odd. TCP port 25 is used for SMTP,
    or email. You would expect an email connection to be *to* port 25, not *from*
    port 25\. Why would a network transaction have a *source* port of 25? Remember,
    every network transaction includes two flows: one from the client to the server
    and another from the server to the client. This "source port 25" flow is the server''s
    communication to the client.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种流量来自[示例 3-1](ch03.html#sample_flow-print_output "示例 3-1. 样例流量打印输出")中的不同 IP，并且将数据发送到与前两种流量中的任何一个
    IP 都不同的远程 IP。这种流量代表了一个与前面两种流量分开且不同的 TCP/IP 事务。这个事务运行在协议 6（或 TCP）上，源端口为 25，目标端口为
    4115。这很奇怪。TCP 端口 25 用于 SMTP，或电子邮件。你可能会期望电子邮件连接是*到*端口 25，而不是*从*端口 25。为什么网络事务会有一个*源*端口为
    25？记住，每个网络事务都包括两个流量：一个是从客户端到服务器，另一个是从服务器到客户端。这个“源端口 25”的流量是服务器与客户端的通信。
- en: Now look at the fourth and final flow. This flow is the reverse of the third
    flow and represents the other half of that SMTP transaction. The source port is
    4115, and the destination is 25, which makes sense if someone is trying to send
    mail to the email server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看第四个也是最后一个流量。这个流量是第三个流量的反向，代表了那个 SMTP 事务的另一部分。源端口是 4115，目标端口是 25，如果有人试图向电子邮件服务器发送邮件，这是有意义的。
- en: As these last two lines demonstrate, `flow-print` does not necessarily print
    flows in the order in which the traffic occurred. For example, if two hosts have
    very fast connectivity to each other, the flow record might show both the flow
    that initiates a connection and the flow that is the response to that connection
    request as starting simultaneously. In that case, `flow-print` displays the flows
    in the order in which they are recorded in the flow file. (We'll extract actual
    timing data from flow files later.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如这两行所示，`flow-print` 并不一定按照流量发生的顺序打印流量。例如，如果两个主机之间有非常快的连接性，流量记录可能会显示同时启动的连接流量和响应该连接请求的流量。在这种情况下，`flow-print`
    会按照它们在流量文件中记录的顺序显示流量。（我们稍后会从流量文件中提取实际的时间数据。）
- en: BITS, BYTES, AND OCTETS
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 位、字节和八位字节
- en: Most network management systems offer information about traffic in some multiple
    of bits—kilobits, megabits, and so on, all in base 10\. However, some flow analysis
    systems, such as flow-tools, offer traffic information in *octets*, rather than
    bits or even bytes, because the byte is not always 8 bits.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络管理系统以比特的某个倍数（千比特、兆比特等）提供有关流量的信息，所有这些都在十进制基数下。然而，一些流量分析系统，如 flow-tools，提供以
    *八进制* 为单位的流量信息，而不是比特甚至字节，因为字节并不总是8比特。
- en: Most computing professionals know a byte as 8 bits. But *very* strictly speaking,
    most computer professionals are wrong. A byte is the smallest unit of memory addressing
    on a particular hardware platform. The Intel 8086 CPU and its descendants, today's
    most common machines, have an 8-bit byte, which many other platforms adopted as
    a convenient standard. Commercially available hardware exists with bytes anywhere
    from 5 to 12 bits, and experimental hardware can have bytes of just about any
    size.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算专业人士都知道字节是8比特。但 *非常* 严格地说，大多数计算机专业人士是错误的。字节是在特定硬件平台上内存寻址的最小单位。英特尔 8086
    CPU 及其后续产品，今天最常见的机器，拥有8比特的字节，许多其他平台将其作为方便的标准。市面上可用的硬件的字节大小从5比特到12比特不等，实验性硬件的字节大小几乎可以是任何大小。
- en: An octet is always eight bits, the same size as the normal byte. If you have
    systems where a byte is not 8 bits, the word *byte* is ambiguous. Some software,
    such as flow-tools, explicitly uses octets for disambiguation because almost all
    network administrators only have hardware with 8-bit bytes. (Most of us don't
    have odd hardware.) You just need to recognize octets when you see them and be
    grateful that some network administrators suffer from annoyances you'll never
    need to cope with.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制总是8比特，与正常字节的大小相同。如果你有字节不是8比特的系统，单词 *字节* 是模糊的。一些软件，如 flow-tools，明确使用八进制进行区分，因为几乎所有网络管理员都只有8比特字节的硬件。（我们大多数人没有奇数硬件。）你只需在看到八进制时识别它们，并感激一些网络管理员遭受的烦恼是你永远不需要应对的。
- en: Printing Protocol and Port Names
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印协议和端口号名称
- en: 'You probably remember that port 53 is for the Domain Name System, and port
    25 is for email''s SMTP protocol, but most of us haven''t memorized the purpose
    of every port number. Similarly, you might remember that protocol 6 is TCP and
    17 is UDP, but you can''t bother memorizing all the other protocol numbers. The
    files */etc/protocols* and */etc/services* list port numbers and their associated
    names. Use the `-n` flag to have `flow-print` display ports and protocols using
    these names, as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得端口号53是用于域名系统，端口号25是用于电子邮件的SMTP协议，但大多数人并没有记住每个端口号的用途。同样，你可能记得协议号6是TCP，17是UDP，但你不必费心记住所有其他协议号。文件
    */etc/protocols* 和 */etc/services* 列出了端口号及其相关名称。使用 `-n` 标志让 `flow-print` 使用这些名称显示端口和协议，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are the same results as in [Example 3-1](ch03.html#sample_flow-print_output
    "Example 3-1. Sample flow-print output"), except that in the `prot` column `tcp`
    replaces 6 and `udp` replaces 17\. Similarly, the numbers in the `srcPort` and
    `dstPort` columns have been replaced with service names such as `domain` and `smtp`.
    While using names for port numbers is reasonable, using hostnames instead of IP
    addresses introduces a dependency on the network. Also, getting hostnames for
    hundreds or thousands of IP addresses can take a very long time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果与 [示例 3-1](ch03.html#sample_flow-print_output "示例 3-1. 样本 flow-print 输出")
    相同，只是在 `prot` 列中 `tcp` 替换了6，`udp` 替换了17。同样，`srcPort` 和 `dstPort` 列中的数字已被替换为服务名称，如
    `domain` 和 `smtp`。虽然使用端口号的名称是合理的，但使用主机名而不是IP地址引入了对网络的依赖。此外，获取数百或数千个IP地址的主机名可能需要非常长的时间。
- en: Not all `flow-print` formats support output with names, however. In those output
    formats, `flow-print` ignores the `-n` flag.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有 `flow-print` 格式都支持以名称输出。在这些输出格式中，`flow-print` 会忽略 `-n` 标志。
- en: Common Protocol and Port Number Assignments
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见协议和端口号分配
- en: Once you've worked with flow information for a while, you'll begin to recognize
    port and protocol numbers automatically. [Table 3-1](ch03.html#common_protocol_numbers
    "Table 3-1. Common Protocol Numbers") lists some protocols you'll commonly see
    on the Internet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你与流量信息工作了一段时间，你将开始自动识别端口号和协议号。[表 3-1](ch03.html#common_protocol_numbers "表
    3-1. 常见协议号") 列出了一些你将在互联网上常见到的协议。
- en: Table 3-1. Common Protocol Numbers
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1. 常见协议号
- en: '| Number | Protocol |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 号码 | 协议 |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Internet Control Message Protocol (ICMP) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 因特网控制消息协议 (ICMP) |'
- en: '| 6 | Transmission Control Protocol (TCP) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 传输控制协议 (TCP) |'
- en: '| 17 | User Datagram Protocol (UDP) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 用户数据报协议 (UDP) |'
- en: '| 47 | Generic Routing Encapsulation (GRE) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 47 | 通用路由封装 (GRE) |'
- en: '| 50 | Encapsulating Security Payload (ESP) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 封装安全载荷 (ESP) |'
- en: '| 51 | Authentication Header (AH) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 51 | 认证头部 (AH) |'
- en: Similarly, [Table 3-2](ch03.html#common_tcp_and_udp_port_assignments "Table 3-2. Common
    TCP and UDP Port Assignments") lists a few of the commonly used TCP and UDP port
    assignments on internal and public networks. (For a more complete list, see */etc/services*
    on your collector host.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，[表 3-2](ch03.html#common_tcp_and_udp_port_assignments "表 3-2. 常用 TCP 和 UDP
    端口分配") 列出了内部和公共网络上常用的一些 TCP 和 UDP 端口分配。（对于更完整的列表，请参阅您的收集器主机上的 */etc/services*。）
- en: Table 3-2. Common TCP and UDP Port Assignments
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2. 常用 TCP 和 UDP 端口分配
- en: '| Number | Service |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 编号 | 服务 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 20 | File Transfer Protocol (FTP) data channel |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 文件传输协议 (FTP) 数据通道 |'
- en: '| 21 | File Transfer Protocol (FTP) control channel |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 文件传输协议 (FTP) 控制通道 |'
- en: '| 22 | Secure Shell (SSH) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 安全壳 (SSH) |'
- en: '| 23 | Telnet |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 23 | Telnet |'
- en: '| 25 | Email (SMTP) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 电子邮件（SMTP）|'
- en: '| 53 | Domain Name Service (DNS) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 53 | 域名系统 (DNS) |'
- en: '| 80 | Hypertext Transfer Protocol (HTTP, Web) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 80 | 超文本传输协议 (HTTP，Web) |'
- en: '| 137 | NetBIOS Naming Service (Windows file sharing) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 137 | NetBIOS 命名服务（Windows 文件共享）|'
- en: '| 138 | NetBIOS Datagram Service (Windows file sharing) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 138 | NetBIOS 数据报服务（Windows 文件共享）|'
- en: '| 139 | NetBIOS Session Service (Windows file sharing) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 139 | NetBIOS 会话服务（Windows 文件共享）|'
- en: '| 161 | Simple Network Management Protocol (SNMP) |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 161 | 简单网络管理协议 (SNMP) |'
- en: '| 389 | Lightweight Directory Access Protocol (LDAP) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 389 | 轻量级目录访问协议 (LDAP) |'
- en: '| 443 | Secure HTTP (HTTPS) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 443 | 安全超文本传输协议 (HTTPS) |'
- en: '| 445 | SMB over TCP (Windows file sharing) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 445 | 基于 TCP 的 SMB（Windows 文件共享）|'
- en: 'You''ll find many more ports than this in use, of course, and if you find that
    a port isn''t in this list or in */etc/services*, an Internet search should identify
    it. Some ports will stubbornly resist identification from the network, though:
    Some program on the host is using that port, and you''ll need to use that host''s
    native tools to identify that program.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您会发现更多这样的端口正在使用中，如果您发现某个端口不在这个列表中或不在 */etc/services* 中，进行网络搜索应该可以识别它。尽管有些端口会顽强地抵抗网络识别：主机上的某个程序正在使用该端口，您需要使用该主机的本地工具来识别该程序。
- en: PORTS VS. SERVICES
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 端口与服务的比较
- en: Always remember that a port assignment is not conclusive proof that a particular
    protocol is running over that port. A systems administrator can run any program
    on any port. For example, you can run a web server on port 25 (email) or an FTP
    server on port 443 (HTTPS). One of my servers runs SSH on ports 23, 25, 53, 80,
    443, and more, which lets me evade most simple packet-filtering firewalls. If
    you discover suspicious traffic, such as very long TCP-based DNS requests, remember
    that users are tricky little buggers and will try just about anything to evade
    your access controls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，端口分配并不能作为特定协议在该端口运行的结论性证据。系统管理员可以在任何端口上运行任何程序。例如，您可以在端口 25（电子邮件）上运行 Web
    服务器或在端口 443（HTTPS）上运行 FTP 服务器。我的一个服务器在端口 23、25、53、80、443 等上运行 SSH，这让我可以绕过大多数简单的数据包过滤防火墙。如果您发现可疑流量，例如非常长的基于
    TCP 的 DNS 请求，请记住，用户是狡猾的小东西，他们会尝试各种方法来规避您的访问控制。
- en: Viewing Flow Record Header Information with -p
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 -p 查看流记录头部信息
- en: Each flow file includes header data that records the collector hostname, timing
    and compression information, and other capture data. The `-p` flag prints the
    header information from a flow file before any of the flows to make it easier
    for you to identify the sensor host, start and stop time of a flow, how long a
    flow ran, how many flows `flow-capture` believes were lost in transit, and so
    on. This flow data is not frequently useful, but you can see it if you think it
    might help.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个流文件都包含头部数据，记录收集器主机名、时间信息和压缩信息，以及其他捕获数据。`-p` 标志会在任何流之前打印流文件的头部信息，以便您更容易地识别传感器主机、流的开始和停止时间、流的运行时长、`flow-capture`
    认为在传输中丢失的流数量等。这些流数据并不常用，但如果您认为它们可能有所帮助，您可以看到它们。
- en: Remember, `flow-cat` specifically strips out this header data to avoid confusing
    other flow tools, which means that you can only effectively examine the headers
    of one flow file at a time, and you cannot use `flow-cat`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`flow-cat` 会特别移除这些头部数据以避免混淆其他流工具，这意味着您一次只能有效地检查一个流文件的头部，并且不能使用 `flow-cat`。
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Printing to a Wide Terminal
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印到宽终端
- en: Many flow-print reports contain a lot of information and as such don't have
    very much whitespace between columns. The `-w` flag tells `flow-print` that you
    have a wide terminal, so it can add extra space between the columns to make the
    output easier to read. If you have a very wide terminal, however, I suggest you
    look at format 5 instead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多`flow-print`报告包含大量信息，因此列与列之间的空白不多。`-w`标志告诉`flow-print`你有宽终端，因此它可以在列之间添加额外的空间，以便更容易阅读输出。然而，如果你有一个非常宽的终端，我建议你查看格式5。
- en: FLAGS AND CONTROL BITS
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 标志位与控制位
- en: The TCP protocol includes *flags*, also known as *control bits*. `flow-print`
    provides the flags field for TCP flows, but this field is meaningless for other
    protocols. I'll call TCP flags by the name *control bits* to be consistent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TCP协议包括*标志位*，也称为*控制位*。`flow-print`提供了TCP流的标志位字段，但这个字段对其他协议来说没有意义。我将用*控制位*这个名字来保持一致性。
- en: Setting flow-print Formats with -f
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`-f`设置`flow-print`格式
- en: Because the default `flow-print` output might not include all the information
    you're interested in (and it certainly doesn't include all the information included
    within a flow file), `flow-print` supports a wide variety of output formats. You
    set the `flow-print` format with the `-f` flag.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认的`flow-print`输出可能不会包含你感兴趣的所有信息（而且它当然不会包含流文件中包含的所有信息），`flow-print`支持多种输出格式。你可以使用`-f`标志来设置`flow-print`的格式。
- en: Each format has a number. For example, format 3 is the default format most commonly
    used by `flow-print`. (If you are using NetFlow version 8, `flow-print` might
    choose a different default.) You can use these format options to present flow
    data in the manner that best suits you, as demonstrated in the following examples.
    I'll cover only the most useful ones, but you can learn about the other formats
    in the `flow-print` man page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个格式都有一个数字。例如，格式3是`flow-print`最常用的默认格式。（如果你使用NetFlow版本8，`flow-print`可能会选择不同的默认格式。）你可以使用这些格式选项以最适合你的方式展示流数据，如下面的示例所示。我将只介绍最有用的那些，但你可以在`flow-print`的man页面上了解其他格式。
- en: Showing Interfaces and Ports in Hex with Format -f 0
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用格式`-f 0`显示接口和端口的十六进制表示
- en: 'If you want to view the router interfaces the flows passed through, use format
    0, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看流经过的路由器接口，请使用格式0，如下所示：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Much of this output looks the same as the default output, but notice the addition
    of the `Sif` and `Dif` columns. These represent the source (`Sif`) and destination
    (`Dif`) interfaces. Flow records include information on which interface a packet
    entered on and which interface the flow departed on. You can match these to router
    interfaces, as you'll see in [Chapter 4](ch04.html "Chapter 4. FILTERING FLOWS")
    ([Identifying Interface Numbers Using SNMP](ch04s02.html#identifying_interface_numbers_using_snmp
    "Identifying Interface Numbers Using SNMP") in [Identifying Interface Numbers
    Using SNMP](ch04s02.html#identifying_interface_numbers_using_snmp "Identifying
    Interface Numbers Using SNMP")).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分输出看起来与默认输出几乎相同，但请注意增加了`Sif`和`Dif`列。这些代表源（`Sif`）和目的（`Dif`）接口。流记录包括有关数据包进入哪个接口以及流离开哪个接口的信息。你可以将这些与路由器接口匹配，正如你将在[第4章](ch04.html
    "第4章。流过滤")([使用SNMP识别接口号](ch04s02.html#identifying_interface_numbers_using_snmp
    "使用SNMP识别接口号"))中看到的。（在[使用SNMP识别接口号](ch04s02.html#identifying_interface_numbers_using_snmp
    "使用SNMP识别接口号")中）。
- en: However, software flow sensors do *not* record interface information because
    they cannot access it. Software-based sensors listen to a monitor port on a switch,
    but they can't see interface information. The interface number is always 0 as
    far as they're concerned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，软件流传感器*不会*记录接口信息，因为它们无法访问。基于软件的传感器监听交换机上的监控端口，但它们看不到接口信息。对它们来说，接口号始终是0。
- en: Format `0` adds interface numbers to the flow output by compressing some of
    the other columns. The protocol column is now `Pr`, for example. But take a look
    at the numbers. The first flow is protocol 11 (or Network Voice Protocol per */etc/protocols*),
    the source port is 915, and the destination port is 35\. You're almost certainly
    not running NVP on your network! What's going on here?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 格式`0`通过压缩其他一些列将接口号添加到流输出中。例如，协议列现在是`Pr`。但看看这些数字。第一个流是协议11（或根据`/etc/protocols`的“网络语音协议”），源端口是915，目的端口是35。你几乎肯定不会在你的网络上运行NVP！这里发生了什么？
- en: What's happening is that this format creates space for interface numbers by
    printing port and protocol information in hexadecimal. For example, 11 is hex
    for 17, or UDP; 915 is hex for 2325; and 35 is hex for 53\. As it turns out, all
    four of these flows are exactly the same flows shown in the earlier examples,
    just printed in hex and with the interface column added.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是这个格式通过以十六进制形式打印端口和协议信息来为接口编号留出空间。例如，11是17的十六进制，或UDP；915是2325的十六进制；35是53的十六进制。结果，这四个流与前面示例中显示的流完全相同，只是以十六进制形式打印，并增加了接口列。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Printing the port numbers in hex is useful if you're looking at ICMP flows.
    If you're looking at TCP or UDP flows with ports and interfaces on something other
    than an old 80-column terminal, use the 132-column format instead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在查看ICMP流，以十六进制形式打印端口号是有用的。如果你在查看带有端口和接口的TCP或UDP流，而这些端口和接口不在老式的80列终端上，请使用132列格式。
- en: Two Lines with Times, Flags, and Hex Ports Using -f 1
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `-f 1` 选项，两行显示时间、标志和十六进制端口
- en: 'There is a better way to show all the information for a flow on a standard-width
    screen: Split each flow across two lines. Use format `1` to see interface information
    and times as well.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的方法可以在标准宽度的屏幕上显示流的所有信息：将每个流分成两行。使用格式 `1` 来查看接口信息和时间。
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These are the same flows that have appeared in all preceding examples, but
    they look very different. Each flow is shown on two lines, with a blank line separating
    individual flows. In addition, the entries on each line are slightly offset. This
    two-line format can be confusing at first glance, especially because it doesn''t
    have actual columns: The header shows where information appears within each flow''s
    two-line entry. The first line of each flow shows the source interface, source
    IP address, destination interface, destination IP address, protocol, source and
    destination ports, number of packets, and number of octets in the flow. (You''ve
    seen all of these before.) Take a moment to see how these appear in each of the
    four sample flows, and then you can look at the new items in the second line of
    each flow.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流与前面所有示例中出现的流相同，但看起来非常不同。每个流都在两行中显示，用空白行分隔单个流。此外，每行的条目略有偏移。这种两行格式一开始可能会让人困惑，尤其是因为它没有实际的列：标题显示了信息在每个流的两个行条目中的位置。每个流的第1行显示了源接口、源IP地址、目的接口、目的IP地址、协议、源和目的端口、数据包数量以及流中的字节数。（你之前都见过这些。）花点时间看看这些在四个样本流中的显示方式，然后你可以查看每个流第二行的新条目。
- en: 'The `StartTime` and `EndTime` spaces give the time that a connection started
    and ended. Here, at ❶, `1201` represents the date, December 1\. The next three
    values give the time in 24-hour-clock format: `17:09:46` is 5:09:46 **pm**. The
    last fraction is the millisecond the flow began, or `.750` seconds. (If you need
    more precision than this, you''re probably trying to solve the wrong problem.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartTime` 和 `EndTime` 空间给出了连接开始和结束的时间。在这里，❶处的 `1201` 代表日期，12月1日。接下来的三个值以24小时制给出时间：`17:09:46`
    是下午5:09:46。最后的分数是流开始时的毫秒数，或 `.750` 秒。（如果你需要比这更高的精度，你可能是在试图解决错误的问题。）'
- en: The `Active` column gives the number of seconds the flow was active, saving
    you the trouble of subtracting the `StartTime` from the `EndTime` (which would
    be easy with the first two flows but slightly more difficult as the flows grow
    longer).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Active` 列给出了流活跃的秒数，这样你就不必从 `EndTime` 减去 `StartTime`（对于前两个流来说很容易，但随着流的增长会稍微困难一些）。'
- en: The `B/Pk` space gives the average number of bytes per packet. The first flow
    had 59 bytes in 1 packet, so the math is pretty easy, but it's more difficult
    in larger flows. The third flow at ❷ averaged 73 bytes per packet, while the fourth
    at ❸ averaged 127 bytes per packet.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`B/Pk` 空间表示每包的平均字节数。第一个流在1个数据包中有59字节，所以计算很简单，但在更大的流中会更困难。第三个流在❷的平均每包73字节，而第四个流在❸的平均每包127字节。'
- en: The `Ts` space gives the Type of Service (ToS), which is almost always `00`
    because most TCP/IP networks do not have to respect the ToS flag. Generally, a
    ToS in a packet indicates either that you're on an experimental network, that
    you're using complicated services such as VoIP or MPLS, or that someone is playing
    silly twits.^([[4](#ftn.CHP-3-FN-1)])
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ts` 空间表示服务类型（ToS），这几乎总是 `00`，因为大多数TCP/IP网络不需要尊重ToS标志。通常，数据包中的ToS表示你在一个实验性网络中，或者你正在使用复杂的如VoIP或MPLS等服务，或者有人在玩愚蠢的小把戏。[^([4](#ftn.CHP-3-FN-1))]'
- en: The `Fl` space gives the flow's flags, the TCP control bits. Non-TCP flows,
    such as the first two, always show flags of zero. The third and fourth examples
    are TCP flows, and the flags are shown as `1b` for both. See [TCP Control Bits
    and Flow Records](ch03s03.html "TCP Control Bits and Flow Records") in [TCP Control
    Bits and Flow Records](ch03s03.html "TCP Control Bits and Flow Records") to learn
    how to transform `1b` into a meaningful value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fl`空间给出流的标志，即TCP控制位。非TCP流，如前两个，总是显示为零的标志。第三和第四个示例是TCP流，标志显示为`1b`。参见[TCP控制位和流记录](ch03s03.html
    "TCP控制位和流记录")以了解如何将`1b`转换为有意义的值。'
- en: Printing BGP Information
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印BGP信息
- en: Routers that speak Border Gateway Protocol (BGP) with multiple upstream ISPs
    transmit flow records that contain autonomous system numbers (ASNs). Format 4
    prints this information instead of the port numbers. Otherwise, this format includes
    the usual source and destination addresses, protocol, octets, and packet information
    you've seen in other formats.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与多个上游ISP使用边界网关协议（BGP）的路由器传输包含自治系统编号（ASNs）的流记录。格式4打印这些信息而不是端口号。否则，这个格式包括你在其他格式中看到的通常的源和目的地址、协议、字节数和包信息。
- en: 'These are the same four flows used in [Example 3-1](ch03.html#sample_flow-print_output
    "Example 3-1. Sample flow-print output"), displayed in format 4:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是[示例3-1](ch03.html#sample_flow-print_output "示例3-1. 样本流打印输出")中使用的相同四个流，以格式4显示：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note in the previous listing that either the source (`srcAS`) or destination
    AS (`dstAS`) for each flow is 0\. These flows are sourced locally. Flow sensors
    don't track your local AS.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的列表中，每个流的源（`srcAS`）或目的AS（`dstAS`）都是0。这些流是本地生成的。流传感器不跟踪你的本地AS。
- en: If you're not using BGP, this format is irrelevant to you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用BGP，这个格式对你来说无关紧要。
- en: Wide-Screen Display
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宽屏显示
- en: If you have a sufficiently wide monitor, working in 80 columns is an annoyance.
    Why not just have a single very wide format that can show the most useful stuff
    on a single line? While we're at it, let's get rid of that hexadecimal and print
    everything in decimal. That's what format 5 is for, the format I use most frequently
    when examining network problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个足够宽的显示器，在80列工作是一种烦恼。为什么不只有一个非常宽的格式，可以在一行中显示最有用的信息呢？既然我们在这里，让我们去掉十六进制，并以十进制打印一切。这就是格式5的目的，这是我在检查网络问题时最频繁使用的格式。
- en: Like a summer special-effects blockbuster film, this format works nicely on
    a wide-screen monitor but less well on the printed page. But rather than provide
    an actual printed sample that would run across two facing pages of the book or
    have to be printed sideways, let's just walk through the fields this format shows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一部夏季特效大片，这个格式在宽屏显示器上工作得很好，但在打印页面上则不太理想。但与其提供实际打印的样本，该样本会跨越书的两个对页或必须横向打印，不如让我们直接浏览这个格式显示的字段。
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Format 5 produces the columns `Start`, `End`, `Sif`, `SrcIPaddress`, `SrcP`,
    `DstIPaddress`, `DstP`, `P`, `Fl`, `Pkts`, and `Octets`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 格式5生成`Start`、`End`、`Sif`、`SrcIPaddress`、`SrcP`、`DstIPaddress`、`DstP`、`P`、`Fl`、`Pkts`和`Octets`列。
- en: '`Start` and `End` give the times the flow begins and ends in millisecond resolution,
    just like format 1.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`和`End`以毫秒分辨率给出流的开始和结束时间，就像格式1一样。'
- en: Then there's `Sif` (source interface), `SrcIPaddress` (source IP address), and
    `SrcP` (source port), followed by `DIf` (destination interface), `DstIPAddress`
    (destination IP address), and `DstP` (destination port). You should have no trouble
    reading these after understanding the earlier reports.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`Sif`（源接口）、`SrcIPaddress`（源IP地址）和`SrcP`（源端口），然后是`DIf`（目的接口）、`DstIPAddress`（目的IP地址）和`DstP`（目的端口）。在理解了前面的报告后，你应该没有阅读这些的困难。
- en: '`P` is the protocol number.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`P`是协议号。'
- en: '`Fl` gives the TCP control bits printed in decimal.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fl`给出以十进制打印的TCP控制位。'
- en: At the end, `Pkts` gives you the number of packets in the flow, and `Octets`
    gives the bytes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Pkts`给出流中的数据包数量，而`Octets`给出字节数。
- en: TIMES VS. TIMES
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**TIMES VS. TIMES**'
- en: Flow record files are named after the time they were collected on the server.
    The times shown when printing flows are the time on the flow sensor. If your collector's
    clock and your sensor's clock don't match, the times shown in your flow records
    won't match the time the records were collected. Synchronize your clocks!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 流记录文件以它们在服务器上收集的时间命名。打印流时显示的时间是流传感器的时钟。如果你的收集器时钟和你的传感器时钟不匹配，你的流记录中显示的时间将不会与记录收集的时间相匹配。请同步你的时钟！
- en: IP Accounting Format
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP计费格式
- en: 'Perhaps you have software that interprets Cisco IP accounting output or you''ve
    looked at the output for so long that you can process it without expending precious
    brainpower. Format 6, shown here, exists specifically to make you happy:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你有软件可以解释Cisco IP会计输出，或者你已经看了很长时间的输出，以至于可以不耗费宝贵的脑力来处理它。这里显示的格式6专门是为了让你高兴：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For example, here are the four sample flows in Cisco format. If you sort this
    output by the number of bytes, you should be able to easily identify the hosts
    exchanging the most traffic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是以Cisco格式显示的四个示例流量。如果你按字节数排序这个输出，你应该能够轻松地识别交换最多流量的主机。
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By sorting the flows into order by the number of octets sent, you''ve ranked
    the flows from largest to smallest. What filled up your circuit? Here''s the quick
    answer: The first line shows that the host 36.85.32.36 sent 64.18.6.14 (❶) 12,820
    packets containing (❷) 19,216,320 bytes. The same host 36.85.32.36 sent 64.18.6.13
    the same amount of traffic. Further filtering and reporting can identify the type
    of traffic between these busiest hosts, as you''ll see in the next two chapters.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按发送的字节数对流量进行排序，你已经将流量从大到小进行了排名。是什么填满了你的电路？这里有一个快速的答案：第一行显示主机36.85.32.36向64.18.6.14（❶）发送了12,820个包含（❷）19,216,320字节的包。同一个主机36.85.32.36向64.18.6.13发送了相同数量的流量。进一步的过滤和报告可以识别这些最繁忙的主机之间的流量类型，正如你将在下一章中看到的。
- en: Now that you can view the traffic any way you want, let's take a closer look
    at some intricacies of TCP and ICMP connections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以以任何你想要的方式查看流量，让我们更仔细地看看TCP和ICMP连接的一些复杂性。
- en: 'WARNING: HEXADECIMAL MATH AHEAD!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：前方是十六进制数学！
- en: The network is binary, and lots of it is in base 16\. To understand TCP control
    bits and ICMP codes and types, you'll need to use basic hexadecimal math. Remember,
    a leading 0x indicates that a number is hexadecimal
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是二进制的，其中很多都是以16进制为基础的。要理解TCP控制位和ICMP代码和类型，你需要使用基本的十六进制数学。记住，前缀0x表示一个数是十六进制的。
- en: '* * *'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-3-FN-1)]) Although Type of Service/Quality of Service are worthwhile
    topics and although flow-tools supports ToS/QoS, these topics are required by
    only a small fraction of networks. Including a proper discussion of them would
    make this book much longer. Once you understand how to search and report on flows
    based on ports and addresses, you won't have any trouble processing flows based
    on their ToS or QoS.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-3-FN-1)]) 尽管服务类型/服务质量是值得探讨的话题，尽管flow-tools支持ToS/QoS，但这些话题只被少数网络所需要。包括对这些话题的适当讨论会使这本书变得很长。一旦你了解了如何根据端口和地址搜索和报告流量，你将不会在处理基于ToS或QoS的流量时遇到任何麻烦。
- en: TCP Control Bits and Flow Records
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP控制位和流记录
- en: Every TCP packet includes one or more control bits, which are on-off switches
    that tell the connection participants how to handle a particular packet. Flow
    records capture the control bits used by each TCP flow. These control bits are
    not terribly useful when a connection works correctly but are invaluable when
    identifying problems. If you're not familiar with TCP control bits, read a good
    TCP/IP primer such as Charles A. Kozierok's *The TCP/IP Guide* (No Starch Press,
    2005).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个TCP包都包含一个或多个控制位，这些是开/关开关，告诉连接参与者如何处理特定的包。流记录捕获每个TCP流使用的控制位。当连接正常工作时，这些控制位并不特别有用，但在识别问题时却非常有价值。如果你不熟悉TCP控制位，请阅读一本好的TCP/IP入门书籍，如Charles
    A. Kozierok的《TCP/IP指南》（No Starch Press，2005）。
- en: 'Control bits are given this name because TCP has six bits set aside just for
    them. These bits are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 控制位之所以被称为控制位，是因为TCP为它们预留了六个位。这些位如下：
- en: '**The SYN (synchronize) bit** indicates a connection synchronization request.
    It permits the sender and receiver to synchronize TCP sequence numbers, allocate
    consistent ports on each end, and so on. This bit is always set on the first packet
    in a flow.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步（SYN）位**表示一个连接同步请求。它允许发送方和接收方同步TCP序列号，在每个端点分配一致的端口等。这个位在流中的第一个包上总是被设置。'
- en: '**The ACK (acknowledge) bit** indicates that a packet contains acknowledgments
    of receiving specific earlier packets.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确认（ACK）位**表示一个包包含对特定先前包的接收确认。'
- en: '**The PSH (push) bit** is set when the side transmitting data wants the client''s
    network stack to immediately shove this data up the protocol stack. This bit requests
    that the client flush all hardware and kernel buffers and hand all data to the
    client.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送（PSH）位**在发送数据的端点希望客户端的网络堆栈立即将此数据推送到协议堆栈时被设置。这个位请求客户端清空所有硬件和内核缓冲区，并将所有数据交给客户端。'
- en: '**The URG (urgent) bit** indicates that the URGENT pointer field contains data
    that needs to be interpreted. In everyday language, this means that this packet
    contains the glue that the receiver needs if it is to correctly process other
    packets in the flow.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URG（紧急）位**表示紧急指针字段包含需要解释的数据。用日常语言来说，这意味着这个数据包包含了接收方正确处理流中其他数据包所需的粘合剂。'
- en: '**RST (reset)** immediately terminates the connection.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RST（重置）**立即终止连接。'
- en: Finally, the **FIN (finish) bit** announces that this host will send no more
    data, but it will continue to listen for data from the other end. A FIN signals
    that it's time to tear down the connection.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**FIN（结束）位**宣布该主机将不再发送数据，但它将继续监听来自另一端的数据。FIN信号表示是时候断开连接了。
- en: Each control bit is expressed as a hexadecimal number, as shown in [Table 3-3](ch03s03.html#tcp_control_bit_hexadecimal_values
    "Table 3-3. TCP Control Bit Hexadecimal Values").
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制位都表示为一个十六进制数，如[表3-3](ch03s03.html#tcp_control_bit_hexadecimal_values "表3-3.
    TCP控制位十六进制值")所示。
- en: Table 3-3. TCP Control Bit Hexadecimal Values
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-3. TCP控制位十六进制值
- en: '| Flag | Hexadecimal |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 十六进制 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| FIN | 0x01 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| FIN | 0x01 |'
- en: '| SYN | 0x02 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| SYN | 0x02 |'
- en: '| RST | 0x04 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| RST | 0x04 |'
- en: '| PSH | 0x08 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| PSH | 0x08 |'
- en: '| ACK | 0x10 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| ACK | 0x10 |'
- en: '| URG | 0x20 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| URG | 0x20 |'
- en: Many people find this easier to understand as a diagram, such as [Figure 3-1](ch03s03.html#tcp_control_bits
    "Figure 3-1. TCP control bits").
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人发现用图表表示更容易理解，例如[图3-1](ch03s03.html#tcp_control_bits "图3-1. TCP控制位")。
- en: '![TCP control bits](httpatomoreillycomsourcenostarchimages651580.png.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![TCP控制位](httpatomoreillycomsourcenostarchimages651580.png.jpg)'
- en: Figure 3-1. TCP control bits
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1. TCP控制位
- en: Any combination of control bits in a packet can be represented as a unique number.
    If a control bit is set, add that flag's number to the packet's total control
    bit number. If you say that a packet's control bits are set to 18, that indicates
    a precise set of control bits. Only one possible combination of control bits adds
    up to 18\. (Go ahead, try it. I'll wait.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包中控制位的任何组合都可以表示为一个唯一的数字。如果设置了控制位，将该标志的数字加到数据包的总控制位数字上。如果你说一个数据包的控制位设置为18，这表示一组精确的控制位。只有一种可能的控制位组合的总和为18。（试试看，我会等着。）
- en: For example, [Figure 3-2](ch03s03.html#tcp_control_bits_in_a_syn_solidus_ack_pa
    "Figure 3-2. TCP control bits in a SYN/ACK packet") shows how you would represent
    a typical SYN/ACK packet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图3-2](ch03s03.html#tcp_control_bits_in_a_syn_solidus_ack_pa "图3-2. SYN/ACK数据包中的TCP控制位")展示了如何表示一个典型的SYN/ACK数据包。
- en: '![TCP control bits in a SYN/ACK packet](httpatomoreillycomsourcenostarchimages651582.png.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![SYN/ACK数据包中的TCP控制位](httpatomoreillycomsourcenostarchimages651582.png.jpg)'
- en: Figure 3-2. TCP control bits in a SYN/ACK packet
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2. SYN/ACK数据包中的TCP控制位
- en: As you can see in [Figure 3-2](ch03s03.html#tcp_control_bits_in_a_syn_solidus_ack_pa
    "Figure 3-2. TCP control bits in a SYN/ACK packet"), this packet has the control
    bits SYN (0x2) and ACK (0x10) marked, and all other control bits are unmarked.
    Go ahead and add 0x2 and 0x10\. Hexadecimal 10 plus hexadecimal 2 is hexadecimal
    12; my calculator tells me that hexadecimal 12 is decimal 18.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3-2](ch03s03.html#tcp_control_bits_in_a_syn_solidus_ack_pa "图3-2. SYN/ACK数据包中的TCP控制位")所示，这个数据包的控制位SYN（0x2）和ACK（0x10）被标记，而所有其他控制位都没有被标记。现在把0x2和0x10加起来。十六进制10加十六进制2等于十六进制12；我的计算器告诉我十六进制12是十进制18。
- en: The only way to get a packet with a control bits value of 18 is if SYN and ACK,
    and only these two control bits, are selected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到控制位值为18的数据包，只有当选择了SYN和ACK，并且只有这两个控制位时才可能。
- en: Flows don't track individual packets, so how can flow records sensibly track
    TCP control bits? The flow sensor tracks all control bits that appear in a single
    flow. For example, when a host that initiates a connection sends a SYN and an
    ACK during the connection, you'd reasonably expect to also see, say, a PSH and
    a FIN. When any of these flags appear in a flow, the flow sensor notes their appearance.
    [Figure 3-3](ch03s03.html#tcp_control_bits_in_a_flow_with_syn_comm "Figure 3-3. TCP
    control bits in a flow with SYN, ACK, PSH, and FIN") shows how this would look
    in a bitmap.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 流不会跟踪单个数据包，那么流记录如何合理地跟踪TCP控制位呢？流传感器跟踪单个流中出现的所有控制位。例如，当一个主机在连接期间发送SYN和ACK时，你合理地期望看到，比如说，PSH和FIN。当这些标志中的任何一个出现在流中时，流传感器会记录它们的出现。[图3-3](ch03s03.html#tcp_control_bits_in_a_flow_with_syn_comm
    "图3-3. 包含SYN、ACK、PSH和FIN的流中的TCP控制位")展示了这在位图中会是什么样子。
- en: '![TCP control bits in a flow with SYN, ACK, PSH, and FIN](httpatomoreillycomsourcenostarchimages651584.png.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![流中的TCP控制位（包含SYN、ACK、PSH和FIN）](httpatomoreillycomsourcenostarchimages651584.png.jpg)'
- en: Figure 3-3. TCP control bits in a flow with SYN, ACK, PSH, and FIN
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3. 流中的TCP控制位（包含SYN、ACK、PSH和FIN）
- en: So, we have 0x1 + 0x2 + 0x8 + 0x10 = 0x1b, or decimal 27.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有0x1 + 0x2 + 0x8 + 0x10 = 0x1b，或者十进制27。
- en: Look back at the first view of TCP flags earlier this chapter (in [Two Lines
    with Times, Flags, and Hex Ports Using -f 1](ch03s02.html#two_lines_with_times_comma_flags_comma
    "Two Lines with Times, Flags, and Hex Ports Using -f 1") in [Two Lines with Times,
    Flags, and Hex Ports Using -f 1](ch03s02.html#two_lines_with_times_comma_flags_comma
    "Two Lines with Times, Flags, and Hex Ports Using -f 1")). The `Flags` field of
    the third and fourth sample flows equals `1b`, which tells you that this flow
    included all the TCP flags required for a normal connection (SYN, ACK, and FIN).
    It also tells you that this flow included a flag perfectly acceptable in a normal
    connection (PSH) and that it didn't include the flag that would indicate a problem
    (RST). This connection almost certainly worked. In [Chapter 4](ch04.html "Chapter 4. FILTERING
    FLOWS") you'll search for flows that have combinations of control bits that indicate
    problems ([TCP Control Bit Primitives](ch04s02.html#tcp_control_bit_primitives
    "TCP Control Bit Primitives") in [TCP Control Bit Primitives](ch04s02.html#tcp_control_bit_primitives
    "TCP Control Bit Primitives")).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下本章早些时候对TCP标志的第一种视图（在[使用-f 1显示时间、标志和十六进制端口的两个行](ch03s02.html#two_lines_with_times_comma_flags_comma
    "使用-f 1显示时间、标志和十六进制端口的两个行")中，见[使用-f 1显示时间、标志和十六进制端口的两个行](ch03s02.html#two_lines_with_times_comma_flags_comma
    "使用-f 1显示时间、标志和十六进制端口的两个行")）。第三个和第四个样本流的`Flags`字段等于`1b`，这告诉你这个流包含了正常连接所需的全部TCP标志（SYN、ACK和FIN）。它还告诉你这个流包含了一个在正常连接中完全可接受的标志（PSH），并且没有包含表示问题的标志（RST）。这个连接几乎肯定成功了。在[第4章](ch04.html
    "第4章。流过滤")中，你将搜索具有指示问题的控制位组合的流（见[TCP控制位原语](ch04s02.html#tcp_control_bit_primitives
    "TCP控制位原语")，见[TCP控制位原语](ch04s02.html#tcp_control_bit_primitives "TCP控制位原语")）。
- en: CONVERTING HEX TO DECIMAL AND BINARY
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将十六进制转换为十进制和二进制
- en: The Calculator program in Windows can convert between the three bases. Open
    the Calculator, and select **View ▸ Scientific**. You'll see buttons for Hex(adecimal),
    Dec(imal), Oct(al), and Bin(ary). Select the base you want to convert from. Type
    in the number in that base. Select the base you want to convert to, and the Calculator
    will convert for you. You can also use the Calculator if you don't do hexadecimal
    math often enough to learn it. Most Unix-like desktop environments also include
    a hexadecimal/decimal calculator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Windows中的计算器程序可以在三种进制之间进行转换。打开计算器，选择**视图 ▸ 科学**。你会看到十六进制（Hex）、十进制（Dec）、八进制（Oct）和二进制（Bin）的按钮。选择你想要转换的进制。输入该进制下的数字。选择你想要转换到的进制，计算器会为你转换。如果你不经常进行十六进制数学运算，你也可以使用计算器来学习。大多数类Unix桌面环境也包含十六进制/十进制计算器。
- en: ICMP Types and Codes and Flow Records
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMP类型和代码以及流记录
- en: Flow records also record ICMP types and codes, displaying them as destination
    port numbers. I'll review ICMP types and codes first and then discuss how flow
    records portray them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 流记录还记录ICMP类型和代码，将它们显示为目标端口号。我将首先回顾ICMP类型和代码，然后讨论流记录如何表示它们。
- en: Types and Codes in ICMP
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP中的类型和代码
- en: Many people mentally pour the different ICMP requests into one large bucket
    and get by on generalizations such as "ICMP is ping." Although this might be fine
    for average users, you're not an average user, and you need a deeper understanding
    of ICMP to manage a network.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人将不同的ICMP请求心理上归入一个大篮子，并依靠诸如“ICMP是ping”这样的概括来应对。虽然这可能对普通用户来说足够了，但你不是普通用户，你需要对ICMP有更深入的理解才能管理网络。
- en: An ICMP *type* is a general class of ICMP request, such as ping requests and
    ping replies. Other ICMP types include messages such as "host unreachable," routing
    advertisements, traceroute requests, routing redirects, and so on. Some ICMP types
    prompt a response from the recipient, while others are received without comment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP的*类型*是一类通用的ICMP请求，例如ping请求和ping回复。其他ICMP类型包括诸如“主机不可达”、“路由通告”、“traceroute请求”、“路由重定向”等消息。一些ICMP类型会从接收方那里得到响应，而其他类型则无注释地接收。
- en: Some ICMP types also include an ICMP *code* that allows an ICMP message to provide
    a more specific response. The meaning of each ICMP code varies with the message's
    ICMP type. For example, although ICMP types 3, 5, and 11 all offer an ICMP code
    of 1, that code has a completely different meaning with each type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些ICMP类型还包括一个ICMP *代码*，允许ICMP消息提供更具体的响应。每个ICMP代码的意义随消息的ICMP类型而变化。例如，尽管ICMP类型3、5和11都提供ICMP代码1，但该代码在每个类型中都有完全不同的意义。
- en: The Internet Assigned Numbers Authority (IANA) assigns ICMP types and codes
    and maintains a list of current assignments at [http://www.iana.org/assignments/icmp-parameters/](http://www.iana.org/assignments/icmp-parameters/).
    These assignments rarely change, so [Table 3-4](ch03s04.html#common_icmp_types_and_associated_codes_i
    "Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal")
    offers the most commonly seen ICMP types and codes. Although an explanation of
    the meanings of different ICMP messages is best left for a book on TCP/IP (such
    as *The TCP/IP Guide*, mentioned earlier), this table provides an easy reference.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网数字分配机构（IANA）分配ICMP类型和代码，并在[http://www.iana.org/assignments/icmp-parameters/](http://www.iana.org/assignments/icmp-parameters/)维护当前分配列表。这些分配很少改变，因此[表3-4](ch03s04.html#common_icmp_types_and_associated_codes_i
    "表3-4. 十进制和十六进制表示的常见ICMP类型和相关代码")提供了最常见的ICMP类型和代码。尽管不同ICMP消息的意义最好留给TCP/IP方面的书籍（如前面提到的《TCP/IP指南》）来解释，但此表提供了一个便捷的参考。
- en: Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-4. 十进制和十六进制表示的常见ICMP类型和相关代码
- en: '| Type | Code | Decimal | Definition |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 代码 | 十进制 | 定义 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | Echo Reply |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 回显应答 |'
- en: '| 3 |   |   | Destination Unreachable |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 3 |   |   | 目标不可达 |'
- en: '|   | 0 | 300 | Network Unreachable |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|   | 0 | 300 | 网络不可达 |'
- en: '|   | 1 | 301 | Host Unreachable |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|   | 1 | 301 | 主机不可达 |'
- en: '|   | 2 | 302 | Protocol Unreachable |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|   | 2 | 302 | 协议不可达 |'
- en: '|   | 3 | 303 | Port Unreachable |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|   | 3 | 303 | 端口不可达 |'
- en: '|   | 4 | 304 | Fragmentation Needed, but Don''t Fragment was Set |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|   | 4 | 304 | 需要分片，但设置了不分片 |'
- en: '|   | 6 | 306 | Destination Network Unknown |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|   | 6 | 306 | 目标网络未知 |'
- en: '|   | 7 | 307 | Destination Host Unknown |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|   | 7 | 307 | 目标主机未知 |'
- en: '|   | 9 | 309 | Communication with Destination Network Administratively Prohibited
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|   | 9 | 309 | 与目标网络通信管理上禁止 |'
- en: '|   | 10(a) | 310 | Communication with Destination Host Administratively Prohibited
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|   | 10(a) | 310 | 与目标主机通信管理上禁止 |'
- en: '|   | 13(d) | 313 | Communication Administratively Prohibited |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|   | 13(d) | 313 | 通信管理上禁止 |'
- en: '| 5 |   |   | Redirect |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 5 |   |   | 重定向 |'
- en: '|   | 0 | 500 | Redirect for Subnet |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|   | 0 | 500 | 子网重定向 |'
- en: '|   | 1 | 501 | Redirect for Host |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|   | 1 | 501 | 主机重定向 |'
- en: '| 8 | 0 | 800 | Echo Request |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 0 | 800 | 回显请求 |'
- en: '| 11(b) |   |   | Time Exceeded |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 11(b) |   |   | 时间超出 |'
- en: '|   | 0 | 2816 | Time to Live exceeded in Transit |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|   | 0 | 2816 | 转发中的生存时间超时 |'
- en: '|   | 1 | 2817 | Fragment Reassembly Time Exceeded |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|   | 1 | 2817 | 分片重组超时 |'
- en: '| 12(c) |   | 3072 | Parameter Problem |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 12(c) |   | 3072 | 参数问题 |'
- en: '| 13(d) |   | 3328 | Timestamp Request |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 13(d) |   | 3328 | 时间戳请求 |'
- en: '| 14(e) |   | 3584 | Timestamp Reply |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 14(e) |   | 3584 | 时间戳应答 |'
- en: Flows and ICMP Details
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流和ICMP详细信息
- en: Flow sensors encode the ICMP type and code in the flow's destination port. Destination
    (and source) ports are two bytes. The first byte of the port gives the type, and
    the second byte gives the code. Because ICMP has no concept of an originating
    port, the source port is always zero. In the following example, I've selected
    a few ICMP flows out of my test data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 流传感器将ICMP类型和代码编码在流的目标端口中。目标（和源）端口是两个字节。端口的第一个字节给出类型，第二个字节给出代码。因为ICMP没有源端口的观念，所以源端口始终为零。在以下示例中，我从我的测试数据中选取了一些ICMP流。
- en: This example uses a print format that displays destination ports in hexadecimal.
    You can use a format that displays ports in decimal, but you must convert the
    destination port from decimal to hex to interpret it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用一种打印格式，显示目标端口为十六进制。您可以使用显示端口的十进制格式的格式，但必须将目标端口从十进制转换为十六进制才能解释它。
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first flow comes from the address 80.95.220.173 to 36.85.32.153 and has
    a destination port of hexadecimal 800 (❶). Although `flow-print` doesn't print
    leading zeros, you could think of this as 0800, just as you could think of port
    25 as port 025\. In this example, the ICMP type is 8, and the code is 00\. ICMP
    type 8 has no associated codes, so `flow-print` gives the ICMP code as 00.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个流量来自地址 80.95.220.173 到 36.85.32.153，目标端口为十六进制 800 (❶)。尽管 `flow-print` 不打印前导零，但你可以将其视为
    0800，就像你可以将端口 25 视为端口 025 一样。在这个例子中，ICMP 类型是 8，代码是 00。ICMP 类型 8 没有相关代码，所以 `flow-print`
    将 ICMP 代码显示为 00。
- en: A look at [Table 3-4](ch03s04.html#common_icmp_types_and_associated_codes_i
    "Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal")
    tells you that ICMP type 8 is an echo request, also known as a *ping attempt*.
    The host 80.95.220.173 is trying to ping 36.85.32.153.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 查看第[表 3-4](ch03s04.html#common_icmp_types_and_associated_codes_i "表 3-4. 十进制和十六进制中常见的
    ICMP 类型及其相关代码")可知，ICMP 类型 8 是一个回显请求，也称为 *ping 尝试*。主机 80.95.220.173 正在尝试 ping 36.85.32.153。
- en: The second ICMP flow has a destination port of b00 (❷), or an ICMP type of b
    and an ICMP code of 00\. ICMP type b is "time exceeded." Unlike ICMP type 8, this
    ICMP type has codes with it. Code 0 means "time to live exceeded in transit."
    In this case, the IP 189.163.178.51 is informing the IP 36.85.32.130 that it's
    taking too long to reach a particular address, which usually means that a client
    has been disconnected.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 ICMP 流量目标端口为 b00 (❷)，或 ICMP 类型为 b 和 ICMP 代码为 00。ICMP 类型 b 是 "超时"。与 ICMP
    类型 8 不同，这种 ICMP 类型有相关代码。代码 0 表示 "传输过程中生存时间超时"。在这种情况下，IP 189.163.178.51 正在通知 IP
    36.85.32.130，到达特定地址的时间过长，这通常意味着客户端已断开连接。
- en: The third flow, from 64.142.0.205 to 36.85.32.5, has a destination port of 300
    (❸). ICMP type 3 messages indicate that a destination is unreachable. ICMP type
    3's code 0 means "network unreachable." In this case, host 36.85.32.5 attempted
    to reach another host, and a router on the Internet is returning a message indicating
    that the target network is not reachable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个流量，从 64.142.0.205 到 36.85.32.5，目标端口为 300 (❸)。ICMP 类型 3 消息表示目标不可达。ICMP 类型
    3 的代码 0 表示 "网络不可达"。在这种情况下，主机 36.85.32.5 尝试连接到另一个主机，而互联网上的一个路由器正在返回一个表示目标网络不可达的消息。
- en: The fourth flow has a destination port of 303 (❹). ICMP type 3 indicates that
    a destination is unreachable, but code 03 means "port unreachable." When a client
    sends a UDP request to a server port that isn't open, the server returns this
    ICMP message. If you were to search these flow records, you would find a UDP request
    going in the other direction between these two hosts.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个流量目标端口为 303 (❹)。ICMP 类型 3 表示目标不可达，但代码 03 表示 "端口不可达"。当客户端向未打开的服务器端口发送 UDP
    请求时，服务器会返回此 ICMP 消息。如果你要搜索这些流量记录，你会在这两个主机之间找到相反方向的 UDP 请求。
- en: Our fifth flow has a destination port of 0 (❺). ICMP type 0 is an echo reply,
    or a response to a ping. If you search these flows, you'll find an echo request
    going in the other direction.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第五个流量目标端口为 0 (❺)。ICMP 类型 0 是一个回显响应，或对 ping 的响应。如果你搜索这些流量，你会找到相反方向的回显请求。
- en: As you can see, ICMP messages are frequently responses to other types of network
    requests. They often show exactly what type of error occurred as a result of an
    attempted connection. Matching these messages to other flows frequently requires
    searching the flow records, which is best accomplished by filtering, as you'll
    see in [Chapter 4](ch04.html "Chapter 4. FILTERING FLOWS").
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，ICMP 消息通常是其他类型网络请求的响应。它们通常会显示尝试连接时发生的确切错误类型。将这些消息与其它流量匹配通常需要搜索流量记录，这最好通过过滤来实现，正如你将在[第
    4 章](ch04.html "第 4 章。过滤流量")中看到的。
