["```\nname = \"Fred\"\n```", "```\n:name = \"Fred\"    # Error!\n```", "```\nattr_reader( :description )\nattr_writer( :description )\n```", "```\n# These 3 strings have 3 different object_ids\nputs( \"hello\".object_id ) #=> 16589436\nputs( \"hello\".object_id ) #=> 16589388\nputs( \"hello\".object_id ) #=> 16589340\n```", "```\n# These 3 symbols have the same object_id\nputs( :hello.object_id ) #=> 208712\nputs( :hello.object_id ) #=> 208712\nputs( :hello.object_id ) #=> 208712\n```", "```\n# These three symbols have the same object_id\nputs( :ten.object_id )  #=> 20712\nputs( :ten.object_id )  #=> 20712\nputs( :ten.object_id )  #=> 20712\n\n# These three integers have the same object_id\nputs( 10.object_id )    #=> 21\nputs( 10.object_id )    #=> 21\nputs( 10.object_id )    #=> 21\n```", "```\nputs( :helloworld.equal?( :helloworld ) )     #=> true\nputs( \"helloworld\".equal?( \"helloworld\" ) )   #=> false\nputs( 1.equal?( 1 ) )                         #=> true\n```", "```\namethod( :deletefiles )\n```", "```\ndef amethod( doThis )\n    if (doThis == :deletefiles) then\n       puts( 'Now deleting files...')\n    elsif (doThis == :formatdisk) then\n       puts( 'Now formatting disk...')\n    else\n        puts( \"Sorry, command not understood.\" )\n    end\nend\n```", "```\ncase doThis\n    when :deletefiles then puts( 'Now deleting files...')\n    when :formatdisk then puts( 'Now formatting disk...')\n    else  puts( \"Sorry, command not understood.\" )\nend\n```", "```\nmodule One\n     class Fred\n     end\n     $f1 = :Fred\nend\n\nmodule Two\n     Fred = 1\n     $f2 = :Fred\nend\n\ndef Fred()\nend\n\n$f3 = :Fred\n```", "```\n# All three display the same id!\nputs( $f1.object_id )  #=> 208868\nputs( $f2.object_id )  #=> 208868\nputs( $f3.object_id )  #=> 208868\n```", "```\nmodule One\n    class Fred\n    end\n    $f1 = :Fred\n    def self.evalFred( aSymbol )\n        puts( eval( aSymbol.id2name ) )\n    end\nend\n\nmodule Two\n    Fred = 1\n    $f2 = :Fred\n    def self.evalFred( aSymbol )\n        puts( eval( aSymbol.id2name ) )\n    end\nend\n\ndef Fred()\n    puts( \"hello from the Fred method\" )\nend\n\n$f3 = :Fred\n```", "```\nOne::evalFred( $f1 )\n```", "```\nOne::Fred\n```", "```\nTwo::evalFred( $f2 )\n```", "```\nmethod($f3).call\n```", "```\n\"hello from the Fred method\"\n```", "```\nOne::evalFred( $f1 )    #=> One::Fred\nTwo::evalFred( $f2 )    #=> 1\nmethod($f3).call        #=> hello from the Fred method\n\nOne::evalFred( $f3 )    #=> One::Fred\nTwo::evalFred( $f1 )    #=> 1\nmethod($f2).call        #=> hello from the Fred method\n\nOne::evalFred( :Fred )  #=> One::Fred\nTwo::evalFred( :Fred )  #=> 1\nmethod(:Fred).call      #=> hello from the Fred method\n```", "```\nx = 1\nxsymbol = :x\n```", "```\ndef amethod( somearg )\n    p( somearg )\nend\n\n# Test 1\namethod( x )\namethod( :x )\n```", "```\n1\n:x\n```", "```\n# Test 2\namethod( eval(:x.id2name))\n```", "```\nx = 1\nxsymbol = :x\n```", "```\n# Test 3\namethod( xsymbol )                                      #=> :x\namethod( :xsymbol )                                     #=> :xsymbol\namethod( eval(:xsymbol.id2name))                        #=> :x\namethod( eval( ( eval(:xsymbol.id2name)).id2name ) )    #=> 1\n```", "```\n#Test 4\nmethod(:amethod).call(\"\")\n```", "```\nmethod(:amethod).call(eval(:x.id2name))\n```", "```\ndef mymethod( somearg )\n   print( \"I say: \" << somearg )\nend\n\nthis_is_a_method_name = method(:mymethod)\n```", "```\nputs( this_is_a_method_name )  #=> #<Method: Object#mymethod>\n```", "```\nputs( \"#{this_is_a_method_name.class}\" )  #=> Method\n```", "```\nthis_is_a_method_name.call( \"hello world\" )  #=>I say: hello world\n```", "```\n{ :text => \"Hello world\" }\n```", "```\nclass Array\n    define_method( :aNewMethod, lambda{\n        |*args| puts( args.inspect)\n    } )\nend\n```", "```\nArray.method_defined?( :aNewMethod )   #=> true\n```", "```\n[].aNewMethod( 1,2,3     #=> [1,2,3]\n```", "```\nclass Array\n    remove_method( :aNewMethod )\nend\n```", "```\np( Symbol.all_symbols )\n```", "```\np( Symbol.all_symbols[0,10] )\n```", "```\n# In Ruby 1.9\np [:a,:c,:b].sort       #=> [:a,:b,:c]\n\n# In Ruby 1.8\np [:a,:c,:b].sort       #=> 'sort': undefined method '<=>' for :a:Symbol\n```", "```\nstr_arr = Symbol.all_symbols.collect{ |s| s.to_s }\nputs( str_arr.sort )\n```"]