<html><head></head><body><div class="appendix" title="Appendix&#xA0;B.&#xA0;THE STRUCTURE OF THE XEN CONFIG FILE"><div class="titlepage"><div><div><h1 class="title"><a id="the_structure_of_the_xen_config_file"/>Appendix B. THE STRUCTURE OF THE XEN CONFIG FILE</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e18647"/><img src="httpatomoreillycomsourcenostarchimages333191.png.jpg" alt="image with no caption"/></div></div><p>The domain config file is the conventional way to define a Xen domain (and the method that we've used throughout this book). It works by specifying Python variables in a config file, conventionally kept in <span class="emphasis"><em>/etc/xen/&lt;domain name&gt;</em></span>. When the domain is created, <code class="literal">xend</code> executes this file and uses it to set variables that will eventually control the output <a id="idx-CHP-B-1208" class="indexterm"/>of the domain builder.</p><p>Note also that you can override values in the config file from the <code class="literal">xm</code> command line. For example, to create the domain <span class="emphasis"><em>coriolanus</em></span> with a different name:</p><a id="I_programlisting_d1e18674"/><pre class="programlisting">xm create coriolanus name=menenius</pre><p>The config file—and it would be difficult to overstate this point—is executed as a standard Python script. Thus, you can embed arbitrary Python in the config file, making it easy to autogenerate configurations based on external constraints. You can see a simple example <a id="idx-CHP-B-1209" class="indexterm"/>of this in the example HVM config shipped with Xen, <span class="emphasis"><em>/etc/xen/xmexample.hvm</em></span>. In this case, the library path is selected based on the processor type (i386 or x86_64).</p><p>The <span class="emphasis"><em>xmexample2</em></span> file takes this technique even further, using a single config file to handle many domains, which are differentiated by a passed-in <code class="literal">vmid</code> variable.</p><p><a id="idx-CHP-B-1210" class="indexterm"/>Python in the config file isn't limited to <a id="idx-CHP-B-1211" class="indexterm"/>domain configuration, either. If you're using Xen for hosting, for example, we might suggest tying the domain configuration to the billing and support-ticketing systems, using some Python glue to keep them in sync. By embedding this logic in the config files, or in a separate module included by the config files, you can build a complex infrastructure around the Xen domains.</p><p>First, let's start with the basic <a id="idx-CHP-B-1212" class="indexterm"/>elements of a domain configuration. Here's a basic config file, <a id="idx-CHP-B-1213" class="indexterm"/>specifying the VM name, kernel image, three network cards, a block device, and a kernel parameter:</p><a id="I_programlisting_d1e18722"/><pre class="programlisting">name = coriolanus
kernel = "/boot/linux-2.6-xen"
vif = ['','','']
disk = ['phy:/dev/corioles/coriolanus-root,sda,rw']
root = "/dev/sda ro"</pre><p>Here we're setting some <a id="idx-CHP-B-1214" class="indexterm"/>variables (<code class="literal">name</code>, <code class="literal">kernel</code>, <code class="literal">disk</code>, and so on) to strings or lists. You can easily identify the lists because they're enclosed in square brackets.</p><p><a id="idx-CHP-B-1215" class="indexterm"/>String quoting follows the standard Python conventions: a single quote for noninterpreted strings, double quotes for strings with variable substitution, and three single quotes to begin and end a multiline string.</p><p><a id="idx-CHP-B-1216" class="indexterm"/>Whitespace has significance just as in standard Python—newlines are significant and spacing doesn't matter, except when used as indentation.</p><div class="note" title="Note"><h3 class="title"><a id="note-62"/>Note</h3><p><span class="emphasis"><em>Although these syntax rules are usually true, some external tools that parse the config file may have stricter rules. pypxeboot is an example</em></span>.</p></div><p>Here's another, more complex example, with an <a id="idx-CHP-B-1217" class="indexterm"/>NFS root. In addition, we'll specify a couple of parameters for the <code class="literal">vif</code>:</p><a id="I_programlisting_d1e18764"/><pre class="programlisting">name = coriolanus
kernel = "/boot/linux-2.6-xen"
initrd = "/boot/initrd-xen-domU"
memory = 256
vif =
['mac=08:de:ad:be:ef:00,bridge=xenbr0','mac=08:de:ad:be:ef:01,bridge=xenbr1']
netmask = '255.255.255.0'
gateway = '192.168.2.1'
ip = '192.168.2.47'
broadcast = '192.168.2.255'
root = "/dev/nfs"
nfs_server ='192.168.2.42'
nfs_root = '/export/domains/coriolanus'</pre><div class="note" title="Note"><h3 class="title"><a id="note-63"/>Note</h3><p><span class="emphasis"><em>Your kernel must have NFS support and your kernel or initrd needs to include <em class="replaceable"><code>xennet</code></em> for this to work</em></span>.</p></div><p>Finally, HVM domains take some other <a id="idx-CHP-B-1218" class="indexterm"/>options. Here's a config file that we might use to install an HVM FreeBSD domU.</p><a id="I_programlisting_d1e18782"/><pre class="programlisting">import os, re
arch = os.uname()[4]
if re.search('64', arch):
   arch_libdir = 'lib64'
else:
   arch_libdir = 'lib'
kernel = "/usr/lib/xen/boot/hvmloader"
builder='hvm'
memory = 1024
name = "coriolanus"
vcpus=1
pae=1
acpi=0
vif = [ 'type=ioemu, bridge=xenbr0' ]
disk = [
       'phy:/dev/corioles/coriolanus_root,hda,w',
       'file:/root/8.0-CURRENT-200809-i386-disc1.iso,hdc:cdrom,r'
]
device_model = '/usr/' + arch_libdir + '/xen/bin/qemu-dm'
boot="cd"
vnc=1
vnclisten="192.168.1.102"
serial='pty'</pre><p>Here we've added options to specify the QEMU-based backing device model and to control certain aspects <a id="idx-CHP-B-1219" class="indexterm"/>of its behavior. Now we pass in a <code class="literal">boot</code> option that tells it to boot from CD and options for a virtual framebuffer and serial device.</p><div class="sect1" title="List of Directives"><div class="titlepage"><div><div><h1 class="title"><a id="list_of_directives"/>List of Directives</h1></div></div></div><p>Here we've tried to list every directive we know about, whether we use it or not, with notes indicating where we cover it in the main text of this book. We have, however, left out stuff that's marked <span class="emphasis"><em>deprecated</em></span> as of Xen version 3.3.<a id="idx-CHP-B-1220" class="indexterm"/></p><p>There are some commands that work with the Xen.org version of Xen but not with the version of Xen included with Red Hat Enterprise Linux/CentOS 5.<span class="emphasis"><em>x</em></span>. We've marked these with an asterisk (*).</p><p>Any Boolean parameters expect values of <code class="literal">true</code> or <code class="literal">false</code>; <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">yes</code>, and <code class="literal">no</code> will also work.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>bootargs=string</code></strong></span></dt><dd><p>This is a list of arguments to pass to the boot loader. For example, to tell PyGRUB to load a particular kernel image, you can specify <code class="literal">bootargs='kernel=vmlinuz-2.6.24'</code>.<a id="I_indexterm_d1e18845" class="indexterm"/></p></dd><dt><span class="term"><strong class="userinput"><code>bootloader=string</code></strong></span></dt><dd><p>The <code class="literal">bootloader</code> line specifies a program that will be run within dom0 to load and initialize the domain kernel. For example, you can specify <code class="literal">bootloader=pygrub</code> to get a domain that, on startup, presents a GRUB-like boot menu. We discuss PyGRUB and pypxeboot in <a class="xref" href="ch07.html" title="Chapter 7. HOSTING UNTRUSTED USERS UNDER XEN: LESSONS FROM THE TRENCHES">Chapter 7</a> and <a class="xref" href="ch03.html" title="Chapter 3. PROVISIONING DOMUS">Chapter 3</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>builder=string</code></strong></span></dt><dd><p>This defaults to "Linux", which is the paravirtualized Linux (and other Unix-like OSs) domain builder. Ordinarily you will either leave this option blank or specify HVM. Other domain builders are generally regarded as historical curiosities.</p></dd><dt><span class="term"><strong class="userinput"><code>cpu_capp=int *</code></strong></span></dt><dd><p>This specifies a maximum share of the CPU time for the domain, expressed in hundredths of a CPU.</p></dd><dt><span class="term"><strong class="userinput"><code>cpu=int</code></strong></span></dt><dd><p>This option specifies the physical CPU that the domain should run VCPU0 on.</p></dd><dt><span class="term"><strong class="userinput"><code>cpu_weight=int *</code></strong></span></dt><dd><p>This specifies the domain's weight for the credit scheduler, just like the <code class="literal">xm sched-credit -w</code> command. For example, <code class="literal">cpu_weight = 1024</code> will give the domain twice as much weight as the default. We talk more about CPU weight in <a class="xref" href="ch07.html" title="Chapter 7. HOSTING UNTRUSTED USERS UNDER XEN: LESSONS FROM THE TRENCHES">Chapter 7</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>cpus=string</code></strong></span></dt><dd><p>The <code class="literal">cpus</code> option specifies a <a id="idx-CHP-B-1221" class="indexterm"/>list of CPUs that the domain may use. The syntax of the list is fairly expressive. For example, <code class="literal">cpus = "0-3,5,^1"</code> specifies 0, 2, 3, and 5 while excluding CPU 1.</p></dd><dt><span class="term"><strong class="userinput"><code>dhcp=bool</code></strong></span></dt><dd><p>This directive is only needed if the kernel is getting its IP at boot, usually because you're using an NFS root device. Ordinary DHCP is handled from within the domain by standard userspace daemons, and so the DHCP directive is not required.</p></dd><dt><span class="term"><strong class="userinput"><code>disk=list</code></strong></span></dt><dd><p>The <code class="literal">disk</code> line specifies one (or more) virtual disk devices. Almost all domains will need at least one, although it's not a requirement as far as Xen's concerned. Each definition is a stanza in the list, each of which has at least three terms: backend device, frontend device, and mode. We go into considerably more detail on the meaning of these terms and the various types of storage in <a class="xref" href="ch04.html" title="Chapter 4. STORAGE WITH XEN">Chapter 4</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>extra=string</code></strong></span></dt><dd><p>The <code class="literal">extra</code> option specifies a string that is appended, unchanged, to the domU kernel options. For example, to boot the domU in single user mode:<a id="idx-CHP-B-1222" class="indexterm"/></p><a id="I_programlisting_d1e18956"/><pre class="programlisting">extra = "s"</pre><p>Many of the other options listed here actually append to the kernel command-line options.</p></dd><dt><span class="term"><strong class="userinput"><code>hpet</code></strong></span></dt><dd><p>This option enables a virtual high-precision event timer.</p></dd><dt><span class="term"><strong class="userinput"><code>kernel=string</code></strong></span></dt><dd><p>This option specifies the kernel image that Xen will load and boot. It is required if no bootloader line is specified. Its value should be the absolute path to the kernel, from the dom0's perspective, unless you've also specified a bootloader. If you're using a bootloader and specify a kernel, the domain creation script will pass the kernel value to the bootloader for further action. For example, PyGRUB will try to load the specified file from the boot media.</p></dd><dt><span class="term"><strong class="userinput"><code>maxmem=int</code></strong></span></dt><dd><p>This specifies the amount of memory given to the domU. From the guest's perspective, this is the amount of memory <span class="emphasis"><em>plugged in</em></span> when it boots.</p></dd><dt><span class="term"><strong class="userinput"><code>memory=int</code></strong></span></dt><dd><p>This is the target memory allocation for the domain. If <code class="literal">maxmem</code> isn't specified, the <code class="literal">memory=</code> line will also set the domain's maximum memory. Because we don't oversubscribe memory, we use this directive rather than <code class="literal">max-mem</code>. We go into a little more detail on memory oversubscription in <a class="xref" href="ch14.html" title="Chapter 14. TIPS">Chapter 14</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>name=string</code></strong></span></dt><dd><p>This is a unique name for the domain. Make it whatever you like, but we recommend keeping it under 15 characters, because Red Hat's (and possibly other distros') <span class="emphasis"><em>xendomains</em></span> script has trouble with longer names. This is one of the few non-optional directives. Every domain needs a name.</p></dd><dt><span class="term"><strong class="userinput"><code>nfs_root=IP</code></strong><br/></span><span class="term"><strong class="userinput"><code>nfs_server=IP</code></strong></span></dt><dd><p>These two arguments are used by the kernel when booting via NFS. We describe setting up an NFS root in <a class="xref" href="ch04.html" title="Chapter 4. STORAGE WITH XEN">Chapter 4</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>nics=int</code></strong></span></dt><dd><p>This option is deprecated, but you may see it referenced in other documentation. It specifies the number of virtual NICs allocated to the domain. In practice, we always just rely on the number of <code class="literal">vif</code> stanzas to implicitly declare the NICs.<a id="idx-CHP-B-1223" class="indexterm"/></p></dd><dt><span class="term"><strong class="userinput"><code>on_crash</code></strong><br/></span><span class="term"><strong class="userinput"><code>on_reboot=string</code></strong><br/></span><span class="term"><strong class="userinput"><code>on_shutdown</code></strong></span></dt><dd><p>These three commands control how the domain will react to various halt states—<code class="literal">on_shutdown</code> for graceful shutdowns, <code class="literal">on_reboot</code> for graceful reboot, and <code class="literal">on_crash</code> for when the domain crashes. Allowed values are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">destroy</code>: Clean up after the domain as usual.</p></li><li class="listitem"><p><code class="literal">restart</code>: Restart the domain.</p></li><li class="listitem"><p><code class="literal">preserve</code>: Keep the domain as-is until you destroy it manually.</p></li><li class="listitem"><p><code class="literal">rename-restart</code>: Preserve the domain, while re-creating another instance with a different name.</p></li></ul></div></dd><dt><span class="term"><strong class="userinput"><code>on_xend_start=ignore|start</code></strong><br/></span><span class="term"><strong class="userinput"><code>on_xend_stop=ignore|shutdown|suspend</code></strong></span></dt><dd><p>Similarly, these two items control how the domain will react to <code class="literal">xend</code> exiting. Because <code class="literal">xend</code> sometimes needs to be restarted, and we prefer to minimize disruption of the domUs, we leave these at the default: <code class="literal">ignore</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>pci=BUS:DEV.FUNC</code></strong></span></dt><dd><p>This adds a PCI device to the domain using the given parameters, which can be found with <code class="literal">lspci</code> in the dom0. We give an example of PCI forwarding in <a class="xref" href="ch14.html" title="Chapter 14. TIPS">Chapter 14</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>ramdisk=string</code></strong></span></dt><dd><p>The <code class="literal">ramdisk</code> option functions like the initrd line in GRUB; it specifies an initial ramdisk, which usually contains drivers and scripts used to access hardware required to mount the root filesystem.</p><p>Many distros won't require an initrd when installed as domUs, because the domU only needs drivers for extremely simple virtual devices. However, because the distro expects to have an initrd, it's often easier to create one. We go into more detail on that subject in <a class="xref" href="ch14.html" title="Chapter 14. TIPS">Chapter 14</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>root=string</code></strong></span></dt><dd><p>This specifies the root device for the domain. We usually specify the root device on the extra line.</p></dd><dt><span class="term"><strong class="userinput"><code>rtc_offset</code></strong></span></dt><dd><p>The <code class="literal">rtc_offset</code> allows you to specify an offset from the machine's real-time clock for the guest domain.</p></dd><dt><span class="term"><strong class="userinput"><code>sdl=bool</code></strong></span></dt><dd><p>Xen supports an SDL console as well as the VNC console, although not both at the same time. Set this option to <code class="literal">true</code> to enable a framebuffer console over SDL. Again, we prefer the <code class="literal">vfb</code> syntax.</p></dd><dt><span class="term"><strong class="userinput"><code>shadow_memory=int</code></strong></span></dt><dd><p>This is the domain shadow memory in MB. PV domains will default to none. Xen uses shadow memory to keep copies of domain-specific page tables. We go into more detail on the role of page table shadows in <a class="xref" href="ch12.html" title="Chapter 12. HVM: BEYOND PARAVIRTUALIZATION">Chapter 12</a>.<a id="idx-CHP-B-1224" class="indexterm"/></p></dd><dt><span class="term"><strong class="userinput"><code>uuid=string</code></strong></span></dt><dd><p>The XenStore requires a UUID to, as the name suggests, uniquely identify a domain. If you don't specify one, it'll be generated for you. The odds of collision are low enough that we don't bother, but you may find it useful if, for example, you want to encode additional information into your UUID.</p></dd><dt><span class="term"><strong class="userinput"><code>vcpu_avail=int</code></strong></span></dt><dd><p>These are active VCPUs. If you're using CPU hotplugging, this number may differ from the total number of VCPUs, just as <code class="literal">max-mem</code> and <code class="literal">memory</code> may differ.</p></dd><dt><span class="term"><strong class="userinput"><code>vcpus=int</code></strong></span></dt><dd><p>This specifies the number of virtual CPUs to report to the domain. For performance reasons, we strongly recommend that this be equal to or fewer than the number of physical CPU cores that the domain has available.</p></dd><dt><span class="term"><strong class="userinput"><code>vfb=list</code></strong>
</span></dt><dd><a id="I_programlisting_d1e19206"/><pre class="programlisting">vfb = [type='vnc' vncunused=1]</pre><p>In this case, we specify a VNC virtual framebuffer, which uses the first unused port in the VNC range. (The default behavior is to use the base VNC port plus domain ID as the listen port for each domain's virtual framebuffer.)</p><p>Valid options for the <code class="literal">vfb</code> line are: <code class="literal">vnclisten</code>, <code class="literal">vncunused</code>, <code class="literal">vncdisplay</code>, <code class="literal">display</code>, <code class="literal">videoram</code>, <code class="literal">xauthority</code>, <code class="literal">type</code>, <code class="literal">vncpasswd</code>, <code class="literal">opengl</code>, and <code class="literal">keymap</code>. We discuss more details about virtual framebuffers in <a class="xref" href="ch14.html" title="Chapter 14. TIPS">Chapter 14</a> and a bit in <a class="xref" href="ch12.html" title="Chapter 12. HVM: BEYOND PARAVIRTUALIZATION">Chapter 12</a>. See the <code class="literal">vnc=</code> and <code class="literal">sdl=</code> options for an alternative syntax.</p></dd><dt><span class="term"><strong class="userinput"><code>videoram=int</code></strong></span></dt><dd><p>The <code class="literal">videoram</code> option specifies the maximum amount of memory that a PV domain may use for its frame buffer.</p></dd><dt><span class="term"><strong class="userinput"><code>vif=list</code></strong></span></dt><dd><p>The <code class="literal">vif</code> directive tells Xen about the domain's virtual network devices. Each <code class="literal">vif</code> specification can include many options, including <code class="literal">bridge</code>, <code class="literal">ip</code>, and <code class="literal">mac</code>. For more information on these, see <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a>.</p><p>Allowable options in the <code class="literal">vif</code> line are <code class="literal">backend</code>, <code class="literal">bridge</code>, <code class="literal">ip</code>, <code class="literal">mac</code>, <code class="literal">script</code>, <code class="literal">type</code>, <code class="literal">vifname</code>, <code class="literal">rate</code>, <code class="literal">model</code>, <code class="literal">accel</code>, <code class="literal">policy</code>, and <code class="literal">label</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>vnc=bool</code></strong></span></dt><dd><p>Set <code class="literal">vnc</code> to 1 to enable the VNC console. You'll also want to set some of the other VNC-related options, such as <code class="literal">vncunused</code>. We prefer the <code class="literal">vfb</code> syntax, which allows you to set options related to the <code class="literal">vfb</code> in a single place, with a similar syntax to the <code class="literal">vif</code> and <code class="literal">disk</code> lines.<a id="idx-CHP-B-1225" class="indexterm"/></p></dd><dt><span class="term"><strong class="userinput"><code>vncconsole=bool</code></strong></span></dt><dd><p>If <code class="literal">vncconsole</code> is set to <code class="literal">yes</code>, <code class="literal">xend</code> automatically spawns a VNC viewer and connects to the domain console when the domain starts up.</p></dd><dt><span class="term"><strong class="userinput"><code>vncdisplay=int</code></strong></span></dt><dd><p>This specifies a VNC display to use. By default, VNC will attach to the display number that corresponds to the domain ID.</p></dd><dt><span class="term"><strong class="userinput"><code>vnclisten=IP</code></strong></span></dt><dd><p>This specifies an IP address on which to listen for incoming VNC connections. It overrides the value of the same name in <em class="filename">xend-config.sxp</em>.</p></dd><dt><span class="term"><strong class="userinput"><code>vncpasswd=string</code></strong><br/></span><span class="term"><strong class="userinput"><code>vncpasswd="Swordfish"</code></strong><sup>[<a id="CHP-B-FNOTE-1" href="#ftn.CHP-B-FNOTE-1" class="footnote">87</a>]</sup></span></dt><dd><p>These options set the password for the VNC console to the given value. Note that this is independent of any authentication that the domU does.</p></dd><dt><span class="term"><strong class="userinput"><code>vscsi=PDEV,VDEV,DOM *</code></strong></span></dt><dd><p>This adds a SCSI device to the domain. The paravirtualized SCSI devices are a mechanism for passing a physical SCSI generic device through to a domain. It's not meant to replace the Xen block driver. Rather, you can use pvSCSI, the SCSI pass-through mechanism, to access devices like tape drives or scanners that are hooked up to the machine's physical SCSI bus.</p></dd><dt><span class="term"><strong class="userinput"><code>vtpm=['instance=INSTANCE,backend=DOM,type=TYPE']</code></strong></span></dt><dd><p>The <code class="literal">vtpm</code> option, just like the <code class="literal">vif</code> or <code class="literal">disk</code> options, describes a virtual device—in this case, a TPM. The TPM instance name is a simple identifier; something like <code class="literal">1</code> will do just fine. The backend is the domain with access to the physical TPM. Usually <code class="literal">0</code> is a good value. Finally, type specifies the type of the TPM emulation. This can be either <code class="literal">pvm</code> or <code class="literal">hvm</code>, for paravirtualized and HVM domains, respectively.</p></dd></dl></div><div class="sect2" title="HVM Directives"><div class="titlepage"><div><div><h2 class="title"><a id="hvm_directives"/>HVM Directives</h2></div></div></div><p>Certain directives only apply if you're using Xen's hardware virtualization, HVM. Most of these enable or disable various hardware features.<a id="idx-CHP-B-1226" class="indexterm"/><a id="I_indexterm_d1e19460" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>acpi=bool</code></strong></span></dt><dd><p>The <code class="literal">acpi</code> option determines whether or not the domain will use ACPI, the Advanced Configuration and Power Interface. Turning it off may improve stability, and will enable some versions of the Windows installer to complete successfully.</p></dd><dt><span class="term"><strong class="userinput"><code>apic=bool</code></strong></span></dt><dd><p>The APIC, or Advanced Programmable Input Controller,<sup>[<a id="CHP-B-FNOTE-2" href="#ftn.CHP-B-FNOTE-2" class="footnote">88</a>]</sup> is a modern implementation of the venerable PIC. This is on by default. You may want to turn it off if your operating system has trouble with the simulated APIC.</p></dd><dt><span class="term"><strong class="userinput"><code>builder=string</code></strong></span></dt><dd><p>With <a id="idx-CHP-B-1227" class="indexterm"/>HVM domains, you'll use the HVM domain builder. With most paravirtualized domains, you'll want the default Linux domain builder. The domain builder is a bit more low level than the parts that we usually work with. For the most part, we are content to let it do its thing.</p></dd><dt><span class="term"><strong class="userinput"><code>device_model=string</code></strong></span></dt><dd><p>The <code class="literal">device_model</code> directive specifies the full path of the executable being used to emulate devices for HVM domains (and for PV domains if the framebuffer is being used). In most situations, the default <code class="literal">qemu-dm</code> should work fine.</p></dd><dt><span class="term"><strong class="userinput"><code>feature=string</code></strong></span></dt><dd><p>This is a pipe-separated list of features to enable in the guest kernel. The list of available features, fresh from the source, is as follows:</p><a id="I_programlisting_d1e19518"/><pre class="programlisting">[XENFEAT_writable_page_tables]       = "writable_page_tables",
[XENFEAT_writable_descriptor_tables] = "writable_descriptor_tables",
[XENFEAT_auto_translated_physmap]    = "auto_translated_physmap",
[XENFEAT_supervisor_mode_kernel]     = "supervisor_mode_kernel",
[XENFEAT_pae_pgdir_above_4gb]        = "pae_pgdir_above_4gb"</pre><p>We have always had good luck using the defaults for this option.</p></dd><dt><span class="term"><strong class="userinput"><code>hap=bool</code></strong></span></dt><dd><p>This directive tells the domain whether or not to take advantage of Hardware-Assisted Paging on recent machines. Implementations include AMD's <span class="emphasis"><em>nested paging</em></span> and Intel's <span class="emphasis"><em>extended paging</em></span>. If the hardware supports this feature, Xen can substantially improve HVM performance by taking advantage of it.</p></dd><dt><span class="term"><strong class="userinput"><code>loader=string</code></strong></span></dt><dd><p>This is the path to HVM firmware. We've always been completely satisfied with the default.</p></dd><dt><span class="term"><strong class="userinput"><code>pae=bool</code></strong></span></dt><dd><p>This enables or disables PAE on an <a id="idx-CHP-B-1228" class="indexterm"/>HVM domain. Note that this won't enable a non-PAE kernel to run on a PAE or 64-bit box. This option is on by default.</p></dd></dl></div></div><div class="sect2" title="Device Model Options"><div class="titlepage"><div><div><h2 class="title"><a id="device_model_options"/>Device Model Options</h2></div></div></div><p>There are some directives that specify options for the device model. As far as we know, these are specific to the QEMU-based model, but, because no others exist, it seems safe to consider them part of Xen's configuration.<a id="idx-CHP-B-1229" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>access_control_policy=POLICY,label=LABEL</code></strong></span></dt><dd><p>The <code class="literal">access_control_policy</code> directive defines the security policy and label to associate with the domain.</p></dd><dt><span class="term"><strong class="userinput"><code>blkif=bool</code></strong><br/></span><span class="term"><strong class="userinput"><code>netif=bool</code></strong><br/></span><span class="term"><strong class="userinput"><code>tpmif=bool</code></strong></span></dt><dd><p>These three variables are all Booleans. If they are enabled, the builder will make the domain a backend for the specified device type.</p><p>To use a non-dom0 backend, specify the <code class="literal">backend</code> parameter in the definition for your device of choice.</p></dd><dt><span class="term"><strong class="userinput"><code>boot=string</code></strong></span></dt><dd><p>Set <code class="literal">boot</code> to one of a, b, c, or d to boot from the first floppy, second floppy, hard drive, or CD drive, respectively.</p></dd><dt><span class="term"><strong class="userinput"><code>fda</code></strong><br/></span><span class="term"><strong class="userinput"><code>fdb=string</code></strong></span></dt><dd><p>This option specifies the disk image or device file used to emulate the first or second floppy drive—fda and fdb, respectively.</p></dd><dt><span class="term"><strong class="userinput"><code>guest_os_type=string</code></strong></span></dt><dd><p>This is the type of the guest OS. It's a free-form identifier, limited to eight characters.</p></dd><dt><span class="term"><strong class="userinput"><code>ioports=FROM-TO</code></strong><br/></span><span class="term"><strong class="userinput"><code>irq=IRQ</code></strong></span></dt><dd><p>These two options instruct Xen to forward a range of (real) ioports and an IRQ to the domU. The main use for this option that we've seen is for serial ports, so that the domU has access to a physical serial port on the server.</p></dd><dt><span class="term"><strong class="userinput"><code>keymap=string</code></strong></span></dt><dd><p>The <code class="literal">keymap</code> option specifies a keymap file by name. Xen (or rather, the device model) keeps its keymaps under <span class="emphasis"><em>/usr/share/xen/qemu/keymaps</em></span>. On our machines, the default is <code class="literal">en-us</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>localtime=bool</code></strong></span></dt><dd><p>This is a simple Boolean option indicating whether the hardware clock is set to local time or GMT.<a id="I_indexterm_d1e19650" class="indexterm"/></p></dd><dt><span class="term"><strong class="userinput"><code>monitor=string</code></strong></span></dt><dd><p>If <code class="literal">monitor</code> is set to <code class="literal">yes</code>, the device model will attach the QEMU monitor, which you can use to give commands to the device model. Use CTRL-ALT-2 to break out to the monitor. From there, you can issue commands—try <code class="literal">help</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>nographic=bool</code></strong></span></dt><dd><p>This indicates whether the device model should use graphics.</p></dd><dt><span class="term"><strong class="userinput"><code>serial</code></strong></span></dt><dd><a id="I_programlisting_d1e19681"/><pre class="programlisting">serial='file:/filename'
serial='/dev/pts/n'
serial='pty'
serial='stdio'</pre><p>The <code class="literal">serial</code> option specifies a file (or file-like object, such as a named pipe) to use as an emulated serial port. Other options are to have Xen pick a <code class="literal">pty</code>, or use STDIN and STDOUT for its serial port; <code class="literal">none</code> is also a valid option.</p></dd><dt><span class="term"><strong class="userinput"><code>soundhw=bool</code></strong></span></dt><dd><p>This indicates whether to emulate an audio device.</p></dd><dt><span class="term"><strong class="userinput"><code>stdvga=bool</code></strong></span></dt><dd><p>If <code class="literal">stdvga</code> is set to <code class="literal">yes</code>, the device model will use standard VGA emulation. If it's set to <code class="literal">no</code> or omitted, it'll use emulated Cirrus Logic graphics instead. Ordinarily, the default is just fine.</p></dd><dt><span class="term"><strong class="userinput"><code>usb=bool</code></strong></span></dt><dd><p>This is a Boolean value that indicates whether to emulate USB.</p></dd><dt><span class="term"><strong class="userinput"><code>usbdevice=HOST:id:id</code></strong></span></dt><dd><p>This item indicates the name of the USB device to add.</p></dd></dl></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-B-FNOTE-1" href="#CHP-B-FNOTE-1" class="para">87</a>] </sup>Terry Pratchett, in <em class="citetitle">Night Watch</em>, has this to say on the subject of passwords: "Every password was 'swordfish'! Whenever anyone tried to think of a word that no one would ever guess, they always chose 'swordfish.' It was just one of those strange quirks of the human mind."</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-B-FNOTE-2" href="#CHP-B-FNOTE-2" class="para">88</a>] </sup>"It's not stupid, it's advanced." —Invader Zim</p></div></div></div></body></html>