- en: isolation.tools.setVersion.disable = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: isolation.tools.getVersion.disable = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_directexec = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_chksimd = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_ntreloc = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_selfmod = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_reloc = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_btinout = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_btmemspace = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_btpriv = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: monitor_control.disable_btseg = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-5: VMware’s* .vmx *file undocumented options used to thwart anti-VM
    techniques* The directexec parameter causes user-mode code to be emulated, instead
    of being run directly on the CPU, thus thwarting certain anti-VM techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: The first four settings are used by VMware backdoor commands so that VMware
    Tools running in the guest cannot get information about the host.
  prefs: []
  type: TYPE_NORMAL
- en: These changes will protect against all of ScoopyNG’s checks, other than the
    sixth, when running on a multiprocessor machine. However, we do not recommend
    using these settings in VMware, because they disable the usefulness of VMware
    Tools and they may have serious negative effects on the performance of your virtual
    machines. Add these options only after you’ve Anti-Virtual Machine Techniques
  prefs: []
  type: TYPE_NORMAL
- en: '**379**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: exhausted all other techniques. These techniques have been mentioned for completeness,
    but modifying a *.vmx* file to try to catch ten of the potentially hundreds of
    ways that VMware might be detected can be a bit of a wild-goose chase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Escaping the Virtual Machine**'
  prefs: []
  type: TYPE_NORMAL
- en: VMware has its vulnerabilities, which can be exploited to crash the host operating
    system or even run code in it.
  prefs: []
  type: TYPE_NORMAL
- en: Many publicized vulnerabilities are found in VMware’s shared folders feature
    or in tools that exploit the drag-and-drop functionality of VMware Tools.
  prefs: []
  type: TYPE_NORMAL
- en: One well-publicized vulnerability uses shared folders to allow a guest to write
    to any file on the host operating system in order to modify or compromise the
    host operating system. Although this particular technique doesn’t work with the
    current version of VMware, several different flaws have been discovered in the
    shared folders feature. Disable shared folders in the virtual machine settings
    to prevent this type of attack.
  prefs: []
  type: TYPE_NORMAL
- en: Another well-publicized vulnerability was found in the virtual machine display
    function in VMware. An exploit for this vulnerability is known as Cloudburst,
    and it is publicly available as part of the Canvas penetration-testing tool (this
    vulnerability has also been patched by VMware).
  prefs: []
  type: TYPE_NORMAL
- en: Certain publicly available tools assist in exploiting VMware once the host has
    been infected, including VMchat, VMcat, VMftp, VMdrag-n-hack, and VMdrag-n-sploit.
    These tools are of little use until you have escaped the virtual machine, and
    you shouldn’t need to worry about them if malware is being run in the virtual
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced the most popular anti-VMware techniques. Because malware
    authors use these techniques to slow down analysis, it’s important to be able
    to recognize them. We have explained these techniques in detail so that you can
    find them in disassembly or debugging, and we’ve explored ways to overcome them
    without needing to modify malware at the disassembly level.
  prefs: []
  type: TYPE_NORMAL
- en: When performing basic dynamic analysis, you should always use a virtual machine.
    However, if your subject malware doesn’t seem to run, consider trying another
    virtual machine with VMware Tools uninstalled before debugging or disassembling
    the malware in search of virtual machine detection.
  prefs: []
  type: TYPE_NORMAL
- en: You might also run your subject malware in a different virtual environment (like
    VirtualBox or Parallels) or even on a physical machine.
  prefs: []
  type: TYPE_NORMAL
- en: As with anti-debugging techniques, anti-VM techniques can be spotted using common
    sense while slowly debugging a process. For example, if you see code terminating
    prematurely at a conditional jump, it may be doing so as a result of an anti-VM
    technique. As always, be aware of these types of issues and look ahead in the
    code to determine what action to take.
  prefs: []
  type: TYPE_NORMAL
- en: '**380**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 17-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in *Lab17-01.exe* inside VMware. This is the same
    malware as *Lab07-01.exe*, with added anti-VMware techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The anti-VM techniques found in this lab may not work in your environment.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What anti-VM techniques does this malware use?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the commercial version of IDA Pro, run the IDA Python script from
    Listing 17-4 in Chapter 17 (provided here as *findAntiVM.py*).
  prefs: []
  type: TYPE_NORMAL
- en: What does it find?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when each anti-VM technique succeeds?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these anti-VM techniques work against your virtual machine?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Why does each anti-VM technique work or fail?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: How could you disable these anti-VM techniques and get the malware to run?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 17-2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Analyze the malware found in the file *Lab17-02.dll* inside VMware. After answering
    the first question in this lab, try to run the installation exports using *rundll32.exe*
    and monitor them with a tool like procmon. The following is an example command
    line for executing the DLL:'
  prefs: []
  type: TYPE_NORMAL
- en: rundll32.exe Lab17-02.dll,InstallRT (or InstallSA/InstallSB)
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What are the exports for this DLL?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens after the attempted installation using *rundll32.exe*?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Which files are created and what do they contain?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What method of anti-VM is in use?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: How could you force the malware to install during runtime?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: How could you permanently disable the anti-VM technique?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: How does each installation export function work?
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Virtual Machine Techniques
  prefs: []
  type: TYPE_NORMAL
- en: '**381**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 17-3**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware *Lab17-03.exe* inside VMware. This lab is similar to *Lab12-02.exe*,
    with added anti-VMware techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you run this malware in a virtual machine?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: How could you get this malware to run and drop its keylogger?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Which anti-VM techniques does this malware use?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What system changes could you make to permanently avoid the anti-VM
  prefs: []
  type: TYPE_NORMAL
- en: techniques used by this malware?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: How could you patch the binary in OllyDbg to force the anti-VM techniques to
    permanently fail?
  prefs: []
  type: TYPE_NORMAL
- en: '**382**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**P A C K E R S A N D U N P A C K I N G**'
  prefs: []
  type: TYPE_NORMAL
- en: Packing programs, known as *packers*, have become
  prefs: []
  type: TYPE_NORMAL
- en: extremely popular with malware writers because they
  prefs: []
  type: TYPE_NORMAL
- en: help malware hide from antivirus software, complicate
  prefs: []
  type: TYPE_NORMAL
- en: malware analysis, and shrink the size of a malicious
  prefs: []
  type: TYPE_NORMAL
- en: executable. Most packers are easy to use and are freely available. Basic static
    analysis isn’t useful on a packed program; packed malware must be unpacked before
    it can be analyzed statically, which makes analysis more complicated and challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packers are used on executables for two main reasons: to shrink programs or
    to thwart detection or analysis. Even though there are a wide variety of packers,
    they all follow a similar pattern: They transform an executable to create a new
    executable that stores the transformed executable as data and contains an unpacking
    stub that is called by the OS.'
  prefs: []
  type: TYPE_NORMAL
- en: We begin this chapter with some background information about how packers work
    and how to recognize them. Then we will discuss unpacking strategies, starting
    with simple ones and then moving on to strategies that are progressively more
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Packer Anatomy**'
  prefs: []
  type: TYPE_NORMAL
- en: When malware has been packed, an analyst typically has access to only the packed
    file, and cannot examine the original unpacked program or the program that packed
    the malware. In order to unpack an executable, we must undo the work performed
    by the packer, which requires that we understand how a packer operates.
  prefs: []
  type: TYPE_NORMAL
- en: All packers take an executable file as input and produce an executable file
    as output. The packed executable is compressed, encrypted, or otherwise transformed,
    making it harder to recognize and reverse-engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Most packers use a compression algorithm to compress the original executable.
    A packer designed to make the file difficult to analyze may encrypt the original
    executable and employ anti-reverse-engineering techniques, such as anti-disassembly,
    anti-debugging, or anti-VM. Packers can pack the entire executable, including
    all data and the resource section, or pack only the code and data sections.
  prefs: []
  type: TYPE_NORMAL
- en: To maintain the functionality of the original program, a packing program needs
    to store the program’s import information. The information can be stored in any
    format, and there are several common strategies, which are covered in depth later
    in this chapter. When unpacking a program, reconstructing the import section can
    sometimes be challenging and time-consuming, but it’s necessary for analyzing
    the program’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Unpacking Stub***'
  prefs: []
  type: TYPE_NORMAL
- en: Nonpacked executables are loaded by the OS. With packed programs, the unpacking
    stub is loaded by the OS, and then the unpacking stub loads the original program.
    The code entry point for the executable points to the unpacking stub rather than
    the original code. The original program is generally stored in one or more extra
    sections of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unpacking stub can be viewed by a malware analyst, and understanding the
    different parts of the stub is fundamental to unpacking the executable. The unpacking
    stub is often small, since it does not contribute to the main functionality of
    the program, and its function is typically simple: unpack the original executable.
    If you attempt to perform static analysis on the packed program, you will be analyzing
    the stub, not the original program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The unpacking stub performs three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Unpacks the original executable into memory
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Resolves all of the imports of the original executable
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Transfers execution to the original entry point (OEP)
  prefs: []
  type: TYPE_NORMAL
- en: '***Loading the Executable***'
  prefs: []
  type: TYPE_NORMAL
- en: When regular executables load, a loader reads the PE header on the disk, and
    allocates memory for each of the executable’s sections based on that header. The
    loader then copies the sections into the allocated spaces in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**384**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Packed executables also format the PE header so that the loader will allocate
    space for the sections, which can come from the original program, or the unpacking
    stub can create the sections. The unpacking stub unpacks the code for each section
    and copies it into the space that was allocated. The exact unpacking method used
    depends on the goals of the packer, and it is generally contained within the stub.
  prefs: []
  type: TYPE_NORMAL
- en: '***Resolving Imports***'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in Chapter 1, nonpacked PE files include a section that tells the
    loader which functions to import, and another section that stores the addresses
    of the names of all the imported functions. The Windows loader reads the import
    information, determines which functions are needed, and then fills in the addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows loader cannot read import information that is packed. For a packed
    executable, the unpacking stub will resolve the imports. The specific approach
    depends on the packer.
  prefs: []
  type: TYPE_NORMAL
- en: The most common approach is to have the unpacking stub import only the LoadLibrary
    and GetProcAddress functions. After the unpacking stub unpacks the original executable,
    it reads the original import information. It will call LoadLibrary for each library,
    in order to load the DLL into memory, and will then use GetProcAddress to get
    the address for each function.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to keep the original import table intact, so that the Windows
    loader can load the DLLs and the imported functions. This is the simplest approach,
    since the unpacking stub does not need to resolve the imports. However, static
    analysis of the packed program will reveal all the original imports, so this approach
    lacks stealth. Additionally, since the imported functions are stored in plaintext
    in the executable, the compression possible with this approach is not optimal.
  prefs: []
  type: TYPE_NORMAL
- en: A third approach is to keep one import function from each DLL contained in the
    original import table. This approach will reveal only one function per imported
    library during analysis, so it’s stealthier than the previous approach, but analysis
    will still reveal all the libraries that are imported. This approach is simpler
    for the packer to implement than the first approach, since the libraries do not
    need to be loaded by the unpacking stub, but the unpacking stub must still resolve
    the majority of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: The final approach is the removal of all imports (including LoadLibrary and
    GetProcAddress). The packer must find all the functions needed from other libraries
    without using functions, or it must find LoadLibrary and GetProcAddress, and use
    them to locate all the other libraries. This process is discussed in Chapter 19,
    because it is similar to what shellcode must do.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this approach is that the packed program includes no imports
    at all, which makes it stealthy. However, in order to use this approach, the unpacking
    stub must be complex.
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**385**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Tail Jump***'
  prefs: []
  type: TYPE_NORMAL
- en: Once the unpacking stub is complete, it must transfer execution to the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction that transfers execution to the OEP is commonly referred to
    as the *tail jump*.
  prefs: []
  type: TYPE_NORMAL
- en: A jump instruction is the simplest and most popular way to transfer execution.
    Since it’s so common, many malicious packers will attempt to obscure this function
    by using a ret or call instruction. Sometimes the tail jump is obscured with OS
    functions that transfer control, such as NtContinue or ZwContinue.
  prefs: []
  type: TYPE_NORMAL
- en: '***Unpacking Illustrated***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figures 18-1 through 18-4 illustrate the packing and unpacking process, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18-1 shows the original executable. The header and sections are visible,
    and the starting point is set to the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18-2 shows the packed executable as it exists on disk. All that is visible
    is the new header, the unpacking stub, and packed original code.
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs: []
  type: TYPE_NORMAL
- en: Exports
  prefs: []
  type: TYPE_NORMAL
- en: Entry Point
  prefs: []
  type: TYPE_NORMAL
- en: .text Section
  prefs: []
  type: TYPE_NORMAL
- en: Entry Point
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs: []
  type: TYPE_NORMAL
- en: .data Section
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking Stub
  prefs: []
  type: TYPE_NORMAL
- en: Packed
  prefs: []
  type: TYPE_NORMAL
- en: .rsrc Section
  prefs: []
  type: TYPE_NORMAL
- en: Original Code
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-1: The original executable,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-2: The packed executable,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*prior to packing*'
  prefs: []
  type: TYPE_NORMAL
- en: '*after the original code is packed and*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the unpacking stub is added*'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18-3 shows the packed executable as it exists when it’s loaded into memory.
    The unpacking stub has unpacked the original code, and valid
  prefs: []
  type: TYPE_NORMAL
- en: .text and .data sections are visible. The starting point for the executable
    still points to the unpacking stub, and the import table is usually not valid
    at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Figure 18-4 shows the fully unpacked executable. The import table has been reconstructed,
    and the starting point has been edited to point to the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the final unpacked program is different than the original program.
    The unpacked program still has the unpacking stub and any other code that the
    packing program added. The unpacking program has a PE
  prefs: []
  type: TYPE_NORMAL
- en: header that has been reconstructed by the unpacker and will not be exactly the
    same as the original program.
  prefs: []
  type: TYPE_NORMAL
- en: '**386**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs: []
  type: TYPE_NORMAL
- en: Exports
  prefs: []
  type: TYPE_NORMAL
- en: Entry Point
  prefs: []
  type: TYPE_NORMAL
- en: Exports
  prefs: []
  type: TYPE_NORMAL
- en: .text Section
  prefs: []
  type: TYPE_NORMAL
- en: .text Section
  prefs: []
  type: TYPE_NORMAL
- en: .data Section
  prefs: []
  type: TYPE_NORMAL
- en: .data Section
  prefs: []
  type: TYPE_NORMAL
- en: .rsrc Section
  prefs: []
  type: TYPE_NORMAL
- en: .rsrc Section
  prefs: []
  type: TYPE_NORMAL
- en: Entry Point
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking Stub
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking Stub
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-3: The program after being*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-4: The fully unpacked*'
  prefs: []
  type: TYPE_NORMAL
- en: '*unpacked and loaded into memory. The*'
  prefs: []
  type: TYPE_NORMAL
- en: '*program. The import table is*'
  prefs: []
  type: TYPE_NORMAL
- en: '*unpacking stub unpacks everything neces-*'
  prefs: []
  type: TYPE_NORMAL
- en: '*reconstructed, and the starting*'
  prefs: []
  type: TYPE_NORMAL
- en: '*sary for the code to run. The program’s*'
  prefs: []
  type: TYPE_NORMAL
- en: '*point is back to the original entry*'
  prefs: []
  type: TYPE_NORMAL
- en: '*starting point still points to the unpacking*'
  prefs: []
  type: TYPE_NORMAL
- en: '*point (OEP).*'
  prefs: []
  type: TYPE_NORMAL
- en: '*stub, and there are no imports.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying Packed Programs**'
  prefs: []
  type: TYPE_NORMAL
- en: An early step when analyzing malware is to recognize that it is packed. We have
    covered techniques for detecting if malware is packed in earlier chapters. Here,
    we’ll provide a review and also introduce a new technique.
  prefs: []
  type: TYPE_NORMAL
- en: '***Indicators of a Packed Program***'
  prefs: []
  type: TYPE_NORMAL
- en: The following list summarizes signs to look for when determining whether malware
    is packed.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The program has few imports, and particularly if the only imports are LoadLibrary
    and GetProcAddress.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: When the program is opened in IDA Pro, only a small amount of code is recognized
    by the automatic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: When the program is opened in OllyDbg, there is a warning that the program may
    be packed.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The program shows section names that indicate a particular packer (such as UPX0).
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The program has abnormal section sizes, such as a .text section with a Size
    of Raw Data of 0 and Virtual Size of nonzero.
  prefs: []
  type: TYPE_NORMAL
- en: Packer-detection tools such as PEiD can also be used to determine if an executable
    is packed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Entropy Calculation***'
  prefs: []
  type: TYPE_NORMAL
- en: Packed executables can also be detected via a technique known as *entropy* *calculation*.
    Entropy is a measure of the disorder in a system or program, and while there is
    not a well-defined standard mathematical formula for calculating entropy, there
    are many well-formed measures of entropy for digital data.
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**387**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Compressed or encrypted data more closely resembles random data, and therefore
    has high entropy; executables that are not encrypted or compressed have lower
    entropy.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tools for detecting packed programs often use heuristics like entropy.
    One such free automated tool is Mandiant Red Curtain, which calculates a threat
    score for any executable using measures such as entropy. Red Curtain can scan
    a filesystem for suspected packed binaries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unpacking Options**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three options for unpacking a packed executable: automated static
    unpacking, automated dynamic unpacking, and manual dynamic unpacking. The automated
    unpacking techniques are faster and easier than manual dynamic unpacking, but
    automated techniques don’t always work. If you have identified the kind of packer
    used, you should determine if an automated unpacker is available. If not, you
    may be able to find information about how to unpack the packer manually.'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with packed malware, remember that your goal is to analyze the
    behavior of the malware, which does not always require you to re-create the original
    malware. Most of the time, when you unpack malware, you create a new binary that
    is not identical to the original, but does all the same things as the original.
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated Unpacking**'
  prefs: []
  type: TYPE_NORMAL
- en: Automated static unpacking programs decompress and/or decrypt the executable.
    This is the fastest method, and when it works, it is the best method, since it
    does not run the executable, and it restores the executable to its original state.
    Automatic static unpacking programs are specific to a single packer, and they
    will not work on packers that are designed to thwart analysis.
  prefs: []
  type: TYPE_NORMAL
- en: PE Explorer, a free program for working with EXE and DLL files, comes with several
    static unpacking plug-ins as part of the default setup. The default plug-ins support
    NSPack, UPack, and UPX. Unpacking files with PE Explorer is completely seamless.
    If PE Explorer detects that a file you’ve chosen to open is packed, it will automatically
    unpack the executable. Note that if you want to examine the unpacked executable
    outside PE Explorer, you’ll need to save it.
  prefs: []
  type: TYPE_NORMAL
- en: Automated dynamic unpackers run the executable and allow the unpacking stub
    to unpack the original executable code. Once the original executable is unpacked,
    the program is written to disk, and the unpacker reconstructs the original import
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The automated unpacking program must determine where the unpacking stub ends
    and the original executable begins, which is difficult. When the packer fails
    to identify the end of the unpacking stub correctly, unpacking fails.
  prefs: []
  type: TYPE_NORMAL
- en: '**388**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, currently there are no good publicly available automated dynamic
    unpackers. Many publicly available tools will do an adequate job on some packers,
    but none is quite ready for serious usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both automated unpacking techniques work quickly and are easy to use, but they
    have limited success. A malware analyst must know the difference between automated
    static and dynamic unpackers: Automated dynamic unpacking programs run the malicious
    executable, and automated static unpacking programs do not. Any time that the
    malicious program will run, it is necessary to make sure that happens in a safe
    environment, as discussed in Chapter 2\.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual Unpacking**'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, packed malware can be unpacked automatically by an existing program,
    but more often it must be unpacked manually. Manual unpacking can sometimes be
    done quickly, with minimal effort; other times it can be a long, arduous process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common approaches to manually unpacking a program:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Discover the packing algorithm and write a program to run it in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: By running the algorithm in reverse, the program undoes each of the steps of
    the packing program. There are automated tools that do this, but this approach
    is still inefficient, since the program written to unpack the malware will be
    specific to the individual packing program used. So, even with automation, this
    process takes a significant amount of time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Run the packed program so that the unpacking stub does the work for you, and
    then dump the process out of memory, and manually fix up the PE header so that
    the program is complete. This is the more efficient approach.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through a simple manual unpacking process. For the purposes of this
    example, we’ll unpack an executable that was packed with UPX. Although UPX can
    easily be unpacked automatically with the UPX
  prefs: []
  type: TYPE_NORMAL
- en: program, it is simple and makes a good example. You’ll work through this process
    yourself in the first lab for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by loading the packed executable into OllyDbg. The first step is to find
    the OEP, which was the first instruction of the program before it was packed.
    Finding the OEP for a function can be one of the more difficult tasks in the manual
    unpacking process, and will be covered in detail later in the chapter. For this
    example, we will use an automated tool that is a part of the OllyDump plug-in
    for OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*OllyDump, a plug-in for OllyDbg, has two good features for unpacking: It can*
    *dump the memory of the current process, and it can search for the OEP for a packed*
    *executable.*'
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**389**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: In OllyDbg, select **Plugins****OllyDump****Find OEP by Section Hop**. The
    program will hit a breakpoint just before the OEP executes.
  prefs: []
  type: TYPE_NORMAL
- en: When that breakpoint is hit, all of the code is unpacked into memory, and the
    original program is ready to be run, so the code is visible and available for
    analysis. The only remaining step is to modify the PE header for this code so
    that our analysis tools can interpret the code properly.
  prefs: []
  type: TYPE_NORMAL
- en: The debugger will be broken on the instruction that is the OEP. Write down the
    value of the OEP, and do not close OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll use the OllyDump plug-in to dump the executable. Select **Plugins****OllyDump****Dump
    Debugged Process**. This will dump everything from process memory onto disk. There
    are a few options on the screen for dumping the file to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'If OllyDbg just dumped the program without making any changes, then the dumped
    program will include the PE header of the packed program, which is not the same
    as the PE header of the unpacked program. We would need to change two things to
    correct the header:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The import table must be reconstructed.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The entry point in the PE header must point to the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, if you don’t change any of the options on the dump screen, OllyDump
    will perform these steps automatically. The entry point of the executable will
    be set to the current instruction pointer, which in this case was the OEP, and
    the import table will be rebuilt. Click the **Dump** button, and you are finished
    unpacking this executable. We were able to unpack this program in just a few simple
    steps because OEP was located and the import table was reconstructed automatically
    by OllyDump. With complex unpackers it will not be so simple and the rest of the
    chapter covers how to unpack when OllyDump fails.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rebuilding the Import Table with Import Reconstructor***'
  prefs: []
  type: TYPE_NORMAL
- en: Rebuilding the import table is complicated, and it doesn’t always work in OllyDump.
    The unpacking stub must resolve the imports to allow the application to run, but
    it does not need to rebuild the original import table. When OllyDbg fails, it’s
    useful to try to use Import Reconstructor (ImpRec) to perform these steps.
  prefs: []
  type: TYPE_NORMAL
- en: ImpRec can be used to repair the import table for packed programs.
  prefs: []
  type: TYPE_NORMAL
- en: Run ImpRec, and open the drop-down menu at the top of the screen. You should
    see the running processes. Select the packed executable. Next, enter the RVA value
    of the OEP (not the entire address) in the OEP field on the right. For example,
    if the image base is 0x400000 and the OEP is 0x403904, enter **0x3904**. Next,
    click the **IAT autosearch** button. You should see a window with a message stating
    that ImpRec found the original import address table (IAT). Now click **GetImports**.
    A listing of all the files with imported functions should appear on the left side
    of the main window. If the operation was successful, all the imports should say
    valid:YES. If the GetImports function was not successful, then the import table
    cannot be fixed automatically using ImpRec.
  prefs: []
  type: TYPE_NORMAL
- en: '**390**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for manually fixing the table are discussed later in this chapter.
    For now, we’ll assume that the import table was discovered successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Fix Dump** button. You’ll be asked for the path to the file that
    you dumped earlier with OllyDump, and ImpRec will write out a new file with an
    underscore appended to the filename.
  prefs: []
  type: TYPE_NORMAL
- en: You can execute the file to make sure that everything has worked, if you’re
    not sure whether you’ve done it correctly. This basic unpacking process will work
    for most packed executables, and should be tried first.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the biggest challenge of manually unpacking malware is
    finding the OEP, as we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding the OEP***'
  prefs: []
  type: TYPE_NORMAL
- en: There are many strategies for locating the OEP, and no single strategy will
    work against all packers. Analysts generally develop personal preferences, and
    they will try their favorite strategies first. But to be successful, analysts
    must be familiar with many techniques in case their favorite method does not work.
    Choosing the wrong technique can be frustrating and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the OEP is a skill that must be developed with practice. This section
    contains a variety of strategies to help you develop your skills, but the only
    way to really learn is to practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to find the OEP, you need to run the malicious program in a debugger
    and use single-stepping and breakpoints. Recall the different types of breakpoints
    described in Chapter 8\. OllyDbg offers four types of breakpoints, which are triggered
    by different conditions: the standard INT 3 breakpoints, the memory breakpoint
    provided by OllyDbg, hardware breakpoints, and run tracing with break conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: Packed code and the unpacking stub are often unlike the code that debuggers
    ordinarily deal with. Packed code is often self-modifying, containing call instructions
    that do not return, code that is not marked as code, and other oddities. These
    features can confuse the debuggers and cause breakpoints to fail.
  prefs: []
  type: TYPE_NORMAL
- en: Using an automated tool to find the OEP is the easiest strategy, but much like
    the automated unpacking approach, these tools do not always work. You may need
    to find the OEP manually.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Automated Tools to Find the OEP**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we used an automated tool to find the OEP. The most
    commonly used automatic tool for finding the OEP is the OllyDump plug-in within
    OllyDbg, called Find OEP by Section Hop. Normally, the unpacking stub is in one
    section and the executable is packed into another section. OllyDbg detects when
    there is a transfer from one section to another and breaks there, using either
    the step-over or step-into method. The step-over method will step-over any call
    instructions. Calls are often used to execute code in another section, and this
    method is designed to prevent OllyDbg from incorrectly labeling those calls the
    OEP. However, if a call function does not return, then OllyDbg will not locate
    the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**391**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Malicious packers often include call functions that do not return in an effort
    to confuse the analyst and the debugger. The step-into option steps into each
    call function, so it’s more likely to find the OEP, but also more likely to produce
    false positives. In practice you should try both the step-over and the step-into
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the OEP Manually**'
  prefs: []
  type: TYPE_NORMAL
- en: When automated methods for finding the OEP fail, you will need to find it manually.
    The simplest manual strategy is to look for the tail jump. As mentioned earlier,
    this instruction jumps from the unpacking stub to the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, it’s a jmp instruction, but some malware authors make it a ret instruction
    in order to evade detection.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the tail jump is the last valid instruction before a bunch of bytes that
    are invalid instructions. These bytes are padding to ensure that the section is
    properly byte-aligned. Generally, IDA Pro is used to search through the packed
    executable for the tail jump. Listing 18-1 shows a simple tail jump example.
  prefs: []
  type: TYPE_NORMAL
- en: 00416C31 PUSH EDI
  prefs: []
  type: TYPE_NORMAL
- en: 00416C32 CALL EBP
  prefs: []
  type: TYPE_NORMAL
- en: 00416C34 POP EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00416C35 POPAD
  prefs: []
  type: TYPE_NORMAL
- en: 00416C36 LEA EAX,DWORD PTR SS:[ESP-80]
  prefs: []
  type: TYPE_NORMAL
- en: 00416C3A PUSH 0
  prefs: []
  type: TYPE_NORMAL
- en: 00416C3C CMP ESP,EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00416C3E JNZ SHORT Sample84.00416C3A
  prefs: []
  type: TYPE_NORMAL
- en: 00416C40 SUB ESP,-80
  prefs: []
  type: TYPE_NORMAL
- en: 00416C43 JMP Sample84.00401000
  prefs: []
  type: TYPE_NORMAL
- en: 00416C48 DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00416C49 DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00416C4A DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00416C4B DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00416C4C DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00416C4D DB 00
  prefs: []
  type: TYPE_NORMAL
- en: 00416C4E DB 00
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-1: A simple tail jump*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows the tail jump for UPX at , which is located at address
    0x00416C43\. Two features indicate clearly that this is the tail jump: It’s located
    at the end of the code, and it links to an address that is very far away. If we
    were examining this jump in a debugger, we would see that there are hundreds of
    0x00 bytes after the jump, which is uncommon; a return generally follows a jump,
    but this one isn’t followed by any meaningful code.'
  prefs: []
  type: TYPE_NORMAL
- en: The other feature that makes this jump stick out is its size. Normally, jumps
    are used for conditional statements and loops, and go to addresses that are within
    a few hundred bytes, but this jump goes to an address that’s 0x15C43 bytes away.
    That is not consistent with a reasonable jmp statement.
  prefs: []
  type: TYPE_NORMAL
- en: The graph view in IDA Pro often makes the tail jump very easy to spot, as shown
    in Figure 18-5\. IDA Pro colors a jump red when it can’t determine **392**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 89](index-426_1.png)'
  prefs: []
  type: TYPE_IMG
- en: where the jump goes. Normally, jumps are within the same function, and IDA Pro
    will draw an arrow to the target of a jmp instruction. In the case of a tail jump,
    IDA Pro encounters an error and colors the jump red.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-5: A tail jump is highlighted in red in the IDA Pro graph view.*'
  prefs: []
  type: TYPE_NORMAL
- en: The tail jump transfers execution to the original program, which is packed on
    disk. Therefore, the tail jump goes to an address that does not contain valid
    instructions when the unpacking stub starts, but does contain valid instructions
    when the program is running. Listing 18-2 shows the disassembly at the address
    of the jump target when the program is loaded in OllyDbg. The instruction ADD
    BYTE PTR DS:[EAX],AL corresponds to two 0x00
  prefs: []
  type: TYPE_NORMAL
- en: bytes, which is not a valid instruction, but OllyDbg is attempting to disassemble
    this instruction anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 00401000 ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 00401002 ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 00401004 ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 00401006 ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 00401008 ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 0040100A ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 0040100C ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: 0040100E ADD BYTE PTR DS:[EAX],AL
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-2: Instruction bytes stored at OEP before the original program
    is unpacked* Packers and Unpacking'
  prefs: []
  type: TYPE_NORMAL
- en: '**393**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 18-3 contains the disassembly found at the same address when the tail
    jump is executed. The original executable has been unpacked, and there are now
    valid instructions at that location. This change is another hall-mark of a tail
    jump.
  prefs: []
  type: TYPE_NORMAL
- en: 00401000 CALL Sample84.004010DC
  prefs: []
  type: TYPE_NORMAL
- en: 00401005 TEST EAX,EAX
  prefs: []
  type: TYPE_NORMAL
- en: 00401007 JNZ SHORT Sample84.0040100E
  prefs: []
  type: TYPE_NORMAL
- en: 00401009 CALL Sample84.00401018
  prefs: []
  type: TYPE_NORMAL
- en: 0040100E PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: 0040100F CALL DWORD PTR DS:[414304] ; kernel32.ExitProcess 00401015 RETN
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-3: Instruction bytes stored at OEP after the original program is
    unpacked* Another way to find the tail jump is to set a read breakpoint on the
    stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember for read breakpoints, you must use either a hardware breakpoint or
    an OllyDbg memory breakpoint. Most functions in disassembly, including the unpacking
    stub, begin with a push instruction of some sort, which you can use to your advantage.
    First, make a note of the memory address on the stack where the first value is
    pushed, and then set a breakpoint on read for that stack location.
  prefs: []
  type: TYPE_NORMAL
- en: After that initial push, everything else on the stack will be higher on the
    stack (at a lower memory address). Only when the unpacking stub is complete will
    that stack address from the original push be accessed. Therefore, that address
    will be accessed via a pop instruction, which will hit the breakpoint and break
    execution. The tail jump is generally just after the pop instruction. It’s often
    necessary to try several different types of breakpoints on that address. A hardware
    breakpoint on read is a good type to try first.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the OllyDbg interface does not allow you to set a breakpoint in the
    stack window. You must view the stack address in the memory dump window and set
    a breakpoint on it there.
  prefs: []
  type: TYPE_NORMAL
- en: Another strategy for manually finding OEP is to set breakpoints after every
    loop in the code. This allows you to monitor each instruction being executed without
    consuming a huge amount of time going through the same code in a loop over and
    over again. Normally, the code will have several loops, including loops within
    loops. Identify the loops by scanning through the code and setting a breakpoint
    after each loop. This method is manually intensive and generally takes longer
    than other methods, but it is easy to comprehend. The biggest pitfall with this
    method is setting a breakpoint in the wrong place, which will cause the executable
    to run to completion without hitting the breakpoint. If this happens, don’t be
    discouraged. Go back to where you left off and keeping setting breakpoints further
    along in the process until you find the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Another common pitfall is stepping over a function call that never returns.
  prefs: []
  type: TYPE_NORMAL
- en: When you step-over the function call, the program will continue to run, and
    the breakpoint will never be hit. The only way to address this is to start over,
    return to the same function call, and step-into the function instead of stepping
    **394**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: over it. Stepping into every function can be time consuming, so it’s advisable
    to use trial and error to determine when to step-over versus step-into.
  prefs: []
  type: TYPE_NORMAL
- en: Another strategy for finding the tail jump is to set a breakpoint on GetProcAddress.
    Most unpackers will use GetProcAddress to resolve the imports for the original
    function. A breakpoint that hits on GetProcAddress is far into the unpacking stub,
    but there is still a lot of code before the tail jump. Setting a breakpoint at
    GetProcAddress allows you to bypass the beginning of the unpacking stub, which
    often contains the most complicated code.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to set a breakpoint on a function that you know will be
    called by the original program and work backward. For example, in most Windows
    programs, the OEP can be found at the beginning of a standard wrapper of code
    that is outside the main method. Because the wrapper is always the same, you can
    find it by setting a breakpoint on one of the functions it calls.
  prefs: []
  type: TYPE_NORMAL
- en: For command-line programs, this wrapper calls the GetVersion and GetCommandLineA
    functions very early in the process, so you can try to break when those functions
    are called. The program isn’t loaded yet, so you can’t set a breakpoint on the
    call to GetVersion, but you can set one on the first instruction of GetVersion,
    which works just as well.
  prefs: []
  type: TYPE_NORMAL
- en: In GUI programs, GetModuleHandleA is usually the first function to be called.
    After the program breaks, examine the previous stack frame to see where the call
    originated. There’s a good chance that the beginning of the function that called
    GetModuleHandleA or GetVersion is the OEP. Beginning at the call instruction,
    scroll up and search for the start of the function. Most functions start with
    push ebp, followed by mov ebp, esp. Try to dump the program with the beginning
    of that function as the OEP. If you’re right, and that function is the OEP, then
    you are finished. If you’re wrong, then the program will still be dumped, because
    the unpacking stub has already finished.
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to view and navigate the program in IDA Pro, but you won’t
    necessarily know where the program starts. You might get lucky and IDA Pro might
    automatically identify WinMain or DllMain.
  prefs: []
  type: TYPE_NORMAL
- en: The last tactic for locating the OEP is to use the Run Trace option in OllyDbg.
    Run Trace gives you a number of additional breakpoint options, and allows you
    to set a breakpoint on a large range of addresses. For example, many packers leave
    the .text section for the original file. Generally, there is nothing in the .text
    section on disk, but the section is left in the PE header so that the loader will
    create space for it in memory. The OEP is always within the original .text section,
    and it is often the first instruction called within that section. The Run Trace
    option allows you to set a breakpoint to trigger whenever any instruction is executed
    within the .text section. When the breakpoint is triggered, the OEP can usually
    be found.
  prefs: []
  type: TYPE_NORMAL
- en: '***Repairing the Import Table Manually***'
  prefs: []
  type: TYPE_NORMAL
- en: OllyDump and ImpRec are usually able to rebuild the import table by searching
    through the program in memory for what looks like a list of imported functions.
    But sometimes this fails, and you need to learn a little more about how the import
    table works in order to analyze the malware.
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**395**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The import table is actually two tables in memory. The first table is the list
    of names or ordinals used by the loader or unpacking stub to determine which functions
    are needed. The second table is the list of the addresses of all the functions
    that are imported. When the code is running, only the second table is needed,
    so a packer can remove the list of names to thwart analysis. If the list of names
    is removed, then you may need to manually rebuild the table.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing malware without import information is extremely difficult, so it’s
    best to repair the import information whenever possible. The simplest strategy
    is to repair the imports one at a time as you encounter them in the disassembly.
    To do this, open the file in IDA Pro without any import information. When you
    see a call to an imported function, label that imported function in the disassembly.
    Calls to imported functions are an indirect call to an address that is outside
    the loaded program, as shown in Listing 18-4\.
  prefs: []
  type: TYPE_NORMAL
- en: push eax
  prefs: []
  type: TYPE_NORMAL
- en: call dword_401244
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'dword_401244: 0x7c4586c8'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-4: Call to an imported function when the import table is not properly
    reconstructed* The listing shows a call instruction with a target based on a DWORD
    pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: In IDA Pro, we navigate to the DWORD and see that it has a value of 0x7c4586c8,
    which is outside our loaded program. Next, we open OllyDbg and navigate to the
    address 0x7c4586c8 to see what is there. OllyDbg has labeled that address WriteFile,
    and we can now label that import address as imp_WriteFile, so that we know what
    the function does. You’ll need to go through these steps for each import you encounter.
    The cross-referencing feature of IDA Pro will then label all calls to the imported
    functions. Once you’ve labeled enough functions, you can effectively analyze the
    malware.
  prefs: []
  type: TYPE_NORMAL
- en: The main drawbacks to this method are that you may need to label a lot of functions,
    and you cannot search for calls to an import until you have labeled it. The other
    drawback to this approach is that you can’t actually run your unpacked program.
    This isn’t a showstopper, because you can use the unpacked program for static
    analysis, and you can still use the packed program for dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Another strategy, which does allow you to run the unpacked program, is to manually
    rebuild the import table. If you can find the table of imported functions, then
    you can rebuild the original import table by hand. The PE
  prefs: []
  type: TYPE_NORMAL
- en: file format is an open standard, and you can enter the imported functions one
    at time, or you could write a script to enter the information for you.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest drawback is that this approach can be very tedious and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: '**396**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sometimes malware authors use more than one packer. This doubles the work
    for the* *analyst, but with persistence, it’s usually possible to unpack even
    double-packed malware. The strategy is simple: Undo the first layer of packing
    using any of the techniques* *we’ve just described, and then repeat to undo the
    second layer of packing. The strategies* *are the same, regardless of the number
    of packers used.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tips and Tricks for Common Packers**'
  prefs: []
  type: TYPE_NORMAL
- en: This section covers just a sampling of popular packers that you are likely to
    encounter when analyzing malware. For each packer covered, we’ve included a description
    and a strategy for unpacking manually. Automated unpackers are also listed for
    some of these, but they do not always work. For each packer, strategies for finding
    the OEP and potential complications are also included.
  prefs: []
  type: TYPE_NORMAL
- en: '***UPX***'
  prefs: []
  type: TYPE_NORMAL
- en: The most common packer used for malware is the Ultimate Packer for eXecutables
    (UPX). UPX is open source, free, and easy to use, and it supports a wide variety
    of platforms. UPX compresses the executable, and is designed for performance rather
    than security. UPX is popular because of its high decompression speed, and the
    small size and low memory requirements of its decompression routine.
  prefs: []
  type: TYPE_NORMAL
- en: UPX was not designed to be difficult to reverse-engineer, and it does not pose
    much of a challenge for a malware analyst. Most programs packed with UPX can be
    unpacked with UPX as well, and the command line has a -d option that you can use
    to decompress a UPX-packed executable.
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s fairly easy to overcome, UPX is a good packer for learning how
    to manually unpack malware. However, many stealthy malicious programs are designed
    to appear to be packed with UPX, when they are really packed with another packer
    or a modified version of UPX. When this is the case, the UPX program will not
    be able to unpack the executable.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the OEP for UPX by using many of the strategies outlined earlier
    in this chapter. You can also use the Find OEP by Section Hop feature in OllyDump,
    or simply page down through the unpacking stub until you see the tail jump. Dumping
    the file and reconstructing the import table with OllyDump will be successful.
  prefs: []
  type: TYPE_NORMAL
- en: '***PECompact***'
  prefs: []
  type: TYPE_NORMAL
- en: PECompact is a commercial packer designed for speed and performance.
  prefs: []
  type: TYPE_NORMAL
- en: A discontinued free student version is still often used by malware authors.
  prefs: []
  type: TYPE_NORMAL
- en: Programs packed with this packer can be difficult to unpack, because it includes
    anti-debugging exceptions and obfuscated code. PECompact has a plug-in framework
    that allows third-party tools to be incorporated, and malware authors often include
    third-party tools that make unpacking even more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**397**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking PECompact manually is largely the same as unpacking UPX. The program
    generates some exceptions, so you will need to have OllyDbg set to pass exceptions
    to the program. This was discussed in detail in Chapter 16\.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the OEP by looking for the tail jump. Step over a few functions,
    and you will see a tail jump consisting of a jmp eax followed by many 0x00 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '***ASPack***'
  prefs: []
  type: TYPE_NORMAL
- en: ASPack is focused on security, and it employs techniques to make it difficult
    to unpack programs. ASPack uses self-modifying code, which makes it difficult
    to set breakpoints and to analyze in general.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a breakpoint can cause programs packed with ASPack to terminate prematurely,
    but these programs can still be manually unpacked using hardware breakpoints set
    on the stack address. Additionally, ASPack is so popular that there are many automated
    unpackers available. Their effectiveness varies, but automated unpacking is always
    worth trying as a first option.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may successfully unpack an ASPack packed file using automated techniques,
    most likely you’ll need to unpack files manually. Begin by opening the code for
    the unpacking stub. Early in the code, you will see a PUSHAD instruction. Determine
    which stack addresses are used to store the registers, and set a hardware breakpoint
    on one of those addresses. Ensure that it is set to break on a read instruction.
    When the corresponding POPAD
  prefs: []
  type: TYPE_NORMAL
- en: instruction is called, the breakpoint will be triggered and you will be just
    a few instructions away from the tail jump that leads to the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: '***Petite***'
  prefs: []
  type: TYPE_NORMAL
- en: Petite is similar to ASPack in a number of ways. Petite also uses anti-debugging
    mechanisms to make it difficult to determine the OEP, and the Petite code uses
    single-step exceptions in order to break into the debugger. This can be resolved
    by passing single-step exceptions to the program, as described in Chapter 16\.
    The best strategy is to use a hardware breakpoint on the stack to find the OEP,
    as with ASPack. Petite uses a complicated code structure that makes it easy to
    spot the OEP once you have gotten close because the original code looks normal
    unlike the Petite wrapper code.
  prefs: []
  type: TYPE_NORMAL
- en: Petite also keeps at least one import from each library in the original import
    table. Although this does not affect how difficult it is to unpack, you can easily
    determine which DLLs the malware uses without unpacking it.
  prefs: []
  type: TYPE_NORMAL
- en: '***WinUpack***'
  prefs: []
  type: TYPE_NORMAL
- en: WinUpack is a packer with a GUI front end, designed for optimal compression,
    and not for security. There is a command-line version of this packer called UPack,
    and there are automated unpackers specific to UPack and WinUpack.
  prefs: []
  type: TYPE_NORMAL
- en: '**398**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Although security isn’t its focus, WinUpack does include security measures that
    make it difficult to find the OEP, and render techniques such as searching for
    the tail jump or using OllyDump useless. Listing 18-5 shows the tail jump for
    this executable.
  prefs: []
  type: TYPE_NORMAL
- en: 010103A6 POP ECX
  prefs: []
  type: TYPE_NORMAL
- en: 010103A7 OR ECX,ECX
  prefs: []
  type: TYPE_NORMAL
- en: 010103A9 MOV DWORD PTR SS:[EBP+3A8],EAX
  prefs: []
  type: TYPE_NORMAL
- en: 010103AF POPAD
  prefs: []
  type: TYPE_NORMAL
- en: 010103B0 JNZ SHORT Sample_upac.010103BA
  prefs: []
  type: TYPE_NORMAL
- en: 010103B2 MOV EAX,1
  prefs: []
  type: TYPE_NORMAL
- en: 010103B7 RETN 0C
  prefs: []
  type: TYPE_NORMAL
- en: 010103BA PUSH Sample_upac.01005F85
  prefs: []
  type: TYPE_NORMAL
- en: 010103BF RETN
  prefs: []
  type: TYPE_NORMAL
- en: 010103C0 MOV EAX,DWORD PTR SS:[EBP+426]
  prefs: []
  type: TYPE_NORMAL
- en: 010103C6 LEA ECX,DWORD PTR SS:[EBP+43B]
  prefs: []
  type: TYPE_NORMAL
- en: 010103CC PUSH ECX
  prefs: []
  type: TYPE_NORMAL
- en: 010103CD PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: 010103CE CALL DWORD PTR SS:[EBP+F49]
  prefs: []
  type: TYPE_NORMAL
- en: 010103D4 MOV DWORD PTR SS:[EBP+555],EAX
  prefs: []
  type: TYPE_NORMAL
- en: 010103DA LEA EAX,DWORD PTR SS:[EBP+447]
  prefs: []
  type: TYPE_NORMAL
- en: 010103E0 PUSH EAX
  prefs: []
  type: TYPE_NORMAL
- en: 010103E1 CALL DWORD PTR SS:[EBP+F51]
  prefs: []
  type: TYPE_NORMAL
- en: 010103E7 MOV DWORD PTR SS:[EBP+42A],EAX
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 18-5: Tail jump for a program packed with UPack* In this listing,
    the tail jump at  is in the middle of the unpacking stub, so it is difficult
    to spot. A push instruction at  followed by a return instruction is extremely
    common for a tail jump. The code jumps all around before arriving at the tail
    jump in order to make it harder to spot. To further obscure the tail jump, the
    push that precedes the retn instruction is modified by the packer shortly before
    it is called. The jump is also not very far, so you can’t identify it by searching
    for long jumps. Because the OEP is in the same section as the unpacking stub,
    OllyDump cannot automatically identify the tail jump via its section-hopping method.'
  prefs: []
  type: TYPE_NORMAL
- en: The best strategy for finding the OEP for a program packed with UPack is to
    set a breakpoint on GetProcAddress, and then single-step carefully over instructions
    looking for the loops that set the import resolution. If you set the breakpoints
    at every jmp or call instruction, you will be single-stepping forever, but if
    you set the breakpoints too sparsely, the program will probably miss your breakpoints
    and run until completion.
  prefs: []
  type: TYPE_NORMAL
- en: Do not be discouraged if the program runs to completion without hitting your
    breakpoints. Simply restart the application in the debugger and try again. Making
    mistakes is a part of the process. Eventually, you will single-step onto a ret
    instruction that is the tail jump.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, recognizing the tail jump can be tricky. In this case, it jumps about
    0x4000 bytes away. Most unpacking stubs are much smaller than 0x4000, and a jump
    of that size usually is a jump to the OEP. A good way to double-check is to examine
    the code around the OEP, which should look more like Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**399**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: ordinary code compared to the unpacking stub. The unpacking stub often has many
    conditional jumps and returns in the middle of a function, but the code around
    the OEP should not have these unusual elements.
  prefs: []
  type: TYPE_NORMAL
- en: Another strategy that works on UPack is to set a breakpoint on GetModuleHandleA
    for GUI programs or GetCommandLineA for command-line programs. In Windows, these
    functions are called shortly after the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Once the breakpoint is triggered, search backward through the code to find the
    OEP.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes WinUpack crashes OllyDbg by using a PE header that OllyDbg parses
    incorrectly. In Chapter 16, we showed that OllyDbg isn’t perfect and has issues
    parsing binaries that run just fine on Windows outside the debugger. If you encounter
    this problem, always try to use WinDbg before attempting to decipher PE header
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: '***Themida***'
  prefs: []
  type: TYPE_NORMAL
- en: Themida is a very complicated packer with many features. Most of the features
    are anti-debugging and anti-analysis, which make it a very secure packer that’s
    difficult to unpack and analyze.
  prefs: []
  type: TYPE_NORMAL
- en: Themida contains features that prevent analysis with VMware, debuggers, and
    Process Monitor (procmon). Themida also has a kernel component, which makes it
    much more difficult to analyze. Code running in the kernel has very few restrictions,
    and analysis code generally runs in user space, and is therefore subject to more
    restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Because Themida includes so many features, the packed executable is unusually
    bulky. In addition, unlike most packers, Themida’s code continues to run the entire
    time that the original program is running.
  prefs: []
  type: TYPE_NORMAL
- en: Some automated tools are designed to unpack Themida files, but their success
    varies based on the version of Themida and the settings used when the program
    was packed. Themida has so many features and settings that it is impossible to
    find a single unpacking strategy that will always work.
  prefs: []
  type: TYPE_NORMAL
- en: If automated tools don’t work, another great strategy is to use ProcDump to
    dump the process from memory without debugging. ProcDump is a tool from Microsoft
    for dumping the contents of a Windows process. It’s designed to work with a debugger,
    but is not itself a debugger. The biggest advantage of ProcDump is that you can
    dump process memory without stopping or debugging the process, which is extremely
    useful for packers that have advanced anti-debugging measures. Even when you cannot
    debug an executable, you can use ProcDump to dump the unpacked contents while
    the executable is running. This process doesn’t completely restore the original
    executable, but it does allow you to run strings and do some analysis on the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing Without Fully Unpacking**'
  prefs: []
  type: TYPE_NORMAL
- en: Some programs, including those packed with Themida, can be very difficult to
    unpack. At times, you might spend all day trying to unpack a program and have
    no success. Perhaps the packer is using a new technique that you simply **400**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: cannot solve. If that happens, you may be in luck—you don’t always need to create
    a fully unpacked working executable in order to analyze a piece of malware.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest case occurs when a program that is unpacked fails to execute because
    you can’t completely repair the import table and PE header. In that case, you
    can still use IDA Pro to analyze the program, even though it is not fully executable.
    Once you have the dumped program on disk, you can have IDA Pro analyze specific
    sections of code by navigating to the memory address and marking that section
    as code. You can also run Strings on the program (as discussed in Chapter 1),
    which might reveal the imported functions and other useful information.
  prefs: []
  type: TYPE_NORMAL
- en: The analysis that’s possible without fully unpacking is very limited, but depending
    on your goal, it may be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Some unpackers do not actually unpack the entire original program before the
    program begins running. Instead, they unpack a portion of the original program,
    and run that portion. When it is time to run the next portion of code, that portion
    is unpacked into memory and run. This creates considerable overhead for the executable,
    but makes it very difficult for an analyst to unpack.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse-engineering the technique that unpacks individual chunks of code can
    enable you to write a script to unpack all of the code, or at least large portions
    of it. Another option is to focus more on dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Packed DLLs**'
  prefs: []
  type: TYPE_NORMAL
- en: There are additional complications associated with packing DLLs, so this capability
    is not supported by all packers. Handling the exports of the DLL is one complication.
    The export table in the DLL points to the address of the exported functions, and
    if the DLL is packed, then the exported functions are also packed. The packer
    must account for this to ensure that the DLL
  prefs: []
  type: TYPE_NORMAL
- en: operates properly.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking a DLL is not much different from unpacking an EXE. The key thing to
    remember is that DLLs have an OEP, just like executables. All DLLs have a function
    called DllMain, which is called when the DLL is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The OEP in a DLL is the original start of DllMain. The start address listed
    in the packed DLL is the address of the unpacking stub, which is placed into DllMain
    rather than into the main method. OllyDbg can load DLLs, and OllyDbg has a tool
    called *loadDll.exe*, which allows you to load and debug DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the DllMain method will be called prior to breaking in OllyDbg.
    By the time the break occurs, the unpacking stub will have already executed, and
    it will be very difficult to find the OEP.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this, open the PE file and locate the Characteristics field in
    the IMAGE_FILE_HEADER section. The bit in the 0x2000 place in the IMAGE_FILE_HEADER
    is set to 1 for DLLs. If this field is changed to a 0, then the file will be interpreted
    as an executable. OllyDbg will open the program as an EXE, and you will be able
    to apply all of the unpacking strategies discussed in this chapter. After you’ve
    found the OEP, change the bit back so that the program will be treated as a DLL
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**401**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered a large number of strategies for dealing with packed software.
    We started with the basics of how packers work and how to unpack software, and
    then discussed some automated unpacking tools and strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered techniques that can be used to manually unpack malicious software.
    No single strategy or tool will work in all cases, so you need to be familiar
    with several techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover shellcode and strategies for recognizing
    and analyzing malicious shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '**402**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 18
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: Your goal for the labs in this chapter is simply to unpack the code for further
    analysis. For each lab, you should try to unpack the code so that other static
    analysis techniques can be used. While you may be able to find an automated unpacker
    that will work with some of these labs, automated unpackers won’t help you learn
    the skills you need when you encounter custom packers. Also, once you master unpacking,
    you may be able to manually unpack a file in less time than it takes to find,
    download, and use an automated unpacker.
  prefs: []
  type: TYPE_NORMAL
- en: Each lab is a packed version of a lab from a previous chapter. Your task in
    each case is to unpack the lab and identify the chapter in which it appeared.
  prefs: []
  type: TYPE_NORMAL
- en: The files are *Lab18-01.exe* through *Lab18-05.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: Packers and Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: '**403**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**S P E C I A L T O P I C S**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**S H E L L C O D E A N A L Y S I S**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Shellcode* refers to a payload of raw executable code.'
  prefs: []
  type: TYPE_NORMAL
- en: The name *shellcode* comes from the fact that attackers would usually use this
    code to obtain interactive shell
  prefs: []
  type: TYPE_NORMAL
- en: access on the compromised system. However, over
  prefs: []
  type: TYPE_NORMAL
- en: time, the term has become commonly used to describe
  prefs: []
  type: TYPE_NORMAL
- en: any piece of self-contained executable code.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode is often used alongside an exploit to subvert a running program, or
    by malware performing process injection. Exploitation and process injection are
    similar in that the shellcode is added to a running program and executed after
    the process has started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shellcode requires its authors to manually perform several actions that software
    developers usually never worry about. For example, the shellcode package cannot
    rely on actions the Windows loader performs during normal program startup, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Placing the program at its preferred memory location
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Applying address relocations if it cannot be loaded at its preferred memory
    location
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Loading required libraries and resolving external dependencies
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to these shellcode techniques, demonstrated
    by full, working real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading Shellcode for Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: Loading and running shellcode in a debugger is problematic because shellcode
    is usually just a binary chunk of data that cannot run in the same way as a normal
    executable. To make things easier, we’ll use *shellcode_launcher.exe* (included
    with the labs available at *http://www.practicalmalwareanalysis.com/*) to load
    and jump to pieces of shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in Chapter 5, loading shellcode into IDA Pro for static analysis
    is relatively simple, but the user must provide input during the load process,
    since there is no executable file format that describes the contents of shellcode.
    First, you must ensure the correct processor type is selected in the load process
    dialog. For samples in this chapter, you can use the **Intel 80x86 processors:
    metapc** processor type and select **32-bit disassembly** when prompted. IDA Pro
    loads the binary but performs no automatic analysis (analysis must be done manually).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Position-Independent Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Position-independent code (PIC)* is code that uses no hard-coded addresses
    for either code or data. Shellcode is PIC. It cannot assume that it will be located
    at a particular memory location when it executes, because at runtime, different
    versions of a vulnerable program may load the shellcode into different memory
    locations. The shellcode must ensure that all memory access for both code and
    data uses PIC techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-1 shows several common types of x86 code and data access, and whether
    they are PIC.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-1:** Different Types of x86 Code and Data Access **Instruction mnemonics**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction bytes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Position-independent?**'
  prefs: []
  type: TYPE_NORMAL
- en: call sub_401000
  prefs: []
  type: TYPE_NORMAL
- en: E8 C1 FF FF FF 
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: jnz short loc_401044
  prefs: []
  type: TYPE_NORMAL
- en: 75 0E 
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, dword_407030 
  prefs: []
  type: TYPE_NORMAL
- en: 8B 15 30 70 40 00
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [ebp-4] 
  prefs: []
  type: TYPE_NORMAL
- en: 8B 45 FC
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: In the table, the call instruction contains a 32-bit signed relative displacement
    that is added to the address immediately following the call instruction in order
    to calculate the target location. Because the call instruction shown in the table
    is located at 0x0040103A, adding the offset value 0xFFFFFFC1 
  prefs: []
  type: TYPE_NORMAL
- en: to the location of the instruction, plus the size of the call instruction (5
    bytes), results in the call target 0x00401000\.
  prefs: []
  type: TYPE_NORMAL
- en: The jnz instruction is very similar to call, except that it uses only an 8-bit
    signed relative displacement. The jnz instruction is located at 0x00401034\.
  prefs: []
  type: TYPE_NORMAL
- en: '**408**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding together this location, the offset stored in the instruction (0xe) ,
    and the size of the instruction (2 bytes) results in the jump target 0x00401044\.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, control-flow instructions such as call and jump are already
    position-independent. They calculate target addresses by adding a relative offset
    stored in the instruction to the current location specified by the EIP
  prefs: []
  type: TYPE_NORMAL
- en: register. (Certain forms of call and jump allow programmers to use absolute,
    or nonrelative, addressing that is not position-independent, but they are easily
    avoided.)
  prefs: []
  type: TYPE_NORMAL
- en: The mov instruction at  shows an instruction accessing the global data variable
    dword_407030\. The last 4 bytes in this instruction show the memory location 0x00407030\.
    This particular instruction is not position-independent and must be avoided by
    shellcode authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the mov instruction at  to the mov instruction at , which accesses
    a DWORD from the stack. This instruction uses the EBP register as a base, and
    contains a signed relative offset: 0xFC (-4). This type of data access is position-independent
    and is the model that shellcode authors must use for all data access: Calculate
    a runtime address and refer to data only by using offsets from this location.
    (The following section discusses finding an appropriate runtime address.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying Execution Location**'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode needs to dereference a base pointer when accessing data in a position-independent
    manner. Adding or subtracting values to this base value will allow it to safely
    access data that is included with the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Because the x86 instruction set does not provide EIP-relative data access, as
    it does for control-flow instructions, a general-purpose register must first be
    loaded with the current instruction pointer, to be used as the base pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the current instruction pointer may not be immediately obvious, because
    the instruction pointer on x86 systems cannot be directly accessed by software.
    In fact, there is no way to assemble the instruction mov eax, eip to directly
    load a general-purpose register with the current instruction pointer. However,
    shellcode uses two popular techniques to address this issue: call/pop and fnstenv
    instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using call/pop***'
  prefs: []
  type: TYPE_NORMAL
- en: When a call instruction is executed, the processor pushes the address of the
    instruction following the call onto the stack, and then branches to the requested
    location. This function executes, and when it completes, it executes a ret instruction
    to pop the return address off the top of the stack and load it into the instruction
    pointer. As a result, execution returns to the instruction just after the call.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode can abuse this convention by immediately executing a pop instruction
    after a call, which will load the address immediately following the call into
    the specified register. Listing 19-1 shows a simple Hello World example that uses
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**409**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Bytes Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: 83 EC 20 sub esp, 20h
  prefs: []
  type: TYPE_NORMAL
- en: 31 D2 xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: E8 0D 00 00 00 call sub_17 
  prefs: []
  type: TYPE_NORMAL
- en: 48 65 6C 6C 6F db 'Hello World!',0 
  prefs: []
  type: TYPE_NORMAL
- en: 20 57 6F 72 6C
  prefs: []
  type: TYPE_NORMAL
- en: 64 21 00
  prefs: []
  type: TYPE_NORMAL
- en: 'sub_17:'
  prefs: []
  type: TYPE_NORMAL
- en: '5F pop edi  ; edi gets string pointer 52 push edx ; uType: MB_OK'
  prefs: []
  type: TYPE_NORMAL
- en: 57 push edi ; lpCaption
  prefs: []
  type: TYPE_NORMAL
- en: 57 push edi ; lpText
  prefs: []
  type: TYPE_NORMAL
- en: '52 push edx ; hWnd: NULL'
  prefs: []
  type: TYPE_NORMAL
- en: B8 EA 07 45 7E mov eax, 7E4507EAh ; MessageBoxA FF D0 call eax 
  prefs: []
  type: TYPE_NORMAL
- en: 52 push edx ; uExitCode
  prefs: []
  type: TYPE_NORMAL
- en: B8 FA CA 81 7C mov eax, 7C81CAFAh ; ExitProcess FF D0 call eax 
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-1: call/pop Hello World example*'
  prefs: []
  type: TYPE_NORMAL
- en: The call at  transfers control to sub_17 at . This is PIC because the call
    instruction uses an EIP relative value (0x0000000D) to calculate the call target.
    The pop instruction at  loads the address stored on top of the stack into EDI.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the EIP value saved by the call instruction points to the location
    immediately following the call, so after the pop instruction, EDI will contain
    a pointer to the db declaration at . This db declaration is assembly language
    syntax to create a sequence of bytes to spell out the string Hello World!. After
    the pop at , EDI will point to this Hello World! string.
  prefs: []
  type: TYPE_NORMAL
- en: This method of intermingling code and data is normal for shellcode, but it can
    easily confuse disassemblers who try to interpret the data following the call
    instruction as code, resulting in either nonsensical disassembly or completely
    halting the disassembly process if invalid opcode combinations are encountered.
    As seen in Chapter 15, using call/pop pairs to obtain pointers to data may be
    incorporated into larger programs as an additional anti-reverse-engineering technique.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining code calls MessageBoxA  to show the “Hello World!” message, and
    then ExitProcess  to cleanly exit. This sample uses hard-coded locations for
    both function calls because imported functions in shellcode are not automatically
    resolved by the loader, but hard-coded locations make this code fragile. (These
    addresses come from a Windows XP SP3 box, and may differ from yours.)
  prefs: []
  type: TYPE_NORMAL
- en: To find these function addresses with OllyDbg, open any process and press CTRL-G
    to bring up the Enter Expression to Follow dialog. Enter **MessageBoxA** in the
    dialog and press ENTER. The debugger should show the location of the function,
    as long as the library with this export ( *user32.dll* ) is loaded by the process
    being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: '**410**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To load and step through this example with *shellcode_launcher.exe*, enter
    the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**shellcode_launcher.exe -i helloworld.bin -bp -L user32**'
  prefs: []
  type: TYPE_NORMAL
- en: The -L user32 option is required because the shellcode does not call LoadLibraryA,
    so *shellcode_launcher.exe* must make sure this library is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The -bp option inserts a breakpoint instruction just prior to jumping to the
    shellcode binary specified with the -i option. Recall that debuggers can be registered
    for just-in-time debugging and can be launched automatically (or when prompted)
    when a program encounters a breakpoint. If a debugger such as OllyDbg has been
    registered as a just-in-time debugger, it will open and attach to the process
    that encountered a breakpoint. This allows you to skip over the contents of the
    *shellcode_launcher.exe* program and begin at the start of the shellcode binary.
  prefs: []
  type: TYPE_NORMAL
- en: You can set OllyDbg as your just-in-time debugger by selecting **Options**
  prefs: []
  type: TYPE_NORMAL
- en: '**Just-in-time Debugging****Make OllyDbg Just-in-time Debugger**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Readers who wish to execute this example may need to modify the hard-coded
    function* *locations for MessageBoxA and ExitProcess. These addresses can be found
    as described* *in the text. Once the addresses have been found, you can patch*
    helloworld.bin *within* *OllyDbg by placing the cursor on the instruction that
    loads the hard-coded function* *location into register EAX and then pressing the
    spacebar. This brings up OllyDbg’s* *Assemble At dialog, which allows you to enter
    your own assembly code. This will be* *assembled by OllyDbg and overwrite the
    current instruction. Simply replace the* *7E4507EAh value with the correct value
    from your machine, and OllyDbg will patch* *the program in memory, allowing the
    shellcode to execute correctly.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using fnstenv***'
  prefs: []
  type: TYPE_NORMAL
- en: The x87 floating-point unit (FPU) provides a separate execution environment
    within the normal x86 architecture. It contains a separate set of special-purpose
    registers that need to be saved by the OS on a context switch when a process is
    performing floating-point arithmetic with the FPU. Listing 19-2
  prefs: []
  type: TYPE_NORMAL
- en: shows the 28-byte structure used by the fstenv and fnstenv instructions to store
    the state of the FPU to memory when executing in 32-bit protected mode.
  prefs: []
  type: TYPE_NORMAL
- en: struct FpuSaveState {
  prefs: []
  type: TYPE_NORMAL
- en: uint32_t control_word;
  prefs: []
  type: TYPE_NORMAL
- en: uint32_t status_word;
  prefs: []
  type: TYPE_NORMAL
- en: uint32_t tag_word;
  prefs: []
  type: TYPE_NORMAL
- en: uint32_t fpu_instruction_pointer;
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t fpu_instruction_selector;
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t fpu_opcode;
  prefs: []
  type: TYPE_NORMAL
- en: uint32_t fpu_operand_pointer;
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t fpu_operand_selector;
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t reserved;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-2: FpuSaveState structure definition*'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**411**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The only field that matters for use here is fpu_instruction_pointer at byte
    offset 12\. This will contain the address of the last CPU instruction that used
    the FPU, providing context information for exception handlers to identify which
    FPU instructions may have caused a fault. This field is required because the FPU
    is running in parallel with the CPU. If the FPU
  prefs: []
  type: TYPE_NORMAL
- en: generates an exception, the exception handler cannot simply look at the interrupt
    return address to identify the instruction that caused the fault.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-3 shows the disassembly of another Hello World program that uses
    fnstenv to obtain the EIP value.
  prefs: []
  type: TYPE_NORMAL
- en: Bytes Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: 83 EC 20 sub esp, 20h
  prefs: []
  type: TYPE_NORMAL
- en: 31 D2 xor edx, edx
  prefs: []
  type: TYPE_NORMAL
- en: EB 15 jmp short loc_1C
  prefs: []
  type: TYPE_NORMAL
- en: EA 07 45 7E dd 7E4507EAh ; MessageBoxA FA CA 81 7C dd 7C81CAFAh ; ExitProcess
    48 65 6C 6C 6F db 'Hello World!',0
  prefs: []
  type: TYPE_NORMAL
- en: 20 57 6F 72 6C
  prefs: []
  type: TYPE_NORMAL
- en: 64 21 00
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_1C:'
  prefs: []
  type: TYPE_NORMAL
- en: D9 EE fldz 
  prefs: []
  type: TYPE_NORMAL
- en: D9 74 24 F4 fnstenv byte ptr [esp-0Ch] 
  prefs: []
  type: TYPE_NORMAL
- en: 5B pop ebx 
  prefs: []
  type: TYPE_NORMAL
- en: ; ebx points to fldz
  prefs: []
  type: TYPE_NORMAL
- en: '8D 7B F3 lea edi, [ebx-0Dh]  ; load HelloWorld pointer 52 push edx ; uType:
    MB_OK'
  prefs: []
  type: TYPE_NORMAL
- en: 57 push edi ; lpCaption
  prefs: []
  type: TYPE_NORMAL
- en: 57 push edi ; lpText
  prefs: []
  type: TYPE_NORMAL
- en: '52 push edx ; hWnd: NULL'
  prefs: []
  type: TYPE_NORMAL
- en: 8B 43 EB mov eax, [ebx-15h]  ;
  prefs: []
  type: TYPE_NORMAL
- en: load
  prefs: []
  type: TYPE_NORMAL
- en: MessageBoxA
  prefs: []
  type: TYPE_NORMAL
- en: FF D0 call eax ; call MessageBoxA 52 push edx ; uExitCode
  prefs: []
  type: TYPE_NORMAL
- en: '8B 43 EF mov eax, [ebx-11h]  ; load ExitProcess FF D0 call eax ; call ExitProcess
    *Listing 19-3: fnstenv Hello World example*'
  prefs: []
  type: TYPE_NORMAL
- en: The fldz instruction at  pushes the floating-point number 0.0 onto the FPU
    stack. The fpu_instruction_pointer value is updated within the FPU to point to
    the fldz instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the fnstenv at  stores the FpuSaveState structure onto the stack
    at [esp-0ch], which allows the shellcode to do a pop at  that loads EBX with
    the fpu_instruction_pointer value. Once the pop executes, EBX will contain a value
    that points to the location of the fldz instruction in memory. The shellcode then
    starts using EBX as a base register to access the data embedded in the code.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous Hello World example, which used the call/pop technique, this
    code calls MessageBoxA and ExitProcess using hard-coded locations, but here the
    function locations are stored as data along with the ASCII string to print. The
    lea instruction at  loads the address of the Hello **412**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: World! string by subtracting 0x0d from the address of the fldz instruction stored
    in EBX. The mov instruction at  loads the first function location for MessageBoxA,
    and the mov instruction at  loads the second function location for ExitProcess.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-3 is a contrived example, but it is common for shellcode to store
    or create* *function pointer arrays. We used the fldz instruction in this example,
    but any non-control FPU instruction can be used.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example can be executed using *shellcode_launcher.exe* with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**shellcode_launcher.exe -i hellofstenv.bin -bp -L user32**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual Symbol Resolution**'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode exists as a binary blob that gains execution. It must do something
    useful once it gains execution, which usually means interacting with the system
    through APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that shellcode cannot use the Windows loader to ensure that all required
    libraries are loaded and available, and to make sure that all external symbols
    are resolved. Instead, it must find the symbols itself. The shellcode in the previous
    examples used hard-coded addresses to find the symbols, but this very fragile
    method will work only on a specific version of an OS and service pack. Shellcode
    must dynamically locate the functions in order to work reliably in different environments,
    and for that task, it typically uses LoadLibraryA and GetProcAddress.
  prefs: []
  type: TYPE_NORMAL
- en: LoadLibraryA loads the specified library and returns a handle. The GetProcAddress
    function searches the library’s exports for the given symbol name or ordinal number.
    If shellcode has access to these two functions, it can load any library on the
    system and find exported symbols, at which point it has full access to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both functions are exported from *kernel32.dll*, so the shellcode must do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Find *kernel32.dll* in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Parse *kernel32.dll*’s PE file and search the exported functions for LoadLibraryA
    and GetProcAddress.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding kernel32.dll in Memory***'
  prefs: []
  type: TYPE_NORMAL
- en: In order to locate *kernel32.dll*, we’ll follow a series of undocumented Windows
    structures. One of these structures contains the load address of *kernel32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**413**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Most of the Windows structures are listed on the Microsoft Developer Network
    (MSDN)* *site, but they are not fully documented. Many contain byte arrays named
    Reserved,* *with the warning “This structure may be altered in future versions
    of Windows.” For* *full listings of these structures, see* http://undocumented.ntinternals.net/
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19-1 shows the data structures that are typically followed in order to
    find the base address for *kernel32.dll* (only relevant fields and offsets within
    each structure are shown).
  prefs: []
  type: TYPE_NORMAL
- en: '**TEB**'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '0x30: PPEB peb;'
  prefs: []
  type: TYPE_NORMAL
- en: '**PEB**'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '0x0c: PPEB_LDR_data ldr;'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**PEB_LDR_Data**'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '0x0c: LIST_ENTRY InLoadOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '0x14: LIST_ENTRY InMemoryOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '0x1c: LIST_ENTRY InInitializationOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '***ntdll.dll*** **LDR_DATA_TABLE_ENTRY**'
  prefs: []
  type: TYPE_NORMAL
- en: '***kernel32.dll*** **LDR_DATA_TABLE_ENTRY**'
  prefs: []
  type: TYPE_NORMAL
- en: '0x00: LIST_ENTRY InLoadOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '0x00: LIST_ENTRY InLoadOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '0x08: LIST_ENTRY InMemoryOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '0x08: LIST_ENTRY InMemoryOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '0x10: LIST_ENTRY InInitializationOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '0x10: LIST_ENTRY InInitializationOrderLinks;'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '0x18: PVOID DllBase;'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '0x24: UNICODE_STRING FullDllName;'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 19-1: Structure traversal to find* kernel32.dll *DllBase* The process
    begins with the TEB, accessible from the FS segment register. Offset 0x30 within
    the TEB is the pointer to the PEB. Offset 0xc within the PEB is the pointer to
    the PEB_LDR_DATA structure, which contains three doubly linked lists of LDR_DATA_TABLE
    structures—one for each loaded module.'
  prefs: []
  type: TYPE_NORMAL
- en: The DllBase field in the *kernel32.dll* entry is the value we’re seeking.
  prefs: []
  type: TYPE_NORMAL
- en: Three LIST_ENTRY structures link the LDR_DATA_TABLE entries together in different
    orders, by name. The InInitializationOrderLinks entry is typically followed by
    shellcode. From Windows 2000 through Vista, *kernel32.dll* is the second DLL initialized,
    just after *ntdll.dll*, which means that the second entry in the InInitializationOrderLinks
    list of structures should belong to *kernel32.dll*. However, beginning with Windows
    7, *kernel32.dll* is no longer the second module to be initialized, so this simple
    algorithm no longer works. Portable shellcode will instead need to examine the
    UNICODE_STRING
  prefs: []
  type: TYPE_NORMAL
- en: FullDllName field to confirm it is *kernel32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: When traversing the LIST_ENTRY structures, it is important to realize that the
    Flink and Blink pointers point to the equivalent LIST_ENTRY in the next and previous
    LDR_DATA_TABLE structures. This means that when following the InInitializationOrderLinks
    to get to *kernel32.dll*’s LDR_DATA_TABLE_ENTRY, you need to add only eight to
    the pointer to get the DllBase, instead of adding 0x18, which you would have to
    do if the pointer pointed to the start of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**414**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-4 contains sample assembly code that finds the base address of *kernel32.dll.*
  prefs: []
  type: TYPE_NORMAL
- en: ; __stdcall DWORD findKernel32Base(void);
  prefs: []
  type: TYPE_NORMAL
- en: 'findKernel32Base:'
  prefs: []
  type: TYPE_NORMAL
- en: push esi
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [fs:eax+0x30]  ; eax gets pointer to PEB
  prefs: []
  type: TYPE_NORMAL
- en: test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: '; if high bit set: Win9x'
  prefs: []
  type: TYPE_NORMAL
- en: js .kernel32_9x 
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [eax + 0x0c] 
  prefs: []
  type: TYPE_NORMAL
- en: ; eax gets pointer to PEB_LDR_DATA
  prefs: []
  type: TYPE_NORMAL
- en: ;esi gets pointer to 1st
  prefs: []
  type: TYPE_NORMAL
- en: ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
  prefs: []
  type: TYPE_NORMAL
- en: mov esi, [eax + 0x1c]
  prefs: []
  type: TYPE_NORMAL
- en: ;eax gets pointer to 2nd
  prefs: []
  type: TYPE_NORMAL
- en: ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
  prefs: []
  type: TYPE_NORMAL
- en: lodsd 
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [eax + 8]
  prefs: []
  type: TYPE_NORMAL
- en: ; eax gets LDR_DATA_TABLE_ENTRY.DllBase
  prefs: []
  type: TYPE_NORMAL
- en: jmp near .finished
  prefs: []
  type: TYPE_NORMAL
- en: '.kernel32_9x:'
  prefs: []
  type: TYPE_NORMAL
- en: jmp near .kernel32_9x 
  prefs: []
  type: TYPE_NORMAL
- en: '; Win9x not supported: infinite loop'
  prefs: []
  type: TYPE_NORMAL
- en: '.finished:'
  prefs: []
  type: TYPE_NORMAL
- en: pop esi
  prefs: []
  type: TYPE_NORMAL
- en: ret
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-4: findKernel32Base implementation*'
  prefs: []
  type: TYPE_NORMAL
- en: The listing accesses the TEB using the FS segment register at  to get the pointer
    to the PEB. The js ( jump if signed) instruction at  is used to test whether
    the most significant bit of the PEB pointer is set, in order to differentiate
    between Win9x and WinNT systems. In WinNT (including Windows 2000, XP, and Vista),
    the most significant bit of the PEB pointer is typically never set, because high
    memory addresses are reserved for the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Using the sign bit to identify the OS family fails on systems that use the /3GB
  prefs: []
  type: TYPE_NORMAL
- en: boot option, which causes the user-level/kernel-level memory split to occur
    at 0xC0000000 instead of 0x8000000, but this is ignored for this simple example.
    This shellcode chose not to support Win9x, so it enters an infinite loop at 
    if Win9x is detected.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode proceeds to PEB_LDR_DATA at . It assumes that it is running under
    Windows Vista or earlier, so it can simply retrieve the second LDR_DATA_TABLE_ENTRY
    in the InInitializationOrderLinks linked list at  and return its DllBase field.
  prefs: []
  type: TYPE_NORMAL
- en: '***Parsing PE Export Data***'
  prefs: []
  type: TYPE_NORMAL
- en: Once you find the base address for *kernel32.dll*, you must parse it to find
    exported symbols. As with finding the location of *kernel32.dll*, this process
    involves following several structures in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**415**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: PE files use relative virtual addresses (RVAs) when defining locations within
    a file. These addresses can be thought of as offsets within the PE
  prefs: []
  type: TYPE_NORMAL
- en: image in memory, so the PE image base address must be added to each RVA to turn
    it into a valid pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The export data is stored in IMAGE_EXPORT_DIRECTORY. An RVA to this is stored
    in the array of IMAGE_DATA_DIRECTORY structures at the end of the IMAGE_OPTIONAL_HEADER.
    The location of the IMAGE_DATA_DIRECTORY array depends on whether the PE file
    is for a 32-bit application or a 64-bit application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical shellcode assumes it is running on a 32-bit platform, so it knows at
    compile time that the correct offset from the PE signature to the directory array
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: sizeof(PE_Signature) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER)
    = 120 bytes The relevant fields in the IMAGE_EXPORT_DIRECTORY structure are shown
    in Figure 19-2\. AddressOfFunctions is an array of RVAs that points to the actual
    export functions. It is indexed by an export ordinal (an alternative way of finding
    an exported symbol).
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode needs to map the export name to the ordinal in order to use this
    array, and it does so using the AddressOfNames and AddressOfNameOrdinals arrays.
    These two arrays exist in parallel. They have the same number of entries, and
    equivalent indices into these arrays are directly related.
  prefs: []
  type: TYPE_NORMAL
- en: AddressOfNames is an array of 32-bit RVAs that point to the strings of symbol
    names. AddressOfNameOrdinals is an array of 16-bit ordinals. For a given index
    idx into these arrays, the symbol at AddressOfNames[idx] has the export ordinal
    value at AddressOfNameOrdinals[idx]. The AddressOfNames array is sorted alpha-betically
    so that a binary search can quickly find a specific string, though most shellcode
    simply performs a linear search starting at the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the export address of a symbol, follow these steps: 1\.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over the AddressOfNames array looking at each char* entry, and perform
    a string comparison against the desired symbol until a match is found. Call this
    index into AddressOfNames iName.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Index into the AddressOfNameOrdinals array using iName. The value retrieved
    is the value iOrdinal.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Use iOrdinal to index into the AddressOfFunctions array. The value retrieved
    is the RVA of the exported symbol. Return this value to the requester.
  prefs: []
  type: TYPE_NORMAL
- en: A sample implementation of this algorithm is shown later in the chapter as part
    of a full Hello World example.
  prefs: []
  type: TYPE_NORMAL
- en: '**416**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: ;BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie) mov edi,
    edi
  prefs: []
  type: TYPE_NORMAL
- en: push ebp
  prefs: []
  type: TYPE_NORMAL
- en: mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: ;ATOM __stdcall AddAtomA(LPCSTR lpString)
  prefs: []
  type: TYPE_NORMAL
- en: mov edi, edi
  prefs: []
  type: TYPE_NORMAL
- en: push ebp
  prefs: []
  type: TYPE_NORMAL
- en: mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: ;ATOM __stdcall AddAtomW(LPCWSTR lpString)
  prefs: []
  type: TYPE_NORMAL
- en: mov edi, edi
  prefs: []
  type: TYPE_NORMAL
- en: push ebp
  prefs: []
  type: TYPE_NORMAL
- en: mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMAGE_EXPORT_DIRECTORY**'
  prefs: []
  type: TYPE_NORMAL
- en: '"ActivateActCtx"'
  prefs: []
  type: TYPE_NORMAL
- en: '"lstrln"'
  prefs: []
  type: TYPE_NORMAL
- en: '"AddAtomA"'
  prefs: []
  type: TYPE_NORMAL
- en: '"lstrlnA"'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '"AddAtomW"'
  prefs: []
  type: TYPE_NORMAL
- en: '"lstrlnW"'
  prefs: []
  type: TYPE_NORMAL
- en: '0x18: NumberOfNames'
  prefs: []
  type: TYPE_NORMAL
- en: '0x1c: AddressOfFunctions'
  prefs: []
  type: TYPE_NORMAL
- en: '0x20: AddressOfNames'
  prefs: []
  type: TYPE_NORMAL
- en: '0x24: AddressOfNameOrdinals'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 3b6
  prefs: []
  type: TYPE_NORMAL
- en: 3b7
  prefs: []
  type: TYPE_NORMAL
- en: 3b8
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 19-2:* kernel32.dll *IMAGE_EXPORT_DIRECTORY*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the shellcode finds LoadLibraryA, it can load arbitrary libraries. The
    return value of LoadLibraryA is treated as a HANDLE in the Win32 API. Examining
    the HANDLE values shows that it is actually a 32-bit pointer to the dllBase of
    the library that was loaded, which means that the shellcode can skip using GetProcAddress
    and continue using its own PE parsing code with the dllBase pointers returned
    from LoadLibraryA (which is also beneficial when hashed names are used, as explained
    in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Hashed Exported Names***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm just discussed has a weakness: It performs a strcmp against each
    export name until it finds the correct one. This requires that the full name of
    each API function the shellcode uses be included as an ASCII string.'
  prefs: []
  type: TYPE_NORMAL
- en: When the size of the shellcode is constrained, these strings could push the
    size of the shellcode over the limit.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**417**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: A common way to address this problem is to calculate a hash of each symbol string
    and compare the result with a precomputed value stored in the shellcode. The hash
    function does not need to be sophisticated; it only needs to guarantee that within
    each DLL used by the shellcode, the hashes that the shellcode uses are unique.
    Hash collisions between symbols in different DLLs and between symbols the shellcode
    does not use are fine.
  prefs: []
  type: TYPE_NORMAL
- en: The most common hash function is the 32-bit rotate-right-additive hash, as shown
    in Listing 19-5\.
  prefs: []
  type: TYPE_NORMAL
- en: ; __stdcall DWORD hashString(char* symbol);
  prefs: []
  type: TYPE_NORMAL
- en: 'hashString:'
  prefs: []
  type: TYPE_NORMAL
- en: push esi
  prefs: []
  type: TYPE_NORMAL
- en: push edi
  prefs: []
  type: TYPE_NORMAL
- en: mov esi, dword [esp+0x0c] ; load function argument in esi
  prefs: []
  type: TYPE_NORMAL
- en: '.calc_hash:'
  prefs: []
  type: TYPE_NORMAL
- en: xor edi, edi 
  prefs: []
  type: TYPE_NORMAL
- en: cld
  prefs: []
  type: TYPE_NORMAL
- en: '.hash_iter:'
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: lodsb 
  prefs: []
  type: TYPE_NORMAL
- en: ; load next byte of input string
  prefs: []
  type: TYPE_NORMAL
- en: cmp al, ah
  prefs: []
  type: TYPE_NORMAL
- en: je .hash_done ; check if at end of symbol ror edi, 0x0d 
  prefs: []
  type: TYPE_NORMAL
- en: ; rotate right 13 (0x0d)
  prefs: []
  type: TYPE_NORMAL
- en: add edi, eax
  prefs: []
  type: TYPE_NORMAL
- en: jmp near .hash_iter
  prefs: []
  type: TYPE_NORMAL
- en: '.hash_done:'
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, edi
  prefs: []
  type: TYPE_NORMAL
- en: pop edi
  prefs: []
  type: TYPE_NORMAL
- en: pop esi
  prefs: []
  type: TYPE_NORMAL
- en: retn 4
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-5: hashString implementation*'
  prefs: []
  type: TYPE_NORMAL
- en: This function calculates a 32-bit DWORD hash value of the string pointer argument.
    The EDI register is treated as the current hash value, and is initialized to zero
    at . Each byte of the input string is loaded via the lodsb instruction at .
    If the byte is not NULL, the current hash is rotated right by 13 (0x0d) at ,
    and the current byte is added into the hash. This hash is returned in EAX so that
    its caller can compare the result with the value compiled into the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The particular algorithm in Listing 19-5 has become commonly used due to its
    inclusion in Metasploit, but variations that use different rotation amounts and
    hash sizes* *are sometimes seen.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Full Hello World Example**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-6 shows a full implementation of the findSymbolByHash function that
    can be used to find exported symbols in loaded DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: '**418**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '; __stdcall DWORD findSymbolByHash(DWORD dllBase, DWORD symHash); findSymbolByHash:'
  prefs: []
  type: TYPE_NORMAL
- en: pushad
  prefs: []
  type: TYPE_NORMAL
- en: 'mov ebp, [esp + 0x24] ; load 1st arg: dllBase'
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [ebp + 0x3c] 
  prefs: []
  type: TYPE_NORMAL
- en: ; get offset to PE signature
  prefs: []
  type: TYPE_NORMAL
- en: '; load edx w/ DataDirectories array: assumes PE32'
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, [ebp + eax + 4+20+96] 
  prefs: []
  type: TYPE_NORMAL
- en: add edx, ebp ; edx:= addr IMAGE_EXPORT_DIRECTORY
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, [edx + 0x18]  ; ecx:= NumberOfNames
  prefs: []
  type: TYPE_NORMAL
- en: mov ebx, [edx + 0x20] ; ebx:= RVA of AddressOfNames add ebx, ebp ; rva->va
  prefs: []
  type: TYPE_NORMAL
- en: '.search_loop:'
  prefs: []
  type: TYPE_NORMAL
- en: jecxz .error_done ; if at end of array, jmp to done dec ecx ; dec loop counter
  prefs: []
  type: TYPE_NORMAL
- en: ; esi:= next name, uses ecx*4 because each pointer is 4 bytes mov esi, [ebx+ecx*4]
  prefs: []
  type: TYPE_NORMAL
- en: add esi, ebp ; rva->va
  prefs: []
  type: TYPE_NORMAL
- en: push esi
  prefs: []
  type: TYPE_NORMAL
- en: call hashString 
  prefs: []
  type: TYPE_NORMAL
- en: ; hash the current string
  prefs: []
  type: TYPE_NORMAL
- en: '; check hash result against arg #2 on stack: symHash'
  prefs: []
  type: TYPE_NORMAL
- en: cmp eax, [esp + 0x28] 
  prefs: []
  type: TYPE_NORMAL
- en: jnz .search_loop
  prefs: []
  type: TYPE_NORMAL
- en: ; at this point we found the string in AddressOfNames
  prefs: []
  type: TYPE_NORMAL
- en: mov ebx, [edx+0x24] ; ebx:= ordinal table rva add ebx, ebp ; rva->va
  prefs: []
  type: TYPE_NORMAL
- en: ; turn cx into ordinal from name index.
  prefs: []
  type: TYPE_NORMAL
- en: '; use ecx*2: each value is 2 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: mov cx, [ebx+ecx*2] 
  prefs: []
  type: TYPE_NORMAL
- en: mov ebx, [edx+0x1c] ; ebx:= RVA of AddressOfFunctions add ebx, ebp ; rva->va
  prefs: []
  type: TYPE_NORMAL
- en: '; eax:= Export function rva. Use ecx*4: each value is 4 bytes mov eax, [ebx+ecx*4]
    '
  prefs: []
  type: TYPE_NORMAL
- en: add eax, ebp ; rva->va
  prefs: []
  type: TYPE_NORMAL
- en: jmp near .done
  prefs: []
  type: TYPE_NORMAL
- en: '.error_done:'
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax ; clear eax on error
  prefs: []
  type: TYPE_NORMAL
- en: '.done:'
  prefs: []
  type: TYPE_NORMAL
- en: mov [esp + 0x1c], eax 
  prefs: []
  type: TYPE_NORMAL
- en: ; overwrite eax saved on stack
  prefs: []
  type: TYPE_NORMAL
- en: popad
  prefs: []
  type: TYPE_NORMAL
- en: retn 8
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-6: findSymbolByHash implementation*'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes as arguments a pointer to the base of the DLL and a 32-bit
    hash value that corresponds to the symbol to find. It returns the pointer to the
    requested function in register EAX. Remember that all addresses in a PE file are
    stored as RVAs, so code needs to continuously add the dllBase value (kept in register
    EBP in this example) to the RVAs retrieved from PE
  prefs: []
  type: TYPE_NORMAL
- en: structures to create pointers it can actually use.
  prefs: []
  type: TYPE_NORMAL
- en: The code begins parsing the PE file at  to get the pointer to the PE
  prefs: []
  type: TYPE_NORMAL
- en: signature. A pointer to IMAGE_EXPORT_DIRECTORY is created at  by adding the
    correct offset, assuming this is a 32-bit PE file. The code begins parsing the
    Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**419**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: IMAGE_EXPORT_DIRECTORY structure at , loading the NumberOfNames value and the
    AddressOfNames pointer. Each string pointer in AddressOfNames is passed to the
    hashString function at , and the result of this calculation is compared against
    the value passed as the function argument at .
  prefs: []
  type: TYPE_NORMAL
- en: Once the correct index into AddressOfNames is found, it is used as an index
    into the AddressOfNameOrdinals array at location  to obtain the corresponding
    ordinal value, which is used as an index into the AddressOfFunctions array at
    . This is the value the user wants, so it is written to the stack at , overwriting
    the EAX value saved by the pushad instruction so that this value is preserved
    by the following popad instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-7 shows a complete Hello World shellcode example that uses the previously
    defined findKernel32Base and findSymbolByHash functions, instead of relying on
    hard-coded API locations.
  prefs: []
  type: TYPE_NORMAL
- en: mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: sub esp, 24h
  prefs: []
  type: TYPE_NORMAL
- en: call sub_A0  ; call to real start of code db 'user32',0 
  prefs: []
  type: TYPE_NORMAL
- en: db 'Hello World!!!!',0
  prefs: []
  type: TYPE_NORMAL
- en: 'sub_A0:'
  prefs: []
  type: TYPE_NORMAL
- en: pop ebx ; ebx gets pointer to data
  prefs: []
  type: TYPE_NORMAL
- en: call findKernel32Base 
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp-4], eax ; store kernel32 base address push 0EC0E4E8Eh ; LoadLibraryA
    hash
  prefs: []
  type: TYPE_NORMAL
- en: push dword ptr [ebp-4]
  prefs: []
  type: TYPE_NORMAL
- en: call findSymbolByHash 
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp-14h], eax ; store LoadLibraryA location lea eax, [ebx]  ; eax points
    to "user32"
  prefs: []
  type: TYPE_NORMAL
- en: push eax
  prefs: []
  type: TYPE_NORMAL
- en: call dword ptr [ebp-14h] ; LoadLibraryA
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp-8], eax ; store user32 base address
  prefs: []
  type: TYPE_NORMAL
- en: push 0BC4DA2A8h  ; MessageBoxA hash
  prefs: []
  type: TYPE_NORMAL
- en: push dword ptr [ebp-8] ; user32 dll location
  prefs: []
  type: TYPE_NORMAL
- en: call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp-0Ch], eax ; store MessageBoxA location push 73E2D87Eh ; ExitProcess
    hash
  prefs: []
  type: TYPE_NORMAL
- en: push dword ptr [ebp-4] ; kernel32 dll location
  prefs: []
  type: TYPE_NORMAL
- en: call findSymbolByHash
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp-10h], eax ; store ExitProcess location xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 'lea edi, [ebx+7] ; edi:= "Hello World!!!!" pointer push eax ; uType: MB_OK'
  prefs: []
  type: TYPE_NORMAL
- en: push edi ; lpCaption
  prefs: []
  type: TYPE_NORMAL
- en: push edi ; lpText
  prefs: []
  type: TYPE_NORMAL
- en: 'push eax ; hWnd: NULL'
  prefs: []
  type: TYPE_NORMAL
- en: call dword ptr [ebp-0Ch] ; call MessageBoxA
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: push eax ; uExitCode
  prefs: []
  type: TYPE_NORMAL
- en: call dword ptr [ebp-10h] ; call ExitProcess
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 19-7: Position-independent Hello World*'
  prefs: []
  type: TYPE_NORMAL
- en: '**420**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The code begins by using a call/pop at  to obtain a pointer to the data starting
    at . It then calls findKernel32Base at  to find *kernel32.dll* and calls findSymbolByHash
    at  to find the export in *kernel32.dll* with the hash 0xEC0E4E8E. This is the
    ror-13-additive hash of the string LoadLibraryA.
  prefs: []
  type: TYPE_NORMAL
- en: When this function returns EAX, it will point to the actual memory location
    for LoadLibraryA.
  prefs: []
  type: TYPE_NORMAL
- en: The code loads a pointer to the "user32" string at  and calls the LoadLibraryA
    function. It then finds the exported function MessageBoxA at 
  prefs: []
  type: TYPE_NORMAL
- en: and calls it to display the “Hello World!!!!” message. Finally, it calls ExitProcess
    to cleanly exit.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the shellcode’s PE parsing ability instead of GetProcAddress has the
    additional* *benefit of making reverse-engineering of the shellcode more difficult.
    The hash values* *hide the API calls used from casual inspection.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shellcode Encodings**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to execute, the shellcode binary must be located somewhere in the program’s
    address space when it is triggered. When paired with an exploit, this means that
    the shellcode must be present before the exploit occurs or be passed along with
    the exploit. For example, if the program is performing some basic filtering on
    input data, the shellcode must pass this filter, or it will not be in the vulnerable
    process’s memory space. This means that shellcode often must look like legitimate
    data in order to be accepted by a vulnerable program.
  prefs: []
  type: TYPE_NORMAL
- en: One example is a program that uses the unsafe string functions strcpy and strcat,
    both of which do not set a maximum length on the data they write. If a program
    reads or copies malicious data into a fixed-length buffer using either of these
    functions, the data can easily exceed the size of the buffer and lead to a buffer-overflow
    attack. These functions treat strings as an array of characters terminated by
    a NULL (0x00) byte. Shellcode that an attacker wants copied into this buffer must
    look like valid data, which means that it must not have any NULL bytes in the
    middle that would prematurely end the string-copy operation.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-8 shows a small piece of disassembly of code used to access the registry,
    with seven NULL bytes in this selection alone. This code could typically not be
    used as-is in a shellcode payload.
  prefs: []
  type: TYPE_NORMAL
- en: 57 push edi
  prefs: []
  type: TYPE_NORMAL
- en: 50 push eax ; phkResult
  prefs: []
  type: TYPE_NORMAL
- en: 6A 01 push 1 ; samDesired 8D 8B D0 13 **00 00** lea ecx, [ebx+13D0h]
  prefs: []
  type: TYPE_NORMAL
- en: 6A **00** push 0 ; ulOptions 51 push ecx ; lpSubKey
  prefs: []
  type: TYPE_NORMAL
- en: '68 02 **00 00** 80 push 80000002h ; hKey: HKEY_LOCAL_MACHINE'
  prefs: []
  type: TYPE_NORMAL
- en: 'FF 15 20 **00** 42 **00** call ds:RegOpenKeyExA *Listing 19-8: Typical code
    with highlighted NULL bytes* Shellcode Analysis'
  prefs: []
  type: TYPE_NORMAL
- en: '**421**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs may perform additional sanity checks on data that the shellcode must
    pass in order to succeed, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: All bytes are printable (less than 0x80) ASCII bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: All bytes are alphanumeric ( *A* through *Z*, *a* through *z*, or 0 through
    9).
  prefs: []
  type: TYPE_NORMAL
- en: To overcome filtering limitations by the vulnerable program, nearly all shellcode
    encodes the main payload to pass the vulnerable program’s filter and inserts a
    decoder that turns the encoded payload into executable bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Only the small decoder section must be written carefully so that its instruction
    bytes will pass the strict filter requirements; the rest of the payload can be
    encoded at compile time to also pass the filter. If the shellcode writes the decoded
    bytes back on top of the encoded bytes (as usual), the shellcode is self-modifying.
    When the decoding is complete, the decoder transfers control to the main payload
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are common encoding techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: XOR all payload bytes with constant byte mask. Remember that for all values
    of the same size *a*, *b* that ( *a* XOR *b*) XOR *b* == *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Use an alphabetic transform where a single byte of payload is split into two
    4-bit nibbles and added to a printable ASCII character (such as *A* or *a*).
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode encodings have additional benefits for the attackers, in that they
    make analysis more difficult by hiding human-readable strings such as URLs or
    IP addresses. Also, they may help evade network IDSs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOP Sleds**'
  prefs: []
  type: TYPE_NORMAL
- en: A *NOP sled* (also known as a *NOP slide*) is a long sequence of instructions
    preceding shellcode, as shown in Figure 19-3\. NOP sleds are not required to be
    present with shellcode, but they are often included as part of an exploit to increase
    the likelihood of the exploit succeeding. Shellcode authors can do this by creating
    a large NOP sled immediately preceding the shellcode. As long as execution is
    directed somewhere within the NOP sled, the shellcode will eventually run.
  prefs: []
  type: TYPE_NORMAL
- en: Jump Location
  prefs: []
  type: TYPE_NORMAL
- en: NOP Sled
  prefs: []
  type: TYPE_NORMAL
- en: Decoder
  prefs: []
  type: TYPE_NORMAL
- en: Encoded Payload
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 19-3: NOP sled and shellcode layout*'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional NOP sleds are made up of long sequences of the NOP (0x90) instruction,
    but exploit authors can be creative in order to avoid detection.
  prefs: []
  type: TYPE_NORMAL
- en: Other popular opcodes are in the 0x40 to 0x4f range. These opcodes are single-byte
    instructions that increment or decrement the general-purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: '**422**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This opcode byte range also consists of only printable ASCII characters. This
    is often useful because the NOP sled executes before the decoder runs, so it must
    pass the same filtering requirements as the rest of the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Shellcode**'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode can be found in a variety of sources, including network traffic, web
    pages, media files, and malware. Because it is not always possible to create an
    environment with the correct version of the vulnerable program that the exploit
    targets, the malware analyst must try to reverse-engineer shellcode using only
    static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious web pages typically use JavaScript to profile a user’s system and
    check for vulnerable versions of the browser and installed plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript unescape is typically used to convert the encoded shellcode text
    into a binary package suitable for execution. Shellcode is often stored as an
    encoded text string included with the script that triggers the exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The encoding understood by unescape treats the text %u *XXYY* as an encoded
    big-endian Unicode character, where *XX* and *YY* are hex values. On little-endian
    machines (such as x86), the byte sequence *YY* *XX* will be the result after decoding.
    For example, consider this text string:'
  prefs: []
  type: TYPE_NORMAL
- en: '%u1122%u3344%u5566%u7788%u99aa%ubbcc%uddee'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be decoded to the following binary byte sequence: 22 11 44 33 66 55
    88 77 aa 99 cc bb ee dd'
  prefs: []
  type: TYPE_NORMAL
- en: A % symbol that is not immediately followed by the letter u is treated as a
    single encoded hex byte. For example, the text string %41%42%43%44 will be decoded
    to the binary byte sequence 41 42 43 44\.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Both single- and double-byte encoded characters can be used within the same
    text string.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This is a popular technique wherever JavaScript is used, including in PDF
    documents.*'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode used within a malicious executable is usually easy to identify because
    the entire program will be written using shellcode techniques as obfuscation,
    or a shellcode payload will be stored within the malware and will be injected
    into another process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shellcode payload is usually found by looking for the typical process-injection
    API calls discussed in Chapter 12: VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread.
    The buffer written into the other process probably contains shellcode if the malware
    launches a remote thread without applying relocation fix-ups or resolving external
    dependencies. This may be convenient for the malware writer, since shellcode can
    bootstrap itself and execute without help from the originating malware.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes shellcode is stored unencoded within a media file. Disassemblers such
    as IDA Pro can load arbitrary binary files, including those suspected of containing
    shellcode. However, even if IDA Pro loads the file, it may not analyze the shellcode,
    because it does not know which bytes are valid code.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**423**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Finding shellcode usually means searching for the initial decoder that is likely
    present at the start of the shellcode. Useful opcodes to search for are listed
    in Table 19-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-2:** Some Opcode Bytes to Search For'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction type**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common opcodes**'
  prefs: []
  type: TYPE_NORMAL
- en: Call
  prefs: []
  type: TYPE_NORMAL
- en: '0xe8'
  prefs: []
  type: TYPE_NORMAL
- en: Unconditional jumps
  prefs: []
  type: TYPE_NORMAL
- en: 0xeb, 0xe9
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs: []
  type: TYPE_NORMAL
- en: 0xe0, 0xe1, 0xe2
  prefs: []
  type: TYPE_NORMAL
- en: Short conditional jumps
  prefs: []
  type: TYPE_NORMAL
- en: 0x70 through 0x7f
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to disassemble each instance of the opcodes listed in Table 19-2
  prefs: []
  type: TYPE_NORMAL
- en: in the loaded file. Any valid code should be immediately obvious. Just remember
    that the payload is likely encoded, so only the decoder will be visible at first.
  prefs: []
  type: TYPE_NORMAL
- en: If none of those searches work, there may still be embedded shellcode, because
    some file formats allow for encoded embedded data. For example, exploits targeting
    the CVE-2010-0188 critical vulnerability in Adobe Reader use malformed TIFF images,
    embedded within PDFs, stored as a Base64-encoded string, which may be zlib-compressed.
    When working with particular file formats, you will need to be familiar with that
    format and the kind of data it can contain in order to search for malicious content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode authors must employ techniques to work around inherent limitations
    of the odd runtime environment in which shellcode executes. This includes identifying
    where in memory the shellcode is executing and manually resolving all of the shellcode’s
    external dependencies so that it can interact with the system. To save on space,
    these dependencies are usually obfuscated by using hash values instead of ASCII
    function names. It is also common for nearly the entire shellcode to be encoded
    so that it bypasses any data filtering by the targeted process. All of these techniques
    can easily frustrate beginning analysts, but the material in this chapter should
    help you recognize these common activities, so you can instead focus on understanding
    the main functionality of the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '**424**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: In these labs, we’ll use what we’ve covered in Chapter 19 to analyze samples
    inspired by real shellcode. Because a debugger cannot easily load and run shellcode
    directly, we’ll use a utility called *shellcode_launcher.exe* to dynamically analyze
    shellcode binaries. You’ll find instructions on how to use this utility in Chapter
    19 and in the detailed analyses in Appendix C.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 19-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the file *Lab19-01.bin* using *shellcode_launcher.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: How is the shellcode encoded?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Which functions does the shellcode manually import?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What network host does the shellcode communicate with?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What filesystem residue does the shellcode leave?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What does the shellcode do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 19-2**'
  prefs: []
  type: TYPE_NORMAL
- en: The file *Lab19-02.exe* contains a piece of shellcode that will be injected
    into another process and run. Analyze this file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What process is injected with the shellcode?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Where is the shellcode located?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: How is the shellcode encoded?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Which functions does the shellcode manually import?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What network hosts does the shellcode communicate with?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: What does the shellcode do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 19-3**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the file *Lab19-03.pdf*. If you get stuck and can’t find the shellcode,
    just skip that part of the lab and analyze file *Lab19-03_sc.bin* using
  prefs: []
  type: TYPE_NORMAL
- en: '*shellcode_launcher.exe*.'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**425**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What exploit is used in this PDF?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: How is the shellcode encoded?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Which functions does the shellcode manually import?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What filesystem residue does the shellcode leave?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What does the shellcode do?
  prefs: []
  type: TYPE_NORMAL
- en: '**426**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**C + + A N A L Y S I S**'
  prefs: []
  type: TYPE_NORMAL
- en: Malware analysis is conducted without access to source
  prefs: []
  type: TYPE_NORMAL
- en: code, but the specific source language has a significant impact on the assembly.
    For example, C++ has several
  prefs: []
  type: TYPE_NORMAL
- en: features and constructs that do not exist in C, and
  prefs: []
  type: TYPE_NORMAL
- en: these can complicate analysis of the resulting assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious programs written in C++ create challenges for the malware analyst
    that make it harder to determine the purpose of assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding basic C++ features and how they appear in assembly language is
    critical to analyzing malware written in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-Oriented Programming**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C, C++ is an object-oriented programming language, following a programming
    model that uses objects that contain data as well as functions to manipulate the
    data. The functions in object-oriented programming are like functions in C programs,
    except that they are associated with a particular object or class of objects.
    Functions within a C++ class are often called *methods*
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: to draw a distinction. Although many features of object-oriented programming
    are irrelevant to malware analysis because they do not impact the assembly, a
    few can complicate analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn more about C++, consider reading* Thinking in C++ *by Bruce Eckel,
    available as a free download from* http://www.mindviewinc.com/ *.*'
  prefs: []
  type: TYPE_NORMAL
- en: In object-orientation, code is arranged in user-defined data types called *classes*.
    Classes are like structs, except that they store function information in addition
    to data. Classes are like a blueprint for creating an object—one that specifies
    the functions and data layout for an object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: When executing object-oriented C++ code, you use the class to create an object
    of the class. This object is referred to as an *instance* of the class. You can
    have multiple instances of the same class. Each instance of a class has its own
    data, but all objects of the same type share the same functions. To access data
    or call a function, you must reference an object of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 20-1 shows a simple C++ program with a class and a single object.
  prefs: []
  type: TYPE_NORMAL
- en: class SimpleClass {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: int x;
  prefs: []
  type: TYPE_NORMAL
- en: void HelloWorld() {
  prefs: []
  type: TYPE_NORMAL
- en: printf("Hello World\n");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: int _tmain(int argc, _TCHAR* argv[])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleClass myObject;
  prefs: []
  type: TYPE_NORMAL
- en: myObject.HelloWorld();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-1: A simple C++ class*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the class is called SimpleClass. It has one data element, x,
    and a single function, HelloWorld. We create an instance of SimpleClass named
    myObject and call the HelloWorld function for that object. (The public keyword
    is a compiler-enforced abstraction mechanism with no impact on the assembly code.)
  prefs: []
  type: TYPE_NORMAL
- en: '***The this Pointer***'
  prefs: []
  type: TYPE_NORMAL
- en: As we have established, data and functions are associated with objects. In order
    to access a piece of data, you use the form *ObjectName.variableName*.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are called similarly with *ObjectName.functionName*. For example,
    in Listing 20-1, if we wanted to access the x variable, we would use myObject.x.
  prefs: []
  type: TYPE_NORMAL
- en: '**428**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to accessing variables using the object name and the variable name,
    you can also access variables for the current object using only the variable name.
    Listing 20-2 shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: class SimpleClass {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: int x;
  prefs: []
  type: TYPE_NORMAL
- en: void HelloWorld() {
  prefs: []
  type: TYPE_NORMAL
- en: if (x == 10) printf("X is 10.\n");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: int _tmain(int argc, _TCHAR* argv[])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleClass myObject;
  prefs: []
  type: TYPE_NORMAL
- en: myObject.x = 9;
  prefs: []
  type: TYPE_NORMAL
- en: myObject.HelloWorld();
  prefs: []
  type: TYPE_NORMAL
- en: SimpleClass myOtherObject;
  prefs: []
  type: TYPE_NORMAL
- en: myOtherOject.x = 10;
  prefs: []
  type: TYPE_NORMAL
- en: myOtherObject.HelloWorld();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-2: A C++ example with the this pointer*'
  prefs: []
  type: TYPE_NORMAL
- en: In the HelloWorld function, the variable x is accessed as just x at , and not
    *ObjectName*.x. That same variable, which refers to the same address in memory,
    is accessed in the main method at  using myObject.x.
  prefs: []
  type: TYPE_NORMAL
- en: Within the HelloWorld method, the variable can be accessed just as x because
    it is assumed to refer to the object that was used to call the function, which
    in the first case is myObject . Depending on which object is used to call the
    HelloWorld function, a different memory address storing the x variable will be
    accessed. For example, if the function were called with myOtherObject.HelloWorld,
    then an x reference at  would access a different memory location than when that
    is called with myObject.HelloWorld. The this pointer is used to keep track of
    which memory address to access when accessing the x variable.
  prefs: []
  type: TYPE_NORMAL
- en: The this pointer is implied in every variable access within a function that
    doesn’t specify an object; it is an implied parameter to every object function
    call. Within Microsoft-generated assembly code, the this parameter is usually
    passed in the ECX register, although sometimes ESI is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 6, we covered the stdcall, cdecl, and fastcall calling conventions.
    The C++ calling convention for the this pointer is often called *thiscall*.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the thiscall convention can be one easy way to identify object-oriented
    code when looking at disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**429**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The assembly in Listing 20-3, generated from Listing 20-2, demonstrates the
    usage of the this pointer.
  prefs: []
  type: TYPE_NORMAL
- en: ;Main Function
  prefs: []
  type: TYPE_NORMAL
- en: 00401100 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00401101 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 00401103 sub esp, 1F0h
  prefs: []
  type: TYPE_NORMAL
- en: 00401109
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp+var_10], offset off_404768
  prefs: []
  type: TYPE_NORMAL
- en: '00401110'
  prefs: []
  type: TYPE_NORMAL
- en: mov [ebp+var_C], 9
  prefs: []
  type: TYPE_NORMAL
- en: '00401117'
  prefs: []
  type: TYPE_NORMAL
- en: lea ecx, [ebp+var_10]
  prefs: []
  type: TYPE_NORMAL
- en: 0040111A call sub_4115D0
  prefs: []
  type: TYPE_NORMAL
- en: 0040111F mov [ebp+var_34], offset off_404768
  prefs: []
  type: TYPE_NORMAL
- en: 00401126 mov [ebp+var_30], 0Ah
  prefs: []
  type: TYPE_NORMAL
- en: 0040112D
  prefs: []
  type: TYPE_NORMAL
- en: lea ecx, [ebp+var_34]
  prefs: []
  type: TYPE_NORMAL
- en: 00401130 call sub_4115D0
  prefs: []
  type: TYPE_NORMAL
- en: ;HelloWorld Function
  prefs: []
  type: TYPE_NORMAL
- en: 004115D0 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004115D1 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 004115D3 sub esp, 9Ch
  prefs: []
  type: TYPE_NORMAL
- en: 004115D9 push ebx
  prefs: []
  type: TYPE_NORMAL
- en: 004115DA push esi
  prefs: []
  type: TYPE_NORMAL
- en: 004115DB push edi
  prefs: []
  type: TYPE_NORMAL
- en: 004115DC mov [ebp+var_4], ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004115DF mov eax, [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: 004115E2 cmp dword ptr [eax+4], 0Ah
  prefs: []
  type: TYPE_NORMAL
- en: 004115E6 jnz short loc_4115F6
  prefs: []
  type: TYPE_NORMAL
- en: 004115E8 push offset aXIs10_ ; "X is 10.\n"
  prefs: []
  type: TYPE_NORMAL
- en: 004115ED call ds:__imp__printf
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-3: The this pointer shown in disassembly*'
  prefs: []
  type: TYPE_NORMAL
- en: The main method first allocates space on the stack. The beginning of the object
    is stored at var_10 on the stack at . The first data value stored in that object
    is the variable x, which is set at an offset of 4 from the beginning of the object.
    The value x is accessed at  and is labeled var_C by IDA Pro.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro can’t determine whether the values are both part of the same object,
    and it labels x as a separate value. The pointer to the object is then placed
    into ECX for the function call . Within the HelloWorld function, the value of
    ECX is retrieved and used as the this pointer . Then at an offset of 4, the code
    accesses the value for x . When the main function calls HelloWorld for the second
    time, it loads a different pointer into ECX.
  prefs: []
  type: TYPE_NORMAL
- en: '***Overloading and Mangling***'
  prefs: []
  type: TYPE_NORMAL
- en: C++ supports a coding construct known as *method overloading*, which is the
    ability to have multiple functions with the same name, but that accept different
    parameters. When the function is called, the compiler determines which version
    of the function to use based on the number and types of parameters used in the
    call, as shown in Listing 20-4\.
  prefs: []
  type: TYPE_NORMAL
- en: '**430**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 90](index-464_1.png)'
  prefs: []
  type: TYPE_IMG
- en: LoadFile (String filename) {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: LoadFile (String filename, int Options) {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Main () {
  prefs: []
  type: TYPE_NORMAL
- en: LoadFile ("c:\myfile.txt"); //Calls the first LoadFile function LoadFile ("c:\myfile.txt",
    GENERIC_READ); //Calls the second LoadFile
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-4: Function overloading example*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the listing, there are two LoadFile functions: one that takes
    only a string and another that takes a string and an integer. When the LoadFile
    function is called within the main method, the compiler selects the function to
    call based on the number of parameters supplied.'
  prefs: []
  type: TYPE_NORMAL
- en: C++ uses a technique called *name mangling* to support method overloading. In
    the PE file format, each function is labeled with only its name, and the function
    parameters are not specified in the compiled binary format.
  prefs: []
  type: TYPE_NORMAL
- en: To support overloading, the names in the file format are modified so that the
    name information includes the parameter information. For example, if a function
    called TestFunction is part of the SimpleClass class and accepts two integers
    as parameters, the mangled name of that function would be
  prefs: []
  type: TYPE_NORMAL
- en: ?TestFunction@SimpleClass@@QAEXHH@Z.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm for mangling the names is compiler-specific, but IDA Pro can demangle
    the names for most compilers. For example, Figure 20-1 shows the function TestFunction.
    IDA Pro demangles the function and shows the original name and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 20-1: IDA Pro listing of a demangled function name* The internal function
    names are visible only if there are symbols in the code you are analyzing. Malware
    usually has the internal symbols removed; however, some imported or exported C++
    functions with mangled names may be visible in IDA Pro.'
  prefs: []
  type: TYPE_NORMAL
- en: C++ Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**431**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Inheritance and Function Overriding***'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inheritance* is an object-oriented programming concept in which parent-child
    relationships are established between classes. Child classes inherit functions
    and data from parent classes. A child class automatically has all the functions
    and data of the parent class, and usually defines additional functions and data.
    For example, Listing 20-5 shows a class called Socket.'
  prefs: []
  type: TYPE_NORMAL
- en: class Socket {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void setDestinationAddr (INetAddr * addr) {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'class UDPSocket : publicSocket {'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void sendData (char * buf, INetAddr * addr) {
  prefs: []
  type: TYPE_NORMAL
- en:  setDestinationAddr(addr)
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-5: Inheritance example*'
  prefs: []
  type: TYPE_NORMAL
- en: The Socket class has a function to set the destination address, but it has no
    function to sendData because it’s not a specific type of socket. A child class
    called UDPSocket can send data and implements the sendData function at , and
    it can also call the setDestinationAddr function defined in the Socket class.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 20-5, the sendData function at  can call the setDestinationAddr
    function at  even though that function is not defined in the UDPSocket class,
    because the functionality of the parent class is automatically included in the
    child class.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance helps programmers more efficiently reuse code, but it’s a feature
    that does not require any runtime data structures and generally isn’t visible
    in assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual vs. Nonvirtual Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: A *virtual function* is one that can be overridden by a subclass and whose execution
    is determined at *runtime*. If a function is defined within a parent class and
    a function with the same name is defined in a child class, the child class’s function
    overrides the parent’s function.
  prefs: []
  type: TYPE_NORMAL
- en: Several popular programming models use this functionality in order to greatly
    simplify complex programming tasks. To illustrate why this is useful, return to
    the socket example in Listing 20-5\. There, we have code that is going to sendData
    over the network, and we want it to be able to send data via TCP and UDP. One
    easy way to accomplish this is to create a parent class **432**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: called Socket with a virtual function called sendData. Then we have two chil-dren
    classes called UDPSocket and TCPSocket, which override the sendData function to
    send the data over the appropriate protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the code that uses the socket, we create an object of type Socket, and create
    whichever socket we are using in this instance. Each time we call the sendData
    function, the sendData function will be called from the proper subclass of Socket,
    whether UDPSocket or TCPSocket, based on which type of Socket object was originally
    created.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage here is that if a new protocol—QDP, for example—
  prefs: []
  type: TYPE_NORMAL
- en: is invented, you simply create a new QDPSocket class, and then change the line
    of code where the object is created. Then all calls to sendData will call the
    new QDPSocket version of sendData without the need to change all the calls individually.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of nonvirtual functions, the function to be executed is determined
    at compile time. If the object is an instance of the parent class, the parent
    class’s function will be called, even if the object at runtime belongs to the
    child class. When a virtual function is called on an object of the child class,
    the child class’s version of the function may be called, if the object is typed
    as an instance of the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Table 20-1 shows a code snippet that will execute differently if the function
    is virtual or nonvirtual.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 20-1:** Source Code Example for Virtual Functions **Non-virtual function**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual function**'
  prefs: []
  type: TYPE_NORMAL
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void foo() {
  prefs: []
  type: TYPE_NORMAL
- en: **virtual** void foo() {
  prefs: []
  type: TYPE_NORMAL
- en: printf("Class A\n");
  prefs: []
  type: TYPE_NORMAL
- en: printf("Class A\n");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'class B : public A {'
  prefs: []
  type: TYPE_NORMAL
- en: 'class B : public A {'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void foo() {
  prefs: []
  type: TYPE_NORMAL
- en: **virtual** void foo() {
  prefs: []
  type: TYPE_NORMAL
- en: printf("Class B\n");
  prefs: []
  type: TYPE_NORMAL
- en: printf("Class B\n");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: void g(A& arg) {
  prefs: []
  type: TYPE_NORMAL
- en: void g(A& arg) {
  prefs: []
  type: TYPE_NORMAL
- en: arg.foo();
  prefs: []
  type: TYPE_NORMAL
- en: arg.foo();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int _tmain(int argc, _TCHAR* argv[])
  prefs: []
  type: TYPE_NORMAL
- en: int _tmain(int argc, _TCHAR* argv[])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: B b;
  prefs: []
  type: TYPE_NORMAL
- en: B b;
  prefs: []
  type: TYPE_NORMAL
- en: A a;
  prefs: []
  type: TYPE_NORMAL
- en: A a;
  prefs: []
  type: TYPE_NORMAL
- en: g(b);
  prefs: []
  type: TYPE_NORMAL
- en: g(b);
  prefs: []
  type: TYPE_NORMAL
- en: return 0;
  prefs: []
  type: TYPE_NORMAL
- en: return 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: C++ Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**433**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code contains two classes: class A and class B. The class B class overrides
    the foo method from class A. The code also contains a function to call the foo
    method from outside either class. If the function is not declared as virtual,
    it will print “Class A.” If it is declared as virtual, it will print “Class B.”
    The code on either side is identical except for the virtual keywords at  and
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of nonvirtual functions, the determination of which function to
    call is made at compile time. In the two code samples in Listing 20-6, when this
    code is compiled, the object at  is of class A. While the object at 
  prefs: []
  type: TYPE_NORMAL
- en: could be a subclass of class A, at compile time, we know that it is an object
    of class A, and the foo function for class A is called. This is why the code on
    the left will print “Class A.”
  prefs: []
  type: TYPE_NORMAL
- en: In the case of virtual functions, the determination of which function to call
    is made at runtime. If a class A object is called at runtime, then the class A
    version of the function is called. If the object is of class B, then the class
    B
  prefs: []
  type: TYPE_NORMAL
- en: function is called. This is why the code on the right will print “Class B.”
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is often referred to as *polymorphism*. The biggest advantage
    to polymorphism is that it allows objects that perform different functionality
    to share a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: '***Use of Vtables***'
  prefs: []
  type: TYPE_NORMAL
- en: The C++ compiler will add special data structures when it compiles code to support
    virtual functions. These data structures are called *virtual function* *tables*,
    or *vtables*. These tables are simply arrays of function pointers. Each class
    using virtual functions has its own vtable, and each virtual function in a class
    has an entry in the vtable.
  prefs: []
  type: TYPE_NORMAL
- en: Table 20-2 shows a disassembly of g function from the two code snippets in Table
    20-1\. On the left is the nonvirtual function call to foo, and on the right is
    the virtual call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 20-2:** Assembly Code of the Example from Table 20-1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-virtual function call**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual function call**'
  prefs: []
  type: TYPE_NORMAL
- en: 00401000 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00401000 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00401001 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 00401001 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 00401003 mov ecx, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 00401003 mov
  prefs: []
  type: TYPE_NORMAL
- en: eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 00401006 call sub_401030
  prefs: []
  type: TYPE_NORMAL
- en: 00401006 mov
  prefs: []
  type: TYPE_NORMAL
- en: edx, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 0040100B pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00401008 mov ecx, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 0040100C retn
  prefs: []
  type: TYPE_NORMAL
- en: 0040100B mov eax, [edx]
  prefs: []
  type: TYPE_NORMAL
- en: 0040100D call eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040100F pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00401010 retn
  prefs: []
  type: TYPE_NORMAL
- en: The source code change is small, but the assembly looks completely different.
    The function call on the left looks the same as the C functions that we have seen
    before. The virtual function call on the right looks different. The biggest difference
    is that we can’t see the destination for the call instruction, which can pose
    a big problem when analyzing disassembled C++, because we need to track down the
    target of the call instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**434**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The argument for the g function is a reference, which can be used as a pointer,
    to an object of class A (or any subclass of class A). The assembly code accesses
    the pointer to the beginning of the object . The code then accesses the first
    4 bytes of the object .
  prefs: []
  type: TYPE_NORMAL
- en: Figure 20-2 shows how the virtual function is used in Table 20-2 to determine
    which code to call. The first 4 bytes of the object are a pointer to the vtable.
    The first 4-byte entry of the vtable is a pointer to the code for the first virtual
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Object
  prefs: []
  type: TYPE_NORMAL
- en: Vtable
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs: []
  type: TYPE_NORMAL
- en: vtable
  prefs: []
  type: TYPE_NORMAL
- en: Function 1
  prefs: []
  type: TYPE_NORMAL
- en: push ebp
  prefs: []
  type: TYPE_NORMAL
- en: mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: object data1
  prefs: []
  type: TYPE_NORMAL
- en: Function 2
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: object data2
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 20-2: C++ object with a virtual function table (vtable)* To figure
    out which function is being called, you find where the vtable is being accessed,
    and you see which offset is being called. In Table 20-2, we see the first vtable
    entry being accessed. To find the code that is called, we must find the vtable
    in memory and then go to the first function in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: Nonvirtual functions do not appear in a vtable because there is no need for
    them. The target for nonvirtual function calls is fixed at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: '***Recognizing a Vtable***'
  prefs: []
  type: TYPE_NORMAL
- en: In order to identify the call destination, we need to determine the type of
    object and locate the vtable. If you can spot the new operator for the constructor
    (a concept described in the next section), you can typically discover the address
    of the vtable being accessed nearby.
  prefs: []
  type: TYPE_NORMAL
- en: The vtable looks like an array of function pointers. For example, Listing 20-6
    shows the vtable for a class with three virtual functions. When you see a vtable,
    only the first value in the table should have a cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: The other elements of the table are accessed by their offset from the beginning
    of the table, and there are no accesses directly to items within the table.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this example, the line labeled off_4020F0 is the beginning of the vtable,
    but don’t* *confuse this with switch offset tables, covered in Chapter 6\. A switch
    offset table* *would have offsets to locations that are not subroutines, labeled
    loc_###### instead* *of sub_######.*'
  prefs: []
  type: TYPE_NORMAL
- en: 004020F0 **off_4020F0** dd offset sub_4010A0
  prefs: []
  type: TYPE_NORMAL
- en: 004020F4 dd offset sub_4010C0
  prefs: []
  type: TYPE_NORMAL
- en: 004020F8 dd offset sub_4010E0
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-6: A vtable in IDA Pro*'
  prefs: []
  type: TYPE_NORMAL
- en: C++ Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**435**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 91](index-469_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can recognize virtual functions by their cross-references. Virtual functions
    are not directly called by other parts of the code, and when you check cross-references
    for a virtual function, you should not see any calls to that function. For example,
    Figure 20-3 shows the cross-references for a virtual function. Both cross-references
    are offsets to the function, and neither is a call instruction. Virtual functions
    almost always appear this way, whereas nonvirtual functions are typically referenced
    via a call instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 20-3: Cross-references for a virtual function* Once you have found
    a vtable and virtual functions, you can use that information to analyze them.
    When you identify a vtable, you instantly know that all functions within that
    table belong to the same class, and that functions within the same class are somehow
    related. You can also use vtables to determine if class relationships exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 20-7, an expansion of Listing 20-6, includes vtables for two classes.
  prefs: []
  type: TYPE_NORMAL
- en: 004020DC off_4020DC dd offset sub_401100
  prefs: []
  type: TYPE_NORMAL
- en: 004020E0 dd offset sub_4010C0
  prefs: []
  type: TYPE_NORMAL
- en: 004020E4
  prefs: []
  type: TYPE_NORMAL
- en: dd offset sub_4010E0
  prefs: []
  type: TYPE_NORMAL
- en: 004020E8 dd offset sub_401120
  prefs: []
  type: TYPE_NORMAL
- en: 004020EC dd offset unk_402198
  prefs: []
  type: TYPE_NORMAL
- en: 004020F0 off_4020F0 dd offset sub_4010A0
  prefs: []
  type: TYPE_NORMAL
- en: 004020F4 dd offset sub_4010C0
  prefs: []
  type: TYPE_NORMAL
- en: 004020F8
  prefs: []
  type: TYPE_NORMAL
- en: dd offset sub_4010E0
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-7: Vtables for two different classes*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the functions at  and  are the same, and that there are two cross-references
    for this function, as shown in Figure 20-3\. The two cross-references are from
    the two vtables that point to this function, which suggests an inheritance relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that child classes automatically include all functions from a parent
    class, unless they override it. In Listing 20-7, sub_4010E0 at  and  is a function
    from the parent class that is also in the vtable for the child class, because
    it can also be called for the child class.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t always differentiate a child class from a parent class, but if one
    vtable is larger than the other, it is the subclass. In this example, the vtable
    at offset 4020F0 is the parent class, and the vtable at offset 4020DC is the child
    class because its vtable is larger. (Remember that child classes always have the
    same functions as the parent class and may have additional functions.) **436**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating and Destroying Objects**'
  prefs: []
  type: TYPE_NORMAL
- en: Two special functions for C++ classes are the *constructor* and *destructor*.
    When an object is created, the constructor is called. When an object is destroyed,
    the destructor is called.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor performs any initialization needed by the object.
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be created on the stack or stored on the heap. For objects created
    on the stack, there is no need to allocate specific memory for the object; the
    object will simply be stored on the stack along with other local variables.
  prefs: []
  type: TYPE_NORMAL
- en: The destructor for objects is automatically called when the objects go out of
    scope. Sometimes this tends to complicate disassembly, because the compiler may
    need to add exception handling code in order to guarantee that object destructors
    are called.
  prefs: []
  type: TYPE_NORMAL
- en: For objects that are not stored on the stack, the memory is allocated with the
    new operator, which is a C++ keyword that creates heap space for a new object
    and calls the constructor. In disassembly, the new operator is usually an imported
    function that can be spotted easily. For example, Listing 20-8 shows the IDA Pro
    disassembly using the new operator implemented as an imported function. Since
    this is the new operator and not a regular function, it has an unusual function
    name. IDA Pro identifies the function properly as the new operator and labels
    it as such. Similarly, a delete operator is called when heap-allocated objects
    are to be freed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Object creation and deletion are key elements of the execution flow for a
    C++ program.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reverse-engineering these routines can usually provide key insight into the
    object layout* *and aid analysis in other member functions.*'
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 00401071 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 00401073 sub esp, 1Ch
  prefs: []
  type: TYPE_NORMAL
- en: 00401076 mov [ebp+var_10],  offset off_4020F0
  prefs: []
  type: TYPE_NORMAL
- en: 0040107D mov [ebp+var_10],  offset off_4020DC
  prefs: []
  type: TYPE_NORMAL
- en: 00401084 mov [ebp+var_4], offset off_4020F0
  prefs: []
  type: TYPE_NORMAL
- en: 0040108B push 4
  prefs: []
  type: TYPE_NORMAL
- en: 0040108D call ??2@YAPAXI@Z ; operator new(uint)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20-8: The new operator in disassembly*'
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 20-8, we’re looking at an object stored on the stack. The offset
    moved into location var_10 is the vtable. The compiler here shows some strange
    behavior by putting different offsets into the same location twice in a row. The
    instruction at  is useless, because the second offset at  will overwrite what
    is stored at .
  prefs: []
  type: TYPE_NORMAL
- en: If we were to look at the offsets for this code, we would see that they are
    the vtables for the two classes. The first offset is the vtable for the parent
    class, and the second offset is the vtable for the class of the object being created.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**437**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to analyze malicious programs written in C++, you need to understand
    C++ features and how they affect the assembly code. By understanding inheritance,
    vtables, the this pointer, and name mangling, you won’t be slowed down by C++
    code, and you’ll be able to take advantage of any clues provided by the additional
    structure created by C++ classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**438**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 20-1**'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this first lab is to demonstrate the usage of the this pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware in *Lab20-01.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Does the function at 0x401040 take any parameters?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Which URL is used in the call to URLDownloadToFile?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What does this program do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 20-2**'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this second lab is to demonstrate virtual functions. Analyze
    the malware in *Lab20-02.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This program is not dangerous to your computer, but it will try to upload
    possibly sensitive files from your machine.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What can you learn from the interesting strings in this program?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What do the imports tell you about this program?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the object created at 0x4011D9? Does it have any virtual
    functions?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Which functions could possibly be called by the call [edx] instruction at 0x401349?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: How could you easily set up the server that this malware expects in order to
    fully analyze the malware without connecting it to the Internet?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of this program?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of implementing a virtual function call in this program?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 20-3**'
  prefs: []
  type: TYPE_NORMAL
- en: This third lab is a longer and more realistic piece of malware. This lab comes
    with a configuration file named *config.dat* that must be in the same directory
    as the lab in order to execute properly. Analyze the malware in *Lab20-03.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '**439**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What can you learn from the interesting strings in this program?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What do the imports tell you about this program?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: At 0x4036F0, there is a function call that takes the string Config error, followed
    a few instructions later by a call to CxxThrowException. Does the function take
    any parameters other than the string? Does the function return anything? What
    can you tell about this function from the context in which it’s used?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What do the six entries in the switch table at 0x4025C8 do?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of this program?
  prefs: []
  type: TYPE_NORMAL
- en: '**440**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**6 4 - B I T M A L W A R E**'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all current malware is 32-bit, but some is writ-
  prefs: []
  type: TYPE_NORMAL
- en: ten for the 64-bit architecture in order to interact
  prefs: []
  type: TYPE_NORMAL
- en: with 64-bit OSs. As 64-bit OSs become more popular,
  prefs: []
  type: TYPE_NORMAL
- en: so will 64-bit malware.
  prefs: []
  type: TYPE_NORMAL
- en: Several 64-bit architectures have been introduced. The first to be supported
    by Windows, Itanium, was designed for performance computing and was not compatible
    with x86\. AMD later introduced a 64-bit architecture called AMD64, which was
    compatible with x86 code. Intel adopted AMD64
  prefs: []
  type: TYPE_NORMAL
- en: and called its implementation EM64T. This architecture is now known as x64,
    or x86-64, and it is the most popular implementation of 64-bit code on Windows.
    All current Windows versions are available in 64-bit versions, which support both
    64-bit and 32-bit applications.
  prefs: []
  type: TYPE_NORMAL
- en: The x64 architecture was designed as an upgrade to x86, and the instruction
    sets are not drastically different. Because most instructions are unchanged from
    x86 to x64, when you open a 64-bit executable in IDA Pro, you should be familiar
    with most of the instructions. One of the biggest complications
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: associated with 64-bit malware analysis is that not all tools support x64 assembly.
    For example, as of this writing, OllyDbg does not support 64-bit applications,
    although WinDbg does. IDA Pro supports x64 assembly, but it requires the IDA Pro
    Advanced version.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter addresses the differences between 32-bit and 64-bit systems, and
    provides a few hints to help analyze 64-bit code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why 64-Bit Malware?**'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that 32-bit malware can target both 32-bit and 64-bit machines, why
    would anyone bother to write 64-bit malware?
  prefs: []
  type: TYPE_NORMAL
- en: While you can run both 32-bit and 64-bit applications on the same system, you
    cannot run 32-bit code within 64-bit applications. When a processor is running
    32-bit code, it is running in 32-bit mode, and you cannot run 64-bit code. Therefore,
    anytime malware needs to run inside the process space of a 64-bit process, it
    must be 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of why malware might need to be compiled for the x64
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel code**'
  prefs: []
  type: TYPE_NORMAL
- en: All kernel code for an OS is within a single memory space, and all kernel code
    running in a 64-bit OS must be 64-bit. Because rootkits often run within the kernel,
    rootkits that target 64-bit OSs must be compiled into 64-bit machine code. Also,
    because antivirus and host-based security code often contain kernel elements,
    malware designed to interfere with these applications must be 64-bit, or at least
    have 64-bit components.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has made changes to the 64-bit versions of Windows that make it difficult
    to run malicious kernel code by detecting unauthorized modifications to the kernel
    and restricting the Windows ability to load drivers that aren’t digitally signed.
    (These changes are covered in detail at the end of Chapter 10.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Plug-ins and injected code**'
  prefs: []
  type: TYPE_NORMAL
- en: These must be 64-bit in order to run properly in a 64-bit process. For example,
    a malicious Internet Explorer plug-in or ActiveX control must be 64-bit if the
    computer is running the 64-bit version of Internet Explorer. Code injected using
    the techniques covered in Chapter 12 also runs within another process. If the
    target process is 64-bit, the injected code must also be 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shellcode**'
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode is usually run as part of an exploit within the process that it is
    exploiting. In order to exploit a vulnerability in the 64-bit version of Internet
    Explorer, for example, a malware author would need to write 64-bit shellcode.
    As more users run a mix of 64-bit and 32-bit applications, malware writers will
    need to write a separate version of shellcode for 32-bit and 64-bit victims.
  prefs: []
  type: TYPE_NORMAL
- en: '**442**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 21
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Differences in x64 Architecture**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most important differences between Windows 64-bit and
    32-bit architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: All addresses and pointers are 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: All general-purpose registers—including RAX, RBX, RCX, and so on—
  prefs: []
  type: TYPE_NORMAL
- en: have increased in size, although the 32-bit versions can still be accessed.
  prefs: []
  type: TYPE_NORMAL
