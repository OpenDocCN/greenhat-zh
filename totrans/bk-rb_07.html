<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Methods"><div class="titlepage"><div><div><h1 class="title"><a id="methods"/>Chapter 7. Methods</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id9"/><div class="mediaobject"><a id="I_mediaobject7_d1e7852"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>You’ve used numerous methods throughout this book. On the whole, they aren’t particularly complicated things, so you may wonder why this chapter, which is all about methods, is so long. As you will discover, there is much more to methods than meets the eye.<a id="IDX-CHP-7-0001" class="indexterm"/></p><div class="sect1" title="Class Methods"><div class="titlepage"><div><div><h1 class="title"><a id="class_methods"/>Class Methods</h1></div></div></div><p>The methods you’ve been using so far have been <span class="emphasis"><em>instance methods</em></span>. An instance method belongs to a specific instance of a class—in other words, to an individual object. It is also possible to write <span class="emphasis"><em>class methods</em></span>. (Some other languages refer to this kind of method as a static method.) A class method belongs to the class itself. To define a class method, you must precede the method name with the class name and a full stop.<a id="IDX-CHP-7-0002" class="indexterm"/><a id="IDX-CHP-7-0003" class="indexterm"/><a id="IDX-CHP-7-0004" class="indexterm"/></p><p><span class="emphasis"><em>class_methods1.rb</em></span><a id="IDX-CHP-7-0005" class="indexterm"/></p><a id="I_programlisting7_d1e7892"/><pre class="programlisting">class MyClass
   def MyClass.classMethod
      puts( "This is a class method" )
   end

   def instanceMethod
      puts( "This is an instance method" )
   en
end</pre><p>You should use the class name when calling a class method:</p><a id="I_programlisting7_d1e7896"/><pre class="programlisting">MyClass.classMethod</pre><p>A specific object cannot call a class method. Nor can a class call an instance method:</p><a id="I_programlisting7_d1e7900"/><pre class="programlisting">MyClass.instanceMethod        #=&gt; Error! This is an 'undefined method'
ob.classMethod                #=&gt; Error! This is an 'undefined method'</pre></div></div>
<div class="sect1" title="What Are Class Methods For?"><div class="titlepage"><div><div><h1 class="title"><a id="what_are_class_methods_for_question"/>What Are Class Methods For?</h1></div></div></div><p>But why, you may reasonably ask, would you ever want to create a class method rather than the more usual instance method? There are two main reasons: First, a class method can be used as a “ready-to-run function” without having to go to the bother of creating an object just to use it, and second, it can be used on those occasions when you need to run a method before an object has been created.</p><p>For a few examples of using methods as “ready-to-run functions,” consider Ruby’s File class. Many of its methods are class methods. This is because most of the time you will be using them to do something to, or return information about, an existing file. You don’t need to create a new File object to do that; instead, you pass the filename as an argument to the File class methods. You’ll look more closely at the File class in <a class="xref" href="ch13.html" title="Chapter 13. Files and IO">Chapter 13</a>. Here are examples of a few of its class methods in use:<a id="IDX-CHP-7-0006" class="indexterm"/></p><p><span class="emphasis"><em>file_methods.rb</em></span></p><a id="I_programlisting7_d1e7917"/><pre class="programlisting">fn = 'file_methods.rb'
if File.exist?(fn) then
   puts(File.expand_path(fn))
   puts(File.basename(fn))
   puts(File.dirname(fn))
   puts(File.extname(fn))
   puts(File.mtime(fn))
   puts("#{File.size(fn)} bytes")
else
   puts( "Can't find file!")
end</pre><p>This outputs something like this:<a id="IDX-CHP-7-0007" class="indexterm"/></p><a id="I_programlisting7_d1e7926"/><pre class="programlisting">C:/bookofruby2/ch7/file_methods.rb
file_methods.rb
.
.rb
2010-10-05 16:14:53 +0100
300 bytes</pre><p>The other occasion when a class method is vital is when you need to use a method before an object has been created. The most important example of this is the <code class="literal">new</code> method.</p><p>You call the <code class="literal">new</code> method every time you create an object. Until the object has been created, you clearly cannot call one of its instance methods—because you can call instance methods only from an object that already exists. When you use <code class="literal">new</code>, you are calling a method of the class itself and telling the class to create a new instance of itself.</p></div>
<div class="sect1" title="Class Variables"><div class="titlepage"><div><div><h1 class="title"><a id="class_variables-id1"/>Class Variables</h1></div></div></div><p>Class methods may remind you of the class variables you used previously (that is, variables whose names begin with <code class="literal">@@</code>). You may recall that you used class variables in a simple adventure game (see <span class="emphasis"><em>2adventure.rb</em></span> in <a class="xref" href="ch02s04.html" title="Attribute Readers and Writers">Attribute Readers and Writers</a>) to keep a tally of the total number of objects in the game; each time a new Thing object was created, 1 was added to the <code class="literal">@@num_things</code> class variable:<a id="IDX-CHP-7-0008" class="indexterm"/><a id="IDX-CHP-7-0009" class="indexterm"/></p><a id="I_programlisting7_d1e7965"/><pre class="programlisting">class Thing
   @@num_things = 0

   def initialize( aName, aDescription )
      @@num_things +=1
   end

end</pre><p>Unlike an instance variable (that is, a variable that belongs to a specific object created from a class), a class variable must be given a value when it is first declared:</p><a id="I_programlisting7_d1e7969"/><pre class="programlisting">@@classvar = 1000     # class variables must be initialized</pre><p>Initialization of either instance or class variables within the body of the class affects only the values stored by the class itself. Class variables are available both to the class itself and to the objects created from that class. However, each instance variable is unique; each object has its own copy of any instance variables—<span class="emphasis"><em>and the class itself may also have its own instance variables</em></span>.</p><div class="sidebar"><a id="class_variables_comma_instance_variables"/><p class="title">Class Variables, Instance Variables, and Methods: Summary</p><p>Instance variables begin with <code class="literal">@</code>:<a id="IDX-CHP-7-0010" class="indexterm"/><a id="IDX-CHP-7-0011" class="indexterm"/><a id="IDX-CHP-7-0012" class="indexterm"/><a id="IDX-CHP-7-0013" class="indexterm"/><a id="IDX-CHP-7-0014" class="indexterm"/></p><a id="I_programlisting7_d1e8001"/><pre class="programlisting">@myinstvar        # instance variable</pre><p>Class variables begin with <code class="literal">@@</code>:</p><a id="I_programlisting7_d1e8008"/><pre class="programlisting">@@myclassvar      # class variable</pre><p>Instance methods are defined by <code class="literal">def</code> <em class="replaceable"><code>MethodName</code></em>:</p><a id="I_programlisting7_d1e8018"/><pre class="programlisting">def anInstanceMethod
    # some code
end</pre><p>Class methods are defined by <code class="literal">def</code> <em class="replaceable"><code>ClassName</code></em>.<em class="replaceable"><code>MethodName</code></em>:</p><a id="I_programlisting7_d1e8031"/><pre class="programlisting">def MyClass.aClassMethod
    # some code
end</pre></div><p>To understand how a class may have instance variables, refer to the <span class="emphasis"><em>class_methods2.rb</em></span> program. This defines a class containing one class method and one instance method:</p><p><span class="emphasis"><em>class_methods2.rb</em></span></p><a id="I_programlisting7_d1e8041"/><pre class="programlisting">class MyClass
    @@classvar = 1000
    @instvar = 1000

    def MyClass.classMethod
        if @instvar == nil then
            @instvar = 10
        else
            @instvar += 10
        end

        if @@classvar == nil then
            @@classvar = 10
        else
            @@classvar += 10
        end
    end

    def instanceMethod
        if @instvar == nil then
            @instvar = 1
        else
            @instvar += 1
        end

        if @@classvar == nil then
            @@classvar = 1
        else
            @@classvar += 1
        end

    end

    def showVars
        return "(instance method) @instvar = #{@instvar}, @@classvar = #{@@classvar}"
    end

    def MyClass.showVars
        return "(class method) @instvar = #{@instvar}, @@classvar = #{@@classvar}"
    end

end</pre><p>Notice that it declares and initializes a class variable and an instance variable, <code class="literal">@@classvar</code> and <code class="literal">@instvar</code>, respectively. Its class method, <code class="literal">classMethod</code>, increments both these variables by 10, while its instance method, <code class="literal">instanceMethod</code>, increments both variables by 1. Notice that I have assigned values to both the class variable and the instance variable:</p><a id="I_programlisting7_d1e8058"/><pre class="programlisting">@@classvar = 1000
@instvar = 1000</pre><p>I said earlier that initial values are not normally assigned to instance variables in this way. The exception to the rule is when you assign a value to an instance variable <span class="emphasis"><em>of the class itself</em></span> rather than to an object derived from that class. The distinction should become clearer shortly.</p><p>I’ve written a few lines of code that create three instances of MyClass (the <code class="literal">ob</code> variable is initialized with a new instance on each turn through the loop) and then call both the class and instance methods:</p><a id="I_programlisting7_d1e8070"/><pre class="programlisting">for i in 0..2 do
   ob = MyClass.new
   MyClass.classMethod
   ob.instanceMethod
   puts( MyClass.showVars )
   puts( ob.showVars )
end</pre><p>The class method, <code class="literal">MyClass.showVars</code>, and the instance method, <code class="literal">showVars</code>, display the values of <code class="literal">@instvar</code> and <code class="literal">@@classvar</code> at each turn through the loop. When you run the code, these are the values displayed:</p><a id="I_programlisting7_d1e8086"/><pre class="programlisting">(class method) @instvar = 1010, @@classvar = 1011
(instance method) @instvar = 1, @@classvar = 1011
(class method) @instvar = 1020, @@classvar = 1022
(instance method) @instvar = 1, @@classvar = 1022
(class method) @instvar = 1030, @@classvar = 1033
(instance method) @instvar = 1, @@classvar = 1033</pre><p>You may need to look at these results carefully in order to see what is going on here. In summary, this is what is happening: The code in both the class method, <code class="literal">MyClass.classMethod</code>, and the instance method, <code class="literal">instanceMethod</code>, increments both the class and instance variables, <code class="literal">@@classvar</code> and <code class="literal">@instvar</code>.<a id="IDX-CHP-7-0015" class="indexterm"/><a id="IDX-CHP-7-0016" class="indexterm"/><a id="IDX-CHP-7-0017" class="indexterm"/></p><p>You can see clearly that the class variable is incremented by both these methods (the class method adds 10 to <code class="literal">@@classvar</code> whenever a new object is created, while the instance method adds 1 to it). However, whenever a new object is created, its instance variable is initialized to 1 by the <code class="literal">instanceMethod</code>. This is the expected behavior since each object has its own copy of an instance variable, but all objects share a unique class variable. Perhaps less obvious is that the class itself also has its own instance variable, <code class="literal">@instvar</code>. This is because, in Ruby, a class is an object and therefore can contain instance variables, just like any other object. The MyClass variable, <code class="literal">@instvar</code>, is incremented by the class method <code class="literal">MyClass.classMethod</code>:</p><a id="I_programlisting7_d1e8139"/><pre class="programlisting">@instvar += 10</pre><p>When the instance method, <code class="literal">showVars</code>, prints the value of <code class="literal">@instvar</code>, it prints the value stored in a specific object, <code class="literal">ob</code>; the value of <code class="literal">ob</code>’s <code class="literal">@instvar</code> is initially <code class="literal">nil</code> (<span class="emphasis"><em>not</em></span> the value 1,000 with which the MyClass variable <code class="literal">@instvar</code> was initialized), and this value is incremented by 1 in <code class="literal">instanceMethod</code>.</p><p>When the class method, <code class="literal">MyClass.showVars</code>, prints the value of <code class="literal">@instvar</code>, it prints the value stored in the class itself (in other words, MyClass’s <code class="literal">@instvar</code> <span class="emphasis"><em>is a different variable</em></span> from <code class="literal">ob</code>’s <code class="literal">@instvar</code>). But when either method prints the value of the class variable, <code class="literal">@@classvar</code>, the value is the same.</p><p>Just remember that there is only ever one copy of a class variable, but there may be many copies of instance variables. If this is still confusing, take a look at the <span class="emphasis"><em>inst_vars.rb</em></span> program:</p><p><span class="emphasis"><em>inst_vars.rb</em></span></p><a id="I_programlisting7_d1e8204"/><pre class="programlisting">class MyClass
   @@classvar = 1000
   @instvar = 1000

   def MyClass.classMethod
      if @instvar == nil then
         @instvar = 10
      else
         @instvar += 10
      end
   end

   def instanceMethod
      if @instvar == nil then
         @instvar = 1
      else
         @instvar += 1
      end
   end
end

ob = MyClass.new
puts MyClass.instance_variable_get(:@instvar)
puts( '--------------' )
for i in 0..2 do
   # MyClass.classMethod
   ob.instanceMethod
   puts( "MyClass @instvar=#{MyClass.instance_variable_get(:@instvar)}")
   puts( "ob @instvar= #{ob.instance_variable_get(:@instvar)}" )
end</pre><p>This time, instead of creating a new object instance at each turn through the loop, you create a single instance (<code class="literal">ob</code>) at the outset. When the <code class="literal">ob.instanceMethod</code> is called, <code class="literal">@instvar</code> is incremented by 1.</p><p>Here I’ve used a little trick to look inside the class and method and retrieve the value of <code class="literal">@instvar</code> using Ruby’s <code class="literal">instance_variable_get</code> method (I’ll return to this when I cover dynamic programming in <a class="xref" href="ch20.html" title="Chapter 20. Dynamic Programming">Chapter 20</a>):<a id="IDX-CHP-7-0018" class="indexterm"/></p><a id="I_programlisting7_d1e8230"/><pre class="programlisting">puts( "MyClass @instvar= #{MyClass.instance_variable_get(:@instvar)}" )
puts( "ob @instvar= #{ob.instance_variable_get(:@instvar)}" )</pre><p>Because you only ever increment the <code class="literal">@instvar</code> that belongs to the object <code class="literal">ob</code>, the value of its <code class="literal">@instvar</code> goes up from 1 to 3 as the <code class="literal">for</code> loop executes. But the <code class="literal">@instvar</code> that belongs to the MyClass class is never incremented; it remains at its initial value of 1,000:</p><a id="I_programlisting7_d1e8249"/><pre class="programlisting">1000
--------------
MyClass @instvar= 1000
ob @instvar= 1
MyClass @instvar= 1000
ob @instvar= 2
MyClass @instvar= 1000
ob @instvar= 3</pre><p>But now let’s uncomment this line:</p><a id="I_programlisting7_d1e8253"/><pre class="programlisting">MyClass.classMethod</pre><p>This calls a class method that increments <code class="literal">@instvar</code> by 10. This time when you run the program, you see that, as before, the <code class="literal">@instvar</code> variable of <code class="literal">ob</code> is incremented by 1 on each turn through the loop, while the <code class="literal">@instvar</code> variable of MyClass is incremented by 10:</p><a id="I_programlisting7_d1e8270"/><pre class="programlisting">1000
--------------
MyClass @instvar= 1010
ob @instvar= 1
MyClass @instvar= 1020
ob @instvar= 2
MyClass @instvar= 1030
ob @instvar= 3</pre><div class="sidebar"><a id="a_class_is_an_object"/><p class="title">A Class Is an Object</p><p>To understand instance variables of classes, just remember that a class is an object (actually, it’s an instance of the <code class="literal">Class</code> class!). The MyClass “class object” has its own instance variable (<code class="literal">@instvar</code>) just as the <code class="literal">ob</code> object has its own instance variable (which here also happens to be called <code class="literal">@instvar</code>). In spite of the same names, these are two different variables: One belongs to the class itself; the other belongs inside each object created from the class. Instance variables are always unique to an object instance, so no two objects (not even an object like MyClass, which also happens to be a class!) can ever share a single instance variable.<a id="IDX-CHP-7-0019" class="indexterm"/><a id="IDX-CHP-7-0020" class="indexterm"/><a id="IDX-CHP-7-0021" class="indexterm"/><a id="IDX-CHP-7-0022" class="indexterm"/></p></div></div>
<div class="sect1" title="Ruby Constructors: new or initialize?"><div class="titlepage"><div><div><h1 class="title"><a id="ruby_constructors_colon_new_or_initializ"/>Ruby Constructors: new or initialize?</h1></div></div></div><p>I gave a brief explanation of <code class="literal">new</code> and <code class="literal">initialize</code> in <a class="xref" href="ch01.html" title="Chapter 1. Strings, Numbers, Classes, and Objects">Chapter 1</a>. At that stage, you had not examined the differences between Ruby’s class and instance methods and variables, so it was not possible to give a full discussion of how <code class="literal">new</code> and <code class="literal">initialize</code> work together. Because these are such important methods, you’ll look at them in more detail now.<a id="IDX-CHP-7-0023" class="indexterm"/><a id="IDX-CHP-7-0024" class="indexterm"/></p><p>The method responsible for bringing an object into being is called the <span class="emphasis"><em>constructor</em></span>. In Ruby, the constructor method is called <code class="literal">new</code>. The <code class="literal">new</code> method is a class method that, once it has created an object, will run an instance method named <code class="literal">initialize</code> if such a method exists.</p><p>In brief then, the <code class="literal">new</code> method is the constructor, and the <code class="literal">initialize</code> method is used to initialize the values of any variables immediately after an object is created. But why can’t you just write your own <code class="literal">new</code> method and initialize variables in it? Well, let’s try that:</p><p><span class="emphasis"><em>new.rb</em></span></p><a id="I_programlisting7_d1e8364"/><pre class="programlisting">class MyClass
   def initialize( aStr )
      @avar = aStr
   end

   def MyClass.new( aStr )
      super
      @anewvar = aStr.swapcase
   end
end

ob = MyClass.new( "hello world" )
puts( ob )
puts( ob.class )</pre><p>Here, I’ve written a <code class="literal">MyClass.new</code> method that begins with the <code class="literal">super</code> keyword to invoke the <code class="literal">new</code> method of its superclass. Then I’ve created a string instance variable, <code class="literal">@anewvar</code>. So what do I end up with? Not, as you might suppose, a new MyClass object containing a string variable. Remember that the last expression evaluated by a method in Ruby is the value returned by that method. The last expression evaluated by the <code class="literal">new</code> method here is a string. I evaluate this:<a id="IDX-CHP-7-0025" class="indexterm"/><a id="IDX-CHP-7-0026" class="indexterm"/><a id="IDX-CHP-7-0027" class="indexterm"/><a id="IDX-CHP-7-0028" class="indexterm"/></p><a id="I_programlisting7_d1e8406"/><pre class="programlisting">ob = MyClass.new( "hello world" )</pre><p>And I display the newly created <code class="literal">ob</code> object and its class:</p><a id="I_programlisting7_d1e8413"/><pre class="programlisting">puts( ob )
puts( ob.class )</pre><p>This is the output:</p><a id="I_programlisting7_d1e8418"/><pre class="programlisting">HELLO WORLD
String</pre><p>This proves that <code class="literal">MyClass.new</code> returns a string, and it is this string (<span class="emphasis"><em>not</em></span> a MyClass object) that is assigned to the variable <code class="literal">ob</code>. If you find this confusing, don’t panic. The moral of the story is that overriding <code class="literal">new</code> <span class="emphasis"><em>is</em></span> confusing and is generally a bad idea. Unless you have a very good reason for doing so, you should avoid trying to override the <code class="literal">new</code> method.</p></div>
<div class="sect1" title="Singleton Methods"><div class="titlepage"><div><div><h1 class="title"><a id="singleton_methods"/>Singleton Methods</h1></div></div></div><p>A singleton method is a method that belongs to a single object rather than to an entire class. Many of the methods in the Ruby class library are singleton methods. This is because, as mentioned earlier, each class is an object of the type Class. Or, to put it simply, the class of every class is Class. This is true of all classes—both those you define yourself and those provided by the Ruby class library:</p><p><span class="emphasis"><em>class_classes.rb</em></span></p><a id="I_programlisting7_d1e8449"/><pre class="programlisting">class MyClass
end

puts( MyClass.class )    #=&gt; Class
puts( String.class )     #=&gt; Class
puts( Object.class )     #=&gt; Class
puts( Class.class )      #=&gt; Class
puts( IO.class )         #=&gt; Class</pre><p>Now, some classes also have class methods—that is, methods that belong to the Class object itself. In that sense, these are singleton methods of the Class object. Indeed, if you evaluate the following, you will be shown an array of method names that match the names of IO class methods:</p><a id="I_programlisting7_d1e8453"/><pre class="programlisting">p( IO.singleton_methods )</pre><p>This displays the following:</p><a id="I_programlisting7_d1e8457"/><pre class="programlisting">[:new, :open, :sysopen, :for_fd, :popen, :foreach, :readlines,
 :read, :binread, :select, :pipe, :try_convert, :copy_stream]</pre><p>As explained earlier, when you write your own class methods, you do so by prefacing the method name with the name of the class:<a id="IDX-CHP-7-0029" class="indexterm"/><a id="IDX-CHP-7-0030" class="indexterm"/></p><a id="I_programlisting7_d1e8469"/><pre class="programlisting">def MyClass.classMethod</pre><p>It turns out that you can use a similar syntax when creating singleton classes for specific objects. This time you preface the method name with the name of the object:</p><a id="I_programlisting7_d1e8474"/><pre class="programlisting">def myObject.objectMethod</pre><div class="sidebar"><a id="finding_an_objectas_ancestor_classes"/><p class="title">Finding an Object’s Ancestor Classes</p><p>Ultimately all classes descend from the Object class. In Ruby 1.9, the Object class itself descends from the BasicObject class (see <a class="xref" href="ch02.html" title="Chapter 2. Class Hierarchies, Attributes, and Class Variables">Chapter 2</a>). This is true even for the <code class="literal">Class</code> class! To prove this, try the <span class="emphasis"><em>class_hierarchy.rb</em></span> program:<a id="IDX-CHP-7-0031" class="indexterm"/><a id="IDX-CHP-7-0032" class="indexterm"/><a id="IDX-CHP-7-0033" class="indexterm"/></p><a id="I_programlisting7_d1e8500"/><pre class="programlisting">def showFamily( aClass )
    if (aClass != nil) then
        puts( "#{aClass} :: about to recurse with aClass.superclass =
 #{aClass.superclass.inspect}" )
        showFamily( aClass.superclass )
    end
end</pre><p>Pass a class name to this method to track back up its family tree of ancestor classes. For example, try this:</p><a id="I_programlisting7_d1e8504"/><pre class="programlisting">showFamily(File)</pre><p>In Ruby 1.9, this displays the following:</p><a id="I_programlisting7_d1e8508"/><pre class="programlisting">File :: about to recurse with aClass.superclass = IO
IO :: about to recurse with aClass.superclass = Object
Object :: about to recurse with aClass.superclass = BasicObject
BasicObject :: about to recurse with aClass.superclass = nil</pre></div><p><span class="emphasis"><em>class_hierarchy.rb</em></span></p><p>Let’s look at a concrete example. Suppose you have a program containing Creature objects of many different species (maybe you are a veterinarian, the head keeper at a zoo, or, like the author of this book, an enthusiastic player of adventure games); each creature has a method called <code class="literal">talk</code> that displays the vocal noise each creature usually makes.</p><p>Here’s my Creature class and a few creature objects:</p><p><span class="emphasis"><em>singleton_meth1.rb</em></span></p><a id="I_programlisting7_d1e8523"/><pre class="programlisting">class Creature
   def initialize( aSpeech )
      @speech = aSpeech
   end


   def talk
      puts( @speech )
   end
end

cat = Creature.new( "miaow" )
dog = Creature.new( "woof" )
budgie = Creature.new( "Who's a pretty boy, then!" )
werewolf = Creature.new( "growl" )</pre><p>Then you suddenly realize that one of those creatures, and one alone, has additional special behavior. On the night of a full moon, the werewolf not only talks (“growl”) but also howls (“How-oo-oo-oo-oo!”). It really needs a <code class="literal">howl</code> method.</p><p>You could go back and add such a method to the Creature class, but then you’d end up with howling dogs, cats, and budgies too—which is not what you want. You could create a new Werewolf class that descends from Creature, but you will only ever have one werewolf (they are, alas, an endangered species), so why do you want a whole class for just that? Wouldn’t it make more sense to have a werewolf <span class="emphasis"><em>object</em></span> that is the same as every other creature object except that it also has a <code class="literal">howl</code> method? Okay, let’s do that by giving the werewolf its very own singleton method. Here goes:</p><a id="I_programlisting7_d1e8538"/><pre class="programlisting">def werewolf.howl
   puts( "How-oo-oo-oo-oo!" )
end</pre><p>Heck, you can do better than that! It howls only on a full moon, so let’s make sure that, if asked to howl when the moon is new, it just growls. Here’s my finished method:</p><a id="I_programlisting7_d1e8543"/><pre class="programlisting">def werewolf.howl
    if FULLMOON then
      puts( "How-oo-oo-oo-oo!" )
   else
      talk
   end
end</pre><p>Notice that, even though this method has been declared outside the Creature class, it is able to call the instance method <code class="literal">talk</code>. That’s because the <code class="literal">howl</code> method now lives “inside” the werewolf object so has the same scope within that object as the <code class="literal">talk</code> method. It does not, however, live inside any of the werewolf’s fellow creatures; the <code class="literal">howl</code> method belongs to him and him alone. Try to make the <code class="literal">budgie.howl</code>, and Ruby will inform you that <code class="literal">howl</code> is an undefined method.</p><p>Now, if you are debugging your code for your own use, having your program blow up thanks to an undefined method may be acceptable; however, if your program does so out in the big, bad world of the “end user,” it is definitely <span class="emphasis"><em>not</em></span> acceptable.<a id="IDX-CHP-7-0034" class="indexterm"/></p><p>If you think undefined methods are likely to be a problem, you can take avoidance measures by testing whether a singleton method exists before trying to use it. The Object class has a <code class="literal">singleton_methods</code> method that returns an array of singleton method names. You can test a method name for inclusion using the Array class’s <code class="literal">include?</code> method. In <span class="emphasis"><em>singleton_meth2.rb</em></span>, for example, I’ve programmed an “open the box” game, which has a number of Box objects, only one of which, when opened, contains the star prize. I’ve named this special Box object <code class="literal">starprize</code> and given it a singleton method called <code class="literal">congratulate</code>:<a id="IDX-CHP-7-0035" class="indexterm"/><a id="IDX-CHP-7-0036" class="indexterm"/></p><p><span class="emphasis"><em>singleton_meth2.rb</em></span></p><a id="I_programlisting7_d1e8603"/><pre class="programlisting">starprize = Box.new( "Star Prize" )
def starprize.congratulate
    puts( "You've won a fabulous holiday in Grimsby!" )
end</pre><p>The <code class="literal">congratulate</code> method should be called when the <code class="literal">starprize</code> box is opened. This bit of code (in which <code class="literal">item</code> is a Box object) ensures that this method (which does not exist in any other object) is not called when some other box is opened:</p><a id="I_programlisting7_d1e8616"/><pre class="programlisting">if item.singleton_methods.include?("congratulate") then
    item.congratulate
end</pre><p>An alternative way of checking the validity of a method would be to pass that method name as a symbol (an identifier preceded by a colon) to the Object class’s <code class="literal">respond_to?</code> method:<a id="IDX-CHP-7-0037" class="indexterm"/></p><a id="I_programlisting7_d1e8626"/><pre class="programlisting">if item.respond_to?( :congratulate ) then
   item.congratulate
end</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>You’ll see another way of handling nonexistent methods in <a class="xref" href="ch20.html" title="Chapter 20. Dynamic Programming">Chapter 20</a>.</p></div></div>
<div class="sect1" title="Singleton Classes"><div class="titlepage"><div><div><h1 class="title"><a id="singleton_classes"/>Singleton Classes</h1></div></div></div><p>A singleton method is a method that belongs to a single object. A singleton class, on the other hand, is a class that defines a single object. Confused? Me too. Let’s take a closer look.</p><p>Let’s suppose you create a few dozen objects, each of which is an instance of the Object class. Naturally they all have access to inherited methods such as <code class="literal">inspect</code> and <code class="literal">class</code>. But now you decide that you want just one special object (for the sake of variety, let’s call him <code class="literal">ob</code>), which has one special method (let’s call it <code class="literal">blather</code>).</p><p>You don’t want to define a whole new class for this one object since you will never again create any more objects with the <code class="literal">blather</code> method. So, you create a class especially for little <code class="literal">ob</code>.<a id="IDX-CHP-7-0038" class="indexterm"/></p><p>You don’t need to name this class. You just tell it to attach itself to <code class="literal">ob</code> by putting a <code class="literal">&lt;&lt;</code> between the keyword <code class="literal">class</code> and the name of the object. Then you add code to the class in the usual way:</p><p><span class="emphasis"><em>singleton_class.rb</em></span></p><a id="I_programlisting7_d1e8679"/><pre class="programlisting">ob = Object.new
    # singleton class
class &lt;&lt; ob
    def blather( aStr )
        puts("blather, blather #{aStr}")
    end
end</pre><p>Now <code class="literal">ob</code>, and only <code class="literal">ob</code>, has not only all the usual methods of the Object class; it also has the methods (here just the <code class="literal">blather</code> method, but there could, in principle, be many more) of its own special anonymous class:</p><a id="I_programlisting7_d1e8692"/><pre class="programlisting">ob.blather( "weeble" )    #=&gt; "blather, blather weeble"</pre><p>If you’ve been paying close attention, you might have noticed that the singleton class seems to be doing something rather similar to a singleton method. With a singleton class, I can create an object and then add extra methods packaged up inside an anonymous class. With singleton methods, I can create an object and then add methods one by one:</p><p><span class="emphasis"><em>singleton_class2.rb</em></span></p><a id="I_programlisting7_d1e8700"/><pre class="programlisting">ob2 = Object.new

def ob2.blather( aStr )        # &lt;= this is a singleton method
   puts( "grippity, grippity #{aStr}" )
end

ob2.blather( "ping!" )         #=&gt; grippity, grippity ping!</pre><p>Similarly, I could rewrite the “star prize” program. In the previous version I added a singleton method, <code class="literal">congratulate</code>, to an object named <code class="literal">starprize</code>. I could just as easily have created a singleton class containing the <code class="literal">congratulate</code> method:</p><a id="I_programlisting7_d1e8713"/><pre class="programlisting">starprize = MyClass.new( "Star Prize" )

class &lt;&lt; starprize
   def congratulate
      puts( "You've won a fabulous holiday in Grimsby!" )
   end
end</pre><p>In fact, the similarity is more than skin deep. The end result of the previous code is that <code class="literal">congratulate</code> becomes a singleton method of <code class="literal">starprize</code>. I can verify this by checking whether the array of singleton methods available for the <code class="literal">item</code> object contains the name <code class="literal">congratulate</code>:<a id="IDX-CHP-7-0039" class="indexterm"/><a id="IDX-CHP-7-0040" class="indexterm"/></p><a id="I_programlisting7_d1e8737"/><pre class="programlisting">if item.singleton_methods.include?(:congratulate)    # Ruby 1.9</pre><p>In Ruby 1.9, the <code class="literal">singleton_methods</code> method returns an array of symbols representing the method names. This is why I have used the symbol <code class="literal">:congratulate</code> in the previous code. However, in Ruby 1.8, <code class="literal">singleton_methods</code> returns an array of strings. So, if you are using Ruby 1.8, you should be sure to use the following test using the string argument <code class="literal">"congratulate"</code>:<a id="IDX-CHP-7-0041" class="indexterm"/><a id="IDX-CHP-7-0042" class="indexterm"/></p><a id="I_programlisting7_d1e8761"/><pre class="programlisting">if item.singleton_methods.include?("congratulate")    # Ruby 1.8</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>What’s the difference between a singleton method and a singleton class? The short answer is, not a lot. These two syntaxes provide different ways of adding methods to a specific object rather than building those methods into its defining class.</p></div></div>
<div class="sect1" title="Overriding Methods"><div class="titlepage"><div><div><h1 class="title"><a id="overriding_methods"/>Overriding Methods</h1></div></div></div><p>Sometimes you may want to redefine a method that already exists in some class. You’ve done this before when, for example, you created classes with their own <code class="literal">to_s</code> methods to return a string representation. Every Ruby class, from Object downward, has a <code class="literal">to_s</code> method. The <code class="literal">to_s</code> method of the Object class returns the class name and a hexadecimal representation of the object’s unique identifier. However, many Ruby classes have their own special versions of <code class="literal">to_s</code>. For example, <code class="literal">Array.to_s</code> concatenates and returns the values in the array.</p><p>When a method in one class replaces a method of the same name in an ancestor class, it is said to <span class="emphasis"><em>override</em></span> that method. You can override methods that are defined in the standard class library such as <code class="literal">to_s</code> as well as methods defined in your own classes. If you need to add new behavior to an existing method, remember to call the superclass’s method using the <code class="literal">super</code> keyword at the start of the overridden method.</p><p>Here is an example:</p><p><span class="emphasis"><em>override.rb</em></span></p><a id="I_programlisting7_d1e8802"/><pre class="programlisting">class MyClass
   def sayHello
      return "Hello from MyClass"
   end

   def sayGoodbye
      return "Goodbye from MyClass"
   end
end

class MyOtherClass &lt; MyClass
    def sayHello            #overrides (and replaces) MyClass.sayHello
        return "Hello from MyOtherClass"
    end

        # overrides MyClass.sayGoodbye   but first calls that method
        # with super. So this version "adds to" MyClass.sayGoodbye
    def sayGoodbye
        return super &lt;&lt; " and also from MyOtherClass"
    end

        # overrides default to_s method
    def to_s
        return "I am an instance of the #{self.class} class"
    end
end</pre></div>
<div class="sect1" title="Public, Protected, and Private Methods"><div class="titlepage"><div><div><h1 class="title"><a id="public_comma_protected_comma_and_private"/>Public, Protected, and Private Methods</h1></div></div></div><p>In some cases, you may want to restrict the “visibility” of your methods to ensure that they cannot be called by code outside the class in which the methods occur.<a id="IDX-CHP-7-0043" class="indexterm"/></p><p>This may be useful when your class defines various “utility” methods that it requires in order to perform certain functions that it does not intend for public consumption. By imposing access restrictions on those methods, you can prevent programmers from using them for their own nefarious purposes. This means you will be able to change the implementation of those methods at a later stage without having to worry you are going to break somebody else’s code.<a id="IDX-CHP-7-0044" class="indexterm"/></p><p>Ruby provides three levels of method accessibility:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>public</p></li><li class="listitem"><p>protected<a id="IDX-CHP-7-0045" class="indexterm"/></p></li><li class="listitem"><p>private<a id="IDX-CHP-7-0046" class="indexterm"/></p></li></ul></div><p>As the name suggests, public methods are the most accessible, and private methods are the least accessible. All your methods are public unless you specify otherwise. When a method is public, it is available to be used by the world outside the object in whose class it is defined.<a id="IDX-CHP-7-0047" class="indexterm"/><a id="IDX-CHP-7-0048" class="indexterm"/></p><p>When a method is private, it can be used only by other methods inside the object in whose class it is defined.</p><p>A protected method generally works in the same way as a private method with one tiny but important difference: In addition to being visible to the methods of the current object, a protected method is also visible to objects of the same type when the second object is within the scope of the first object.</p><p>The distinction between private and protected methods will probably be easier to understand when you see a working example. Consider this class:</p><p><span class="emphasis"><em>pub_prot_priv.rb</em></span></p><a id="I_programlisting7_d1e8858"/><pre class="programlisting">class MyClass

    private
        def priv
             puts( "private" )
        end

    protected
        def prot
             puts( "protected" )
        end

   public
        def pub
             puts( "public" )
        end

        def useOb( anOb )
             anOb.pub
             anOb.prot
             anOb.priv
        end
end</pre><p>I’ve declared three methods, one for each level of accessibility. These levels are set by putting <code class="literal">private</code>, <code class="literal">protected</code>, or <code class="literal">public</code> prior to one or more methods. The specified accessibility level remains in force for all subsequent methods until some other access level is specified.</p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">public</code>, <code class="literal">private</code>, and <code class="literal">protected</code> may look like keywords. But they are, in fact, methods of the Module class.</p></div><p>Finally, my class has a public method, <code class="literal">useOb</code>, which takes a <code class="literal">MyOb</code> object as an argument and calls the three methods <code class="literal">pub</code>, <code class="literal">prot</code>, and <code class="literal">priv</code> of that object. Now, let’s see how a <code class="literal">MyClass</code> object can be used. First, I’ll create two instances of the class:</p><a id="I_programlisting7_d1e8904"/><pre class="programlisting">myob = MyClass.new
myob2 = MyClass.new</pre><p>Now, I try to call each of the three methods in turn:</p><a id="I_programlisting7_d1e8908"/><pre class="programlisting">myob.pub         # This works! Prints out "public"
myob.prot        # This doesn't work! I get an error
myob.priv        # This doesn't work either - another error</pre><p>From the previous, it would seem that the public method is (as expected) visible from the world outside the object to which it applies. But both the private and the protected methods are invisible. This being so, what is the protected method for? Another example should help clarify this:</p><a id="I_programlisting7_d1e8912"/><pre class="programlisting">myob.useOb( myob2 )</pre><p>This time, I am calling the public method <code class="literal">useOb</code> of the <code class="literal">myob</code> object, and I am passing to it a second object, <code class="literal">myob2</code>, as an argument. The important thing to note is that <code class="literal">myob</code> and <code class="literal">myob2</code> are instances of the same class. Now, recall what I said earlier: <span class="emphasis"><em>In addition to being visible to the methods of the current object, a protected method is also visible to objects of the same type when the second object is within the scope of the first object</em></span>.</p><p>This may sound like gobbledygook. Let’s see if I can make some sense out of it. In the program, the first MyClass object (here <code class="literal">myob</code>) has a second MyClass object within its scope when <code class="literal">myob2</code> is passed as an argument to a method of <code class="literal">myob</code>. When this happens, you can think of <code class="literal">myob2</code> as being present “inside” <code class="literal">myob</code>. Now <code class="literal">myob2</code> shares the scope of the “containing” object, <code class="literal">myob</code>. In this special circumstance—when two objects of the same class are within the scope defined by that class—the protected methods of any objects of this class become visible.</p><p>In the present case, the protected method <code class="literal">prot</code> of the object <code class="literal">myob2</code> (or, at any rate, of the argument that “receives” <code class="literal">myob2</code>, here called <code class="literal">anob</code>) becomes visible and can be executed. Its private arguments, however, are not visible:</p><a id="I_programlisting7_d1e8974"/><pre class="programlisting">def useOb( anOb )
   anOb.pub
   anOb.prot    # protected method can be called
   anOb.priv    # calling a private method results in an error
end</pre><div class="sidebar"><a id="digging_deeper-id6"/><p class="title">Digging Deeper</p><p>Here you will learn more about the visibility of code inside methods and another way of defining singleton methods.<a id="IDX-CHP-7-0049" class="indexterm"/></p><p><span class="bolditalic">Protected and Private Methods in Descendant Classes</span></p><p>The same access rules described in this chapter also apply when calling the methods of ancestor and descendant objects. That is, when you pass an object to a method (as an argument) that has the same class as the receiver object (in other words, the object to which the method belongs), the argument object can call the public and protected methods of the class but not its private methods.<a id="IDX-CHP-7-0050" class="indexterm"/><a id="IDX-CHP-7-0051" class="indexterm"/></p><p>For an example of this, take a look at the <span class="emphasis"><em>protected.rb</em></span> program. Here I have created a MyClass object called <code class="literal">myob</code> and a MyOtherClass object, <code class="literal">myotherob</code>, where MyOtherClass descends from MyClass:</p><p><span class="emphasis"><em>protected.rb</em></span></p><a id="I_programlisting7_d1e9013"/><pre class="programlisting">class MyClass

    private
        def priv( aStr )
            return aStr.upcase
        end

    protected
        def prot( aStr )
            return aStr &lt;&lt; '!!!!!!'
        end

    public

        def exclaim( anOb )  # calls a protected method
            puts( anOb.prot( "This is a #{anOb.class} - hurrah" ) )
        end

        def shout( anOb )    # calls a private method
            puts( anOb.priv( "This is a #{anOb.class} - hurrah" ) )
        end

end

class MyOtherClass &lt; MyClass

end

class MyUnrelatedClass

end</pre><p>I now create objects from each of these three classes, and I try to pass <code class="literal">myotherob</code> as an argument to the <code class="literal">myob</code> public method, <code class="literal">shout</code>:<a id="IDX-CHP-7-0052" class="indexterm"/><a id="IDX-CHP-7-0053" class="indexterm"/><a id="IDX-CHP-7-0054" class="indexterm"/><a id="IDX-CHP-7-0055" class="indexterm"/></p><a id="I_programlisting7_d1e9046"/><pre class="programlisting">myob = MyClass.new
myotherob = MyOtherClass.new
myunrelatedob = MyUnrelatedClass.new</pre><p>If you load this program from the code archive, you will see that it contains a number of lines of code in which these three objects attempt to execute the <code class="literal">shout</code> and <code class="literal">exclaim</code> methods. Many of these attempts are doomed to failure and so have been commented out. However, when testing the code, you may want to uncomment each method call one by one to see the results. This is my first attempt:</p><a id="I_programlisting7_d1e9056"/><pre class="programlisting">myob.shout( myotherob )     # fails</pre><p>Here the <code class="literal">shout</code> method calls the private method <code class="literal">priv</code> on the argument object:</p><a id="I_programlisting7_d1e9067"/><pre class="programlisting">def shout( anOb )    # calls a private method
   puts( anOb.priv( "This is a #{anOb.class} - hurrah" ) )
end</pre><p>This won’t work! Ruby complains that the <code class="literal">priv</code> method is private.</p><p>Similarly, were I to do it the other way around—that is, by passing the ancestor object <code class="literal">myob</code> as the argument and invoking the method <code class="literal">shout</code> on the descendant object—I would encounter the same error:</p><a id="I_programlisting7_d1e9082"/><pre class="programlisting">myotherob.shout( myob )     # fails</pre><p>The MyClass class also has another public method, <code class="literal">exclaim</code>. This one calls a protected method, <code class="literal">prot</code>:</p><a id="I_programlisting7_d1e9092"/><pre class="programlisting">def exclaim( anOb )  # calls a protected method
   puts( anOb.prot( "This is a #{anOb.class} - hurrah" ) )
end</pre><p>Now, I can pass either the MyClass object, <code class="literal">myob</code>, or the MyOtherClass object, <code class="literal">myotherob</code>, as an argument to the <code class="literal">exclaim</code> method, and no error will occur when the protected method is called:</p><a id="I_programlisting7_d1e9105"/><pre class="programlisting">myob.exclaim( myotherob )        # This is OK
myotherob.exclaim( myob )        # And so is this...
myob.exclaim( myunrelatedob )    # But this won't work</pre><p>Needless to say, this works only when the two objects (the receiver object to the left of the dot and the argument passed to the method) share the same line of descent. If you send an unrelated object as an argument, you would not be able to call methods of the receiver class, no matter what their protection levels.<a id="IDX-CHP-7-0056" class="indexterm"/><a id="IDX-CHP-7-0057" class="indexterm"/><a id="IDX-CHP-7-0058" class="indexterm"/><a id="IDX-CHP-7-0059" class="indexterm"/><a id="IDX-CHP-7-0060" class="indexterm"/><a id="IDX-CHP-7-0061" class="indexterm"/></p><p><span class="bolditalic">Invading the Privacy of Private Methods</span></p><p>The whole point of a private method is that it cannot be called from outside the scope of the object to which it belongs. So, this won’t work:</p><p><span class="emphasis"><em>send.rb</em></span></p><a id="I_programlisting7_d1e9150"/><pre class="programlisting">class X
    private
        def priv( aStr )
             puts("I'm private, " &lt;&lt; aStr)
        end
end

ob = X.new
ob.priv( "hello" )      # This fails</pre><p>However, it turns out that Ruby provides a “get out clause” (or maybe I should say a “get in” clause?) in the form of a method called <code class="literal">send</code>.</p><p>The <code class="literal">send</code> method invokes the method whose name matches that of a symbol (an identifier beginning with a colon such as <code class="literal">:priv</code>), which is passed as the first argument to <code class="literal">send</code> like this:</p><a id="I_programlisting7_d1e9168"/><pre class="programlisting">ob.send( :priv, "hello" )    # This succeeds</pre><p>Any arguments supplied after the symbol (like the string “hello”) are passed in the normal way to the specified method.</p><p>Using <code class="literal">send</code> to gain public access to a private method is not generally a good idea. After all, if you need access to a certain method, why make it private in the first place? Use this technique with caution or not at all.</p><p><span class="bolditalic">Singleton Class Methods</span></p><p>Earlier, I created class methods by appending a method name to the name of the class like this:</p><a id="I_programlisting7_d1e9182"/><pre class="programlisting">def MyClass.classMethod</pre><p>There is a “shortcut” syntax for doing this. Here is an example:</p><p><span class="emphasis"><em>class_methods3.rb</em></span></p><a id="I_programlisting7_d1e9190"/><pre class="programlisting">class MyClass

   def MyClass.methodA
      puts("a")
   end

   class &lt;&lt; self
      def methodB
         puts("b")
      end

      def methodC
         puts("c")
      end
   end

end</pre><p>Here, <code class="literal">methodA</code>, <code class="literal">methodB</code>, and <code class="literal">methodC</code> are all class methods of MyClass; <code class="literal">methodA</code> is declared using the syntax used previously:<a id="IDX-CHP-7-0062" class="indexterm"/></p><a id="I_programlisting7_d1e9211"/><pre class="programlisting">def <em class="replaceable"><code>ClassName</code></em>.<em class="replaceable"><code>methodname</code></em></pre><p>But <code class="literal">methodB</code> and <code class="literal">methodC</code> are declared using the syntax of instance methods:</p><a id="I_programlisting7_d1e9226"/><pre class="programlisting">def <em class="replaceable"><code>methodname</code></em></pre><p>So, why do they end up as class methods? It’s all because the method declarations have been placed inside this code:</p><a id="I_programlisting7_d1e9232"/><pre class="programlisting">class &lt;&lt; self
    # some method declarations
end</pre><p>This may remind you of the syntax used for declaring singleton classes. For example, in the <span class="emphasis"><em>singleton_class.rb</em></span> program, you may recall that I first created an object named <code class="literal">ob</code> and then gave it its very own method, <code class="literal">blather</code>:</p><a id="I_programlisting7_d1e9245"/><pre class="programlisting">class &lt;&lt; ob
   def blather( aStr )
      puts("blather, blather #{aStr}")
   end
end</pre><p>The <code class="literal">blather</code> method here is a singleton method of the <code class="literal">ob</code> object. Similarly, in the <span class="emphasis"><em>class_methods3.rb</em></span> program, the <code class="literal">methodB</code> and <code class="literal">methodC</code> methods are singleton methods of <code class="literal">self</code>—and <code class="literal">self</code> happens to be the MyClass class. You can similarly add singleton methods from outside the class definition by using <code class="literal">&lt;&lt;</code> followed by the class name, like this:</p><a id="I_programlisting7_d1e9275"/><pre class="programlisting">class &lt;&lt; MyClass
   def methodD
      puts( "d" )
   end
end</pre><p>Finally, the code checks that all four methods really are singleton methods by first printing the names of all available singleton methods and then calling them:<a id="IDX-CHP-7-0063" class="indexterm"/></p><a id="I_programlisting7_d1e9282"/><pre class="programlisting">puts( MyClass.singleton_methods.sort )
MyClass.methodA
MyClass.methodB
MyClass.methodC
MyClass.methodD</pre><p>This displays the following:</p><a id="I_programlisting7_d1e9286"/><pre class="programlisting">methodA
methodB
methodC
methodD
a
b
c
d</pre><p><span class="bolditalic">Nested Methods</span></p><p>You can nest methods; that is, you can write methods that contain other methods. This gives you a way of dividing a long method into reusable chunks. So, for example, if method <code class="literal">x</code> needs to do calculation <code class="literal">y</code> at several different points, you can put the <code class="literal">y</code> method inside the <code class="literal">x</code> method (the methods in the following example are called <code class="literal">outer_x</code>, <code class="literal">nested_y</code>, and <code class="literal">nested_z</code> for clarity):<a id="IDX-CHP-7-0064" class="indexterm"/></p><p><span class="emphasis"><em>nested_methods.rb</em></span></p><a id="I_programlisting7_d1e9323"/><pre class="programlisting">class X

   def outer_x
      print( "x:" )

      def nested_y
         print("ha! ")
      end

      def nested_z
         print( "z:" )
         nested_y
      end

      nested_y
      nested_z
   end

end</pre><p>Nested methods are not initially visible outside the scope in which they are defined. So, in the previous example, although <code class="literal">nested_y</code> and <code class="literal">nested_z</code> may be called from inside <code class="literal">outer_x</code>, they may not be called by any other code:<a id="IDX-CHP-7-0065" class="indexterm"/></p><a id="I_programlisting7_d1e9342"/><pre class="programlisting">ob = X.new
ob.outer_x         #=&gt; x:ha! z:ha!</pre><p>If, instead of <code class="literal">ob.outer_x</code> in the previous code, you were to call <code class="literal">ob.nested_y</code> or <code class="literal">ob.nested_z</code>, you would see an error message since the <code class="literal">nested_y</code> and <code class="literal">nested_z</code> methods would not, at this stage, be visible. However, when you run a method that encloses nested methods, those nested methods <span class="emphasis"><em>will</em></span> be brought into scope outside that method!</p><p><span class="emphasis"><em>nested_methods2.rb</em></span></p><a id="I_programlisting7_d1e9368"/><pre class="programlisting">class X
   def x
      print( "x:" )
      def y
         print("y:")
      end

      def z
         print( "z:" )
         y
      end
   end
end


ob = X.new
ob.x        #=&gt; x:
puts
ob.y        #=&gt; y:
puts
ob.z        #=&gt; z:y:</pre><p>To see another example of this, try running the <span class="emphasis"><em>nested_methods.rb</em></span> code again, but this time uncomment all three method calls. This time, when the <code class="literal">outer_x</code> method executes, it brings <code class="literal">nested_y</code> and <code class="literal">nested_z</code> into scope so the calls to the two nested methods now succeed:</p><a id="I_programlisting7_d1e9384"/><pre class="programlisting">ob.outer_x     #=&gt; x:ha! z:ha!
ob.nested_y    #=&gt; ha!
ob.nested_z    #=&gt; z:ha!</pre><p><span class="bolditalic">Method Names</span></p><p>As a final point, it’s worth mentioning that method names in Ruby almost always begin with a lowercase character like this:</p><a id="I_programlisting7_d1e9391"/><pre class="programlisting">def fred</pre><p>However, that is a <span class="emphasis"><em>convention</em></span>, not an <span class="emphasis"><em>obligation</em></span>. It is also permissible to begin method names with capital letters, like this:</p><a id="I_programlisting7_d1e9401"/><pre class="programlisting">def Fred</pre><p>Since the <code class="literal">Fred</code> method looks like a constant (it starts with a capital letter), you would need to tell Ruby that it is a method when calling it by adding parentheses:</p><p><span class="emphasis"><em>method_names.rb</em></span></p><a id="I_programlisting7_d1e9412"/><pre class="programlisting">Fred         # &lt;= Ruby complains 'uninitialized constant'
Fred()       # &lt;= Ruby calls the Fred method</pre><p>On the whole, it is better to stick to the convention of using method names that begin with a lowercase character.</p></div></div></body></html>