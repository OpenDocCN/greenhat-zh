["```\ntypedef int (*modeventhand_t)(module_t, int /* modeventtype_t */, void *);\n```", "```\ntypedef enum modeventtype {\n        MOD_LOAD,       /* Set when module is loaded. */\n        MOD_UNLOAD,     /* Set when module is unloaded. */\n        MOD_SHUTDOWN,   /* Set on shutdown. */\n        MOD_QUIESCE     /* Set when module is about to be unloaded. */\n} modeventtype_t;\n```", "```\nstatic int\nmodevent(module_t mod __unused, int event, void *arg __unused)\n{\n        int error = 0;\n\n        switch (event) {\n      case MOD_LOAD:\n                uprintf(\"Hello, world!\\n\");\n                break;\n      case MOD_UNLOAD:\n                uprintf(\"Good-bye, cruel world!\\n\");\n                break;\n      default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return (error);\n}\n```", "```\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/module.h>\n\nDECLARE_MODULE(name, moduledata_t data, sub, order);\n```", "```\ntypedef struct moduledata {\n        const char      *name;\n        modeventhand_t  evhand;\n        void            *priv;\n} moduledata_t;\n```", "```\nenum sysinit_sub_id {\n        SI_SUB_DUMMY            = 0x0000000,    /* Not executed.        */\n        SI_SUB_DONE             = 0x0000001,    /* Processed.           */\n        SI_SUB_TUNABLES         = 0x0700000,    /* Tunable values.      */\n        SI_SUB_COPYRIGHT        = 0x0800001,    /* First console use.   */\n        SI_SUB_SETTINGS         = 0x0880000,    /* Check settings.      */\n        SI_SUB_MTX_POOL_STATIC  = 0x0900000,    /* Static mutex pool.   */\n        SI_SUB_LOCKMGR          = 0x0980000,    /* Lock manager.        */\n        SI_SUB_VM               = 0x1000000,    /* Virtual memory.      */\n...\n      SI_SUB_DRIVERS          = 0x3100000,     /* Device drivers.      */\n...\n};\n```", "```\nenum sysinit_elem_order {\n        SI_ORDER_FIRST          = 0x0000000,    /* First.               */\n        SI_ORDER_SECOND         = 0x0000001,    /* Second.              */\n        SI_ORDER_THIRD          = 0x0000002,    /* Third.               */\n        SI_ORDER_FOURTH         = 0x0000003,    /* Fourth.              */\n      SI_ORDER_MIDDLE         = 0x1000000,    /* Somewhere in the middle. */\n        SI_ORDER_ANY            = 0xfffffff     /* Last.                    */\n};\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  static int\n hello_modevent(module_t mod __unused, int event, void *arg __unused)\n  {\n          int error = 0;\n\n          switch (event) {\n          case MOD_LOAD:\n                  uprintf(\"Hello, world!\\n\");\n                  break;\n          case MOD_UNLOAD:\n                  uprintf(\"Good-bye, cruel world!\\n\");\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n static moduledata_t hello_mod = {\n          \"hello\",\n          hello_modevent,\n          NULL\n  };\n\n DECLARE_MODULE(hello, hello_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);\n```", "```\n KMOD=   hello\n SRCS=   hello.c\n\n  .include <bsd.kmod.mk>\n```", "```\n$ `make`\nWarning: Object directory not changed from original /usr/home/ghost/hello\n@ -> /usr/src/sys\nmachine -> /usr/src/sys/i386/include\ncc -O2 -fno-strict-aliasing -pipe  -D_KERNEL -DKLD_MODULE -std=c99 -nostdinc\n-I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 -\n-param large-function-growth=1000 -fno-common  -mno-align-long-strings -mpref\nerred-stack-boundary=2  -mno-mmx -mno-3dnow -mno-sse -mno-sse2 -mno-sse3 -ffr\neestanding -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmi\nssing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-s\nign -fformat-extensions -c hello.c\nld  -d -warn-common -r -d -o hello.kld hello.o\n:> export_syms\nawk -f /sys/conf/kmod_syms.awk hello.kld  export_syms | xargs -J% objcopy % h\nello.kld\nld -Bshareable  -d -warn-common -o hello.ko hello.kld\nobjcopy --strip-debug hello.ko\n$ `ls -F`\n@@           export_syms  hello.kld    hello.o\nMakefile     hello.c      hello.ko*    machine@\n```", "```\n$ `sudo kldload ./hello.ko`\nHello, world!\n$ `sudo kldunload hello.ko`\nGood-bye, cruel world!\n```", "```\n$ `sudo make load`\n/sbin/kldload -v /usr/home/ghost/hello/hello.ko\nHello, world!\nLoaded /usr/home/ghost/hello/hello.ko, id=3\n$ `sudo make unload`\n/sbin/kldunload -v hello.ko\nUnloading hello.ko, id=3\nGood-bye, cruel world!\n```", "```\n$ `kldstat`\nId Refs Address    Size     Name\n 1    4 0xc0400000 906518   kernel\n 2    1 0xc0d07000 6a32c    acpi.ko\n 3    1 0xc3301000 2000     hello.ko\n```", "```\nstruct cdevsw {\n        int                     d_version;\n        u_int                   d_flags;\n        const char              *d_name;\n        d_open_t                *d_open;\n        d_fdopen_t              *d_fdopen;\n        d_close_t               *d_close;\n        d_read_t                *d_read;\n        d_write_t               *d_write;\n        d_ioctl_t               *d_ioctl;\n        d_poll_t                *d_poll;\n        d_mmap_t                *d_mmap;\n        d_strategy_t            *d_strategy;\n        dumper_t                *d_dump;\n        d_kqfilter_t            *d_kqfilter;\n        d_purge_t               *d_purge;\n        d_spare2_t              *d_spare2;\n        uid_t                   d_uid;\n        gid_t                   d_gid;\n        mode_t                  d_mode;\n        const char              *d_kind;\n\n        /* These fields should not be messed with by drivers. */\n        LIST_ENTRY(cdevsw)      d_list;\n        LIST_HEAD(, cdev)       d_devs;\n        int                     d_spare3;\n        struct cdevsw           *d_gianttrick;\n};\n```", "```\nstatic struct cdevsw echo_cdevsw = {\n        .d_version =    D_VERSION,\n        .d_open =       echo_open,\n        .d_close =      echo_close,\n        .d_read =       echo_read,\n        .d_write =      echo_write,\n        .d_name =       \"echo\"\n};\n```", "```\n#include <sys/param.h>\n#include <sys/conf.h>\n\nstruct cdev *\nmake_dev(struct cdevsw *cdevsw, int minor, uid_t uid, gid_t gid,\n    int perms, const char *fmt, ...);\n```", "```\n#include <sys/param.h>\n#include <sys/conf.h>\n\nvoid\ndestroy_dev(struct cdev *dev);\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/conf.h>\n  #include <sys/uio.h>\n  #include <sys/malloc.h>\n\n  #define BUFFER_SIZE     256\n\n  /* Forward declarations. */\n  static d_open_t         echo_open;\n  static d_close_t        echo_close;\n  static d_read_t         echo_read;\n  static d_write_t        echo_write;\n\n static struct cdevsw echo_cdevsw = {\n          .d_version =    D_VERSION,\n          .d_open =       echo_open,\n          .d_close =      echo_close,\n          .d_read =       echo_read,\n          .d_write =      echo_write,\n          .d_name =       \"echo\"\n  };\n\n  typedef struct echo {\n          char buffer[BUFFER_SIZE];\n          int length;\n  } echo_t;\n\n static echo_t *echo_message;\n static struct cdev *echo_dev;\n\n  static int\n echo_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n  {\n          uprintf(\"Opening echo device.\\n\");\n          return (0);\n  }\n\n  static int\n echo_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n  {\n          uprintf(\"Closing echo device.\\n\");\n          return (0);\n  }\n\n  static int\n  echo_write(struct cdev *dev, struct uio *uio, int ioflag)\n  {\n          int error = 0;\n\n          error = copyin(uio->uio_iov->iov_base, echo_message->buffer,\n              MIN(uio->uio_iov->iov_len, BUFFER_SIZE - 1));\n          if (error != 0) {\n                  uprintf(\"Write failed.\\n\");\n                  return (error);\n          }\n\n          *(echo_message->buffer +\n              MIN(uio->uio_iov->iov_len, BUFFER_SIZE - 1)) = 0;\n\n          echo_message->length = MIN(uio->uio_iov->iov_len, BUFFER_SIZE - 1);\n\n          return (error);\n  }\n\n  static int\n  echo_read(struct cdev *dev, struct uio *uio, int ioflag)\n  {\n          int error = 0;\n          int amount;\n\n          amount = MIN(uio->uio_resid,\n              (echo_message->length - uio->uio_offset > 0) ?\n               echo_message->length - uio->uio_offset : 0);\n\n          error = uiomove(echo_message->buffer + uio->uio_offset, amount, uio);\n          if (error != 0)\n                  uprintf(\"Read failed.\\n\");\n\n          return (error);\n  }\n\n  static int\n  echo_modevent(module_t mod __unused, int event, void *arg __unused)\n  {\n          int error = 0;\n\n          switch (event) {\n          case MOD_LOAD:\n                  echo_message = malloc(sizeof(echo_t), M_TEMP, M_WAITOK);\n                  echo_dev = make_dev(&echo_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                      0600, \"echo\");\n                  uprintf(\"Echo driver loaded.\\n\");\n                  break;\n          case MOD_UNLOAD:\n                  destroy_dev(echo_dev);\n                  free(echo_message, M_TEMP);\n                  uprintf(\"Echo driver unloaded.\\n\");\n                  break;\n          default:\n                  error = EOPNOTSUPP;\n                  break;\n          }\n\n          return (error);\n  }\n\n  DEV_MODULE(echo, echo_modevent, NULL);\n```", "```\nstatic int\necho_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int error = 0;\n\n        error = copyin(uio->uio_iov->iov_base,\n echo_message->buffer,\n            MIN(uio->uio_iov->iov_len, BUFFER_SIZE - 1));\n        if (error != 0) {\n                uprintf(\"Write failed.\\n\");\n                return (error);\n        }\n\n      *(echo_message->buffer +\n            MIN(uio->uio_iov->iov_len, BUFFER_SIZE - 1)) = 0;\n\n      echo_message->length = MIN(uio->uio_iov->iov_len, BUFFER_SIZE - 1);\n\n        return (error);\n}\n```", "```\nstatic int\necho_read(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int error = 0;\n        int amount;\n\n        amount = MIN(uio->uio_resid,\n            (echo_message->length - uio->uio_offset > 0) ?\n            echo_message->length - uio->uio_offset : 0);\n\n        error = uiomove(echo_message->buffer + uio->uio_offset,\n amount,\n            uio);\n        if (error != 0)\n                uprintf(\"Read failed.\\n\");\n\n        return (error);\n}\n```", "```\nstatic int\necho_modevent(module_t mod __unused, int event, void *arg __unused)\n{\n        int error = 0;\n\n        switch (event) {\n        case MOD_LOAD:\n              echo_message = malloc(sizeof(echo_t), M_TEMP, M_WAITOK);\n                echo_dev = make_dev(&echo_cdevsw, 0, UID_ROOT, GID_WHEEL,\n                    0600, \"echo\");\n                uprintf(\"Echo driver loaded.\\n\");\n                break;\n        case MOD_UNLOAD:\n              destroy_dev(echo_dev);\n              free(echo_message, M_TEMP);\n                uprintf(\"Echo driver unloaded.\\n\");\n                break;\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return (error);\n}\n```", "```\n#define DEV_MODULE(name, evh, arg)                                      \\\n  static moduledata_t name##_mod = {                                      \\\n      #name,                                                              \\\n      evh,                                                                \\\n      arg                                                                 \\\n  };                                                                      \\\n DECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE)\n```", "```\n$ `sudo kldload ./echo.ko`\nEcho driver loaded.\n$ `ls -l /dev/echo`\ncrw-------  1 root  wheel    0,  95 Jun  4 23:23 /dev/echo\n$ `su`\nPassword:\n# `echo \"DON'T PANIC\" > /dev/echo`\nOpening echo device.\nClosing echo device.\n# `cat /dev/echo`\nOpening echo device.\nDON'T PANIC\nClosing echo device.\n```"]