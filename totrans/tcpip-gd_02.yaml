- en: Part I-2. THE OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. OSI REFERENCE MODEL LAYERS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. OSI REFERENCE MODEL SUMMARY")'
  prefs: []
  type: TYPE_NORMAL
- en: Models are useful because they help us understand difficult concepts and complicated
    systems. When it comes to networking, there are several models that are used to
    explain the roles played by various technologies and how they interact. Of these,
    the most popular and commonly used is the Open Systems Interconnection (OSI) Reference
    Model. The OSI Reference Model makes it easier for networks to be analyzed, designed,
    built, and rearranged, by allowing them to be considered as modular pieces that
    interact in predictable ways, rather than enormous, complex monoliths.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find that it's nearly impossible to read a lot about networking without
    encountering discussions that presume at least some knowledge of how the OSI Reference
    Model works. This is why I strongly advise that if you are new to the OSI Reference
    Model, you read this part carefully. While it is all arguably background material,
    this information will give you a foundation for understanding networks, as well
    as make the rest of the book easier to follow. If you are quite familiar with
    the OSI Reference Model, you may wish to skip this part or just skim through it.
  prefs: []
  type: TYPE_NORMAL
- en: This part is geared to a discussion of networks and internetworks in general,
    and not specifically to the TCP/IP protocol suite. Therefore, not all of the material
    in this section is directly relevant to learning about TCP/IP, although much of
    it is. You may also wish to refer to [Part I-3](pt03.html "Part I-3. TCP/IP PROTOCOL
    SUITE AND ARCHITECTURE"), which includes a discussion of how the TCP/IP and OSI
    models compare.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, I describe the OSI Reference Model in detail. I begin with a discussion
    of some general concepts related to the OSI Reference Model and networking models
    overall. I then describe each of the seven layers of the OSI Reference Model.
    I conclude with a summary chapter that includes a useful analogy to help you understand
    how the reference model works to explain the interaction of networks on multiple
    levels. That chapter also presents a reference table of the layers and their respective
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The idea behind the OSI Reference Model is to provide a framework for both designing
    networking systems and explaining how they work. As you read about networking,
    you will frequently find references to the various levels, or layers, of the OSI
    Reference Model. However, before I can properly discuss the actual OSI model *layers*,
    you need to understand the model as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I introduce the OSI Reference Model and provide some useful
    background information to help you understand it. I begin with a brief history
    of the model, including a look at its development and goals. I then introduce
    networking models in general terms, describing why they are beneficial and how
    they can best be used. The bulk of the chapter contains important OSI model concepts,
    which will help you begin to really understand the way model works, the terminology
    used to describe it, and how it can be of value in explaining the operation of
    networking technologies.
  prefs: []
  type: TYPE_NORMAL
- en: History of the OSI Reference Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A look at the origins of the OSI Reference Model takes us back to several issues
    related to standards and standards organizations that were discussed in [Chapter 3](ch03.html
    "Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS"). The idea behind the
    creation of networking standards is to define widely accepted ways of setting
    up networks and connecting them together. The OSI Reference Model represented
    an early attempt to get all of the various hardware and software manufacturers
    to agree on a framework for developing various networking technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the late 1970s, two projects began independently with the same goal: to
    define a unifying standard for the architecture of networking systems. One was
    administered by the *International Organization for Standardization (ISO)*, while
    the other was undertaken by the *International Telegraph and Telephone Consultative
    Committee*, or *CCITT* (the abbreviation is from the French version of the name).
    These two international standards bodies each developed a document that defined
    similar networking models.'
  prefs: []
  type: TYPE_NORMAL
- en: In 1983, these two documents were merged to form a standard called *The Basic
    Reference Model for Open Systems Interconnection*. That's a mouthful, so the standard
    is usually referred to as the *Open Systems Interconnection Reference Model*,
    the *OSI Reference Model*, or even just the *OSI model*. It was published in 1984
    by both the ISO, as standard ISO 7498, and the renamed CCITT (now called the *Telecommunications
    Standardization Sector of the International Telecommunication Union* or *ITU-T*)
    as standard X.200\. (Incidentally, isn't the new name for the CCITT *much* catchier
    than the old one? Just rolls off the old tongue, doesn't it?)
  prefs: []
  type: TYPE_NORMAL
- en: One interesting aspect of the history of the OSI Reference Model is that the
    original objective was *not* to create a model primarily for educational purposes,
    even though many people today think that this was the case. It was intended to
    serve as the foundation for the establishment of a widely adopted suite of protocols
    that would be used by international internetworks—basically, what the Internet
    became. This was called, unsurprisingly, the OSI protocol suite.
  prefs: []
  type: TYPE_NORMAL
- en: However, things didn't quite work out as planned. The rise in popularity of
    the Internet and its TCP/IP protocols met the OSI protocol suite head on, and
    in a nutshell, TCP/IP won. Some of the OSI protocols were implemented, but as
    a whole, the OSI protocols lost out to TCP/IP when the Internet started to grow.
  prefs: []
  type: TYPE_NORMAL
- en: The OSI model itself, however, found a home as a device for explaining the operation
    of not just the OSI protocols, but networking in general. It's used widely as
    an educational tool—much as I use it myself—and it's also used to help describe
    interactions between the components of other protocol suites and even hardware
    devices. Although most technologies were not designed specifically to meet the
    dictates of the OSI model, many are described in terms of how they fit into its
    layers. This includes networking protocols, software applications, and even different
    types of hardware devices, such as switches and routers. The model is also useful
    to those who develop software and hardware products because it clarifies the roles
    performed by each of the components in a networking system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *Open Systems Interconnection Reference Model* (*OSI Reference
    Model* or *OSI model*) was originally created as the basis for designing a universal
    set of protocols called the *OSI protocol suite*. This suite never achieved widespread
    success, but the model became a very useful tool for both education and development.
    The model defines a set of layers and a number of concepts for their use that
    make understanding networks easier.'
  prefs: []
  type: TYPE_NORMAL
- en: General Reference Model Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss some of the basic issues related to reference models. In part,
    I want to explain why I place so much emphasis on the OSI model, even going so
    far as to build much of this book's organization around this model and its layers.
    I also want you to understand why the model is important, and how it benefits
    networking not only on a conceptual level, but in reality.
  prefs: []
  type: TYPE_NORMAL
- en: In the topics that follow, I describe several issues that relate to reference
    models in general terms, and of course, to the OSI Reference Model specifically.
    I begin with an overview of why networking models are beneficial and why it is
    important for you to understand how the OSI model works. I then talk about how
    best to use the model and contrast it with some "real-world" network architectures
    and protocol stacks.
  prefs: []
  type: TYPE_NORMAL
- en: The Benefits of Networking Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Networking is complicated, and special pains must be taken to try to *simplify*
    it. One of the ways in which networking technology is made easier to understand
    is by splitting it into pieces, each of which plays a particular role or is responsible
    for a specific job or function.
  prefs: []
  type: TYPE_NORMAL
- en: However, if this is to be done, you must have a way of ensuring that these various
    pieces can interoperate; that is, each must know what is expected of it and also
    what it can expect from the other pieces. This is one of the important roles of
    networking models. They split the multitude of tasks required to implement modern
    networks into smaller chunks that can be more easily managed. Just as importantly,
    they establish "walls" between those pieces and rules for passing information
    over those walls.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good analogy of a networking model is that of an assembly line at a manufacturer.
    No company attempts to have one person build an entire car; even if the company
    did, it wouldn''t expect that individual to be able to learn how to do it all
    at once. The division of labor offers several advantages to a company that builds
    a complex product, such as an automobile. Generally speaking, these include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Training and Documentation** It is easier to explain how to build a complex
    system by breaking the process into smaller parts. Training can be done for a
    specific job without everyone needing to know how everything else works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specialization** If everyone is responsible for doing every job, no one gets
    enough experience to become an expert at anything. Through specialization, certain
    individuals develop expertise at particular jobs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier Design Modification and Enhancement** By separating the automobile
    into systems as well as the particular jobs required to build those systems, you
    can make changes in the future more easily. Without such divisions, it would be
    much more difficult to determine what the impact might be of a change, which would
    serve as a disincentive for innovation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** This is related to each of the previous items. If the automobile''s
    systems and manufacturing steps are broken down according to a sensible architecture
    or model, it becomes easier to interchange parts and procedures between vehicles.
    This saves time and money.'
  prefs: []
  type: TYPE_NORMAL
- en: Networking models yield very similar benefits to the networking world. They
    represent a framework for dividing up the tasks needed to implement a network
    by splitting the work into different levels, or *layers*. Hardware and software
    running on each layer are responsible for interacting with corresponding hardware
    and software that are running on other devices on the same layer. The responsibilities
    of each hardware or software element are defined in part by specifically dividing
    lines between the layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, you get all of the benefits listed in the previous points: easier
    training, specialized capabilities at each layer, improved capabilities for modification,
    and modularity. Modularity is particularly important, because it allows you to
    interchange technologies that run at different layers. While no one would try
    to build a vehicle that is partly a compact sedan, partly an SUV, and partly a
    motorcycle, there are situations in networking for which you may want to do something
    surprisingly similar to this. Networking models help make this possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Networking models such as the *OSI Reference Model* provide
    a framework for breaking down complex internetworks into components that can more
    easily be understood and utilized. The model defines networking functions not
    as a large, complicated whole, but as a set of layered, modular components, each
    of which is responsible for a particular function. The result is better comprehension
    of network operations, improved performance and functionality, easier design and
    development, and the ability to combine different components in a way that''s
    best suited to the needs of the network.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Understanding the OSI Reference Model Is Important to You
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of networking books and other resources gloss over the OSI Reference Model
    or relegate it to the back pages of a hard-to-find appendix. The reason usually
    stated for this is that the OSI model is "too theoretical" and "doesn't apply
    to modern networking protocols like TCP/IP."
  prefs: []
  type: TYPE_NORMAL
- en: This is a misguided notion. While it is certainly true that the OSI model is
    primarily theoretical, and that networking protocols aren't always designed to
    fit strictly within the confines of their layers, it's *not* true that the OSI
    model has little applicability to the real world. In fact, it is difficult to
    read about networking technology today without seeing references to the OSI model
    and its layers, because the model's structure helps to frame discussions of protocols
    and contrast various technologies.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the OSI Reference Model provides the basis for understanding how
    technologies like Ethernet and HomePNA are similar; it explains how a PC can communicate
    using any of several different sets of protocols, even simultaneously; it is an
    important part of understanding the differences between interconnection devices
    such as repeaters, hubs, bridges, switches, and routers; and it also explains
    how many WAN technologies interoperate.
  prefs: []
  type: TYPE_NORMAL
- en: Far from being obsolete, the OSI model layers are now showing up more than ever
    in discussions of technology. In fact, some protocols are even *named* specifically
    in terms of their place in the OSI Reference Model! For an example, consider the
    Layer Two Tunneling Protocol. Also, switches are now commonly categorized as layer
    2, layer 3, or even higher-layer switches.
  prefs: []
  type: TYPE_NORMAL
- en: In theoretical discussions, the OSI Reference Model helps you to understand
    how networks and network protocols function in the real world. It also helps you
    to figure out which protocols and devices can interact with each other. So I encourage
    you to read on. It's time well spent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** While many people scoff at the notion of studying the OSI Reference
    Model, understanding it is very helpful in making sense of networking protocols
    and technologies. The model is theoretical, but its concepts are employed regularly
    to describe the operation of real-world networks.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Use the OSI Reference Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although some people tend to downplay the OSI model too much, others go to the
    opposite extreme. They use it too much, overanalyzing and trying to use it in
    a way that was never intended.
  prefs: []
  type: TYPE_NORMAL
- en: The most common mistake is made when attempting to try to "make everything fit"
    into the layered structure of the OSI model. I must confess to falling into this
    trap myself on occasion. When I first started laying out the structure of this
    book, I wanted to organize *everything* based on where it fell in terms of OSI
    model layers. I quickly discovered that this was like attempting to put pegs of
    various shapes into a board containing only round holes. I had to change my approach.
    I ended up organizing it based on the OSI layers where it made sense and using
    a different structure where it did not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn from my experience. A simple rule of thumb is this: Refer to the OSI
    Reference Model if it helps you make sense of technologies and understand how
    they work; *don''t* use it if it makes things more complicated. In particular,
    bear the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be very hard to figure out where some technologies fall within the model.
    Many protocols were designed without the OSI model in mind, and they may not fall
    neatly into one layer or another. Some overlap two or more layers; other protocol
    suites may have two protocols that share a layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The boundaries between the upper layers (session, presentation, and application)
    get particularly fuzzy. Some protocols are clearly designed to fit on one of these
    layers, while others may overlap all three. This is one reason why I do not categorize
    higher-level protocols by layer. (The OSI Reference Model was designed to account
    for the fact that differentiating between these layers might not make sense.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OSI Reference Model was designed primarily with LANs in mind. WAN technologies
    often fit very poorly into the model, with a lot of overlapping and partial layer
    coverage. However, it's still useful in most cases to look at these protocols
    in terms of their approximate fit in the OSI model, since parts of WAN technologies
    are sometimes interchanged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The people who design products don't generally worry about ensuring that their
    latest inventions implement only specific layers of the model. Thus, sometimes
    new products come out that break the rules and implement functions across more
    than one layer, which used to be done by multiple devices at the individual layers.
    This is usually progress—a good thing!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, an observation: I have noticed that people learning about networking—especially
    those trying to memorize easy answers to difficult questions so they can pass
    exams—often ask, "At what layer does this piece of hardware operate?" The problem
    here is not the answer but rather the question, which is simplistic. With the
    exception of simple physical devices such as connectors and cables, pretty much
    *all* networking devices operate at many layers. While a router, for example,
    is usually associated with layer 3, it has two or more device interfaces that
    implement layers 2 and 1\. A better question is what is the *highest* layer at
    which a device functions?'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that the OSI Reference Model is a tool. If you use it wisely,
    it can be immensely helpful to you. Just remember not to be too inflexible in
    how you apply it, and you'll be fine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** It is just as much a mistake to assign too much importance
    to the OSI Reference Model as too little. While the model defines a framework
    for understanding networks, not all networking components, protocols, and technologies
    will necessarily fall into the model''s strict layering architecture. There are
    cases in which trying to use the model to describe certain concepts can lead to
    less clarity rather than more. You should remember that the OSI model is a *tool*
    and should be used accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Network Architectures and Protocol Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OSI Reference Model is not the only model used to describe the structure
    of networks; several other models and systems are used to describe various sets
    of networking technologies that work together. These don't generally describe
    theoretical models, but rather groupings of protocols that are actively used in
    actual networks. They are, therefore, more often called *networking architectures*
    and *protocol suites* than models.
  prefs: []
  type: TYPE_NORMAL
- en: As you just saw, many technologies and protocols don't "fit" well into the specific
    layers used in the OSI model. Similarly, most of the protocol suites used in the
    real world don't fit the OSI model exactly. This happens, of course, because they
    were developed independently of the OSI model. Still, most of these architectures
    and suites still use layers—they are just different from the ones that the OSI
    model uses.
  prefs: []
  type: TYPE_NORMAL
- en: Since the OSI model is referenced so often, it can be very helpful in making
    sense of other architectures and even comparing them. Regardless of what the individual
    layers and technologies are called, networking protocol suites all try to accomplish
    the same goals in implementing a network. Thus, even though the layers are not
    the same, they are often comparable.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of TCP/IP, a special model called the DoD (Department of Defense)
    model or TCP/IP model is usually used in discussions of the suite (see [Chapter 8](ch08.html
    "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE")). This model has many similarities
    to the OSI model, but also some important differences. In other areas in the field
    of networking, still other models are used, such as the IEEE 802 networking architecture
    model. These, too, are similar in some ways to the OSI model, but they have their
    own unique characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Even within the scope of some individual specific technologies, you can see
    a layered structure of related protocols. There are technologies that are generally
    considered to implement a single level of the OSI model, even though they actually
    have portions that overlap several OSI layers; examples include Ethernet and Asynchronous
    Transfer Mode (ATM). In fact, some protocols even have *subprotocols* that are
    layered within the confines of what is considered a single layer under OSI. A
    good example is the TCP/IP Point-to-Point Protocol (PPP), which, despite the name,
    is not a single protocol but a protocol suite unto itself (see [Part II-1](pt04.html
    "Part II-1. TCP/IP NETWORK INTERFACE LAYER PROTOCOLS")).
  prefs: []
  type: TYPE_NORMAL
- en: Key OSI Reference Model Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OSI Reference Model is valuable as a tool for explaining how networks function,
    and for describing the relationships between different networking technologies
    and protocols. To accomplish this, the model relies on a number of important concepts
    and terms, which I'll discuss in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll begin with a discussion of how the model uses layers. This is perhaps
    the single most important of all model concepts. I then talk about some of the
    notation and jargon you are likely to see in general discussions of the model.
    I define in more detail what *interfaces* and *protocols* are in the context of
    the model. I then explain the important concept of data encapsulation and the
    terminology used to refer to messages in the OSI Reference Model: protocol data
    units (PDUs) and service data units (SDUs). Finally, I connect most of the preceding
    issues by describing how the various layers work to handle the routing of messages
    on a theoretical basis.'
  prefs: []
  type: TYPE_NORMAL
- en: OSI Reference Model Networking Layers, Sublayers, and Layer Groupings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important OSI Reference Model concept is that of networking *layers*.
    It's not an exaggeration to say that layers are really the heart of the OSI model—the
    entire point of the model is to separate networking into distinct functions that
    operate at different levels. Each layer is responsible for performing a specific
    task or set of tasks and dealing with the layers above and below it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OSI Reference Model is composed of seven conceptual layers, each of which
    is assigned a number from 1 to 7\. The layer number represents the position of
    the layer in the model as a whole, and indicates how close the layer is to the
    actual hardware used to implement a network. The first and lowest layer is the
    *physical layer*, which is where low-level signaling and hardware are implemented.
    The seventh and highest layer is the *application layer*, which deals with high-level
    applications employed by users: both end users and the operating system software.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that as you proceed from the first layer to the seventh, you move
    up the *layer stack* and, in so doing, increase your level of *abstraction*. This
    means that the higher a layer is in the stack, the more it deals with logical
    concepts and software, and the less it deals with the hardware of a network and
    the nuts and bolts of making it work. The first layer is the most concrete, because
    it deals with the actual hardware of networks and the specific methods of sending
    bits from one device to another. It is the domain of hardware engineers and signaling
    experts. The second layer is a bit more abstract but still deals with signaling
    and hardware. As you proceed through the third, fourth, and subsequent layers,
    the technologies at those layers become increasingly abstract. By the time you
    reach the seventh layer, you are no longer dealing with hardware or even operating
    system concepts very much; you are in the realm of the user and high-level programs
    that rely on lower levels to do the "heavy lifting" for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OSI Reference Model does not formally assign any relationship between groups
    of adjacent layers. However, to help explain how the layers work, it is common
    to categorize them into two *layer groupings*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower Layers (Layers 1, 2, 3, and 4)** As shown in [Figure 5-1](ch05s03.html#osi_reference_model_layers_the_osi_refer
    "Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking
    functions into a stack of seven layers, numbered 1 through 7 from the bottom up,
    and sometimes divided into two layer groupings—the lower layers and the upper
    layers."), the lower layers of the model—*physical, data link, network,* and *transport*—are
    primarily concerned with the formatting, encoding, and transmission of data over
    the network. They don''t care that much about what the data is or what it is being
    used for; instead, they just want to know about moving it around. They are implemented
    in both hardware and software, with the transition from hardware to software occurring
    as you proceed up from layer 1 to layer 4.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Upper Layers (Layers 5, 6, and 7)** The higher layers of the model—*session,
    presentation*, and *application*—are concerned primarily with interacting with
    the user and implementing the applications that run over the network. The protocols
    that run at higher layers are less concerned with the low-level details of how
    data gets sent from one place to another; they rely on the lower layers to deliver
    the data. These layers are almost always implemented as software running on a
    computer or other hardware device.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some people who would not necessarily agree with how I have chosen
    to divide the layers in [Figure 5-1](ch05s03.html#osi_reference_model_layers_the_osi_refer
    "Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking
    functions into a stack of seven layers, numbered 1 through 7 from the bottom up,
    and sometimes divided into two layer groupings—the lower layers and the upper
    layers."). In particular, valid arguments can be made for including the transport
    layer in the upper layer group, since it is usually implemented as software and
    is fairly abstract. I place it in the lower layer group because its primary job
    is still providing services to higher layers for moving data. Really, layer 4
    is somewhat of a transition zone and is hard to categorize. [Figure 5-1](ch05s03.html#osi_reference_model_layers_the_osi_refer
    "Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking
    functions into a stack of seven layers, numbered 1 through 7 from the bottom up,
    and sometimes divided into two layer groupings—the lower layers and the upper
    layers.") indicates the special position of layer 4 in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The most fundamental concept in the OSI Reference Model is
    the division of networking functions into a set of *layers*, from layer 1 at the
    bottom to layer 7 at the top. As you go up the layer stack, you move away from
    concrete, hardware-specific functions to ones that are increasingly abstract,
    until you reach the realm of user applications at layer 7\. The seven layers are
    sometimes divided into groupings: the lower layers (1 through 3) and the upper
    layers (4 through 7). There is some disagreement on whether layer 4 is a lower
    or upper layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![OSI Reference Model layers The OSI Reference Model divides networking functions
    into a stack of seven layers, numbered 1 through 7 from the bottom up, and sometimes
    divided into two layer groupings—the lower layers and the upper layers.](httpatomoreillycomsourcenostarchimages287703.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1. OSI Reference Model layers The OSI Reference Model divides networking
    functions into a stack of seven layers, numbered 1 through 7 from the bottom up,
    and sometimes divided into two layer groupings—the lower layers and the upper
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: There are also certain OSI layers that have natural relationships to each other.
    The physical and data link layers, in particular, are closely related. For example,
    most people talk about Ethernet as a layer 2 technology, but Ethernet specifications
    really deal with both layer 2 and layer 1\. Similarly, layers 3 and 4 are often
    related; protocol suites are often designed so that layer 3 and 4 protocols work
    together. Good examples are TCP and IP in the TCP/IP protocol suite, and IPX and
    SPX in the Novell suite.
  prefs: []
  type: TYPE_NORMAL
- en: In some areas, the layers are so closely related that the lines between them
    become *blurry*. This is particularly the case when looking at the higher layers;
    many technologies implement two or even all three of these layers, which is another
    reason why I feel they best belong in a group together. One important reason why
    the distinctions between layers 5 through 7 are blurry is that the TCP/IP protocols
    are based on the TCP/IP model (covered in [Chapter 8](ch08.html "Chapter 8. TCP/IP
    PROTOCOL SUITE AND ARCHITECTURE")), which combines the functions of layers 5 through
    7 in a single, thick layer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The four lower layers of the OSI model are most often discussed
    individually, because the boundaries between them are reasonably clear-cut. In
    contrast, the lines between the session, presentation, and application layers
    are somewhat blurry. As a result, sometimes protocols span two or even all three
    of these layers; this is especially true of TCP/IP application protocols, since
    the TCP/IP model treats layers 5 through 7 as a single layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that some OSI Reference Model layers are further divided into
    *sublayers* to help define more precisely the internal details of protocols and
    technologies at those layers. This is commonly done at the lower layers, especially
    at the physical layer and the data link layer.
  prefs: []
  type: TYPE_NORMAL
- en: '"N" Notation and Other OSI Model Layer Terminology'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a theoretical model, the OSI Reference Model comes complete with a set of
    terminology that is used to describe it and its constituent parts. This is sort
    of both good news and bad news. The good news is that if you understand this terminology,
    it can help you comprehend how technologies relate to the model as well as most
    OSI model discussions in general. The bad news is that the terminology can also
    increase confusion—especially since it isn't always used consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few terminology concepts you will often see used to refer to the
    OSI Reference Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layer Names and Numbers** The various layers of the OSI Reference Model are
    referred to in a variety of ways. They may have their names spelled out in full,
    or they may be abbreviated. They are also often simply referenced by their layer
    number. So, for example, all of these refer to the same thing: data link layer,
    Data Link Layer, DLL, L2, layer two, and layer 2\. Similarly, you will often see
    layer names being used as adjectives to describe protocols and technologies. For
    example, a layer 3 technology is one that operates primarily at the network layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**N Notation** The letter *N* is often used to generically refer to a number
    within the computer world. With respect to the OSI model, it''s common to see
    this letter used in discussions that relate generically to individual layers without
    mentioning a specific layer. You will hear terms like *N-functions* and *N-services*,
    which just refer to the functions and services provided within a particular layer.
    As another example, you might hear someone say that a particular technology "provides
    a useful service to the N+1 layer." This just means it provides a function to
    the layer above the one at which it operates. Conceptually, every layer but the
    first and seventh have an N-1 layer, an N+1 layer, and so on. If you are looking
    at the network layer (layer 3), then the N+2 layer is the session layer (layer
    5).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocols and Interfaces** These words have special meaning within the context
    of the OSI model. A *protocol* represents communication between logical or physical
    devices at the same layer of the model. An *interface* represents information
    moving between adjacent layers within the same device. Thus, in N notation, protocols
    represent communication between layer N on one device and layer N on another device,
    while interfaces deal with communication between layer N and N+1 or layer N and
    N-1 on the same device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Stacks** What do you get when you take a bunch of layers and pile
    them up on top of each other? You get a *stack*. This term is used to refer to
    the entire set of layers in a model or suite of technologies, or a partial set.
    Since each layer has protocols associated with it, this is also sometimes called
    the *protocol stack*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities, Functions, Facilities, and Services** These often interchanged,
    somewhat vague terms refer to specific tasks or jobs performed at various layers
    in the model. An *N-entity* is a term that refers to a specific operation or job
    done at layer N. A *function* is basically the same thing. *Facilities* and *services*
    are what a layer provides to the layers above it. This is often expressed in N-notation
    as well: the N+1 layer often uses a set of N services or N facilities provided
    by the N layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-2](ch05s03.html#osi_reference_model_layer_relationships_ "Figure 5-2. OSI
    Reference Model layer relationships and terminology Each layer has a relationship
    with the layer above and below it; here, if the network layer is layer N, it provides
    services to the transport layer (layer N+1) and uses services of the data link
    layer (layer N-1).") serves as a summary of the previous information by showing
    the relationships between OSI model layers and the terminology used to refer to
    adjacent layers in the context of any particular layer. Each layer (except layer
    7) provides services to the layer above it; each layer (other than layer 1) uses
    services provided by the layer below it. Another way of saying this is that each
    layer N provides services to layer N+1 and uses the services of layer N-1\. Taking
    the example of layer 3, the network layer, you see that it provides services to
    layer 4 and uses services of layer 2\. From the standpoint of the network layer,
    the transport layer is layer N+1 and the data link layer is N-1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![OSI Reference Model layer relationships and terminology Each layer has a
    relationship with the layer above and below it; here, if the network layer is
    layer N, it provides services to the transport layer (layer N+1) and uses services
    of the data link layer (layer N-1).](httpatomoreillycomsourcenostarchimages287705.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. OSI Reference Model layer relationships and terminology Each layer
    has a relationship with the layer above and below it; here, if the network layer
    is layer N, it provides services to the transport layer (layer N+1) and uses services
    of the data link layer (layer N-1).
  prefs: []
  type: TYPE_NORMAL
- en: You may have just read all of that and said to yourself, "Why do they bother
    making this so *complicated* anyway?" Good question. Remember, I *did* say there
    was bad news here! Now that you know what all of this stuff is about, if you run
    into it, you won't be *too* confused.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the use of the previous buzzwords is somewhat limited. Most references
    are to specific layer names or numbers, and in particular, the N-1 and N+1 stuff
    is rarely used in discussions of real-world technologies. However, it can be very
    useful in explaining the model itself, as you will see in some of these terms
    when you read the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces: Vertical (Adjacent Layer) Communication'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The seven layers of the OSI Reference Model are used to divide the various functions
    that are required to implement a networking system. On any given device in a network,
    different software and hardware routines and devices may be functioning on any
    or all of these layers simultaneously. Because, in general, all of these are supposed
    to be working together to implement networking functions, there is a need for
    layers to communicate *vertically* between the layers within a particular host.
  prefs: []
  type: TYPE_NORMAL
- en: In OSI Reference Model parlance, the mechanism for communication between adjacent
    layers in the model is called an *interface*. Of course, the term *interface*
    is also used widely in other contexts in the computer and networking worlds, since
    its generic meaning refers to connecting just about *anything* together. However,
    when someone talks about an interface between OSI model layers, that person typically
    refers to the process by which data is passed between layer N of the model and
    layer N-1 or layer N+1\. These relationships are demonstrated in [Figure 5-3](ch05s03.html#osi_reference_model_interfaces_for_verti
    "Figure 5-3. OSI Reference Model interfaces for vertical communication In OSI
    model terminology, an interface is a conduit for communication between adjacent
    layers in the layer stack."). For example, the *layer 2/3 interface* is used by
    a layer 2 and layer 3 protocol to pass data and control information; the *layer
    3/4 interface* connects layers 3 and 4 together.
  prefs: []
  type: TYPE_NORMAL
- en: '![OSI Reference Model interfaces for vertical communication In OSI model terminology,
    an interface is a conduit for communication between adjacent layers in the layer
    stack.](httpatomoreillycomsourcenostarchimages287707.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3. OSI Reference Model interfaces for vertical communication In OSI
    model terminology, an interface is a conduit for communication between adjacent
    layers in the layer stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Remember that not all layers may be implemented in every system or protocol
    stack in the real world. So it''s possible that a process that is technically
    running at layer 7 might communicate with one running at layer 5\. However, I
    am talking about the theoretical model here*.'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical communication is done up and down the protocol stack every time anything
    is sent across the network, and of course, whenever anything is received. This
    occurs because the higher levels are implemented as logical functions in software;
    there is no actual physical connection. The higher layers package data and send
    it down to the lower layers for it to be sent across the network. At the very
    lowest level, the data is sent over the network. On the receiving end, the process
    is reversed, with the data traveling back up to the higher layers on the receiving
    device. I'll discuss this logical interaction between corresponding layers momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary goals of the OSI Reference Model is to allow the interconnection
    of different implementations of various layers. Thus, the intention is to have
    somewhat autonomous individual layers that you can mix and match—to a point. The
    only way to make this work is to have well-defined ways that the layers connect
    together, and that brings me back to the matter of interfaces. Each layer must
    present a consistent, well-documented interface to the layers above it so that
    any upper layer implementation can use the lower layer properly.
  prefs: []
  type: TYPE_NORMAL
- en: I'll provide an example from the world of TCP/IP to illustrate what I mean.
    The heart of the TCP/IP protocol suite is the Internet Protocol (IP). Whenever
    you use any application on the Internet—email, websites, FTP, chat rooms, and
    so on—you are indirectly using IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you never use IP directly—you generally use one of two transport layer
    (layer 4) protocols: the Transmission Control Protocol (TCP) or the User Datagram
    Protocol (UDP) (see [Part II-8](pt11.html "Part II-8. TCP/IP TRANSPORT LAYER PROTOCOLS")).
    A standard interface exists between the network layer and the transport layer
    in the TCP/IP protocol stack, which defines how IP is to be used by upper layer
    protocols; this enables TCP and UDP to interface to it. Similarly, both TCP and
    UDP present a particular interface to the hundreds of higher-layer protocols and
    applications that use them at higher layers.'
  prefs: []
  type: TYPE_NORMAL
- en: Many different types of communication actually take place between layers. Control
    information is passed to enable the higher layers to utilize the lower ones, and
    for the lower ones to pass status and results information back to the higher ones.
    Data is also passed in both directions across the interface. For transmission,
    it flows down to the lower layer, which normally results in data encapsulation.
    Upon reception, the process is reversed, with data being sent back up across the
    interface from a lower to higher layer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In the OSI Reference Model, an *interface* defines the mechanism
    for vertical communication between adjacent layers. The existence of well-defined
    interfaces between layers is what permits a higher layer to use the services of
    any of a number of lower layers, without requiring knowledge of how those layers
    are implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocols: Horizontal (Corresponding Layer) Communication'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each layer in the OSI Reference Model has a particular role (or roles)—a set
    of general tasks for which it is responsible. On each system on the network, hardware
    and software are running at many of the different levels in the model. The routines
    doing a particular job on Machine A are designed to communicate with similar or
    complementary ones that are running on Machine B. This *horizontal communication*
    is the very heart of what networking is about. It is what enables web browsers
    and web servers to talk, email applications to exchange messages, and so much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all communication types function only if everyone agrees to the same
    methods of accomplishing it. Each set of rules describing one type of communication
    is called a *protocol*. You can think of a protocol as a language or a set of
    instructions. Each function or service of a network has its own language; like
    human languages, some are similar to each other while others are quite unique.
  prefs: []
  type: TYPE_NORMAL
- en: If you've done any reading at all about networks, you have probably seen the
    term *protocol* many, many times. Like the word *interface*, the word *protocol*
    can have many meanings. In fact, it is so fundamental to networking, and used
    in so many different ways, that I have a discussion devoted to it in [Chapter 1](ch01.html
    "Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES").
  prefs: []
  type: TYPE_NORMAL
- en: All that aside, you must remember that the OSI Reference Model is intended to
    be a formal way of describing networks. As such, the term *protocol* has a formal
    meaning in the context of the model. It refers specifically to a set of communication
    rules, instructions, and procedures that describe communication between specific
    software or hardware elements running *at the same layer* on different machines
    within a network.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider how these corresponding layers communicate using protocols. First,
    you'll recall that every layer in the model, except the bottom (physical) layer,
    is really a program or algorithm running on a computer. There is no way for, say,
    a web browser and a web server to actually connect together directly—they are
    just software programs, after all. Instead, the software running at various layers
    communicates *logically*. That is to say, through the use of software and procedures,
    a process running at layer 5 on one machine can accomplish *logical communication*
    with a similar process running at layer 5 on another machine.
  prefs: []
  type: TYPE_NORMAL
- en: Since machines are only physically connected at layer 1, the data on the sending
    machine must pass down the data through the layers between layer 5 and layer 1
    in order for a protocol at layer 5 to function. The data is then transmitted over
    the physical connection to layer 1 of the other machine and passed up on the protocol
    stack of the receiving machine to layer 5\. This is how the two machines are logically
    linked at layer 5, even though they have no physical connection at that layer.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, with the exception of the actual physical connection at layer 1, all horizontal
    communication also requires vertical communication—down the stack on one machine,
    and then back up the stack on the other. (The communication doesn't always go
    all the way back up the stack for each connection, however, as in the case of
    routing, as discussed in the "Indirect Device Connection and Message Routing"
    section at the end of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](ch05s03.html#osi_reference_model_protocols_horizontal "Figure 5-4. OSI
    Reference Model protocols: horizontal communication The term protocol has many
    meanings; in the context of the OSI Reference Model, it refers specifically to
    software or hardware elements that accomplish communication between corresponding
    layers on two or more devices.") illustrates how horizontal communication works.
    As an example, IP is said to be a layer 3 protocol because each device uses IP
    software to communicate at layer 3\. The actual transmission and reception of
    data occurs only at the lowest, physical layer; higher-layer protocols communicate
    *logically* by passing data down interfaces until it reaches layer 1, transmitting
    at layer 1, and then passing the data back up to the appropriate layer at the
    recipient.'
  prefs: []
  type: TYPE_NORMAL
- en: '![OSI Reference Model protocols: horizontal communication The term protocol
    has many meanings; in the context of the OSI Reference Model, it refers specifically
    to software or hardware elements that accomplish communication between corresponding
    layers on two or more devices.](httpatomoreillycomsourcenostarchimages287709.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4. OSI Reference Model protocols: horizontal communication The term
    protocol has many meanings; in the context of the OSI Reference Model, it refers
    specifically to software or hardware elements that accomplish communication between
    corresponding layers on two or more devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In the OSI Reference Model, a *protocol* refers specifically
    to a set of rules or procedures that define communication between software or
    hardware elements running at the same layer on network devices. Physical layer
    protocols are responsible for the actual transmission and reception of data at
    layer 1\. Protocols at higher layers pass data down through the layers below them
    to layer 1 for transmission, then across the network and back up to the corresponding
    entity at the same layer on the receiving device. The result is that software
    processes running at say, layer 4 on each of two devices can communicate *logically*
    as if they were directly connected at layer 4, even though they are not.'
  prefs: []
  type: TYPE_NORMAL
- en: Data Encapsulation, Protocol Data Units (PDUs), and Service Data Units (SDUs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protocols are what describe the rules that control horizontal communication,
    that is, conversations between processes that run at corresponding layers within
    the OSI Reference Model. At every layer (except layer 1), these communications
    ultimately take the form of some sort of message that is sent between corresponding
    software elements on two or more devices. Since these messages are the mechanism
    for communicating information between protocols, they are most generally called
    *protocol data units (PDUs)*. Each PDU has a specific format that implements the
    features and requirements of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in the previous section, the communication between layers higher
    than layer 1 is *logical*; the only hardware connection is at the physical layer.
    Thus, in order for a protocol to communicate, it must pass down its PDU to the
    next lower layer for transmission. You''ve also already seen that, using OSI terminology,
    lower layers are said to provide *services* to the layers immediately above them.
    One of the services each layer provides is this function: to handle and manage
    data received from the layer above.'
  prefs: []
  type: TYPE_NORMAL
- en: At any particular layer N, a PDU is a complete message that implements the protocol
    at that layer. However, when this layer N PDU is passed down to layer N-1, it
    becomes the *data* that the layer N-1 protocol is supposed to *service*. Thus,
    the layer N protocol data unit (PDU) is called the layer N-1 *service data unit
    (SDU)*. The job of layer N-1 is to transport this SDU, which it does by placing
    the layer N SDU into its own PDU format, preceding the SDU with its own headers
    and appending footers as necessary. This process is called *data encapsulation*,
    because the entire contents of the higher-layer message are encapsulated as the
    data payload of the message at the lower layer.
  prefs: []
  type: TYPE_NORMAL
- en: What does layer N-1 do with its PDU? It passes it down to the next lower layer,
    where it is treated as a layer N-2 SDU. Layer N-2 creates a layer N-2 PDU containing
    the layer N-1 SDU and layer N-2's headers and footers. And so the process continues,
    all the way down to the physical layer. In the theoretical model, what you end
    up with is a message at layer 1 that consists of application-layer data that is
    encapsulated with headers and footers from layers 7 through 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-5](ch05s03.html#osi_reference_model_data_encapsulation_e "Figure 5-5. OSI
    Reference Model data encapsulation Each protocol creates a protocol data unit
    (PDU) for transmission, each of which includes headers required by that protocol
    and data to be transmitted. This data becomes the service data unit (SDU) of the
    next layer below it.") shows a layer 7 PDU consisting of a layer 7 header (labeled
    L7H) and application data. When this is passed to layer 6, it becomes a layer
    6 SDU. The layer 6 protocol prepends to it a layer 6 header (labeled L6H) to create
    a layer 6 PDU, which is passed to layer 5\. The encapsulation process continues
    all the way down to layer 2, which creates a layer 2 PDU—in this case, shown with
    both a header and a footer—that is converted to bits and sent at layer 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![OSI Reference Model data encapsulation Each protocol creates a protocol data
    unit (PDU) for transmission, each of which includes headers required by that protocol
    and data to be transmitted. This data becomes the service data unit (SDU) of the
    next layer below it.](httpatomoreillycomsourcenostarchimages287711.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5. OSI Reference Model data encapsulation Each protocol creates a protocol
    data unit (PDU) for transmission, each of which includes headers required by that
    protocol and data to be transmitted. This data becomes the service data unit (SDU)
    of the next layer below it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The message used to communicate information for a particular
    protocol is called its *protocol data unit (PDU)* in OSI model terminology. That
    PDU is passed down to the next lower layer for transmission; since that layer
    is providing the service of handling that PDU, it is called the lower layer''s
    *service data unit (SDU)*. The SDU is encapsulated into that layer''s own PDU
    and, in turn, sent to the next lower layer in the stack, proceeding until the
    physical layer is reached. The process is reversed on the recipient device. In
    summary, a layer N PDU is a layer N-1 SDU, which is *encapsulated* into a layer
    N-1 PDU.'
  prefs: []
  type: TYPE_NORMAL
- en: The "N-1, N-2" stuff makes this seem more difficult than it really is, so let's
    use a real-world (simplified) example instead. TCP operates at layer 4 of the
    OSI model. It transmits messages called *segments* that contain data encapsulated
    from higher-layer protocols. The layer below TCP is IP at layer 3\. It receives
    data from TCP and encapsulates it for transmission.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the formal language of the OSI Reference Model, TCP segments are created
    as layer 4 PDUs. When passed to IP, they are treated as layer 3 SDUs. The IP software
    packages these SDUs into messages called *IP packets* or *IP datagrams*, which
    are layer 3 PDUs. These are passed down to a layer 2 protocol, say Ethernet, which
    treats IP datagrams as layer 2 SDUs, and packages them into layer 2 PDUs (Ethernet
    frames), which are sent on to layer 1\. (Actually, in some technologies, further
    encapsulation even occurs at layer 1 prior to transmission.)
  prefs: []
  type: TYPE_NORMAL
- en: On the receiving device, the process of encapsulation is reversed. The Ethernet
    software inspects the layer 2 PDU (Ethernet frame) and removes from it the layer
    2 SDU (IP datagram), which it passes up to IP as a layer 3 PDU. The IP layer removes
    the layer 3 SDU (TCP segment) and passes it to TCP as a layer 4 PDU. TCP continues
    the process, going back up the protocol layer stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-6](ch05s03.html#osi_reference_model_pdu_and_sdu_encapsul "Figure 5-6. OSI
    Reference Model PDU and SDU encapsulation Each PDU at one layer of the OSI model
    becomes an SDU at the next lower layer and is encapsulated into that layer''s
    PDU.") shows in more detail how OSI PDUs and SDUs are created and encapsulated.
    A TCP segment (layer 4 PDU) becomes a layer 3 SDU, which is encapsulated into
    a layer 3 PDU through the addition of an IP header. This becomes the payload of
    an Ethernet frame, which is a layer 2 PDU containing an Ethernet header, a layer
    2 SDU (the IP datagram), and an Ethernet footer. The receiving device extracts
    the IP datagram from the Ethernet header and passes it to layer 3; the IP software
    extracts the TCP segment and passes it up to the TCP software.'
  prefs: []
  type: TYPE_NORMAL
- en: This whole matter of encapsulation, passing data up and down the protocol stack,
    and so on may seem needlessly complex. It also may appear to be rather inefficient;
    why send a message with so many headers and footers? However, the notion of data
    encapsulation is critical to creating modular, flexible networks.
  prefs: []
  type: TYPE_NORMAL
- en: '![OSI Reference Model PDU and SDU encapsulation Each PDU at one layer of the
    OSI model becomes an SDU at the next lower layer and is encapsulated into that
    layer''s PDU.](httpatomoreillycomsourcenostarchimages287713.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6. OSI Reference Model PDU and SDU encapsulation Each PDU at one layer
    of the OSI model becomes an SDU at the next lower layer and is encapsulated into
    that layer's PDU.
  prefs: []
  type: TYPE_NORMAL
- en: The term *protocol data unit* or PDU is rather formal. You will see it used
    in standards and sometimes in discussions, but more often than not, you'll encounter
    the message terms, such as *frame* and *datagram*, as discussed in [Chapter 1](ch01.html
    "Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES"). Similarly,
    data encapsulated by these messages is not normally called a *service data unit*
    or SDU, but rather simply the *message body* or *payload*, as you saw when you
    looked at message formatting in [Chapter 1](ch01.html "Chapter 1. NETWORKING INTRODUCTION,
    CHARACTERISTICS, AND TYPES"). There are cases, however, for which knowing the
    difference between an SDU and a PDU is important to understanding the technology.
    One example is the IEEE 802.11 physical layer—the 802.11 standards talk about
    SDUs and PDUs constantly!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** See the OSI Reference Model analogy in the "The Benefits
    of Networking Models" section earlier in this chapter for an example that compares
    networking encapsulation to something done in a real-world, nonnetworking context.'
  prefs: []
  type: TYPE_NORMAL
- en: Indirect Device Connection and Message Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the explanations that I have provided in the other sections of this
    chapter have discussed the mechanisms by which machines connect to each other
    over a network *directly*. However, one of the most powerful aspects of networking
    is that it is possible to create internetworks—networks of networks—that allow
    devices to be connected *indirectly*. For example, Machine A may send a message
    to Machine B without really even knowing where it is on the network.
  prefs: []
  type: TYPE_NORMAL
- en: If a message is being sent between devices that are not on the same network,
    then it must be passed between directly connected networks until it reaches its
    final destination. The process of transmitting a message from one network to another
    is called *forwarding*, and the collective process of forwarding from one device
    to another is *routing*. These concepts are fundamental to all internetworking,
    including the Internet itself. Every time you access an Internet resource such
    as a website, you are sending messages that get routed to that site, and the responses
    you receive get routed back.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Even though the technically correct term for moving a message from one network
    to an adjacent network is* forwarding, *over time, the term* routing *has come
    to be used both for a single network-to-network transfer, as well as the overall
    process of transmitting a message from one device to another*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of the OSI Reference Model, routing is an activity that generally
    takes place at the network layer, layer 3\. You''ll recall that data encapsulation
    causes a higher-layer message to be surrounded by headers and footers at the lower
    layers. When a message is routed, here''s what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: A high-level application on a machine decides to send a datagram to a distant
    computer. The datagram is packaged, and then passed down vertically through the
    protocol stack on the originating machine. Each layer encapsulates the data, as
    described in the previous section. The datagram is addressed to the final destination
    device. When the message gets to the lower layers, however, it is not packaged
    for local delivery directly to its ultimate destination, but rather passed to
    an *intermediate device*. This is the device that is responsible for routing to
    that destination network. The message is passed down to the data link and physical
    layers for transmission to that intermediate device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intermediate device (often called a *router*) receives the message at the
    physical layer. It is passed up to the data link layer, where it is processed,
    checked for errors and so on, and the data link layer headers are removed. The
    resulting packet is passed up to the network layer. There, the intermediate device
    determines if the destination machine is on its local network, or if it needs
    to be forwarded to another intermediate device. It then repackages the message
    and passes it back *down* to the data link layer to be sent on the next leg of
    its journey.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After several potential intermediate devices handle the message, it eventually
    reaches its destination. Here, it travels back up the protocol stack until it
    reaches the same layer as the one from the application that generated the message
    on the originating machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key to this description is that in the intermediate devices, the message
    travels back up the OSI layers *only to the network layer*. It is then repackaged
    and sent back along its way. The higher layers are involved only on the source
    and destination devices. The protocol used at layer 3 must be common across the
    internetwork, but each individual network can be different. This demonstrates
    some of the power of layering by enabling even rather dissimilar physical networks
    to be connected together.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-7](ch05s03.html#message_routing_in_the_osi_reference_mod "Figure 5-7. Message
    routing in the OSI Reference Model Routing in the OSI model is accomplished using
    an intermediate device that connects networks at layer 3\. Data passes up to layer
    3 in that device on one network and then passes back down to layer 1 on another.")
    shows how routing is accomplished conceptually in the OSI model. The intermediate
    device connects the networks of the message transmitter and recipient. When data
    is sent, it is passed up to the network layer on the intermediate device, where
    it is repackaged and sent back down the stack for the next leg of its transmission.
    Note that the intermediate device actually has two different layer 1 and 2 implementations—one
    for the interface to each network. Also note that while the layer 3 protocol must
    be the same across the internetwork, each network can use different technologies
    at layers 1 and 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message routing in the OSI Reference Model Routing in the OSI model is accomplished
    using an intermediate device that connects networks at layer 3\. Data passes up
    to layer 3 in that device on one network and then passes back down to layer 1
    on another.](httpatomoreillycomsourcenostarchimages287715.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7. Message routing in the OSI Reference Model Routing in the OSI model
    is accomplished using an intermediate device that connects networks at layer 3\.
    Data passes up to layer 3 in that device on one network and then passes back down
    to layer 1 on another.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In the OSI model, the process of *routing* occurs when data
    is sent not directly from transmitter to ultimate recipient, but indirectly through
    the use of an intermediate system. That device, normally called a *router*, connects
    to two or more physical networks, and thus has multiple interfaces to layer 2\.
    When it receives data, the data passes up only to the network layer, where it
    is repackaged and then sent on the next leg of its journey over the appropriate
    layer 2 interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. OSI REFERENCE MODEL LAYERS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we look at the individual layers of the OSI Reference Model.
    Each layer in the OSI model has certain characteristics that define it, and also
    various protocols normally associated with it. I'll describe how each layer functions
    in the OSI layer stack, outline the specific types of activities for which each
    is normally responsible, and provide some examples of the technologies and protocols
    that reside at each layer. Understanding the nuances of each layer will help you
    understand all the technologies that use them.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, however, that the descriptions in this section are *generic*.
    To really comprehend the details of the various layers and how they are used,
    read the details of the individual protocols that function at each layer later
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *[Chapter 7](ch07.html "Chapter 7. OSI REFERENCE MODEL
    SUMMARY") contains summary information that may be helpful to you in understanding
    the OSI model layers. This includes some common mnemonics for remembering the
    order of the layers and a summary chart for quickly comparing the layers'' key
    characteristics*.'
  prefs: []
  type: TYPE_NORMAL
- en: Physical Layer (Layer 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lowest layer of the OSI Reference Model is layer 1, the *physical layer*;
    it is commonly abbreviated PHY. This layer is the only one where data is physically
    moved across the network interface. All other layers perform functions to create
    messages that implement various protocols, but these messages must all be transmitted
    down the protocol stack to the physical layer, and they are eventually sent out
    over the network.
  prefs: []
  type: TYPE_NORMAL
- en: First, a bit of clarification. The name *physical layer* can be a bit problematic
    because it suggests that this layer relates only to the actual network hardware,
    which is not the case. While some people say that the physical layer is the network
    interface cards and cables, this is not actually true. The physical layer defines
    a number of network functions in addition to interfaces with hardware cables and
    cards.
  prefs: []
  type: TYPE_NORMAL
- en: People also suggest that all network hardware belongs to the physical layer.
    Again, this isn't strictly accurate. All hardware must have *some* relation to
    the physical layer in order to send data over the network, but hardware devices
    generally implement multiple layers of the OSI model in addition to the physical
    layer. For example, an Ethernet network interface card performs functions at both
    the physical layer and the data link layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The physical layer technologies deal with the actual ones and zeros that are
    sent over the network. For example, repeaters, conventional hubs, and transceivers
    all operate at the physical layer. These devices have no knowledge of the contents
    of a message; they simply take input bits and send them as output. The physical
    layer is responsible for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Specifications Definition** The details of operation of cables,
    connectors, wireless radio transceivers, network interface cards, and other hardware
    devices are generally a function of the physical layer (although also partially
    the data link layer, layer 2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding and Signaling** The physical layer is responsible for various encoding
    and signaling functions that transform the data from bits that reside within a
    computer or another device into signals that can be sent over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Transmission and Reception** After encoding the data appropriately,
    the physical layer actually transmits the data, and of course, receives it. (This
    applies equally to wired and wireless networks, even if there is no tangible cable
    in a wireless network.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Topology and Physical Network Design** The physical layer is also considered
    the domain of many hardware-related network design issues, such as local area
    network (LAN) and wide area network (WAN) topology.'
  prefs: []
  type: TYPE_NORMAL
- en: While the physical layer of a network primarily defines the hardware it uses,
    it is also closely related to the data link layer. Thus, it is not generally possible
    to define hardware at the physical layer independently from the technology being
    used at the data link layer. For example, Ethernet is a technology that describes
    specific types of cables and network hardware, but the physical layer of Ethernet
    can be isolated from its data link layer aspects only to a point. Though Ethernet
    cables are the physical layer, the cables' maximum length is related closely to
    message format rules that exist at the data link layer.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, some technologies perform functions at the physical layer that
    are normally more closely associated with the data link layer. For example, it
    is common to have the physical layer perform low-level (bit-level) repackaging
    of data link layer frames for transmission. Error detection and correction may
    also be done at layer 1 in some cases, though most people would consider these
    layer 2 functions.
  prefs: []
  type: TYPE_NORMAL
- en: In many technologies, a number of physical layers can be used with a data link
    layer. The classic example is Ethernet, for which dozens of different physical
    layer implementations exist. Each implementation uses the same data link layer
    (possibly with slight variations).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The lowest layer in the OSI Reference Model is the *physical
    layer*. It is the realm of networking hardware specifications, and is the place
    where technologies that perform data encoding, signaling, transmission, and reception
    functions reside. The physical layer is closely related to the data link layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Many technologies further subdivide the physical layer into *sublayers* in order
    to allow different network media to be supported by the same technology, while
    sharing other functions at the physical layer that are common between the various
    media. A good example of this is the physical layer architecture used for Fast
    Ethernet, Gigabit Ethernet, and 10-Gigabit Ethernet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In some contexts, the physical layer technology that''s used to convey bits
    across a network or communications line is called a* transport method *(not to
    be confused with the OSI transport layer, layer 4)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Data Link Layer (Layer 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second-lowest layer (layer 2) in the OSI Reference Model stack is the *data
    link layer*, often called simply the *link layer*, or abbreviated DLL. The data
    link layer is where many wired and wireless LAN technologies primarily function.
    For example, Ethernet, Token Ring, FDDI, and 802.11 (wireless Ethernet or Wi-Fi)
    are all sometimes called data link layer technologies. The set of devices connected
    at the data link layer is commonly considered a simple network (as opposed to
    an internetwork, which is a collection of networks connected at layer 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'The data link layer is often conceptually divided into two sublayers: *logical
    link control (LLC)* and *media access control (MAC)*. This split is based on the
    architecture used in the IEEE 802 Project, which is the IEEE working group responsible
    for creating the standards that define many networking technologies. By separating
    LLC and MAC functions, interoperability of different network technologies is made
    easier, as explained in the discussion of networking models in [Chapter 5](ch05.html
    "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS").'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key tasks performed at the data link layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical Link Control (LLC)** Logical link control refers to the functions
    required for the establishment and control of logical links between local devices
    on a network. This is usually considered a sublayer; it provides services to the
    network layer above it and hides the rest of the details of the data link layer,
    which allows different technologies to work seamlessly with the higher layers.
    Most LAN technologies use the IEEE 802.2 LLC protocol to implement this part of
    the data link layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Media Access Control (MAC)** This refers to the procedures used by devices
    to control access to the network medium. Since many networks use a shared medium
    (such as a single network cable, or a series of cables that are electrically connected
    into a single virtual medium), it is necessary to have rules for managing the
    medium to avoid conflicts. For example, Ethernet uses the CSMA/CD method of media
    access control, while Token Ring uses token passing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Framing** The data link layer is responsible for data framing, which
    is the final encapsulation of higher-level messages into *frames* that are sent
    over the network at the physical layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Addressing** The data link layer is the lowest layer in the OSI model that
    is concerned with addressing. It labels information with a particular destination
    location. Each device on a network has a unique number that is used by the data
    link layer protocol to ensure that data intended for a specific machine gets to
    it properly. This is usually called a *hardware address* (since it is intimately
    related with low-level hardware) or a *MAC address* (after the MAC function described
    earlier).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error Detection and Handling** The data link layer handles errors that occur
    at the lower levels of the network stack. For example, a cyclic redundancy check
    (CRC) field is often calculated based on the frame''s contents and then included
    in it. This can be employed to allow the station receiving data to detect if it
    was received correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical Layer Standards** The physical layer and the data link layer are
    very closely related. The requirements for the physical layer of a network are
    often part of the data link layer standard that describes a particular technology.
    Certain physical-layer hardware and encoding aspects are specified by the data
    link layer technology being used. The best example of this is the Ethernet standard,
    IEEE 802.3, which specifies not just how Ethernet works at the data link layer,
    but also its various physical layers.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The second OSI Reference Model layer is the *data link layer*.
    This is where most LAN and wireless LAN technologies are defined. Layer 2 is responsible
    for *logical link control (LLC), media access control (MAC)*, hardware addressing,
    error detection and handling, and defining physical layer standards. It is often
    divided into the LLC and MAC sublayers based on the IEEE 802 Project that uses
    that architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Many types of hardware are associated with the data link layer. Network interface
    cards typically implement a specific data link layer technology, so they are often
    called Ethernet cards, Token Ring cards, and so on. There are also a number of
    network interconnection devices that are said to operate at layer 2 in whole or
    in part because they make decisions about what to do with data they receive by
    looking at data link layer frames. These devices include most bridges, switches,
    and brouters, though the latter two also encompass functions performed by layer
    3.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most popular technologies and protocols generally associated with
    layer 2 are Ethernet, Token Ring, FDDI (plus CDDI), HomePNA, IEEE 802.11, Asynchronous
    Transfer Mode (ATM), TCP/IP's Serial Line Interface Protocol (SLIP), and TCP/IP's
    Point-to-Point Protocol (PPP).
  prefs: []
  type: TYPE_NORMAL
- en: Network Layer (Layer 3)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third-lowest layer of the OSI Reference Model is the *network layer*. If
    the data link layer defines the boundaries of what is considered a network, the
    network layer defines how *internetworks* (interconnected networks) function.
    The network layer is the lowest one in the OSI model that is concerned with actually
    getting data from one computer to another even if it is on a remote network; in
    contrast, the data link layer only deals with devices that are local to each other.
  prefs: []
  type: TYPE_NORMAL
- en: While layers 2 through 6 all act as fences between the layers above and below
    them, the network layer is particularly important in terms of separating higher
    and lower-layer functions. It is here that the transition really begins from the
    more abstract functions of the higher layers—which don't concern themselves as
    much with data delivery—into the specific tasks required to get data to its destination.
    (The transport layer continues this abstraction transition as you go up the OSI
    protocol stack.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the specific jobs normally performed by the network layer include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical Addressing** Every device that communicates over a network has a
    logical address associated with it, which identifies the device regardless of
    its particular location. This is sometimes called a *layer 3* address. For example,
    on the Internet, the Internet Protocol (IP) is the network layer protocol and
    every machine has an IP address. Logical addresses are independent of particular
    hardware and must be unique across an entire internetwork.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Addressing is done at the data link layer as well, but those addresses refer
    to local physical devices*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Routing** The defining function of the network layer is routing—moving data
    across a series of interconnected networks. It is the job of the devices and software
    routines that function at the network layer to handle incoming packets from various
    sources, determine their final destination, and then figure out where they need
    to be sent to get them where they are supposed to go. (You''ll find a more complete
    discussion of routing in the OSI model in the section covering indirect device
    connection in [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES
    AND CONCEPTS").)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Datagram Encapsulation** The network layer normally *encapsulates* messages
    received from higher layers by placing them into *datagrams* (also called *packets*)
    with a network layer header (the previous chapter discusses encapsulation).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fragmentation and Reassembly** The network layer must send messages down
    to the data link layer for transmission. Some data link layer technologies limit
    the length of any message that can be sent. If the packet that the network layer
    wants to send is too large, the network layer must split the packet up (fragment
    it), send each piece to the data link layer, and then have the pieces reassembled
    once they arrive at the network layer on the destination machine. The IP is the
    best-known example of a protocol that performs these functions; see [Chapter 22](ch22.html
    "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY") for a discussion
    of IP datagram fragmentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error Handling and Diagnostics** The network layer uses special protocols
    to allow devices that are logically connected (or that are trying to route traffic)
    to exchange information about the status of hosts on the network or the devices
    themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: Network layer protocols offer either connection-oriented or connectionless services
    for delivering packets across the network. Connectionless ones are far more common
    at the network layer. In many protocol suites, the network layer protocol is connectionless,
    and connection-oriented services are provided by the transport layer. For example,
    in TCP/IP, IP is connectionless, while the layer 4 Transmission Control Protocol
    (TCP) is connection-oriented. Connection-oriented and connectionless protocols
    are discussed thoroughly in [Chapter 1](ch01.html "Chapter 1. NETWORKING INTRODUCTION,
    CHARACTERISTICS, AND TYPES").
  prefs: []
  type: TYPE_NORMAL
- en: The most common network layer protocol is IP, which is why I have already mentioned
    it a couple of times. IP is the backbone of the Internet and the foundation of
    the entire TCP/IP protocol suite. There are also several protocols directly related
    to IP that work with it at the network layer, such as IPsec, IP NAT, and Mobile
    IP. The Internet Control Message Protocol (ICMP) is the main error-handling and
    control protocol that is used along with IP. Another notable network layer protocol
    outside the TCP/IP world is the Novell Internetworking Packet Exchange (IPX) protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The OSI Reference Model''s third layer is the *network layer*.
    This is one of the most important layers in the model; it is responsible for the
    tasks that link together individual networks into *internetworks*. Network layer
    functions include internetwork-level addressing, routing, datagram encapsulation,
    fragmentation and reassembly, and certain types of error handling and diagnostics.
    The network layer and transport layer are closely related to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: The network interconnection devices that operate at the network layer are usually
    called *routers*. They are responsible for the routing functions I have mentioned,
    because they receive packets as they are sent along each "hop" of a route and
    send them on the next leg of their trip. They communicate with each other using
    routing protocols in order to determine the best routes for sending traffic efficiently.
    So-called brouters also reside, at least in part, at the network layer, as do
    the rather obviously named layer 3 switches.
  prefs: []
  type: TYPE_NORMAL
- en: Transport Layer (Layer 4)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth layer of the OSI Reference Model protocol stack is the *transport
    layer*, also called the *middle layer*. The transport layer is in some ways part
    of both the lower and upper groups of layers in the OSI model. It is more often
    associated with the lower layers, because it concerns itself with the *transport*
    of data, but its functions are also somewhat high level, resulting in its having
    a fair bit in common with layers 5 through 7 as well.
  prefs: []
  type: TYPE_NORMAL
- en: You'll recall that layers 1 through 3 are concerned with the actual packaging,
    addressing, routing, and delivery of data. The physical layer handles the bits,
    the data link layer deals with local networks, and the network layer handles routing
    between networks. The transport layer, in contrast, is sufficiently conceptual
    that it no longer concerns itself with these nuts-and-bolts matters. It relies
    on the lower layers to move data between devices.
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer acts as a liaison of sorts between the abstract world of
    applications at the higher layers and the concrete functions of layers 1 to 3\.
    Its overall job is to provide the necessary functions to enable communication
    between software application processes on different computers, which encompasses
    a number of different but related duties.
  prefs: []
  type: TYPE_NORMAL
- en: Because modern computers are multitasking, many different software applications
    may be trying to send and receive data to the same machine at any given point.
    The transport layer is charged with providing a means by which these applications
    can all send and receive data using the same lower-layer protocol implementation.
    Thus, it is sometimes said to be responsible for *end-to-end* or *host-to-host*
    transport (in fact, the equivalent layer in the TCP/IP model is called the host-to-host
    transport layer).
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this communication between processes, the transport layer must
    perform several different but related jobs. For transmission, it must track the
    data from each application, then combine it into a single flow of data to send
    to the lower layers. The device receiving information must reverse these operations,
    fragment the data, and funnel it to the appropriate recipient processes. The transport
    layer is also responsible for defining the means by which potentially large amounts
    of application data are fragmented for transmission.
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer is also responsible for providing *connection services*
    for the protocols and applications that run at the levels above it. These can
    be categorized as either connection-oriented services or connectionless services,
    and each has its uses. While connection-oriented services can be handled at the
    network layer, they are more often seen in the transport layer in the real world.
    (Some protocol suites, such as TCP/IP, provide both a connection-oriented and
    a connectionless transport layer protocol that suits the needs of different applications.)
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer is also where functions are normally included for adding
    features to end-to-end data transport. Whereas network layer protocols are normally
    concerned with just "best-effort" communications for which delivery is not guaranteed,
    transport layer protocols are given intelligence in the form of algorithms that
    ensure the reliable and efficient communication between devices. This intelligence
    encompasses several related jobs, including lost transmission detection and handling,
    and managing the rate at which data is sent in order to ensure that the receiving
    device is not overwhelmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transmission quality—ensuring that transmissions are received as sent—is so
    important that some networking books define the transport layer on the basis of
    reliability and flow-control functions. However, not all transport layer protocols
    provide these services. Just as a protocol suite may have a connection-oriented
    and a connectionless transport layer protocol, it may also have one transport
    layer protocol that provides reliability and data management services, and one
    that doesn''t. Again, this is the case with TCP/IP: There is one main transport
    layer protocol, TCP, that includes reliability and flow-control features, and
    a second, User Datagram Protocol (UDP), that doesn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the specific functions often performed at the transport layer
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process-Level Addressing** Addressing at the transport layer is used to differentiate
    between software programs. This is part of what enables many different software
    programs to use a network layer protocol simultaneously. The best example of transport-layer
    process-level addressing is the TCP and UDP port mechanism that''s used in TCP/IP,
    which allows applications to be individually referenced on any TCP/IP device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiplexing and Demultiplexing** Using the process-level addresses, transport
    layer protocols on a sending device *multiplex* the data received from many application
    programs for transport, combining them into a single stream of data to be sent.
    The same protocols receive data and then *demultiplex* it from the incoming stream
    of datagrams, and direct each one to the appropriate recipient application processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Segmentation, Packaging, and Reassembly** The transport layer segments the
    large amounts of data it sends over the network into smaller pieces on the source
    machine, and then reassembles them on the destination machine. This function is
    similar to the fragmentation function of the network layer. Just as the network
    layer fragments messages to fit the limits of the data link layer, the transport
    layer segments messages to suit the requirements of the underlying network layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection Establishment, Management, and Termination** Transport layer connection-oriented
    protocols are responsible for the series of communications required to establish
    a connection, maintain it as data is sent over it, and then terminate the connection
    when it is no longer required.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acknowledgments and Retransmissions** As mentioned earlier, the transport
    layer is where many protocols that guarantee reliable delivery of data are implemented.
    This is done using a variety of techniques, most commonly by combining *acknowledgment*
    and *retransmission timers*. The sending device starts a timer on each occasion
    that data is sent; if the data is received, the recipient sends back an acknowledgment
    to the sender to indicate successful transmission. If no acknowledgment is returned
    before the timer expires, the data is retransmitted. Other algorithms and techniques
    are usually required to support this basic process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow Control** Transport layer protocols that offer reliable delivery also
    often implement *flow-control* features. These features allow one device in a
    communication to specify to another that it must throttle back the rate at which
    it is sending data. This will prevent the receiver from being bogged down with
    data. These features allow mismatches in speed between sender and receiver to
    be detected and handled.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The fourth and middle OSI Reference Model layer is the *transport
    layer*. This layer represents the transition point between the lower layers that
    deal with data delivery issues, and the higher ones that work with application
    software. The transport layer is responsible for enabling *end-to-end communication*
    between application processes, which it accomplishes in part through the use of
    process-level addressing and multiplexing or demultiplexing. Transport layer protocols
    are responsible for segmenting application data into blocks for transmission and
    may be either connection-oriented or connectionless. Protocols at this layer also
    often provide data delivery management services such as reliability and flow control.'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, the transport and network layers are distinct, but in practice, they
    are often very closely related to each other. You can see this easily just by
    looking at the names of common protocol stacks. They are often named after the
    layer 3 and 4 protocols in the suite, thereby implying their close relationship.
    For example, the name TCP/IP comes from the suite's most commonly used transport
    layer protocol (TCP) and network layer protocol (IP). Similarly, the Novell NetWare
    suite is often called IPX/SPX for its layer 3 (IPX) and layer 4 (Sequenced Packet
    Exchange, or SPX) protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, specific transport layer protocols use the network layers in the
    same family. You won't often find a network using the transport layer protocol
    from one suite and the network layer protocol from another. The most commonly
    used transport layer protocols are TCP and UDP in the TCP/IP suite, SPX in the
    NetWare protocol suite, and NetBEUI in the NetBIOS/NetBEUI/NBF suite (though NetBEUI
    is more difficult to categorize).
  prefs: []
  type: TYPE_NORMAL
- en: Session Layer (Layer 5)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fifth layer in the OSI Reference Model is the *session layer*. As you proceed
    up the OSI layer stack from the bottom, the session layer is the first one where
    essentially all practical matters related to the addressing, packaging, and delivery
    of data are left behind; they are functions of layers 4 and below. The session
    layer is the lowest of the three upper layers, which, as a group, are concerned
    mainly with software application issues and not with the details of network and
    internetwork implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name session layer is telling: It is designed to allow devices to establish
    and manage *sessions*. In general terms, a session is a persistent logical linking
    of two software application processes that allows them to exchange data over time.
    In some discussions, these sessions are called *dialogs*, and, in fact, they are
    roughly analogous to a telephone call made between two people.'
  prefs: []
  type: TYPE_NORMAL
- en: Session layer protocols primarily provide the necessary means for setting up,
    managing, and ending sessions. In fact, in some ways, session-layer software products
    resemble sets of tools more than specific protocols. These session-layer tools
    are normally provided to higher-layer protocols through command sets that are
    often called *application program interfaces* or *APIs.*
  prefs: []
  type: TYPE_NORMAL
- en: Common APIs include NetBIOS, TCP/IP Sockets, and Remote Procedure Calls (RPCs).
    APIs allow an application to easily accomplish certain high-level communications
    over the network by using a standardized set of services. Most of these session-layer
    tools are of primary interest to the developers of application software. The programmers
    use the APIs to write software that is able to communicate using TCP/IP without
    developers having to know the implementation details of how TCP/IP works.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Sockets interface lies conceptually at layer 5 and is used
    by TCP/IP application programmers to create sessions between software programs
    over the Internet on the UNIX operating system. Windows Sockets similarly lets
    programmers create Windows software that is Internet capable and able to interact
    easily with other software that uses that interface. (Strictly speaking, Sockets
    is not a protocol, but rather a programming method.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The boundaries between layers start to blur once you get to the session layer.
    This makes it hard to categorize what exactly belongs at layer 5, and some technologies
    really span layers 5 through 7\. In the world of TCP/IP in particular, it is not
    common to identify protocols that are specific to the OSI session layer*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The fifth layer in the OSI Reference Model layer is the *session
    layer*. As its name suggests, it is the layer intended to provide functions for
    establishing and managing sessions between software processes. Session layer technologies
    are often implemented as sets of software tools called *application program interfaces
    (APIs)*, which provide a consistent set of services that allow programmers to
    develop networking applications without needing to worry about lower-level details
    of transport, addressing, and delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The term "session" is somewhat vague, which means that there is sometimes
    disagreement on the specific functions that belong at the session layer, or about
    whether certain protocols belong at the session layer or not. To add to this potential
    confusion, there is the matter of differentiating between a connection and a session.
    Connections are normally the province of layer 4 and layer 3, yet a TCP connection,
    for example, can persist for a long time. The longevity of TCP connections makes
    them hard to distinguish from sessions (and there are some people who feel that
    the TCP/IP host-to-host transport layer really straddles OSI layers 4 and 5)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation Layer (Layer 6)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *presentation layer* is the sixth layer of the OSI Reference Model protocol
    stack and second from the top. It differs from the other layers in two key respects.
    First, it has a much more limited and specific function than the other layers.
    Second, it is used much less often than the other layers and is not required by
    many types of communications.
  prefs: []
  type: TYPE_NORMAL
- en: This layer deals with the *presentation* of data. More specifically, it is charged
    with taking care of any issues that might arise when data sent from one system
    needs to be viewed in a different way by the receiving system. The presentation
    layer also handles any special processing that must be done to data from the time
    an application tries to send it until the time it is sent over the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the specific types of data-handling issues that the presentation
    layer handles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Translation** Many different types of computers can exist on the same network,
    such as PCs, Macs, UNIX systems, AS/400 servers, and mainframes. Each has many
    distinct characteristics and represents data in different ways (with different
    character sets, for example). The presentation layer hides the differences between
    machines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compression** Compression (and decompression) may be done at the presentation
    layer to improve the throughput of data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption** Some types of encryption (and decryption) are performed at the
    presentation layer to ensure the security of the data as it travels down the protocol
    stack. For example, one of the most popular encryption schemes usually associated
    with the presentation layer is the Secure Sockets Layer (SSL) protocol. (Some
    encryption is done at lower layers in the protocol stack in technologies such
    as IPsec.)'
  prefs: []
  type: TYPE_NORMAL
- en: The presentation layer is not always used in network communications because
    these functions mentioned are simply not always needed. Compression and encryption
    are usually considered optional, and translation features are needed only in certain
    circumstances. Also, the presentation layer's functions may be performed at the
    application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Since its translation job isn''t always needed, the presentation layer is
    commonly skipped by actual protocol stack implementations; in such implementations
    protocols at layer 7 may talk directly with those at layer 5\. This is part of
    the reason why all of the functions at layers 5 through 7 may be included in the
    same software package, as described in the overview of layers and layer groupings
    in the previous chapter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The sixth OSI model layer is the *presentation layer*. Protocols
    at this layer take care of manipulation tasks that transform data from one representation
    to another, such as translation, compression, and encryption. In many cases, no
    such functions are required in a particular networking stack; if so, there may
    not be any protocol active at layer 6, so layer 7 may deal with layer 5.'
  prefs: []
  type: TYPE_NORMAL
- en: Application Layer (Layer 7)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the very top of the OSI Reference Model stack of layers, you find layer 7,
    the *application layer*. Continuing the trend that you saw in layers 5 and 6,
    this one is also named very appropriately. The application layer is the one that
    is used by network applications. These programs are what actually implement the
    functions performed by users to accomplish various tasks over the network.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that what the OSI model calls an application is
    not exactly the same as what you normally think of as an application. In the OSI
    model, the application layer provides services for user applications to employ.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you use your web browser, that actual software is an application
    running on your PC. It doesn't really reside at the application layer. Rather,
    it makes use of the services offered by a protocol that operates at the application
    layer, which is called the Hypertext Transfer Protocol (HTTP). The distinction
    between the browser and HTTP is subtle but important.
  prefs: []
  type: TYPE_NORMAL
- en: Not all user applications use the network's application layer in the same way.
    Sure, your web browser, email client, and Usenet newsreader do, but if you open
    a file over the network with a text editor, that editor is not using the application
    layer—it just sees a file addressed with a name that has been mapped to a network
    somewhere else. The operating system redirects what the editor does, over the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, not all uses of the application layer are by applications. The operating
    system itself can (and does) use services directly at the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: That caveat aside, under normal circumstances, whenever you interact with a
    program on your computer that is designed specifically for use on a network, you
    are dealing directly with the application layer. For example, sending an email
    message, firing up a web browser, and using a chat program involve protocols that
    reside at the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*There are dozens of different application layer protocols. Some of the most
    popular ones include HTTP, FTP, SMTP, DHCP, NFS, Telnet, SNMP, POP3, NNTP, and
    IRC. I describe all of these and more in Section III*.'
  prefs: []
  type: TYPE_NORMAL
- en: As the top-of-the-stack layer, the application layer is the only one that does
    not provide any services to the layer above it in the stack—there isn't one! Instead,
    it provides services to programs that want to use the network, and to you, the
    user. So the responsibilities at this layer are simply to implement the functions
    that are needed by users of the network and to issue the appropriate commands
    to make use of the services provided by the lower layers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *application layer* is the seventh and highest layer in
    the OSI Reference Model. Application protocols that implement specific user applications
    and other high-level functions are defined at this layer. Since they are at the
    top of the stack, application protocols are the only ones that do not provide
    services to a higher layer; they use services provided by the layers below.'
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen, the distinctions between the top three layers in the OSI Model
    are not very clear. In the case of TCP/IP, this is exacerbated by the decision
    not to separate out the session, presentation, and application layer functions.
    All of the protocols mentioned earlier are from the TCP/IP protocol family, and
    some may cover all three of the top three OSI layers, two of them, or one; in
    the TCP/IP model, they are all just considered applications.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. OSI REFERENCE MODEL SUMMARY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Many students of networking find the OSI Reference Model challenging to deal
    with. One main reason for this is that the model is somewhat *abstract*, making
    it hard to understand and even more difficult to apply to real networking situations.
    For this reason, I have included in this chapter a set of three tools that I hope
    will help you better understand and remember the OSI Reference Model''s and concepts:
    an analogy, a set of mnemonics, and a summary table of OSI model layers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the OSI Model: An Analogy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have attempted in this discussion of the OSI Reference Model to provide as
    much a plain English explanation of how it works as possible. However, there are
    situations in which a good analogy can accomplish what lots of descriptions cannot.
    So I am going to illustrate the key OSI model concepts by way of a real-life analogy.
    You can be the judge of whether it is a *good* analogy or not. Just remember that
    no analogy is perfect!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our scenario seems relatively simple and common: The CEO of a Fortune 500 company
    needs to send a letter to the CEO of another company. Simple, right? Just like
    firing up your web browser and connecting to your favorite website is simple.
    However, in both cases, a lot goes on behind the scenes to make the communication
    happen. In the analogy shown in [Table 7-1](ch07.html#osi_reference_model_real-world_analogy
    "Table 7-1. OSI Reference Model Real-World Analogy"), I compare these real-world
    and cyber-world communications.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1. OSI Reference Model Real-World Analogy
  prefs: []
  type: TYPE_NORMAL
- en: '| Phase | OSI Layer | CEO Letter | Website Connection (Simplified) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Transmission | 7 | The CEO of a company in Phoenix decides he needs to send
    a letter to a peer in Albany. He dictates the letter to his administrative assistant.
    | You decide you want to connect to the web server at IP address 10.0.12.34, which
    is within your organization but not on your local network. You type the address
    into your browser. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 6 | The administrative assistant transcribes the dictation into writing.
    | With a website connection, nothing usually happens here. Format translation
    may be done in some cases. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 5 | The administrative assistant puts the letter in an envelope and gives
    it to the mail room. The assistant doesn''t actually know how the letter will
    be sent, but knows it is urgent, so he says, "Get this to its destination quickly."
    | The request is sent via a call to an API, which issues the command necessary
    to contact the server at that address. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 4 | The mail room must decide how to get the letter where it needs to
    go. Since it is a rush, the people in the mail room decide to give the envelope
    to a courier company to send. | TCP is used to create a segment that will be sent
    to IP address 10.0.12.34. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | The courier company receives the envelope, but it needs to add its
    own handling information, so it places the smaller envelope in a courier envelope
    (encapsulation). The courier then consults its airplane route information and
    determines that to get this envelope to Albany, it must be flown through its hub
    in Chicago. It hands this envelope to the workers who load packages on its planes.
    | Your computer creates an IP datagram encapsulating the TCP datagram created
    earlier. It then addresses the packet to 10.0.12.34, but discovers that it is
    not on its local network. Instead, it realizes it needs to send the message to
    its designated routing device at IP address 10.0.43.21\. It hands the packet to
    the driver for your Ethernet card (the software that interfaces to the Ethernet
    hardware). |'
  prefs: []
  type: TYPE_TB
- en: '| Routing | 2 | The workers take the courier envelope and put a tag on it with
    the code for Chicago. They then put it in a handling box and load it on the plane
    to Chicago. | The Ethernet card driver forms a frame containing the IP datagram
    and prepares it to be sent over the network. It packages the message and puts
    the address 10.0.43.21 (for the router) in the frame. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1 | The plane flies to Chicago. | The frame is sent over the twisted-pair
    cable that connects your local area network. (I''m ignoring overhead, collisions,
    and so on, here, but then I also ignored the possibility of collisions with the
    plane.) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2 | In Chicago, the box is unloaded, and the courier envelope is removed
    from it and given to the people who handle routing in Chicago. | The Ethernet
    card at the machine with IP address 10.0.43.21 receives the frame, strips off
    the frame headers, and hands it up to the network layer. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | The tag marked "Chicago" is removed from the outside of the courier
    envelope. The envelope is then given back to the airplane workers to be sent to
    Albany. | The IP datagram is processed by the router, which realizes the destination
    (10.0.12.34) can be reached directly. It passes the datagram back down to the
    Ethernet driver. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2 | The envelope is given a new tag with the code for Albany, placed
    in another box, and loaded on the plane to Albany. | The Ethernet driver creates
    a new frame and prepares to send it to the device that uses IP address 10.0.12.34.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1 | The plane flies to Albany. | The frame is sent over the network.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2 | The box is unloaded, and the courier envelope is removed from the
    box. It is given to the Albany routing office. | The Ethernet card at the device
    with IP address 10.0.12.34 receives the frame, strips off the headers, and passes
    it up the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| Reception | 3 | The courier company in Albany sees that the destination is
    in Albany and delivers the envelope to the destination CEO''s company. | The IP
    headers are removed from the datagram, and the TCP segments are handed up to TCP.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 4 | The mail room removes the inner envelope from the courier envelope
    and delivers it to the destination CEO''s assistant. | TCP removes its headers
    and hands the data up to the drivers on the destination machine. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 5 | The assistant takes the letter out of the envelope. | The request
    is sent to the web-server software for processing. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 6 | The assistant reads the letter and decides whether to give the letter
    to the CEO, transcribe it to email, call the CEO on her cell phone, or whatever.
    | Again, in this example nothing probably happens at the presentation layer. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 7 | The second CEO receives the message that was sent by the first one.
    | The web server receives and processes the request. |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the processes have a fair bit in common. The vertical communication
    and encapsulation are pretty obvious, as is the routing. Also implied is the horizontal
    communication that occurs logically—the two CEOs seem to be "connected" despite
    all that happens to enable this to occur. Similarly, in a way, the two assistants
    are logically connected as well, even though they never actually converse. Of
    course, this example is highly simplified in just about every way imaginable,
    so please don't use it as a way of trying to learn about how TCP/IP works—or courier
    services, for that matter!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remembering the OSI Model Layers: Some Mnemonics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you spend any amount of time at all dealing with networking design or implementation
    issues, or learning about how the various protocols operate, the names and numbers
    of the various layers will eventually become second nature.
  prefs: []
  type: TYPE_NORMAL
- en: Many people, however, especially those just learning about networks, find it
    difficult to recall the names of all the layers, and especially, their exact order.
    For these people, a number of mnemonics have been created as memory aids. You
    probably remember mnemonics from elementary school. These are cute phrases in
    which each word starts with the first letter of an OSI model layer, arranged in
    the correct order. Some of these go in ascending layer number order, and some
    go in the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two go from physical layer to application layer:'
  prefs: []
  type: TYPE_NORMAL
- en: Please Do Not Throw Sausage Pizza Away
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please Do Not Touch Steve's Pet Alligator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And these go the other direction, from application to physical:'
  prefs: []
  type: TYPE_NORMAL
- en: All People Seem To Need Data Processing (a popular one)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All People Standing Totally Naked Don't Perspire (hmm, that's interesting!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For your convenience, I have illustrated all four of these in [Figure 7-1](ch07s02.html#osi_reference_model_mnemonics_these_mnem
    "Figure 7-1. OSI Reference Model mnemonics These mnemonics may help you to remember
    the order of the OSI Reference Model layers.").
  prefs: []
  type: TYPE_NORMAL
- en: '![OSI Reference Model mnemonics These mnemonics may help you to remember the
    order of the OSI Reference Model layers.](httpatomoreillycomsourcenostarchimages287717.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1. OSI Reference Model mnemonics These mnemonics may help you to remember
    the order of the OSI Reference Model layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or try my own creation: All People Should Teach Networking Daily Please.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarizing the OSI Model Layers: A Summary Chart'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To assist you in quickly comparing the layers of the OSI Reference Model, and
    understanding where they are different and how they relate to each other, I'm
    offering you the summary chart shown in [Table 7-2](ch07s03.html#osi_reference_model_layer_summary
    "Table 7-2. OSI Reference Model Layer Summary"). It shows each layer's name and
    number, describes its key responsibilities, talks about what type of data is generally
    handled at each layer, and also describes the scope of each layer in approximate
    terms. I also show some of the more common protocols that are associated with
    each layer.
  prefs: []
  type: TYPE_NORMAL
- en: The standard disclaimers still apply to this table. Namely, the layers aren't
    always hard-fast; I haven't listed every single protocol here, so some may really
    fit into more than one layer, and so on. In particular, note that many of the
    technologies listed as being in the data link layer are there because that is
    the layer where their primary functionality resides. In reality, most of these
    technologies include components in other layers, especially the physical layer.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2. OSI Reference Model Layer Summary
  prefs: []
  type: TYPE_NORMAL
- en: '| Group | # | Layer Name | Key Responsibilities | Data Type Handled | Scope
    | Common Protocols and Technologies |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Lower Layers | 1 | Physical | Encoding and signaling; physical data transmission;
    hardware specifications; topology and design | Bits | Electrical or light signals
    sent between local devices | Physical layers of most of the technologies listed
    for the data link layer |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2 | Data Link | Logical link control; media access control; data framing;
    addressing; error detection and handling; defining requirements of physical layer
    | Frames | Low-level data messages between local devices | IEEE 802.2 LLC, Ethernet
    family; Token Ring; FDDI and CDDI; IEEE 802.11 (WLAN, Wi-Fi); HomePNA; HomeRF;
    ATM; SLIP and PPP |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | Network | Logical addressing; routing; datagram encapsulation; fragmentation
    and reassembly; error handling and diagnostics | Datagrams/packets | Messages
    between local or remote devices | IP; IPv6; IP NAT; IPsec; Mobile IP; ICMP; IPX;
    DLC; PLP; routing protocols such as RIP and BGP |'
  prefs: []
  type: TYPE_TB
- en: '|   | 4 | Transport | Process-level addressing; multiplexing/demultiplexing;
    connections; segmentation and reassembly; acknowledgments and retransmissions;
    flow control | Datagrams/segments | Communication between software processes |
    TCP and UDP; SPX; NetBEUI/NBF |'
  prefs: []
  type: TYPE_TB
- en: '| Upper Layers | 5 | Session | Session establishment, management, and termination
    | Sessions | Sessions between local or remote devices | NetBIOS, Sockets, named
    pipes, RPC |'
  prefs: []
  type: TYPE_TB
- en: '|   | 6 | Presentation | Data translation; compression and encryption | Encoded
    user data | Application data representations | SSL; shells and redirectors; MIME
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 7 | Application | User application services | User data | Application
    data | DNS; NFS; BOOTP; DHCP; SNMP; RMON; FTP; TFTP; SMTP; POP3; IMAP; NNTP; HTTP;
    Telnet |'
  prefs: []
  type: TYPE_TB
