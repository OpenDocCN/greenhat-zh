- en: Part V. Real-World Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五部分。实际应用
- en: Chapter 20. Compiler Personalities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章。编译器个性
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: At this point, if we have done our job properly, you now possess the essential
    skills to use IDA effectively and, more important, to bend it to your will. The
    next step, young grasshopper, is to learn to react to the ninja stars that binaries
    (as opposed to IDA) will throw at you. Depending on your motives for staring at
    assembly language, you may be very familiar with what you are looking at, or you
    may never know what you are going to be faced with. If you happen to spend all
    of your time examining code that was compiled using gcc on a Linux platform, you
    may become quite familiar with the style of code that it generates. On the other
    hand, if someone dropped a debug version of a program compiled using Microsoft
    Visual C++ (VC++) in your lap, you might be completely baffled. Malware analysts
    in particular are faced with a wide variety of code to examine. Setting aside
    the topic of obfuscation for the moment, malware analysts are likely to see code
    created using Visual Basic, Delphi, and Visual C/C++; machine language blobs embedded
    within documents; and more all in the same afternoon.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果我们已经正确地完成了我们的工作，你现在已经拥有了使用IDA有效使用的基本技能，更重要的是，能够按照你的意愿来操控它。下一步，年轻的跳蚤，是学习如何应对二进制（与IDA相反）向你投来的忍者飞镖。根据你盯着汇编语言的原因，你可能非常熟悉你所看到的内容，或者你可能永远不知道你将面临什么。如果你碰巧把所有的时间都花在检查使用gcc在Linux平台上编译的代码上，你可能会非常熟悉它生成的代码风格。另一方面，如果有人在你面前放下了一个使用Microsoft
    Visual C++（VC++）编译的程序的调试版本，你可能会感到完全困惑。特别是恶意软件分析师面临着要检查的代码种类繁多。暂时不谈混淆的话题，恶意软件分析师可能会看到使用Visual
    Basic、Delphi和Visual C/C++创建的代码；文档中嵌入的机器语言块；以及更多，这一切都在同一个下午发生。
- en: In this chapter we will take a brief look at some of the ways that compilers
    differ as viewed through the IDA looking glass. The intent is not to delve into
    why compilers differ; rather, we hope to cover some of the ways that those differences
    manifest themselves in disassembly listings and how you may resolve those differences.
    Among other things, the compiler and associated options used to build a particular
    piece of software constitute one data point in profiling the author of that software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要地看看通过IDA的视角来看编译器之间的一些差异。我们的意图不是深入探讨为什么编译器会有差异；相反，我们希望涵盖一些这些差异如何在反汇编列表中体现，以及你如何解决这些差异。在其他方面，用于构建特定软件的编译器和相关选项构成了分析该软件作者的一个数据点。
- en: While a wide variety of compilers are available for a wide variety of languages,
    in this chapter we will primarily utilize compiled C code for our examples, as
    a large number of C compilers are available for a large number of platforms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有各种各样的编译器可以用于各种语言，但在本章中，我们将主要使用编译后的C代码作为我们的示例，因为许多平台都有大量的C编译器可用。
- en: Jump Tables and Switch Statements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳转表和switch语句
- en: The C `switch` statement is a frequent target for compiler optimizations. The
    goal of these optimizations is to match the switch variable to a valid case label
    in the most efficient manner possible. The means by which this is achieved typically
    depends on the nature of the `switch` statement’s case labels. When the case labels
    are widely spread, as in the following example, most compilers generate code to
    perform a binary search ^([[140](#ftn.CHP-20-FN-1)])to match the switch variable
    against one of the cases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C的`switch`语句是编译器优化的常见目标。这些优化的目标是尽可能高效地匹配switch变量到一个有效的case标签。实现这一目标的方式通常取决于`switch`语句的情况标签的性质。当情况标签分布广泛时，如以下示例所示，大多数编译器会生成代码以执行二分搜索^([[140](#ftn.CHP-20-FN-1)))来匹配switch变量与其中一个情况。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When case labels are closely clustered, preferably sequentially as shown here,
    compilers generally resolve the switch variable by performing a table lookup^([[141](#ftn.CHP-20-FN-2)])
    to match the switch variable to the address of its associated case.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当情况标签紧密聚集时，最好是像这里显示的按顺序聚集，编译器通常通过执行表查找^([[141](#ftn.CHP-20-FN-2)])来解析switch变量，以匹配switch变量与其关联的情况的地址。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A compiled example of a `switch` statement that matches the switch variable
    against the consecutive cases 1 through 12 is shown here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了匹配switch变量与连续情况1到12的`switch`语句的编译示例：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example was compiled using the Borland command-line compiler, which IDA
    well understands. The comments, which IDA inserted during the analysis phase,
    demonstrate that IDA has a clear understanding that this is a `switch` statement.
    In this example we note that IDA recognizes the switch test ![](httpatomoreillycomsourcenostarchimages854061.png),
    the jump table ![](httpatomoreillycomsourcenostarchimages854063.png), and individual
    cases by value ![](httpatomoreillycomsourcenostarchimages854093.png) within the
    code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用Borland命令行编译器编译，IDA非常了解。IDA在分析阶段插入的注释表明，IDA清楚地理解这是一个`switch`语句。在这个例子中，我们注意到IDA识别了代码中的跳转测试
    ![链接](httpatomoreillycomsourcenostarchimages854061.png)，跳转表 ![链接](httpatomoreillycomsourcenostarchimages854063.png)，以及通过值识别的单独案例
    ![链接](httpatomoreillycomsourcenostarchimages854093.png)。
- en: As a side note on the use of jump tables to resolve switch cases, note that
    the table in the previous example contains 13 entries, while the `switch` statement
    is known to test cases 1 through 12 only. In this case, the compiler elected to
    include an entry for case 0 rather than treating 0 as a special case. The destination
    for case 0 ![](httpatomoreillycomsourcenostarchimages854095.png) is the same as
    the destination for every other value outside the range of 1 to 12 ![](httpatomoreillycomsourcenostarchimages854099.png).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用跳转表来解决`switch`案例的附加说明，请注意，前一个示例中的表包含13个条目，而`switch`语句已知仅测试案例1到12。在这种情况下，编译器选择包含一个针对案例0的条目，而不是将0视为特殊案例。案例0的目标与1到12范围之外的所有其他值的目标相同
    ![链接](httpatomoreillycomsourcenostarchimages854095.png) ![链接](httpatomoreillycomsourcenostarchimages854099.png)。
- en: A final implementation note concerns the nature of the test performed on the
    switch variable. For readers less familiar with the x86 instruction set, the test
    ![](httpatomoreillycomsourcenostarchimages854061.png) and the associated jump
    in the succeeding line may appear only to exclude values larger than 12 while
    failing to account for negative values. If true, this could be disastrous, as
    using a negative index into the jump table might lead to unintended consequences.
    Fortunately, the `ja` (jump above) instruction treats comparisons as if they were
    performed on unsigned values; thus `−1` (`0xFFFFFFFF`) would be seen as `4294967295`,
    which is much larger than 12 and therefore excluded from the valid range for indexing
    the jump table.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个实现注意事项是关于对`switch`变量进行的测试的性质。对于不太熟悉x86指令集的读者来说，测试 ![链接](httpatomoreillycomsourcenostarchimages854061.png)
    和后续行中相关的跳转可能看起来只是排除了大于12的值，而没有考虑到负值。如果这是真的，那么可能会造成灾难性的后果，因为使用跳转表中的负索引可能会导致意外的后果。幸运的是，`ja`（跳转以上）指令将比较视为在无符号值上执行；因此
    `-1` (`0xFFFFFFFF`) 会被视为 `4294967295`，这比12大得多，因此被排除在跳转表索引的有效范围之外。
- en: 'The same source code compiled using Microsoft Visual C++ results in the disassembly
    listing shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Microsoft Visual C++编译的相同源代码导致以下反汇编列表：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Several differences are apparent when comparing this code with the code generated
    by the Borland compiler. One obvious difference is that the jump table has been
    relocated to space immediately following the function containing the `switch`
    statement (as opposed to being embedded within the function itself in the case
    of the Borland code). Other than providing a cleaner separation of code and data,
    relocating the jump table in this manner has little effect on the behavior of
    the program. Despite the different layout of the code, IDA remains capable of
    annotating the key features of the `switch` statement, including the number of
    cases and the code blocks associated with each case.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与Borland编译器生成的代码相比，有几个明显的差异。一个明显的差异是跳转表已经被移动到包含`switch`语句的函数之后的立即空间（与Borland代码中将跳转表嵌入函数本身的情况相反）。除了提供代码和数据之间更清晰的分离之外，以这种方式重新定位跳转表对程序的行为影响很小。尽管代码布局不同，IDA仍然能够注释`switch`语句的关键特性，包括案例数量以及与每个案例关联的代码块。
- en: A few of the implementation details of the `switch` statement include the fact
    that the switch variable (`var_8` in this case) is decremented ![](httpatomoreillycomsourcenostarchimages854061.png)
    to shift the range of valid values to 0 through 11 ![](httpatomoreillycomsourcenostarchimages854063.png),
    allowing the variable to be used directly as an index into the jump table ![](httpatomoreillycomsourcenostarchimages854093.png)
    without the need to create a dummy slot for the unused case 0\. As a result, the
    first entry (or zero index entry) ![](httpatomoreillycomsourcenostarchimages854095.png)
    in the jump table actually refers to the code for switch case 1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的实现细节中包括这样一个事实，即switch变量（在这个例子中是`var_8`）被递减![图片链接](httpatomoreillycomsourcenostarchimages854061.png)以将有效值的范围移至0到11![图片链接](httpatomoreillycomsourcenostarchimages854063.png)，从而使变量可以直接用作跳转表的索引![图片链接](httpatomoreillycomsourcenostarchimages854093.png)，无需为未使用的case
    0创建一个虚拟槽位。因此，跳转表中的第一个条目（或零索引条目）![图片链接](httpatomoreillycomsourcenostarchimages854095.png)实际上指的是switch
    case 1的代码。'
- en: 'Rounding out our comparison of `switch` statements is the following code generated
    by gcc:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将比较`switch`语句的gcc生成的以下代码：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code bears some similarities to the Borland code as seen by the comparison
    to 12 ![](httpatomoreillycomsourcenostarchimages854061.png), the jump table ![](httpatomoreillycomsourcenostarchimages854063.png)
    that contains 13 entries, and the use of a pointer to the default case ![](httpatomoreillycomsourcenostarchimages854093.png)
    in the case 0 slot of the jump table. As in the Borland code, the address for
    the case 1 handler ![](httpatomoreillycomsourcenostarchimages854095.png) can be
    found at index 1 into the jump table. Notable differences between the gcc code
    and previous examples include a different style of executing the jump ![](httpatomoreillycomsourcenostarchimages854099.png)
    and the fact that the jump table is stored in the read-only data (`.rdata`) section
    of the binary, providing a logical separation between the code associated with
    the `switch` statement and the data required to implement the `switch` statement.
    As in the other two examples, IDA is able to locate and annotate the key elements
    of the switch statement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与Borland代码有一些相似之处，这可以从与12![图片链接](httpatomoreillycomsourcenostarchimages854061.png)的比较中看出，包含13个条目的跳转表![图片链接](httpatomoreillycomsourcenostarchimages854063.png)，以及在跳转表的case
    0槽位中使用指向默认情况的指针![图片链接](httpatomoreillycomsourcenostarchimages854093.png)。与Borland代码一样，case
    1处理器的地址可以在跳转表的索引1处找到。gcc代码与之前的示例之间的显著差异包括执行跳转的不同风格![图片链接](httpatomoreillycomsourcenostarchimages854099.png)以及跳转表存储在二进制的只读数据（`.rdata`）部分，在`switch`语句的代码和数据之间提供了逻辑上的分离。与其他两个示例一样，IDA能够定位并注释switch语句的关键元素。
- en: One of the points we are making here is that there is no single correct way
    to compile source to assembly. Familiarity with code generated by a specific compiler
    in no way guarantees that you will recognize high-level constructs compiled using
    an entirely different compiler (or even different versions of the same compiler
    family). More important, do not assume that something is not a `switch` statement
    simply because IDA fails to add comments to that effect. Like you, IDA is more
    familiar with the output of some compilers than others. Rather than relying entirely
    on IDA’s analysis capabilities to recognize commonly used code and data constructs,
    you should always be prepared to utilize your own skills—your familiarity with
    a given assembly language, your knowledge of compilers, and your research skills—to
    properly interpret a disassembly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要强调的一个观点是，将源代码编译成汇编代码并没有一种唯一正确的方法。熟悉特定编译器生成的代码并不能保证您能识别出完全使用不同编译器（甚至同一编译器家族的不同版本）编译的高级结构。更重要的是，不要仅仅因为IDA未能添加相应的注释就假设某项内容不是`switch`语句。与您一样，IDA对某些编译器的输出比对其他编译器的输出更熟悉。与其完全依赖IDA的分析能力来识别常用的代码和数据结构，您应该始终准备好利用自己的技能——您对特定汇编语言的熟悉程度、对编译器的了解以及您的研究能力——来正确解释反汇编代码。
- en: '* * *'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[140](#CHP-20-FN-1)]) For you algorithmic analysis fans, this means that
    the switch variable is matched after at most log-[2]*N* operations, where *N*
    is the number of cases contained in the `switch` statement.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[140](#CHP-20-FN-1)]) 对于喜欢算法分析的您来说，这意味着switch变量最多经过log-2*N*次操作后就能匹配，其中*N*是`switch`语句中包含的case数量。
- en: ^([[141](#CHP-20-FN-2)]) Again for those analyzing algorithms at home, the use
    of a table lookup allows the target case to be found in a single operation, which
    you may recall from your algorithms class is also called *constant time* or *O(1)*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[141](#CHP-20-FN-2)]) 对于在家分析算法的读者来说，使用表查找可以在一次操作中找到目标情况，你可能还记得，在算法课程中这被称为
    *常数时间* 或 *O(1)*。
- en: RTTI Implementations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTTI 实现
- en: In [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures") we discussed
    C++ Runtime Type Identification (RTTI) and the fact that no standard exists for
    the manner in which RTTI is implemented by a compiler. Automatic recognition of
    RTTI-related constructs within a binary is another area in which IDA’s capabilities
    vary across compilers. Not surprisingly, IDA’s capabilities in this area are strongest
    with binaries compiled using Borland compilers. Readers interested in automated
    recognition of Microsoft RTTI data structures may want to try Igor Skochinsky’s
    IDC script available at The IDA Palace^([[142](#ftn.CHP-20-FN-3)]) or the Class
    Informer plug-in by Sirmabus,^([[143](#ftn.CHP-20-FN-4)]) which will be discussed
    further in [Chapter 23](ch23.html "Chapter 23. Real-World IDA Plug-ins").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.html "第 8 章。数据类型和数据结构") 中，我们讨论了 C++ 运行时类型识别（RTTI）以及没有标准存在来规定编译器如何实现
    RTTI 的实现方式。在二进制文件中自动识别 RTTI 相关结构是 IDA 功能随编译器而变化的另一个领域。不出所料，IDA 在这个领域的功能在用 Borland
    编译器编译的二进制文件中是最强的。对自动识别 Microsoft RTTI 数据结构感兴趣的读者可以尝试在 IDA Palace 上可用的 Igor Skochinsky
    的 IDC 脚本^([[142](#ftn.CHP-20-FN-3)]) 或 Sirmabus 的 Class Informer 插件^([[143](#ftn.CHP-20-FN-4)]），这些将在
    [第 23 章](ch23.html "第 23 章。现实世界的 IDA 插件") 中进一步讨论。
- en: A simple strategy for understanding how a specific compiler embeds type information
    for C++ classes is to write a basic program that makes use of classes containing
    virtual functions. After compiling the program, you can load the resulting executable
    into IDA and search for instances of strings that contain the names of classes
    used in the program. Regardless of the compiler used to build a binary, one thing
    that RTTI data structures have in common is that they all contain a pointer to
    a string containing the name of the class that they represent. Using data cross-references,
    it should be possible to locate a pointer to one such string, thus locating candidate
    RTTI data structures. The last step is to link a candidate RTTI structure back
    to the associated class’s vtable, which is best accomplished by following data
    cross-references backward from a candidate RTTI structure until a table of function
    pointers (the vtable) is reached.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理解特定编译器如何为 C++ 类嵌入类型信息的简单策略是编写一个使用包含虚拟函数的类的基本程序。编译程序后，你可以将生成的可执行文件加载到 IDA 中，并搜索包含程序中使用的类名的字符串实例。无论使用哪种编译器构建二进制文件，RTTI
    数据结构都具有一个共同点，即它们都包含一个指向表示其类名的字符串的指针。使用数据交叉引用，应该能够定位到这样一个字符串的指针，从而定位候选 RTTI 数据结构。最后一步是将候选
    RTTI 结构链接回相关类的 vtable，这最好通过从候选 RTTI 结构反向跟踪数据交叉引用，直到到达函数指针表（vtable）来实现。
- en: '* * *'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[142](#CHP-20-FN-3)]) See [http://old.idapalace.net/idc/ms_rtti.zip](http://old.idapalace.net/idc/ms_rtti.zip).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[142](#CHP-20-FN-3)]) 见 [http://old.idapalace.net/idc/ms_rtti.zip](http://old.idapalace.net/idc/ms_rtti.zip)。
- en: ^([[143](#CHP-20-FN-4)]) See [http://www.openrce.org/blog/browse/Sirmabus](http://www.openrce.org/blog/browse/Sirmabus).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[143](#CHP-20-FN-4)]) 见 [http://www.openrce.org/blog/browse/Sirmabus](http://www.openrce.org/blog/browse/Sirmabus)。
- en: Locating main
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位 main
- en: If you were fortunate enough to have source code available for a C/C++ program
    that you wanted to analyze, a good place to begin your analysis might be the `main`
    function, as this is where execution notionally begins. When faced with analyzing
    a binary, this is not a bad strategy to follow. However, as we know, it is complicated
    by the fact that compilers/linkers (and the use of libraries) add additional code
    that executes before `main` is reached. Thus it would often be incorrect to assume
    that the entry point of a binary corresponds to the `main` function written by
    the program’s author.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很幸运，可以获取你想要分析的一个 C/C++ 程序的源代码，分析的开始可能从 `main` 函数开始，因为这是执行概念上开始的地方。当面对分析二进制文件时，这是一个不错的策略。然而，正如我们所知，由于编译器/链接器（以及库的使用）在达到
    `main` 之前添加了额外的代码，这使得分析变得复杂。因此，通常假设二进制文件的入口点对应于程序作者编写的 `main` 函数是不正确的。
- en: In fact, the notion that all programs have a `main` function is a C/C++ compiler
    convention rather than a hard-and-fast rule for writing programs. If you have
    ever written a Windows GUI application, then you may be familiar with the `WinMain`
    variation on `main`. Once you step away from C/C++, you will find that other languages
    use other names for their primary entry-point function. Regardless of what it
    may be called, we will refer to this function generically as the `main` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，所有程序都有一个`main`函数的观念是C/C++编译器的惯例，而不是编写程序的硬性规则。如果你曾经编写过Windows GUI应用程序，那么你可能对`main`的`WinMain`变体很熟悉。一旦你离开C/C++，你会发现其他语言为它们的入口点函数使用其他名称。无论它被称为什么，我们都会泛称这个函数为`main`函数。
- en: '[Chapter 12](ch12.html "Chapter 12. Library Recognition Using FLIRT Signatures")
    covered the concept of IDA signature files, their generation, and their application.
    IDA utilizes special startup signatures to attempt to identify a program’s `main`
    function. When IDA is able to match a binary’s startup sequence against one of
    the startup sequences in its signature files, IDA can locate a program’s `main`
    function based on its understanding of the behavior of the matched startup routine.
    This works great until IDA fails to match the startup sequence in a binary to
    any of its known signatures. In general, a program’s startup code is closely tied
    to both the compiler used to generate the code and the platform for which the
    code was built.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。使用FLIRT签名识别库")介绍了IDA签名文件的概念、它们的生成及其应用。IDA使用特殊的启动签名来尝试识别程序的`main`函数。当IDA能够将二进制文件的启动序列与签名文件中的某个启动序列相匹配时，IDA可以根据对匹配启动例程行为的理解来定位程序的`main`函数。这很好，直到IDA无法将二进制文件的启动序列与任何已知的签名相匹配。一般来说，程序的启动代码与生成代码的编译器和代码构建的平台紧密相关。'
- en: Recall from [Chapter 12](ch12.html "Chapter 12. Library Recognition Using FLIRT
    Signatures") that startup signatures are grouped together and stored in signature
    files specific to binary file types. For example, startup signatures for use with
    the PE loader are stored in *pe.sig*, while startup signatures for use with the
    MS-DOS loader are stored in *exe.sig*. The existence of a signature file for a
    given binary file type does not guarantee that IDA will be able to identify a
    program’s `main` function 100 percent of the time. There are too many compilers,
    and startup sequences are too much of a moving target for IDA to ship with every
    possible signature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第12章](ch12.html "第12章。使用FLIRT签名识别库")中提到的，启动签名被分组并存储在针对二进制文件类型的特定签名文件中。例如，用于PE加载器的启动签名存储在`pe.sig`中，而用于MS-DOS加载器的启动签名存储在`exe.sig`中。对于给定的二进制文件类型存在签名文件并不能保证IDA能够100%地识别程序的`main`函数。有太多的编译器，启动序列变化太快，以至于IDA无法携带所有可能的签名。
- en: For many file types, such as ELF and Mach-O, IDA does not include any startup
    signatures at all. The net result is that IDA can’t use signatures to locate a
    `main` function within an ELF binary (though the function will be found if it
    is named `main`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多文件类型，如ELF和Mach-O，IDA根本不包含任何启动签名。最终结果是，IDA无法使用签名在ELF二进制文件中定位`main`函数（尽管如果函数被命名为`main`，它将被找到）。
- en: The point of this discussion is to prepare you for the fact that, on occasion,
    you will be on your own when it comes to locating the `main` function of a program.
    In such cases it is useful to have some strategies for understanding how the program
    itself prepares for the call to `main`. As an example, consider a binary that
    has been obfuscated to some degree. In this case, IDA will certainly fail to match
    a startup signature because the startup routine itself has been obfuscated. If
    you manage to de-obfuscate the binary somehow (the topic of [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis")), you will probably need to locate not
    only `main` on your own but the original start routine as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论的目的是让你为这样一个事实做好准备，即有时你将不得不自己寻找程序的`main`函数。在这种情况下，拥有一些理解程序本身如何为调用`main`做准备的战略是有用的。例如，考虑一个被一定程度混淆的二进制文件。在这种情况下，IDA肯定无法匹配启动签名，因为启动例程本身已经被混淆。如果你设法以某种方式去混淆二进制文件（这是[第21章](ch21.html
    "第21章。混淆代码分析")的主题），你将不仅需要自己找到`main`，还需要找到原始的启动例程。
- en: 'For C and C++ programs with a traditional `main` function,^([[144](#ftn.CHP-20-FN-5)])
    one of the responsibilities of the startup code is to set up the stack arguments
    required by `main`, the integer `argc` (a count of the number of command-line
    arguments), the character pointer array `argv` (an array of pointers to strings
    containing the command-line arguments), and the character pointer array `envp`
    (an array of pointers to strings containing the environment variables that were
    set at program invocation). The following excerpt from a FreeBSD 8.0 dynamically
    linked, stripped binary demonstrates how gcc-generated startup code calls to `main`
    on a FreeBSD system:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有传统 `main` 函数的 C 和 C++ 程序，^([[144](#ftn.CHP-20-FN-5)]) 启动代码的一个职责是设置 `main`
    所需的堆栈参数，整数 `argc`（命令行参数的数量），字符指针数组 `argv`（包含命令行参数的字符串指针数组），以及字符指针数组 `envp`（包含在程序调用时设置的环境变量的字符串指针数组）。以下是从
    FreeBSD 8.0 动态链接、去除了符号的二进制文件中摘录的内容，展示了 gcc 生成的启动代码如何在 FreeBSD 系统上调用 `main`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the call to `sub_8048400` ![](httpatomoreillycomsourcenostarchimages854061.png)
    turns out to be the call to `main`. This code is typical of many startup sequences
    in that there are calls to initialization functions (`_atexit` ![](httpatomoreillycomsourcenostarchimages854063.png)
    and `_init_proc` ![](httpatomoreillycomsourcenostarchimages854093.png)) preceding
    the call to `main` and a call to `_exit` ![](httpatomoreillycomsourcenostarchimages854095.png)
    following the return from `main`. The call to `_exit` ensures that the program
    terminates cleanly in the event that `main` performs a return rather than calling
    `_exit` itself. Note that the parameter passed to `_exit` ![](httpatomoreillycomsourcenostarchimages854099.png)
    is the value returned by main in EAX; thus the exit code of the program is the
    return value of `main`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对 `sub_8048400` 的调用 ![图片链接](httpatomoreillycomsourcenostarchimages854061.png)
    实际上是调用 `main`。这段代码在许多启动序列中很典型，因为在调用 `main` 之前有对初始化函数的调用（`_atexit` ![图片链接](httpatomoreillycomsourcenostarchimages854063.png)
    和 `_init_proc` ![图片链接](httpatomoreillycomsourcenostarchimages854093.png)），而在从
    `main` 返回后有一个对 `_exit` ![图片链接](httpatomoreillycomsourcenostarchimages854095.png)
    的调用。对 `_exit` 的调用确保在 `main` 执行返回而不是调用 `_exit` 本身时程序能够干净地终止。注意，传递给 `_exit` ![图片链接](httpatomoreillycomsourcenostarchimages854099.png)
    的参数是 EAX 寄存器中 `main` 返回的值；因此，程序的退出代码是 `main` 的返回值。
- en: If the previous program was statically linked and stripped, the start routine
    would have the same structure as the preceding example; however, none of the library
    functions would have useful names. In that case, the `main` function would continue
    to stand out as the only function that is called with three parameters. Of course,
    applying FLIRT signatures as early as possible would also help to restore many
    of the library function names and make `main` stand out, as it does in the preceding
    example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的程序是静态链接并去除了符号的，则启动例程的结构将与前面的示例相同；然而，库函数将没有有用的名称。在这种情况下，`main` 函数将继续作为唯一一个以三个参数调用的函数而突出。当然，尽早应用
    FLIRT 签名也有助于恢复许多库函数的名称，并使 `main` 函数像前面示例中那样突出。
- en: 'In order to demonstrate that the same compiler may generate a completely different
    style of code when running on a different platform, consider the following example,
    also created using gcc, of a dynamically linked, stripped binary taken from a
    Linux system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明相同的编译器在不同的平台上运行时可能会生成完全不同的代码风格，考虑以下示例，它也是使用 gcc 创建的，是从 Linux 系统中提取的动态链接、去除了符号的二进制文件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, `start` makes a single function call to `___libc_start_main`.
    The purpose of `___libc_start_main` is to perform all of the same types of tasks
    that were performed in the preceding FreeBSD example, including calling `main`
    and ultimately `exit`. Since `___libc_start_main` is a library function, we know
    that the only way it knows where `main` actually resides is that it is told via
    one of its parameters (of which there appear to be eight). Clearly two of the
    parameters ![](httpatomoreillycomsourcenostarchimages854061.png) and ![](httpatomoreillycomsourcenostarchimages854063.png)
    are pointers to functions, while a third ![](httpatomoreillycomsourcenostarchimages854093.png)
    is a pointer to a location within the `.text` section. There are few clues in
    the previous listing as to which function might be `main`, so you might need to
    analyze the code at the three potential locations in order to correctly locate
    `main`. This might be a useful exercise; however, you may prefer simply to remember
    that the first argument (topmost on the stack and therefore last pushed) to `___libc_start_main`
    is in fact a pointer to `main`. There are two factors that combine to prevent
    IDA from identifying `loc_8048384` as a function (which would have been named
    `sub_8048384`). The first is that the function is never called directly, so `loc_8048384`
    never appears as the target of a call instruction. The second is that although
    IDA contains heuristics to recognized functions based on their prologues (which
    is why `sub_80483C0` and `sub_80483D0` are identified as functions even though
    they too are never called directly), the function at `loc_8048384` (`main`) does
    not use a prologue recognized by IDA. The offending prologue (with comments) is
    shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`start` 函数仅调用一次 `___libc_start_main`。`___libc_start_main` 的目的是执行与前面 FreeBSD
    示例中相同的所有类型任务，包括调用 `main` 和最终 `exit`。由于 `___libc_start_main` 是一个库函数，我们知道它知道 `main`
    实际位置的唯一方式是通过其参数之一（似乎有八个参数）。显然，其中两个参数 ![](httpatomoreillycomsourcenostarchimages854061.png)
    和 ![](httpatomoreillycomsourcenostarchimages854063.png) 是函数指针，而第三个 ![](httpatomoreillycomsourcenostarchimages854093.png)
    是 `.text` 部分内的位置指针。前述列表中几乎没有关于哪个函数可能是 `main` 的线索，因此你可能需要分析三个潜在位置处的代码，以正确定位 `main`。这可能是一项有用的练习；然而，你可能更愿意简单地记住，`___libc_start_main`
    的第一个参数（位于栈顶，因此是最后压入的）实际上是指向 `main` 的指针。有两个因素结合在一起阻止 IDA 将 `loc_8048384` 识别为函数（这将命名为
    `sub_8048384`）。第一个因素是函数从未被直接调用，因此 `loc_8048384` 从未出现在调用指令的目标中。第二个因素是尽管 IDA 包含基于其前缀识别函数的启发式方法（这就是为什么
    `sub_80483C0` 和 `sub_80483D0` 被识别为函数，尽管它们也从未被直接调用），但 `loc_8048384` 处的函数（`main`）没有使用
    IDA 识别的前缀。有问题的前缀（带注释）如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This prologue clearly contains the elements of a traditional prologue for a
    function that uses EBP as a frame pointer. The caller’s frame pointer is saved
    ![](httpatomoreillycomsourcenostarchimages854061.png) before setting the frame
    pointer for the current function ![](httpatomoreillycomsourcenostarchimages854063.png)
    and finally allocating space for local variables ![](httpatomoreillycomsourcenostarchimages854093.png).
    The problem for IDA is that these actions do not occur as the first actions within
    the function, and thus IDA’s heuristics fail. It is a simple enough matter to
    manually create a function (Edit ▸ Functions ▸ Create Function) at this point,
    but you should take care to monitor IDA’s behavior. Just as it failed to identify
    the function in the first place, it may fail to recognize the fact that the function
    uses EBP as a frame pointer. In such a case, you would need to edit the function
    (alt-P) to force IDA to believe that the function has a *BP-based frame* as well
    as to make adjustments to the number of stack bytes dedicated to saved registers
    and local variables.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前缀明显包含了一个使用 EBP 作为帧指针的函数的传统前缀元素。在设置当前函数的帧指针 ![](httpatomoreillycomsourcenostarchimages854063.png)
    并最终为局部变量分配空间 ![](httpatomoreillycomsourcenostarchimages854093.png) 之前，保存了调用者的帧指针
    ![](httpatomoreillycomsourcenostarchimages854061.png)。对于 IDA 来说，问题在于这些操作不是在函数中的第一个动作，因此
    IDA 的启发式方法失败了。在这个时候手动创建一个函数（编辑 ▸ 函数 ▸ 创建函数）是一个简单的问题，但你应该注意监控 IDA 的行为。就像它最初未能识别函数一样，它可能未能识别出该函数使用
    EBP 作为帧指针的事实。在这种情况下，你需要编辑函数（alt-P），以强制 IDA 相信该函数有一个 *基于 BP 的帧*，并且还需要调整分配给保存寄存器和局部变量的栈字节数。
- en: As in the case of the FreeBSD binary, if the preceding Linux example happened
    to be both statically linked and stripped, the start routine would not change
    at all other than the fact that the name for `___libc_start_main` would be missing.
    You could still locate `main` by remembering that gcc’s Linux start routine makes
    only one function call and that the first parameter to that function is the address
    of `main`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像FreeBSD的二进制文件一样，如果前面的Linux示例既静态链接又剥离，启动例程将不会发生任何变化，除了`___libc_start_main`的名称将缺失。你仍然可以通过记住gcc的Linux启动例程只调用一个函数，并且该函数的第一个参数是`main`的地址来定位`main`。
- en: 'On the Windows side of the house, the number of C/C++ compilers (and therefore
    the number of startup routines) in use is somewhat higher. Perhaps not unsurprisingly,
    in the case of gcc on Windows, it is possible to leverage some of the knowledge
    gained by studying gcc’s behavior on other platforms. The startup routine shown
    here is from a gcc/Cygwin binary:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows这边，使用的C/C++编译器（因此是启动例程）的数量要高一些。也许不出所料，在Windows上的gcc，可以借助在其他平台上研究gcc行为获得的一些知识。下面显示的是gcc/Cygwin二进制文件的启动例程：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Clearly this code does not map cleanly to the previous Linux-based example.
    However, there is one striking similarity: only one function is called ![](httpatomoreillycomsourcenostarchimages854061.png),
    and the function takes a function pointer for parameter ![](httpatomoreillycomsourcenostarchimages854063.png).
    In this case `sub_401120` serves much the same purpose as `___libc_start_main`,
    while `sub_4010B0` turns out to be the `main` function of the program.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这段代码与基于Linux的先前的例子没有直接映射。然而，有一个显著的相似之处：只调用了一个函数![](httpatomoreillycomsourcenostarchimages854061.png)，该函数接受一个函数指针作为参数![](httpatomoreillycomsourcenostarchimages854063.png)。在这种情况下，`sub_401120`起着与`___libc_start_main`相同的作用，而`sub_4010B0`最终成为程序的`main`函数。
- en: 'Windows binaries compiled using gcc/MinGW make use of yet another style of
    `start` function, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gcc/MinGW编译的Windows二进制文件使用另一种样式的`start`函数，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is another case in which IDA will fail to identify the program’s `main`
    function. The preceding code offers few clues as to the location of `main`, as
    there is only one nonlibrary function called ![](httpatomoreillycomsourcenostarchimages854061.png)
    (`sub_401150`) and that function does not appear to take any arguments (as `main`
    should). In this instance, the best course of action is to continue the search
    for `main` within `sub_401150`. A portion of `sub_401150` is shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是IDA无法识别程序`main`函数的另一个例子。前面的代码对`main`的位置提供很少的线索，因为只有一个非库函数被调用![](httpatomoreillycomsourcenostarchimages854061.png)（`sub_401150`），而这个函数似乎没有接受任何参数（就像`main`应该做的那样）。在这种情况下，最好的做法是在`sub_401150`中继续寻找`main`。以下是`sub_401150`的一部分：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the function turns out to have many similarities with the `start`
    function associated with FreeBSD that we saw earlier. Process of elimination points
    to `sub_401395` as the likely candidate for `main`, as it is the only non-library
    function that is called with three arguments—![](httpatomoreillycomsourcenostarchimages854063.png),
    ![](httpatomoreillycomsourcenostarchimages854093.png), and ![](httpatomoreillycomsourcenostarchimages854095.png).
    Also, the third argument ![](httpatomoreillycomsourcenostarchimages854095.png)
    is related to the return value of the `__p__environ` library function, which correlates
    well with the fact that `main`’s third argument is expected to be a pointer to
    the environment strings array. The example code is also preceded by a call to
    the `getmainargs` library function (not shown), which is called to set up the
    `argc` and `argv` parameters prior to actually calling `main`. This helps to reinforce
    the notion that `main` is about to be called.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，该函数与我们在前面看到的与FreeBSD相关的`start`函数有许多相似之处。通过排除法，我们可以将`sub_401395`视为`main`的可能候选，因为它是有三个参数——![](httpatomoreillycomsourcenostarchimages854063.png)、![](httpatomoreillycomsourcenostarchimages854093.png)和![](httpatomoreillycomsourcenostarchimages854095.png）——调用的唯一非库函数。此外，第三个参数![](httpatomoreillycomsourcenostarchimages854095.png)与`__p__environ`库函数的返回值相关，这与`main`的第三个参数预期为环境字符串数组指针的事实很好地相符。示例代码之前还有一个对`getmainargs`库函数的调用（未显示），该函数在调用`main`之前设置`argc`和`argv`参数。这有助于加强`main`即将被调用的观念。
- en: 'The start routine for Visual C/C++ code is short and sweet, as seen here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C/C++代码的启动例程简短而清晰，如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'IDA has actually recognized the library routines referenced in the two instructions
    through the application of startup signatures rather than by the fact that the
    program is linked to a dynamic library containing the given symbols. IDA’s startup
    signatures provide easy location of the initial call to `main`, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 实际上是通过应用启动签名而不是通过程序链接到包含给定符号的动态库的事实来识别这两条指令中引用的库例程。IDA 的启动签名提供了轻松定位对 `main`
    的初始调用的方法，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Within the entire body of `tmainCRTStartup`, `_main` is the only function called
    with exactly three arguments. Further analysis would reveal that the call to `_main`
    is preceded by a call to the `GetCommandLine` library function, which is yet another
    indication that a program’s `main` function may be called shortly. As a final
    note concerning the use of startup signatures, it is important to understand that,
    in this example, IDA has generated the name `_main` entirely on its own as a result
    of matching a startup signature. The ASCII string `main` appeared nowhere in the
    binary used in this example. Thus, you can expect `main` to be found and labeled
    anytime a startup signature is matched, even when a binary has been stripped of
    its symbols.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tmainCRTStartup` 的整个主体中，`_main` 是唯一一个带有三个精确参数的函数。进一步分析将揭示对 `_main` 的调用之前有一个对
    `GetCommandLine` 库函数的调用，这又是程序 `main` 函数可能很快被调用的另一个迹象。关于启动签名的使用，重要的是要理解，在这个例子中，IDA
    完全根据匹配启动签名自行生成了 `_main` 这个名称。ASCII 字符串 `main` 在这个例子使用的二进制文件中根本不存在。因此，你可以预期，每当匹配到启动签名时，`main`
    都会被找到并标记，即使二进制文件已经去除了其符号。
- en: 'The last startup routine that we will examine for a C compiler is generated
    by Borland’s free command-line compiler. ^([[145](#ftn.CHP-20-FN-6)]) The last
    few lines of Borland’s start routine are shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个 C 编译器的启动例程是由 Borland 的免费命令行编译器生成的。^([[145](#ftn.CHP-20-FN-6)]) Borland
    启动例程的最后几行如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The pointer value pushed on the stack ![](httpatomoreillycomsourcenostarchimages854061.png)
    refers to a structure that in turn contains a pointer to `main`. Within `__startup`,
    the setup to call `main` is shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 压入堆栈的指针值 ![](httpatomoreillycomsourcenostarchimages854061.png) 指向一个结构，该结构反过来又包含一个指向
    `main` 的指针。在 `__startup` 中，调用 `main` 的设置如下所示：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, this example bears many similarities to previous examples in that the
    call to `main` ![](httpatomoreillycomsourcenostarchimages854061.png) takes three
    arguments ![](httpatomoreillycomsourcenostarchimages854063.png), ![](httpatomoreillycomsourcenostarchimages854093.png),
    and ![](httpatomoreillycomsourcenostarchimages854095.png) (the only function called
    within `__startup` to do so) and the return value is passed directly to `_exit`
    to terminate the program. Additional analysis of `__startup` would reveal calls
    to the Windows API functions `GetEnvironmentStrings` and `GetCommandLine`, which
    are often precursors to the invocation of `main`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个例子与之前的例子有很多相似之处，即对 `main` 的调用 ![](httpatomoreillycomsourcenostarchimages854061.png)
    带有三个参数 ![](httpatomoreillycomsourcenostarchimages854063.png)、![](httpatomoreillycomsourcenostarchimages854093.png)
    和 ![](httpatomoreillycomsourcenostarchimages854095.png)（在 `__startup` 中唯一被调用的函数）并且返回值直接传递给
    `_exit` 以终止程序。对 `__startup` 的进一步分析将揭示对 Windows API 函数 `GetEnvironmentStrings`
    和 `GetCommandLine` 的调用，这些通常是调用 `main` 的先兆。
- en: 'Finally, in order to demonstrate that tracking down a program’s `main` function
    is not a problem specific to C programs, consider the following startup code from
    a compiled Visual Basic 6.0 program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了证明追踪程序的 `main` 函数并不是 C 程序特有的问题，考虑以下从编译后的 Visual Basic 6.0 程序中提取的启动代码：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ThunRTMain` library function performs a function similar to the Linux
    `libc_start_main` function in that its job is to perform any initialization required
    prior to invoking the actual `main` function of the program. In order to transfer
    control to the `main` function, Visual Basic utilizes a mechanism very similar
    to that in the Borland code in the earlier examples. `ThunRTMain` takes a single
    argument ![](httpatomoreillycomsourcenostarchimages854061.png), which is a pointer
    to a structure containing additional information required for program initialization,
    including the address of the `main` function. The content of this structure is
    shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThunRTMain` 库函数执行的功能类似于 Linux 中的 `libc_start_main` 函数，其任务是执行在调用程序的实际 `main`
    函数之前所需的任何初始化操作。为了将控制权传递给 `main` 函数，Visual Basic 使用了一种与早期示例中 Borland 代码中非常相似的机制。`ThunRTMain`
    接收一个单一参数 ![](httpatomoreillycomsourcenostarchimages854061.png)，这是一个指向包含程序初始化所需额外信息的结构的指针，包括
    `main` 函数的地址。该结构的内容如下所示：'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Within this data structure, there is only one item ![](httpatomoreillycomsourcenostarchimages854061.png)
    that appears to reference code at all, the pointer to `sub_4045D0`, which turns
    out to be the `main` function for the program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此数据结构中，只有一个项目 ![](httpatomoreillycomsourcenostarchimages854061.png) 看起来似乎引用了代码，即指向
    `sub_4045D0` 的指针，结果证明这是程序的 `main` 函数。
- en: In the end, learning how to find `main` is a matter of understanding how executable
    files are built. In cases where you are experiencing difficulties, it may be beneficial
    to build some simple executables (with a reference to an easily identifiable string
    in `main`, for example) with the same tools used to build the binary you are analyzing.
    By studying your test cases, you will gain an understanding of the basic structure
    of binaries built using a specific set of tools that may assist you in further
    analyzing more complex binaries built with the same set of tools.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，学习如何找到 `main` 是理解可执行文件构建过程的问题。在遇到困难的情况下，使用构建你正在分析的二进制文件相同的工具构建一些简单的可执行文件（例如，在
    `main` 中包含一个易于识别的字符串）可能是有益的。通过研究你的测试用例，你将了解使用特定工具集构建的二进制文件的基本结构，这可能有助于你进一步分析使用相同工具集构建的更复杂的二进制文件。
- en: '* * *'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[144](#CHP-20-FN-5)]) Windows GUI applications require a `WinMain` function
    instead of `main`. Documentation regarding `WinMain` can be found here: [http://msdn2.microsoft.com/en-us/library/ms633559.aspx](http://msdn2.microsoft.com/en-us/library/ms633559.aspx).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[144](#CHP-20-FN-5)]) Windows GUI 应用程序需要 `WinMain` 函数而不是 `main`。有关 `WinMain`
    的文档可以在此处找到：[http://msdn2.microsoft.com/en-us/library/ms633559.aspx](http://msdn2.microsoft.com/en-us/library/ms633559.aspx)。
- en: ^([[145](#CHP-20-FN-6)]) See [http://forms.embarcadero.com/forms/BCC32CompilerDownload/](http://forms.embarcadero.com/forms/BCC32CompilerDownload/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[145](#CHP-20-FN-6)]) 请参阅 [http://forms.embarcadero.com/forms/BCC32CompilerDownload/](http://forms.embarcadero.com/forms/BCC32CompilerDownload/)。
- en: Debug vs. Release Binaries
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试版本与发布版本二进制文件的区别
- en: Microsoft’s Visual Studio projects are usually capable of building either debug
    or release versions of program binaries. One way to note the differences is to
    compare the build options specified for the debug version of a project to the
    build options specified for the release version. Simple differences include the
    fact that release versions are generally optimized,^([[146](#ftn.CHP-20-FN-7)])
    while debug versions are not, and debug versions are linked with additional symbol
    information and debugging versions of the runtime library, while release versions
    are not. The addition of debugging-related symbols allows debuggers to map assembly
    language statements back to their source code counterparts and to determine the
    names of local variables.^([[147](#ftn.CHP-20-FN-8)]) Such information is typically
    lost during the compilation process. The debugging versions of Microsoft’s runtime
    libraries have also been compiled with debugging symbols included, optimizations
    disabled, and additional safety checks enabled to verify that some function parameters
    are valid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 的 Visual Studio 项目通常能够构建程序的调试或发布版本。一种区分这两种版本的方法是对比项目调试版本的构建选项与发布版本的构建选项。简单的区别包括发布版本通常经过优化，^([[146](#ftn.CHP-20-FN-7)]），而调试版本则没有，调试版本与包含附加符号信息和调试版本的运行时库链接，而发布版本则不是。调试相关符号的添加允许调试器将汇编语言语句映射回其源代码对应项，并确定局部变量的名称.^([[147](#ftn.CHP-20-FN-8)）此类信息通常在编译过程中丢失。Microsoft
    的运行时库的调试版本也包含调试符号，禁用优化，并启用额外的安全检查以验证某些函数参数是否有效。
- en: When disassembled using IDA, debug builds of Visual Studio projects look significantly
    different from release builds. This is a result of compiler and linker options
    specified only in debug builds, such as basic runtime checks (/RTCx^([[148](#ftn.CHP-20-FN-9)])),
    which introduce extra code into the resulting binary. A side effect of this extra
    code is that it defeats IDA’s startup signature-matching process, resulting in
    IDA’s frequent failure to automatically locate `main` in debug builds of binaries.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 IDA 反汇编时，Visual Studio 项目的调试构建与发布构建看起来显著不同。这是由于仅在调试构建中指定的编译器和链接器选项的结果，例如基本的运行时检查
    (/RTCx^([[148](#ftn.CHP-20-FN-9)]))，这些检查会在生成的二进制文件中引入额外的代码。这些额外代码的副作用是它破坏了 IDA
    的启动签名匹配过程，导致 IDA 在二进制文件的调试构建中频繁无法自动定位 `main` 函数。
- en: 'One of the first differences you may notice in a debug build of a binary is
    that virtually all functions are reached via *jump* functions (also known as *thunk*
    functions), as shown in the following code fragments:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在二进制文件的调试构建中注意到的第一个差异是，几乎所有函数都是通过 *跳转* 函数（也称为 *thunk* 函数）到达的，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the program entry point ![](httpatomoreillycomsourcenostarchimages854061.png)
    does nothing other than jump ![](httpatomoreillycomsourcenostarchimages854063.png)
    to the actual startup function ![](httpatomoreillycomsourcenostarchimages854093.png).
    The startup function, in turn, calls ![](httpatomoreillycomsourcenostarchimages854095.png)
    another function ![](httpatomoreillycomsourcenostarchimages854099.png), which
    simply jumps ![](httpatomoreillycomsourcenostarchimages854101.png) to the actual
    implementation of that function. The two functions ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854099.png) that contain nothing
    but a single jump statement are called *thunk* functions. The heavy use of thunk
    functions in debug binaries is one of the obstacles to IDA’s signature-matching
    process. While the presence of thunk functions may briefly slow down your analysis,
    using the techniques described in the previous section, it is still possible to
    track down the `main` function of the binary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，程序入口点 ![](httpatomoreillycomsourcenostarchimages854061.png) 除了跳转到实际的启动函数
    ![](httpatomoreillycomsourcenostarchimages854093.png) 外，什么都不做。启动函数反过来调用 ![](httpatomoreillycomsourcenostarchimages854095.png)
    另一个函数 ![](httpatomoreillycomsourcenostarchimages854099.png)，该函数只是简单地跳转到该函数的实际实现。包含仅有一个跳转语句的两个函数
    ![](httpatomoreillycomsourcenostarchimages854061.png) 和 ![](httpatomoreillycomsourcenostarchimages854099.png)
    被称为 *thunk* 函数。在调试二进制文件中大量使用 thunk 函数是 IDA 签名匹配过程的一个障碍。虽然 thunk 函数的存在可能会暂时减慢你的分析速度，但使用前一小节中描述的技术，仍然可以追踪到二进制文件的
    `main` 函数。
- en: 'The basic runtime checks in a debug build cause several additional operations
    to be performed upon entry to any function. An example of an extended prologue
    in a debug build is shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 调试构建中的基本运行时检查会在进入任何函数时执行几个额外的操作。以下是一个调试构建中扩展前导部分的示例：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The function in this example utilizes four local variables that should require
    only 16 bytes of stack space. Instead we see that this function allocates 240
    bytes ![](httpatomoreillycomsourcenostarchimages854061.png) of stack space and
    then proceeds to fill each of the 240 bytes with the value `0xCC`. The four lines
    starting at ![](httpatomoreillycomsourcenostarchimages854063.png) equate to the
    following function call:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，该函数使用了四个局部变量，这些变量应该只需要 16 字节的堆栈空间。然而，我们看到这个函数分配了 240 字节的堆栈空间，然后继续将这 240
    字节全部填充为值 `0xCC`。从 ![](httpatomoreillycomsourcenostarchimages854061.png) 开始的四个线条相当于以下函数调用：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The byte value `0xCC` corresponds to the x86 opcode for `int 3`, which is a
    software interrupt that causes a program to trap to a debugger. The intent of
    filling the stack frame with an overabundance of `0xCC` values may be to ensure
    that the debugger is invoked in the event that the program somehow attempts to
    execute instructions from the stack (an error condition that one would hope to
    catch in a debug build).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 字节值 `0xCC` 对应于 x86 指令集的 `int 3` 指令，这是一个软件中断，会导致程序陷入调试器。在堆栈帧中填充过量的 `0xCC` 值的意图可能是为了确保在程序以某种方式尝试从堆执行指令（一个希望在调试构建中捕获的错误条件）时，会调用调试器。
- en: 'The function’s local variables are initialized beginning at ![](httpatomoreillycomsourcenostarchimages854093.png),
    where we note that the variables are not adjacent to one another. The intervening
    space will have been filled with the value `0xCC` by the preceding `memset` operation.
    Providing extra space between variables in this manner can make it easier to detect
    overflows from one variable that may spill into and corrupt another variable.
    Under normal conditions, none of the `0xCC` values used as filler, outside of
    any declared variables, should be overwritten. For comparison purposes, the release
    version of the same code is shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的局部变量从 ![图片](httpatomoreillycomsourcenostarchimages854093.png) 开始初始化，我们注意到变量并不相邻。中间的空间将由前面的
    `memset` 操作填充为 `0xCC` 的值。以这种方式在变量之间提供额外的空间可以使检测一个变量可能溢出到并损坏另一个变量的情况变得更容易。在正常情况下，除了任何声明的变量之外，不应覆盖用作填充的任何
    `0xCC` 值。为了比较目的，这里显示了相同代码的发布版本：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the release version we see that only the required amount of space is requested
    for local variables ![](httpatomoreillycomsourcenostarchimages854061.png) and
    that all four local variables are adjacent to one another ![](httpatomoreillycomsourcenostarchimages854063.png).
    Also note that the use of `0xCC` as a filler value has been eliminated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布版本中，我们看到只为局部变量请求了所需的空间 ![图片](httpatomoreillycomsourcenostarchimages854061.png)
    ，并且所有四个局部变量都彼此相邻 ![图片](httpatomoreillycomsourcenostarchimages854063.png) 。此外，请注意，使用
    `0xCC` 作为填充值的做法已被消除。
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[146](#CHP-20-FN-7)]) *Optimization* generally involves elimination of redundancy
    in code or selection of faster, but potentially larger, sequences of code in order
    to satisfy a developer’s desire to create either faster or smaller executable
    files. Optimized code may not be as straightforward to analyze as nonoptimized
    code and may therefore be considered a bad choice for use during a program’s development
    and debugging phases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[146](#CHP-20-FN-7)]) *优化* 通常涉及消除代码中的冗余或选择更快但可能更大的代码序列，以满足开发者创建更快或更小的可执行文件的需求。优化后的代码可能不如非优化代码容易分析，因此可能被认为在程序的开发和调试阶段使用不是一个好的选择。
- en: ^([[147](#CHP-20-FN-8)]) gcc also offers the ability to insert debugging symbols
    during the compilation process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[147](#CHP-20-FN-8)]) gcc 还提供了在编译过程中插入调试符号的能力。
- en: ^([[148](#CHP-20-FN-9)]) See [http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx](http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[148](#CHP-20-FN-9)]) 请参阅 [http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx](http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx)。
- en: Alternative Calling Conventions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代调用约定
- en: In [Chapter 6](ch06.html "Chapter 6. Disassembly Navigation"), we discussed
    the most common calling conventions utilized in C and C++ code. While adherence
    to a published calling convention is crucial when attempting to interface one
    compiled module to another, nothing prohibits the use of custom calling conventions
    by functions within a single module. This is commonly seen in highly optimized
    functions that are not designed to be called from outside the module in which
    they reside.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。反汇编导航")中，我们讨论了在C和C++代码中最常用的调用约定。尽管遵循已发布的调用约定在尝试将一个编译模块与另一个模块接口时至关重要，但没有任何规定禁止单个模块内的函数使用自定义调用约定。这在高度优化的函数中很常见，这些函数不是设计为从它们所在的模块外部调用的。
- en: 'The following code represents the first four lines of a function that uses
    a nonstandard calling convention:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示使用非标准调用约定的函数的前四行：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: According to IDA’s analysis, only one argument ![](httpatomoreillycomsourcenostarchimages854061.png)
    exists in the function’s stack frame. However, upon closer inspection of the code,
    you can see that both the EAX register ![](httpatomoreillycomsourcenostarchimages854063.png)
    and the CL register ![](httpatomoreillycomsourcenostarchimages854093.png) are
    used without any initialization taking place within the function. The only possible
    conclusion is that both EAX and CL are expected to be initialized by the caller.
    Therefore, you should view this function as a three-argument function rather than
    a single-argument function, and you must take special care when calling it to
    ensure that the three arguments are all in their proper places.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IDA的分析，函数的堆栈帧中只有一个参数存在。然而，在仔细检查代码后，你可以看到 EAX 寄存器 ![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)
    和 CL 寄存器 ![httpatomoreillycomsourcenostarchimages854063.png](httpatomoreillycomsourcenostarchimages854063.png)
    都被使用，而在函数内部没有任何初始化发生。唯一可能的结论是 EAX 和 CL 都预期由调用者初始化。因此，你应该将此函数视为一个三参数函数，而不是一个单参数函数，并且在调用它时必须特别小心，以确保三个参数都处于正确的位置。
- en: IDA allows you to specify custom calling conventions for any function by setting
    the function’s “type.” This is done by entering the function’s prototype via the
    Edit ▸ Functions ▸ Set function type menu option and using IDA’s `__usercall`
    calling convention. [Figure 20-1](ch20s05.html#designating_a_function_as_underscore_und
    "Figure 20-1. Designating a function as __usercall") shows the resulting dialog
    used to set the type for `sub_158AC` in the preceding example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 允许您通过设置函数的“类型”来为任何函数指定自定义调用约定。这是通过通过“编辑”▸“函数”▸“设置函数类型”菜单选项输入函数原型并使用 IDA
    的 `__usercall` 调用约定来完成的。[图 20-1](ch20s05.html#designating_a_function_as_underscore_und
    "图 20-1. 将函数指定为 __usercall") 显示了用于设置前例中 `sub_158AC` 类型的结果对话框。
- en: '![Designating a function as __usercall](httpatomoreillycomsourcenostarchimages854313.png.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![将函数指定为 __usercall](httpatomoreillycomsourcenostarchimages854313.png.jpg)'
- en: Figure 20-1. Designating a function as `__usercall`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20-1. 将函数指定为 `__usercall`
- en: 'For clarity, the declaration is shown again here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，此处再次展示声明：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here the IDA keyword `__usercall` is used in place of one of the standard calling
    conventions such as `__cdecl` or `__stdcall`. The use of `__usercall` requires
    us to tell IDA the name of the register used to hold the function’s return value
    by appending the register name to the name of the function (yielding `sub_158AC<eax>`
    in this case). If the function returns no value, the return register may be omitted.
    Within the parameter list, each register-based parameter must also be annotated
    by appending the corresponding register name to the parameter’s data type. After
    the function’s type has been set, IDA propagates parameter information to calling
    functions, which results in improved commenting of function call sequences as
    shown in the following listing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，IDA 关键字 `__usercall` 被用于替代标准调用约定之一，如 `__cdecl` 或 `__stdcall`。使用 `__usercall`
    要求我们通过将寄存器名称附加到函数名称上来告诉 IDA 用于存储函数返回值的寄存器名称（在本例中产生 `sub_158AC<eax>`）。如果函数不返回任何值，则可以省略返回寄存器。在参数列表中，每个基于寄存器的参数也必须通过将相应的寄存器名称附加到参数的数据类型上来进行注释。在设置函数类型之后，IDA
    将参数信息传播到调用函数，从而提高了函数调用序列的注释质量，如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here it is clear that IDA recognizes that EAX will hold the first argument to
    the function ![](httpatomoreillycomsourcenostarchimages854061.png), CL will hold
    the second argument ![](httpatomoreillycomsourcenostarchimages854063.png), and
    the third argument will placed on the stack ![](httpatomoreillycomsourcenostarchimages854093.png).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里很明显，IDA 识别出 EAX 将持有函数的第一个参数 ![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)，CL
    将持有第二个参数 ![httpatomoreillycomsourcenostarchimages854063.png](httpatomoreillycomsourcenostarchimages854063.png)，第三个参数将放置在堆栈上
    ![httpatomoreillycomsourcenostarchimages854093.png](httpatomoreillycomsourcenostarchimages854093.png)。
- en: 'To demonstrate that calling conventions can vary widely even with a single
    executable, a second example using a custom calling convention is taken from the
    same binary file and shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明即使对于单个可执行文件，调用约定也可以有很大的差异，这里从同一个二进制文件中取了一个使用自定义调用约定的第二个示例，并在此展示：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here again, IDA has indicated that the function accesses only one argument ![](httpatomoreillycomsourcenostarchimages854061.png)
    within the stack frame. Closer inspection makes it quite clear that the ESI register
    ![](httpatomoreillycomsourcenostarchimages854063.png) is also expected to be initialized
    prior to calling this function. This example demonstrates that even with the same
    binary file, the registers chosen to hold register-based arguments may vary from
    function to function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，IDA表明该函数仅访问堆栈帧中的一个参数 ![图片](http://atomoreilly.com/source/nostarch/images/854061.png)。仔细检查可以清楚地看出，ESI寄存器
    ![图片](http://atomoreilly.com/source/nostarch/images/854063.png) 也应该在调用此函数之前初始化。这个例子表明，即使对于相同的二进制文件，用于存储基于寄存器的参数所选择的寄存器也可能因函数而异。
- en: The lesson to be learned here is to make certain that you understand how each
    register used in a function is initialized. If a function makes use of a register
    prior to initializing that register, then the register is being used to pass a
    parameter. Please refer to [Chapter 6](ch06.html "Chapter 6. Disassembly Navigation")
    for a review of which registers are used by various compilers and common calling
    conventions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要吸取的教训是确保你理解函数中使用的每个寄存器的初始化方式。如果一个函数在初始化寄存器之前就使用了该寄存器，那么该寄存器正在被用来传递参数。请参阅[第6章](ch06.html
    "第6章。反汇编导航")以回顾各种编译器和常见调用约定所使用的寄存器。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The number of compiler-specific behaviors is too numerous to cover in a single
    chapter (or even a single book for that matter). Among other behaviors, compilers
    differ in the algorithms they employ to implement various high-level constructs
    and the manner in which they choose to optimize generated code. Because a compiler’s
    behavior is heavily influenced by the options supplied to the compiler during
    the build process, it is possible for one compiler to generate radically different
    binaries when fed the same source but different build options. Unfortunately,
    learning to cope with all of these variations is usually a matter of experience.
    Further complicating matters is the fact that it often very difficult to search
    for help on specific assembly language constructs, as it is very difficult to
    craft search expressions that will yield results specific to your particular case.
    When this happens, your best resource is generally a forum dedicated to reverse
    engineering in which you can post code and benefit from the knowledge of others
    who have had similar experiences.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器特定的行为太多，无法在单章（甚至一本书）中涵盖。在其他行为中，编译器在实现各种高级构造时采用的算法以及它们选择优化生成代码的方式都不同。由于编译器的行为受到构建过程中提供给编译器的选项的强烈影响，因此，一个编译器在接收到相同的源代码但不同的构建选项时可能会生成根本不同的二进制文件。不幸的是，学会应对所有这些变化通常是一个经验问题。进一步复杂化的是，通常很难在特定的汇编语言构造上寻找帮助，因为很难构建出能够产生针对你特定情况的特定结果的搜索表达式。当这种情况发生时，你最好的资源通常是专门针对逆向工程的论坛，你可以在那里发布代码并从有类似经验的其他人的知识中受益。
- en: Chapter 21. Obfuscated Code Analysis
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章。混淆代码分析
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/854059.png.jpg)'
- en: Even under ideal circumstances, comprehending a disassembly listing is a difficult
    task at best. High-quality disassemblies are essential for anyone contemplating
    digging into the inner workings of a binary, which is precisely why we have spent
    the last 20 chapters discussing IDA Pro and its capabilities. It can be argued
    that IDA is so effective at what it does that it has lowered the barriers for
    entry into the binary analysis field. While certainly not attributable to IDA
    alone, the fact that the state of binary reverse engineering has advanced so far
    in recent years is not lost on anyone who does not want his software to be analyzed.
    Thus, over the last several years, an arms race of sorts has been taking place
    between reverse engineers and programmers who wish to keep their code secret.
    In this chapter we will examine IDA’s role in this arms race and discuss some
    of the measures that have been taken to protect code, along with how to defeat
    those measures using IDA.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在理想情况下，理解反汇编列表也是一个困难的任务。高质量的反汇编对于任何想要深入了解二进制内部工作原理的人来说是必不可少的，这正是我们为什么在过去的20章中讨论IDA
    Pro及其功能的原因。可以说，IDA在它所做的事情上非常有效，以至于它降低了进入二进制分析领域的门槛。虽然这当然不能仅归因于IDA本身，但近年来二进制逆向工程的状态取得了如此大的进步，这对任何不希望其软件被分析的人来说都是显而易见的。因此，在过去的几年中，逆向工程师和希望保持其代码秘密的程序员之间进行了一场某种形式的军备竞赛。在本章中，我们将探讨IDA在这场军备竞赛中的作用，并讨论一些已采取的措施来保护代码，以及如何使用IDA来克服这些措施。
- en: Various dictionary definitions will inform you that *obfuscation* is the act
    of making something obscure, perplexing, confusing, or bewildering in order to
    prevent others from understanding the obfuscated item. Anti–reverse engineering,
    on the other hand, encompasses a broader range of techniques (obfuscation being
    one of them) designed to hinder analysis of an item. In the context of this book
    and the use of IDA, the items to which such anti–reverse engineering techniques
    may be applied are binary executable files (as opposed to source files or silicon
    chips, for example).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的词典定义会告诉你，*混淆*是指为了防止他人理解被混淆的项目而使某物变得晦涩、令人困惑、混乱或令人困惑的行为。另一方面，反逆向工程则包含更广泛的技术范围（混淆只是其中之一），旨在阻碍对项目的分析。在本书的上下文中以及使用IDA的情况下，可能应用此类反逆向工程技术的项目是二进制可执行文件（例如，与源文件或硅芯片相对）。
- en: In order to consider the impact of obfuscation, and anti–reverse engineering
    techniques in general, on the use of IDA, it is first useful to categorize some
    of these techniques in order to understand exactly how each may manifest itself.
    It is important to note that there is no one correct way to categorize each technique,
    as the general categories that follow often overlap in their descriptions. In
    addition, new anti–reverse engineering techniques are under continuous development,
    and it is not possible to provide a single, all-inclusive list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑混淆以及反逆向工程技术在IDA使用中的影响，首先对其中一些技术进行分类是有用的，以便了解每种技术可能如何体现。重要的是要注意，没有一种正确的方式来分类每种技术，因为以下的一般类别在描述中经常重叠。此外，新的反逆向工程技术正在不断发展，不可能提供一个单一、全面的列表。
- en: Anti–Static Analysis Techniques
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静电分析技术
- en: The primary purpose of anti–static analysis techniques is to prevent an analyst
    from understanding the nature of a program without actually running the program.
    These are precisely the types of techniques that target disassemblers such as
    IDA and are thus of greatest concern if IDA is your weapon of choice for reverse
    engineering binaries. Several types of anti–static analysis techniques are discussed
    here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 防止静态分析技术的首要目的是防止分析师在不实际运行程序的情况下理解程序的本质。这些正是针对像IDA这样的反汇编器的技术类型，因此如果IDA是你的二进制逆向工程武器选择，那么这些技术就最为关注。这里讨论了几种类型的防止静态分析技术。
- en: Disassembly Desynchronization
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆卸去同步化
- en: One of the older techniques designed to frustrate the disassembly process involves
    the creative use of instructions and data to prevent the disassembly from finding
    the correct starting address for one or more instructions. Forcing the disassembler
    to lose track of itself in this manner usually results in a failed or, at a minimum,
    incorrect disassembly listing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设计用来挫败反汇编过程的较老技术之一涉及创造性地使用指令和数据来防止反汇编找到一个或多个指令的正确起始地址。以这种方式迫使反汇编器失去自我跟踪通常会导致反汇编失败，或者至少是错误的反汇编列表。
- en: 'The following listing shows IDA’s efforts to disassemble a portion of the Shiva^([[149](#ftn.CHP-21-FN-1)])
    anti–reverse engineering tool:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了IDA尝试反汇编Shiva^([[149](#ftn.CHP-21-FN-1)])反逆向工程工具的一部分：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example executes a call ![](httpatomoreillycomsourcenostarchimages854061.png)
    (a jump can just as easily be used) into the middle of an existing instruction
    ![](httpatomoreillycomsourcenostarchimages854063.png). Since the function call
    is assumed to return, the succeeding instruction at address `0A04B0D6` ![](httpatomoreillycomsourcenostarchimages854063.png)
    is disassembled (incorrectly). The actual target of the call instruction, `loc_A04B0D6+1`
    (`0A04B0D7`), cannot be disassembled because the associated bytes have already
    been incorporated into the 5-byte instruction at `0A04B0D6`. Assuming we notice
    that this is taking place, the remainder of the disassembly must be considered
    suspect. Evidence of this fact shows up in the form of unexpected user-space instructions
    ![](httpatomoreillycomsourcenostarchimages854093.png) (in this case an `iret`^([[150](#ftn.CHP-21-FN-2)]))
    and miscellaneous databytes ![](httpatomoreillycomsourcenostarchimages854095.png).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例执行了一个调用![](httpatomoreillycomsourcenostarchimages854061.png)（也可以使用跳转）到现有指令的中间![](httpatomoreillycomsourcenostarchimages854063.png)。由于假设函数调用会返回，因此地址`0A04B0D6`![](httpatomoreillycomsourcenostarchimages854063.png)处的后续指令被反汇编（错误地）。调用指令的实际目标`loc_A04B0D6+1`(`0A04B0D7`)无法反汇编，因为相关的字节已经被包含在`0A04B0D6`的5字节指令中。假设我们注意到这种情况，反汇编的其余部分必须被视为可疑。这一事实的证据以意外的用户空间指令![](httpatomoreillycomsourcenostarchimages854093.png)（在这种情况下是一个`iret`^([[150](#ftn.CHP-21-FN-2)]))和杂项数据字节![](httpatomoreillycomsourcenostarchimages854095.png)的形式出现。
- en: Note that this type of behavior is not restricted to IDA. Virtually all disassemblers,
    whether they utilize a recursive descent algorithm or a linear sweep algorithm,
    fall victim to this technique.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种行为不仅限于IDA。几乎所有反汇编器，无论它们使用递归下降算法还是线性扫描算法，都会成为这种技术的受害者。
- en: 'The proper way to deal with this situation in IDA is to undefine the instruction
    that contains the bytes that are the target of the call and then define an instruction
    at the call target address in an attempt to resynchronize the disassembly. Of
    course, the use of an interactive disassembler greatly simplifies this process.
    Using IDA, a quick Edit ▸ Undefine (hotkey U) with the cursor positioned at ![](httpatomoreillycomsourcenostarchimages854061.png)
    followed by an Edit ▸ Code (hotkey C) with the cursor repositioned on address
    `0A04B0D7` results in the listing shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA中处理这种情况的正确方法是在包含调用目标的字节的指令中取消定义指令，然后在调用目标地址处定义一条指令，以尝试重新同步反汇编。当然，使用交互式反汇编器大大简化了这一过程。使用IDA，将光标定位在![](httpatomoreillycomsourcenostarchimages854061.png)处进行快速编辑▸取消定义（快捷键U），然后重新定位光标在地址`0A04B0D7`处进行编辑▸代码（快捷键C），结果如这里所示：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this point, it is somewhat more obvious that the byte at address `0A04B0D6`
    ![](httpatomoreillycomsourcenostarchimages854061.png) is never executed. The instruction
    at `0A04B0D7` ![](httpatomoreillycomsourcenostarchimages854063.png) (the target
    of the call) is used to clear the return address (from the bogus call) off the
    stack, and execution continues. Note that is does not take long before the technique
    is used again, this time using a 2-byte jump instruction at address `0A04B0DB`
    ![](httpatomoreillycomsourcenostarchimages854093.png), which actually jumps into
    the middle of itself. Here again, we are obligated to undefine an instruction
    in order to get to the start of the next instruction. One more application of
    the undefine (at `0A04B0DB`) and redefine (at `0A04B0DC`) processes yields the
    following disassembly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这一点更加明显，地址`0A04B0D6`的字节![](httpatomoreillycomsourcenostarchimages854061.png)永远不会被执行。地址`0A04B0D7`的指令![](httpatomoreillycomsourcenostarchimages854063.png)（调用的目标）用于从栈中清除（虚假调用）的返回地址，然后继续执行。请注意，不久之后，这种技术再次被使用，这次使用的是地址`0A04B0DB`的2字节跳转指令![](httpatomoreillycomsourcenostarchimages854093.png)，它实际上跳到了自身的中间。在这里，我们又不得不取消定义一条指令，以便到达下一条指令的开始。取消定义（在`0A04B0DB`）和重新定义（在`0A04B0DC`）过程的一次更多应用产生了以下反汇编：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The target of the jump instruction turns out to be yet another jump instruction
    ![](httpatomoreillycomsourcenostarchimages854061.png). In this case, however,
    the jump is impossible for a disassembler (and potentially confusing to the human
    analyst) to follow, as the target of the jump is contained in a register (EAX)
    and computed at runtime. This is an example of another type of anti–static analysis
    technique, discussed in [Dynamically Computed Target Addresses](ch21.html#dynamically_computed_target_addresses
    "Dynamically Computed Target Addresses") in [Dynamically Computed Target Addresses](ch21.html#dynamically_computed_target_addresses
    "Dynamically Computed Target Addresses"). In this case the value contained in
    the EAX register is not difficult to determine given the relatively simple instruction
    sequence that precedes the jump. The `pop` instruction at ![](httpatomoreillycomsourcenostarchimages854063.png)
    loads the return address from the call instruction in the previous example (`0A04B0D6`)
    into the EAX register, while the following instruction ![](httpatomoreillycomsourcenostarchimages854093.png)
    has the effect of adding 10 to EAX. Thus the target of the jump instruction is
    `0A04B0E0`, and this is the address at which we must resume the disassembly process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转指令的目标竟然又是另一个跳转指令 ![图片](httpatomoreillycomsourcenostarchimages854061.png)。然而，在这种情况下，由于跳转的目标位于寄存器（EAX）中，并在运行时计算，因此反汇编器（以及可能对人类分析师造成混淆）无法跟踪跳转目标。这是一个另一种反静态分析技术的例子，在
    [动态计算目标地址](ch21.html#dynamically_computed_target_addresses "动态计算目标地址") 中进行了讨论。在这种情况下，EAX寄存器中的值并不难确定，因为跳转之前有一个相对简单的指令序列。![图片](httpatomoreillycomsourcenostarchimages854063.png)处的`pop`指令将上一个示例中的调用指令的返回地址（`0A04B0D6`）加载到EAX寄存器中，而随后的指令![图片](httpatomoreillycomsourcenostarchimages854093.png)的效果是将EAX增加10。因此，跳转指令的目标是`0A04B0E0`，这是我们必须继续反汇编过程的位置。
- en: 'The final example of desynchronization taken from a different binary demonstrates
    how processor flags may be utilized to turn conditional jumps into absolute jumps.
    The following disassembly demonstrates the use of the x86 `Z` flag for just such
    a purpose:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的二进制文件中提取的最终不同步示例演示了如何利用处理器标志将条件跳转转换为绝对跳转。以下反汇编示例展示了x86 `Z`标志的使用目的：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, the `xor` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    is used to zero the EAX register and set the x86 `Z` flag. The programmer, knowing
    that the `Z` flag is set, utilizes a jump-on-zero (`jz`) instruction ![](httpatomoreillycomsourcenostarchimages854063.png),
    which will always be taken, to attain the effect of an unconditional jump. As
    a result, the instructions ![](httpatomoreillycomsourcenostarchimages854093.png)
    and ![](httpatomoreillycomsourcenostarchimages854095.png) between the jump and
    the jump target will never be executed and serve only to confuse any analyst who
    fails to realize this fact. Note that, once again, this example obscures the actual
    jump target by jumping into the middle of an instruction ![](httpatomoreillycomsourcenostarchimages854099.png).
    Properly disassembled, the code should read as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`xor`指令![图片](httpatomoreillycomsourcenostarchimages854061.png)用于将EAX寄存器清零并设置x86
    `Z`标志。程序员知道`Z`标志被设置，因此使用跳转零（`jz`）指令![图片](httpatomoreillycomsourcenostarchimages854063.png)，这将始终被执行，以达到无条件跳转的效果。因此，跳转和跳转目标之间的指令![图片](httpatomoreillycomsourcenostarchimages854093.png)和![图片](httpatomoreillycomsourcenostarchimages854095.png)将永远不会被执行，并且仅用于混淆未能意识到这一事实的分析员。请注意，再次强调，此示例通过跳入指令的中间部分![图片](httpatomoreillycomsourcenostarchimages854099.png)来隐藏实际的跳转目标。正确反汇编的代码应如下所示：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The actual target of the jump ![](httpatomoreillycomsourcenostarchimages854061.png)
    has been revealed, as has the extra byte ![](httpatomoreillycomsourcenostarchimages854063.png)
    that caused the desynchronization in the first place. It is certainly possible
    to use far more roundabout ways of setting and testing flags prior to executing
    a conditional jump. The level of difficulty for analyzing such code increases
    with the number of operations that may affect the CPU flag bits prior to testing
    their value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转的实际目标 ![图片](httpatomoreillycomsourcenostarchimages854061.png) 已经被揭示，同样，最初导致不同步的额外字节
    ![图片](httpatomoreillycomsourcenostarchimages854063.png) 也已被发现。当然，在执行条件跳转之前，可以使用更多迂回的方式来设置和测试标志。分析此类代码的难度随着可能影响CPU标志位之前操作的数量而增加。
- en: Dynamically Computed Target Addresses
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态计算目标地址
- en: Do not confuse the title of this section with an anti–dynamic analysis technique.
    The phrase *dynamically computed* simply means that an address to which execution
    will flow is computed at runtime. In this section we discuss several ways in which
    such an address can be derived. The intent of such techniques is to hide (obfuscate)
    the actual control flow path that a binary will follow from the prying eyes of
    the static analysis process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将本节的标题与反动态分析技术混淆。短语“动态计算”仅仅意味着执行流程将流向的地址是在运行时计算的。在本节中，我们将讨论几种可以派生此类地址的方法。这些技术的目的是为了隐藏（混淆）二进制程序将遵循的实际控制流路径，以避免静态分析过程的窥探。
- en: One example of this technique was shown in the preceding section. The example
    used a `call` statement to place a return address on the stack. The return address
    was popped directly off the stack into a register, and a constant value was added
    to the register to derive the final target address, which was ultimately reached
    by performing a jump to the location specified by the register contents.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中展示了这种技术的一个示例。该示例使用`call`语句将返回地址放置在栈上。返回地址被直接从栈中弹出并放入寄存器中，然后向寄存器中添加一个常数，以派生最终的目标地址，最终通过执行跳转到寄存器内容指定的位置来达到该地址。
- en: 'An infinite number of similar code sequences can be developed for deriving
    a target address and transferring control to that address. The following code,
    which wraps up the initial startup sequence in Shiva, demonstrates an alternate
    method for dynamically computing target addresses:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以开发出无限数量的类似代码序列，用于派生目标地址并将控制权转移到该地址。以下代码展示了Shiva初始启动序列的另一种动态计算目标地址的方法：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The comments in the right-hand margin document the changes being made to various
    CPU registers at each instruction. The process culminates in a derived value being
    moved into the top position of the stack (`TOS`) ![](httpatomoreillycomsourcenostarchimages854061.png),
    which causes the return instruction to transfer control to the computed location
    (`0A048068` in this case). Code sequences such as these can significantly increase
    the amount of work that must be performed during static analysis, as the analyst
    must essentially run the code by hand to determine the actual control flow path
    taken in the program.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧边栏中的注释记录了在每条指令下对各种CPU寄存器所做的更改。这个过程最终会将一个派生值移动到栈顶位置（`TOS`）![httpatomoreillycomsourcenostarchimages854061.png]，这会导致返回指令将控制权转移到计算出的位置（在本例中为`0A048068`）。这样的代码序列可能会显著增加静态分析期间必须执行的工作量，因为分析师必须手动运行代码以确定程序中实际的控制流路径。
- en: Much more complex types of control flow hiding have been developed and utilized
    in recent years. In the most complex cases, a program will use multiple threads
    or child processes to compute control flow information and receive that information
    via some form of interprocess communication (for child processes) or synchronization
    primitives (for multiple threads). In such cases, static analysis can become extremely
    difficult, as it becomes necessary to understand not only the behavior of multiple
    executable entities but also the exact manner by which those entities exchange
    information. For example, one thread may wait on a shared semaphore^([[151](#ftn.CHP-21-FN-3)])
    object, while a second thread computes values or modifies code that the first
    thread will make use of once the second thread signals its completion via the
    semaphore.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，已经开发并使用了更多复杂类型的控制流隐藏技术。在最复杂的情况下，程序将使用多个线程或子进程来计算控制流信息，并通过某种形式的过程间通信（对于子进程）或同步原语（对于多个线程）接收该信息。在这种情况下，静态分析可能变得极其困难，因为有必要理解多个可执行实体的行为，以及这些实体交换信息的确切方式。例如，一个线程可能在一个共享信号量^([[151](#ftn.CHP-21-FN-3)])对象上等待，而第二个线程计算值或修改代码，一旦第二个线程通过信号量发出完成信号，第一个线程将使用这些值或代码。
- en: 'Another technique, frequently used within Windows-oriented malware, involves
    configuring an exception handler,^([[152](#ftn.CHP-21-FN-4)]) intentionally triggering
    an exception, and then manipulating the state of the process’s registers while
    handling the exception. The following example is used by the tElock anti–reverse
    engineering tool to obscure the program’s actual control flow:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术，常用于面向Windows的恶意软件中，涉及配置异常处理程序，^([[152](#ftn.CHP-21-FN-4)]有意引发异常，然后在处理异常时操纵进程寄存器的状态。以下示例被tElock反逆向工程工具用于混淆程序的实际控制流：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The sequence begins by using a call ![](httpatomoreillycomsourcenostarchimages854061.png)
    to the next instruction ![](httpatomoreillycomsourcenostarchimages854063.png);
    the call instruction pushes `0041D07F` onto the stack as a return address, which
    is promptly popped off the stack into the EBP register ![](httpatomoreillycomsourcenostarchimages854063.png).
    Next ![](httpatomoreillycomsourcenostarchimages854093.png), the EAX register is
    set to the sum of EBP and `46h`, or `0041D0C5`, and this address is pushed onto
    the stack ![](httpatomoreillycomsourcenostarchimages854095.png) as the address
    of an exception handler function. The remainder of the exception handler setup
    takes place at ![](httpatomoreillycomsourcenostarchimages854099.png) and ![](httpatomoreillycomsourcenostarchimages854101.png),
    which complete the process of linking the new exception handler into the existing
    chain of exception handlers referenced by `fs:[0]`.^([[153](#ftn.CHP-21-FN-5)])
    The next step is to intentionally generate an exception ![](httpatomoreillycomsourcenostarchimages854103.png),
    in this case an `int 3`, which is a software trap (interrupt) to the debugger.
    In x86 programs, the `int 3` instruction is used by debuggers to implement a software
    breakpoint. Normally at this point, an attached debugger would gain control; in
    fact, if a debugger is attached, it will have the first opportunity to handle
    the exception, thinking that it is a breakpoint. In this case, the program fully
    expects to handle the exception, so any attached debugger must be instructed to
    pass the exception along to the program. Failing to allow the program to handle
    the exception may result in an incorrect operation and possibly a crash of the
    program. Without understanding how the `int 3` exception is handled, it is impossible
    to know what may happen next in this program. If we assume that execution simply
    resumes following the `int 3`, then it appears that a divide-by-zero exception
    will eventually be triggered by instructions ![](httpatomoreillycomsourcenostarchimages854133.png)
    and ![](httpatomoreillycomsourcenostarchimages854135.png).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 序列首先通过调用下一个指令 ![http://atomoreilly.com/source/no_starch_images/854061.png](http://atomoreilly.com/source/no_starch_images/854061.png)
    来开始；调用指令将 `0041D07F` 作为返回地址压入堆栈，然后立即从堆栈弹出并进入 EBP 寄存器 ![http://atomoreilly.com/source/no_starch_images/854063.png](http://atomoreilly.com/source/no_starch_images/854063.png)。接下来
    ![http://atomoreilly.com/source/no_starch_images/854093.png]，将 EAX 寄存器设置为 EBP
    和 `46h` 的和，即 `0041D0C5`，然后将此地址压入堆栈 ![http://atomoreilly.com/source/no_starch_images/854095.png]
    作为异常处理函数的地址。异常处理程序的其余设置在 ![http://atomoreilly.com/source/no_starch_images/854099.png](http://atomoreilly.com/source/no_starch_images/854099.png)
    和 ![http://atomoreilly.com/source/no_starch_images/854101.png] 进行，这完成了将新的异常处理程序链接到由
    `fs:[0]` 引用的现有异常处理程序链的过程。^([[153](#ftn.CHP-21-FN-5)]) 下一步是故意生成一个异常 ![http://atomoreilly.com/source/no_starch_images/854103.png](http://atomoreilly.com/source/no_starch_images/854103.png)，在这种情况下是一个
    `int 3`，这是一个软件陷阱（中断）到调试器。在 x86 程序中，`int 3` 指令被调试器用来实现软件断点。通常在这种情况下，连接的调试器将获得控制权；实际上，如果连接了调试器，它将首先有机会处理异常，认为它是一个断点。在这种情况下，程序完全期望处理异常，因此必须指示任何连接的调试器将异常传递给程序。如果程序无法处理异常，可能会导致操作不正确，甚至可能使程序崩溃。如果不了解如何处理
    `int 3` 异常，就无法知道在这个程序中接下来可能发生什么。如果我们假设执行在 `int 3` 后简单地继续，那么似乎指令 ![http://atomoreilly.com/source/no_starch_images/854133.png](http://atomoreilly.com/source/no_starch_images/854133.png)
    和 ![http://atomoreilly.com/source/no_starch_images/854135.png] 最终会触发除以零异常。
- en: 'The exception handler associated with the preceding code begins at address
    `0041D0C5`. The first portion of this function is shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面代码关联的异常处理程序从地址 `0041D0C5` 开始。此函数的前部分如下所示：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The third argument ![](httpatomoreillycomsourcenostarchimages854061.png) to
    the exception handler function is a pointer to a Windows `CONTEXT` structure (defined
    in the Windows API header file *winnt.h*). The `CONTEXT` structure is initialized
    with the contents of all CPU registers as they existed at the time of the exception.
    An exception handler has the opportunity to inspect and, if desired, modify the
    contents of the `CONTEXT` structure. If the exception handler feels that it has
    corrected the problem that led to the exception, it can notify the operating system
    that the offending thread should be allowed to continue. At this point the operating
    system reloads the CPU registers for the thread from the `CONTEXT` structure that
    was provided to the exception handler, and execution of the thread resumes as
    if nothing had ever happened.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理函数的第三个参数 ![](httpatomoreillycomsourcenostarchimages854061.png) 是指向 Windows
    `CONTEXT` 结构（在 Windows API 头文件 *winnt.h* 中定义）的指针。`CONTEXT` 结构初始化为异常发生时所有 CPU 寄存器的内容。异常处理程序有机会检查，如果需要，修改
    `CONTEXT` 结构的内容。如果异常处理程序认为它已经纠正了导致异常的问题，它可以通知操作系统允许有问题的线程继续。此时，操作系统从提供给异常处理程序的
    `CONTEXT` 结构中重新加载线程的 CPU 寄存器，线程的执行就像什么都没发生过一样继续。
- en: In the preceding example, the exception handler begins by accessing the thread’s
    `CONTEXT` ![](httpatomoreillycomsourcenostarchimages854063.png) in order to increment
    the instruction pointer ![](httpatomoreillycomsourcenostarchimages854093.png),
    thus moving beyond the instruction that generated the exception. Next, the exception’s
    type code (a field within the provided `EXCEPTION_RECORD` ![](httpatomoreillycomsourcenostarchimages854095.png))
    is retrieved ![](httpatomoreillycomsourcenostarchimages854099.png) in order to
    determine the nature of the exception. This portion of the exception handler deals
    with the divide-by-zero error ![](httpatomoreillycomsourcenostarchimages854101.png),
    generated in the previous example, by zeroing ![](httpatomoreillycomsourcenostarchimages854103.png)
    all of the x86 hardware debugging registers.^([[154](#ftn.CHP-21-FN-6)]) Without
    examining the remainder of the tElock code, it is not immediately apparent why
    the debug registers are being cleared. In this case, tElock is clearing values
    from a previous operation in which it used the debug registers to set four breakpoints
    in addition to the `int 3` seen previously. In addition to obfuscating the true
    flow of the program, clearing or modifying the x86 debug registers can wreak havoc
    with software debuggers such as OllyDbg or IDA’s own internal debugger. Such anti-debugging
    techniques are discussed in [Anti–Dynamic Analysis Techniques](ch21s02.html "Anti–Dynamic
    Analysis Techniques") in [Anti–Dynamic Analysis Techniques](ch21s02.html "Anti–Dynamic
    Analysis Techniques").
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，异常处理程序首先访问线程的 `CONTEXT` ![](httpatomoreillycomsourcenostarchimages854063.png)
    以增加指令指针 ![](httpatomoreillycomsourcenostarchimages854093.png)，从而跳过产生异常的指令。接下来，检索异常的类型代码（在提供的
    `EXCEPTION_RECORD` ![](httpatomoreillycomsourcenostarchimages854095.png) 中的一个字段）以确定异常的性质。这部分异常处理程序通过将所有
    x86 硬件调试寄存器清零 ![](httpatomoreillycomsourcenostarchimages854101.png) 来处理前面例子中生成的除以零错误
    ![](httpatomoreillycomsourcenostarchimages854103.png)。在不检查 tElock 代码其余部分的情况下，不清楚为什么调试寄存器会被清除。在这种情况下，tElock
    正在清除之前操作中使用的调试寄存器设置的四个断点以及之前看到的 `int 3`。除了混淆程序的真正流程外，清除或修改 x86 调试寄存器可能会对 OllyDbg
    或 IDA 自身内部调试器等软件调试器造成破坏。这类反调试技术将在 [反动态分析技术](ch21s02.html "反动态分析技术") 中讨论。
- en: Opcode Obfuscation
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令码混淆
- en: While the techniques described to this point may provide—in fact, are intended
    to provide—a hindrance to understanding a program’s control flow, none prevent
    you from observing the correct disassembled form of a program you are analyzing.
    Desynchronization had the greatest impact on the disassembly, but it was easily
    defeated by reformatting the disassembly to reflect the correct instruction flow.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止所描述的技术可能——事实上，其目的是——为理解程序的流程提供障碍，但没有任何一种技术能阻止你观察你正在分析程序的正确反汇编形式。去同步对反汇编的影响最大，但通过重新格式化反汇编以反映正确的指令流，它很容易被克服。
- en: A more effective technique for preventing correct disassembly is to encode or
    encrypt the actual instructions when the executable file is being created. The
    obfuscated instructions are useless to the CPU and must be de-obfuscated back
    to their original form before they are fetched for execution by the CPU. Therefore,
    at least some portion of the program must remain unencrypted in order to serve
    as the startup routine, which, in the case of an obfuscated program, is usually
    responsible for de-obfuscating some or all of the remainder of the program. A
    very generic overview of the obfuscation process is shown in [Figure 21-1](ch21.html#generic_obfuscation_process
    "Figure 21-1. Generic obfuscation process").
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 防止正确反汇编的一个更有效的方法是在创建可执行文件时对实际指令进行编码或加密。混淆后的指令对 CPU 无用，必须在 CPU 取出执行之前将其解混淆回原始形式。因此，程序中至少有一部分必须保持未加密状态，以便作为启动例程，在混淆程序的情况下，通常负责解混淆程序剩余部分或全部。图
    21-1 展示了混淆过程的非常通用的概述。[图 21-1](ch21.html#generic_obfuscation_process "图 21-1. 通用混淆过程")。
- en: '![Generic obfuscation process](httpatomoreillycomsourcenostarchimages854316.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![通用混淆过程](httpatomoreillycomsourcenostarchimages854316.png)'
- en: Figure 21-1. Generic obfuscation process
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21-1. 通用混淆过程
- en: As shown, the input to the process is a program that a user wishes to obfuscate
    for some reason. In many cases, the input program is written using standard programming
    languages and build tools (editors, compilers, and the like) with little thought
    required about the obfuscation to come. The resulting executable file is fed into
    an obfuscation utility, which transforms the binary into a functionally equivalent,
    yet obfuscated, binary. As depicted, the obfuscation utility is responsible for
    obfuscating the original program’s code and data sections and adding additional
    code (a de-obfuscation stub) that performs the task of de-obfuscating the code
    and data before the original functionality can be accessed at runtime. The obfuscation
    utility also modifies the program headers to redirect the program entry point
    to the de-obfuscation stub, ensuring that execution begins with the de-obfuscation
    process. Following de-obfuscation, execution typically transfers to the entry
    point of the original program, which begins execution as if it had never been
    obfuscated at all.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，该过程的输入是一个用户出于某种原因希望混淆的程序。在许多情况下，输入程序是使用标准编程语言和构建工具（编辑器、编译器等）编写的，对即将到来的混淆几乎没有考虑。生成的可执行文件被输入到混淆工具中，该工具将二进制文件转换为功能等效但已混淆的二进制文件。如图所示，混淆工具负责混淆原始程序的代码和数据部分，并添加额外的代码（解混淆占位符），在原始功能可以在运行时访问之前执行解混淆代码和数据。混淆工具还修改程序头，将程序入口点重定向到解混淆占位符，确保执行从解混淆过程开始。解混淆后，执行通常转移到原始程序的入口点，程序开始执行，就像它从未被混淆过一样。
- en: This oversimplified process varies widely based on the obfuscation utility that
    is used to create the obfuscated binary. An ever-increasing number of utilities
    are available to handle the obfuscation process. Such utilities offer features
    ranging from compression to anti-disassembly and anti-debugging techniques. Examples
    include programs such as UPX^([[155](#ftn.CHP-21-FN-7)]) (compressor, also works
    with ELF), ASPack^([[156](#ftn.CHP-21-FN-8)]) (compressor), ASProtect (anti–reverse
    engineering by the makers of ASPack), and tElock^([[157](#ftn.CHP-21-FN-9)]) (compression
    and anti–reverse engineering) for Windows PE files, and Burneye^([[158](#ftn.CHP-21-FN-10)])
    (encryption) and Shiva^([[159](#ftn.CHP-21-FN-11)]) (encryption and anti-debugging)
    for Linux ELF binaries. The capabilities of obfuscation utilities have advanced
    to the point that some anti–reverse engineering tools such as WinLicense^([[160](#ftn.CHP-21-FN-12)])
    provide more integration throughout the entire build process, allowing programmers
    to integrate anti–reverse engineering features at every step, from source code
    through post-processing the compiled binary file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过于简化的过程根据用于创建混淆二进制文件的混淆实用程序而大相径庭。可用的混淆处理工具数量不断增加。这些实用程序提供从压缩到反汇编和反调试技术的各种功能。例如，包括
    UPX^([[155](#ftn.CHP-21-FN-7)])（压缩器，也适用于 ELF）、ASPack^([[156](#ftn.CHP-21-FN-8)])（压缩器）、ASProtect（由
    ASPack 制造商提供的反逆向工程）和 tElock^([[157](#ftn.CHP-21-FN-9)])（压缩和反逆向工程）用于 Windows PE
    文件，以及 Burneye^([[158](#ftn.CHP-21-FN-10)])（加密）和 Shiva^([[159](#ftn.CHP-21-FN-11)])（加密和反调试）用于
    Linux ELF 二进制文件。混淆实用程序的能力已经发展到一些反逆向工程工具（如 WinLicense^([[160](#ftn.CHP-21-FN-12)])）在整个构建过程中提供更多集成的程度，允许程序员在从源代码到编译二进制文件的后期处理每个步骤中集成反逆向工程功能。
- en: A more recent evolution in the world of obfuscation programs involves wrapping
    the original executable with a virtual machine execution engine. Depending on
    the sophistication of the virtualizing obfuscator, the original machine code may
    never execute directly; instead that code is interpreted by a byte code–oriented
    virtual machine. Very sophisticated virtualizers are capable of generating unique
    virtual machine instances each time they run, making it difficult to create an
    all-purpose de-obfuscation algorithm to defeat them. VMProtect^([[161](#ftn.CHP-21-FN-13)])
    is one example of a virtualizing obfuscator. VMProtect was used to obfuscate the
    Clampi^([[162](#ftn.CHP-21-FN-14)]) trojan.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在混淆程序的世界中，最近的一个演变趋势是将原始的可执行文件包裹在一个虚拟机执行引擎中。根据虚拟化混淆器的复杂程度，原始的机器代码可能永远不会直接执行；相反，该代码由一个面向字节码的虚拟机进行解释。非常复杂的虚拟化器能够在每次运行时生成独特的虚拟机实例，这使得创建一个通用的反混淆算法来击败它们变得困难。VMProtect^([[161](#ftn.CHP-21-FN-13)])
    是一个虚拟化混淆器的例子。VMProtect 被用来混淆 Clampi^([[162](#ftn.CHP-21-FN-14)]) 木马。
- en: As with any offensive technology, defensive measures have been developed to
    counter many anti–reverse engineering tools. In most cases the goal of such tools
    is to recover the original, unprotected executable file (or a reasonable facsimile),
    which can then be analyzed using more traditional tools such as disassemblers
    and debuggers. One such tool designed to de-obfuscate Windows executables is called
    QuickUnpack.^([[163](#ftn.CHP-21-FN-15)]) QuickUnpack, like many other automated
    unpackers, operates by functioning as a debugger and allowing an obfuscated binary
    to execute through its de-obfuscation phase and then capturing the process image
    from memory. Beware that this type of tool actually runs potentially malicious
    programs in the hope of intercepting the execution of those programs after they
    have unpacked or de-obfuscated themselves but before they have a chance to do
    anything malicious. Thus, you should always execute such programs in a sandbox-type
    environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何攻击性技术一样，为了对抗许多反逆向工程工具，已经开发出了防御措施。在大多数情况下，这些工具的目标是恢复原始的、未受保护的执行文件（或合理的复制品），然后可以使用更传统的工具（如反汇编器和调试器）进行分析。一个专门设计用来反混淆
    Windows 可执行文件的工具叫做 QuickUnpack.^([[163](#ftn.CHP-21-FN-15)])。QuickUnpack，就像许多其他自动化解包器一样，通过充当调试器来工作，允许混淆的二进制文件通过其反混淆阶段执行，并从内存中捕获进程映像。请注意，这类工具实际上在希望拦截程序在解包或反混淆之后、但在它们有机会进行恶意操作之前执行潜在恶意程序。因此，您应该始终在沙盒环境中执行此类程序。
- en: Using a purely static analysis environment to analyze obfuscated code is a challenging
    task at best. Without being able to execute the de-obfuscation stub, some means
    of unpacking or decrypting the obfuscated portions of the binary must be employed
    before disassembly of the obfuscated code can begin. [Figure 21-2](ch21.html#ida_navigation_band_for_a_binary_packed
    "Figure 21-2. IDA navigation band for a binary packed using UPX") shows the layout
    of an executable that has been packed using the UPX packer. The only portion of
    the address space that IDA has identified as code is the thin stripe at ![](httpatomoreillycomsourcenostarchimages854061.png),
    which happens to be the UPX decompression stub.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯静态分析环境分析混淆代码是至多具有挑战性的任务。在无法执行解混淆占位符的情况下，在开始解混淆代码的解汇编之前，必须采用某种解包或解密二进制文件混淆部分的方法。[图 21-2](ch21.html#ida_navigation_band_for_a_binary_packed
    "图 21-2. 使用 UPX 打包的二进制文件的 IDA 导航带") 显示了使用 UPX 打包的可执行文件的布局。IDA 识别为代码的唯一地址空间部分是
    ![](httpatomoreillycomsourcenostarchimages854061.png) 的细条带，这恰好是 UPX 解压缩占位符。
- en: '![IDA navigation band for a binary packed using UPX](httpatomoreillycomsourcenostarchimages854318.png.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![使用 UPX 打包的二进制文件的 IDA 导航带](httpatomoreillycomsourcenostarchimages854318.png.jpg)'
- en: Figure 21-2. IDA navigation band for a binary packed using UPX
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21-2. 使用 UPX 打包的二进制文件的 IDA 导航带
- en: 'Examination of the contents of the address space would reveal empty space to
    the left of ![](httpatomoreillycomsourcenostarchimages854063.png) and apparently
    random data in the region between ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png). The random data is
    the result of the UPX compression process, and the job of the decompression stub
    is to unpack that data into the empty region at the left of the navigation band
    before finally transferring control to the unpacked code. Note that the unusual
    appearance of the navigation band is a potential tip-off that this binary has
    been obfuscated in some manner. In fact, a number of things typically stand out
    when viewing an obfuscated binary with IDA. Some potential tip-offs that a binary
    is obfuscated include the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 检查地址空间的内容将揭示在 ![](httpatomoreillycomsourcenostarchimages854063.png) 的左侧有空白空间，在
    ![](httpatomoreillycomsourcenostarchimages854061.png) 和 ![](httpatomoreillycomsourcenostarchimages854063.png)
    之间区域有看似随机的数据。这些随机数据是 UPX 压缩过程的结果，解压缩占位符的任务是将这些数据解包到导航带左侧的空白区域，然后在最终将控制权传递给解包的代码之前。请注意，导航带的不寻常外观可能是这种二进制文件被以某种方式混淆的潜在提示。实际上，在用
    IDA 查看混淆的二进制文件时，通常会突出显示一些东西。以下是一些表明二进制文件被混淆的潜在提示：
- en: Very little code is highlighted in the navigation band.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航带中高亮的代码非常少。
- en: Very few functions are listed in the Functions window. Often only the `start`
    function will appear.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数窗口中列出的函数非常少。通常只会出现 `start` 函数。
- en: Very few imported functions are listed in the Imports window.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入窗口中列出的导入函数非常少。
- en: Very few legible strings appear in the Strings window (not opened by default).
    Often only the names of the few imported libraries and functions will be visible.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串窗口（默认情况下未打开）中，可辨认的字符串非常少。通常情况下，只能看到少数导入的库和函数的名称。
- en: One or more program sections will be both writable and executable.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个程序部分将是可写和可执行的。
- en: Nonstandard section names such as `UPX0` or `.shrink` are used.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非标准部分名称，如 `UPX0` 或 `.shrink`。
- en: SANDBOX ENVIRONMENTS
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 沙箱环境
- en: The purpose of a *sandbox environment* for reverse engineering is to allow you
    to execute a program in a manner that allows observation of the program’s behavior
    without allowing that behavior to adversely impact critical components of your
    reverse engineering platform. Sandbox environments are commonly constructed using
    platform virtualization software such asd VMware,^([[164](#ftn.CHP-21-FN-16)])
    but they may be constructed on dedicated systems that are capable of being restored
    to a known good state following the execution of any malware.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 反向工程中沙箱环境的目的在于允许你在一种方式下执行程序，这种方式允许观察程序的行为，同时不允许这种行为对你的逆向工程平台的关键组件产生不利影响。沙箱环境通常使用平台虚拟化软件（如
    VMware）构建，^([[164](#ftn.CHP-21-FN-16)]) 但它们也可以在执行任何恶意软件后能够恢复到已知良好状态的专用系统上构建。
- en: A common feature of sandbox systems is the fact that they are typically heavily
    instrumented in order to observe and collect information on the behavior of programs
    run within the sandbox. Collected data may include information on the file system
    activity of a program, on the registry activity of a (Windows) program, and about
    any networking activity generated by the program.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒系统的常见特征是它们通常被大量仪器化，以便观察和收集在沙盒中运行的程序的行为信息。收集的数据可能包括有关程序文件系统活动、(Windows) 程序注册表活动以及程序生成的任何网络活动信息。
- en: 'The information presented in the navigation band can be correlated with the
    properties of each segment within the binary to determine whether the information
    presented in each display is consistent. The segments listing for this binary
    is shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 导航带中显示的信息可以与二进制中每个段的属性相关联，以确定每个显示的信息是否一致。此二进制的段列表如下所示：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this case, the entire range of addresses comprising segment `UPX0` ![](httpatomoreillycomsourcenostarchimages854061.png)
    and segment `UPX1` ![](httpatomoreillycomsourcenostarchimages854063.png) (`00401000-00409000`)
    is marked as executable (the `X` flag is set). Given this fact, we should expect
    to see the entire navigation band colorized to represent code. The fact that we
    do not, coupled with the fact that inspection reveals the entire range of `UPX0`
    to be empty, should be considered highly suspicious. Within IDA, the section header
    for `UPX0` contains the following lines:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，包含段 `UPX0` ![图片](http://atomoreilly.com/source/nostarch/images/854061.png)
    和段 `UPX1` ![图片](http://atomoreilly.com/source/nostarch/images/854063.png) (`00401000-00409000`)
    的整个地址范围被标记为可执行（设置了 `X` 标志）。鉴于这一事实，我们应该期望看到整个导航带被着色以表示代码。我们没有看到这一点，加上检查发现 `UPX0`
    的整个范围都是空的，应该被视为高度可疑。在 IDA 中，`UPX0` 的部分标题包含以下行：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Techniques for using IDA to perform the decompression operation in a static
    context (without actually executing the binary) are discussed in [Static De-obfuscation
    of Binaries Using IDA](ch21s03.html "Static De-obfuscation of Binaries Using IDA")
    in [Static De-obfuscation of Binaries Using IDA](ch21s03.html "Static De-obfuscation
    of Binaries Using IDA").
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用 IDA 在静态环境中执行解压缩操作的技术](https://wiki.example.org/ch21s03.html "使用 IDA 在静态环境中执行解压缩操作的技术")中讨论了使用
    IDA 进行二进制静态去混淆的方法([Static De-obfuscation of Binaries Using IDA](https://wiki.example.org/ch21s03.html
    "Static De-obfuscation of Binaries Using IDA))。
- en: Imported Function Obfuscation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入函数混淆
- en: In order to avoid leaking information about potential actions that a binary
    may perform, an additional anti–static analysis technique is aimed at making it
    difficult to determine which shared libraries and library functions are used within
    an obfuscated binary. In most cases, it is possible to render tools such as `dumpbin`,
    `ldd`, and `objdump` ineffective for the purposes of listing library dependencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免泄露关于二进制可能执行的操作的信息，一种额外的反静态分析技术旨在使确定在混淆的二进制中使用的共享库和库函数变得困难。在大多数情况下，可以使 `dumpbin`、`ldd`
    和 `objdump` 等工具在列出库依赖关系方面失效。
- en: 'The effect of such obfuscations on IDA is most obvious in the Imports window.
    The entire content of the Imports window for our earlier tElock example is shown
    here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混淆对 IDA 的影响在导入窗口中最为明显。我们之前 tElock 示例的导入窗口的全部内容如下所示：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Only two external functions are referenced, `GetModulehandleA` (from *kernel32.dll*)
    and `MessageBoxA` (from *user32.dll*). Virtually nothing about the behavior of
    the program can be inferred from this short list. How then does such a program
    get anything useful accomplished? Here again the techniques are varied, but they
    essentially boil down to the fact that the program itself must load any additional
    libraries that it depends on, and once the libraries are loaded, the program must
    locate any required functions within those libraries. In most cases, these tasks
    are performed by the de-obfuscation stub prior to transferring control to the
    de-obfuscated program. The end goal is for the program’s import table to have
    been properly initialized, just as if the process had been performed by the operating
    system’s own loader.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 仅引用了两个外部函数，`GetModulehandleA`（来自`kernel32.dll`）和`MessageBoxA`（来自`user32.dll`）。从这个简短的列表中几乎无法推断出程序的行为。那么这样的程序是如何完成任何有用的工作的呢？在这里，技术多种多样，但本质上归结为程序本身必须加载它所依赖的任何附加库，一旦库被加载，程序必须在那些库中定位所需的函数。在大多数情况下，这些任务是由解混淆存根在将控制权传递给解混淆程序之前执行的。最终目标是确保程序的导入表已经正确初始化，就像是由操作系统的自身加载器执行的过程一样。
- en: For Windows binaries, a simple approach is to use the `LoadLibrary` function
    to load required libraries by name and then perform function address lookups within
    each library using the `GetProcAddress` function. In order to use these functions,
    a program must be either explicitly linked to them or have an alternate means
    of looking them up. The Names listing for the tElock example does not include
    either of these functions, while the Names listing for the UPX example shown here
    includes both.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows可执行文件，一种简单的方法是使用`LoadLibrary`函数通过名称加载所需的库，然后使用`GetProcAddress`函数在每个库中执行函数地址查找。为了使用这些函数，程序必须明确链接到它们或具有查找它们的替代方法。tElock示例的名称列表不包括这两个函数，而此处显示的UPX示例的名称列表包括这两个函数。
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The actual UPX code responsible for rebuilding the import table is shown in
    [Example 21-1](ch21.html#import_table_reconstruction_in_upx "Example 21-1. Import
    table reconstruction in UPX").
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 负责重建导入表的实际UPX代码显示在[示例21-1](ch21.html#import_table_reconstruction_in_upx "示例21-1.
    UPX中的导入表重建")中。
- en: Example 21-1. Import table reconstruction in UPX
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 示例21-1. UPX中的导入表重建
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This example contains an outer loop responsible for calling `LoadLibraryA`^([[165](#ftn.CHP-21-FN-17)])
    ![](httpatomoreillycomsourcenostarchimages854061.png) and an inner loop responsible
    for calling `GetProcAddress` ![](httpatomoreillycomsourcenostarchimages854063.png).
    Following each successful call to `GetProcAddress`, the newly retrieved function
    address is stored into the reconstructed import table ![](httpatomoreillycomsourcenostarchimages854093.png).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含一个外循环，用于调用`LoadLibraryA`^([[165](#ftn.CHP-21-FN-17)]) ![](httpatomoreillycomsourcenostarchimages854061.png)，以及一个内循环，用于调用`GetProcAddress`
    ![](httpatomoreillycomsourcenostarchimages854063.png)。在每次成功调用`GetProcAddress`之后，新检索到的函数地址被存储到重建的导入表中
    ![](httpatomoreillycomsourcenostarchimages854093.png)。
- en: These loops are executed as the last portion of the UPX de-obfuscation stub,
    because each function takes string pointer parameters that point to either a library
    name or a function name, and the associated strings are held within the compressed
    data region to avoid detection by the `strings` utility. As a result, library
    loading in UPX cannot take place until the required strings have been decompressed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些循环作为UPX解混淆存根的最后部分执行，因为每个函数都接受指向库名称或函数名称的字符串指针参数，并且相关的字符串被保存在压缩数据区域中，以避免被`strings`实用程序检测。因此，在所需的字符串被解压缩之前，UPX中的库加载无法进行。
- en: 'Returning to the tElock example, a different problem presents itself. With
    only two imported functions, neither of which is `LoadLibraryA` or `GetProcAddress`,
    how can the tElock utility perform the function-resolution tasks that were performed
    by UPX? All Windows processes depend on *kernel32.dll*, which means that it is
    present in memory for all processes. If a program can locate *kernel32.dll*, a
    relatively straightforward process may be followed to locate any function within
    the DLL, including `LoadLibraryA` and `GetProcAddress`. As shown previously, with
    these two functions in hand, it is possible to load any additional libraries required
    by the process and locate all required functions within those libraries. In his
    paper “Understanding Windows Shellcode,”^([[166](#ftn.CHP-21-FN-18)]) Skape discusses
    techniques for doing exactly this. While tElock does not use the exact techniques
    detailed by Skape, there are many parallels, and the net effect is to obscure
    the details of the loading and linking process. Without carefully tracing the
    program’s instructions, it is extremely easy to overlook the loading of a library
    or the lookup of a function address. The following small code fragment illustrates
    the manner in which tElock attempts to locate the address of `LoadLibraryA`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回到tElock的例子，出现了一个不同的问题。只有两个导入函数，都不是`LoadLibraryA`或`GetProcAddress`，tElock工具如何执行UPX所执行的功能解析任务？所有Windows进程都依赖于`kernel32.dll`，这意味着它在所有进程中都存在于内存中。如果一个程序可以定位到`kernel32.dll`，那么可以遵循一个相对直接的过程来定位DLL中的任何函数，包括`LoadLibraryA`和`GetProcAddress`。正如之前所展示的，有了这两个函数，就可以加载进程所需的任何额外库，并定位那些库中的所有所需函数。在论文“理解Windows
    Shellcode”中，Skape讨论了执行这一任务的技术。虽然tElock没有使用Skape详细说明的精确技术，但有很多相似之处，最终效果是模糊了加载和链接过程的细节。如果不仔细追踪程序的指令，很容易忽略库的加载或函数地址的查找。以下是一个小代码片段，说明了tElock尝试定位`LoadLibraryA`地址的方式：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It is immediately obvious that several comparisons are taking place in rapid
    succession. What may not be immediately clear is the purpose of these comparisons.
    Reformatting the operands used in each comparison sheds a little light on the
    code, as seen here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，几个比较是连续进行的。可能不太清楚的是这些比较的目的。重新格式化每个比较中使用的操作数，可以稍微揭示代码，如下所示：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each hexadecimal constant is actually a sequence of four ASCII characters, which
    taken in order (recall that the x86 is a little-endian processor and we need to
    read the characters in reverse order) spell `LoadLibraryA`. If the three comparisons
    succeed, then tElock has located the export table entry for `LoadLibraryA`, and
    in a few short operations, the address of this function will be obtained and available
    for use in loading additional libraries. An interesting characteristic of tElock’s
    approach to function lookup is that it is somewhat resistant to strings analysis
    because the 4-byte constants embedded directly in the program’s instructions do
    not look like more standard, null-terminated strings and thus do not get included
    in strings lists generated by IDA.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个十六进制常量实际上是一系列四个ASCII字符，按照顺序（记住x86是一个小端处理器，我们需要按相反的顺序读取字符）拼写出`LoadLibraryA`。如果这三个比较都成功，那么tElock已经找到了`LoadLibraryA`的导出表条目，并且通过几个简短的操作，这个函数的地址将被获得并可用于加载额外的库。tElock在函数查找方面的一个有趣特点是它对字符串分析有一定的抵抗力，因为直接嵌入程序指令中的4字节常量看起来不像更标准的null终止字符串，因此不会包含在IDA生成的字符串列表中。
- en: 'Manually reconstructing a program’s import table through careful analysis of
    the program’s code is made easier in the case of UPX and tElock because, ultimately,
    they both contain ASCII character data that we can use to determine exactly which
    libraries and which functions are being referenced. Skape’s paper details a function-resolution
    process in which no strings at all appear within the code. The basic idea discussed
    in the paper is to precompute a unique hash^([[167](#ftn.CHP-21-FN-19)]) value
    for the name of each function that you need to resolve. To resolve each function,
    a search is conducted through a library’s exported names table. Each name in the
    table is hashed, and the resulting hash is compared against the precomputed hash
    value for the desired function. If the hashes match, the desired function has
    been located, and you can easily find its address in the library’s export address
    table. In order to statically analyze binaries obfuscated in this manner, you
    need to understand the hashing algorithm used for each function name and apply
    that algorithm to all of the names exported by the library that the program is
    searching. With a complete table of hashes in hand, you will be able to do a simple
    lookup of each hash that you encounter in the program to determine which function
    the hash references.^([[168](#ftn.CHP-21-FN-20)]) A portion of such a table, generated
    for kernel32.dll, might look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在UPX和tElock的情况下，通过仔细分析程序代码手动重建程序导入表变得更容易，因为最终，它们都包含我们可以用来确定引用了哪些库和哪些函数的ASCII字符数据。Skape的论文详细描述了一个函数解析过程，其中代码中根本不出现任何字符串。论文中讨论的基本思想是为每个需要解析的函数名称预先计算一个唯一的哈希值^([[167](#ftn.CHP-21-FN-19)])。为了解析每个函数，会在库的导出名称表中进行搜索。表中的每个名称都会进行哈希处理，得到的哈希值与预先计算的所需函数的哈希值进行比较。如果哈希值匹配，则找到了所需的函数，并且可以轻松地在库的导出地址表中找到其地址。为了静态分析以这种方式混淆的二进制文件，需要了解每个函数名称使用的哈希算法，并将该算法应用于程序正在搜索的库导出的所有名称。有了完整的哈希表，你将能够简单地查找程序中遇到的每个哈希值，以确定它引用的是哪个函数.^([[168](#ftn.CHP-21-FN-20)])
    为kernel32.dll生成的此类表的一部分可能看起来像这样：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that the hash values are specific to the hash function being used within
    a particular binary and are likely to vary from one binary to another. Using this
    particular table, if the hash value `8A0FB5E2` ![](httpatomoreillycomsourcenostarchimages854061.png)
    was encountered within a program, we could quickly determine that the program
    was attempting to look up the address of the `GetProcAddress` function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，哈希值是特定于特定二进制文件中使用的哈希函数的，并且可能因二进制文件而异。使用这个特定的表，如果在程序中遇到哈希值`8A0FB5E2` ![](httpatomoreillycomsourcenostarchimages854061.png)，我们可以迅速确定程序正在尝试查找`GetProcAddress`函数的地址。
- en: Skape’s use of hash values to resolve function names was originally developed
    and documented for use in exploit payloads for Windows vulnerabilities; however,
    hash values have been adopted for use in obfuscated programs as well. The WinLicense
    obfuscation utility is one example that makes use of such hashing techniques to
    disguise its behavior.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Skape使用哈希值解析函数名称的方法最初是为Windows漏洞的利用有效载荷开发并记录的；然而，哈希值已经被用于混淆程序中。WinLicense混淆工具就是利用这种哈希技术来伪装其行为的例子之一。
- en: A final note on import tables is that, interestingly, IDA is sometimes able
    to offer you a clue that something is not quite right with a program’s import
    table. Obfuscated Windows binaries often have sufficiently altered import tables
    that IDA will notify you that something seems out of the ordinary with such a
    binary. [Figure 21-3](ch21.html#mangled_imports_segment_warning_dialog "Figure 21-3. Mangled
    imports segment warning dialog") shows the warning dialog that IDA displays in
    such cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导入表的一个最后的说明是，有趣的是，IDA有时能够提供一些线索，表明程序导入表可能有些不正常。混淆的Windows二进制文件通常有足够改变的导入表，以至于IDA会通知你这样的二进制文件似乎有些异常。[图21-3](ch21.html#mangled_imports_segment_warning_dialog
    "图21-3. 损坏的导入段警告对话框")显示了IDA在这种情况下显示的警告对话框。
- en: '![Mangled imports segment warning dialog](httpatomoreillycomsourcenostarchimages854321.png.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![损坏的导入段警告对话框](httpatomoreillycomsourcenostarchimages854321.png.jpg)'
- en: Figure 21-3. Mangled imports segment warning dialog
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-3. 损坏的导入段警告对话框
- en: This dialog provides one of the earliest indications that a binary may have
    been obfuscated in some manner and should serve as a warning that the binary may
    be difficult to analyze. Thus, you should take care while analyzing the binary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框提供了最早的迹象之一，表明二进制文件可能以某种方式被混淆，应作为警告，表明二进制文件可能难以分析。因此，在分析二进制文件时应小心行事。
- en: Targeted Attacks on Analysis Tools
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对分析工具的针对性攻击
- en: This category of anti–reverse engineering capability is mentioned only because
    of its unique potential to hinder reverse engineering efforts. Most reverse engineering
    tools can be viewed as highly specialized parsers that process input data to provide
    some sort of summary information or detail display. As software, these tools are
    not immune to the same types of vulnerabilities that affect all other software.
    Specifically, incorrect handling of user-supplied data may, in some cases, lead
    to exploitable conditions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 提及此类反逆向工程能力仅是因为它具有阻碍逆向工程努力的独特潜力。大多数逆向工程工具可以被视为高度专业的解析器，它们处理输入数据以提供某种总结信息或详细显示。作为软件，这些工具不会免受影响所有其他软件的相同类型漏洞的影响。具体来说，在处理用户提供的输入数据时，在某些情况下可能会导致可利用的条件。
- en: In addition to the techniques we have discussed thus far, programmers intent
    on preventing analysis of their software may opt for a more active form of anti–reverse
    engineering. By properly crafting input files, it may be possible to create a
    program that is both valid enough to execute properly and mal-formed enough to
    exploit a vulnerability in a reverse engineering tool. Such vulnerabilities, while
    uncommon, have been documented to include vulnerabilities in IDA.^([[169](#ftn.CHP-21-FN-21)])
    The goal of the attacker is to exploit the fact that a piece of malware is likely
    to get loaded into IDA at some point. At a minimum, the attacker may achieve a
    denial of service in which IDA always crashes before a database can be created;
    alternatively, the attacker may gain access to the analyst’s computer and associated
    network. Users concerned with this type of attack should consider performing all
    initial analysis tasks in a sandbox environment. For example, you might run a
    copy of IDA in a sandbox to create the initial database for all binaries. The
    initial database (which in theory is free from any malicious capability) can then
    be distributed to additional analysts, who need never touch the original binary
    file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前讨论的技术之外，那些意图防止对其软件进行分析的程序员可能会选择一种更积极的反逆向工程形式。通过适当构建输入文件，可能创建一个既足够有效以正确执行又足够损坏以利用逆向工程工具漏洞的程序。虽然这种漏洞不常见，但已记录包括
    IDA 中的漏洞.^([[169](#ftn.CHP-21-FN-21)]) 攻击者的目标是利用恶意软件可能最终被加载到 IDA 中的事实。至少，攻击者可能实现拒绝服务，导致
    IDA 在创建数据库之前总是崩溃；或者，攻击者可能访问分析师的计算机及其相关网络。对这类攻击感到担忧的用户应考虑在沙盒环境中执行所有初始分析任务。例如，你可以在沙盒中运行
    IDA 的副本以创建所有二进制文件的初始数据库。初始数据库（理论上不包含任何恶意功能）然后可以分发给其他分析师，他们无需接触原始二进制文件。
- en: '* * *'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[149](#CHP-21-FN-1)]) Shaun Clowes and Neel Mehta first introduced Shiva
    at CanSecWest in 2003\. See [http://www.cansecwest.com/core03/shiva.ppt](http://www.cansecwest.com/core03/shiva.ppt).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[149](#CHP-21-FN-1)]) Shaun Clowes 和 Neel Mehta 首次在 2003 年的 CanSecWest 上介绍了
    Shiva。请参阅[http://www.cansecwest.com/core03/shiva.ppt](http://www.cansecwest.com/core03/shiva.ppt)。
- en: ^([[150](#CHP-21-FN-2)]) The x86 `iret` instruction is used to return from an
    interrupt-handling routine. Interrupt-handling routines are most often found in
    kernel space.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[150](#CHP-21-FN-2)]) x86 的 `iret` 指令用于从中断处理例程返回。中断处理例程通常位于内核空间。
- en: ^([[151](#CHP-21-FN-3)]) Think of a *semaphore* as a token that must be in your
    possession before you can enter a room to perform some action. While you hold
    the token, no other person may enter the room. When you have finished with your
    task in the room, you may leave and give the token to someone else, who may then
    enter the room and take advantage of the work you have done (without your knowledge
    because you are no longer in the room!). Semaphores are often used to enforce
    mutual exclusion locks around code or data in a program.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[151](#CHP-21-FN-3)]) 将**信号量**想象成一种必须在你手中才能进入房间执行某些动作的凭证。在你持有凭证期间，其他任何人不得进入房间。当你完成房间内的任务后，你可以离开并将凭证交给其他人，其他人随后可以进入房间并利用你已完成的工作（因为你已经不在房间内，所以你不会知道这一点！）信号量通常用于在程序中对代码或数据进行互斥锁的强制。
- en: ^([[152](#CHP-21-FN-4)]) For more information on Windows Structured Exception
    Handling (SEH), see [http://www.microsoft.com/msj/0197/exception/exception.aspx](http://www.microsoft.com/msj/0197/exception/exception.aspx).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[152](#CHP-21-FN-4)]) 关于Windows结构化异常处理（SEH）的更多信息，请参阅 [http://www.microsoft.com/msj/0197/exception/exception.aspx](http://www.microsoft.com/msj/0197/exception/exception.aspx).
- en: ^([[153](#CHP-21-FN-5)]) Windows configures the FS register to point to the
    base address of the current thread’s environment block (TEB). The first item (offset
    zero) in a TEB is the head of a linked list of pointers to exception handler functions,
    which are called in turn when an exception is raised in a process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[153](#CHP-21-FN-5)]) Windows将FS寄存器配置为指向当前线程环境块（TEB）的基址。TEB中的第一个条目（偏移量为零）是一个指向异常处理函数链表的指针头，当在进程中引发异常时，会依次调用这些函数。
- en: ^([[154](#CHP-21-FN-6)]) In the x86, debug registers 0 through 7 (`Dr0` through
    `Dr7`) are used to control the use of hardware-assisted breakpoints. `Dr0` through
    `Dr3` are used to specify breakpoint addresses, while `Dr6` and `Dr7` are used
    to enable and disable specific hardware breakpoints.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[154](#CHP-21-FN-6)]) 在x86中，调试寄存器0到7（`Dr0`到`Dr7`）用于控制硬件辅助断点的使用。`Dr0`到`Dr3`用于指定断点地址，而`Dr6`和`Dr7`用于启用和禁用特定的硬件断点。
- en: ^([[155](#CHP-21-FN-7)]) See [http://upx.sourceforge.net/](http://upx.sourceforge.net/).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[155](#CHP-21-FN-7)]) 请参阅 [http://upx.sourceforge.net/](http://upx.sourceforge.net/).
- en: ^([[156](#CHP-21-FN-8)]) See [http://www.aspack.com/](http://www.aspack.com/).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[156](#CHP-21-FN-8)]) 请参阅 [http://www.aspack.com/](http://www.aspack.com/).
- en: ^([[157](#CHP-21-FN-9)]) See [http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[157](#CHP-21-FN-9)]) 请参阅 [http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml).
- en: ^([[158](#CHP-21-FN-10)]) See [http://www.packetstormsecurity.org/groups/teso/indexdate.html](http://www.packetstormsecurity.org/groups/teso/indexdate.html).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[158](#CHP-21-FN-10)]) 请参阅 [http://www.packetstormsecurity.org/groups/teso/indexdate.html](http://www.packetstormsecurity.org/groups/teso/indexdate.html).
- en: '^([[159](#CHP-21-FN-11)]) See [http://www.cansecwest.com/core03/shiva.ppt](http://www.cansecwest.com/core03/shiva.ppt)
    (tool: [http://www.securiteam.com/tools/5XP041FA0U.html](http://www.securiteam.com/tools/5XP041FA0U.html).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[159](#CHP-21-FN-11)]) 请参阅 [http://www.cansecwest.com/core03/shiva.ppt](http://www.cansecwest.com/core03/shiva.ppt)（工具：[http://www.securiteam.com/tools/5XP041FA0U.html](http://www.securiteam.com/tools/5XP041FA0U.html)）。
- en: ^([[160](#CHP-21-FN-12)]) See [http://www.oreans.com/winlicense.php](http://www.oreans.com/winlicense.php).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[160](#CHP-21-FN-12)]) 请参阅 [http://www.oreans.com/winlicense.php](http://www.oreans.com/winlicense.php).
- en: ^([[161](#CHP-21-FN-13)]) See [http://www.vmpsoft.com/](http://www.vmpsoft.com/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[161](#CHP-21-FN-13)]) 请参阅 [http://www.vmpsoft.com/](http://www.vmpsoft.com/).
- en: ^([[162](#CHP-21-FN-14)]) See [http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi](http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[162](#CHP-21-FN-14)]) 请参阅 [http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi](http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi).
- en: ^([[163](#CHP-21-FN-15)]) See [http://qunpack.ahteam.org/wp2/](http://qunpack.ahteam.org/wp2/)
    (Russian) or [http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack](http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[163](#CHP-21-FN-15)]) 请参阅 [http://qunpack.ahteam.org/wp2/](http://qunpack.ahteam.org/wp2/)（俄语）或
    [http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack](http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack).
- en: ^([[164](#CHP-21-FN-16)]) See [http://www.vmware.com/](http://www.vmware.com/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[164](#CHP-21-FN-16)]) 请参阅 [http://www.vmware.com/](http://www.vmware.com/).
- en: '^([[165](#CHP-21-FN-17)]) Many Windows functions that accept string arguments
    come in two versions: one that accepts ASCII strings and one that accepts Unicode
    strings. The ASCII versions of these functions carry an `A` suffix, while the
    Unicode versions carry a `W` suffix.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[165](#CHP-21-FN-17)]) 许多接受字符串参数的Windows函数有两种版本：一种接受ASCII字符串，另一种接受Unicode字符串。这些函数的ASCII版本带有`A`后缀，而Unicode版本带有`W`后缀。
- en: ^([[166](#CHP-21-FN-18)]) See [http://www.hick.org/code/skape/papers/win32-shellcode.pdf](http://www.hick.org/code/skape/papers/win32-shellcode.pdf),
    specifically [Chapter 3](ch03.html "Chapter 3. IDA Pro Background"), “Shellcode
    Basics,” and section 3.3, “Resolving Symbol Addresses.”
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[166](#CHP-21-FN-18)]) 请参阅 [http://www.hick.org/code/skape/papers/win32-shellcode.pdf](http://www.hick.org/code/skape/papers/win32-shellcode.pdf)，特别是[第3章](ch03.html
    "第3章。IDA Pro 背景")，“Shellcode 基础”，以及3.3节，“解析符号地址”。
- en: ^([[167](#CHP-21-FN-19)]) A *hash function* is a mathematical process that derives
    a fixed-size result (4 bytes, for example) from an arbitrary-sized input (such
    as a string).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[167](#CHP-21-FN-19)]) **哈希函数**是一种数学过程，它从任意大小的输入（例如字符串）中推导出一个固定大小的结果（例如4字节）。
- en: '^([[168](#CHP-21-FN-20)]) Hex-Rays discusses IDA’s debugging capabilities to
    compute such hashes here: [http://www.hexblog.com/?p=93](http://www.hexblog.com/?p=93).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[168](#CHP-21-FN-20)]) Hex-Rays 在此处讨论了 IDA 的调试能力来计算这些哈希值：[http://www.hexblog.com/?p=93](http://www.hexblog.com/?p=93)。
- en: ^([[169](#CHP-21-FN-21)]) See [http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115).
    More detail is available at [http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189](http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[169](#CHP-21-FN-21)]) 请参阅 [http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115)。更多详细信息可在
    [http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189](http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189)
    找到。
- en: Anti–Dynamic Analysis Techniques
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反动态分析技术
- en: None of the anti–static analysis techniques covered in the past few sections
    have any effect whatsoever on whether a program will actually execute or not.
    In fact, while they may make it difficult for you to comprehend the true behavior
    of a program using static analysis techniques alone, they can’t prevent the program
    from executing, or they would render a program useless from the start and therefore
    eliminate the need to analyze the program at all.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几节中讨论的反静态分析技术对程序是否实际执行没有任何影响。事实上，虽然它们可能会使你难以仅使用静态分析技术理解程序的真实行为，但它们不能阻止程序执行，否则程序从一开始就变得无用，从而消除了分析程序的需要。
- en: Given that a program must run in order for it to do any work, dynamic analysis
    aims to observe the behavior of a program in motion (while it is running) rather
    than observe the program at rest (using static analysis while the program is not
    running). In this section we briefly summarize some of the more common anti–dynamic
    analysis techniques. For the most part, these techniques have little effect on
    static analysis tools; however, where there is overlap, we will point this out.
    We will return to discuss the impact of many of these techniques on IDA’s integrated
    debugger beginning in [Chapter 24](ch24.html "Chapter 24. The IDA Debugger").
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序必须运行才能执行任何工作，动态分析旨在观察程序在运行时的行为（而不是在程序不运行时使用静态分析观察程序），本节简要总结了一些更常见的反动态分析技术。在大多数情况下，这些技术对静态分析工具的影响很小；然而，在存在重叠的地方，我们将指出这一点。我们将在第
    24 章（“第 24 章。IDA 调试器”）开始讨论许多这些技术对 IDA 集成调试器的影响。
- en: Detecting Virtualization
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测虚拟化
- en: One of the most common choices for configuring a sandbox environment is to make
    use of virtualization software, such as VMware, to provide an execution environment
    for malicious software (or, for that matter, any other software of interest).
    The advantage of such environments is that they typically offer checkpoint and
    rollback capabilities that facilitate rapid restoration of the sandbox to a known
    clean state. The primary disadvantage of using such environments as the foundation
    for a sandbox is the fact that it is fairly easy (especially on 32-bit x86 platforms)
    for a program to detect that it is running within a virtualized environment. Under
    the assumption that virtualization equates to observation, many programs that
    want to remain undetected simply choose to shut down once they determine that
    they are running within a virtual machine.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 配置沙盒环境时最常见的选择之一是使用虚拟化软件，如 VMware，为恶意软件（或者，就其本身而言，任何其他感兴趣的软件）提供一个执行环境。这种环境的主要优势是它们通常提供检查点和回滚功能，这有助于快速将沙盒恢复到已知的干净状态。将这种环境作为沙盒基础的主要缺点是，对于程序来说，检测它是否在虚拟化环境中运行相当容易（特别是在
    32 位 x86 平台上）。在假设虚拟化等同于观察的情况下，许多希望保持未被发现状态的程序一旦确定它们在虚拟机中运行，就会简单地选择关闭。
- en: The following list describes a few of the techniques that have been used by
    programs running in virtualized environments to determine that they are running
    within a virtual machine rather than on native hardware.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了一些在虚拟化环境中运行的程序所使用的技巧，这些技巧用于确定它们是在虚拟机中运行，而不是在原生硬件上。
- en: '**Detection of virtualization–specific software**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测特定于虚拟化的软件**'
- en: Users often install helper applications within virtual machines to facilitate
    communications between a virtual machine and its host operating system or simply
    to improve performance within the virtual machine. The VMware Tools collection
    is one example of such software. The presence of such software is easily detected
    by programs running within the virtual machine. For example, when VMware Tools
    is installed into a Microsoft Windows virtual machine, it creates Windows registry
    entries that can be read by any program. VMware Tools is rarely required in order
    to run malware within a virtual environment and should not be installed so as
    to eliminate such trivially detectable traces of the virtual machine.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常在虚拟机内部安装辅助应用程序，以方便虚拟机与其宿主操作系统之间的通信，或者简单地提高虚拟机内的性能。VMware Tools集合就是此类软件的一个例子。此类软件的存在很容易被虚拟机内部运行的程序检测到。例如，当VMware
    Tools安装到Microsoft Windows虚拟机中时，它会创建任何程序都可以读取的Windows注册表条目。在虚拟环境中运行恶意软件通常不需要VMware
    Tools，并且不应安装以消除这种容易检测到的虚拟机痕迹。
- en: '**Detection of virtualization–specific hardware**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测虚拟化特定的硬件**'
- en: Virtual machines make use of virtual hardware abstraction layers to provide
    the interface between the virtual machine and the host computer’s native hardware.
    Characteristics of the virtual hardware are often easily detectable by software
    running within the virtual machine. For example, VMware has been assigned its
    own organizationally unique identifiers (OUI)^([[170](#ftn.CHP-21-FN-22)]) for
    use with its virtualized network adapters. Observing a VMware-specific OUI is
    a good indication that a program is running within a virtual machine. Note that
    it is usually possible to modify the MAC address assigned to virtual network adapters
    using configuration options on the host computer.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机利用虚拟硬件抽象层来提供虚拟机与宿主机原生硬件之间的接口。虚拟硬件的特性通常很容易被虚拟机内部运行的软件检测到。例如，VMware为其虚拟化网络适配器分配了自己的组织唯一标识符（OUI）^([[170](#ftn.CHP-21-FN-22)）以供使用。观察到VMware特定的OUI是程序在虚拟机内部运行的良好迹象。请注意，通常可以通过在宿主机上使用配置选项来修改分配给虚拟网络适配器的MAC地址。
- en: '**Detection of virtual machine–specific behaviors**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测虚拟机特定的行为**'
- en: Some virtualization platforms contain backdoor-style communications channels
    to facilitate communications between a virtual machine and its host software.
    For example, the following five lines may be used to determine if you are running
    within a VMware virtual machine:^([[171](#ftn.CHP-21-FN-23)])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一些虚拟化平台包含后门式通信通道，以方便虚拟机与其宿主软件之间的通信。例如，以下五条线可以用来确定你是否在VMware虚拟机内部运行:^([[171](#ftn.CHP-21-FN-23)）
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The sequence will result in the EBX register containing the value `0x564D5868`
    if you are inside a virtual machine. If you are not within a virtual machine,
    the code will result in either an exception or no change to EBX, depending on
    the host operating system in use. This instruction sequence takes advantage of
    the fact that the x86 `in` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    is generally not used or allowed in user-space programs; however, within VMware,
    the instruction sequence can be used to test for the presence of the channel used
    by VMware guest operating systems to communicate with their host operating system.
    This channel is used by VMware Tools, for example, to facilitate the exchange
    of data (such as clipboard contents) between the host and guest operating systems.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在虚拟机内部，该序列将导致EBX寄存器包含值`0x564D5868`。如果你不在虚拟机内部，代码将根据所使用的宿主机操作系统导致异常或EBX没有变化。这个指令序列利用了x86
    `in` 指令 ![](httpatomoreillycomsourcenostarchimages854061.png) 通常不在用户空间程序中使用或允许的事实；然而，在VMware中，这个指令序列可以用来测试VMware客户操作系统与其宿主机操作系统通信所使用的通道是否存在。这个通道由VMware
    Tools使用，例如，以促进主机操作系统和客户操作系统之间数据（如剪贴板内容）的交换。
- en: '**Detection of processor-specific behavioral changes**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测处理器特定的行为变化**'
- en: Perfect virtualization is a difficult thing to achieve. Ideally a program should
    not be able to detect any difference between a virtualized environment and native
    hardware. However, this is seldom the case. Joanna Rutkowska developed her redpill^([[172](#ftn.CHP-21-FN-24)])
    VMware-detection technique after observing behavioral differences between the
    operation of the x86 `sidt` instruction on native hardware and the same instruction
    executed within a virtual machine environment.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 完美虚拟化是一个难以实现的目标。理想情况下，程序不应能够检测到虚拟化环境与原生硬件之间的任何差异。然而，这种情况很少发生。Joanna Rutkowska在观察到x86
    `sidt`指令在原生硬件上的操作与在虚拟机环境中执行相同指令之间的行为差异后，开发了她的redpill^([[172](#ftn.CHP-21-FN-24)])
    VMware检测技术。
- en: 'Though it is not the first paper on the topic, “On the Cutting Edge: Thwarting
    Virtual Machine Detection” by Tom Liston and Ed Skoudis^([[173](#ftn.CHP-21-FN-25)])
    presents a nice overview of virtual machine–detection techniques.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然这不是关于该主题的第一篇论文，但Tom Liston和Ed Skoudis^([[173](#ftn.CHP-21-FN-25)])的“On the
    Cutting Edge: Thwarting Virtual Machine Detection”提供了关于虚拟机检测技术的良好概述。'
- en: Detecting Instrumentation
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测仪器
- en: Following creation of your sandbox environment and prior to executing any program
    you want to observe, you need to ensure that instrumentation is in place to properly
    collect and record information about the behavior of the program you are analyzing.
    A wide variety of tools exists for performing such monitoring tasks. Two widely
    used examples include Process Monitor,^([[174](#ftn.CHP-21-FN-26)]) from the Sysinternals
    group^([[175](#ftn.CHP-21-FN-27)]) at Microsoft, and Wireshark.^([[176](#ftn.CHP-21-FN-28)])
    Process Monitor is a utility capable of monitoring certain activities associated
    with any running Windows process, including accesses to the Windows registry and
    file system activity. Wireshark is a network packet capture and analysis tool
    often used to analyze the network traffic generated by malicious software.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的沙盒环境之后，在执行您想要观察的任何程序之前，您需要确保已安装仪器，以便正确收集和记录您正在分析程序的行为信息。存在各种工具用于执行此类监控任务。两个广泛使用的例子包括来自微软Sysinternals组的Process
    Monitor^([[174](#ftn.CHP-21-FN-26)))和Wireshark.^([[176](#ftn.CHP-21-FN-28))) Process
    Monitor是一个能够监控与任何运行中的Windows进程相关的某些活动的实用程序，包括对Windows注册表和文件系统活动的访问。Wireshark是一个网络数据包捕获和分析工具，常用于分析恶意软件生成的网络流量。
- en: 'Malware authors with a sufficient level of paranoia may program their software
    to search for running instances of such monitoring programs. Techniques range
    from scanning the active process list for process names known to be associated
    with such monitoring software to scanning the title bar text for all active Windows
    applications to search for known strings. Deeper searches can be performed, with
    some software going so far as to search for specific characteristics associated
    with Windows GUI components used within certain instrumentation software. For
    example, the WinLicense obfuscation/protection program uses the following function
    call to attempt to determine whether the Filemon (a predecessor of Process Monitor)
    utility is currently executing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有足够偏执程度的恶意软件作者可能会编写软件来搜索此类监控程序的运行实例。技术范围从扫描已知与此类监控软件相关的进程名称的活跃进程列表，到扫描所有活跃Windows应用程序的标题栏文本以搜索已知字符串。可以进行更深入的搜索，一些软件甚至搜索与某些仪器软件中使用的Windows
    GUI组件相关的特定特征。例如，WinLicense混淆/保护程序使用以下函数调用来尝试确定Filemon（Process Monitor的前身）实用程序是否正在执行：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, the `FindWindow` function is being used to search for a top-level
    application window based on the registered class name (`"FilemonClass"`) of the
    window rather than the window’s title. If a window of the requested class is located,
    then Filemon is assumed to be executing, and the program terminates.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`FindWindow`函数正在根据窗口的注册类名（`"FilemonClass"`）而不是窗口的标题来搜索顶级应用程序窗口。如果找到请求的类窗口，则假定Filemon正在执行，程序终止。
- en: Detecting Debuggers
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测调试器
- en: Moving beyond simple observation of a program, the use of a debugger allows
    an analyst to take complete control of the execution of program that requires
    analyzing. A common use of a debugger with obfuscated programs is to run the obfuscated
    program just long enough to complete any decompression or decryption tasks and
    then utilize the debugger’s memory-access features to extract the de-obfuscated
    process image from memory. In most cases, standard static analysis tools and techniques
    can be used to complete the analysis of the extracted process image.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 超越对程序简单观察的使用，调试器的使用允许分析师完全控制需要分析的程序的执行。使用调试器对混淆程序的一个常见用途是运行混淆程序足够长的时间以完成任何解压缩或解密任务，然后利用调试器的内存访问功能从内存中提取去混淆的过程图像。在大多数情况下，可以使用标准的静态分析工具和技术来完成提取的过程图像的分析。
- en: The authors of obfuscation utilities are well aware of such debugger-assisted
    de-obfuscation techniques, so they have developed measures to attempt to defeat
    the use of debuggers for execution of their obfuscated programs. Programs that
    detect the presence of a debugger often choose to terminate rather than proceed
    with any operations that might allow an analyst to more easily determine the behavior
    of the program.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆工具的作者非常清楚这种由调试器辅助的反混淆技术，因此他们已经采取了措施来尝试阻止调试器执行他们的混淆程序。检测到调试器存在的程序通常会选择终止，而不是进行任何可能使分析师更容易确定程序行为的操作。
- en: Techniques for detecting the presence of debuggers range from simple queries
    to the operating system via well-known API functions, such as the Windows `IsDebuggerPresent`
    function, to lower-level checks for memory or processor artifacts resulting from
    the use of a debugger. An example of the latter includes detecting that a processor’s
    trace (single-step) flag is set. Detection of specific debuggers is also possible
    in some cases. For example, SoftIce, a Windows kernel debugger, can be detected
    through the presence of the `"\\.\NTICE"` device, which is used to communicate
    with the debugger.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 检测调试器存在的技术范围从通过已知的API函数（如Windows的`IsDebuggerPresent`函数）对操作系统进行简单查询，到对内存或处理器因使用调试器而产生的痕迹进行低级检查。后者的一个例子包括检测处理器跟踪（单步）标志是否被设置。在某些情况下，也可以检测特定的调试器。例如，SoftIce，一个Windows内核调试器，可以通过检测用于与调试器通信的`"\\.\NTICE"`设备来识别。
- en: As long as you know what to look for, there is nothing terribly tricky about
    trying to detect a debugger, and attempts to do so are easily observed during
    static analysis (unless anti–static analysis techniques are employed simultaneously).
    For more information on debugger detection, consult Nicolas Falliere’s article
    “Windows Anti-Debug Reference,”^([[177](#ftn.CHP-21-FN-29)]) which provides a
    comprehensive overview of Windows anti-debugging techniques.^([[178](#ftn.CHP-21-FN-30)])
    In addition, OpenRCE maintains an Anti Reverse Engineering Techniques Database,^([[179](#ftn.CHP-21-FN-31)])
    which contains a number of debugger-specific techniques.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你知道要寻找什么，尝试检测调试器并没有什么特别棘手的地方，并且在静态分析过程中（除非同时使用反静态分析技术）很容易观察到这些尝试。有关调试器检测的更多信息，请参阅Nicolas
    Falliere的文章“Windows Anti-Debug Reference”，^([[177](#ftn.CHP-21-FN-29)])，该文章提供了Windows反调试技术的全面概述.^([[178](#ftn.CHP-21-FN-30)])
    此外，OpenRCE维护了一个反逆向工程技术数据库，^([[179](#ftn.CHP-21-FN-31)]) 其中包含了许多针对调试器的特定技术。
- en: Preventing Debugging
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止调试
- en: If a debugger manages to remain undetectable, there are still a number of techniques
    available to thwart its use. These additional techniques attempt to confound the
    debugger by introducing spurious breakpoints, clearing hardware breakpoints, hindering
    disassembly to make selection of appropriate breakpoint addresses difficult, or
    preventing the debugger from attaching to a process in the first place. Many of
    the techniques discussed in Nicolas Falliere’s article are geared toward preventing
    debuggers from operating correctly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调试器设法保持不可检测，仍然有几种技术可以用来阻止其使用。这些额外技术试图通过引入虚假断点、清除硬件断点、阻碍反汇编以使选择适当的断点地址变得困难，或者阻止调试器最初就附加到进程来迷惑调试器。Nicolas
    Falliere文章中讨论的许多技术都是针对防止调试器正常运行的。
- en: Intentionally generating exceptions is one means by which a program may attempt
    to hinder debugging. In most cases, an attached debugger will catch the exception,
    and the user of the debugger is faced with the task of analyzing why the exception
    occurred and whether to pass the exception along to the program being debugged.
    In the case of a software breakpoint such as the x86 `int 3`, it may be difficult
    to distinguish a software interrupt generated by the underlying program from one
    that results from an actual debugger breakpoint. This confusion is exactly the
    effect that is desired by the creator of the obfuscated program. In such cases,
    careful analysis of the disassembly listing to understand the true program flow
    is usually possible, though the level of effort for static analysis is raised
    somewhat.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 故意生成异常是程序试图阻碍调试的一种方法。在大多数情况下，附加的调试器会捕获异常，调试器的用户将面临分析异常发生的原因以及是否将异常传递给正在调试的程序的任务。在软件断点的情况下，例如x86的`int
    3`，可能很难区分由底层程序生成的软件中断和由实际的调试器断点引起的软件中断。这种混淆正是混淆程序创建者所期望的效果。在这种情况下，通常可以通过仔细分析反汇编列表来理解真正的程序流程，尽管静态分析所需的努力有所增加。
- en: Encoding portions of a program in some manner has the dual effect of hindering
    static analysis because disassembly is not possible and of hindering debugging
    because placing breakpoints is difficult. Even if the start of each instruction
    is known, software breakpoints cannot be placed until the instructions have actually
    been decoded, as altering the instructions by inserting a software breakpoint
    is likely to result in a failed decryption of the obfuscated code and a resulting
    crash of the program when execution reaches the intended breakpoint.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种方式编码程序的部分具有双重效果，一方面阻碍了静态分析，因为无法进行反汇编，另一方面阻碍了调试，因为设置断点困难。即使知道每条指令的开始，也必须在指令实际解码后才能放置软件断点，因为通过插入软件断点来更改指令很可能会导致混淆代码的解密失败，并在执行达到预期的断点时导致程序崩溃。
- en: Alternatively, some de-obfuscation routines compute checksum values over ranges
    of bytes within the process. If one or more software breakpoints have been set
    within the range over which a checksum is being computed, the resulting checksum
    will be incorrect, and the program is likely to abort.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一些去混淆例程会在进程的字节范围内计算校验和值。如果在计算校验和的范围内设置了软件断点，则生成的校验和将是不正确的，程序很可能会终止。
- en: The Shiva ELF obfuscation tool for Linux makes use of a technique called *mutual
    ptrace* to prevent the use of a debugger in analyzing Shiva’s behavior.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的Shiva ELF混淆工具使用了一种称为*互斥ptrace*的技术来防止在分析Shiva的行为时使用调试器。
- en: PROCESS TRACING
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 进程跟踪
- en: The *ptrace*, or process tracing, API is available on many Unix systems and
    provides a mechanism for one process to monitor and control the execution of another
    process. The GNU debugger (gdb) is one of the more well-known applications that
    makes use of the ptrace API. Using the ptrace API, a ptrace parent process may
    attach to and control the execution of a ptrace child process. In order to begin
    controlling a process, a parent process must first *attach* to the child process
    that it seeks to control. Once attached, the child process is stopped anytime
    it receives a signal, and the parent is notified of this fact via the POSIX `wait`
    function, at which point the parent may choose to alter or inspect the state of
    the child process before instructing the child process to continue execution.
    Once a parent process has attached to a child process, no other process may attach
    to the same child process until the tracing parent chooses to detach from the
    child process.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*ptrace*，或进程跟踪，API在许多Unix系统上可用，并提供了一种机制，允许一个进程监控和控制另一个进程的执行。GNU调试器（gdb）是使用ptrace
    API的更知名的应用程序之一。使用ptrace API，ptrace父进程可以附加并控制ptrace子进程的执行。为了开始控制进程，父进程必须首先*附加*到它想要控制的子进程。一旦附加，子进程在任何时候收到信号时都会停止，并且父进程通过POSIX
    `wait`函数通知这一事实，此时父进程可以选择在指示子进程继续执行之前更改或检查子进程的状态。一旦父进程附加到子进程，除非跟踪父进程选择从子进程断开连接，否则没有其他进程可以附加到同一个子进程。'
- en: Shiva takes advantage of the fact that a process may be ptraced by only one
    other process at any given time. Early in its execution, the Shiva process forks
    to create a copy of itself. The original Shiva process immediately performs a
    ptrace attach operation on the newly forked child. The newly forked child process,
    in turn, immediately attaches to its parent process. If either attach operation
    fails, Shiva terminates under the assumption that another debugger is being used
    to monitor the Shiva process. If both operations succeed, then no other debugger
    can be used to attach to the running Shiva pair, and Shiva can continue to run
    without fear of being observed. While operating in this manner, either Shiva process
    may alter the state of the other, making it difficult to determine, using static
    analysis techniques, what the exact control flow path is through the Shiva binary.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Shiva利用了这样一个事实：在任何给定时间，一个进程可能只被另一个进程ptraced。在执行早期，Shiva进程会进行fork操作以创建自身的副本。原始的Shiva进程立即对新fork出的子进程执行ptrace
    attach操作。新fork出的子进程反过来立即连接到其父进程。如果任一attach操作失败，Shiva将假定另一个调试器正在用于监控Shiva进程而终止。如果两个操作都成功，则没有其他调试器可以用来附加到正在运行的Shiva对，Shiva可以继续运行而无需担心被观察。在以这种方式操作时，任一Shiva进程都可能改变另一个的状态，使得使用静态分析技术难以确定通过Shiva二进制的确切控制流路径。
- en: '* * *'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[170](#CHP-21-FN-22)]) An *OUI* makes up the first three bytes of a network
    adapter’s factory-assigned MAC address.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[170](#CHP-21-FN-22)]) 一个*OUI*组成了网络适配器出厂分配的MAC地址的前三个字节。
- en: ^([[171](#CHP-21-FN-23)]) See [http://www.codeproject.com/KB/system/VmDetect.aspx](http://www.codeproject.com/KB/system/VmDetect.aspx)
    by Elias Bachaalany.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[171](#CHP-21-FN-23)]) 请参阅Elias Bachaalany的[http://www.codeproject.com/KB/system/VmDetect.aspx](http://www.codeproject.com/KB/system/VmDetect.aspx)。
- en: ^([[172](#CHP-21-FN-24)]) See [http://www.invisiblethings.org/papers/redpill.html](http://www.invisiblethings.org/papers/redpill.html)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[172](#CHP-21-FN-24)]) 请参阅[http://www.invisiblethings.org/papers/redpill.html](http://www.invisiblethings.org/papers/redpill.html)。
- en: ^([[173](#CHP-21-FN-25)]) See [http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf](http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[173](#CHP-21-FN-25)]) 请参阅[http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf](http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf)。
- en: ^([[174](#CHP-21-FN-26)]) See [http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx](http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[174](#CHP-21-FN-26)]) 请参阅[http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx](http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx)。
- en: ^([[175](#CHP-21-FN-27)]) See [http://technet.microsoft.com/en-us/sysinternals/default.aspx](http://technet.microsoft.com/en-us/sysinternals/default.aspx)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[175](#CHP-21-FN-27)]) 请参阅[http://technet.microsoft.com/en-us/sysinternals/default.aspx](http://technet.microsoft.com/en-us/sysinternals/default.aspx)。
- en: ^([[176](#CHP-21-FN-28)]) See [http://www.wireshark.org/](http://www.wireshark.org/).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[176](#CHP-21-FN-28)]) 请参阅[http://www.wireshark.org/](http://www.wireshark.org/)。
- en: ^([[177](#CHP-21-FN-29)]) See [http://www.symantec.com/connect/articles/windows-anti-debug-reference/](http://www.symantec.com/connect/articles/windows-anti-debug-reference/).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[177](#CHP-21-FN-29)]) 请参阅[http://www.symantec.com/connect/articles/windows-anti-debug-reference/](http://www.symantec.com/connect/articles/windows-anti-debug-reference/)。
- en: ^([[178](#CHP-21-FN-30)]) See [http://pferrie.tripod.com/papers/unpackers.pdf/](http://pferrie.tripod.com/papers/unpackers.pdf/)
    by Peter Ferrie.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[178](#CHP-21-FN-30)]) 请参阅Peter Ferrie的[http://pferrie.tripod.com/papers/unpackers.pdf/](http://pferrie.tripod.com/papers/unpackers.pdf/)。
- en: ^([[179](#CHP-21-FN-31)]) See [http://www.openrce.org/reference_library/anti_reversing/](http://www.openrce.org/reference_library/anti_reversing/)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[179](#CHP-21-FN-31)]) 请参阅[http://www.openrce.org/reference_library/anti_reversing/](http://www.openrce.org/reference_library/anti_reversing/)。
- en: Static De-obfuscation of Binaries Using IDA
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IDA进行二进制静态去混淆
- en: At this point you may be wondering how, given all of the anti–reverse engineering
    techniques available, it is possible to analyze software that a programmer is
    intent on keeping secret. Given that these techniques target both static analysis
    tools and dynamic analysis tools, what is the best approach to take in revealing
    a program’s hidden behavior? Unfortunately, there is no single solution that fits
    all cases equally well. In most cases, the solution depends on your skill set
    and the tools available to you. If your analysis tool of choice is a debugger,
    then you will need to develop strategies for circumventing debugger detection
    and prevention protections. If your preferred analysis tool is a disassembler,
    you will need to develop strategies for obtaining an accurate disassembly and,
    in cases in which self-modifying code is encountered, for mimicking the behavior
    of that code in order to properly update your disassembly listings.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能想知道，鉴于所有可用的反逆向工程技术，如何分析程序员有意保密的软件。鉴于这些技术针对静态分析工具和动态分析工具，揭示程序隐藏行为的最佳方法是什么？不幸的是，没有一种解决方案能够同样适合所有情况。在大多数情况下，解决方案取决于您的技能集和可用的工具。如果您选择的工具是调试器，那么您需要开发绕过调试器检测和预防保护的策略。如果您首选的工具是反汇编器，那么您需要开发获取准确反汇编的策略，以及在遇到自修改代码的情况下，模拟该代码的行为，以便正确更新您的反汇编列表。
- en: In this section we will discuss two techniques for dealing with self-modifying
    code in a static analysis environment (that is, without executing the code). Static
    analysis may be your only option for cases in which you are unwilling (because
    of hostile code) or unable (because of a lack of hardware or appropriate sandbox
    environment) to analyze a program while controlling it with a debugger.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两种在静态分析环境中（即在执行代码之前）处理自修改代码的技术。在您不愿意（由于恶意代码）或无法（由于缺乏硬件或适当的沙盒环境）使用调试器控制程序进行分析的情况下，静态分析可能是您的唯一选择。
- en: Script-Oriented De-obfuscation
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以脚本为导向的解混淆
- en: Because IDA may be used to disassemble binaries developed for a number of different
    CPU types, it is not uncommon to analyze a binary developed for an entirely different
    platform than the one on which you are running IDA. For example, you may be asked
    to analyze a Linux x86 binary even though you happen to run the Windows version
    of IDA, or you may be asked to analyze a MIPS or ARM binary even though IDA runs
    only on x86 platforms. In such cases you may not have access to dynamic analysis
    tools, such as debuggers, suitable for use in performing dynamic analysis on the
    binary you have been given. When such a binary has been obfuscated by encoding
    portions of the program, you may have no other option than to create an IDA script
    that will mimic the de-obfuscating stage of the program in order to properly decode
    the program and disassemble the decoded instructions and data.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IDA可以用于反汇编为多种不同CPU类型开发的二进制文件，因此分析一个与您运行IDA的平台完全不同的平台上的二进制文件并不罕见。例如，您可能被要求分析一个Linux
    x86二进制文件，尽管您碰巧运行的是IDA的Windows版本，或者您可能被要求分析一个MIPS或ARM二进制文件，尽管IDA仅在x86平台上运行。在这种情况下，您可能无法访问适合在您提供的二进制文件上执行动态分析的调试器等动态分析工具。当这样的二进制文件被通过编码程序的部分来混淆时，您可能别无选择，只能创建一个IDA脚本，该脚本将模拟程序的解混淆阶段，以便正确解码程序并反汇编解码后的指令和数据。
- en: This may seem like a daunting task. However, in many cases the decoding stages
    of an obfuscated program make use of only a small subset of a processor’s instruction
    set, so familiarizing yourself with the necessary operations may not require an
    understanding of the entire instruction set for the target CPU.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一项艰巨的任务。然而，在许多情况下，混淆程序的解码阶段仅使用处理器指令集的一小部分，因此熟悉必要的操作可能不需要理解目标CPU的整个指令集。
- en: '[Chapter 15](ch15.html "Chapter 15. IDA Scripting") presented an algorithm
    for developing scripts that emulate the behavior of portions of a program. In
    the following example, we will utilize those steps to develop a simple IDC script
    to decode a program that has been encrypted with the Burneye ELF encryption tool.
    In our example program, execution begins with the instructions in [Example 21-2](ch21s03.html#burneye_startup_sequence_and_obfuscated
    "Example 21-2. Burneye startup sequence and obfuscated code").'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 15 章](ch15.html "第 15 章。IDA 脚本编程") 提出了一种开发脚本算法，该脚本模拟程序部分的行为。在下面的示例中，我们将利用这些步骤开发一个简单的
    IDC 脚本来解码使用 Burneye ELF 加密工具加密的程序。在我们的示例程序中，执行从 [示例 21-2](ch21s03.html#burneye_startup_sequence_and_obfuscated
    "示例 21-2. Burneye 启动序列和混淆代码") 中的指令开始。'
- en: Example 21-2. Burneye startup sequence and obfuscated code
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 21-2. Burneye 启动序列和混淆代码
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The program begins by pushing the contents of memory location `05371008h` onto
    the stack ![](httpatomoreillycomsourcenostarchimages854061.png) before pushing
    the CPU flags ![](httpatomoreillycomsourcenostarchimages854063.png) and then pushing
    all CPU registers ![](httpatomoreillycomsourcenostarchimages854093.png). The purpose
    of these instructions is not immediately clear, so we simply file this information
    away for later. Next, the ECX register is loaded with the contents of memory location
    `5371000h` ![](httpatomoreillycomsourcenostarchimages854095.png). According to
    the algorithm presented in [Chapter 15](ch15.html "Chapter 15. IDA Scripting"),
    we need to declare a variable named `ecx` at this point and initialize it from
    memory using IDC’s `Dword` function, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先将内存位置 `05371008h` 的内容推入栈 ![图片](httpatomoreillycomsourcenostarchimages854061.png)，然后推入
    CPU 标志 ![图片](httpatomoreillycomsourcenostarchimages854063.png) 和所有 CPU 寄存器 ![图片](httpatomoreillycomsourcenostarchimages854093.png)。这些指令的目的并不立即清楚，所以我们只是将这些信息存档以备后用。接下来，ECX
    寄存器被加载了内存位置 `5371000h` 的内容 ![图片](httpatomoreillycomsourcenostarchimages854095.png)。根据第
    15 章中提出的算法 [Chapter 15](ch15.html "第 15 章。IDA 脚本编程")，我们需要在此处声明一个名为 `ecx` 的变量，并使用
    IDC 的 `Dword` 函数从内存中初始化它，如下所示：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Following an absolute jump, the program calls function `sub_5371048` ![](httpatomoreillycomsourcenostarchimages854099.png),
    which has the side effect of pushing address `05371087h` (the return address)
    onto the stack. Note that the disassembled instructions that follow the `call`
    instruction begin to make less and less sense. The `out` instruction ![](httpatomoreillycomsourcenostarchimages854101.png)
    is not generally encountered in user-space code, while IDA is unable to disassemble
    an instruction at address `053710B1h` ![](httpatomoreillycomsourcenostarchimages854103.png).
    These are both indications that something is not quite right with this binary
    (that and the fact that the Functions window lists only two functions).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行绝对跳转后，程序调用函数 `sub_5371048` ![图片](httpatomoreillycomsourcenostarchimages854099.png)，它具有将地址
    `05371087h`（返回地址）推入栈中的副作用。请注意，跟随 `call` 指令之后的反汇编指令开始变得越来越没有意义。`out` 指令 ![图片](httpatomoreillycomsourcenostarchimages854101.png)
    通常不会在用户空间代码中遇到，而 IDA 无法反汇编地址 `053710B1h` ![图片](httpatomoreillycomsourcenostarchimages854103.png)
    的指令。这些都是表明这个二进制文件（以及函数窗口只列出两个函数的事实）有些不对劲的迹象。
- en: At this point, analysis needs to continue with function `sub_5371048`, which
    is shown in [Example 21-3](ch21s03.html#main_burneye_decoding_function "Example 21-3. Main
    Burneye decoding function").
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，分析需要继续使用函数 `sub_5371048`，该函数在[示例 21-3](ch21s03.html#main_burneye_decoding_function
    "示例 21-3. 主 Burneye 解码函数")中展示。
- en: Example 21-3. Main Burneye decoding function
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 21-3. 主 Burneye 解码函数
- en: '[PRE45]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Closer inspection reveals that this is not a typical function in that it begins
    by immediately popping the return address off the stack into the ESI register
    ![](httpatomoreillycomsourcenostarchimages854061.png). Recalling that the saved
    return address was `05371087h`, and taking into account the initialization of
    EDI ![](httpatomoreillycomsourcenostarchimages854063.png), EBX ![](httpatomoreillycomsourcenostarchimages854093.png),
    and EDX ![](httpatomoreillycomsourcenostarchimages854095.png), our script grows
    to the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查发现，这不是一个典型的函数，因为它一开始就立即将返回地址从栈中弹出至 ESI 寄存器 ![图片](httpatomoreillycomsourcenostarchimages854061.png)。回忆起保存的返回地址是
    `05371087h`，并考虑到 EDI ![图片](httpatomoreillycomsourcenostarchimages854063.png)、EBX
    ![图片](httpatomoreillycomsourcenostarchimages854093.png) 和 EDX ![图片](httpatomoreillycomsourcenostarchimages854095.png)
    的初始化，我们的脚本扩展到以下内容：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Following these initializations, the function performs a test on the value contained
    in the EBX register ![](httpatomoreillycomsourcenostarchimages854099.png) before
    entering an outer loop ![](httpatomoreillycomsourcenostarchimages854101.png) and
    an inner loop ![](httpatomoreillycomsourcenostarchimages854103.png). The remaining
    logic of the function is captured in the following completed script. Within the
    script, comments are used to relate script actions to the corresponding actions
    in the preceding disassembly listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些初始化之后，函数在进入外循环 ![](httpatomoreillycomsourcenostarchimages854101.png) 和内循环
    ![](httpatomoreillycomsourcenostarchimages854103.png) 之前对EBX寄存器中的值进行测试 ![](httpatomoreillycomsourcenostarchimages854099.png)。函数的其余逻辑在以下完成的脚本中体现。在脚本中，注释用于将脚本操作与前面的反汇编列表中的对应操作联系起来。
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There are two minor points to raise with this example. First, the right shift
    operator (`>>`) in IDC performs signed shifts (meaning that the sign bit is replicated
    into the most significant bit), while the x86 `shr` and `shrd` instructions perform
    unsigned shifts. In order to emulate an unsigned right shift in IDC, we must clear
    all bits that have been shifted in from the left, as is done at ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png). The second point involves
    the choice of an appropriate data size and variable to properly implement the
    x86 `lodsb` (load string byte) and `stosb` (store string byte) instructions. These
    instructions write to (`lodsb`) and read from (`stosb`) the low-order 8 bits of
    the EAX register,^([[180](#ftn.CHP-21-FN-32)]) leaving the upper 24 bits unchanged.
    In IDC, there is no way to partition a variable into bit-sized portions other
    than using various bitwise operations to mask off and recombine portions of the
    variable. Specifically, in the case of the `lodsb` instruction, a more faithful
    emulation would read as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个例子，有两个小问题需要提出。首先，IDC中的右移运算符（`>>`）执行有符号移位（意味着符号位被复制到最高有效位），而x86的`shr`和`shrd`指令执行无符号移位。为了在IDC中模拟无符号右移，我们必须清除从左边移入的所有位，就像在
    ![](httpatomoreillycomsourcenostarchimages854061.png) 和 ![](httpatomoreillycomsourcenostarchimages854063.png)
    中所做的那样。第二个问题涉及选择合适的数据大小和变量，以正确实现x86的`lodsb`（加载字符串字节）和`stosb`（存储字符串字节）指令。这些指令写入（`lodsb`）和读取（`stosb`）EAX寄存器的低8位，^([[180](#ftn.CHP-21-FN-32)])而高24位保持不变。在IDC中，除了使用各种位操作来屏蔽和重新组合变量的部分外，没有其他方法可以将变量分割成位大小的部分。具体来说，对于`lodsb`指令，更精确的模拟应该如下所示：
- en: '[PRE48]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This example first clears the low 8 bits of the EAX variable and then merges
    in the new value for the low 8 bits using an `OR` operation. In the Burn-eye decoding
    example, we make note of the fact that the entire EAX register is set to 8 at
    the beginning of each outer loop, which has the effect of zeroing the upper 24
    bits of EAX. As a result, we have elected to simplify our implementation of `lodsb`
    ![](httpatomoreillycomsourcenostarchimages854093.png) by ignoring the effect of
    the assignment on the upper 24 bits of EAX. No thought need be given to our implementation
    of `stosb` ![](httpatomoreillycomsourcenostarchimages854095.png), as the `PatchByte`
    function reads only from the low-order 8 bits of its input value (EAX in this
    case).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先清除了EAX变量的低8位，然后使用`OR`操作合并新的低8位值。在Burn-eye解码示例中，我们注意到在每个外循环开始时，整个EAX寄存器被设置为8，这相当于清除了EAX的高24位。因此，我们选择简化`lodsb`的实现，忽略对EAX高24位的影响！[](httpatomoreillycomsourcenostarchimages854093.png)。对于`stosb`
    ![](httpatomoreillycomsourcenostarchimages854095.png)的实现，无需考虑，因为`PatchByte`函数只读取输入值（在这种情况下为EAX）的低8位。
- en: Following execution of the Burneye decoding IDC script, our database would reflect
    all of the changes that would normally not be observable until the obfuscated
    program was executed on a Linux system. If the de-obfuscation process was carried
    out properly, we are very likely to see many more legible strings within IDA’s
    Strings window. In order to observe this fact, you may need to refresh the Strings
    window content by closing and reopening the window or by right-clicking within
    the window, selecting Setup, and then clicking OK. Either action causes IDA to
    rescan the database for string content.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行Burneye解码IDC脚本之后，我们的数据库将反映所有在Linux系统上执行混淆程序之前通常无法观察到的变化。如果去混淆过程执行得当，我们很可能在IDA的字符串窗口中看到更多的可读字符串。为了观察这一事实，你可能需要通过关闭并重新打开窗口或在窗口内右键单击，选择设置，然后点击确定来刷新字符串窗口内容。任何一种操作都会导致IDA重新扫描数据库以查找字符串内容。
- en: 'Remaining tasks include determining where the decoding function will return,
    given that it popped its return address in the very first instruction of the function,
    along with coaxing IDA to properly display the decoded byte values as instructions
    or data as appropriate. The Burneye decoding function ends with the following
    three instructions:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的任务包括确定解码函数将返回的位置，考虑到它在函数的第一个指令中弹出返回地址，以及诱导IDA正确显示解码的字节值作为指令或数据。Burneye解码函数以以下三条指令结束：
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Recall that the function began by popping its own return address, which means
    that the remaining stack values were set up by the caller. The `popa` and `popf`
    instructions used here are the counterparts to the `pusha` and `pushf` instructions
    used at the beginning of Burneye’s start routine, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，函数开始时通过弹出其自己的返回地址，这意味着剩余的栈值是由调用者设置的。这里使用的`popa`和`popf`指令是Burneye启动例程开始时使用的`pusha`和`pushf`指令的对应指令，如下所示：
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The net result is that the only value that remains on the stack is the one that
    was pushed at the first line of `start` ![](httpatomoreillycomsourcenostarchimages854061.png).
    It is to this location that the Burneye decoding routine returns, and it is at
    this location that further analysis of the Burneye protected binary would need
    to continue.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，栈上唯一保留的值是在`start`的第一行推入的那个值 ![http://atomoreilly.com/source/nostarch/images/854061.png]。Burneye解码例程返回的位置就是这里，进一步分析Burneye受保护的二进制文件也需要从这里继续。
- en: The preceding example may make it seem like writing a script to decode or unpack
    an obfuscated binary is a relatively easy thing to do. This is true in the case
    of Burneye, which does not use a terribly sophisticated initial obfuscation algorithm.
    The de-obfuscation stub of more sophisticated utilities such as ASPack and tElock
    would require somewhat more effort to implement using IDC.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可能让人觉得编写脚本以解码或解包混淆的二进制文件相对容易。在Burneye的情况下，这是正确的，因为它没有使用非常复杂的初始混淆算法。使用IDC实现更复杂工具（如ASPack和tElock）的去混淆存根需要更多的努力。
- en: Advantages to script-based de-obfuscation include the fact that the binary being
    analyzed need never be executed and that it is possible to create a functional
    script without ever developing a complete understanding of the exact algorithm
    used to de-obfuscate the binary. This latter statement may seem counterintuitive,
    as it would seem that you would need to have a complete understanding of the de-obfuscation
    before you could emulate the algorithm using a script. Using the development process
    described here and in [Chapter 15](ch15.html "Chapter 15. IDA Scripting"), however,
    all you really need is a complete understanding of each CPU instruction involved
    in the de-obfuscation process. By faithfully implementing each CPU action using
    IDC and properly sequencing each action according to the disassembly listing,
    you will have a script that mimics the program’s actions even if you do not fully
    comprehend the higher-level algorithm that those actions, as a whole, implement.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 基于脚本去混淆的优点包括分析的二进制文件无需执行，并且可以在不完整理解用于去混淆二进制文件的精确算法的情况下创建一个功能脚本。这种说法可能看起来有些反直觉，因为似乎在用脚本模拟算法之前，你需要对去混淆过程有一个完整理解。然而，使用这里和第15章（ch15.html
    "第15章。IDA脚本"）中描述的开发过程，你真正需要的是对去混淆过程中涉及的每个CPU指令的完整理解。通过忠实地使用IDC实现每个CPU动作，并按照反汇编列表正确排序每个动作，你将得到一个模拟程序动作的脚本，即使你并不完全理解这些动作整体实现的高级算法。
- en: Disadvantages of using a script-based approach include the fact that the scripts
    are rather fragile. If a de-obfuscation algorithm changes as a result of an upgrade
    to a de-obfuscation tool or through the use of alternate command-line settings
    supplied to the obfuscation tool, it is quite likely that a script that had been
    effective against that tool will need to be modified accordingly. For example,
    it is possible to develop a generic unpacking script for use with binaries packed
    using UPX,^([[181](#ftn.CHP-21-FN-33)]) but such a script requires constant tuning
    as UPX evolves.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于脚本的方法的缺点包括脚本相当脆弱。如果脱混淆算法因为脱混淆工具的升级或通过提供给混淆工具的替代命令行设置而发生变化，那么之前对该工具有效的脚本很可能需要相应地进行修改。例如，可以开发一个通用的解包脚本，用于与使用UPX打包的二进制文件一起使用，^([[181](#ftn.CHP-21-FN-33)])
    但这样的脚本需要随着UPX的演变而不断调整。
- en: Finally, scripted de-obfuscation suffers from the lack of a one-size-fits-all
    solution to de-obfuscation. There is no megascript capable of de-obfuscating all
    binaries. In a sense, scripted de-obfuscation suffers from many of the same shortcomings
    as signature-based intrusion-detection and antivirus systems. A new script must
    be developed for each new type of packer, and subtle changes in existing packers
    are likely to break existing scripts.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本脱混淆的缺点在于缺乏一个适用于所有脱混淆情况的解决方案。没有一种万能的宏脚本能够脱混淆所有二进制文件。从某种意义上说，脚本脱混淆与基于签名的入侵检测和防病毒系统存在许多相同的不足。对于每种新的打包器类型，都需要开发一个新的脚本，并且现有打包器的细微变化很可能会破坏现有的脚本。
- en: Emulation-Oriented De-obfuscation
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向模拟的脱混淆
- en: A recurring theme encountered when creating scripts to perform de-obfuscation
    tasks is the need to emulate a CPU’s instruction set so the script behaves identically
    to the program being de-obfuscated. If we had an actual instruction emulator at
    our disposal, it might be possible to shift some or all of the work performed
    by these scripts over to the emulator and drastically reduce the amount of time
    required to de-obfuscate an IDA database. Emulators can fill the void between
    scripts and debuggers and have the advantage of being both more efficient than
    scripts and more flexible than debuggers. Using emulators, for example, it is
    possible to emulate a MIPS binary on an x86 platform or to emulate instructions
    from a Linux ELF binary on a Windows platform.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建脚本以执行脱混淆任务时，遇到的一个反复出现的问题是需要模拟CPU的指令集，以便脚本的行为与正在脱混淆的程序相同。如果我们手头有一个实际的指令模拟器，那么可能可以将这些脚本中的一些或全部工作转移到模拟器上，从而大大减少脱混淆IDA数据库所需的时间。模拟器可以填补脚本和调试器之间的空白，并且具有比脚本更高效、比调试器更灵活的优势。例如，使用模拟器，可以在x86平台上模拟MIPS二进制文件，或者在Windows平台上模拟Linux
    ELF二进制文件的指令。
- en: Emulators vary in sophistication. At a minimum, an emulator requires a stream
    of instruction bytes and sufficient memory to dedicate to stack operations and
    CPU registers. More sophisticated emulators may provide access to emulated hardware
    devices and operating system services.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器的复杂程度各不相同。最基本的情况下，模拟器需要一个指令字节流以及足够的内存来分配给堆栈操作和CPU寄存器。更复杂的模拟器可能提供对模拟硬件设备和操作系统服务的访问。
- en: IDA does not offer a native emulation facility,^([[182](#ftn.CHP-21-FN-34)])
    but its plug-in architecture is sophisticated enough to allow for the creation
    of emulator-type plug-ins. One possible implementation of such an emulator treats
    the IDA database as virtual memory that happens to contain the mapped binary we
    wish to emulate (courtesy of a loader module). All that is required of an emulator
    plug-in is to provide a small amount of memory to track the state of all CPU registers
    and some means to implement a stack. One approach implements a stack by creating
    a new segment within the database mapped to a location suitable for a stack. The
    emulator operates by reading bytes from the database location specified by the
    current value of the the emulator’s instruction pointer, decoding the retrieved
    values according to the emulated CPU’s instruction set specification, and updating
    any memory values affected by the decoded instruction. Possible updates might
    include modifying emulated register values, storing values into the emulated stack
    memory space, or patching modified values into the data or code sections within
    the IDA database as dictated by memory addresses generated by the decoded instruction.
    Control of the emulator could be similar to control of a debugger in that instructions
    could be stepped through, memory could be examined, registers could be modified,
    and breakpoints could be set. Memory contents within the program memory space
    would be displayed courtesy of IDA’s disassembly and hex views, while the emulator
    would be required to generate its own displays for the CPU registers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 不提供原生的模拟器功能^([[182](#ftn.CHP-21-FN-34)]), 但其插件架构足够复杂，允许创建模拟器类型的插件。此类模拟器的一种可能的实现是将
    IDA 数据库视为虚拟内存，该内存恰好包含我们希望模拟的映射二进制文件（由加载模块提供）。对模拟器插件的要求仅限于提供一小部分内存来跟踪所有 CPU 寄存器的状态，以及一些实现堆栈的方法。一种实现堆栈的方法是在数据库中创建一个新的段，将其映射到适合堆栈的位置。模拟器通过从由模拟器的指令指针当前值指定的数据库位置读取字节，根据模拟
    CPU 的指令集规范解码检索到的值，并更新由解码指令影响的任何内存值来运行。可能的更新可能包括修改模拟寄存器值、将值存储到模拟堆栈内存空间中，或者根据解码指令生成的内存地址，将修改后的值修补到
    IDA 数据库中的数据或代码部分。模拟器的控制可能与调试器的控制类似，即可以逐步执行指令、检查内存、修改寄存器，并设置断点。程序内存空间内的内存内容将由 IDA
    的反汇编和十六进制视图提供，而模拟器则需要生成自己的 CPU 寄存器显示。
- en: Using such an emulator, an obfuscated program may be de-obfuscated by initiating
    emulation at the program entry point and stepping through the instructions that
    constitute the de-obfuscation phase of the program. Because the emulator utilizes
    the database as its backing memory, all self-modifications are reflected immediately
    as changes in the database. By the time the de-obfuscation routine has completed,
    the database has been transformed into the correct de-obfuscated version of the
    program, just as if the program had been running under debugger control. An immediate
    advantage of emulation over debugging is that potentially malicious code is never
    actually executed by an emulator, whereas debugger-assisted de-obfuscation must
    allow at least some portion of the malicious program to execute in order to obtain
    the de-obfuscated version of the program.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的模拟器，可以通过在程序入口点启动模拟并逐步执行构成程序去混淆阶段的指令来去混淆一个混淆程序。因为模拟器使用数据库作为其支持内存，所以所有自我修改都会立即反映为数据库中的变化。当去混淆例程完成时，数据库已经转换成程序的正确去混淆版本，就像程序在调试器控制下运行一样。模拟器相对于调试器的直接优势是，潜在的恶意代码永远不会实际由模拟器执行，而调试器辅助的去混淆必须允许至少部分恶意程序执行，以便获得程序的去混淆版本。
- en: The ida-x86emu (x86emu) plug-in is an example of an emulator plug-in that is
    designed to offer emulation of the x86 instruction set. The plug-in is open source
    and builds with all versions of the IDA SDK from 4.9 onward. Binary versions of
    the plug-in compiled for all versions of IDA are included with the x86emu distribution.
    The plug-in is designed for use with either the Windows GUI version or the Qt
    version of IDA and includes build scripts, which allow the plug-in to be built
    using either MinGW (g++/make) or Microsoft (Visual Studio 2008) tools. The Qt
    version of the plug-in is also compatible with the Linux and OS X versions of
    IDA. Other than the appropriate SDK for your version of IDA, the plug-in has no
    other dependencies. The plug-in is installed by copying the compiled plug-in binary
    (*x86emu.plw/x86emu_qt.plw*) into *<IDADIR>/plugins*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ida-x86emu（x86emu）插件是一个旨在提供 x86 指令集模拟的模拟器插件示例。该插件是开源的，并支持从 4.9 版本开始的 IDA SDK
    所有版本。x86emu 分发中包含了为 IDA 所有版本编译的插件的二进制版本。该插件旨在与 IDA 的 Windows 图形界面版本或 Qt 版本一起使用，并包括构建脚本，允许使用
    MinGW（g++/make）或 Microsoft（Visual Studio 2008）工具构建插件。该插件的 Qt 版本也与 IDA 的 Linux
    和 OS X 版本兼容。除了适合您 IDA 版本的 SDK 之外，插件没有其他依赖项。通过将编译好的插件二进制文件（*x86emu.plw/x86emu_qt.plw*）复制到
    *<IDADIR>/plugins* 来安装插件。
- en: No plug-in configuration is required, and the emulator is activated using the
    alt-F8 key sequence by default. The plug-in may be activated only for binaries
    that make use of the x86 processor, and the plug-in may be used with binaries
    of any file type, such as PE, ELF, and Mach-O. The plug-in may be built from source
    using the tools (Visual Studio or MinGW’s gcc and make) discussed in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要插件配置，默认情况下使用 alt-F8 键序列激活模拟器。插件仅适用于使用 x86 处理器的二进制文件，并且可以与任何文件类型的二进制文件一起使用，例如
    PE、ELF 和 Mach-O。可以使用第 17 章中讨论的工具（Visual Studio 或 MinGW 的 gcc 和 make）从源代码构建插件。
- en: '| **Name** | ida-x86emu |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | ida-x86emu |'
- en: '| **Author** | Chris Eagle |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Chris Eagle |'
- en: '| **Distribution** | Source for SDK v6.1 and binaries for all versions of IDA
    from 5.0, including IDA Freeware. Source is backward compatible to SDK version
    4.9. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | SDK v6.1 的源代码以及包括 IDA Freeware 在内的 IDA 所有版本的二进制文件。源代码与 SDK 版本 4.9
    兼容。|'
- en: '| **Price** | Free |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | Embedded x86 instruction emulator for IDA |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | IDA 的嵌入式 x86 指令模拟器 |'
- en: '| **Information** | [http://www.idabook.com/ida-x86emu](http://www.idabook.com/ida-x86emu)
    |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://www.idabook.com/ida-x86emu](http://www.idabook.com/ida-x86emu)
    |'
- en: x86emu Initialization
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86emu 初始化
- en: When the x86emu plug-in is activated, the plug-in control dialog shown in [Figure 21-4](ch21s03.html#x86emu_emulator_control_dialog
    "Figure 21-4. x86emu emulator control dialog") is displayed. The basic display
    shows register values and provides button controls used to perform simple emulation
    tasks such as stepping the emulator or modifying data values.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活 x86emu 插件时，将显示如图 21-4 所示的插件控制对话框。[图 21-4](ch21s03.html#x86emu_emulator_control_dialog
    "图 21-4. x86emu 模拟器控制对话框") 中的基本显示显示寄存器值，并提供用于执行简单模拟任务的按钮控件，例如单步模拟或修改数据值。
- en: '![x86emu emulator control dialog](httpatomoreillycomsourcenostarchimages854324.png.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![x86emu 模拟器控制对话框](httpatomoreillycomsourcenostarchimages854324.png.jpg)'
- en: Figure 21-4. x86emu emulator control dialog
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21-4. x86emu 模拟器控制对话框
- en: 'Upon initial activation, the plug-in carries out a number of additional actions.
    For all file types, the emulator creates new database segments named `.stack`
    and `.heap` in order to provide runtime memory support for emulated program operations.
    The first time the plug-in is activated within a particular binary, the current
    cursor location is used to initialize the instruction pointer (`EIP`). For Windows
    PE binaries, the plug-in performs the following additional tasks:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次激活时，插件执行一系列附加操作。对于所有文件类型，模拟器创建名为 `.stack` 和 `.heap` 的新数据库段，以便为模拟程序操作提供运行时内存支持。在特定二进制文件中首次激活插件时，当前光标位置用于初始化指令指针（`EIP`）。对于
    Windows PE 二进制文件，插件执行以下附加任务：
- en: Creates an additional program segment named `.headers`, rereads the input binary
    file, and then loads the MS-DOS and PE header bytes into the database.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `.headers` 的附加程序段，重新读取输入的二进制文件，然后将 MS-DOS 和 PE 标头字节加载到数据库中。
- en: Allocates memory to emulate a thread environment block (TEB) and a process environment
    block (PEB). These structures are populated with reasonable values in an attempt
    to convince the program being emulated that it is running within an actual Windows
    environment.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配内存以模拟线程环境块（TEB）和进程环境块（PEB）。这些结构通过合理的值进行填充，试图让被模拟的程序相信它正在实际Windows环境中运行。
- en: Assigns reasonable values to the x86 segment registers and configures a fake
    interrupt descriptor table in order to provide a minimal exception-handling capability.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为x86段寄存器分配合理的值，并配置一个假的中断描述符表，以提供最小异常处理能力。
- en: Attempts to locate all DLLs referenced in the PE file’s import directory. For
    each such DLL that is found, the emulator creates additional segments within the
    database and loads the DLL’s headers and export directory. The binary’s import
    table is then populated with function addresses derived from the loaded DLL information.
    Note that no code from any of the imported DLLs is loaded into the database.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试定位PE文件导入目录中引用的所有DLL。对于找到的每个此类DLL，模拟器在数据库中创建额外的段，并加载DLL的头部和导出目录。然后，二进制文件的导入表被填充从加载的DLL信息中派生的函数地址。请注意，不会将任何导入DLL的代码加载到数据库中。
- en: The current state of the plug-in (register values) is saved in a netnode each
    time the database is saved or closed. Additional memory state such as stack and
    heap values is saved as well because these values are stored within dedicated
    segments in the database. Upon subsequent activation, the emulator state is restored
    from existing netnode data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 每次数据库保存或关闭时，插件当前状态（寄存器值）都会保存在一个netnode中。此外，还会保存如栈和堆值等附加内存状态，因为这些值存储在数据库中的专用段中。在后续激活时，模拟器状态从现有的netnode数据中恢复。
- en: Basic x86emu Operation
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本x86emu操作
- en: The emulator control dialog is intended to provide capabilities similar to those
    of a very basic debugger. CPU register contents may be altered by entering a new
    value into the desired register’s edit box.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器控制对话框旨在提供类似于非常基本调试器的功能。可以通过在所需寄存器的编辑框中输入新值来更改CPU寄存器的内容。
- en: The Step button is used to emulate a single instruction. A single instruction
    is emulated by reading one or more bytes from the database location specified
    by the EIP register and carrying out any actions specified by the instruction
    bytes. Where required, register display values are updated to reflect changes
    resulting from the emulation of the current instruction. Each time the Step button
    is clicked, the emulator ensures that the bytes at the address specified by EIP
    are displayed as code (rather than data). This feature helps defeat any desynchronization
    attempts that may occur within the instruction stream. In addition, the emulator
    jumps the disassembly display window to the location specified by EIP so that
    the display tracks along with each emulated instruction.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: “单步”按钮用于模拟单个指令。通过从由EIP寄存器指定的数据库位置读取一个或多个字节，并执行由指令字节指定的任何操作来模拟单个指令。需要时，会更新寄存器显示值以反映当前指令模拟引起的变化。每次单击“单步”按钮时，模拟器都会确保由EIP指定的地址处的字节显示为代码（而不是数据）。此功能有助于防止指令流中可能发生的任何不同步尝试。此外，模拟器将反汇编显示窗口跳转到由EIP指定的位置，以便显示与每个模拟指令一起跟踪。
- en: The Run To Cursor button may be used to emulate an entire sequence of instructions
    at one time. Emulation continues from the current EIP location and does not stop
    until a breakpoint is reached or EIP is equal to the current cursor location.
    The emulator recognizes breakpoints set via IDA’s debugger interface (right-click
    the desired address and select **Add breakpoint**) or breakpoints set via the
    emulator’s own breakpoint interface, Emulate ▸ Set Breakpoint.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用“运行到光标”按钮一次性模拟一系列指令。模拟从当前EIP位置继续，直到达到断点或EIP等于当前光标位置才停止。模拟器识别通过IDA调试器接口设置的断点（在所需地址上右键单击并选择**添加断点**）或通过模拟器自己的断点接口，模拟
    ▸ 设置断点设置的断点。
- en: x86EMU BREAKPOINTS
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: x86EMU 断点
- en: The emulator does not make use of hardware debug registers or software interrupts
    such as the `int 3` instruction. Instead, the emulator maintains an internal list
    of breakpoints against which the emulated instruction pointer is compared prior
    to emulating each instruction. While this may seem inefficient, it is no more
    inefficient than emulation in general, and it offers the advantage that emulator
    breakpoints are undetectable, and unalterable, by the program being emulated.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器不使用硬件调试寄存器或软件中断，如`int 3`指令。相反，模拟器维护一个内部断点列表，在模拟每条指令之前将模拟的指令指针与该列表进行比较。虽然这看起来可能效率不高，但它并不比一般模拟效率低，并且它提供了优势，即模拟器的断点对被模拟的程序来说是不可检测和不可更改的。
- en: Once Run To Cursor has been selected, the emulator does not pause to reformat
    the disassembly for each fetched instruction; instead it formats only the first
    and last instructions executed. For long instruction sequences, the overhead associated
    with reformatting the disassembly at each instruction would result in intolerably
    slow performance of the emulator. You should use the Run To Cursor command very
    carefully, as control of the emulator (and IDA) will not be regained until EIP
    reaches the cursor location. If, for any reason, execution never hits a breakpoint
    or fails to reach the cursor location, you may be required to forcibly terminate
    IDA, potentially losing valuable work.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了“运行到光标”选项，模拟器不会为每条取出的指令重新格式化反汇编；相反，它只格式化执行的第一条和最后一条指令。对于长的指令序列，在每条指令上重新格式化反汇编的开销会导致模拟器性能缓慢到无法忍受。你应该非常小心地使用“运行到光标”命令，因为只有在EIP达到光标位置时，才能重新获得模拟器（和IDA）的控制权。如果由于任何原因，执行从未遇到断点或未能达到光标位置，你可能需要强制终止IDA，这可能会导致丢失有价值的工作。
- en: The Skip button is used to advance the emulator by exactly one instruction without
    emulating that instruction. One potential use of the Skip command is to skip over
    a conditional jump in order to reach a specific block of code regardless of the
    state of any condition flags. Skip is also useful for skipping over calls to imported
    library functions whose code is not available for emulation. Should you elect
    to skip over a function call, make certain that you update the database to reflect
    any changes that the function would have made. Examples of such changes include
    modifying the value of EAX to reflect the desired function return value or populating
    a buffer whose address was passed to the function. Additionally, if the skipped
    function uses the `stdcall` calling convention, you should also be careful to
    manually adjust ESP according to the number of bytes that the skipped function
    would have cleared from the stack upon return.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过按钮用于在不模拟该指令的情况下，精确地前进一个指令。跳过命令的一个潜在用途是跳过条件跳转，以便无论任何条件标志的状态如何，都能到达特定的代码块。跳过命令对于跳过调用不可用于模拟的导入库函数也是很有用的。如果你选择跳过函数调用，请确保更新数据库以反映函数可能做出的任何更改。此类更改的例子包括修改EAX的值以反映所需的函数返回值或填充传递给函数的地址的缓冲区。此外，如果跳过的函数使用`stdcall`调用约定，你还应小心手动调整ESP，以符合跳过的函数在返回时从堆栈中清除的字节数。
- en: The Jump To Cursor button causes EIP to be updated with the address of the current
    cursor location. This feature may be used to skip entire sections of code or to
    follow a conditional jump when the state of the CPU flags may not cause the jump
    to be taken otherwise. Keep in mind that jumping around within a function may
    have consequences on stack layout (if you skip over a push or stack pointer adjustment,
    for example), resulting in unexpected behaviors. Note that it is not necessarily
    the intention of the emulator that emulation begins with the entry point of a
    program. It is entirely possible to use the emulator to emulate a single function
    within a binary in order to study the behavior of that function. This is one of
    the motivations behind the inclusion of the Jump to Cursor button, to allow easy
    redirection of your emulation efforts within a binary.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: “跳转到光标”按钮会将EIP更新为当前光标位置的地址。此功能可用于跳过整个代码段或当CPU标志的状态可能不会导致跳转时，跟随条件跳转。请注意，在函数内跳转可能会影响堆栈布局（例如，如果你跳过了push或堆栈指针调整），从而导致意外的行为。请注意，模拟器开始于程序的入口点并不一定是其意图。完全有可能使用模拟器来模拟二进制中的一个单独的函数，以便研究该函数的行为。这是包含“跳转到光标”按钮的动机之一，以便在二进制文件内轻松重定向你的模拟工作。
- en: The Run button is similar in functionality to the Run To Cursor button; however,
    it is more dangerous in that execution continues until a breakpoint is reached.
    You should be absolutely certain that one of your break-points will be reached
    if you elect to use this command.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: “运行”按钮的功能类似于“运行到光标处”按钮；然而，它更危险，因为执行会继续，直到遇到断点。如果您选择使用此命令，请务必确保您的其中一个断点将被达到。
- en: The Segments button provides access to configuration for x86 segment registers
    and segment base addresses. [Figure 21-5](ch21s03.html#x86emu_segment_register_configuration
    "Figure 21-5. x86emu segment register configuration") shows the resulting dialog
    used to alter segment-related values.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: “段”按钮提供访问x86段寄存器和段基地址的配置。[图21-5](ch21s03.html#x86emu_segment_register_configuration
    "图21-5. x86emu段寄存器配置")显示了用于更改段相关值的对话框。
- en: '![x86emu segment register configuration](httpatomoreillycomsourcenostarchimages854327.png.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![x86emu段寄存器配置](httpatomoreillycomsourcenostarchimages854327.png.jpg)'
- en: Figure 21-5. x86emu segment register configuration
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-5. x86emu段寄存器配置
- en: While the emulator’s address computations honor the supplied base values, the
    emulator does not currently provide a complete emulation of the x86 global descriptor
    table (GDT).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模拟器的地址计算遵循提供的基值，但模拟器目前尚未提供对x86全局描述符表（GDT）的完整仿真。
- en: The Set Memory button provides access to a basic memory modification dialog,
    as shown in [Figure 21-6](ch21s03.html#x86emu_memory_modification_dialog "Figure 21-6. x86emu
    memory modification dialog").
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: “设置内存”按钮提供访问基本内存修改对话框，如图[图21-6](ch21s03.html#x86emu_memory_modification_dialog
    "图21-6. x86emu内存修改对话框")所示。
- en: '![x86emu memory modification dialog](httpatomoreillycomsourcenostarchimages854330.png.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![x86emu内存修改对话框](httpatomoreillycomsourcenostarchimages854330.png.jpg)'
- en: Figure 21-6. x86emu memory modification dialog
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-6. x86emu内存修改对话框
- en: This dialog is essentially a wrapper around some of the SDK `Patch`*`XXX`* functions.
    The type of data to be inserted into the database is selected via the provided
    radio buttons, while the actual data is entered into the provided edit control.
    If the Load from file radio button is selected, the user is presented with a standard
    file-open dialog to select a file whose content is transferred into the database
    beginning at the specified address.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框本质上是一些SDK `Patch`*`XXX`*函数的包装器。通过提供的单选按钮选择要插入数据库的数据类型，而实际数据则输入到提供的编辑控件中。如果选择“从文件加载”单选按钮，用户将看到一个标准的文件打开对话框，用于选择一个文件，其内容将从指定的地址开始传输到数据库中。
- en: The Push Data button is used to place data values onto the top of the emulated
    program stack. The resulting dialog, shown in [Figure 21-7](ch21s03.html#x86emu_stack_data_dialog
    "Figure 21-7. x86emu stack data dialog"), may be used to specify one or more data
    items that will be pushed onto the stack.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: “推数据”按钮用于将数据值放置在仿真程序堆栈的顶部。如图[图21-7](ch21s03.html#x86emu_stack_data_dialog "图21-7.
    x86emu堆数据对话框")所示的对话框可用于指定一个或多个将被推送到堆栈上的数据项。
- en: '![x86emu stack data dialog](httpatomoreillycomsourcenostarchimages854333.png.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![x86emu堆数据对话框](httpatomoreillycomsourcenostarchimages854333.png.jpg)'
- en: Figure 21-7. x86emu stack data dialog
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-7. x86emu堆数据对话框
- en: The emulator currently accepts only numeric data. Supplied values are pushed,
    as 4-byte quantities, onto the emulation stack in right-to-left order as if they
    were parameters to a function call. The value of the stack pointer is adjusted
    according to the number of values pushed onto the stack. The intended use of this
    dialog is to configure function parameters prior to jumping directly to the function
    to be emulated. This allows a function to be emulated without requiring users
    to find an actual execution path to the function.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器目前仅接受数值数据。提供的值以4字节量推送到仿真堆栈中，顺序从右到左，就像它们是函数调用的参数一样。根据推送到堆栈上的值的数量调整堆栈指针。此对话框的预期用途是在直接跳转到要仿真的函数之前配置函数参数。这允许在不要求用户找到函数的实际执行路径的情况下仿真函数。
- en: Emulator-Assisted De-obfuscation
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟器辅助去混淆
- en: At this point we are ready to discuss the use of x86emu as a de-obfuscation
    tool. We begin by returning to the Burneye example for which we developed an entire
    IDC script. Assuming that we have no prior knowledge of the Burn-eye decoding
    algorithm, de-obfuscation would proceed as follows.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已准备好讨论x86emu作为去混淆工具的使用。我们首先回到Burneye示例，为该示例我们开发了一个完整的IDC脚本。假设我们对Burn-eye解码算法没有任何先验知识，去混淆过程将如下进行。
- en: Open the Burneye protected binary. The cursor should be automatically positioned
    at the `start` entry point. Activate the emulator (alt-F8). [Figure 21-4](ch21s03.html#x86emu_emulator_control_dialog
    "Figure 21-4. x86emu emulator control dialog") shows the resulting state of the
    emulator.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Burneye 受保护的二进制文件。光标应自动定位在`start`入口点。激活模拟器（alt-F8）。![图 21-4](ch21s03.html#x86emu_emulator_control_dialog
    "图 21-4. x86emu 模拟器控制对话框")显示了模拟器的结果状态。
- en: Begin stepping the emulator, paying close attention to the instructions that
    are about to be emulated. After six steps, the emulator arrives at function `sub_5371048`
    (see [Example 21-3](ch21s03.html#main_burneye_decoding_function "Example 21-3. Main
    Burneye decoding function")).
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始执行模拟器，密切注意即将要模拟的指令。经过六次步骤后，模拟器到达函数`sub_5371048`（见[示例 21-3](ch21s03.html#main_burneye_decoding_function
    "示例 21-3. 主 Burneye 解码函数")）。
- en: This function appears to be fairly well structured. We could choose to step
    the emulator for a while to obtain a better sense of the flow of execution, or
    we could choose to study the function for a while and determine if it is safe
    to position the cursor at the function’s `return` statement and click Run To Cursor.
    Opting for the latter, we position the cursor at address `05371081h` and click
    **Run To Cursor**.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数看起来结构相当合理。我们可以选择让模拟器运行一段时间，以获得更好的执行流程感，或者我们可以选择研究这个函数一段时间，并确定是否可以在函数的`return`语句处放置光标并点击运行到光标处。选择后者，我们将光标定位在地址`05371081h`处并点击**运行到光标**。
- en: At this point the de-obfuscation is complete. Stepping the emulator two more
    times executes the `return` statement, returning the the newly de-obfuscated code,
    and causes IDA to reformat the de-obfuscated bytes as instructions.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，去混淆已经完成。再执行两次模拟器，执行`return`语句，返回新去混淆的代码，并导致 IDA 重新格式化去混淆的字节为指令。
- en: 'The resulting de-obfuscated code is shown here:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了去混淆后的代码：
- en: '[PRE51]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Comparing this listing to that of [Example 21-2](ch21s03.html#burneye_startup_sequence_and_obfuscated
    "Example 21-2. Burneye startup sequence and obfuscated code"), it is clear that
    the instructions have changed as a result of the de-obfuscation process. Following
    the initial de-obfuscation, execution of the program resumes with the `pushf`
    instruction ![](httpatomoreillycomsourcenostarchimages854061.png) at `loc_5371090`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 将此列表与[示例 21-2](ch21s03.html#burneye_startup_sequence_and_obfuscated "示例 21-2. Burneye
    启动序列和混淆代码")进行比较，很明显，由于去混淆过程，指令已经发生了变化。在初始去混淆之后，程序执行从`pushf`指令![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)在`loc_5371090`处恢复。
- en: Emulator-assisted de-obfuscation is clearly easier than the script-oriented
    de-obfuscation process followed earlier. Time spent developing the emulator approach
    pays off with a highly flexible de-obfuscation alternative, whereas time spent
    developing a Burneye-specific script pays off in a very specialized script that
    is of little use in other de-obfuscation scenarios.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器辅助去混淆显然比之前遵循的基于脚本的去混淆过程要容易得多。开发模拟器方法所花费的时间以高度灵活的去混淆替代方案回报，而开发针对 Burneye 的特定脚本所花费的时间则以一个非常专业的脚本回报，这种脚本在其他去混淆场景中几乎无用。
- en: Note that while the Burneye-protected binary in the previous example was a Linux
    ELF binary, x86emu has no problems emulating the instructions within the binary
    because they are all x86 instructions, regardless of the operating system and
    file type that they were taken from. x86emu can be used just as easily on a Windows
    PE binary, such as the UPX example discussed earlier in this chapter. Because
    of the fact that the overwhelming majority of obfuscated malware in existence
    today is targeted at the Windows platform, x86emu contains many features specific
    to Windows PE binaries (as detailed earlier).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然前一个示例中的 Burneye 受保护的二进制文件是 Linux ELF 二进制文件，但 x86emu 在模拟二进制文件中的指令时没有问题，因为它们都是
    x86 指令，无论它们是从哪个操作系统和文件类型中提取的。x86emu 可以像在 Windows PE 二进制文件上一样轻松使用，例如本章前面讨论的 UPX
    示例。由于当今绝大多数混淆恶意软件都是针对 Windows 平台的，x86emu 包含许多针对 Windows PE 二进制文件的具体功能（如前所述）。
- en: 'Using the emulator to uncompress a UPX binary is very straightforward. The
    emulator should be launched with the cursor positioned on the program entry point
    (`start`). Next, the cursor can be moved to the first instruction of the UPX import
    table, rebuilding loops (address `0040886Ch` in [Example 21-1](ch21.html#import_table_reconstruction_in_upx
    "Example 21-1. Import table reconstruction in UPX")), and the emulator can be
    allowed to run using the Run To Cursor command. At this point, the binary has
    been unpacked, and the Strings window can be used to view all of the unpacked
    library and function names that will be used by UPX to build the program’s import
    tables. If the emulator is stepped through the code of [Example 21-1](ch21.html#import_table_reconstruction_in_upx
    "Example 21-1. Import table reconstruction in UPX"), the following function call
    will eventually be encountered:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟器解压UPX二进制文件非常简单。应将模拟器启动，并将光标定位在程序入口点（`start`）。接下来，可以将光标移动到UPX导入表的第一条指令，重建循环（地址`0040886Ch`在[示例21-1](ch21.html#import_table_reconstruction_in_upx
    "示例21-1. UPX导入表重建"))，然后可以使用“运行到光标”命令允许模拟器运行。此时，二进制文件已被解包，可以使用字符串窗口查看UPX将用于构建程序导入表的所有解包库和函数名称。如果模拟器逐步执行[示例21-1](ch21.html#import_table_reconstruction_in_upx
    "示例21-1. UPX导入表重建")的代码，最终会遇到以下函数调用：
- en: '[PRE52]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Instructions of this sort can be dangerous to emulate, as it is not immediately
    apparent where the instruction may lead (meaning that the destination address
    of the `call` instruction is not obvious). In general, function calls can lead
    to one of two places: a function within the program’s code (`.text`) segment or
    a function within a shared library being used by the program. Whenever a `call`
    instruction is encountered, the emulator determines whether the target address
    lies within the virtual address space of the file being analyzed or whether the
    target address correlates to a function that is being exported by one of the libraries
    that the binary has loaded. Recall that for PE binaries the emulator loads the
    export dictionaries of all libraries loaded by the binary being analyzed. When
    the emulator determines that the target address of a call instruction lies outside
    the bounds of the binary, the emulator scans the export tables that were loaded
    into the database in order to determine which library function is being called.
    For Windows PE files, the emulator contains emulated implementations of the functions
    listed in [Table 21-1](ch21s03.html#functions_emulated_by_x86emu "Table 21-1. Functions
    Emulated by x86emu").'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这类指令模拟可能很危险，因为指令可能指向的位置并不立即明显（意味着`call`指令的目标地址不明显）。一般来说，函数调用可以指向两个地方：程序代码（`.text`）段内的函数或程序使用的共享库内的函数。每当遇到`call`指令时，模拟器都会确定目标地址是否位于正在分析文件的虚拟地址空间内，或者目标地址是否与二进制文件加载的某个库导出的函数相关。回想一下，对于PE二进制文件，模拟器会加载正在分析的二进制文件加载的所有库的导出字典。当模拟器确定`call`指令的目标地址超出了二进制文件的边界时，模拟器会扫描已加载到数据库中的导出表，以确定正在调用的库函数。对于Windows
    PE文件，模拟器包含模拟实现[表21-1](ch21s03.html#functions_emulated_by_x86emu "表21-1. x86emu模拟的函数")中列出的函数。
- en: When the emulator determines that one of these functions has been called, it
    reads any parameters from the program stack and either carries out the same actions
    that the actual function would carry out if the program were actually running
    or performs some minimal action and generates a return value that will appear
    to be correct from the perspective of the emulated program. In the case of `stdcall`
    functions, the emulator properly removes any stack arguments prior to completing
    the emulated function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟器确定这些函数之一已被调用时，它会从程序堆栈中读取任何参数，并执行实际函数在程序实际运行时本应执行的动作，或者执行一些最小动作并生成一个看起来正确的返回值，从被模拟程序的角度看。在`stdcall`函数的情况下，模拟器在完成模拟函数之前会正确地移除任何堆栈参数。
- en: Table 21-1. Functions Emulated by x86emu
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-1. x86emu模拟的函数
- en: '| `CheckRemoteDebuggerPresent` | `GetTickCount` | `LocalFree` | `VirtualAlloc`
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `CheckRemoteDebuggerPresent` | `GetTickCount` | `LocalFree` | `VirtualAlloc`
    |'
- en: '| `CreateThread` | `GetVersion` | `NtQuerySystemInformation` | `VirtualFree`
    |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `CreateThread` | `GetVersion` | `NtQuerySystemInformation` | `VirtualFree`
    |'
- en: '| `GetCurrentThreadId` | `HeapAlloc` | `NtQueryInformationProcess` | `calloc`
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `GetCurrentThreadId` | `HeapAlloc` | `NtQueryInformationProcess` | `calloc`
    |'
- en: '| `GetCurrentProcess` | `HeapCreate` | `NtSetInformationThread` | `free` |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `GetCurrentProcess` | `HeapCreate` | `NtSetInformationThread` | `free` |'
- en: '| `GetCurrentProcessId` | `HeapDestroy` | `RtlAllocateHeap` | `lstrcat` |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `GetCurrentProcessId` | `HeapDestroy` | `RtlAllocateHeap` | `lstrcat` |'
- en: '| `GetModuleHandleA` | `HeapFree` | `TlsAlloc` | `lstrcpy` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `GetModuleHandleA` | `HeapFree` | `TlsAlloc` | `lstrcpy` |'
- en: '| `GetProcAddress` | `IsDebuggerPresent` | `TlsFree` | `lstrlen` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `GetProcAddress` | `IsDebuggerPresent` | `TlsFree` | `lstrlen` |'
- en: '| `GetProcessHeap` | `LoadLibraryA` | `TlsGetValue` | `malloc` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `GetProcessHeap` | `LoadLibraryA` | `TlsGetValue` | `malloc` |'
- en: '| `GetThreadContext` | `LocalAlloc` | `TlsSetValue` | `realloc` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `GetThreadContext` | `LocalAlloc` | `TlsSetValue` | `realloc` |'
- en: Emulated behavior for the heap-related functions causes the emulator to manipulate
    its internal heap implementation (backed by the `.heap` section) and return a
    value appropriate to the function being emulated. For example, the value returned
    by the emulated version of `HeapAlloc` is an address that is suitable for the
    emulated program to write data to. When the emulated version of `VirtualAlloc`
    is called, a new section is created in the database to represent the newly mapped
    virtual address space. The emulated version of `IsDebuggerPresent` always returns
    false. When emulating `LoadLibraryA`, the emulator extracts the name of the library
    being loaded by examining the stack arguments provided to `LoadLibraryA`. The
    emulator then attempts to open the named library on the local system so that library’s
    export table can be loaded into the database, and an appropriate library handle^([[183](#ftn.CHP-21-FN-35)])
    value is returned to the caller. When a call to `GetProcAddress` is intercepted,
    the emulator examines arguments on the stack to determine which shared library
    is being referenced; then the emulator parses the library’s export table in order
    to compute the proper memory address of the requested function, which is then
    returned to the caller. Calls to `LoadLibraryA` and `GetProcAddress` are noted
    in the IDA Output window.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与堆相关的函数的仿真行为，会导致仿真器操作其内部堆实现（由`.heap`部分支持）并返回一个适合被仿真程序写入数据的地址。例如，`HeapAlloc`仿真版本返回的值是一个适合被仿真程序写入数据的地址。当调用`VirtualAlloc`仿真版本时，在数据库中创建一个新的部分来表示新映射的虚拟地址空间。`IsDebuggerPresent`仿真版本始终返回false。当仿真`LoadLibraryA`时，仿真器通过检查提供给`LoadLibraryA`的堆栈参数来提取正在加载的库的名称。然后仿真器尝试在本地系统上打开该命名的库，以便将该库的导出表加载到数据库中，并返回一个适当的库句柄^([[183](#ftn.CHP-21-FN-35)])给调用者。当拦截`GetProcAddress`调用时，仿真器检查堆栈上的参数以确定正在引用哪个共享库；然后仿真器解析库的导出表以计算请求的函数的正确内存地址，然后将该地址返回给调用者。`LoadLibraryA`和`GetProcAddress`的调用会在IDA输出窗口中记录。
- en: When a function for which x86emu has no internal emulation is called, a dialog
    similar to the one shown in [Figure 21-8](ch21s03.html#x86emu_library_function_dialog
    "Figure 21-8. x86emu library function dialog") is displayed.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用x86emu没有内部仿真的函数时，会显示一个类似于[图21-8](ch21s03.html#x86emu_library_function_dialog
    "图21-8. x86emu库函数对话框")所示的对话框。
- en: Knowing the name of the function being called, the emulator queries IDA’s type
    library information to obtain the number and types of parameters required by the
    function. The emulator then digs into the program stack to display all of the
    arguments that have been passed to the function, along with the type of the argument
    and the formal parameter name of the argument. Argument types and names are displayed
    only when type information is available from IDA. The dialog also offers the user
    a chance to specify a return value, as well as the opportunity to specify the
    calling convention used by the function (this information may be available from
    IDA). When the `stdcall` calling convention is selected, the user should indicate
    how many arguments (not bytes) should be removed from the stack when the call
    completes. This information is required in order for the emulator to maintain
    the integrity of the execution stack across emulated function calls.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 知道被调用的函数的名称后，仿真器查询IDA的类型库信息以获取函数所需的参数数量和类型。然后仿真器深入程序堆栈以显示传递给函数的所有参数，包括参数的类型和参数的形式参数名称。只有当从IDA获取类型信息时，才会显示参数类型和名称。对话框还允许用户指定返回值，以及指定函数使用的调用约定（此信息可能来自IDA）。当选择`stdcall`调用约定时，用户应指明在调用完成后应从堆栈中移除多少个参数（而不是字节数）。为了使仿真器在仿真函数调用之间保持执行堆栈的完整性，需要此信息。
- en: '![x86emu library function dialog](httpatomoreillycomsourcenostarchimages854336.png.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![x86emu库函数对话框](httpatomoreillycomsourcenostarchimages854336.png.jpg)'
- en: Figure 21-8. x86emu library function dialog
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-8. x86emu库函数对话框
- en: 'Returning to the UPX de-obfuscation example, and allowing the emulator to complete
    the import table reconstruction loops, we would find that the emulator generates
    output such as the following in IDA’s Output window:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到UPX解混淆示例，并允许模拟器完成导入表重建循环，我们会在IDA的输出窗口中找到以下输出：
- en: '[PRE53]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This output provides a record of the libraries that the obfuscated binary is
    loading and the functions within those libraries that the obfuscated program is
    resolving.^([[184](#ftn.CHP-21-FN-36)]) When function addresses are looked up
    in this manner, they are often saved in an array (this array is the program’s
    import table) for later use.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出提供了被混淆的二进制文件加载的库以及混淆程序解析这些库中函数的记录.^([[184](#ftn.CHP-21-FN-36)]) 当以这种方式查找函数地址时，它们通常会被保存在一个数组中（这个数组是程序的导入表），以供以后使用。
- en: 'A fundamental problem with de-obfuscated programs is that they lack the symbol
    table information that is usually present in un-obfuscated binaries. When a binary’s
    import table is intact, IDA’s PE loader names each entry in the import table according
    to the name of the functions whose address it will contain at runtime. When an
    obfuscated binary is encountered, it is useful to apply function names to each
    location in which a function address is stored. In the case of UPX, the following
    lines from [Example 21-1](ch21.html#import_table_reconstruction_in_upx "Example 21-1. Import
    table reconstruction in UPX") show how function addresses are saved into memory
    with each pass through the function lookup loop:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 解混淆程序的一个基本问题是它们缺少通常在未混淆的二进制文件中存在的符号表信息。当一个二进制文件的导入表完整时，IDA的PE加载器会根据将在运行时包含的函数的名称来命名导入表中的每个条目。当遇到混淆的二进制文件时，将函数名称应用于存储函数地址的每个位置是有用的。在UPX的情况下，[示例 21-1](ch21.html#import_table_reconstruction_in_upx
    "示例 21-1. UPX中的导入表重建")中的以下行显示了函数地址是如何在每次通过函数查找循环时保存到内存中的：
- en: '[PRE54]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The instruction at address `004088A1h` ![](httpatomoreillycomsourcenostarchimages854061.png)
    is responsible for storing function addresses into the import table as it is reconstructed.
    x86emu provides an automated facility for naming each import table entry provided
    that an instruction such as this can be identified. The emulator terms such an
    instruction an *import address save point*, and you may designate an address as
    such using the Emulate ▸ Windows ▸ Set Import Address Save Point menu option.
    This designation must be made before the instruction is emulated in order for
    this functionality to work. Following designation, each time the instruction is
    emulated, the emulator will perform a lookup to determine what function is referenced
    by the data being written and then name the address being written using the name
    of the imported function. In the UPX example, making no effort to clean up the
    import table would yield the (partial) import table shown here:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 地址为`004088A1h`的指令 ![](httpatomoreillycomsourcenostarchimages854061.png) 负责将函数地址存储到导入表中，当它被重建时。只要可以识别出这样的指令，x86emu就提供了一个自动命名每个导入表条目的功能。模拟器将此类指令称为*导入地址保存点*，你可以使用“模拟”▸“Windows”▸“设置导入地址保存点”菜单选项将地址指定为这样的点。为了使此功能正常工作，必须在执行指令之前进行此指定。指定之后，每次模拟此指令时，模拟器都会执行查找以确定正在写入的数据引用了哪个函数，然后使用导入函数的名称命名正在写入的地址。在UPX示例中，不努力清理导入表将产生以下（部分）导入表：
- en: '[PRE55]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, the automated naming that is performed when an import address save
    point is designated yields the following automatically generated (partial) import
    table.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当指定导入地址保存点时执行的自动命名会产生以下自动生成的（部分）导入表。
- en: '[PRE56]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With the import table reconstructed in this manner, IDA is able to properly
    annotate calls to library functions using parameter-type information extracted
    from its type libraries, and the overall quality of the disassembly is significantly
    enhanced.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重建导入表后，IDA能够使用从其类型库中提取的参数类型信息正确注释对库函数的调用，从而显著提高了反汇编的整体质量。
- en: Additional x86emu Features
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外的x86emu功能
- en: The emulator contains several additional features that you may find useful.
    The following list details some of these capabilities.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器包含一些你可能觉得有用的附加功能。以下列表详细说明了这些功能的一些能力。
- en: '| **File** ▸ **Dump** This menu option allows the user to specify a range of
    database addresses to be dumped to a file. By default, the range extends from
    the current cursor location to the maximum virtual address present in the database.
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| **文件** ▸ **导出** 此菜单选项允许用户指定要导出到文件中的数据库地址范围。默认情况下，范围从当前光标位置扩展到数据库中存在的最大虚拟地址。'
- en: '| **File** ▸ **Dump Embedded PE** Many malware programs contain embedded executables,
    which they install on target systems. This menu option looks for a valid PE file
    at the current cursor position, parses the file’s headers to determine the size
    of the file, and then extracts the bytes from the database to a saved file. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| **文件** ▸ **导出嵌入式 PE** 许多恶意软件包含嵌入式可执行文件，它们会在目标系统上安装。此菜单选项在当前光标位置查找有效的 PE 文件，解析文件的头部以确定文件大小，然后从数据库中提取字节到一个保存的文件中。'
- en: '| **View** ▸ **Enumerate Heap** This menu option causes the emulator to dump
    a list of allocated heap blocks to the Output window, as shown here: |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **查看** ▸ **枚举堆** 此菜单选项会导致仿真器将分配的堆块列表导出到输出窗口，如下所示：'
- en: '[PRE57]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '| **Emulate** ▸ **Switch Thread** When emulating within a Windows PE file,
    x86emu traps calls to the `CreateThread` function and allocates additional resources
    to manage a new thread. Because the emulator has no scheduler of its own, you
    must use this menu option if you want to switch among multiple threads. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| **仿真** ▸ **切换线程** 当在 Windows PE 文件中进行仿真时，x86emu 会拦截对 `CreateThread` 函数的调用，并为管理新线程分配额外的资源。因为仿真器没有自己的调度器，所以如果您想在多个线程之间切换，必须使用此菜单选项。'
- en: '| **Functions** ▸ **Allocate Heap Block** This menu option allows the user
    to reserve a block of memory within the emulation heap. The user is asked for
    the size of the block to reserve. The address of the newly reserved block is reported
    to the user. This feature is useful when scratch space is required during emulation.
    |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| **函数** ▸ **分配堆块** 此菜单选项允许用户在仿真堆中预留一块内存。用户会被询问要预留的块的大小。新预留的块的地址会报告给用户。当仿真过程中需要临时空间时，此功能非常有用。'
- en: '| **Functions** ▸ **Allocate Stack Block** This menu option allows the user
    to reserve a block of memory within the emulation stack. It behaves in a manner
    similar to Functions ▸ Allocate Heap Block. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| **函数** ▸ **分配堆栈块** 此菜单选项允许用户在仿真堆栈中预留一块内存。其行为类似于函数 ▸ 分配堆栈块。'
- en: x86emu and Anti-debugging
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86emu 和反调试
- en: While the emulator is not intended to be used a debugger, it must simulate a
    runtime environment for the program being emulated. In order to successfully emulate
    many obfuscated binaries, the emulator must not fall victim to active anti-debugging
    techniques. Several features of the emulator have been designed with anti-debugging
    in mind.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仿真器并非旨在用作调试器，但它必须为被仿真的程序模拟运行时环境。为了成功仿真许多混淆的二进制文件，仿真器必须避免成为活跃的反调试技术的受害者。仿真器的几个功能是考虑到反调试而设计的。
- en: One anti-debugging technique measures time intervals, using the x86 `rdtsc`
    instruction, to ensure that a program has not been paused by a debugger. The `rdtsc`
    instruction is used to read the value of an internal *time stamp counter (TSC)*
    and returns a 64-bit value representing the number of clock ticks since the processor
    was last reset. The rate at which the TSC increments varies among CPU types but
    is roughly once per internal CPU clock cycle. Debuggers cannot stop the TSC from
    incrementing, and therefore a process can determine that it has been stopped for
    an excessive amount of time by measuring the difference in the TSC between two
    successive invocations of `rdtsc`. x86emu maintains an internal TSC that it increments
    with each emulated instruction. Because the emulated TSC is affected only by emulated
    instructions, it does not matter how much actual time elapses between uses of
    `rdtsc`. In such cases, the difference in observed values will always be roughly
    proportional to the number of instructions that were emulated between invocations
    of `rdtsc` and should always be small enough to convince the emulated program
    that no debugger is attached.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一种反调试技术通过使用x86 `rdtsc`指令来测量时间间隔，以确保程序没有被调试器暂停。`rdtsc`指令用于读取内部 *时间戳计数器（TSC）*
    的值，并返回一个表示自处理器上次重置以来时钟滴答数的64位值。TSC增加的速率在不同类型的CPU之间有所不同，但大致为每个内部CPU时钟周期一次。调试器无法停止TSC的增加，因此可以通过测量两次连续调用`rdtsc`之间的TSC差异来确定程序是否被停止了过长时间。x86emu维护一个内部TSC，它在每次仿真指令时都会增加。因为仿真TSC仅受仿真指令的影响，所以使用`rdtsc`之间的实际时间间隔多少并不重要。在这种情况下，观察到的值之间的差异将始终大致与`rdtsc`调用之间仿真的指令数成比例，并且应该足够小，以使仿真程序相信没有附加调试器。
- en: The intentional use of exceptions is another anti-debugging technique that must
    be handled by the emulator. The emulator contains very basic capabilities to mimic
    the behavior of the Windows structured exception handling (SEH) process. When
    the emulated program is a Windows PE binary, the emulator responds to an exception
    or software interrupt by constructing an SEH `CONTEXT` structure, locating the
    current exception handler by walking the exception handler list via `fs:[0]`,
    and transferring control to the installed exception handler. When the exception
    handler returns, the emulator restores the CPU state from the `CONTEXT` structure
    (which may have been manipulated within the exception handler).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 故意使用异常是另一种必须由仿真器处理的反调试技术。仿真器包含非常基本的模拟Windows结构化异常处理（SEH）过程行为的能力。当仿真程序是Windows
    PE二进制文件时，仿真器通过构造SEH `CONTEXT`结构、通过`fs:[0]`遍历异常处理程序列表来定位当前异常处理程序，并将控制权转移到已安装的异常处理程序来响应异常或软件中断。当异常处理程序返回时，仿真器从`CONTEXT`结构（可能已在异常处理程序中操作）恢复CPU状态。
- en: Finally, x86emu emulates the behavior of the x86 hardware-debug registers but
    does not make use of those registers in order to set breakpoints within an emulated
    program. As discussed earlier, the emulator maintains an internal list of user-specified
    breakpoints that it scans prior to executing each instruction. Any manipulation
    of the debug registers within a Windows exception handler will not interfere with
    the operation of the emulator.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，x86emu仿真了x86硬件调试寄存器的行为，但并不使用这些寄存器在仿真程序中设置断点。如前所述，仿真器在执行每条指令之前维护一个用户指定的断点列表，并对其进行扫描。在Windows异常处理程序中对调试寄存器的任何操作都不会干扰仿真器的操作。
- en: '* * *'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[180](#CHP-21-FN-32)]) The low-order 8 bits of the EAX register are also
    referred to as the AL register.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[180](#CHP-21-FN-32)]) EAX寄存器的低8位也被称为AL寄存器。
- en: ^([[181](#CHP-21-FN-33)]) See [http://www.idabook.com/examples/chapter21/](http://www.idabook.com/examples/chapter21/)
    for one such example.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[181](#CHP-21-FN-33)]) 请参阅 [http://www.idabook.com/examples/chapter21/](http://www.idabook.com/examples/chapter21/)
    以获取此类示例之一。
- en: ^([[182](#CHP-21-FN-34)]) IDA does ship with a plug-in capable of interfacing
    with open source Bochs emulator via IDA’s debugging interface. Please refer to
    [Chapter 24](ch24.html "Chapter 24. The IDA Debugger") through [Chapter 26](ch26.html
    "Chapter 26. Additional Debugger Features") for more information.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[182](#CHP-21-FN-34)]) IDA附带了一个插件，可以通过IDA的调试接口与开源Bochs仿真器进行接口。请参阅第24章至第26章以获取更多信息。[第24章](ch24.html
    "第24章。IDA调试器") [第26章](ch26.html "第26章。附加调试功能")。
- en: ^([[183](#CHP-21-FN-35)]) A Windows library handle uniquely identifies a library
    within a Windows process. A *library handle* is actually the base address at which
    the library is loaded into memory.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[183](#CHP-21-FN-35)]) Windows 库句柄在 Windows 进程中唯一标识一个库。一个 *库句柄* 实际上是库加载到内存中的基本地址。
- en: ^([[184](#CHP-21-FN-36)]) Once a program has used `GetProcAddress` to find the
    address of a function, the program may call that function anytime it wishes using
    the returned address. Looking up function addresses in this manner eliminates
    the need to explicitly link to the functions at build time and reduces the amount
    of information that can be extracted by static analysis tools such as dumpbin.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[184](#CHP-21-FN-36)]) 一旦程序使用 `GetProcAddress` 找到函数的地址，程序就可以在任何时候使用返回的地址调用该函数。以这种方式查找函数地址消除了在构建时显式链接到函数的需求，并减少了静态分析工具（如
    dumpbin）可以提取的信息量。
- en: Virtual Machine-Based Obfuscation
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于虚拟机的混淆
- en: Mentioned earlier in this chapter (in [Opcode Obfuscation](ch21.html#opcode_obfuscation
    "Opcode Obfuscation") in [Opcode Obfuscation](ch21.html#opcode_obfuscation "Opcode
    Obfuscation")), some of the most sophisticated obfuscators reimplement the program
    they receive as input, using a custom byte code and associated virtual machine.
    When confronting a binary obfuscated in this manner, the only native code that
    you might see would be the virtual machine. Assuming you recognize that you are
    looking at a software virtual machine, developing a complete understanding of
    all of this code generally fails to reveal the true purpose of the obfuscated
    program. This is because the behavior of the program remains buried in the embedded
    byte code that the virtual machine must interpret. To fully understand the program,
    you must, first, locate all of the embedded byte code and, second, reverse engineer
    the instruction set of the virtual machine so you can properly interpret the meaning
    of that byte code.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到（在 [指令码混淆](ch21.html#opcode_obfuscation "指令码混淆") 中 [指令码混淆](ch21.html#opcode_obfuscation
    "指令码混淆")），一些最复杂的混淆器使用自定义字节码和相关的虚拟机重新实现了它们接收到的程序。当面对以这种方式混淆的二进制文件时，你可能会看到的唯一原生代码就是虚拟机。假设你认识到你正在查看一个软件虚拟机，全面理解所有这些代码通常无法揭示混淆程序的真正目的。这是因为程序的行为仍然隐藏在虚拟机必须解释的嵌入式字节码中。要完全理解程序，你必须首先找到所有嵌入式字节码，其次，逆向工程虚拟机的指令集，这样你才能正确解释字节码的意义。
- en: By way of comparison, imagine that you knew nothing whatsoever about Java, and
    someone handed you a Java virtual machine and a *.class* file containing compiled
    byte code and asked you what they did. Lacking any documentation, you could make
    little sense of the byte code file, and you would need to fully reverse the virtual
    machine to learn both the structure of a *.class* file and how to interpret its
    contents. With an understanding of the byte code machine language, you could then
    proceed to understanding the *.class* file.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较，想象一下你对 Java 一无所知，有人给你一个 Java 虚拟机和包含编译后字节码的 *.class* 文件，并问你它们做了什么。在没有任何文档的情况下，你对字节码文件的理解几乎为零，你需要完全逆向虚拟机来学习
    *.class* 文件的结构以及如何解释其内容。在理解了字节码机器语言之后，你就可以继续理解 *.class* 文件了。
- en: 'VMProtect is an example of a commercial product that utilizes very sophisticated
    virtual machine-based obfuscation techniques. As more of an academic exercise,
    TheHyper’s HyperUnpackMe2 challenge binary is a fairly straightforward example
    of the use of virtual machines in obfuscation, the primary challenge being to
    locate the virtual machine’s embedded byte code program and determine the meaning
    of each byte code. In his article on OpenRCE describing HyperUnpackMe2,^([[185](#ftn.CHP-21-FN-37)])
    Rolf Rolles’s approach was to fully comprehend the virtual machine in order to
    build a processor module capable of disassembling its byte code. The processor
    module then allowed him to disassemble the byte code embedded within the challenge
    binary. A minor limitation to this approach is that it allows you to view either
    the x86 code within HyperUnpackme2 (using IDA’s x86 module) or the virtual machine
    code (using Rolle’s processor module) but not both at the same time. This obligates
    you to create two different databases, each using a different processor module.
    An alternative approach takes advantage of the ability to customize existing processor
    modules (see [Customizing Existing Processors](ch19s05.html "Customizing Existing
    Processors") in [Customizing Existing Processors](ch19s05.html "Customizing Existing
    Processors")) through the use of plug-ins, effectively allowing you to extend
    an instruction set to include all of the instructions of an embedded virtual machine.
    Applying this approach to HyperUnpackMe2 allows us to view x86 code and virtual
    machine code together in a single database, as shown in the following listing:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: VMProtect 是一个利用非常复杂的基于虚拟机的混淆技术的商业产品的例子。作为一个更偏向学术的练习，TheHyper 的 HyperUnpackMe2
    挑战二进制文件是使用虚拟机进行混淆的一个相当直接的例子，主要挑战在于定位虚拟机嵌入的字节码程序并确定每个字节码的含义。在他的关于 OpenRCE 描述 HyperUnpackMe2
    的文章中，Rolf Rolles 的方法是完全理解虚拟机，以便构建一个能够反汇编其字节码的处理器模块。这个处理器模块然后使他能够反汇编挑战二进制文件中嵌入的字节码。这种方法的一个小限制是，它允许你查看
    HyperUnpackme2 中的 x86 代码（使用 IDA 的 x86 模块）或虚拟机代码（使用 Rolle 的处理器模块），但不能同时查看两者。这迫使你创建两个不同的数据库，每个数据库使用不同的处理器模块。另一种方法利用了通过使用插件来定制现有处理器模块的能力（参见[定制现有处理器](ch19s05.html
    "Customizing Existing Processors")），有效地允许你扩展指令集以包括嵌入虚拟机的所有指令。将这种方法应用于 HyperUnpackMe2
    允许我们在单个数据库中一起查看 x86 代码和虚拟机代码，如下面的列表所示：
- en: '[PRE58]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, the code beginning at ![](httpatomoreillycomsourcenostarchimages854061.png)
    is disassembled as HyperUnpackMe2 byte code, while the code that follows at ![](httpatomoreillycomsourcenostarchimages854063.png)
    is displayed as x86 code.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从 ![](httpatomoreillycomsourcenostarchimages854061.png) 开始的代码被反汇编为 HyperUnpackMe2
    字节码，而随后的代码在 ![](httpatomoreillycomsourcenostarchimages854063.png) 处显示为 x86 代码。
- en: The ability to simultaneously display native code and byte code has been anticipated
    by Hex-Rays, which introduced custom datatypes and formats in IDA 5.7\. Custom
    data formats are useful when IDA’s built-in formatting options fail to meet your
    needs. New formatting capabilities are registered by specifying (using a script
    or plug-in) a menu name for your format and a function to perform the formatting.
    Once you select a custom format for a data item, IDA will invoke your formatting
    function each time it needs to display that data item. Custom datatypes are useful
    when IDA’s built-in datatypes are not expressive enough represent the data that
    you encounter in a particular binary. Custom datatypes, like custom formats, are
    registered using a script or a plug-in. The Hex-Rays example registers a custom
    data type to designate virtual machine byte code and displays each byte code as
    an instruction by using a custom data format. A drawback to this approach is that
    it requires you to locate every virtual machine instruction and explicitly change
    its data type. Using a custom processor extension, designating a single value
    as a virtual machine instruction automatically leads to the discovery of every
    reachable instruction, because IDA drives the disassembly process and the processor
    extension discovers new reachable instructions via its custom_emu implementation.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Hex-Rays 预测到了同时显示原生代码和字节码的能力，在 IDA 5.7 中引入了自定义数据类型和格式。当 IDA 的内置格式选项无法满足您的需求时，自定义数据格式非常有用。通过指定（使用脚本或插件）格式和执行格式的函数的菜单名称，可以注册新的格式功能。一旦为数据项选择了一个自定义格式，IDA
    就会在需要显示该数据项时调用您的格式化函数。当 IDA 的内置数据类型不足以表示您在特定二进制文件中遇到的数据时，自定义数据类型非常有用。与自定义格式一样，自定义数据类型也是通过脚本或插件注册的。Hex-Rays
    的示例注册了一个自定义数据类型来指定虚拟机字节码，并使用自定义数据格式将每个字节码显示为一条指令。这种方法的一个缺点是，它要求您找到每个虚拟机指令并显式更改其数据类型。使用自定义处理器扩展，将单个值指定为虚拟机指令会自动导致发现每个可到达的指令，因为
    IDA 驱动反汇编过程，处理器扩展通过其自定义_emu 实现发现新的可到达指令。
- en: '* * *'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[185](#CHP-21-FN-37)]) See “Defeating HyperUnpackMe2 With an IDA Processor
    Module” at [http://www.openrce.org/articles/full_view/28](http://www.openrce.org/articles/full_view/28).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[185](#CHP-21-FN-37)]) 请参阅“使用 IDA 处理器模块击败 HyperUnpackMe2”文章，链接：[http://www.openrce.org/articles/full_view/28](http://www.openrce.org/articles/full_view/28).
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Obfuscated programs are the rule rather than the exception when it comes to
    malware these days. Any attempts to study the internal operations of a mal-ware
    sample are almost certain to require some type of de-obfuscation. Whether you
    take a debugger-assisted, dynamic approach to de-obfuscation or whether you prefer
    not to run potentially malicious code and instead use scripts or emulation to
    de-obfuscate your binaries, the ultimate goal is to produce a de-obfuscated binary
    that can be fully disassembled and properly analyzed. In most cases, this final
    analysis will be performed using a tool such as IDA. Given this ultimate goal
    (of using IDA for analysis), it makes some sense to attempt to use IDA from start
    to finish. The techniques presented in this chapter are intended to demonstrate
    that IDA is capable of far more than generating disassembly listings. In [Chapter 25](ch25.html
    "Chapter 25. Disassembler/Debugger Integration") we will revisit obfuscated code
    and take a look at how IDA’s debugging features may be leveraged as a de-obfuscation
    tool as well.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的恶意软件中，混淆程序是常态而非例外。任何试图研究恶意软件样本内部操作的行为几乎肯定需要某种类型的去混淆。无论您是采用调试器辅助的动态去混淆方法，还是更倾向于不运行可能有害的代码，而是使用脚本或仿真来去混淆您的二进制文件，最终目标都是生成一个去混淆的二进制文件，以便可以完全反汇编并进行适当的分析。在大多数情况下，这种最终分析将使用像
    IDA 这样的工具来完成。鉴于这个最终目标（使用 IDA 进行分析），从开始到结束尝试使用 IDA 是有意义的。本章中介绍的技术旨在证明 IDA 能够做到远不止生成反汇编列表。在第
    25 章（[Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger Integration")）中，我们将重新审视混淆代码，并探讨如何利用
    IDA 的调试功能作为去混淆工具。
- en: Chapter 22. Vulnerability Analysis
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 22 章. 漏洞分析
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: 'Before we get too far into this chapter, we need to make one thing clear: IDA
    is not a vulnerability discovery tool. There, we said it; what a relief! IDA seems
    to have attained mystical qualities in some people’s minds. All too often people
    seem to have the impression that merely opening a binary with IDA will reveal
    all the secrets of the universe, that the behavior of a piece of malware will
    be fully explained to them in comments automatically generated by IDA, that vulnerabilities
    will be highlighted in red, and that IDA will automatically generate exploit code
    if you right-click while standing on one foot in some obscure Easter egg–activation
    sequence.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入本章内容之前，我们需要明确一点：IDA 不是一个漏洞发现工具。我们就是这样说的；多么令人欣慰！IDA 在某些人的心目中似乎获得了神秘的品质。人们常常有一种印象，认为只需用
    IDA 打开一个二进制文件，就能揭示宇宙的所有秘密，恶意软件的行为将被 IDA 自动生成的注释完全解释，漏洞将以红色突出显示，如果你在某个神秘的复活节彩蛋激活序列中单脚站立并右键点击，IDA
    将自动生成漏洞利用代码。
- en: While IDA is certainly a very capable tool, without a clever user sitting at
    the keyboard (and perhaps a handy collection of scripts and plug-ins), it is really
    only a disassembler/debugger. As a static-analysis tool, it can only facilitate
    your attempts to locate software vulnerabilities. Ultimately, it is up to your
    skills and how you apply them as to whether IDA makes your search for vulnerabilities
    easier. Based on our experience, IDA is not the optimal tool for locating new
    vulnerabilities,^([[186](#ftn.CHP-22-FN-1)]) but when used in conjunction with
    a debugger, it is one of the best tools available for assisting in exploit development
    once a vulnerability has been discovered.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 IDA 确实是一个非常强大的工具，但没有一个聪明的用户坐在键盘前（也许还有一套方便的脚本和插件），它实际上只是一个反汇编器/调试器。作为一个静态分析工具，它只能帮助你尝试定位软件漏洞。最终，是否使
    IDA 使你的漏洞搜索更容易，取决于你的技能以及你如何应用它们。根据我们的经验，IDA 并不是定位新漏洞的最佳工具^([[186](#ftn.CHP-22-FN-1)]),
    但一旦发现漏洞，与调试器结合使用时，它就是可用的最佳工具之一，用于辅助开发漏洞利用。
- en: Over the past several years, IDA has taken on a new role in discovering existing
    vulnerabilities. Initially, it may seem unusual to search for known vulnerabilities
    until we stop to consider exactly what is known about these vulnerabilities and
    exactly who knows it. In the closed-source, binary-only software world, vendors
    frequently release software patches without disclosing exactly what has been patched
    and why. By performing differential analysis between new patched versions of a
    piece of software and old un-patched versions of the same software, it is possible
    to isolate the areas that have changed within a binary. Under the assumption that
    these changes were made for a reason, such differential-analysis techniques actually
    help to shine a spotlight on what were formerly vulnerable code sequences. With
    the search thusly narrowed, anyone with the requisite skills can develop an exploit
    for use against unpatched systems. In fact, given Microsoft’s well-known *Patch
    Tuesday* cycle of publishing updates, large numbers of security researchers prepare
    to sit down and do just that once every month.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，IDA 在发现现有漏洞方面承担了新的角色。起初，在考虑了我们对这些漏洞的了解以及谁知道这些漏洞之后，搜索已知漏洞可能看起来有些不寻常。在闭源、仅二进制软件的世界里，供应商经常发布软件补丁，而不透露具体修复了什么以及为什么修复。通过在新补丁版本和旧未修补版本的同一种软件之间进行差异分析，可以隔离二进制中发生变化的区域。在假设这些更改是出于某种原因的情况下，这种差异分析技术实际上有助于突出以前易受攻击的代码序列。通过这样缩小搜索范围，任何具备相应技能的人都可以为未修补的系统开发漏洞利用程序。事实上，鉴于微软众所周知的“补丁星期二”发布更新周期，大量的安全研究人员准备每个月都坐下来做这件事。
- en: Considering that entire books exist on the topic,^([[187](#ftn.CHP-22-FN-2)])
    there is no way that we can do justice to vulnerability analysis in a single chapter
    in a book dedicated to IDA. What we will do is assume that the reader is familiar
    with some of the basic concepts of software vulnerabilities, such as buffer overflows,
    and discuss some of the ways that IDA may be used to hunt down, analyze, and ultimately
    develop exploits for those vulnerabilities.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到关于这个主题有整本书，我们不可能在一本关于 IDA 的书中用一章来公正地处理漏洞分析。我们将假设读者熟悉一些关于软件漏洞的基本概念，例如缓冲区溢出，并讨论一些使用
    IDA 搜索、分析和最终为这些漏洞开发漏洞利用程序的方法。
- en: Discovering New Vulnerabilities with IDA
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IDA 发现新漏洞
- en: Vulnerability researchers take many different approaches to discovering new
    vulnerabilities in software. When source code is available, it may be possible
    to utilize any of a growing number of automated source code–auditing tools to
    highlight potential problem areas within a program. In many cases, such automated
    tools will only point out the low-hanging fruit, while discovery of deeper vulnerabilities
    may require extensive manual auditing.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞研究人员采取了许多不同的方法来发现软件中的新漏洞。当源代码可用时，可以利用越来越多的自动化源代码审计工具来突出显示程序中的潜在问题区域。在许多情况下，此类自动化工具只会指出低垂的果实，而发现更深层次的漏洞可能需要广泛的手动审计。
- en: Tools for performing automated auditing of binaries offer many of the same reporting
    capabilities offered by automated source-auditing tools. A clear advantage of
    automated binary analysis is that no access to the application source code is
    required. Therefore, it is possible to perform automated analysis of closed-source,
    binary-only programs. Veracode^([[188](#ftn.CHP-22-FN-3)]) is an example of a
    company that offers a subscription-based service in which users may submit binary
    files for analysis by Veracode’s proprietary binary-analysis tools. While there
    is no guarantee that such tools can find any or all vulnerabilities within a binary,
    these technologies bring binary analysis within reach of the average person seeking
    some measure of confidence that the software she uses is free from vulnerabilities.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 执行自动化二进制审计的工具提供了与自动化源代码审计工具相同的许多报告功能。自动化二进制分析的一个明显优势是不需要访问应用程序的源代码。因此，可以对仅提供二进制文件的封闭源代码程序进行自动化分析。Veracode^([[188](#ftn.CHP-22-FN-3)])是一家提供基于订阅服务的企业，用户可以向Veracode的专有二进制分析工具提交二进制文件进行分析。虽然不能保证此类工具可以在二进制中找到任何或所有漏洞，但这些技术使二进制分析对寻求对其使用的软件有一定信心的一般用户变得可行。
- en: 'Whether auditing at the source or binary level, basic static-analysis techniques
    include auditing for the use of problematic functions such as `strcpy` and `sprintf`,
    auditing the use of buffers returned by dynamic memory-allocation routines such
    as `malloc` and `VirtualAlloc`, and auditing the handling of user-supplied input
    received via functions such as `recv`, `read`, `fgets`, and many other similar
    functions. Locating such calls within a database is not difficult. For example,
    to track down all calls to `strcpy`, we could perform the following steps:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在源代码级别还是二进制级别进行审计，基本的静态分析技术包括审计使用有问题的函数，如`strcpy`和`sprintf`，审计使用由动态内存分配例程（如`malloc`和`VirtualAlloc`）返回的缓冲区，以及审计通过函数（如`recv`、`read`、`fgets`等）接收到的用户输入的处理。在数据库中定位此类调用并不困难。例如，要追踪所有对`strcpy`的调用，我们可以执行以下步骤：
- en: Find the `strcpy` function.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`strcpy`函数。
- en: Display all cross-references to the `strcpy` function by positioning the cursor
    on the `strcpy` label and then choosing **View** ▸ **Open Subviews** ▸ **Cross
    References**.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将光标置于`strcpy`标签上，然后选择**查看** ▸ **打开子视图** ▸ **交叉引用**来显示所有对`strcpy`函数的交叉引用。
- en: Visit each cross-reference and analyze the parameters provided to `strcpy` to
    determine whether a buffer overflow may be possible.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问每个交叉引用，并分析提供给`strcpy`的参数，以确定是否可能发生缓冲区溢出。
- en: 'Step 3 may require a substantial amount of code and data-flow analysis to understand
    all potential inputs to the function call. Hopefully, the complexity of such a
    task is clear. Step 1, although it seems straightforward, may require a little
    effort on your part. Locating `strcpy` may be as easy as using the Jump ▸ Jump
    to Address command (G) and entering `strcpy` as the address to jump to. In Windows
    PE binaries or statically linked ELF binaries, this is usually all that is needed.
    However, with other binaries, extra steps may be required. In a dynamically linked
    ELF binary, using the Jump command may not take you directly to the desired function.
    Instead, it is likely to take you to an entry in the `extern` section (which is
    involved in the dynamic-linking process). An IDA representation of the `strcpy`
    entry in an `extern` section is shown here:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步可能需要大量的代码和数据流分析来理解函数调用的所有潜在输入。希望这样的任务的复杂性是显而易见的。第1步，尽管看起来很简单，可能需要你付出一点努力。定位`strcpy`可能就像使用“跳转
    ▸ 跳转到地址”命令（G）并输入要跳转到的地址`strcpy`一样简单。在Windows PE二进制文件或静态链接的ELF二进制文件中，这通常就足够了。然而，在其他二进制文件中，可能需要额外的步骤。在动态链接的ELF二进制文件中，使用跳转命令可能不会直接带你到所需函数。相反，它可能带你到`extern`部分的条目（这涉及到动态链接过程）。以下是IDA在`extern`部分中`strcpy`条目的表示：
- en: '[PRE59]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To confuse matters, this location does not appear to be named `strcpy` at all
    (it is, but the name is indented), and the only code cross-reference ![](httpatomoreillycomsourcenostarchimages854061.png)
    to the location is a jump cross-reference from a function that appears to be named
    `_strcpy`, while a data cross-reference is also made to this location from the
    `.got` section. The referencing function is actually named `.strcpy`, which is
    not at all obvious from the display. In this case, IDA has replaced the dot character
    with an underscore because IDA does not consider dots to be valid identifier characters
    by default. Double-clicking the code cross-reference takes us to the program’s
    procedure linkage table (.`plt`) entry for `strcpy`, as shown here:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了混淆问题，这个位置看起来根本不叫`strcpy`（实际上它叫，但名字缩进），并且指向这个位置的唯一代码交叉引用![链接](httpatomoreillycomsourcenostarchimages854061.png)是从一个看起来命名为`_strcpy`的函数跳转过来的，同时从`.got`部分也有数据交叉引用指向这个位置。引用函数实际上命名为`.strcpy`，但从显示中并不明显。在这种情况下，IDA将点字符替换为下划线，因为IDA默认不认为点是有效的标识符字符。双击代码交叉引用会带我们到程序中`strcpy`的进程链接表（`.`plt`）条目，如下所示：
- en: '[PRE60]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If instead we follow the data cross-reference, we end up at the corresponding
    `.got` entry for `strcpy` shown here:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们追踪数据交叉引用，最终会到达这里显示的`strcpy`对应的`.got`条目：
- en: '[PRE61]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the `.got` entry, we encounter another data cross-reference to the `.strcpy`
    function in the `.plt` section. In practice, following the data cross-references
    is the most reliable means of navigating from the `extern` section to the `.plt`
    section. In dynamically linked ELF binaries, functions are called indirectly through
    the procedure linkage table. Now that we have reached the .`plt`, we can bring
    up the cross-references to `_strcpy` (actually `.strcpy`) and begin to audit each
    call (of which there are at least two in this example).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.got`条目中，我们遇到了另一个指向`.plt`部分`.strcpy`函数的数据交叉引用。在实践中，跟随数据交叉引用是从`extern`部分导航到`.plt`部分的最可靠方法。在动态链接的ELF二进制文件中，函数通过进程链接表间接调用。现在我们已经到达了`.`plt`，我们可以调出对`_strcpy`（实际上是`.strcpy`）的交叉引用，并开始审计每个调用（在这个例子中至少有两个）。
- en: This process can become tedious when we have a list of several common functions
    whose calls we wish to locate and audit. At this point it may be useful to develop
    a script that can automatically locate and comment all interesting function calls
    for us. With comments in place, we can perform simple searches to move from one
    audit location to another. The foundation for such a script is a function that
    can reliably locate another function so that we can locate all cross-references
    to that function. With the understanding of ELF binaries gained in the preceding
    discussion, the IDC function in [Example 22-1](ch22.html#finding_a_functionas_callable_address
    "Example 22-1. Finding a function’s callable address") takes a function name as
    an input argument and returns an address suitable for cross-reference iteration.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一系列常见的函数调用列表，希望定位和审计这些调用时，这个过程可能会变得繁琐。此时，开发一个能够自动定位并注释所有有趣函数调用的脚本可能是有用的。有了注释，我们可以执行简单的搜索，从一个审计位置移动到另一个位置。此类脚本的基础是一个能够可靠地定位另一个函数的函数，以便我们可以定位对该函数的所有交叉引用。在前面的讨论中，我们获得了对ELF二进制文件的理解，[示例22-1](ch22.html#finding_a_functionas_callable_address
    "示例22-1. 查找函数的可调用地址")中的IDC函数接受一个函数名作为输入参数，并返回一个适合交叉引用迭代的地址。
- en: Example 22-1. Finding a function’s callable address
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例22-1. 查找函数的可调用地址]'
- en: '[PRE62]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Using the supplied return address, it is now possible to track down all of the
    references to any function whose use we want to audit. The IDC function in [Example 22-2](ch22.html#flagging_calls_to_a_designated_function
    "Example 22-2. Flagging calls to a designated function") leverages the `getFuncAddr`
    function from the preceding example to obtain a function address and add comments
    at all calls to the function.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的返回地址，现在可以追踪到所有我们希望审计的函数的引用。[示例22-2](ch22.html#flagging_calls_to_a_designated_function
    "示例22-2. 标记指定函数的调用")中的IDC函数利用前一个示例中的`getFuncAddr`函数来获取函数地址，并在所有调用该函数的位置添加注释。
- en: Example 22-2. Flagging calls to a designated function
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例22-2. 标记指定函数的调用]'
- en: '[PRE63]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once the desired function’s address has been located ![](httpatomoreillycomsourcenostarchimages854061.png),
    two loops are used to iterate over cross-references to the function. In the first
    loop ![](httpatomoreillycomsourcenostarchimages854063.png), a comment is inserted
    at each location that calls the function of interest. In the second loop ![](httpatomoreillycomsourcenostarchimages854093.png),
    additional comments are inserted at each location that takes the address of the
    function (use of an offset cross-reference type). The second loop is required
    in order to track down calls of the following style:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到了所需函数的地址 ![http://atomoreilly.com/source/nostarch/images/854061.png]，就使用两个循环来迭代该函数的交叉引用。在第一个循环
    ![http://atomoreilly.com/source/nostarch/images/854063.png]，在调用感兴趣函数的每个位置插入注释。在第二个循环
    ![http://atomoreilly.com/source/nostarch/images/854093.png]，在获取函数地址的每个位置插入额外的注释（使用偏移交叉引用类型）。第二个循环是必要的，以便追踪以下风格的调用：
- en: '[PRE64]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the compiler has cached the address of the `strcpy` function
    in the ESI register ![](httpatomoreillycomsourcenostarchimages854061.png) in order
    to make use of a faster means of calling `strcpy` later ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the program. The `call` instruction shown here is faster to execute because
    it is both smaller (2 bytes) and requires no additional operations to resolve
    the target of the call, since the address is already contained within the CPU
    within the ESI register. A compiler may choose to generate this type of code when
    one function makes several calls to another function.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器已将`strcpy`函数的地址缓存到ESI寄存器 ![http://atomoreilly.com/source/nostarch/images/854061.png]，以便在程序稍后使用更快的调用方式
    ![http://atomoreilly.com/source/nostarch/images/854063.png]。这里显示的`call`指令执行速度更快，因为它既小（2字节）且不需要额外的操作来解析调用目标，因为地址已经包含在CPU的ESI寄存器中。编译器可能会选择生成此类代码，当某个函数多次调用另一个函数时。
- en: 'Given the indirect nature of the call in this example, the `flagCalls` function
    in our example may see only the data cross-reference to `strcpy` ![](httpatomoreillycomsourcenostarchimages854061.png)
    while failing to see the call to `strcpy` ![](httpatomoreillycomsourcenostarchimages854063.png)
    because the `call` instruction does not reference `strcpy` directly. In practice,
    however, IDA possesses the capability to perform some limited data-flow analysis
    in cases such as these and is likely to generate the disassembly shown here:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个例子中调用的间接性，我们示例中的`flagCalls`函数可能只能看到对`strcpy`的数据交叉引用 ![图片](http://atomoreilly.com/source/nostarch/images/854061.png)，而无法看到对`strcpy`的调用
    ![图片](http://atomoreilly.com/source/nostarch/images/854063.png)，因为`call`指令并没有直接引用`strcpy`。然而，在实践中，IDA具有在这些情况下执行一些有限的数据流分析的能力，并可能生成以下所示的汇编代码：
- en: '[PRE65]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that the `call` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    has been annotated with a comment indicating which function IDA believes is being
    called. In addition to inserting the comment, IDA adds a code cross-reference
    from the point of the call to the function being called. This benefits the `flagCalls`
    function, because in this case the `call` instruction will be found and annotated
    via a code cross-reference.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`call`指令 ![图片](http://atomoreilly.com/source/nostarch/images/854061.png)
    已经被注释，表明IDA认为正在调用哪个函数。除了插入注释外，IDA还从调用点添加了一个代码交叉引用到被调用的函数。这有利于`flagCalls`函数，因为在这种情况下，`call`指令将通过代码交叉引用被找到并注释。
- en: 'To finish up our example script, we need a `main` function that invokes `flagCalls`
    for all of the functions that we are interested in auditing. A simple example
    to annotate calls to some of the functions mentioned earlier in this section is
    shown here:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的示例脚本，我们需要一个`main`函数，该函数调用我们感兴趣审计的所有函数的`flagCalls`。本节前面提到的某些函数的调用注释的简单示例如下：
- en: '[PRE66]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After running this script, we can move from one interesting call to the next
    by searching for the inserted comment text, `*** AUDIT ***`. Of course this still
    leaves a lot of work to be done from an analysis perspective, since the mere fact
    that a program calls `strcpy` does not make that program exploitable. This is
    where data-flow analysis comes into play. In order to understand whether a particular
    call to `strcpy` is exploitable or not, you must determine what parameters are
    being passed in to `strcpy` and evaluate whether those parameters can be manipulated
    to your advantage or not.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，我们可以通过搜索插入的注释文本`*** AUDIT ***`从一个有趣的调用跳转到下一个。当然，这仍然留下了很多分析方面的工作要做，因为仅仅因为程序调用了`strcpy`并不意味着该程序可利用。这正是数据流分析发挥作用的地方。为了了解对`strcpy`的特定调用是否可利用，您必须确定传递给`strcpy`的参数，并评估这些参数是否可以被操纵以获得您的优势。
- en: Data-flow analysis is a far more complex task than simply finding calls to problem
    functions. In order to track the flow of data in a static-analysis environment,
    a thorough understanding of the instruction set being used is required. Your static-analysis
    tools need to understand where registers may have been assigned values and how
    those values may have changed and propagated to other registers. Further, your
    tools need a means for determining the sizes of source and destination buffers
    being referenced within the program, which in turn requires the ability to understand
    the layout of stack frames and global variables as well as the ability to deduce
    the size of dynamically allocated memory blocks. And, of course, all of this is
    being attempted without actually running the program.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流分析是一项比仅仅找到对问题函数的调用要复杂得多的任务。为了在静态分析环境中跟踪数据的流动，需要对所使用的指令集有一个彻底的了解。您的静态分析工具需要理解寄存器可能被赋予的值以及这些值如何可能改变并传播到其他寄存器。此外，您的工具需要一种确定程序中引用的源和目标缓冲区大小的手段，这反过来又需要理解堆栈帧和全局变量的布局，以及推断动态分配的内存块大小的能力。当然，所有这些都是在实际上不运行程序的情况下尝试的。
- en: 'An interesting example of what can be accomplished with creative scripting
    comes in the form of the BugScam^([[189](#ftn.CHP-22-FN-4)]) scripts created by
    Halvar Flake. BugScam utilizes techniques similar to the preceding examples to
    locate calls to problematic functions and takes the additional step of performing
    rudimentary data-flow analysis at each function call. The result of BugScam’s
    analysis is an HTML report of potential problems in a binary. A sample report
    table generated as a result of a `sprintf` analysis is shown here:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 创意脚本所能完成的有趣示例之一是 Halvar Flake 创建的 BugScam^([[189](#ftn.CHP-22-FN-4)]) 脚本。BugScam
    使用与前面示例类似的技术来定位对问题函数的调用，并在每个函数调用处执行基本的数据流分析。BugScam 分析的结果是一个二进制文件中潜在问题的 HTML 报告。以下是一个由
    `sprintf` 分析生成的示例报告表：
- en: '| Address | Severity | Description |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 地址 | 严重性 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8048c03 | 5 | The maximum expansion of the data appears to be larger than
    the target buffer; this might be the cause of a buffer overrun! Maximum Expansion:
    1053\. Target Size: 1036. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 8048c03 | 5 | 数据的最大扩展似乎大于目标缓冲区；这可能是缓冲区溢出的原因！最大扩展：1053。目标大小：1036。 |'
- en: In this case, BugScam was able to determine the size of the input and output
    buffers, which, when combined with the format specifiers contained in the format
    string, were used to determine the maximum size of the generated output.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，BugScam 能够确定输入和输出缓冲区的大小，当与格式字符串中包含的格式说明符结合使用时，用于确定生成输出的最大大小。
- en: Developing scripts of this nature requires an in-depth understanding of various
    exploit classes in order to develop an algorithm that can be applied generically
    across a large body of binaries. Lacking such knowledge, we can still develop
    scripts (or plug-ins) that answer simple questions for us faster than we can find
    the answers manually.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 开发此类脚本需要深入了解各种漏洞类别，以便开发一个可以通用地应用于大量二进制文件的算法。缺乏这种知识，我们仍然可以开发脚本（或插件），使我们能够比手动查找答案更快地回答简单问题。
- en: As a final example, consider the task of locating all functions that contain
    stack-allocated buffers, since these are the functions that might be susceptible
    to stack-based buffer-overflow attacks. Rather than manually scrolling through
    a database, we can develop a script to analyze the stack frame of each function,
    looking for variables that occupy large amounts of space. The Python function
    in [Example 22-3](ch22.html#scanning_for_stack-allocated_buffers "Example 22-3. Scanning
    for stack-allocated buffers") iterates through the defined members of a given
    function’s stack frame in search of variables whose size is larger than a specified
    minimum size.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，考虑定位所有包含堆分配缓冲区的函数的任务，因为这些函数可能容易受到基于堆的缓冲区溢出攻击。而不是手动滚动数据库，我们可以开发一个脚本来分析每个函数的堆栈帧，寻找占用大量空间的变量。[示例
    22-3](ch22.html#scanning_for_stack-allocated_buffers "示例 22-3. 扫描堆分配缓冲区") 中的 Python
    函数遍历给定函数堆栈帧中定义的成员，寻找大小大于指定最小大小的变量。
- en: Example 22-3. Scanning for stack-allocated buffers
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 22-3. 扫描堆分配缓冲区
- en: '[PRE67]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This function locates all the variables in a stack frame using repeated calls
    to `GetMemberName` ![](httpatomoreillycomsourcenostarchimages854061.png) for all
    valid offsets within the stack frame. The size of a variable is computed as the
    difference between the starting offsets of two successive variables ![](httpatomoreillycomsourcenostarchimages854063.png).
    If the size exceeds a threshold size (`minsize`) ![](httpatomoreillycomsourcenostarchimages854093.png),
    then the variable is reported as a possible stack buffer. The index into the structure
    is moved along by either 1 byte ![](httpatomoreillycomsourcenostarchimages854095.png)
    when no member is defined at the current offset or by the size of any member found
    at the current offset ![](httpatomoreillycomsourcenostarchimages854099.png). The
    `GetMem-berSize` function may seem like a more suitable choice for computing the
    size of each stack variable; however, this is true only if the variable has been
    sized properly by either IDA or the user. Consider the following stack frame:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过重复调用 `GetMemberName` ![](httpatomoreillycomsourcenostarchimages854061.png)
    来定位堆栈帧中的所有变量，对于堆栈帧中所有有效的偏移量。变量的大小是通过计算两个连续变量的起始偏移量之间的差值来计算的 ![](httpatomoreillycomsourcenostarchimages854063.png)。如果大小超过阈值大小
    (`minsize`) ![](httpatomoreillycomsourcenostarchimages854093.png)，则该变量被报告为可能的堆栈缓冲区。结构体中的索引通过以下方式移动：当当前偏移量没有定义成员时，通过
    1 字节 ![](httpatomoreillycomsourcenostarchimages854095.png) 移动；当当前偏移量找到任何成员时，通过该成员的大小
    ![](httpatomoreillycomsourcenostarchimages854099.png) 移动。`GetMemberSize` 函数可能看起来更适合计算每个堆栈变量的大小；然而，这只有在变量已被
    IDA 或用户正确设置大小的情况下才成立。考虑以下堆栈帧：
- en: '[PRE68]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Using the displayed byte offsets, we can compute that there are 1,024 bytes
    from the start of `var_818` to the start of `var_418` (`818h - 418h = 400h`) and
    1,036 bytes between the start of `var_418` and the start of `var_C` (`418h - 0Ch`).
    However, the stack frame might be expanded to show the following layout:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显示的字节偏移量，我们可以计算出从 `var_818` 的开始到 `var_418` 的开始有 1,024 字节（`818h - 418h = 400h`），从
    `var_418` 的开始到 `var_C` 的开始有 1,036 字节（`418h - 0Ch`）。然而，堆栈帧可能扩展以显示以下布局：
- en: '[PRE69]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, `var_418` has been collapsed into an array, while `var_818` appears to
    be only a single byte (with 1,023 undefined bytes filling the space between `var_818`
    and `var_418`). For this stack layout, `GetMemberSize` will report 1 byte for
    `var_818` and 1,036 bytes for `var_418`, which is an undesirable result. The output
    of a call to `findStackBuffers(0x08048B38, 16)` results in the following output,
    regardless of whether `var_818` is defined as a single byte or an array of 1,024
    bytes:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`var_418` 已被合并为一个数组，而 `var_818` 看起来只是一个单字节（1,023 个未定义字节填充了 `var_818` 和 `var_418`
    之间的空间）。对于这种堆布局，`GetMemberSize` 将报告 `var_818` 为 1 字节，`var_418` 为 1,036 字节，这是一个不理想的结果。调用
    `findStackBuffers(0x08048B38, 16)` 的输出如下，无论 `var_818` 被定义为单字节还是 1,024 字节的数组：
- en: '[PRE70]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Creating a `main` function that iterates through all functions in a database
    (see [Chapter 15](ch15.html "Chapter 15. IDA Scripting")) and calls `findStackBuffers`
    for each function yields a script that quickly points out the use of stack buffers
    within a program. Of course, determining whether any of those buffers can be overflowed
    requires additional (usually manual) study of each function. The tedious nature
    of static analysis is precisely the reason that fuzz testing is so popular.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，该函数遍历数据库中的所有函数（见第 15 章 [IDA Scripting]），并对每个函数调用 `findStackBuffers`，这将生成一个快速指出程序中堆栈缓冲区使用的脚本。当然，确定这些缓冲区中的任何一个是否可以被溢出需要额外的（通常是手动）对每个函数的研究。静态分析的繁琐性质正是模糊测试如此受欢迎的原因。
- en: '* * *'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[186](#CHP-22-FN-1)]) In general, far more vulnerabilities are discovered
    through fuzz testing than through static analysis.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[186](#CHP-22-FN-1)]) 通常，通过模糊测试发现的安全漏洞比通过静态分析发现的要多得多。
- en: '^([[187](#CHP-22-FN-2)]) For example, see Jon Erickson’s *Hacking: The Art
    of Exploitation, 2nd Edition* ([http://nostarch.com/hacking2.htm](http://nostarch.com/hacking2.htm)).'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[187](#CHP-22-FN-2)]) 例如，参见 Jon Erickson 的 *Hacking: The Art of Exploitation,
    2nd Edition* ([http://nostarch.com/hacking2.htm](http://nostarch.com/hacking2.htm)).'
- en: ^([[188](#CHP-22-FN-3)]) See [http://www.veracode.com/](http://www.veracode.com/).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[188](#CHP-22-FN-3)]) 请参阅 [http://www.veracode.com/](http://www.veracode.com/).
- en: ^([[189](#CHP-22-FN-4)]) See [http://www.sourceforge.net/projects/bugscam/](http://www.sourceforge.net/projects/bugscam/).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[189](#CHP-22-FN-4)]) 请参阅 [http://www.sourceforge.net/projects/bugscam/](http://www.sourceforge.net/projects/bugscam/).
- en: After-the-Fact Vulnerability Discovery with IDA
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IDA 进行事后的漏洞发现
- en: A perpetual debate rages over the exact process by which software vulnerabilities
    should be disclosed. For any vulnerability discovered in a piece of software,
    we can assign the roles of discoverer (of the vulnerability) and maintainer (of
    the software). In addition, we can specify a number of events, which may or may
    not take place, surrounding the discovery of any vulnerability. Some of these
    events are briefly described here. Please keep in mind that the entire vulnerability-disclosure
    process is hotly debated, and the following terms are by no means standardized
    or even widely accepted.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件漏洞应该如何披露的精确过程一直存在永无休止的争论。对于任何软件中发现的漏洞，我们可以分配发现者（漏洞的发现者）和维护者（软件的维护者）的角色。此外，我们可以指定一些可能发生也可能不发生的事件，这些事件围绕任何漏洞的发现。其中一些事件在此简要描述。请记住，整个漏洞披露过程是一个激烈争论的话题，以下术语绝对没有标准化，甚至没有被广泛接受。
- en: '**Discovery**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**发现**'
- en: The time at which a vulnerability is initially discovered. For our purposes,
    we will also consider this to be the time at which an exploit for that vulnerability
    is initially developed.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞最初被发现的时间。在我们的目的中，我们也将这个时间视为针对该漏洞的利用程序最初开发的时间。
- en: '**Notification**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**通知**'
- en: The time at which the software maintainer is initially made aware of the vulnerability
    within its product. This may coincide with discovery if the vendor happens to
    find the vulnerability itself.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 软件维护者最初意识到其产品中存在漏洞的时间。这可能与管理员自己发现漏洞时的情况一致。
- en: '**Disclosure**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**披露**'
- en: The time at which a vulnerability is made known to the public. This event can
    be muddied by the level of detail made available regarding the vulnerability.
    Disclosure may or may not be accompanied by the release or identification of working
    exploits. In some cases disclosure also serves as notification to the vendor.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞对公众公开的时间。这一事件可能会因为关于漏洞的详细程度而变得复杂。披露可能伴随着或没有工作利用程序的发布或识别。在某些情况下，披露也作为对供应商的通知。
- en: '**Mitigation**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓解**'
- en: The time at which steps are published that, if followed, may prevent a user
    from falling victim to an existing exploit. Mitigation steps are work-around solutions
    for users awaiting the publication of a patch.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 发布步骤的时间，如果遵循这些步骤，可以防止用户成为现有利用程序的受害者。缓解步骤是用户等待补丁发布时的临时解决方案。
- en: '**Patch availability**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**补丁可用性**'
- en: The time at which the maintainer (or a third party) makes available a corrected
    version of the vulnerable software.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 维护者（或第三方）提供修正版漏洞软件的时间。
- en: '**Patch application**'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**补丁应用**'
- en: The time at which users actually install the updated, corrected software, rendering
    themselves immune (hopefully) to all known attacks that rely on the presence of
    the given vulnerability.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 用户实际安装更新、修正软件的时间，使他们（希望）对所有已知依赖该漏洞存在的攻击免疫。
- en: A wealth of papers are more than happy to tell you all about windows of vulnerability,
    obligations on the part of the discoverer and the maintainer, and exactly how
    much information should be disclosed and when that disclosure should take place.
    Getting to the point, it is common for disclosure to coincide with the availability
    of a patch.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 许多论文都乐于告诉你关于漏洞窗口、发现者和维护者的义务，以及应该披露多少信息以及何时进行披露。直截了当地说，披露通常与补丁的可用性同时发生。
- en: In most cases, a vulnerability advisory is published in conjunction with the
    patch. The vulnerability advisory provides some level of technical detail describing
    the nature and severity of the problem that has been patched, but the level of
    detail is usually insufficient to use in developing a working exploit for the
    problem. Why anyone would want to develop a working exploit is another matter.
    Clearly some people are interested in exploiting computers that remain unpatched,
    and the faster an exploit can be developed, the greater their chance of exploiting
    more computers. In other cases, vendors may be interested in developing tools
    that scan for the presence of unpatched systems on networks or in developing techniques
    for real-time detection of exploitation attempts. In most cases, development of
    such tools requires a detailed understanding of the exact nature of the newly
    patched vulnerability.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，漏洞警告信息与补丁一起发布。漏洞警告信息提供了一定程度的技术细节，描述了已修补问题的性质和严重性，但通常这种细节水平不足以用于开发针对该问题的有效利用。为什么有人想要开发有效利用又是一个问题。显然，有些人对利用未修补的计算机感兴趣，并且利用工具开发得越快，他们利用更多计算机的机会就越大。在其他情况下，供应商可能对开发扫描网络或实时检测利用尝试的技术感兴趣。在大多数情况下，开发此类工具需要详细了解新修补漏洞的确切性质。
- en: Advisories may lack such essential information as the exact file or files that
    contain the vulnerability, the name or location of any vulnerable functions, and
    exactly what was changed within those functions. The patched files themselves,
    however, contain all the information that an exploit developer requires in order
    to develop a working exploit for the newly patched vulnerability. This information
    is not immediately obvious, nor is it clearly intended for the consumption of
    an exploit developer. Instead, this information is present in the form of the
    changes that were made in order to eliminate the underlying vulnerability. The
    easiest way to highlight such changes is to compare a patched binary against its
    unpatched counterpart. If we have the luxury of looking for differences in patched
    source files, then standard text-oriented comparison utilities such as `diff`
    can make short work of pinpointing changes. Unfortunately, tracking down behavioral
    changes between two revisions of a binary file is far more complicated than simple
    text file diffing.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 警告信息可能缺少一些关键信息，例如包含漏洞的确切文件或文件名、任何易受攻击函数的名称或位置，以及这些函数内部具体发生了什么变化。然而，修补后的文件本身却包含了漏洞开发者为了开发针对新修补漏洞的有效利用所需的全部信息。这些信息并不立即明显，也不是明确为漏洞开发者准备的。相反，这些信息以消除潜在漏洞所进行的更改的形式存在。突出这些更改的最简单方法是将修补后的二进制文件与其未修补的对应版本进行比较。如果我们有幸能够查找修补源文件中的差异，那么标准基于文本的比较工具，如`diff`，可以轻松地定位更改。不幸的是，追踪二进制文件两个版本之间的行为变化比简单的文本文件比较要复杂得多。
- en: The difficulty with using difference computation to isolate the changes in two
    binaries lies in the fact that binaries can change for several reasons. Changes
    may be triggered by compiler optimizations, changes to the compiler itself, reorganization
    of source code, addition of code unrelated to the vulnerability, and of course
    the code that patches the vulnerability itself. The challenge lies in isolating
    behavioral changes (such as those required to fix the vulnerability) from cosmetic
    changes (such as the use of different registers to accomplish the same task).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 使用差异计算来隔离两个二进制文件中的更改的困难在于，二进制文件可能由于多种原因而发生变化。更改可能是由编译器优化、编译器本身的更改、源代码的重组、添加与漏洞无关的代码，以及当然，修补漏洞本身的代码触发的。挑战在于将行为变化（例如，修复漏洞所需的变化）从外观变化（例如，使用不同的寄存器来完成相同任务）中分离出来。
- en: A number of tools designed specifically for binary diffing are available, including
    the commercial BinDiff from Zynamics;^([[190](#ftn.CHP-22-FN-5)]) the free Binary
    Diffing Suite (BDS) from eEye Digital Security;^([[191](#ftn.CHP-22-FN-6)]) Turbodiff,^([[192](#ftn.CHP-22-FN-7)])
    also free and available from Core Labs (part of Core Security, makers of Core
    Impact^([[193](#ftn.CHP-22-FN-8)])); and PatchDiff2^([[194](#ftn.CHP-22-FN-9)])
    by Nicolas Pouvesle. Each of these tools relies on supplied IDA in one way or
    another. BinDiff and BDS make use of IDA scripts and plug-ins to perform initial
    analysis tasks on both the patched and the unpatched versions of the binaries
    being analyzed. Information extracted by the plug-ins is stored in a backend database,
    and each tool provides a graph-based display and can navigate through the differences
    detected during the analysis phase. Turbodiff and PatchDiff2 are implemented as
    IDA plug-ins and display their results within IDA itself. The ultimate goal of
    these tools is to quickly highlight the changes made to patch a vulnerability
    in order to understand why the code was vulnerable in the first place. Additional
    information on each tool is available on its respective website.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多专门为二进制差异比较设计的工具可用，包括来自 Zynamics 的商业 BinDiff；^([[190](#ftn.CHP-22-FN-5)])
    来自 eEye Digital Security 的免费 Binary Diffing Suite (BDS)；^([[191](#ftn.CHP-22-FN-6)])
    Turbodiff，^([[192](#ftn.CHP-22-FN-7))) 同样免费，由 Core Labs 提供（Core Security 的组成部分，也是
    Core Impact 的制造商^([[193](#ftn.CHP-22-FN-8)])); 以及 Nicolas Pouvesle 的 PatchDiff2^([[194](#ftn.CHP-22-FN-9)]))。这些工具中的每一个都以某种方式依赖于提供的
    IDA。BinDiff 和 BDS 使用 IDA 脚本和插件来对被分析的补丁版本和未补丁版本的二进制文件执行初始分析任务。插件提取的信息存储在后端数据库中，每个工具都提供基于图形的显示，并可以在分析阶段检测到的差异中进行导航。Turbodiff
    和 PatchDiff2 作为 IDA 插件实现，并在 IDA 本身中显示其结果。这些工具的最终目标是快速突出显示修补漏洞所做的更改，以便理解代码最初为何会存在漏洞。有关每个工具的更多信息可在其各自的网站上找到。
- en: Representative of the free diffing tools, PatchDiff2 is an open source project
    offering compiled, 32- and 64-bit Windows versions of the plug-in along with subversion
    access to the plug-in source. Installing the plug-in involves copying the plug-in
    binaries into *<IDADIR>/plugins*.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: PatchDiff2 是免费差异比较工具的代表，是一个开源项目，提供编译后的插件，包括 32 位和 64 位 Windows 版本，以及插件源代码的子版本访问。安装插件涉及将插件二进制文件复制到
    *<IDADIR>/plugins*。
- en: The first step in using PatchDiff2 is to create two separate IDA databases,
    one for each of the two binaries to be compared. Typically one of these databases
    would be created for the original version of the binary, while the other database
    would be created for the patched version of the binary.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PatchDiff2 的第一步是为要比较的两个二进制文件创建两个单独的 IDA 数据库，每个数据库对应一个二进制文件。通常，其中一个数据库会为二进制文件的原版创建，而另一个数据库则会为二进制文件的修补版创建。
- en: '| **Name** | PatchDiff2 |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | PatchDiff2 |'
- en: '| **Author** | Nicolas Pouvesle |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Nicolas Pouvesle |'
- en: '| **Distribution** | Source and binaries for IDA 5.7 |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | IDA 5.7 的源代码和二进制文件 |'
- en: '| **Price** | Free |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | Binary difference generation and display |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 二进制差异生成和显示 |'
- en: '| **Information** | [http://code.google.com/p/patchdiff2/](http://code.google.com/p/patchdiff2/)
    |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://code.google.com/p/patchdiff2/](http://code.google.com/p/patchdiff2/)
    |'
- en: Invoking the plug-in typically involves opening the database for the original
    binary and then activating PatchDiff2 via the Edit ▸ Plugins menu or its associated
    hot key (default is ctrl-8). PatchDiff2 refers to the database from which you
    invoke the plug-in as *IDB1*, or the “first idb.” Upon activation, PatchDiff2
    will ask to open the second database against which the currently open database
    will be compared; this database is known as *IDB2*, or the “second idb.” Once
    a second database has been selected, PatchDiff2 computes a number of identifying
    features for every function in each database including various types of signatures,
    hash values, and CRC values. Utilizing these features, PatchDiff2 creates three
    lists of functions titled *Identical Functions*, *Unmatched Functions*, and *Matched
    Functions*. Each of these lists is displayed in a new tabbed window opened by
    PatchDiff2.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 启用插件通常涉及打开原始二进制文件的数据库，然后通过Edit ▸ Plugins菜单或其关联的热键（默认为ctrl-8）激活PatchDiff2。PatchDiff2将你调用插件的数据库称为
    *IDB1*，或“第一个idb”。激活后，PatchDiff2将要求打开第二个数据库，该数据库将与当前打开的数据库进行比较；这个数据库被称为 *IDB2*，或“第二个idb”。一旦选择了第二个数据库，PatchDiff2将为每个数据库中的每个函数计算一系列识别特征，包括各种类型的签名、哈希值和CRC值。利用这些特征，PatchDiff2创建了三个函数列表，分别称为
    *Identical Functions*、*Unmatched Functions* 和 *Matched Functions*。PatchDiff2在每个新标签页窗口中显示这些列表。
- en: The Identical Functions list contains the list of functions that PatchDiff2
    deems to be identical in both databases. From an analysis point of view, these
    functions are likely to be uninteresting because they contribute nothing to the
    changes that produced the patched version of the binary.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Identical Functions列表包含PatchDiff2认为在两个数据库中都相同的函数列表。从分析的角度来看，这些函数可能不太有趣，因为它们对生成修补版二进制文件的变化没有贡献。
- en: The Unmatched Functions list shows functions from both databases that do not
    appear to be similar to one another according to the metrics applied by PatchDiff2\.
    In practice, these functions have either been added to the patched version, removed
    from the unpatched version, or are too similar to other functions within the same
    binary to be able to distinguish them from corresponding functions in the second
    binary. With careful manual analysis it is often possible to match pairs of functions
    within the Unmatched Functions list. As a general rule of thumb, it is a good
    idea to manually compare the structure of functions that have similar numbers
    of signatures. To facilitate this, it is best to sort the list based on the *sig*
    column so that functions with similar numbers of signatures are listed near one
    another. The first few lines of an unmatched functions list sorted on *sig* are
    shown here.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Unmatched Functions列表显示了两个数据库中看起来彼此不相似的功能，根据PatchDiff2应用的度量标准。在实践中，这些函数可能已被添加到修补版本中，从未修补版本中删除，或者与同一二进制文件中的其他功能太相似，以至于无法将它们与第二个二进制文件中的对应功能区分开来。通过仔细的手动分析，通常可以在Unmatched
    Functions列表中匹配函数对。作为一个一般规则，手动比较具有相似签名数量的函数结构是一个好主意。为了便于这样做，最好根据 *sig* 列对列表进行排序，以便具有相似签名数量的函数列在一起。这里显示了按
    *sig* 排序的未匹配函数列表的前几行。
- en: '[PRE71]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It is clear that the two functions from file one are related to the two functions
    from file two; however, PatchDiff2 is unable to determine how to pair them up.
    It is not uncommon to see multiple functions with identical structures in binaries
    that make use of the C++ *standard template library (STL)*. If you are able to
    manually match a function from one file to its corresponding function in the other
    file, you may use PatchDiff2’s *Set Match* feature (available on the context-sensitive
    menu) to choose one function in the list and match it to a second function in
    the list. [Figure 22-1](ch22s02.html#manually_matching_functions_with_patchdi
    "Figure 22-1. Manually matching functions with PatchDiff2") shows the Set Match
    dialog.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，来自第一个文件的两个函数与来自第二个文件的两个函数是相关的；然而，PatchDiff2无法确定如何将它们配对。在二进制文件中，使用C++ *标准模板库
    (STL)* 的程序中看到具有相同结构的多个函数并不罕见。如果你能够手动将一个文件中的一个函数与其在另一个文件中的对应函数匹配，你可以使用PatchDiff2的
    *Set Match* 功能（可在上下文相关菜单中找到）来选择列表中的一个函数并将其匹配到列表中的第二个函数。[图22-1](ch22s02.html#manually_matching_functions_with_patchdi
    "图22-1. 使用PatchDiff2手动匹配函数")显示了Set Match对话框。
- en: '![Manually matching functions with PatchDiff2](httpatomoreillycomsourcenostarchimages854338.png.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![使用PatchDiff2手动匹配函数](httpatomoreillycomsourcenostarchimages854338.png.jpg)'
- en: Figure 22-1. Manually matching functions with PatchDiff2
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图22-1. 使用PatchDiff2手动匹配函数
- en: Manual matching begins when you choose one function using the Set Match menu
    option. In the resulting dialog, you must enter the address of the matching function
    in the file you are not viewing. The Propagate option asks PatchDiff2 to match
    as many additional functions as it can, given that you have informed it of a new
    match.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 手动匹配开始于您使用“设置匹配”菜单选项选择一个函数。在随后出现的对话框中，您必须在您未查看的文件中输入匹配函数的地址。传播选项要求 PatchDiff2
    匹配尽可能多的其他函数，前提是您已告知它一个新的匹配。
- en: The Matched Functions list contains the list of functions that PatchDiff2 deems
    sufficiently similar, yet not quite identical, according to the metrics applied
    by in the matching process. Right-clicking any entry in this list and selecting
    Display Graphs causes PatchDiff2 to display flow graphs for the two matched functions.
    One such pair of graphs is shown in [Figure 22-2](ch22s02.html#patchdiff2_graphical_function_comparison
    "Figure 22-2. PatchDiff2 graphical function comparison"). PatchDiff2 makes use
    of color coding to highlight blocks that have been introduced into the patched
    version of the binary, making it easy to focus on the changed portions of the
    code.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配函数列表包含 PatchDiff2 根据匹配过程中应用的度量标准认为足够相似但又不完全相同的函数列表。在列表中的任何条目上右键单击并选择显示图形，将导致
    PatchDiff2 显示两个匹配函数的流程图。[图 22-2](ch22s02.html#patchdiff2_graphical_function_comparison
    "图 22-2. PatchDiff2 图形函数比较") 中显示了一对这样的图形。PatchDiff2 使用颜色编码来突出显示已添加到二进制补丁版本中的块，这使得关注代码的更改部分变得容易。
- en: '![PatchDiff2 graphical function comparison](httpatomoreillycomsourcenostarchimages854341.png.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![PatchDiff2 图形函数比较](httpatomoreillycomsourcenostarchimages854341.png.jpg)'
- en: Figure 22-2. PatchDiff2 graphical function comparison
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22-2. PatchDiff2 图形函数比较
- en: In these graphs, blocks ![](httpatomoreillycomsourcenostarchimages854061.png)
    through ![](httpatomoreillycomsourcenostarchimages854095.png) are present in both
    functions, while block ![](httpatomoreillycomsourcenostarchimages854099.png) has
    been added in the patched version of the function. During differential analysis,
    matched functions may be of the highest interest initially because they are likely
    to contain the changes that have been incorporated into the patched binary that
    address vulnerabilities discovered in the original binary. Close study of these
    changes may reveal the corrections that have been made or safety checks that have
    been added in order to address incorrect behavior or exploitable conditions. If
    we fail to find any interesting changes highlighted in the Matched Functions list,
    then the Unmatched Functions list is our only other option for attempting to locate
    the patched code.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些图形中，块 ![](httpatomoreillycomsourcenostarchimages854061.png) 到 ![](httpatomoreillycomsourcenostarchimages854095.png)
    在两个函数中都存在，而块 ![](httpatomoreillycomsourcenostarchimages854099.png) 已添加到函数的补丁版本中。在差异分析期间，匹配函数最初可能最具兴趣，因为它们很可能包含已合并到补丁二进制文件中的更改，这些更改解决了原始二进制文件中发现的漏洞。仔细研究这些更改可能会揭示为解决错误行为或可利用条件而进行的修正或安全检查。如果我们未能找到在匹配函数列表中突出显示的任何有趣更改，那么未匹配函数列表是我们尝试定位补丁代码的唯一其他选项。
- en: '* * *'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[190](#CHP-22-FN-5)]) See [http://www.zynamics.com/bindiff.html](http://www.zynamics.com/bindiff.html).
    Note that in March 2011, Zynamics was acquired by Google.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[190](#CHP-22-FN-5)]) 请参阅 [http://www.zynamics.com/bindiff.html](http://www.zynamics.com/bindiff.html)。请注意，2011年3月，Zynamics
    被谷歌收购。
- en: ^([[191](#CHP-22-FN-6)]) See [http://research.eeye.com/html/tools/RT20060801-1.html](http://research.eeye.com/html/tools/RT20060801-1.html).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[191](#CHP-22-FN-6)]) 请参阅 [http://research.eeye.com/html/tools/RT20060801-1.html](http://research.eeye.com/html/tools/RT20060801-1.html)。
- en: ^([[192](#CHP-22-FN-7)]) See [http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=tool&name=turbodiff](http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=tool&name=turbodiff).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[192](#CHP-22-FN-7)]) 请参阅 [http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=tool&name=turbodiff](http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=tool&name=turbodiff)。
- en: ^([[193](#CHP-22-FN-8)]) See [http://www.coresecurity.com/content/core-impact-overview/](http://www.coresecurity.com/content/core-impact-overview/).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[193](#CHP-22-FN-8)]) 请参阅 [http://www.coresecurity.com/content/core-impact-overview/](http://www.coresecurity.com/content/core-impact-overview/)。
- en: ^([[194](#CHP-22-FN-9)]) See [http://code.google.com/p/patchdiff2](http://code.google.com/p/patchdiff2).
    Note also that Alexander Pick has ported PatchDiff2 to IDA 6.0 for OS X. For more
    information please see [https://github.com/alexander-pick/patchdiff2_ida6](https://github.com/alexander-pick/patchdiff2_ida6).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[194](#CHP-22-FN-9)]) 请参阅 [http://code.google.com/p/patchdiff2](http://code.google.com/p/patchdiff2)。注意，亚历山大·皮克（Alexander
    Pick）已将 PatchDiff2 移植到适用于 OS X 的 IDA 6.0。更多信息请参阅 [https://github.com/alexander-pick/patchdiff2_ida6](https://github.com/alexander-pick/patchdiff2_ida6)。
- en: IDA and the Exploit-Development Process
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA 和漏洞利用开发过程
- en: Assuming that you manage to locate a potentially exploitable vulnerability,
    how can IDA help with the exploit-development process? The answer to this question
    requires that you understand what type of help you need in order for you to make
    use of the appropriate features of IDA.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您设法找到了一个可能可利用的漏洞，IDA 如何帮助漏洞利用开发过程？要回答这个问题，您需要了解您需要什么类型的帮助，以便您能够利用 IDA 的适当功能。
- en: 'IDA is very good at several things that can save you a tremendous amount of
    trial and error when developing exploits:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 在几个方面非常出色，这些方面可以在开发漏洞利用时节省您大量的试错时间：
- en: IDA graphs can be useful in determining control flow paths as a means of understanding
    how a vulnerable function may be reached. Careful selection of graph-generation
    parameters may be required in large binaries in order to minimize the complexity
    of generated graphs. Refer to [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing") for more information on IDA graphs.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDA 图可以用来确定控制流路径，从而理解一个易受攻击的函数是如何被到达的。在大型的二进制文件中，可能需要仔细选择图生成参数，以最小化生成的图的复杂性。有关
    IDA 图的更多信息，请参阅 [第 9 章](ch09.html "第 9 章。交叉引用和绘图")。
- en: IDA breaks down stack frames to a great level of detail. If you are overwriting
    information in the stack, IDA will help you understand exactly what is getting
    overwritten by which portions of your buffer. IDA stack displays are also invaluable
    in determining the memory layout of format string buffers.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDA 将堆栈帧分解到非常详细的程度。如果您正在覆盖堆栈中的信息，IDA 将帮助您了解哪些缓冲区部分覆盖了哪些信息。IDA 堆栈显示在确定格式化字符串缓冲区的内存布局方面也非常宝贵。
- en: IDA has excellent search facilities. If you need to search for a specific instruction
    (such as `jmp esp`) or sequence of instructions (such as `pop/pop/``ret`) within
    a binary, IDA can rapidly tell you whether the instruction(s) is present in the
    binary and, if so, the exact virtual address at which the instruction(s) is located.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDA 具有出色的搜索功能。如果您需要在二进制中搜索特定的指令（如 `jmp esp`）或指令序列（如 `pop/pop/ret`），IDA 可以快速告诉您指令（们）是否存在于二进制中，如果是的话，指令（们）的确切虚拟地址。
- en: The fact that IDA maps binaries as if they are loaded in memory makes it easier
    for you to locate virtual addresses that you may require in order to land your
    exploit. IDA’s disassembly listings make it simple to determine the virtual address
    of any globally allocated buffers as well as useful addresses (such as `GOT` entries)
    to target when you have a write4^([[195](#ftn.CHP-22-FN-10)]) capability.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 IDA 将二进制映射为在内存中加载的样子，这使得您更容易找到您可能需要的虚拟地址，以便实施您的漏洞利用。IDA 的反汇编列表使得确定任何全局分配的缓冲区的虚拟地址以及有用的地址（例如
    `GOT` 条目）变得简单，当您具有写4^([[195](#ftn.CHP-22-FN-10)]) 能力时。
- en: We will discuss several of these capabilities and how you can leverage them
    in the following sections.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下几节中讨论这些功能以及如何利用它们。
- en: Stack Frame Breakdown
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈帧分解
- en: While stack-protection mechanisms are rapidly becoming standard features in
    modern operating systems, many computers continue to run operating systems that
    allow code to be executed in the stack, as is done in a plain-vanilla stack-based
    buffer-overflow attack. Even when stack protections are in place, overflows may
    be used to corrupt stack-based pointer variables, which can be further leveraged
    to complete an attack.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然堆栈保护机制正在迅速成为现代操作系统的标准功能，但许多计算机仍在运行允许代码在堆栈中执行的操作系统，就像在普通的基于堆栈的缓冲区溢出攻击中所做的那样。即使堆栈保护措施已经到位，溢出也可能被用来破坏基于堆栈的指针变量，这可以进一步被利用来完成攻击。
- en: 'Regardless of what you intend to do when you discover a stack-based buffer
    overflow, it is vital to understand exactly what stack content will be overwritten
    as your data overflows the vulnerable stack buffer. You will probably also be
    interested in knowing exactly how many bytes you need to write into the buffer
    until you can control various variables within the function’s stack frame, including
    the function’s saved return address. IDA’s default stack frame displays can answer
    all of these questions if you are willing to do a little math. The distance between
    any two variables in the stack can be computed by subtracting the stack offsets
    of the two variables. The following stack frame includes a buffer that can be
    overflowed when input to the corresponding function is carefully controlled:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在发现基于堆栈的缓冲区溢出时打算做什么，了解当您的数据溢出到易受攻击的堆栈缓冲区时，确切地哪些堆栈内容将被覆盖，这一点至关重要。您可能还想知道确切需要写入多少字节到缓冲区，才能控制函数堆栈帧内的各种变量，包括函数的保存返回地址。如果您愿意做一点数学计算，IDA的默认堆栈帧显示可以回答所有这些问题。堆栈中任意两个变量之间的距离可以通过减去这两个变量的堆栈偏移量来计算。以下堆栈帧包括一个当输入到相应函数时可以仔细控制的缓冲区可以被溢出：
- en: '[PRE72]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The distance from the beginning of the vulnerable buffer (`buffer_132`) to the
    saved return address is 156 bytes (`4 - −98h`, or `4 - −152`). You can also see
    that after 132 bytes (`−14h - −98h`), the contents of `p_buf` will start to get
    overwritten, which may or may not cause problems. You must clearly understand
    the effect of overwriting variables that lie beyond the end of the buffer in order
    to prevent the target application from crashing before the exploit can be triggered.
    In this example, `filedes` (a socket descriptor) might be another problematic
    variable. If the vulnerable function expects to use the socket descriptor after
    you have finished overflowing the buffer, then you need to take care that any
    overwriting of `filedes` will not cause the function to error out unexpectedly.
    One strategy for dealing with variables that will be overwritten is to write values
    into these variables that make sense to the program so that the program continues
    to function normally until your exploit is triggered.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 从易受攻击的缓冲区（`buffer_132`）的起始位置到保存的返回地址的距离是156字节（`4 - −98h`，或者`4 - −152`）。您还可以看到，在132字节（`−14h
    - −98h`）之后，`p_buf`的内容将开始被覆盖，这可能会也可能不会引起问题。为了防止在触发漏洞之前目标应用程序崩溃，您必须清楚地理解覆盖缓冲区末尾之外变量的影响。在这个例子中，`filedes`（一个套接字描述符）可能是一个另一个有问题的变量。如果易受攻击的函数在您完成缓冲区溢出之后期望使用套接字描述符，那么您需要确保任何对`filedes`的覆盖都不会导致函数意外出错。处理将要被覆盖的变量的一个策略是将对程序有意义的值写入这些变量，以便程序在您的漏洞触发之前继续正常工作。
- en: For a slightly more readable breakdown of a stack frame, we can modify the stack
    buffer–scanning code from [Example 22-3](ch22.html#scanning_for_stack-allocated_buffers
    "Example 22-3. Scanning for stack-allocated buffers") to enumerate all members
    of a stack frame, compute their apparent size, and display the distance from each
    member to the saved return address. [Example 22-4](ch22s03.html#enumerating_a_single_stack_frame_using_p
    "Example 22-4. Enumerating a single stack frame using Python") shows the resulting
    script.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使堆栈帧的分解更易于阅读，我们可以修改来自[示例22-3](ch22.html#scanning_for_stack-allocated_buffers
    "示例22-3. 搜索堆栈分配的缓冲区")的堆栈缓冲区扫描代码，以枚举堆栈帧的所有成员，计算它们的明显大小，并显示每个成员到保存返回地址的距离。[示例22-4](ch22s03.html#enumerating_a_single_stack_frame_using_p
    "示例22-4. 使用Python枚举单个堆栈帧")显示了生成的脚本。
- en: Example 22-4. Enumerating a single stack frame using Python
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 示例22-4. 使用Python枚举单个堆栈帧
- en: '[PRE73]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This script introduces the `GetFrameLvarSize` and `GetFrameRegsSize` functions
    (also available in IDC). These functions are used to retrieve the size of a stack
    frame’s local variable and saved register areas, respectively. The saved return
    address lies directly beneath these two areas, and the offset to the saved return
    address is computed as the sum of these two values ![](httpatomoreillycomsourcenostarchimages854061.png).
    When executed against our example function, the script produces the following
    output:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本介绍了`GetFrameLvarSize`和`GetFrameRegsSize`函数（也可在IDC中找到）。这些函数分别用于检索堆栈帧局部变量和保存寄存器区域的大小。保存的返回地址直接位于这两个区域下方，保存返回地址的偏移量是通过这两个值的总和计算得出的
    ![图片链接](httpatomoreillycomsourcenostarchimages854061.png)。当针对我们的示例函数执行脚本时，它会产生以下输出：
- en: '[PRE74]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The results offer a concise summary of a function’s stack frame annotated with
    additional information of potential use to an exploit developer.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果提供了一个关于函数堆栈帧的简洁总结，并附有对漏洞开发者可能有用的附加信息。
- en: IDA’s stack frame displays also prove useful when developing exploits for format
    string vulnerabilities. As an example, consider the following short code fragment
    in which the `fprintf` function is invoked with a user-supplied buffer provided
    as the format string.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的堆栈帧显示在开发针对格式字符串漏洞的漏洞利用时也非常有用。例如，考虑以下简短的代码片段，其中调用了 `fprintf` 函数，并使用用户提供的缓冲区作为格式字符串。
- en: '[PRE75]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this example, only two arguments are passed to `fprintf`, a file pointer
    ![](httpatomoreillycomsourcenostarchimages854061.png) and the address of the user’s
    buffer as a format string ![](httpatomoreillycomsourcenostarchimages854063.png).
    These arguments occupy the top two positions on the stack, memory that has already
    been allocated by the calling function as part of the function’s prologue. The
    stack frame for the vulnerable function is shown in [Example 22-5](ch22s03.html#stack_frame_for_format_string_example
    "Example 22-5. Stack frame for format string example").
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只向 `fprintf` 传递了两个参数，一个文件指针 ![http://atomoreilly.com/source/no_starch_images/854061.png]
    和用户缓冲区的地址作为格式字符串 ![http://atomoreilly.com/source/no_starch_images/854063.png]。这些参数占据了堆栈上的前两个位置，这是调用函数作为函数序言的一部分已经分配的内存。漏洞函数的堆栈帧显示在
    [示例 22-5](ch22s03.html#stack_frame_for_format_string_example "示例 22-5. 格式字符串示例的堆栈帧")
    中。
- en: Example 22-5. Stack frame for format string example
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 22-5. 格式字符串示例的堆栈帧
- en: '[PRE76]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The 16 undefined bytes spanning frame offsets `128h` through `119h` represent
    the block of memory that the compiler (gcc in this case) has preallocated for
    the arguments passed in to the functions that will be called by the vulnerable
    function. The `stream` argument to `fprintf` will be placed at the top of the
    stack ![](httpatomoreillycomsourcenostarchimages854061.png), while the format
    string pointer will be placed immediately below ![](httpatomoreillycomsourcenostarchimages854063.png)
    the `stream` argument.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 从帧偏移 `128h` 到 `119h` 的 16 个未定义字节代表了编译器（在本例中为 gcc）为传递给将被漏洞函数调用的函数的参数预分配的内存块。`stream`
    参数将放置在堆栈的顶部 ![http://atomoreilly.com/source/no_starch_images/854061.png]，而格式字符串指针将放置在
    `stream` 参数的下方 ![http://atomoreilly.com/source/no_starch_images/854063.png]。
- en: In format string exploits, an attacker is often interested in the distance from
    the format string pointer to the beginning of the buffer holding the attacker’s
    input. In the preceding stack frame, 16 bytes separate the format string argument
    from the actual format string buffer. To further the discussion, we will assume
    that an attacker has entered the following format string.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式字符串漏洞利用中，攻击者通常对格式字符串指针到包含攻击者输入的缓冲区开始的距离感兴趣。在前面的堆栈帧中，16 个字节将格式字符串参数与实际的格式字符串缓冲区分隔开来。为了进一步讨论，我们将假设攻击者输入了以下格式字符串。
- en: '[PRE77]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, `fprintf` would expect five arguments immediately following the format
    string argument. The first four of these arguments would occupy the space between
    the format string argument and the format string buffer. The fifth, and final,
    of these arguments would overlap the first four bytes of the format string buffer
    itself. Readers familiar with format string exploits^([[196](#ftn.CHP-22-FN-11)])
    will know that arguments within a format string may be named explicitly by index
    number. The following format string demonstrates accessing the fifth argument
    following the format string in order to format it as a hexadecimal value.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fprintf` 函数期望在格式字符串参数之后立即有五个参数。这四个参数将占据格式字符串参数和格式字符串缓冲区之间的空间。最后一个，也是第五个参数将覆盖格式字符串缓冲区的第一个四个字节。熟悉格式字符串漏洞的读者会知道，格式字符串内的参数可以通过索引号明确命名。以下格式字符串示例展示了如何访问格式字符串之后的第五个参数，以便将其格式化为十六进制值。
- en: '[PRE78]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Continuing with the preceding example, this format string would read the first
    4 bytes of the format string buffer as an integer (which we previously noted would
    occupy the space of the fifth argument to the format string should one have been
    required), format that integer as a hexadecimal value, and then output the result
    to the specified file stream. Additional arguments to the format string (the sixth,
    seventh, and so on) would overlap successive 4-byte blocks within the format string
    buffer.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个示例，这个格式字符串将读取格式字符串缓冲区的第一个4个字节作为整数（我们之前提到，如果需要，它将占据格式字符串第五个参数的空间），然后将该整数格式化为十六进制值，并将结果输出到指定的文件流。格式字符串的附加参数（第六个、第七个等）将重叠格式字符串缓冲区内的连续4字节块。
- en: Crafting a format string that will work properly to exploit a vulnerable binary
    can be tricky and generally relies on precise specification of arguments within
    the format string. The preceding discussion demonstrates that, in many cases,
    IDA may be used to quickly and accurately compute required offsets into a format
    string buffer. By combining this information with information that IDA presents
    when disassembling various program sections, such as the global offset table (*.got*)
    or the destructor table (*.dtor*), a correct format string may be derived accurately
    with no trial and error as might be required when using only a debugger to develop
    an exploit.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个能够正确利用易受攻击的二进制文件的格式字符串可能很棘手，通常依赖于对格式字符串中参数的精确指定。前面的讨论表明，在许多情况下，IDA可以快速准确地计算格式字符串缓冲区中所需的偏移量。通过结合IDA在反汇编各种程序部分时提供的信息，例如全局偏移表
    (*.got*) 或析构函数表 (*.dtor*)，可以准确地推导出正确的格式字符串，而无需像仅使用调试器开发漏洞利用时那样进行试错。
- en: Locating Instruction Sequences
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位指令序列
- en: In order to reliably land an exploit, it is often useful to employ a control-transfer
    mechanism that does not require you to know the exact memory address at which
    your shellcode resides. This is particularly true when your shellcode lies in
    the heap or the stack, which may make the address of your shellcode unpredictable.
    In such cases, it is desirable to find a register that happens to point at your
    shellcode at the time your exploit is triggered. For example, if the ESI register
    is known to point at your shellcode at the moment you take control of the instruction
    pointer, it would be very helpful if the instruction pointer happened to point
    to a `jmp esi` or `call esi` instruction, which would vector execution to your
    shellcode without requiring you to know the exact address of your shellcode. Similarly
    a `jmp esp` is often a very handy way to transfer control to shellcode that you
    have placed in the stack. This takes advantage of the fact that when a function
    containing a vulnerable buffer returns, the stack pointer will be left pointing
    just below the same saved return address that you just overwrote. If you continued
    to overwrite the stack beyond the saved return address, then the stack pointer
    is pointing at your data (which should be code!). The combination of a register
    pointing at your shellcode along with an instruction sequence that redirects execution
    by jumping to or calling the location pointed to by that register is called a
    *trampoline*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可靠地实现漏洞利用，通常很有用采用一种控制传输机制，该机制不需要你知道你的shellcode所在的精确内存地址。这在你将shellcode放置在堆或栈中时尤其正确，这可能会使你的shellcode的地址不可预测。在这种情况下，找到在漏洞利用触发时恰好指向你的shellcode的寄存器是可取的。例如，如果ESI寄存器在控制指令指针的瞬间已知指向你的shellcode，那么如果指令指针恰好指向一个`jmp
    esi`或`call esi`指令，这将非常有帮助，因为它会将执行流程引导到你的shellcode，而无需你知道shellcode的确切地址。同样，`jmp
    esp`通常是将控制权转移到你放在栈中的shellcode的非常方便的方法。这利用了这样一个事实：当包含易受攻击缓冲区的函数返回时，栈指针将指向刚刚覆盖的相同保存的返回地址下方。如果你继续覆盖栈，超过保存的返回地址，那么栈指针将指向你的数据（应该是代码！）。一个指向你的shellcode的寄存器与一个通过跳转到或调用该寄存器指向的位置来重定向执行指令序列的组合被称为*跳板*。
- en: The notion of searching for such instruction sequences is not a new one. In
    Appendix D of his paper “Variations in Exploit Methods between Linux and Windows,”^([[197](#ftn.CHP-22-FN-12)])
    David Litchfield presents a program named *getopcode.c* designed to search for
    useful instructions in Linux ELF binaries. Along similar lines, the Metasploit^([[198](#ftn.CHP-22-FN-13)])
    project offers its `msfpescan` tool, which is capable of scanning Windows PE binaries
    for useful instruction sequences. IDA is just as capable of locating interesting
    instruction sequences as either of these tools when given the chance.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找此类指令序列的概念并非新事物。在论文“Linux和Windows之间漏洞利用方法的变化”的附录D中，David Litchfield提出了一个名为
    *getopcode.c* 的程序，用于在Linux ELF二进制文件中搜索有用的指令。沿着类似的思路，Metasploit^([[198](#ftn.CHP-22-FN-13)])
    项目提供了其 `msfpescan` 工具，该工具能够扫描Windows PE二进制文件中的有用指令序列。如果有机会，IDA与这些工具一样能够定位有趣的指令序列。
- en: 'For the sake of example, assume that you would like to locate a `jmp esp` instruction
    in a particular x86 binary. You could use IDA’s text-search features to look for
    the string `jmp esp`, which you would only find if you happened to have exactly
    the right number of spaces between *jmp* and *esp* and which you are unlikely
    to find in any case because a jump into the stack is seldom used by any compiler.
    So why bother searching in the first place? The answer lies in the fact that what
    you are actually interested in is not an occurrence of the disassembled text `jmp
    esp` but rather the byte sequence `FF E4`, regardless of its location. For example,
    the following instruction contains an embedded `jmp esp`:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，假设你想要在特定的x86二进制文件中定位一个 `jmp esp` 指令。你可以使用IDA的文本搜索功能来查找字符串 `jmp esp`，你只有在恰好有正确数量的空格在
    *jmp* 和 *esp* 之间时才会找到它，而且你不太可能在任何情况下找到它，因为任何编译器很少使用跳入堆栈的操作。那么为什么还要搜索呢？答案在于，你真正感兴趣的不是反汇编文本
    `jmp esp` 的出现，而是无论其位置如何的字节序列 `FF E4`。例如，以下指令包含一个嵌入的 `jmp esp`：
- en: '[PRE79]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Virtual address `080486CFh` may be used if a `jmp esp` is desired. IDA’s binary
    search (Search ▸ Sequence of Bytes) capability is the correct way to rapidly locate
    byte sequences such as these. When performing a binary search for exact matches
    against a known byte sequence, remember to perform a case-sensitive search, or
    a byte sequence such as `50 C3` (`push eax/ret`) will be matched by the byte sequence
    `70 C3` (because 50h is an uppercase *P*, while 70h is a lowercase *p*), which
    is a jump on overflow with a relative offset of –61 bytes. Binary searches can
    be scripted using the `FindBinary` function, as shown here:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要 `jmp esp`，则可以使用虚拟地址 `080486CFh`。IDA的二进制搜索（搜索 ▸ 字节序列）功能是快速定位此类字节序列的正确方法。当执行针对已知字节序列的精确匹配的二进制搜索时，请记住执行区分大小写的搜索，否则像
    `50 C3` (`push eax/ret`) 这样的字节序列将被字节序列 `70 C3`（因为50h是大写的 *P*，而70h是小写的 *p*）匹配，这是一个带有-61字节相对偏移量的溢出跳转。可以使用
    `FindBinary` 函数编写脚本进行二进制搜索，如下所示：
- en: '[PRE80]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This function call begins searching down (toward higher addresses) from the
    lowest virtual address in the database, in a case-sensitive manner, in search
    of a `jmp esp` (`FF E4`). If sequence is found, the return value is the virtual
    address of the start of the byte sequence. If the sequence is not found, the return
    value is BADADDR (−1). A script that automates searches for a wider variety of
    instructions is available on the book’s website. Using this script, we might request
    a search for instructions that transfer control to the location pointed to by
    the EDX register and receive results similar to the following:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用从数据库中的最低虚拟地址开始向下（向高地址）搜索，以区分大小写的方式，寻找 `jmp esp` (`FF E4`)。如果找到序列，返回值是字节序列开始的虚拟地址。如果没有找到序列，返回值是BADADDR（-1）。在本书的网站上有一个自动化搜索更广泛指令种类的脚本。使用此脚本，我们可能请求搜索将控制权转移到由EDX寄存器指向的位置的指令，并得到以下类似的结果：
- en: '[PRE81]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Convenience scripts such as these can save a substantial amount of time while
    ensuring that we don’t forget to cover all possible cases as we search for items
    in a database.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的便捷脚本可以在确保我们在数据库中搜索项目时不会忘记涵盖所有可能的案例的同时，节省大量时间。
- en: Finding Useful Virtual Addresses
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找有用的虚拟地址
- en: The last item we will mention briefly is IDA’s display of virtual addresses
    in its disassemblies. Situations in which we know that our shellcode is going
    to end up in a static buffer (in a `.data` or `.bss` section, for example) are
    almost always better than situations in which our shellcode lands in the heap
    or the stack, because we end up with a known, fixed address to which we can transfer
    control. This usually eliminates the need for NOP slides or the need to find special
    instruction sequences.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要提到的最后一项是IDA在其反汇编中显示虚拟地址。我们知道我们的shellcode最终将出现在静态缓冲区（例如`.data`或`.bss`部分）的情况几乎总是比我们的shellcode落在堆或栈上的情况更好，因为我们最终得到一个已知的、固定的地址，我们可以将其控制权转移。这通常消除了需要NOP滑动或找到特殊指令序列的需要。
- en: NOP SLIDES
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: NOP滑动
- en: A *NOP* slide is a long sequence of consecutive nop (do nothing) instructions
    that provides a wider target for hitting our shellcode when the address of our
    shellcode is known to be somewhat variable. Rather than targeting the first useful
    instruction of our shellcode, we target the middle of the NOP slide. If the NOP
    slide (and hence the rest of our payload) shifts slightly up or down in memory,
    we still have a good chance of landing somewhere within the slide and successfully
    running into our shellcode. For example, if we have room for 500 NOPs as a prefix
    for our shellcode, we can target the middle of the slide and still hit the slide
    as long as the address that we guess for the middle of the slide is within 250
    bytes of the actual address.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '*NOP*滑动是一个由连续的nop（什么都不做）指令组成的序列，当我们的shellcode地址已知且有些可变时，提供了一个更宽的目标来命中我们的shellcode。我们不是针对我们的shellcode的第一个有用指令进行定位，而是针对NOP滑动的中间部分。如果NOP滑动（以及因此我们的有效负载的其余部分）在内存中稍微向上或向下移动，我们仍然有很大的机会落在滑动内并成功运行到我们的shellcode。例如，如果我们有500个NOP作为shellcode的前缀空间，我们可以针对滑动的中间部分，只要我们猜测的滑动中间地址在实际地址的250字节范围内。'
- en: Some exploits take advantage of the fact that attackers are able to write any
    data they like to any location they choose. In many cases, this may be restricted
    to a 4-byte overwrite, but this amount often turns out to be sufficient. When
    a 4-byte overwrite is possible, one alternative is to overwrite a function pointer
    with the address of our shellcode. The dynamic linking process used in most ELF
    binaries utilizes a table of function pointers called the *global offset table
    (GOT)* to store addresses of dynamically linked library functions. When one of
    these table entries can be overwritten, it is possible to hijack a function call
    and redirect the call to a location of the attacker’s choosing. A typical sequence
    of events for an attacker in such cases is to stage shellcode in a known location
    and then overwrite the GOT entry for the next library function to be called by
    the exploited program. When the library function is called, control is instead
    transferred to the attacker’s shellcode.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 一些攻击利用了攻击者能够将任何他们喜欢的数据写入他们选择的任何位置的事实。在许多情况下，这可能会限制为4字节覆盖，但这个数量通常证明是足够的。当可能进行4字节覆盖时，一个替代方案是将函数指针覆盖为我们shellcode的地址。大多数ELF二进制文件中使用的动态链接过程利用一个称为*全局偏移表（GOT）*的函数指针表来存储动态链接库函数的地址。当这些表中的一个条目可以被覆盖时，就可以劫持一个函数调用并将调用重定向到攻击者选择的位置。在这种情况下，攻击者的典型事件序列是在已知位置放置shellcode，然后覆盖将被利用程序调用的下一个库函数的GOT条目。当库函数被调用时，控制权将转移到攻击者的shellcode。
- en: 'The addresses of GOT entries are easily found in IDA by scrolling to the `got`
    section and browsing for the function whose entry you wish to overwrite. In the
    name of automating as much as possible, though, the following Python script quickly
    reports the address of the GOT entry that will be used by a given function call:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA中，通过滚动到`got`部分并浏览你希望覆盖的条目的函数，可以轻松找到GOT条目的地址。然而，为了尽可能自动化，以下Python脚本会快速报告给定函数调用将使用的GOT条目地址：
- en: '[PRE82]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This script is executed by placing the cursor on any call to a library function,
    such as the following, and invoking the script.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本通过将光标放在对库函数的任何调用上，例如以下调用，并调用脚本来执行。
- en: '[PRE83]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The script operates by walking forward through cross-references until the GOT
    is reached. The first cross-reference that is retrieved ![](httpatomoreillycomsourcenostarchimages854061.png)
    is tested to ensure that it is a call reference and that it references the ELF
    procedure linkage table (`.plt`). PLT entries contain code that reads a GOT entry
    and transfers control to the address specified in the GOT entry. The second cross-reference
    retrieved ![](httpatomoreillycomsourcenostarchimages854063.png) obtains the address
    of the location being read from the PLT, and this is the address of the associated
    GOT entry. When executed on the preceding call to `_memset`, the output of the
    script on our example binary yields the following:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过遍历交叉引用直到到达 GOT 来操作。检索到的第一个交叉引用 ![](httpatomoreillycomsourcenostarchimages854061.png)
    被测试以确保它是一个调用引用，并且它引用了 ELF 程序链接表 (`.plt`)。PLT 条目包含读取 GOT 条目并将控制权转移到 GOT 条目中指定的地址的代码。检索到的第二个交叉引用
    ![](httpatomoreillycomsourcenostarchimages854063.png) 获取正在从 PLT 读取的位置的地址，这就是相关
    GOT 条目的地址。在先前的 `_memset` 调用上执行时，脚本在我们示例二进制文件上的输出如下：
- en: '[PRE84]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This output provides us with exactly the information we require if our intention
    is to take control of the program by hijacking a call to `memset`, namely that
    we need to overwrite the contents of address `0x080618d8` with the address of
    our shellcode.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目的是通过劫持对 `memset` 的调用来控制程序，那么这个输出为我们提供了所需的确切信息，即我们需要覆盖地址 `0x080618d8` 的内容，将其替换为我们的
    shellcode 地址。
- en: '* * *'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[195](#CHP-22-FN-10)]) A *write4* capability presents an attacker with the
    opportunity to write 4 bytes of his choosing to a memory location of his choosing.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[195](#CHP-22-FN-10)]) *write4* 功能为攻击者提供了将 4 个字节写入其选择的内存位置的机会。
- en: '^([[196](#CHP-22-FN-11)]) Readers wishing to learn more about format string
    exploits might again refer to Jon Erickson’s *Hacking: The Art of Exploitation,
    2nd Edition*.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[196](#CHP-22-FN-11)]) 想要了解更多关于格式字符串漏洞利用的读者可以再次参考 Jon Erickson 的 *《黑客：利用的艺术，第2版》*。
- en: ^([[197](#CHP-22-FN-12)]) See [http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx](http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[197](#CHP-22-FN-12)]) 请参阅 [http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx](http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx)。
- en: ^([[198](#CHP-22-FN-13)]) See [http://www.metasploit.com/](http://www.metasploit.com/).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[198](#CHP-22-FN-13)]) 请参阅 [http://www.metasploit.com/](http://www.metasploit.com/)。
- en: Analyzing Shellcode
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Shellcode
- en: Up to this point, this chapter has focused on the use of IDA as an offensive
    tool. Before we conclude, it might be nice to offer up at least one use for IDA
    as a defensive tool. As with any other binary code, there is only one way to determine
    what shellcode does, and that is to disassemble it. Of course, the first requirement
    is to get your hands on some shellcode. If you are the curious type and have always
    wondered how Metasploit payloads work, you might simply use Metasploit to generate
    a payload in raw form and then disassemble the resulting blob.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章主要关注 IDA 作为攻击工具的使用。在我们结束之前，提出 IDA 作为防御工具至少一种用途可能是个不错的想法。与任何其他二进制代码一样，确定
    shellcode 的唯一方法是对其进行反汇编。当然，首先的要求是获取一些 shellcode。如果你是好奇的类型，并且一直想知道 Metasploit 负载是如何工作的，你可以简单地使用
    Metasploit 生成原始形式的负载，然后对生成的 blob 进行反汇编。
- en: 'The following Metasploit command generates a payload that calls back to port
    4444 on the attacker’s computer and grants the attacker a shell on the target
    Windows computer:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Metasploit 命令生成一个负载，该负载将回连到攻击者的计算机上的 4444 端口，并在目标 Windows 计算机上为攻击者提供一个 shell：
- en: '[PRE85]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The resulting file contains the requested payload in its raw binary form. The
    file can be opened in IDA (in binary form since it has no specific format) and
    a disassembly obtained by converting the displayed bytes into code.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件包含请求的原始二进制形式的负载。该文件可以在 IDA 中打开（以二进制形式打开，因为它没有特定的格式），并通过将显示的字节转换为代码来获得反汇编。
- en: 'Another place that shellcode can turn up is in network packet captures. Narrowing
    down exactly which packets contain shellcode can be a challenge, and you are invited
    to check out any of the vast number of books on network security that will be
    happy to tell you just how to find all those nasty packets. For now consider the
    reassembled client stream of an attack observed on the Capture the Flag network
    at DEFCON 18:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode还可能出现在网络数据包捕获中。缩小确切哪些数据包包含shellcode可能是一个挑战，欢迎您查阅大量关于网络安全方面的书籍，这些书籍将很高兴告诉您如何找到所有那些讨厌的数据包。现在，考虑在DEFCON
    18网络捕获中观察到的攻击的重新组装客户端流：
- en: '[PRE86]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This dump clearly contains a mix of ASCII and binary data, and based on other
    data associated with this particular network connection, the binary data is assumed
    to be shellcode. Packet-analysis tools such as Wireshark^([[199](#ftn.CHP-22-FN-14)])
    often possess the capability to extract TCP session content directly to a file.
    In the case of Wireshark, once you find a TCP session of interest, you can use
    the `Follow TCP Stream` command and then save the raw stream content to a file.
    The resulting file can then be loaded into IDA (using IDA’s binary loader) and
    analyzed further. Often network attack sessions contain a mix of shellcode and
    application layer content. In order to properly disassemble the shellcode, you
    must correctly locate the first bytes of the attacker’s payload. The level of
    difficulty in doing this will vary from one attack to the next and one protocol
    to the next. In some cases, long NOP slides will be obvious (long sequences of
    `0x90` for x86 attacks), while in other cases (such as the current example), locating
    the NOPs, and therefore the shellcode, may be less obvious. The preceding hex
    dump, for example, actually contains a NOP slide; however, instead of actual x86
    NOPs, a randomly generated sequence of 1-byte instructions that have no effect
    on the shell code to follow is used. Since an infinite number of permutations
    exist for such a NOP slide, the danger that a network intrusion detection system
    will recognize and alert on the NOP slide is diminished. Finally, some knowledge
    of the application that is being attacked may help in distinguishing data elements
    meant for consumption by the application from shellcode meant to be executed.
    In this case, with a little effort, IDA disassembles the preceding binary content
    as shown here:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包明显包含ASCII和二进制数据的混合，并且根据与这个特定网络连接相关的其他数据，可以假设二进制数据是shellcode。像Wireshark^([[199](#ftn.CHP-22-FN-14)])这样的数据包分析工具通常具有直接将TCP会话内容提取到文件的能力。在Wireshark的情况下，一旦找到感兴趣的TCP会话，可以使用`Follow
    TCP Stream`命令，然后将原始流内容保存到文件中。生成的文件可以随后加载到IDA（使用IDA的二进制加载器）中，进行进一步分析。通常，网络攻击会话包含shellcode和应用层内容的混合。为了正确反汇编shellcode，必须正确定位攻击者有效载荷的第一字节。完成这一任务的难度会因攻击和协议的不同而有所不同。在某些情况下，长的NOP滑块会很明显（对于x86攻击，是长序列的`0x90`），而在其他情况下（例如当前示例），定位NOP以及因此shellcode可能不那么明显。例如，前面的十六进制转储实际上包含一个NOP滑块；然而，它使用的是随机生成的1字节指令序列，这些指令对后续的shellcode没有影响。由于这样的NOP滑块存在无限多种排列组合，网络入侵检测系统识别并对此发出警报的危险性降低。最后，对正在被攻击的应用程序的一些了解可能有助于区分旨在由应用程序消费的数据元素和旨在执行的shellcode。在这种情况下，经过一点努力，IDA将前面的二进制内容反汇编成如下所示：
- en: '[PRE87]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: One point worth noting is that the first 8 bytes of the stream ![](httpatomoreillycomsourcenostarchimages854061.png)
    are actually protocol data, not shellcode, and thus we have chosen not to disassemble
    them. Also, IDA seems to have misidentified the system calls that are being made
    at ![](httpatomoreillycomsourcenostarchimages854063.png) and ![](httpatomoreillycomsourcenostarchimages854093.png).
    We have omitted the fact that this exploit was targeting a FreeBSD application,
    which would be helpful in decoding the system call numbers being used in the payload.
    Because IDA is only capable of annotating Linux system call numbers, we are left
    to do a little research to learn that FreeBSD system call `29` (`1dh`) is actually
    `recvfrom` (rather than `pause`) and system call `90` (`5Ah`) is actually the
    `dup2` function (rather than `old_mmap`).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，流的前8个字节![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)实际上是协议数据，而不是shellcode，因此我们选择不对其进行反汇编。此外，IDA似乎在![httpatomoreillycomsourcenostarchimages854063.png](httpatomoreillycomsourcenostarchimages854063.png)和![httpatomoreillycomsourcenostarchimages854093.png](httpatomoreillycomsourcenostarchimages854093.png)处识别的系统调用有误。我们省略了这一事实，即这个漏洞利用目标是针对FreeBSD应用程序的，这有助于解码有效载荷中使用的系统调用编号。由于IDA只能注释Linux的系统调用编号，我们不得不进行一些研究来了解FreeBSD的系统调用`29`（`1dh`）实际上是`recvfrom`（而不是`pause`），系统调用`90`（`5Ah`）实际上是`dup2`函数（而不是`old_mmap`）。
- en: Because it lacks any header information useful to IDA, shellcode will generally
    require extra attention in order to be properly disassembled. In addition, shellcode
    encoders are frequently employed as a means of evading intrusion detection systems.
    Such encoders have an effect very much like the effect that obfuscation tools
    have on standard binaries, further complicating the shellcode-disassembly process.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它缺少IDA有用的任何头部信息，shellcode通常需要额外的关注才能正确反汇编。此外，shellcode编码器经常被用作绕过入侵检测系统的手段。这样的编码器产生的效果与混淆工具对标准二进制文件的效果非常相似，进一步复杂化了shellcode反汇编的过程。
- en: '* * *'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[199](#CHP-22-FN-14)]) See [http://www.wireshark.org/](http://www.wireshark.org/).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[199](#CHP-22-FN-14)]) 查看 [http://www.wireshark.org/](http://www.wireshark.org/).
- en: Summary
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Keep in mind that IDA is not a silver bullet you can use to make vulnerabilities
    pop out of binaries. If your ultimate goal is to perform vulnerability analysis
    using only IDA, then you would be wise to automate your efforts to the maximum
    extent possible. As you develop algorithms for analyzing binaries, you should
    always consider how you might automate those algorithms in order to save time
    on future analysis tasks. Finally, it is important to understand that no amount
    of reading through the best books available can make you proficient at vulnerability
    analysis and exploit development. If you are interested in developing your skills,
    you must practice. A large number of sites offer practice challenges for just
    this purpose; an excellent starting point is the Wargames section at [http://www.overthewire.org/wargames/](http://www.overthewire.org/wargames/).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，IDA并不是一个能够让你从二进制文件中直接发现漏洞的万能工具。如果你的最终目标是仅使用IDA进行漏洞分析，那么最大限度地自动化你的工作将是明智之举。在开发分析二进制文件的算法时，你应该始终考虑如何自动化这些算法，以便在未来的分析任务中节省时间。最后，重要的是要理解，阅读所有最好的书籍并不能让你在漏洞分析和漏洞利用开发方面变得精通。如果你有兴趣提高你的技能，你必须进行实践。许多网站提供针对这一目的的练习挑战；一个很好的起点是[http://www.overthewire.org/wargames/](http://www.overthewire.org/wargames/)上的Wargames部分。
- en: Chapter 23. Real-World IDA Plug-ins
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第23章。现实世界的IDA插件
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: Given the variety of uses that IDA has been put to over the years, it should
    not be surprising that a large number of plug-ins have been developed to add capabilities
    that people have found useful in their particular applications of IDA. If you
    decide that you would like to take advantage of other people’s work, know that
    there is no one-stop shop for publicly available plug-ins. The three principal
    locations where you may find references to plug-ins are the Hex-Rays download
    page,^([[200](#ftn.CHP-23-FN-1)]) the OpenRCE downloads page,^([[201](#ftn.CHP-23-FN-2)])
    and the RCE reverse engineering forums.^([[202](#ftn.CHP-23-FN-3)]) Of course,
    spending a little time with Google doesn’t hurt either.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IDA多年来被用于各种用途，因此不会令人惊讶的是，已经开发了大量插件来添加人们在其特定IDA应用中找到的有用功能。如果你决定想利用他人的工作，要知道没有一家商店可以提供所有公开可用的插件。你可能找到插件参考的三个主要位置是Hex-Rays下载页面^([[200](#ftn.CHP-23-FN-1)]),
    OpenRCE下载页面^([[201](#ftn.CHP-23-FN-2)]), 和RCE逆向工程论坛^([[202](#ftn.CHP-23-FN-3)]）。当然，花点时间使用Google也不会有害。
- en: As with any other piece of publicly available software, you may face some challenges
    while attempting to install third-party plug-ins. In cases where plug-in developers
    have elected to publish their efforts, plug-ins are distributed in the form of
    source code, a compiled binary, or both. If forced to build from source, you must
    deal with the make files (or equivalents) supplied by the plug-in’s author, which
    may or may not work with your particular compiler configuration. On the other
    hand, if a plug-in is distributed in binary form, it may have been built with
    a version of the SDK that is incompatible with your version of IDA, which means
    you will not be able to run the plug-in at all until the author elects to release
    an updated version. Finally, the plug-in may have external dependencies that must
    be satisfied in order to build it, run it, or both.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他公开可用的软件一样，在尝试安装第三方插件时，你可能会遇到一些挑战。在插件开发者选择发布他们的努力的情况下，插件以源代码、编译的二进制文件或两者兼有的形式分发。如果被迫从源代码构建，你必须处理插件作者提供的make文件（或等效文件），这些文件可能与你的特定编译器配置不兼容。另一方面，如果插件以二进制形式分发，它可能使用了与你的IDA版本不兼容的SDK版本，这意味着你将无法运行该插件，直到作者选择发布更新版本。最后，插件可能具有外部依赖项，这些依赖项必须满足才能构建、运行或两者兼而有之。
- en: In this chapter we will review several popular IDA plug-ins; their purpose;
    where to obtain them; and how to build, install, and use them.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾几个流行的IDA插件；它们的目的；如何获取它们；以及如何构建、安装和使用它们。
- en: Hex-Rays
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hex-Rays
- en: Perhaps the granddaddy of all IDA plug-ins, Hex-Rays is a decompiler plug-in
    capable of generating “C-like pseudocode”^([[203](#ftn.CHP-23-FN-4)]) for functions
    in compiled ARM or 32-bit x86 binaries. Hex-Rays is a commercial plug-in created
    and sold by the same company that produces IDA. The decompiler is available for
    all 32-bit versions of IDA. Hex-Rays is shipped in binary form only, and installation
    is performed by copying the supplied plug-in into *<IDADIR>/plugins*. A manual
    for using Hex-Rays is available online^([[204](#ftn.CHP-23-FN-5)]) that provides
    a nice overview of using Hex-Rays and that contains some documentation for the
    Hex-Rays SDK^([[205](#ftn.CHP-23-FN-6)]) used to create decompiler plug-ins.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 或许是所有IDA插件中的“老大哥”，Hex-Rays是一个能够为编译的ARM或32位x86二进制文件中的函数生成“类似C的伪代码”^([[203](#ftn.CHP-23-FN-4)])的反汇编插件。Hex-Rays是由生产IDA的同一公司创建和销售的商业插件。反汇编器适用于IDA的所有32位版本。Hex-Rays仅以二进制形式提供，安装是通过将提供的插件复制到*<IDADIR>/plugins*目录来完成的。在线上可提供Hex-Rays的使用手册^([[204](#ftn.CHP-23-FN-5)]),
    该手册提供了使用Hex-Rays的精彩概述，并包含用于创建反汇编插件的Hex-Rays SDK^([[205](#ftn.CHP-23-FN-6)])的一些文档。
- en: Once installed, the decompiler is activated via View ▸ Open Subviews ▸ Pseudocode
    (hotkey F5) to decompile the function containing the cursor or via File ▸ Produce
    File ▸ Create C File (hotkey ctrl-F5) to decompile all functions in the database
    and save them to a file.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以通过View ▸ Open Subviews ▸ Pseudocode（快捷键F5）激活反汇编器来反汇编包含光标的函数，或者通过File
    ▸ Produce File ▸ Create C File（快捷键ctrl-F5）来反汇编数据库中的所有函数并将它们保存到文件中。
- en: When you generate pseudocode for a single function, a new subview (tabbed window)
    containing the decompiled function opens in the IDA display. [Example 23-1](ch23.html#example_hex-rays_output
    "Example 23-1. Example Hex-Rays output") shows an example of pseudocode generated
    using Hex-Rays to examine a Defcon 15 Capture the Flag binary. Each time you generate
    pseudocode for a function, Hex-Rays opens a new tabbed window to display the result.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为单个函数生成伪代码时，IDA显示中会打开一个新的子视图（标签窗口），其中包含反汇编的函数。[示例23-1](ch23.html#example_hex-rays_output
    "示例23-1. Hex-Rays输出示例")展示了使用Hex-Rays生成用于检查Defcon 15 Capture the Flag二进制的伪代码的示例。每次为函数生成伪代码时，Hex-Rays都会打开一个新的标签窗口来显示结果。
- en: Example 23-1. Example Hex-Rays output
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 示例23-1. Hex-Rays输出示例
- en: '[PRE88]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that while Hex-Rays uses a slightly different dummy-naming convention for
    arguments (`a1`, `a2`, etc.) and local variables (`v1`, `v2`) than is used in
    IDA, the ability to distinguish between function parameters and local variables
    remains. If you have changed the names of any variables within the disassembly,
    the decompiler will make use of those names rather than internally generated dummy
    names.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管Hex-Rays在参数（`a1`、`a2`等）和局部变量（`v1`、`v2`）的占位符命名约定上与IDA略有不同，但区分函数参数和局部变量的能力仍然存在。如果你在反汇编中更改了任何变量的名称，反汇编器将使用这些名称而不是内部生成的占位符名称。
- en: '| **Name** | Hex-Rays Decompiler |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | Hex-Rays反汇编器 |'
- en: '| **Author** | Ilfak Guilfanov, [Hex-Rays.com](http://hex-rays.com) |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Ilfak Guilfanov, [Hex-Rays.com](http://hex-rays.com) |'
- en: '| **Distribution** | Binary only |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | 仅二进制 |'
- en: '| **Price** | US$2,239 |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 美元2,239 |'
- en: '| **Description** | Generates C-like pseudocode from compiled ARM or 32-bit,
    x86 functions |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 从编译的ARM或32位、x86函数生成类似C的伪代码 |'
- en: '| **Information** | [http://www.hex-rays.com/decompiler.shtml](http://www.hex-rays.com/decompiler.shtml)
    |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://www.hex-rays.com/decompiler.shtml](http://www.hex-rays.com/decompiler.shtml)
    |'
- en: Hex-Rays utilizes the same cues employed by IDA to deduce datatypes; however,
    you will probably notice some type casting taking place in order to coerce type
    conversions where the types used in an operation do not appear to match Hex-Rays’s
    expectations. As a convenience, you may tell Hex-Rays to hide all casts by right-clicking
    and choosing the Hide Casts menu option.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: Hex-Rays使用与IDA相同的提示来推断数据类型；然而，你可能注意到在进行操作时类型不匹配Hex-Rays预期的情况时，会发生一些类型转换。为了方便，你可以通过右键单击并选择隐藏类型转换菜单选项来告诉Hex-Rays隐藏所有类型转换。
- en: Once a pseudocode window has been opened, you may use it almost like a source
    code editor and navigator. Navigating and editing within a pseudo-code window
    are much like navigating and editing within a standard IDA disassembly window.
    Double-clicking a function name, for example, immediately causes the selected
    function to be decompiled within the pseudocode window. Many editing features
    are available via context-sensitive menus, as shown in [Figure 23-1](ch23.html#hex-rays_decompiler_editing_options
    "Figure 23-1. Hex-Rays decompiler editing options"), including the ability to
    change variable and function names and types.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开伪代码窗口，你就可以几乎像使用源代码编辑器和导航器一样使用它。在伪代码窗口中进行导航和编辑与在标准IDA反汇编窗口中进行导航和编辑非常相似。例如，双击一个函数名，会立即在伪代码窗口中反汇编选定的函数。许多编辑功能都可通过上下文相关菜单获得，如图[图23-1](ch23.html#hex-rays_decompiler_editing_options
    "图23-1. Hex-Rays反汇编编辑选项")所示，包括更改变量和函数名称和类型的能力。
- en: '![Hex-Rays decompiler editing options](httpatomoreillycomsourcenostarchimages854344.png)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![Hex-Rays反汇编编辑选项](httpatomoreillycomsourcenostarchimages854344.png)'
- en: Figure 23-1. Hex-Rays decompiler editing options
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 图23-1. Hex-Rays反汇编编辑选项
- en: Further, changes that you make to variable names, function names, and datatypes
    are propagated back to IDA’s disassembly windows. Through repeated application
    of Rename and Set Type, and by hiding casts, [Example 23-1](ch23.html#example_hex-rays_output
    "Example 23-1. Example Hex-Rays output") is easily transformed into the following.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你对变量名、函数名和数据类型所做的更改会传播回IDA的反汇编窗口。通过重复应用重命名和设置类型，并通过隐藏类型转换，[示例23-1](ch23.html#example_hex-rays_output
    "示例23-1. Hex-Rays输出示例")可以轻松地转换为以下内容。
- en: '[PRE89]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Keep in mind that information is lost during compilation. There is no need to
    retain symbol information for any nonexternal symbols, and compiler optimizations
    tend to remove redundancies and streamline code. As a result, in addition to the
    liberal use of type casts, you are also likely to notice more `goto` statements
    in the generated pseudocode than you might generally expect to see in human-generated
    C code. This is not unexpected, because it is often very difficult to neatly map
    compiler-generated control flows back to their original C form. However, Hex-Rays
    is capable of recognizing complex C constructs such as `switch` statements, and
    a tremendous amount of work has been put into recognizing standard code sequences
    utilized by various C compilers.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在编译过程中信息会丢失。对于任何非外部符号，没有必要保留符号信息，编译器优化通常会删除冗余并简化代码。因此，除了广泛使用类型转换外，你可能会在生成的伪代码中注意到比通常在人类编写的C代码中预期的更多`goto`语句。这并不意外，因为将编译器生成的控制流整齐地映射回其原始的C形式通常非常困难。然而，Hex-Rays能够识别复杂的C结构，如`switch`语句，并且已经投入了大量工作来识别各种C编译器使用的标准代码序列。
- en: For all of its capabilities, you are encouraged not to become overreliant on
    Hex-Rays. C source is certainly easier to read and more succinct than its corresponding
    assembly representation, but decompilation is not a perfect science. In reading
    Hex-Rays pseudocode, you are trusting that what you see is a faithful representation
    of the underlying assembly, and while Ilfak works very hard to ensure that Hex-Rays
    is as accurate as possible, there are certainly edge cases that may prove problematic
    for Hex-Rays. It is highly recommended that you back up any conclusions you draw
    from reading Hex-Rays pseudo-code by verifying them against the underlying assembly
    code. Finally, keep in mind that while Hex-Rays may be used on binaries compiled
    from C++ code, it is only capable of generating C code, and the resulting code
    will lack any features that are specific to C++.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Hex-Rays具有所有这些功能，但鼓励您不要过度依赖Hex-Rays。C源代码当然比其相应的汇编表示更容易阅读和更简洁，但反编译并不是一门完美的科学。在阅读Hex-Rays伪代码时，您是在信任您所看到的是底层汇编的忠实表示，尽管Ilfak非常努力确保Hex-Rays尽可能准确，但肯定存在一些边缘情况可能会对Hex-Rays造成问题。强烈建议您通过验证底层汇编代码来支持您从阅读Hex-Rays伪代码中得出的任何结论。最后，请记住，尽管Hex-Rays可以用于从C++代码编译的二进制文件，但它只能生成C代码，并且生成的代码将缺少任何特定于C++的特性。
- en: '* * *'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[200](#CHP-23-FN-1)]) See [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[200](#CHP-23-FN-1)]) 请参阅 [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
- en: ^([[201](#CHP-23-FN-2)]) See [http://www.openrce.org/downloads/](http://www.openrce.org/downloads/).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[201](#CHP-23-FN-2)]) 请参阅 [http://www.openrce.org/downloads/](http://www.openrce.org/downloads/).
- en: ^([[202](#CHP-23-FN-3)]) See [http://www.woodmann.com/forum/index.php](http://www.woodmann.com/forum/index.php).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[202](#CHP-23-FN-3)]) 请参阅 [http://www.woodmann.com/forum/index.php](http://www.woodmann.com/forum/index.php).
- en: ^([[203](#CHP-23-FN-4)]) See [http://www.hex-rays.com/decompiler.shtml](http://www.hex-rays.com/decompiler.shtml).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[203](#CHP-23-FN-4)]) 请参阅 [http://www.hex-rays.com/decompiler.shtml](http://www.hex-rays.com/decompiler.shtml).
- en: ^([[204](#CHP-23-FN-5)]) See [http://www.hex-rays.com/manual/](http://www.hex-rays.com/manual/).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[204](#CHP-23-FN-5)]) 请参阅 [http://www.hex-rays.com/manual/](http://www.hex-rays.com/manual/).
- en: ^([[205](#CHP-23-FN-6)]) See [http://www.hexblog.com/?p=107](http://www.hexblog.com/?p=107).
    Not to be confused with IDA SDK.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[205](#CHP-23-FN-6)]) 请参阅 [http://www.hexblog.com/?p=107](http://www.hexblog.com/?p=107).
    请注意不要与IDA SDK混淆。
- en: IDAPython
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDAPython
- en: IDAPython began life as a third-party IDA plug-in developed by Gergely Erdelyi
    and is covered more thoroughly in [Chapter 15](ch15.html "Chapter 15. IDA Scripting").
    Its popularity among IDA users spread rapidly, and since IDA 5.4, IDAPython has
    shipped as a standard plug-in with all versions of IDA. Nonetheless, IDAPython
    remains available as an open source project that you may download and modify to
    suit your needs.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: IDAPython最初是由Gergely Erdelyi开发的第三方IDA插件，在[第15章](ch15.html "第15章。IDA脚本")中有更详细的介绍。它在IDA用户中的普及迅速，自IDA
    5.4以来，IDAPython已作为标准插件随所有版本的IDA一起提供。尽管如此，IDAPython仍然作为一个开源项目提供，您可以下载并修改以满足您的需求。
- en: Instructions for building IDAPython are available in the file *BUILDING.txt*
    contained in the IDAPython source, while instructions for installation are available
    on the IDAPython website. If you elect to build IDAPython from source, a number
    of dependencies must be satisfied. First and foremost is the need to have a working
    installation of 32-bit Python. Windows and OS X users are recommended to obtain
    and install Python using one of the installers available at the Python website.^([[206](#ftn.CHP-23-FN-7)])
    Linux users can generally get by with the 32-bit version of Python available for
    their flavor of Linux. Note that as of this writing, IDAPython is not compatible
    with Python version 3.*x*.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDAPython 源代码中包含的 *BUILDING.txt* 文件中提供了构建 IDAPython 的说明，而安装说明可在 IDAPython
    网站上找到。如果您选择从源代码构建 IDAPython，必须满足一系列依赖项。首先，需要有一个 32 位 Python 的有效安装。建议 Windows 和
    OS X 用户使用 Python 网站上提供的安装程序之一来获取和安装 Python.^([[206](#ftn.CHP-23-FN-7)]) Linux
    用户通常可以使用适用于其 Linux 版本的 32 位 Python 版本。请注意，截至本文撰写时，IDAPython 与 Python 版本 3.*x*
    不兼容。
- en: '| **Name** | IDAPython |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | IDAPython |'
- en: '| **Author** | Gergely Erdelyi |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Gergely Erdelyi |'
- en: '| **Distribution** | Source and binary (A binary version also ships with IDA.)
    |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | 源代码和二进制文件（IDA 也附带二进制版本） |'
- en: '| **Price** | Free |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | Python scripting engine for IDA Pro |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | IDA Pro 的 Python 脚本引擎 |'
- en: '| **Information** | [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
    |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
    |'
- en: The Python build script supplied with IDAPython, *build.py*, makes use of the
    Simplified Wrapper Interface Generator (SWIG)^([[207](#ftn.CHP-23-FN-8)]) to generate
    the components required to interface Python to IDA’s C++ libraries, and the header
    files that ship with the IDA SDK (since version 5.4) contain a number of macro
    declarations to ensure that they are compatible with SWIG. In addition to SWIG,
    the build process requires a C++ compiler. For Windows builds, the build script
    is configured to use Microsoft Visual C++,^([[208](#ftn.CHP-23-FN-9)]) while for
    Linux and Mac builds, the build process utilizes g++.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 随 IDAPython 一起提供的 Python 构建脚本 *build.py* 使用简化包装器接口生成器 (SWIG)^([[207](#ftn.CHP-23-FN-8)])
    生成将 Python 与 IDA 的 C++ 库接口所需的组件，以及随 IDA SDK 一起提供的头文件（自 5.4 版本起）包含许多宏声明，以确保它们与
    SWIG 兼容。除了 SWIG 之外，构建过程还需要一个 C++ 编译器。对于 Windows 构建，构建脚本配置为使用 Microsoft Visual
    C++^([[208](#ftn.CHP-23-FN-9)]），而对于 Linux 和 Mac 构建，构建过程使用 g++。
- en: '* * *'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[206](#CHP-23-FN-7)]) See [http://www.python.org/](http://www.python.org/).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[206](#CHP-23-FN-7)]) 请参阅 [http://www.python.org/](http://www.python.org/)。
- en: ^([[207](#CHP-23-FN-8)]) See [http://www.swig.org/](http://www.swig.org/).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[207](#CHP-23-FN-8)]) 请参阅 [http://www.swig.org/](http://www.swig.org/)。
- en: ^([[208](#CHP-23-FN-9)]) To obtain a free, stripped-down version of Visual C++,
    please visit [http://www.microsoft.com/express/](http://www.microsoft.com/express/).
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[208](#CHP-23-FN-9)]) 要获取免费、精简版的 Visual C++，请访问 [http://www.microsoft.com/express/](http://www.microsoft.com/express/)。
- en: collabREate
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: collabREate
- en: The collabREate plug-in is designed to facilitate collaboration between multiple
    users analyzing the same binary file. The goals of the project are to provide
    a natural integration of a plug-in component representing the synchronization
    client with a robust server component backed by a SQL database and capable of
    supporting features beyond simple database synchronization.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: collabREate 插件旨在促进多个用户分析同一二进制文件之间的协作。该项目的目标是提供一种自然集成表示同步客户端的插件组件与一个由 SQL 数据库支持的强大服务器组件，并且能够支持超出简单数据库同步的功能。
- en: '| **Name** | collabREate |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | collabREate |'
- en: '| **Author** | Chris Eagle and Tim Vidas |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Chris Eagle 和 Tim Vidas |'
- en: '| **Distribution** | C++ source and binary (including IDA freeware) |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | C++ 源代码和二进制文件（包括 IDA 免费软件） |'
- en: '| **Price** | Free |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | Collaborative framework for synchronizing remote IDA sessions
    |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 用于同步远程 IDA 会话的协作框架 |'
- en: '| **Information** | [http://www.idabook.com/collabreate/](http://www.idabook.com/collabreate/)
    |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://www.idabook.com/collabreate/](http://www.idabook.com/collabreate/)
    |'
- en: From a high-level perspective, collabREate owes much to the IDA Sync project.^([[209](#ftn.CHP-23-FN-10)])
    The collabREate plug-in processes databases updates and communicates with a remote
    server component to synchronize database updates with additional project members.
    Because IDA is a single-threaded application, some mechanism for dealing with
    asynchronous non-blocking network communications is necessary. In IDA versions
    prior to 6.0, the asynchronous communications component derives from the Windows
    Asynchronous Sockets techniques used by IDA Sync; however, with the introduction
    of IDA 6.0, asynchronous communications are now handled using Qt socket classes,
    allowing collabREate to be used on all IDA-supported platforms.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个高层次的角度来看，collabREate 在很大程度上得益于 IDA Sync 项目。[^[[209](#ftn.CHP-23-FN-10)])
    collabREate 插件处理数据库更新并与远程服务器组件通信，以同步数据库更新与项目其他成员。由于 IDA 是一个单线程应用程序，因此需要某种机制来处理异步非阻塞网络通信。在
    IDA 6.0 之前的版本中，异步通信组件来自 IDA Sync 使用的 Windows 异步套接字技术；然而，随着 IDA 6.0 的引入，异步通信现在使用
    Qt 套接字类进行处理，这使得 collabREate 可以在所有 IDA 支持的平台中使用。
- en: CollabREate takes an integrated approach to capturing user actions by leveraging
    IDA’s process and IDB event-notification mechanisms. By hooking various database
    change notifications, collabREate is able to seamlessly propagate database updates
    to the collabREate server. The types and numbers of change notifications generated
    by IDA have grown with each release of IDA, and collabREate endeavors to hook
    as many useful notifications as it possibly can for the version of IDA that it
    has been built for. An interesting side effect of using collabREate is that it
    allows users of very different versions of IDA (5.2 and 6.0, for example) to synchronize
    their activities even when they would be unable to exchange *.idb* files with
    one another.^([[210](#ftn.CHP-23-FN-11)]) The collabREate architecture offers
    true publish and subscribe capabilities to participating users. A user may selectively
    choose to publish her changes to the collabREate server, subscribe to changes
    posted to the server, or both publish and subscribe. For example, an experienced
    user may wish to share (publish) her changes with a group while blocking (not
    subscribing to) all changes made by other users. Users may select the types of
    actions to which they may publish and subscribe, such as byte-value changes, name
    changes, and the addition or deletion of comments. For example, one user may wish
    only to publish comments, while another user may wish to subscribe only to name
    changes and patched-byte notifications.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: CollabREate 通过利用 IDA 的进程和 IDB 事件通知机制，采取了一种综合的方法来捕获用户操作。通过挂钩各种数据库更改通知，collabREate
    能够无缝地将数据库更新传播到 collabREate 服务器。随着 IDA 的每次发布，IDA 生成的更改通知的类型和数量都在增长，collabREate
    努力为它构建的 IDA 版本尽可能多地挂钩有用的通知。使用 collabREate 的一个有趣副作用是，它允许使用不同版本 IDA 的用户（例如 5.2 和
    6.0）即使无法相互交换 *.idb* 文件，也能同步他们的活动。[^[[210](#ftn.CHP-23-FN-11)]) collabREate 架构为参与用户提供了真正的发布和订阅功能。用户可以选择性地将她的更改发布到
    collabREate 服务器，订阅服务器上发布的更改，或者两者都进行发布和订阅。例如，一个经验丰富的用户可能希望与一个组共享（发布）她的更改，同时阻止（不订阅）其他用户所做的所有更改。用户可以选择他们可以发布和订阅的操作类型，例如字节值更改、名称更改以及注释的添加或删除。例如，一个用户可能只想发布注释，而另一个用户可能只想订阅名称更改和修补字节通知。
- en: One of the most significant features of the collabREate plug-in is its degree
    of integration with the IDA SDK. IDA notifications are tied to specific database
    actions, not specific user actions. The fact that user actions happen to trigger
    IDA notifications is, of course, critical to the collaborative process; however,
    notifications can be triggered by other means as well. Scripts and API function
    calls can generate notification messages as well. As a result, the actions of
    a script that patches database bytes, renames locations or variables, or inserts
    new comments will be published to the collabREate server and will ultimately be
    shared with other IDA users working on the same project.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: collabREate 插件最显著的特点之一是其与 IDA SDK 的集成程度。IDA 通知与特定的数据库操作相关联，而不是与特定的用户操作相关联。用户操作恰好触发
    IDA 通知这一事实，当然对于协作过程至关重要；然而，通知也可以通过其他方式触发。脚本和 API 函数调用也可以生成通知消息。因此，修改数据库字节、重命名位置或变量或插入新注释的脚本操作将被发布到
    collabREate 服务器，并最终与其他在同一项目上工作的 IDA 用户共享。
- en: The collabREate server component is currently implemented in Java and utilizes
    JDBC^([[211](#ftn.CHP-23-FN-12)]) to communicate with a backend SQL database.
    The server is responsible for user and project management. User accounts are managed
    via a command-line interface to the server, while projects are created by users
    as they connect to the server. Following authentication with the server, a user’s
    collabREate plug-in sends the MD5 hash of the input file that the user is analyzing
    to the server. The MD5 value is used to ensure that multiple users are in fact
    working on identical input files. Upon initial connection, users indicate the
    types of updates that they would like to subscribe to, at which point the server
    forwards all updates that have been cached since the user’s last session. CollabREate’s
    Project Selection dialog is shown in [Figure 23-2](ch23s03.html#collabreate_project_selection_dialog
    "Figure 23-2. CollabREate Project Selection dialog").
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: collabREate 服务器组件目前是用 Java 实现的，并使用 JDBC^([[211](#ftn.CHP-23-FN-12)]) 与后端 SQL
    数据库进行通信。服务器负责用户和项目管理。用户账户通过服务器命令行界面进行管理，而项目则由用户在连接到服务器时创建。在通过服务器认证后，用户的 collabREate
    插件会将用户正在分析的输入文件的 MD5 哈希值发送到服务器。MD5 值用于确保多个用户实际上正在处理相同的输入文件。在初次连接时，用户会指出他们希望订阅的更新类型，此时服务器将自用户上次会话以来缓存的全部更新转发给用户。CollabREate
    的项目选择对话框如图 [图 23-2](ch23s03.html#collabreate_project_selection_dialog "图 23-2.
    CollabREate 项目选择对话框") 所示。
- en: '![CollabREate Project Selection dialog](httpatomoreillycomsourcenostarchimages854347.png.jpg)'
  id: totrans-657
  prefs: []
  type: TYPE_IMG
  zh: '![CollabREate 项目选择对话框](httpatomoreillycomsourcenostarchimages854347.png.jpg)'
- en: Figure 23-2. CollabREate Project Selection dialog
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23-2. CollabREate 项目选择对话框
- en: Users are presented with a drop-down list of projects that are compatible with
    the current database. As an option, it is always possible to create a new project
    that requires the user to enter a project description for others to view.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 用户会看到一个与当前数据库兼容的项目下拉列表。作为一个选项，始终可以创建一个需要用户输入项目描述以供他人查看的新项目。
- en: The collabREate server is capable of forking existing projects to allow users
    to create alternate branches of a project without impacting other users. This
    is a useful feature if you want to make (and track) a significant number of changes
    to a database without forcing those changes on other users. Since the server is
    capable of handling multiple projects related to a single binary input file, the
    plug-in and the server take additional steps to ensure that users are connecting
    to the proper project for their particular database.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: collabREate 服务器能够创建现有项目的分支，以便用户在不影响其他用户的情况下创建项目的替代分支。如果您想在不对其他用户施加这些更改的情况下对数据库进行大量修改（并跟踪这些更改），这是一个非常有用的功能。由于服务器能够处理与单个二进制输入文件相关的多个项目，插件和服务器会采取额外的步骤以确保用户连接到他们特定数据库的正确项目。
- en: The server does not provide rollback capability but does provide for a form
    of “save point.” A snapshot can be made at any time; then, to return to that database
    state, a user could re-open the binary (new *.idb* file) and fork a new project
    from the snapshot. This allows users to return to a specific point in time in
    the reversing process. CollabREate’s fork and snapshot features are accessed through
    the same hotkey sequence used for initial activation of the plug-in, which results
    in the dialog shown in [Figure 23-3](ch23s03.html#collabreate_select_command_dialog
    "Figure 23-3. CollabREate Select Command dialog").
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不提供回滚功能，但提供了一种形式的“保存点”。可以在任何时候创建快照；然后，为了返回到该数据库状态，用户可以重新打开二进制文件（新的 *.idb*
    文件）并从快照中创建一个新的项目。这使用户能够在回滚过程中返回到特定的时间点。CollabREate 的分支和快照功能通过与插件初始激活相同的快捷键序列访问，这导致显示如图
    [图 23-3](ch23s03.html#collabreate_select_command_dialog "图 23-3. CollabREate 选择命令对话框")
    所示的对话框。
- en: '![CollabREate Select Command dialog](httpatomoreillycomsourcenostarchimages854350.png)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![CollabREate Select Command 对话框](httpatomoreillycomsourcenostarchimages854350.png)'
- en: Figure 23-3. CollabREate Select Command dialog
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23-3. CollabREate 选择命令对话框
- en: A final feature of the collabREate server is the ability to restrict users to
    specific types of updates. For example, one user may be restricted to a subscribe-only
    profile, while another user may be allowed to publish only comments, while a third
    is allowed to publish all types of updates.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: collabREate 服务器的一个最终特性是能够限制用户对特定类型的更新。例如，一个用户可能被限制为仅订阅配置文件，而另一个用户可能只允许发布评论，第三个用户则允许发布所有类型的更新。
- en: '* * *'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[209](#CHP-23-FN-10)]) See [http://pedram.redhive.com/code/ida_plugins/ida_sync/](http://pedram.redhive.com/code/ida_plugins/ida_sync/).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[209](#CHP-23-FN-10)]) 请参阅 [http://pedram.redhive.com/code/ida_plugins/ida_sync/](http://pedram.redhive.com/code/ida_plugins/ida_sync/)。
- en: ^([[210](#CHP-23-FN-11)]) Older versions of IDA are typically unable to open
    *.idb* files created with newer versions of IDA.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[210](#CHP-23-FN-11)]) IDA 的旧版本通常无法打开使用 IDA 新版本创建的 *.idb* 文件。
- en: ^([[211](#CHP-23-FN-12)]) *JDBC* is the Java Database Connectivity API.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[211](#CHP-23-FN-12)]) *JDBC* 是 Java 数据库连接 API。
- en: ida-x86emu
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ida-x86emu
- en: Reverse engineering binaries often involves hand tracing through code in order
    to develop an understanding of how a function behaves. In order to do this, you
    need a solid understanding of the instruction set you are analyzing and a handy
    reference to refresh your memory when you encounter an instruction that doesn’t
    look familiar. An instruction emulator can be a useful tool to track all of the
    register and CPU state changes that take place over a series of instructions.
    The ida-x86emu plug-in, which was discussed in detail in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis") and whose information is shown again here,
    is one such emulator.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编二进制文件通常涉及手动跟踪代码，以便了解函数的行为。为了做到这一点，你需要对你正在分析的指令集有一个扎实的理解，并在遇到不熟悉的指令时有一个方便的参考资料来刷新你的记忆。指令模拟器可以是一个有用的工具，用于跟踪一系列指令中发生的所有寄存器和
    CPU 状态变化。ida-x86emu 插件，如第 21 章详细讨论的，以及其信息在此再次显示，就是这样一种模拟器。
- en: '| **Name** | ida-x86emu |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | ida-x86emu |'
- en: '| **Author** | Chris Eagle |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Chris Eagle |'
- en: '| **Distribution** | Source for SDK v6.1 and binaries for all versions of IDA
    from 5.0, including IDA Freeware. Source is backward compatible to SDK version
    4.9. |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | SDK v6.1 的源代码以及 IDA 5.0 及以上所有版本的二进制文件，包括 IDA 免费版。源代码与 SDK 版本 4.9
    兼容。|'
- en: '| **Price** | Free |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | Embedded x86 instruction emulator for IDA |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | IDA 的嵌入式 x86 指令模拟器 |'
- en: '| **Information** | [http://www.idabook.com/ida-x86emu/](http://www.idabook.com/ida-x86emu/)
    |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://www.idabook.com/ida-x86emu/](http://www.idabook.com/ida-x86emu/)
    |'
- en: This plug-in is distributed in source and binary form and is compatible with
    IDA SDK versions 4.6 and later. The plug-in is distributed with build scripts
    and project files to facilitate building with MinGW tools or Microsoft Visual
    Studio on Windows platforms and g++ on non-Windows platforms. A precompiled binary
    version of the plug-in for use with IDA freeware is included in the distribution.
    ida-x86emu is compatible with all Qt-based versions of IDA; however, prior to
    IDA 6.0, the plug-in is compatible with only the Windows GUI version of IDA.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件以源代码和二进制形式分发，且与 IDA SDK 4.6 及更高版本兼容。插件附带构建脚本和项目文件，以便在 Windows 平台上使用 MinGW
    工具或 Microsoft Visual Studio 以及在非 Windows 平台上使用 g++ 进行构建。分发中包含用于与 IDA 免费版一起使用的插件预编译二进制版本。ida-x86emu
    与所有基于 Qt 的 IDA 版本兼容；然而，在 IDA 6.0 之前，该插件仅与 IDA 的 Windows 图形界面版本兼容。
- en: The plug-in was developed with self-modifying code in mind and operates by reading
    instruction bytes from the current IDA database, decoding the instruction, and
    performing the associated operation. Operations may involve updating the emulator’s
    internal register variables or writing back to the database in the case of self-modifying
    code. A simulated stack and a heap are implemented by allocating new IDA segments
    that are read and written as appropriate. For more detailed information on using
    ida-x86emu, please refer to [Chapter 21](ch21.html "Chapter 21. Obfuscated Code
    Analysis").
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件考虑到自修改代码的开发，通过从当前 IDA 数据库读取指令字节、解码指令并执行相关操作来运行。操作可能涉及更新模拟器的内部寄存器变量或在自修改代码的情况下将数据写回数据库。通过分配新的
    IDA 段并按需读取和写入，实现了模拟堆栈和堆。有关使用 ida-x86emu 的更详细信息，请参阅 [第 21 章](ch21.html "第 21 章。混淆代码分析")。
- en: Class Informer
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类信息
- en: Recall from [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures")
    that C++ programs may include information that can assist you in recovering class
    names and class hierarchies. This embedded information is designed to support
    C++ Runtime Type Identification (RTTI). The C++ Class Informer plug-in by Sirmabus
    is designed to assist in the process of reverse engineering C++ code that was
    compiled using Microsoft Visual Studio. Class Informer automates much of the process
    described by Igor Skochinsky in his OpenRCE article on reversing Microsoft Visual
    C++^([[212](#ftn.CHP-23-FN-13)]) by identifying virtual function tables (vtables
    or vftables) and RTTI information and then extracting related class name and inheritance
    information.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第 8 章](ch08.html "第 8 章。数据类型和数据结构")，C++ 程序可能包含有助于您恢复类名和类层次结构的信息。这种嵌入信息旨在支持
    C++ 运行时类型识别 (RTTI)。Sirmabus 设计的 C++ Class Informer 插件旨在帮助逆向工程使用 Microsoft Visual
    Studio 编译的 C++ 代码。Class Informer 通过识别虚拟函数表（vtable 或 vftable）和 RTTI 信息，然后提取相关的类名和继承信息，自动化了
    Igor Skochinsky 在其 OpenRCE 文章中描述的许多过程，该文章讨论了逆向工程 Microsoft Visual C++^([[212](#ftn.CHP-23-FN-13)])。
- en: '| **Name** | Class Informer |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | Class Informer |'
- en: '| **Author** | Sirmabus |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Sirmabus |'
- en: '| **Distribution** | Binary only |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | 仅二进制 |'
- en: '| **Price** | Free |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | MSVC C++ class identifier |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | MSVC C++ 类标识符 |'
- en: '| **Download** | [http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip](http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip)
    |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| **下载** | [http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip](http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip)
    |'
- en: Upon activation, Class Informer displays the options dialog shown in [Figure 23-4](ch23s05.html#class_informer_options_dialog
    "Figure 23-4. Class Informer options dialog"), allowing the user to dictate where
    within the binary Class Informer should scan for vtables and permitting the user
    to control the verbosity of Class Informer’s output.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 激活后，Class Informer 显示如图 [图 23-4](ch23s05.html#class_informer_options_dialog
    "图 23-4。Class Informer 选项对话框") 所示的选项对话框，允许用户指定 Class Informer 应在二进制文件中的何处扫描 vtable，并允许用户控制
    Class Informer 输出的详细程度。
- en: '![Class Informer options dialog](httpatomoreillycomsourcenostarchimages854353.png.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![Class Informer 选项对话框](httpatomoreillycomsourcenostarchimages854353.png.jpg)'
- en: Figure 23-4. Class Informer options dialog
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23-4。Class Informer 选项对话框
- en: Once the user clicks Continue, Class Informer begins its scan, which may take
    some time depending on the size of the binary and the number of virtual function
    tables that Class Informer encounters. When complete, Class Informer opens a new
    tabbed window within IDA in order to summarize its findings. A partial listing,
    representative of Class Informer’s output, is shown here.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击继续后，Class Informer 开始扫描，这可能需要一些时间，具体取决于二进制文件的大小和 Class Informer 遇到的虚拟函数表数量。扫描完成后，Class
    Informer 在 IDA 中打开一个新的标签窗口，以总结其发现。这里显示的是 Class Informer 输出的部分列表，具有代表性。
- en: '[PRE90]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: For each virtual function table discovered, Class Informer displays the address
    of the vtable ![](httpatomoreillycomsourcenostarchimages854061.png), the method
    count ![](httpatomoreillycomsourcenostarchimages854063.png) (equal to the number
    of function pointers contained in the vtable), and summary information about each
    class ![](httpatomoreillycomsourcenostarchimages854093.png) derived from embedded
    RTTI information. Recovered class information includes the name of the class,
    the name of any superclasses, and an indication of whether the class inherits
    from a single base class (`[SI]`) or multiple base classes (`[MI]`). For each
    vtable discovered, Class Informer also applies structure templates to all of the
    RTTI-related data structures associated with the class as well as naming each
    structure and the class’s vtable in accordance with Microsoft’s name-mangling
    scheme. This results in a substantial time saving for anyone who may be reverse
    engineering Visual C++ code of any complexity.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个发现的虚拟函数表，Class Informer 会显示 vtable 的地址 ![httpatomoreillycomsourcenostarchimages854061.png]，方法计数
    ![httpatomoreillycomsourcenostarchimages854063.png]（等于 vtable 中包含的功能指针数量），以及从嵌入的
    RTTI 信息中派生出的每个类的摘要信息 ![httpatomoreillycomsourcenostarchimages854093.png]。恢复的类信息包括类的名称、任何超类的名称，以及类是否从单个基类（`[SI]`）或多个基类（`[MI]`）继承的指示。对于每个发现的
    vtable，Class Informer 还会将结构模板应用于与类相关的所有 RTTI 相关的数据结构，并根据微软的名称混淆方案对每个结构和类的 vtable
    进行命名。这为可能正在逆向工程任何复杂性的 Visual C++ 代码的人节省了大量时间。
- en: '* * *'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[212](#CHP-23-FN-13)]) See [http://www.openrce.org/articles/full_view/23](http://www.openrce.org/articles/full_view/23).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[212](#CHP-23-FN-13)]) 请参阅 [http://www.openrce.org/articles/full_view/23](http://www.openrce.org/articles/full_view/23)。
- en: MyNav
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyNav
- en: While not, strictly speaking, a plug-in, Joxean Koret’s Python scripts, dubbed
    *MyNav*, certainly qualify as a useful IDA extension, useful enough that MyNav
    earned the top spot in the Hex-Rays plug-in writing contest for 2010.^([[213](#ftn.CHP-23-FN-14)])
    The *mynav.py* script should be launched after you have loaded a binary and the
    initial autoanalysis has completed. Upon launch, MyNav adds 20 new menu options
    to IDA’s Edit ▸ Plugins menu, at which point you are ready to take advantage of
    a number of new features.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然严格来说不是一个插件，但Joxean Koret的Python脚本，被称为*MyNav*，确实可以算作一个有用的IDA扩展，其有用性足以使MyNav在2010年Hex-Rays插件编写比赛中获得第一名.^([[213](#ftn.CHP-23-FN-14)])
    在加载二进制文件并完成初始自动分析后，应启动*mynav.py*脚本。启动后，MyNav将为IDA的Edit ▸ Plugins菜单添加20个新的菜单选项，此时您就可以利用许多新功能了。
- en: '| **Name** | MyNav |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | MyNav |'
- en: '| **Author** | Joxean Koret |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Joxean Koret |'
- en: '| **Distribution** | Python source |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | Python源代码 |'
- en: '| **Price** | Free |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | Debugger tracing and code coverage tool |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 调试跟踪和代码覆盖率工具 |'
- en: '| **Information** | [http://code.google.com/p/mynav/](http://code.google.com/p/mynav/)
    |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://code.google.com/p/mynav/](http://code.google.com/p/mynav/)
    |'
- en: Among the features added by MyNav are a function-level (as opposed to basic
    block-level) graphical browser inspired by Zynamics’s BinNavi, additional graphing
    features such as displaying the code paths between any two functions, and a number
    of features designed to enhance IDA’s debugging capabilities.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: MyNav增加的功能包括一个受Zynamics的BinNavi启发的函数级（而非基本块级）图形浏览器，以及显示任何两个函数之间代码路径等额外的绘图功能，还有许多旨在增强IDA调试能力的功能。
- en: For debugging, MyNav records information about debugging sessions and allows
    you to use the results of one debugging session to serve as a filter for subsequent
    sessions. Following any debugging session, MyNav displays a graph that highlights
    only those functions executed during the session. Using the capabilities offered
    by MyNav, it is possible to quickly narrow down sets of functions that are responsible
    for specific actions within a program. For example, if you happen to be interested
    in the functions that are responsible for initiating network connections and downloading
    some content, you might create a session that does everything but initiate a network
    connection and then conduct a second session in which you do create a network
    connection. By excluding all functions that executed during your first debugging
    session, the resulting graph will contain hits for just those functions responsible
    for initiating the network connection. This feature is very useful if you are
    trying to characterize functions with very large binaries.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试，MyNav记录调试会话的信息，并允许您使用一个调试会话的结果作为后续会话的过滤器。在任意调试会话之后，MyNav会显示一个图表，仅突出显示会话期间执行的那些函数。利用MyNav提供的功能，可以快速缩小负责程序中特定操作的函数集。例如，如果您对负责启动网络连接并下载某些内容的函数感兴趣，您可能创建一个不启动网络连接的会话，然后进行第二个会话以创建网络连接。通过排除第一次调试会话期间执行的所有函数，生成的图表将仅包含负责启动网络连接的函数。如果您正在尝试描述具有非常大的二进制文件的函数，这个功能非常有用。
- en: For a full discussion of MyNav’s features, please refer to Joxean’s blog,^([[214](#ftn.CHP-23-FN-15)])
    where you will find a number of video walkthroughs demonstrating some of the capabilities
    of MyNav.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MyNav功能的全面讨论，请参阅Joxean的博客，^([[214](#ftn.CHP-23-FN-15)])，在那里您可以找到一些视频教程，展示了MyNav的一些功能。
- en: '* * *'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[213](#CHP-23-FN-14)]) See [http://www.hex-rays.com/contest2010/#mynav](http://www.hex-rays.com/contest2010/#mynav).
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[213](#CHP-23-FN-14)]) 请参阅 [http://www.hex-rays.com/contest2010/#mynav](http://www.hex-rays.com/contest2010/#mynav)。
- en: ^([[214](#CHP-23-FN-15)]) See [http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/](http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[214](#CHP-23-FN-15)]) 请参阅 [http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/](http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/)。
- en: IdaPdf
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IdaPdf
- en: Document-based malware is becoming increasingly common. Malicious PDF files
    are one example of document files designed to exploit vulnerabilities in document-viewing
    software. Analyzing malicious PDF files (or any document files for that matter)
    requires that you understand the structure of the file you are analyzing. In dissecting
    the structure of such a file, your goal is often to discover any embedded code
    that may get executed if the document is successfully utilized to compromise a
    computer used to view it. The few PDF analysis tools that exist are primarily
    targeted at the command-line user with the goal of facilitating the extraction
    of information that might ultimately be loaded into IDA for further analysis.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文档的恶意软件变得越来越普遍。恶意PDF文件是设计用来利用文档查看软件漏洞的文档文件的一个例子。分析恶意PDF文件（或任何文档文件）需要你了解你正在分析文件的结构。在分解此类文件的结构的分析中，你的目标通常是发现任何可能被成功利用以损害查看该文档的计算机的嵌入式代码。现有的少数PDF分析工具主要针对命令行用户，目标是简化可能最终被加载到IDA中进行进一步分析的信息提取。
- en: '| **Name** | IdaPdf |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | IdaPdf |'
- en: '| **Author** | Chris Eagle |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| **作者** | Chris Eagle |'
- en: '| **Distribution** | C++ source |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| **分发** | C++源代码 |'
- en: '| **Price** | Free |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| **价格** | 免费 |'
- en: '| **Description** | PDF loader and plug-in for dissecting and navigating PDF
    files |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 用于分解和导航PDF文件的PDF加载器和插件 |'
- en: '| **Information** | [http://www.idabook.com/idapdf/](http://www.idabook.com/idapdf/)
    |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | [http://www.idabook.com/idapdf/](http://www.idabook.com/idapdf/)
    |'
- en: IdaPdf consists of an IDA loader module and an IDA plug-in module, each designed
    to facilitate the analysis of PDF files. The loader component of IdaPdf recognizes
    PDF files and loads them into a new IDA database. The loader takes care of breaking
    the PDF into its individual components. During the loading process, the loader
    makes every attempt to extract and filter all PDF stream objects. Since loader
    modules get unloaded once the load process is complete, a second component, the
    IdaPdf plug-in, is required in order to provide PDF analysis capabilities beyond
    the initial loading. The plug-in module, upon recognizing that a PDF file has
    been loaded, proceeds to enumerate all of the PDF objects contained within the
    file and opens a new tabbed window containing a list of every object within the
    PDF. The following listing is representative of the type of information contained
    in the PDF Objects window.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: IdaPdf由IDA加载模块和IDA插件模块组成，每个模块都旨在简化PDF文件的分析。IdaPdf的加载组件识别PDF文件并将它们加载到新的IDA数据库中。加载组件负责将PDF分解为其各个组件。在加载过程中，加载组件会尽力提取和过滤所有PDF流对象。由于加载模块在加载过程完成后会卸载，因此需要一个第二个组件，即IdaPdf插件，以提供超出初始加载的PDF分析功能。插件模块在识别到已加载PDF文件后，会列出文件中包含的所有PDF对象，并打开一个新标签窗口，其中包含PDF中每个对象的列表。以下列表是PDF对象窗口中包含的信息类型的示例。
- en: '[PRE91]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The listing shows object numbers along with the location of the object, the
    object’s data, any filters that must be applied to stream objects, and a pointer
    to the extracted, unfiltered data. Context-sensitive menu options allow for easy
    navigating to view either the object data or any extracted filtered data. The
    opportunity to extract object data, either raw or filtered, is also made available
    via context-sensitive menu options. The Ascii column indicates the plug-in’s best-effort
    opinion as to whether the object contains only ASCII data in its raw or filtered
    versions.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中显示了对象的编号以及对象的位置、对象的数据、必须应用于流对象的任何过滤器，以及指向提取的、未过滤数据的指针。上下文相关菜单选项允许轻松导航以查看对象数据或任何提取的过滤数据。通过上下文相关菜单选项，还可以提供提取对象数据（无论是原始的还是过滤的）的机会。Ascii列指示插件对其最佳判断，即对象在其原始或过滤版本中是否仅包含ASCII数据。
- en: The last features implemented by IdaPdf are exposed through the addition of
    two new menu options under Edit ▸ Other when IdaPdf is launched. These menu options
    allow you to highlight a block of data in the database and then ask the plug-in
    to Base64 decode the data or unescape^([[215](#ftn.CHP-23-FN-16)]) the data, with
    the results being copied into a newly created section within IDA. Such uncoded
    data will often turn out to be the malicious payload contained within the PDF.
    Since the plug-in extracts this data to a new IDA segment, it is fairly straightforward
    to navigate to the extracted data and ask IDA to disassemble some or all of it.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 IdaPdf 时，通过在“编辑”▸“其他”下添加两个新的菜单选项，暴露了 IdaPdf 实现的最后一些功能。这些菜单选项允许你在数据库中突出显示一块数据，然后要求插件对数据进行
    Base64 解码或取消转义^([[215](#ftn.CHP-23-FN-16)))，结果将被复制到 IDA 中的新部分。这种未编码的数据通常会变成 PDF
    中包含的恶意有效载荷。由于插件将此数据提取到新的 IDA 段中，因此导航到提取的数据并要求 IDA 反汇编其中的一部分或全部是非常直接的。
- en: '* * *'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[215](#CHP-23-FN-16)]) The plug-in implements the JavaScript unescape function.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[215](#CHP-23-FN-16))) 插件实现了 JavaScript 取消转义函数。
- en: Summary
  id: totrans-723
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Anytime you find yourself wishing that IDA could perform some task, you should
    take a moment to wonder whether anyone else may have had the same wish and, further,
    whether someone has done something about implementing the missing functionality.
    Many IDA plug-ins are the result of exactly this kind of effort. The vast majority
    of publicly available plug-ins are short and sweet and designed to solve a specific
    problem. In addition to serving as potential solutions for your reverse engineering
    problems, plug-ins for which source code is available can serve as valuable references
    for interesting uses of the IDA SDK.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现自己希望 IDA 能够执行某些任务时，你应该花点时间想想是否其他人可能也有同样的愿望，更进一步，是否有人已经采取了措施来实现缺失的功能。许多
    IDA 插件正是这种努力的结果。绝大多数公开可用的插件都很短小精悍，旨在解决特定问题。除了作为解决你的逆向工程问题的潜在解决方案外，那些源代码可用的插件还可以作为
    IDA SDK 有趣用途的有价值参考。
