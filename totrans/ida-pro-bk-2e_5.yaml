- en: Part V. Real-World Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 20. Compiler Personalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, if we have done our job properly, you now possess the essential
    skills to use IDA effectively and, more important, to bend it to your will. The
    next step, young grasshopper, is to learn to react to the ninja stars that binaries
    (as opposed to IDA) will throw at you. Depending on your motives for staring at
    assembly language, you may be very familiar with what you are looking at, or you
    may never know what you are going to be faced with. If you happen to spend all
    of your time examining code that was compiled using gcc on a Linux platform, you
    may become quite familiar with the style of code that it generates. On the other
    hand, if someone dropped a debug version of a program compiled using Microsoft
    Visual C++ (VC++) in your lap, you might be completely baffled. Malware analysts
    in particular are faced with a wide variety of code to examine. Setting aside
    the topic of obfuscation for the moment, malware analysts are likely to see code
    created using Visual Basic, Delphi, and Visual C/C++; machine language blobs embedded
    within documents; and more all in the same afternoon.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will take a brief look at some of the ways that compilers
    differ as viewed through the IDA looking glass. The intent is not to delve into
    why compilers differ; rather, we hope to cover some of the ways that those differences
    manifest themselves in disassembly listings and how you may resolve those differences.
    Among other things, the compiler and associated options used to build a particular
    piece of software constitute one data point in profiling the author of that software.
  prefs: []
  type: TYPE_NORMAL
- en: While a wide variety of compilers are available for a wide variety of languages,
    in this chapter we will primarily utilize compiled C code for our examples, as
    a large number of C compilers are available for a large number of platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Jump Tables and Switch Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C `switch` statement is a frequent target for compiler optimizations. The
    goal of these optimizations is to match the switch variable to a valid case label
    in the most efficient manner possible. The means by which this is achieved typically
    depends on the nature of the `switch` statement’s case labels. When the case labels
    are widely spread, as in the following example, most compilers generate code to
    perform a binary search ^([[140](#ftn.CHP-20-FN-1)])to match the switch variable
    against one of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When case labels are closely clustered, preferably sequentially as shown here,
    compilers generally resolve the switch variable by performing a table lookup^([[141](#ftn.CHP-20-FN-2)])
    to match the switch variable to the address of its associated case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A compiled example of a `switch` statement that matches the switch variable
    against the consecutive cases 1 through 12 is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example was compiled using the Borland command-line compiler, which IDA
    well understands. The comments, which IDA inserted during the analysis phase,
    demonstrate that IDA has a clear understanding that this is a `switch` statement.
    In this example we note that IDA recognizes the switch test ![](httpatomoreillycomsourcenostarchimages854061.png),
    the jump table ![](httpatomoreillycomsourcenostarchimages854063.png), and individual
    cases by value ![](httpatomoreillycomsourcenostarchimages854093.png) within the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note on the use of jump tables to resolve switch cases, note that
    the table in the previous example contains 13 entries, while the `switch` statement
    is known to test cases 1 through 12 only. In this case, the compiler elected to
    include an entry for case 0 rather than treating 0 as a special case. The destination
    for case 0 ![](httpatomoreillycomsourcenostarchimages854095.png) is the same as
    the destination for every other value outside the range of 1 to 12 ![](httpatomoreillycomsourcenostarchimages854099.png).
  prefs: []
  type: TYPE_NORMAL
- en: A final implementation note concerns the nature of the test performed on the
    switch variable. For readers less familiar with the x86 instruction set, the test
    ![](httpatomoreillycomsourcenostarchimages854061.png) and the associated jump
    in the succeeding line may appear only to exclude values larger than 12 while
    failing to account for negative values. If true, this could be disastrous, as
    using a negative index into the jump table might lead to unintended consequences.
    Fortunately, the `ja` (jump above) instruction treats comparisons as if they were
    performed on unsigned values; thus `−1` (`0xFFFFFFFF`) would be seen as `4294967295`,
    which is much larger than 12 and therefore excluded from the valid range for indexing
    the jump table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same source code compiled using Microsoft Visual C++ results in the disassembly
    listing shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Several differences are apparent when comparing this code with the code generated
    by the Borland compiler. One obvious difference is that the jump table has been
    relocated to space immediately following the function containing the `switch`
    statement (as opposed to being embedded within the function itself in the case
    of the Borland code). Other than providing a cleaner separation of code and data,
    relocating the jump table in this manner has little effect on the behavior of
    the program. Despite the different layout of the code, IDA remains capable of
    annotating the key features of the `switch` statement, including the number of
    cases and the code blocks associated with each case.
  prefs: []
  type: TYPE_NORMAL
- en: A few of the implementation details of the `switch` statement include the fact
    that the switch variable (`var_8` in this case) is decremented ![](httpatomoreillycomsourcenostarchimages854061.png)
    to shift the range of valid values to 0 through 11 ![](httpatomoreillycomsourcenostarchimages854063.png),
    allowing the variable to be used directly as an index into the jump table ![](httpatomoreillycomsourcenostarchimages854093.png)
    without the need to create a dummy slot for the unused case 0\. As a result, the
    first entry (or zero index entry) ![](httpatomoreillycomsourcenostarchimages854095.png)
    in the jump table actually refers to the code for switch case 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rounding out our comparison of `switch` statements is the following code generated
    by gcc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code bears some similarities to the Borland code as seen by the comparison
    to 12 ![](httpatomoreillycomsourcenostarchimages854061.png), the jump table ![](httpatomoreillycomsourcenostarchimages854063.png)
    that contains 13 entries, and the use of a pointer to the default case ![](httpatomoreillycomsourcenostarchimages854093.png)
    in the case 0 slot of the jump table. As in the Borland code, the address for
    the case 1 handler ![](httpatomoreillycomsourcenostarchimages854095.png) can be
    found at index 1 into the jump table. Notable differences between the gcc code
    and previous examples include a different style of executing the jump ![](httpatomoreillycomsourcenostarchimages854099.png)
    and the fact that the jump table is stored in the read-only data (`.rdata`) section
    of the binary, providing a logical separation between the code associated with
    the `switch` statement and the data required to implement the `switch` statement.
    As in the other two examples, IDA is able to locate and annotate the key elements
    of the switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: One of the points we are making here is that there is no single correct way
    to compile source to assembly. Familiarity with code generated by a specific compiler
    in no way guarantees that you will recognize high-level constructs compiled using
    an entirely different compiler (or even different versions of the same compiler
    family). More important, do not assume that something is not a `switch` statement
    simply because IDA fails to add comments to that effect. Like you, IDA is more
    familiar with the output of some compilers than others. Rather than relying entirely
    on IDA’s analysis capabilities to recognize commonly used code and data constructs,
    you should always be prepared to utilize your own skills—your familiarity with
    a given assembly language, your knowledge of compilers, and your research skills—to
    properly interpret a disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[140](#CHP-20-FN-1)]) For you algorithmic analysis fans, this means that
    the switch variable is matched after at most log-[2]*N* operations, where *N*
    is the number of cases contained in the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[141](#CHP-20-FN-2)]) Again for those analyzing algorithms at home, the use
    of a table lookup allows the target case to be found in a single operation, which
    you may recall from your algorithms class is also called *constant time* or *O(1)*.
  prefs: []
  type: TYPE_NORMAL
- en: RTTI Implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures") we discussed
    C++ Runtime Type Identification (RTTI) and the fact that no standard exists for
    the manner in which RTTI is implemented by a compiler. Automatic recognition of
    RTTI-related constructs within a binary is another area in which IDA’s capabilities
    vary across compilers. Not surprisingly, IDA’s capabilities in this area are strongest
    with binaries compiled using Borland compilers. Readers interested in automated
    recognition of Microsoft RTTI data structures may want to try Igor Skochinsky’s
    IDC script available at The IDA Palace^([[142](#ftn.CHP-20-FN-3)]) or the Class
    Informer plug-in by Sirmabus,^([[143](#ftn.CHP-20-FN-4)]) which will be discussed
    further in [Chapter 23](ch23.html "Chapter 23. Real-World IDA Plug-ins").
  prefs: []
  type: TYPE_NORMAL
- en: A simple strategy for understanding how a specific compiler embeds type information
    for C++ classes is to write a basic program that makes use of classes containing
    virtual functions. After compiling the program, you can load the resulting executable
    into IDA and search for instances of strings that contain the names of classes
    used in the program. Regardless of the compiler used to build a binary, one thing
    that RTTI data structures have in common is that they all contain a pointer to
    a string containing the name of the class that they represent. Using data cross-references,
    it should be possible to locate a pointer to one such string, thus locating candidate
    RTTI data structures. The last step is to link a candidate RTTI structure back
    to the associated class’s vtable, which is best accomplished by following data
    cross-references backward from a candidate RTTI structure until a table of function
    pointers (the vtable) is reached.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[142](#CHP-20-FN-3)]) See [http://old.idapalace.net/idc/ms_rtti.zip](http://old.idapalace.net/idc/ms_rtti.zip).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[143](#CHP-20-FN-4)]) See [http://www.openrce.org/blog/browse/Sirmabus](http://www.openrce.org/blog/browse/Sirmabus).
  prefs: []
  type: TYPE_NORMAL
- en: Locating main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were fortunate enough to have source code available for a C/C++ program
    that you wanted to analyze, a good place to begin your analysis might be the `main`
    function, as this is where execution notionally begins. When faced with analyzing
    a binary, this is not a bad strategy to follow. However, as we know, it is complicated
    by the fact that compilers/linkers (and the use of libraries) add additional code
    that executes before `main` is reached. Thus it would often be incorrect to assume
    that the entry point of a binary corresponds to the `main` function written by
    the program’s author.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the notion that all programs have a `main` function is a C/C++ compiler
    convention rather than a hard-and-fast rule for writing programs. If you have
    ever written a Windows GUI application, then you may be familiar with the `WinMain`
    variation on `main`. Once you step away from C/C++, you will find that other languages
    use other names for their primary entry-point function. Regardless of what it
    may be called, we will refer to this function generically as the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. Library Recognition Using FLIRT Signatures")
    covered the concept of IDA signature files, their generation, and their application.
    IDA utilizes special startup signatures to attempt to identify a program’s `main`
    function. When IDA is able to match a binary’s startup sequence against one of
    the startup sequences in its signature files, IDA can locate a program’s `main`
    function based on its understanding of the behavior of the matched startup routine.
    This works great until IDA fails to match the startup sequence in a binary to
    any of its known signatures. In general, a program’s startup code is closely tied
    to both the compiler used to generate the code and the platform for which the
    code was built.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 12](ch12.html "Chapter 12. Library Recognition Using FLIRT
    Signatures") that startup signatures are grouped together and stored in signature
    files specific to binary file types. For example, startup signatures for use with
    the PE loader are stored in *pe.sig*, while startup signatures for use with the
    MS-DOS loader are stored in *exe.sig*. The existence of a signature file for a
    given binary file type does not guarantee that IDA will be able to identify a
    program’s `main` function 100 percent of the time. There are too many compilers,
    and startup sequences are too much of a moving target for IDA to ship with every
    possible signature.
  prefs: []
  type: TYPE_NORMAL
- en: For many file types, such as ELF and Mach-O, IDA does not include any startup
    signatures at all. The net result is that IDA can’t use signatures to locate a
    `main` function within an ELF binary (though the function will be found if it
    is named `main`).
  prefs: []
  type: TYPE_NORMAL
- en: The point of this discussion is to prepare you for the fact that, on occasion,
    you will be on your own when it comes to locating the `main` function of a program.
    In such cases it is useful to have some strategies for understanding how the program
    itself prepares for the call to `main`. As an example, consider a binary that
    has been obfuscated to some degree. In this case, IDA will certainly fail to match
    a startup signature because the startup routine itself has been obfuscated. If
    you manage to de-obfuscate the binary somehow (the topic of [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis")), you will probably need to locate not
    only `main` on your own but the original start routine as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For C and C++ programs with a traditional `main` function,^([[144](#ftn.CHP-20-FN-5)])
    one of the responsibilities of the startup code is to set up the stack arguments
    required by `main`, the integer `argc` (a count of the number of command-line
    arguments), the character pointer array `argv` (an array of pointers to strings
    containing the command-line arguments), and the character pointer array `envp`
    (an array of pointers to strings containing the environment variables that were
    set at program invocation). The following excerpt from a FreeBSD 8.0 dynamically
    linked, stripped binary demonstrates how gcc-generated startup code calls to `main`
    on a FreeBSD system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the call to `sub_8048400` ![](httpatomoreillycomsourcenostarchimages854061.png)
    turns out to be the call to `main`. This code is typical of many startup sequences
    in that there are calls to initialization functions (`_atexit` ![](httpatomoreillycomsourcenostarchimages854063.png)
    and `_init_proc` ![](httpatomoreillycomsourcenostarchimages854093.png)) preceding
    the call to `main` and a call to `_exit` ![](httpatomoreillycomsourcenostarchimages854095.png)
    following the return from `main`. The call to `_exit` ensures that the program
    terminates cleanly in the event that `main` performs a return rather than calling
    `_exit` itself. Note that the parameter passed to `_exit` ![](httpatomoreillycomsourcenostarchimages854099.png)
    is the value returned by main in EAX; thus the exit code of the program is the
    return value of `main`.
  prefs: []
  type: TYPE_NORMAL
- en: If the previous program was statically linked and stripped, the start routine
    would have the same structure as the preceding example; however, none of the library
    functions would have useful names. In that case, the `main` function would continue
    to stand out as the only function that is called with three parameters. Of course,
    applying FLIRT signatures as early as possible would also help to restore many
    of the library function names and make `main` stand out, as it does in the preceding
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate that the same compiler may generate a completely different
    style of code when running on a different platform, consider the following example,
    also created using gcc, of a dynamically linked, stripped binary taken from a
    Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `start` makes a single function call to `___libc_start_main`.
    The purpose of `___libc_start_main` is to perform all of the same types of tasks
    that were performed in the preceding FreeBSD example, including calling `main`
    and ultimately `exit`. Since `___libc_start_main` is a library function, we know
    that the only way it knows where `main` actually resides is that it is told via
    one of its parameters (of which there appear to be eight). Clearly two of the
    parameters ![](httpatomoreillycomsourcenostarchimages854061.png) and ![](httpatomoreillycomsourcenostarchimages854063.png)
    are pointers to functions, while a third ![](httpatomoreillycomsourcenostarchimages854093.png)
    is a pointer to a location within the `.text` section. There are few clues in
    the previous listing as to which function might be `main`, so you might need to
    analyze the code at the three potential locations in order to correctly locate
    `main`. This might be a useful exercise; however, you may prefer simply to remember
    that the first argument (topmost on the stack and therefore last pushed) to `___libc_start_main`
    is in fact a pointer to `main`. There are two factors that combine to prevent
    IDA from identifying `loc_8048384` as a function (which would have been named
    `sub_8048384`). The first is that the function is never called directly, so `loc_8048384`
    never appears as the target of a call instruction. The second is that although
    IDA contains heuristics to recognized functions based on their prologues (which
    is why `sub_80483C0` and `sub_80483D0` are identified as functions even though
    they too are never called directly), the function at `loc_8048384` (`main`) does
    not use a prologue recognized by IDA. The offending prologue (with comments) is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This prologue clearly contains the elements of a traditional prologue for a
    function that uses EBP as a frame pointer. The caller’s frame pointer is saved
    ![](httpatomoreillycomsourcenostarchimages854061.png) before setting the frame
    pointer for the current function ![](httpatomoreillycomsourcenostarchimages854063.png)
    and finally allocating space for local variables ![](httpatomoreillycomsourcenostarchimages854093.png).
    The problem for IDA is that these actions do not occur as the first actions within
    the function, and thus IDA’s heuristics fail. It is a simple enough matter to
    manually create a function (Edit ▸ Functions ▸ Create Function) at this point,
    but you should take care to monitor IDA’s behavior. Just as it failed to identify
    the function in the first place, it may fail to recognize the fact that the function
    uses EBP as a frame pointer. In such a case, you would need to edit the function
    (alt-P) to force IDA to believe that the function has a *BP-based frame* as well
    as to make adjustments to the number of stack bytes dedicated to saved registers
    and local variables.
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of the FreeBSD binary, if the preceding Linux example happened
    to be both statically linked and stripped, the start routine would not change
    at all other than the fact that the name for `___libc_start_main` would be missing.
    You could still locate `main` by remembering that gcc’s Linux start routine makes
    only one function call and that the first parameter to that function is the address
    of `main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Windows side of the house, the number of C/C++ compilers (and therefore
    the number of startup routines) in use is somewhat higher. Perhaps not unsurprisingly,
    in the case of gcc on Windows, it is possible to leverage some of the knowledge
    gained by studying gcc’s behavior on other platforms. The startup routine shown
    here is from a gcc/Cygwin binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly this code does not map cleanly to the previous Linux-based example.
    However, there is one striking similarity: only one function is called ![](httpatomoreillycomsourcenostarchimages854061.png),
    and the function takes a function pointer for parameter ![](httpatomoreillycomsourcenostarchimages854063.png).
    In this case `sub_401120` serves much the same purpose as `___libc_start_main`,
    while `sub_4010B0` turns out to be the `main` function of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows binaries compiled using gcc/MinGW make use of yet another style of
    `start` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another case in which IDA will fail to identify the program’s `main`
    function. The preceding code offers few clues as to the location of `main`, as
    there is only one nonlibrary function called ![](httpatomoreillycomsourcenostarchimages854061.png)
    (`sub_401150`) and that function does not appear to take any arguments (as `main`
    should). In this instance, the best course of action is to continue the search
    for `main` within `sub_401150`. A portion of `sub_401150` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the function turns out to have many similarities with the `start`
    function associated with FreeBSD that we saw earlier. Process of elimination points
    to `sub_401395` as the likely candidate for `main`, as it is the only non-library
    function that is called with three arguments—![](httpatomoreillycomsourcenostarchimages854063.png),
    ![](httpatomoreillycomsourcenostarchimages854093.png), and ![](httpatomoreillycomsourcenostarchimages854095.png).
    Also, the third argument ![](httpatomoreillycomsourcenostarchimages854095.png)
    is related to the return value of the `__p__environ` library function, which correlates
    well with the fact that `main`’s third argument is expected to be a pointer to
    the environment strings array. The example code is also preceded by a call to
    the `getmainargs` library function (not shown), which is called to set up the
    `argc` and `argv` parameters prior to actually calling `main`. This helps to reinforce
    the notion that `main` is about to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start routine for Visual C/C++ code is short and sweet, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'IDA has actually recognized the library routines referenced in the two instructions
    through the application of startup signatures rather than by the fact that the
    program is linked to a dynamic library containing the given symbols. IDA’s startup
    signatures provide easy location of the initial call to `main`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Within the entire body of `tmainCRTStartup`, `_main` is the only function called
    with exactly three arguments. Further analysis would reveal that the call to `_main`
    is preceded by a call to the `GetCommandLine` library function, which is yet another
    indication that a program’s `main` function may be called shortly. As a final
    note concerning the use of startup signatures, it is important to understand that,
    in this example, IDA has generated the name `_main` entirely on its own as a result
    of matching a startup signature. The ASCII string `main` appeared nowhere in the
    binary used in this example. Thus, you can expect `main` to be found and labeled
    anytime a startup signature is matched, even when a binary has been stripped of
    its symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last startup routine that we will examine for a C compiler is generated
    by Borland’s free command-line compiler. ^([[145](#ftn.CHP-20-FN-6)]) The last
    few lines of Borland’s start routine are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The pointer value pushed on the stack ![](httpatomoreillycomsourcenostarchimages854061.png)
    refers to a structure that in turn contains a pointer to `main`. Within `__startup`,
    the setup to call `main` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Again, this example bears many similarities to previous examples in that the
    call to `main` ![](httpatomoreillycomsourcenostarchimages854061.png) takes three
    arguments ![](httpatomoreillycomsourcenostarchimages854063.png), ![](httpatomoreillycomsourcenostarchimages854093.png),
    and ![](httpatomoreillycomsourcenostarchimages854095.png) (the only function called
    within `__startup` to do so) and the return value is passed directly to `_exit`
    to terminate the program. Additional analysis of `__startup` would reveal calls
    to the Windows API functions `GetEnvironmentStrings` and `GetCommandLine`, which
    are often precursors to the invocation of `main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to demonstrate that tracking down a program’s `main` function
    is not a problem specific to C programs, consider the following startup code from
    a compiled Visual Basic 6.0 program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ThunRTMain` library function performs a function similar to the Linux
    `libc_start_main` function in that its job is to perform any initialization required
    prior to invoking the actual `main` function of the program. In order to transfer
    control to the `main` function, Visual Basic utilizes a mechanism very similar
    to that in the Borland code in the earlier examples. `ThunRTMain` takes a single
    argument ![](httpatomoreillycomsourcenostarchimages854061.png), which is a pointer
    to a structure containing additional information required for program initialization,
    including the address of the `main` function. The content of this structure is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Within this data structure, there is only one item ![](httpatomoreillycomsourcenostarchimages854061.png)
    that appears to reference code at all, the pointer to `sub_4045D0`, which turns
    out to be the `main` function for the program.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, learning how to find `main` is a matter of understanding how executable
    files are built. In cases where you are experiencing difficulties, it may be beneficial
    to build some simple executables (with a reference to an easily identifiable string
    in `main`, for example) with the same tools used to build the binary you are analyzing.
    By studying your test cases, you will gain an understanding of the basic structure
    of binaries built using a specific set of tools that may assist you in further
    analyzing more complex binaries built with the same set of tools.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[144](#CHP-20-FN-5)]) Windows GUI applications require a `WinMain` function
    instead of `main`. Documentation regarding `WinMain` can be found here: [http://msdn2.microsoft.com/en-us/library/ms633559.aspx](http://msdn2.microsoft.com/en-us/library/ms633559.aspx).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[145](#CHP-20-FN-6)]) See [http://forms.embarcadero.com/forms/BCC32CompilerDownload/](http://forms.embarcadero.com/forms/BCC32CompilerDownload/).
  prefs: []
  type: TYPE_NORMAL
- en: Debug vs. Release Binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft’s Visual Studio projects are usually capable of building either debug
    or release versions of program binaries. One way to note the differences is to
    compare the build options specified for the debug version of a project to the
    build options specified for the release version. Simple differences include the
    fact that release versions are generally optimized,^([[146](#ftn.CHP-20-FN-7)])
    while debug versions are not, and debug versions are linked with additional symbol
    information and debugging versions of the runtime library, while release versions
    are not. The addition of debugging-related symbols allows debuggers to map assembly
    language statements back to their source code counterparts and to determine the
    names of local variables.^([[147](#ftn.CHP-20-FN-8)]) Such information is typically
    lost during the compilation process. The debugging versions of Microsoft’s runtime
    libraries have also been compiled with debugging symbols included, optimizations
    disabled, and additional safety checks enabled to verify that some function parameters
    are valid.
  prefs: []
  type: TYPE_NORMAL
- en: When disassembled using IDA, debug builds of Visual Studio projects look significantly
    different from release builds. This is a result of compiler and linker options
    specified only in debug builds, such as basic runtime checks (/RTCx^([[148](#ftn.CHP-20-FN-9)])),
    which introduce extra code into the resulting binary. A side effect of this extra
    code is that it defeats IDA’s startup signature-matching process, resulting in
    IDA’s frequent failure to automatically locate `main` in debug builds of binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first differences you may notice in a debug build of a binary is
    that virtually all functions are reached via *jump* functions (also known as *thunk*
    functions), as shown in the following code fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the program entry point ![](httpatomoreillycomsourcenostarchimages854061.png)
    does nothing other than jump ![](httpatomoreillycomsourcenostarchimages854063.png)
    to the actual startup function ![](httpatomoreillycomsourcenostarchimages854093.png).
    The startup function, in turn, calls ![](httpatomoreillycomsourcenostarchimages854095.png)
    another function ![](httpatomoreillycomsourcenostarchimages854099.png), which
    simply jumps ![](httpatomoreillycomsourcenostarchimages854101.png) to the actual
    implementation of that function. The two functions ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854099.png) that contain nothing
    but a single jump statement are called *thunk* functions. The heavy use of thunk
    functions in debug binaries is one of the obstacles to IDA’s signature-matching
    process. While the presence of thunk functions may briefly slow down your analysis,
    using the techniques described in the previous section, it is still possible to
    track down the `main` function of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic runtime checks in a debug build cause several additional operations
    to be performed upon entry to any function. An example of an extended prologue
    in a debug build is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The function in this example utilizes four local variables that should require
    only 16 bytes of stack space. Instead we see that this function allocates 240
    bytes ![](httpatomoreillycomsourcenostarchimages854061.png) of stack space and
    then proceeds to fill each of the 240 bytes with the value `0xCC`. The four lines
    starting at ![](httpatomoreillycomsourcenostarchimages854063.png) equate to the
    following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The byte value `0xCC` corresponds to the x86 opcode for `int 3`, which is a
    software interrupt that causes a program to trap to a debugger. The intent of
    filling the stack frame with an overabundance of `0xCC` values may be to ensure
    that the debugger is invoked in the event that the program somehow attempts to
    execute instructions from the stack (an error condition that one would hope to
    catch in a debug build).
  prefs: []
  type: TYPE_NORMAL
- en: 'The function’s local variables are initialized beginning at ![](httpatomoreillycomsourcenostarchimages854093.png),
    where we note that the variables are not adjacent to one another. The intervening
    space will have been filled with the value `0xCC` by the preceding `memset` operation.
    Providing extra space between variables in this manner can make it easier to detect
    overflows from one variable that may spill into and corrupt another variable.
    Under normal conditions, none of the `0xCC` values used as filler, outside of
    any declared variables, should be overwritten. For comparison purposes, the release
    version of the same code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the release version we see that only the required amount of space is requested
    for local variables ![](httpatomoreillycomsourcenostarchimages854061.png) and
    that all four local variables are adjacent to one another ![](httpatomoreillycomsourcenostarchimages854063.png).
    Also note that the use of `0xCC` as a filler value has been eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[146](#CHP-20-FN-7)]) *Optimization* generally involves elimination of redundancy
    in code or selection of faster, but potentially larger, sequences of code in order
    to satisfy a developer’s desire to create either faster or smaller executable
    files. Optimized code may not be as straightforward to analyze as nonoptimized
    code and may therefore be considered a bad choice for use during a program’s development
    and debugging phases.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[147](#CHP-20-FN-8)]) gcc also offers the ability to insert debugging symbols
    during the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[148](#CHP-20-FN-9)]) See [http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx](http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Calling Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Disassembly Navigation"), we discussed
    the most common calling conventions utilized in C and C++ code. While adherence
    to a published calling convention is crucial when attempting to interface one
    compiled module to another, nothing prohibits the use of custom calling conventions
    by functions within a single module. This is commonly seen in highly optimized
    functions that are not designed to be called from outside the module in which
    they reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code represents the first four lines of a function that uses
    a nonstandard calling convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: According to IDA’s analysis, only one argument ![](httpatomoreillycomsourcenostarchimages854061.png)
    exists in the function’s stack frame. However, upon closer inspection of the code,
    you can see that both the EAX register ![](httpatomoreillycomsourcenostarchimages854063.png)
    and the CL register ![](httpatomoreillycomsourcenostarchimages854093.png) are
    used without any initialization taking place within the function. The only possible
    conclusion is that both EAX and CL are expected to be initialized by the caller.
    Therefore, you should view this function as a three-argument function rather than
    a single-argument function, and you must take special care when calling it to
    ensure that the three arguments are all in their proper places.
  prefs: []
  type: TYPE_NORMAL
- en: IDA allows you to specify custom calling conventions for any function by setting
    the function’s “type.” This is done by entering the function’s prototype via the
    Edit ▸ Functions ▸ Set function type menu option and using IDA’s `__usercall`
    calling convention. [Figure 20-1](ch20s05.html#designating_a_function_as_underscore_und
    "Figure 20-1. Designating a function as __usercall") shows the resulting dialog
    used to set the type for `sub_158AC` in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designating a function as __usercall](httpatomoreillycomsourcenostarchimages854313.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-1. Designating a function as `__usercall`
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, the declaration is shown again here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the IDA keyword `__usercall` is used in place of one of the standard calling
    conventions such as `__cdecl` or `__stdcall`. The use of `__usercall` requires
    us to tell IDA the name of the register used to hold the function’s return value
    by appending the register name to the name of the function (yielding `sub_158AC<eax>`
    in this case). If the function returns no value, the return register may be omitted.
    Within the parameter list, each register-based parameter must also be annotated
    by appending the corresponding register name to the parameter’s data type. After
    the function’s type has been set, IDA propagates parameter information to calling
    functions, which results in improved commenting of function call sequences as
    shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here it is clear that IDA recognizes that EAX will hold the first argument to
    the function ![](httpatomoreillycomsourcenostarchimages854061.png), CL will hold
    the second argument ![](httpatomoreillycomsourcenostarchimages854063.png), and
    the third argument will placed on the stack ![](httpatomoreillycomsourcenostarchimages854093.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate that calling conventions can vary widely even with a single
    executable, a second example using a custom calling convention is taken from the
    same binary file and shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here again, IDA has indicated that the function accesses only one argument ![](httpatomoreillycomsourcenostarchimages854061.png)
    within the stack frame. Closer inspection makes it quite clear that the ESI register
    ![](httpatomoreillycomsourcenostarchimages854063.png) is also expected to be initialized
    prior to calling this function. This example demonstrates that even with the same
    binary file, the registers chosen to hold register-based arguments may vary from
    function to function.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson to be learned here is to make certain that you understand how each
    register used in a function is initialized. If a function makes use of a register
    prior to initializing that register, then the register is being used to pass a
    parameter. Please refer to [Chapter 6](ch06.html "Chapter 6. Disassembly Navigation")
    for a review of which registers are used by various compilers and common calling
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of compiler-specific behaviors is too numerous to cover in a single
    chapter (or even a single book for that matter). Among other behaviors, compilers
    differ in the algorithms they employ to implement various high-level constructs
    and the manner in which they choose to optimize generated code. Because a compiler’s
    behavior is heavily influenced by the options supplied to the compiler during
    the build process, it is possible for one compiler to generate radically different
    binaries when fed the same source but different build options. Unfortunately,
    learning to cope with all of these variations is usually a matter of experience.
    Further complicating matters is the fact that it often very difficult to search
    for help on specific assembly language constructs, as it is very difficult to
    craft search expressions that will yield results specific to your particular case.
    When this happens, your best resource is generally a forum dedicated to reverse
    engineering in which you can post code and benefit from the knowledge of others
    who have had similar experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 21. Obfuscated Code Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even under ideal circumstances, comprehending a disassembly listing is a difficult
    task at best. High-quality disassemblies are essential for anyone contemplating
    digging into the inner workings of a binary, which is precisely why we have spent
    the last 20 chapters discussing IDA Pro and its capabilities. It can be argued
    that IDA is so effective at what it does that it has lowered the barriers for
    entry into the binary analysis field. While certainly not attributable to IDA
    alone, the fact that the state of binary reverse engineering has advanced so far
    in recent years is not lost on anyone who does not want his software to be analyzed.
    Thus, over the last several years, an arms race of sorts has been taking place
    between reverse engineers and programmers who wish to keep their code secret.
    In this chapter we will examine IDA’s role in this arms race and discuss some
    of the measures that have been taken to protect code, along with how to defeat
    those measures using IDA.
  prefs: []
  type: TYPE_NORMAL
- en: Various dictionary definitions will inform you that *obfuscation* is the act
    of making something obscure, perplexing, confusing, or bewildering in order to
    prevent others from understanding the obfuscated item. Anti–reverse engineering,
    on the other hand, encompasses a broader range of techniques (obfuscation being
    one of them) designed to hinder analysis of an item. In the context of this book
    and the use of IDA, the items to which such anti–reverse engineering techniques
    may be applied are binary executable files (as opposed to source files or silicon
    chips, for example).
  prefs: []
  type: TYPE_NORMAL
- en: In order to consider the impact of obfuscation, and anti–reverse engineering
    techniques in general, on the use of IDA, it is first useful to categorize some
    of these techniques in order to understand exactly how each may manifest itself.
    It is important to note that there is no one correct way to categorize each technique,
    as the general categories that follow often overlap in their descriptions. In
    addition, new anti–reverse engineering techniques are under continuous development,
    and it is not possible to provide a single, all-inclusive list.
  prefs: []
  type: TYPE_NORMAL
- en: Anti–Static Analysis Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of anti–static analysis techniques is to prevent an analyst
    from understanding the nature of a program without actually running the program.
    These are precisely the types of techniques that target disassemblers such as
    IDA and are thus of greatest concern if IDA is your weapon of choice for reverse
    engineering binaries. Several types of anti–static analysis techniques are discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembly Desynchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the older techniques designed to frustrate the disassembly process involves
    the creative use of instructions and data to prevent the disassembly from finding
    the correct starting address for one or more instructions. Forcing the disassembler
    to lose track of itself in this manner usually results in a failed or, at a minimum,
    incorrect disassembly listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows IDA’s efforts to disassemble a portion of the Shiva^([[149](#ftn.CHP-21-FN-1)])
    anti–reverse engineering tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This example executes a call ![](httpatomoreillycomsourcenostarchimages854061.png)
    (a jump can just as easily be used) into the middle of an existing instruction
    ![](httpatomoreillycomsourcenostarchimages854063.png). Since the function call
    is assumed to return, the succeeding instruction at address `0A04B0D6` ![](httpatomoreillycomsourcenostarchimages854063.png)
    is disassembled (incorrectly). The actual target of the call instruction, `loc_A04B0D6+1`
    (`0A04B0D7`), cannot be disassembled because the associated bytes have already
    been incorporated into the 5-byte instruction at `0A04B0D6`. Assuming we notice
    that this is taking place, the remainder of the disassembly must be considered
    suspect. Evidence of this fact shows up in the form of unexpected user-space instructions
    ![](httpatomoreillycomsourcenostarchimages854093.png) (in this case an `iret`^([[150](#ftn.CHP-21-FN-2)]))
    and miscellaneous databytes ![](httpatomoreillycomsourcenostarchimages854095.png).
  prefs: []
  type: TYPE_NORMAL
- en: Note that this type of behavior is not restricted to IDA. Virtually all disassemblers,
    whether they utilize a recursive descent algorithm or a linear sweep algorithm,
    fall victim to this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proper way to deal with this situation in IDA is to undefine the instruction
    that contains the bytes that are the target of the call and then define an instruction
    at the call target address in an attempt to resynchronize the disassembly. Of
    course, the use of an interactive disassembler greatly simplifies this process.
    Using IDA, a quick Edit ▸ Undefine (hotkey U) with the cursor positioned at ![](httpatomoreillycomsourcenostarchimages854061.png)
    followed by an Edit ▸ Code (hotkey C) with the cursor repositioned on address
    `0A04B0D7` results in the listing shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it is somewhat more obvious that the byte at address `0A04B0D6`
    ![](httpatomoreillycomsourcenostarchimages854061.png) is never executed. The instruction
    at `0A04B0D7` ![](httpatomoreillycomsourcenostarchimages854063.png) (the target
    of the call) is used to clear the return address (from the bogus call) off the
    stack, and execution continues. Note that is does not take long before the technique
    is used again, this time using a 2-byte jump instruction at address `0A04B0DB`
    ![](httpatomoreillycomsourcenostarchimages854093.png), which actually jumps into
    the middle of itself. Here again, we are obligated to undefine an instruction
    in order to get to the start of the next instruction. One more application of
    the undefine (at `0A04B0DB`) and redefine (at `0A04B0DC`) processes yields the
    following disassembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The target of the jump instruction turns out to be yet another jump instruction
    ![](httpatomoreillycomsourcenostarchimages854061.png). In this case, however,
    the jump is impossible for a disassembler (and potentially confusing to the human
    analyst) to follow, as the target of the jump is contained in a register (EAX)
    and computed at runtime. This is an example of another type of anti–static analysis
    technique, discussed in [Dynamically Computed Target Addresses](ch21.html#dynamically_computed_target_addresses
    "Dynamically Computed Target Addresses") in [Dynamically Computed Target Addresses](ch21.html#dynamically_computed_target_addresses
    "Dynamically Computed Target Addresses"). In this case the value contained in
    the EAX register is not difficult to determine given the relatively simple instruction
    sequence that precedes the jump. The `pop` instruction at ![](httpatomoreillycomsourcenostarchimages854063.png)
    loads the return address from the call instruction in the previous example (`0A04B0D6`)
    into the EAX register, while the following instruction ![](httpatomoreillycomsourcenostarchimages854093.png)
    has the effect of adding 10 to EAX. Thus the target of the jump instruction is
    `0A04B0E0`, and this is the address at which we must resume the disassembly process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final example of desynchronization taken from a different binary demonstrates
    how processor flags may be utilized to turn conditional jumps into absolute jumps.
    The following disassembly demonstrates the use of the x86 `Z` flag for just such
    a purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `xor` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    is used to zero the EAX register and set the x86 `Z` flag. The programmer, knowing
    that the `Z` flag is set, utilizes a jump-on-zero (`jz`) instruction ![](httpatomoreillycomsourcenostarchimages854063.png),
    which will always be taken, to attain the effect of an unconditional jump. As
    a result, the instructions ![](httpatomoreillycomsourcenostarchimages854093.png)
    and ![](httpatomoreillycomsourcenostarchimages854095.png) between the jump and
    the jump target will never be executed and serve only to confuse any analyst who
    fails to realize this fact. Note that, once again, this example obscures the actual
    jump target by jumping into the middle of an instruction ![](httpatomoreillycomsourcenostarchimages854099.png).
    Properly disassembled, the code should read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The actual target of the jump ![](httpatomoreillycomsourcenostarchimages854061.png)
    has been revealed, as has the extra byte ![](httpatomoreillycomsourcenostarchimages854063.png)
    that caused the desynchronization in the first place. It is certainly possible
    to use far more roundabout ways of setting and testing flags prior to executing
    a conditional jump. The level of difficulty for analyzing such code increases
    with the number of operations that may affect the CPU flag bits prior to testing
    their value.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically Computed Target Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do not confuse the title of this section with an anti–dynamic analysis technique.
    The phrase *dynamically computed* simply means that an address to which execution
    will flow is computed at runtime. In this section we discuss several ways in which
    such an address can be derived. The intent of such techniques is to hide (obfuscate)
    the actual control flow path that a binary will follow from the prying eyes of
    the static analysis process.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this technique was shown in the preceding section. The example
    used a `call` statement to place a return address on the stack. The return address
    was popped directly off the stack into a register, and a constant value was added
    to the register to derive the final target address, which was ultimately reached
    by performing a jump to the location specified by the register contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'An infinite number of similar code sequences can be developed for deriving
    a target address and transferring control to that address. The following code,
    which wraps up the initial startup sequence in Shiva, demonstrates an alternate
    method for dynamically computing target addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The comments in the right-hand margin document the changes being made to various
    CPU registers at each instruction. The process culminates in a derived value being
    moved into the top position of the stack (`TOS`) ![](httpatomoreillycomsourcenostarchimages854061.png),
    which causes the return instruction to transfer control to the computed location
    (`0A048068` in this case). Code sequences such as these can significantly increase
    the amount of work that must be performed during static analysis, as the analyst
    must essentially run the code by hand to determine the actual control flow path
    taken in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Much more complex types of control flow hiding have been developed and utilized
    in recent years. In the most complex cases, a program will use multiple threads
    or child processes to compute control flow information and receive that information
    via some form of interprocess communication (for child processes) or synchronization
    primitives (for multiple threads). In such cases, static analysis can become extremely
    difficult, as it becomes necessary to understand not only the behavior of multiple
    executable entities but also the exact manner by which those entities exchange
    information. For example, one thread may wait on a shared semaphore^([[151](#ftn.CHP-21-FN-3)])
    object, while a second thread computes values or modifies code that the first
    thread will make use of once the second thread signals its completion via the
    semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another technique, frequently used within Windows-oriented malware, involves
    configuring an exception handler,^([[152](#ftn.CHP-21-FN-4)]) intentionally triggering
    an exception, and then manipulating the state of the process’s registers while
    handling the exception. The following example is used by the tElock anti–reverse
    engineering tool to obscure the program’s actual control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The sequence begins by using a call ![](httpatomoreillycomsourcenostarchimages854061.png)
    to the next instruction ![](httpatomoreillycomsourcenostarchimages854063.png);
    the call instruction pushes `0041D07F` onto the stack as a return address, which
    is promptly popped off the stack into the EBP register ![](httpatomoreillycomsourcenostarchimages854063.png).
    Next ![](httpatomoreillycomsourcenostarchimages854093.png), the EAX register is
    set to the sum of EBP and `46h`, or `0041D0C5`, and this address is pushed onto
    the stack ![](httpatomoreillycomsourcenostarchimages854095.png) as the address
    of an exception handler function. The remainder of the exception handler setup
    takes place at ![](httpatomoreillycomsourcenostarchimages854099.png) and ![](httpatomoreillycomsourcenostarchimages854101.png),
    which complete the process of linking the new exception handler into the existing
    chain of exception handlers referenced by `fs:[0]`.^([[153](#ftn.CHP-21-FN-5)])
    The next step is to intentionally generate an exception ![](httpatomoreillycomsourcenostarchimages854103.png),
    in this case an `int 3`, which is a software trap (interrupt) to the debugger.
    In x86 programs, the `int 3` instruction is used by debuggers to implement a software
    breakpoint. Normally at this point, an attached debugger would gain control; in
    fact, if a debugger is attached, it will have the first opportunity to handle
    the exception, thinking that it is a breakpoint. In this case, the program fully
    expects to handle the exception, so any attached debugger must be instructed to
    pass the exception along to the program. Failing to allow the program to handle
    the exception may result in an incorrect operation and possibly a crash of the
    program. Without understanding how the `int 3` exception is handled, it is impossible
    to know what may happen next in this program. If we assume that execution simply
    resumes following the `int 3`, then it appears that a divide-by-zero exception
    will eventually be triggered by instructions ![](httpatomoreillycomsourcenostarchimages854133.png)
    and ![](httpatomoreillycomsourcenostarchimages854135.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception handler associated with the preceding code begins at address
    `0041D0C5`. The first portion of this function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The third argument ![](httpatomoreillycomsourcenostarchimages854061.png) to
    the exception handler function is a pointer to a Windows `CONTEXT` structure (defined
    in the Windows API header file *winnt.h*). The `CONTEXT` structure is initialized
    with the contents of all CPU registers as they existed at the time of the exception.
    An exception handler has the opportunity to inspect and, if desired, modify the
    contents of the `CONTEXT` structure. If the exception handler feels that it has
    corrected the problem that led to the exception, it can notify the operating system
    that the offending thread should be allowed to continue. At this point the operating
    system reloads the CPU registers for the thread from the `CONTEXT` structure that
    was provided to the exception handler, and execution of the thread resumes as
    if nothing had ever happened.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the exception handler begins by accessing the thread’s
    `CONTEXT` ![](httpatomoreillycomsourcenostarchimages854063.png) in order to increment
    the instruction pointer ![](httpatomoreillycomsourcenostarchimages854093.png),
    thus moving beyond the instruction that generated the exception. Next, the exception’s
    type code (a field within the provided `EXCEPTION_RECORD` ![](httpatomoreillycomsourcenostarchimages854095.png))
    is retrieved ![](httpatomoreillycomsourcenostarchimages854099.png) in order to
    determine the nature of the exception. This portion of the exception handler deals
    with the divide-by-zero error ![](httpatomoreillycomsourcenostarchimages854101.png),
    generated in the previous example, by zeroing ![](httpatomoreillycomsourcenostarchimages854103.png)
    all of the x86 hardware debugging registers.^([[154](#ftn.CHP-21-FN-6)]) Without
    examining the remainder of the tElock code, it is not immediately apparent why
    the debug registers are being cleared. In this case, tElock is clearing values
    from a previous operation in which it used the debug registers to set four breakpoints
    in addition to the `int 3` seen previously. In addition to obfuscating the true
    flow of the program, clearing or modifying the x86 debug registers can wreak havoc
    with software debuggers such as OllyDbg or IDA’s own internal debugger. Such anti-debugging
    techniques are discussed in [Anti–Dynamic Analysis Techniques](ch21s02.html "Anti–Dynamic
    Analysis Techniques") in [Anti–Dynamic Analysis Techniques](ch21s02.html "Anti–Dynamic
    Analysis Techniques").
  prefs: []
  type: TYPE_NORMAL
- en: Opcode Obfuscation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the techniques described to this point may provide—in fact, are intended
    to provide—a hindrance to understanding a program’s control flow, none prevent
    you from observing the correct disassembled form of a program you are analyzing.
    Desynchronization had the greatest impact on the disassembly, but it was easily
    defeated by reformatting the disassembly to reflect the correct instruction flow.
  prefs: []
  type: TYPE_NORMAL
- en: A more effective technique for preventing correct disassembly is to encode or
    encrypt the actual instructions when the executable file is being created. The
    obfuscated instructions are useless to the CPU and must be de-obfuscated back
    to their original form before they are fetched for execution by the CPU. Therefore,
    at least some portion of the program must remain unencrypted in order to serve
    as the startup routine, which, in the case of an obfuscated program, is usually
    responsible for de-obfuscating some or all of the remainder of the program. A
    very generic overview of the obfuscation process is shown in [Figure 21-1](ch21.html#generic_obfuscation_process
    "Figure 21-1. Generic obfuscation process").
  prefs: []
  type: TYPE_NORMAL
- en: '![Generic obfuscation process](httpatomoreillycomsourcenostarchimages854316.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-1. Generic obfuscation process
  prefs: []
  type: TYPE_NORMAL
- en: As shown, the input to the process is a program that a user wishes to obfuscate
    for some reason. In many cases, the input program is written using standard programming
    languages and build tools (editors, compilers, and the like) with little thought
    required about the obfuscation to come. The resulting executable file is fed into
    an obfuscation utility, which transforms the binary into a functionally equivalent,
    yet obfuscated, binary. As depicted, the obfuscation utility is responsible for
    obfuscating the original program’s code and data sections and adding additional
    code (a de-obfuscation stub) that performs the task of de-obfuscating the code
    and data before the original functionality can be accessed at runtime. The obfuscation
    utility also modifies the program headers to redirect the program entry point
    to the de-obfuscation stub, ensuring that execution begins with the de-obfuscation
    process. Following de-obfuscation, execution typically transfers to the entry
    point of the original program, which begins execution as if it had never been
    obfuscated at all.
  prefs: []
  type: TYPE_NORMAL
- en: This oversimplified process varies widely based on the obfuscation utility that
    is used to create the obfuscated binary. An ever-increasing number of utilities
    are available to handle the obfuscation process. Such utilities offer features
    ranging from compression to anti-disassembly and anti-debugging techniques. Examples
    include programs such as UPX^([[155](#ftn.CHP-21-FN-7)]) (compressor, also works
    with ELF), ASPack^([[156](#ftn.CHP-21-FN-8)]) (compressor), ASProtect (anti–reverse
    engineering by the makers of ASPack), and tElock^([[157](#ftn.CHP-21-FN-9)]) (compression
    and anti–reverse engineering) for Windows PE files, and Burneye^([[158](#ftn.CHP-21-FN-10)])
    (encryption) and Shiva^([[159](#ftn.CHP-21-FN-11)]) (encryption and anti-debugging)
    for Linux ELF binaries. The capabilities of obfuscation utilities have advanced
    to the point that some anti–reverse engineering tools such as WinLicense^([[160](#ftn.CHP-21-FN-12)])
    provide more integration throughout the entire build process, allowing programmers
    to integrate anti–reverse engineering features at every step, from source code
    through post-processing the compiled binary file.
  prefs: []
  type: TYPE_NORMAL
- en: A more recent evolution in the world of obfuscation programs involves wrapping
    the original executable with a virtual machine execution engine. Depending on
    the sophistication of the virtualizing obfuscator, the original machine code may
    never execute directly; instead that code is interpreted by a byte code–oriented
    virtual machine. Very sophisticated virtualizers are capable of generating unique
    virtual machine instances each time they run, making it difficult to create an
    all-purpose de-obfuscation algorithm to defeat them. VMProtect^([[161](#ftn.CHP-21-FN-13)])
    is one example of a virtualizing obfuscator. VMProtect was used to obfuscate the
    Clampi^([[162](#ftn.CHP-21-FN-14)]) trojan.
  prefs: []
  type: TYPE_NORMAL
- en: As with any offensive technology, defensive measures have been developed to
    counter many anti–reverse engineering tools. In most cases the goal of such tools
    is to recover the original, unprotected executable file (or a reasonable facsimile),
    which can then be analyzed using more traditional tools such as disassemblers
    and debuggers. One such tool designed to de-obfuscate Windows executables is called
    QuickUnpack.^([[163](#ftn.CHP-21-FN-15)]) QuickUnpack, like many other automated
    unpackers, operates by functioning as a debugger and allowing an obfuscated binary
    to execute through its de-obfuscation phase and then capturing the process image
    from memory. Beware that this type of tool actually runs potentially malicious
    programs in the hope of intercepting the execution of those programs after they
    have unpacked or de-obfuscated themselves but before they have a chance to do
    anything malicious. Thus, you should always execute such programs in a sandbox-type
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using a purely static analysis environment to analyze obfuscated code is a challenging
    task at best. Without being able to execute the de-obfuscation stub, some means
    of unpacking or decrypting the obfuscated portions of the binary must be employed
    before disassembly of the obfuscated code can begin. [Figure 21-2](ch21.html#ida_navigation_band_for_a_binary_packed
    "Figure 21-2. IDA navigation band for a binary packed using UPX") shows the layout
    of an executable that has been packed using the UPX packer. The only portion of
    the address space that IDA has identified as code is the thin stripe at ![](httpatomoreillycomsourcenostarchimages854061.png),
    which happens to be the UPX decompression stub.
  prefs: []
  type: TYPE_NORMAL
- en: '![IDA navigation band for a binary packed using UPX](httpatomoreillycomsourcenostarchimages854318.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-2. IDA navigation band for a binary packed using UPX
  prefs: []
  type: TYPE_NORMAL
- en: 'Examination of the contents of the address space would reveal empty space to
    the left of ![](httpatomoreillycomsourcenostarchimages854063.png) and apparently
    random data in the region between ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png). The random data is
    the result of the UPX compression process, and the job of the decompression stub
    is to unpack that data into the empty region at the left of the navigation band
    before finally transferring control to the unpacked code. Note that the unusual
    appearance of the navigation band is a potential tip-off that this binary has
    been obfuscated in some manner. In fact, a number of things typically stand out
    when viewing an obfuscated binary with IDA. Some potential tip-offs that a binary
    is obfuscated include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Very little code is highlighted in the navigation band.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very few functions are listed in the Functions window. Often only the `start`
    function will appear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very few imported functions are listed in the Imports window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very few legible strings appear in the Strings window (not opened by default).
    Often only the names of the few imported libraries and functions will be visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more program sections will be both writable and executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonstandard section names such as `UPX0` or `.shrink` are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SANDBOX ENVIRONMENTS
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a *sandbox environment* for reverse engineering is to allow you
    to execute a program in a manner that allows observation of the program’s behavior
    without allowing that behavior to adversely impact critical components of your
    reverse engineering platform. Sandbox environments are commonly constructed using
    platform virtualization software such asd VMware,^([[164](#ftn.CHP-21-FN-16)])
    but they may be constructed on dedicated systems that are capable of being restored
    to a known good state following the execution of any malware.
  prefs: []
  type: TYPE_NORMAL
- en: A common feature of sandbox systems is the fact that they are typically heavily
    instrumented in order to observe and collect information on the behavior of programs
    run within the sandbox. Collected data may include information on the file system
    activity of a program, on the registry activity of a (Windows) program, and about
    any networking activity generated by the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information presented in the navigation band can be correlated with the
    properties of each segment within the binary to determine whether the information
    presented in each display is consistent. The segments listing for this binary
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the entire range of addresses comprising segment `UPX0` ![](httpatomoreillycomsourcenostarchimages854061.png)
    and segment `UPX1` ![](httpatomoreillycomsourcenostarchimages854063.png) (`00401000-00409000`)
    is marked as executable (the `X` flag is set). Given this fact, we should expect
    to see the entire navigation band colorized to represent code. The fact that we
    do not, coupled with the fact that inspection reveals the entire range of `UPX0`
    to be empty, should be considered highly suspicious. Within IDA, the section header
    for `UPX0` contains the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Techniques for using IDA to perform the decompression operation in a static
    context (without actually executing the binary) are discussed in [Static De-obfuscation
    of Binaries Using IDA](ch21s03.html "Static De-obfuscation of Binaries Using IDA")
    in [Static De-obfuscation of Binaries Using IDA](ch21s03.html "Static De-obfuscation
    of Binaries Using IDA").
  prefs: []
  type: TYPE_NORMAL
- en: Imported Function Obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to avoid leaking information about potential actions that a binary
    may perform, an additional anti–static analysis technique is aimed at making it
    difficult to determine which shared libraries and library functions are used within
    an obfuscated binary. In most cases, it is possible to render tools such as `dumpbin`,
    `ldd`, and `objdump` ineffective for the purposes of listing library dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of such obfuscations on IDA is most obvious in the Imports window.
    The entire content of the Imports window for our earlier tElock example is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Only two external functions are referenced, `GetModulehandleA` (from *kernel32.dll*)
    and `MessageBoxA` (from *user32.dll*). Virtually nothing about the behavior of
    the program can be inferred from this short list. How then does such a program
    get anything useful accomplished? Here again the techniques are varied, but they
    essentially boil down to the fact that the program itself must load any additional
    libraries that it depends on, and once the libraries are loaded, the program must
    locate any required functions within those libraries. In most cases, these tasks
    are performed by the de-obfuscation stub prior to transferring control to the
    de-obfuscated program. The end goal is for the program’s import table to have
    been properly initialized, just as if the process had been performed by the operating
    system’s own loader.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows binaries, a simple approach is to use the `LoadLibrary` function
    to load required libraries by name and then perform function address lookups within
    each library using the `GetProcAddress` function. In order to use these functions,
    a program must be either explicitly linked to them or have an alternate means
    of looking them up. The Names listing for the tElock example does not include
    either of these functions, while the Names listing for the UPX example shown here
    includes both.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The actual UPX code responsible for rebuilding the import table is shown in
    [Example 21-1](ch21.html#import_table_reconstruction_in_upx "Example 21-1. Import
    table reconstruction in UPX").
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-1. Import table reconstruction in UPX
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This example contains an outer loop responsible for calling `LoadLibraryA`^([[165](#ftn.CHP-21-FN-17)])
    ![](httpatomoreillycomsourcenostarchimages854061.png) and an inner loop responsible
    for calling `GetProcAddress` ![](httpatomoreillycomsourcenostarchimages854063.png).
    Following each successful call to `GetProcAddress`, the newly retrieved function
    address is stored into the reconstructed import table ![](httpatomoreillycomsourcenostarchimages854093.png).
  prefs: []
  type: TYPE_NORMAL
- en: These loops are executed as the last portion of the UPX de-obfuscation stub,
    because each function takes string pointer parameters that point to either a library
    name or a function name, and the associated strings are held within the compressed
    data region to avoid detection by the `strings` utility. As a result, library
    loading in UPX cannot take place until the required strings have been decompressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the tElock example, a different problem presents itself. With
    only two imported functions, neither of which is `LoadLibraryA` or `GetProcAddress`,
    how can the tElock utility perform the function-resolution tasks that were performed
    by UPX? All Windows processes depend on *kernel32.dll*, which means that it is
    present in memory for all processes. If a program can locate *kernel32.dll*, a
    relatively straightforward process may be followed to locate any function within
    the DLL, including `LoadLibraryA` and `GetProcAddress`. As shown previously, with
    these two functions in hand, it is possible to load any additional libraries required
    by the process and locate all required functions within those libraries. In his
    paper “Understanding Windows Shellcode,”^([[166](#ftn.CHP-21-FN-18)]) Skape discusses
    techniques for doing exactly this. While tElock does not use the exact techniques
    detailed by Skape, there are many parallels, and the net effect is to obscure
    the details of the loading and linking process. Without carefully tracing the
    program’s instructions, it is extremely easy to overlook the loading of a library
    or the lookup of a function address. The following small code fragment illustrates
    the manner in which tElock attempts to locate the address of `LoadLibraryA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It is immediately obvious that several comparisons are taking place in rapid
    succession. What may not be immediately clear is the purpose of these comparisons.
    Reformatting the operands used in each comparison sheds a little light on the
    code, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Each hexadecimal constant is actually a sequence of four ASCII characters, which
    taken in order (recall that the x86 is a little-endian processor and we need to
    read the characters in reverse order) spell `LoadLibraryA`. If the three comparisons
    succeed, then tElock has located the export table entry for `LoadLibraryA`, and
    in a few short operations, the address of this function will be obtained and available
    for use in loading additional libraries. An interesting characteristic of tElock’s
    approach to function lookup is that it is somewhat resistant to strings analysis
    because the 4-byte constants embedded directly in the program’s instructions do
    not look like more standard, null-terminated strings and thus do not get included
    in strings lists generated by IDA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually reconstructing a program’s import table through careful analysis of
    the program’s code is made easier in the case of UPX and tElock because, ultimately,
    they both contain ASCII character data that we can use to determine exactly which
    libraries and which functions are being referenced. Skape’s paper details a function-resolution
    process in which no strings at all appear within the code. The basic idea discussed
    in the paper is to precompute a unique hash^([[167](#ftn.CHP-21-FN-19)]) value
    for the name of each function that you need to resolve. To resolve each function,
    a search is conducted through a library’s exported names table. Each name in the
    table is hashed, and the resulting hash is compared against the precomputed hash
    value for the desired function. If the hashes match, the desired function has
    been located, and you can easily find its address in the library’s export address
    table. In order to statically analyze binaries obfuscated in this manner, you
    need to understand the hashing algorithm used for each function name and apply
    that algorithm to all of the names exported by the library that the program is
    searching. With a complete table of hashes in hand, you will be able to do a simple
    lookup of each hash that you encounter in the program to determine which function
    the hash references.^([[168](#ftn.CHP-21-FN-20)]) A portion of such a table, generated
    for kernel32.dll, might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that the hash values are specific to the hash function being used within
    a particular binary and are likely to vary from one binary to another. Using this
    particular table, if the hash value `8A0FB5E2` ![](httpatomoreillycomsourcenostarchimages854061.png)
    was encountered within a program, we could quickly determine that the program
    was attempting to look up the address of the `GetProcAddress` function.
  prefs: []
  type: TYPE_NORMAL
- en: Skape’s use of hash values to resolve function names was originally developed
    and documented for use in exploit payloads for Windows vulnerabilities; however,
    hash values have been adopted for use in obfuscated programs as well. The WinLicense
    obfuscation utility is one example that makes use of such hashing techniques to
    disguise its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A final note on import tables is that, interestingly, IDA is sometimes able
    to offer you a clue that something is not quite right with a program’s import
    table. Obfuscated Windows binaries often have sufficiently altered import tables
    that IDA will notify you that something seems out of the ordinary with such a
    binary. [Figure 21-3](ch21.html#mangled_imports_segment_warning_dialog "Figure 21-3. Mangled
    imports segment warning dialog") shows the warning dialog that IDA displays in
    such cases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mangled imports segment warning dialog](httpatomoreillycomsourcenostarchimages854321.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-3. Mangled imports segment warning dialog
  prefs: []
  type: TYPE_NORMAL
- en: This dialog provides one of the earliest indications that a binary may have
    been obfuscated in some manner and should serve as a warning that the binary may
    be difficult to analyze. Thus, you should take care while analyzing the binary.
  prefs: []
  type: TYPE_NORMAL
- en: Targeted Attacks on Analysis Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This category of anti–reverse engineering capability is mentioned only because
    of its unique potential to hinder reverse engineering efforts. Most reverse engineering
    tools can be viewed as highly specialized parsers that process input data to provide
    some sort of summary information or detail display. As software, these tools are
    not immune to the same types of vulnerabilities that affect all other software.
    Specifically, incorrect handling of user-supplied data may, in some cases, lead
    to exploitable conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the techniques we have discussed thus far, programmers intent
    on preventing analysis of their software may opt for a more active form of anti–reverse
    engineering. By properly crafting input files, it may be possible to create a
    program that is both valid enough to execute properly and mal-formed enough to
    exploit a vulnerability in a reverse engineering tool. Such vulnerabilities, while
    uncommon, have been documented to include vulnerabilities in IDA.^([[169](#ftn.CHP-21-FN-21)])
    The goal of the attacker is to exploit the fact that a piece of malware is likely
    to get loaded into IDA at some point. At a minimum, the attacker may achieve a
    denial of service in which IDA always crashes before a database can be created;
    alternatively, the attacker may gain access to the analyst’s computer and associated
    network. Users concerned with this type of attack should consider performing all
    initial analysis tasks in a sandbox environment. For example, you might run a
    copy of IDA in a sandbox to create the initial database for all binaries. The
    initial database (which in theory is free from any malicious capability) can then
    be distributed to additional analysts, who need never touch the original binary
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[149](#CHP-21-FN-1)]) Shaun Clowes and Neel Mehta first introduced Shiva
    at CanSecWest in 2003\. See [http://www.cansecwest.com/core03/shiva.ppt](http://www.cansecwest.com/core03/shiva.ppt).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[150](#CHP-21-FN-2)]) The x86 `iret` instruction is used to return from an
    interrupt-handling routine. Interrupt-handling routines are most often found in
    kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[151](#CHP-21-FN-3)]) Think of a *semaphore* as a token that must be in your
    possession before you can enter a room to perform some action. While you hold
    the token, no other person may enter the room. When you have finished with your
    task in the room, you may leave and give the token to someone else, who may then
    enter the room and take advantage of the work you have done (without your knowledge
    because you are no longer in the room!). Semaphores are often used to enforce
    mutual exclusion locks around code or data in a program.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[152](#CHP-21-FN-4)]) For more information on Windows Structured Exception
    Handling (SEH), see [http://www.microsoft.com/msj/0197/exception/exception.aspx](http://www.microsoft.com/msj/0197/exception/exception.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[153](#CHP-21-FN-5)]) Windows configures the FS register to point to the
    base address of the current thread’s environment block (TEB). The first item (offset
    zero) in a TEB is the head of a linked list of pointers to exception handler functions,
    which are called in turn when an exception is raised in a process.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[154](#CHP-21-FN-6)]) In the x86, debug registers 0 through 7 (`Dr0` through
    `Dr7`) are used to control the use of hardware-assisted breakpoints. `Dr0` through
    `Dr3` are used to specify breakpoint addresses, while `Dr6` and `Dr7` are used
    to enable and disable specific hardware breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[155](#CHP-21-FN-7)]) See [http://upx.sourceforge.net/](http://upx.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[156](#CHP-21-FN-8)]) See [http://www.aspack.com/](http://www.aspack.com/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[157](#CHP-21-FN-9)]) See [http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[158](#CHP-21-FN-10)]) See [http://www.packetstormsecurity.org/groups/teso/indexdate.html](http://www.packetstormsecurity.org/groups/teso/indexdate.html).
  prefs: []
  type: TYPE_NORMAL
- en: '^([[159](#CHP-21-FN-11)]) See [http://www.cansecwest.com/core03/shiva.ppt](http://www.cansecwest.com/core03/shiva.ppt)
    (tool: [http://www.securiteam.com/tools/5XP041FA0U.html](http://www.securiteam.com/tools/5XP041FA0U.html).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[160](#CHP-21-FN-12)]) See [http://www.oreans.com/winlicense.php](http://www.oreans.com/winlicense.php).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[161](#CHP-21-FN-13)]) See [http://www.vmpsoft.com/](http://www.vmpsoft.com/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[162](#CHP-21-FN-14)]) See [http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi](http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[163](#CHP-21-FN-15)]) See [http://qunpack.ahteam.org/wp2/](http://qunpack.ahteam.org/wp2/)
    (Russian) or [http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack](http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[164](#CHP-21-FN-16)]) See [http://www.vmware.com/](http://www.vmware.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '^([[165](#CHP-21-FN-17)]) Many Windows functions that accept string arguments
    come in two versions: one that accepts ASCII strings and one that accepts Unicode
    strings. The ASCII versions of these functions carry an `A` suffix, while the
    Unicode versions carry a `W` suffix.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[166](#CHP-21-FN-18)]) See [http://www.hick.org/code/skape/papers/win32-shellcode.pdf](http://www.hick.org/code/skape/papers/win32-shellcode.pdf),
    specifically [Chapter 3](ch03.html "Chapter 3. IDA Pro Background"), “Shellcode
    Basics,” and section 3.3, “Resolving Symbol Addresses.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([[167](#CHP-21-FN-19)]) A *hash function* is a mathematical process that derives
    a fixed-size result (4 bytes, for example) from an arbitrary-sized input (such
    as a string).
  prefs: []
  type: TYPE_NORMAL
- en: '^([[168](#CHP-21-FN-20)]) Hex-Rays discusses IDA’s debugging capabilities to
    compute such hashes here: [http://www.hexblog.com/?p=93](http://www.hexblog.com/?p=93).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[169](#CHP-21-FN-21)]) See [http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115).
    More detail is available at [http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189](http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189).
  prefs: []
  type: TYPE_NORMAL
- en: Anti–Dynamic Analysis Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: None of the anti–static analysis techniques covered in the past few sections
    have any effect whatsoever on whether a program will actually execute or not.
    In fact, while they may make it difficult for you to comprehend the true behavior
    of a program using static analysis techniques alone, they can’t prevent the program
    from executing, or they would render a program useless from the start and therefore
    eliminate the need to analyze the program at all.
  prefs: []
  type: TYPE_NORMAL
- en: Given that a program must run in order for it to do any work, dynamic analysis
    aims to observe the behavior of a program in motion (while it is running) rather
    than observe the program at rest (using static analysis while the program is not
    running). In this section we briefly summarize some of the more common anti–dynamic
    analysis techniques. For the most part, these techniques have little effect on
    static analysis tools; however, where there is overlap, we will point this out.
    We will return to discuss the impact of many of these techniques on IDA’s integrated
    debugger beginning in [Chapter 24](ch24.html "Chapter 24. The IDA Debugger").
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common choices for configuring a sandbox environment is to make
    use of virtualization software, such as VMware, to provide an execution environment
    for malicious software (or, for that matter, any other software of interest).
    The advantage of such environments is that they typically offer checkpoint and
    rollback capabilities that facilitate rapid restoration of the sandbox to a known
    clean state. The primary disadvantage of using such environments as the foundation
    for a sandbox is the fact that it is fairly easy (especially on 32-bit x86 platforms)
    for a program to detect that it is running within a virtualized environment. Under
    the assumption that virtualization equates to observation, many programs that
    want to remain undetected simply choose to shut down once they determine that
    they are running within a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: The following list describes a few of the techniques that have been used by
    programs running in virtualized environments to determine that they are running
    within a virtual machine rather than on native hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detection of virtualization–specific software**'
  prefs: []
  type: TYPE_NORMAL
- en: Users often install helper applications within virtual machines to facilitate
    communications between a virtual machine and its host operating system or simply
    to improve performance within the virtual machine. The VMware Tools collection
    is one example of such software. The presence of such software is easily detected
    by programs running within the virtual machine. For example, when VMware Tools
    is installed into a Microsoft Windows virtual machine, it creates Windows registry
    entries that can be read by any program. VMware Tools is rarely required in order
    to run malware within a virtual environment and should not be installed so as
    to eliminate such trivially detectable traces of the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detection of virtualization–specific hardware**'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines make use of virtual hardware abstraction layers to provide
    the interface between the virtual machine and the host computer’s native hardware.
    Characteristics of the virtual hardware are often easily detectable by software
    running within the virtual machine. For example, VMware has been assigned its
    own organizationally unique identifiers (OUI)^([[170](#ftn.CHP-21-FN-22)]) for
    use with its virtualized network adapters. Observing a VMware-specific OUI is
    a good indication that a program is running within a virtual machine. Note that
    it is usually possible to modify the MAC address assigned to virtual network adapters
    using configuration options on the host computer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detection of virtual machine–specific behaviors**'
  prefs: []
  type: TYPE_NORMAL
- en: Some virtualization platforms contain backdoor-style communications channels
    to facilitate communications between a virtual machine and its host software.
    For example, the following five lines may be used to determine if you are running
    within a VMware virtual machine:^([[171](#ftn.CHP-21-FN-23)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The sequence will result in the EBX register containing the value `0x564D5868`
    if you are inside a virtual machine. If you are not within a virtual machine,
    the code will result in either an exception or no change to EBX, depending on
    the host operating system in use. This instruction sequence takes advantage of
    the fact that the x86 `in` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    is generally not used or allowed in user-space programs; however, within VMware,
    the instruction sequence can be used to test for the presence of the channel used
    by VMware guest operating systems to communicate with their host operating system.
    This channel is used by VMware Tools, for example, to facilitate the exchange
    of data (such as clipboard contents) between the host and guest operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detection of processor-specific behavioral changes**'
  prefs: []
  type: TYPE_NORMAL
- en: Perfect virtualization is a difficult thing to achieve. Ideally a program should
    not be able to detect any difference between a virtualized environment and native
    hardware. However, this is seldom the case. Joanna Rutkowska developed her redpill^([[172](#ftn.CHP-21-FN-24)])
    VMware-detection technique after observing behavioral differences between the
    operation of the x86 `sidt` instruction on native hardware and the same instruction
    executed within a virtual machine environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though it is not the first paper on the topic, “On the Cutting Edge: Thwarting
    Virtual Machine Detection” by Tom Liston and Ed Skoudis^([[173](#ftn.CHP-21-FN-25)])
    presents a nice overview of virtual machine–detection techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Instrumentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following creation of your sandbox environment and prior to executing any program
    you want to observe, you need to ensure that instrumentation is in place to properly
    collect and record information about the behavior of the program you are analyzing.
    A wide variety of tools exists for performing such monitoring tasks. Two widely
    used examples include Process Monitor,^([[174](#ftn.CHP-21-FN-26)]) from the Sysinternals
    group^([[175](#ftn.CHP-21-FN-27)]) at Microsoft, and Wireshark.^([[176](#ftn.CHP-21-FN-28)])
    Process Monitor is a utility capable of monitoring certain activities associated
    with any running Windows process, including accesses to the Windows registry and
    file system activity. Wireshark is a network packet capture and analysis tool
    often used to analyze the network traffic generated by malicious software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware authors with a sufficient level of paranoia may program their software
    to search for running instances of such monitoring programs. Techniques range
    from scanning the active process list for process names known to be associated
    with such monitoring software to scanning the title bar text for all active Windows
    applications to search for known strings. Deeper searches can be performed, with
    some software going so far as to search for specific characteristics associated
    with Windows GUI components used within certain instrumentation software. For
    example, the WinLicense obfuscation/protection program uses the following function
    call to attempt to determine whether the Filemon (a predecessor of Process Monitor)
    utility is currently executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `FindWindow` function is being used to search for a top-level
    application window based on the registered class name (`"FilemonClass"`) of the
    window rather than the window’s title. If a window of the requested class is located,
    then Filemon is assumed to be executing, and the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Debuggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving beyond simple observation of a program, the use of a debugger allows
    an analyst to take complete control of the execution of program that requires
    analyzing. A common use of a debugger with obfuscated programs is to run the obfuscated
    program just long enough to complete any decompression or decryption tasks and
    then utilize the debugger’s memory-access features to extract the de-obfuscated
    process image from memory. In most cases, standard static analysis tools and techniques
    can be used to complete the analysis of the extracted process image.
  prefs: []
  type: TYPE_NORMAL
- en: The authors of obfuscation utilities are well aware of such debugger-assisted
    de-obfuscation techniques, so they have developed measures to attempt to defeat
    the use of debuggers for execution of their obfuscated programs. Programs that
    detect the presence of a debugger often choose to terminate rather than proceed
    with any operations that might allow an analyst to more easily determine the behavior
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for detecting the presence of debuggers range from simple queries
    to the operating system via well-known API functions, such as the Windows `IsDebuggerPresent`
    function, to lower-level checks for memory or processor artifacts resulting from
    the use of a debugger. An example of the latter includes detecting that a processor’s
    trace (single-step) flag is set. Detection of specific debuggers is also possible
    in some cases. For example, SoftIce, a Windows kernel debugger, can be detected
    through the presence of the `"\\.\NTICE"` device, which is used to communicate
    with the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: As long as you know what to look for, there is nothing terribly tricky about
    trying to detect a debugger, and attempts to do so are easily observed during
    static analysis (unless anti–static analysis techniques are employed simultaneously).
    For more information on debugger detection, consult Nicolas Falliere’s article
    “Windows Anti-Debug Reference,”^([[177](#ftn.CHP-21-FN-29)]) which provides a
    comprehensive overview of Windows anti-debugging techniques.^([[178](#ftn.CHP-21-FN-30)])
    In addition, OpenRCE maintains an Anti Reverse Engineering Techniques Database,^([[179](#ftn.CHP-21-FN-31)])
    which contains a number of debugger-specific techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a debugger manages to remain undetectable, there are still a number of techniques
    available to thwart its use. These additional techniques attempt to confound the
    debugger by introducing spurious breakpoints, clearing hardware breakpoints, hindering
    disassembly to make selection of appropriate breakpoint addresses difficult, or
    preventing the debugger from attaching to a process in the first place. Many of
    the techniques discussed in Nicolas Falliere’s article are geared toward preventing
    debuggers from operating correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Intentionally generating exceptions is one means by which a program may attempt
    to hinder debugging. In most cases, an attached debugger will catch the exception,
    and the user of the debugger is faced with the task of analyzing why the exception
    occurred and whether to pass the exception along to the program being debugged.
    In the case of a software breakpoint such as the x86 `int 3`, it may be difficult
    to distinguish a software interrupt generated by the underlying program from one
    that results from an actual debugger breakpoint. This confusion is exactly the
    effect that is desired by the creator of the obfuscated program. In such cases,
    careful analysis of the disassembly listing to understand the true program flow
    is usually possible, though the level of effort for static analysis is raised
    somewhat.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding portions of a program in some manner has the dual effect of hindering
    static analysis because disassembly is not possible and of hindering debugging
    because placing breakpoints is difficult. Even if the start of each instruction
    is known, software breakpoints cannot be placed until the instructions have actually
    been decoded, as altering the instructions by inserting a software breakpoint
    is likely to result in a failed decryption of the obfuscated code and a resulting
    crash of the program when execution reaches the intended breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, some de-obfuscation routines compute checksum values over ranges
    of bytes within the process. If one or more software breakpoints have been set
    within the range over which a checksum is being computed, the resulting checksum
    will be incorrect, and the program is likely to abort.
  prefs: []
  type: TYPE_NORMAL
- en: The Shiva ELF obfuscation tool for Linux makes use of a technique called *mutual
    ptrace* to prevent the use of a debugger in analyzing Shiva’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: PROCESS TRACING
  prefs: []
  type: TYPE_NORMAL
- en: The *ptrace*, or process tracing, API is available on many Unix systems and
    provides a mechanism for one process to monitor and control the execution of another
    process. The GNU debugger (gdb) is one of the more well-known applications that
    makes use of the ptrace API. Using the ptrace API, a ptrace parent process may
    attach to and control the execution of a ptrace child process. In order to begin
    controlling a process, a parent process must first *attach* to the child process
    that it seeks to control. Once attached, the child process is stopped anytime
    it receives a signal, and the parent is notified of this fact via the POSIX `wait`
    function, at which point the parent may choose to alter or inspect the state of
    the child process before instructing the child process to continue execution.
    Once a parent process has attached to a child process, no other process may attach
    to the same child process until the tracing parent chooses to detach from the
    child process.
  prefs: []
  type: TYPE_NORMAL
- en: Shiva takes advantage of the fact that a process may be ptraced by only one
    other process at any given time. Early in its execution, the Shiva process forks
    to create a copy of itself. The original Shiva process immediately performs a
    ptrace attach operation on the newly forked child. The newly forked child process,
    in turn, immediately attaches to its parent process. If either attach operation
    fails, Shiva terminates under the assumption that another debugger is being used
    to monitor the Shiva process. If both operations succeed, then no other debugger
    can be used to attach to the running Shiva pair, and Shiva can continue to run
    without fear of being observed. While operating in this manner, either Shiva process
    may alter the state of the other, making it difficult to determine, using static
    analysis techniques, what the exact control flow path is through the Shiva binary.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[170](#CHP-21-FN-22)]) An *OUI* makes up the first three bytes of a network
    adapter’s factory-assigned MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[171](#CHP-21-FN-23)]) See [http://www.codeproject.com/KB/system/VmDetect.aspx](http://www.codeproject.com/KB/system/VmDetect.aspx)
    by Elias Bachaalany.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[172](#CHP-21-FN-24)]) See [http://www.invisiblethings.org/papers/redpill.html](http://www.invisiblethings.org/papers/redpill.html)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[173](#CHP-21-FN-25)]) See [http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf](http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[174](#CHP-21-FN-26)]) See [http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx](http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[175](#CHP-21-FN-27)]) See [http://technet.microsoft.com/en-us/sysinternals/default.aspx](http://technet.microsoft.com/en-us/sysinternals/default.aspx)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[176](#CHP-21-FN-28)]) See [http://www.wireshark.org/](http://www.wireshark.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[177](#CHP-21-FN-29)]) See [http://www.symantec.com/connect/articles/windows-anti-debug-reference/](http://www.symantec.com/connect/articles/windows-anti-debug-reference/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[178](#CHP-21-FN-30)]) See [http://pferrie.tripod.com/papers/unpackers.pdf/](http://pferrie.tripod.com/papers/unpackers.pdf/)
    by Peter Ferrie.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[179](#CHP-21-FN-31)]) See [http://www.openrce.org/reference_library/anti_reversing/](http://www.openrce.org/reference_library/anti_reversing/)
  prefs: []
  type: TYPE_NORMAL
- en: Static De-obfuscation of Binaries Using IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point you may be wondering how, given all of the anti–reverse engineering
    techniques available, it is possible to analyze software that a programmer is
    intent on keeping secret. Given that these techniques target both static analysis
    tools and dynamic analysis tools, what is the best approach to take in revealing
    a program’s hidden behavior? Unfortunately, there is no single solution that fits
    all cases equally well. In most cases, the solution depends on your skill set
    and the tools available to you. If your analysis tool of choice is a debugger,
    then you will need to develop strategies for circumventing debugger detection
    and prevention protections. If your preferred analysis tool is a disassembler,
    you will need to develop strategies for obtaining an accurate disassembly and,
    in cases in which self-modifying code is encountered, for mimicking the behavior
    of that code in order to properly update your disassembly listings.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will discuss two techniques for dealing with self-modifying
    code in a static analysis environment (that is, without executing the code). Static
    analysis may be your only option for cases in which you are unwilling (because
    of hostile code) or unable (because of a lack of hardware or appropriate sandbox
    environment) to analyze a program while controlling it with a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Script-Oriented De-obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because IDA may be used to disassemble binaries developed for a number of different
    CPU types, it is not uncommon to analyze a binary developed for an entirely different
    platform than the one on which you are running IDA. For example, you may be asked
    to analyze a Linux x86 binary even though you happen to run the Windows version
    of IDA, or you may be asked to analyze a MIPS or ARM binary even though IDA runs
    only on x86 platforms. In such cases you may not have access to dynamic analysis
    tools, such as debuggers, suitable for use in performing dynamic analysis on the
    binary you have been given. When such a binary has been obfuscated by encoding
    portions of the program, you may have no other option than to create an IDA script
    that will mimic the de-obfuscating stage of the program in order to properly decode
    the program and disassemble the decoded instructions and data.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like a daunting task. However, in many cases the decoding stages
    of an obfuscated program make use of only a small subset of a processor’s instruction
    set, so familiarizing yourself with the necessary operations may not require an
    understanding of the entire instruction set for the target CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15](ch15.html "Chapter 15. IDA Scripting") presented an algorithm
    for developing scripts that emulate the behavior of portions of a program. In
    the following example, we will utilize those steps to develop a simple IDC script
    to decode a program that has been encrypted with the Burneye ELF encryption tool.
    In our example program, execution begins with the instructions in [Example 21-2](ch21s03.html#burneye_startup_sequence_and_obfuscated
    "Example 21-2. Burneye startup sequence and obfuscated code").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-2. Burneye startup sequence and obfuscated code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The program begins by pushing the contents of memory location `05371008h` onto
    the stack ![](httpatomoreillycomsourcenostarchimages854061.png) before pushing
    the CPU flags ![](httpatomoreillycomsourcenostarchimages854063.png) and then pushing
    all CPU registers ![](httpatomoreillycomsourcenostarchimages854093.png). The purpose
    of these instructions is not immediately clear, so we simply file this information
    away for later. Next, the ECX register is loaded with the contents of memory location
    `5371000h` ![](httpatomoreillycomsourcenostarchimages854095.png). According to
    the algorithm presented in [Chapter 15](ch15.html "Chapter 15. IDA Scripting"),
    we need to declare a variable named `ecx` at this point and initialize it from
    memory using IDC’s `Dword` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Following an absolute jump, the program calls function `sub_5371048` ![](httpatomoreillycomsourcenostarchimages854099.png),
    which has the side effect of pushing address `05371087h` (the return address)
    onto the stack. Note that the disassembled instructions that follow the `call`
    instruction begin to make less and less sense. The `out` instruction ![](httpatomoreillycomsourcenostarchimages854101.png)
    is not generally encountered in user-space code, while IDA is unable to disassemble
    an instruction at address `053710B1h` ![](httpatomoreillycomsourcenostarchimages854103.png).
    These are both indications that something is not quite right with this binary
    (that and the fact that the Functions window lists only two functions).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, analysis needs to continue with function `sub_5371048`, which
    is shown in [Example 21-3](ch21s03.html#main_burneye_decoding_function "Example 21-3. Main
    Burneye decoding function").
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-3. Main Burneye decoding function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Closer inspection reveals that this is not a typical function in that it begins
    by immediately popping the return address off the stack into the ESI register
    ![](httpatomoreillycomsourcenostarchimages854061.png). Recalling that the saved
    return address was `05371087h`, and taking into account the initialization of
    EDI ![](httpatomoreillycomsourcenostarchimages854063.png), EBX ![](httpatomoreillycomsourcenostarchimages854093.png),
    and EDX ![](httpatomoreillycomsourcenostarchimages854095.png), our script grows
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Following these initializations, the function performs a test on the value contained
    in the EBX register ![](httpatomoreillycomsourcenostarchimages854099.png) before
    entering an outer loop ![](httpatomoreillycomsourcenostarchimages854101.png) and
    an inner loop ![](httpatomoreillycomsourcenostarchimages854103.png). The remaining
    logic of the function is captured in the following completed script. Within the
    script, comments are used to relate script actions to the corresponding actions
    in the preceding disassembly listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two minor points to raise with this example. First, the right shift
    operator (`>>`) in IDC performs signed shifts (meaning that the sign bit is replicated
    into the most significant bit), while the x86 `shr` and `shrd` instructions perform
    unsigned shifts. In order to emulate an unsigned right shift in IDC, we must clear
    all bits that have been shifted in from the left, as is done at ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png). The second point involves
    the choice of an appropriate data size and variable to properly implement the
    x86 `lodsb` (load string byte) and `stosb` (store string byte) instructions. These
    instructions write to (`lodsb`) and read from (`stosb`) the low-order 8 bits of
    the EAX register,^([[180](#ftn.CHP-21-FN-32)]) leaving the upper 24 bits unchanged.
    In IDC, there is no way to partition a variable into bit-sized portions other
    than using various bitwise operations to mask off and recombine portions of the
    variable. Specifically, in the case of the `lodsb` instruction, a more faithful
    emulation would read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This example first clears the low 8 bits of the EAX variable and then merges
    in the new value for the low 8 bits using an `OR` operation. In the Burn-eye decoding
    example, we make note of the fact that the entire EAX register is set to 8 at
    the beginning of each outer loop, which has the effect of zeroing the upper 24
    bits of EAX. As a result, we have elected to simplify our implementation of `lodsb`
    ![](httpatomoreillycomsourcenostarchimages854093.png) by ignoring the effect of
    the assignment on the upper 24 bits of EAX. No thought need be given to our implementation
    of `stosb` ![](httpatomoreillycomsourcenostarchimages854095.png), as the `PatchByte`
    function reads only from the low-order 8 bits of its input value (EAX in this
    case).
  prefs: []
  type: TYPE_NORMAL
- en: Following execution of the Burneye decoding IDC script, our database would reflect
    all of the changes that would normally not be observable until the obfuscated
    program was executed on a Linux system. If the de-obfuscation process was carried
    out properly, we are very likely to see many more legible strings within IDA’s
    Strings window. In order to observe this fact, you may need to refresh the Strings
    window content by closing and reopening the window or by right-clicking within
    the window, selecting Setup, and then clicking OK. Either action causes IDA to
    rescan the database for string content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remaining tasks include determining where the decoding function will return,
    given that it popped its return address in the very first instruction of the function,
    along with coaxing IDA to properly display the decoded byte values as instructions
    or data as appropriate. The Burneye decoding function ends with the following
    three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the function began by popping its own return address, which means
    that the remaining stack values were set up by the caller. The `popa` and `popf`
    instructions used here are the counterparts to the `pusha` and `pushf` instructions
    used at the beginning of Burneye’s start routine, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The net result is that the only value that remains on the stack is the one that
    was pushed at the first line of `start` ![](httpatomoreillycomsourcenostarchimages854061.png).
    It is to this location that the Burneye decoding routine returns, and it is at
    this location that further analysis of the Burneye protected binary would need
    to continue.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example may make it seem like writing a script to decode or unpack
    an obfuscated binary is a relatively easy thing to do. This is true in the case
    of Burneye, which does not use a terribly sophisticated initial obfuscation algorithm.
    The de-obfuscation stub of more sophisticated utilities such as ASPack and tElock
    would require somewhat more effort to implement using IDC.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages to script-based de-obfuscation include the fact that the binary being
    analyzed need never be executed and that it is possible to create a functional
    script without ever developing a complete understanding of the exact algorithm
    used to de-obfuscate the binary. This latter statement may seem counterintuitive,
    as it would seem that you would need to have a complete understanding of the de-obfuscation
    before you could emulate the algorithm using a script. Using the development process
    described here and in [Chapter 15](ch15.html "Chapter 15. IDA Scripting"), however,
    all you really need is a complete understanding of each CPU instruction involved
    in the de-obfuscation process. By faithfully implementing each CPU action using
    IDC and properly sequencing each action according to the disassembly listing,
    you will have a script that mimics the program’s actions even if you do not fully
    comprehend the higher-level algorithm that those actions, as a whole, implement.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of using a script-based approach include the fact that the scripts
    are rather fragile. If a de-obfuscation algorithm changes as a result of an upgrade
    to a de-obfuscation tool or through the use of alternate command-line settings
    supplied to the obfuscation tool, it is quite likely that a script that had been
    effective against that tool will need to be modified accordingly. For example,
    it is possible to develop a generic unpacking script for use with binaries packed
    using UPX,^([[181](#ftn.CHP-21-FN-33)]) but such a script requires constant tuning
    as UPX evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, scripted de-obfuscation suffers from the lack of a one-size-fits-all
    solution to de-obfuscation. There is no megascript capable of de-obfuscating all
    binaries. In a sense, scripted de-obfuscation suffers from many of the same shortcomings
    as signature-based intrusion-detection and antivirus systems. A new script must
    be developed for each new type of packer, and subtle changes in existing packers
    are likely to break existing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Emulation-Oriented De-obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A recurring theme encountered when creating scripts to perform de-obfuscation
    tasks is the need to emulate a CPU’s instruction set so the script behaves identically
    to the program being de-obfuscated. If we had an actual instruction emulator at
    our disposal, it might be possible to shift some or all of the work performed
    by these scripts over to the emulator and drastically reduce the amount of time
    required to de-obfuscate an IDA database. Emulators can fill the void between
    scripts and debuggers and have the advantage of being both more efficient than
    scripts and more flexible than debuggers. Using emulators, for example, it is
    possible to emulate a MIPS binary on an x86 platform or to emulate instructions
    from a Linux ELF binary on a Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: Emulators vary in sophistication. At a minimum, an emulator requires a stream
    of instruction bytes and sufficient memory to dedicate to stack operations and
    CPU registers. More sophisticated emulators may provide access to emulated hardware
    devices and operating system services.
  prefs: []
  type: TYPE_NORMAL
- en: IDA does not offer a native emulation facility,^([[182](#ftn.CHP-21-FN-34)])
    but its plug-in architecture is sophisticated enough to allow for the creation
    of emulator-type plug-ins. One possible implementation of such an emulator treats
    the IDA database as virtual memory that happens to contain the mapped binary we
    wish to emulate (courtesy of a loader module). All that is required of an emulator
    plug-in is to provide a small amount of memory to track the state of all CPU registers
    and some means to implement a stack. One approach implements a stack by creating
    a new segment within the database mapped to a location suitable for a stack. The
    emulator operates by reading bytes from the database location specified by the
    current value of the the emulator’s instruction pointer, decoding the retrieved
    values according to the emulated CPU’s instruction set specification, and updating
    any memory values affected by the decoded instruction. Possible updates might
    include modifying emulated register values, storing values into the emulated stack
    memory space, or patching modified values into the data or code sections within
    the IDA database as dictated by memory addresses generated by the decoded instruction.
    Control of the emulator could be similar to control of a debugger in that instructions
    could be stepped through, memory could be examined, registers could be modified,
    and breakpoints could be set. Memory contents within the program memory space
    would be displayed courtesy of IDA’s disassembly and hex views, while the emulator
    would be required to generate its own displays for the CPU registers.
  prefs: []
  type: TYPE_NORMAL
- en: Using such an emulator, an obfuscated program may be de-obfuscated by initiating
    emulation at the program entry point and stepping through the instructions that
    constitute the de-obfuscation phase of the program. Because the emulator utilizes
    the database as its backing memory, all self-modifications are reflected immediately
    as changes in the database. By the time the de-obfuscation routine has completed,
    the database has been transformed into the correct de-obfuscated version of the
    program, just as if the program had been running under debugger control. An immediate
    advantage of emulation over debugging is that potentially malicious code is never
    actually executed by an emulator, whereas debugger-assisted de-obfuscation must
    allow at least some portion of the malicious program to execute in order to obtain
    the de-obfuscated version of the program.
  prefs: []
  type: TYPE_NORMAL
- en: The ida-x86emu (x86emu) plug-in is an example of an emulator plug-in that is
    designed to offer emulation of the x86 instruction set. The plug-in is open source
    and builds with all versions of the IDA SDK from 4.9 onward. Binary versions of
    the plug-in compiled for all versions of IDA are included with the x86emu distribution.
    The plug-in is designed for use with either the Windows GUI version or the Qt
    version of IDA and includes build scripts, which allow the plug-in to be built
    using either MinGW (g++/make) or Microsoft (Visual Studio 2008) tools. The Qt
    version of the plug-in is also compatible with the Linux and OS X versions of
    IDA. Other than the appropriate SDK for your version of IDA, the plug-in has no
    other dependencies. The plug-in is installed by copying the compiled plug-in binary
    (*x86emu.plw/x86emu_qt.plw*) into *<IDADIR>/plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: No plug-in configuration is required, and the emulator is activated using the
    alt-F8 key sequence by default. The plug-in may be activated only for binaries
    that make use of the x86 processor, and the plug-in may be used with binaries
    of any file type, such as PE, ELF, and Mach-O. The plug-in may be built from source
    using the tools (Visual Studio or MinGW’s gcc and make) discussed in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture").
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | ida-x86emu |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Chris Eagle |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Source for SDK v6.1 and binaries for all versions of IDA
    from 5.0, including IDA Freeware. Source is backward compatible to SDK version
    4.9. |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Embedded x86 instruction emulator for IDA |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://www.idabook.com/ida-x86emu](http://www.idabook.com/ida-x86emu)
    |'
  prefs: []
  type: TYPE_TB
- en: x86emu Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the x86emu plug-in is activated, the plug-in control dialog shown in [Figure 21-4](ch21s03.html#x86emu_emulator_control_dialog
    "Figure 21-4. x86emu emulator control dialog") is displayed. The basic display
    shows register values and provides button controls used to perform simple emulation
    tasks such as stepping the emulator or modifying data values.
  prefs: []
  type: TYPE_NORMAL
- en: '![x86emu emulator control dialog](httpatomoreillycomsourcenostarchimages854324.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-4. x86emu emulator control dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon initial activation, the plug-in carries out a number of additional actions.
    For all file types, the emulator creates new database segments named `.stack`
    and `.heap` in order to provide runtime memory support for emulated program operations.
    The first time the plug-in is activated within a particular binary, the current
    cursor location is used to initialize the instruction pointer (`EIP`). For Windows
    PE binaries, the plug-in performs the following additional tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an additional program segment named `.headers`, rereads the input binary
    file, and then loads the MS-DOS and PE header bytes into the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocates memory to emulate a thread environment block (TEB) and a process environment
    block (PEB). These structures are populated with reasonable values in an attempt
    to convince the program being emulated that it is running within an actual Windows
    environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assigns reasonable values to the x86 segment registers and configures a fake
    interrupt descriptor table in order to provide a minimal exception-handling capability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempts to locate all DLLs referenced in the PE file’s import directory. For
    each such DLL that is found, the emulator creates additional segments within the
    database and loads the DLL’s headers and export directory. The binary’s import
    table is then populated with function addresses derived from the loaded DLL information.
    Note that no code from any of the imported DLLs is loaded into the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current state of the plug-in (register values) is saved in a netnode each
    time the database is saved or closed. Additional memory state such as stack and
    heap values is saved as well because these values are stored within dedicated
    segments in the database. Upon subsequent activation, the emulator state is restored
    from existing netnode data.
  prefs: []
  type: TYPE_NORMAL
- en: Basic x86emu Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The emulator control dialog is intended to provide capabilities similar to those
    of a very basic debugger. CPU register contents may be altered by entering a new
    value into the desired register’s edit box.
  prefs: []
  type: TYPE_NORMAL
- en: The Step button is used to emulate a single instruction. A single instruction
    is emulated by reading one or more bytes from the database location specified
    by the EIP register and carrying out any actions specified by the instruction
    bytes. Where required, register display values are updated to reflect changes
    resulting from the emulation of the current instruction. Each time the Step button
    is clicked, the emulator ensures that the bytes at the address specified by EIP
    are displayed as code (rather than data). This feature helps defeat any desynchronization
    attempts that may occur within the instruction stream. In addition, the emulator
    jumps the disassembly display window to the location specified by EIP so that
    the display tracks along with each emulated instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The Run To Cursor button may be used to emulate an entire sequence of instructions
    at one time. Emulation continues from the current EIP location and does not stop
    until a breakpoint is reached or EIP is equal to the current cursor location.
    The emulator recognizes breakpoints set via IDA’s debugger interface (right-click
    the desired address and select **Add breakpoint**) or breakpoints set via the
    emulator’s own breakpoint interface, Emulate ▸ Set Breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: x86EMU BREAKPOINTS
  prefs: []
  type: TYPE_NORMAL
- en: The emulator does not make use of hardware debug registers or software interrupts
    such as the `int 3` instruction. Instead, the emulator maintains an internal list
    of breakpoints against which the emulated instruction pointer is compared prior
    to emulating each instruction. While this may seem inefficient, it is no more
    inefficient than emulation in general, and it offers the advantage that emulator
    breakpoints are undetectable, and unalterable, by the program being emulated.
  prefs: []
  type: TYPE_NORMAL
- en: Once Run To Cursor has been selected, the emulator does not pause to reformat
    the disassembly for each fetched instruction; instead it formats only the first
    and last instructions executed. For long instruction sequences, the overhead associated
    with reformatting the disassembly at each instruction would result in intolerably
    slow performance of the emulator. You should use the Run To Cursor command very
    carefully, as control of the emulator (and IDA) will not be regained until EIP
    reaches the cursor location. If, for any reason, execution never hits a breakpoint
    or fails to reach the cursor location, you may be required to forcibly terminate
    IDA, potentially losing valuable work.
  prefs: []
  type: TYPE_NORMAL
- en: The Skip button is used to advance the emulator by exactly one instruction without
    emulating that instruction. One potential use of the Skip command is to skip over
    a conditional jump in order to reach a specific block of code regardless of the
    state of any condition flags. Skip is also useful for skipping over calls to imported
    library functions whose code is not available for emulation. Should you elect
    to skip over a function call, make certain that you update the database to reflect
    any changes that the function would have made. Examples of such changes include
    modifying the value of EAX to reflect the desired function return value or populating
    a buffer whose address was passed to the function. Additionally, if the skipped
    function uses the `stdcall` calling convention, you should also be careful to
    manually adjust ESP according to the number of bytes that the skipped function
    would have cleared from the stack upon return.
  prefs: []
  type: TYPE_NORMAL
- en: The Jump To Cursor button causes EIP to be updated with the address of the current
    cursor location. This feature may be used to skip entire sections of code or to
    follow a conditional jump when the state of the CPU flags may not cause the jump
    to be taken otherwise. Keep in mind that jumping around within a function may
    have consequences on stack layout (if you skip over a push or stack pointer adjustment,
    for example), resulting in unexpected behaviors. Note that it is not necessarily
    the intention of the emulator that emulation begins with the entry point of a
    program. It is entirely possible to use the emulator to emulate a single function
    within a binary in order to study the behavior of that function. This is one of
    the motivations behind the inclusion of the Jump to Cursor button, to allow easy
    redirection of your emulation efforts within a binary.
  prefs: []
  type: TYPE_NORMAL
- en: The Run button is similar in functionality to the Run To Cursor button; however,
    it is more dangerous in that execution continues until a breakpoint is reached.
    You should be absolutely certain that one of your break-points will be reached
    if you elect to use this command.
  prefs: []
  type: TYPE_NORMAL
- en: The Segments button provides access to configuration for x86 segment registers
    and segment base addresses. [Figure 21-5](ch21s03.html#x86emu_segment_register_configuration
    "Figure 21-5. x86emu segment register configuration") shows the resulting dialog
    used to alter segment-related values.
  prefs: []
  type: TYPE_NORMAL
- en: '![x86emu segment register configuration](httpatomoreillycomsourcenostarchimages854327.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-5. x86emu segment register configuration
  prefs: []
  type: TYPE_NORMAL
- en: While the emulator’s address computations honor the supplied base values, the
    emulator does not currently provide a complete emulation of the x86 global descriptor
    table (GDT).
  prefs: []
  type: TYPE_NORMAL
- en: The Set Memory button provides access to a basic memory modification dialog,
    as shown in [Figure 21-6](ch21s03.html#x86emu_memory_modification_dialog "Figure 21-6. x86emu
    memory modification dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![x86emu memory modification dialog](httpatomoreillycomsourcenostarchimages854330.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-6. x86emu memory modification dialog
  prefs: []
  type: TYPE_NORMAL
- en: This dialog is essentially a wrapper around some of the SDK `Patch`*`XXX`* functions.
    The type of data to be inserted into the database is selected via the provided
    radio buttons, while the actual data is entered into the provided edit control.
    If the Load from file radio button is selected, the user is presented with a standard
    file-open dialog to select a file whose content is transferred into the database
    beginning at the specified address.
  prefs: []
  type: TYPE_NORMAL
- en: The Push Data button is used to place data values onto the top of the emulated
    program stack. The resulting dialog, shown in [Figure 21-7](ch21s03.html#x86emu_stack_data_dialog
    "Figure 21-7. x86emu stack data dialog"), may be used to specify one or more data
    items that will be pushed onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![x86emu stack data dialog](httpatomoreillycomsourcenostarchimages854333.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-7. x86emu stack data dialog
  prefs: []
  type: TYPE_NORMAL
- en: The emulator currently accepts only numeric data. Supplied values are pushed,
    as 4-byte quantities, onto the emulation stack in right-to-left order as if they
    were parameters to a function call. The value of the stack pointer is adjusted
    according to the number of values pushed onto the stack. The intended use of this
    dialog is to configure function parameters prior to jumping directly to the function
    to be emulated. This allows a function to be emulated without requiring users
    to find an actual execution path to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Emulator-Assisted De-obfuscation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point we are ready to discuss the use of x86emu as a de-obfuscation
    tool. We begin by returning to the Burneye example for which we developed an entire
    IDC script. Assuming that we have no prior knowledge of the Burn-eye decoding
    algorithm, de-obfuscation would proceed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Burneye protected binary. The cursor should be automatically positioned
    at the `start` entry point. Activate the emulator (alt-F8). [Figure 21-4](ch21s03.html#x86emu_emulator_control_dialog
    "Figure 21-4. x86emu emulator control dialog") shows the resulting state of the
    emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin stepping the emulator, paying close attention to the instructions that
    are about to be emulated. After six steps, the emulator arrives at function `sub_5371048`
    (see [Example 21-3](ch21s03.html#main_burneye_decoding_function "Example 21-3. Main
    Burneye decoding function")).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function appears to be fairly well structured. We could choose to step
    the emulator for a while to obtain a better sense of the flow of execution, or
    we could choose to study the function for a while and determine if it is safe
    to position the cursor at the function’s `return` statement and click Run To Cursor.
    Opting for the latter, we position the cursor at address `05371081h` and click
    **Run To Cursor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point the de-obfuscation is complete. Stepping the emulator two more
    times executes the `return` statement, returning the the newly de-obfuscated code,
    and causes IDA to reformat the de-obfuscated bytes as instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting de-obfuscated code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Comparing this listing to that of [Example 21-2](ch21s03.html#burneye_startup_sequence_and_obfuscated
    "Example 21-2. Burneye startup sequence and obfuscated code"), it is clear that
    the instructions have changed as a result of the de-obfuscation process. Following
    the initial de-obfuscation, execution of the program resumes with the `pushf`
    instruction ![](httpatomoreillycomsourcenostarchimages854061.png) at `loc_5371090`.
  prefs: []
  type: TYPE_NORMAL
- en: Emulator-assisted de-obfuscation is clearly easier than the script-oriented
    de-obfuscation process followed earlier. Time spent developing the emulator approach
    pays off with a highly flexible de-obfuscation alternative, whereas time spent
    developing a Burneye-specific script pays off in a very specialized script that
    is of little use in other de-obfuscation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the Burneye-protected binary in the previous example was a Linux
    ELF binary, x86emu has no problems emulating the instructions within the binary
    because they are all x86 instructions, regardless of the operating system and
    file type that they were taken from. x86emu can be used just as easily on a Windows
    PE binary, such as the UPX example discussed earlier in this chapter. Because
    of the fact that the overwhelming majority of obfuscated malware in existence
    today is targeted at the Windows platform, x86emu contains many features specific
    to Windows PE binaries (as detailed earlier).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the emulator to uncompress a UPX binary is very straightforward. The
    emulator should be launched with the cursor positioned on the program entry point
    (`start`). Next, the cursor can be moved to the first instruction of the UPX import
    table, rebuilding loops (address `0040886Ch` in [Example 21-1](ch21.html#import_table_reconstruction_in_upx
    "Example 21-1. Import table reconstruction in UPX")), and the emulator can be
    allowed to run using the Run To Cursor command. At this point, the binary has
    been unpacked, and the Strings window can be used to view all of the unpacked
    library and function names that will be used by UPX to build the program’s import
    tables. If the emulator is stepped through the code of [Example 21-1](ch21.html#import_table_reconstruction_in_upx
    "Example 21-1. Import table reconstruction in UPX"), the following function call
    will eventually be encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Instructions of this sort can be dangerous to emulate, as it is not immediately
    apparent where the instruction may lead (meaning that the destination address
    of the `call` instruction is not obvious). In general, function calls can lead
    to one of two places: a function within the program’s code (`.text`) segment or
    a function within a shared library being used by the program. Whenever a `call`
    instruction is encountered, the emulator determines whether the target address
    lies within the virtual address space of the file being analyzed or whether the
    target address correlates to a function that is being exported by one of the libraries
    that the binary has loaded. Recall that for PE binaries the emulator loads the
    export dictionaries of all libraries loaded by the binary being analyzed. When
    the emulator determines that the target address of a call instruction lies outside
    the bounds of the binary, the emulator scans the export tables that were loaded
    into the database in order to determine which library function is being called.
    For Windows PE files, the emulator contains emulated implementations of the functions
    listed in [Table 21-1](ch21s03.html#functions_emulated_by_x86emu "Table 21-1. Functions
    Emulated by x86emu").'
  prefs: []
  type: TYPE_NORMAL
- en: When the emulator determines that one of these functions has been called, it
    reads any parameters from the program stack and either carries out the same actions
    that the actual function would carry out if the program were actually running
    or performs some minimal action and generates a return value that will appear
    to be correct from the perspective of the emulated program. In the case of `stdcall`
    functions, the emulator properly removes any stack arguments prior to completing
    the emulated function.
  prefs: []
  type: TYPE_NORMAL
- en: Table 21-1. Functions Emulated by x86emu
  prefs: []
  type: TYPE_NORMAL
- en: '| `CheckRemoteDebuggerPresent` | `GetTickCount` | `LocalFree` | `VirtualAlloc`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CreateThread` | `GetVersion` | `NtQuerySystemInformation` | `VirtualFree`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GetCurrentThreadId` | `HeapAlloc` | `NtQueryInformationProcess` | `calloc`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GetCurrentProcess` | `HeapCreate` | `NtSetInformationThread` | `free` |'
  prefs: []
  type: TYPE_TB
- en: '| `GetCurrentProcessId` | `HeapDestroy` | `RtlAllocateHeap` | `lstrcat` |'
  prefs: []
  type: TYPE_TB
- en: '| `GetModuleHandleA` | `HeapFree` | `TlsAlloc` | `lstrcpy` |'
  prefs: []
  type: TYPE_TB
- en: '| `GetProcAddress` | `IsDebuggerPresent` | `TlsFree` | `lstrlen` |'
  prefs: []
  type: TYPE_TB
- en: '| `GetProcessHeap` | `LoadLibraryA` | `TlsGetValue` | `malloc` |'
  prefs: []
  type: TYPE_TB
- en: '| `GetThreadContext` | `LocalAlloc` | `TlsSetValue` | `realloc` |'
  prefs: []
  type: TYPE_TB
- en: Emulated behavior for the heap-related functions causes the emulator to manipulate
    its internal heap implementation (backed by the `.heap` section) and return a
    value appropriate to the function being emulated. For example, the value returned
    by the emulated version of `HeapAlloc` is an address that is suitable for the
    emulated program to write data to. When the emulated version of `VirtualAlloc`
    is called, a new section is created in the database to represent the newly mapped
    virtual address space. The emulated version of `IsDebuggerPresent` always returns
    false. When emulating `LoadLibraryA`, the emulator extracts the name of the library
    being loaded by examining the stack arguments provided to `LoadLibraryA`. The
    emulator then attempts to open the named library on the local system so that library’s
    export table can be loaded into the database, and an appropriate library handle^([[183](#ftn.CHP-21-FN-35)])
    value is returned to the caller. When a call to `GetProcAddress` is intercepted,
    the emulator examines arguments on the stack to determine which shared library
    is being referenced; then the emulator parses the library’s export table in order
    to compute the proper memory address of the requested function, which is then
    returned to the caller. Calls to `LoadLibraryA` and `GetProcAddress` are noted
    in the IDA Output window.
  prefs: []
  type: TYPE_NORMAL
- en: When a function for which x86emu has no internal emulation is called, a dialog
    similar to the one shown in [Figure 21-8](ch21s03.html#x86emu_library_function_dialog
    "Figure 21-8. x86emu library function dialog") is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the name of the function being called, the emulator queries IDA’s type
    library information to obtain the number and types of parameters required by the
    function. The emulator then digs into the program stack to display all of the
    arguments that have been passed to the function, along with the type of the argument
    and the formal parameter name of the argument. Argument types and names are displayed
    only when type information is available from IDA. The dialog also offers the user
    a chance to specify a return value, as well as the opportunity to specify the
    calling convention used by the function (this information may be available from
    IDA). When the `stdcall` calling convention is selected, the user should indicate
    how many arguments (not bytes) should be removed from the stack when the call
    completes. This information is required in order for the emulator to maintain
    the integrity of the execution stack across emulated function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![x86emu library function dialog](httpatomoreillycomsourcenostarchimages854336.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-8. x86emu library function dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the UPX de-obfuscation example, and allowing the emulator to complete
    the import table reconstruction loops, we would find that the emulator generates
    output such as the following in IDA’s Output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This output provides a record of the libraries that the obfuscated binary is
    loading and the functions within those libraries that the obfuscated program is
    resolving.^([[184](#ftn.CHP-21-FN-36)]) When function addresses are looked up
    in this manner, they are often saved in an array (this array is the program’s
    import table) for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fundamental problem with de-obfuscated programs is that they lack the symbol
    table information that is usually present in un-obfuscated binaries. When a binary’s
    import table is intact, IDA’s PE loader names each entry in the import table according
    to the name of the functions whose address it will contain at runtime. When an
    obfuscated binary is encountered, it is useful to apply function names to each
    location in which a function address is stored. In the case of UPX, the following
    lines from [Example 21-1](ch21.html#import_table_reconstruction_in_upx "Example 21-1. Import
    table reconstruction in UPX") show how function addresses are saved into memory
    with each pass through the function lookup loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The instruction at address `004088A1h` ![](httpatomoreillycomsourcenostarchimages854061.png)
    is responsible for storing function addresses into the import table as it is reconstructed.
    x86emu provides an automated facility for naming each import table entry provided
    that an instruction such as this can be identified. The emulator terms such an
    instruction an *import address save point*, and you may designate an address as
    such using the Emulate ▸ Windows ▸ Set Import Address Save Point menu option.
    This designation must be made before the instruction is emulated in order for
    this functionality to work. Following designation, each time the instruction is
    emulated, the emulator will perform a lookup to determine what function is referenced
    by the data being written and then name the address being written using the name
    of the imported function. In the UPX example, making no effort to clean up the
    import table would yield the (partial) import table shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: However, the automated naming that is performed when an import address save
    point is designated yields the following automatically generated (partial) import
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With the import table reconstructed in this manner, IDA is able to properly
    annotate calls to library functions using parameter-type information extracted
    from its type libraries, and the overall quality of the disassembly is significantly
    enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: Additional x86emu Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The emulator contains several additional features that you may find useful.
    The following list details some of these capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '| **File** ▸ **Dump** This menu option allows the user to specify a range of
    database addresses to be dumped to a file. By default, the range extends from
    the current cursor location to the maximum virtual address present in the database.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **File** ▸ **Dump Embedded PE** Many malware programs contain embedded executables,
    which they install on target systems. This menu option looks for a valid PE file
    at the current cursor position, parses the file’s headers to determine the size
    of the file, and then extracts the bytes from the database to a saved file. |'
  prefs: []
  type: TYPE_TB
- en: '| **View** ▸ **Enumerate Heap** This menu option causes the emulator to dump
    a list of allocated heap blocks to the Output window, as shown here: |'
  prefs: []
  type: TYPE_TB
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '| **Emulate** ▸ **Switch Thread** When emulating within a Windows PE file,
    x86emu traps calls to the `CreateThread` function and allocates additional resources
    to manage a new thread. Because the emulator has no scheduler of its own, you
    must use this menu option if you want to switch among multiple threads. |'
  prefs: []
  type: TYPE_TB
- en: '| **Functions** ▸ **Allocate Heap Block** This menu option allows the user
    to reserve a block of memory within the emulation heap. The user is asked for
    the size of the block to reserve. The address of the newly reserved block is reported
    to the user. This feature is useful when scratch space is required during emulation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Functions** ▸ **Allocate Stack Block** This menu option allows the user
    to reserve a block of memory within the emulation stack. It behaves in a manner
    similar to Functions ▸ Allocate Heap Block. |'
  prefs: []
  type: TYPE_TB
- en: x86emu and Anti-debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the emulator is not intended to be used a debugger, it must simulate a
    runtime environment for the program being emulated. In order to successfully emulate
    many obfuscated binaries, the emulator must not fall victim to active anti-debugging
    techniques. Several features of the emulator have been designed with anti-debugging
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: One anti-debugging technique measures time intervals, using the x86 `rdtsc`
    instruction, to ensure that a program has not been paused by a debugger. The `rdtsc`
    instruction is used to read the value of an internal *time stamp counter (TSC)*
    and returns a 64-bit value representing the number of clock ticks since the processor
    was last reset. The rate at which the TSC increments varies among CPU types but
    is roughly once per internal CPU clock cycle. Debuggers cannot stop the TSC from
    incrementing, and therefore a process can determine that it has been stopped for
    an excessive amount of time by measuring the difference in the TSC between two
    successive invocations of `rdtsc`. x86emu maintains an internal TSC that it increments
    with each emulated instruction. Because the emulated TSC is affected only by emulated
    instructions, it does not matter how much actual time elapses between uses of
    `rdtsc`. In such cases, the difference in observed values will always be roughly
    proportional to the number of instructions that were emulated between invocations
    of `rdtsc` and should always be small enough to convince the emulated program
    that no debugger is attached.
  prefs: []
  type: TYPE_NORMAL
- en: The intentional use of exceptions is another anti-debugging technique that must
    be handled by the emulator. The emulator contains very basic capabilities to mimic
    the behavior of the Windows structured exception handling (SEH) process. When
    the emulated program is a Windows PE binary, the emulator responds to an exception
    or software interrupt by constructing an SEH `CONTEXT` structure, locating the
    current exception handler by walking the exception handler list via `fs:[0]`,
    and transferring control to the installed exception handler. When the exception
    handler returns, the emulator restores the CPU state from the `CONTEXT` structure
    (which may have been manipulated within the exception handler).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, x86emu emulates the behavior of the x86 hardware-debug registers but
    does not make use of those registers in order to set breakpoints within an emulated
    program. As discussed earlier, the emulator maintains an internal list of user-specified
    breakpoints that it scans prior to executing each instruction. Any manipulation
    of the debug registers within a Windows exception handler will not interfere with
    the operation of the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[180](#CHP-21-FN-32)]) The low-order 8 bits of the EAX register are also
    referred to as the AL register.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[181](#CHP-21-FN-33)]) See [http://www.idabook.com/examples/chapter21/](http://www.idabook.com/examples/chapter21/)
    for one such example.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[182](#CHP-21-FN-34)]) IDA does ship with a plug-in capable of interfacing
    with open source Bochs emulator via IDA’s debugging interface. Please refer to
    [Chapter 24](ch24.html "Chapter 24. The IDA Debugger") through [Chapter 26](ch26.html
    "Chapter 26. Additional Debugger Features") for more information.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[183](#CHP-21-FN-35)]) A Windows library handle uniquely identifies a library
    within a Windows process. A *library handle* is actually the base address at which
    the library is loaded into memory.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[184](#CHP-21-FN-36)]) Once a program has used `GetProcAddress` to find the
    address of a function, the program may call that function anytime it wishes using
    the returned address. Looking up function addresses in this manner eliminates
    the need to explicitly link to the functions at build time and reduces the amount
    of information that can be extracted by static analysis tools such as dumpbin.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Machine-Based Obfuscation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mentioned earlier in this chapter (in [Opcode Obfuscation](ch21.html#opcode_obfuscation
    "Opcode Obfuscation") in [Opcode Obfuscation](ch21.html#opcode_obfuscation "Opcode
    Obfuscation")), some of the most sophisticated obfuscators reimplement the program
    they receive as input, using a custom byte code and associated virtual machine.
    When confronting a binary obfuscated in this manner, the only native code that
    you might see would be the virtual machine. Assuming you recognize that you are
    looking at a software virtual machine, developing a complete understanding of
    all of this code generally fails to reveal the true purpose of the obfuscated
    program. This is because the behavior of the program remains buried in the embedded
    byte code that the virtual machine must interpret. To fully understand the program,
    you must, first, locate all of the embedded byte code and, second, reverse engineer
    the instruction set of the virtual machine so you can properly interpret the meaning
    of that byte code.
  prefs: []
  type: TYPE_NORMAL
- en: By way of comparison, imagine that you knew nothing whatsoever about Java, and
    someone handed you a Java virtual machine and a *.class* file containing compiled
    byte code and asked you what they did. Lacking any documentation, you could make
    little sense of the byte code file, and you would need to fully reverse the virtual
    machine to learn both the structure of a *.class* file and how to interpret its
    contents. With an understanding of the byte code machine language, you could then
    proceed to understanding the *.class* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'VMProtect is an example of a commercial product that utilizes very sophisticated
    virtual machine-based obfuscation techniques. As more of an academic exercise,
    TheHyper’s HyperUnpackMe2 challenge binary is a fairly straightforward example
    of the use of virtual machines in obfuscation, the primary challenge being to
    locate the virtual machine’s embedded byte code program and determine the meaning
    of each byte code. In his article on OpenRCE describing HyperUnpackMe2,^([[185](#ftn.CHP-21-FN-37)])
    Rolf Rolles’s approach was to fully comprehend the virtual machine in order to
    build a processor module capable of disassembling its byte code. The processor
    module then allowed him to disassemble the byte code embedded within the challenge
    binary. A minor limitation to this approach is that it allows you to view either
    the x86 code within HyperUnpackme2 (using IDA’s x86 module) or the virtual machine
    code (using Rolle’s processor module) but not both at the same time. This obligates
    you to create two different databases, each using a different processor module.
    An alternative approach takes advantage of the ability to customize existing processor
    modules (see [Customizing Existing Processors](ch19s05.html "Customizing Existing
    Processors") in [Customizing Existing Processors](ch19s05.html "Customizing Existing
    Processors")) through the use of plug-ins, effectively allowing you to extend
    an instruction set to include all of the instructions of an embedded virtual machine.
    Applying this approach to HyperUnpackMe2 allows us to view x86 code and virtual
    machine code together in a single database, as shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, the code beginning at ![](httpatomoreillycomsourcenostarchimages854061.png)
    is disassembled as HyperUnpackMe2 byte code, while the code that follows at ![](httpatomoreillycomsourcenostarchimages854063.png)
    is displayed as x86 code.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to simultaneously display native code and byte code has been anticipated
    by Hex-Rays, which introduced custom datatypes and formats in IDA 5.7\. Custom
    data formats are useful when IDA’s built-in formatting options fail to meet your
    needs. New formatting capabilities are registered by specifying (using a script
    or plug-in) a menu name for your format and a function to perform the formatting.
    Once you select a custom format for a data item, IDA will invoke your formatting
    function each time it needs to display that data item. Custom datatypes are useful
    when IDA’s built-in datatypes are not expressive enough represent the data that
    you encounter in a particular binary. Custom datatypes, like custom formats, are
    registered using a script or a plug-in. The Hex-Rays example registers a custom
    data type to designate virtual machine byte code and displays each byte code as
    an instruction by using a custom data format. A drawback to this approach is that
    it requires you to locate every virtual machine instruction and explicitly change
    its data type. Using a custom processor extension, designating a single value
    as a virtual machine instruction automatically leads to the discovery of every
    reachable instruction, because IDA drives the disassembly process and the processor
    extension discovers new reachable instructions via its custom_emu implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[185](#CHP-21-FN-37)]) See “Defeating HyperUnpackMe2 With an IDA Processor
    Module” at [http://www.openrce.org/articles/full_view/28](http://www.openrce.org/articles/full_view/28).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obfuscated programs are the rule rather than the exception when it comes to
    malware these days. Any attempts to study the internal operations of a mal-ware
    sample are almost certain to require some type of de-obfuscation. Whether you
    take a debugger-assisted, dynamic approach to de-obfuscation or whether you prefer
    not to run potentially malicious code and instead use scripts or emulation to
    de-obfuscate your binaries, the ultimate goal is to produce a de-obfuscated binary
    that can be fully disassembled and properly analyzed. In most cases, this final
    analysis will be performed using a tool such as IDA. Given this ultimate goal
    (of using IDA for analysis), it makes some sense to attempt to use IDA from start
    to finish. The techniques presented in this chapter are intended to demonstrate
    that IDA is capable of far more than generating disassembly listings. In [Chapter 25](ch25.html
    "Chapter 25. Disassembler/Debugger Integration") we will revisit obfuscated code
    and take a look at how IDA’s debugging features may be leveraged as a de-obfuscation
    tool as well.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 22. Vulnerability Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we get too far into this chapter, we need to make one thing clear: IDA
    is not a vulnerability discovery tool. There, we said it; what a relief! IDA seems
    to have attained mystical qualities in some people’s minds. All too often people
    seem to have the impression that merely opening a binary with IDA will reveal
    all the secrets of the universe, that the behavior of a piece of malware will
    be fully explained to them in comments automatically generated by IDA, that vulnerabilities
    will be highlighted in red, and that IDA will automatically generate exploit code
    if you right-click while standing on one foot in some obscure Easter egg–activation
    sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: While IDA is certainly a very capable tool, without a clever user sitting at
    the keyboard (and perhaps a handy collection of scripts and plug-ins), it is really
    only a disassembler/debugger. As a static-analysis tool, it can only facilitate
    your attempts to locate software vulnerabilities. Ultimately, it is up to your
    skills and how you apply them as to whether IDA makes your search for vulnerabilities
    easier. Based on our experience, IDA is not the optimal tool for locating new
    vulnerabilities,^([[186](#ftn.CHP-22-FN-1)]) but when used in conjunction with
    a debugger, it is one of the best tools available for assisting in exploit development
    once a vulnerability has been discovered.
  prefs: []
  type: TYPE_NORMAL
- en: Over the past several years, IDA has taken on a new role in discovering existing
    vulnerabilities. Initially, it may seem unusual to search for known vulnerabilities
    until we stop to consider exactly what is known about these vulnerabilities and
    exactly who knows it. In the closed-source, binary-only software world, vendors
    frequently release software patches without disclosing exactly what has been patched
    and why. By performing differential analysis between new patched versions of a
    piece of software and old un-patched versions of the same software, it is possible
    to isolate the areas that have changed within a binary. Under the assumption that
    these changes were made for a reason, such differential-analysis techniques actually
    help to shine a spotlight on what were formerly vulnerable code sequences. With
    the search thusly narrowed, anyone with the requisite skills can develop an exploit
    for use against unpatched systems. In fact, given Microsoft’s well-known *Patch
    Tuesday* cycle of publishing updates, large numbers of security researchers prepare
    to sit down and do just that once every month.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that entire books exist on the topic,^([[187](#ftn.CHP-22-FN-2)])
    there is no way that we can do justice to vulnerability analysis in a single chapter
    in a book dedicated to IDA. What we will do is assume that the reader is familiar
    with some of the basic concepts of software vulnerabilities, such as buffer overflows,
    and discuss some of the ways that IDA may be used to hunt down, analyze, and ultimately
    develop exploits for those vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering New Vulnerabilities with IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulnerability researchers take many different approaches to discovering new
    vulnerabilities in software. When source code is available, it may be possible
    to utilize any of a growing number of automated source code–auditing tools to
    highlight potential problem areas within a program. In many cases, such automated
    tools will only point out the low-hanging fruit, while discovery of deeper vulnerabilities
    may require extensive manual auditing.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for performing automated auditing of binaries offer many of the same reporting
    capabilities offered by automated source-auditing tools. A clear advantage of
    automated binary analysis is that no access to the application source code is
    required. Therefore, it is possible to perform automated analysis of closed-source,
    binary-only programs. Veracode^([[188](#ftn.CHP-22-FN-3)]) is an example of a
    company that offers a subscription-based service in which users may submit binary
    files for analysis by Veracode’s proprietary binary-analysis tools. While there
    is no guarantee that such tools can find any or all vulnerabilities within a binary,
    these technologies bring binary analysis within reach of the average person seeking
    some measure of confidence that the software she uses is free from vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether auditing at the source or binary level, basic static-analysis techniques
    include auditing for the use of problematic functions such as `strcpy` and `sprintf`,
    auditing the use of buffers returned by dynamic memory-allocation routines such
    as `malloc` and `VirtualAlloc`, and auditing the handling of user-supplied input
    received via functions such as `recv`, `read`, `fgets`, and many other similar
    functions. Locating such calls within a database is not difficult. For example,
    to track down all calls to `strcpy`, we could perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `strcpy` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display all cross-references to the `strcpy` function by positioning the cursor
    on the `strcpy` label and then choosing **View** ▸ **Open Subviews** ▸ **Cross
    References**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit each cross-reference and analyze the parameters provided to `strcpy` to
    determine whether a buffer overflow may be possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step 3 may require a substantial amount of code and data-flow analysis to understand
    all potential inputs to the function call. Hopefully, the complexity of such a
    task is clear. Step 1, although it seems straightforward, may require a little
    effort on your part. Locating `strcpy` may be as easy as using the Jump ▸ Jump
    to Address command (G) and entering `strcpy` as the address to jump to. In Windows
    PE binaries or statically linked ELF binaries, this is usually all that is needed.
    However, with other binaries, extra steps may be required. In a dynamically linked
    ELF binary, using the Jump command may not take you directly to the desired function.
    Instead, it is likely to take you to an entry in the `extern` section (which is
    involved in the dynamic-linking process). An IDA representation of the `strcpy`
    entry in an `extern` section is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To confuse matters, this location does not appear to be named `strcpy` at all
    (it is, but the name is indented), and the only code cross-reference ![](httpatomoreillycomsourcenostarchimages854061.png)
    to the location is a jump cross-reference from a function that appears to be named
    `_strcpy`, while a data cross-reference is also made to this location from the
    `.got` section. The referencing function is actually named `.strcpy`, which is
    not at all obvious from the display. In this case, IDA has replaced the dot character
    with an underscore because IDA does not consider dots to be valid identifier characters
    by default. Double-clicking the code cross-reference takes us to the program’s
    procedure linkage table (.`plt`) entry for `strcpy`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If instead we follow the data cross-reference, we end up at the corresponding
    `.got` entry for `strcpy` shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the `.got` entry, we encounter another data cross-reference to the `.strcpy`
    function in the `.plt` section. In practice, following the data cross-references
    is the most reliable means of navigating from the `extern` section to the `.plt`
    section. In dynamically linked ELF binaries, functions are called indirectly through
    the procedure linkage table. Now that we have reached the .`plt`, we can bring
    up the cross-references to `_strcpy` (actually `.strcpy`) and begin to audit each
    call (of which there are at least two in this example).
  prefs: []
  type: TYPE_NORMAL
- en: This process can become tedious when we have a list of several common functions
    whose calls we wish to locate and audit. At this point it may be useful to develop
    a script that can automatically locate and comment all interesting function calls
    for us. With comments in place, we can perform simple searches to move from one
    audit location to another. The foundation for such a script is a function that
    can reliably locate another function so that we can locate all cross-references
    to that function. With the understanding of ELF binaries gained in the preceding
    discussion, the IDC function in [Example 22-1](ch22.html#finding_a_functionas_callable_address
    "Example 22-1. Finding a function’s callable address") takes a function name as
    an input argument and returns an address suitable for cross-reference iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Example 22-1. Finding a function’s callable address
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Using the supplied return address, it is now possible to track down all of the
    references to any function whose use we want to audit. The IDC function in [Example 22-2](ch22.html#flagging_calls_to_a_designated_function
    "Example 22-2. Flagging calls to a designated function") leverages the `getFuncAddr`
    function from the preceding example to obtain a function address and add comments
    at all calls to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Example 22-2. Flagging calls to a designated function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the desired function’s address has been located ![](httpatomoreillycomsourcenostarchimages854061.png),
    two loops are used to iterate over cross-references to the function. In the first
    loop ![](httpatomoreillycomsourcenostarchimages854063.png), a comment is inserted
    at each location that calls the function of interest. In the second loop ![](httpatomoreillycomsourcenostarchimages854093.png),
    additional comments are inserted at each location that takes the address of the
    function (use of an offset cross-reference type). The second loop is required
    in order to track down calls of the following style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the compiler has cached the address of the `strcpy` function
    in the ESI register ![](httpatomoreillycomsourcenostarchimages854061.png) in order
    to make use of a faster means of calling `strcpy` later ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the program. The `call` instruction shown here is faster to execute because
    it is both smaller (2 bytes) and requires no additional operations to resolve
    the target of the call, since the address is already contained within the CPU
    within the ESI register. A compiler may choose to generate this type of code when
    one function makes several calls to another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the indirect nature of the call in this example, the `flagCalls` function
    in our example may see only the data cross-reference to `strcpy` ![](httpatomoreillycomsourcenostarchimages854061.png)
    while failing to see the call to `strcpy` ![](httpatomoreillycomsourcenostarchimages854063.png)
    because the `call` instruction does not reference `strcpy` directly. In practice,
    however, IDA possesses the capability to perform some limited data-flow analysis
    in cases such as these and is likely to generate the disassembly shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `call` instruction ![](httpatomoreillycomsourcenostarchimages854061.png)
    has been annotated with a comment indicating which function IDA believes is being
    called. In addition to inserting the comment, IDA adds a code cross-reference
    from the point of the call to the function being called. This benefits the `flagCalls`
    function, because in this case the `call` instruction will be found and annotated
    via a code cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish up our example script, we need a `main` function that invokes `flagCalls`
    for all of the functions that we are interested in auditing. A simple example
    to annotate calls to some of the functions mentioned earlier in this section is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: After running this script, we can move from one interesting call to the next
    by searching for the inserted comment text, `*** AUDIT ***`. Of course this still
    leaves a lot of work to be done from an analysis perspective, since the mere fact
    that a program calls `strcpy` does not make that program exploitable. This is
    where data-flow analysis comes into play. In order to understand whether a particular
    call to `strcpy` is exploitable or not, you must determine what parameters are
    being passed in to `strcpy` and evaluate whether those parameters can be manipulated
    to your advantage or not.
  prefs: []
  type: TYPE_NORMAL
- en: Data-flow analysis is a far more complex task than simply finding calls to problem
    functions. In order to track the flow of data in a static-analysis environment,
    a thorough understanding of the instruction set being used is required. Your static-analysis
    tools need to understand where registers may have been assigned values and how
    those values may have changed and propagated to other registers. Further, your
    tools need a means for determining the sizes of source and destination buffers
    being referenced within the program, which in turn requires the ability to understand
    the layout of stack frames and global variables as well as the ability to deduce
    the size of dynamically allocated memory blocks. And, of course, all of this is
    being attempted without actually running the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting example of what can be accomplished with creative scripting
    comes in the form of the BugScam^([[189](#ftn.CHP-22-FN-4)]) scripts created by
    Halvar Flake. BugScam utilizes techniques similar to the preceding examples to
    locate calls to problematic functions and takes the additional step of performing
    rudimentary data-flow analysis at each function call. The result of BugScam’s
    analysis is an HTML report of potential problems in a binary. A sample report
    table generated as a result of a `sprintf` analysis is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Address | Severity | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8048c03 | 5 | The maximum expansion of the data appears to be larger than
    the target buffer; this might be the cause of a buffer overrun! Maximum Expansion:
    1053\. Target Size: 1036. |'
  prefs: []
  type: TYPE_TB
- en: In this case, BugScam was able to determine the size of the input and output
    buffers, which, when combined with the format specifiers contained in the format
    string, were used to determine the maximum size of the generated output.
  prefs: []
  type: TYPE_NORMAL
- en: Developing scripts of this nature requires an in-depth understanding of various
    exploit classes in order to develop an algorithm that can be applied generically
    across a large body of binaries. Lacking such knowledge, we can still develop
    scripts (or plug-ins) that answer simple questions for us faster than we can find
    the answers manually.
  prefs: []
  type: TYPE_NORMAL
- en: As a final example, consider the task of locating all functions that contain
    stack-allocated buffers, since these are the functions that might be susceptible
    to stack-based buffer-overflow attacks. Rather than manually scrolling through
    a database, we can develop a script to analyze the stack frame of each function,
    looking for variables that occupy large amounts of space. The Python function
    in [Example 22-3](ch22.html#scanning_for_stack-allocated_buffers "Example 22-3. Scanning
    for stack-allocated buffers") iterates through the defined members of a given
    function’s stack frame in search of variables whose size is larger than a specified
    minimum size.
  prefs: []
  type: TYPE_NORMAL
- en: Example 22-3. Scanning for stack-allocated buffers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This function locates all the variables in a stack frame using repeated calls
    to `GetMemberName` ![](httpatomoreillycomsourcenostarchimages854061.png) for all
    valid offsets within the stack frame. The size of a variable is computed as the
    difference between the starting offsets of two successive variables ![](httpatomoreillycomsourcenostarchimages854063.png).
    If the size exceeds a threshold size (`minsize`) ![](httpatomoreillycomsourcenostarchimages854093.png),
    then the variable is reported as a possible stack buffer. The index into the structure
    is moved along by either 1 byte ![](httpatomoreillycomsourcenostarchimages854095.png)
    when no member is defined at the current offset or by the size of any member found
    at the current offset ![](httpatomoreillycomsourcenostarchimages854099.png). The
    `GetMem-berSize` function may seem like a more suitable choice for computing the
    size of each stack variable; however, this is true only if the variable has been
    sized properly by either IDA or the user. Consider the following stack frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the displayed byte offsets, we can compute that there are 1,024 bytes
    from the start of `var_818` to the start of `var_418` (`818h - 418h = 400h`) and
    1,036 bytes between the start of `var_418` and the start of `var_C` (`418h - 0Ch`).
    However, the stack frame might be expanded to show the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `var_418` has been collapsed into an array, while `var_818` appears to
    be only a single byte (with 1,023 undefined bytes filling the space between `var_818`
    and `var_418`). For this stack layout, `GetMemberSize` will report 1 byte for
    `var_818` and 1,036 bytes for `var_418`, which is an undesirable result. The output
    of a call to `findStackBuffers(0x08048B38, 16)` results in the following output,
    regardless of whether `var_818` is defined as a single byte or an array of 1,024
    bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Creating a `main` function that iterates through all functions in a database
    (see [Chapter 15](ch15.html "Chapter 15. IDA Scripting")) and calls `findStackBuffers`
    for each function yields a script that quickly points out the use of stack buffers
    within a program. Of course, determining whether any of those buffers can be overflowed
    requires additional (usually manual) study of each function. The tedious nature
    of static analysis is precisely the reason that fuzz testing is so popular.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[186](#CHP-22-FN-1)]) In general, far more vulnerabilities are discovered
    through fuzz testing than through static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[187](#CHP-22-FN-2)]) For example, see Jon Erickson’s *Hacking: The Art
    of Exploitation, 2nd Edition* ([http://nostarch.com/hacking2.htm](http://nostarch.com/hacking2.htm)).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[188](#CHP-22-FN-3)]) See [http://www.veracode.com/](http://www.veracode.com/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[189](#CHP-22-FN-4)]) See [http://www.sourceforge.net/projects/bugscam/](http://www.sourceforge.net/projects/bugscam/).
  prefs: []
  type: TYPE_NORMAL
- en: After-the-Fact Vulnerability Discovery with IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A perpetual debate rages over the exact process by which software vulnerabilities
    should be disclosed. For any vulnerability discovered in a piece of software,
    we can assign the roles of discoverer (of the vulnerability) and maintainer (of
    the software). In addition, we can specify a number of events, which may or may
    not take place, surrounding the discovery of any vulnerability. Some of these
    events are briefly described here. Please keep in mind that the entire vulnerability-disclosure
    process is hotly debated, and the following terms are by no means standardized
    or even widely accepted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovery**'
  prefs: []
  type: TYPE_NORMAL
- en: The time at which a vulnerability is initially discovered. For our purposes,
    we will also consider this to be the time at which an exploit for that vulnerability
    is initially developed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Notification**'
  prefs: []
  type: TYPE_NORMAL
- en: The time at which the software maintainer is initially made aware of the vulnerability
    within its product. This may coincide with discovery if the vendor happens to
    find the vulnerability itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclosure**'
  prefs: []
  type: TYPE_NORMAL
- en: The time at which a vulnerability is made known to the public. This event can
    be muddied by the level of detail made available regarding the vulnerability.
    Disclosure may or may not be accompanied by the release or identification of working
    exploits. In some cases disclosure also serves as notification to the vendor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mitigation**'
  prefs: []
  type: TYPE_NORMAL
- en: The time at which steps are published that, if followed, may prevent a user
    from falling victim to an existing exploit. Mitigation steps are work-around solutions
    for users awaiting the publication of a patch.
  prefs: []
  type: TYPE_NORMAL
- en: '**Patch availability**'
  prefs: []
  type: TYPE_NORMAL
- en: The time at which the maintainer (or a third party) makes available a corrected
    version of the vulnerable software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Patch application**'
  prefs: []
  type: TYPE_NORMAL
- en: The time at which users actually install the updated, corrected software, rendering
    themselves immune (hopefully) to all known attacks that rely on the presence of
    the given vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: A wealth of papers are more than happy to tell you all about windows of vulnerability,
    obligations on the part of the discoverer and the maintainer, and exactly how
    much information should be disclosed and when that disclosure should take place.
    Getting to the point, it is common for disclosure to coincide with the availability
    of a patch.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, a vulnerability advisory is published in conjunction with the
    patch. The vulnerability advisory provides some level of technical detail describing
    the nature and severity of the problem that has been patched, but the level of
    detail is usually insufficient to use in developing a working exploit for the
    problem. Why anyone would want to develop a working exploit is another matter.
    Clearly some people are interested in exploiting computers that remain unpatched,
    and the faster an exploit can be developed, the greater their chance of exploiting
    more computers. In other cases, vendors may be interested in developing tools
    that scan for the presence of unpatched systems on networks or in developing techniques
    for real-time detection of exploitation attempts. In most cases, development of
    such tools requires a detailed understanding of the exact nature of the newly
    patched vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Advisories may lack such essential information as the exact file or files that
    contain the vulnerability, the name or location of any vulnerable functions, and
    exactly what was changed within those functions. The patched files themselves,
    however, contain all the information that an exploit developer requires in order
    to develop a working exploit for the newly patched vulnerability. This information
    is not immediately obvious, nor is it clearly intended for the consumption of
    an exploit developer. Instead, this information is present in the form of the
    changes that were made in order to eliminate the underlying vulnerability. The
    easiest way to highlight such changes is to compare a patched binary against its
    unpatched counterpart. If we have the luxury of looking for differences in patched
    source files, then standard text-oriented comparison utilities such as `diff`
    can make short work of pinpointing changes. Unfortunately, tracking down behavioral
    changes between two revisions of a binary file is far more complicated than simple
    text file diffing.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty with using difference computation to isolate the changes in two
    binaries lies in the fact that binaries can change for several reasons. Changes
    may be triggered by compiler optimizations, changes to the compiler itself, reorganization
    of source code, addition of code unrelated to the vulnerability, and of course
    the code that patches the vulnerability itself. The challenge lies in isolating
    behavioral changes (such as those required to fix the vulnerability) from cosmetic
    changes (such as the use of different registers to accomplish the same task).
  prefs: []
  type: TYPE_NORMAL
- en: A number of tools designed specifically for binary diffing are available, including
    the commercial BinDiff from Zynamics;^([[190](#ftn.CHP-22-FN-5)]) the free Binary
    Diffing Suite (BDS) from eEye Digital Security;^([[191](#ftn.CHP-22-FN-6)]) Turbodiff,^([[192](#ftn.CHP-22-FN-7)])
    also free and available from Core Labs (part of Core Security, makers of Core
    Impact^([[193](#ftn.CHP-22-FN-8)])); and PatchDiff2^([[194](#ftn.CHP-22-FN-9)])
    by Nicolas Pouvesle. Each of these tools relies on supplied IDA in one way or
    another. BinDiff and BDS make use of IDA scripts and plug-ins to perform initial
    analysis tasks on both the patched and the unpatched versions of the binaries
    being analyzed. Information extracted by the plug-ins is stored in a backend database,
    and each tool provides a graph-based display and can navigate through the differences
    detected during the analysis phase. Turbodiff and PatchDiff2 are implemented as
    IDA plug-ins and display their results within IDA itself. The ultimate goal of
    these tools is to quickly highlight the changes made to patch a vulnerability
    in order to understand why the code was vulnerable in the first place. Additional
    information on each tool is available on its respective website.
  prefs: []
  type: TYPE_NORMAL
- en: Representative of the free diffing tools, PatchDiff2 is an open source project
    offering compiled, 32- and 64-bit Windows versions of the plug-in along with subversion
    access to the plug-in source. Installing the plug-in involves copying the plug-in
    binaries into *<IDADIR>/plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in using PatchDiff2 is to create two separate IDA databases,
    one for each of the two binaries to be compared. Typically one of these databases
    would be created for the original version of the binary, while the other database
    would be created for the patched version of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | PatchDiff2 |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Nicolas Pouvesle |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Source and binaries for IDA 5.7 |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Binary difference generation and display |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://code.google.com/p/patchdiff2/](http://code.google.com/p/patchdiff2/)
    |'
  prefs: []
  type: TYPE_TB
- en: Invoking the plug-in typically involves opening the database for the original
    binary and then activating PatchDiff2 via the Edit ▸ Plugins menu or its associated
    hot key (default is ctrl-8). PatchDiff2 refers to the database from which you
    invoke the plug-in as *IDB1*, or the “first idb.” Upon activation, PatchDiff2
    will ask to open the second database against which the currently open database
    will be compared; this database is known as *IDB2*, or the “second idb.” Once
    a second database has been selected, PatchDiff2 computes a number of identifying
    features for every function in each database including various types of signatures,
    hash values, and CRC values. Utilizing these features, PatchDiff2 creates three
    lists of functions titled *Identical Functions*, *Unmatched Functions*, and *Matched
    Functions*. Each of these lists is displayed in a new tabbed window opened by
    PatchDiff2.
  prefs: []
  type: TYPE_NORMAL
- en: The Identical Functions list contains the list of functions that PatchDiff2
    deems to be identical in both databases. From an analysis point of view, these
    functions are likely to be uninteresting because they contribute nothing to the
    changes that produced the patched version of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: The Unmatched Functions list shows functions from both databases that do not
    appear to be similar to one another according to the metrics applied by PatchDiff2\.
    In practice, these functions have either been added to the patched version, removed
    from the unpatched version, or are too similar to other functions within the same
    binary to be able to distinguish them from corresponding functions in the second
    binary. With careful manual analysis it is often possible to match pairs of functions
    within the Unmatched Functions list. As a general rule of thumb, it is a good
    idea to manually compare the structure of functions that have similar numbers
    of signatures. To facilitate this, it is best to sort the list based on the *sig*
    column so that functions with similar numbers of signatures are listed near one
    another. The first few lines of an unmatched functions list sorted on *sig* are
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: It is clear that the two functions from file one are related to the two functions
    from file two; however, PatchDiff2 is unable to determine how to pair them up.
    It is not uncommon to see multiple functions with identical structures in binaries
    that make use of the C++ *standard template library (STL)*. If you are able to
    manually match a function from one file to its corresponding function in the other
    file, you may use PatchDiff2’s *Set Match* feature (available on the context-sensitive
    menu) to choose one function in the list and match it to a second function in
    the list. [Figure 22-1](ch22s02.html#manually_matching_functions_with_patchdi
    "Figure 22-1. Manually matching functions with PatchDiff2") shows the Set Match
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![Manually matching functions with PatchDiff2](httpatomoreillycomsourcenostarchimages854338.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-1. Manually matching functions with PatchDiff2
  prefs: []
  type: TYPE_NORMAL
- en: Manual matching begins when you choose one function using the Set Match menu
    option. In the resulting dialog, you must enter the address of the matching function
    in the file you are not viewing. The Propagate option asks PatchDiff2 to match
    as many additional functions as it can, given that you have informed it of a new
    match.
  prefs: []
  type: TYPE_NORMAL
- en: The Matched Functions list contains the list of functions that PatchDiff2 deems
    sufficiently similar, yet not quite identical, according to the metrics applied
    by in the matching process. Right-clicking any entry in this list and selecting
    Display Graphs causes PatchDiff2 to display flow graphs for the two matched functions.
    One such pair of graphs is shown in [Figure 22-2](ch22s02.html#patchdiff2_graphical_function_comparison
    "Figure 22-2. PatchDiff2 graphical function comparison"). PatchDiff2 makes use
    of color coding to highlight blocks that have been introduced into the patched
    version of the binary, making it easy to focus on the changed portions of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![PatchDiff2 graphical function comparison](httpatomoreillycomsourcenostarchimages854341.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-2. PatchDiff2 graphical function comparison
  prefs: []
  type: TYPE_NORMAL
- en: In these graphs, blocks ![](httpatomoreillycomsourcenostarchimages854061.png)
    through ![](httpatomoreillycomsourcenostarchimages854095.png) are present in both
    functions, while block ![](httpatomoreillycomsourcenostarchimages854099.png) has
    been added in the patched version of the function. During differential analysis,
    matched functions may be of the highest interest initially because they are likely
    to contain the changes that have been incorporated into the patched binary that
    address vulnerabilities discovered in the original binary. Close study of these
    changes may reveal the corrections that have been made or safety checks that have
    been added in order to address incorrect behavior or exploitable conditions. If
    we fail to find any interesting changes highlighted in the Matched Functions list,
    then the Unmatched Functions list is our only other option for attempting to locate
    the patched code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[190](#CHP-22-FN-5)]) See [http://www.zynamics.com/bindiff.html](http://www.zynamics.com/bindiff.html).
    Note that in March 2011, Zynamics was acquired by Google.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[191](#CHP-22-FN-6)]) See [http://research.eeye.com/html/tools/RT20060801-1.html](http://research.eeye.com/html/tools/RT20060801-1.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[192](#CHP-22-FN-7)]) See [http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=tool&name=turbodiff](http://corelabs.coresecurity.com/index.php?module=Wiki&action=view&type=tool&name=turbodiff).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[193](#CHP-22-FN-8)]) See [http://www.coresecurity.com/content/core-impact-overview/](http://www.coresecurity.com/content/core-impact-overview/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[194](#CHP-22-FN-9)]) See [http://code.google.com/p/patchdiff2](http://code.google.com/p/patchdiff2).
    Note also that Alexander Pick has ported PatchDiff2 to IDA 6.0 for OS X. For more
    information please see [https://github.com/alexander-pick/patchdiff2_ida6](https://github.com/alexander-pick/patchdiff2_ida6).
  prefs: []
  type: TYPE_NORMAL
- en: IDA and the Exploit-Development Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming that you manage to locate a potentially exploitable vulnerability,
    how can IDA help with the exploit-development process? The answer to this question
    requires that you understand what type of help you need in order for you to make
    use of the appropriate features of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: 'IDA is very good at several things that can save you a tremendous amount of
    trial and error when developing exploits:'
  prefs: []
  type: TYPE_NORMAL
- en: IDA graphs can be useful in determining control flow paths as a means of understanding
    how a vulnerable function may be reached. Careful selection of graph-generation
    parameters may be required in large binaries in order to minimize the complexity
    of generated graphs. Refer to [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing") for more information on IDA graphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDA breaks down stack frames to a great level of detail. If you are overwriting
    information in the stack, IDA will help you understand exactly what is getting
    overwritten by which portions of your buffer. IDA stack displays are also invaluable
    in determining the memory layout of format string buffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDA has excellent search facilities. If you need to search for a specific instruction
    (such as `jmp esp`) or sequence of instructions (such as `pop/pop/``ret`) within
    a binary, IDA can rapidly tell you whether the instruction(s) is present in the
    binary and, if so, the exact virtual address at which the instruction(s) is located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that IDA maps binaries as if they are loaded in memory makes it easier
    for you to locate virtual addresses that you may require in order to land your
    exploit. IDA’s disassembly listings make it simple to determine the virtual address
    of any globally allocated buffers as well as useful addresses (such as `GOT` entries)
    to target when you have a write4^([[195](#ftn.CHP-22-FN-10)]) capability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss several of these capabilities and how you can leverage them
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Frame Breakdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While stack-protection mechanisms are rapidly becoming standard features in
    modern operating systems, many computers continue to run operating systems that
    allow code to be executed in the stack, as is done in a plain-vanilla stack-based
    buffer-overflow attack. Even when stack protections are in place, overflows may
    be used to corrupt stack-based pointer variables, which can be further leveraged
    to complete an attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of what you intend to do when you discover a stack-based buffer
    overflow, it is vital to understand exactly what stack content will be overwritten
    as your data overflows the vulnerable stack buffer. You will probably also be
    interested in knowing exactly how many bytes you need to write into the buffer
    until you can control various variables within the function’s stack frame, including
    the function’s saved return address. IDA’s default stack frame displays can answer
    all of these questions if you are willing to do a little math. The distance between
    any two variables in the stack can be computed by subtracting the stack offsets
    of the two variables. The following stack frame includes a buffer that can be
    overflowed when input to the corresponding function is carefully controlled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The distance from the beginning of the vulnerable buffer (`buffer_132`) to the
    saved return address is 156 bytes (`4 - −98h`, or `4 - −152`). You can also see
    that after 132 bytes (`−14h - −98h`), the contents of `p_buf` will start to get
    overwritten, which may or may not cause problems. You must clearly understand
    the effect of overwriting variables that lie beyond the end of the buffer in order
    to prevent the target application from crashing before the exploit can be triggered.
    In this example, `filedes` (a socket descriptor) might be another problematic
    variable. If the vulnerable function expects to use the socket descriptor after
    you have finished overflowing the buffer, then you need to take care that any
    overwriting of `filedes` will not cause the function to error out unexpectedly.
    One strategy for dealing with variables that will be overwritten is to write values
    into these variables that make sense to the program so that the program continues
    to function normally until your exploit is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: For a slightly more readable breakdown of a stack frame, we can modify the stack
    buffer–scanning code from [Example 22-3](ch22.html#scanning_for_stack-allocated_buffers
    "Example 22-3. Scanning for stack-allocated buffers") to enumerate all members
    of a stack frame, compute their apparent size, and display the distance from each
    member to the saved return address. [Example 22-4](ch22s03.html#enumerating_a_single_stack_frame_using_p
    "Example 22-4. Enumerating a single stack frame using Python") shows the resulting
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Example 22-4. Enumerating a single stack frame using Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This script introduces the `GetFrameLvarSize` and `GetFrameRegsSize` functions
    (also available in IDC). These functions are used to retrieve the size of a stack
    frame’s local variable and saved register areas, respectively. The saved return
    address lies directly beneath these two areas, and the offset to the saved return
    address is computed as the sum of these two values ![](httpatomoreillycomsourcenostarchimages854061.png).
    When executed against our example function, the script produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The results offer a concise summary of a function’s stack frame annotated with
    additional information of potential use to an exploit developer.
  prefs: []
  type: TYPE_NORMAL
- en: IDA’s stack frame displays also prove useful when developing exploits for format
    string vulnerabilities. As an example, consider the following short code fragment
    in which the `fprintf` function is invoked with a user-supplied buffer provided
    as the format string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this example, only two arguments are passed to `fprintf`, a file pointer
    ![](httpatomoreillycomsourcenostarchimages854061.png) and the address of the user’s
    buffer as a format string ![](httpatomoreillycomsourcenostarchimages854063.png).
    These arguments occupy the top two positions on the stack, memory that has already
    been allocated by the calling function as part of the function’s prologue. The
    stack frame for the vulnerable function is shown in [Example 22-5](ch22s03.html#stack_frame_for_format_string_example
    "Example 22-5. Stack frame for format string example").
  prefs: []
  type: TYPE_NORMAL
- en: Example 22-5. Stack frame for format string example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The 16 undefined bytes spanning frame offsets `128h` through `119h` represent
    the block of memory that the compiler (gcc in this case) has preallocated for
    the arguments passed in to the functions that will be called by the vulnerable
    function. The `stream` argument to `fprintf` will be placed at the top of the
    stack ![](httpatomoreillycomsourcenostarchimages854061.png), while the format
    string pointer will be placed immediately below ![](httpatomoreillycomsourcenostarchimages854063.png)
    the `stream` argument.
  prefs: []
  type: TYPE_NORMAL
- en: In format string exploits, an attacker is often interested in the distance from
    the format string pointer to the beginning of the buffer holding the attacker’s
    input. In the preceding stack frame, 16 bytes separate the format string argument
    from the actual format string buffer. To further the discussion, we will assume
    that an attacker has entered the following format string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fprintf` would expect five arguments immediately following the format
    string argument. The first four of these arguments would occupy the space between
    the format string argument and the format string buffer. The fifth, and final,
    of these arguments would overlap the first four bytes of the format string buffer
    itself. Readers familiar with format string exploits^([[196](#ftn.CHP-22-FN-11)])
    will know that arguments within a format string may be named explicitly by index
    number. The following format string demonstrates accessing the fifth argument
    following the format string in order to format it as a hexadecimal value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Continuing with the preceding example, this format string would read the first
    4 bytes of the format string buffer as an integer (which we previously noted would
    occupy the space of the fifth argument to the format string should one have been
    required), format that integer as a hexadecimal value, and then output the result
    to the specified file stream. Additional arguments to the format string (the sixth,
    seventh, and so on) would overlap successive 4-byte blocks within the format string
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting a format string that will work properly to exploit a vulnerable binary
    can be tricky and generally relies on precise specification of arguments within
    the format string. The preceding discussion demonstrates that, in many cases,
    IDA may be used to quickly and accurately compute required offsets into a format
    string buffer. By combining this information with information that IDA presents
    when disassembling various program sections, such as the global offset table (*.got*)
    or the destructor table (*.dtor*), a correct format string may be derived accurately
    with no trial and error as might be required when using only a debugger to develop
    an exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Locating Instruction Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to reliably land an exploit, it is often useful to employ a control-transfer
    mechanism that does not require you to know the exact memory address at which
    your shellcode resides. This is particularly true when your shellcode lies in
    the heap or the stack, which may make the address of your shellcode unpredictable.
    In such cases, it is desirable to find a register that happens to point at your
    shellcode at the time your exploit is triggered. For example, if the ESI register
    is known to point at your shellcode at the moment you take control of the instruction
    pointer, it would be very helpful if the instruction pointer happened to point
    to a `jmp esi` or `call esi` instruction, which would vector execution to your
    shellcode without requiring you to know the exact address of your shellcode. Similarly
    a `jmp esp` is often a very handy way to transfer control to shellcode that you
    have placed in the stack. This takes advantage of the fact that when a function
    containing a vulnerable buffer returns, the stack pointer will be left pointing
    just below the same saved return address that you just overwrote. If you continued
    to overwrite the stack beyond the saved return address, then the stack pointer
    is pointing at your data (which should be code!). The combination of a register
    pointing at your shellcode along with an instruction sequence that redirects execution
    by jumping to or calling the location pointed to by that register is called a
    *trampoline*.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of searching for such instruction sequences is not a new one. In
    Appendix D of his paper “Variations in Exploit Methods between Linux and Windows,”^([[197](#ftn.CHP-22-FN-12)])
    David Litchfield presents a program named *getopcode.c* designed to search for
    useful instructions in Linux ELF binaries. Along similar lines, the Metasploit^([[198](#ftn.CHP-22-FN-13)])
    project offers its `msfpescan` tool, which is capable of scanning Windows PE binaries
    for useful instruction sequences. IDA is just as capable of locating interesting
    instruction sequences as either of these tools when given the chance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of example, assume that you would like to locate a `jmp esp` instruction
    in a particular x86 binary. You could use IDA’s text-search features to look for
    the string `jmp esp`, which you would only find if you happened to have exactly
    the right number of spaces between *jmp* and *esp* and which you are unlikely
    to find in any case because a jump into the stack is seldom used by any compiler.
    So why bother searching in the first place? The answer lies in the fact that what
    you are actually interested in is not an occurrence of the disassembled text `jmp
    esp` but rather the byte sequence `FF E4`, regardless of its location. For example,
    the following instruction contains an embedded `jmp esp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Virtual address `080486CFh` may be used if a `jmp esp` is desired. IDA’s binary
    search (Search ▸ Sequence of Bytes) capability is the correct way to rapidly locate
    byte sequences such as these. When performing a binary search for exact matches
    against a known byte sequence, remember to perform a case-sensitive search, or
    a byte sequence such as `50 C3` (`push eax/ret`) will be matched by the byte sequence
    `70 C3` (because 50h is an uppercase *P*, while 70h is a lowercase *p*), which
    is a jump on overflow with a relative offset of –61 bytes. Binary searches can
    be scripted using the `FindBinary` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This function call begins searching down (toward higher addresses) from the
    lowest virtual address in the database, in a case-sensitive manner, in search
    of a `jmp esp` (`FF E4`). If sequence is found, the return value is the virtual
    address of the start of the byte sequence. If the sequence is not found, the return
    value is BADADDR (−1). A script that automates searches for a wider variety of
    instructions is available on the book’s website. Using this script, we might request
    a search for instructions that transfer control to the location pointed to by
    the EDX register and receive results similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Convenience scripts such as these can save a substantial amount of time while
    ensuring that we don’t forget to cover all possible cases as we search for items
    in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Useful Virtual Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last item we will mention briefly is IDA’s display of virtual addresses
    in its disassemblies. Situations in which we know that our shellcode is going
    to end up in a static buffer (in a `.data` or `.bss` section, for example) are
    almost always better than situations in which our shellcode lands in the heap
    or the stack, because we end up with a known, fixed address to which we can transfer
    control. This usually eliminates the need for NOP slides or the need to find special
    instruction sequences.
  prefs: []
  type: TYPE_NORMAL
- en: NOP SLIDES
  prefs: []
  type: TYPE_NORMAL
- en: A *NOP* slide is a long sequence of consecutive nop (do nothing) instructions
    that provides a wider target for hitting our shellcode when the address of our
    shellcode is known to be somewhat variable. Rather than targeting the first useful
    instruction of our shellcode, we target the middle of the NOP slide. If the NOP
    slide (and hence the rest of our payload) shifts slightly up or down in memory,
    we still have a good chance of landing somewhere within the slide and successfully
    running into our shellcode. For example, if we have room for 500 NOPs as a prefix
    for our shellcode, we can target the middle of the slide and still hit the slide
    as long as the address that we guess for the middle of the slide is within 250
    bytes of the actual address.
  prefs: []
  type: TYPE_NORMAL
- en: Some exploits take advantage of the fact that attackers are able to write any
    data they like to any location they choose. In many cases, this may be restricted
    to a 4-byte overwrite, but this amount often turns out to be sufficient. When
    a 4-byte overwrite is possible, one alternative is to overwrite a function pointer
    with the address of our shellcode. The dynamic linking process used in most ELF
    binaries utilizes a table of function pointers called the *global offset table
    (GOT)* to store addresses of dynamically linked library functions. When one of
    these table entries can be overwritten, it is possible to hijack a function call
    and redirect the call to a location of the attacker’s choosing. A typical sequence
    of events for an attacker in such cases is to stage shellcode in a known location
    and then overwrite the GOT entry for the next library function to be called by
    the exploited program. When the library function is called, control is instead
    transferred to the attacker’s shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The addresses of GOT entries are easily found in IDA by scrolling to the `got`
    section and browsing for the function whose entry you wish to overwrite. In the
    name of automating as much as possible, though, the following Python script quickly
    reports the address of the GOT entry that will be used by a given function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This script is executed by placing the cursor on any call to a library function,
    such as the following, and invoking the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The script operates by walking forward through cross-references until the GOT
    is reached. The first cross-reference that is retrieved ![](httpatomoreillycomsourcenostarchimages854061.png)
    is tested to ensure that it is a call reference and that it references the ELF
    procedure linkage table (`.plt`). PLT entries contain code that reads a GOT entry
    and transfers control to the address specified in the GOT entry. The second cross-reference
    retrieved ![](httpatomoreillycomsourcenostarchimages854063.png) obtains the address
    of the location being read from the PLT, and this is the address of the associated
    GOT entry. When executed on the preceding call to `_memset`, the output of the
    script on our example binary yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This output provides us with exactly the information we require if our intention
    is to take control of the program by hijacking a call to `memset`, namely that
    we need to overwrite the contents of address `0x080618d8` with the address of
    our shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[195](#CHP-22-FN-10)]) A *write4* capability presents an attacker with the
    opportunity to write 4 bytes of his choosing to a memory location of his choosing.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[196](#CHP-22-FN-11)]) Readers wishing to learn more about format string
    exploits might again refer to Jon Erickson’s *Hacking: The Art of Exploitation,
    2nd Edition*.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[197](#CHP-22-FN-12)]) See [http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx](http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[198](#CHP-22-FN-13)]) See [http://www.metasploit.com/](http://www.metasploit.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Shellcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, this chapter has focused on the use of IDA as an offensive
    tool. Before we conclude, it might be nice to offer up at least one use for IDA
    as a defensive tool. As with any other binary code, there is only one way to determine
    what shellcode does, and that is to disassemble it. Of course, the first requirement
    is to get your hands on some shellcode. If you are the curious type and have always
    wondered how Metasploit payloads work, you might simply use Metasploit to generate
    a payload in raw form and then disassemble the resulting blob.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Metasploit command generates a payload that calls back to port
    4444 on the attacker’s computer and grants the attacker a shell on the target
    Windows computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The resulting file contains the requested payload in its raw binary form. The
    file can be opened in IDA (in binary form since it has no specific format) and
    a disassembly obtained by converting the displayed bytes into code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another place that shellcode can turn up is in network packet captures. Narrowing
    down exactly which packets contain shellcode can be a challenge, and you are invited
    to check out any of the vast number of books on network security that will be
    happy to tell you just how to find all those nasty packets. For now consider the
    reassembled client stream of an attack observed on the Capture the Flag network
    at DEFCON 18:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This dump clearly contains a mix of ASCII and binary data, and based on other
    data associated with this particular network connection, the binary data is assumed
    to be shellcode. Packet-analysis tools such as Wireshark^([[199](#ftn.CHP-22-FN-14)])
    often possess the capability to extract TCP session content directly to a file.
    In the case of Wireshark, once you find a TCP session of interest, you can use
    the `Follow TCP Stream` command and then save the raw stream content to a file.
    The resulting file can then be loaded into IDA (using IDA’s binary loader) and
    analyzed further. Often network attack sessions contain a mix of shellcode and
    application layer content. In order to properly disassemble the shellcode, you
    must correctly locate the first bytes of the attacker’s payload. The level of
    difficulty in doing this will vary from one attack to the next and one protocol
    to the next. In some cases, long NOP slides will be obvious (long sequences of
    `0x90` for x86 attacks), while in other cases (such as the current example), locating
    the NOPs, and therefore the shellcode, may be less obvious. The preceding hex
    dump, for example, actually contains a NOP slide; however, instead of actual x86
    NOPs, a randomly generated sequence of 1-byte instructions that have no effect
    on the shell code to follow is used. Since an infinite number of permutations
    exist for such a NOP slide, the danger that a network intrusion detection system
    will recognize and alert on the NOP slide is diminished. Finally, some knowledge
    of the application that is being attacked may help in distinguishing data elements
    meant for consumption by the application from shellcode meant to be executed.
    In this case, with a little effort, IDA disassembles the preceding binary content
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: One point worth noting is that the first 8 bytes of the stream ![](httpatomoreillycomsourcenostarchimages854061.png)
    are actually protocol data, not shellcode, and thus we have chosen not to disassemble
    them. Also, IDA seems to have misidentified the system calls that are being made
    at ![](httpatomoreillycomsourcenostarchimages854063.png) and ![](httpatomoreillycomsourcenostarchimages854093.png).
    We have omitted the fact that this exploit was targeting a FreeBSD application,
    which would be helpful in decoding the system call numbers being used in the payload.
    Because IDA is only capable of annotating Linux system call numbers, we are left
    to do a little research to learn that FreeBSD system call `29` (`1dh`) is actually
    `recvfrom` (rather than `pause`) and system call `90` (`5Ah`) is actually the
    `dup2` function (rather than `old_mmap`).
  prefs: []
  type: TYPE_NORMAL
- en: Because it lacks any header information useful to IDA, shellcode will generally
    require extra attention in order to be properly disassembled. In addition, shellcode
    encoders are frequently employed as a means of evading intrusion detection systems.
    Such encoders have an effect very much like the effect that obfuscation tools
    have on standard binaries, further complicating the shellcode-disassembly process.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[199](#CHP-22-FN-14)]) See [http://www.wireshark.org/](http://www.wireshark.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep in mind that IDA is not a silver bullet you can use to make vulnerabilities
    pop out of binaries. If your ultimate goal is to perform vulnerability analysis
    using only IDA, then you would be wise to automate your efforts to the maximum
    extent possible. As you develop algorithms for analyzing binaries, you should
    always consider how you might automate those algorithms in order to save time
    on future analysis tasks. Finally, it is important to understand that no amount
    of reading through the best books available can make you proficient at vulnerability
    analysis and exploit development. If you are interested in developing your skills,
    you must practice. A large number of sites offer practice challenges for just
    this purpose; an excellent starting point is the Wargames section at [http://www.overthewire.org/wargames/](http://www.overthewire.org/wargames/).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 23. Real-World IDA Plug-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Given the variety of uses that IDA has been put to over the years, it should
    not be surprising that a large number of plug-ins have been developed to add capabilities
    that people have found useful in their particular applications of IDA. If you
    decide that you would like to take advantage of other people’s work, know that
    there is no one-stop shop for publicly available plug-ins. The three principal
    locations where you may find references to plug-ins are the Hex-Rays download
    page,^([[200](#ftn.CHP-23-FN-1)]) the OpenRCE downloads page,^([[201](#ftn.CHP-23-FN-2)])
    and the RCE reverse engineering forums.^([[202](#ftn.CHP-23-FN-3)]) Of course,
    spending a little time with Google doesn’t hurt either.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other piece of publicly available software, you may face some challenges
    while attempting to install third-party plug-ins. In cases where plug-in developers
    have elected to publish their efforts, plug-ins are distributed in the form of
    source code, a compiled binary, or both. If forced to build from source, you must
    deal with the make files (or equivalents) supplied by the plug-in’s author, which
    may or may not work with your particular compiler configuration. On the other
    hand, if a plug-in is distributed in binary form, it may have been built with
    a version of the SDK that is incompatible with your version of IDA, which means
    you will not be able to run the plug-in at all until the author elects to release
    an updated version. Finally, the plug-in may have external dependencies that must
    be satisfied in order to build it, run it, or both.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will review several popular IDA plug-ins; their purpose;
    where to obtain them; and how to build, install, and use them.
  prefs: []
  type: TYPE_NORMAL
- en: Hex-Rays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the granddaddy of all IDA plug-ins, Hex-Rays is a decompiler plug-in
    capable of generating “C-like pseudocode”^([[203](#ftn.CHP-23-FN-4)]) for functions
    in compiled ARM or 32-bit x86 binaries. Hex-Rays is a commercial plug-in created
    and sold by the same company that produces IDA. The decompiler is available for
    all 32-bit versions of IDA. Hex-Rays is shipped in binary form only, and installation
    is performed by copying the supplied plug-in into *<IDADIR>/plugins*. A manual
    for using Hex-Rays is available online^([[204](#ftn.CHP-23-FN-5)]) that provides
    a nice overview of using Hex-Rays and that contains some documentation for the
    Hex-Rays SDK^([[205](#ftn.CHP-23-FN-6)]) used to create decompiler plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, the decompiler is activated via View ▸ Open Subviews ▸ Pseudocode
    (hotkey F5) to decompile the function containing the cursor or via File ▸ Produce
    File ▸ Create C File (hotkey ctrl-F5) to decompile all functions in the database
    and save them to a file.
  prefs: []
  type: TYPE_NORMAL
- en: When you generate pseudocode for a single function, a new subview (tabbed window)
    containing the decompiled function opens in the IDA display. [Example 23-1](ch23.html#example_hex-rays_output
    "Example 23-1. Example Hex-Rays output") shows an example of pseudocode generated
    using Hex-Rays to examine a Defcon 15 Capture the Flag binary. Each time you generate
    pseudocode for a function, Hex-Rays opens a new tabbed window to display the result.
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-1. Example Hex-Rays output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note that while Hex-Rays uses a slightly different dummy-naming convention for
    arguments (`a1`, `a2`, etc.) and local variables (`v1`, `v2`) than is used in
    IDA, the ability to distinguish between function parameters and local variables
    remains. If you have changed the names of any variables within the disassembly,
    the decompiler will make use of those names rather than internally generated dummy
    names.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | Hex-Rays Decompiler |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Ilfak Guilfanov, [Hex-Rays.com](http://hex-rays.com) |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Binary only |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | US$2,239 |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Generates C-like pseudocode from compiled ARM or 32-bit,
    x86 functions |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://www.hex-rays.com/decompiler.shtml](http://www.hex-rays.com/decompiler.shtml)
    |'
  prefs: []
  type: TYPE_TB
- en: Hex-Rays utilizes the same cues employed by IDA to deduce datatypes; however,
    you will probably notice some type casting taking place in order to coerce type
    conversions where the types used in an operation do not appear to match Hex-Rays’s
    expectations. As a convenience, you may tell Hex-Rays to hide all casts by right-clicking
    and choosing the Hide Casts menu option.
  prefs: []
  type: TYPE_NORMAL
- en: Once a pseudocode window has been opened, you may use it almost like a source
    code editor and navigator. Navigating and editing within a pseudo-code window
    are much like navigating and editing within a standard IDA disassembly window.
    Double-clicking a function name, for example, immediately causes the selected
    function to be decompiled within the pseudocode window. Many editing features
    are available via context-sensitive menus, as shown in [Figure 23-1](ch23.html#hex-rays_decompiler_editing_options
    "Figure 23-1. Hex-Rays decompiler editing options"), including the ability to
    change variable and function names and types.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hex-Rays decompiler editing options](httpatomoreillycomsourcenostarchimages854344.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-1. Hex-Rays decompiler editing options
  prefs: []
  type: TYPE_NORMAL
- en: Further, changes that you make to variable names, function names, and datatypes
    are propagated back to IDA’s disassembly windows. Through repeated application
    of Rename and Set Type, and by hiding casts, [Example 23-1](ch23.html#example_hex-rays_output
    "Example 23-1. Example Hex-Rays output") is easily transformed into the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that information is lost during compilation. There is no need to
    retain symbol information for any nonexternal symbols, and compiler optimizations
    tend to remove redundancies and streamline code. As a result, in addition to the
    liberal use of type casts, you are also likely to notice more `goto` statements
    in the generated pseudocode than you might generally expect to see in human-generated
    C code. This is not unexpected, because it is often very difficult to neatly map
    compiler-generated control flows back to their original C form. However, Hex-Rays
    is capable of recognizing complex C constructs such as `switch` statements, and
    a tremendous amount of work has been put into recognizing standard code sequences
    utilized by various C compilers.
  prefs: []
  type: TYPE_NORMAL
- en: For all of its capabilities, you are encouraged not to become overreliant on
    Hex-Rays. C source is certainly easier to read and more succinct than its corresponding
    assembly representation, but decompilation is not a perfect science. In reading
    Hex-Rays pseudocode, you are trusting that what you see is a faithful representation
    of the underlying assembly, and while Ilfak works very hard to ensure that Hex-Rays
    is as accurate as possible, there are certainly edge cases that may prove problematic
    for Hex-Rays. It is highly recommended that you back up any conclusions you draw
    from reading Hex-Rays pseudo-code by verifying them against the underlying assembly
    code. Finally, keep in mind that while Hex-Rays may be used on binaries compiled
    from C++ code, it is only capable of generating C code, and the resulting code
    will lack any features that are specific to C++.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[200](#CHP-23-FN-1)]) See [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[201](#CHP-23-FN-2)]) See [http://www.openrce.org/downloads/](http://www.openrce.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[202](#CHP-23-FN-3)]) See [http://www.woodmann.com/forum/index.php](http://www.woodmann.com/forum/index.php).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[203](#CHP-23-FN-4)]) See [http://www.hex-rays.com/decompiler.shtml](http://www.hex-rays.com/decompiler.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[204](#CHP-23-FN-5)]) See [http://www.hex-rays.com/manual/](http://www.hex-rays.com/manual/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[205](#CHP-23-FN-6)]) See [http://www.hexblog.com/?p=107](http://www.hexblog.com/?p=107).
    Not to be confused with IDA SDK.
  prefs: []
  type: TYPE_NORMAL
- en: IDAPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDAPython began life as a third-party IDA plug-in developed by Gergely Erdelyi
    and is covered more thoroughly in [Chapter 15](ch15.html "Chapter 15. IDA Scripting").
    Its popularity among IDA users spread rapidly, and since IDA 5.4, IDAPython has
    shipped as a standard plug-in with all versions of IDA. Nonetheless, IDAPython
    remains available as an open source project that you may download and modify to
    suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions for building IDAPython are available in the file *BUILDING.txt*
    contained in the IDAPython source, while instructions for installation are available
    on the IDAPython website. If you elect to build IDAPython from source, a number
    of dependencies must be satisfied. First and foremost is the need to have a working
    installation of 32-bit Python. Windows and OS X users are recommended to obtain
    and install Python using one of the installers available at the Python website.^([[206](#ftn.CHP-23-FN-7)])
    Linux users can generally get by with the 32-bit version of Python available for
    their flavor of Linux. Note that as of this writing, IDAPython is not compatible
    with Python version 3.*x*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | IDAPython |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Gergely Erdelyi |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Source and binary (A binary version also ships with IDA.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Python scripting engine for IDA Pro |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
    |'
  prefs: []
  type: TYPE_TB
- en: The Python build script supplied with IDAPython, *build.py*, makes use of the
    Simplified Wrapper Interface Generator (SWIG)^([[207](#ftn.CHP-23-FN-8)]) to generate
    the components required to interface Python to IDA’s C++ libraries, and the header
    files that ship with the IDA SDK (since version 5.4) contain a number of macro
    declarations to ensure that they are compatible with SWIG. In addition to SWIG,
    the build process requires a C++ compiler. For Windows builds, the build script
    is configured to use Microsoft Visual C++,^([[208](#ftn.CHP-23-FN-9)]) while for
    Linux and Mac builds, the build process utilizes g++.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[206](#CHP-23-FN-7)]) See [http://www.python.org/](http://www.python.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[207](#CHP-23-FN-8)]) See [http://www.swig.org/](http://www.swig.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[208](#CHP-23-FN-9)]) To obtain a free, stripped-down version of Visual C++,
    please visit [http://www.microsoft.com/express/](http://www.microsoft.com/express/).
  prefs: []
  type: TYPE_NORMAL
- en: collabREate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collabREate plug-in is designed to facilitate collaboration between multiple
    users analyzing the same binary file. The goals of the project are to provide
    a natural integration of a plug-in component representing the synchronization
    client with a robust server component backed by a SQL database and capable of
    supporting features beyond simple database synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | collabREate |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Chris Eagle and Tim Vidas |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | C++ source and binary (including IDA freeware) |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Collaborative framework for synchronizing remote IDA sessions
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://www.idabook.com/collabreate/](http://www.idabook.com/collabreate/)
    |'
  prefs: []
  type: TYPE_TB
- en: From a high-level perspective, collabREate owes much to the IDA Sync project.^([[209](#ftn.CHP-23-FN-10)])
    The collabREate plug-in processes databases updates and communicates with a remote
    server component to synchronize database updates with additional project members.
    Because IDA is a single-threaded application, some mechanism for dealing with
    asynchronous non-blocking network communications is necessary. In IDA versions
    prior to 6.0, the asynchronous communications component derives from the Windows
    Asynchronous Sockets techniques used by IDA Sync; however, with the introduction
    of IDA 6.0, asynchronous communications are now handled using Qt socket classes,
    allowing collabREate to be used on all IDA-supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: CollabREate takes an integrated approach to capturing user actions by leveraging
    IDA’s process and IDB event-notification mechanisms. By hooking various database
    change notifications, collabREate is able to seamlessly propagate database updates
    to the collabREate server. The types and numbers of change notifications generated
    by IDA have grown with each release of IDA, and collabREate endeavors to hook
    as many useful notifications as it possibly can for the version of IDA that it
    has been built for. An interesting side effect of using collabREate is that it
    allows users of very different versions of IDA (5.2 and 6.0, for example) to synchronize
    their activities even when they would be unable to exchange *.idb* files with
    one another.^([[210](#ftn.CHP-23-FN-11)]) The collabREate architecture offers
    true publish and subscribe capabilities to participating users. A user may selectively
    choose to publish her changes to the collabREate server, subscribe to changes
    posted to the server, or both publish and subscribe. For example, an experienced
    user may wish to share (publish) her changes with a group while blocking (not
    subscribing to) all changes made by other users. Users may select the types of
    actions to which they may publish and subscribe, such as byte-value changes, name
    changes, and the addition or deletion of comments. For example, one user may wish
    only to publish comments, while another user may wish to subscribe only to name
    changes and patched-byte notifications.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most significant features of the collabREate plug-in is its degree
    of integration with the IDA SDK. IDA notifications are tied to specific database
    actions, not specific user actions. The fact that user actions happen to trigger
    IDA notifications is, of course, critical to the collaborative process; however,
    notifications can be triggered by other means as well. Scripts and API function
    calls can generate notification messages as well. As a result, the actions of
    a script that patches database bytes, renames locations or variables, or inserts
    new comments will be published to the collabREate server and will ultimately be
    shared with other IDA users working on the same project.
  prefs: []
  type: TYPE_NORMAL
- en: The collabREate server component is currently implemented in Java and utilizes
    JDBC^([[211](#ftn.CHP-23-FN-12)]) to communicate with a backend SQL database.
    The server is responsible for user and project management. User accounts are managed
    via a command-line interface to the server, while projects are created by users
    as they connect to the server. Following authentication with the server, a user’s
    collabREate plug-in sends the MD5 hash of the input file that the user is analyzing
    to the server. The MD5 value is used to ensure that multiple users are in fact
    working on identical input files. Upon initial connection, users indicate the
    types of updates that they would like to subscribe to, at which point the server
    forwards all updates that have been cached since the user’s last session. CollabREate’s
    Project Selection dialog is shown in [Figure 23-2](ch23s03.html#collabreate_project_selection_dialog
    "Figure 23-2. CollabREate Project Selection dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![CollabREate Project Selection dialog](httpatomoreillycomsourcenostarchimages854347.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-2. CollabREate Project Selection dialog
  prefs: []
  type: TYPE_NORMAL
- en: Users are presented with a drop-down list of projects that are compatible with
    the current database. As an option, it is always possible to create a new project
    that requires the user to enter a project description for others to view.
  prefs: []
  type: TYPE_NORMAL
- en: The collabREate server is capable of forking existing projects to allow users
    to create alternate branches of a project without impacting other users. This
    is a useful feature if you want to make (and track) a significant number of changes
    to a database without forcing those changes on other users. Since the server is
    capable of handling multiple projects related to a single binary input file, the
    plug-in and the server take additional steps to ensure that users are connecting
    to the proper project for their particular database.
  prefs: []
  type: TYPE_NORMAL
- en: The server does not provide rollback capability but does provide for a form
    of “save point.” A snapshot can be made at any time; then, to return to that database
    state, a user could re-open the binary (new *.idb* file) and fork a new project
    from the snapshot. This allows users to return to a specific point in time in
    the reversing process. CollabREate’s fork and snapshot features are accessed through
    the same hotkey sequence used for initial activation of the plug-in, which results
    in the dialog shown in [Figure 23-3](ch23s03.html#collabreate_select_command_dialog
    "Figure 23-3. CollabREate Select Command dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![CollabREate Select Command dialog](httpatomoreillycomsourcenostarchimages854350.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-3. CollabREate Select Command dialog
  prefs: []
  type: TYPE_NORMAL
- en: A final feature of the collabREate server is the ability to restrict users to
    specific types of updates. For example, one user may be restricted to a subscribe-only
    profile, while another user may be allowed to publish only comments, while a third
    is allowed to publish all types of updates.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[209](#CHP-23-FN-10)]) See [http://pedram.redhive.com/code/ida_plugins/ida_sync/](http://pedram.redhive.com/code/ida_plugins/ida_sync/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[210](#CHP-23-FN-11)]) Older versions of IDA are typically unable to open
    *.idb* files created with newer versions of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[211](#CHP-23-FN-12)]) *JDBC* is the Java Database Connectivity API.
  prefs: []
  type: TYPE_NORMAL
- en: ida-x86emu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reverse engineering binaries often involves hand tracing through code in order
    to develop an understanding of how a function behaves. In order to do this, you
    need a solid understanding of the instruction set you are analyzing and a handy
    reference to refresh your memory when you encounter an instruction that doesn’t
    look familiar. An instruction emulator can be a useful tool to track all of the
    register and CPU state changes that take place over a series of instructions.
    The ida-x86emu plug-in, which was discussed in detail in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis") and whose information is shown again here,
    is one such emulator.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | ida-x86emu |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Chris Eagle |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Source for SDK v6.1 and binaries for all versions of IDA
    from 5.0, including IDA Freeware. Source is backward compatible to SDK version
    4.9. |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Embedded x86 instruction emulator for IDA |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://www.idabook.com/ida-x86emu/](http://www.idabook.com/ida-x86emu/)
    |'
  prefs: []
  type: TYPE_TB
- en: This plug-in is distributed in source and binary form and is compatible with
    IDA SDK versions 4.6 and later. The plug-in is distributed with build scripts
    and project files to facilitate building with MinGW tools or Microsoft Visual
    Studio on Windows platforms and g++ on non-Windows platforms. A precompiled binary
    version of the plug-in for use with IDA freeware is included in the distribution.
    ida-x86emu is compatible with all Qt-based versions of IDA; however, prior to
    IDA 6.0, the plug-in is compatible with only the Windows GUI version of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: The plug-in was developed with self-modifying code in mind and operates by reading
    instruction bytes from the current IDA database, decoding the instruction, and
    performing the associated operation. Operations may involve updating the emulator’s
    internal register variables or writing back to the database in the case of self-modifying
    code. A simulated stack and a heap are implemented by allocating new IDA segments
    that are read and written as appropriate. For more detailed information on using
    ida-x86emu, please refer to [Chapter 21](ch21.html "Chapter 21. Obfuscated Code
    Analysis").
  prefs: []
  type: TYPE_NORMAL
- en: Class Informer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall from [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures")
    that C++ programs may include information that can assist you in recovering class
    names and class hierarchies. This embedded information is designed to support
    C++ Runtime Type Identification (RTTI). The C++ Class Informer plug-in by Sirmabus
    is designed to assist in the process of reverse engineering C++ code that was
    compiled using Microsoft Visual Studio. Class Informer automates much of the process
    described by Igor Skochinsky in his OpenRCE article on reversing Microsoft Visual
    C++^([[212](#ftn.CHP-23-FN-13)]) by identifying virtual function tables (vtables
    or vftables) and RTTI information and then extracting related class name and inheritance
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | Class Informer |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Sirmabus |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Binary only |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | MSVC C++ class identifier |'
  prefs: []
  type: TYPE_TB
- en: '| **Download** | [http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip](http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip)
    |'
  prefs: []
  type: TYPE_TB
- en: Upon activation, Class Informer displays the options dialog shown in [Figure 23-4](ch23s05.html#class_informer_options_dialog
    "Figure 23-4. Class Informer options dialog"), allowing the user to dictate where
    within the binary Class Informer should scan for vtables and permitting the user
    to control the verbosity of Class Informer’s output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Class Informer options dialog](httpatomoreillycomsourcenostarchimages854353.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-4. Class Informer options dialog
  prefs: []
  type: TYPE_NORMAL
- en: Once the user clicks Continue, Class Informer begins its scan, which may take
    some time depending on the size of the binary and the number of virtual function
    tables that Class Informer encounters. When complete, Class Informer opens a new
    tabbed window within IDA in order to summarize its findings. A partial listing,
    representative of Class Informer’s output, is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: For each virtual function table discovered, Class Informer displays the address
    of the vtable ![](httpatomoreillycomsourcenostarchimages854061.png), the method
    count ![](httpatomoreillycomsourcenostarchimages854063.png) (equal to the number
    of function pointers contained in the vtable), and summary information about each
    class ![](httpatomoreillycomsourcenostarchimages854093.png) derived from embedded
    RTTI information. Recovered class information includes the name of the class,
    the name of any superclasses, and an indication of whether the class inherits
    from a single base class (`[SI]`) or multiple base classes (`[MI]`). For each
    vtable discovered, Class Informer also applies structure templates to all of the
    RTTI-related data structures associated with the class as well as naming each
    structure and the class’s vtable in accordance with Microsoft’s name-mangling
    scheme. This results in a substantial time saving for anyone who may be reverse
    engineering Visual C++ code of any complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[212](#CHP-23-FN-13)]) See [http://www.openrce.org/articles/full_view/23](http://www.openrce.org/articles/full_view/23).
  prefs: []
  type: TYPE_NORMAL
- en: MyNav
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While not, strictly speaking, a plug-in, Joxean Koret’s Python scripts, dubbed
    *MyNav*, certainly qualify as a useful IDA extension, useful enough that MyNav
    earned the top spot in the Hex-Rays plug-in writing contest for 2010.^([[213](#ftn.CHP-23-FN-14)])
    The *mynav.py* script should be launched after you have loaded a binary and the
    initial autoanalysis has completed. Upon launch, MyNav adds 20 new menu options
    to IDA’s Edit ▸ Plugins menu, at which point you are ready to take advantage of
    a number of new features.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | MyNav |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Joxean Koret |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Python source |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | Debugger tracing and code coverage tool |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://code.google.com/p/mynav/](http://code.google.com/p/mynav/)
    |'
  prefs: []
  type: TYPE_TB
- en: Among the features added by MyNav are a function-level (as opposed to basic
    block-level) graphical browser inspired by Zynamics’s BinNavi, additional graphing
    features such as displaying the code paths between any two functions, and a number
    of features designed to enhance IDA’s debugging capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: For debugging, MyNav records information about debugging sessions and allows
    you to use the results of one debugging session to serve as a filter for subsequent
    sessions. Following any debugging session, MyNav displays a graph that highlights
    only those functions executed during the session. Using the capabilities offered
    by MyNav, it is possible to quickly narrow down sets of functions that are responsible
    for specific actions within a program. For example, if you happen to be interested
    in the functions that are responsible for initiating network connections and downloading
    some content, you might create a session that does everything but initiate a network
    connection and then conduct a second session in which you do create a network
    connection. By excluding all functions that executed during your first debugging
    session, the resulting graph will contain hits for just those functions responsible
    for initiating the network connection. This feature is very useful if you are
    trying to characterize functions with very large binaries.
  prefs: []
  type: TYPE_NORMAL
- en: For a full discussion of MyNav’s features, please refer to Joxean’s blog,^([[214](#ftn.CHP-23-FN-15)])
    where you will find a number of video walkthroughs demonstrating some of the capabilities
    of MyNav.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[213](#CHP-23-FN-14)]) See [http://www.hex-rays.com/contest2010/#mynav](http://www.hex-rays.com/contest2010/#mynav).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[214](#CHP-23-FN-15)]) See [http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/](http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/).
  prefs: []
  type: TYPE_NORMAL
- en: IdaPdf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Document-based malware is becoming increasingly common. Malicious PDF files
    are one example of document files designed to exploit vulnerabilities in document-viewing
    software. Analyzing malicious PDF files (or any document files for that matter)
    requires that you understand the structure of the file you are analyzing. In dissecting
    the structure of such a file, your goal is often to discover any embedded code
    that may get executed if the document is successfully utilized to compromise a
    computer used to view it. The few PDF analysis tools that exist are primarily
    targeted at the command-line user with the goal of facilitating the extraction
    of information that might ultimately be loaded into IDA for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | IdaPdf |'
  prefs: []
  type: TYPE_TB
- en: '| **Author** | Chris Eagle |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | C++ source |'
  prefs: []
  type: TYPE_TB
- en: '| **Price** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **Description** | PDF loader and plug-in for dissecting and navigating PDF
    files |'
  prefs: []
  type: TYPE_TB
- en: '| **Information** | [http://www.idabook.com/idapdf/](http://www.idabook.com/idapdf/)
    |'
  prefs: []
  type: TYPE_TB
- en: IdaPdf consists of an IDA loader module and an IDA plug-in module, each designed
    to facilitate the analysis of PDF files. The loader component of IdaPdf recognizes
    PDF files and loads them into a new IDA database. The loader takes care of breaking
    the PDF into its individual components. During the loading process, the loader
    makes every attempt to extract and filter all PDF stream objects. Since loader
    modules get unloaded once the load process is complete, a second component, the
    IdaPdf plug-in, is required in order to provide PDF analysis capabilities beyond
    the initial loading. The plug-in module, upon recognizing that a PDF file has
    been loaded, proceeds to enumerate all of the PDF objects contained within the
    file and opens a new tabbed window containing a list of every object within the
    PDF. The following listing is representative of the type of information contained
    in the PDF Objects window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The listing shows object numbers along with the location of the object, the
    object’s data, any filters that must be applied to stream objects, and a pointer
    to the extracted, unfiltered data. Context-sensitive menu options allow for easy
    navigating to view either the object data or any extracted filtered data. The
    opportunity to extract object data, either raw or filtered, is also made available
    via context-sensitive menu options. The Ascii column indicates the plug-in’s best-effort
    opinion as to whether the object contains only ASCII data in its raw or filtered
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: The last features implemented by IdaPdf are exposed through the addition of
    two new menu options under Edit ▸ Other when IdaPdf is launched. These menu options
    allow you to highlight a block of data in the database and then ask the plug-in
    to Base64 decode the data or unescape^([[215](#ftn.CHP-23-FN-16)]) the data, with
    the results being copied into a newly created section within IDA. Such uncoded
    data will often turn out to be the malicious payload contained within the PDF.
    Since the plug-in extracts this data to a new IDA segment, it is fairly straightforward
    to navigate to the extracted data and ask IDA to disassemble some or all of it.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[215](#CHP-23-FN-16)]) The plug-in implements the JavaScript unescape function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anytime you find yourself wishing that IDA could perform some task, you should
    take a moment to wonder whether anyone else may have had the same wish and, further,
    whether someone has done something about implementing the missing functionality.
    Many IDA plug-ins are the result of exactly this kind of effort. The vast majority
    of publicly available plug-ins are short and sweet and designed to solve a specific
    problem. In addition to serving as potential solutions for your reverse engineering
    problems, plug-ins for which source code is available can serve as valuable references
    for interesting uses of the IDA SDK.
  prefs: []
  type: TYPE_NORMAL
