- en: Part I-1. NETWORKING FUNDAMENTALS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP/IP OVERVIEW AND BACKGROUND INFORMATION
  prefs: []
  type: TYPE_NORMAL
- en: They say the best place to start is at the beginning, and that's exactly where
    you are now. This initial section contains background information that will help
    you to understand what networking is about and where TCP/IP fits into the grand
    scheme of things. This introductory information will help ease you into your studies
    of TCP/IP, and it is particularly valuable to those who are new to the world of
    networking.
  prefs: []
  type: TYPE_NORMAL
- en: This section contains three parts. The first part covers a number of important
    fundamental aspects of networks, discussing how they are used, the standards that
    define them, the terminology that describes them, and much more. The second part
    describes the important OSI Reference Model, which is an essential tool to comprehending
    the function and organization of networking technologies. The third part contains
    a high-level overview of the TCP/IP protocol suite, which will frame the more
    complete discussions of individual TCP/IP protocols that follow in the latter
    two sections of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS,
    AND TYPES")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. NETWORK PERFORMANCE ISSUES AND CONCEPTS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS
    OF COMPUTING")'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike authors of many other TCP/IP-related resources, I do not assume that
    readers already know what networking is all about. After all, that's why you are
    reading this book!
  prefs: []
  type: TYPE_NORMAL
- en: This part provides an overview of some of the basic issues related to networking.
    It includes discussions of some of the most fundamental networking concepts and
    ideas. It serves not only to provide you with useful background material, but
    also as a repository for general information, so that I don't need to repeat it
    in many different places elsewhere in the book (and if you already know about
    these basics, you don't need to skip over them in many other locations). The topics
    covered here are useful for understanding certain TCP/IP concepts. However, some
    of the material is very broadly oriented toward networking as a whole and is not
    specific to TCP/IP internetworking.
  prefs: []
  type: TYPE_NORMAL
- en: This part consists of four chapters. The first chapter in this part introduces
    networking in broad terms, describes its fundamental characteristics, and differentiates
    between network sizes and types. The second chapter talks about many different
    matters related to network performance. The third chapter explains the importance
    of networking standards and standards organizations. Finally, the fourth chapter
    provides background information about how data is stored and manipulated in computers;
    if you are new to computing, you may find this information useful when reading
    some other parts of this book. If you are experienced in networking and related
    technologies, you may wish to skip this part of the book. Or, you can scan the
    headings in the chapters; if you understand the terminology mentioned in a heading,
    you can probably skip the discussion. Cross-references in other areas of the book
    refer to information in this part as appropriate, so if you need to fill in your
    knowledge of a particular fundamental on the fly, you can do so rather easily.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Someone new to networking will usually have some pretty important questions.
    What is networking all about? What are the most important attributes that describe
    networks? And what sort of networks exist? The obvious place to begin discussing
    networking fundamentals is to answer those questions using a high-level introduction
    to networking as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is divided into three sections. The first provides a quick introduction
    to networking. I define networking in the most basic terms, then place networking
    in an overall context by describing some of its advantages and benefits, as well
    as some of its disadvantages and costs.
  prefs: []
  type: TYPE_NORMAL
- en: The second section discusses key concepts that describe and differentiate between
    types of networks and networking technologies. This is where I'll define terms
    and "buzzwords" that you cannot avoid if you are going to learn about networks.
    The topics here include explanations of protocols, switching methods, types of
    network messages, message formatting, and ways of addressing messages. I also
    discuss the differences between client-server and peer-to-peer networking.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section, I describe the major types of networks by drawing distinctions
    between them based on their size and scope, and I also show you how to use each
    type and size. I discuss LANs, WLANs, and WANs, and a few variations on these
    three main categories. I also explore the many terms that are related to the various
    sizes of networks and how they are used, including segments, subnetworks, internetworks,
    intranets, and extranets.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this day and age, networks are everywhere, especially in the form of the
    Internet. The Internet, the ultimate network, has revolutionized not only the
    computer world, but the lives of millions. We tend to take for granted that computers
    should be connected together. In fact, these days, whenever I have two computers
    in the same room, I have a difficult time *not* connecting them!
  prefs: []
  type: TYPE_NORMAL
- en: Given the ubiquitousness of networking, it's hard to believe that the field
    is still a relatively young one, especially when it comes to hooking up PCs. In
    approaching any discussion of networking, it is very useful to take a step back
    and look at networking from a higher level. What is it, exactly, and why is it
    now considered so important that it is just assumed that most PCs and other devices
    will be networked?
  prefs: []
  type: TYPE_NORMAL
- en: What Is Networking?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For such an extensive and involved subject that includes so many different technologies,
    hardware devices, and protocols, networking is actually quite simple. A *network*
    is simply a collection of computers or other hardware devices that are connected
    together, either physically or logically, using special hardware and software
    that allows the devices to exchange information and cooperate. *Networking* is
    the term that describes the processes involved in designing, implementing, upgrading,
    managing, and otherwise working with networks and network technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A network is a set of hardware devices connected together,
    either physically or logically. This allows them to exchange information.'
  prefs: []
  type: TYPE_NORMAL
- en: Networks are used for an incredible array of purposes. Most people learning
    about networking think about networking as interconnecting PCs and other "true"
    computers, but you use a variety of types of networks every day. Each time you
    pick up a phone, use a credit card at a store, get cash from an ATM machine, or
    even plug in an electrical appliance, you are using some type of network.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the definition can even be expanded beyond the world of technology.
    I'm sure you've heard the term *networking* used to describe the process of finding
    an employer or employee through friends and associates. Similarly, the idea here
    is that independent units are connected together to share information and cooperate.
  prefs: []
  type: TYPE_NORMAL
- en: The widespread networking of personal computers is a relatively new phenomenon.
    For the first decade or so of their existence, PCs were very much "islands unto
    themselves," and were rarely connected together. In the early 1990s, PC networking
    began to grow in popularity as businesses realized the advantages that networking
    could provide. By the late 1990s, networking in homes with two or more PCs really
    started to take off as well.
  prefs: []
  type: TYPE_NORMAL
- en: This interconnection of small devices represents, in a way, a return to the
    good old days of mainframe computers. Before computers were small and personal,
    they were large and centralized machines that many users operating remote terminals
    shared. Although having all of that computer power in one place had many disadvantages,
    one benefit was that all users were connected because they shared the central
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individualized PCs took away that advantage. Networking attempts to move computing
    to a middle ground. It provides PC users with the best of both worlds: the independence
    and flexibility of personal computers, and the connectivity and resource sharing
    of mainframes. In fact, networking today is considered so vital that it''s hard
    to conceive of an organization with two or more computers that would not want
    to connect them together!'
  prefs: []
  type: TYPE_NORMAL
- en: The Advantages and Benefits of Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have undoubtedly heard the expression "The whole is greater than the sum
    of its parts." This phrase describes networking very well and explains why it
    has become so popular. A network isn't just a bunch of computers with wires running
    between them. Properly implemented, a network is a system that provides its users
    with unique capabilities, above and beyond what the individual machines and their
    software applications can provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the benefits of networking can be divided into two basic categories:
    *connectivity* and *sharing*. Networks allow computers, and hence their users,
    to connect to each other. They also allow for the easy sharing of information
    and resources, and for the simple cooperation between the devices in other ways.
    Since modern business depends so much on the intelligent flow and management of
    information, this ease of use tells you a lot about why networking is so valuable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, in no particular order, are some of the specific advantages generally
    associated with networking:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connectivity and Communication** Networks connect computers and the users
    of those computers. Individuals within a building or workgroup can be connected
    through *local area networks (LANs)*; LANs in distant locations can be interconnected
    to form larger, *wide area networks (WANs)*. Once computers are connected, it
    is possible for network users to communicate with each other using technologies
    such as electronic mail. This makes the transmission of business (or nonbusiness)
    information easier, more efficient, and less expensive than it would be without
    the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Sharing** One of the most important uses of networking is to allow the
    sharing of data. Before networking was common, an accounting employee who wanted
    to prepare a report for her manager would have to produce it on her PC, put it
    on a floppy disk, and then walk it over to the manager, who would transfer the
    data to her PC''s hard disk. (This sort of "shoe-based network" was sometimes
    sarcastically called a *sneakernet*.)'
  prefs: []
  type: TYPE_NORMAL
- en: True networking allows thousands of employees to share data much more easily
    and quickly than this. It also makes possible applications that enable many people
    to access and share the same data, such as databases, group software development,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Sharing** Networks facilitate the sharing of hardware devices. For
    example, instead of giving each employee in a department an expensive color printer
    (or resorting to the sneakernet again), you can place one printer on the network
    for everyone to share.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Access** The Internet is itself an enormous network, so whenever
    you access the Internet, you are using a network. The significance of the Internet
    today is hard to exaggerate!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Access Sharing** Small computer networks allow multiple users to
    share a single Internet connection. Special hardware devices allow the bandwidth
    of the connection to be easily allocated to various individuals as they need it,
    and these devices permit an organization to purchase one high-speed connection
    instead of many slower ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Security and Management** In a business environment, a network allows
    the administrators to manage the company''s critical data better. Instead of spreading
    data over dozens or even hundreds of small computers in a haphazard fashion as
    users create it, administrators can centralize data on shared servers. This makes
    it easy for everyone to find the data and makes it possible for the administrators
    to ensure that the data is regularly backed up. Administrators can also implement
    security measures to control who can read or change various pieces of critical
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance Enhancement and Balancing** Under some circumstances, you can
    use a network to enhance the overall performance of some applications by distributing
    the computation tasks to various computers on the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entertainment** Networks facilitate many types of games and entertainment.
    The Internet itself offers many sources of entertainment. In addition, many multiplayer
    games operate over a LAN. Many home networks are set up for this reason, and gaming
    across WANs (including the Internet) has also become quite popular. Of course,
    if you are running a business and have employees who are easily amused, you might
    insist that this is really a *disadvantage* of networking rather than an advantage!'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** At a high level, networks are advantageous because they allow
    computers and people to be connected together so that they can share resources.
    Some of the specific benefits of networking include communication, data sharing,
    Internet access, data security and management, application performance enhancement,
    and entertainment.'
  prefs: []
  type: TYPE_NORMAL
- en: The Disadvantages and Costs of Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that I have discussed the great value and many useful benefits of networking,
    I must bring you crashing back to Earth with that old nemesis of the realistic:
    TANSTAAFL. For those who are not Heinlein fans, this acronym stands for "There
    ain''t no such thing as a free lunch." Even though networking really does represent
    a whole that is greater than the sum of its parts, it does have some real and
    significant costs and drawbacks associated with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few disadvantages of networking:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Hardware, Software, and Setup Costs** Computers don''t just magically
    network themselves, of course. Setting up a network requires an investment in
    hardware and software, as well as funds for planning, designing, and implementing
    the network. For a home with a small network of two or three PCs, this is relatively
    inexpensive. It amounts to more or less a hundred dollars with today''s low prices
    for network hardware, and practically no setup costs considering that the operating
    systems have already been designed for networks. For a large company, however,
    costs can easily run into tens of thousands of dollars or more.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware and Software Management and Administration Costs** In all but the
    smallest of implementations, ongoing maintenance and management of the network
    requires the care and attention of an IT professional. In a smaller organization
    that already has a system administrator, a network may fall within this person''s
    job responsibilities, but it will take time away from other tasks. In more substantial
    organizations, a network administrator may need to be hired, and in large companies
    an entire department may be necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Undesirable Sharing** With the good comes the bad; though networking allows
    the easy sharing of useful information, it also allows the sharing of undesirable
    data. One significant sharing problem in this regard has to do with viruses, which
    are easily spread over networks and the Internet. Mitigating these effects costs
    time, money, and administrative effort.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Illegal or Undesirable Behavior** Similar to the previous point, networking
    facilitates useful connectivity and communication, but also brings difficulties
    with it. Typical problems include the abuse of company resources, distractions
    that reduce productivity, the downloading of illegal or illicit materials, and
    even software piracy. In larger organizations, these issues must be managed through
    explicit policies and monitoring, which, again, further increases management costs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Security Concerns** If a network is implemented properly, it is possible
    to greatly improve the security of important data. In contrast, a poorly secured
    network puts critical data at risk, exposing it to the potential problems associated
    with hackers, unauthorized access, and even sabotage.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of these costs and potential problems can be managed by those who set up
    and run networks. In the end, the choice of whether to use a network is a matter
    of weighing the advantages against the disadvantages. Today, nearly everyone decides
    that networking is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Networking has a few drawbacks that you can weigh against its
    many positive aspects. Setting up a network has costs in hardware, software, maintenance,
    and administration. It is also necessary to manage a network to keep it running
    smoothly and to address possible misuse or abuse issues. Data security also becomes
    a much bigger concern when computers are connected together.'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental Network Characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many different kinds of networks and network technologies that are
    used to create them. The proliferation of networking methods has generally occurred
    for a very good reason: Different needs require different solutions. The drawback
    of this is that there are so many different types of protocols and technologies
    for the networking student to understand!'
  prefs: []
  type: TYPE_NORMAL
- en: Before you can really compare these approaches, you need to understand some
    of the basic characteristics that make networks what they are. Although network
    types may be quite dissimilar, they are often described and even contrasted on
    the basis of a number of common attributes, which I'll discuss in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Networking Layers, Models, and Architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the reasons why many people find networking difficult to learn is that
    it can be a very complicated subject. One of the chief reasons for this complexity
    is that networks consist of so many hardware and software elements. While a network
    user may perceive that he is using only one computer program (like a web browser)
    and one piece of hardware (like a PC), these are parts of a much larger puzzle.
    In order for even the simplest task to be accomplished on a network, dozens of
    different components must cooperate by passing control information and data to
    accomplish the overall goal of network communication.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand any complex system is to break it down into pieces
    and then analyze what those pieces do and how they interact. The most logical
    approach is to divide the overall set of functions into modular components, each
    of which is responsible for a particular function. At the same time, you also
    need to define interfaces between these components, which describe how they fit
    together. This enables you to simplify the complexity of networking by approaching
    it in digestible chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Networking technologies are most often compartmentalized in this manner by dividing
    their functions into *layers*, each of which contains hardware and software elements.
    Each layer is responsible for performing a particular type of task and interacts
    with the layers above and below it. Layers are conceptually arranged into a vertical
    *stack*. Lower layers are charged with more concrete tasks such as hardware signaling
    and low-level communication; they provide services to the higher layers. The higher
    layers, in turn, use these services to implement more abstract functions such
    as implementing user applications.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing networks into layers this way is somewhat like the division of labor
    in a manufacturing facility, and it yields similar benefits. Each hardware device
    or software program can be specialized to perform the function needed by that
    layer, like a well-trained specialist on an assembly line. The different modules
    can be combined in different ways as needed. This way, it's also easier to understand
    how a network functions overall.
  prefs: []
  type: TYPE_NORMAL
- en: One other important benefit of layering is that makes it possible for technologies
    defined by different groups to interoperate. For this to be possible, it is necessary
    for everyone to agree on how layers will be defined and used. The most common
    tool for this purpose is a *networking model*. The model describes what the different
    layers are in the network, what each is responsible for doing, and how they interact.
    A univerally accepted model ensures that everyone is on the same page when creating
    hardware and software.
  prefs: []
  type: TYPE_NORMAL
- en: The most common general model in use today is the Open Systems Interconnection
    (OSI) Reference Model, which consists of seven stacked layers. These range from
    the physical layer (layer 1) at the bottom, which is responsible for low-level
    signaling, to the application layer (layer 7) at the top, where application software
    is implemented. Understanding the OSI model is essential to understanding networking
    as a whole. I explain models and layers in more detail, and provide a complete
    description of the OSI Reference Model, in [Part I-2](pt02.html "Part I-2. THE
    OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL") of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Closely related to the concept of a model is the concept of an *architecture*.
    An architecture is essentially a set of rules that describes the function of some
    portion of the hardware and software that constitutes a stack of layers. Such
    a ruleset usually takes the form of a specification or standard that describes
    how equipment and programs using the technology must behave. A networking architecture
    is designed to implement the functions associated with a particular contiguous
    set of layers of the OSI Reference Model, either formally or informally.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I discuss TCP/IP, the protocol suite that runs the Internet. TCP/IP
    is a complex set of technologies that spans many layers of the OSI model. By examining
    the various components of TCP/IP and how they implement different OSI model layers,
    you will really learn how TCP/IP works. For starters, the name of the suite, TCP/IP,
    comes from the Transmission Control Protocol (TCP), which operates at layer 4
    of the OSI model, and the Internet Protocol (IP), which runs at OSI model layer
    3\. IP provides services to layer 4 and uses services from layer 2 below it. TCP
    uses IP's functions and provides functions to the layers above it.
  prefs: []
  type: TYPE_NORMAL
- en: I'll start a more complete examination of TCP/IP by looking at its architecture,
    and by looking at a second, special model that was developed specifically to make
    sense of TCP/IP. Both are explored in [Chapter 8](ch08.html "Chapter 8. TCP/IP
    PROTOCOL SUITE AND ARCHITECTURE").
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocols: What Are They, Anyway?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there's one word you will get used to seeing a lot as you go through this
    book, it is *protocol*. You will see references to networking protocols, internetworking
    protocols, high-level protocols, low-level protocols, protocol stacks, protocol
    suites, subprotocols, and so on. Clearly, protocols are important, yet many reference
    works and standards use the term over and over again without ever explaining it.
    One reason for this may be because the term is somewhat vague and can have many
    meanings.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, understanding a technical term is easier if you go back to look
    at how the term is used in plain English. In the real world, a protocol often
    refers to a code of conduct or a form of etiquette observed by diplomats. These
    people must follow certain rules of ceremony and formality to ensure that they
    communicate effectively without causing conflict. They also must understand what
    is expected of them when they interact with representatives from other nations,
    making sure that, for example, they do not offend anyone due to an unfamiliarity
    with local customs. In fact, most people follow various protocols; they are sort
    of the unwritten rules of society.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem to have little to do with networking, but in fact, this is a pretty
    good high-level description of what networking protocols are about. They define
    a language and a set of rules and procedures that enable devices and systems to
    communicate. Obviously, computers do not have local customs, and they hardly have
    to worry about committing a faux pas that might cause another computer to take
    offense. Networking protocols concern themselves with ensuring that all the devices
    on a network or internetwork are in agreement about how various actions must be
    performed in the total communication process.
  prefs: []
  type: TYPE_NORMAL
- en: A protocol is thus basically a way of ensuring that devices are able to talk
    to each other effectively. In most cases, an individual protocol describes how
    communication is accomplished between one particular software or hardware element
    in two or more devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the OSI Reference Model, a protocol is formally defined as
    a set of rules governing communication between entities at the same layer. For
    example, TCP is responsible for a specific set of functions on TCP/IP networks.
    Each host on a TCP/IP network has a TCP implementation, and those hosts all communicate
    with each other logically at layer 4 of the OSI model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The formalized OSI Reference Model meaning of the word* protocol *is covered
    in the OSI Reference Model topic on horizontal layer communication (discussed
    in [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS"),
    in the section titled "Protocols: Horizontal (Corresponding Layer) Communication")*.'
  prefs: []
  type: TYPE_NORMAL
- en: While OSI Reference Model definitions are sometimes overly theoretical in nature,
    this definition of protocol is rather accurate in assessing protocols in real-world
    networking. If something doesn't specify a means of communication, it arguably
    isn't a protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A networking protocol defines a set of rules, algorithms, messages,
    and other mechanisms that enables software and hardware in networked devices to
    communicate effectively. A protocol usually describes a means for communication
    between corresponding entities at the same OSI Reference Model layer in two or
    more devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite this, the term *protocol* is often used colloquially to refer to many
    different concepts in networking. Some of the more common alternative uses of
    the word are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol Suites** It is very common to hear the word *protocol* used to refer
    to sets of protocols that are more properly called *protocol suites* (or *stacks*,
    in reference to a stack of layers). For example, TCP/IP is often called just a
    protocol when it is really a (large) set of protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Windows Protocols** One important example of the issue of referring
    to protocol suites as single protocols is the networking software in Microsoft
    Windows. It usually calls a full networking stack like TCP/IP or IPX/SPX just
    a protocol. When you install one of these so-called protocols, however, you actually
    get a software module that supports a full protocol suite.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Technologies** Sometimes technologies that are not protocols at all
    are called protocols, either out of convention or perhaps because people think
    it sounds good. For example, TCP/IP Remote Network Monitoring (RMON) is often
    called a protocol when it is really just an enhancement to the Simple Network
    Management Protocol (SNMP), which is a protocol! (See [Part III-4](pt15.html "Part III-4. TCP/IP
    NETWORK MANAGEMENT FRAMEWORK AND PROTOCOLS") for details on SNMP and RMON.)'
  prefs: []
  type: TYPE_NORMAL
- en: So, does it really matter whether a protocol is a "true" protocol or not? Well,
    the networking hardware devices and software programs sure don't care. But hopefully,
    having read about the term and what it means, you will be able to better understand
    the word when you encounter it in your studies—especially in the places where
    it may not always be used in a way that's entirely consistent with its formal
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit-Switching and Packet-Switching Networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Networks are devices that are connected together using special hardware and
    software that allows them to exchange information. The most important word in
    that sentence is the final one: *information*. As you will see in your exploration
    of this book, there are many methods for exchanging information between networked
    devices. There are also a number of ways of categorizing and describing these
    methods and the types of networks that use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One fundamental way to differentiate between networking technologies is on
    the basis of the method used to determine the path between devices over which
    information will flow. In highly simplified terms, there are two approaches: a
    path can be set up between the devices in advance, or the data can be sent as
    individual data elements over a variable path.'
  prefs: []
  type: TYPE_NORMAL
- en: Circuit Switching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *circuit-switching* networking method, a connection called a *circuit*,
    which is used for the whole communication, is set up between two devices. Information
    about the nature of the circuit is maintained by the network. The circuit may
    be either a fixed one that is always present or one that is created on an as-needed
    basis. Even if many potential paths through intermediate devices may exist between
    the two devices that are communicating, only one will be used for any given dialogue,
    as shown in [Figure 1-1](ch01s02.html#circuit_switching_in_a_circuit-switched_
    "Figure 1-1. Circuit switching In a circuit-switched network, before communication
    can occur between two devices, a circuit is established between them. This is
    shown as a darker line for the conduit of data from Device A to Device B, and
    a matching lighter line from B back to A. Once it's set up, all communication
    between these devices takes place over this circuit, even though there are other
    possible ways that data could conceivably be passed over the network of devices
    between them. Contrast this diagram to Figure 1-2.").
  prefs: []
  type: TYPE_NORMAL
- en: The classic example of a circuit-switched network is the telephone system. When
    you call someone and she answers, you establish a circuit connection and can pass
    data in a steady stream. That circuit functions the same way, regardless of how
    many intermediate devices are used to carry your voice. You use it for as long
    as you need it and then terminate the circuit. The next time you call, you get
    a new circuit, which may (probably will) use different hardware than the first
    circuit did, depending on what's available at that time in the network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Circuit switching In a circuit-switched network, before communication can
    occur between two devices, a circuit is established between them. This is shown
    as a darker line for the conduit of data from Device A to Device B, and a matching
    lighter line from B back to A. Once it''s set up, all communication between these
    devices takes place over this circuit, even though there are other possible ways
    that data could conceivably be passed over the network of devices between them.
    Contrast this diagram to .](httpatomoreillycomsourcenostarchimages287683.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1. Circuit switching In a circuit-switched network, before communication
    can occur between two devices, a circuit is established between them. This is
    shown as a darker line for the conduit of data from Device A to Device B, and
    a matching lighter line from B back to A. Once it's set up, all communication
    between these devices takes place over this circuit, even though there are other
    possible ways that data could conceivably be passed over the network of devices
    between them. Contrast this diagram to [Figure 1-2](ch01s02.html#packet_switching_in_a_packet-switched_ne
    "Figure 1-2. Packet switching In a packet-switched network, no circuit is set
    up prior to sending data between devices. Blocks of data, even from the same file
    or communication, may take any number of paths as they journey from one device
    to another. Compare this to Figure 1-1.").
  prefs: []
  type: TYPE_NORMAL
- en: Packet Switching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *packet-switching* network type, no specific path is used for data transfer.
    Instead, the data is chopped up into small pieces called *packets* and sent over
    the network. You can route, combine, or fragment the packets as required to get
    them to their eventual destination. On the receiving end, the process is reversed—the
    data is read from the packets and reassembled to form the original data. A packet-switched
    network is more analogous to the postal system than it is to the telephone system
    (though the comparison isn't perfect). An example is shown in [Figure 1-2](ch01s02.html#packet_switching_in_a_packet-switched_ne
    "Figure 1-2. Packet switching In a packet-switched network, no circuit is set
    up prior to sending data between devices. Blocks of data, even from the same file
    or communication, may take any number of paths as they journey from one device
    to another. Compare this to Figure 1-1.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Packet switching In a packet-switched network, no circuit is set up prior
    to sending data between devices. Blocks of data, even from the same file or communication,
    may take any number of paths as they journey from one device to another. Compare
    this to .](httpatomoreillycomsourcenostarchimages287685.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2. Packet switching In a packet-switched network, no circuit is set
    up prior to sending data between devices. Blocks of data, even from the same file
    or communication, may take any number of paths as they journey from one device
    to another. Compare this to [Figure 1-1](ch01s02.html#circuit_switching_in_a_circuit-switched_
    "Figure 1-1. Circuit switching In a circuit-switched network, before communication
    can occur between two devices, a circuit is established between them. This is
    shown as a darker line for the conduit of data from Device A to Device B, and
    a matching lighter line from B back to A. Once it's set up, all communication
    between these devices takes place over this circuit, even though there are other
    possible ways that data could conceivably be passed over the network of devices
    between them. Contrast this diagram to Figure 1-2.").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One way that networking technologies are categorized is based
    on the path used to carry data between devices. In circuit switching, a circuit
    is first established and then used to carry all data between devices. In packet
    switching, no fixed path is created between devices that communicate; it is broken
    into packets, each of which may take a separate path from sender to recipient.'
  prefs: []
  type: TYPE_NORMAL
- en: Which Switching Method to Choose?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common temptation when considering alternatives such as these is to ask which
    is better; the answer is neither. There are places for which one is more suited
    than the other, but if one were clearly superior, both methods wouldn't be used.
  prefs: []
  type: TYPE_NORMAL
- en: One important issue in selecting a switching method is whether the network medium
    is *shared* or *dedicated*. Your phone line can be used for establishing a circuit
    because you are the only one who can use it—assuming you can keep that pesky wife/husband/child/sister/brother/father/mother
    off it. However, this doesn't work well with LANs, which typically use a single
    shared medium and baseband signaling. If two devices were to establish a connection,
    they would lock out all the other devices for a long period of time. It makes
    more sense to chop the data into small pieces and send them one at a time. Then,
    if two other devices want to communicate, *their* packets can be interspersed,
    and everyone can share the network.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to have many devices communicate simultaneously without dedicated
    data paths is one reason why packet switching is becoming predominant today. However,
    there are some disadvantages of packet switching compared to circuit switching.
    One is that since all data does not take the same predictable path between devices,
    it is possible that some pieces of data may get lost in transit or show up in
    the incorrect order. In some situations this does not matter, but in others it
    is very important indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Although the theoretical difference between circuit and packet switching is
    pretty clear-cut, understanding how to use them is a bit more complicated. One
    of the major issues is that in modern networks, they are often combined.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you connect to the Internet using a dial-up modem. You
    will be using IP datagrams (packets) to carry higher-layer data, but it will be
    over the circuit-switched telephone network. Yet the data may be sent over the
    telephone system in digital packetized form. So in some ways, both circuit switching
    and packet switching are being used concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is the relationship between circuit and packet switching, and
    whether a technology is connection-oriented or connectionless. The two concepts
    are related but not the same, as you will see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The word* packet *is only one of several terms that are used to refer to messages
    that are sent over a network. Other terms that you will encounter include frame,
    datagram, cell, and segment. You will learn more about these terms later in this
    chapter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Connection-Oriented and Connectionless Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I just compared networking technologies based on whether or not they use a dedicated
    path or *circuit* over which they send data. Another way in which technologies
    and protocols are differentiated has to do with whether or not they use *connections*
    between devices. This issue is closely related to the matter of packet versus
    circuit switching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocols are divided into the following two categories based on their use
    of connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection-Oriented Protocols** These protocols require you to establish
    a logical connection between two devices before transferring data. This is generally
    accomplished by following a specific set of rules that specify how a connection
    should be initiated, negotiated, managed, and eventually terminated. Usually,
    one device begins by sending a request to open a connection, and the other responds.
    The devices pass control information to determine if and how the connection should
    be set up. If this is successful, data is sent between the devices. When they
    are finished, the connection is broken.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connectionless Protocols** These protocols do not establish a connection
    between devices. As soon as a device has data to send to another, it just sends
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A connection-oriented protocol is one in which a logical connection
    is first established between devices prior to data being sent. In a connectionless
    protocol, data is just sent without a connection being created.'
  prefs: []
  type: TYPE_NORMAL
- en: You can probably immediately see the relationship between the concepts of circuits
    and connections. Obviously, in order to establish a circuit between two devices,
    you must connect them. For this reason, circuit-switched networks are inherently
    based on connections. This has led to the interchangeable use of the terms *circuit-switched*
    and *connection-oriented*.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is an oversimplification that results from a common logical fallacy—people
    make the mistake of thinking that if A implies B, then B implies A, which is like
    saying that since all apples are fruit, then all fruit are apples! A connection
    is needed for a circuit, but a circuit is *not* a prerequisite for a connection.
    There are, therefore, protocols that are connection-oriented, even though they
    aren't predicated on the use of circuit-based networks at all.
  prefs: []
  type: TYPE_NORMAL
- en: These connection-oriented protocols are important because they enable the implementation
    of applications that require connections over packet-switched networks that have
    no inherent sense of a connection. For example, to use the TCP/IP File Transfer
    Protocol (FTP), you want to be able to connect to a server, enter a login and
    password, and then execute commands to change directories, send or retrieve files,
    and so on. This requires the establishment of a connection over which commands,
    replies, and data can be passed. Similarly, the Telnet Protocol (TP) involves
    establishing a connection—it lets you remotely use another machine. Yet, both
    of these work (indirectly) over IP, which is based on the use of packets, through
    the important principle of layering (see [Chapter 5](ch05.html "Chapter 5. GENERAL
    OSI REFERENCE MODEL ISSUES AND CONCEPTS")).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Circuit-switched networking technologies are inherently connection-oriented,
    but not all connection-oriented technologies use circuit switching. Logical connection-oriented
    protocols can be implemented on top of packet-switching networks to provide higher-layer
    services to applications that require connections.'
  prefs: []
  type: TYPE_NORMAL
- en: To comprehend the relationship between connections and circuits, you must recall
    the layered nature of modern networking architecture (as I discuss in some detail
    in [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS")).
    Even though packets may be used at lower layers for the mechanics of sending data,
    a higher-layer protocol can create logical connections through the use of messages
    sent in those packets.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP has two main protocols that operate at the transport layer of the OSI
    Reference Model. One is TCP, which is connection-oriented; the other, the User
    Datagram Protocol (UDP), is connectionless. TCP is used for applications that
    require the establishment of connections (as well as TCP's other service features),
    such as FTP; it works using a set of rules, as described earlier, by which a logical
    connection is negotiated prior to sending data. UDP is used by other applications
    that don't need connections or other features, but do need the faster performance
    that UDP can offer by not needing to make such connections before sending data.
  prefs: []
  type: TYPE_NORMAL
- en: Some people consider the layering of a connection-oriented protocol over a connectionless
    protocol to be like a simulation of circuit switching at higher network layers;
    this is perhaps a dubious analogy. Even though you can use a TCP connection to
    send data back and forth between devices, all that data is indeed still being
    sent as packets; there is no real circuit between the devices. This means that
    TCP must deal with all the potential pitfalls of packet-switched communication,
    such as the potential for data loss or receipt of data pieces in the incorrect
    order. Certainly, the existence of connection-oriented protocols like TCP doesn't
    obviate the need for circuit-switching technologies, though you will get some
    arguments about that one too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle of layering also means that there are other ways that connection-oriented
    and connectionless protocols can be combined at different levels of an internetwork.
    Just as a connection-oriented protocol can be implemented over an inherently connectionless
    protocol, the reverse is also true: a connectionless protocol can be implemented
    over a connection-oriented protocol at a lower level. In a preceding example,
    I talked about Telnet (which requires a connection) running over IP (which is
    connectionless). In turn, IP can run over a connection-oriented protocol like
    Asynchronous Transfer Mode (ATM).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages: Packets, Frames, Datagrams, and Cells'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many networking technologies are based on packet switching, which involves the
    creation of small chunks of data to be sent over a network. Even though *packet*
    appears in the name of this method, the data items sent between networked devices
    are most generically called *messages*. *Packet* is one of a variety of similar
    words that are used in different contexts to refer to messages sent from one device
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the different terms can be very useful, because the name used
    to refer to a particular message can tell you something about what the message
    contains, as you will see shortly. In particular, different message names are
    usually associated with protocols and technologies operating at specific layers
    of the OSI Reference Model. Thus, the use of these different names can help clarify
    discussions that involve multiple protocols operating at different layers.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, these terms can also cause confusion, because they are not always
    applied in a universal or even consistent manner. Some people are strict about
    applying particular message designations only to the appropriate technologies
    where they are normally used, while others use the different terms completely
    interchangeably. This means that you should be familiar with the different message
    types and how they are normally used, but you should still be prepared for the
    unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common terms used for messages are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Packet** This term is considered by many to correctly refer to a message
    sent by protocols operating at the network layer of the OSI Reference Model. So
    you will commonly see people refer to *IP packets*. However, this term is commonly
    also used to refer generically to any type of message, as I mentioned earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Datagram** This term is basically synonymous with *packet* and is also used
    to refer to network layer technologies. It is also often used to refer to a message
    that is sent at a higher level of the OSI Reference Model (more often than *packet*
    is).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frame** This term is most commonly associated with messages that travel at
    low levels of the OSI Reference Model. In particular, it is most commonly seen
    used in reference to data link layer messages. It is occasionally also used to
    refer to physical layer messages, when message formatting is performed by a layer
    1 technology. A frame gets its name from the fact that it is created by taking
    higher-level packets or datagrams and "framing" them with additional header information
    needed at the lower level.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cell** Frames and packets, in general, can be of variable length, depending
    on their contents; in contrast, a *cell* is most often a message that is fixed
    in size. For example, the fixed-length, 53-byte messages sent in ATM are called
    cells. Like frames, cells are usually used by technologies operating at the lower
    layers of the OSI model.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol Data Unit (PDU) and Service Data Unit (SDU)** These are the formal
    terms used in the OSI Reference Model to describe protocol messages. A PDU at
    layer N is a message sent between protocols at layer N. It consists of layer N
    header information and an encapsulated message from layer N+1, which is called
    both the *layer N SDU* and the *layer N+1 PDU*. After you stop scratching your
    head, see the "Data Encapsulation, Protocol Data Units (PDUs), and Service Data
    Units (SDUs)" section in [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE
    MODEL ISSUES AND CONCEPTS") for a discussion of this.'
  prefs: []
  type: TYPE_NORMAL
- en: I should also point out that there are certain protocols that use unusual names,
    which aren't used elsewhere in the world of networking, to refer to their messages.
    One prominent example is TCP, which calls its messages *segments*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Communication between devices on packet-switched networks is
    based on items most generically called messages. These pieces of information also
    go by other names such as packets, datagrams, frames, and cells, which often correspond
    to protocols at particular layers of the OSI Reference Model. The formal OSI terms
    for messages are *protocol data unit (PDU)* and *service data unit (SDU)*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I have made a specific effort not to imply anything about the
    nature of a message solely based on the name it uses, but I do follow the most
    common name used for a particular technology. For example, messages sent over
    Ethernet are almost always called Ethernet frames—they are not generally called
    Ethernet datagrams, for example. However, I do not structure discussions so that
    the type of name used for a message is the only way to determine what sort of
    message it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Message Formatting: Headers, Payloads, and Footers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Messages* are the structures used to send information over networks. They
    vary greatly from one protocol or technology to the next in how they are used,
    and as just described, they are also called by many different names. Shakespeare
    had the right idea about names, however. The most important way that messages
    differ is not in what they are called but in terms of their *content*.'
  prefs: []
  type: TYPE_NORMAL
- en: Every protocol uses a special *formatting method* that determines the structure
    of the messages it employs. Obviously, a message that is intended to connect a
    web server and a web browser is going to be quite different from one that connects
    two Ethernet cards at a low level. This is why I separately describe the formats
    of dozens of different protocol messages in various areas of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the format of a particular message type depends entirely on the nature
    of the technology that uses it, messages on the whole tend to follow a fairly
    uniform overall structure. In generic terms, each message contains the following
    three elements (see [Figure 1-3](ch01s03.html#network_message_formatting_in_the_most_g
    "Figure 1-3. Network message formatting In the most general of terms, a message
    consists of a data payload that will be communicated, bracketed by a set of header
    and footer fields. The data of any particular message sent in a networking protocol
    will itself contain an encapsulated higher-layer message containing a header,
    data, and a footer. This "nesting" can occur many times as data is passed down
    a protocol stack. The header is found in most protocol messages; the footer only
    in some.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header** Information that is placed before the actual data. The header normally
    contains a small number of control-information bytes, which are used to communicate
    important facts about the data that the message contains and how it is to be interpreted
    and used. It serves as the communication and control link between protocol elements
    on different devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data** The actual data to be transmitted, often called the *payload* of the
    message (metaphorically borrowing a term from the space industry!). Most messages
    contain some data of one form or another, but some messages actually contain none.
    They are used for only control and communication purposes. For example, these
    may be used to set up or terminate a logical connection before data is sent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Footer** Information that is placed after the data. There is no real difference
    between the header and the footer, as both generally contain control fields. The
    term *trailer* is also sometimes used.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network message formatting In the most general of terms, a message consists
    of a data payload that will be communicated, bracketed by a set of header and
    footer fields. The data of any particular message sent in a networking protocol
    will itself contain an encapsulated higher-layer message containing a header,
    data, and a footer. This "nesting" can occur many times as data is passed down
    a protocol stack. The header is found in most protocol messages; the footer only
    in some.](httpatomoreillycomsourcenostarchimages287687.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3. Network message formatting In the most general of terms, a message
    consists of a data payload that will be communicated, bracketed by a set of header
    and footer fields. The data of any particular message sent in a networking protocol
    will itself contain an encapsulated higher-layer message containing a header,
    data, and a footer. This "nesting" can occur many times as data is passed down
    a protocol stack. The header is found in most protocol messages; the footer only
    in some.
  prefs: []
  type: TYPE_NORMAL
- en: Since the header and footer can contain both control and information fields,
    you might rightly wonder what the point is of having a separate footer anyway.
    One reason is that some types of control information are calculated using the
    values of the data itself. In some cases, it is more efficient to perform this
    computation as the data payload is being sent, and then transmit the result after
    the payload in a footer. A good example of a field often found in a footer is
    redundancy data such as cyclic redundancy check (CRC) code, which can be used
    for error detection by the receiving device. Footers are most often associated
    with lower-layer protocols, especially at the data link layer of the OSI Reference
    Model.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The general format of a networking message consists of a *header*,
    followed by the *data* or *payload* of the message, followed optionally by a *footer*.
    Header and footer information is functionally the same except for its position
    in the message; footer fields are only sometimes used, especially in cases where
    the data in the field is calculated based on the values of the data being transmitted.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, any particular protocol is concerned with only its *own*
    header (and footer, if present). It doesn't care much about what is in the data
    portion of the message, just as a delivery person worries only about driving the
    truck and not so much about what it contains. At the beginning of that data will
    normally be the headers of other protocols that were used higher up in the protocol
    stack; this, too, is shown in [Figure 1-3](ch01s03.html#network_message_formatting_in_the_most_g
    "Figure 1-3. Network message formatting In the most general of terms, a message
    consists of a data payload that will be communicated, bracketed by a set of header
    and footer fields. The data of any particular message sent in a networking protocol
    will itself contain an encapsulated higher-layer message containing a header,
    data, and a footer. This "nesting" can occur many times as data is passed down
    a protocol stack. The header is found in most protocol messages; the footer only
    in some."). In the OSI Reference Model, a message handled by a particular protocol
    is said to be its PDU; the data it carries in its payload is its SDU. The SDU
    of a lower-layer protocol is usually a PDU of a higher-layer protocol. The discussion
    of data encapsulation in [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE
    MODEL ISSUES AND CONCEPTS") contains a full explanation of this important concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Message Addressing and Transmission Methods: Unicast, Broadcast, and Multicast'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a networking technology that uses messages to send data, you must undertake
    a number of tasks in order to successfully transmit the data from one place to
    another. One is simply *addressing* the message—putting an address on it so that
    the system knows where it is supposed to go. Another is *transmitting* the message,
    which is sending it to its intended recipient.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different ways of addressing and transmitting a message over
    a network. One way in which messages are differentiated is in how they are addressed
    and how many recipients will receive them. The method used depends on the function
    of the message and also on whether or not the sender knows specifically or generally
    whom they are trying to contact.
  prefs: []
  type: TYPE_NORMAL
- en: To help explain these different methods, I will use a real-world analogy. Consider
    a social function with 300 people that is being held in a large hall. These people
    are mingling and having different conversations. There are different kinds of
    messages that you may need to send in this setting, as is the case with networks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Unicast, multicast, and broadcast message addressing and transmission The
    three basic types of addressing and message delivery in networking are illustrated
    in this simplified LAN. Device 6 is sending a unicast message to Device 2, shown
    as the dark, heavy arrow. Device 4 is sending a multicast message to multicast
    group X, shown as the medium-weight arrows. In this case, that group includes
    Devices 1 and 3, which are highlighted. Finally, Device 5 is sending a broadcast
    message, which goes to all other devices on the LAN, shown as the thin, faint
    arrows.](httpatomoreillycomsourcenostarchimages287689.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4. Unicast, multicast, and broadcast message addressing and transmission
    The three basic types of addressing and message delivery in networking are illustrated
    in this simplified LAN. Device 6 is sending a unicast message to Device 2, shown
    as the dark, heavy arrow. Device 4 is sending a multicast message to multicast
    group X, shown as the medium-weight arrows. In this case, that group includes
    Devices 1 and 3, which are highlighted. Finally, Device 5 is sending a broadcast
    message, which goes to all other devices on the LAN, shown as the thin, faint
    arrows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bearing this analogy in mind, consider these three kinds of message transmissions,
    which are illustrated in [Figure 1-4](ch01s03.html#unicast_multicast_and_broadcast_message_
    "Figure 1-4. Unicast, multicast, and broadcast message addressing and transmission
    The three basic types of addressing and message delivery in networking are illustrated
    in this simplified LAN. Device 6 is sending a unicast message to Device 2, shown
    as the dark, heavy arrow. Device 4 is sending a multicast message to multicast
    group X, shown as the medium-weight arrows. In this case, that group includes
    Devices 1 and 3, which are highlighted. Finally, Device 5 is sending a broadcast
    message, which goes to all other devices on the LAN, shown as the thin, faint
    arrows."):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicast Messages** These are messages that are sent from one device to another
    device; they are not intended for others. If you have a friend at this social
    event, this is the equivalent of pulling him aside for a private conversation.
    Of course, there is still the possibility of someone else at the event overhearing
    your conversation—or even eavesdropping on it. The same is true in networking
    as well—addressing a message to a particular computer doesn''t guarantee that
    others won''t also read it; it''s just that they normally will not do so.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcast Messages** As the name suggests, these messages are sent to every
    device on a network. You use them when you need to communicate a piece of information
    to everyone on the network, or when the sending station needs to send it to just
    one recipient, but doesn''t know its address. For example, suppose a new arrival
    at the social gathering saw in the parking lot a blue sedan with its lights left
    on. She does not know who the car belongs to. The best way to communicate this
    information is to broadcast it by having the host make an announcement that will
    be heard by all, including the vehicle''s owner. In networks, broadcast messages
    are used for a variety of purposes, including finding the locations of particular
    stations or the devices that manage different services.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast Messages** These are a compromise between the previous two types.
    Multicast messages are sent to a group of stations that meet a particular set
    of criteria. These stations are usually related to each other in some way. For
    example, they serve a common function or are set up into a particular *multicast
    group*. (Note that you can also consider broadcast messages to be a special case
    of multicast in which the group is "everyone.")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our analogy: This would be somewhat like a group of friends who go
    to this large social hall and then stay together in a small discussion group—or
    perhaps use radios to talk to each other from a distance. Multicasting requires
    special techniques that make clear who is in the intended group of recipients.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these transmission methods differ based on how many and which devices
    receive the transmission, they are tied directly to the methods used for addressing,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicast Addressing** Unicast delivery requires that a message should be addressed
    to a specific recipient. This is the most common type of messaging, so this addressing
    capability is present in almost all protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcast Addressing** Broadcasts are normally implemented via a special
    address that is reserved for that function. Whenever devices see a message sent
    to that address, they all interpret it as "This message goes to everyone."'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast Addressing** Multicasts are the most complex type of message because
    they require a means of identifying a set of specific devices that will receive
    a message. It is often necessary to create several such groups, which may or may
    not partially overlap in their membership. Some mechanism is needed to manage
    which devices are in which groups.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Three basic methods are used to address and transmit data between
    networked devices. A *unicast* transmission goes from one device to exactly one
    other; this is the most common method used for most message transactions. A *broadcast*
    transmission is sent from one device to all connected devices on a network. A
    *multicast* transmission is addressed and sent to a select group of devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, one special case in the field of addressing is worth mentioning. In
    some networks or links, only two devices are connected together, forming what
    is often called a *point-to-point network*. In this situation, everything sent
    by one device is implicitly intended for the other, and vice versa. Thus, no addressing
    of messages on a point-to-point link is strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*A new type of message-addressing method was defined as part of IP version
    6 (IPv6): the anycast message. This term identifies a message that should be sent
    to the closest member of a group of devices. [Chapter 25](ch25.html "Chapter 25. IPV6
    ADDRESSING") describes this type of addressing and transmission*.'
  prefs: []
  type: TYPE_NORMAL
- en: Network Structural Models and Client-Server and Peer-to-Peer Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I mentioned in my discussion of the advantages of networking that networks
    are normally set up for two primary purposes: *connectivity* and *sharing*. If
    you have a network with a number of different machines on it, each computer can
    interact with another''s hardware and software, which enables you to perform a
    variety of tasks. How this is actually done depends to a large degree on the overall
    design of the network.'
  prefs: []
  type: TYPE_NORMAL
- en: One very important issue in network design is how to configure the network for
    the sharing of resources. Specifically, the network designer must decide whether
    or not to dedicate resource management functions to the devices that constitute
    it. In some networks, all devices are treated equally in this regard, while in
    others, each computer is responsible for a particular job in the overall function
    of providing services. In this latter arrangement, the devices are sometimes said
    to have *roles*, somewhat like actors in a play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two common terms are used to describe these different approaches
    to setting up a network:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peer-to-Peer Networking** In a strict peer-to-peer networking setup, every
    computer is an equal, a *peer* in the network. Each machine can have resources
    that are shared with any other machine. There is no assigned role for any particular
    device, and each of the devices usually runs similar software. Any device can
    and will send requests to any other, as illustrated in [Figure 1-5](ch01s04.html#peer-to-peer_networking_in_this_model_ea
    "Figure 1-5. Peer-to-peer networking In this model, each device on the network
    is treated as a peer, or equal. Each device can send requests and responses, and
    none are specifically designated as performing a particular role. This model is
    more often used in very small networks. Contrast this with Figure 1-6.").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Server Networking** In this design, a small number of computers are
    designated as centralized *servers* and are given the task of providing services
    to a larger number of user machines called *clients*, as shown in [Figure 1-6](ch01s04.html#client-server_networking_in_the_client-s
    "Figure 1-6. Client-server networking In the client-server model, a small number
    of devices are designated as servers and equipped with special hardware and software
    that allows them to interact efficiently and simultaneously with multiple client
    machines. Though the clients can still interact with each other, most of the time
    they send requests of various sorts to the server, and the server sends back responses
    to them. Contrast this with the peer-to-peer networking example in Figure 1-5.").
    The servers are usually powerful computers with a lot of memory and storage space,
    and fast network connections. The clients are typically smaller, regular computers
    like PCs; they are optimized for human use.'
  prefs: []
  type: TYPE_NORMAL
- en: The term *client-server* also frequently refers to protocols and software, which
    are designed with matching, complementary components. Usually, server software
    runs on server hardware, and client software is used on client computers that
    connect to those servers. Most of the interaction on the network is between client
    and server, not between clients. Server software is designed to efficiently respond
    to requests, while client software provides the interface to the human users of
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Networks are usually configured to share resources using one
    of two basic *structural models*. In a *peer-to-peer network*, each device is
    an equal, and none are assigned particular jobs. In a *client-server network*,
    however, devices are assigned particular roles—a small number of powerful computers
    are set up as *servers* and respond to requests from the other devices, which
    are *clients*. Client-server computing also refers to the interaction between
    complementary protocol elements and software programs. It''s rising in popularity
    due to its prevalence in TCP/IP and Internet applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Peer-to-peer networking In this model, each device on the network is treated
    as a peer, or equal. Each device can send requests and responses, and none are
    specifically designated as performing a particular role. This model is more often
    used in very small networks. Contrast this with .](httpatomoreillycomsourcenostarchimages287691.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-5. Peer-to-peer networking In this model, each device on the network
    is treated as a peer, or equal. Each device can send requests and responses, and
    none are specifically designated as performing a particular role. This model is
    more often used in very small networks. Contrast this with [Figure 1-6](ch01s04.html#client-server_networking_in_the_client-s
    "Figure 1-6. Client-server networking In the client-server model, a small number
    of devices are designated as servers and equipped with special hardware and software
    that allows them to interact efficiently and simultaneously with multiple client
    machines. Though the clients can still interact with each other, most of the time
    they send requests of various sorts to the server, and the server sends back responses
    to them. Contrast this with the peer-to-peer networking example in Figure 1-5.").
  prefs: []
  type: TYPE_NORMAL
- en: The choice of client-server or peer-to-peer is sometimes called choosing a *structural
    model* for the network. As with most situations in which two different schemes
    are used, there is no right answer in this regard. Your choice depends entirely
    on the needs of the particular network.
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer networking has primary advantages of simplicity and low cost, meaning
    that it has traditionally been used on small networks. Client-server networking
    provides advantages in the areas of performance, scalability, security, and reliability,
    but is more complicated and expensive to set up. This makes it better suited to
    larger networks. Over time, however, there has been a steady evolution toward
    client-server networking, even on smaller networks. Many years ago, it was common
    to see even networks with 20 to 50 machines using the peer-to-peer model; today,
    even networks with only a half-dozen machines are sometimes set up in a client-server
    mode because of the advantages of centralized resource serving.
  prefs: []
  type: TYPE_NORMAL
- en: The rise in popularity of client-server networking is ironic because, in some
    ways, it is actually a throwback to the days of large mainframes decades ago.
    A mainframe with attached terminals can be thought of as a client-server network,
    with the mainframe itself being the server and the terminals being clients. This
    analogy is not perfect, of course, because modern client computers do a lot more
    work than dumb terminals on mainframes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons why the client-server structural model is becoming dominant
    is that it is the primary model used by the world''s largest network: the Internet.
    Client-server architecture is the basis for most TCP/IP protocols and services.
    For example, the term *web browser* is really another name for a web client, and
    a *website* is really a web server.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*For more information on client-server computing, I recommend that you read
    the section "TCP/IP Services and Client/Server Operation" in [Chapter 8](ch08.html
    "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE"). That topic also contains
    a very relevant exposition on the different meanings of the terms client and server
    in hardware, software, and transactional contexts*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-server networking In the client-server model, a small number of devices
    are designated as servers and equipped with special hardware and software that
    allows them to interact efficiently and simultaneously with multiple client machines.
    Though the clients can still interact with each other, most of the time they send
    requests of various sorts to the server, and the server sends back responses to
    them. Contrast this with the peer-to-peer networking example in .](httpatomoreillycomsourcenostarchimages287693.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-6. Client-server networking In the client-server model, a small number
    of devices are designated as servers and equipped with special hardware and software
    that allows them to interact efficiently and simultaneously with multiple client
    machines. Though the clients can still interact with each other, most of the time
    they send requests of various sorts to the server, and the server sends back responses
    to them. Contrast this with the peer-to-peer networking example in [Figure 1-5](ch01s04.html#peer-to-peer_networking_in_this_model_ea
    "Figure 1-5. Peer-to-peer networking In this model, each device on the network
    is treated as a peer, or equal. Each device can send requests and responses, and
    none are specifically designated as performing a particular role. This model is
    more often used in very small networks. Contrast this with Figure 1-6.").
  prefs: []
  type: TYPE_NORMAL
- en: Types and Sizes of Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons that understanding networks can be difficult at times is
    that there are so many different types! When someone talks about a network, she
    can mean anything from two computers hooked together in an apartment to a globe-spanning
    entity with millions of nodes. Every network is unique, and each one has an important
    role to play in filling the communication and data-sharing needs of different
    individuals and organizations. In fact, the great diversity and flexibility of
    networking is one of its most important strengths.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most basic ways that you can distinguish and contrast various networks
    are the relative distances between the devices that they connect and the general
    mechanisms used to communicate between them. The reason for making these distinctions
    is that the technological needs of a network differ greatly depending on the amount
    of ground you are trying to cover, and also by the overall way that you want to
    transmit and receive information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many people, including me, like to divide the many kinds of networks in existence
    into three general classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Area Networks (LANs)** Networks that connect computers that are relatively
    close to each other—generally, within the same room or building. When most people
    think about networking PCs and other small computers, this is what they usually
    have in mind. The vast majority of regular LANs connect using cables, so the term
    *LAN* by itself usually implies a wired LAN, but not always.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wireless LANs (WLANs)** LANs that connect devices without wires, using radio
    frequencies or light. WLANs can be entirely wireless, but most are not. They usually
    connect wireless devices to each other as well as to the wired portion of the
    network. Due to the limits of most wireless technologies, WLANs usually connect
    devices that are very close to each other, generally within a few hundred feet
    at most.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wide Area Networks (WANs)** Networks that connect devices or other networks
    over a greater distance than that which is practical for LANs. If the distance
    between devices can be measured in miles, you will generally use WAN and not LAN
    technology to link them.'
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, WANs are used to link physically distant LANs. For example,
    a company with locations in two different cities would normally set up a LAN in
    each building and then connect them together in a WAN. I also consider most Internet
    access technologies to be a form of WAN, though some might not agree with that.
    There is also the term *wireless WAN (WWAN)*, which just refers to a WAN that
    uses wireless technology.
  prefs: []
  type: TYPE_NORMAL
- en: As with most other distinctions and categorizations in the world of networking,
    the lines between these various definitions are not very concrete. As I mentioned
    already, WLANs are usually not entirely wireless because they contained wired
    elements. Similarly, trying to say absolutely when a network is "local" and when
    it is "wide" is difficult.
  prefs: []
  type: TYPE_NORMAL
- en: It's also somewhat pointless to spend too much energy on differentiating these
    network classes precisely. In some cases it's not the definitions that decide
    what technology to use, but rather the technology that indicates what kind of
    network you have! Since some protocols are designed for WANs, if you are using
    them, many would say you have a WAN, even if all the devices in that technology
    are near each other. On the other hand, some LAN technologies allow for the use
    of cables that can run for many miles; most would still consider a mile-long Ethernet
    fiber link to be a LAN connection, even though it may span WAN distances.
  prefs: []
  type: TYPE_NORMAL
- en: There are many dimensions in which LAN and WAN technologies differ; two of the
    most important are *cost* and *performance*. It's easy to establish a high-speed
    conduit for data between two systems that are in the same room, but it's much
    more difficult if the two are in different states. This means that in the world
    of WAN, one either pays a lot more or gets a lot less throughput—often it's both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The gray area between LAN and WAN is becoming more muddled every year. One
    reason is the emergence of intermediate network types that straddle the line between
    these more familiar terms. Two of the more common ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Campus Area Networks (CANs)** A *CAN* is one created to span multiple buildings
    in the same location, such as the campus of a university. Campus area networking
    is a gray area, since neither LANs nor WANs alone are always well suited for this
    type of application. Often, a mix of LAN and WAN techniques is used for campus
    networking, depending on the characteristics of the campus and the needs of the
    organization.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Metropolitan Area Networks (MANs)** Another intermediate term that you may
    see sometimes is the *MAN*. As the name implies, this refers to a network that
    spans a particular small region or a city. MANs can be considered small WANs that
    cover a limited geographical area, or large LANs that cover an area greater than
    what is normally associated with a local network. Wireless MANs are sometimes
    called *WMANs*; IEEE 802.16 is an example of a WMAN standard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is one other term occasionally used that I should mention: the
    *personal area network (PAN)*. This type of network generally means a very small
    LAN with a range of only a few feet. PANs mostly connect devices used by a single
    person (or very small group). The term is most commonly used in reference to Bluetooth/IEEE
    802.15 wireless technology, so you will sometimes see the terms *wireless PAN
    (WPAN)* and *PAN* used interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Networks are often divided by size and general communication
    method into three classes. *Local area networks (LANs)* generally connect proximate
    devices, usually using cables. *Wireless LANs (WLANs)* are like cabled LANs but
    use radio frequency or light technology to connect devices without wires. *Wide
    area networks (WANs)* connect distant devices or LANs to each other. *Campus area
    networks (CANs)* and *metropolitan area networks (MANs)* fall between LANs and
    WANs in terms of overall size. *Personal area networks (PANs)* are like very small
    LANs and often appear as *wireless PANs (WPANs)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Segments, Networks, Subnetworks, and Internetworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons that networks are so powerful is that they can be used to
    connect not only individual computers, but also groups of computers. Thus, network
    connections can exist at multiple levels; one network can be attached to another
    network, and that entire network can be attached to another set of networks, and
    so on. The ultimate example of this is, of course, the Internet, which is a huge
    collection of networks that have been interconnected into…dare I say, a web?
  prefs: []
  type: TYPE_NORMAL
- en: This means that a larger network can be described as consisting of several smaller
    networks or even parts of networks that are linked together. Conversely, we can
    talk about taking individual networks or network portions and assembling them
    into larger structures. The reason why this concept is important is that certain
    technologies are best explained when looking at an entire large network at a high
    level, while others really require that you drill down to the detailed level of
    how constituent network pieces work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, a collection of terms has evolved in the networking world to describe
    the relative sizes of larger and smaller networks. Some of the most common ones
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network** This is the least specific of the terms mentioned here. Basically,
    a *network* can be pretty much any size, from two devices to thousands. When networks
    get very large, however, and are clearly comprised of smaller networks connected
    together, they are often no longer called networks but *internetworks*, as you
    will see momentarily. Despite this, it is fairly common to hear someone refer
    to something like "Microsoft''s corporate network," which obviously contains thousands
    or even tens of thousands of machines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subnetwork (Subnet)** A *subnetwork* is a portion of a network, or a network
    that is part of a larger internetwork. This term is also a rather subjective one;
    subnetworks can be rather large when they are part of a network that is very large.'
  prefs: []
  type: TYPE_NORMAL
- en: The abbreviated term *subnet* can refer generically to a subnetwork, but also
    has a specific meaning in the context of TCP/IP addressing (see [Chapter 18](ch18.html
    "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS")).
  prefs: []
  type: TYPE_NORMAL
- en: '**Segment (Network Segment)** A *segment* is a small section of a network.
    In some contexts, a segment is the same as a subnetwork and the terms are used
    interchangeably. More often, however, the term *segment* implies something smaller
    than a subnetwork. Networks are often designed so that, for the sake of efficiency,
    computers that are related to each other or that are used by the same groups of
    people are put on the same network segment.'
  prefs: []
  type: TYPE_NORMAL
- en: Some LAN technologies—including Ethernet—use the term *segment* to refer specifically
    to a collection of geographically proximate machines that are connected directly
    to each other, either by a single cable or single device such as a hub. Such technologies
    have specific rules about how many devices can be on a segment, how many segments
    can be connected together, and so on, depending on what sort of network interconnection
    devices you are using.
  prefs: []
  type: TYPE_NORMAL
- en: '**Internetwork (or Internet)** Most often, this refers to a larger networking
    structure that is formed by connecting smaller ones. Again, the term can have
    either a generic or a specific meaning, depending on context. In some technologies,
    an internetwork is just a very large network that has networks as components.
    In others, a network is differentiated from an internetwork based on how the devices
    are connected together.'
  prefs: []
  type: TYPE_NORMAL
- en: An important example of the latter definition is TCP/IP, in which a *network*
    usually refers to a collection of machines that are linked at layer 2 of the OSI
    Reference Model, using technologies like Ethernet or Token Ring, as well as interconnection
    devices such as hubs and switches. An internetwork is formed when these networks
    are linked together at layer 3, using routers that pass IP datagrams between networks.
    Naturally, this is highly simplified, but in studying TCP/IP, you should keep
    this in mind when you encounter the terms *network* and *internetwork*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The shorter form of the word internetwork* (internet) *is often avoided by
    people who wish to avoid confusion with the proper noun form* (Internet). *The
    latter, of course, refers only to the well-known global internetwork of computers
    and all the services it provides. I personally try to use the word* internetwork
    *most of the time in this book instead of* internet, *for this very reason*.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these different terms is important not only for helping you comprehend
    what you read about networks, but also because they are important concepts in
    network design. This is particularly true for LANs in which decisions regarding
    how to set up segments and how to connect them to each other have an important
    impact on the overall performance and usability of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Several terms are often used to describe the relative sizes
    of networks and parts of networks. The most basic term is *network* itself, which
    can refer to most anything, but often means a set of devices connected using an
    OSI layer 2 technology. A *subnetwork* is a part of a network (or internetwork),
    as is a *segment*, though the latter often has a more specific meaning in certain
    technologies. An *internetwork* refers either generically to a very large network,
    or specifically, to a set of layer 2 networks connected using routers at layer
    3.'
  prefs: []
  type: TYPE_NORMAL
- en: The term *segment* is notably problematic because it is routinely used in two
    different ways, especially in discussions related to Ethernet. Traditionally,
    a *segment* referred to a specific cable. The earliest forms of Ethernet used
    coaxial cables, and the coaxial cable segment was shared and became the collision
    domain for the network. *Collision domain* is a term that refers generally to
    a collection of hardware devices in which only one can transmit at a time. Devices
    such as hubs and repeaters were used to extend collision domains by connecting
    together these segments of cable into wider networks. Over time, the terms *collision
    domain* and *segment* started to be used interchangeably. Thus today a segment
    can refer either to a specific piece of cable or to a collection of cables connected
    electrically that represent a single collision domain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As if that potential ambiguity in the use of the word* segment *isn''t bad
    enough, it also has another, totally unrelated meaning: It is the name of the
    messages sent in TCP!*'
  prefs: []
  type: TYPE_NORMAL
- en: The Internet, Intranets, and Extranets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned in the preceding discussion of segments, networks, subnetworks,
    and internetworks that the Internet is really the king of internetworks. After
    all, you don't get to be called "the" something unless you pretty much define
    it!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the Internet is not just a large internetwork, but substantially more.
    The Internet is defined not just as the computers that are connected to each other
    around the world, but as the set of services and features that it offers. More
    than that, the Internet defines a specific way of doing things, of sharing information
    and resources between people and companies. And though it might be a bit melodramatic
    to say so, to many people, the Internet is a way of life.
  prefs: []
  type: TYPE_NORMAL
- en: As Internet use exploded in the 1990s, many people realized that the techniques
    and technologies used on the Internet would be useful if applied to internal company
    networks as well. The term *intranet* was coined to refer to an internal network
    that functioned like a private Internet. It comes from the prefix *intra*, which
    means within. Of course, *inter* is the opposite of intra, so this makes some
    people think that an intranet is the opposite of an internet. In fact, most intranets
    *are* internetworks as well!
  prefs: []
  type: TYPE_NORMAL
- en: As if that weren't bad enough from a jargon standpoint, the buzzword buzzards
    then decided to take matters a step further. If an intranet is extended to allow
    access to it not only by people or groups strictly from within the organization,
    but also by people or groups outside the main company, this is sometimes called
    an *extranet*. *Extra*, of course, is a prefix that means outside, or beyond.
  prefs: []
  type: TYPE_NORMAL
- en: So, an extranet is a type of internal, private Internet that, well, isn't entirely
    internal. An extranet is an extended intranet, which is really a type of internet
    that works like the Internet. (You can start to see why I am not a big fan of
    these fancy terms. But then, I don't get to choose them; I just have to help you
    understand them!) An extranet isn't public and open to all—it is controlled by
    a private organization. At the same time, it isn't entirely private either.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The generic noun *internet* is a short form for the word internetwork,
    while the proper noun *Internet* refers to the global internetwork of TCP/IP networks
    that we all know and use. The term *intranet* refers to an internal network that
    uses TCP/IP technologies as the Internet does. An *extranet* is like an intranet
    that is extended to individuals or organizations outside the company. All these
    terms can be used ambiguously, so you must take care to determine exactly what
    they mean in any given context.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the lines between the Internet, intranets, and extranets were
    pretty blurry from the start, and the concepts are rapidly blending into a diffuse
    gray mass as the whole computing world becomes more tightly integrated. For example,
    even if you have an entirely private intranet, you will want to connect it to
    the Internet to communicate with the outside world and to allow access to Internet
    resources. And an extranet may be implemented, in part, through the public Internet
    infrastructure, using technologies such as virtual private networking (VPN). I
    think you get the picture.
  prefs: []
  type: TYPE_NORMAL
- en: The key that binds all of these concepts together is that they all use *Internet
    technologies*, which is a term that is also somewhat vague. This usually refers
    to the use of the TCP/IP protocol suite, which is the defining technology of the
    Internet as well as the set of services that are available on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that being told that a company has an intranet or an extranet—as
    opposed to a plain old boring network—doesn't tell you much at all. It is best
    not to rely on the slogans and instead look at the underlying characteristics
    of the network or internetwork itself. Furthermore, when designing such a network,
    you should focus on using the technologies and protocols that make sense—let the
    marketing people decide what to call it later.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. NETWORK PERFORMANCE ISSUES AND CONCEPTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Networking is largely about connecting together devices so that information
    can be shared between them. Since the idea is to send data from one place to another,
    a very important characteristic of any network is its *speed*: How fast can data
    be transmitted and received? This matter of speed turns out to be only one of
    several issues that determine the overall *performance* of a network.'
  prefs: []
  type: TYPE_NORMAL
- en: In the computing world, performance is, in general, one of the most discussed
    but least understood characteristics of any system or hardware device. This is
    true of networking as well. For example, most people know the raw throughput rating
    of their network hardware, and they may even start to draw conclusions about its
    capabilities based on those numbers. Many, however, don't realize that they will
    never actually achieve that rated amount of performance in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the other subtle issues related to performance are also typically ignored
    or misunderstood, such as the impact of software drivers on hardware performance,
    and the fact that certain applications need more than just raw bit speed—they
    need *reliable* delivery of data. But even beyond all of this, one of the most
    important issues related to network performance is understanding what your needs
    are, because then you can make sure you don't spend too much money for performance
    you don't need—or worse, create a network that can't meet your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I discuss various performance issues and concepts that are
    related to networking in one way or another. First and foremost, I try to put
    performance in context and also contrast it with nonperformance issues. Then I
    talk about several key performance terms and metrics: speed, bandwidth, throughput,
    and latency. I also discuss some of the units used to measure network performance.
    I then explain how the real-world performance of a network differs from its theoretical
    performance and talk about factors that have an impact on network performance.
    I conclude by contrasting full-duplex and half-duplex network operation, and talking
    about quality of service, which is a concept that is especially important in the
    use of networks for real-time applications such as streaming multimedia.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting Network Performance in Perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Performance* is probably the mother of all buzzwords in the computer industry.
    There are many people who consider it the ultimate goal of any computer or computer
    system, and by extension, any network. A lot of people spend many dollars and
    hours of time trying to maximize it. There''s good reason for this: Performance
    *is* very important. A network that does not offer adequate performance simply
    will not get the job done for those that rely on it. However, it is very important
    to keep performance in perspective. Successfully maximizing performance requires
    that you first take a step back and look at the big picture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question you must ask yourself is also the most essential one: How
    important is performance to you? Before you answer this question, recall the old
    auto racing adage: "Speed costs money—how fast do you want to go?" While there
    are some situations in which you can get much better performance in a network
    by spending just a little more money, in general, you don''t get more performance
    without paying for it in some way. That may mean a higher cost for the network,
    or it may mean a trade-off of some nonperformance feature.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are designing or specifying a network, it's very important to keep in
    mind that your goal is to come up with a system that will meet the needs that
    were determined for it during requirements analysis. This means coming up with
    a network that has a level of performance that matches the requirements and leaves
    some room for expansion. Unless you have an unlimited budget—and who does, right?—your
    objective is not "performance at any cost." It is to create a network that meets
    *all* of your users' needs, including balancing performance and nonperformance
    characteristics, as you will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Buyer beware. Companies are constantly coming out with the "latest and greatest"
    high-performance networking technologies. They usually try to sell their technologies
    by attempting to convince you that you just cannot live without this latest advance;
    that you "need" to upgrade—immediately, if not sooner! Well, it''s simply not
    the case. For example, even though you can find Ethernet hardware that runs with
    a theoretical throughput of 10,000 megabits per second, there are many older networks
    that continue to work just fine at one 1/100th that speed—or even 1/1,000th!*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, remember that designing a network is usually not an irreversible, permanent
    decision. Networks can be upgraded and expanded. While it is prudent to build
    some slack into any network to allow for growth, it is not wise to spend too much
    time and money planning for the future when changes can be made later. This is
    especially true given that network hardware prices drop over time. Again, this
    is a matter of drawing an appropriate balance between future performance planning
    and budget.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing Network Performance with Key Nonperformance Characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that performance is very important to any network. However, anyone
    putting together a network must also be concerned with many different nonperformance
    characteristics as well. Depending on the network, these can be just as essential
    to the users of the network as performance, and possibly even more critical. More
    than this, nonperformance issues often *trade off* against performance, and in
    fact, more often than not they have to be reduced to get performance to increase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can create a very high-performance network, you must understand
    the key nonperformance network characteristics that you may need to compromise.
    The following are a few of these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design and Implementation Cost** Unless you have bottomless pockets, you
    must be concerned with the network''s costs. As mentioned earlier, cost is the
    main trade-off with performance. Going faster usually costs more money.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quality** The quality of the network is a function of the quality of the
    components used and how they are installed. Quality is important because it impacts
    all of the other factors, such as reliability and ease of administration, as well
    as performance. Quality doesn''t trade off *directly* with performance—you can
    design high-quality, high-performance networks—but it does *compete* with performance
    for resources in the budget. All else being equal, it costs a great deal more
    to implement a high-quality, high-performance network than a high-quality, low-speed
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standardization** Network protocols and hardware can be designed to meet
    either universally accepted standards or nonstandard, proprietary ones. Standard
    designs are almost always preferable, because they make interoperability, upgrading,
    support, and training easier. Proprietary standards may include enhancements that
    improve performance, but may increase cost or make management more difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability** This is related to several other issues, especially quality
    and performance. Faster networks aren''t necessarily less reliable, but they are
    more difficult and expensive to make run reliably than slower ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expandability and Upgradability** It''s very important to always plan for
    the future when creating a network. Higher-performance networks can be more difficult
    to expand, and they are certainly more expensive to expand. Once again, the matter
    of implementing a network with a capacity for future needs now, as opposed to
    upgrading later if it becomes necessary, is an important network design decision.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of Administration and Maintenance** Higher-performance networks require
    more work and resources to administer and maintain, and they are more likely to
    require troubleshooting than slower ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Premises and Utility Issues** Implementation of high-speed networks may be
    limited by the physical premises or may have an impact on how they are laid out.
    Choosing a higher-speed option may require more infrastructure to be put in place,
    thus increasing cost. The classic example of this is choosing between wired and
    wireless options for a home or small office network. You can go much faster with
    wires, but do you really want to run them?'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** While performance is one of the most important characteristics
    of any network, there are others that are equally important. In many cases, you
    must weigh the cost, quality, reliability, expandability, maintainability, and
    other attributes of a network against overall performance. The faster you want
    your network to go, the more difficult it is to ensure that these other attributes
    are kept at sufficiently high levels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance Measurements: Speed, Bandwidth, Throughput, and Latency'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of terms are commonly used to refer to various aspects of network performance.
    Some of them are quite similar to each other, and you will often see them used—and
    in many cases, misused or even *ab*used! I'll examine each of them to see how
    they are commonly used and what they really mean.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*More than just the issue of different terms related to performance, however,
    is the more important reality that there are multiple* facets *to performance.
    Depending on the application, the manner in which data is sent across the network
    may be more important than the raw speed at which it is transported. In particular,
    many multimedia applications require real-time performance; they need data sent
    in such a manner that it will be delivered steadily. For these purposes, raw speed
    isn''t as important as* consistent *speed. This is an issue that is often not
    properly recognized*.'
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Speed* is the most generic performance term used in networking. As such, it
    can mean just about *anything*. Most commonly, however, it refers to the *rated*
    or *nominal* speed of a particular networking technology. For example, Fast Ethernet
    has a nominal speed of 100 Mbps (megabits per second); for that reason, it is
    often called 100 Mbps Ethernet, or given a designation such as 100BASE-TX.'
  prefs: []
  type: TYPE_NORMAL
- en: Rated speed is the biggest performance magic number in networking—you see it
    used to label hardware devices, and many people bandy the numbers about as if
    those numbers actually represented the network's real speed. The problem with
    using nominal speed ratings is that they are only *theoretical*, and as such,
    tell an incomplete story. No networking technology can run at its full-rated speed,
    and many run *substantially* below it, due to real-world performance factors.
  prefs: []
  type: TYPE_NORMAL
- en: Speed ratings such as 100 Mbps Ethernet are also often referred to as the *throughput*
    of a technology, even though the maximum theoretical speed of a technology is
    more analogous to bandwidth than throughput, and the two are not identical.
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bandwidth is a widely used term that usually refers to the data-carrying capacity
    of a network or data-transmission medium. It indicates the maximum amount of data
    that can pass from one point to another in a unit of time. The term comes from
    the study of electromagnetic radiation, where it refers to the width of a band
    of frequencies used to carry data. It is usually given in a theoretical context,
    though not always.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bandwidth is still used in these two senses: frequency bandwidth and data capacity.
    For example, radio frequencies are used for wireless technologies, and the bandwidth
    of such technologies can refer to how wide the radio frequency band is. More commonly,
    though, bandwidth refers to how much data can be sent down a network, and it is
    often used in relative terms. For example, for Internet access, a cable or xDSL
    connection is considered high-bandwidth access; using a regular analog modem is
    low-bandwidth access.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughput
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughput is a measure of how much actual data can be sent per unit of time
    across a network, channel, or interface. While throughput can be a theoretical
    term like bandwidth, it is more often used in a practical sense—for example, to
    measure the amount of data actually sent across a network in the real world. Throughput
    is limited by bandwidth, or by rated speed: If an Ethernet network is rated at
    100 Mbps, that''s the absolute upper limit on throughput, even though you will
    normally get quite a bit less. So, you may see someone say that they are using
    a 100 Mbps Ethernet connection but getting throughput of, say, 71.9 Mbps on their
    network.'
  prefs: []
  type: TYPE_NORMAL
- en: The terms *bandwidth* and *throughput* are often used interchangeably, even
    though they are really not exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Latency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Latency* is a very important, often overlooked term, which refers to the *timing*
    of data transfers on a communications channel or network. One important aspect
    of latency is how long it takes from the time a request for data is made until
    it starts to arrive. Another aspect is how much control a device has over the
    timing of the data that is sent, and whether the network can be arranged to allow
    for the consistent delivery of data over a period of time. Low latency is considered
    better than high latency.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Performance Measurements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all networking terms, there are no hard-and-fast rules; many people
    are rather loose with their use of terms relating to performance measurement.
    You will even see terms such as *throughput bandwidth*, *bandwidth throughput*,
    and other charming inventions from the department of redundancy department. More
    often, you will just see a lot of mishmashed term usage, and especially, spurious
    conclusions being drawn about what data streams a network can handle based on
    its rated speed. Making matters worse is that speed ratings are usually specified
    in bits per second, but throughput may be given in bits or bytes per second.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The three terms used most often to refer to the overall performance
    of a network are *speed, bandwidth*, and *throughput*. These are related and often
    used interchangeably, but are not identical. The term *speed* is the most generic
    and often refers to the rated or nominal speed of a networking technology. *Bandwidth*
    can mean either the width of a frequency band used by a technology or more generally,
    data capacity, where it''s used as more of a theoretical measure. *Throughput*
    is a specific measure of how much data flows over a channel in a given period
    of time. It is usually a practical measurement.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, *speed*, *bandwidth*, and *throughput* get a lot of attention, while
    *latency* gets little. Yet latency considerations are very important for many
    real-time applications such as streaming audio and video and interactive gaming.
    In fact, they are often more important than raw bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you move to a rural home, and your choices for Internet
    access are a regular 28.8 Kbps modem connection or fancy satellite Internet. The
    companies selling satellite connectivity call it "broadband" and advertise very
    high rated speeds—400 Kbps or more. They make a big deal about it being "over
    ten times as fast as dial-up," and they certainly charge a lot for this very high-tech
    service. This is a slam dunk, right?
  prefs: []
  type: TYPE_NORMAL
- en: Wrong. The satellite connection has high bandwidth, but very poor (high) latency
    due to the time it takes for the signals to travel to and from the satellite.
    It is definitely much better than the modem for downloading that nice little 150
    MB patch from Microsoft. However, it is much *worse* than the modem for playing
    the latest online video game with your buddy over the Internet, because of the
    latency, or *lag*, in transmissions. Every move you make in your game will be
    delayed for over half a second as the signal bounces around between the satellite
    and the earth, making online gaming nearly impossible. Thus, whether satellite
    Internet is worth the extra money depends entirely on what you plan to use it
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*An important issue closely related to latency is* quality of service, *a general
    term that refers (among other things) to the ability of networks to deliver necessary
    bandwidth and reliable data transfer for applications that need it. See the section
    "Quality of Service (QoS)" later in the chapter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Where bandwidth and throughput indicate how fast data moves
    across a network, *latency* describes the nature of how it is conveyed. It is
    most often used to describe the delay between the time that data is requested
    and the time when it arrives. A networking technology with very high throughput
    and bad (high) latency can be worse for some applications than one with relatively
    low throughput but good (low) latency.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Performance Measurement Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People who make networking hardware, or write materials that try to tell you
    how to operate it, use many terms to describe performance, such as *throughput*
    and *bandwidth*. (These terms are explained in the previous section.) In addition,
    they also use several different *units* to measure performance. Unfortunately,
    these units are often used incorrectly, and they are also very similar to each
    other in name. Worse, they also have overlapping abbreviations, and lots of people
    use these abbreviations without making clear what the heck they are talking about.
    Isn't that great?
  prefs: []
  type: TYPE_NORMAL
- en: Bits and Bytes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first issue is the infamous letter *B*. Or rather, I should say, the matter
    of the big *B* and the little *b*. By popular convention, the capitalized *B*
    is supposed to be used for byte, and the lowercase *b* for bit—this is the way
    these abbreviations are always used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*A byte is normally eight bits; sometimes the term* octet *is used instead.
    If you aren''t familiar with these terms, refer to [Chapter 4](ch04.html "Chapter 4. A
    REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING") for a primer
    on binary basics, where you will also find a discussion of the small controversy
    related to bytes and octets*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this convention is not followed strictly by everyone. As a result,
    you may on occasion see *b* being used to refer to bytes, and *B* used for bits.
    This *b* and *B* business causes a tremendous amount of confusion sometimes, with
    people mistaking bits for bytes and accidentally thinking that networks are running
    eight times faster or slower than they really are.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind when looking at speed ratings that they are almost always given
    in terms of bits, not bytes. The 56K in a modem rating means 56,000 bits, not
    56,000 bytes of theoretical transfer speed. (This is true even if someone calls
    it a "56K" modem.) Similarly, Fast Ethernet operates at 100 mega*bits* per second,
    not megabytes, and a 1.544 Mbps T1 link sends a theoretical maximum of 1,544,000
    bits each second. This, at least, is usually pretty consistent.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to throughput measurements, however, both bits and bytes are used,
    so you have to be careful. Raw throughput values are normally given in bits per
    second, but many software applications report transfer rates in bytes per second,
    including many web browsers and FTP client programs. This often leads to users
    wondering why they are only getting one-eighth of their expected download or transfer
    speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In most cases in discussions of networking performance, the
    lowercase letter *b* refers to bits and the uppercase *B* to bytes. However, these
    conventions are not always universally followed, so context must be used to interpret
    a particular measurement.'
  prefs: []
  type: TYPE_NORMAL
- en: The standard unit for bit throughput is the bit per second, which is commonly
    abbreviated bit/s, bps, or b/s. The byte unit is byte per second, abbreviated
    bytes/s, Bps or B/s—unless some cruel author decides to use a lowercase *b* just
    to confuse you! This means that the maximum theoretical throughput of 100BASE-TX
    (100 Mbps) Ethernet is about 12 MB/s. Where the context is unclear, it is better
    to spell out the unit as 100 Mbits/s or 12 Mbytes/s, which, of course, I try to
    do in this book.
  prefs: []
  type: TYPE_NORMAL
- en: You will also occasionally, especially when dealing in the realm of communications,
    see throughput measured in characters per second, or cps. In most computer systems
    (including PCs), each character takes up one byte, so cps is equivalent to bytes/s,
    B/s, or Bps.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, most networking technologies don't move just a few bits and bytes
    around every second; they move, thousands, millions, or even billions. Thus, most
    speed ratings are not in bits per second, but rather *kilo*bits (Kb), *mega*bits
    (Mb), or *giga*bits (Gb) per second, and the same thing can be done for bytes.
    Thus, you find terms such as 100 Mbps Ethernet or 700 kb/s ADSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you run into another problem: the existence of both decimal and binary
    versions of the terms *kilo*, *mega*, and *giga*. For example, the decimal form
    of the prefix for a million (mega) is 10⁶ or 1,000,000, while the binary form
    is 2^(20) or 1,048,576\. This differential of about 5 percent leads to all sorts
    of confusion. When you see these abbreviations, bear in mind that in networking,
    they almost always refer to the decimal form. Thus, 100 Mbps Ethernet is rated
    at 100,000,000 bits per second, not 104,857,600 bits per second.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The unit most often used to express networking throughput is
    *bits per second* or *bps*. This term is often expressed in thousands, millions,
    or billions as *Kbps*, *Mbps*, or *Gbps*. It almost always uses the decimal, not
    binary, versions of the kilo, mega, or giga multipliers.'
  prefs: []
  type: TYPE_NORMAL
- en: Baud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, there''s another term that you will encounter frequently in discussions
    of modems and some other technologies: the *baud*. Named for telegraphy pioneer
    Jean-Maurice-Émile Baudot (1845–1903), this unit measures the number of changes,
    or transitions, that occur in a signal in each second. So, if the signal changes
    from a one value to a zero value (or vice versa) one hundred times per second,
    that is a rate of 100 baud.'
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of very slow modems, each bit transition encoded a single
    bit of data. Thus, 300 baud modems sent a theoretical maximum of 300 bits per
    second of data. This led to people confusing the terms *baud* and *bits per second*—and
    the terms are still used interchangeably *far* too often. You will commonly hear
    people refer to a 28.8 Kbps modem, for example, as running at 28,800 baud.
  prefs: []
  type: TYPE_NORMAL
- en: But the two units are in fact not the same; one measures data (the throughput
    of a channel), and the other measures transitions (called the *signaling rate*).
    Modern modems use advanced modulation techniques that encode more than one bit
    of data into each transition. A 28,800 bps modem typically encodes nine bits into
    each transition; it runs at 3,200 baud, not 28,800 baud (the latter number being
    the product of 3,200 and 9). In fact, there's no way to operate a modem on a conventional
    phone line at 28,800 baud—it exceeds the frequency bandwidth of the phone line.
    That's the reason why advanced modulation is used to encode more data into each
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *baud* and *bps* units are often treated equivalently,
    but are not the same. *Baud* measures not the throughput of a network but its
    signaling rate, meaning the number of times that the signal changes value in each
    second. Since modern encoding and modulation techniques often encode either greater
    or less than one bit value into each such transition, the throughput and baud
    rate of network technologies are usually different.'
  prefs: []
  type: TYPE_NORMAL
- en: Theoretical and Real-World Throughput, and Factors Affecting Network Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When assessing the performance of networks, keep in mind that there is always
    a difference between theoretical speed ratings and real-world throughput. If your
    network is set up well, this difference is relatively small but still significant.
    Otherwise, the difference can be extremely large. (Notice that the difference
    between theoretical and practical performance can never be negligible.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons for the difference between what a network or communications
    method is supposed to be able to do and what it actually can do. The reasons generally
    fall into three categories: normal network overhead, external performance limiters,
    and network configuration problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*There are many different ways of measuring and assessing performance. Synthetic
    benchmark programs are often used to measure throughput, and can produce impressive
    performance scores, which usually have little to do with how a network will actually
    operate. Such metrics are best used for comparison purposes by showing that one
    network or system is faster than another, rather than by paying too much attention
    to the actual number the metrics produce. Even when doing comparisons, however,
    caution is wise*.'
  prefs: []
  type: TYPE_NORMAL
- en: Normal Network Overhead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every network has some degree of normal network overhead, which guarantees that
    you will never be able to use all of the bandwidth of any connection for data.
    Take as an example 10 Mbps Ethernet. Sure, the line may be able to transmit 10,000,000
    bits every second, but not all of those bits are data! Some are used to package
    and address the data—data can't just be thrown onto the network in raw form. Also,
    many of those bits are used for general overhead activities, and they deal with
    collisions on transmissions and other issues. There are natural inefficiencies
    in any networking technology.
  prefs: []
  type: TYPE_NORMAL
- en: Even beyond this, there are other overhead issues. Any network transaction involves
    a number of different hardware and software layers, and overhead exists at each
    of them, from the application and operating system down to the hardware. These
    overheads mean that you generally lose at least 20 percent of the rated speed
    of a local area network (LAN) technology off the top, and sometimes even more.
    For example, 7 Mbps user data throughput on a regular 10 Mbps Ethernet network
    is actually very good.
  prefs: []
  type: TYPE_NORMAL
- en: External Performance Limiters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are external factors that limit the performance of a network. Important
    issues here include the ability of the hardware to process the data and also any
    bandwidth limitations that exist in the chain of data transmission between two
    nodes. Hardware issues most often show up with very fast networking technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a gigabit (1,000 Mbps) Ethernet connection between two regular PCs.
    In theory, this connection should allow the transmission of 1 GB of data every
    second. Even beyond the matter of overhead mentioned earlier, no regular PC is
    capable of pumping this much data per second. Only high-end servers have this
    capacity—and even they would have problems sustaining this unless they were doing
    nothing else. An older PC's hard disk probably can't even stream data fast enough
    to keep a 100 Mbps Ethernet connection busy. Thus, upgrading a 100 Mbps Ethernet
    card in an older machine to gigabit is not likely to help as much as you might
    expect.
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth limitations cause network throughput issues because the entire network
    can run only as fast as its slowest link. These bottlenecks create reduced performance.
    As a common example, suppose you have a cable modem connection to the Internet
    that is rated at 1 Mbps for downloads. It may be very fast most of the time, but
    if the website you are accessing is totally bogged down or it is having connectivity
    problems itself, you are not going to download from that site at 1 Mbps. In fact,
    your download probably won't even get close to that speed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's also important to remember that there are many technologies that
    simply do not always operate at a constant fixed speed, though they may change
    speeds based on physical network characteristics. A good example is an analog
    modem, which can vary greatly in performance depending on the quality of the line
    over which it operates.
  prefs: []
  type: TYPE_NORMAL
- en: Network Configuration Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The issues I mentioned earlier are usually ones that you cannot do anything
    about; they are just the nature of the networking beast. The third category of
    performance limiters, *misconfiguration*, is different. This refers to network
    slowdowns that occur because hardware or software has not been set up correctly.
    Poor cabling, misconfigured interface cards, or bad drivers can *seriously* reduce
    the performance of a network—by 90 percent or even more.
  prefs: []
  type: TYPE_NORMAL
- en: These problems can usually be corrected, but only if you are looking for them.
    Driver problems are particularly insidious because the natural tendency is for
    people to blame hardware when slowdowns occur. However, you cannot get the most
    of your hardware devices without proper software to run it. These issues are much
    more significant with bleeding-edge hardware than with established products, incidentally.
  prefs: []
  type: TYPE_NORMAL
- en: Also included in this category of issues are problems that occur due to poor
    design. For example, putting 30 busy workstations on a shared 10 Mbps Ethernet
    segment is likely to result in poor performance—using a switch would be much better.
    Another common mistake is not providing a "fatter pipe" (higher bandwidth connection)
    to servers in a client/server setup. These issues can be avoided or ameliorated
    by reconfiguring the network—or even better, by designing it properly in the first
    place, right?
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bear in mind that many networking technologies, especially ones used for Internet
    access, are *asymmetric*, meaning that they offer much higher bandwidth in one
    direction than the other. Usually, this is arranged so that more bandwidth goes
    down to the user than from the user to the network, since most Internet users
    download far more than they upload. However, it's always important to find out
    if a speed rating is for both directions, or for only one direction, and if so,
    what the other direction's speed is. Common technologies with asymmetric performance
    include 56K modems, Asymmetric Digital Subscriber Line (ADSL), cable modems, and
    satellite Internet access. Beware, because the marketing people who sell these
    technologies will often try to hide the asymmetry of their services, usually highlighting
    only the bigger download figure and avoiding mention of the slower uploads.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetry can also have unexpected effects on network performance, because most
    communications, even if they seem unidirectional, are not. The most common case
    is when an Internet access technology has much higher download bandwidth than
    upload bandwidth. When using TCP/IP to download data, acknowledgments must be
    sent regularly. If the upstream bandwidth is too low, this may make it impossible
    to fully exploit the download bandwidth of the link.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The theoretical rated speed of a network is never achieved
    in practice for a number of reasons. *Overhead* issues mean that not all of the
    possible capacity of a network can be used for data. *External factors* such as
    hardware bandwidth limitations restrict data input and output. *Configuration
    problems* can also greatly reduce real-world performance. Finally, it is important
    to remember that many technologies are asymmetric, offering higher speed in one
    direction than the other, and often, the larger number is the one that is advertised.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplex, Full-Duplex, and Half-Duplex Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another aspect of performance that is worthy of some attention is the mode of
    operation of the network or connection. Obviously, whenever we connect together
    Device A and Device B, there must be some way for Device A to send to Device B
    and Device B to send to Device A. Many people don't realize, however, that networking
    technologies can differ in terms of how these two directions of communication
    are handled. Depending on how the network is set up and the characteristics of
    the technologies used, you may be able to improve performance through the selection
    of performance-enhancing modes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with a look at the three basic modes of operation that can exist
    for any network connection, communications channel, or interface.
  prefs: []
  type: TYPE_NORMAL
- en: Simplex Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *simplex* operation, a network cable or communications channel can send
    information in only one direction; it''s a one-way street. This may seem counterintuitive:
    What''s the point of communications that travel in only one direction? In fact,
    there are at least two different places in which simplex operation is encountered
    in modern networking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is when two distinct channels are used for communication: one transmits
    from A to B and the other from B to A. This is surprisingly common, even though
    it isn''t always obvious. For example, most, if not all, fiber-optic communication
    is simplex, meaning that it uses one strand to send data in each direction. But
    this may not be obvious if the pair of fiber strands are combined into one cable.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplex operation is also used in special types of technologies, especially
    ones that are asymmetric. For example, one type of satellite Internet access sends
    data over the satellite only for downloads, while a regular dial-up modem is used
    for upload to the service provider. In this case, both the satellite link and
    the dial-up connection are operating in a simplex mode.
  prefs: []
  type: TYPE_NORMAL
- en: Half-Duplex Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technologies that employ *half-duplex* operation are capable of sending information
    in both directions between two nodes, but only one direction or the other can
    be utilized at a time. This is a fairly common mode of operation when there is
    only a single network medium (cable, radio frequency, and so forth) between devices.
  prefs: []
  type: TYPE_NORMAL
- en: While this term is often used to describe the behavior of a pair of devices,
    it can refer more generally to any number of connected devices that take turns
    transmitting information. For example, in conventional Ethernet networks, any
    device can transmit, but only one may do so at a time. For this reason, regular
    (unswitched) Ethernet networks are often said to be half-duplex, even though it
    may seem strange to describe a LAN that way.
  prefs: []
  type: TYPE_NORMAL
- en: Full-Duplex Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *full-duplex* operation, a connection between two devices is capable of sending
    data in both directions simultaneously. Full-duplex channels can be constructed
    either as a pair of simplex links (as described earlier) or by using one channel
    that's designed to permit bidirectional simultaneous transmissions. A full-duplex
    link can connect only two devices, so many such links are required if multiple
    devices are to be connected together.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The term* full-duplex *is somewhat redundant;* duplex *would suffice, but
    everyone still says full-duplex (likely, to differentiate this mode from half-duplex)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of these three options, full-duplex is obviously the one that yields the highest
    performance. Full-duplex operation doubles the theoretical bandwidth of the connection.
    If a link normally runs at 1 Mbps but can work in full-duplex mode, it really
    has 2 Mbps of bandwidth (1 Mbps in each direction). Remember the key word *theoretical*,
    however—you do not really get double the performance in real life, because communications
    usually do not involve sending a lot of data in both directions at once. However,
    you certainly get better throughput than you do in a half-duplex mode.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the mode of operation is a function of the technology and cannot
    be changed. In others, however, full-duplex mode is a matter of the correct hardware
    settings, and also whether the software supports full-duplex operation. Thus,
    getting higher performance in this area is sometimes simply a matter of ensuring
    proper configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Full-duplex operation has been pretty much taken for granted in communications
    for years. The more interesting development has been the rise in the significance
    of full-duplex operation for local area networking. Traditionally, LANs have always
    used half-duplex operation on a shared access medium. As the use of switches has
    increased, thereby allowing dedicated bandwidth to each computer, full-duplex
    operation has become very popular. Full-duplex operation in Ethernet not only
    allows the simultaneous transmission of data in both directions, but also eliminates
    contention for the formerly shared access medium—thus, no more collisions. The
    combination of these two effects improves performance, sometimes substantially.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** There are three basic operating modes that describe how data
    is sent between connected devices on a network. In a *simplex* operation, data
    can flow in only one direction between two devices. *Half-duplex* networks allow
    any device to transmit, but only one may do so at a time. *Full-duplex* operation
    means two attached devices can each transmit and receive simultaneously. The latter
    offers the greatest potential performance, because forcing one device to wait
    for another before sending data does not decrease throughput.'
  prefs: []
  type: TYPE_NORMAL
- en: Quality of Service (QoS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my discussion of common network performance measurements earlier in this
    chapter, I mentioned that there are many different aspects to network performance.
    I also introduced the concept of *latency*, which measures how long it takes for
    data to travel across a network. Latency is one important part of a larger issue
    in networking that is sometimes called *quality of service* or *QoS*.
  prefs: []
  type: TYPE_NORMAL
- en: The inherent nature of most networking technologies is that they are more concerned
    with pumping data from one place to another as fast as possible than they are
    with how the data is sent. For example, the Internet is designed on top of the
    Internet Protocol (IP), a packet-switching technology (described in [Chapter 1](ch01.html
    "Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES")) that is designed
    to get packets from point A to point B in the most effective way, without requiring
    the user to have any knowledge about what route will be taken. In fact, some packets
    in the same data stream may be sent along different routes. Packets may be stored
    for a while before being forwarded to their destination, or even dropped and retransmitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most applications, such as simple file or message transfers, this is perfectly
    fine. However, there are applications for which this sort of service represents
    low quality. In these cases, the nature of how the data is delivered is more important
    than merely how fast it is, and there is a need for technologies or protocols
    that offer QoS. This general term can encompass a number of related features such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bandwidth Reservation** The ability to reserve a portion of bandwidth in
    a network or interface for a period of time so that two devices can count on having
    that bandwidth for a particular operation. This is used for multimedia applications
    for which data must be streamed in real time, and packet rerouting and retransmission
    would result in problems. This is also called *resource reservation*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latency Management** A feature that limits the latency between two devices
    in any data transfer to a known value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic Prioritization** In conventional networks, all packets are created
    equal. A useful QoS feature is the ability to handle packets so that more important
    connections receive priority over less important ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic Shaping** This refers to the use of buffers and limits, both of which
    restrict traffic across a connection to a value below a predetermined maximum.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Congestion Avoidance** This QoS feature refers to monitoring particular
    connections in a network and rerouting data when a particular part of the network
    is becoming congested.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in essence, QoS in the networking context is analogous to QoS in the real
    world. It is the difference between getting take-out and sit-down service at a
    nice French restaurant—both cure the hunger pangs, but they meet very different
    needs. Some applications, especially multimedia applications such as voice, music,
    and video, are time dependent and require a constant flow of information more
    than raw bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The generic term *quality of service (QoS)* describes the characteristics
    of how data is transmitted between devices, rather than how quickly it is sent.
    QoS features seek to provide more predictable streams of data rather than faster
    ones. Examples of such features include bandwidth reservation, latency minimums,
    traffic prioritization and shaping, and congestion limitation. QoS is more important
    for specialty applications, such as multimedia, than for routine applications,
    such as those that transfer files or messages.'
  prefs: []
  type: TYPE_NORMAL
- en: To support QoS requirements, many newer technologies have been developed or
    enhanced to add QoS features to them. This includes the ability to support *isochronous
    transmissions* that can reserve a specific amount of bandwidth over time to support
    applications that must send data in real time. One technology that has received
    a lot of attention for its QoS features is Asynchronous Transfer Mode (ATM). ATM
    is designed to support traffic-management features that are not generally available
    on networks that haven't been optimized to provide QoS features (such as Ethernet).
  prefs: []
  type: TYPE_NORMAL
- en: QoS has become a big buzzword lately. By itself, this term conveys about as
    much useful information about what the technology offers as being told that it
    is high performance. You have to dig past the marketing-speak and find out exactly
    what QoS features are being offered.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can't study networking and its related technologies without very quickly
    encountering a whole host of standards that are related to the subject, as well
    as the organizations that create these standards. Network standards facilitate
    the interoperability of network technologies and are extremely important. It may
    be an exaggeration to say that networking would not exist without standards, but
    it isn't an exaggeration to say that networking *as we know it* would not exist
    without them. Networks are literally everywhere, and every hardware device or
    protocol is governed by at least one standard and usually many.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I briefly examine the often overlooked subject of network standards
    and standards organizations. I begin with a background discussion of why standards
    are important, highlighting the differences between proprietary, de facto, and
    open standards. I give an overview of networking standards in general terms and
    then describe the most important international standards organizations and industry
    groups related to networking. I then describe the structure of the organizations
    responsible for Internet standards, including the registration authorities and
    registries that manage resources such as addresses, domain names, and protocol
    values. I conclude with a discussion of the Request for Comment (RFC) process
    used for creating Internet standards.
  prefs: []
  type: TYPE_NORMAL
- en: Proprietary, Open, and De Facto Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are standards important? An old saw in the computer world says, "The beauty
    of standards is that there are so many to choose from." This little joke reflects
    the frustration that technicians often feel at the thousands of standards that
    are found in the industry. Aside from differing in terms of content—what technologies
    and protocols they describe—standards also often differ in terms of their type
    and how they came about. In fact, part of the reason why there are sometimes so
    many to choose from in a particular area is *because* of how they come about.
  prefs: []
  type: TYPE_NORMAL
- en: Proprietary Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days of computing, many people didn't quite understand just how
    important universal standards were. Most companies were run by skilled inventors,
    who came up with great ideas for new technologies, but who weren't particularly
    interested in sharing them. It wasn't considered a smart business move to share
    information about new inventions with other companies—the competition! Oh sure,
    companies believed that standards were important, but they thought it was even
    more important that *they* be the ones to control those standards.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that it's 1985, and I have just come up with a great networking
    technology, which I have incorporated into a fancy new local area networking (LAN)
    product called SooperDooperNet. SooperDooperNet is *my* product. I have patents
    on the technology, I control its design and manufacture, and I sure as heck don't
    tell anyone else how it works, because if I did, someone would copy me.
  prefs: []
  type: TYPE_NORMAL
- en: I could sell interface cards, cables, and accessories for SooperDooperNet, and
    companies that wanted to use it could install the cards in all of their PCs and
    be assured that those computers would be able to talk to each other. This solves
    the interoperability problem for this company by creating a "SooperDooperNet standard."
    This would be an example of a *proprietary* standard—it's owned by one company
    or person.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with proprietary standards is that other companies are excluded
    from the standard development process, and therefore have little incentive to
    cooperate with the standard owner. In fact, just the opposite: They have a strong
    motivation to develop a competing proprietary standard, even if it doesn''t improve
    on the existing one.'
  prefs: []
  type: TYPE_NORMAL
- en: So when my competition sees what I am doing, he is not going to also create
    network interface cards that can work with SooperDooperNet, which would require
    paying me a royalty. Instead, he is going to develop a new line of networking
    hardware called MegaAwesomeNet, which is very similar to SooperDooperNet in operation
    but uses different connectors, cable, and logic. He, too, will try to sell bunches
    of cards and cables to my customers.
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the market ends up with different companies using different
    products that don't work together. If you install SooperDooperNet, you *have*
    to come to me for any upgrades or changes—you have no choice. Worse, what happens
    if Acme Manufacturing, which has 50 PCs running SooperDooperNet, merges with Emca
    Manufacturing, which has 40 PCs running MegaAwesomeNet? The IT people have a problem.
    Sure, there would be ways to solve it, but wouldn't everyone be better off avoiding
    these difficulties in the first place? And how could you create something like
    the Internet if everyone's networks use different "standards"?
  prefs: []
  type: TYPE_NORMAL
- en: Open Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eventually, companies learned that they would be better off with standards that
    everyone agreed on. This is particularly true of networking, where devices need
    to talk to each other. If many companies get together and agree to cooperate,
    they can create an *open standard* instead of a bunch of proprietary ones. The
    name is rather self-explanatory; rather than being the closely guarded secret
    of one organization, an open standard is available to anyone who is interested
    in using it.
  prefs: []
  type: TYPE_NORMAL
- en: One key to the success of an open standard is a steering organization to promote
    it. Usually, a neutral, nonprofit trade association or working group is established
    to develop the standard, and the various for-profit hardware and software companies
    join this group and support it financially. These groups also work with standards
    approval bodies like the International Telecommunication Union (ITU) and International
    Organization for Standardization (ISO) to gain acceptance for their standards.
    These and other standards organizations are described in the "International Networking
    Standards Organizations" section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the companies aren't doing this just to be nice to their customers.
    In creating open standards, they split the market-share pie among them, but they
    make the pie grow much larger by attracting more customers. Customers like open
    standards more than proprietary ones, because those standards give them more choices
    and increase their ability to interact with other companies, troubleshoot problems,
    hire skilled workers, and expand in the future. As for the companies, they still
    compete with their specific offerings, so it's not like they all end up making
    the same products. For all of these reasons, open standards are now far more common
    than proprietary ones.
  prefs: []
  type: TYPE_NORMAL
- en: However, the process involved in creating these standards is often a difficult
    one. In some cases, the standards organization will draft the standard from the
    ground up, but in others, it may select one technology as the basis for the standard
    from several that are submitted in what is commonly called a "technology bake-off."
    Thus, many different companies may come to the table with different approaches,
    each of them vying for selection as the standard for use by the group. Politics
    can cause groups to get bogged down for years fighting over various options, or
    even to split into multiple groups. Good examples are what occurred in the conflict
    between supporters of 100VG-AnyLAN and Fast Ethernet, and the problems with standards
    politics that have plagued the world of powerline networking.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, there are still some companies that believe strongly in proprietary
    standards, because they really want to control and direct the market. One of the
    most famous (infamous) in this regard is Sony, a company that makes excellent
    hardware but frequently refuses to accept established standards. For this reason,
    some people avoid Sony's products, even though they are good, because they want
    to stick to industry standards.
  prefs: []
  type: TYPE_NORMAL
- en: De Facto Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This brings me to the third type of standard that is often seen in the computer
    world: the *de facto standard*. "De facto" is Latin for "in fact." A de facto
    standard is one that is used as a universal standard just because, over time,
    it has been widely used, and not because the standard was developed and approved
    by a standards committee.'
  prefs: []
  type: TYPE_NORMAL
- en: A good example of a de facto standard is the AT command set used by modems.
    Virtually all modems use it, but this acceptance didn't result from an industry
    group agreeing to adopt and deploy it. Rather, it was developed unilaterally by
    Hayes, the pioneering modem company, and then adopted by virtually every other
    modem maker until it became a standard.
  prefs: []
  type: TYPE_NORMAL
- en: One reason why proprietary standards are still sometimes seen is that some companies
    want to produce a standard that will become so universally used that it becomes
    the de facto standard, thus giving them a leadership position in that market.
    Again, in my estimation, Sony falls into this category—the developers often want
    to do things their way and create proprietary standards that they try to promote
    using their powerful market presence.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes this succeeds, but often it does not, resulting in a fragmented market
    of incompatible products. An excellent example is when Sony created a new format
    for a digital camera's flash memory (the Memory Stick) rather than using the CompactFlash
    format used by other camera manufacturers. The end result was that not everyone
    used memory sticks as Sony had hoped, and there were now two incompatible standards
    that increased confusion and yielded no real benefit to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Networking standards can be classified as *proprietary, open*,
    or *de facto*. Proprietary standards are owned by one particular organization.
    If that organization has sufficient market clout and the industry lacks alternatives
    to its standard, it may be adopted by the whole industry, becoming a de facto
    standard. Usually, however, differing proprietary standards compete with each
    other, resulting in a fragmented market. In contrast, open standards are not owned
    by anyone—they are created by neutral organizations to ensure that compatible
    products can be designed and developed by many different companies. This makes
    life easier for the customer and also promotes the market as a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: Networking Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All networking technologies have standards associated with them. These are usually
    highly technical documents, and they often presume that the reader has a fair
    bit of knowledge about networking. If you aren't an expert, you will probably
    have some difficulty understanding networking standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, many technologies have quite a number of standards associated with
    them. A networking technology may have more than one standard for any or all of
    the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The original standard has been revised or updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technology is sufficiently complex that it needs to be described in more
    than one document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technology borrows from or builds on documents used in related technologies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More than one organization has been involved in developing the technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standards documents created in the United States are usually developed in English,
    but are also routinely translated into other languages. European standards are
    often published simultaneously in English, French, German, and perhaps other languages
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Today, virtually all networking standards are open standards, administered by
    a standards organization or industry group. As I explained in the previous section,
    open standards are more popular than proprietary ones in the computer industry,
    and that's especially true when it comes to networking. In fact, the few technologies
    for which there is no universally accepted open standard have been losing ground
    to those with open standards, particularly in the areas of wireless LANs and home
    networking. This pretty much proves how important an open process really is.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*You''ll find discussions of various standards throughout this book. These
    can usually be found in an overview chapter introducing each technology type,
    though the discussions of more complex protocols include a section discussing
    relevant standards*.'
  prefs: []
  type: TYPE_NORMAL
- en: International Networking Standards Organizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rise of open standards has been a great boon to customers of computer and
    networking products, as well as to the manufacturers that sell to them. In order
    to facilitate the development of open standards, however, we need organizations
    that will coordinate the creation and publishing of these documents. Generally,
    these are nonprofit organizations that specifically take a neutral stance regarding
    technologies and work for the betterment of the industry as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a selective list of some of the standards organizations that you are
    likely to encounter when reading about networking and the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '**International Organization for Standardization (ISO)** Probably the biggest
    standards organization in the world, the ISO is really a federation of standards
    organizations from dozens of nations. In the networking world, the ISO is best
    known for its OSI Reference Model, which is discussed in [Part I-2](pt02.html
    "Part I-2. THE OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL") of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The shortened name of the International Organization for Standardization is
    indeed ISO, not IOS, as you might imagine. In fact, it is not an acronym at all.
    Since the full name of the body differs from one language the next, any acronym
    for that name would differ as well. Instead, the organization chose the name ISO
    from the Greek word* isos, *meaning equal. Many people, especially in the United
    States, think ISO is short for International Standards Organization, but this
    is incorrect*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**American National Standards Institute (ANSI)** ANSI is the main organization
    responsible for coordinating and publishing computer and information technology
    standards in the United States. Although many people think that this organization
    develops and maintains standards, it does neither. Instead, it oversees and accredits
    the organizations that actually create the standards, qualifying them as *Standards
    Developing Organizations* or *SDOs*. ANSI also publishes the standards documents
    created by the SDOs and serves as the United States'' representative to the ISO.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Information Technology Industry Council (ITIC)** ITIC is a group of several
    dozen companies in the information technology (computer) industry. ITIC is the
    SDO approved by ANSI to develop and process standards related to many computer-related
    topics. It was formerly known as the *Computer and Business Equipment Manufacturers
    Association (CBEMA)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**National Committee for Information Technology (NCITS)** NCITS is a committee
    established by the ITIC to develop and maintain standards related to the information-technology
    world. NCITS was formerly known by the name *Accredited Standards Committee X3,
    Information Technology*, or more commonly, just *X3*. It maintains several subcommittees
    that develop and maintain standards for various technical subjects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Institute of Electrical and Electronics Engineers (IEEE)** The IEEE (pronounced
    "eye-triple-ee") is a well-known professional organization for those in the electrical
    or electronics fields, including computers and networking. IEEE''s main claim
    to fame in the networking industry is the IEEE 802 Project, which encompasses
    many popular networking technologies, including Ethernet.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Industries Alliance (EIA)** The EIA is an international industry
    association that is best known for publishing electrical wiring and transmission
    standards.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Telecommunications Industry Association (TIA)** The TIA is the communications
    sector of the EIA, and it is responsible for developing communications standards.
    Since communications, wiring, and transmission are all related, and since the
    TIA and EIA organizations are also related, standards produced by the EIA or TIA
    are often labeled with the combined prefixes EIA/TIA or TIA/EIA.'
  prefs: []
  type: TYPE_NORMAL
- en: '**International Telecommunication Union—Telecommunication Standardization Sector
    (ITU-T)** ITU-T is another large international body that develops standards for
    the telecommunications industry. The ITU-T was formerly named the International
    Telephone and Telegraph Consultative Committee (CCITT; the abbreviation comes
    from the French version of the organization''s name: *Comité Consultatif International
    Téléphonique et Télégraphique*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**European Telecommunications Standards Institute (ETSI)** An organization
    with members from dozens of countries both within and outside Europe that is dedicated
    to developing telecommunications standards for the European market (and elsewhere).
    ETSI is known for, among other things, regulating the use of radio bandwidth in
    Europe and developing standards such as HiperLAN.'
  prefs: []
  type: TYPE_NORMAL
- en: Many of these organizations do not actually develop the various standards. Generally,
    these are oversight organizations—high-level management, if you will—that work
    with many other smaller groups who actually develop the standards. Also, in many
    cases, a particular standard may be published by more than one standards organization,
    so it may be labeled with more than one name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The set of related organizations responsible for creating Internet standards
    is not shown in this list because I have elected to cover them in two dedicated
    sections later in this chapter, on Internet standards organizations and registration
    authorities*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** There are a number of well-known international organizations
    that play important roles in the development of open networking standards. Some
    of the most important of these are ISO, ANSI, ITIC, IEEE, EIA/TIA, ITU-T, and
    ETSI. These are oversight organizations, responsible for overall management of
    the standards development process, rather than for the particulars of creating
    individual standards.'
  prefs: []
  type: TYPE_NORMAL
- en: Networking Industry Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While most open standards are coordinated and published by a small number of
    large, often international, standards organizations, these are not the only groups
    involved in the development of standards for networking and Internet technologies.
    Many different networking *industry groups* play an important role in the standard
    creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Networking industry groups differ in a few ways from standards organizations.
    They are typically dedicated to the promotion of a specific technology, whereas
    standards organizations are more generic and oversee hundreds of different ones.
    Industry groups are also generally smaller than standards organizations, with
    members drawn primarily from the field of developers and manufacturers that create
    products for the particular technology the group promotes.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps most important, industry groups often actually write and maintain the
    standards, whereas standards organizations generally act as supervisors who ensure
    that the standards are clear enough to be implemented. Some industry groups, however,
    are concerned only with marketing and promotion activities.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, these industry groups work closely together with the standards organizations.
    In some cases, they may even be part of the same overall organization, and all
    of the different groups are related in some way. For example, the IEEE 802 Project
    consists of a number of working groups charged with maintaining and developing
    specific technology standards, which the larger IEEE organization approves and
    publishes.
  prefs: []
  type: TYPE_NORMAL
- en: One of these working groups is the 802.11 working group, which develops wireless
    Ethernet technology. At the same time that this group does its thing, there is
    an industry group called the *Wireless Ethernet Compatibility Alliance (WECA)*.
    This group works to ensure the cross-vendor compatibility of 802.11b wireless
    networking hardware and software.
  prefs: []
  type: TYPE_NORMAL
- en: Other industry groups are formed specifically to develop independent standards
    that are not approved through a formal standardization process. Examples include
    groups such as HomePNA, IrDA, and HomeRF.
  prefs: []
  type: TYPE_NORMAL
- en: One of the problems with these groups is that they usually do not make their
    standards open to the public. This is undoubtedly due to some sort of security
    concern or desire to keep the inner workings of their technology secret. Unfortunately
    for these groups, this policy harms the ability of regular people to learn how
    their technologies work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As an example of what I mean about these closed standards, I can point to
    my own experience in writing this and other reference works. I was almost always
    unable to obtain specifications from most of the private industry groups. They
    either refused to allow me to get the document at all or wanted to charge me a
    great deal of money for the privilege (well into the thousands of dollars in some
    cases). In doing this, these groups harm their own cause, thereby making it more
    difficult for those interested in their technologies to learn about them. This
    is another key advantage of having open standards managed by public organizations
    such as ANSI or the IEEE*.'
  prefs: []
  type: TYPE_NORMAL
- en: Internet Standards Organizations (ISOC, IAB, IESG, IETF, IRSG, and IRTF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-quality, widely accepted open standards become more important as the number
    of people that use a network grows. The largest network of all is of course the
    *Internet*, which connects millions of people on thousands of individual networks
    into a globe-spanning internetwork. The Internet has revolutionized not only networking
    and computing, but also communication, business, and even society as a whole.
    One of the critical factors in the success of the Internet has been its development
    using open standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, nobody sat down one day and said, "Hey, let''s create the Internet!"
    (No, not even Al Gore.) It began as a small research network, and was developed
    over time concurrently with the technology set that implemented it: TCP/IP. At
    first, a relatively small organization was sufficient for managing the development
    of Internet standards and overseeing its activities, but as the Internet continued
    to grow, this organization became inadequate. Eventually, a more formalized structure
    of organizations was required in order to manage the Internet development process
    and other activities. This ensured the continued success and growth of the Internet
    and the TCP/IP technologies that powered it.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, six organizations are responsible for the development of the Internet's
    architecture, standards and policies, and related activities. They are closely
    related, with certain organizations responsible for overseeing others. These organizations
    perform many tasks and can be somewhat confusing to understand, since many have
    similar-sounding names and responsibilities. Therefore, I will concentrate mostly
    on their role in the development of Internet standards, since that is the primary
    interest in this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are brief descriptions, rather simplified, of the key Internet standards
    organizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Society (ISOC)** A professional society responsible for general,
    high-level activities related to the management, development, and promotion of
    the Internet. ISOC has thousands of individual and organizational members that
    engage in activities such as research, education, public policy development, and
    standardization. It is responsible for providing financial and administrative
    support to the other organizations listed in this chapter. From the standpoint
    of standards development, ISOC''s key role is its responsibility for oversight
    of the IAB.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Architecture Board (IAB)** Formerly the *Internet Activities Board*,
    the IAB is charged with the overall management of the development of Internet
    standards. It makes "big-picture" policy decisions related to how Internet technologies
    and structures should work. This ensures that various standardization efforts
    are coordinated and consistent with overall development of the Internet. It is
    responsible for publishing Internet standards (RFCs), as described in the "Internet
    Standards and the Request for Comment (RFC) Process" section at the end of this
    chapter. It advises the ISOC and oversees the IETF and IRTF; it also acts as an
    appeals body for complaints about the standardization activities performed by
    the IETF. The charter of the IAB is described in RFC 2850.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Engineering Task Force (IETF)** The IETF focuses on issues related
    to the development of current Internet and TCP/IP technologies. It is divided
    into a number of *working groups*, each of which is responsible for developing
    standards and technologies in a particular area, such as routing or security.
    Each area is managed by an *area director*, who serves on the IESG. The IETF is
    overseen directly by the IESG and in turn by the IAB; it is described in RFC 3160.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Engineering Steering Group (IESG)** The IESG is directly responsible
    for managing the IETF and the Internet standards development process. It consists
    of each of the IETF area directors, who make final decisions about the approval
    of proposed standards, and works to resolve any issues that may arise in the standardization
    process. The IESG is technically considered part of the IETF and is also described
    in RFC 3160.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Research Task Force (IRTF)** Where the IETF is focused primarily
    on short-term development issues, the IRTF is responsible for longer-term research
    related to the Internet and TCP/IP technologies. It is a much smaller organization
    than the IETF, consisting of a set of *research groups*, which are analogous to
    the IETF''s working groups. The IRTF is overseen by the IRSG and IAB. It is described
    in RFC 2014.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Research Steering Group (IRSG)** The IRSG manages the IRTF in a
    similar way to how the IESG manages the IETF. It consists of the chairs of each
    of the IRTF research groups and works with the chair of the whole IRTF to make
    appropriate decisions on research activities. It is also discussed in RFC 2014.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](ch03s05.html#internet_standards_organizations_the_iso "Figure 3-1. Internet
    standards organizations The ISOC is responsible for overseeing the IAB, which
    in turn is responsible for the two task forces, the IETF and IRTF, which are headed
    by the IESG and IRSG, respectively.") shows the relationship between the Internet
    standards associations. The ISOC oversees the IAB, which in turn directs the IETF
    and IRTF. The IETF develops current Internet and TCP/IP standards and is headed
    by the IESG, which manages IETF working groups. The IRTF is the IETF''s research
    counterpart, containing *research groups* led by the IRSG.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Internet standards organizations The ISOC is responsible for overseeing the
    IAB, which in turn is responsible for the two task forces, the IETF and IRTF,
    which are headed by the IESG and IRSG, respectively.](httpatomoreillycomsourcenostarchimages287695.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1. Internet standards organizations The ISOC is responsible for overseeing
    the IAB, which in turn is responsible for the two task forces, the IETF and IRTF,
    which are headed by the IESG and IRSG, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Of these organizations, the IETF is the one that you will most often hear referenced,
    because it is directly responsible for the development of the majority of Internet
    standards. Thus, whenever I mention Internet standards development efforts in
    this book, I'm referring to the IETF as the organization doing the work. This
    is, of course, a bit of an oversimplification, since all of these organizations
    play a role in the standards development process, as described later in this chapter,
    in the discussion of the RFC process.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these organizations are responsible for a great deal more than just
    standards development. This is especially true of the ISOC, for which standardization
    is just one of many activities. The IAB also performs a number of functions not
    strictly associated with standards development, including managing the assignment
    of protocol values done by the Internet Assigned Numbers Authority and acting
    as a liaison between the Internet standards organizations and other standards
    bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A group of related organizations is responsible for the development
    of TCP/IP standards and Internet technologies. The *Internet Society (ISOC)* has
    overall responsibility for many Internet activities, including standards development.
    It oversees the *Internet Architecture Board (IAB)*, which makes high-level decisions
    about Internet technology development. Most of the actual work of creating current
    Internet standards is performed by the *Internet Engineering Task Force (IETF)*,
    which is managed by the *Internet Engineering Steering Group (IESG)*. Longer-term
    research is done by the IETF''s sibling organization, the *Internet Research Task
    Force (IRTF)*, which is led by the *Internet Research Steering Group (IRSG)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Internet Registration Authorities and Registries (IANA, ICANN, APNIC, ARIN,
    LACNIC, and RIPE NCC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success of the global Internet relies on the development of universally
    accepted standards for protocols and other technologies. Internet standards organizations
    such as the IETF are thus critically important. They manage the standards development
    process, which ensures that everyone agrees on how to create hardware and software
    that will work together to communicate worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the need to standardize protocols seems obvious, there are a couple of
    other aspects to Internet standardization that are equally important but perhaps
    not quite as well understood:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameter Standardization** Most protocols rely on the use of parameters
    that control how they function. As just two of many, many examples, the IP has
    a set of numbers that define different IP options, and the Address Resolution
    Protocol (ARP) has an Operation Code field that can take on many different values.
    Just as it is essential for devices to agree on what protocols to use, so they
    must also agree on what parameters to use for those protocols, if communication
    is to be successful.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Resource Allocation and Identifier Uniqueness** There are a number
    of resources that are used on the Internet that must be allocated from a fixed
    set of values. Uniqueness in assignment is essential for these values. The most
    obvious example is that each TCP/IP host must have a unique IP address. Another
    important example is ensuring that only one organization uses a given Domain Name
    System (DNS) domain name. If two devices have the same IP address or two organizations
    try to use the same domain name, the results would be unpredictable, but almost
    certainly bad!'
  prefs: []
  type: TYPE_NORMAL
- en: In both of these cases, some sort of centralized organization is required. We
    need a group to take responsibility for managing parameters. It must ensure that
    everyone uses the same parameters, and the same protocols. We also need to coordinate
    the assignment of identifiers such as addresses and names. This ensures that the
    identifiers are created and allocated in a way that is acceptable to all. In the
    world of the Internet, these are sometimes called *management authorities* or
    *registration authorities*.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Centralized Registration Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The organization originally responsible for managing parameters and identifiers
    was the Internet Assigned Numbers Authority (IANA). Amazingly, while the name
    makes it sound like the IANA was a huge bureaucracy, it was effectively one man:
    Jonathan B. (Jon) Postel, one of the most important pioneers of Internet and TCP/IP
    technologies. Jon Postel ran IANA until his untimely death in 1998.'
  prefs: []
  type: TYPE_NORMAL
- en: IANA was originally charged with managing which IP address blocks had been assigned
    to different companies and groups, and it maintained lists of periodically published
    Internet parameters such as UDP and TCP port numbers. It also was in charge of
    the registrations of DNS domain names, which were more directly handled by the
    Internet Network Information Center (InterNIC), a service managed by the United
    States government. Network Solutions, Inc. (NSI) was later granted the contract
    to manage the InterNIC and was eventually purchased by VeriSign.
  prefs: []
  type: TYPE_NORMAL
- en: As the Internet continued to grow, an effort commenced in the mid-1990s to define
    a new organization that would be responsible for the central registration of Internet
    addresses and names. This took the form of a new private, nonprofit company called
    the Internet Corporation for Assigned Names and Numbers (ICANN). ICANN is officially
    charged with all of the centralized registration tasks I have mentioned so far,
    including IP address assignment, DNS domain name assignment, and protocol parameters
    management.
  prefs: []
  type: TYPE_NORMAL
- en: In a simpler world, this development would have meant that ICANN would have
    replaced IANA, which would no longer exist. Instead, ICANN kept IANA around, leaving
    that organization in charge of overseeing IP address registration and Internet
    parameters. ICANN is now in charge of IANA, so both organizations are responsible
    for IP addresses and parameters. This often leads to confusion, and to make things
    worse, it is common to see IANA and ICANN mentioned in conjunction as IANA/ICANN
    or ICANN/IANA.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Internet registration authorities are centralized organizations
    responsible for coordinating protocol parameters and globally assigned resources
    such as IP addresses. The first such organization was the *Internet Assigned Numbers
    Authority (IANA)*, which was initially in charge of IP address assignment, DNS
    domain name management, and protocol parameters. Today, the *Internet Corporation
    for Assigned Names and Numbers (ICANN)* has overall responsibility for these activities;
    the IANA operates under the auspices of ICANN and is still responsible for IP
    address assignment and parameter coordination.'
  prefs: []
  type: TYPE_NORMAL
- en: Modern Hierarchy of Registration Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the original "classful" IP addressing scheme, addresses were assigned to
    organizations directly by IANA in address blocks: Class A, Class B, and Class
    C. Today, a hierarchical, classless addressing system called *Classless Inter-Domain
    Routing (CIDR)* is used instead. Address assignment in CIDR involves the hierarchical
    allocation of blocks of addresses, starting with large blocks that are given to
    big organizations, which split them to assign to smaller groups. (Much more detail
    on these methods can be found in Chapters [Chapter 16](ch16.html "Chapter 16. IPV4
    ADDRESSING CONCEPTS AND ISSUES") through [Chapter 20](ch20.html "Chapter 20. IP
    CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING"), which
    cover IP addressing.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'IANA, as the organization in charge of all IP addresses, assigns the largest
    blocks of addresses to *regional Internet registries (RIRs)* that are responsible
    for further allocation activities. Each RIR manages IP addresses and other Internet
    number resources (such as autonomous system numbers) for a particular region.
    The four regional registries are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asia Pacific Network Information Centre (APNIC)** Covers the Asia/Pacific
    region.'
  prefs: []
  type: TYPE_NORMAL
- en: '**American Registry for Internet Numbers (ARIN)** Manages North America, part
    of the Caribbean, and subequatorial Africa.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latin American and Caribbean Internet Addresses Registry (LACNIC)** Responsible
    for Latin America and part of the Caribbean.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Réseaux IP Européens Network Coordination Center (RIPE NCC)** Takes care
    of Europe, the Middle East, Central Asia, and Africa north of the equator.'
  prefs: []
  type: TYPE_NORMAL
- en: Each registry may assign address blocks to Internet service providers (ISPs)
    directly or further delegate them to *national Internet registries* or smaller
    *local Internet registries*. (See [Chapter 16](ch16.html "Chapter 16. IPV4 ADDRESSING
    CONCEPTS AND ISSUES"), which covers IP address allocation issues, for more details.)
  prefs: []
  type: TYPE_NORMAL
- en: Name registration has changed over the last several years. It is no longer part
    of IANA's responsibilities, and ICANN has opened up the name registration business,
    so it is no longer the province of a single organization such as InterNIC/NSI/VeriSign.
    Now, many different accredited registrars can be used for name registration in
    many of the popular top-level domains. This is discussed in [Chapter 54](ch54.html
    "Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES"),
    which covers DNS public registration. The complete list of documents containing
    Internet and TCP/IP parameters can be found on the IANA's website at [http://www.iana.org/numbers.html](http://www.iana.org/numbers.html).
  prefs: []
  type: TYPE_NORMAL
- en: Internet Standards and the Request for Comment (RFC) Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The precursors of the modern Internet were diminutive networks developed and
    run by a small group of computer scientists and engineers. These technologists
    knew that developing open, widely adopted standards would be essential to the
    eventual growth of the Internet and the TCP/IP protocol suite. But there was no
    formalized standards development mechanism back then.
  prefs: []
  type: TYPE_NORMAL
- en: Standardization was achieved largely through building consensus through discussion
    about new technologies and protocols. If someone had a proposal for a new protocol
    or technology, or an idea for a change to an existing one, that person would create
    a memorandum describing it and circulate it to others. Since the goal was to solicit
    comments on the proposal, these memos were called *Requests for Comments (RFCs)*.
    Not all RFCs described formalized standards; many were just descriptive documents,
    clarifications, or contained miscellaneous information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The documents defining early standards were originally called* Internet Engineering
    Notes (IENs) *before they were called RFCs*.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, of course, the Internet is enormous, and there is an official structure
    of Internet standards organizations that is responsible for creating new Internet
    and TCP/IP standards. Due to the many thousands of people who play an active role
    in developing Internet technologies, an informal system where anyone could just
    write an RFC would lead to chaos. Thus, Internet and TCP/IP standards are still
    called RFCs, but the process of creating one is much more formal and organized
    today.
  prefs: []
  type: TYPE_NORMAL
- en: The IETF is the standards body that is most directly responsible for the creation
    of Internet standards. The IETF's working groups, overseen by the IESG and the
    IAB, develop new protocols and technologies continuously, and these developments
    are formalized in RFCs.
  prefs: []
  type: TYPE_NORMAL
- en: The office of the RFC Editor handles the publishing of RFCs. For nearly 30 years,
    beginning in 1969, the RFC Editor was Internet pioneer Jon Postel. After his death
    in 1998, the function was assigned to the networking division of the USC Information
    Sciences Institute (ISI), where Jon Postel was once director. The function of
    the RFC Editor is to publish and archive RFCs, and to maintain an online repository
    of these documents so that they can be accessed and used by the Internet community.
  prefs: []
  type: TYPE_NORMAL
- en: The open and free access to RFCs has greatly contributed to the Internet's success.
    Even today, if you consider that standards bodies charge thousands of dollars
    for access to a single standard, the ability to log on and immediately retrieve
    any of the thousands of RFCs is noteworthy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*An up-to-date list of RFCs with hyperlinks to each document (except for some
    of the early ones) can be found at the office of the RFC Editor. Go to* [http://www.rfc-editor.org/rfc-index.html](http://www.rfc-editor.org/rfc-index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: RFC Categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned, not all RFCs are official Internet standards. This is important
    to remember. Each RFC has a *category* or *status* associated with it that indicates
    its disposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proposed Standard/Draft Standard/Standard** These documents describe technologies
    that are on the standards track. That means they are either already formally approved
    as standards, or they are likely to become standards in the future. In many cases,
    the document is just listed as "standards track," rather than one of those three
    precise labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Best Current Practice** A document providing guideline information or recommendations
    from the IETF that is not a formal standard.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Informational** A document that provides general information or commentary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Experimental** A proposal for an experimental standard that is not on the
    standards track. In some cases, protocols or proposed changes to existing protocols
    that are not accepted as formal standards are changed to experimental status.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Historic** Former standards that have been made obsolete.'
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Standardization Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before a proposal will be considered for the Internet standardization process,
    it must be published as an *Internet Draft (ID)*. The IETF publishes a set of
    guidelines that specify how IDs must be created and submitted. Members of working
    groups within the IETF who are involved in specific projects write most IDs. However,
    because the standards process is open, any member of the public can independently
    submit a standard for review by creating an ID for consideration by the IETF and
    IESG. IDs are usually revised many times based on feedback from other working
    groups within the IETF.
  prefs: []
  type: TYPE_NORMAL
- en: If an ID has been reviewed and is considered valuable, well understood, and
    stable (meaning that it is not being rapidly updated with new revisions), it may
    become a candidate for standardization. The IESG can place the ID on the Internet
    standards track by changing its status to *proposed standard*. Documents of this
    status are considered mostly complete, but may still be revised based on further
    review, testing, and experimentation with the technology.
  prefs: []
  type: TYPE_NORMAL
- en: Once the specification is sufficiently mature and widely accepted, it may be
    elevated from proposed standard to *draft standard*. A key requirement for such
    advancement is that the technology must be demonstrated to be functional on at
    least two independent and interoperable implementations. This proves that the
    standard has been cleared and completed, and that at least two different groups
    have been able to implement it compatibly.
  prefs: []
  type: TYPE_NORMAL
- en: A document only reaches draft standard when the IETF community believes it is
    technically mature and the specification is complete. Changes are usually only
    made to draft standards to correct problems encountered in testing or resolve
    new issues that arise.
  prefs: []
  type: TYPE_NORMAL
- en: The final station on the Internet standards track is *Internet standard*. This
    designation is applied to only very mature specifications that are popular and
    that have been widely implemented. A document that reaches this status often describes
    a technology that is or will become universally implemented, and is assigned an
    STD (standard) number.
  prefs: []
  type: TYPE_NORMAL
- en: The RFC development process can take months or even years, depending on how
    complex the technology is, how many changes are required to the documents, and
    whether or not the proposal is considered important or interesting. Many RFCs
    never make it officially to Internet standard status; draft standard status is
    generally considered stable enough that the technology is often just implemented
    by companies when that level is reached. Some RFCs never even make it to draft
    standard status, and the technologies they describe are still used in products.
  prefs: []
  type: TYPE_NORMAL
- en: Once an RFC is published, it cannot be changed. This is a specific policy decision
    intended to avoid the confusion that would otherwise result from the fact that
    there were multiple versions of the same RFC. The RFC publication process incorporates
    a number of steps at which RFC authors can revise their documents and check for
    editorial omissions and errors.
  prefs: []
  type: TYPE_NORMAL
- en: This need for a new document whenever a change is made is also why proposals
    are typically published with a category designation of standards track rather
    than proposed standard, draft standard, and Internet standard. This eliminates
    the need to publish a new RFC when a proposal advances down the standards track
    without requiring any real changes aside from a different category designation.
  prefs: []
  type: TYPE_NORMAL
- en: I've just outlined the process for creating and publishing an Internet standard
    here. The full details of the standards process can be found in RFC 2026 (where
    else but an RFC?).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Internet standards are described in a series of documents called
    *Requests for Comments (RFCs)*. The RFC process describes how an Internet standard
    is usually created. An idea for a new technology or enhancement begins with the
    creation of an *Internet Draft (ID)*. After review and feedback, if the proposal
    has support, it may be placed on the Internet standards track, and its status
    will be changed to *proposed standard*. As the fledgling standard matures, its
    status may advance to *draft standard* and eventually, *Internet standard*. However,
    many RFCs are implemented in products without reaching Internet standard status.
    There are also other RFCs that define experimental technologies or provide information
    without describing official Internet standards.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We use decimal (base 10) numbers to represent numeric information, and we use
    various alphabets and symbol systems to represent other types of information.
    In contrast, computers understand only one basic type of information: ones and
    zeros, which themselves are representative of either an on or off electrical state
    within the hardware of the device. These ones and zeros are combined in various
    ways to form more common data elements that we are used to finding in computers:
    regular numbers, characters, and files. However, all of these are really only
    abstractions; the ones and zeros are always underneath whatever logical structures
    are used within the computer.'
  prefs: []
  type: TYPE_NORMAL
- en: This same basic foundation of ones and zeros applies to networking as well.
    Even though most of the information in a network is exchanged in a logical fashion
    between higher-layer protocols, ones and zeros sent over the network medium underlie
    all networking structures. Understanding how data is represented and manipulated
    in computer systems is important because it will help you comprehend many of the
    different technologies. Computer data representation and mathematics are important
    for explaining how low-level physical layer modulation and encoding techniques
    work. Those two elements come into play even for higher-level concepts, such as
    how IP addresses are set up and used on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide some general background information on how numerical
    data is represented, stored, and manipulated within computers and networking hardware.
    I begin with a description of binary numbers and the different terms used to refer
    to collections of binary information of various sizes. I describe the different
    types of numbering systems used in computer systems, such as octal, decimal, and
    hexadecimal, and how data can be converted between these different types. I explain
    how arithmetic is performed on binary and hexadecimal numbers. I then discuss
    boolean logic and how logical functions are used to manipulate binary data.
  prefs: []
  type: TYPE_NORMAL
- en: These explanations then form the basis for a discussion of how logical functions
    are used for setting, clearing, inverting, and masking bits. These operations
    are employed extensively in certain networking technologies and protocols. Masking
    operations especially are often used in IP addressing, so even though this section
    seems rather low-level, it is quite relevant to the world of TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Needless to say, you may know most or all of the information in this chapter,
    so feel free to skip (or just skim) those topics that you already know. I provide
    this background detail for the sake of those new to computing or those needing
    a refresher. However, even those of you who know what a bit and a byte are, and
    know the difference between binary and decimal numbers, may find the discussion
    of bit masking worth perusing*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary Information and Representation: Bits, Bytes, Nibbles, Octets, and Characters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essence of computing is *information*. Computer hardware and software are
    designed to allow the input, storage, transfer, and expression of various types
    of information. One primary way by which types of information are differentiated
    is as either *analog* or *digital*.
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, a light switch and a dimmer. A light switch allows a
    light to be turned on or off; there are no in-between states. These discrete states,
    on or off, represent digital information. In contrast, a dimmer allows you to
    fine-tune the light output from fully on to fully off, with an infinite number
    of intermediate states in between; that's analog information.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern digital computers store information digitally. In the same way a light
    bulb has only an on or off value, so do the components that store and manipulate
    information within computers. Millions of *transistors* compose computer processors
    and other circuits, and are, in highly simplified form, digital switches. Thus,
    all information in computers is manipulated as collections of information pieces
    that can be only on or off, like a switch.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are only two possible states—on or off—this is called *binary* information
    (the prefix *bi* means two). There are several advantages to using binary representation
    for information. It is a simple way to represent many types of information, whether
    a light switch is on or off or a file has been successfully copied. It is also
    possible to combine binary values to represent more complex information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps most important, binary information is *unambiguous*: On is always on,
    and off is always off. This property is important because it allows devices to
    detect clearly the value of a particular piece of information. Computers like
    black and white; they are not particularly good at dealing with shades of gray.
    (This becomes especially important in the field of networking, in which transmission
    of data can cause signals to become polluted by noise.)'
  prefs: []
  type: TYPE_NORMAL
- en: The on or off condition of a binary value can be expressed in a number of different
    ways. In logical expressions, we may consider the value to be true or false. When
    representing mathematical values, the most common representation is one (on) or
    zero (off).
  prefs: []
  type: TYPE_NORMAL
- en: Binary Information Representation and Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fundamental building block of computer information is the *bit* (a contraction
    of *binary digit*). Every bit can be either 0 or 1\. Making the value of a bit
    1 is commonly called *setting* the bit; changing it to 0 is *resetting* or *clearing*
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, bits represent only a very small amount of information: a single
    fact or value. We must make collections of these bits so that we can use them
    to store large amounts of information and more complex data types. The most common
    grouping is to take 8 bits and reference them as a single unit. A collection of
    8 bits is technically called an *octet*, but is more commonly called a *byte*
    (more on that in a moment).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Byte* is a jocular play on the term *bit*. Over time, various sizes of bit
    collections have been defined. Some geek comedian decided that if 8 bits made
    a byte, then 4 bits must be a *nybble* (or "nibble"). Hilarious, no? Larger collections
    have also been defined and given various names. [Table 4-1](ch04.html#binary_information_group_representations
    "Table 4-1. Binary Information Group Representations and Terms") summarizes the
    most common representations of groups of bits and the terms used for them; their
    relative sizes are also shown graphically in [Figure 4-1](ch04.html#binary_information_representations_and_t
    "Figure 4-1. Binary Information Representations and Terms This diagram shows the
    relative sizes of the most commonly sized collections of binary information.").'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. Binary Information Group Representations and Terms
  prefs: []
  type: TYPE_NORMAL
- en: '| Number of Bits | Common Representation Terms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Bit/Digit/Flag |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Nybble/Nibble |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Byte/Octet/Character |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | Double Byte/Word |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | Double Word/Long Word |'
  prefs: []
  type: TYPE_TB
- en: '| 64 | Very Long Word |'
  prefs: []
  type: TYPE_TB
- en: A few of the new terms that appear in [Table 4-1](ch04.html#binary_information_group_representations
    "Table 4-1. Binary Information Group Representations and Terms") are worth special
    mention. A bit is also sometimes called a *flag*; this term is most often heard
    when a bit is used by itself to represent a particular information state. For
    example, a computer might use a Changed flag to represent whether a particular
    file has been modified; this is an analogy to a flag either being raised or lowered
    to indicate a condition. These flags are often seen in networking message formats.
  prefs: []
  type: TYPE_NORMAL
- en: The term *character* is also used to express a set of 8 bits. This use comes
    from the fact that computers often store alphanumeric characters, such as letters
    and numbers, one to a byte. The 16-bit *word* is used fairly often, but not nearly
    as much as *byte*. The larger collections of bits, such as double word and so
    on, are not often encountered in everyday parlance; they are used to represent
    chunks of data in technical fields such as hardware design or programming.
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary Information Representations and Terms This diagram shows the relative
    sizes of the most commonly sized collections of binary information.](httpatomoreillycomsourcenostarchimages287697.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. Binary Information Representations and Terms This diagram shows
    the relative sizes of the most commonly sized collections of binary information.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the number of bits used for each of these terms is a power of two.
    As you will see later in this section, this occurs because when bits come in sets
    that are a power of two in size, they are easier to represent and manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Computers store all information in *binary digital form*. This
    means that all data—whether it''s text, photographs, audio, or whatever else—is
    composed of only collections of ones and zeros. The fundamental building block
    of digital information is the *binary digit* or *bit*, which represents a single
    zero or one state. To represent larger amounts of information, bits can be collected
    into groups of 4, 8, 16, 32, or 64, called *nybbles, bytes, words, long words*,
    and *very long words*, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Byte Versus Octet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There has been some disagreement, and even controversy, surrounding the use
    of the words *byte* and *octet*. The word *byte* has traditionally been the most
    commonly used term for a set of 8 bits, especially in North America. However,
    it is *technically* not the correct term.
  prefs: []
  type: TYPE_NORMAL
- en: A byte is, formally, the smallest unit of data that can be read from or written
    to at one time in a computer system. In almost all cases today, that is indeed
    8 bits, but there have been some systems in which a byte was not 8 bits. Some
    older 36-bit computers used 9-bit bytes, and others had byte sizes of 6 or 7 bits,
    or even variable-sized bytes. For this reason, many people, especially techie
    professionals, prefer the term *octet*, which clearly and unambiguously implies
    8\. This term is much more common outside North America.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This matter of* octets *and* bytes *is the kind of tempest in a teapot that
    computer people love so much. The bottom line in modern computer systems, however,
    is that an octet is a byte and a byte is an octet, and the terms can generally
    be used interchangeably without too much danger. You will more often see* octets
    *used in technical standards. In this book, I use the term* bytes *because it
    is the term that most people are familiar with*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Formally, an *octet* is the correct term for exactly 8 bits,
    while a *byte* is the smallest number of bits that can be accessed in a computer
    system, which may or may not equal 8\. In practice, modern computers use 8-bit
    bytes, and the terms are used interchangeably (with *byte* being more common in
    North America, and octet often being preferred in Europe).'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal, Binary, Octal, and Hexadecimal Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The numbers we are accustomed to using in everyday life are called *decimal
    numbers*. The word *decimal* refers to the number 10\. Every digit can take on
    one of ten values: 0 to 9\. Arithmetic performed on decimal numbers is also called
    *base 10* mathematics, because of this orientation around the number 10\. (Why
    is the number 10 the foundation of our normal mathematical system? Hold both hands
    up and count!)'
  prefs: []
  type: TYPE_NORMAL
- en: Computer systems, however, don't have fingers or toes; they deal only with binary
    numbers, which have just two values. Each bit can represent only a 0 or a 1\.
    A single 0 or 1 value is sufficient for encoding a single fact, such as whether
    something is true or false, or whether the answer is yes or no. But a bit is not
    enough to hold more complex information, such as your bank account balance, a
    text document, or a picture of the Yellowstone Canyon.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Numbers and Their Decimal Equivalents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this reason, larger collections of bits have been created by computer scientists,
    such as bytes (octets), words, and so forth. When individual bits are collected
    into sets in this way, they can represent larger integers, called *binary numbers*.
    Since there are only two possible values for each digit in a binary number (0
    or 1), binary numbers are also called *base 2* numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The key to understanding binary numbers is to realize that they are exactly
    the same as decimal numbers, except that each digit has a value in the range of
    0 to 1, instead of 0 to 9\. For example, when you count in decimals, you go up
    to 9 in the ones place, and then you need a second place for tens. If you go above
    99, you need a third place for hundreds. Each additional place added on the left
    is a higher power of ten.
  prefs: []
  type: TYPE_NORMAL
- en: Binary is the same, except the limit for each place is 1 instead of 9\. So,
    in binary, you go up to 1 in the ones place, and then need a second place for
    twos (instead of tens). If you go above 3, you need a third place for fours (instead
    of hundreds). Each added digit is a subsequent higher power of two, rather than
    ten.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, where counting in decimal goes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
    13, and so on, counting in binary goes 0, 1, 10, 11, 100, 101, 110, 111, 1000,
    1001, 1010, 1011, 1100, 1101\. For example, the number 13 in decimal is the same
    as 1101 in binary. How? Well, in decimal, we have a 3 in the ones place, plus
    a 1 in the tens place, which has a value of 10\. This is 3 + 10, or 13\. In binary,
    we start with a 1 in the ones place, add a 1 in the fours place (for a value of
    4), plus a 1 in the eights place, for a value of 8\. This is 1 + 4 + 8, or 13.
  prefs: []
  type: TYPE_NORMAL
- en: To take a more complex example, 211 in decimal is 11010011 in binary. [Table 4-2](ch04s02.html#binary_and_decimal_number_equivalents
    "Table 4-2. Binary and Decimal Number Equivalents") shows how the two are equivalent,
    by adding the values for each binary digit place where there is a 1\. Read it
    from left to right, going top to bottom. Starting in the leftmost column, you
    can see that the example number has a 1 in the 128s place. So you start with a
    sum of 128\. In the next column there is a 1 in the 64s place, so you add 64 for
    a running sum of 192\. But in the 32s place, the binary digit value is 0, so you
    don't add 32 to the sum. If you continue down to the ones place, you'll get the
    decimal equivalent of the binary number.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2. Binary and Decimal Number Equivalents
  prefs: []
  type: TYPE_NORMAL
- en: '| Binary Number | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Power of Two | 2⁷ | 2⁶ | 2⁵ | 2⁴ | 2³ | 2² | 2¹ | 2⁰ |'
  prefs: []
  type: TYPE_TB
- en: '| Value of Digit Place | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Value for This Number | 128 | 64 | 0 | 16 | 0 | 0 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Running Sum (from Left to Right) | 128 | 128+64 = 192 | 192 | 192+16 = 208
    | 208 | 208 | 208+2 = 210 | 210+1 = 211 |'
  prefs: []
  type: TYPE_TB
- en: As you can see, a binary number with *N* digits can hold up to 2^(*N*) values.
    So a byte with 8 bits can hold 2⁸, or 256 different values, which are numbered
    from 0 to 255\. A 16-bit word can hold 2^(16), or 65,536 values.
  prefs: []
  type: TYPE_NORMAL
- en: Making Binary Numbers Easier to Use by Grouping Bits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One problem with binary numbers is that although computers love them, people
    have trouble with them because they quickly become long and cumbersome to deal
    with. For example, 1,000,000 in the decimal system is 11110100001001000000 in
    the binary system. To make binary numbers easier to work with, two different shorthand
    notations have been defined. In both of these, instead of working with each bit
    individually, the numbers are collected into subgroups, each of which is assigned
    a single digit in an alternative numbering system.
  prefs: []
  type: TYPE_NORMAL
- en: Octal Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the binary number 11110100, which is 244 in decimal. Instead of looking
    at each bit individually, chop them into groups of three, starting from the right:
    11110100 becomes (11)(110)(100). Each of those groups has three bits, so each
    can have 23 values: from 0 to 7\. In this case, (11)(110)(100) = (3)(6)(4), or
    364 in the *octal* or *base 8* numbering system (see [Figure 4-2](ch04s02.html#binary_octal_and_hexadecimal_number_repr
    "Figure 4-2. Binary, octal, and hexadecimal number representations A binary number
    can be represented in octal form by grouping its bits into sets of three, or in
    hexadecimal by using sets of four bits. These base 8 and base 16 numbers are far
    shorter than binary numbers, and hence much easier to work with.")). As with binary,
    octal numbers are the same as decimal numbers, except that they use base 8 instead
    of base 10\. So 364 in octal is just 3 x 64 + 6 x 8 + 4, or 244\. As you can see,
    octal is a lot less cumbersome than binary, especially when dealing with larger
    numbers. In the decimal system, 1,000,000 is 3641100 in octal. Compare that with
    11110100001001000000 in binary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary, octal, and hexadecimal number representations A binary number can
    be represented in octal form by grouping its bits into sets of three, or in hexadecimal
    by using sets of four bits. These base 8 and base 16 numbers are far shorter than
    binary numbers, and hence much easier to work with.](httpatomoreillycomsourcenostarchimages287699.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. Binary, octal, and hexadecimal number representations A binary number
    can be represented in octal form by grouping its bits into sets of three, or in
    hexadecimal by using sets of four bits. These base 8 and base 16 numbers are far
    shorter than binary numbers, and hence much easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Octal numbers were at one time quite commonly used, but are much less popular
    today. The problem with octal is that it divides bits into groups of three, but
    sets of binary numbers typically use a number of bits that is a multiple of *four*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Hexadecimal* or the *base 16* numbering system is an alternative method that
    works like octal, but uses groups of four. Since there are 4 bits in each group,
    each can have one of 16 values. Hexadecimal is commonly called *hex* for short.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Regular numbers are called *decimal numbers* because they are
    built upon the base 10 system of mathematics. Computers use collections of one
    or zero bits called *binary numbers*, which can be treated just like regular numbers
    except that each digit can only be 0 or 1 instead of 0 to 9\. Bits in a binary
    number can be expressed as *octal numbers* by grouping three bits into an *octal*
    digit that ranges from 0 to 7, or taking sets of four bits to create a single
    *hexadecimal* digit from 0 to 15\. To represent the values 10 through 15 in hexadecimal
    numbers using a single character, you use the letters A through F.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The term* hexadecimal *was not the first name used for base 16 numbers in
    computing. Originally, these were called* sexadecimal *numbers. This is actually
    the correct term, since Latin prefixes* (sexa-) *are normally used for numbers,
    not Greek ones* (hexa-). *However, in the early 1950s, IBM decided that the word*
    sexadecimal *was just a little too provocative for their tastes, so they changed
    it to* hexadecimal. *IBM being IBM—especially back then—meant everyone else followed
    suit*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to the previous example: 11110100 in binary, 244 in decimal. Next
    you divide this into groups of four to get (1111)(0100). The binary value 1111
    is 15, and 0100 is 4, so you have (15)(4). You need to be able to represent 15,
    but you only have ten numerals. To solve this problem, the values 10, 11, 12,
    13, 14, or 15 in hexadecimal are represented by the letters A, B, C, D, E, and
    F, respectively. So 11110100 in binary is (15)(4), or F4 in hexadecimal (also
    shown in [Figure 4-2](ch04s02.html#binary_octal_and_hexadecimal_number_repr "Figure 4-2. Binary,
    octal, and hexadecimal number representations A binary number can be represented
    in octal form by grouping its bits into sets of three, or in hexadecimal by using
    sets of four bits. These base 8 and base 16 numbers are far shorter than binary
    numbers, and hence much easier to work with.")).'
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal numbers are in some ways even less intuitive than binary ones (it
    takes some practice to get used to thinking of letters as numbers). Still, hexadecimal
    is particularly useful as a way to compactly represent binary information. Where
    1,000,000 in decimal numbers is 11110100001001000000 in binary, it is only F4240
    in hexadecimal numbers—even shorter than the decimal number, since 16 is larger
    than 10\. Also, a single byte has 8 bits, so it can be represented using only
    two hexadecimal digits. This is why hexadecimal numbers are widely used in computing
    and networking. For example, you will often see hexadecimal numbers used as network
    addresses or representing different types of information in frame or packet formats.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you see a number that has a letter from A to F in it, you know it is a
    hex number, but not all hex numbers use these letters. Hex numbers are usually
    displayed in a special notation, to avoid confusing them with decimal numbers.
    That notation is either a prefix of* 0x *or a suffix of* h *(sometimes both).
    Thus, the number 54 is just 54, but 0x54 is 54 in hexadecimal numbers, which is
    5 x 16 + 4, or 84 in decimal numbers. Be sure to watch for these representations*.'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal, Binary, Octal, and Hexadecimal Number Conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because people and computers speak different number languages, it is often necessary
    to convert numbers from one system to another. The easiest way to perform the
    conversion is with a scientific calculator. However, there will be cases for which
    you need to perform the conversion by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you don''t have a scientific calculator, the Windows Calculator program
    is a reasonable facsimile. Open it, go to the View menu, and change the setting
    from Standard to Scientific. Click the button next to a numbering system. Then
    enter a number, and if you click a button next to a different numbering type,
    the number will be converted for you. There are similar tools for UNIX and Mac
    OS*.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary, Octal, and Hexadecimal Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To convert between binary, octal, and hex, remember that each octal digit is
    three binary digits, and each hexadecimal digit is four binary digits. To perform
    the conversion, group the digits, and convert each group into an octal or hex
    digit. To convert from hex or octal to binary, convert each hex or octal digit
    into a set of bits. [Table 4-3](ch04s03.html#binary_octal_and_hexadecimal_digit_conve
    "Table 4-3. Binary, Octal, and Hexadecimal Digit Conversion") shows the conversions
    from each of the octal and hexadecimal single-digit values to binary (with decimal
    digits thrown in for convenience).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3. Binary, Octal, and Hexadecimal Digit Conversion
  prefs: []
  type: TYPE_NORMAL
- en: '| Binary Digits | Octal Digit | Hexadecimal Digit | Decimal Digit |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0001 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0010 | 2 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0011 | 3 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0100 | 4 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 0101 | 5 | 5 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 0110 | 6 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 0111 | 7 | 7 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | - | 8 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 1001 | - | 9 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 1010 | - | A | - |'
  prefs: []
  type: TYPE_TB
- en: '| 1011 | - | B | - |'
  prefs: []
  type: TYPE_TB
- en: '| 1100 | - | C | - |'
  prefs: []
  type: TYPE_TB
- en: '| 1101 | - | D | - |'
  prefs: []
  type: TYPE_TB
- en: '| 1110 | - | E | - |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 | - | F | - |'
  prefs: []
  type: TYPE_TB
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary to Octal** Start with the binary number 110101001010\. Divide this
    into groups of three: (110)(101)(001)(010), and then convert each group to a number
    from 0 to 7 (which is easy to do in your head if you practice a bit). The result
    is (6)(5)(1)(2), or 6512 octal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal to Binary** Start with the hex number 0x4D1B. Convert each digit
    as given in [Table 4-3](ch04s03.html#binary_octal_and_hexadecimal_digit_conve
    "Table 4-3. Binary, Octal, and Hexadecimal Digit Conversion"). Now you have 0x4D1B
    = (0100)(1101)(0001)(1011), or 0100110100011011.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversion from Binary, Octal, or Hexadecimal to Decimal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conversions to and from decimal are more complicated, because 2, 8, and 16
    are powers of two but ten is not. Of the two directions, conversions *to* decimal
    are easier: You take the value of each binary, octal, or hexadecimal digit, convert
    it to decimal, and then multiply it by the power of 2, 8, or 16 represented by
    the digit''s place in the number. Then you add all the numbers together. I did
    this with the example of the decimal number 211 (see [Table 4-2](ch04s02.html#binary_and_decimal_number_equivalents
    "Table 4-2. Binary and Decimal Number Equivalents")).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-4](ch04s03.html#hexadecimal_to_decimal_number_conversion "Table 4-4. Hexadecimal
    to Decimal Number Conversion") shows the hexadecimal number 0x830C converted to
    decimal (octal uses a similar process). Read the table from left to right, top
    to bottom; each digit''s value is multiplied by the appropriate power of 16 and
    added together, yielding the decimal result of 33,548.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4. Hexadecimal to Decimal Number Conversion
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hexadecimal Number** | **8** | **3** | **0** | **C** |'
  prefs: []
  type: TYPE_TB
- en: '| **Decimal Value of Digit** | 8 | 3 | 0 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| **Power of 16** | 16³ | 16² | 16¹ | 16⁰ |'
  prefs: []
  type: TYPE_TB
- en: '| **Value of Digit Place** | 4096 | 256 | 16 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Value for This Number** | 8 x 4096 = 32768 | 3 x 256 = 768 | 0 x 16 = 0
    | 12 x 1 = 12 |'
  prefs: []
  type: TYPE_TB
- en: '| **Running Sum (from left to right)** | 32768 | 32768+768 = 33536 | 33536
    | 33536+12 = 33548 |'
  prefs: []
  type: TYPE_TB
- en: Conversion from Decimal to Binary, Octal, or Hexadecimal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conversions *from* decimal requires you to perform the opposite of the previous
    calculation: You divide and subtract instead of multiply and add.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversion from Decimal to Binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest of the three conversions from decimal is to binary. Because the
    maximum value of each digit is 1, there is no dividing, just subtraction. To perform
    the conversion, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the largest power of two that is smaller than the number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a 1 in the digit place for that power of two and subtract that power of
    two from the decimal number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 and 2 until you are reduced to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is easier to explain using an example and a table. Let's convert the decimal
    number 689, as shown in [Table 4-5](ch04s03.html#decimal_to_binary_number_conversion
    "Table 4-5. Decimal to Binary Number Conversion"). Again, read the table starting
    from the upper left, and going down and then across. You start by noticing that
    1024 is not less than or equal to 689, so the 1024s place gets a 0\. In the next
    place, 512 is less than 689, so you make the 512s place a 1 and subtract 512 from
    689 to leave 177\. The calculation continues, before it eventually shows that
    the 689 decimal is 1010110001 binary.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-5. Decimal to Binary Number Conversion
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal Value Before Considering This Digit Place | 689 | 689 | 177 | 177
    | 49 | 49 | 17 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Power of Two | 2^(10) | 2⁹ | 2⁸ | 2⁷ | 2⁶ | 2⁵ | 2⁴ | 2³ | 2² | 2¹ | 2⁰ |'
  prefs: []
  type: TYPE_TB
- en: '| Value of Digit Place | 1024 | 512 | 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2
    | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Value of Digit Place Equal to or Less Than Current Decimal Number? | No |
    Yes | No | Yes | No | Yes | Yes | No | No | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction Step | Skip | 689 - 512 = 177 | Skip | 177 - 128 = 49 | Skip
    | 49 - 32 = 17 | 17 - 16 = 1 | Skip | Skip | Skip | 1 - 1 = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Binary Digits | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Conversion from Decimal to Octal or Hexadecimal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process for octal and hexadecimal is almost the same, except that you must
    divide by powers of two instead of just subtracting, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the highest power of 16 (hexadecimal) or 8 (octal) that is smaller
    than the number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide the decimal number by that power, keeping only the integer part of the
    result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the remainder after the division is done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 through 3 until you get to the ones place, and then enter whatever
    is left after the higher digits were done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Table 4-6](ch04s03.html#decimal_to_hexadecimal_number_conversion "Table 4-6. Decimal
    to Hexadecimal Number Conversion") shows the same example as [Table 4-5](ch04s03.html#decimal_to_binary_number_conversion
    "Table 4-5. Decimal to Binary Number Conversion"), but goes from decimal to hexadecimal
    instead of decimal to binary: 689 in decimal is 0x2B1 in hexadecimal.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-6. Decimal to Hexadecimal Number Conversion
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal Value Before Considering This Digit Place | 689 | 689 | 177 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Power of 16 | 16³ | 16² | 16¹ | 16⁰ |'
  prefs: []
  type: TYPE_TB
- en: '| Value of Digit Place | 4096 | 256 | 16 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Value of Digit Place Smaller Than Current Decimal Number? | No | Yes | No
    | n/a |'
  prefs: []
  type: TYPE_TB
- en: '| Division Step | Skip | 689/256 = 2.691 (use 2 for this digit) | 177/16 =
    11.0625 (use B for this digit) | n/a |'
  prefs: []
  type: TYPE_TB
- en: '| Remainder After Division | Skip | 177 | 1 | n/a |'
  prefs: []
  type: TYPE_TB
- en: '| Hexadecimal Digits | 0 | 2 | B | 1 |'
  prefs: []
  type: TYPE_TB
- en: Binary, Octal, and Hexadecimal Arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use arithmetic every day to give us the information we need to make decisions.
    Like us, computers perform arithmetic operations constantly as part of their normal
    operation, except that computers use binary numbers to perform their calculations
    incredibly fast.
  prefs: []
  type: TYPE_NORMAL
- en: Binary, octal, and hexadecimal numbers are essentially different representations
    of numbers, and as such they are not really much different than decimal numbers;
    they simply have a different number of values per digit. In a similar vein, doing
    arithmetic with binary, octal, or hexadecimal numbers is not that different from
    the equivalent operations with decimal numbers. You just have to keep in mind
    that you are working with powers of 2, 8, or 16, instead of 10, which isn't always
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: As with number system conversions, calculators are usually the way to go if
    you need to do math with binary, octal, or hexadecimal numbers. If your calculator
    does math with only decimal numbers, you can use the trick of converting the numbers
    to decimal, and then performing the operation and converting the result. However,
    you can fairly easily do the same addition, subtraction, multiplication, and division
    on binary, octal, or hexadecimal numbers that you would with decimal numbers by
    using the Windows Calculator program.
  prefs: []
  type: TYPE_NORMAL
- en: Computers often need to perform multiplication and division operations on binary
    numbers, but people working with computers don't often perform these operations.
    Addition and subtraction are much more common operations (especially addition),
    and they have the added bonus of being much easier to explain. You probably won't
    need to do this type of arithmetic that often, but it's good to understand it.
    I'll provide a couple of examples to give you the general idea.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with binary. Adding binary numbers is the same as adding decimal
    ones, except that you end up doing *a lot* of the carrying of ones since there
    are so few values allowed per digit. [Table 4-7](ch04s04.html#binary_addition
    "Table 4-7. Binary Addition") shows an example, with one digit in each column;
    read it from right to left and top to bottom, just as you would usually do with
    a manual addition. You start by adding the 1 in the ones place from the first
    number with the 1 in that place from the second number, thereby yielding a raw
    digit sum of 2\. This means the result for the ones digit is 1, and you carry
    a 1 to the twos place. You continue with this process until you have added all
    the digits.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-7. Binary Addition
  prefs: []
  type: TYPE_NORMAL
- en: '| Carry |   | 1 | 1 |   |   | 1 | 1 | — |'
  prefs: []
  type: TYPE_TB
- en: '| First Binary Number | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Second Binary Number | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Raw Digit Sum | 1 | 1 | 3 | 2 | 1 | 1 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Result | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Carry to Next Higher Digit |   |   | 1 | 1 |   |   | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Octal and Hexadecimal Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Octal and hexadecimal are pretty much the same, except that you carry the number
    if the sum in a particular digit exceeds either 8 or 16, respectively. Hexadecimal
    is more common, and more interesting, so let's examine how to add two hexadecimal
    numbers. While performing the operation, you will need to convert single-digit
    hexadecimal numbers to decimal and back again, but this isn't too difficult.
  prefs: []
  type: TYPE_NORMAL
- en: The example shown in [Table 4-8](ch04s04.html#hexadecimal_addition "Table 4-8. Hexadecimal
    Addition") should be read from right to left. You start by adding 8 (decimal 8)
    to A (decimal 10) in the ones place. This yields a raw sum of 18, from which you
    carry 16 as a 1 to the 16s place and leave a result of 2\. You add this 1 to the
    D (value 13) and E (14 value) of the 16s place. This is a total of 28, leaving
    12 (C in hexadecimal), and you carry a 1 to the 256s place. This continues until
    you are left with a sum of 6DC2h.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-8. Hexadecimal Addition
  prefs: []
  type: TYPE_NORMAL
- en: '| Carry |   | 1 | 1 |   |'
  prefs: []
  type: TYPE_TB
- en: '| First Hex Number | 2 | C | D | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Second Hex Number | 4 | 0 | E | A |'
  prefs: []
  type: TYPE_TB
- en: '| Raw Digit Sum | 2+4 = 6 | 1+12+0 = 13 | 1+13+14 = 28 | 8+10 = 18 |'
  prefs: []
  type: TYPE_TB
- en: '| Result | 6 | D | C | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Carry to Next Higher Digit |   |   | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Boolean Logic and Logical Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll recall that every bit in a computer system can hold a value of either
    1 or 0, representing the basic on or off states inherent in a binary digital system,
    and that you can interpret these on or off values as true or false states, respectively.
    These values can represent various logical conditions within a system, and you
    can use various logical operations to manipulate and combine these values to represent
    more complex logical states.
  prefs: []
  type: TYPE_NORMAL
- en: British mathematician George Boole (1815–1864) was one of the pioneering users
    of binary values in logical equations, and in recognition of his contribution
    we call this *boolean logic*.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Logical Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boolean logic defines a number of *boolean logical functions*, which are sometimes
    called *operators*. Each of these functions uses a logical algorithm to compute
    an output value based on the value of one or more inputs. The algorithm determines
    when the output is true, based on the combination of true and false values the
    inputs take. Thus, the table that shows the inputs and outputs for a logical function
    is called a *truth table*. Each of the logical functions is analogous to a real-world
    logical operation that you can use to define various logical situations (as you
    will soon see).
  prefs: []
  type: TYPE_NORMAL
- en: NOT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the simplest function: *NOT*. As you might expect, this is a just
    a negation; the output is the opposite of the input. The NOT function takes only
    one input, so it is called a *unary* function or operator. The truth table for
    NOT is shown in [Table 4-9](ch04s05.html#not_operator_truth_table "Table 4-9. NOT
    Operator Truth Table"). As you can see, the output is true when the input is false,
    and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-9. NOT Operator Truth Table
  prefs: []
  type: TYPE_NORMAL
- en: '| Input | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| False | True |'
  prefs: []
  type: TYPE_TB
- en: '| True | False |'
  prefs: []
  type: TYPE_TB
- en: 'The NOT function logically represents the opposite of a condition. For example,
    suppose you have a bit called B1 whose logical meaning is that when the bit is
    true, a particular pixel on a screen is lit up. Then the *boolean expression*
    NOT B1 would be the opposite: It would be false when the pixel is lit up, and
    thus true only when the pixel is *not* lit up.'
  prefs: []
  type: TYPE_NORMAL
- en: Since true and false values are represented in computers by 1 or 0 values, boolean
    logic is often expressed in terms of ones and zeros, instead of true and false.
    The circuits inside computer processors and other devices manipulate one and zero
    bits directly using these functions. In some (but not all) cases, they interpret
    one and zero as true and false, but in either case, the two representations are
    functionally equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-10](ch04s05.html#not_operator_truth_table_using_bit_value "Table 4-10. NOT
    Operator Truth Table (Using Bit Values)") shows the same truth table as [Table 4-9](ch04s05.html#not_operator_truth_table
    "Table 4-9. NOT Operator Truth Table"), but using bit values. Each true is represented
    as a 1, and each false is represented as a 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-10. NOT Operator Truth Table (Using Bit Values)
  prefs: []
  type: TYPE_NORMAL
- en: '| Input | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: AND and OR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The two other primary boolean functions that are widely used are *AND* and *OR*.
    The output of an AND function is true only if its first, and second, and third
    inputs and so on are true. The output of an OR function is true if the first input
    is true *or* the second input is true, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Both AND and OR can have any number of inputs, with a minimum of two. [Table 4-11](ch04s05.html#and_operator_truth_table
    "Table 4-11. AND Operator Truth Table") shows the truth table for the AND function,
    with two inputs. You can see that the output is a 1 only when both inputs are
    1, but it's 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-11. AND Operator Truth Table
  prefs: []
  type: TYPE_NORMAL
- en: '| Input 1 | Input 2 | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Like NOT, AND represents a logical operation similar to how we use the word
    *and* in our everyday speech. For example, at lunchtime, I might say to a colleague,
    "Let's go out for lunch *and* stop at the post office."
  prefs: []
  type: TYPE_NORMAL
- en: The truth table for the OR function (again with two inputs) is shown in [Table 4-12](ch04s05.html#or_operator_truth_table
    "Table 4-12. OR Operator Truth Table"). Here, the output is 1 whenever a 1 appears
    in at least one input, not necessarily both as in the previous table.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-12. OR Operator Truth Table
  prefs: []
  type: TYPE_NORMAL
- en: '| Input 1 | Input 2 | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Interestingly, unlike AND, the OR function does *not* have the same meaning
    as what we take the word *or* to mean in everyday English. In boolean, the word
    OR means that the output is true as long as *any* of the inputs is true.
  prefs: []
  type: TYPE_NORMAL
- en: Exclusive-OR (XOR or EOR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A modification of OR called *Exclusive-OR* (abbreviated either *XOR* or *EOR*)
    represents the way we normally use *or* in the real world. Its output is only
    true if one input or the other is true, but *not both*. The truth table for XOR
    is as shown in [Table 4-13](ch04s05.html#exclusive_or_xor_operator_truth_table
    "Table 4-13. Exclusive OR (XOR) Operator Truth Table"). Notice the difference
    between this table and [Table 4-12](ch04s05.html#or_operator_truth_table "Table 4-12. OR
    Operator Truth Table"): The output is 0 in the case where both inputs are 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-13. Exclusive OR (XOR) Operator Truth Table
  prefs: []
  type: TYPE_NORMAL
- en: '| Input 1 | Input 2 | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Combining Boolean Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions described earlier can also be combined arbitrarily to produce
    more complex logical conditions. For example, when searching the Web, you might
    enter "cheese AND (cheddar OR swiss) NOT wisconsin" into a search engine. In response,
    the search engine might return pages that contain the word *cheese* and the word
    *cheddar* or *swiss* (or both), but pages that do *not* contain the word *wisconsin*.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean functions are important because they are the building blocks of much
    of the circuitry within computer hardware. The functions are implemented as tiny
    *gates* that are designed to allow electrical energy to flow only to the output
    based on certain combinations of inputs as described by the truth tables for functions
    like NOT, AND, OR, and others. In networking, boolean logic is important for describing
    certain conditions and functions in the operation of networks. Boolean functions
    are also very important because they are used to set, clear, and mask strings
    of binary digits, which I will explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *Boolean logic* is a system that uses boolean functions to
    produce output based on varying conditions in input data. The most common boolean
    functions are as follows: *NOT*, which produces output that is the opposite of
    its input; *AND*, which is true only if all of its inputs are true; *OR*, which
    is true if any of its input is true; and *XOR*, which is true only if exactly
    one of its inputs is true (that is, if the inputs are different). These functions
    can be used in boolean logic expressions that represent conditional states for
    making decisions, and they can also be used for bit manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Bit Masking (Setting, Clearing, and Inverting) Using Boolean Logical Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The boolean functions NOT, AND, OR, and XOR describe different ways that logical
    expressions can be used to manipulate true and false values to represent both
    simple and complex decisions or conditions. However, these functions can also
    be used in a more mundane manner to allow the direct manipulation of binary data.
    This use of boolean logic is very important in a number of different applications
    in networking.
  prefs: []
  type: TYPE_NORMAL
- en: You should recall that when you give a bit a value you *set* the bit, and when
    you give it a value of 0, you *reset* or *clear* it. In some situations bits are
    handled individually and are set or cleared simply by assigning a 0 or 1 value
    to each bit. However, it is common to have large groups of bits that are used
    collectively to represent a great deal of information, whenever many bits need
    to be set or cleared at once. In this situation, the boolean functions come to
    the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Groups of Bits with OR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can set bits en masse with the OR function. Recall that an OR's output is
    true (equal to 1) if any of its inputs are true (equal to 1). Thus, if you OR
    a bit with a value known to be 1, the result will always be 1, no matter what
    the other value is. In contrast, if you OR with a 0, the original value, 1 or
    0, is not changed.
  prefs: []
  type: TYPE_NORMAL
- en: By using a string with 0s and 1s in particular spots, you can set certain bits
    to 1 while leaving others unchanged. This procedure is comparable to how a painter
    *masks* areas that he does not want to be painted, using plastic or perhaps masking
    tape. Thus, the process is called *masking*. The string of digits used in the
    operation is called the *bit mask*, or simply the *mask*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have the 12-bit binary input number 101001011010,
    and you want to set the middle six bits to be all ones. To do this, you OR the
    number with the 12-bit mask 000111111000\. [Table 4-14](ch04s06.html#setting_bits_using_an_or_bit_mask
    "Table 4-14. Setting Bits Using an OR Bit Mask") shows how this works with the
    changed bits in the result in bold—you simply OR each bit in the input with its
    corresponding bit in the mask:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-14. Setting Bits Using an OR Bit Mask
  prefs: []
  type: TYPE_NORMAL
- en: '| Input | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Mask | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Result of OR Operation | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Clearing Bits with AND
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To clear a certain pattern of bits, you perform a similar masking operation,
    but using the AND function instead. If you AND a bit with 0, it will clear it
    to 0, regardless of what the bit was before, while ANDing with 1 will leave the
    bit unchanged. For example, to clear the middle six bits in [Table 4-14](ch04s06.html#setting_bits_using_an_or_bit_mask
    "Table 4-14. Setting Bits Using an OR Bit Mask"), you AND with the reverse bit
    mask, 111000000111.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-15](ch04s06.html#clearing_bits_using_an_and_bit_mask "Table 4-15. Clearing
    Bits Using an AND Bit Mask") and [Figure 4-3](ch04s06.html#clearing_bits_using_an_and_bit_mask_appl
    "Figure 4-3. Clearing Bits Using an AND Bit Mask Applying a bit mask to an input
    binary number using the AND function clears to 0 all bits where the mask bit was
    0 and leaves alone bits where the mask was 1.") show how a bit mask can be used
    to clear certain bits in a binary number while preserving others. Each 1 represents
    a "transparent" area that keeps the corresponding input bit value, while each
    0 is a bit where the original value is to be cleared. After performing an AND
    on each bit pair, the first three and last three bits are preserved, while the
    middle six, since they were each ANDed with 0, are forced to 0 in the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clearing Bits Using an AND Bit Mask Applying a bit mask to an input binary
    number using the AND function clears to 0 all bits where the mask bit was 0 and
    leaves alone bits where the mask was 1.](httpatomoreillycomsourcenostarchimages287701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. Clearing Bits Using an AND Bit Mask Applying a bit mask to an input
    binary number using the AND function clears to 0 all bits where the mask bit was
    0 and leaves alone bits where the mask was 1.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-15. Clearing Bits Using an AND Bit Mask
  prefs: []
  type: TYPE_NORMAL
- en: '| Input | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Mask | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Result of AND Operation | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: You can also look at this clearing function a different way. You are clearing
    the bits where the mask is a 0, and in so doing selecting the bits where the mask
    is a 1\. Thus, ANDing with a bit mask essentially means that you keep the bits
    where the mask is a 1 and remove the bits where it is a 0.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting Bits with XOR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also situations in which you want to *invert* some bits; that is,
    change a 1 value to a 0, or a 0 value to a 1\. To do this, you use the XOR function.
    While this is not as intuitive as masking, if you refer to the XOR truth table
    ([Table 4-13](ch04s05.html#exclusive_or_xor_operator_truth_table "Table 4-13. Exclusive
    OR (XOR) Operator Truth Table")) you will see that if you XOR with a 1, the input
    value is flipped, while XORing with a 0 causes the input to be unchanged. To see
    how this works, use the same input example and invert the middle six bits, as
    shown in [Table 4-16](ch04s06.html#inverting_bits_using_an_xor_bit_mask "Table 4-16. Inverting
    Bits Using an XOR Bit Mask").
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-16. Inverting Bits Using an XOR Bit Mask
  prefs: []
  type: TYPE_NORMAL
- en: '| Input | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Mask | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Result of XOR Operation | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: In the world of networking, bit masking is most commonly used to manipulate
    addresses. In particular, masking is perhaps best known for its use in differentiating
    between the host and subnetwork (subnet) portions of Internet Protocol (IP) addresses,
    a process called *subnet masking* (see [Chapter 18](ch18.html "Chapter 18. IP
    SUBNET ADDRESSING (SUBNETTING) CONCEPTS"), which discusses IP subnet addressing).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Masks are often expressed in either hexadecimal or decimal notation for simplicity,
    as shown in the IP subnetting summary tables in [Chapter 18](ch18.html "Chapter 18. IP
    SUBNET ADDRESSING (SUBNETTING) CONCEPTS"). However, the masks are always applied
    in binary, as described previously. You should convert the mask to binary if you
    want to see exactly how the masking operation will work*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The properties of the *OR* and *AND* boolean functions make
    them useful when certain bits of a data item need to be set (changed to 1) or
    cleared (changed to 0). This process is called *bit masking*. To set bits to 1,
    a mask is created and used in a bit-by-bit OR function with the input. When the
    mask has a value of 1, the bit is forced to a 1, while each 0 bit leaves the corresponding
    original bit unchanged. Similarly, a mask used with the AND function clears certain
    bits; each 1 bit in the mask leaves the original bit alone, while each 0 forces
    the output to 0\. Finally, *XOR* can be used to invert selected bits using a mask.'
  prefs: []
  type: TYPE_NORMAL
