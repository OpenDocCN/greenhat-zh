<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Using, Optimizing, and Testing Functional Techniques"><div class="titlepage"><div><div><h1 class="title"><a id="using_optimizing_and_testing_functional_"/>Chapter 7. Using, Optimizing, and Testing Functional Techniques</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e11108"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages686190.png.jpg"/></div></div><p>This chapter shows some recursive and other functional solutions to simple problems, as well as some ways we can test and improve these solutions. Two very common programming topics that demonstrate functional programming are the factorial and Fibonacci mathematical series—largely because they’re so easily described using recursive means.<sup>[<a class="footnote" href="#ftn.CHP-7-FNOTE-1" id="CHP-7-FNOTE-1">20</a>]</sup></p><p>The <span class="emphasis"><em>factorial</em></span> of a given positive number is the product of all the integers from 1 to that number, so factorial(3) = 3 x 2 x 1, factorial(5) = 5 x 4 x 3 x 2 x 1, and so on. This can be expressed generally as:</p><div class="blockquote"><blockquote class="blockquote"><p>factorial(<span class="emphasis"><em>x</em></span>) = <span class="emphasis"><em>x</em></span> x (<span class="emphasis"><em>x</em></span> – 1) x (<span class="emphasis"><em>x</em></span> – 2) … 1</p></blockquote></div><p>The <a class="indexterm" id="idx-CHP-7-0687"/>Fibonacci series is infinite, but you can look at a slice of it. The <span class="emphasis"><em>Fibonacci</em></span> value for 0 is 0, and the value for 1 is 1. Subsequent values are calculated, rather than preset. The number in the Fibonacci series at a given index is the sum of the previous two numbers. Therefore, the Fibonacci series starts like this: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on. The formula for <a class="indexterm" id="idx-CHP-7-0688"/>Fibonacci values for numbers greater than one can be expressed generally as Fibonacci(<span class="emphasis"><em>x</em></span>) = Fibonacci(<span class="emphasis"><em>x</em></span>-1) + Fibonacci(<span class="emphasis"><em>x</em></span>-2).</p><p>If you think that the general definitions of both <a class="indexterm" id="idx-CHP-7-0689"/>factorials and Fibonaccis look recursive, you’re right. We’ll look at Ruby <a class="indexterm" id="idx-CHP-7-0690"/>code that generates both types of numbers using recursion.</p><div class="sect1" title="#26 Basic Factorials and Fibonaccis (factorial1.rb through fibonacci5.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp26_basic_factorials_and_fibonaccis_"/>#26 Basic Factorials and Fibonaccis (factorial1.rb through fibonacci5.rb)</h1></div></div></div><p>The most common criticism of recursion and other functional techniques is that they are resource intensive. Each new version of these factorial or Fibonacci scripts adds some feature intended to <span class="emphasis"><em>optimize</em></span> the code, or produce a speed improvement. In some cases, these features result in a very dramatic improvement, but in other cases, they either fail to improve the code or sometimes even make it worse. The places where these attempts fail to improve speed are often as interesting as where they succeed. There’s an old adage among programmers: <span class="emphasis"><em>Premature optimization is the root of all evil</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-7-FNOTE-2" id="CHP-7-FNOTE-2">21</a>]</sup> Keep that in mind while reading these examples.</p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id025"/>The Code</h2></div></div></div><p>For this chapter, we’ll be looking at some short scripts in pairs. Here’s <code class="literal">factorial1.rb</code>:<a class="indexterm" id="idx-CHP-7-0694"/></p><a id="I_programlisting7_d1e11222"/><pre class="programlisting">  #!/usr/bin/env ruby
  # factorial1.rb

  class Integer

    def fact()
❶     return 1 if (self.zero?) or (self == 1)
❷     return self * (self-1).fact
    end

  end</pre><p>And here’s <code class="literal">fibonacci1.rb</code>:<a class="indexterm" id="idx-CHP-7-0695"/></p><a id="I_programlisting7_d1e11232"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0696"/>fibonacci1.rb

  class Integer

    def fib()
❸     return 0 if (self.zero?)
      return 1 if self == 1
❹     return (self-1).fib + (self-2).fib
    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id024"/>How It Works</h2></div></div></div><p>For <code class="literal">factorial1.rb</code> and <code class="literal">fibonacci1.rb</code>, we add a new method to all Integers: either <code class="literal">fact</code> or <code class="literal">fib</code>, respectively. In both cases, we have our exit conditions that <code class="literal">return</code> either zero or one. For <a class="indexterm" id="idx-CHP-7-0697"/>factorials, we <code class="literal">return 1</code> when <code class="literal">self</code> is either <code class="literal">0</code> or <code class="literal">1</code>, testing for <code class="literal">0</code> with the predicate <code class="literal">zero?</code> (❶). For the <a class="indexterm" id="idx-CHP-7-0698"/>Fibonacci series, we <code class="literal">return</code> either zero or one at ❸. At either ❷ or ❹, we <code class="literal">return</code> the appropriate calculated value: <code class="literal">self</code> times the factorial of one lower than <code class="literal">self</code> (❷), or the sum of the previous two Fibonaccis (❹), matching the definitions I gave <a class="indexterm" id="idx-CHP-7-0699"/>for factorials and Fibonaccis, respectively. Both of these scripts are simple, accurate ways to produce the mathematical procedures we want. Let’s look at the results using irb. Note that we can require more than one library file with multiple <code class="literal">-r</code> flags.<sup>[<a class="footnote" href="#ftn.CHP-7-FNOTE-3" id="CHP-7-FNOTE-3">22</a>]</sup></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id022"/>The Results</h2></div></div></div><a id="I_programlisting7_d1e11319"/><pre class="programlisting">$ irb -r <a class="indexterm" id="idx-CHP-7-0701"/>factorial1.rb -r <a class="indexterm" id="idx-CHP-7-0702"/>fibonacci1.rb
irb(main):001:0&gt; 3.fact
=&gt; 6
irb(main):002:0&gt; 4.fact
=&gt; 24
irb(main):003:0&gt; 5.fact
=&gt; 120</pre><p>The factorial of 3 is 3 x 2 x 1, which is 6, so that’s fine. 6 x 4 is 24, and 24 x 5 is 120. So our fact method seems to work well. On to the fibonacci series.</p><a id="I_programlisting7_d1e11335"/><pre class="programlisting">irb(main):004:0&gt; 3.fib
=&gt; 2
irb(main):005:0&gt; 4.fib
=&gt; 3
irb(main):006:0&gt; 5.fib
=&gt; 5</pre><p>The first seven values in the Fibonacci series are 0, 1, 1, 2, 3, 5, and 8. The <span class="emphasis"><em>zeroth</em></span> number (the number at the 0 index) is 0, the first is 1, the second is also 1, the third is 2, the fourth is 3, and the fifth is 5. Our <code class="literal">fib</code> method also seems to work well.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id014"/>Hacking the Script</h2></div></div></div><p>How could we improve the speed of this <a class="indexterm" id="idx-CHP-7-0703"/>script? We have several options. I’ll outline each of them in turn and discuss the possible motivations for each change, but we’ll wait to test them (and therefore, to see the results of our assumptions) until the end.<a class="indexterm" id="idx-CHP-7-0704"/></p><div class="note" title="Note"><h3 class="title"><a id="note-42"/>Note</h3><p><span class="emphasis"><em>Modifying a computer program to improve it without changing its external behavior is called</em></span> <a class="indexterm" id="idx-CHP-7-0705"/>refactoring. <span class="emphasis"><em>That’s what we’re doing with these scripts, because we’re not changing the factorial or Fibonacci values for a given input—we’re just changing how (and possibly how quickly) we return the same value. Refactoring is a fascinating topic; you can read more about it at <a class="ulink" href="http://refactoring.com">http://refactoring.com</a> or in Martin Fowler’s</em></span> <a class="indexterm" id="idx-CHP-7-0706"/>Refactoring: Improving the Design of Existing Code <span class="emphasis"><em>(Addison-Wesley Professional, 1999). Unit testing, which we’ll describe later in this chapter, is a critical tool to use when refactoring, as I’ll explain in that section</em></span>.<a class="indexterm" id="idx-CHP-7-0707"/><a class="indexterm" id="idx-CHP-7-0708"/></p></div><div class="sect3" title="Using include? (factorial2.rb and fibonacci2.rb)"><div class="titlepage"><div><div><h3 class="title"><a id="using_include_factorial2rb_and_fibonacci"/>Using include? (factorial2.rb and fibonacci2.rb)</h3></div></div></div><p>Here’s a variant that decides what to <code class="literal">return</code> via the <code class="literal">include?</code> method, which eliminates the need to run two separate tests to find out whether <code class="literal">self</code> is either zero or one. The motivation is that it could be faster to do a single test instead of two separate tests. Again, I’ll show the alterations for both the factorial and Fibonacci scripts. Notice how both ❺ lines differ from either ❶ or ❸ in the initial scripts.<a class="indexterm" id="idx-CHP-7-0709"/><a class="indexterm" id="idx-CHP-7-0710"/><a class="indexterm" id="idx-CHP-7-0711"/></p><a id="I_programlisting7_d1e11408"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0712"/>factorial2.rb

  class Integer

    def fact()
❺     return 1 if [0, 1].include?(self)
      return self * (self-1).fact
    end

  end</pre><p>Here’s the Fibonacci script:<a class="indexterm" id="I_indexterm7_d1e11418"/><a class="indexterm" id="I_indexterm7_d1e11421"/><a class="indexterm" id="I_indexterm7_d1e11424"/><a class="indexterm" id="I_indexterm7_d1e11429"/></p><a id="I_programlisting7_d1e11434"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0713"/>fibonacci2.rb

  class Integer

    def fib()
❺     return self if [0, 1].include?(self)
      return (self-1).fib + (self-2).fib
    end

  end</pre></div><div class="sect3" title="Passing the returns1 or returns_self Array as an Argument (factorial3.rb and fibonacci3.rb)"><div class="titlepage"><div><div><h3 class="title"><a id="passing_the_returns1_or_returns_self_arr"/>Passing the returns1 or returns_self Array as an Argument (factorial3.rb and fibonacci3.rb)</h3></div></div></div><p>In these variants we have an Array called either <code class="literal">returns1</code> or <code class="literal">returns_self</code> that defines the <a class="indexterm" id="idx-CHP-7-0714"/>return values for either a factorial or Fibonacci test. The Array is <code class="literal">[0, 1]</code> in both cases, because zero and one are the values we use in our rules to calculate other values in both tests. The motivation for this variant is the thought that it might be faster to create a data structure (such as <code class="literal">returns1</code>) once and pass it around, rather than re-creating our <code class="literal">[0, 1]</code> Array every time we make a new recursive call to either <code class="literal">fact()</code> or <code class="literal">fib()</code>. Notice how we define <code class="literal">returns1</code> or <code class="literal">returns_self</code> as an argument to each of our methods at ❻ in each script and then use it subsequently for both our exit conditions testing and as an explicit argument to the recursive calls (❼).<a class="indexterm" id="idx-CHP-7-0715"/><a class="indexterm" id="idx-CHP-7-0716"/></p><a id="I_programlisting7_d1e11488"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0717"/>factorial3.rb

  class Integer

❻   def fact(returns1 = [0, 1])
      return 1 if returns1.include?(self)
❼     return self * (self-1).fact(returns1)
    end

  end</pre><p>Here is the Fibonacci version:</p><a id="I_programlisting7_d1e11498"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0718"/>fibonacci3.rb

  class Integer

❻   def fib(returns_self = [0, 1])
      return self if returns_self.include?(self)
❼     return (self-1).fib(returns_self) + (self-2).fib(returns_self)
    end

  end</pre></div><div class="sect3" title="Making RETURNS1 or RETURNS_SELF a Class Constant (factorial4.rb and fibonacci4.rb)"><div class="titlepage"><div><div><h3 class="title"><a id="making_returns1_or_returns_self_a_class_"/>Making RETURNS1 or RETURNS_SELF a Class Constant (factorial4.rb and fibonacci4.rb)</h3></div></div></div><p>Making <code class="literal">returns1</code> or <code class="literal">returns_self</code> an argument seems silly for one reason: It’s always the same value, <code class="literal">[0, 1]</code>. Things that don’t change are ideal <a class="indexterm" id="idx-CHP-7-0719"/>constants, so let’s try that for both scripts. We’ll define a constant with an appropriate name at ❽ in each script and then use it in our method’s tests. Note that there is no longer any need to pass the constant as an argument to the recursive method calls, as we did in the previous variant at ❼.<a class="indexterm" id="idx-CHP-7-0720"/><a class="indexterm" id="idx-CHP-7-0721"/></p><a id="I_programlisting7_d1e11528"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0722"/>factorial4.rb

  class Integer

❽   RETURNS_1_FOR_FACTORIAL = [0, 1]

    def fact()
      return 1 if RETURNS_1_FOR_FACTORIAL.include?(self)
      return self * (self-1).fact
    end

  end</pre><p>Here is the <a class="indexterm" id="idx-CHP-7-0723"/>Fibonacci version:</p><a id="I_programlisting7_d1e11540"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0724"/>fibonacci4.rb

  class Integer

❽   RETURNS_SELF = [0, 1]

    def fib()
      return self if RETURNS_SELF.include?(self)
      return (self-1).fib() + (self-2).fib()
    end

  end</pre></div><div class="sect3" title="Memoization of Results (factorial5.rb and fibonacci5.rb)"><div class="titlepage"><div><div><h3 class="title"><a id="memoization_of_results_factorial5rb_and_"/>Memoization of Results (factorial5.rb and fibonacci5.rb)</h3></div></div></div><p>One unexamined flaw in our scripts so far is that they’re stupid. It sounds harsh, but it’s fair.<sup>[<a class="footnote" href="#ftn.CHP-7-FNOTE-4" id="CHP-7-FNOTE-4">23</a>]</sup> They keep repeating the same calculations over and over again. For the sake of example, let’s assume that we’ve called the <code class="literal">fib()</code> method on the Integer <code class="literal">5</code>, and <code class="literal">fib()</code> is as defined in <code class="literal">fibonacci4.rb</code>, our most recent Fibonacci script variant. What happens?<a class="indexterm" id="idx-CHP-7-0728"/></p><p>The first thing of interest is that whenever our <code class="literal">5</code> is instantiated, it has a class constant called <code class="literal">RETURNS_SELF</code>, defined as an Array: <code class="literal">[0, 1]</code>. Next we call <code class="literal">fib()</code> on our <code class="literal">5. RETURNS_SELF</code> does not <code class="literal">include? 5</code>, so we then call <code class="literal">fib()</code> on the expression <code class="literal">(5-1)</code>, which is of course the Integer <code class="literal">4</code>, and add its returned value to the result of calling <code class="literal">fib()</code> on the value <code class="literal">(5-2)</code>, also known as the Integer <code class="literal">3</code>. We then find that <code class="literal">RETURNS_SELF</code> does not <code class="literal">include? 4</code>, either, so we then call <code class="literal">fib()</code> on the expressions <code class="literal">(4-1)</code>, which is the Integer <code class="literal">3</code>, and add its returned value to the result of calling <code class="literal">fib()</code> on the value <code class="literal">(4-2)</code>, also known as the Integer <code class="literal">2</code>. We keep doing this recursively until we get a value of <code class="literal">self</code> that is found within the <code class="literal">RETURNS_SELF</code> Array.</p><p>The main problem with doing this is that we keep re-calculating methods like <code class="literal">3.fib()</code>. We had to calculate it in the guise of <code class="literal">(self-2).fib()</code> in our initial call to <code class="literal">5.fib()</code>, and we had to calculate it in the guise of <code class="literal">(self-1).fib()</code> when our value for <code class="literal">self</code> was <code class="literal">4</code>. The reason all this recalculation is a problem is that <code class="literal">3.fib()</code> gives the same result, whether it is called as <code class="literal">(5-2).fib()</code> or as <code class="literal">(4-1).fib()</code>—it’s the same thing under the hood. Wouldn’t it be great if there were a way to call something like <code class="literal">3.fib()</code> once and then remember its value for subsequent calls?</p><p>There is such a technique. It’s called <span class="emphasis"><em>memoization</em></span>, and it’s a critical way to make recursive programs use processor time more efficiently. Take a look at our new <a class="indexterm" id="idx-CHP-7-0729"/>script variants, which take advantage of memoization. In both variants, we define an appropriately named Array at ❾ that holds the memoized results so far. We already have starting results for both <code class="literal">0</code> and <code class="literal">1</code>, which we defined in the <code class="literal">returns1</code> Array in our earlier examples. We then use that memoized results Array (either <code class="literal">@@factorial_results</code> or <code class="literal">@@fibonacci_results</code>) at ❿, using the <code class="literal">||=</code> operator to set a value for the <code class="literal">self</code> index within the Array, if there isn’t a value already. Since Ruby methods always return the last evaluated expression, we don’t need separate setting and returning operations. Now, whenever we need the <code class="literal">fact</code> or <code class="literal">fib</code> value for a lower <code class="literal">self</code>, we can just read it out. The <code class="literal">||=</code> operator at ❿ evaluates the element from the Array as <code class="literal">true</code> and simply returns it without making a new assignment.<sup>[<a class="footnote" href="#ftn.CHP-7-FNOTE-5" id="CHP-7-FNOTE-5">24</a>]</sup></p><p>A complement to memoization is <a class="indexterm" id="idx-CHP-7-0734"/>lazy evaluation. Few languages implement this by default, Haskell being the most widely known exception. Most languages use <span class="emphasis"><em>eager evaluation</em></span>, in which expressions are evaluated as early as possible, certainly on entry into a method or function. <span class="emphasis"><em>Lazy evaluation</em></span> lets expressions be passed around unevaluated until their value is needed. The benefit for factorial and Fibonacci operations is that the operations on higher numbers can wait until the operations on lower numbers are already done, which speeds up the whole process. There’s a library for lazy evaluation in Ruby at <a class="ulink" href="http://moonbase.rydia.net/software/lazy.rb">http://moonbase.rydia.net/software/lazy.rb</a>.<a class="indexterm" id="idx-CHP-7-0735"/><a class="indexterm" id="idx-CHP-7-0736"/><a class="indexterm" id="I_indexterm7_d1e11783"/></p><a id="I_programlisting7_d1e11786"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0737"/>factorial5.rb

  class Integer

❾   @@factorial_results = [1, 1] # Both 0 and 1 have a value of 1

    def fact()
❿     @@factorial_results[self] ||= self * (self-1).fact    <em class="lineannotation"><span class="lineannotation">Memoization</span></em>
    end

    def show_mems()
      @@factorial_results.inspect
    end

  end</pre><p>The <a class="indexterm" id="idx-CHP-7-0738"/>Fibonacci version is:</p><a id="I_programlisting7_d1e11801"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0739"/>fibonacci5.rb

  class Integer

❾   @@fibonacci_results = [1, 1] # Both 0 and 1 have a value of 1

    def fib()
❿     @@fibonacci_results[self] ||= (self-1).fib + (self-2).fib
    end

  end</pre><p>That should be enough variants to test. Note that this last factorial script also includes a method called <code class="literal">show_mems</code> that you can use to inspect the state of the memoization. If you’d like, you can add your own equivalent to <code class="literal">fibonacci5.rb</code>. On to the <a class="indexterm" id="idx-CHP-7-0740"/>testing.<a class="indexterm" id="idx-CHP-7-0741"/><a class="indexterm" id="idx-CHP-7-0742"/></p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FNOTE-1" id="ftn.CHP-7-FNOTE-1">20</a>] </sup>This is as good a place as any to mention <a class="indexterm" id="idx-CHP-7-0685"/>tail <a class="indexterm" id="idx-CHP-7-0686"/>recursion. A function or method is <span class="emphasis"><em>tail recursive</em></span> if it can be easily converted from recursion (which is friendly to human readers at a high level of abstraction) to iteration (which is friendlier to computer hardware). The Ruby interpreter does not currently do such conversion. I mention this because we’ll be doing a lot of recursing in this chapter.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FNOTE-2" id="ftn.CHP-7-FNOTE-2">21</a>] </sup>Commonly attributed to Donald <a class="indexterm" id="idx-CHP-7-0691"/>Knuth, a computer programming genius if there ever was one.<a class="indexterm" id="idx-CHP-7-0692"/><a class="indexterm" id="idx-CHP-7-0693"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FNOTE-3" id="ftn.CHP-7-FNOTE-3">22</a>] </sup>The integers resulting from factorial and Fibonacci operations can become rather large. Luckily, Ruby allows you to just treat them all as Integers, transparently doing whatever operations are needed with Bignums and Fixnums without making you worry about such things.<a class="indexterm" id="idx-CHP-7-0700"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FNOTE-4" id="ftn.CHP-7-FNOTE-4">23</a>] </sup>Maybe the criticism is more fair when directed at the author than the scripts. After all, the scripts only do what I tell them to. In fairness to me, I wrote them to demonstrate failed optimization attempts.<a class="indexterm" id="idx-CHP-7-0725"/><a class="indexterm" id="idx-CHP-7-0726"/><a class="indexterm" id="idx-CHP-7-0727"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FNOTE-5" id="ftn.CHP-7-FNOTE-5">24</a>] </sup>Our Perl friends do something similar to our use of <code class="literal">||=</code> here that they call the <span class="emphasis"><em>Orcish Maneuver</em></span>. Look it up at <a class="ulink" href="http://perl.plover.com/TPC/1998/Hardware-notes.html">http://perl.plover.com/TPC/1998/Hardware-notes.html</a> if you’re curious. The name comes from both a pun and the prevalence of <span class="emphasis"><em>The Lord of the Rings</em></span> fandom in the Perl community.<a class="indexterm" id="idx-CHP-7-0730"/><a class="indexterm" id="idx-CHP-7-0731"/><a class="indexterm" id="idx-CHP-7-0732"/><a class="indexterm" id="idx-CHP-7-0733"/></p></div></div></div>
<div class="sect1" title="#27 Benchmarking and Profiling (tests/test_opts.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp27_benchmarking_and_profiling_tests"/>#27 Benchmarking and Profiling (tests/test_opts.rb)</h1></div></div></div><p>Here we’ll talk about two distinct ways to test the <a class="indexterm" id="idx-CHP-7-0743"/>execution speed of code. <span class="emphasis"><em>Benchmarking</em></span> measures the overall speed of the <a class="indexterm" id="idx-CHP-7-0744"/>code, while <span class="emphasis"><em>profiling</em></span> gives more detailed information about how long different parts of the code take to execute, relative to each other.<a class="indexterm" id="idx-CHP-7-0745"/></p><div class="sect2" title="Benchmarking"><div class="titlepage"><div><div><h2 class="title"><a id="benchmarking"/>Benchmarking</h2></div></div></div><p>The previous variants all showed ways to modify the base code in the hopes of making it faster. Here’s where we test our assumptions and find out what really makes a difference. I store it in a directory called <code class="literal">tests</code>, meaning that I run it with <code class="literal">ruby -w tests/test_opts.rb</code>.<a class="indexterm" id="I_indexterm7_d1e11864"/></p></div><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id026"/>The Code</h2></div></div></div><a id="I_programlisting7_d1e11870"/><pre class="programlisting">  #!/usr/bin/env ruby
  # test_opts.rb

  =begin comment
  Run this without warnings to avoid messages about method redefinition,
  which we are doing intentionally for this testing script.
  =end

❶ require 'benchmark'    <em class="lineannotation"><span class="lineannotation">Benchmark Module</span></em>
  include Benchmark

❷   FUNC_OF_FILE = {
      'factorial' =&gt; 'fact',
      'fibonacci' =&gt; 'fib',
    }

    UPPER_OF_FILE = {
      'factorial' =&gt; 200,
      'fibonacci' =&gt; 30,
    }

❸ ['factorial', 'fibonacci'].each do |file|

❹   (1..5).to_a.each do |num|
❺     require "#{file}#{num}"
      upper = UPPER_OF_FILE[file]

❻     <a class="indexterm" id="idx-CHP-7-0746"/>bm do |test|

❼       test.report("#{file}#{num}") do
❽         upper.<a class="indexterm" id="idx-CHP-7-0747"/>send(FUNC_OF_FILE[file])
        end

      end

    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id025"/>How It Works</h2></div></div></div><p>First, I <code class="literal">require</code> a file called <code class="literal">‘benchmark’</code> (❶); the <code class="literal">include</code> command that immediately follows it mixes in a Module called Benchmark. This is the workhorse of our script. It provides a facility for <a class="indexterm" id="idx-CHP-7-0748"/>testing how long specific operations take within a program. In order to do those tests, we need to set up a few Constants, which we do at ❷. The <code class="literal">FUNC_OF_FILE</code> constant contains the name of the method (or function) we want to call in each file, and <code class="literal">UPPER_OF_FILE</code> determines the largest Integer on which to call that function (the upper limit, in other words).<a class="indexterm" id="idx-CHP-7-0749"/></p><p>At ❸, we loop through each <code class="literal">file</code>, and at ❹, we loop through each <code class="literal">num</code>, which is the filename suffix. Then we require a specific, dynamically generated filename at ❺. Note that this will override any previous definitions of methods with the same name. (This is why we will run this script without warnings, as the RDoc at the beginning of the file indicates.) We then set the value of the <code class="literal">upper</code> local variable. At ❻, we call the method <code class="literal">bm</code>, provided by the <a class="indexterm" id="idx-CHP-7-0750"/>Benchmark module. It takes a block whose local variable is the <code class="literal">test</code> to be run. That <code class="literal">test</code> has a method called <code class="literal">report</code>, which (as the name suggests) generates a report of the test’s findings. The <code class="literal">report</code> method also takes a block that contains the <a class="indexterm" id="idx-CHP-7-0751"/>code comprising the test. That block consists of only one line at ❽. We haven’t seen the <code class="literal">send</code> method yet, but calling <code class="literal">some_object.send( some_func_name, some_arg )</code> is the same as calling <code class="literal">some_object.some_func_name( some_arg )</code>. I’ll describe <code class="literal">send</code> in greater detail in the <code class="literal">to_lang.rb</code> script in <a class="xref" href="ch10.html" title="Chapter 10. More Complex Utilities and Tricks, Part II">Chapter 10</a>. For now, just understand that it calls the desired method (either <code class="literal">fact</code> or <code class="literal">fib</code>) for each file.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id020"/>Running the Script</h2></div></div></div><p>You’ll want to run this with the command <code class="literal">ruby tests/test_opts.rb</code>. Notice that we eschew the <code class="literal">-w</code> flag in this particular case. The reason is that we are redefining methods, which triggers a warning. Since we are doing this intentionally and are aware of the situation, the warning is merely an annoyance in this particular case.</p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id023"/>The Results</h2></div></div></div><p>Here are my results. Your results may vary considerably, depending on how fast your machine is.</p><a id="I_programlisting7_d1e11993"/><pre class="programlisting">      user     system      total        real
factorial1  0.016667   0.000000   0.016667 (  0.002705)
      user     system      total        real
factorial2  0.000000   0.000000   0.000000 (  0.001517)
      user     system      total        real
factorial3  0.000000   0.000000   0.000000 (  0.001532)
      user     system      total        real
factorial4  0.000000   0.000000   0.000000 (  0.001491)
      user     system      total        real
factorial5  0.000000   0.000000   0.000000 (  0.001508)
      user     system      total        real
fibonacci1  8.416667   1.900000  10.316667 (  6.207565)
      user     system      total        real
fibonacci2 11.316667   1.866667  13.183333 (  8.567413)
      user     system      total        real
fibonacci3  9.066667   1.816667  10.883333 (  6.809812)
      user     system      total        real
fibonacci4  9.233333   1.533333  10.766667 (  6.520220)
      user     system      total        real
fibonacci5  0.000000   0.000000   0.000000 (  0.000166)</pre><p>The <a class="indexterm" id="idx-CHP-7-0752"/>benchmarking output shows seconds used from the perspective of the user, system, total, and real labels. You can read more about the specific meanings of these labels via the command <code class="literal">man time</code> on a Unix-like system. For now, keep in mind that they are useful for measuring the time one process takes, relative to another process. I’ll be referring to the <code class="literal">real</code> time in my discussion. You can see that there is very little variation among the factorial scripts. The main reason for this is that the factorial operation is comparatively simple, since it is a single, recursive multiplication. We see more striking data for the Fibonacci scripts because each recursive Fibonacci operation spawns two additional Fibonacci operations, unless it uses memoization. This double spawning is why I set the upper limit of Fibonacci operations at the much lower value of 30, compared with the factorial’s upper limit of 200.</p><p>Our tests showed that the simple <code class="literal">fibonacci1.rb</code> took about 6.20 seconds to run 30 consecutive operations of calling <code class="literal">fib</code> on the numbers from one to five. Things actually get worse when we try the <code class="literal">include?</code> optimization in <code class="literal">fibonacci2.rb</code> (it takes about 8.56 seconds), and improve only slightly for the argument optimization in <code class="literal">fibonacci3.rb</code> (which takes about 6.81 seconds). The run time doesn’t significantly change until we introduce <a class="indexterm" id="idx-CHP-7-0753"/>memoization in <code class="literal">fibonacci5.rb</code>, where the time spent drops so much that it’s no longer significant.</p><p>The moral of the story is twofold. First, we’ve learned that it’s better to base <a class="indexterm" id="idx-CHP-7-0754"/>code optimization for speed on tests, rather than intuitions. By trying to squeeze some faster performance out of a piece of <a class="indexterm" id="idx-CHP-7-0755"/>code, you can waste time in an area that isn’t even your speed bottleneck, and it will only make your code harder to read. The second moral is that memoization (as used in <code class="literal">factorial5.rb</code> and <code class="literal">fibonacci5.rb</code>) is a crucial addition to any recursive operations that are likely to be repeated.</p></div><div class="sect2" title="Profiling"><div class="titlepage"><div><div><h2 class="title"><a id="profiling"/>Profiling</h2></div></div></div><p>Of course, <a class="indexterm" id="idx-CHP-7-0756"/>benchmarking is only part of the story. If you’re worried about the speed of your code, knowing only the total time it takes to run is not especially useful. What’s more useful is the information provided by <span class="emphasis"><em>profiling</em></span>, which breaks down the parts of your code and gives speed reports at a finer level of detail.<a class="indexterm" id="idx-CHP-7-0757"/></p><p>Ruby has a profiling library called <code class="literal">profile</code>. It can be <code class="literal">require</code> d, just like benchmark, but it doesn’t demand specific <a class="indexterm" id="idx-CHP-7-0758"/>testing code like the <code class="literal">bm</code> method and its block. The library can be automatically applied to an <a class="indexterm" id="idx-CHP-7-0759"/>execution of code simply by including <code class="literal">profile</code> via the <code class="literal">-r</code> flag. Let’s do so with a command-line execution of the first script we wrote:<a class="indexterm" id="idx-CHP-7-0760"/></p><a id="I_programlisting7_d1e12096"/><pre class="programlisting">ruby -r profile -r 99bottles.rb -e 'wall = Wall.new(99); wall.sing_one_verse!
until wall.empty?'.</pre><p>Notice how all we have to do is require <code class="literal">profile</code> with the <code class="literal">-r</code> flag; our <code class="literal">-e</code> flag contains code to be executed that works just like the irb session we used with <code class="literal">99bottles.rb</code> when we wrote it in <a class="xref" href="ch02.html" title="Chapter 2. Amusements and Simple Utilities">Chapter 2</a>. Here is an extremely truncated version of its results:<a class="indexterm" id="I_indexterm7_d1e12115"/></p><a id="I_programlisting7_d1e12118"/><pre class="programlisting">2 bottles of beer on the wall, 2 bottles of beer
take one down, pass it around, 1 bottle of beer on the wall.

1 bottle of beer on the wall, 1 bottle of beer
take one down, pass it around, no more bottles of beer on the wall.

  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 31.25     0.08      0.08      297     0.28     0.45  Wall#sing
 18.75     0.13      0.05       99     0.51     2.53  Wall#sing_one_verse!
 18.75     0.18      0.05       99     0.51     0.51  Wall#take_one_down!
 12.50     0.22      0.03      297     0.11     0.11  Fixnum#==
  6.25     0.23      0.02      100     0.17     0.17  Wall#empty?
  6.25     0.25      0.02      297     0.06     0.06  Fixnum#&gt;
  6.25     0.27      0.02       99     0.17     0.17  Kernel.puts
  0.00     0.27      0.00        1     0.00     0.00  Wall#initialize
  0.00     0.27      0.00        5     0.00     0.00  Module#method_added
  0.00     0.27      0.00        1     0.00     0.00  Class#inherited
  0.00     0.27      0.00       99     0.00     0.00  IO#write
  0.00     0.27      0.00      594     0.00     0.00  String#+
  0.00     0.27      0.00       99     0.00     0.00  Fixnum#-
  0.00     0.27      0.00      100     0.00     0.00  Fixnum#zero?
  0.00     0.27      0.00        1     0.00     0.00  Class#new
  0.00     0.27      0.00      296     0.00     0.00  Fixnum#to_s
  0.00     0.27      0.00        1     0.00     0.00  Module#private
  0.00     0.27      0.00        1     0.00   266.67  #toplevel</pre><p>This report provides a great deal of interesting information, including the percentage of total time that a given method takes, the raw seconds used by that method call, the number of calls to each method, and the number of milliseconds taken per call. This data gives you something to use when you’re trying to improve <a class="indexterm" id="idx-CHP-7-0761"/>execution speed. If the number of calls to a given method is high, perhaps the method is being called multiple times in a loop. You can increase speed by pre-running that method only once and passing its value into the loop for use. You can also try different ways of implementing the same operation to see which way runs faster, and so on.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id015"/>Hacking the Script</h2></div></div></div><p>There are several variations you could try with these scripts. The simplest <a class="indexterm" id="idx-CHP-7-0762"/>code modifications involve changing the upper limit values in <code class="literal">upper_of_file</code> for each <code class="literal">file</code>. You can also try operations other than factorial or Fibonacci ones. You can also run any of the scripts in this book with <code class="literal">-r profile</code>. When writing them, I focused on pedagogy rather than speed, so you can probably make some speed improvements to these stock scripts. Now let’s move on to a practical application of functional programming that should remind you of some earlier scripts.</p></div></div>
<div class="sect1" title="#28 Converting Temperatures (temperature_converter.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp28_converting_temperatures_temperat"/>#28 Converting Temperatures (temperature_converter.rb)</h1></div></div></div><p>For this example, we’ll write a converter script. This time, instead of converting currencies, we’ll convert units for other real-world factors like length, mass, temperature, and so on. The version that I show here only handles temperatures, but you can download <code class="literal">units_converter.rb</code> at this book’s companion website; it is a more comprehensive script that also handles length, volume, and mass. We’ll concentrate on converting to and from <a class="indexterm" id="idx-CHP-7-0763"/>English and <a class="indexterm" id="idx-CHP-7-0764"/>metric units, but we’ll also support kelvins. Let’s take a look.<a class="indexterm" id="idx-CHP-7-0765"/><a class="indexterm" id="idx-CHP-7-0766"/><a class="indexterm" id="idx-CHP-7-0767"/><a class="indexterm" id="I_indexterm7_d1e12173"/><a class="indexterm" id="I_indexterm7_d1e12177"/><a class="indexterm" id="I_indexterm7_d1e12182"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id027"/>The Code</h2></div></div></div><a id="I_programlisting7_d1e12190"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-7-0768"/>temperature_converter.rb
  # See also GNU units at http://www.gnu.org/software/units/units.html

  # Converts <a class="indexterm" id="idx-CHP-7-0769"/>Metric/SI &lt;-&gt; <a class="indexterm" id="idx-CHP-7-0770"/>English units.

  =begin rdoc
  Converts to and from various units of temperature.
  =end
  class Temperature_Converter

    # every factor has some base unit for multi-stage conversion
    # I allow either full or shortened name as the key
❶    BASE_UNIT_OF = {
      'temperature' =&gt; 'K',
      'temp'        =&gt; 'K',
    }

❷   C_TO_F_ADD        = 32.0
    F_TO_C_RATIO      = 5.0/9.0
    C_TO_K_ADD        = 273.15

❸   C2K = lambda { |c| c + C_TO_K_ADD }
    F2C = lambda { |f| (f - C_TO_F_ADD ) * F_TO_C_RATIO }
    K2C = lambda { |k| k - C_TO_K_ADD }
    C2F = lambda { |c| (c / F_TO_C_RATIO) + C_TO_F_ADD }
    F2K = lambda { |f| C2K.call( F2C.call(f) ) }    <em class="lineannotation"><span class="lineannotation">Composition of Functions</span></em>
    K2F = lambda { |k| C2F.call( K2C.call(k) ) }

❹   CONVERSIONS = {
      # most units just need to get to the base unit
      # have =&gt; {want =&gt; how_many_wants_per_have},
      'C'   =&gt; { 'K' =&gt; C2K },
      'F'   =&gt; { 'K' =&gt; F2K },

❺     # The base unit requires more conversion targets
      'K'   =&gt; {
        'F'   =&gt; K2F,
        'C'   =&gt; K2C,
      },

    }

    OUTPUT_FORMAT = "%.2f"

❻   def convert(params)
      conversion_proc =
        CONVERSIONS[params[:have_unit]][params[:want_unit]] ||
        get_proc_via_base_unit(params)

      return "#{params[:have_num]} #{params[:have_unit]} = " +
        "#{sprintf( OUTPUT_FORMAT, conversion_proc[params[:have_num]] )} " +
        "#{params[:want_unit]}"
    end

    private

  =begin rdoc
  If there is no direct link between the known unit and the desired unit,
  we must do a two-stage conversion, using the base unit for that factor
  as a "Rosetta Stone."
  =end
    def get_proc_via_base_unit(params)
❼     base_unit         = BASE_UNIT_OF['temperature']
❽     have_to_base_proc = CONVERSIONS[params[:have_unit]][base_unit]
❾     base_to_want_proc = CONVERSIONS[base_unit][params[:want_unit]]
❿     return lambda do |have|
        base_to_want_proc.call( have_to_base_proc.call( have ) )
      end
    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id026"/>How It Works</h2></div></div></div><p>This <a class="indexterm" id="idx-CHP-7-0771"/>script uses a few functional techniques that we haven’t covered yet. Let’s step through the code. At ❶, we define a <code class="literal">BASE_UNIT_OF</code> Hash that holds the base unit. Note that <span class="emphasis"><em>temperature</em></span> and <span class="emphasis"><em>temp</em></span> are both acceptable, and that the script uses <a class="indexterm" id="idx-CHP-7-0772"/>kelvins, the scientific unit of absolute temperature, as its internal temperature unit. Next, we define some helpful conversion constants. I’ve broken these up into paragraphs: The first paragraph of definitions (❷) holds simple addition and multiplication constants, while the second paragraph (❸) uses <code class="literal">lambda</code> to define Procs that will use the values from the first paragraph. Temperature conversion is a bit more complicated than conversion of length or mass.</p><p>Most unit conversions consist of a simple multiplication operation. If you have 100 pounds and you want to know how many kilograms that is, you simply multiply 100 by 0.45. But to convert temperature between Fahrenheit and <a class="indexterm" id="idx-CHP-7-0773"/>Celsius, you must multiply <span class="emphasis"><em>and</em></span> add. The general formula is F = ( C x 9/5 ) + 32. Conversely, C = ( F – 32 ) x 5/9. Note also that one degree Celsius and one kelvin are the same size (meaning there is no multiplication needed to convert between them), but they are offset by 273.15, so 0 degrees Celsius = 273.15 kelvins, and 0 kelvins (absolute zero) = -273.15 degrees Celsius. That’s cold.</p><p>At ❸, we define constants with three-character names that suggest the type of temperature conversion they do; for example, the <code class="literal">K2C</code> conversion Proc accepts kelvins and returns the Celsius equivalent. Most of these are pretty straightforward and implement the temperature relationships I described in the paragraph of declarations (❷).</p><p>However, the <code class="literal">F2K</code> and <code class="literal">K2F</code> Procs are more interesting. They use previously defined Procs inside themselves and then use the <code class="literal">call</code> method successively to perform two-stage conversions. <code class="literal">F2K</code> accepts some Fahrenheit value <code class="literal">f</code>, converts that to Celsius via <code class="literal">F2C.call(f)</code>, and then uses that Celsius value as the argument to <code class="literal">C2F.call()</code>. This general operation of performing successive function calls is called <span class="emphasis"><em>composition</em></span>. <code class="literal">F2K</code> composes <code class="literal">C2K</code> and <code class="literal">F2C</code>, and <code class="literal">K2F</code> composes <code class="literal">C2F</code> and <code class="literal">K2C</code>. This has the same benefits as breaking operations up into functions or methods: You only need to have a single, definitive place where any given operation is defined, and you can just call that operation as you build more complicated operations that depend on earlier definitions.<a class="indexterm" id="idx-CHP-7-0774"/></p><p>We have some useful constants, including temperature-related Procs. Next is our <code class="literal">CONVERSIONS</code> Hash at ❹. This is a doubly nested Hash, and the outermost keys are the <a class="indexterm" id="idx-CHP-7-0775"/>units we have. Each of those keys points to yet another Hash, with a key representing the <a class="indexterm" id="idx-CHP-7-0776"/>units we want to <a class="indexterm" id="idx-CHP-7-0777"/>convert to and a value that is the necessary conversion Proc. If we have degrees Celsius and we want kelvins, our conversion operation is <code class="literal">CONVERSIONS[‘C’][‘K’]</code>, which is the <code class="literal">C2K</code> Proc constant.<a class="indexterm" id="idx-CHP-7-0778"/></p><div class="note" title="Note"><h3 class="title"><a id="note-43"/>Note</h3><p><span class="emphasis"><em>The purpose of the <em class="replaceable"><code>CONVERSIONS</code></em> Hash is to pass in some identifier(s) and get something useful out, specifically the Proc needed to do the requested unit conversion. This is very similar to a</em></span> Factory <span class="emphasis"><em>in object orientation, which is an object that creates other objects based on the parameters it receives. Our <em class="replaceable"><code>CONVERSIONS</code></em> Hash is an example of the same concept applied to Procs</em></span>.</p></div><p>The first paragraph of data in <code class="literal">CONVERSIONS</code> converts to our base unit for each factor—kelvins, in our case. But what if someone asks for a final output that isn’t our base unit? We need to be able to convert from the base unit to all the other units, which is what the next paragraph of code at ❺ is for. It’s still part of the <code class="literal">CONVERSIONS</code> Hash, and it still follows the same structure of <code class="literal">{ have =&gt; { want =&gt; some_conversion_proc } }</code>, but it has two conversion targets instead of one. We close the constants with <code class="literal">OUTPUT_FORMAT</code>, which restricts our reported values to two decimal places.</p><p>At ❻ we define our main method, called <code class="literal">convert</code>. It takes a mandatory argument called <code class="literal">params</code> and defines a local variable called <code class="literal">conversion_proc</code> that has the value of either <code class="literal">CONVERSIONS[params[:have_unit]][params[:want_unit]]</code> or, failing that, the output of <code class="literal">get_proc_via_base_unit(params)</code>. We already know that the value of <code class="literal">CONVERSIONS[‘C’][‘K’]</code> is the Celsius-to-kelvins Proc. Let’s verify that in irb:</p><a id="I_programlisting7_d1e12374"/><pre class="programlisting">$ irb -r <a class="indexterm" id="idx-CHP-7-0779"/>temperature_converter.rb
irb(main):001:0&gt; tc = Temperature_Converter.new
=&gt; #&lt;Temperature_Converter:0xb7ccdb04&gt;
irb(main):002:0&gt; tc.convert( {:have_unit =&gt; 'C', :want_unit =&gt; 'K', :have_num
=&gt; 15} )
=&gt; "15 C = 288.15 K"</pre><p>There is another key to <code class="literal">params</code> here other than <code class="literal">:have_units</code> and <code class="literal">:want_units</code>, but it should be fairly clear. We also need to tell the converter how many units we have, which is what <code class="literal">:have_num</code> does. These results look good; they are examples in which there is a value available for <code class="literal">CONVERSIONS[params[:have_unit]][params[:want_unit]]</code> inside the <code class="literal">convert</code> method, meaning that it doesn’t need to use <code class="literal">get_proc_via_base_unit(params)</code>. After it’s got the <code class="literal">conversion_proc</code>, it returns the output you already saw in irb, which shows the number and unit already known, and what it converts into.</p><p>This is straightforward enough. But what happens when there isn’t a value for <code class="literal">CONVERSIONS[params[:have_unit]][params[:want_unit]]</code> available? This would be true in cases such as converting degrees Celsius to degrees Fahrenheit. There is no Proc at <code class="literal">CONVERIONS[‘C’][‘F’]</code>. Does this mean that our base unit needs to be either the known or desired value? Yes and no. Yes in only the most pedantic sense. No in any practical sense, because we can use the <code class="literal">get_proc_via_base_unit</code> method to create our own <code class="literal">conversion_proc</code> by composing two other known <code class="literal">conversion_procs</code>, just like the ones we hard-coded into the temperature converters.<a class="indexterm" id="idx-CHP-7-0780"/></p><p>If the unit our <code class="literal">params</code> asks for doesn’t have a built-in conversion Proc, we can use <code class="literal">get_proc_via_base_unit</code>, as noted. Inside <code class="literal">get_proc_via_base_unit</code>, we first get the <code class="literal">base_unit</code> (❼). We then create the <code class="literal">have_to_base_proc</code> by getting the Proc out of <code class="literal">CONVERIONS</code> that would be used to convert from the known unit to the <code class="literal">base_unit</code> (❽). Then we get the <code class="literal">base_to_want_proc</code> by getting the Proc out of <code class="literal">CONVERIONS</code> that would be used to convert from the <code class="literal">base_unit</code> to the unit we want (❾). Then at ❿, we compose <code class="literal">base_to_want_proc</code> and <code class="literal">have_to_base_proc</code>, just as we did in the ❸ section for <code class="literal">F2K</code> and <code class="literal">K2F</code>. We could have called our new Proc <code class="literal">have_to_want_proc</code>, but we just <code class="literal">return</code> it, and it becomes <code class="literal">conversion_proc</code> inside the <code class="literal">convert</code> method at ❻.<a class="indexterm" id="idx-CHP-7-0781"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id024"/>The Results</h2></div></div></div><p>Let’s try it out in irb. It was 65 degrees Fahrenheit in <a class="indexterm" id="idx-CHP-7-0782"/>Buffalo, New York in November today (yes, really), and I was talking with a Canadian coworker about this temperature conversion script. Let’s start with that.</p><a id="I_programlisting7_d1e12500"/><pre class="programlisting">$ irb -r <a class="indexterm" id="idx-CHP-7-0783"/>temperature_converter.rb
irb(main):001:0&gt; tc = Temperature_Converter.new
=&gt; #&lt;Temperature_Converter:0xb7c75b5c&gt;
irb(main):002:0&gt; tc.convert( { :have_num =&gt; 65.0, :have_unit =&gt; 'F', :want_unit =&gt; 'C' } )
=&gt; "65.0 F = 18.33 C"
irb(main):003:0&gt; tc.convert( { :have_num =&gt; 0, :have_unit =&gt; 'K', :want_unit =&gt; 'F' } )
=&gt; "0 K = -459.67 F"</pre><p>These examples should give you an idea of this program’s interface. You can also call it with other conversions that are of interest to you.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id016"/>Hacking the Script</h2></div></div></div><p>As I already noted, there is a more complex version of this script available for download at the book’s website. If you find that you want to convert to or from <a class="indexterm" id="idx-CHP-7-0784"/>units that I don’t have built in, just create a key/value pair in <code class="literal">CONVERSIONS</code> that converts from your new unit to the appropriate base unit and another that converts from the base unit to your new unit. That should give you the ability to convert to and from any unit relative to your new unit.</p><p>We also use <a class="indexterm" id="idx-CHP-7-0785"/>implicit composition in <code class="literal">temperature_converter.rb</code>—at ❸ for definition and at ❿ for use. You could modify the script to have an explicit <code class="literal">compose</code> method that takes two Procs and returns a new Proc that performs each operation in order. Here’s an example in irb:<a class="indexterm" id="idx-CHP-7-0786"/><a class="indexterm" id="idx-CHP-7-0787"/></p><a id="I_programlisting7_d1e12538"/><pre class="programlisting">irb(main):001:0&gt; def compose(inner_proc, outer_proc, *args)
irb(main):002:1&gt; return lambda { |*args| outer_proc.call(inner_proc[*args]) }
irb(main):003:1&gt; end
=&gt; nil
irb(main):004:0&gt; square = lambda { |x| x ** 2 }
=&gt; #&lt;Proc:0xb7cda048@(irb):4&gt;
irb(main):005:0&gt; inc = lambda { |x| x + 1 }
=&gt; #&lt;Proc:0xb7ccb8f4@(irb):5&gt;
irb(main):006:0&gt; square_then_inc = compose( square, inc )
=&gt; #&lt;Proc:0xb7ce5204@(irb):2&gt;
irb(main):007:0&gt; inc_then_square = compose( inc, square )
=&gt; #&lt;Proc:0xb7ce5204@(irb):2&gt;
irb(main):008:0&gt; square_then_inc.call(1)
=&gt; 2
irb(main):009:0&gt; square_then_inc.call(2)
=&gt; 5
irb(main):010:0&gt; inc_then_square.call(2)
=&gt; 9</pre><p>Line 8 gives us <code class="literal">2</code>, because <code class="literal">(1 ** 1) + 1 = 2</code>. Line 9 gives us <code class="literal">5</code>, because <code class="literal">(2 ** 2) + 1 = 5</code>. Line 10 gives us <code class="literal">9</code>, because <code class="literal">(2 + 1) ** 2 = 9</code>. Once you have this <code class="literal">compose</code> method, you can even use it on Procs that are the returned value from a previous call to <code class="literal">compose</code>, allowing you to stack successive operations as much as you like.</p></div></div>
<div class="sect1" title="#29 Testing temperature_converter.rb (tests/test_temp_converter.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp29_testing_temperature_converterrb_"/>#29 Testing temperature_converter.rb (tests/test_temp_converter.rb)</h1></div></div></div><p>Up until this point, our testing scripts have been relatively primitive, and to a very large degree, we have rolled our own testing solutions. It’s silly to do that repeatedly, especially in computer programs, because good programming languages allow you to express abstract concepts abstractly, as well as to adapt general-purpose tools in code libraries to your specific needs.<a class="indexterm" id="idx-CHP-7-0788"/><a class="indexterm" id="idx-CHP-7-0789"/></p><p>Ruby has a general-purpose testing library called <code class="literal">Test::Unit</code>. Here is code that allows you to use its power to test the script <code class="literal">temperature_converter.rb</code>.<a class="indexterm" id="idx-CHP-7-0790"/><a class="indexterm" id="I_indexterm7_d1e12593"/><a class="indexterm" id="I_indexterm7_d1e12596"/><a class="indexterm" id="I_indexterm7_d1e12601"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id028"/>The Code</h2></div></div></div><a id="I_programlisting7_d1e12609"/><pre class="programlisting">  #!/usr/bin/env ruby
  # test_temp_converter.rb

❶ require 'temperature_converter'
  require 'test/unit'

❷ class Tester &lt; Test::Unit::TestCase    <em class="lineannotation"><span class="lineannotation">Unit <a class="indexterm" id="idx-CHP-7-0791"/>Testing</span></em>

    def setup
      @converter = Temperature_Converter.new()
    end

    def test_temps()

❸     tests = {
        '100.0 C = 212.00 F' =&gt; {
          :have_num  =&gt; 100.0,
          :have_unit =&gt; 'C',
          :want_unit =&gt; 'F',
        },
        '212.0 F = 100.00 C' =&gt; {
          :have_num =&gt; 212.0,
          :have_unit =&gt; 'F',
          :want_unit =&gt; 'C',
        },
        '70.0 F = 294.26 K' =&gt; {
          :have_num =&gt; 70.0,
          :have_unit =&gt; 'F',
          :want_unit =&gt; 'K',
        },
        '25.0 C = 298.15 K' =&gt; {
          :have_num =&gt; 25.0,
          :have_unit =&gt; 'C',
          :want_unit =&gt; 'K',
        },
      }
      general_tester( tests )

    end

    private

❹   def general_tester(tests)
❺     tests.each_pair do |result,test_args|
❻       assert_equal( result, @converter.convert( test_args ) )
      end
    end

  end</pre></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id025"/>The Results</h2></div></div></div><p>Let’s run it and see what happens.</p><a id="I_programlisting7_d1e12625"/><pre class="programlisting">$ ruby -w tests/test_temp_converter.rb
Loaded suite tests/test_temp_converter
Started
.
Finished in 0.001094 seconds.

1 tests, 4 assertions, 0 failures, 0 errors</pre><p>All four of our assertions passed with no failures or errors. That’s wonderful news. Now let’s look at what it means.</p><div class="note" title="Note"><h3 class="title"><a id="note-44"/>Note</h3><p><span class="emphasis"><em>One term you may hear in reference to testing is</em></span> <a class="indexterm" id="idx-CHP-7-0792"/>code coverage, <span class="emphasis"><em>which is the degree to which the tests adequately examine the pertinent code. This can be defined in terms of the percentage of total code lines that are tested, the percentage of Boolean evaluations that are tested, and other similar metrics</em></span>.<a class="indexterm" id="idx-CHP-7-0793"/></p></div><p>Earlier in this chapter, I mentioned <a class="indexterm" id="idx-CHP-7-0794"/>refactoring, the practice of cleaning up code implementation while leaving its behavior unchanged. Unit testing is very useful when refactoring, especially if you use tests that have high <span class="emphasis"><em>entry/exit coverage</em></span>, meaning they try to ensure that all outputs from functions stay the same as long as those functions get the same inputs. This type of testing keeps your refactoring honest.<a class="indexterm" id="idx-CHP-7-0795"/></p></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id027"/>How It Works</h2></div></div></div><p>First, we need access to the code that we’ll be testing. Luckily, we’ve followed good design practice and defined our code in a library called <code class="literal">temperature_converter.rb</code>, so we <code class="literal">require</code> both it and the <code class="literal">test/unit</code> library at ❶. Then we define a new class called <code class="literal">Tester;</code> as you can see at ❷, this class is a child of <code class="literal">Test::Unit::TestCase</code>, meaning that it inherits all of the methods and characteristics of <code class="literal">Test::Unit::TestCase</code>.<a class="indexterm" id="idx-CHP-7-0796"/><a class="indexterm" id="idx-CHP-7-0797"/></p><p>We then define a testing method called <code class="literal">test_temps</code>. It’s just a wrapper for a multi-level Hash called <code class="literal">tests</code>, defined at ❸ inside <code class="literal">test_temps</code>. You’ll notice that each key of <code class="literal">tests</code> is a String that looks like the output of <code class="literal">Units_Converter.convert</code>; that key’s value is a Hash that you use as the argument into <code class="literal">Units_Converter.convert</code> in order to get output that matches that key. Inside <code class="literal">test_temps</code>, we then pass <code class="literal">tests</code> as an argument into a private method called <code class="literal">general_tester</code>, which we define at ❹.<a class="indexterm" id="idx-CHP-7-0798"/><a class="indexterm" id="idx-CHP-7-0799"/></p><p>The <code class="literal">general_tester</code> method loops through <code class="literal">each_pair</code> in the <code class="literal">tests</code> Hash at ❺, calling the expected result <code class="literal">result</code> and the argument Hash needed to produce that <code class="literal">result, test_args</code>. For each of those pairs, we assert that <code class="literal">result</code> and <code class="literal">@converter.convert( test_args )</code> are equal, using the appropriately named <code class="literal">assert_equal</code> method (❻). That’s all there is to it.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id017"/>Hacking the Script</h2></div></div></div><p>Try making a change in one of the <code class="literal">tests</code> Hashes. If you either change only the key (which becomes <code class="literal">result</code> in <code class="literal">general_tester</code>) or only the value (which becomes <code class="literal">test_args</code> in <code class="literal">general_tester</code>), the call to <code class="literal">assert_equal</code> will fail, because the two items passed as arguments to be compared will no longer be equal. You can also add entirely new elements to the <code class="literal">tests</code> Hash, with new values you want to verify.</p><p>This script only scratches the surface of how to use <code class="literal">Test::Unit</code>. Type <code class="literal">ri Test::Unit</code> at the command line for more information. You can also browse to <a class="ulink" href="http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc">http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc</a> within the <a class="indexterm" id="idx-CHP-7-0800"/>Ruby Standard Library Documentation site. Note that the HTML generated for that documentation came from RDoc.</p><p>I already mentioned that testing can be useful during refactoring. A good place to start with testing is what I’ve done here, pre-figuring expected values from a method based on a set of known input parameters. The <code class="literal">assert_equal</code> method is very useful for such testing. There are other methods available, which you can read about by typing <code class="literal">ri Test::Unit::Assertions</code> at the command line. Notables include <code class="literal">assert_instance_of</code>, which checks whether its argument belongs to a specified class; <code class="literal">assert_nil</code>, which checks whether its argument is <code class="literal">nil</code>; <code class="literal">assert_raise</code>, which you can use to intentionally raise an Exception (i.e., break something); and <code class="literal">assert_respond_to</code>, which checks whether a given argument knows how to respond to a given specified method.<a class="indexterm" id="idx-CHP-7-0801"/><a class="indexterm" id="idx-CHP-7-0802"/><a class="indexterm" id="idx-CHP-7-0803"/></p></div></div>
<div class="sect1" title="Chapter Recap"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_recap-id005"/>Chapter Recap</h1></div></div></div><p>What was new in this chapter?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Recursive factorials and Fibonaccis as good profiling candidates</p></li><li class="listitem"><p>Refactoring</p></li><li class="listitem"><p>Memoization</p></li><li class="listitem"><p>Testing with Benchmark</p></li><li class="listitem"><p>Profiling</p></li><li class="listitem"><p>Converting temperatures</p></li><li class="listitem"><p>Hashes with Proc values as Proc Factories</p></li><li class="listitem"><p>Composition of Procs</p></li><li class="listitem"><p>Testing with <code class="literal">Test::Unit</code></p></li></ul></div><p>Again, that’s a lot to take in. This list is deceptively short, because some of these concepts require more contemplation than those we’ve considered in previous chapters. Let’s move on to the next chapter, in which we’ll write some tools for processing HTML and XML.<a class="indexterm" id="I_indexterm7_d1e12863"/><a class="indexterm" id="I_indexterm7_d1e12866"/></p></div></body></html>