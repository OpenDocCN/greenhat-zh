- en: '![](../images/313-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**RTA REFERENCE**](toc.html#app1)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Run Time Access (RTA)* is a library that displays your program’s internal
    structures and arrays as database tables. RTA uses a subset of the PostgreSQL
    protocol and is compatible with the PostgreSQL bindings for C and PHP, as well
    as for the PostgreSQL command-line tool, psql. This appendix contains the definitions,
    data structures, and function prototypes for the RTA package.'
  prefs: []
  type: TYPE_NORMAL
- en: The contents of this appendix that are taken from the RTA include excerpts from
    the file rta.h. We use the exact text of rta.h wherever possible. A less technical
    description of the material in this appendix is given in Chapters 2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'This appendix covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of RTA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTA constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API subroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELECT and UPDATE syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal RTA tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback routines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux appliances lack real-time access to status and statistics, as well as
    the ability to configure a service once it has started. As Linux users, we assume
    that to configure an application we will be able to use SSH or telnet to gain
    access to the service, use an editor to modify the /etc configuration file, and
    use the kill -1 command to terminate the process—so real-time status and statistics
    are features Linux programmers don’t even think to request. The lack of run-time
    access poses a particular challenge for network appliances where SSH is unavailable,
    either because it is not installed or it is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge for appliance designers is that more than one type of user
    interface may be required. Many appliances have some combination of web, command-line,
    SNMP agent, front panel, and framebuffer interfaces. It is a nontrivial task to
    give the end user a consistent view regardless of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Overview of RTA**](toc.html#app1.1)'
  prefs: []
  type: TYPE_NORMAL
- en: The RTA package addresses the challenges described above by giving realtime
    access to the data structures and arrays inside a running program. With minimal
    effort, we can use RTA to make a program’s data structures appear as PostgreSQL
    tables in a PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Using RTA, a structure definition is also the definition for a table row, and
    an array of structures will appear as a table. For example, the code below shows
    a definition of a data structure for TCP connection information.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/314-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tcpconn structure describes a single connection. An array of these structures
    is needed if there’s more than one connection. This array might be allocated with
  prefs: []
  type: TYPE_NORMAL
- en: struct tcpconn Conns[10];
  prefs: []
  type: TYPE_NORMAL
- en: 'The above array of structures could be considered a database table, with each
    structure in the array as a row and each member in the structure as a column.
    RTA allows you to use any programming language with a PostgreSQL binding to query
    this table of TCP connections. Here are two sample SQL statements to manipulate
    the data in the Conns table:'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT lport, dport FROM Conns WHERE fd != -1;
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE Conns SET dport = 0 WHERE fd = -1;
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if the above statements do not make sense; there is a short tutorial
    on SQL later in this appendix.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of a database API offers several advantages. For one, debugging
    is made easier because you can use simple PostgreSQL tools to view much of your
    program’s state. The PostgreSQL database API also makes it easier to build UI
    programs, since it includes bindings for PHP, Tcl/Tk, Perl, C, Java, Visual C++,
    and many other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: A database API can also help speed up development. When the tables used by the
    UI programs are carefully defined, the core application team can build the application
    while the UI developers work on the web pages, wizards, and MIBs of the various
    UI programs.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make your arrays and structures available to the database API, you
    must tell RTA about the tables (including things like the name, start address,
    number of rows, and length of each row) and columns (including things like the
    associate table name, column name, column’s data type, and whether special functions
    called *callbacks* are to be called when the column is read or written).
  prefs: []
  type: TYPE_NORMAL
- en: '[**RTA Constants**](toc.html#app1.2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here is an excerpt from the rta.h file showing the constants that describe the
    internal size limits for the RTA package. You can change these limits, but if
    you do, be sure to recompile the RTA package using your new settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/315-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/316-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**Data Structures**](toc.html#app1.3)'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that each column in a table corresponds to a structure member, and each
    row in a table corresponds to an array element. In order for RTA to treat your
    arrays of structures as tables, you have the tell RTA about the tables. You describe
    each column by filling in a COLDEF structure, and you describe each table by filling
    in a TBLDEF structure. Here is an excerpt from rta.h that completely defines the
    data structures and constants associated with tables and columns.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/316-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/317-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/317-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/318-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/318-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/319-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/319-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/320-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**API Subroutines**](toc.html#app1.4)'
  prefs: []
  type: TYPE_NORMAL
- en: There are only six subroutines in the RTA API. Table A-1 summarizes them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-1:** Subroutines for the RTA PostgreSQL API'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/320-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The subroutines in the RTA libraries usually return one of the following values.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/320-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The dbcommand() Subroutine***](toc.html#app1.5)'
  prefs: []
  type: TYPE_NORMAL
- en: The main application in your appliance accepts TCP connections from PostgreSQL
    clients and passes the stream of bytes (encoded SQL requests) from the client
    into RTA via the dbcommand() subroutine. In turn, dbcommand() writes the stream
    of bytes to an input buffer to be parsed for an SQL command.
  prefs: []
  type: TYPE_NORMAL
- en: If the input buffer contains a complete command, the command will be executed,
    the number-of-characters-in (nin) variable will be decreased by the number of
    bytes consumed, and RTA_SUCCESS will be returned. If there is not a complete command
    in the input buffer, RTA_NOCMD will be returned and no bytes will be removed from
    the input buffer.
  prefs: []
  type: TYPE_NORMAL
- en: If a command is executed, the results will be encoded into the PostgreSQL protocol
    and placed in the output buffer (out). When the subroutine is called, the input
    variable, number-of-characters-out (nout), has the number of free bytes available
    in the output buffer. When the subroutine returns, the nout variable will be decremented
    by the size of the response placed in the output buffer. An error message is generated
    if the number of available bytes in the output buffer is too small to hold the
    response from the SQL command.
  prefs: []
  type: TYPE_NORMAL
- en: The list below summarizes the input buffers and bytes for the dbcommand() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/321-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The list below summarizes the returns for the dbcommand() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/321-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The prototype for the dbcommand() subroutine is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/321-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The rta_add_table() Subroutine***](toc.html#app1.6)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_add_table() subroutine registers a table for inclusion in the database
    interface, which gives external PostgreSQL clients access to the contents of the
    table. You need to call rta_add_table() for each of your tables.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the TBLDEF structure must be statically allocated. RTA keeps only
    the pointer to the table and does not copy the information. This means that you
    can change the contents of the table definition by changing the contents of the
    TBLDEF structure, which is useful if you need to allocate more memory for the
    table and change its row count and address.
  prefs: []
  type: TYPE_NORMAL
- en: When you add an RTA table, you will see an error message if another table with
    the same name already exists in the database or if the table is defined without
    any columns.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify a savefile, the SQL commands in the savefile will be loaded as
    part of the rta_add_table() call. See “The rta_load() Subroutine” on page 300
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: This list summarizes the input for the rta_add_table() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/322-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This list summarizes the returns for the rta_add_table() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/322-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The prototype of the rta_add_table() subroutine is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/322-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The SQL_string() Subroutine***](toc.html#app1.7)'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL_string() subroutine executes the SQL command placed in the null-terminated
    input string, cmd. The results are encoded into the PostgreSQL protocol and placed
    in the output buffer, out. When the subroutine is called, the input variable,
    nout, has the number of free bytes available in the output buffer, out. When the
    subroutine returns, nout has been decremented by the size of the response placed
    in the output buffer. An error message is generated if the number of available
    bytes in the output buffer is too small to hold the response from the SQL command.
  prefs: []
  type: TYPE_NORMAL
- en: This subroutine may be most useful when updating a table value in order to invoke
    the write callbacks. (The output buffer has the results encoded in the PostgreSQL
    protocol and might not be too useful directly.)
  prefs: []
  type: TYPE_NORMAL
- en: The list below summarizes the input for the SQL_string() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/323-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The SQL_string() subroutine returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype for the SQL_string() subroutine is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/323-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The rta_config_dir() Subroutine***](toc.html#app1.8)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_config_dir() subroutine sets the default path to the savefile directory.
    The string that the input parameter, configdir, points to is saved and prepended
    to the savefile names for tables with savefiles.
  prefs: []
  type: TYPE_NORMAL
- en: You should call the rta_config_dir() subroutine before you load your application
    tables. This subroutine is intended to simplify applications that let the user
    specify a configuration directory on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: If the savefile uses an absolute path (starting with /), it is not prepended
    with the configuration directory.
  prefs: []
  type: TYPE_NORMAL
- en: This list summarizes the input for the rta_config_dir() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/323-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This list summarizes the return values for the rta_config_dir() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/323-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The prototype of the rta_config_dir() subroutine is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: int rta_config_dir(char *configdir);
  prefs: []
  type: TYPE_NORMAL
- en: '[***The rta_save() Subroutine***](toc.html#app1.9)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_save() subroutine saves a table to a file, including all savetodisk
    columns to the path and file specified. Only savetodisk columns are saved. The
    resulting file is a list of UPDATE commands containing the desired data. There
    is one UPDATE command for each row in a table.
  prefs: []
  type: TYPE_NORMAL
- en: The rta_save() subroutine tries to prevent corrupted save files by opening a
    temporary (temp) file in the same directory as the target file. The subroutine
    saves the data in the temp file and then automatically calls the rename() subroutine
    to atomically move the temp file to the savefile. The rta_save() subroutine generates
    errors if it cannot open the temp file or if it is unable to rename the temp file
    with rename().
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a general warning, keep in mind that any disk I/O can cause a program to
    block briefly. Therefore, saving and loading tables can cause your program to
    block for a moment.*'
  prefs: []
  type: TYPE_NORMAL
- en: This list summarizes the input for the rta_save() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/324-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This list summarizes the return values for the rta_save() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/324-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The prototype of the rta_save() subroutine is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/324-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The rta_load() Subroutine***](toc.html#app1.10)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_load() subroutine loads a table from a file of UPDATE commands. The
    file format is a series of UPDATE commands with one command per line. Any write
    callbacks are executed as each UPDATE occurs. Note that a call to rta_load() occurs
    automatically when you add the table using rta_add_table(). This list summarizes
    the input for the rta_load() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: This list summarizes the return values for the rta_load() subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/324-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The prototype of the rta_save() subroutine is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/324-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The prototype of the rta_save() subroutine is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/325-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**SELECT and UPDATE Syntax**](toc.html#app1.11)'
  prefs: []
  type: TYPE_NORMAL
- en: The next two sections give a brief introduction to the two SQL commands implemented
    by the RTA API. Neither the RTA UPDATE command nor the RTA SELECT command adhere
    strictly to their PostgreSQL equivalents. RTA does not allow JOIN clauses, and
    the WHERE clause supports only the boolean AND operator. There are no locks or
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[***The SELECT Command***](toc.html#app1.12)'
  prefs: []
  type: TYPE_NORMAL
- en: The prototype for the RTA SELECT command is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: SELECT column_list FROM table [where_clause] [limit_clause]
  prefs: []
  type: TYPE_NORMAL
- en: Most NCMDCOLS (defined above) columns can be specified in the column_list or
    in the WHERE clause. The reserved word *LIMIT* restricts the number of rows returned
    to the number specified. The reserved word *OFFSET* skips the number of rows specified
    and begins output with the next row.
  prefs: []
  type: TYPE_NORMAL
- en: A column_list can contain * (a wild card character that represents all columns),
    a single column name, or a comma-separated list of column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample of the where_clause syntax is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: col_name = value [AND col_name = value ..]
  prefs: []
  type: TYPE_NORMAL
- en: In this example, all the col_name = value pairs must match for a row to match.
    Note that you can use five other comparison operators in addition to equality.
    The list below shows the six available comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/325-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A sample of the limit_clause syntax is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: LIMIT 5
  prefs: []
  type: TYPE_NORMAL
- en: You will find the LIMIT and OFFSET columns to be very useful because they prevent
    a buffer overflow on the output buffer of dbcommand(). They are also useful for
    web-based UIs in which users want to be able to view data one page at a time.
  prefs: []
  type: TYPE_NORMAL
- en: There are eight reserved words that can not be used as column or table names.
    The reserved words are *AND*, *FROM*, *LIMIT*, *OFFSET*, *SELECT*, *SET*, *UPDATE*,
    and *WHERE*. These are not case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings may contain any of the following characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/326-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a string contains a double quote, use a single quote to wrap it. The string
    below is enclosed in single quotes since the string contains double quotes surrounding
    the *Hi mom!* substring.
  prefs: []
  type: TYPE_NORMAL
- en: '''The sign says "Hi mom!"'''
  prefs: []
  type: TYPE_NORMAL
- en: Use double quotes to wrap strings with embedded single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the SELECT command are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/326-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The UPDATE Command***](toc.html#app1.13)'
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE command writes values into a table. The prototype for the RTA UPDATE
    command is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/326-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An UPDATE invokes write callbacks on the affected columns. All data in the UPDATE_list
    is written before the callbacks are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The LIMIT clause for UPDATE is not standard PostgreSQL, but this clause can
    be useful for stepping through a table one row at a time. To change only the wth
    row of a table, use a limit clause like the one below. Note that *n* is zero indexed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/327-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**Internal RTA Tables**](toc.html#app1.14)'
  prefs: []
  type: TYPE_NORMAL
- en: When you use the RTA library, your application will include the following four
    RTA tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/327-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The rta_tables Table***](toc.html#app1.15)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_tables table gives SQL access to all internal and registered tables.
    The data in the table is exactly the same as the data in the TBLDEF structures
    registered with the rta_add_table() subroutine. This table is the generic table
    editor, which is used for application debugging. The columns in the rta_tables
    table are shown below and correspond to the fields in the RTA_TABLE data structure
    described above.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/327-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/328-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***The rta_columns Table***](toc.html#app1.16)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_columns table lists the column definitions for all the columns in the
    database. The data in the table is exactly the same as the data in the COLDEF
    structures registered with the rta_add_table() subroutine. This table is used
    for the generic table viewer and table editor applications, which are used mostly
    for application debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The columns in the rta_columns table are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/328-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**Debug Configuration**](toc.html#app1.17)'
  prefs: []
  type: TYPE_NORMAL
- en: The RTA package does not generates any user-level log messages, only debug messages.
    The rta_dbgconfig table specifies the handling of these debug log messages. All
    of the fields in this table are volatile. You need to set the values in your main
    program to make them seem persistent. See the sample SQL string subroutine below.
  prefs: []
  type: TYPE_NORMAL
- en: SQL_string("UPDATE rta_dbgconfig SET target = 3")
  prefs: []
  type: TYPE_NORMAL
- en: The columns in the rta_dbgconfig table are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/328-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/329-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**Error Messages**](toc.html#app1.18)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of error messages available in the RTA package: SQL request
    messages and internal debug messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '[***SQL Request Errors***](toc.html#app1.19)'
  prefs: []
  type: TYPE_NORMAL
- en: SQL request messages include the error messages returned as part of an SQL request.
    The six messages of this type are listed below.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: Relation ''%s'' does not exist'
  prefs: []
  type: TYPE_NORMAL
- en: This reply indicates that a table requested in a SELECT or UPDATE statement
    does not exist. The %s is replaced by the name of the requested table.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: Attribute ''%s'' not found'
  prefs: []
  type: TYPE_NORMAL
- en: This reply indicates that a column requested in a SELECT or UPDATE statement
    does not exist. The %s is replaced by the name of the requested column.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: SQL parse error'
  prefs: []
  type: TYPE_NORMAL
- en: This reply indicates a malformed SQL request or a mismatch in the types of data
    in a where clause or in an UPDATE list.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: Output buffer full'
  prefs: []
  type: TYPE_NORMAL
- en: This reply indicates that the size of the response to a request exceeds the
    size of the output buffer. (See dbcommand() and the out and nout parameters.)
    This error can be avoided with a large enough output buffer, or, preferably, with
    the use of LIMIT and OFFSET.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: String too long for ''%s'''
  prefs: []
  type: TYPE_NORMAL
- en: This reply indicates that an UPDATE to a column of type string or pointer to
    string would have exceeded the width of the column. The %s is replaced by the
    column name.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: Can not UPDATE read-only column ''%s'''
  prefs: []
  type: TYPE_NORMAL
- en: This reply indicates an attempt to UPDATE a column marked as readonly. The %s
    is replaced by the column name.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Internal Debug Messages***](toc.html#app1.20)'
  prefs: []
  type: TYPE_NORMAL
- en: The RTA program logs internal errors using the standard syslog() facility, which
    is available on all Linux systems. The default syslog() facility is LOG_USER,
    but you can change the default by setting facility in the rta_dbg table.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify syslogd in order to do post-processing, such as generating SNMP
    traps from these debug messages. The RTA program sends all internal debug error
    messages to syslog() in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rta[PID]: FILE LINE#: error_message'
  prefs: []
  type: TYPE_NORMAL
- en: The RTA program will replace PID, FILE, and LINE# with the process ID, the source
    filename, and the line number where the error was detected.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the definitions used to generate debug and error messages. The RTA
    program will replace %s %d at the start of each error string with the filename
    and line number where the error was detected.
  prefs: []
  type: TYPE_NORMAL
- en: '**System Errors**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/330-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**RTA Errors**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/331-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SQL Errors**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/331-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Trace Messages**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/331-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**Callback Routines**](toc.html#app1.21)'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, read callbacks are executed before a column value is used,
    and write callbacks are called after all columns have been UPDATEd. Both read
    and write callbacks return zero on success and nonzero on error.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Read Callbacks***](toc.html#app1.22)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read callbacks have the following calling parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/331-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Read callbacks are particularly useful for computing values like sums and averages.
    These values are not worth the effort to compute continuously if it’s possible
    to compute them only when the values are required.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Write Callbacks***](toc.html#app1.23)'
  prefs: []
  type: TYPE_NORMAL
- en: Write callbacks are most applicable when tied to configuration changes. As such,
    a write callback is also a good place to log configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Write callbacks have the same parameters as read callbacks, with the addition
    of a pointer to a copy of the row before it was modified. Access to a copy of
    the unmodified row is useful to detect changes in the row’s data. This is useful
    since some UIs can generate an UPDATE even if nothing actually changed.
  prefs: []
  type: TYPE_NORMAL
- en: The callback returns zero on success and nonzero on failure. On failure, the
    table’s row is restored to its initial values and an SQL error is returned to
    the client. The returned error is TRIGGERED ACTION EXCEPTION.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write callbacks have the following calling parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/332-1.jpg)'
  prefs: []
  type: TYPE_IMG
