- en: Chapter 23. Customizing OpenBSD
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第23章. 定制OpenBSD
- en: '*Customize installs*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*定制安装*'
- en: '*with files and DHCP,*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用文件和DHCP，*'
- en: '*then run without disk.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*然后无盘运行。*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) This chapter covers
    different ways to use OpenBSD to customize itself, as well as how to install OpenBSD
    in nonstandard situations and debug problems with your system. The first task
    we’ll address is diskless installation. Diskless systems are usually used to install
    OpenBSD without attaching any installation media, but they can also be used to
    run a system without a hard drive. Next, we’ll create a USB flash drive for use
    as OpenBSD installation media. Finally, we’ll cover various ways to customize
    the OpenBSD installation and upgrade processes.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](http://atomoreilly.com/source/nostarch/images/1616079.png) 这章介绍了使用OpenBSD来自定义自己的不同方法，以及如何在非标准情况下安装OpenBSD和调试系统问题。我们将要解决的第一项任务是无盘安装。无盘系统通常用于在不连接任何安装媒体的情况下安装OpenBSD，但它们也可以用于在没有硬盘的情况下运行系统。接下来，我们将创建一个USB闪存驱动器，用作OpenBSD安装媒体。最后，我们将介绍各种自定义OpenBSD安装和升级过程的方法。'
- en: All of these tasks assume that you already have an OpenBSD machine running the
    version you want to customize. You can accomplish some of these tasks using a
    virtual machine, as long as the virtual machine software has the necessary support.
    Because virtualization is such a common choice, let’s tackle it first.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都假设你已经有一个运行着你想要定制的版本的OpenBSD机器。只要虚拟机软件有必要的支持，你可以使用虚拟机来完成这些任务之一。由于虚拟化是一个常见的选项，让我们先来解决这个问题。
- en: Virtualizing OpenBSD
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化OpenBSD
- en: The OpenBSD developers are pretty clear on virtualization. OpenBSD is written
    for real hardware. Virtual hardware is not real hardware. While it can be very
    similar, it’s not exactly the same.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD的开发者对虚拟化非常明确。OpenBSD是为真实硬件编写的。虚拟硬件不是真实硬件。虽然它可以非常相似，但并不完全相同。
- en: This approach has a number of implications, the most problematic of which is
    that not all virtualization software can run OpenBSD. As I write this, Oracle’s
    VirtualBox can’t cleanly run either i386 or amd64 OpenBSD. (Some people report
    being able to boot some versions of VirtualBox and/or OpenBSD, but OpenBSD software
    crashes all over the place.) This is not an OpenBSD bug. VirtualBox doesn’t sufficiently
    emulate real hardware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个影响，其中最成问题的是，并非所有虚拟化软件都能运行OpenBSD。当我写这篇文章时，Oracle的VirtualBox无法干净地运行i386或amd64版本的OpenBSD。（有些人报告说能够启动某些版本的VirtualBox和/或OpenBSD，但OpenBSD软件到处崩溃。）这不是OpenBSD的bug。VirtualBox没有充分模拟真实硬件。
- en: That said, OpenBSD does run well on some virtual machines. VMware works well
    enough that OpenBSD includes specific drivers for VMware integration, including
    a VMware Tools driver in the kernel. KVM virtualization also works, although KVM
    requires some tweaks depending on the exact combination of KVM and OpenBSD you’re
    using. Microsoft’s virtualization mostly works, although Virtual PC has some commercially
    motivated limitations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，OpenBSD在某些虚拟机上运行得很好。VMware运行得足够好，以至于OpenBSD包括针对VMware集成的特定驱动程序，包括内核中的VMware
    Tools驱动程序。KVM虚拟化也工作，尽管KVM需要根据你使用的KVM和OpenBSD的确切组合进行一些调整。微软的虚拟化大部分工作，尽管Virtual
    PC有一些商业动机的限制。
- en: The main problem with virtualization is that a compromise of the virtualization
    platform automatically gives an intruder hardware-level access to all virtual
    machines, and OpenBSD cannot possibly secure you against that kind of attack.
    In fact, no operating system can. And it does you no good to run your database
    on OpenBSD when any script kiddie can compromise the underlying virtualization
    server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化的主要问题是，虚拟化平台的妥协会自动给入侵者提供对所有虚拟机的硬件级访问权限，而OpenBSD不可能保护你免受这种攻击。实际上，没有任何操作系统可以做到。当任何脚本小子都能妥协底层的虚拟化服务器时，在OpenBSD上运行数据库对你没有任何好处。
- en: In my experience, OpenBSD virtual machines are excellent for experimentation
    and reference. I used them to document the installation process for this book,
    and I always test software configurations on virtual machines before rolling them
    out to production. (The real benefit of virtualization might be that there’s no
    longer any excuse for not testing changes.) But when I want a server that’s actually
    secure, I put OpenBSD on real hardware.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，OpenBSD虚拟机非常适合实验和参考。我使用它们来记录这本书的安装过程，并且在将它们部署到生产之前，我总是在虚拟机上测试软件配置。（虚拟化的真正好处可能就是不再有任何借口不测试更改。）但是，当我需要一个真正安全的服务器时，我会将OpenBSD安装在真实硬件上。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to run virtual machines on OpenBSD, you can find `qemu`, `bochs`,
    `dosbox`, and other packages in the packages collection. Check */usr/ports/emulators*
    for other options.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 OpenBSD 上运行虚拟机，你可以在软件包集合中找到 `qemu`、`bochs`、`dosbox` 和其他软件包。检查 */usr/ports/emulators*
    以获取其他选项。
- en: Diskless Installation
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无盘安装
- en: Booting a blank system into the OpenBSD installer without using local media
    can save you time and energy. A lot of modern hardware doesn’t come with CD or
    floppy drives. Of course, you could temporarily add a CD drive, but if you have
    a whole bunch of OpenBSD machines to install, that’s just an annoyance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用本地媒体将空白系统引导到 OpenBSD 安装程序可以节省你的时间和精力。许多现代硬件都没有配备 CD 或软盘驱动器。当然，你可以临时添加一个 CD
    驱动器，但如果你要安装大量的 OpenBSD 机器，那只是个麻烦。
- en: You can also use network booting to boot OpenBSD on hardware that lacks an installed
    operating system, or with a different operating system that you plan to overwrite.
    This process is called *pxebooting*, or *diskless*, operation. Diskless systems
    can have disks—they just don’t use them to boot the operating system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用网络引导在缺少已安装操作系统的硬件上引导 OpenBSD，或者在与你计划覆盖的不同操作系统上。这个过程被称为 *pxebooting*，或
    *diskless* 操作。无盘系统可以有磁盘——只是它们不使用它们来引导操作系统。
- en: If you’ve never worked with diskless systems before, your first attempts will
    probably give you a headache. Setting up your first diskless environment can be
    tricky, and will teach you all sorts of things you didn’t know about your operating
    system and hardware. But test everything along the way, read the error messages
    carefully, and soon you’ll wonder why you thought this was hard.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过无盘系统，你的第一次尝试可能会让你头疼。设置你的第一个无盘环境可能会很棘手，这会教你许多关于你的操作系统和硬件的未知知识。但沿途测试一切，仔细阅读错误信息，很快你就会
    wonder why you thought this was hard.
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I’ll cover diskless installations on amd64 and i386 hardware. Other platforms
    have different requirements that may be very different. Read the `diskless(8)`
    man page for your particular architecture to get an overview of your platform.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍在 amd64 和 i386 硬件上的无盘安装。其他平台可能有不同的要求，可能非常不同。阅读 `diskless(8)` 手册页以获取你特定架构的平台概述。
- en: Diskless systems work because a computer doesn’t need a hard disk to run. It
    needs an operating system. The easiest way to store a computer’s operating system
    is on the local hard drive, but a sufficiently smart network card can use information
    provided by DHCP to find an initial boot loader.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无盘系统之所以能够工作，是因为计算机不需要硬盘来运行。它需要一个操作系统。存储计算机操作系统的最简单方法是在本地硬盘上，但足够智能的网络卡可以使用 DHCP
    提供的信息找到初始引导加载程序。
- en: All amd64 and modern i386 hardware use Intel’s Preboot Execution Environment
    (PXE, pronounced “pixie”). The DHCP server tells the network card the name of
    a file and the IP address where the file can be found, and the server fetches
    the file via TFTP. This file is usually called *pxeboot*, but *pxeboot* files
    can vary widely among operating systems. A *pxeboot* file for OpenBSD probably
    won’t boot a FreeBSD system, let alone anything from Microsoft. It’s specific
    to each operating system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 amd64 和现代 i386 硬件都使用 Intel 的预引导执行环境 (PXE，发音为“pixie”）。DHCP 服务器告诉网卡文件的名称和可以找到该文件的
    IP 地址，服务器通过 TFTP 获取该文件。这个文件通常被称为 *pxeboot*，但 *pxeboot* 文件在不同的操作系统之间可能会有很大的差异。OpenBSD
    的 *pxeboot* 文件可能无法引导 FreeBSD 系统，更不用说微软的任何系统了。它是针对每个操作系统的。
- en: Once the computer has loaded *pxeboot*, it goes back to the TFTP server to look
    for the appropriate kernel. An OpenBSD *pxeboot* looks for a file called *bsd*,
    assumes that it’s a kernel, loads the kernel into memory, and boots it. To install
    OpenBSD, you’ll load the install kernel file *bsd.rd* instead, which you can do
    automatically.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算机加载了 *pxeboot*，它就会回到 TFTP 服务器去寻找适当的内核。一个 OpenBSD *pxeboot* 会寻找一个名为 *bsd*
    的文件，假设它是一个内核，将内核加载到内存中，并启动它。要安装 OpenBSD，你需要加载安装内核文件 *bsd.rd*，这可以自动完成。
- en: Diskless Hardware
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无盘硬件
- en: OpenBSD systems installed over diskless systems must have enough smarts to find
    their boot loader and operating system over the network or they won’t boot. Any
    machine built in the past several years uses PXE.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在无盘系统上安装的 OpenBSD 系统必须足够聪明，能够在网络上找到其引导加载程序和操作系统，否则它们将无法启动。过去几年内制造的任何机器都使用 PXE。
- en: You’ve probably seen a computer try to boot from the network more than once,
    and for most people, those BIOS messages are just an annoyance that they keep
    forgetting to disable. For diskless installation, you need to make sure that feature
    is on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到过一台计算机多次尝试从网络启动，对于大多数人来说，这些 BIOS 信息只是他们不断忘记禁用的烦恼。对于无盘安装，你需要确保该功能是开启的。
- en: To enable PXE, boot the hardware and go into the BIOS setup. Somewhere in the
    BIOS, you should find an option to set the device boot order. If the machine supports
    PXE, one of those options will be to boot over a network. Enable that option and
    see if it works. While you’re in the BIOS, make a note of the MAC address of your
    network card. Your DHCP server will need it. If your BIOS uses the Unified Extensible
    Firmware Interface (UEFI) by default, disable that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 PXE，请启动硬件并进入 BIOS 设置。在 BIOS 中，你应该找到一个设置设备启动顺序的选项。如果机器支持 PXE，其中之一将是通过网络启动。启用该选项并查看是否可行。当你在
    BIOS 中时，记下你的网络卡的 MAC 地址。你的 DHCP 服务器将需要它。如果你的 BIOS 默认使用统一可扩展固件接口 (UEFI)，请禁用它。
- en: Save your changes and exit. Your hardware should now be prepared. Let’s ready
    the server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的更改并退出。现在你的硬件应该已经准备好了。让我们准备服务器。
- en: DHCP Server Setup
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DHCP 服务器设置
- en: DHCP is not just a way to hand out IP addresses and network configurations.
    A DHCP server can tell network-aware phones where to find their configuration,
    server hardware where to find its operating system, printers where to find their
    print server, and so on. Diskless installations use DHCP to feed diskless servers
    the location of the *pxeboot* file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP 不仅仅是分发 IP 地址和网络配置的方式。DHCP 服务器可以告诉网络感知的电话在哪里找到它们的配置，服务器硬件在哪里找到它的操作系统，打印机在哪里找到它们的打印服务器，等等。无盘安装使用
    DHCP 向无盘服务器提供 *pxeboot* 文件的存储位置。
- en: Per-Host or Per-Network Configuration
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个主机或每个网络的配置
- en: DHCP expects to configure hosts either by the network or by the host. When a
    DHCP server receives a DHCP request, it knows the address of the network that
    the host is on and the host’s MAC address. The DHCP server must decide which configuration
    to give the host based on this information. This means you can configure your
    DHCP server so that any host on a given network is told to install OpenBSD, or
    you can give it the MAC address of the machine you’re going to install and tell
    the DHCP server to start the installation only on that machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP 期望通过网络或主机配置主机。当 DHCP 服务器收到 DHCP 请求时，它知道主机所在的网络地址和主机的 MAC 地址。根据这些信息，DHCP
    服务器必须决定向主机提供哪种配置。这意味着你可以配置你的 DHCP 服务器，以便给定网络上的任何主机都被告知安装 OpenBSD，或者你可以给出你将要安装的机器的
    MAC 地址，并告诉 DHCP 服务器只在该机器上启动安装。
- en: Because I install machines frequently, I usually set up a small VLAN where any
    machine plugged onto the network is told to install OpenBSD. That way, workers
    who plug their laptops into random Ethernet cables in my office get a free operating
    system upgrade. If you only occasionally install machines, and have control over
    the DHCP server, it’s pretty easy to configure the DHCP server to tell a host
    with a specific MAC address to install OpenBSD.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我经常安装机器，我通常设置一个小型 VLAN，任何连接到网络的机器都会被告知安装 OpenBSD。这样，把他们的笔记本电脑插入我办公室随机以太网线的员工就可以免费升级操作系统。如果你只是偶尔安装机器，并且控制
    DHCP 服务器，配置 DHCP 服务器告诉具有特定 MAC 地址的主机安装 OpenBSD 非常容易。
- en: The DHCP server needs to tell the client the location of a PXE boot file, which
    gives the client just enough brains to find a bootable kernel. This is just like
    the on-disk boot loader, except that the PXE boot file talks to the network. OpenBSD’s
    i386 and amd64 platforms include the file */usr/mdec/pxeboot* for just this purpose.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP 服务器需要告诉客户端 PXE 启动文件的存储位置，这给客户端足够的智能来找到可引导的内核。这就像磁盘上的引导加载器一样，只不过 PXE 启动文件是与网络通信。OpenBSD
    的 i386 和 amd64 平台包括文件 */usr/mdec/pxeboot*，就是为了这个目的。
- en: 'Give the name of the PXE boot file with the `filename` option, and then use
    the `next-server` option to specify the IP address of the TFTP server where the
    client can get the file. This example tells DHCP clients to load the file *pxeboot*
    from the server at 192.0.2.34:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `filename` 选项给出 PXE 启动文件的名称，然后使用 `next-server` 选项指定客户端可以获取文件的 TFTP 服务器的 IP
    地址。此示例告诉 DHCP 客户端从 IP 地址为 192.0.2.34 的服务器加载文件 *pxeboot*：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Place these statements according to whether you have an installation network
    or your DHCP server is set for a specific MAC address.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是否有一个安装网络或你的 DHCP 服务器设置为特定的 MAC 地址，放置这些语句。
- en: Per-Network Configuration
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个网络的配置
- en: 'If you want all the hosts on your network to receive the OpenBSD installation
    PXE boot file, put the `filename` and `next-server` options in the `subnet` stanza,
    like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让网络上的所有主机都能接收到OpenBSD安装的PXE启动文件，请在`subnet`段落中放置`filename`和`next-server`选项，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any host on this network that makes a DHCP request at boot will learn where
    to get the PXE boot file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上任何在启动时发出DHCP请求的主机都会学习到获取PXE启动文件的位置。
- en: Per-Machine Configuration
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每台机器的配置
- en: If you’ve hard-coded a machine’s MAC address into your DHCP configuration, as
    discussed in [Chapter 16](ch16.html "Chapter 16. Network Servers"), you can feed
    the PXE boot information to that host.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在[第16章](ch16.html "第16章。网络服务器")中讨论的DHCP配置中将机器的MAC地址硬编码，您可以向该主机提供PXE启动信息。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Machines on this subnet that make a PXE request at boot will get the location
    of the PXE boot file only if they have MAC address 02:03:04:05:06:07.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在此子网上启动时发出PXE请求的机器只有在它们具有MAC地址02:03:04:05:06:07时才能获得PXE启动文件的位置。
- en: Decide how you want your DHCP server to behave and make similar configuration
    changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 决定您希望您的DHCP服务器如何行为，并做出类似的配置更改。
- en: Now let’s look at the TFTP server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看TFTP服务器。
- en: TFTP Server Setup
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TFTP服务器设置
- en: The next task is to make the OpenBSD-specific boot files available on your TFTP
    server. As a minimum, you need the *pxeboot* file and a kernel, but adding a *boot.conf*
    file will simplify your life.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是使OpenBSD特定的启动文件在您的TFTP服务器上可用。至少，您需要*pxeboot*文件和一个内核，但添加一个*boot.conf*文件将简化您的工作。
- en: OpenBSD includes an architecture-specific *pxeboot* file in */usr/mdec/*. If
    you’re installing an i386 machine, grab this file and */bsd.rd* from an existing
    i386 installation. If you’re installing amd64 hardware, get *pxeboot* and */bsd.rd*
    from an existing amd64 system. Copy them to the TFTP server root directory, and
    verify that they’re world-readable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD在`/usr/mdec/`中包含一个特定于架构的*pxeboot*文件。如果您正在安装i386机器，从现有的i386安装中获取此文件和`/bsd.rd`。如果您正在安装amd64硬件，从现有的amd64系统中获取*pxeboot*和`/bsd.rd`。将它们复制到TFTP服务器的根目录，并验证它们是否对所有用户可读。
- en: '*pxeboot* tells the machine to look for the standard kernel */bsd*, not the
    installation kernel */bsd.rd*. When *pxeboot* finishes loading, it looks exactly
    like the standard OpenBSD boot loader. You could interrupt the boot, as described
    in [Chapter 5](ch05.html "Chapter 5. The Boot Process"), and choose a different
    kernel, but *pxeboot* also recognizes */etc/boot.conf*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*pxeboot*告诉机器查找标准内核*/bsd*，而不是安装内核*/bsd.rd*。当*pxeboot*加载完成后，它看起来就像标准的OpenBSD引导加载程序。您可以像在[第5章](ch05.html
    "第5章。引导过程")中描述的那样中断引导，并选择不同的内核，但*pxeboot*也识别`/etc/boot.conf`。'
- en: 'To tell *pxeboot* to load a different kernel, create an *etc* directory in
    your TFTP server’s root directory, and then create the file *boot.conf* inside
    that. This new *boot.conf* file has exactly the same syntax as */etc/boot.conf*,
    so you can do a one-line entry like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉*pxeboot*加载不同的内核，在您的TFTP服务器根目录中创建一个*etc*目录，然后在其中创建*boot.conf*文件。这个新的*boot.conf*文件与`/etc/boot.conf`具有完全相同的语法，因此您可以进行如下一行条目：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can include additional boot options, such as setting a serial console.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以包括额外的启动选项，例如设置串行控制台。
- en: Completing Diskless Installation
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成无盘安装
- en: Once you have DHCP and TFTP, power on the installation target. You should see
    the network card make a DHCP request, get an IP address, and grab *pxeboot* via
    TFTP. You should then see the OpenBSD boot loader load the installation *bsd.rd*.
    Finally, you should get the OpenBSD install script.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了DHCP和TFTP，打开安装目标。您应该看到网卡发出DHCP请求，获取IP地址，并通过TFTP获取*pxeboot*。然后您应该看到OpenBSD引导加载程序加载安装的*bsd.rd*。最后，您应该获得OpenBSD安装脚本。
- en: If you don’t get the installer, take a step back. Does the network card get
    an address from DHCP? If not, check your wiring and DHCP server configuration.
    If you get an IP address, but can’t fetch *pxeboot*, check that you put the `filename`
    and `next-server` statements in the correct part of your DHCP configuration, and
    verify that you don’t have a packet filter blocking access to the TFTP server.
    Try to fetch those files from a different TFTP client to make sure that the TFTP
    server works. If the installation target partially boots OpenBSD, but doesn’t
    activate the installer, make sure you have an *etc/boot.conf* entry pointing the
    client at *bsd.rd* rather than *bsd*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有获取到安装程序，请退一步。网卡是否从DHCP获取地址？如果不是，检查你的布线和DHCP服务器配置。如果你获取了IP地址，但不能获取*pxeboot*，请确保你在DHCP配置的正确部分放置了`filename`和`next-server`语句，并验证你没有包过滤器阻止对TFTP服务器的访问。尝试从不同的TFTP客户端获取这些文件，以确保TFTP服务器工作正常。如果安装目标部分启动了OpenBSD，但没有激活安装程序，请确保你有指向*bsd.rd*而不是*bsd*的*etc/boot.conf*条目。
- en: At this point, you should be able to install OpenBSD normally, as described
    in [Chapter 2](ch02.html "Chapter 2. Installation Preparations") and [Chapter 3](ch03.html
    "Chapter 3. Installation Walk-Through"). But what if you want to run a full OpenBSD
    system without a hard drive? That’s where diskless operation comes in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该能够按照[第2章](ch02.html "第2章。安装准备")和[第3章](ch03.html "第3章。安装过程")中描述的方法正常安装OpenBSD。但是，如果你想在没有硬盘的情况下运行完整的OpenBSD系统呢？这就是无盘操作的作用所在。
- en: Running Diskless
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行无盘系统
- en: If you manage many computers, you probably understand that moving parts cause
    trouble. Spinning hard drives, in particular, are just a very bad idea.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你管理许多计算机，你可能理解到移动部件会带来麻烦。特别是旋转硬盘，这只是一个非常糟糕的想法。
- en: 'Try this: If you have a roomful of identical machines, try simplifying maintenance
    by running them without hard drives. Each machine in this group will use a root
    directory and filesystem mounted via NFS rather than stored locally. You’ll still
    need data storage, but you can use a central high-availability disk array, flash
    drives, or some other mechanism with better reliability than lowest-common-denominator
    hard drives.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这样做：如果你有一间满是相同机器的房间，尝试通过不使用硬盘来简化维护。这个组中的每台机器将使用通过NFS挂载的根目录和文件系统，而不是本地存储。你仍然需要数据存储，但可以使用一个中央高可用磁盘阵列、闪存驱动器或一些其他机制，其可靠性比最低标准的硬盘更好。
- en: 'You can extend the diskless installation process to run OpenBSD in full multiuser
    mode without a local hard drive. Your server will need three additional services
    to support fully diskless clients: `rarpd(8)`, `bootparamd(8)`, and NFS. (Only
    diskless clients need `rarpd` and `bootparamd`.)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将无盘安装过程扩展到在没有本地硬盘的情况下以全多用户模式运行OpenBSD。你的服务器将需要三个额外的服务来支持完全无盘客户端：`rarpd(8)`、`bootparamd(8)`和NFS。（只有无盘客户端需要`rarpd`和`bootparamd`。）
- en: Using rarpd(8) for Reverse ARP
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`rarpd(8)`进行反向ARP
- en: In a standard ARP request, a client knows an IP address and wants to get the
    corresponding MAC address. For reverse ARP, a client knows a MAC address and wants
    to know the corresponding IP address. OpenBSD needs to get reverse ARP during
    the diskless boot process, and it uses `rarpd(8)` to provide reverse ARP services
    to other hosts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的ARP请求中，客户端知道一个IP地址，并想要获取相应的MAC地址。对于反向ARP，客户端知道一个MAC地址，并想要知道相应的IP地址。OpenBSD需要在无盘启动过程中获取反向ARP，它使用`rarpd(8)`为其他主机提供反向ARP服务。
- en: '`rarpd` uses */etc/ethers* as a table of Ethernet addresses and hostnames.
    Each diskless client needs an */etc/ethers* entry much like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`rarpd`使用`/etc/ethers`作为以太网地址和主机名的表格。每个无盘客户端需要一个类似于以下的`/etc/ethers`条目：'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This entry means that the host with MAC address 00:50:56:00:01:01 has the hostname
    *gill.blackhelicopters.org*. The `rarpd` server must be able to resolve the hostname
    to an IP address, either in DNS or in */etc/hosts*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目意味着MAC地址为00:50:56:00:01:01的主机的主机名为*gill.blackhelicopters.org*。`rarpd`服务器必须能够将主机名解析为IP地址，无论是在DNS中还是在`/etc/hosts`中。
- en: Now decide which network interfaces you want to run `rarpd` on. If your server
    has only one network interface, that’s the one to use. If you have multiple network
    interfaces, however, it might make sense to listen on only a single interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在决定你想要在哪个网络接口上运行`rarpd`。如果你的服务器只有一个网络接口，那么就使用它。然而，如果你有多个网络接口，可能只监听一个接口是有意义的。
- en: 'To use a specific interface, use the interface name as a command-line argument;
    otherwise, use `-a` to listen on all network interfaces. For example, this *rc.conf.local*
    entry tells `rarpd` to listen on only interface `em0`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用特定的接口，请使用接口名称作为命令行参数；否则，使用 `-a` 以监听所有网络接口。例如，此 *rc.conf.local* 条目指示 `rarpd`
    仅在接口 `em0` 上监听：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Start `rarpd` with */etc/rc.d/rarpd*, and go on to `bootparamd`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 */etc/rc.d/rarpd* 启动 `rarpd`，然后继续 `bootparamd`。
- en: Running bootparamd(8)
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 bootparamd(8)
- en: The boot parameter daemon `bootparamd` tells a diskless OpenBSD machine where
    to find its root filesystem. When a boot parameter request arrives at the server,
    `bootparamd` checks the file */etc/bootparams* for a matching configuration and
    returns that to the client.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 启动参数守护进程 `bootparamd` 告诉无盘 OpenBSD 机器其根文件系统的位置。当启动参数请求到达服务器时，`bootparamd` 会检查
    */etc/bootparams* 文件以查找匹配的配置，并将其返回给客户端。
- en: Entries in */etc/bootparams* give a hostname, followed by the string `root=`,
    an NFS server, and the directory where the client’s root directory is stored.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/bootparams* 中的条目给出一个主机名，后跟字符串 `root=`，一个 NFS 服务器，以及客户端根目录存储的目录。'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the host *gill.blackhelicopters.org* will use an NFS root directory
    from a server at 192.0.2.34, in the directory */var/diskless/client1*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，主机 *gill.blackhelicopters.org* 将使用来自 IP 地址 192.0.2.34 的服务器的 NFS 根目录，在目录
    */var/diskless/client1* 中。
- en: 'For almost all environments, you can run `bootparamd` without any command-line
    options. Enable it in *rc.conf.local* like so:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有环境，您可以在没有任何命令行选项的情况下运行 `bootparamd`。像这样在 *rc.conf.local* 中启用它：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Start `bootparamd`. Now it’s time to deal with your NFS server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 `bootparamd`。现在是你处理你的 NFS 服务器的时候了。
- en: Setting Up the NFS Root Directory
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 NFS 根目录
- en: A multiuser OpenBSD system needs a userland. Without a local disk, you’ll need
    to create an OpenBSD userland. It is possible to export the NFS server’s root
    directory for use as the diskless client’s root directory, but this isn’t merely
    insecure, it’s also a good way to damage the NFS server itself. Create a separate
    userland for your diskless machine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多用户 OpenBSD 系统需要一个用户空间。没有本地磁盘，您需要创建一个 OpenBSD 用户空间。可以将 NFS 服务器的根目录导出以用作无盘客户端的根目录，但这不仅是不安全的，而且也是损坏
    NFS 服务器的良好方式。为您的无盘机器创建一个单独的用户空间。
- en: Exporting the Root Directory
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导出根目录
- en: 'You must export the userland’s root directory to the diskless machine. For
    example, here’s an */etc/exports* line that shares the directory */var/diskless/client1*
    to the IP address 192.0.2.37:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将用户空间的根目录导出到无盘机器。例如，以下是一个 */etc/exports* 行，它将目录 */var/diskless/client1* 共享到
    IP 地址 192.0.2.37：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the `-maproot` option here. The diskless client will expect to be able
    to write and own files as the root user. This `-maproot` entry maps UID 0 (root)
    on the client to the root account on the NFS server. You can also set up a separate
    user for the diskless client’s root account, map the client’s root account to
    that new account, and change the ownership of all files in the diskless userland
    to that root account. As this is your first diskless host, however, we’ll start
    off basic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的 `-maproot` 选项。无盘客户端期望能够以 root 用户身份写入和拥有文件。此 `-maproot` 条目将客户端的 UID 0（root）映射到
    NFS 服务器的 root 账户。您还可以为无盘客户端的 root 账户设置一个单独的用户，将客户端的 root 账户映射到该新账户，并将无盘用户空间中所有文件的拥有权更改为该
    root 账户。但是，由于这是您的第一个无盘主机，我们将从基本开始。
- en: Populating the Diskless Userland
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 填充无盘用户空间
- en: The easy way to install a minimal userland is to extract the *etcXX.tgz* and
    *baseXX.tgz* file sets from your chosen OpenBSD release into the NFS root directory.
    In the following example, I’ve copied these file sets into */tmp*, and I’m using
    them to create a userland in */var/diskless/client1*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安装最小用户空间的最简单方法是提取您选择的 OpenBSD 版本的 *etcXX.tgz* 和 *baseXX.tgz* 文件集到 NFS 根目录。在以下示例中，我已经将这些文件集复制到
    */tmp*，并使用它们在 */var/diskless/client1* 中创建用户空间。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the use of the `-p` flag in the `tar` command, preserving the original
    permissions on extracted files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `tar` 命令中使用 `-p` 标志，以保留提取文件的原始权限。
- en: The diskless client also needs device nodes. Go into the new userland’s *dev*
    directory and create them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无盘客户端还需要设备节点。进入新用户空间的 *dev* 目录并创建它们。
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While `bootparamd` told the kernel where to find the root of the filesystem,
    userland programs expect to read */etc/fstab* for that information. Create an
    */etc/fstab* file that points the root directory to your NFS share.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `bootparamd` 告诉内核文件系统的根位置，但用户空间程序期望读取 */etc/fstab* 来获取该信息。创建一个 */etc/fstab*
    文件，将根目录指向您的 NFS 共享。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can also add any other NFS-mounted directories you desire here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在此处添加任何其他所需的NFS挂载目录。
- en: This should be everything you need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就是您需要的一切。
- en: Power On!
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开机！
- en: Once you have a basic userland, device nodes, and a filesystem table, you can
    power on your diskless node, and it should boot. If it doesn’t boot to a login
    prompt, read the console error messages. Usually, they’re pretty clear.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个基本用户空间、设备节点和文件系统表，您就可以开启无盘节点，它应该会启动。如果它没有启动到登录提示符，请阅读控制台错误消息。通常，它们非常清晰。
- en: Because you’ve bypassed the OpenBSD installer, there are no root password or
    user accounts yet. Immediately, log in as root and change the root password, and
    then set up a regular user account.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您绕过了OpenBSD安装程序，目前还没有root密码或用户账户。立即以root身份登录并更改root密码，然后设置一个普通用户账户。
- en: For your first diskless setup, once you have a working userland, back it up
    right away. Even a tar file containing the entire userland will prove useful.
    You’ll muck up the diskless userland more than once as you’re trying to get things
    working exactly as you wish, and being able to blow the entire userland away and
    restore it from the backup file is invaluable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的第一个无盘设置，一旦您有一个工作的用户空间，立即备份它。即使是一个包含整个用户空间的tar文件也将非常有用。在您试图将一切设置得尽可能完美时，您可能会多次弄乱无盘用户空间，能够将整个用户空间全部删除并从备份文件中恢复是非常宝贵的。
- en: Once you have a basic system working, expand it. Add additional file sets as
    needed, set up more users, add packages, and deploy for your users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个基本系统运行，就可以扩展它。根据需要添加额外的文件集，设置更多用户，添加软件包，并为您的用户部署。
- en: Congratulations, you’re now on the cutting edge of OpenBSD users.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您，现在您已经成为OpenBSD用户的尖端用户。
- en: USB Installation Media
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USB安装介质
- en: For many people, burning a CD to install an operating system seems like a waste.
    They prefer to write an image to a USB flash drive and install from that. OpenBSD
    doesn’t provide such an image, but if you’re willing to do some extra work, you
    can create a bootable USB device that you can use to install on your target hardware.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，烧录CD来安装操作系统似乎是一种浪费。他们更喜欢将镜像写入USB闪存驱动器并从那里安装。OpenBSD不提供这样的镜像，但如果您愿意做一些额外的工作，您可以创建一个可引导的USB设备，用于在目标硬件上安装。
- en: The official recommendation is to install OpenBSD on the USB device, copy *bsd.rd*
    and the file sets to that device, and use that to install your new hardware. The
    OpenBSD installer lets you choose the target hard drive. You select the USB device
    in the installer, and OpenBSD installs to the USB just as it would any other data-storage
    device. But how do you install OpenBSD on the USB device without burning a CD
    in the first place? There are a few ways around this, including a couple of approaches
    already covered in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 官方建议是在USB设备上安装OpenBSD，将*bsd.rd*文件和文件集复制到该设备，并使用它来安装新硬件。OpenBSD安装程序允许您选择目标硬盘驱动器。在安装程序中选择USB设备，OpenBSD将像对待任何其他数据存储设备一样安装到USB上。但您如何在最初不烧录CD的情况下在USB设备上安装OpenBSD呢？有几种方法可以解决这个问题，包括本章中已经介绍的一些方法。
- en: Using a Virtual Machine
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用虚拟机
- en: Your first choice is to perform the USB installation in a virtual machine. Many
    desktop virtual machine software packages let you attach a physical USB port to
    a guest virtual machine. (OpenBSD’s virtualization options are discussed in [Virtualizing
    OpenBSD](ch23.html#virtualizing_openbsd "Virtualizing OpenBSD").)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个选择是在虚拟机中执行USB安装。许多桌面虚拟机软件包允许您将物理USB端口连接到虚拟机。 (OpenBSD的虚拟化选项在[虚拟化OpenBSD](ch23.html#virtualizing_openbsd
    "虚拟化OpenBSD")中讨论。)
- en: If you have virtualization software that runs OpenBSD and supports USB, choose
    this option.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有运行OpenBSD并支持USB的虚拟化软件，请选择此选项。
- en: Running a Diskless Installation
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行无盘安装
- en: Your second choice is to run a diskless installation. Most DHCP servers embedded
    in cheap home hardware will let you send a filename and a TFTP server address
    to a client. If yours won’t, you can get suitable DHCP servers for any platform.
    You can find freely available TFTP servers for just about any operating system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第二个选择是运行无盘安装。大多数嵌入在廉价家用硬件中的DHCP服务器都会允许您向客户端发送一个文件名和一个TFTP服务器地址。如果您的服务器不支持，您可以为任何平台获取合适的DHCP服务器。您几乎可以在任何操作系统上找到免费提供的TFTP服务器。
- en: 'Boot your install target with the USB drive, but load the *bsd.rd* kernel.
    You now have the OpenBSD installer running on the target system, and an OpenBSD
    system that fits in your pocket and that you can run almost anywhere. If you’re
    already running OpenBSD on something with the right architecture and a USB socket,
    it’s even easier: You boot the system from the appropriate *bsd.rd*, choose the
    `disk` option, and point the installer to sets in a local directory.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 USB 驱动器启动安装目标，但加载 *bsd.rd* 内核。你现在在目标系统上运行了 OpenBSD 安装程序，并且有一个可以放在口袋里、几乎在任何地方都可以运行的
    OpenBSD 系统。如果你已经在具有正确架构和 USB 插座的设备上运行了 OpenBSD，那就更容易了：从适当的 *bsd.rd* 启动系统，选择 `disk`
    选项，并将安装程序指向本地目录中的集合。
- en: Converting ISO Images
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换 ISO 镜像
- en: As a less official method, you can find software to convert ISO images to bootable
    USB images. I’ve used Rufus (*[http://rufus.akeo.ie/](http://rufus.akeo.ie/)*)
    on Windows and UNetbootin (*[http://unetbootin.sourceforge.net/](http://unetbootin.sourceforge.net/)*)
    on other Unix-like systems. This approach might work, but it’s certainly not OpenBSD-approved.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种不那么正式的方法，你可以找到将 ISO 镜像转换为可启动 USB 镜像的软件。我在 Windows 上使用了 Rufus (*[http://rufus.akeo.ie/](http://rufus.akeo.ie/)*)，在其他类
    Unix 系统上使用了 UNetbootin (*[http://unetbootin.sourceforge.net/](http://unetbootin.sourceforge.net/)*)。这种方法可能有效，但绝对不是
    OpenBSD 推荐的。
- en: Customizing OpenBSD Installations
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 OpenBSD 安装
- en: Many of us follow a set of steps when installing a machine. All freshly installed
    hosts of a specific operating system revision have a common SSH server configuration.
    My machines all have `tcsh` installed and attach to the central authentication
    system. You probably have your own list. These tasks can be done by hand after
    installation, but it’s much easier to let OpenBSD do them for you during the installation
    process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人安装机器时都会遵循一系列步骤。所有刚刚安装的特定操作系统版本的宿主机都有一个共同的 SSH 服务器配置。我的机器都安装了 `tcsh` 并连接到中央认证系统。你可能有自己的列表。这些任务可以在安装后手动完成，但让
    OpenBSD 在安装过程中为你完成这些任务会容易得多。
- en: Installations can be customized by adding files during installation or by running
    commands after the installation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可以通过在安装过程中添加文件或在安装后运行命令来自定义。
- en: Custom File Sets
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义文件集
- en: A custom file set includes files that you want copied to your new installation.
    I use custom file sets to install the default */etc/sudoers*, a SSH server configuration,
    my company’s default *pf.conf*, and similar files. As I’m the lead sysadmin, I
    also include dotfiles in my home directory and other personal touches to make
    my life easier. Some people include several home directories, including *authorized_keys*
    files for SSH.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义文件集包括你想要复制到新安装中的文件。我使用自定义文件集来安装默认的 */etc/sudoers*、SSH 服务器配置、我公司的默认 *pf.conf*
    以及类似文件。作为主要系统管理员，我还包括我的主目录中的 dotfiles 和其他个人化细节，以使我的生活更轻松。有些人包括多个主目录，包括 SSH 的 *authorized_keys*
    文件。
- en: Bundle these files together as a *siteXX.tgz* file, which the installer can
    extract in the root directory of the new installation. (Be sure to replace the
    *XX* with the OpenBSD version you’re installing on; for example, name a *siteXX.tgz*
    file for OpenBSD 5.4 *site54.tgz*.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些文件打包成一个 *siteXX.tgz* 文件，安装程序可以在新安装的根目录中提取它。（请确保将 *XX* 替换为你要安装的 OpenBSD 版本；例如，为
    OpenBSD 5.4 命名一个 *site54.tgz* 文件。）
- en: Start by installing an OpenBSD machine of the exact same version and platform
    that you want to customize. Make your changes and add your files to this system,
    verify that this template system works exactly as you desire, and then copy the
    changed files to a tar file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装一个与你想要定制的版本和平台完全相同的 OpenBSD 机器。进行更改并将你的文件添加到这个系统中，验证这个模板系统是否完全符合你的需求，然后将更改后的文件复制到
    tar 文件中。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You could make a directory hierarchy and copy the files you want to it, but
    I find that to be more error-prone. A small virtual machine will let you build
    a *siteXX.tgz* file more reliably.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个目录层次结构并将你想要的文件复制到其中，但我发现这样做更容易出错。一个小型虚拟机可以让你更可靠地构建 *siteXX.tgz* 文件。
- en: The following example creates a *site54.tar* file containing one file, */etc/ssh/sshd_config*.
    Note that I start by creating a plain tar file. Since I can’t easily add files
    to a compressed tar file, I’ll need to compress the file after it’s complete.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个包含一个文件 */etc/ssh/sshd_config* 的 *site54.tar* 文件。请注意，我首先创建了一个普通的 tar
    文件。由于我无法轻松地将文件添加到压缩的 tar 文件中，我需要在文件完成后对其进行压缩。
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that I have the initial file, I can add additional files. I’ve customized
    a few files on the system, as well as added new ones, all of which I add to the
    *site54.tar* file. The `-r` flag tells `tar` to add a file to an archive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了初始文件，我可以添加额外的文件。我已经对系统上的几个文件进行了定制，并添加了新的文件，所有这些都添加到 *site54.tar* 文件中。`-r`
    标志告诉 `tar` 将文件添加到归档中。
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s how to compress the tar file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何压缩 tar 文件的方法：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I’ve built my own custom release of OpenBSD, so I have a local FTP server that
    contains all of the release files. If you’re using the official OpenBSD release,
    but you’re installing enough OpenBSD machines to warrant making a *siteXX.tgz*
    file, you can copy the official release to a local FTP or HTTP mirror. Copy your
    *siteXX.tgz* file to this directory and update the *index.txt* file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经构建了自己的 OpenBSD 定制版本，因此我有一个包含所有发布文件的本地 FTP 服务器。如果你使用的是官方 OpenBSD 发布版，但安装了足够多的
    OpenBSD 机器，需要创建一个 *siteXX.tgz* 文件，你可以将官方发布版复制到本地 FTP 或 HTTP 镜像。将你的 *siteXX.tgz*
    文件复制到这个目录，并更新 *index.txt* 文件。
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now start your installation. Tell the installer to use your local release mirror
    rather than an official OpenBSD mirror. You should see the following sets:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始你的安装。告诉安装程序使用你的本地发布镜像而不是官方 OpenBSD 镜像。你应该能看到以下集合：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Your *site54.tgz* file should now be available as a file set. Add it because
    the installer won’t automatically include it. Once the installation finishes,
    you should find your customized and added files on the new system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 *site54.tgz* 文件现在应该作为一个文件集可用。添加它，因为安装程序不会自动包含它。一旦安装完成，你应该能在新系统中找到你定制的和添加的文件。
- en: Post-Install Shell Scripts
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装后 Shell 脚本
- en: Some tasks can be accomplished by copying files, but that’s annoying. For example,
    I want the shell `tcsh` installed on all of my OpenBSD servers. I could put all
    the files in the `tcsh` package, as well as the contents of */var/db/pkg/tcsh*,
    in *siteXX.tgz*, but I know I’m likely to mess that up somehow. It would be much
    easier to run `pkg_add tcsh` after the installation, and let OpenBSD do what it’s
    supposed to do. That’s where the `install.site` script comes in.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一些任务可以通过复制文件来完成，但这很麻烦。例如，我想在我的所有 OpenBSD 服务器上安装 shell `tcsh`。我可以在 `tcsh` 软件包中放置所有文件，以及
    */var/db/pkg/tcsh* 的内容，到 *siteXX.tgz* 中，但我知道我可能会以某种方式搞砸。在安装后运行 `pkg_add tcsh`
    会容易得多，让 OpenBSD 做它应该做的事情。这就是 `install.site` 脚本的作用所在。
- en: After completing the installation, but before giving you the final command prompt,
    OpenBSD checks for */install.site*. If this file exists, the installer runs it.
    The script is run `chroot`ed into the new installed system, so you don’t need
    to worry about changing any paths. The script does need to run on a minimal kernel,
    however, so it’s best to wait for low-level kernel twiddling until the first real
    boot.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成安装但在给出最终命令提示之前，OpenBSD 会检查 */install.site* 文件。如果此文件存在，安装程序会运行它。脚本在 `chroot`
    中运行到新安装的系统，所以你不需要担心更改任何路径。然而，脚本需要在最小内核上运行，所以最好在第一次真实启动之前等待低级内核调整。
- en: 'Here’s a sample `install.site` script that installs the two packages `tcsh`
    and `python`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例 `install.site` 脚本，它安装了两个软件包 `tcsh` 和 `python`：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When working with `install.site` scripts, if a package’s name could be ambiguous,
    be sure to give the full package name. There’s only one `tcsh` package, but Python
    comes in several versions. I specify the full package name, rather than using
    plain `python`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 `install.site` 脚本时，如果软件包的名称可能不明确，请确保给出完整的软件包名称。只有一个 `tcsh` 软件包，但 Python
    有几个版本。我指定了完整的软件包名称，而不是使用普通的 `python`。
- en: Also note that while you’re running in a `chroot` that contains a full userland,
    that userland isn’t fully initialized. When dropping into the `chroot`, OpenBSD
    doesn’t do a full multiuser startup of that `chroot`. The environment is roughly
    equivalent to single-user mode. The `install.site` script is not where you initialize
    your database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当你在一个包含完整用户空间的 `chroot` 中运行时，那个用户空间并没有完全初始化。当进入 `chroot` 时，OpenBSD 不会在该
    `chroot` 中进行完整的多用户启动。环境大致相当于单用户模式。`install.site` 脚本不是你初始化数据库的地方。
- en: When you have a real userland ready to go, to automatically run commands on
    the system’s first real boot, append the commands to */etc/rc.firsttime*. This
    file runs once, at the system’s first boot after installation, and then deletes
    itself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有准备好的真实用户空间时，要自动在系统第一次真实启动时运行命令，请将命令追加到 */etc/rc.firsttime* 文件中。此文件在安装后的第一次系统启动时运行一次，然后删除自己。
- en: Customizing Upgrades
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制升级
- en: OpenBSD lets you use custom file sets and shell scripts during binary upgrades.
    If you have a lot of machines to upgrade, run these to ensure that your systems
    are as identical after the upgrade as they were before. I highly recommend automating
    known changes during an upgrade.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 允许你在二进制升级期间使用自定义文件集和 shell 脚本。如果你有很多机器需要升级，运行这些脚本来确保你的系统在升级后与升级前尽可能相同。我强烈建议在升级期间自动化已知的变化。
- en: The *siteXX.tgz* file works for upgrades exactly as for installations. Put the
    files you want on this system in *siteXX.tgz*, and the install program should
    copy those files to the system as it installs the upgraded files. Rather than
    `install.site`, however, the upgrade software looks for the script `upgrade.site`.
    Any *install.site* file is ignored during an upgrade, so you can use the same
    *siteXX.tgz* for upgrades and for new installations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*siteXX.tgz* 文件在升级和安装时工作方式完全相同。将你想要在这个系统上使用的文件放入 *siteXX.tgz* 中，安装程序在安装升级文件时应该会复制这些文件到系统中。然而，与
    `install.site` 不同，升级软件会查找脚本 `upgrade.site`。在升级过程中，任何 *install.site* 文件都会被忽略，因此你可以使用相同的
    *siteXX.tgz* 进行升级和新的安装。'
- en: I find the `upgrade.site` script especially useful in conjunction with the *OpenBSD
    Upgrade Guide* for that release. The *Upgrade Guide* includes tasks that must
    be performed during an upgrade, many of which are very suitable for scripting.
    For example, the common tasks of deleting files, programs, and libraries removed
    from the new OpenBSD release are easily added to `upgrade.site`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现 `upgrade.site` 脚本与该版本的 *OpenBSD Upgrade Guide* 结合使用特别有用。*升级指南* 包含在升级过程中必须执行的任务，其中许多非常适合脚本化。例如，删除新
    OpenBSD 版本中删除的文件、程序和库的常见任务可以轻松添加到 `upgrade.site`。
- en: One convenient thing about `upgrade.site` is that you can copy the script to
    the target machine before running the upgrade. It doesn’t need to be part of *siteXX.tgz*.
    That said, I don’t recommend running `pkg_add -u` in `upgrade.site`. While the
    idea of automatically upgrading all your packages sounds good, remember that you’re
    running on a limited kernel with a less than completely initialized userland.
    Have your `upgrade.site` script add any commands that need to run on a fully multiuser
    system to */etc/rc.firsttime*, so that they run when the system boots the first
    time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `upgrade.site` 的一个方便之处是，在运行升级之前，你可以将脚本复制到目标机器上。它不需要是 *siteXX.tgz* 的一部分。话虽如此，我不建议在
    `upgrade.site` 中运行 `pkg_add -u`。虽然自动升级所有软件包的想法听起来不错，但请记住，你正在运行在一个有限的内核上，用户空间还没有完全初始化。让
    `upgrade.site` 脚本添加任何需要在完全多用户系统上运行的命令到 */etc/rc.firsttime*，这样它们就会在系统第一次启动时运行。
- en: With the hints in this chapter, you can customize OpenBSD any way you need.
    And with the information throughout this book, you should know where OpenBSD fits
    into your network. Remember that they really are out to get you, and you’ll achieve
    practical paranoia.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章中的提示，你可以根据需要自定义 OpenBSD。并且，通过本书中的信息，你应该知道 OpenBSD 在你的网络中是如何定位的。记住，他们确实是在针对你，你将实现实用的偏执。
